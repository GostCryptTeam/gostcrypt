; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	RootDeviceObject
PUBLIC	DriverShuttingDown
PUBLIC	OsMajorVersion
PUBLIC	DriverUnloadDisabled
PUBLIC	PortableMode
PUBLIC	VolumeClassFilterRegistered
PUBLIC	CacheBootPassword
PUBLIC	NonAdminSystemFavoritesAccessDisabled
PUBLIC	??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@HFFKBABD@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BE@NLKDDOJN@?$AAg?$AAo?$AAs?$AAt?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1HM@FBFGPOIK@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@KPILIDPC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@BHENEMCP@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_PsGetVersion:PROC
EXTRN	__imp_IoGetDeviceInterfaces:PROC
EXTRN	GUID_DEVINTERFACE_VOLUME:BYTE
EXTRN	__imp_IoRegisterShutdownNotification:PROC
EXTRN	__imp_KeInitializeSemaphore:PROC
EXTRN	__imp_IoEnumerateDeviceObjectList:PROC
EXTRN	__imp_ObOpenObjectByPointer:PROC
EXTRN	__imp_PsCreateSystemThread:PROC
EXTRN	__imp_SeCreateClientSecurity:PROC
EXTRN	__imp_KeReleaseSemaphore:PROC
EXTRN	__imp_KeInitializeTimerEx:PROC
EXTRN	__imp_KeSetTimerEx:PROC
EXTRN	__imp_wcsncat:PROC
EXTRN	__imp_MmGetSystemRoutineAddress:PROC
EXTRN	__imp_SeTokenType:PROC
EXTRN	__imp_IoGetDeviceObjectPointer:PROC
EXTRN	__imp_ObReferenceObjectByHandle:PROC
EXTRN	__imp_IoBuildSynchronousFsdRequest:PROC
EXTRN	__imp_ObfReferenceObject:PROC
EXTRN	__imp_IoBuildDeviceIoControlRequest:PROC
EXTRN	__imp_IoGetRelatedDeviceObject:PROC
EXTRN	__imp_IoCreateSymbolicLink:PROC
EXTRN	__imp_IoDeleteSymbolicLink:PROC
EXTRN	__imp_RtlLengthSid:PROC
EXTRN	__imp_RtlCopySid:PROC
EXTRN	__imp_ZwQuerySymbolicLinkObject:PROC
EXTRN	__imp_ZwCreateFile:PROC
EXTRN	__imp_ZwOpenSymbolicLinkObject:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_KeQueryActiveProcessors:PROC
EXTRN	__imp_KeDelayExecutionThread:PROC
EXTRN	__imp_ZwQueryValueKey:PROC
EXTRN	__imp_ZwClose:PROC
EXTRN	__imp_ZwOpenKey:PROC
EXTRN	__imp_ZwSetValueKey:PROC
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	__imp_SeCaptureSubjectContext:PROC
EXTRN	__imp_SeReleaseSubjectContext:PROC
EXTRN	__imp_RtlEqualSid:PROC
EXTRN	__imp_SeTokenIsAdmin:PROC
EXTRN	__imp_SeQueryInformationToken:PROC
EXTRN	__imp_KeQueryPerformanceCounter:PROC
COMM	VirtualVolumeDeviceObjects:QWORD:01aH
COMM	LastUniqueVolumeId:DWORD
COMM	OsMinorVersion:DWORD
COMM	SelfTestsPassed:DWORD
COMM	GSTDriverObject:QWORD
RootDeviceObject DQ 01H DUP (?)
DriverShuttingDown DD 01H DUP (?)
OsMajorVersion DD 01H DUP (?)
DriverUnloadDisabled DD 01H DUP (?)
PortableMode DD	01H DUP (?)
VolumeClassFilterRegistered DD 01H DUP (?)
CacheBootPassword DD 01H DUP (?)
NonAdminSystemFavoritesAccessDisabled DD 01H DUP (?)
	ALIGN	8

EncryptionThreadPoolFreeCpuCountLimit DQ 01H DUP (?)
SystemFavoriteVolumeDirty DD 01H DUP (?)
PagingFileCreationPrevented DD 01H DUP (?)
;	COMDAT ??_C@_1EA@BHENEMCP@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@BHENEMCP@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'E', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'y'
	DB	00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'F', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, 'C', 00H, 'p', 00H, 'u', 00H, 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@KPILIDPC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@KPILIDPC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i'
	DB	00H, 'g', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1HM@FBFGPOIK@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1HM@FBFGPOIK@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'S', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'g'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BE@NLKDDOJN@?$AAg?$AAo?$AAs?$AAt?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BE@NLKDDOJN@?$AAg?$AAo?$AAs?$AAt?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB 'g'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ DB 'U'
	DB	00H, 'p', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'C', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '\', 00H, 'C', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, '\', 00H, '{', 00H, '7', 00H
	DB	'1', 00H, 'A', 00H, '2', 00H, '7', 00H, 'C', 00H, 'D', 00H, 'D'
	DB	00H, '-', 00H, '8', 00H, '1', 00H, '2', 00H, 'A', 00H, '-', 00H
	DB	'1', 00H, '1', 00H, 'D', 00H, '0', 00H, '-', 00H, 'B', 00H, 'E'
	DB	00H, 'C', 00H, '7', 00H, '-', 00H, '0', 00H, '8', 00H, '0', 00H
	DB	'0', 00H, '2', 00H, 'B', 00H, 'E', 00H, '2', 00H, '0', 00H, '9'
	DB	00H, '2', 00H, 'F', 00H, '}', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'P'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'M', 00H, 'a', 00H
	DB	'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ DB 'P'
	DB	00H, 's', 00H, 'D', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'I'
	DB	00H, 'm', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'o', 00H
	DB	'n', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'G', 00H, 'o'
	DB	00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@HFFKBABD@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@HFFKBABD@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ DB '\', 00H
	DB	'?', 00H, '?', 00H, '\', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@ DB 'GostCrypt', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@FNODOBFM@ DB 'GostCryptVolume', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'G', 00H, 'o'
	DB	00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ DB 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
PUBLIC	IsOSAtLeast
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
pdata	SEGMENT
$pdata$IsOSAtLeast DD imagerel $LN13
	DD	imagerel $LN13+144
	DD	imagerel $unwind$IsOSAtLeast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsOSAtLeast DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IsOSAtLeast
_TEXT	SEGMENT
reqMinOS$ = 64
IsOSAtLeast PROC					; COMDAT

; 3869 : {

$LN13:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3870 : 	/* When updating this function, update IsOSVersionAtLeast() in Dlgcode.c too. */
; 3871 : 
; 3872 : 	ULONG major = 0, minor = 0;
; 3873 : 
; 3874 : 	ASSERT (OsMajorVersion != 0);
; 3875 : 
; 3876 : 	switch (reqMinOS)

  00004	45 33 c0	 xor	 r8d, r8d
  00007	83 e9 07	 sub	 ecx, 7
  0000a	74 51		 je	 SHORT $LN6@IsOSAtLeas
  0000c	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00010	2b ca		 sub	 ecx, edx
  00012	74 42		 je	 SHORT $LN5@IsOSAtLeas
  00014	83 e9 02	 sub	 ecx, 2
  00017	74 33		 je	 SHORT $LN4@IsOSAtLeas
  00019	2b ca		 sub	 ecx, edx
  0001b	74 28		 je	 SHORT $LN3@IsOSAtLeas
  0001d	83 f9 02	 cmp	 ecx, 2
  00020	74 1c		 je	 SHORT $LN2@IsOSAtLeas

; 3883 : 
; 3884 : 	default:
; 3885 : 		GST_THROW_FATAL_EXCEPTION;

  00022	41 8d 48 29	 lea	 ecx, QWORD PTR [r8+41]
  00026	45 33 c9	 xor	 r9d, r9d
  00029	ba 2d 0f 00 00	 mov	 edx, 3885		; 00000f2dH
  0002e	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0003d	cc		 int	 3
$LN2@IsOSAtLeas:

; 3882 : 	case WIN_7:				major = 6; minor = 1; break;

  0003e	b8 06 00 00 00	 mov	 eax, 6
  00043	eb 20		 jmp	 SHORT $LN7@IsOSAtLeas
$LN3@IsOSAtLeas:

; 3881 : 	case WIN_VISTA:			major = 6; minor = 0; break;

  00045	b8 06 00 00 00	 mov	 eax, 6
  0004a	eb 16		 jmp	 SHORT $LN12@IsOSAtLeas
$LN4@IsOSAtLeas:

; 3880 : 	case WIN_SERVER_2003:	major = 5; minor = 2; break;

  0004c	b8 05 00 00 00	 mov	 eax, 5
  00051	8d 50 fd	 lea	 edx, QWORD PTR [rax-3]
  00054	eb 0f		 jmp	 SHORT $LN7@IsOSAtLeas
$LN5@IsOSAtLeas:

; 3879 : 	case WIN_XP:			major = 5; minor = 1; break;

  00056	b8 05 00 00 00	 mov	 eax, 5
  0005b	eb 08		 jmp	 SHORT $LN7@IsOSAtLeas
$LN6@IsOSAtLeas:

; 3877 : 	{
; 3878 : 	case WIN_2000:			major = 5; minor = 0; break;

  0005d	b8 05 00 00 00	 mov	 eax, 5
$LN12@IsOSAtLeas:
  00062	41 8b d0	 mov	 edx, r8d
$LN7@IsOSAtLeas:

; 3886 : 		break;
; 3887 : 	}
; 3888 : 
; 3889 : 	return ((OsMajorVersion << 16 | OsMinorVersion << 8)
; 3890 : 		>= (major << 16 | minor << 8));

  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR OsMajorVersion
  0006b	c1 e0 08	 shl	 eax, 8
  0006e	0b c2		 or	 eax, edx
  00070	c1 e1 08	 shl	 ecx, 8
  00073	ba ff ff ff 00	 mov	 edx, 16777215		; 00ffffffH
  00078	0b 0d 00 00 00
	00		 or	 ecx, DWORD PTR OsMinorVersion
  0007e	23 c2		 and	 eax, edx
  00080	23 ca		 and	 ecx, edx
  00082	3b c8		 cmp	 ecx, eax
  00084	41 0f 93 c0	 setae	 r8b
  00088	41 8b c0	 mov	 eax, r8d

; 3891 : }

  0008b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008f	c3		 ret	 0
$LN11@IsOSAtLeas:
IsOSAtLeast ENDP
_TEXT	ENDS
PUBLIC	GSTReadRegistryKey
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTReadRegistryKey DD imagerel $LN9
	DD	imagerel $LN9+291
	DD	imagerel $unwind$GSTReadRegistryKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTReadRegistryKey DD 040f01H
	DD	013340fH
	DD	07008f20fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTReadRegistryKey
_TEXT	SEGMENT
regKeyHandle$ = 48
valName$ = 56
size$ = 144
keyPath$ = 144
keyValueName$ = 152
keyData$ = 160
resultSize$ = 168
GSTReadRegistryKey PROC					; COMDAT

; 3473 : {

$LN9:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	57		 push	 rdi
  00008	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 3474 : 	OBJECT_ATTRIBUTES regObjAttribs;
; 3475 : 	HANDLE regKeyHandle;
; 3476 : 	NTSTATUS status;
; 3477 : 	UNICODE_STRING valName;
; 3478 : 	ULONG size = 0;

  0000f	83 60 08 00	 and	 DWORD PTR [rax+8], 0

; 3479 : 	ULONG resultSize;
; 3480 : 
; 3481 : 	InitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00013	48 83 60 c8 00	 and	 QWORD PTR [rax-56], 0
  00018	48 83 60 e0 00	 and	 QWORD PTR [rax-32], 0
  0001d	48 83 60 e8 00	 and	 QWORD PTR [rax-24], 0
  00022	49 8b f8	 mov	 rdi, r8
  00025	48 89 48 d0	 mov	 QWORD PTR [rax-48], rcx
  00029	48 8b da	 mov	 rbx, rdx

; 3482 : 	status = ZwOpenKey (&regKeyHandle, KEY_READ, &regObjAttribs);

  0002c	4c 8d 40 c0	 lea	 r8, QWORD PTR [rax-64]
  00030	48 8d 48 a8	 lea	 rcx, QWORD PTR [rax-88]
  00034	ba 19 00 02 00	 mov	 edx, 131097		; 00020019H
  00039	c7 40 c0 30 00
	00 00		 mov	 DWORD PTR [rax-64], 48	; 00000030H
  00040	c7 40 d8 40 02
	00 00		 mov	 DWORD PTR [rax-40], 576	; 00000240H
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenKey

; 3483 : 	if (!NT_SUCCESS (status))

  0004d	85 c0		 test	 eax, eax

; 3484 : 		return status;

  0004f	0f 88 bd 00 00
	00		 js	 $LN5@GSTReadReg

; 3485 : 
; 3486 : 	RtlInitUnicodeString (&valName, keyValueName);

  00055	48 8d 4c 24 38	 lea	 rcx, QWORD PTR valName$[rsp]
  0005a	48 8b d3	 mov	 rdx, rbx
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3487 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, NULL, 0, &size);

  00063	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  00068	45 33 c9	 xor	 r9d, r9d
  0006b	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR size$[rsp]
  00073	45 8d 41 02	 lea	 r8d, QWORD PTR [r9+2]
  00077	48 8d 54 24 38	 lea	 rdx, QWORD PTR valName$[rsp]
  0007c	4c 89 5c 24 28	 mov	 QWORD PTR [rsp+40], r11
  00081	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryValueKey
  0008c	8b d8		 mov	 ebx, eax

; 3488 : 		
; 3489 : 	if (!NT_SUCCESS (status) && status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL)

  0008e	85 c0		 test	 eax, eax
  00090	79 0e		 jns	 SHORT $LN3@GSTReadReg
  00092	3d 05 00 00 80	 cmp	 eax, -2147483643	; ffffffff80000005H
  00097	74 07		 je	 SHORT $LN3@GSTReadReg
  00099	3d 23 00 00 c0	 cmp	 eax, -1073741789	; ffffffffc0000023H
  0009e	75 65		 jne	 SHORT $LN7@GSTReadReg
$LN3@GSTReadReg:

; 3490 : 	{
; 3491 : 		ZwClose (regKeyHandle);
; 3492 : 		return status;
; 3493 : 	}
; 3494 : 
; 3495 : 	if (size == 0)

  000a0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  000a7	85 c0		 test	 eax, eax
  000a9	75 07		 jne	 SHORT $LN2@GSTReadReg
  000ab	bb 22 00 00 80	 mov	 ebx, -2147483614	; ffffffff80000022H
  000b0	eb 53		 jmp	 SHORT $LN7@GSTReadReg
$LN2@GSTReadReg:

; 3496 : 	{
; 3497 : 		ZwClose (regKeyHandle);
; 3498 : 		return STATUS_NO_DATA_DETECTED;
; 3499 : 	}
; 3500 : 
; 3501 : 	*keyData = (PKEY_VALUE_PARTIAL_INFORMATION) GSTalloc (size);

  000b2	48 8b d0	 mov	 rdx, rax
  000b5	33 c9		 xor	 ecx, ecx
  000b7	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000c3	4c 8b c8	 mov	 r9, rax
  000c6	48 89 07	 mov	 QWORD PTR [rdi], rax

; 3502 : 	if (!*keyData)

  000c9	48 85 c0	 test	 rax, rax
  000cc	75 07		 jne	 SHORT $LN1@GSTReadReg
  000ce	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; ffffffffc000009aH
  000d3	eb 30		 jmp	 SHORT $LN7@GSTReadReg
$LN1@GSTReadReg:

; 3503 : 	{
; 3504 : 		ZwClose (regKeyHandle);
; 3505 : 		return STATUS_INSUFFICIENT_RESOURCES;
; 3506 : 	}
; 3507 : 
; 3508 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, *keyData, size, &resultSize);

  000d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  000da	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR resultSize$[rsp]
  000e2	48 8d 54 24 38	 lea	 rdx, QWORD PTR valName$[rsp]
  000e7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ec	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  000f3	41 b8 02 00 00
	00		 mov	 r8d, 2
  000f9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryValueKey
  00103	8b d8		 mov	 ebx, eax
$LN7@GSTReadReg:
  00105	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
  00110	8b c3		 mov	 eax, ebx
$LN5@GSTReadReg:

; 3509 : 
; 3510 : 	ZwClose (regKeyHandle);
; 3511 : 	return status;
; 3512 : }

  00112	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  0011a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00121	5f		 pop	 rdi
  00122	c3		 ret	 0
GSTReadRegistryKey ENDP
_TEXT	ENDS
PUBLIC	EnsureNullTerminatedString
; Function compile flags: /Ogspy
;	COMDAT EnsureNullTerminatedString
_TEXT	SEGMENT
str$ = 8
maxSizeInBytes$ = 16
EnsureNullTerminatedString PROC				; COMDAT

; 3422 : 	ASSERT ((maxSizeInBytes & 1) == 0);
; 3423 : 	str[maxSizeInBytes / sizeof (wchar_t) - 1] = 0;

  00000	33 c0		 xor	 eax, eax
  00002	66 89 81 06 02
	00 00		 mov	 WORD PTR [rcx+518], ax

; 3424 : }

  00009	c3		 ret	 0
EnsureNullTerminatedString ENDP
_TEXT	ENDS
PUBLIC	GetCpuCount
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetCpuCount DD imagerel $LN10
	DD	imagerel $LN10+54
	DD	imagerel $unwind$GetCpuCount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetCpuCount DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetCpuCount
_TEXT	SEGMENT
GetCpuCount PROC					; COMDAT

; 3391 : {

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3392 : 	KAFFINITY activeCpuMap = KeQueryActiveProcessors();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeQueryActiveProcessors

; 3393 : 	size_t mapSize = sizeof (activeCpuMap) * 8;

  0000a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0000f	4c 8b d8	 mov	 r11, rax

; 3394 : 	size_t cpuCount = 0;

  00012	33 c0		 xor	 eax, eax
  00014	8d 51 c1	 lea	 edx, QWORD PTR [rcx-63]
$LL4@GetCpuCoun:

; 3395 : 
; 3396 : 	while (mapSize--)

  00017	48 2b ca	 sub	 rcx, rdx

; 3397 : 	{
; 3398 : 		if (activeCpuMap & 1)

  0001a	44 84 da	 test	 r11b, dl
  0001d	74 03		 je	 SHORT $LN2@GetCpuCoun

; 3399 : 			++cpuCount;

  0001f	48 03 c2	 add	 rax, rdx
$LN2@GetCpuCoun:

; 3400 : 
; 3401 : 		activeCpuMap >>= 1;

  00022	49 d1 eb	 shr	 r11, 1
  00025	48 85 c9	 test	 rcx, rcx
  00028	75 ed		 jne	 SHORT $LL4@GetCpuCoun

; 3402 : 	}
; 3403 : 
; 3404 : 	if (cpuCount == 0)

  0002a	48 85 c0	 test	 rax, rax
  0002d	48 0f 44 c2	 cmove	 rax, rdx

; 3405 : 		return 1;
; 3406 : 
; 3407 : 	return cpuCount;
; 3408 : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
GetCpuCount ENDP
_TEXT	ENDS
PUBLIC	GSTCompleteDiskIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTCompleteDiskIrp DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$GSTCompleteDiskIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCompleteDiskIrp DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTCompleteDiskIrp
_TEXT	SEGMENT
irp$ = 48
status$ = 56
information$ = 64
GSTCompleteDiskIrp PROC					; COMDAT

; 3375 : {

$LN3:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3376 : 	irp->IoStatus.Status = status;
; 3377 : 	irp->IoStatus.Information = information;
; 3378 : 	IoCompleteRequest (irp, NT_SUCCESS (status) ? IO_DISK_INCREMENT : IO_NO_INCREMENT);

  00006	85 d2		 test	 edx, edx
  00008	8b da		 mov	 ebx, edx
  0000a	89 51 30	 mov	 DWORD PTR [rcx+48], edx
  0000d	0f 99 c2	 setns	 dl
  00010	4c 89 41 38	 mov	 QWORD PTR [rcx+56], r8
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 3379 : 	return status;

  0001a	8b c3		 mov	 eax, ebx

; 3380 : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
GSTCompleteDiskIrp ENDP
_TEXT	ENDS
PUBLIC	GSTCompleteIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTCompleteIrp DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$GSTCompleteIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCompleteIrp DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTCompleteIrp
_TEXT	SEGMENT
irp$ = 48
status$ = 56
information$ = 64
GSTCompleteIrp PROC					; COMDAT

; 3356 : {

$LN3:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b da		 mov	 ebx, edx

; 3357 : 	irp->IoStatus.Status = status;

  00008	89 51 30	 mov	 DWORD PTR [rcx+48], edx

; 3358 : 	irp->IoStatus.Information = information;
; 3359 : 	IoCompleteRequest (irp, IO_NO_INCREMENT);

  0000b	33 d2		 xor	 edx, edx
  0000d	4c 89 41 38	 mov	 QWORD PTR [rcx+56], r8
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 3360 : 	return status;

  00017	8b c3		 mov	 eax, ebx

; 3361 : }

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
GSTCompleteIrp ENDP
_TEXT	ENDS
PUBLIC	IsAccessibleByUser
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsAccessibleByUser DD imagerel $LN4
	DD	imagerel $LN4+144
	DD	imagerel $unwind$IsAccessibleByUser
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsAccessibleByUser DD 020a01H
	DD	015010aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IsAccessibleByUser
_TEXT	SEGMENT
fileHandle$ = 176
objectFileName$ = 176
readOnly$ = 184
IsAccessibleByUser PROC					; COMDAT

; 3268 : {

$LN4:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 3269 : 	OBJECT_ATTRIBUTES fileObjAttributes;
; 3270 : 	IO_STATUS_BLOCK ioStatusBlock;
; 3271 : 	HANDLE fileHandle;
; 3272 : 	NTSTATUS status;
; 3273 : 
; 3274 : 	ASSERT (!IoIsSystemThread (PsGetCurrentThread()));
; 3275 : 
; 3276 : 	InitializeObjectAttributes (&fileObjAttributes, objectFileName, OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE, NULL, NULL);
; 3277 : 	
; 3278 : 	status = ZwCreateFile (&fileHandle,
; 3279 : 		readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
; 3280 : 		&fileObjAttributes,
; 3281 : 		&ioStatusBlock,
; 3282 : 		NULL,
; 3283 : 		FILE_ATTRIBUTE_NORMAL,
; 3284 : 		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
; 3285 : 		FILE_OPEN,
; 3286 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 3287 : 		NULL,
; 3288 : 		0);

  0000a	83 60 a8 00	 and	 DWORD PTR [rax-88], 0
  0000e	48 83 60 a0 00	 and	 QWORD PTR [rax-96], 0
  00013	48 83 60 d0 00	 and	 QWORD PTR [rax-48], 0
  00018	48 83 60 e8 00	 and	 QWORD PTR [rax-24], 0
  0001d	48 83 60 f0 00	 and	 QWORD PTR [rax-16], 0
  00022	c7 40 98 20 00
	00 00		 mov	 DWORD PTR [rax-104], 32	; 00000020H
  00029	c7 40 90 01 00
	00 00		 mov	 DWORD PTR [rax-112], 1
  00030	c7 40 88 07 00
	00 00		 mov	 DWORD PTR [rax-120], 7
  00037	48 89 48 d8	 mov	 QWORD PTR [rax-40], rcx
  0003b	c7 40 80 80 00
	00 00		 mov	 DWORD PTR [rax-128], 128 ; 00000080H
  00042	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00048	4c 8d 48 b8	 lea	 r9, QWORD PTR [rax-72]
  0004c	4c 8d 40 c8	 lea	 r8, QWORD PTR [rax-56]
  00050	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00054	ba 00 00 00 c0	 mov	 edx, -1073741824	; c0000000H
  00059	c7 40 c8 30 00
	00 00		 mov	 DWORD PTR [rax-56], 48	; 00000030H
  00060	c7 40 e0 40 06
	00 00		 mov	 DWORD PTR [rax-32], 1600 ; 00000640H
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile

; 3289 : 
; 3290 : 	if (NT_SUCCESS (status))

  0006d	85 c0		 test	 eax, eax
  0006f	78 15		 js	 SHORT $LN1@IsAccessib

; 3291 : 	{
; 3292 : 		ZwClose (fileHandle);

  00071	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR fileHandle$[rsp]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3293 : 		return TRUE;

  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	eb 02		 jmp	 SHORT $LN2@IsAccessib
$LN1@IsAccessib:

; 3294 : 	}
; 3295 : 
; 3296 : 	return FALSE;

  00086	33 c0		 xor	 eax, eax
$LN2@IsAccessib:

; 3297 : }

  00088	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0008f	c3		 ret	 0
IsAccessibleByUser ENDP
_TEXT	ENDS
PUBLIC	GetIntersection
; Function compile flags: /Ogspy
;	COMDAT GetIntersection
_TEXT	SEGMENT
start1$ = 8
length1$ = 16
start2$ = 24
end2$ = 32
intersectStart$ = 40
intersectLength$ = 48
GetIntersection PROC					; COMDAT

; 3247 : 	uint64 end1 = start1 + length1 - 1;

  00000	8b c2		 mov	 eax, edx
  00002	48 8d 54 08 ff	 lea	 rdx, QWORD PTR [rax+rcx-1]

; 3248 : 	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

  00007	49 3b d1	 cmp	 rdx, r9
  0000a	4c 0f 46 ca	 cmovbe	 r9, rdx

; 3249 : 	
; 3250 : 	*intersectStart = (start1 >= start2) ? start1 : start2;

  0000e	48 8b 54 24 28	 mov	 rdx, QWORD PTR intersectStart$[rsp]
  00013	49 3b c8	 cmp	 rcx, r8
  00016	4c 0f 43 c1	 cmovae	 r8, rcx
  0001a	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 3251 : 	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

  0001d	4d 3b c1	 cmp	 r8, r9
  00020	76 05		 jbe	 SHORT $LN4@GetInterse
  00022	45 33 c9	 xor	 r9d, r9d
  00025	eb 06		 jmp	 SHORT $LN5@GetInterse
$LN4@GetInterse:
  00027	4d 2b c8	 sub	 r9, r8
  0002a	49 ff c1	 inc	 r9
$LN5@GetInterse:
  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR intersectLength$[rsp]
  00032	44 89 08	 mov	 DWORD PTR [rax], r9d

; 3252 : 	
; 3253 : 	if (*intersectLength == 0)

  00035	45 85 c9	 test	 r9d, r9d
  00038	75 03		 jne	 SHORT $LN1@GetInterse

; 3254 : 		*intersectStart = start1;

  0003a	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN1@GetInterse:

; 3255 : }

  0003d	c3		 ret	 0
GetIntersection ENDP
_TEXT	ENDS
PUBLIC	RegionsOverlap
; Function compile flags: /Ogspy
;	COMDAT RegionsOverlap
_TEXT	SEGMENT
start1$ = 8
end1$ = 16
start2$ = 24
end2$ = 32
RegionsOverlap PROC					; COMDAT

; 3228 : 	return (start1 < start2) ? (end1 >= start2) : (start1 <= end2);

  00000	33 c0		 xor	 eax, eax
  00002	49 3b d0	 cmp	 rdx, r8
  00005	44 8b d0	 mov	 r10d, eax
  00008	41 0f 93 c2	 setae	 r10b
  0000c	49 3b c9	 cmp	 rcx, r9
  0000f	0f 96 c0	 setbe	 al
  00012	49 3b c8	 cmp	 rcx, r8
  00015	41 0f 42 c2	 cmovb	 eax, r10d

; 3229 : }

  00019	c3		 ret	 0
RegionsOverlap ENDP
_TEXT	ENDS
PUBLIC	SymbolicLinkToTarget
;	COMDAT pdata
pdata	SEGMENT
$pdata$SymbolicLinkToTarget DD imagerel $LN4
	DD	imagerel $LN4+195
	DD	imagerel $unwind$SymbolicLinkToTarget
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SymbolicLinkToTarget DD 060f01H
	DD	011640fH
	DD	010340fH
	DD	0700bd20fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT SymbolicLinkToTarget
_TEXT	SEGMENT
target$31595 = 32
fullFileName$ = 48
objectAttributes$ = 64
symlinkName$ = 128
targetName$ = 136
maxTargetNameLength$ = 144
handle$ = 152
SymbolicLinkToTarget PROC				; COMDAT

; 3186 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8b fa	 mov	 rdi, rdx

; 3187 : 	NTSTATUS ntStatus;
; 3188 : 	OBJECT_ATTRIBUTES objectAttributes;
; 3189 : 	UNICODE_STRING fullFileName;
; 3190 : 	HANDLE handle;
; 3191 : 
; 3192 : 	RtlInitUnicodeString (&fullFileName, symlinkName);

  00012	48 8b d1	 mov	 rdx, rcx
  00015	48 8d 4c 24 30	 lea	 rcx, QWORD PTR fullFileName$[rsp]
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3193 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00020	33 f6		 xor	 esi, esi
  00022	48 8d 44 24 30	 lea	 rax, QWORD PTR fullFileName$[rsp]

; 3194 : 
; 3195 : 	ntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);

  00027	4c 8d 44 24 40	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  0002c	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR handle$[rsp]
  00034	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00039	48 89 44 24 50	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  0003e	c7 44 24 40 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  00046	48 89 74 24 48	 mov	 QWORD PTR objectAttributes$[rsp+8], rsi
  0004b	c7 44 24 58 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  00053	48 89 74 24 60	 mov	 QWORD PTR objectAttributes$[rsp+32], rsi
  00058	48 89 74 24 68	 mov	 QWORD PTR objectAttributes$[rsp+40], rsi
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenSymbolicLinkObject

; 3196 : 
; 3197 : 	if (NT_SUCCESS (ntStatus))

  00063	3b c6		 cmp	 eax, esi
  00065	8b d8		 mov	 ebx, eax
  00067	7c 46		 jl	 SHORT $LN1@SymbolicLi

; 3198 : 	{
; 3199 : 		UNICODE_STRING target;
; 3200 : 		target.Buffer = targetName;
; 3201 : 		target.Length = 0;
; 3202 : 		target.MaximumLength = maxTargetNameLength;

  00069	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H

; 3203 : 		memset (targetName, 0, maxTargetNameLength);

  0006f	33 d2		 xor	 edx, edx
  00071	48 8b cf	 mov	 rcx, rdi
  00074	48 89 7c 24 28	 mov	 QWORD PTR target$31595[rsp+8], rdi
  00079	66 89 74 24 20	 mov	 WORD PTR target$31595[rsp], si
  0007e	66 44 89 44 24
	22		 mov	 WORD PTR target$31595[rsp+2], r8w
  00084	e8 00 00 00 00	 call	 memset

; 3204 : 
; 3205 : 		ntStatus = ZwQuerySymbolicLinkObject (handle, &target, NULL);

  00089	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR handle$[rsp]
  00091	48 8d 54 24 20	 lea	 rdx, QWORD PTR target$31595[rsp]
  00096	45 33 c0	 xor	 r8d, r8d
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQuerySymbolicLinkObject

; 3206 : 
; 3207 : 		ZwClose (handle);

  0009f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR handle$[rsp]
  000a7	8b d8		 mov	 ebx, eax
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@SymbolicLi:

; 3208 : 	}
; 3209 : 
; 3210 : 	return ntStatus;
; 3211 : }

  000af	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000b4	8b c3		 mov	 eax, ebx
  000b6	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000ba	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000be	49 8b e3	 mov	 rsp, r11
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
SymbolicLinkToTarget ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTReadWriteDevice DD imagerel GSTReadWriteDevice
	DD	imagerel GSTReadWriteDevice+213
	DD	imagerel $unwind$GSTReadWriteDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTReadWriteDevice DD 061401H
	DD	0116414H
	DD	0103414H
	DD	07010d214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTReadWriteDevice
_TEXT	SEGMENT
ioStatusBlock$ = 64
completionEvent$ = 80
write$ = 128
deviceObject$ = 136
buffer$ = 144
offset$ = 152
length$ = 160
GSTReadWriteDevice PROC					; COMDAT

; 2633 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  0000f	57		 push	 rdi
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	8b d9		 mov	 ebx, ecx
  00016	49 8b f8	 mov	 rdi, r8
  00019	48 8b f2	 mov	 rsi, rdx

; 2634 : 	NTSTATUS status;
; 2635 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2636 : 	PIRP irp;
; 2637 : 	KEVENT completionEvent;
; 2638 : 
; 2639 : 	ASSERT (KeGetCurrentIrql() <= APC_LEVEL);
; 2640 : 
; 2641 : 	KeInitializeEvent (&completionEvent, NotificationEvent, FALSE);

  0001c	48 8d 48 d8	 lea	 rcx, QWORD PTR [rax-40]
  00020	45 33 c0	 xor	 r8d, r8d
  00023	33 d2		 xor	 edx, edx
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2642 : 	irp = IoBuildSynchronousFsdRequest (write ? IRP_MJ_WRITE : IRP_MJ_READ, deviceObject, buffer, length, &offset, &completionEvent, &ioStatusBlock);

  0002b	44 8b 8c 24 a0
	00 00 00	 mov	 r9d, DWORD PTR length$[rsp]
  00033	48 8d 44 24 40	 lea	 rax, QWORD PTR ioStatusBlock$[rsp]
  00038	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0003d	48 8d 44 24 50	 lea	 rax, QWORD PTR completionEvent$[rsp]
  00042	f7 db		 neg	 ebx
  00044	1b c9		 sbb	 ecx, ecx
  00046	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004b	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR offset$[rsp]
  00053	f7 d9		 neg	 ecx
  00055	4c 8b c7	 mov	 r8, rdi
  00058	48 8b d6	 mov	 rdx, rsi
  0005b	83 c1 03	 add	 ecx, 3
  0005e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildSynchronousFsdRequest
  00069	48 8b d8	 mov	 rbx, rax

; 2643 : 	if (!irp)

  0006c	48 85 c0	 test	 rax, rax
  0006f	75 07		 jne	 SHORT $LN3@GSTReadWri

; 2644 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00071	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00076	eb 4b		 jmp	 SHORT $LN4@GSTReadWri
$LN3@GSTReadWri:

; 2645 : 
; 2646 : 	ObReferenceObject (deviceObject);

  00078	48 8b ce	 mov	 rcx, rsi
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfReferenceObject

; 2647 : 	status = IoCallDriver (deviceObject, irp);

  00081	48 8b d3	 mov	 rdx, rbx
  00084	48 8b ce	 mov	 rcx, rsi
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  0008d	8b d8		 mov	 ebx, eax

; 2648 : 
; 2649 : 	if (status == STATUS_PENDING)

  0008f	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  00094	75 22		 jne	 SHORT $LN1@GSTReadWri

; 2650 : 	{
; 2651 : 		status = KeWaitForSingleObject (&completionEvent, Executive, KernelMode, FALSE, NULL);

  00096	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0009c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR completionEvent$[rsp]
  000a1	45 33 c9	 xor	 r9d, r9d
  000a4	45 33 c0	 xor	 r8d, r8d
  000a7	33 d2		 xor	 edx, edx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  000af	8b d8		 mov	 ebx, eax

; 2652 : 		if (NT_SUCCESS (status))

  000b1	85 c0		 test	 eax, eax
  000b3	0f 49 5c 24 40	 cmovns	 ebx, DWORD PTR ioStatusBlock$[rsp]
$LN1@GSTReadWri:

; 2653 : 			status = ioStatusBlock.Status;
; 2654 : 	}
; 2655 : 
; 2656 : 	ObDereferenceObject (deviceObject);

  000b8	48 8b ce	 mov	 rcx, rsi
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2657 : 	return status;

  000c1	8b c3		 mov	 eax, ebx
$LN4@GSTReadWri:

; 2658 : }

  000c3	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000c8	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000cc	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000d0	49 8b e3	 mov	 rsp, r11
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
GSTReadWriteDevice ENDP
_TEXT	ENDS
PUBLIC	GSTCloseFsVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTCloseFsVolume DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$GSTCloseFsVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCloseFsVolume DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTCloseFsVolume
_TEXT	SEGMENT
volumeHandle$ = 48
fileObject$ = 56
GSTCloseFsVolume PROC					; COMDAT

; 2614 : {

$LN3:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2615 : 	ObDereferenceObject (fileObject);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2616 : 	ZwClose (volumeHandle);

  00012	48 8b cb	 mov	 rcx, rbx

; 2617 : }

  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5b		 pop	 rbx
  0001a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_ZwClose
GSTCloseFsVolume ENDP
_TEXT	ENDS
PUBLIC	SendDeviceIoControlRequest
;	COMDAT pdata
pdata	SEGMENT
$pdata$SendDeviceIoControlRequestWorkItemRoutine DD imagerel SendDeviceIoControlRequestWorkItemRoutine
	DD	imagerel SendDeviceIoControlRequestWorkItemRoutine+68
	DD	imagerel $unwind$SendDeviceIoControlRequestWorkItemRoutine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SendDeviceIoControlRequestWorkItemRoutine DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT SendDeviceIoControlRequestWorkItemRoutine
_TEXT	SEGMENT
rootDeviceObject$ = 64
arg$ = 72
SendDeviceIoControlRequestWorkItemRoutine PROC		; COMDAT

; 2418 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2419 : 	arg->Status = SendDeviceIoControlRequest (arg->deviceObject, arg->ioControlCode, arg->inputBuffer, arg->inputBufferSize, arg->outputBuffer, arg->outputBufferSize);

  00006	8b 42 28	 mov	 eax, DWORD PTR [rdx+40]
  00009	44 8b 4a 18	 mov	 r9d, DWORD PTR [rdx+24]
  0000d	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]
  00011	48 8b da	 mov	 rbx, rdx
  00014	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00018	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  0001c	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  0001f	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00022	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00027	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 2420 : 	KeSetEvent (&arg->WorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);

  0002c	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
  00030	45 33 c0	 xor	 r8d, r8d
  00033	33 d2		 xor	 edx, edx
  00035	89 43 2c	 mov	 DWORD PTR [rbx+44], eax

; 2421 : }

  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5b		 pop	 rbx
  0003d	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeSetEvent
SendDeviceIoControlRequestWorkItemRoutine ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	GSTGetDosNameFromNumber
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTGetDosNameFromNumber DD imagerel $LN6
	DD	imagerel $LN6+133
	DD	imagerel $unwind$GSTGetDosNameFromNumber
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTGetDosNameFromNumber DD 021519H
	DD	070021206H
	DD	imagerel __GSHandlerCheck
	DD	08H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTGetDosNameFromNumber
_TEXT	SEGMENT
tmp$ = 0
__$ArrayPad$ = 8
dosname$ = 32
nDriveNo$ = 40
GSTGetDosNameFromNumber PROC				; COMDAT

; 2049 : {

$LN6:
  00000	40 57		 push	 rdi
  00002	48 83 ec 10	 sub	 rsp, 16
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 08	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2050 : 	WCHAR tmp[3] =
; 2051 : 	{0, ':', 0};
; 2052 : 	int j = nDriveNo + (WCHAR) 'A';

  00015	66 83 c2 41	 add	 dx, 65			; 00000041H
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	45 33 c0	 xor	 r8d, r8d

; 2053 : 
; 2054 : 	tmp[0] = (short) j;

  0001f	66 89 14 24	 mov	 WORD PTR tmp$[rsp], dx

; 2055 : 	wcscpy (dosname, (LPWSTR) DOS_MOUNT_PREFIX);

  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
  0002a	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH
  0002f	48 8b d7	 mov	 rdx, rdi
  00032	66 44 89 44 24
	04		 mov	 WORD PTR tmp$[rsp+4], r8w
  00038	66 89 44 24 02	 mov	 WORD PTR tmp$[rsp+2], ax
  0003d	48 2b d1	 sub	 rdx, rcx
$LL3@GSTGetDosN:
  00040	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00043	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00047	48 83 c1 02	 add	 rcx, 2
  0004b	66 41 3b c0	 cmp	 ax, r8w
  0004f	75 ef		 jne	 SHORT $LL3@GSTGetDosN

; 2056 : 	wcscat (dosname, tmp);

  00051	33 c0		 xor	 eax, eax
  00053	48 83 c9 ff	 or	 rcx, -1
  00057	48 8d 14 24	 lea	 rdx, QWORD PTR tmp$[rsp]
  0005b	66 f2 af	 repne scasw
  0005e	33 c9		 xor	 ecx, ecx
$LL5@GSTGetDosN:
  00060	0f b7 04 0a	 movzx	 eax, WORD PTR [rdx+rcx]
  00064	48 83 c1 02	 add	 rcx, 2
  00068	66 89 44 0f fc	 mov	 WORD PTR [rdi+rcx-4], ax
  0006d	66 85 c0	 test	 ax, ax
  00070	75 ee		 jne	 SHORT $LL5@GSTGetDosN

; 2057 : }

  00072	48 8b 4c 24 08	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00077	48 33 cc	 xor	 rcx, rsp
  0007a	e8 00 00 00 00	 call	 __security_check_cookie
  0007f	48 83 c4 10	 add	 rsp, 16
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
GSTGetDosNameFromNumber ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	GSTGetNTNameFromNumber
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTGetNTNameFromNumber DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$GSTGetNTNameFromNumber
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTGetNTNameFromNumber DD 011319H
	DD	06204H
	DD	imagerel __GSHandlerCheck
	DD	028H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTGetNTNameFromNumber
_TEXT	SEGMENT
tmp$ = 32
__$ArrayPad$ = 40
ntname$ = 64
nDriveNo$ = 72
GSTGetNTNameFromNumber PROC				; COMDAT

; 2029 : {

$LN5:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2030 : 	WCHAR tmp[3] =
; 2031 : 	{0, ':', 0};
; 2032 : 	int j = nDriveNo + (WCHAR) 'A';

  00013	66 83 c2 41	 add	 dx, 65			; 00000041H
  00017	45 33 c9	 xor	 r9d, r9d
  0001a	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH

; 2033 : 
; 2034 : 	tmp[0] = (short) j;

  0001f	66 89 54 24 20	 mov	 WORD PTR tmp$[rsp], dx

; 2035 : 	wcscpy (ntname, (LPWSTR) NT_MOUNT_PREFIX);

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@HFFKBABD@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
  0002b	4c 8b c1	 mov	 r8, rcx
  0002e	66 89 44 24 22	 mov	 WORD PTR tmp$[rsp+2], ax
  00033	66 44 89 4c 24
	24		 mov	 WORD PTR tmp$[rsp+4], r9w
  00039	4c 2b c2	 sub	 r8, rdx
$LL3@GSTGetNTNa:
  0003c	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  0003f	66 41 89 04 10	 mov	 WORD PTR [r8+rdx], ax
  00044	48 83 c2 02	 add	 rdx, 2
  00048	66 41 3b c1	 cmp	 ax, r9w
  0004c	75 ee		 jne	 SHORT $LL3@GSTGetNTNa

; 2036 : 	wcsncat (ntname, tmp, 1);

  0004e	48 8d 54 24 20	 lea	 rdx, QWORD PTR tmp$[rsp]
  00053	41 b8 01 00 00
	00		 mov	 r8d, 1
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 2037 : }

  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00064	48 33 cc	 xor	 rcx, rsp
  00067	e8 00 00 00 00	 call	 __security_check_cookie
  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
GSTGetNTNameFromNumber ENDP
_TEXT	ENDS
PUBLIC	GSTSleep
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTSleep DD imagerel $LN4
	DD	imagerel $LN4+124
	DD	imagerel $unwind$GSTSleep
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTSleep DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTSleep
_TEXT	SEGMENT
milliSeconds$ = 64
GSTSleep PROC						; COMDAT

; 1887 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 63 d9	 movsxd	 rbx, ecx

; 1888 : 	PKTIMER timer = (PKTIMER) GSTalloc (sizeof (KTIMER));

  0000d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00012	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00018	33 c9		 xor	 ecx, ecx
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00020	48 8b f8	 mov	 rdi, rax

; 1889 : 	LARGE_INTEGER duetime;
; 1890 : 
; 1891 : 	if (!timer)

  00023	48 85 c0	 test	 rax, rax
  00026	74 49		 je	 SHORT $LN2@GSTSleep

; 1892 : 		return;
; 1893 : 
; 1894 : 	duetime.QuadPart = (__int64) milliSeconds * -10000;
; 1895 : 	KeInitializeTimerEx(timer, NotificationTimer);

  00028	33 d2		 xor	 edx, edx
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	48 69 db f0 d8
	ff ff		 imul	 rbx, -10000		; ffffffffffffd8f0H
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeTimerEx

; 1896 : 	KeSetTimerEx(timer, duetime, 0, NULL);

  0003a	45 33 c9	 xor	 r9d, r9d
  0003d	45 33 c0	 xor	 r8d, r8d
  00040	48 8b d3	 mov	 rdx, rbx
  00043	48 8b cf	 mov	 rcx, rdi
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetTimerEx

; 1897 : 
; 1898 : 	KeWaitForSingleObject (timer, Executive, KernelMode, FALSE, NULL);

  0004c	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00052	45 33 c9	 xor	 r9d, r9d
  00055	45 33 c0	 xor	 r8d, r8d
  00058	33 d2		 xor	 edx, edx
  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1899 : 
; 1900 : 	GSTfree (timer);

  00063	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00068	48 8b cf	 mov	 rcx, rdi
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@GSTSleep:

; 1901 : }

  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
GSTSleep ENDP
_TEXT	ENDS
PUBLIC	GSTStopVolumeThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTStopVolumeThread DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$GSTStopVolumeThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTStopVolumeThread DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTStopVolumeThread
_TEXT	SEGMENT
DeviceObject$ = 64
Extension$ = 72
GSTStopVolumeThread PROC				; COMDAT

; 1848 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1849 : 	NTSTATUS ntStatus;
; 1850 : 
; 1851 : 	if (DeviceObject);	/* Remove compiler warning */
; 1852 : 
; 1853 : 	Dump ("Signalling thread to quit...\n");
; 1854 : 
; 1855 : 	Extension->bThreadShouldQuit = TRUE;

  00006	41 b8 01 00 00
	00		 mov	 r8d, 1

; 1856 : 
; 1857 : 	KeReleaseSemaphore (&Extension->RequestSemaphore,
; 1858 : 			    0,
; 1859 : 			    1,
; 1860 : 			    TRUE);

  0000c	48 8d 4a 58	 lea	 rcx, QWORD PTR [rdx+88]
  00010	48 8b da	 mov	 rbx, rdx
  00013	44 89 42 1c	 mov	 DWORD PTR [rdx+28], r8d
  00017	33 d2		 xor	 edx, edx
  00019	45 8a c8	 mov	 r9b, r8b
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSemaphore

; 1861 : 
; 1862 : 	ntStatus = KeWaitForSingleObject (Extension->peThread,
; 1863 : 					  Executive,
; 1864 : 					  KernelMode,
; 1865 : 					  FALSE,
; 1866 : 					  NULL);

  00022	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00026	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0002c	45 33 c9	 xor	 r9d, r9d
  0002f	45 33 c0	 xor	 r8d, r8d
  00032	33 d2		 xor	 edx, edx
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1867 : 
; 1868 : 	ASSERT (NT_SUCCESS (ntStatus));
; 1869 : 
; 1870 : 	ObDereferenceObject (Extension->peThread);

  0003a	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 1871 : 	Extension->peThread = NULL;

  00044	48 83 63 20 00	 and	 QWORD PTR [rbx+32], 0

; 1872 : 
; 1873 : 	Dump ("Thread exited\n");
; 1874 : }

  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
GSTStopVolumeThread ENDP
_TEXT	ENDS
PUBLIC	GSTStopThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTStopThread DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$GSTStopThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTStopThread DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTStopThread
_TEXT	SEGMENT
kThread$ = 64
wakeUpEvent$ = 72
GSTStopThread PROC					; COMDAT

; 1742 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 1743 : 	if (wakeUpEvent)

  0000c	48 85 d2	 test	 rdx, rdx
  0000f	74 0e		 je	 SHORT $LN1@GSTStopThr

; 1744 : 		KeSetEvent (wakeUpEvent, 0, FALSE);

  00011	45 33 c0	 xor	 r8d, r8d
  00014	33 d2		 xor	 edx, edx
  00016	48 8b c8	 mov	 rcx, rax
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN1@GSTStopThr:

; 1745 : 
; 1746 : 	KeWaitForSingleObject (kThread, Executive, KernelMode, FALSE, NULL);

  0001f	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00025	45 33 c9	 xor	 r9d, r9d
  00028	45 33 c0	 xor	 r8d, r8d
  0002b	33 d2		 xor	 edx, edx
  0002d	48 8b cb	 mov	 rcx, rbx
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1747 : 	ObDereferenceObject (kThread);

  00036	48 8b cb	 mov	 rcx, rbx

; 1748 : }

  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	5b		 pop	 rbx
  0003e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_ObfDereferenceObject
GSTStopThread ENDP
_TEXT	ENDS
PUBLIC	GSTStartThreadInProcess
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTStartThreadInProcess DD imagerel $LN8
	DD	imagerel $LN8+212
	DD	imagerel $unwind$GSTStartThreadInProcess
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTStartThreadInProcess DD 041301H
	DD	0123413H
	DD	0700cf213H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTStartThreadInProcess
_TEXT	SEGMENT
processHandle$ = 64
threadProc$ = 144
threadArg$ = 152
kThread$ = 160
threadHandle$ = 168
process$ = 168
GSTStartThreadInProcess PROC				; COMDAT

; 1697 : {

$LN8:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  0000b	57		 push	 rdi
  0000c	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1698 : 	NTSTATUS status;
; 1699 : 	HANDLE threadHandle;
; 1700 : 	HANDLE processHandle = NULL;

  00013	48 83 60 b8 00	 and	 QWORD PTR [rax-72], 0

; 1701 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1702 : 
; 1703 : 	if (process)
; 1704 : 	{
; 1705 : 		status = ObOpenObjectByPointer (process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &processHandle);
; 1706 : 		if (!NT_SUCCESS (status))
; 1707 : 			return status;
; 1708 : 	}
; 1709 : 
; 1710 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  00018	48 83 60 c8 00	 and	 QWORD PTR [rax-56], 0
  0001d	48 83 60 d0 00	 and	 QWORD PTR [rax-48], 0
  00022	48 83 60 e0 00	 and	 QWORD PTR [rax-32], 0
  00027	48 83 60 e8 00	 and	 QWORD PTR [rax-24], 0

; 1711 : 	
; 1712 : 	status = PsCreateSystemThread (&threadHandle, THREAD_ALL_ACCESS, &threadObjAttributes, processHandle, NULL, threadProc, threadArg);

  0002c	48 89 50 a8	 mov	 QWORD PTR [rax-88], rdx
  00030	48 89 48 a0	 mov	 QWORD PTR [rax-96], rcx
  00034	48 83 60 98 00	 and	 QWORD PTR [rax-104], 0
  00039	49 8b f8	 mov	 rdi, r8
  0003c	bb ff 03 1f 00	 mov	 ebx, 2032639		; 001f03ffH
  00041	48 8d 48 20	 lea	 rcx, QWORD PTR [rax+32]
  00045	4c 8d 40 c0	 lea	 r8, QWORD PTR [rax-64]
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	8b d3		 mov	 edx, ebx
  0004e	c7 40 c0 30 00
	00 00		 mov	 DWORD PTR [rax-64], 48	; 00000030H
  00055	c7 40 d8 00 02
	00 00		 mov	 DWORD PTR [rax-40], 512	; 00000200H
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread

; 1713 : 	if (!NT_SUCCESS (status))

  00062	85 c0		 test	 eax, eax

; 1714 : 		return status;

  00064	78 5d		 js	 SHORT $LN6@GSTStartTh

; 1715 : 
; 1716 : 	status = ObReferenceObjectByHandle (threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *) kThread, NULL);

  00066	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  0006e	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  00074	45 33 c9	 xor	 r9d, r9d
  00077	45 33 c0	 xor	 r8d, r8d
  0007a	8b d3		 mov	 edx, ebx
  0007c	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  00087	8b d8		 mov	 ebx, eax

; 1717 : 	if (!NT_SUCCESS (status))

  00089	85 c0		 test	 eax, eax
  0008b	79 16		 jns	 SHORT $LN2@GSTStartTh

; 1718 : 	{
; 1719 : 		ZwClose (threadHandle);

  0008d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1720 : 		*kThread = NULL;

  0009b	48 83 27 00	 and	 QWORD PTR [rdi], 0

; 1721 : 		return status;

  0009f	8b c3		 mov	 eax, ebx
  000a1	eb 20		 jmp	 SHORT $LN6@GSTStartTh
$LN2@GSTStartTh:

; 1722 : 	}
; 1723 : 
; 1724 : 	if (processHandle)

  000a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR processHandle$[rsp]
  000a8	48 85 c9	 test	 rcx, rcx
  000ab	74 06		 je	 SHORT $LN1@GSTStartTh

; 1725 : 		ZwClose (processHandle);

  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@GSTStartTh:

; 1726 : 
; 1727 : 	ZwClose (threadHandle);

  000b3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1728 : 	return STATUS_SUCCESS;

  000c1	33 c0		 xor	 eax, eax
$LN6@GSTStartTh:

; 1729 : }

  000c3	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  000cb	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
GSTStartThreadInProcess ENDP
_TEXT	ENDS
PUBLIC	GSTStartThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTStartThread DD imagerel $LN10
	DD	imagerel $LN10+211
	DD	imagerel $unwind$GSTStartThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTStartThread DD 040f01H
	DD	012340fH
	DD	07008f20fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTStartThread
_TEXT	SEGMENT
processHandle$35690 = 64
threadProc$ = 144
threadArg$ = 152
kThread$ = 160
threadHandle$35689 = 168
GSTStartThread PROC					; COMDAT

; 1680 : {

$LN10:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	57		 push	 rdi
  00008	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1681 : 	return GSTStartThreadInProcess (threadProc, threadArg, kThread, NULL);

  0000f	48 83 60 b8 00	 and	 QWORD PTR [rax-72], 0
  00014	48 83 60 c8 00	 and	 QWORD PTR [rax-56], 0
  00019	48 83 60 d0 00	 and	 QWORD PTR [rax-48], 0
  0001e	48 83 60 e0 00	 and	 QWORD PTR [rax-32], 0
  00023	48 83 60 e8 00	 and	 QWORD PTR [rax-24], 0
  00028	48 89 50 a8	 mov	 QWORD PTR [rax-88], rdx
  0002c	48 89 48 a0	 mov	 QWORD PTR [rax-96], rcx
  00030	48 83 60 98 00	 and	 QWORD PTR [rax-104], 0
  00035	49 8b f8	 mov	 rdi, r8
  00038	48 8d 48 20	 lea	 rcx, QWORD PTR [rax+32]
  0003c	4c 8d 40 c0	 lea	 r8, QWORD PTR [rax-64]
  00040	45 33 c9	 xor	 r9d, r9d
  00043	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  00048	c7 40 c0 30 00
	00 00		 mov	 DWORD PTR [rax-64], 48	; 00000030H
  0004f	c7 40 d8 00 02
	00 00		 mov	 DWORD PTR [rax-40], 512	; 00000200H
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread
  0005c	8b d8		 mov	 ebx, eax
  0005e	85 c0		 test	 eax, eax
  00060	78 5e		 js	 SHORT $LN8@GSTStartTh@2
  00062	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$35689[rsp]
  0006a	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  00070	45 33 c9	 xor	 r9d, r9d
  00073	45 33 c0	 xor	 r8d, r8d
  00076	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  0007b	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  00086	8b d8		 mov	 ebx, eax
  00088	85 c0		 test	 eax, eax
  0008a	79 14		 jns	 SHORT $LN4@GSTStartTh@2
  0008c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$35689[rsp]
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
  0009a	48 83 27 00	 and	 QWORD PTR [rdi], 0
  0009e	eb 20		 jmp	 SHORT $LN8@GSTStartTh@2
$LN4@GSTStartTh@2:
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR processHandle$35690[rsp]
  000a5	48 85 c9	 test	 rcx, rcx
  000a8	74 06		 je	 SHORT $LN3@GSTStartTh@2
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN3@GSTStartTh@2:
  000b0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$35689[rsp]
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
  000be	33 db		 xor	 ebx, ebx
$LN8@GSTStartTh@2:
  000c0	8b c3		 mov	 eax, ebx

; 1682 : }

  000c2	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  000ca	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000d1	5f		 pop	 rdi
  000d2	c3		 ret	 0
GSTStartThread ENDP
_TEXT	ENDS
PUBLIC	RootDeviceControlMutexRelease
RootDeviceControlMutex DB 038H DUP (?)
; Function compile flags: /Ogspy
;	COMDAT RootDeviceControlMutexRelease
_TEXT	SEGMENT
RootDeviceControlMutexRelease PROC			; COMDAT

; 576  : 	KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00007	33 d2		 xor	 edx, edx

; 577  : }

  00009	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeReleaseMutex
RootDeviceControlMutexRelease ENDP
_TEXT	ENDS
PUBLIC	RootDeviceControlMutexAcquireNoWait
;	COMDAT pdata
pdata	SEGMENT
$pdata$RootDeviceControlMutexAcquireNoWait DD imagerel $LN5
	DD	imagerel $LN5+68
	DD	imagerel $unwind$RootDeviceControlMutexAcquireNoWait
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RootDeviceControlMutexAcquireNoWait DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RootDeviceControlMutexAcquireNoWait
_TEXT	SEGMENT
timeout$ = 64
RootDeviceControlMutexAcquireNoWait PROC		; COMDAT

; 557  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 558  : 	NTSTATUS status;
; 559  : 	LARGE_INTEGER timeout;
; 560  : 	timeout.QuadPart = 0;
; 561  : 
; 562  : 	status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, &timeout);

  00006	48 8d 44 24 40	 lea	 rax, QWORD PTR timeout$[rsp]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00012	33 db		 xor	 ebx, ebx
  00014	45 33 c9	 xor	 r9d, r9d
  00017	45 33 c0	 xor	 r8d, r8d
  0001a	33 d2		 xor	 edx, edx
  0001c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00021	48 89 5c 24 40	 mov	 QWORD PTR timeout$[rsp], rbx
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 563  : 	return NT_SUCCESS (status) && status != STATUS_TIMEOUT;

  0002c	3b c3		 cmp	 eax, ebx
  0002e	7c 0c		 jl	 SHORT $LN4@RootDevice
  00030	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  00035	74 05		 je	 SHORT $LN4@RootDevice
  00037	bb 01 00 00 00	 mov	 ebx, 1
$LN4@RootDevice:
  0003c	8b c3		 mov	 eax, ebx

; 564  : }

  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
RootDeviceControlMutexAcquireNoWait ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	GSTCreateRootDeviceObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTCreateRootDeviceObject DD imagerel $LN9
	DD	imagerel $LN9+323
	DD	imagerel $unwind$GSTCreateRootDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCreateRootDeviceObject DD 051f19H
	DD	023340dH
	DD	020010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTCreateRootDeviceObject
INIT	SEGMENT
DeviceObject$ = 64
ntUnicodeString$ = 72
Win32NameString$ = 88
ntname$ = 112
dosname$ = 176
__$ArrayPad$ = 240
DriverObject$ = 272
GSTCreateRootDeviceObject PROC				; COMDAT

; 425  : {

$LN9:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 426  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 427  : 	WCHAR dosname[32], ntname[32];
; 428  : 	PDEVICE_OBJECT DeviceObject;
; 429  : 	NTSTATUS ntStatus;
; 430  : 	BOOL *bRootExtension;
; 431  : 
; 432  : 	Dump ("GSTCreateRootDeviceObject BEGIN\n");
; 433  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
; 434  : 
; 435  : 	wcscpy (dosname, (LPWSTR) DOS_ROOT_PREFIX);

  0001f	33 ff		 xor	 edi, edi
  00021	48 8b d9	 mov	 rbx, rcx
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0002b	48 8b cf	 mov	 rcx, rdi
$LL5@GSTCreateR:
  0002e	0f b7 84 11 00
	00 00 00	 movzx	 eax, WORD PTR ??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@[rcx+rdx]
  00036	48 83 c1 02	 add	 rcx, 2
  0003a	66 89 84 0c ae
	00 00 00	 mov	 WORD PTR dosname$[rsp+rcx-2], ax
  00042	66 3b c7	 cmp	 ax, di
  00045	75 e7		 jne	 SHORT $LL5@GSTCreateR

; 436  : 	wcscpy (ntname, (LPWSTR) NT_ROOT_PREFIX);

  00047	48 8b cf	 mov	 rcx, rdi
$LL6@GSTCreateR:
  0004a	0f b7 84 11 00
	00 00 00	 movzx	 eax, WORD PTR ??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@[rcx+rdx]
  00052	48 83 c1 02	 add	 rcx, 2
  00056	66 89 44 0c 6e	 mov	 WORD PTR ntname$[rsp+rcx-2], ax
  0005b	66 3b c7	 cmp	 ax, di
  0005e	75 ea		 jne	 SHORT $LL6@GSTCreateR

; 437  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  00060	48 8d 54 24 70	 lea	 rdx, QWORD PTR ntname$[rsp]
  00065	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ntUnicodeString$[rsp]
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 438  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  00070	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR dosname$[rsp]
  00078	48 8d 4c 24 58	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 439  : 
; 440  : 	Dump ("Creating root device nt=%ls dos=%ls\n", ntname, dosname);
; 441  : 	
; 442  : 	ntStatus = IoCreateDevice (
; 443  : 					  DriverObject,
; 444  : 					  sizeof (BOOL),
; 445  : 					  &ntUnicodeString,
; 446  : 					  FILE_DEVICE_UNKNOWN,
; 447  : 					  FILE_DEVICE_SECURE_OPEN,
; 448  : 					  FALSE,
; 449  : 					  &DeviceObject);

  00083	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  00089	4c 8d 5c 24 40	 lea	 r11, QWORD PTR DeviceObject$[rsp]
  0008e	4c 89 5c 24 30	 mov	 QWORD PTR [rsp+48], r11
  00093	4c 8d 44 24 48	 lea	 r8, QWORD PTR ntUnicodeString$[rsp]
  00098	41 8d 51 e2	 lea	 edx, QWORD PTR [r9-30]
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	40 88 7c 24 28	 mov	 BYTE PTR [rsp+40], dil
  000a4	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 450  : 
; 451  : 	if (!NT_SUCCESS (ntStatus))

  000b2	3b c7		 cmp	 eax, edi

; 452  : 	{
; 453  : 		Dump ("GSTCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 454  : 		return ntStatus;/* Failed to create DeviceObject */

  000b4	7c 6c		 jl	 SHORT $LN3@GSTCreateR

; 455  : 	}
; 456  : 
; 457  : 	DeviceObject->Flags |= DO_DIRECT_IO;

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$[rsp]

; 458  : 	DeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

  000bb	ba 01 00 00 00	 mov	 edx, 1
  000c0	83 48 30 10	 or	 DWORD PTR [rax+48], 16
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  000c9	89 90 98 00 00
	00		 mov	 DWORD PTR [rax+152], edx

; 459  : 
; 460  : 	/* Setup the device extension */
; 461  : 	bRootExtension = (BOOL *) DeviceObject->DeviceExtension;

  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  000d4	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]

; 462  : 	*bRootExtension = TRUE;

  000d8	89 11		 mov	 DWORD PTR [rcx], edx

; 463  : 
; 464  : 	KeInitializeMutex (&RootDeviceControlMutex, 0);

  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  000e1	33 d2		 xor	 edx, edx
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeMutex

; 465  : 
; 466  : 	ntStatus = IoCreateSymbolicLink (&Win32NameString, &ntUnicodeString);

  000e9	48 8d 54 24 48	 lea	 rdx, QWORD PTR ntUnicodeString$[rsp]
  000ee	48 8d 4c 24 58	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink

; 467  : 
; 468  : 	if (!NT_SUCCESS (ntStatus))
; 469  : 	{
; 470  : 		Dump ("GSTCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 471  : 		IoDeleteDevice (DeviceObject);

  000f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  000fe	3b c7		 cmp	 eax, edi
  00100	8b d8		 mov	 ebx, eax
  00102	7d 0a		 jge	 SHORT $LN1@GSTCreateR
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 472  : 		return ntStatus;

  0010a	8b c3		 mov	 eax, ebx
  0010c	eb 14		 jmp	 SHORT $LN3@GSTCreateR
$LN1@GSTCreateR:

; 473  : 	}
; 474  : 
; 475  : 	IoRegisterShutdownNotification (DeviceObject);

  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoRegisterShutdownNotification

; 476  : 	RootDeviceObject = DeviceObject;

  00114	4c 8b 5c 24 40	 mov	 r11, QWORD PTR DeviceObject$[rsp]

; 477  : 
; 478  : 	Dump ("GSTCreateRootDeviceObject STATUS_SUCCESS END\n");
; 479  : 	return STATUS_SUCCESS;

  00119	33 c0		 xor	 eax, eax
  0011b	4c 89 1d 00 00
	00 00		 mov	 QWORD PTR RootDeviceObject, r11
$LN3@GSTCreateR:

; 480  : }

  00122	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012a	48 33 cc	 xor	 rcx, rsp
  0012d	e8 00 00 00 00	 call	 __security_check_cookie
  00132	48 8b 9c 24 18
	01 00 00	 mov	 rbx, QWORD PTR [rsp+280]
  0013a	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  00141	5f		 pop	 rdi
  00142	c3		 ret	 0
GSTCreateRootDeviceObject ENDP
INIT	ENDS
PUBLIC	GetVirtualVolumeDeviceObject
; Function compile flags: /Ogspy
;	COMDAT GetVirtualVolumeDeviceObject
_TEXT	SEGMENT
driveNumber$ = 8
GetVirtualVolumeDeviceObject PROC			; COMDAT

; 246  : 	if (driveNumber < MIN_MOUNTED_VOLUME_DRIVE_NUMBER || driveNumber > MAX_MOUNTED_VOLUME_DRIVE_NUMBER)

  00000	83 f9 19	 cmp	 ecx, 25
  00003	77 0f		 ja	 SHORT $LN1@GetVirtual

; 248  : 
; 249  : 	return VirtualVolumeDeviceObjects[driveNumber];

  00005	48 63 c1	 movsxd	 rax, ecx
  00008	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VirtualVolumeDeviceObjects
  0000f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 250  : }

  00013	c3		 ret	 0
$LN1@GetVirtual:

; 247  : 		return NULL;

  00014	33 c0		 xor	 eax, eax

; 250  : }

  00016	c3		 ret	 0
GetVirtualVolumeDeviceObject ENDP
PUBLIC	ReadRegistryConfigFlags
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
pdata	SEGMENT
$pdata$ReadRegistryConfigFlags DD imagerel $LN13
	DD	imagerel $LN13+202
	DD	imagerel $unwind$ReadRegistryConfigFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadRegistryConfigFlags DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
xdata	ENDS
;	COMDAT ReadRegistryConfigFlags
_TEXT	SEGMENT
name$ = 32
driverEntry$ = 64
data$ = 72
ReadRegistryConfigFlags PROC				; COMDAT

; 3599 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	8b f9		 mov	 edi, ecx

; 3600 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3601 : 	UNICODE_STRING name;
; 3602 : 	NTSTATUS status;
; 3603 : 	uint32 flags = 0;
; 3604 : 
; 3605 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\gostcrypt");

  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1HM@FBFGPOIK@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  00013	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3606 : 	status = GSTReadRegistryKey (&name, GST_DRIVER_CONFIG_REG_VALUE_NAME, &data);

  0001e	4c 8d 44 24 48	 lea	 r8, QWORD PTR data$[rsp]
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@KPILIDPC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
  0002a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  0002f	e8 00 00 00 00	 call	 GSTReadRegistryKey
  00034	8b d8		 mov	 ebx, eax

; 3607 : 
; 3608 : 	if (NT_SUCCESS (status))

  00036	85 c0		 test	 eax, eax
  00038	78 45		 js	 SHORT $LN8@ReadRegist

; 3609 : 	{
; 3610 : 		if (data->Type == REG_DWORD)

  0003a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR data$[rsp]
  0003f	83 79 04 04	 cmp	 DWORD PTR [rcx+4], 4
  00043	75 2a		 jne	 SHORT $LN7@ReadRegist

; 3611 : 		{
; 3612 : 			flags = *(uint32 *) data->Data;
; 3613 : 			Dump ("Configuration flags = 0x%x\n", flags);
; 3614 : 
; 3615 : 			if (driverEntry)

  00045	85 ff		 test	 edi, edi
  00047	74 2b		 je	 SHORT $LN3@ReadRegist

; 3616 : 			{
; 3617 : 				if (flags & (GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD | GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))

  00049	f6 41 0c 03	 test	 BYTE PTR [rcx+12], 3
  0004d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR CacheBootPassword
  00053	ba 01 00 00 00	 mov	 edx, 1
  00058	0f 45 c2	 cmovne	 eax, edx

; 3618 : 					CacheBootPassword = TRUE;
; 3619 : 
; 3620 : 				if (flags & GST_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS)

  0005b	f6 41 0c 04	 test	 BYTE PTR [rcx+12], 4
  0005f	89 05 00 00 00
	00		 mov	 DWORD PTR CacheBootPassword, eax
  00065	74 0d		 je	 SHORT $LN3@ReadRegist

; 3621 : 					NonAdminSystemFavoritesAccessDisabled = TRUE;

  00067	89 15 00 00 00
	00		 mov	 DWORD PTR NonAdminSystemFavoritesAccessDisabled, edx

; 3622 : 			}
; 3623 : 
; 3624 : 			EnableHwEncryption ((flags & GST_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION) ? FALSE : TRUE);
; 3625 : 		}
; 3626 : 		else

  0006d	eb 05		 jmp	 SHORT $LN3@ReadRegist
$LN7@ReadRegist:

; 3627 : 			status = STATUS_INVALID_PARAMETER;

  0006f	bb 0d 00 00 c0	 mov	 ebx, -1073741811	; ffffffffc000000dH
$LN3@ReadRegist:

; 3628 : 
; 3629 : 		GSTfree (data);

  00074	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN8@ReadRegist:

; 3630 : 	}
; 3631 : 
; 3632 : 	if (driverEntry && NT_SUCCESS (GSTReadRegistryKey (&name, GST_ENCRYPTION_FREE_CPU_COUNT_REG_VALUE_NAME, &data)))

  0007f	85 ff		 test	 edi, edi
  00081	74 3a		 je	 SHORT $LN2@ReadRegist
  00083	4c 8d 44 24 48	 lea	 r8, QWORD PTR data$[rsp]
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EA@BHENEMCP@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
  0008f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  00094	e8 00 00 00 00	 call	 GSTReadRegistryKey
  00099	85 c0		 test	 eax, eax
  0009b	78 20		 js	 SHORT $LN2@ReadRegist

; 3633 : 	{
; 3634 : 		if (data->Type == REG_DWORD)

  0009d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR data$[rsp]
  000a2	83 79 04 04	 cmp	 DWORD PTR [rcx+4], 4
  000a6	75 0a		 jne	 SHORT $LN1@ReadRegist

; 3635 : 			EncryptionThreadPoolFreeCpuCountLimit = *(uint32 *) data->Data;

  000a8	8b 41 0c	 mov	 eax, DWORD PTR [rcx+12]
  000ab	48 89 05 00 00
	00 00		 mov	 QWORD PTR EncryptionThreadPoolFreeCpuCountLimit, rax
$LN1@ReadRegist:

; 3636 : 
; 3637 : 		GSTfree (data);

  000b2	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@ReadRegist:

; 3638 : 	}
; 3639 : 
; 3640 : 	return status;

  000bd	8b c3		 mov	 eax, ebx

; 3641 : }

  000bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5f		 pop	 rdi
  000c9	c3		 ret	 0
ReadRegistryConfigFlags ENDP
_TEXT	ENDS
PUBLIC	IsVolumeClassFilterRegistered
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsVolumeClassFilterRegistered DD imagerel $LN14
	DD	imagerel $LN14+175
	DD	imagerel $unwind$IsVolumeClassFilterRegistered
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsVolumeClassFilterRegistered DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IsVolumeClassFilterRegistered
_TEXT	SEGMENT
name$ = 32
data$ = 64
IsVolumeClassFilterRegistered PROC			; COMDAT

; 3556 : {

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3557 : 	UNICODE_STRING name;
; 3558 : 	NTSTATUS status;
; 3559 : 	BOOL registered = FALSE;
; 3560 : 
; 3561 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3562 : 
; 3563 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}");

  00006	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  0000d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  00012	33 db		 xor	 ebx, ebx
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3564 : 	status = GSTReadRegistryKey (&name, L"UpperFilters", &data);

  0001a	4c 8d 44 24 40	 lea	 r8, QWORD PTR data$[rsp]
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
  00026	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  0002b	e8 00 00 00 00	 call	 GSTReadRegistryKey

; 3565 : 
; 3566 : 	if (NT_SUCCESS (status))

  00030	3b c3		 cmp	 eax, ebx
  00032	7c 73		 jl	 SHORT $LN6@IsVolumeCl

; 3567 : 	{
; 3568 : 		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00039	83 79 04 07	 cmp	 DWORD PTR [rcx+4], 7
  0003d	75 5d		 jne	 SHORT $LN2@IsVolumeCl
  0003f	83 79 08 12	 cmp	 DWORD PTR [rcx+8], 18
  00043	72 57		 jb	 SHORT $LN2@IsVolumeCl

; 3569 : 		{
; 3570 : 			// Search for the string "gostcrypt"
; 3571 : 			ULONG i;
; 3572 : 			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)

  00045	44 8b 51 08	 mov	 r10d, DWORD PTR [rcx+8]
  00049	44 8b cb	 mov	 r9d, ebx
  0004c	48 8b c3	 mov	 rax, rbx
  0004f	49 83 ea 12	 sub	 r10, 18
$LL4@IsVolumeCl:

; 3573 : 			{
; 3574 : 				if (memcmp (data->Data + i, L"gostcrypt", 9 * sizeof (wchar_t)) == 0)

  00053	48 8d 44 08 0c	 lea	 rax, QWORD PTR [rax+rcx+12]
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BE@NLKDDOJN@?$AAg?$AAo?$AAs?$AAt?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  0005f	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00062	4c 3b 02	 cmp	 r8, QWORD PTR [rdx]
  00065	75 1a		 jne	 SHORT $LN12@IsVolumeCl
  00067	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0006b	4c 3b 42 08	 cmp	 r8, QWORD PTR [rdx+8]
  0006f	75 10		 jne	 SHORT $LN12@IsVolumeCl
  00071	66 44 8b 40 10	 mov	 r8w, WORD PTR [rax+16]
  00076	66 44 3b 42 10	 cmp	 r8w, WORD PTR [rdx+16]
  0007b	75 04		 jne	 SHORT $LN12@IsVolumeCl
  0007d	8b c3		 mov	 eax, ebx
  0007f	eb 05		 jmp	 SHORT $LN13@IsVolumeCl
$LN12@IsVolumeCl:
  00081	1b c0		 sbb	 eax, eax
  00083	83 d8 ff	 sbb	 eax, -1
$LN13@IsVolumeCl:
  00086	3b c3		 cmp	 eax, ebx
  00088	74 0d		 je	 SHORT $LN10@IsVolumeCl
  0008a	41 ff c1	 inc	 r9d
  0008d	41 8b c1	 mov	 eax, r9d
  00090	49 3b c2	 cmp	 rax, r10
  00093	76 be		 jbe	 SHORT $LL4@IsVolumeCl
  00095	eb 05		 jmp	 SHORT $LN2@IsVolumeCl
$LN10@IsVolumeCl:

; 3575 : 				{
; 3576 : 					Dump ("Volume class filter active\n");
; 3577 : 					registered = TRUE;

  00097	bb 01 00 00 00	 mov	 ebx, 1
$LN2@IsVolumeCl:

; 3578 : 					break;
; 3579 : 				}
; 3580 : 			}
; 3581 : 		}
; 3582 : 
; 3583 : 		GSTfree (data);

  0009c	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@IsVolumeCl:

; 3584 : 	}
; 3585 : 
; 3586 : 	return registered;

  000a7	8b c3		 mov	 eax, ebx

; 3587 : }

  000a9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ad	5b		 pop	 rbx
  000ae	c3		 ret	 0
IsVolumeClassFilterRegistered ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	IsDriveLetterAvailable
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsDriveLetterAvailable DD imagerel $LN4
	DD	imagerel $LN4+166
	DD	imagerel $unwind$IsDriveLetterAvailable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsDriveLetterAvailable DD 021919H
	DD	0310107H
	DD	imagerel __GSHandlerCheck
	DD	0170H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IsDriveLetterAvailable
_TEXT	SEGMENT
handle$ = 32
objectAttributes$ = 40
objectName$ = 88
link$ = 112
__$ArrayPad$ = 368
nDosDriveNo$ = 400
IsDriveLetterAvailable PROC				; COMDAT

; 3325 : {

$LN4:
  00000	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3326 : 	OBJECT_ATTRIBUTES objectAttributes;
; 3327 : 	UNICODE_STRING objectName;
; 3328 : 	WCHAR link[128];
; 3329 : 	HANDLE handle;
; 3330 : 
; 3331 : 	GSTGetDosNameFromNumber (link, nDosDriveNo);

  00019	8b d1		 mov	 edx, ecx
  0001b	48 8d 4c 24 70	 lea	 rcx, QWORD PTR link$[rsp]
  00020	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 3332 : 	RtlInitUnicodeString (&objectName, link);

  00025	48 8d 54 24 70	 lea	 rdx, QWORD PTR link$[rsp]
  0002a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR objectName$[rsp]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3333 : 	InitializeObjectAttributes (&objectAttributes, &objectName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00035	48 83 64 24 30
	00		 and	 QWORD PTR objectAttributes$[rsp+8], 0
  0003b	48 83 64 24 48
	00		 and	 QWORD PTR objectAttributes$[rsp+32], 0
  00041	48 83 64 24 50
	00		 and	 QWORD PTR objectAttributes$[rsp+40], 0
  00047	48 8d 44 24 58	 lea	 rax, QWORD PTR objectName$[rsp]

; 3334 : 
; 3335 : 	if (NT_SUCCESS (ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes)))

  0004c	4c 8d 44 24 28	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  00051	48 8d 4c 24 20	 lea	 rcx, QWORD PTR handle$[rsp]
  00056	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0005b	48 89 44 24 38	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  00060	c7 44 24 28 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  00068	c7 44 24 40 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenSymbolicLinkObject
  00076	85 c0		 test	 eax, eax
  00078	78 0f		 js	 SHORT $LN1@IsDriveLet

; 3336 : 	{
; 3337 : 		ZwClose (handle);

  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR handle$[rsp]
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3338 : 		return FALSE;

  00085	33 c0		 xor	 eax, eax
  00087	eb 05		 jmp	 SHORT $LN2@IsDriveLet
$LN1@IsDriveLet:

; 3339 : 	}
; 3340 : 
; 3341 : 	return TRUE;

  00089	b8 01 00 00 00	 mov	 eax, 1
$LN2@IsDriveLet:

; 3342 : }

  0008e	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00096	48 33 cc	 xor	 rcx, rsp
  00099	e8 00 00 00 00	 call	 __security_check_cookie
  0009e	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  000a5	c3		 ret	 0
IsDriveLetterAvailable ENDP
_TEXT	ENDS
PUBLIC	UserCanAccessDriveDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$UserCanAccessDriveDevice DD imagerel $LN6
	DD	imagerel $LN6+204
	DD	imagerel $unwind$UserCanAccessDriveDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UserCanAccessDriveDevice DD 030901H
	DD	0160109H
	DD	03002H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT UserCanAccessDriveDevice
_TEXT	SEGMENT
name$ = 96
ioStatusBlock$36826 = 112
fileObjAttributes$36825 = 128
fileHandle$36827 = 192
UserCanAccessDriveDevice PROC				; COMDAT

; 3308 : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 3309 : 	UNICODE_STRING name;
; 3310 : 	RtlInitUnicodeString (&name, L"\\Device\\MountPointManager");

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00010	48 8d 4c 24 60	 lea	 rcx, QWORD PTR name$[rsp]
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3311 : 
; 3312 : 	return IsAccessibleByUser (&name, FALSE);

  0001b	83 64 24 50 00	 and	 DWORD PTR [rsp+80], 0
  00020	48 83 64 24 48
	00		 and	 QWORD PTR [rsp+72], 0
  00026	48 83 a4 24 88
	00 00 00 00	 and	 QWORD PTR fileObjAttributes$36825[rsp+8], 0
  0002f	48 83 a4 24 a0
	00 00 00 00	 and	 QWORD PTR fileObjAttributes$36825[rsp+32], 0
  00038	48 83 a4 24 a8
	00 00 00 00	 and	 QWORD PTR fileObjAttributes$36825[rsp+40], 0
  00041	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  00049	48 8d 44 24 60	 lea	 rax, QWORD PTR name$[rsp]
  0004e	bb 01 00 00 00	 mov	 ebx, 1
  00053	89 5c 24 38	 mov	 DWORD PTR [rsp+56], ebx
  00057	c7 44 24 30 07
	00 00 00	 mov	 DWORD PTR [rsp+48], 7
  0005f	4c 8d 4c 24 70	 lea	 r9, QWORD PTR ioStatusBlock$36826[rsp]
  00064	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR fileObjAttributes$36825[rsp]
  0006c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR fileHandle$36827[rsp]
  00074	ba 00 00 00 c0	 mov	 edx, -1073741824	; c0000000H
  00079	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  00081	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00087	c7 84 24 80 00
	00 00 30 00 00
	00		 mov	 DWORD PTR fileObjAttributes$36825[rsp], 48 ; 00000030H
  00092	c7 84 24 98 00
	00 00 40 06 00
	00		 mov	 DWORD PTR fileObjAttributes$36825[rsp+24], 1600 ; 00000640H
  0009d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR fileObjAttributes$36825[rsp+16], rax
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  000ab	85 c0		 test	 eax, eax
  000ad	78 10		 js	 SHORT $LN3@UserCanAcc
  000af	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR fileHandle$36827[rsp]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
  000bd	eb 02		 jmp	 SHORT $LN4@UserCanAcc
$LN3@UserCanAcc:
  000bf	33 db		 xor	 ebx, ebx
$LN4@UserCanAcc:
  000c1	8b c3		 mov	 eax, ebx

; 3313 : }

  000c3	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  000ca	5b		 pop	 rbx
  000cb	c3		 ret	 0
UserCanAccessDriveDevice ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT FindVolumeWithHighestUniqueId
_TEXT	SEGMENT
maxUniqueId$ = 8
FindVolumeWithHighestUniqueId PROC			; COMDAT

; 3108 : 	PDEVICE_OBJECT highestIdDevice = NULL;
; 3109 : 	int highestId = -1;
; 3110 : 	int drive;
; 3111 : 
; 3112 : 	for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00000	33 d2		 xor	 edx, edx
  00002	45 33 c9	 xor	 r9d, r9d
  00005	41 83 ca ff	 or	 r10d, -1

; 3113 : 	{
; 3114 : 		PDEVICE_OBJECT device = GetVirtualVolumeDeviceObject (drive);

  00009	48 83 fa 19	 cmp	 rdx, 25
$LN14@FindVolume:
  0000d	77 0d		 ja	 SHORT $LN8@FindVolume
  0000f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:VirtualVolumeDeviceObjects
  00016	4d 8b 04 d0	 mov	 r8, QWORD PTR [r8+rdx*8]
  0001a	eb 03		 jmp	 SHORT $LN10@FindVolume
$LN8@FindVolume:
  0001c	45 33 c0	 xor	 r8d, r8d
$LN10@FindVolume:

; 3115 : 		if (device)

  0001f	4d 85 c0	 test	 r8, r8
  00022	74 16		 je	 SHORT $LN4@FindVolume

; 3116 : 		{
; 3117 : 			PEXTENSION extension = (PEXTENSION) device->DeviceExtension;

  00024	49 8b 40 40	 mov	 rax, QWORD PTR [r8+64]

; 3118 : 			if (extension->UniqueVolumeId > highestId && extension->UniqueVolumeId <= maxUniqueId)

  00028	44 39 50 10	 cmp	 DWORD PTR [rax+16], r10d
  0002c	7e 0c		 jle	 SHORT $LN4@FindVolume
  0002e	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00031	7f 07		 jg	 SHORT $LN4@FindVolume

; 3119 : 			{
; 3120 : 				highestId = extension->UniqueVolumeId;

  00033	44 8b 50 10	 mov	 r10d, DWORD PTR [rax+16]

; 3121 : 				highestIdDevice = device;

  00037	4d 8b c8	 mov	 r9, r8
$LN4@FindVolume:
  0003a	48 ff c2	 inc	 rdx
  0003d	48 83 fa 19	 cmp	 rdx, 25
  00041	7e ca		 jle	 SHORT $LN14@FindVolume

; 3122 : 			}
; 3123 : 		}
; 3124 : 	}
; 3125 : 
; 3126 : 	return highestIdDevice;

  00043	49 8b c1	 mov	 rax, r9

; 3127 : }

  00046	c3		 ret	 0
FindVolumeWithHighestUniqueId ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	RemoveDriveLink
;	COMDAT pdata
pdata	SEGMENT
$pdata$RemoveDriveLink DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$RemoveDriveLink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RemoveDriveLink DD 021919H
	DD	0490107H
	DD	imagerel __GSHandlerCheck
	DD	0230H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RemoveDriveLink
_TEXT	SEGMENT
symLink$ = 32
link$ = 48
__$ArrayPad$ = 560
nDosDriveNo$ = 592
RemoveDriveLink PROC					; COMDAT

; 2770 : {

$LN3:
  00000	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2771 : 	WCHAR link[256];
; 2772 : 	UNICODE_STRING symLink;
; 2773 : 	NTSTATUS ntStatus;
; 2774 : 
; 2775 : 	GSTGetDosNameFromNumber (link, nDosDriveNo);

  00019	8b d1		 mov	 edx, ecx
  0001b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR link$[rsp]
  00020	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 2776 : 	RtlInitUnicodeString (&symLink, link);

  00025	48 8d 54 24 30	 lea	 rdx, QWORD PTR link$[rsp]
  0002a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2777 : 
; 2778 : 	ntStatus = IoDeleteSymbolicLink (&symLink);

  00035	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 2779 : 	Dump ("IoDeleteSymbolicLink returned %X\n", ntStatus);
; 2780 : 	return ntStatus;
; 2781 : }

  00040	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00048	48 33 cc	 xor	 rcx, rsp
  0004b	e8 00 00 00 00	 call	 __security_check_cookie
  00050	48 81 c4 48 02
	00 00		 add	 rsp, 584		; 00000248H
  00057	c3		 ret	 0
RemoveDriveLink ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	CreateDriveLink
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateDriveLink DD imagerel $LN3
	DD	imagerel $LN3+132
	DD	imagerel $unwind$CreateDriveLink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateDriveLink DD 031b19H
	DD	04a0109H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0240H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CreateDriveLink
_TEXT	SEGMENT
symLink$ = 32
deviceName$ = 48
dev$ = 64
link$ = 320
__$ArrayPad$ = 576
nDosDriveNo$ = 608
CreateDriveLink PROC					; COMDAT

; 2744 : {

$LN3:
  00000	40 53		 push	 rbx
  00002	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001b	8b d9		 mov	 ebx, ecx

; 2745 : 	WCHAR dev[128], link[128];
; 2746 : 	UNICODE_STRING deviceName, symLink;
; 2747 : 	NTSTATUS ntStatus;
; 2748 : 
; 2749 : 	GSTGetNTNameFromNumber (dev, nDosDriveNo);

  0001d	8b d1		 mov	 edx, ecx
  0001f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR dev$[rsp]
  00024	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 2750 : 	GSTGetDosNameFromNumber (link, nDosDriveNo);

  00029	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR link$[rsp]
  00031	8b d3		 mov	 edx, ebx
  00033	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 2751 : 
; 2752 : 	RtlInitUnicodeString (&deviceName, dev);

  00038	48 8d 54 24 40	 lea	 rdx, QWORD PTR dev$[rsp]
  0003d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR deviceName$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2753 : 	RtlInitUnicodeString (&symLink, link);

  00048	48 8d 94 24 40
	01 00 00	 lea	 rdx, QWORD PTR link$[rsp]
  00050	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2754 : 
; 2755 : 	ntStatus = IoCreateSymbolicLink (&symLink, &deviceName);

  0005b	48 8d 54 24 30	 lea	 rdx, QWORD PTR deviceName$[rsp]
  00060	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink

; 2756 : 	Dump ("IoCreateSymbolicLink returned %X\n", ntStatus);
; 2757 : 	return ntStatus;
; 2758 : }

  0006b	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00073	48 33 cc	 xor	 rcx, rsp
  00076	e8 00 00 00 00	 call	 __security_check_cookie
  0007b	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  00082	5b		 pop	 rbx
  00083	c3		 ret	 0
CreateDriveLink ENDP
_TEXT	ENDS
PUBLIC	GSTFsctlCall
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$GSTFsctlCall DD imagerel $LN7
	DD	imagerel $LN7+214
	DD	imagerel $unwind$GSTFsctlCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTFsctlCall DD 061201H
	DD	0136412H
	DD	0123412H
	DD	0700bf212H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
xdata	ENDS
;	COMDAT GSTFsctlCall
_TEXT	SEGMENT
ioStatusBlock$ = 80
event$ = 96
fileObject$ = 144
IoControlCode$ = 152
InputBuffer$ = 160
InputBufferSize$ = 168
OutputBuffer$ = 176
OutputBufferSize$ = 184
GSTFsctlCall PROC					; COMDAT

; 2697 : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	8b da		 mov	 ebx, edx
  00014	48 8b f9	 mov	 rdi, rcx

; 2698 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2699 : 	NTSTATUS ntStatus;
; 2700 : 	PIRP irp;
; 2701 : 	KEVENT event;
; 2702 : 	PIO_STACK_LOCATION stack;
; 2703 : 	PDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject (fileObject);

  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetRelatedDeviceObject

; 2704 : 
; 2705 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  0001d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR event$[rsp]
  00022	45 33 c0	 xor	 r8d, r8d
  00025	33 d2		 xor	 edx, edx
  00027	48 8b f0	 mov	 rsi, rax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2706 : 
; 2707 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2708 : 					     deviceObject,
; 2709 : 					     InputBuffer, InputBufferSize,
; 2710 : 					     OutputBuffer, OutputBufferSize,
; 2711 : 					     FALSE,
; 2712 : 					     &event,
; 2713 : 					     &ioStatusBlock);

  00030	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR OutputBufferSize$[rsp]
  00037	4c 8d 5c 24 50	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  0003c	48 8d 44 24 60	 lea	 rax, QWORD PTR event$[rsp]
  00041	45 33 c9	 xor	 r9d, r9d
  00044	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  00049	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0004e	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  00053	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00057	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR OutputBuffer$[rsp]
  0005f	45 33 c0	 xor	 r8d, r8d
  00062	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00067	8b cb		 mov	 ecx, ebx
  00069	48 8b d6	 mov	 rdx, rsi
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  00072	48 8b d0	 mov	 rdx, rax

; 2714 : 
; 2715 : 	if (irp == NULL)

  00075	48 85 c0	 test	 rax, rax
  00078	75 07		 jne	 SHORT $LN2@GSTFsctlCa

; 2716 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0007a	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  0007f	eb 40		 jmp	 SHORT $LN1@GSTFsctlCa
$LN2@GSTFsctlCa:

; 2717 : 
; 2718 : 	stack = IoGetNextIrpStackLocation(irp);

  00081	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]

; 2719 : 	
; 2720 : 	stack->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
; 2721 : 	stack->MinorFunction = IRP_MN_USER_FS_REQUEST;
; 2722 : 	stack->FileObject = fileObject;
; 2723 : 
; 2724 : 	ntStatus = IoCallDriver (deviceObject, irp);

  00088	48 8b ce	 mov	 rcx, rsi
  0008b	c6 40 b8 0d	 mov	 BYTE PTR [rax-72], 13
  0008f	c6 40 b9 00	 mov	 BYTE PTR [rax-71], 0
  00093	48 89 78 e8	 mov	 QWORD PTR [rax-24], rdi
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 2725 : 	if (ntStatus == STATUS_PENDING)

  0009d	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000a2	75 1d		 jne	 SHORT $LN1@GSTFsctlCa

; 2726 : 	{
; 2727 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  000a4	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000aa	48 8d 4c 24 60	 lea	 rcx, QWORD PTR event$[rsp]
  000af	45 33 c9	 xor	 r9d, r9d
  000b2	45 33 c0	 xor	 r8d, r8d
  000b5	33 d2		 xor	 edx, edx
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2728 : 		ntStatus = ioStatusBlock.Status;

  000bd	8b 44 24 50	 mov	 eax, DWORD PTR ioStatusBlock$[rsp]
$LN1@GSTFsctlCa:

; 2729 : 	}
; 2730 : 
; 2731 : 	return ntStatus;
; 2732 : }

  000c1	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  000c9	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000cd	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000d1	49 8b e3	 mov	 rsp, r11
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
GSTFsctlCall ENDP
_TEXT	ENDS
PUBLIC	GSTWriteDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTWriteDevice DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$GSTWriteDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTWriteDevice DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTWriteDevice
_TEXT	SEGMENT
deviceObject$ = 64
buffer$ = 72
offset$ = 80
length$ = 88
GSTWriteDevice PROC					; COMDAT

; 2690 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2691 : 	return GSTReadWriteDevice (TRUE, deviceObject, buffer, offset, length);

  00004	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00009	4d 8b c8	 mov	 r9, r8
  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d1	 mov	 rdx, rcx
  00012	b9 01 00 00 00	 mov	 ecx, 1
  00017	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 2692 : }

  0001c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00020	c3		 ret	 0
GSTWriteDevice ENDP
_TEXT	ENDS
PUBLIC	GSTReadDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTReadDevice DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$GSTReadDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTReadDevice DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTReadDevice
_TEXT	SEGMENT
deviceObject$ = 64
buffer$ = 72
offset$ = 80
length$ = 88
GSTReadDevice PROC					; COMDAT

; 2673 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2674 : 	return GSTReadWriteDevice (FALSE, deviceObject, buffer, offset, length);

  00004	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00009	4d 8b c8	 mov	 r9, r8
  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d1	 mov	 rdx, rcx
  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 2675 : }

  00019	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001d	c3		 ret	 0
GSTReadDevice ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	GSTOpenFsVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTOpenFsVolume DD imagerel $LN5
	DD	imagerel $LN5+288
	DD	imagerel $unwind$GSTOpenFsVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTOpenFsVolume DD 051f19H
	DD	05f340dH
	DD	05a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTOpenFsVolume
_TEXT	SEGMENT
objectAttributes$ = 96
fullFileName$ = 144
ioStatus$ = 160
volumeName$ = 176
__$ArrayPad$ = 704
Extension$ = 736
volumeHandle$ = 744
fileObject$ = 752
GSTOpenFsVolume PROC					; COMDAT

; 2562 : {

$LN5:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 81 ec d0 02
	00 00		 sub	 rsp, 720		; 000002d0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001f	48 8b fa	 mov	 rdi, rdx

; 2563 : 	NTSTATUS ntStatus;
; 2564 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2565 : 	UNICODE_STRING fullFileName;
; 2566 : 	IO_STATUS_BLOCK ioStatus;
; 2567 : 	WCHAR volumeName[GST_MAX_PATH];
; 2568 : 
; 2569 : 	GSTGetNTNameFromNumber (volumeName, Extension->nDosDriveNo);

  00022	8b 51 14	 mov	 edx, DWORD PTR [rcx+20]
  00025	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR volumeName$[rsp]
  0002d	49 8b d8	 mov	 rbx, r8
  00030	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 2570 : 	RtlInitUnicodeString (&fullFileName, volumeName);

  00035	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR volumeName$[rsp]
  0003d	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR fullFileName$[rsp]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2571 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
; 2572 : 
; 2573 : 	ntStatus = ZwCreateFile (volumeHandle,
; 2574 : 		SYNCHRONIZE | GENERIC_READ,
; 2575 : 		&objectAttributes,
; 2576 : 		&ioStatus,
; 2577 : 		NULL,
; 2578 : 		FILE_ATTRIBUTE_NORMAL,
; 2579 : 		FILE_SHARE_READ | FILE_SHARE_WRITE,
; 2580 : 		FILE_OPEN,
; 2581 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2582 : 		NULL,
; 2583 : 		0);

  0004b	83 64 24 50 00	 and	 DWORD PTR [rsp+80], 0
  00050	48 83 64 24 48
	00		 and	 QWORD PTR [rsp+72], 0
  00056	48 83 64 24 68
	00		 and	 QWORD PTR objectAttributes$[rsp+8], 0
  0005c	48 83 a4 24 80
	00 00 00 00	 and	 QWORD PTR objectAttributes$[rsp+32], 0
  00065	48 83 a4 24 88
	00 00 00 00	 and	 QWORD PTR objectAttributes$[rsp+40], 0
  0006e	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  00076	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  0007e	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR fullFileName$[rsp]
  00086	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  0008e	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR ioStatus$[rsp]
  00096	4c 8d 44 24 60	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  0009b	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  000a0	48 8b cf	 mov	 rcx, rdi
  000a3	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  000ab	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000b1	c7 44 24 60 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  000b9	c7 44 24 78 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  000c1	48 89 44 24 70	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile

; 2584 : 
; 2585 : 	Dump ("Volume %ls open NTSTATUS 0x%08x\n", volumeName, ntStatus);
; 2586 : 
; 2587 : 	if (!NT_SUCCESS (ntStatus))

  000cc	85 c0		 test	 eax, eax

; 2588 : 		return ntStatus;

  000ce	78 2f		 js	 SHORT $LN3@GSTOpenFsV

; 2589 : 
; 2590 : 	ntStatus = ObReferenceObjectByHandle (*volumeHandle,
; 2591 : 		FILE_READ_DATA,
; 2592 : 		NULL,
; 2593 : 		KernelMode,
; 2594 : 		fileObject,
; 2595 : 		NULL);

  000d0	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000d3	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  000d9	45 33 c9	 xor	 r9d, r9d
  000dc	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  000e0	45 33 c0	 xor	 r8d, r8d
  000e3	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  000ee	8b d8		 mov	 ebx, eax

; 2596 : 
; 2597 : 	if (!NT_SUCCESS (ntStatus))

  000f0	85 c0		 test	 eax, eax
  000f2	79 09		 jns	 SHORT $LN1@GSTOpenFsV

; 2598 : 		ZwClose (*volumeHandle);

  000f4	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@GSTOpenFsV:

; 2599 : 
; 2600 : 	return ntStatus;

  000fd	8b c3		 mov	 eax, ebx
$LN3@GSTOpenFsV:

; 2601 : }

  000ff	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00107	48 33 cc	 xor	 rcx, rsp
  0010a	e8 00 00 00 00	 call	 __security_check_cookie
  0010f	48 8b 9c 24 f8
	02 00 00	 mov	 rbx, QWORD PTR [rsp+760]
  00117	48 81 c4 d0 02
	00 00		 add	 rsp, 720		; 000002d0H
  0011e	5f		 pop	 rdi
  0011f	c3		 ret	 0
GSTOpenFsVolume ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$SendDeviceIoControlRequest DD imagerel $LN10
	DD	imagerel $LN10+439
	DD	imagerel $unwind$SendDeviceIoControlRequest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SendDeviceIoControlRequest DD 0b1c01H
	DD	01f741cH
	DD	01e641cH
	DD	01d541cH
	DD	01c341cH
	DD	01a011cH
	DD	0c015H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
xdata	ENDS
;	COMDAT SendDeviceIoControlRequest
_TEXT	SEGMENT
ioStatusBlock$ = 80
event$ = 96
args$31253 = 128
deviceObject$ = 224
ioControlCode$ = 232
inputBuffer$ = 240
inputBufferSize$ = 248
outputBuffer$ = 256
outputBufferSize$ = 264
SendDeviceIoControlRequest PROC				; COMDAT

; 2438 : {

$LN10:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	41 8b f1	 mov	 esi, r9d
  0001f	49 8b e8	 mov	 rbp, r8
  00022	44 8b e2	 mov	 r12d, edx
  00025	48 8b d9	 mov	 rbx, rcx

; 2439 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2440 : 	NTSTATUS status;
; 2441 : 	PIRP irp;
; 2442 : 	KEVENT event;
; 2443 : 
; 2444 : 	if (KeGetCurrentIrql() > APC_LEVEL)

  00028	44 0f 20 c0	 mov	 rax, cr8
  0002c	3c 01		 cmp	 al, 1
  0002e	0f 86 c0 00 00
	00		 jbe	 $LN4@SendDevice

; 2445 : 	{
; 2446 : 		SendDeviceIoControlRequestWorkItemArgs args;
; 2447 : 
; 2448 : 		PIO_WORKITEM workItem = IoAllocateWorkItem (RootDeviceObject);

  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAllocateWorkItem
  00041	48 8b f8	 mov	 rdi, rax

; 2449 : 		if (!workItem)

  00044	48 85 c0	 test	 rax, rax
  00047	75 0a		 jne	 SHORT $LN3@SendDevice
$LN9@SendDevice:

; 2450 : 			return STATUS_INSUFFICIENT_RESOURCES;

  00049	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  0004e	e9 46 01 00 00	 jmp	 $LN5@SendDevice
$LN3@SendDevice:

; 2451 : 
; 2452 : 		args.deviceObject = deviceObject;
; 2453 : 		args.ioControlCode = ioControlCode;
; 2454 : 		args.inputBuffer = inputBuffer;
; 2455 : 		args.inputBufferSize = inputBufferSize;
; 2456 : 		args.outputBuffer = outputBuffer;

  00053	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR outputBuffer$[rsp]

; 2457 : 		args.outputBufferSize = outputBufferSize;
; 2458 : 
; 2459 : 		KeInitializeEvent (&args.WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  0005b	45 33 c0	 xor	 r8d, r8d
  0005e	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR args$31253[rsp+48]
  00066	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR args$31253[rsp+32], rax
  0006e	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR outputBufferSize$[rsp]
  00075	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00079	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR args$31253[rsp], rbx
  00081	44 89 a4 24 88
	00 00 00	 mov	 DWORD PTR args$31253[rsp+8], r12d
  00089	48 89 ac 24 90
	00 00 00	 mov	 QWORD PTR args$31253[rsp+16], rbp
  00091	89 84 24 a8 00
	00 00		 mov	 DWORD PTR args$31253[rsp+40], eax
  00098	89 b4 24 98 00
	00 00		 mov	 DWORD PTR args$31253[rsp+24], esi
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2460 : 		IoQueueWorkItem (workItem, SendDeviceIoControlRequestWorkItemRoutine, DelayedWorkQueue, &args); 

  000a5	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR args$31253[rsp]
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:SendDeviceIoControlRequestWorkItemRoutine
  000b4	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ba	48 8b cf	 mov	 rcx, rdi
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoQueueWorkItem

; 2461 : 
; 2462 : 		KeWaitForSingleObject (&args.WorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);

  000c3	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000c9	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR args$31253[rsp+48]
  000d1	45 33 c9	 xor	 r9d, r9d
  000d4	45 33 c0	 xor	 r8d, r8d
  000d7	33 d2		 xor	 edx, edx
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2463 : 		IoFreeWorkItem (workItem);

  000df	48 8b cf	 mov	 rcx, rdi
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoFreeWorkItem

; 2464 :  
; 2465 : 		return args.Status;

  000e8	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR args$31253[rsp+44]
  000ef	e9 a5 00 00 00	 jmp	 $LN5@SendDevice
$LN4@SendDevice:

; 2466 : 	}
; 2467 : 
; 2468 : 	KeInitializeEvent (&event, NotificationEvent, FALSE);

  000f4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR event$[rsp]
  000f9	45 33 c0	 xor	 r8d, r8d
  000fc	33 d2		 xor	 edx, edx
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2469 : 
; 2470 : 	irp = IoBuildDeviceIoControlRequest (ioControlCode, deviceObject, inputBuffer, inputBufferSize,
; 2471 : 		outputBuffer, outputBufferSize, FALSE, &event, &ioStatusBlock);

  00104	48 8d 44 24 60	 lea	 rax, QWORD PTR event$[rsp]
  00109	4c 8d 5c 24 50	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  0010e	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  00113	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00118	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR outputBufferSize$[rsp]
  0011f	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  00124	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00128	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR outputBuffer$[rsp]
  00130	44 8b ce	 mov	 r9d, esi
  00133	4c 8b c5	 mov	 r8, rbp
  00136	48 8b d3	 mov	 rdx, rbx
  00139	41 8b cc	 mov	 ecx, r12d
  0013c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  00147	48 8b f8	 mov	 rdi, rax

; 2472 : 
; 2473 : 	if (!irp)

  0014a	48 85 c0	 test	 rax, rax

; 2474 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0014d	0f 84 f6 fe ff
	ff		 je	 $LN9@SendDevice

; 2475 : 
; 2476 : 	ObReferenceObject (deviceObject);

  00153	48 8b cb	 mov	 rcx, rbx
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfReferenceObject

; 2477 : 
; 2478 : 	status = IoCallDriver (deviceObject, irp);

  0015c	48 8b d7	 mov	 rdx, rdi
  0015f	48 8b cb	 mov	 rcx, rbx
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  00168	8b f8		 mov	 edi, eax

; 2479 : 	if (status == STATUS_PENDING)

  0016a	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  0016f	75 1d		 jne	 SHORT $LN1@SendDevice

; 2480 : 	{
; 2481 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  00171	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00177	48 8d 4c 24 60	 lea	 rcx, QWORD PTR event$[rsp]
  0017c	45 33 c9	 xor	 r9d, r9d
  0017f	45 33 c0	 xor	 r8d, r8d
  00182	33 d2		 xor	 edx, edx
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2482 : 		status = ioStatusBlock.Status;

  0018a	8b 7c 24 50	 mov	 edi, DWORD PTR ioStatusBlock$[rsp]
$LN1@SendDevice:

; 2483 : 	}
; 2484 : 
; 2485 : 	ObDereferenceObject (deviceObject);

  0018e	48 8b cb	 mov	 rcx, rbx
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2486 : 	return status;

  00197	8b c7		 mov	 eax, edi
$LN5@SendDevice:

; 2487 : }

  00199	4c 8d 9c 24 d0
	00 00 00	 lea	 r11, QWORD PTR [rsp+208]
  001a1	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  001a5	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  001a9	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  001ad	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  001b1	49 8b e3	 mov	 rsp, r11
  001b4	41 5c		 pop	 r12
  001b6	c3		 ret	 0
SendDeviceIoControlRequest ENDP
_TEXT	ENDS
PUBLIC	GSTDeviceIoControl
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$GSTDeviceIoControl DD imagerel $LN8
	DD	imagerel $LN8+281
	DD	imagerel $unwind$GSTDeviceIoControl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTDeviceIoControl DD 071201H
	DD	0176412H
	DD	0163412H
	DD	0140112H
	DD	0700bH
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
xdata	ENDS
;	COMDAT GSTDeviceIoControl
_TEXT	SEGMENT
deviceObject$ = 80
fileObject$ = 88
name$ = 96
ioStatusBlock$ = 112
event$ = 128
deviceName$ = 176
IoControlCode$ = 184
InputBuffer$ = 192
InputBufferSize$ = 200
OutputBuffer$ = 208
OutputBufferSize$ = 216
GSTDeviceIoControl PROC					; COMDAT

; 2353 : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00012	8b f2		 mov	 esi, edx

; 2354 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2355 : 	NTSTATUS ntStatus;
; 2356 : 	PIRP irp;
; 2357 : 	PFILE_OBJECT fileObject;
; 2358 : 	PDEVICE_OBJECT deviceObject;
; 2359 : 	KEVENT event;
; 2360 : 	UNICODE_STRING name;
; 2361 : 
; 2362 : 	RtlInitUnicodeString(&name, deviceName);

  00014	48 8b d1	 mov	 rdx, rcx
  00017	48 8d 4c 24 60	 lea	 rcx, QWORD PTR name$[rsp]
  0001c	41 8b d9	 mov	 ebx, r9d
  0001f	49 8b f8	 mov	 rdi, r8
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2363 : 	ntStatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  00028	4c 8d 4c 24 50	 lea	 r9, QWORD PTR deviceObject$[rsp]
  0002d	4c 8d 44 24 58	 lea	 r8, QWORD PTR fileObject$[rsp]
  00032	48 8d 4c 24 60	 lea	 rcx, QWORD PTR name$[rsp]
  00037	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer

; 2364 : 
; 2365 : 	if (!NT_SUCCESS (ntStatus))

  00042	85 c0		 test	 eax, eax

; 2366 : 		return ntStatus;

  00044	0f 88 ba 00 00
	00		 js	 $LN4@GSTDeviceI

; 2367 : 
; 2368 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  0004a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  00052	45 33 c0	 xor	 r8d, r8d
  00055	33 d2		 xor	 edx, edx
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2369 : 
; 2370 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2371 : 					     deviceObject,
; 2372 : 					     InputBuffer, InputBufferSize,
; 2373 : 					     OutputBuffer, OutputBufferSize,
; 2374 : 					     FALSE,
; 2375 : 					     &event,
; 2376 : 					     &ioStatusBlock);

  0005d	48 8b 54 24 50	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  00062	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR event$[rsp]
  0006a	4c 8d 5c 24 70	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  0006f	44 8b cb	 mov	 r9d, ebx
  00072	4c 8b c7	 mov	 r8, rdi
  00075	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  0007a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0007f	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR OutputBufferSize$[rsp]
  00086	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  0008b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0008f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR OutputBuffer$[rsp]
  00097	8b ce		 mov	 ecx, esi
  00099	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  000a4	48 8b d0	 mov	 rdx, rax

; 2377 : 
; 2378 : 	if (irp == NULL)

  000a7	48 85 c0	 test	 rax, rax
  000aa	75 07		 jne	 SHORT $LN2@GSTDeviceI

; 2379 : 	{
; 2380 : 		Dump ("IRP allocation failed\n");
; 2381 : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  000ac	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; ffffffffc000009aH

; 2382 : 		goto ret;

  000b1	eb 44		 jmp	 SHORT $ret$31215
$LN2@GSTDeviceI:

; 2383 : 	}
; 2384 : 
; 2385 : 	IoGetNextIrpStackLocation (irp)->FileObject = fileObject;

  000b3	48 8b 88 b8 00
	00 00		 mov	 rcx, QWORD PTR [rax+184]
  000ba	48 8b 44 24 58	 mov	 rax, QWORD PTR fileObject$[rsp]
  000bf	48 89 41 e8	 mov	 QWORD PTR [rcx-24], rax

; 2386 : 
; 2387 : 	ntStatus = IoCallDriver (deviceObject, irp);

  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  000ce	8b d8		 mov	 ebx, eax

; 2388 : 	if (ntStatus == STATUS_PENDING)

  000d0	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000d5	75 20		 jne	 SHORT $ret$31215

; 2389 : 	{
; 2390 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  000d7	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000dd	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  000e5	45 33 c9	 xor	 r9d, r9d
  000e8	45 33 c0	 xor	 r8d, r8d
  000eb	33 d2		 xor	 edx, edx
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2391 : 		ntStatus = ioStatusBlock.Status;

  000f3	8b 5c 24 70	 mov	 ebx, DWORD PTR ioStatusBlock$[rsp]
$ret$31215:

; 2392 : 	}
; 2393 : 
; 2394 : ret:
; 2395 : 	ObDereferenceObject (fileObject);

  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fileObject$[rsp]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2396 : 	return ntStatus;

  00102	8b c3		 mov	 eax, ebx
$LN4@GSTDeviceI:

; 2397 : }

  00104	4c 8d 9c 24 a0
	00 00 00	 lea	 r11, QWORD PTR [rsp+160]
  0010c	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00110	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00114	49 8b e3	 mov	 rsp, r11
  00117	5f		 pop	 rdi
  00118	c3		 ret	 0
GSTDeviceIoControl ENDP
_TEXT	ENDS
PUBLIC	OnShutdownPending
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnShutdownPending DD imagerel $LN14
	DD	imagerel $LN14+137
	DD	imagerel $unwind$OnShutdownPending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnShutdownPending DD 010401H
	DD	08204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT OnShutdownPending
_TEXT	SEGMENT
unmount$ = 48
OnShutdownPending PROC					; COMDAT

; 2327 : {

$LN14:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2328 : 	UNMOUNT_STRUCT unmount;
; 2329 : 	memset (&unmount, 0, sizeof (unmount));

  00004	33 c0		 xor	 eax, eax
  00006	48 89 44 24 30	 mov	 QWORD PTR unmount$[rsp], rax

; 2330 : 	unmount.ignoreOpenFiles = TRUE;

  0000b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR unmount$[rsp+4], 1
  00013	48 89 44 24 38	 mov	 QWORD PTR unmount$[rsp+8], rax
$LL5@OnShutdown:

; 2331 : 
; 2332 : 	while (SendDeviceIoControlRequest (RootDeviceObject, GST_IOCTL_DISMOUNT_ALL_VOLUMES, &unmount, sizeof (unmount), &unmount, sizeof (unmount)) == STATUS_INSUFFICIENT_RESOURCES || unmount.HiddenVolumeProtectionTriggered)

  00018	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0001f	48 8d 44 24 30	 lea	 rax, QWORD PTR unmount$[rsp]
  00024	4c 8d 44 24 30	 lea	 r8, QWORD PTR unmount$[rsp]
  00029	41 b9 10 00 00
	00		 mov	 r9d, 16
  0002f	ba 14 20 22 00	 mov	 edx, 2236436		; 00222014H
  00034	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR [rsp+40], 16
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00046	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  0004b	74 07		 je	 SHORT $LN3@OnShutdown
  0004d	83 7c 24 38 00	 cmp	 DWORD PTR unmount$[rsp+8], 0
  00052	74 07		 je	 SHORT $LL2@OnShutdown
$LN3@OnShutdown:

; 2333 : 		unmount.HiddenVolumeProtectionTriggered = FALSE;

  00054	83 64 24 38 00	 and	 DWORD PTR unmount$[rsp+8], 0
  00059	eb bd		 jmp	 SHORT $LL5@OnShutdown
$LL2@OnShutdown:

; 2334 : 
; 2335 : 	while (SendDeviceIoControlRequest (RootDeviceObject, GST_IOCTL_WIPE_PASSWORD_CACHE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00062	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  00067	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0006d	45 33 c9	 xor	 r9d, r9d
  00070	45 33 c0	 xor	 r8d, r8d
  00073	ba 30 20 22 00	 mov	 edx, 2236464		; 00222030H
  00078	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0007d	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  00082	74 d7		 je	 SHORT $LL2@OnShutdown

; 2336 : }

  00084	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00088	c3		 ret	 0
OnShutdownPending ENDP
_TEXT	ENDS
PUBLIC	GSTDeleteDeviceObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTDeleteDeviceObject DD imagerel $LN18
	DD	imagerel $LN18+348
	DD	imagerel $unwind$GSTDeleteDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTDeleteDeviceObject DD 060f01H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTDeleteDeviceObject
_TEXT	SEGMENT
Win32NameString$ = 48
name$31160 = 64
DeviceObject$ = 96
Extension$ = 104
GSTDeleteDeviceObject PROC				; COMDAT

; 2234 : {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2235 : 	UNICODE_STRING Win32NameString;
; 2236 : 	NTSTATUS ntStatus;
; 2237 : 
; 2238 : 	Dump ("GSTDeleteDeviceObject BEGIN\n");
; 2239 : 
; 2240 : 	if (Extension->bRootDevice)

  0000f	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  00012	48 8b da	 mov	 rbx, rdx
  00015	48 8b f1	 mov	 rsi, rcx
  00018	74 2a		 je	 SHORT $LN11@GSTDeleteD

; 2241 : 	{
; 2242 : 		RtlInitUnicodeString (&Win32NameString, (LPWSTR) DOS_ROOT_PREFIX);

  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00021	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2243 : 		ntStatus = IoDeleteSymbolicLink (&Win32NameString);

  0002c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 2244 : 		if (!NT_SUCCESS (ntStatus))
; 2245 : 			Dump ("IoDeleteSymbolicLink failed ntStatus = 0x%08x\n", ntStatus);
; 2246 : 
; 2247 : 		RootDeviceObject = NULL;

  00037	48 83 25 00 00
	00 00 00	 and	 QWORD PTR RootDeviceObject, 0

; 2248 : 	}
; 2249 : 	else

  0003f	e9 ff 00 00 00	 jmp	 $LN9@GSTDeleteD
$LN11@GSTDeleteD:

; 2250 : 	{
; 2251 : 		if (Extension->peThread != NULL)

  00044	48 83 7a 20 00	 cmp	 QWORD PTR [rdx+32], 0
  00049	74 41		 je	 SHORT $LN15@GSTDeleteD

; 2252 : 			GSTStopVolumeThread (DeviceObject, Extension);

  0004b	c7 42 1c 01 00
	00 00		 mov	 DWORD PTR [rdx+28], 1
  00052	48 8d 4a 58	 lea	 rcx, QWORD PTR [rdx+88]
  00056	33 d2		 xor	 edx, edx
  00058	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  0005c	41 b1 01	 mov	 r9b, 1
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSemaphore
  00065	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00069	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0006f	45 33 c9	 xor	 r9d, r9d
  00072	45 33 c0	 xor	 r8d, r8d
  00075	33 d2		 xor	 edx, edx
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0007d	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
  00087	48 83 63 20 00	 and	 QWORD PTR [rbx+32], 0
$LN15@GSTDeleteD:

; 2253 : 
; 2254 : 		if (Extension->UserSid)

  0008c	48 8b 8b 88 05
	00 00		 mov	 rcx, QWORD PTR [rbx+1416]
  00093	48 85 c9	 test	 rcx, rcx
  00096	74 0b		 je	 SHORT $LN7@GSTDeleteD

; 2255 : 			GSTfree (Extension->UserSid);

  00098	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN7@GSTDeleteD:

; 2256 : 
; 2257 : 		if (Extension->SecurityClientContextValid)

  000a3	83 bb 90 05 00
	00 00		 cmp	 DWORD PTR [rbx+1424], 0
  000aa	0f 84 83 00 00
	00		 je	 $LN1@GSTDeleteD

; 2258 : 		{
; 2259 : 			if (OsMajorVersion == 5 && OsMinorVersion == 0)

  000b0	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR OsMajorVersion, 5
  000b7	75 18		 jne	 SHORT $LN5@GSTDeleteD
  000b9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMinorVersion, 0
  000c0	75 0f		 jne	 SHORT $LN5@GSTDeleteD

; 2260 : 			{
; 2261 : 				ObDereferenceObject (Extension->SecurityClientContext.ClientToken);

  000c2	48 8b 8b a8 05
	00 00		 mov	 rcx, QWORD PTR [rbx+1448]
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2262 : 			}
; 2263 : 			else

  000cf	eb 62		 jmp	 SHORT $LN1@GSTDeleteD
$LN5@GSTDeleteD:

; 2264 : 			{
; 2265 : 				// Windows 2000 does not support PsDereferenceImpersonationToken() used by SeDeleteClientSecurity().
; 2266 : 				// TODO: Use only SeDeleteClientSecurity() once support for Windows 2000 is dropped.
; 2267 : 
; 2268 : 				VOID (*PsDereferenceImpersonationTokenD) (PACCESS_TOKEN ImpersonationToken);
; 2269 : 				UNICODE_STRING name;
; 2270 : 				RtlInitUnicodeString (&name, L"PsDereferenceImpersonationToken");

  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
  000d8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR name$31160[rsp]
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2271 : 
; 2272 : 				PsDereferenceImpersonationTokenD = MmGetSystemRoutineAddress (&name);

  000e3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR name$31160[rsp]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress
  000ee	48 8b f8	 mov	 rdi, rax

; 2273 : 				if (!PsDereferenceImpersonationTokenD)

  000f1	48 85 c0	 test	 rax, rax
  000f4	75 22		 jne	 SHORT $LN3@GSTDeleteD

; 2274 : 					GST_BUG_CHECK (STATUS_NOT_IMPLEMENTED);

  000f6	8d 48 29	 lea	 ecx, QWORD PTR [rax+41]
  000f9	45 33 c9	 xor	 r9d, r9d
  000fc	ba e2 08 00 00	 mov	 edx, 2274		; 000008e2H
  00101	49 c7 c0 02 00
	00 c0		 mov	 r8, -1073741822		; ffffffffc0000002H
  00108	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00117	cc		 int	 3
$LN3@GSTDeleteD:

; 2275 : 				
; 2276 : #				define PsDereferencePrimaryToken
; 2277 : #				define PsDereferenceImpersonationToken PsDereferenceImpersonationTokenD
; 2278 : 
; 2279 : 				SeDeleteClientSecurity (&Extension->SecurityClientContext);

  00118	48 8b 8b a8 05
	00 00		 mov	 rcx, QWORD PTR [rbx+1448]
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeTokenType
  00125	83 f8 01	 cmp	 eax, 1
  00128	74 09		 je	 SHORT $LN1@GSTDeleteD
  0012a	48 8b 8b a8 05
	00 00		 mov	 rcx, QWORD PTR [rbx+1448]
  00131	ff d7		 call	 rdi
$LN1@GSTDeleteD:

; 2280 : 
; 2281 : #				undef PsDereferencePrimaryToken
; 2282 : #				undef PsDereferenceImpersonationToken
; 2283 : 			}
; 2284 : 		}
; 2285 : 
; 2286 : 		VirtualVolumeDeviceObjects[Extension->nDosDriveNo] = NULL;

  00133	48 63 43 14	 movsxd	 rax, DWORD PTR [rbx+20]
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VirtualVolumeDeviceObjects
  0013e	48 83 24 c1 00	 and	 QWORD PTR [rcx+rax*8], 0
$LN9@GSTDeleteD:

; 2287 : 	}
; 2288 : 
; 2289 : 	IoDeleteDevice (DeviceObject);

  00143	48 8b ce	 mov	 rcx, rsi
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 2290 : 
; 2291 : 	Dump ("GSTDeleteDeviceObject END\n");
; 2292 : }

  0014c	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00151	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00156	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0015a	5f		 pop	 rdi
  0015b	c3		 ret	 0
$LN17@GSTDeleteD:
GSTDeleteDeviceObject ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	GSTCreateDeviceObject
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$GSTCreateDeviceObject DD imagerel $LN8
	DD	imagerel $LN8+403
	DD	imagerel $unwind$GSTCreateDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCreateDeviceObject DD 051f19H
	DD	01e010dH
	DD	060057006H
	DD	03004H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
xdata	ENDS
;	COMDAT GSTCreateDeviceObject
_TEXT	SEGMENT
ntUnicodeString$ = 64
Win32NameString$ = 80
ntname$ = 96
dosname$ = 160
__$ArrayPad$ = 224
DriverObject$ = 272
ppDeviceObject$ = 280
mount$ = 288
GSTCreateDeviceObject PROC				; COMDAT

; 485  : {

$LN8:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	56		 push	 rsi
  00005	57		 push	 rdi
  00006	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001f	48 8b f2	 mov	 rsi, rdx

; 486  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 487  : 	WCHAR dosname[32], ntname[32];
; 488  : 	PEXTENSION Extension;
; 489  : 	NTSTATUS ntStatus;
; 490  : 	ULONG devChars = 0;
; 491  : 
; 492  : 	Dump ("GSTCreateDeviceObject BEGIN\n");
; 493  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
; 494  : 
; 495  : 	GSTGetDosNameFromNumber (dosname, mount->nDosDriveNo);

  00022	41 8b 90 64 02
	00 00		 mov	 edx, DWORD PTR [r8+612]
  00029	48 8b d9	 mov	 rbx, rcx
  0002c	49 8d 4b 98	 lea	 rcx, QWORD PTR [r11-104]
  00030	49 8b f8	 mov	 rdi, r8
  00033	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 496  : 	GSTGetNTNameFromNumber (ntname, mount->nDosDriveNo);

  00038	8b 97 64 02 00
	00		 mov	 edx, DWORD PTR [rdi+612]
  0003e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ntname$[rsp]
  00043	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 497  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  00048	48 8d 54 24 60	 lea	 rdx, QWORD PTR ntname$[rsp]
  0004d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ntUnicodeString$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 498  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  00058	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR dosname$[rsp]
  00060	48 8d 4c 24 50	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 499  : 
; 500  : 	devChars = FILE_DEVICE_SECURE_OPEN;
; 501  : 	devChars |= mount->bMountReadOnly ? FILE_READ_ONLY_DEVICE : 0;

  0006b	8b 87 6c 02 00
	00		 mov	 eax, DWORD PTR [rdi+620]

; 502  : 	devChars |= mount->bMountRemovable ? FILE_REMOVABLE_MEDIA : 0;
; 503  : 
; 504  : 	Dump ("Creating device nt=%ls dos=%ls\n", ntname, dosname);
; 505  : 
; 506  : 	ntStatus = IoCreateDevice (
; 507  : 					  DriverObject,			/* Our Driver Object */
; 508  : 					  sizeof (EXTENSION),	/* Size of state information */
; 509  : 					  &ntUnicodeString,		/* Device name "\Device\Name" */
; 510  : 					  FILE_DEVICE_DISK,		/* Device type */
; 511  : 					  devChars,				/* Device characteristics */
; 512  : 					  FALSE,				/* Exclusive device */
; 513  : 					  ppDeviceObject);		/* Returned ptr to Device Object */

  00071	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00076	f7 d8		 neg	 eax
  00078	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0007d	4c 8d 44 24 40	 lea	 r8, QWORD PTR ntUnicodeString$[rsp]
  00082	1b d2		 sbb	 edx, edx
  00084	33 c0		 xor	 eax, eax
  00086	41 b9 07 00 00
	00		 mov	 r9d, 7
  0008c	83 e2 02	 and	 edx, 2
  0008f	39 87 70 02 00
	00		 cmp	 DWORD PTR [rdi+624], eax
  00095	48 8b cb	 mov	 rcx, rbx
  00098	0f 95 c0	 setne	 al
  0009b	0b d0		 or	 edx, eax
  0009d	0f ba ea 08	 bts	 edx, 8
  000a1	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  000a5	ba e0 05 00 00	 mov	 edx, 1504		; 000005e0H
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 514  : 
; 515  : 	if (!NT_SUCCESS (ntStatus))

  000b0	85 c0		 test	 eax, eax

; 516  : 	{
; 517  : 		Dump ("GSTCreateDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 518  : 		return ntStatus;/* Failed to create DeviceObject */

  000b2	0f 88 c0 00 00
	00		 js	 $LN2@GSTCreateD

; 519  : 	}
; 520  : 	/* Initialize device object and extension. */
; 521  : 
; 522  : 	(*ppDeviceObject)->Flags |= DO_DIRECT_IO;

  000b8	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 523  : 	(*ppDeviceObject)->StackSize += 6;		// Reduce occurrence of NO_MORE_IRP_STACK_LOCATIONS bug check caused by buggy drivers
; 524  : 
; 525  : 	/* Setup the device extension */
; 526  : 	Extension = (PEXTENSION) (*ppDeviceObject)->DeviceExtension;
; 527  : 	memset (Extension, 0, sizeof (EXTENSION));

  000bb	33 d2		 xor	 edx, edx
  000bd	41 b8 e0 05 00
	00		 mov	 r8d, 1504		; 000005e0H
  000c3	83 48 30 10	 or	 DWORD PTR [rax+48], 16
  000c7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000ca	80 40 4c 06	 add	 BYTE PTR [rax+76], 6
  000ce	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000d1	48 8b 58 40	 mov	 rbx, QWORD PTR [rax+64]
  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	e8 00 00 00 00	 call	 memset

; 528  : 
; 529  : 	Extension->IsVolumeDevice = TRUE;

  000dd	ba 01 00 00 00	 mov	 edx, 1

; 530  : 	Extension->nDosDriveNo = mount->nDosDriveNo;
; 531  : 	Extension->bRemovable = mount->bMountRemovable;
; 532  : 	Extension->PartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;
; 533  : 	Extension->SystemFavorite = mount->SystemFavorite;
; 534  : 
; 535  : 	KeInitializeEvent (&Extension->keCreateEvent, SynchronizationEvent, FALSE);

  000e2	48 8d 4b 28	 lea	 rcx, QWORD PTR [rbx+40]
  000e6	89 53 04	 mov	 DWORD PTR [rbx+4], edx
  000e9	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [rdi+612]
  000ef	45 33 c0	 xor	 r8d, r8d
  000f2	89 43 14	 mov	 DWORD PTR [rbx+20], eax
  000f5	8b 87 70 02 00
	00		 mov	 eax, DWORD PTR [rdi+624]
  000fb	89 83 44 03 00
	00		 mov	 DWORD PTR [rbx+836], eax
  00101	8b 87 80 02 00
	00		 mov	 eax, DWORD PTR [rdi+640]
  00107	89 83 48 03 00
	00		 mov	 DWORD PTR [rbx+840], eax
  0010d	8b 87 88 02 00
	00		 mov	 eax, DWORD PTR [rdi+648]
  00113	89 83 54 03 00
	00		 mov	 DWORD PTR [rbx+852], eax
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 536  : 	KeInitializeSemaphore (&Extension->RequestSemaphore, 0L, MAXLONG);

  0011f	48 8d 4b 58	 lea	 rcx, QWORD PTR [rbx+88]
  00123	33 d2		 xor	 edx, edx
  00125	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeSemaphore

; 537  : 	KeInitializeSpinLock (&Extension->ListSpinLock);

  00131	48 83 63 40 00	 and	 QWORD PTR [rbx+64], 0

; 538  : 	InitializeListHead (&Extension->ListEntry);

  00136	48 8d 43 48	 lea	 rax, QWORD PTR [rbx+72]

; 539  : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  0013a	48 8d 8b 80 01
	00 00		 lea	 rcx, QWORD PTR [rbx+384]
  00141	45 33 c9	 xor	 r9d, r9d
  00144	45 33 c0	 xor	 r8d, r8d
  00147	ba 54 43 52 4c	 mov	 edx, 1280459604		; 4c524354H
  0014c	48 89 40 08	 mov	 QWORD PTR [rax+8], rax
  00150	48 89 00	 mov	 QWORD PTR [rax], rax
  00153	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoInitializeRemoveLockEx

; 540  : 
; 541  : 	VirtualVolumeDeviceObjects[mount->nDosDriveNo] = *ppDeviceObject;

  00161	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00164	4c 63 9f 64 02
	00 00		 movsxd	 r11, DWORD PTR [rdi+612]
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VirtualVolumeDeviceObjects
  00172	4a 89 04 d9	 mov	 QWORD PTR [rcx+r11*8], rax

; 542  : 
; 543  : 	Dump ("GSTCreateDeviceObject STATUS_SUCCESS END\n");
; 544  : 
; 545  : 	return STATUS_SUCCESS;

  00176	33 c0		 xor	 eax, eax
$LN2@GSTCreateD:

; 546  : }

  00178	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00180	48 33 cc	 xor	 rcx, rsp
  00183	e8 00 00 00 00	 call	 __security_check_cookie
  00188	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  0018f	5f		 pop	 rdi
  00190	5e		 pop	 rsi
  00191	5b		 pop	 rbx
  00192	c3		 ret	 0
GSTCreateDeviceObject ENDP
_TEXT	ENDS
PUBLIC	ValidateIOBufferSize
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$ValidateIOBufferSize DD imagerel $LN13
	DD	imagerel $LN13+135
	DD	imagerel $unwind$ValidateIOBufferSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ValidateIOBufferSize DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
xdata	ENDS
;	COMDAT ValidateIOBufferSize
_TEXT	SEGMENT
irp$ = 48
requiredBufferSize$ = 56
type$ = 64
ValidateIOBufferSize PROC				; COMDAT

; 214  : {

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 215  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);

  00004	4c 8b 99 b8 00
	00 00		 mov	 r11, QWORD PTR [rcx+184]
  0000b	4c 8b c9	 mov	 r9, rcx

; 216  : 	BOOL input = (type == ValidateInput || type == ValidateInputOutput);

  0000e	45 85 c0	 test	 r8d, r8d
  00011	74 0b		 je	 SHORT $LN7@ValidateIO
  00013	41 83 f8 02	 cmp	 r8d, 2
  00017	74 05		 je	 SHORT $LN7@ValidateIO
  00019	45 33 d2	 xor	 r10d, r10d
  0001c	eb 06		 jmp	 SHORT $LN8@ValidateIO
$LN7@ValidateIO:
  0001e	41 ba 01 00 00
	00		 mov	 r10d, 1
$LN8@ValidateIO:

; 217  : 	BOOL output = (type == ValidateOutput || type == ValidateInputOutput);

  00024	41 83 f8 01	 cmp	 r8d, 1
  00028	74 0a		 je	 SHORT $LN9@ValidateIO
  0002a	41 83 f8 02	 cmp	 r8d, 2
  0002e	74 04		 je	 SHORT $LN9@ValidateIO
  00030	33 c9		 xor	 ecx, ecx
  00032	eb 05		 jmp	 SHORT $LN10@ValidateIO
$LN9@ValidateIO:
  00034	b9 01 00 00 00	 mov	 ecx, 1
$LN10@ValidateIO:

; 218  : 
; 219  : 	if ((input && irpSp->Parameters.DeviceIoControl.InputBufferLength < requiredBufferSize)
; 220  : 		|| (output && irpSp->Parameters.DeviceIoControl.OutputBufferLength < requiredBufferSize))

  00039	45 85 d2	 test	 r10d, r10d
  0003c	74 09		 je	 SHORT $LN2@ValidateIO
  0003e	41 8b 43 10	 mov	 eax, DWORD PTR [r11+16]
  00042	48 3b c2	 cmp	 rax, rdx
  00045	72 0d		 jb	 SHORT $LN3@ValidateIO
$LN2@ValidateIO:
  00047	85 c9		 test	 ecx, ecx
  00049	74 1a		 je	 SHORT $LN4@ValidateIO
  0004b	41 8b 43 08	 mov	 eax, DWORD PTR [r11+8]
  0004f	48 3b c2	 cmp	 rax, rdx
  00052	73 11		 jae	 SHORT $LN4@ValidateIO
$LN3@ValidateIO:

; 221  : 	{
; 222  : 		Dump ("STATUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d insize=%d outsize=%d\n", (int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16), (int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2), input, output, requiredBufferSize, irpSp->Parameters.DeviceIoControl.InputBufferLength, irpSp->Parameters.DeviceIoControl.OutputBufferLength);
; 223  : 
; 224  : 		irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
; 225  : 		irp->IoStatus.Information = 0;

  00054	49 83 61 38 00	 and	 QWORD PTR [r9+56], 0
  00059	41 c7 41 30 23
	00 00 c0	 mov	 DWORD PTR [r9+48], -1073741789 ; ffffffffc0000023H

; 226  : 		return FALSE;

  00061	33 c0		 xor	 eax, eax
  00063	eb 1d		 jmp	 SHORT $LN5@ValidateIO
$LN4@ValidateIO:

; 227  : 	}
; 228  : 
; 229  : 	if (!input && output)

  00065	45 85 d2	 test	 r10d, r10d
  00068	75 13		 jne	 SHORT $LN1@ValidateIO
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 0f		 je	 SHORT $LN1@ValidateIO

; 230  : 		memset (irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  0006e	45 8b 43 08	 mov	 r8d, DWORD PTR [r11+8]
  00072	49 8b 49 18	 mov	 rcx, QWORD PTR [r9+24]
  00076	33 d2		 xor	 edx, edx
  00078	e8 00 00 00 00	 call	 memset
$LN1@ValidateIO:

; 231  : 
; 232  : 	return TRUE;

  0007d	b8 01 00 00 00	 mov	 eax, 1
$LN5@ValidateIO:

; 233  : }

  00082	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00086	c3		 ret	 0
ValidateIOBufferSize ENDP
_TEXT	ENDS
PUBLIC	DriverAddDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverAddDevice DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$DriverAddDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverAddDevice DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DriverAddDevice
_TEXT	SEGMENT
driverObject$ = 48
pdo$ = 56
interfaceLinks$30299 = 64
DriverAddDevice PROC					; COMDAT

; 139  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 140  : #ifdef DEBUG
; 141  : 	char nameInfoBuffer[128];
; 142  : 	POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION) nameInfoBuffer;
; 143  : 	ULONG nameInfoSize;
; 144  : 	Dump ("AddDevice pdo=%p type=%x name=%ws\n", pdo, pdo->DeviceType, NT_SUCCESS (ObQueryNameString (pdo, nameInfo, sizeof (nameInfoBuffer), &nameInfoSize)) ? nameInfo->Name.Buffer : L"?");
; 145  : #endif
; 146  : 
; 147  : 	if (VolumeClassFilterRegistered && BootArgsValid && BootArgs.HiddenSystemPartitionStart != 0)

  0000f	33 f6		 xor	 esi, esi
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	39 35 00 00 00
	00		 cmp	 DWORD PTR VolumeClassFilterRegistered, esi
  0001d	74 50		 je	 SHORT $LN2@DriverAddD
  0001f	39 35 00 00 00
	00		 cmp	 DWORD PTR BootArgsValid, esi
  00025	74 48		 je	 SHORT $LN2@DriverAddD
  00027	48 39 35 5a 00
	00 00		 cmp	 QWORD PTR BootArgs+90, rsi
  0002e	74 3f		 je	 SHORT $LN2@DriverAddD

; 148  : 	{
; 149  : 		PWSTR interfaceLinks;
; 150  : 		if (NT_SUCCESS (IoGetDeviceInterfaces (&GUID_DEVINTERFACE_VOLUME, pdo, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &interfaceLinks)))

  00030	4c 8d 4c 24 40	 lea	 r9, QWORD PTR interfaceLinks$30299[rsp]
  00035	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:GUID_DEVINTERFACE_VOLUME
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceInterfaces
  00046	3b c6		 cmp	 eax, esi
  00048	7c 25		 jl	 SHORT $LN2@DriverAddD

; 151  : 		{
; 152  : 			if (interfaceLinks[0] != UNICODE_NULL)

  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR interfaceLinks$30299[rsp]

; 153  : 			{
; 154  : 				Dump ("Volume pdo=%p interface=%ws\n", pdo, interfaceLinks);
; 155  : 				ExFreePool (interfaceLinks);

  0004f	33 d2		 xor	 edx, edx
  00051	66 39 31	 cmp	 WORD PTR [rcx], si
  00054	74 13		 je	 SHORT $LN1@DriverAddD
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 156  : 
; 157  : 				return VolumeFilterAddDevice (driverObject, pdo);

  0005c	48 8b d3	 mov	 rdx, rbx
  0005f	48 8b cf	 mov	 rcx, rdi
  00062	e8 00 00 00 00	 call	 VolumeFilterAddDevice
  00067	eb 11		 jmp	 SHORT $LN4@DriverAddD
$LN1@DriverAddD:

; 158  : 			}
; 159  : 
; 160  : 			ExFreePool (interfaceLinks);

  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@DriverAddD:

; 161  : 		}
; 162  : 	}
; 163  : 
; 164  : 	return DriveFilterAddDevice (driverObject, pdo);

  0006f	48 8b d3	 mov	 rdx, rbx
  00072	48 8b cf	 mov	 rcx, rdi
  00075	e8 00 00 00 00	 call	 DriveFilterAddDevice
$LN4@DriverAddD:

; 165  : }

  0007a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
DriverAddDevice ENDP
PUBLIC	IsVolumeAccessibleByCurrentUser
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$IsVolumeAccessibleByCurrentUser DD imagerel $LN12
	DD	imagerel $LN12+233
	DD	imagerel $unwind$IsVolumeAccessibleByCurrentUser
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsVolumeAccessibleByCurrentUser DD 060f01H
	DD	0c640fH
	DD	0a340fH
	DD	0700b720fH
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
xdata	ENDS
;	COMDAT IsVolumeAccessibleByCurrentUser
_TEXT	SEGMENT
subContext$ = 32
volumeDeviceExtension$ = 80
tokenUser$ = 88
IsVolumeAccessibleByCurrentUser PROC			; COMDAT

; 3787 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b f1	 mov	 rsi, rcx

; 3788 : 	SECURITY_SUBJECT_CONTEXT subContext;
; 3789 : 	PACCESS_TOKEN accessToken;
; 3790 : 	PTOKEN_USER tokenUser;
; 3791 : 	BOOL result = FALSE;
; 3792 : 
; 3793 : 	if (IoIsSystemThread (PsGetCurrentThread())
; 3794 : 		|| UserCanAccessDriveDevice()
; 3795 : 		|| !volumeDeviceExtension->UserSid
; 3796 : 		|| (volumeDeviceExtension->SystemFavorite && !NonAdminSystemFavoritesAccessDisabled))

  00012	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  0001b	33 db		 xor	 ebx, ebx
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  00023	3a c3		 cmp	 al, bl
  00025	0f 85 a9 00 00
	00		 jne	 $LN4@IsVolumeAc
  0002b	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00030	3b c3		 cmp	 eax, ebx
  00032	0f 85 9c 00 00
	00		 jne	 $LN4@IsVolumeAc
  00038	48 39 9e 88 05
	00 00		 cmp	 QWORD PTR [rsi+1416], rbx
  0003f	0f 84 8f 00 00
	00		 je	 $LN4@IsVolumeAc
  00045	39 9e 54 03 00
	00		 cmp	 DWORD PTR [rsi+852], ebx
  0004b	74 08		 je	 SHORT $LN5@IsVolumeAc
  0004d	39 1d 00 00 00
	00		 cmp	 DWORD PTR NonAdminSystemFavoritesAccessDisabled, ebx
  00053	74 7f		 je	 SHORT $LN4@IsVolumeAc
$LN5@IsVolumeAc:

; 3799 : 	}
; 3800 : 
; 3801 : 	SeCaptureSubjectContext (&subContext);

  00055	48 8d 4c 24 20	 lea	 rcx, QWORD PTR subContext$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCaptureSubjectContext

; 3802 : 	accessToken = SeQuerySubjectContextToken (&subContext);

  00060	48 39 5c 24 20	 cmp	 QWORD PTR subContext$[rsp], rbx
  00065	48 8b 7c 24 30	 mov	 rdi, QWORD PTR subContext$[rsp+16]
  0006a	48 0f 45 7c 24
	20		 cmovne	 rdi, QWORD PTR subContext$[rsp]

; 3803 : 
; 3804 : 	if (!accessToken)

  00070	48 3b fb	 cmp	 rdi, rbx
  00073	74 50		 je	 SHORT $ret$31884

; 3805 : 		goto ret;
; 3806 : 	
; 3807 : 	if (SeTokenIsAdmin (accessToken))

  00075	48 8b cf	 mov	 rcx, rdi
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeTokenIsAdmin
  0007e	3a c3		 cmp	 al, bl
  00080	74 07		 je	 SHORT $LN2@IsVolumeAc

; 3808 : 	{
; 3809 : 		result = TRUE;

  00082	bb 01 00 00 00	 mov	 ebx, 1

; 3810 : 		goto ret;

  00087	eb 3c		 jmp	 SHORT $ret$31884
$LN2@IsVolumeAc:

; 3811 : 	}
; 3812 : 
; 3813 : 	if (!NT_SUCCESS (SeQueryInformationToken (accessToken, TokenUser, &tokenUser)))

  00089	4c 8d 44 24 58	 lea	 r8, QWORD PTR tokenUser$[rsp]
  0008e	ba 01 00 00 00	 mov	 edx, 1
  00093	48 8b cf	 mov	 rcx, rdi
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeQueryInformationToken
  0009c	3b c3		 cmp	 eax, ebx
  0009e	7c 25		 jl	 SHORT $ret$31884

; 3814 : 		goto ret;
; 3815 : 
; 3816 : 	result = RtlEqualSid (volumeDeviceExtension->UserSid, tokenUser->User.Sid);

  000a0	48 8b 54 24 58	 mov	 rdx, QWORD PTR tokenUser$[rsp]
  000a5	48 8b 8e 88 05
	00 00		 mov	 rcx, QWORD PTR [rsi+1416]
  000ac	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlEqualSid

; 3817 : 	ExFreePool (tokenUser);		// Documented in newer versions of WDK

  000b5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tokenUser$[rsp]
  000ba	33 d2		 xor	 edx, edx
  000bc	0f b6 d8	 movzx	 ebx, al
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$ret$31884:

; 3818 : 
; 3819 : ret:
; 3820 : 	SeReleaseSubjectContext (&subContext);

  000c5	48 8d 4c 24 20	 lea	 rcx, QWORD PTR subContext$[rsp]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeReleaseSubjectContext

; 3821 : 	return result;

  000d0	8b c3		 mov	 eax, ebx
  000d2	eb 05		 jmp	 SHORT $LN6@IsVolumeAc
$LN4@IsVolumeAc:

; 3797 : 	{
; 3798 : 		return TRUE;

  000d4	b8 01 00 00 00	 mov	 eax, 1
$LN6@IsVolumeAc:

; 3822 : }

  000d9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000de	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000e3	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e7	5f		 pop	 rdi
  000e8	c3		 ret	 0
IsVolumeAccessibleByCurrentUser ENDP
_TEXT	ENDS
PUBLIC	GetDeviceSectorSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetDeviceSectorSize DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$GetDeviceSectorSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetDeviceSectorSize DD 020601H
	DD	030029206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetDeviceSectorSize
_TEXT	SEGMENT
geometry$ = 48
deviceObject$ = 96
bytesPerSector$ = 104
GetDeviceSectorSize PROC				; COMDAT

; 3671 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 3672 : 	NTSTATUS status;
; 3673 : 	DISK_GEOMETRY geometry;
; 3674 : 
; 3675 : 	status = SendDeviceIoControlRequest (deviceObject, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry));

  00006	48 8d 44 24 30	 lea	 rax, QWORD PTR geometry$[rsp]
  0000b	48 8b da	 mov	 rbx, rdx
  0000e	45 33 c9	 xor	 r9d, r9d
  00011	45 33 c0	 xor	 r8d, r8d
  00014	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  00019	c7 44 24 28 18
	00 00 00	 mov	 DWORD PTR [rsp+40], 24
  00021	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00026	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 3676 : 
; 3677 : 	if (!NT_SUCCESS (status))

  0002b	85 c0		 test	 eax, eax

; 3678 : 		return status;

  0002d	78 08		 js	 SHORT $LN2@GetDeviceS

; 3679 : 
; 3680 : 	*bytesPerSector = geometry.BytesPerSector;

  0002f	8b 44 24 44	 mov	 eax, DWORD PTR geometry$[rsp+20]
  00033	89 03		 mov	 DWORD PTR [rbx], eax

; 3681 : 	return STATUS_SUCCESS;

  00035	33 c0		 xor	 eax, eax
$LN2@GetDeviceS:

; 3682 : }

  00037	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
GetDeviceSectorSize ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	MountManagerUnmount
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountManagerUnmount DD imagerel $LN3
	DD	imagerel $LN3+171
	DD	imagerel $unwind$MountManagerUnmount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountManagerUnmount DD 031b19H
	DD	04e0109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0260H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT MountManagerUnmount
_TEXT	SEGMENT
buf$ = 48
out$ = 304
__$ArrayPad$ = 608
nDosDriveNo$ = 640
MountManagerUnmount PROC				; COMDAT

; 2838 : {

$LN3:
  00000	40 57		 push	 rdi
  00002	48 81 ec 70 02
	00 00		 sub	 rsp, 624		; 00000270H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001b	8b f9		 mov	 edi, ecx

; 2839 : 	NTSTATUS ntStatus; 
; 2840 : 	char buf[256], out[300];
; 2841 : 	PMOUNTMGR_MOUNT_POINT in = (PMOUNTMGR_MOUNT_POINT) buf;
; 2842 : 
; 2843 : 	memset (buf, 0, sizeof buf);

  0001d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00022	33 d2		 xor	 edx, edx
  00024	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0002a	e8 00 00 00 00	 call	 memset

; 2844 : 
; 2845 : 	GSTGetDosNameFromNumber ((PWSTR) &in[1], nDosDriveNo);

  0002f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR buf$[rsp+24]
  00034	8b d7		 mov	 edx, edi
  00036	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 2846 : 
; 2847 : 	// Only symbolic link can be deleted with IOCTL_MOUNTMGR_DELETE_POINTS. If any other entry is specified, the mount manager will ignore subsequent IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for the same volume ID.
; 2848 : 	in->SymbolicLinkNameOffset = sizeof (MOUNTMGR_MOUNT_POINT);
; 2849 : 	in->SymbolicLinkNameLength = (USHORT) wcslen ((PWCHAR) &in[1]) * 2;

  0003b	48 83 c9 ff	 or	 rcx, -1
  0003f	33 c0		 xor	 eax, eax
  00041	c7 44 24 30 18
	00 00 00	 mov	 DWORD PTR buf$[rsp], 24
  00049	48 8d 7c 24 48	 lea	 rdi, QWORD PTR buf$[rsp+24]

; 2850 : 
; 2851 : 	ntStatus = GSTDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_DELETE_POINTS,
; 2852 : 		in, sizeof(MOUNTMGR_MOUNT_POINT) + in->SymbolicLinkNameLength, out, sizeof out);

  0004e	4c 8d 44 24 30	 lea	 r8, QWORD PTR buf$[rsp]
  00053	66 f2 af	 repne scasw
  00056	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR out$[rsp]
  0005e	ba 04 c0 6d 00	 mov	 edx, 7192580		; 006dc004H
  00063	48 f7 d1	 not	 rcx
  00066	c7 44 24 28 2c
	01 00 00	 mov	 DWORD PTR [rsp+40], 300	; 0000012cH
  0006e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00073	48 ff c9	 dec	 rcx
  00076	66 03 c9	 add	 cx, cx

; 2853 : 
; 2854 : 	Dump ("IOCTL_MOUNTMGR_DELETE_POINTS returned 0x%08x\n", ntStatus);
; 2855 : 
; 2856 : 	return ntStatus;

  00079	44 0f b7 c9	 movzx	 r9d, cx
  0007d	66 89 4c 24 34	 mov	 WORD PTR buf$[rsp+4], cx
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00089	41 83 c1 18	 add	 r9d, 24
  0008d	e8 00 00 00 00	 call	 GSTDeviceIoControl

; 2857 : }

  00092	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009a	48 33 cc	 xor	 rcx, rsp
  0009d	e8 00 00 00 00	 call	 __security_check_cookie
  000a2	48 81 c4 70 02
	00 00		 add	 rsp, 624		; 00000270H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
MountManagerUnmount ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	MountManagerMount
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountManagerMount DD imagerel $LN5
	DD	imagerel $LN5+415
	DD	imagerel $unwind$MountManagerMount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountManagerMount DD 092919H
	DD	06b6417H
	DD	06a5417H
	DD	0693417H
	DD	0660117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0320H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT MountManagerMount
_TEXT	SEGMENT
devName$ = 48
symName$ = 64
buf$ = 80
arrVolume$ = 288
__$ArrayPad$ = 800
mount$ = 832
MountManagerMount PROC					; COMDAT

; 2793 : {

$LN5:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 30 03
	00 00		 sub	 rsp, 816		; 00000330H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2794 : 	NTSTATUS ntStatus; 
; 2795 : 	WCHAR arrVolume[256];
; 2796 : 	char buf[200];
; 2797 : 	PMOUNTMGR_TARGET_NAME in = (PMOUNTMGR_TARGET_NAME) buf;
; 2798 : 	PMOUNTMGR_CREATE_POINT_INPUT point = (PMOUNTMGR_CREATE_POINT_INPUT) buf;
; 2799 : 	UNICODE_STRING symName, devName;
; 2800 : 
; 2801 : 	GSTGetNTNameFromNumber (arrVolume, mount->nDosDriveNo);

  00029	8b 91 64 02 00
	00		 mov	 edx, DWORD PTR [rcx+612]
  0002f	48 8b d9	 mov	 rbx, rcx
  00032	49 8d 8b e8 fd
	ff ff		 lea	 rcx, QWORD PTR [r11-536]
  00039	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 2802 : 	in->DeviceNameLength = (USHORT) wcslen (arrVolume) * 2;

  0003e	33 c0		 xor	 eax, eax
  00040	48 83 cd ff	 or	 rbp, -1
  00044	48 8d bc 24 20
	01 00 00	 lea	 rdi, QWORD PTR arrVolume$[rsp]
  0004c	48 8b cd	 mov	 rcx, rbp
  0004f	66 f2 af	 repne scasw
  00052	48 f7 d1	 not	 rcx
  00055	48 ff c9	 dec	 rcx
  00058	0f b7 c1	 movzx	 eax, cx
  0005b	66 03 c0	 add	 ax, ax

; 2803 : 	wcscpy(in->DeviceName, arrVolume);

  0005e	33 f6		 xor	 esi, esi
  00060	48 8b d6	 mov	 rdx, rsi
  00063	66 89 44 24 50	 mov	 WORD PTR buf$[rsp], ax
$LL3@MountManag:
  00068	0f b7 84 14 20
	01 00 00	 movzx	 eax, WORD PTR arrVolume$[rsp+rdx]
  00070	48 83 c2 02	 add	 rdx, 2
  00074	66 89 44 14 50	 mov	 WORD PTR buf$[rsp+rdx], ax
  00079	66 3b c6	 cmp	 ax, si
  0007c	75 ea		 jne	 SHORT $LL3@MountManag

; 2804 : 
; 2805 : 	ntStatus = GSTDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
; 2806 : 		in, (ULONG) (sizeof (in->DeviceNameLength) + wcslen (arrVolume) * 2), 0, 0);

  0007e	44 8d 4c 09 02	 lea	 r9d, DWORD PTR [rcx+rcx+2]
  00083	4c 8d 44 24 50	 lea	 r8, QWORD PTR buf$[rsp]
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0008f	ba 2c 40 6d 00	 mov	 edx, 7159852		; 006d402cH
  00094	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00098	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0009d	e8 00 00 00 00	 call	 GSTDeviceIoControl

; 2807 : 
; 2808 : 	memset (buf, 0, sizeof buf);

  000a2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  000a7	33 d2		 xor	 edx, edx
  000a9	41 b8 c8 00 00
	00		 mov	 r8d, 200		; 000000c8H
  000af	e8 00 00 00 00	 call	 memset

; 2809 : 	GSTGetDosNameFromNumber ((PWSTR) &point[1], mount->nDosDriveNo);

  000b4	8b 93 64 02 00
	00		 mov	 edx, DWORD PTR [rbx+612]
  000ba	48 8d 4c 24 58	 lea	 rcx, QWORD PTR buf$[rsp+8]
  000bf	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 2810 : 
; 2811 : 	point->SymbolicLinkNameOffset = sizeof (MOUNTMGR_CREATE_POINT_INPUT);

  000c4	ba 08 00 00 00	 mov	 edx, 8

; 2812 : 	point->SymbolicLinkNameLength = (USHORT) wcslen ((PWSTR) &point[1]) * 2;

  000c9	33 c0		 xor	 eax, eax
  000cb	66 89 54 24 50	 mov	 WORD PTR buf$[rsp], dx
  000d0	48 8d 7c 24 58	 lea	 rdi, QWORD PTR buf$[rsp+8]
  000d5	48 8b cd	 mov	 rcx, rbp
  000d8	66 f2 af	 repne scasw

; 2813 : 
; 2814 : 	RtlInitUnicodeString(&symName, (PWSTR) (buf + point->SymbolicLinkNameOffset));

  000db	48 8d 54 24 58	 lea	 rdx, QWORD PTR buf$[rsp+8]
  000e0	48 f7 d1	 not	 rcx
  000e3	48 ff c9	 dec	 rcx
  000e6	66 03 c9	 add	 cx, cx
  000e9	66 89 4c 24 52	 mov	 WORD PTR buf$[rsp+2], cx
  000ee	48 8d 4c 24 40	 lea	 rcx, QWORD PTR symName$[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2815 : 
; 2816 : 	point->DeviceNameOffset = point->SymbolicLinkNameOffset + point->SymbolicLinkNameLength;

  000f9	0f b7 54 24 52	 movzx	 edx, WORD PTR buf$[rsp+2]
  000fe	66 03 54 24 50	 add	 dx, WORD PTR buf$[rsp]

; 2817 : 	GSTGetNTNameFromNumber ((PWSTR) (buf + point->DeviceNameOffset), mount->nDosDriveNo);

  00103	0f b7 c2	 movzx	 eax, dx
  00106	66 89 54 24 54	 mov	 WORD PTR buf$[rsp+4], dx
  0010b	8b 93 64 02 00
	00		 mov	 edx, DWORD PTR [rbx+612]
  00111	48 8d 4c 04 50	 lea	 rcx, QWORD PTR buf$[rsp+rax]
  00116	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 2818 : 	point->DeviceNameLength = (USHORT) wcslen ((PWSTR) (buf + point->DeviceNameOffset)) * 2;

  0011b	0f b7 54 24 54	 movzx	 edx, WORD PTR buf$[rsp+4]
  00120	33 c0		 xor	 eax, eax
  00122	48 8d 54 14 50	 lea	 rdx, QWORD PTR buf$[rsp+rdx]
  00127	48 8b cd	 mov	 rcx, rbp
  0012a	48 8b fa	 mov	 rdi, rdx
  0012d	66 f2 af	 repne scasw
  00130	48 f7 d1	 not	 rcx
  00133	48 ff c9	 dec	 rcx
  00136	66 03 c9	 add	 cx, cx
  00139	66 89 4c 24 56	 mov	 WORD PTR buf$[rsp+6], cx

; 2819 : 
; 2820 : 	RtlInitUnicodeString(&devName, (PWSTR) (buf + point->DeviceNameOffset));

  0013e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR devName$[rsp]
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2821 : 
; 2822 : 	ntStatus = GSTDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_CREATE_POINT, point,
; 2823 : 		point->DeviceNameOffset + point->DeviceNameLength, 0, 0);
; 2824 : 
; 2825 : 	return ntStatus;

  00149	44 0f b7 4c 24
	56		 movzx	 r9d, WORD PTR buf$[rsp+6]
  0014f	0f b7 44 24 54	 movzx	 eax, WORD PTR buf$[rsp+4]
  00154	4c 8d 44 24 50	 lea	 r8, QWORD PTR buf$[rsp]
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00160	44 03 c8	 add	 r9d, eax
  00163	ba 00 c0 6d 00	 mov	 edx, 7192576		; 006dc000H
  00168	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0016c	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00171	e8 00 00 00 00	 call	 GSTDeviceIoControl

; 2826 : }

  00176	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0017e	48 33 cc	 xor	 rcx, rsp
  00181	e8 00 00 00 00	 call	 __security_check_cookie
  00186	4c 8d 9c 24 30
	03 00 00	 lea	 r11, QWORD PTR [rsp+816]
  0018e	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  00192	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  00196	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  0019a	49 8b e3	 mov	 rsp, r11
  0019d	5f		 pop	 rdi
  0019e	c3		 ret	 0
MountManagerMount ENDP
_TEXT	ENDS
PUBLIC	ProbeRealDriveSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProbeRealDriveSize DD imagerel $LN21
	DD	imagerel $LN21+292
	DD	imagerel $unwind$ProbeRealDriveSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProbeRealDriveSize DD 0a1801H
	DD	0d6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ProbeRealDriveSize
_TEXT	SEGMENT
driveDeviceObject$ = 80
driveSize$ = 88
sysLength$ = 96
ProbeRealDriveSize PROC					; COMDAT

; 2500 : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fa	 mov	 rdi, rdx
  0001b	48 8b e9	 mov	 rbp, rcx

; 2501 : 	NTSTATUS status;
; 2502 : 	LARGE_INTEGER sysLength;
; 2503 : 	LARGE_INTEGER offset;
; 2504 : 	byte *sectorBuffer;
; 2505 : 	ULONGLONG startTime;
; 2506 : 
; 2507 : 	if (!UserCanAccessDriveDevice())

  0001e	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00023	85 c0		 test	 eax, eax
  00025	75 0a		 jne	 SHORT $LN9@ProbeRealD

; 2508 : 		return STATUS_ACCESS_DENIED;

  00027	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  0002c	e9 da 00 00 00	 jmp	 $LN4@ProbeRealD
$LN9@ProbeRealD:

; 2509 : 
; 2510 : 	sectorBuffer = GSTalloc (GST_SECTOR_SIZE_BIOS);

  00031	41 bd 00 02 00
	00		 mov	 r13d, 512		; 00000200H
  00037	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0003d	33 c9		 xor	 ecx, ecx
  0003f	49 8b d5	 mov	 rdx, r13
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00048	48 8b f0	 mov	 rsi, rax

; 2511 : 	if (!sectorBuffer)

  0004b	48 85 c0	 test	 rax, rax
  0004e	75 0a		 jne	 SHORT $LN8@ProbeRealD

; 2512 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00050	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00055	e9 b1 00 00 00	 jmp	 $LN4@ProbeRealD
$LN8@ProbeRealD:

; 2513 : 
; 2514 : 	status = SendDeviceIoControlRequest (driveDeviceObject, IOCTL_DISK_GET_LENGTH_INFO,
; 2515 : 		NULL, 0, &sysLength, sizeof (sysLength));

  0005a	48 8d 44 24 60	 lea	 rax, QWORD PTR sysLength$[rsp]
  0005f	45 33 c9	 xor	 r9d, r9d
  00062	45 33 c0	 xor	 r8d, r8d
  00065	ba 5c 40 07 00	 mov	 edx, 475228		; 0007405cH
  0006a	48 8b cd	 mov	 rcx, rbp
  0006d	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  00075	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007a	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0007f	8b d8		 mov	 ebx, eax

; 2516 : 
; 2517 : 	if (!NT_SUCCESS (status))

  00081	85 c0		 test	 eax, eax
  00083	78 76		 js	 SHORT $LN20@ProbeRealD

; 2518 : 	{
; 2519 : 		Dump ("Failed to get drive size - error %x\n", status);
; 2520 : 		GSTfree (sectorBuffer);
; 2521 : 		return status;
; 2522 : 	}
; 2523 : 
; 2524 : 	startTime = KeQueryInterruptTime ();

  00085	49 bc 08 00 00
	00 80 f7 ff ff	 mov	 r12, -9345848836088	; fffff78000000008H
  0008f	4d 8b 24 24	 mov	 r12, QWORD PTR [r12]

; 2525 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += GST_SECTOR_SIZE_BIOS)

  00093	48 8b 5c 24 60	 mov	 rbx, QWORD PTR sysLength$[rsp]
$LL6@ProbeRealD:

; 2526 : 	{
; 2527 : 		status = GSTReadDevice (driveDeviceObject, sectorBuffer, offset, GST_SECTOR_SIZE_BIOS);

  00098	4c 8b cb	 mov	 r9, rbx
  0009b	4c 8b c6	 mov	 r8, rsi
  0009e	48 8b d5	 mov	 rdx, rbp
  000a1	33 c9		 xor	 ecx, ecx
  000a3	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  000a8	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 2528 : 		
; 2529 : 		if (NT_SUCCESS (status))

  000ad	85 c0		 test	 eax, eax
  000af	78 45		 js	 SHORT $LN18@ProbeRealD

; 2530 : 			status = GSTWriteDevice (driveDeviceObject, sectorBuffer, offset, GST_SECTOR_SIZE_BIOS);

  000b1	4c 8b cb	 mov	 r9, rbx
  000b4	4c 8b c6	 mov	 r8, rsi
  000b7	48 8b d5	 mov	 rdx, rbp
  000ba	b9 01 00 00 00	 mov	 ecx, 1
  000bf	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  000c4	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 2531 : 
; 2532 : 		if (!NT_SUCCESS (status))

  000c9	85 c0		 test	 eax, eax
  000cb	78 29		 js	 SHORT $LN18@ProbeRealD

; 2535 : 			Dump ("Real drive size = %I64d bytes (%I64d hidden)\n", driveSize->QuadPart, driveSize->QuadPart - sysLength.QuadPart);
; 2536 : 			GSTfree (sectorBuffer);
; 2537 : 			return STATUS_SUCCESS;
; 2538 : 		}
; 2539 : 
; 2540 : 		if (KeQueryInterruptTime() - startTime > 3ULL * 60 * 1000 * 1000 * 10)

  000cd	48 a1 08 00 00
	00 80 f7 ff ff	 mov	 rax, QWORD PTR ds:-9345848836088
  000d7	49 2b c4	 sub	 rax, r12
  000da	48 3d 00 d2 49
	6b		 cmp	 rax, 1800000000		; 6b49d200H
  000e0	77 05		 ja	 SHORT $LN19@ProbeRealD

; 2525 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += GST_SECTOR_SIZE_BIOS)

  000e2	49 03 dd	 add	 rbx, r13
  000e5	eb b1		 jmp	 SHORT $LL6@ProbeRealD
$LN19@ProbeRealD:

; 2541 : 		{
; 2542 : 			// Abort if probing for more than 3 minutes
; 2543 : 			driveSize->QuadPart = sysLength.QuadPart;

  000e7	48 8b 44 24 60	 mov	 rax, QWORD PTR sysLength$[rsp]
  000ec	bb 02 01 00 00	 mov	 ebx, 258		; 00000102H
  000f1	48 89 07	 mov	 QWORD PTR [rdi], rax
  000f4	eb 05		 jmp	 SHORT $LN20@ProbeRealD
$LN18@ProbeRealD:

; 2533 : 		{
; 2534 : 			driveSize->QuadPart = offset.QuadPart;

  000f6	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  000f9	33 db		 xor	 ebx, ebx
$LN20@ProbeRealD:
  000fb	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00100	48 8b ce	 mov	 rcx, rsi
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
  00109	8b c3		 mov	 eax, ebx
$LN4@ProbeRealD:

; 2544 : 			GSTfree (sectorBuffer);
; 2545 : 			return STATUS_TIMEOUT;
; 2546 : 		}
; 2547 : 	}
; 2548 : }

  0010b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00110	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00115	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0011a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011e	41 5d		 pop	 r13
  00120	41 5c		 pop	 r12
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0
ProbeRealDriveSize ENDP
_TEXT	ENDS
PUBLIC	GSTUnloadDriver
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
pdata	SEGMENT
$pdata$GSTUnloadDriver DD imagerel $LN10
	DD	imagerel $LN10+91
	DD	imagerel $unwind$GSTUnloadDriver
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTUnloadDriver DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
xdata	ENDS
;	COMDAT GSTUnloadDriver
_TEXT	SEGMENT
DriverObject$ = 64
GSTUnloadDriver PROC					; COMDAT

; 2304 : {

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2305 : 	Dump ("GSTUnloadDriver BEGIN\n");
; 2306 : 
; 2307 : 	OnShutdownPending();

  00004	e8 00 00 00 00	 call	 OnShutdownPending

; 2308 : 
; 2309 : 	if (IsBootDriveMounted())

  00009	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR BootDriveFilterExtension
  00010	4d 85 db	 test	 r11, r11
  00013	74 2d		 je	 SHORT $LN1@GSTUnloadD
  00015	41 83 bb b8 02
	00 00 00	 cmp	 DWORD PTR [r11+696], 0
  0001d	74 23		 je	 SHORT $LN1@GSTUnloadD

; 2310 : 		GST_BUG_CHECK (STATUS_INVALID_DEVICE_STATE);

  0001f	45 33 c9	 xor	 r9d, r9d
  00022	ba 06 09 00 00	 mov	 edx, 2310		; 00000906H
  00027	49 c7 c0 84 01
	00 c0		 mov	 r8, -1073741436		; ffffffffc0000184H
  0002e	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00032	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00041	cc		 int	 3
$LN1@GSTUnloadD:

; 2311 : 
; 2312 : 	EncryptionThreadPoolStop();

  00042	e8 00 00 00 00	 call	 EncryptionThreadPoolStop

; 2313 : 	GSTDeleteDeviceObject (RootDeviceObject, (PEXTENSION) RootDeviceObject->DeviceExtension);

  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0004e	48 8b 51 40	 mov	 rdx, QWORD PTR [rcx+64]

; 2314 : 
; 2315 : 	Dump ("GSTUnloadDriver END\n");
; 2316 : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	e9 00 00 00 00	 jmp	 GSTDeleteDeviceObject
$LN9@GSTUnloadD:
GSTUnloadDriver ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	ProcessVolumeDeviceControlIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessVolumeDeviceControlIrp DD imagerel $LN68
	DD	imagerel $LN68+1545
	DD	imagerel $unwind$ProcessVolumeDeviceControlIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessVolumeDeviceControlIrp DD 092819H
	DD	0695416H
	DD	0663416H
	DD	0620116H
	DD	0c00dd00fH
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0300H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ProcessVolumeDeviceControlIrp
_TEXT	SEGMENT
tmp$30497 = 80
offset$30579 = 88
ntUnicodeString$30512 = 88
ntUnicodeString$30479 = 88
ioStatus$30573 = 104
volId$30496 = 128
ntName$30513 = 256
ntName$30480 = 256
__$ArrayPad$ = 768
DeviceObject$ = 816
Extension$ = 824
Irp$ = 832
ProcessVolumeDeviceControlIrp PROC			; COMDAT

; 591  : {

$LN68:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 81 ec 10 03
	00 00		 sub	 rsp, 784		; 00000310H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 00
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 592  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00028	4d 8b a0 b8 00
	00 00		 mov	 r12, QWORD PTR [r8+184]

; 593  : 
; 594  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0002f	b9 5c 40 07 00	 mov	 ecx, 475228		; 0007405cH
  00034	49 8b d8	 mov	 rbx, r8
  00037	41 8b 44 24 18	 mov	 eax, DWORD PTR [r12+24]
  0003c	48 8b fa	 mov	 rdi, rdx
  0003f	3b c1		 cmp	 eax, ecx
  00041	0f 87 03 03 00
	00		 ja	 $LN50@ProcessVol
  00047	0f 84 c0 02 00
	00		 je	 $LN22@ProcessVol
  0004d	2d 00 00 07 00	 sub	 eax, 458752		; 00070000H
  00052	0f 84 53 02 00
	00		 je	 $LN30@ProcessVol
  00058	83 e8 14	 sub	 eax, 20
  0005b	0f 84 52 01 00
	00		 je	 $LN19@ProcessVol
  00061	83 e8 10	 sub	 eax, 16
  00064	0f 84 2b 01 00
	00		 je	 $LN10@ProcessVol
  0006a	83 e8 24	 sub	 eax, 36			; 00000024H
  0006d	0f 84 ca 00 00
	00		 je	 $LN26@ProcessVol
  00073	2d b8 0b 00 00	 sub	 eax, 3000		; 00000bb8H
  00078	0f 84 2d 02 00
	00		 je	 $LN30@ProcessVol
  0007e	2d 04 34 00 00	 sub	 eax, 13316		; 00003404H
  00083	74 66		 je	 SHORT $LN28@ProcessVol
  00085	83 f8 08	 cmp	 eax, 8
  00088	0f 85 01 03 00
	00		 jne	 $LN1@ProcessVol

; 760  : 
; 761  : 	case IOCTL_DISK_GET_DRIVE_LAYOUT:
; 762  : 		if (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION), ValidateOutput))

  0008e	8d 50 20	 lea	 edx, QWORD PTR [rax+32]
  00091	44 8d 40 f9	 lea	 r8d, QWORD PTR [rax-7]
  00095	48 8b cb	 mov	 rcx, rbx
  00098	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0009d	85 c0		 test	 eax, eax
  0009f	0f 84 28 05 00
	00		 je	 $LN11@ProcessVol

; 763  : 		{
; 764  : 			PDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION)
; 765  : 			Irp->AssociatedIrp.SystemBuffer;

  000a5	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]

; 766  : 
; 767  : 			outputBuffer->PartitionCount = 1;
; 768  : 			outputBuffer->Signature = 0;
; 769  : 
; 770  : 			outputBuffer->PartitionEntry->PartitionType = Extension->PartitionType;
; 771  : 			outputBuffer->PartitionEntry->BootIndicator = FALSE;
; 772  : 			outputBuffer->PartitionEntry->RecognizedPartition = TRUE;
; 773  : 			outputBuffer->PartitionEntry->RewritePartition = FALSE;
; 774  : 			outputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;
; 775  : 			outputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;
; 776  : 			outputBuffer->PartitionEntry->HiddenSectors = 0;
; 777  : 
; 778  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 779  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);

  000a9	bd 20 00 00 00	 mov	 ebp, 32			; 00000020H
  000ae	83 61 04 00	 and	 DWORD PTR [rcx+4], 0
  000b2	c7 01 01 00 00
	00		 mov	 DWORD PTR [rcx], 1
  000b8	8a 87 bc 00 00
	00		 mov	 al, BYTE PTR [rdi+188]
  000be	88 41 20	 mov	 BYTE PTR [rcx+32], al
  000c1	c6 41 21 00	 mov	 BYTE PTR [rcx+33], 0
  000c5	c6 41 22 01	 mov	 BYTE PTR [rcx+34], 1
  000c9	c6 41 23 00	 mov	 BYTE PTR [rcx+35], 0
  000cd	8b 87 b8 00 00
	00		 mov	 eax, DWORD PTR [rdi+184]
  000d3	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  000d7	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  000de	83 61 18 00	 and	 DWORD PTR [rcx+24], 0
  000e2	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 780  : 		}
; 781  : 		break;

  000e6	e9 15 02 00 00	 jmp	 $LN63@ProcessVol
$LN28@ProcessVol:

; 724  : 
; 725  : 	case IOCTL_DISK_GET_PARTITION_INFO:
; 726  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION), ValidateOutput))

  000eb	bd 20 00 00 00	 mov	 ebp, 32			; 00000020H
  000f0	48 8b cb	 mov	 rcx, rbx
  000f3	44 8d 45 e1	 lea	 r8d, QWORD PTR [rbp-31]
  000f7	48 8b d5	 mov	 rdx, rbp
  000fa	e8 00 00 00 00	 call	 ValidateIOBufferSize
  000ff	85 c0		 test	 eax, eax
  00101	0f 84 c6 04 00
	00		 je	 $LN11@ProcessVol

; 727  : 		{
; 728  : 			PPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)
; 729  : 			Irp->AssociatedIrp.SystemBuffer;
; 730  : 
; 731  : 			outputBuffer->PartitionType = Extension->PartitionType;

  00107	8a 87 bc 00 00
	00		 mov	 al, BYTE PTR [rdi+188]
  0010d	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00111	88 41 18	 mov	 BYTE PTR [rcx+24], al

; 732  : 			outputBuffer->BootIndicator = FALSE;

  00114	c6 41 19 00	 mov	 BYTE PTR [rcx+25], 0

; 733  : 			outputBuffer->RecognizedPartition = TRUE;

  00118	c6 41 1a 01	 mov	 BYTE PTR [rcx+26], 1

; 734  : 			outputBuffer->RewritePartition = FALSE;

  0011c	c6 41 1b 00	 mov	 BYTE PTR [rcx+27], 0

; 735  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  00120	8b 87 b8 00 00
	00		 mov	 eax, DWORD PTR [rdi+184]
  00126	48 89 01	 mov	 QWORD PTR [rcx], rax

; 736  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  00129	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]

; 737  : 			outputBuffer->HiddenSectors = 0;

  00130	83 61 10 00	 and	 DWORD PTR [rcx+16], 0
  00134	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 738  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 739  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);
; 740  : 		}
; 741  : 		break;

  00138	e9 c3 01 00 00	 jmp	 $LN63@ProcessVol
$LN26@ProcessVol:

; 742  : 
; 743  : 	case IOCTL_DISK_GET_PARTITION_INFO_EX:
; 744  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION_EX), ValidateOutput))

  0013d	bd 90 00 00 00	 mov	 ebp, 144		; 00000090H
  00142	41 b8 01 00 00
	00		 mov	 r8d, 1
  00148	48 8b cb	 mov	 rcx, rbx
  0014b	48 8b d5	 mov	 rdx, rbp
  0014e	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00153	85 c0		 test	 eax, eax
  00155	0f 84 72 04 00
	00		 je	 $LN11@ProcessVol

; 745  : 		{
; 746  : 			PPARTITION_INFORMATION_EX outputBuffer = (PPARTITION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;

  0015b	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]

; 747  : 
; 748  : 			outputBuffer->PartitionStyle = PARTITION_STYLE_MBR;

  0015f	83 21 00	 and	 DWORD PTR [rcx], 0

; 749  : 			outputBuffer->RewritePartition = FALSE;

  00162	c6 41 1c 00	 mov	 BYTE PTR [rcx+28], 0

; 750  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  00166	8b 87 b8 00 00
	00		 mov	 eax, DWORD PTR [rdi+184]
  0016c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 751  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  00170	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  00177	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 752  : 			outputBuffer->Mbr.PartitionType = Extension->PartitionType;

  0017b	8a 87 bc 00 00
	00		 mov	 al, BYTE PTR [rdi+188]

; 753  : 			outputBuffer->Mbr.BootIndicator = FALSE;
; 754  : 			outputBuffer->Mbr.RecognizedPartition = TRUE;
; 755  : 			outputBuffer->Mbr.HiddenSectors = 0;

  00181	83 61 24 00	 and	 DWORD PTR [rcx+36], 0
  00185	88 41 20	 mov	 BYTE PTR [rcx+32], al
  00188	c6 41 21 00	 mov	 BYTE PTR [rcx+33], 0
  0018c	c6 41 22 01	 mov	 BYTE PTR [rcx+34], 1

; 756  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 757  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION_EX);
; 758  : 		}
; 759  : 		break;

  00190	e9 6b 01 00 00	 jmp	 $LN63@ProcessVol
$LN10@ProcessVol:

; 843  : 			}
; 844  : 		}
; 845  : 		break;
; 846  : 
; 847  : 	case IOCTL_DISK_IS_WRITABLE:
; 848  : 		{
; 849  : 			if (Extension->bReadOnly)

  00195	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [rdx+832]
  0019b	f7 d8		 neg	 eax
  0019d	1b c9		 sbb	 ecx, ecx
  0019f	81 e1 a2 00 00
	c0		 and	 ecx, -1073741662	; ffffffffc00000a2H
  001a5	41 89 48 30	 mov	 DWORD PTR [r8+48], ecx
$LN66@ProcessVol:

; 850  : 				Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;
; 851  : 			else
; 852  : 				Irp->IoStatus.Status = STATUS_SUCCESS;
; 853  : 			Irp->IoStatus.Information = 0;

  001a9	49 83 60 38 00	 and	 QWORD PTR [r8+56], 0

; 854  : 
; 855  : 		}
; 856  : 		break;

  001ae	e9 1a 04 00 00	 jmp	 $LN11@ProcessVol
$LN19@ProcessVol:

; 798  : 
; 799  : 	case IOCTL_DISK_VERIFY:
; 800  : 		if (ValidateIOBufferSize (Irp, sizeof (VERIFY_INFORMATION), ValidateInput))

  001b3	45 33 c0	 xor	 r8d, r8d
  001b6	48 8b cb	 mov	 rcx, rbx
  001b9	41 8d 50 10	 lea	 edx, QWORD PTR [r8+16]
  001bd	e8 00 00 00 00	 call	 ValidateIOBufferSize
  001c2	85 c0		 test	 eax, eax
  001c4	0f 84 03 04 00
	00		 je	 $LN11@ProcessVol

; 801  : 		{
; 802  : 			PVERIFY_INFORMATION pVerifyInformation;
; 803  : 			pVerifyInformation = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

  001ca	48 8b 6b 18	 mov	 rbp, QWORD PTR [rbx+24]

; 804  : 
; 805  : 			if (pVerifyInformation->StartingOffset.QuadPart + pVerifyInformation->Length > Extension->DiskLength)

  001ce	8b 4d 08	 mov	 ecx, DWORD PTR [rbp+8]
  001d1	48 8b c1	 mov	 rax, rcx
  001d4	48 03 45 00	 add	 rax, QWORD PTR [rbp]
  001d8	48 3b 87 a0 00
	00 00		 cmp	 rax, QWORD PTR [rdi+160]

; 806  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 807  : 			else

  001df	0f 8f 43 02 00
	00		 jg	 $LN58@ProcessVol

; 808  : 			{
; 809  : 				IO_STATUS_BLOCK ioStatus;
; 810  : 				PVOID buffer = GSTalloc (max (pVerifyInformation->Length, PAGE_SIZE));

  001e5	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  001ea	41 bd 54 43 4d
	4d		 mov	 r13d, 1296909140	; 4d4d4354H
  001f0	3b c8		 cmp	 ecx, eax
  001f2	45 8b c5	 mov	 r8d, r13d
  001f5	0f 47 c1	 cmova	 eax, ecx
  001f8	33 c9		 xor	 ecx, ecx
  001fa	8b d0		 mov	 edx, eax
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00202	4c 8b e0	 mov	 r12, rax

; 811  : 				
; 812  : 				if (!buffer)

  00205	48 85 c0	 test	 rax, rax
  00208	75 0c		 jne	 SHORT $LN15@ProcessVol

; 813  : 				{
; 814  : 					Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  0020a	c7 43 30 9a 00
	00 c0		 mov	 DWORD PTR [rbx+48], -1073741670 ; ffffffffc000009aH

; 815  : 				}
; 816  : 				else

  00211	e9 19 02 00 00	 jmp	 $LN13@ProcessVol
$LN15@ProcessVol:

; 817  : 				{
; 818  : 					LARGE_INTEGER offset = pVerifyInformation->StartingOffset;

  00216	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]

; 819  : 					offset.QuadPart += Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset;

  0021a	48 8b 8f 90 00
	00 00		 mov	 rcx, QWORD PTR [rdi+144]
  00221	48 89 44 24 58	 mov	 QWORD PTR offset$30579[rsp], rax
  00226	83 b9 48 04 00
	00 00		 cmp	 DWORD PTR [rcx+1096], 0
  0022d	74 09		 je	 SHORT $LN48@ProcessVol
  0022f	48 8b 91 c0 1e
	00 00		 mov	 rdx, QWORD PTR [rcx+7872]
  00236	eb 07		 jmp	 SHORT $LN49@ProcessVol
$LN48@ProcessVol:
  00238	48 8b 91 b0 1e
	00 00		 mov	 rdx, QWORD PTR [rcx+7856]
$LN49@ProcessVol:

; 820  : 
; 821  : 					Irp->IoStatus.Status = ZwReadFile (Extension->hDeviceFile, NULL, NULL, NULL, &ioStatus, buffer, pVerifyInformation->Length, &offset, NULL);

  0023f	48 83 64 24 40
	00		 and	 QWORD PTR [rsp+64], 0
  00245	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]
  00249	48 03 c2	 add	 rax, rdx
  0024c	48 89 44 24 58	 mov	 QWORD PTR offset$30579[rsp], rax
  00251	48 8d 44 24 58	 lea	 rax, QWORD PTR offset$30579[rsp]
  00256	45 33 c9	 xor	 r9d, r9d
  00259	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0025e	8b 45 08	 mov	 eax, DWORD PTR [rbp+8]
  00261	45 33 c0	 xor	 r8d, r8d
  00264	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00268	48 8d 44 24 68	 lea	 rax, QWORD PTR ioStatus$30573[rsp]
  0026d	33 d2		 xor	 edx, edx
  0026f	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00274	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile

; 822  : 					GSTfree (buffer);

  0027f	41 8b d5	 mov	 edx, r13d
  00282	49 8b cc	 mov	 rcx, r12
  00285	89 43 30	 mov	 DWORD PTR [rbx+48], eax
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 823  : 
; 824  : 					if (NT_SUCCESS (Irp->IoStatus.Status) && ioStatus.Information != pVerifyInformation->Length)

  0028e	83 7b 30 00	 cmp	 DWORD PTR [rbx+48], 0
  00292	0f 8c 97 01 00
	00		 jl	 $LN13@ProcessVol
  00298	8b 45 08	 mov	 eax, DWORD PTR [rbp+8]
  0029b	48 39 44 24 70	 cmp	 QWORD PTR ioStatus$30573[rsp+8], rax
  002a0	0f 84 89 01 00
	00		 je	 $LN13@ProcessVol

; 825  : 						Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 826  : 				}
; 827  : 			}
; 828  : 
; 829  : 			Irp->IoStatus.Information = 0;
; 830  : 		}
; 831  : 		break;

  002a6	e9 7d 01 00 00	 jmp	 $LN58@ProcessVol
$LN30@ProcessVol:

; 705  : 
; 706  : 	case IOCTL_DISK_GET_MEDIA_TYPES:
; 707  : 	case IOCTL_DISK_GET_DRIVE_GEOMETRY:
; 708  : 		/* Return the drive geometry for the disk.  Note that we
; 709  : 		   return values which were made up to suit the disk size.  */
; 710  : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY), ValidateOutput))

  002ab	bd 18 00 00 00	 mov	 ebp, 24
  002b0	48 8b cb	 mov	 rcx, rbx
  002b3	44 8d 45 e9	 lea	 r8d, QWORD PTR [rbp-23]
  002b7	48 8b d5	 mov	 rdx, rbp
  002ba	e8 00 00 00 00	 call	 ValidateIOBufferSize
  002bf	85 c0		 test	 eax, eax
  002c1	0f 84 06 03 00
	00		 je	 $LN11@ProcessVol

; 711  : 		{
; 712  : 			PDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY)
; 713  : 			Irp->AssociatedIrp.SystemBuffer;
; 714  : 
; 715  : 			outputBuffer->MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;

  002c7	8b 87 44 03 00
	00		 mov	 eax, DWORD PTR [rdi+836]
  002cd	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  002d1	f7 d8		 neg	 eax
  002d3	1b c9		 sbb	 ecx, ecx
  002d5	83 c1 0c	 add	 ecx, 12
  002d8	89 4a 08	 mov	 DWORD PTR [rdx+8], ecx

; 716  : 			outputBuffer->Cylinders.QuadPart = Extension->NumberOfCylinders;

  002db	48 8b 87 a8 00
	00 00		 mov	 rax, QWORD PTR [rdi+168]
  002e2	48 89 02	 mov	 QWORD PTR [rdx], rax

; 717  : 			outputBuffer->TracksPerCylinder = Extension->TracksPerCylinder;

  002e5	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [rdi+176]
  002eb	89 42 0c	 mov	 DWORD PTR [rdx+12], eax

; 718  : 			outputBuffer->SectorsPerTrack = Extension->SectorsPerTrack;

  002ee	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [rdi+180]
  002f4	89 42 10	 mov	 DWORD PTR [rdx+16], eax

; 719  : 			outputBuffer->BytesPerSector = Extension->BytesPerSector;

  002f7	8b 87 b8 00 00
	00		 mov	 eax, DWORD PTR [rdi+184]
  002fd	89 42 14	 mov	 DWORD PTR [rdx+20], eax
$LN63@ProcessVol:

; 720  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00300	83 63 30 00	 and	 DWORD PTR [rbx+48], 0

; 721  : 			Irp->IoStatus.Information = sizeof (DISK_GEOMETRY);

  00304	48 89 6b 38	 mov	 QWORD PTR [rbx+56], rbp

; 722  : 		}
; 723  : 		break;

  00308	e9 c0 02 00 00	 jmp	 $LN11@ProcessVol
$LN22@ProcessVol:

; 782  : 
; 783  : 	case IOCTL_DISK_GET_LENGTH_INFO:
; 784  : 		if (!ValidateIOBufferSize (Irp, sizeof (GET_LENGTH_INFORMATION), ValidateOutput))

  0030d	ba 08 00 00 00	 mov	 edx, 8
  00312	48 8b cb	 mov	 rcx, rbx
  00315	44 8d 42 f9	 lea	 r8d, QWORD PTR [rdx-7]
  00319	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0031e	85 c0		 test	 eax, eax
  00320	75 09		 jne	 SHORT $LN21@ProcessVol

; 785  : 		{
; 786  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  00322	c7 43 30 05 00
	00 80		 mov	 DWORD PTR [rbx+48], -2147483643 ; ffffffff80000005H

; 787  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);
; 788  : 		}
; 789  : 		else

  00329	eb 12		 jmp	 SHORT $LN65@ProcessVol
$LN21@ProcessVol:

; 790  : 		{
; 791  : 			PGET_LENGTH_INFORMATION outputBuffer = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
; 792  : 
; 793  : 			outputBuffer->Length.QuadPart = Extension->DiskLength;

  0032b	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  00332	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00336	48 89 01	 mov	 QWORD PTR [rcx], rax

; 794  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00339	83 63 30 00	 and	 DWORD PTR [rbx+48], 0
$LN65@ProcessVol:

; 795  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);

  0033d	48 c7 43 38 08
	00 00 00	 mov	 QWORD PTR [rbx+56], 8

; 796  : 		}
; 797  : 		break;

  00345	e9 83 02 00 00	 jmp	 $LN11@ProcessVol
$LN50@ProcessVol:

; 593  : 
; 594  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0034a	2d 00 48 07 00	 sub	 eax, 477184		; 00074800H
  0034f	0f 84 57 02 00
	00		 je	 $LN12@ProcessVol
  00355	2d 00 00 26 00	 sub	 eax, 2490368		; 00260000H
  0035a	0f 84 4c 02 00
	00		 je	 $LN12@ProcessVol
  00360	2d 00 b8 1f 00	 sub	 eax, 2078720		; 001fb800H
  00365	bd 04 00 00 00	 mov	 ebp, 4
  0036a	0f 84 a1 01 00
	00		 je	 $LN37@ProcessVol
  00370	83 e8 08	 sub	 eax, 8
  00373	0f 84 10 01 00
	00		 je	 $LN41@ProcessVol
  00379	2b c5		 sub	 eax, ebp
  0037b	0f 84 8e 00 00
	00		 je	 $LN33@ProcessVol
  00381	2d f4 ff 08 00	 sub	 eax, 589812		; 0008fff4H
  00386	74 33		 je	 SHORT $LN6@ProcessVol
  00388	3d 08 c0 00 00	 cmp	 eax, 49160		; 0000c008H
  0038d	74 22		 je	 SHORT $LN7@ProcessVol
$LN1@ProcessVol:

; 883  : 
; 884  : 	default:
; 885  : 		return GSTCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  0038f	49 83 60 38 00	 and	 QWORD PTR [r8+56], 0
  00394	33 d2		 xor	 edx, edx
  00396	48 8b cb	 mov	 rcx, rbx
  00399	41 c7 40 30 10
	00 00 c0	 mov	 DWORD PTR [r8+48], -1073741808 ; ffffffffc0000010H
  003a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  003a7	b8 10 00 00 c0	 mov	 eax, -1073741808	; ffffffffc0000010H
  003ac	e9 2f 02 00 00	 jmp	 $LN44@ProcessVol
$LN7@ProcessVol:

; 857  : 		
; 858  : 	case IOCTL_VOLUME_ONLINE:
; 859  : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  003b1	41 83 60 30 00	 and	 DWORD PTR [r8+48], 0

; 860  : 		Irp->IoStatus.Information = 0;
; 861  : 		break;

  003b6	e9 ee fd ff ff	 jmp	 $LN66@ProcessVol
$LN6@ProcessVol:

; 862  : 
; 863  : 	case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
; 864  : 
; 865  : 		// Vista's filesystem defragmenter fails if IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS does not succeed.
; 866  : 		if (!(OsMajorVersion == 6 && OsMinorVersion == 0))

  003bb	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR OsMajorVersion, 6
  003c2	75 3e		 jne	 SHORT $LN4@ProcessVol
  003c4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMinorVersion, 0
  003cb	75 35		 jne	 SHORT $LN4@ProcessVol

; 869  : 			Irp->IoStatus.Information = 0;
; 870  : 		}
; 871  : 		else if (ValidateIOBufferSize (Irp, sizeof (VOLUME_DISK_EXTENTS), ValidateOutput))

  003cd	bd 20 00 00 00	 mov	 ebp, 32			; 00000020H
  003d2	48 8b cb	 mov	 rcx, rbx
  003d5	44 8d 45 e1	 lea	 r8d, QWORD PTR [rbp-31]
  003d9	48 8b d5	 mov	 rdx, rbp
  003dc	e8 00 00 00 00	 call	 ValidateIOBufferSize
  003e1	85 c0		 test	 eax, eax
  003e3	0f 84 e4 01 00
	00		 je	 $LN11@ProcessVol

; 872  : 		{
; 873  : 			VOLUME_DISK_EXTENTS *extents = (VOLUME_DISK_EXTENTS *) Irp->AssociatedIrp.SystemBuffer;

  003e9	48 8b 7b 18	 mov	 rdi, QWORD PTR [rbx+24]

; 874  : 
; 875  : 			// No extent data can be returned as this is not a physical drive.
; 876  : 			memset (extents, 0, sizeof (*extents));

  003ed	4c 8b c5	 mov	 r8, rbp
  003f0	33 d2		 xor	 edx, edx
  003f2	48 8b cf	 mov	 rcx, rdi
  003f5	e8 00 00 00 00	 call	 memset

; 877  : 			extents->NumberOfDiskExtents = 0;

  003fa	83 27 00	 and	 DWORD PTR [rdi], 0

; 878  : 
; 879  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 880  : 			Irp->IoStatus.Information = sizeof (*extents);

  003fd	e9 fe fe ff ff	 jmp	 $LN63@ProcessVol
$LN4@ProcessVol:

; 867  : 		{
; 868  : 			Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

  00402	41 c7 40 30 10
	00 00 c0	 mov	 DWORD PTR [r8+48], -1073741808 ; ffffffffc0000010H

; 881  : 		}
; 882  : 		break;

  0040a	e9 9a fd ff ff	 jmp	 $LN66@ProcessVol
$LN33@ProcessVol:

; 667  : 
; 668  : 	case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
; 669  : 		{
; 670  : 			ULONG outLength;
; 671  : 			UNICODE_STRING ntUnicodeString;
; 672  : 			WCHAR ntName[256];
; 673  : 			PMOUNTDEV_SUGGESTED_LINK_NAME outputBuffer = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;

  0040f	4d 8b 68 18	 mov	 r13, QWORD PTR [r8+24]

; 674  : 
; 675  : 			if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_SUGGESTED_LINK_NAME), ValidateOutput))

  00413	ba 06 00 00 00	 mov	 edx, 6
  00418	48 8b cb	 mov	 rcx, rbx
  0041b	44 8d 42 fb	 lea	 r8d, QWORD PTR [rdx-5]
  0041f	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00424	85 c0		 test	 eax, eax
  00426	75 11		 jne	 SHORT $LN32@ProcessVol
$LN58@ProcessVol:

; 676  : 			{
; 677  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00428	c7 43 30 0d 00
	00 c0		 mov	 DWORD PTR [rbx+48], -1073741811 ; ffffffffc000000dH
$LN13@ProcessVol:

; 678  : 				Irp->IoStatus.Information = 0;

  0042f	48 83 63 38 00	 and	 QWORD PTR [rbx+56], 0

; 679  : 				break; 

  00434	e9 94 01 00 00	 jmp	 $LN11@ProcessVol
$LN32@ProcessVol:

; 680  : 			}
; 681  : 
; 682  : 			GSTGetDosNameFromNumber (ntName, Extension->nDosDriveNo);

  00439	8b 57 14	 mov	 edx, DWORD PTR [rdi+20]
  0043c	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR ntName$30513[rsp]
  00444	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 683  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  00449	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR ntName$30513[rsp]
  00451	48 8d 4c 24 58	 lea	 rcx, QWORD PTR ntUnicodeString$30512[rsp]
  00456	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 684  : 
; 685  : 			outLength = FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME,Name) + ntUnicodeString.Length;

  0045c	0f b7 7c 24 58	 movzx	 edi, WORD PTR ntUnicodeString$30512[rsp]

; 686  : 
; 687  : 			outputBuffer->UseOnlyIfThereAreNoOtherLinks = FALSE;

  00461	41 c6 45 00 00	 mov	 BYTE PTR [r13], 0

; 688  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  00466	0f b7 44 24 58	 movzx	 eax, WORD PTR ntUnicodeString$30512[rsp]
  0046b	03 fd		 add	 edi, ebp
  0046d	66 41 89 45 02	 mov	 WORD PTR [r13+2], ax

; 689  : 
; 690  : 			if(irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00472	41 39 7c 24 08	 cmp	 DWORD PTR [r12+8], edi
  00477	73 0a		 jae	 SHORT $LN31@ProcessVol

; 691  : 			{
; 692  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_SUGGESTED_LINK_NAME);

  00479	48 c7 43 38 06
	00 00 00	 mov	 QWORD PTR [rbx+56], 6

; 693  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 694  : 				break;

  00481	eb 5f		 jmp	 SHORT $LN60@ProcessVol
$LN31@ProcessVol:

; 695  : 			}
; 696  : 
; 697  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  00483	49 8d 4d 04	 lea	 rcx, QWORD PTR [r13+4]

; 698  : 		
; 699  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 700  : 			Irp->IoStatus.Information = outLength;
; 701  : 
; 702  : 			Dump ("link = %ls\n",ntName);
; 703  : 		}
; 704  : 		break;

  00487	eb 69		 jmp	 SHORT $LN67@ProcessVol
$LN41@ProcessVol:

; 595  : 	{
; 596  : 
; 597  : 	case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
; 598  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_NAME), ValidateOutput))

  00489	41 b8 01 00 00
	00		 mov	 r8d, 1
  0048f	48 8b d5	 mov	 rdx, rbp
  00492	48 8b cb	 mov	 rcx, rbx
  00495	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0049a	85 c0		 test	 eax, eax

; 599  : 		{
; 600  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);
; 601  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 602  : 		}
; 603  : 		else

  0049c	74 40		 je	 SHORT $LN59@ProcessVol

; 604  : 		{
; 605  : 			ULONG outLength;
; 606  : 			UNICODE_STRING ntUnicodeString;
; 607  : 			WCHAR ntName[256];
; 608  : 			PMOUNTDEV_NAME outputBuffer = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;
; 609  : 
; 610  : 			GSTGetNTNameFromNumber (ntName, Extension->nDosDriveNo);

  0049e	8b 57 14	 mov	 edx, DWORD PTR [rdi+20]
  004a1	4c 8b 6b 18	 mov	 r13, QWORD PTR [rbx+24]
  004a5	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR ntName$30480[rsp]
  004ad	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 611  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  004b2	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR ntName$30480[rsp]
  004ba	48 8d 4c 24 58	 lea	 rcx, QWORD PTR ntUnicodeString$30479[rsp]
  004bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 612  : 
; 613  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  004c5	0f b7 54 24 58	 movzx	 edx, WORD PTR ntUnicodeString$30479[rsp]
  004ca	66 41 89 55 00	 mov	 WORD PTR [r13], dx

; 614  : 			outLength = ntUnicodeString.Length + sizeof(USHORT);

  004cf	0f b7 7c 24 58	 movzx	 edi, WORD PTR ntUnicodeString$30479[rsp]
  004d4	83 c7 02	 add	 edi, 2

; 615  : 
; 616  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  004d7	41 39 7c 24 08	 cmp	 DWORD PTR [r12+8], edi
  004dc	73 10		 jae	 SHORT $LN38@ProcessVol
$LN59@ProcessVol:

; 617  : 			{
; 618  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);

  004de	48 89 6b 38	 mov	 QWORD PTR [rbx+56], rbp
$LN60@ProcessVol:

; 619  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  004e2	c7 43 30 05 00
	00 80		 mov	 DWORD PTR [rbx+48], -2147483643 ; ffffffff80000005H

; 620  : 
; 621  : 				break;

  004e9	e9 df 00 00 00	 jmp	 $LN11@ProcessVol
$LN38@ProcessVol:

; 622  : 			}
; 623  : 
; 624  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  004ee	49 8d 4d 02	 lea	 rcx, QWORD PTR [r13+2]
$LN67@ProcessVol:
  004f2	44 0f b7 44 24
	58		 movzx	 r8d, WORD PTR ntUnicodeString$30479[rsp]
  004f8	48 8b 54 24 60	 mov	 rdx, QWORD PTR ntUnicodeString$30479[rsp+8]
$LN61@ProcessVol:
  004fd	e8 00 00 00 00	 call	 memcpy

; 625  : 
; 626  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00502	83 63 30 00	 and	 DWORD PTR [rbx+48], 0

; 627  : 			Irp->IoStatus.Information = outLength;

  00506	8b c7		 mov	 eax, edi
  00508	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 628  : 
; 629  : 			Dump ("name = %ls\n",ntName);
; 630  : 		}
; 631  : 		break;

  0050c	e9 bc 00 00 00	 jmp	 $LN11@ProcessVol
$LN37@ProcessVol:

; 632  : 
; 633  : 	case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
; 634  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_UNIQUE_ID), ValidateOutput))

  00511	41 b8 01 00 00
	00		 mov	 r8d, 1
  00517	48 8b d5	 mov	 rdx, rbp
  0051a	48 8b cb	 mov	 rcx, rbx
  0051d	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00522	85 c0		 test	 eax, eax

; 635  : 		{
; 636  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);
; 637  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 638  : 		}
; 639  : 		else

  00524	74 b8		 je	 SHORT $LN59@ProcessVol

; 640  : 		{
; 641  : 			ULONG outLength;
; 642  : 			UCHAR volId[128], tmp[] = { 0,0 };
; 643  : 			PMOUNTDEV_UNIQUE_ID outputBuffer = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;
; 644  : 
; 645  : 			strcpy (volId, GST_UNIQUE_ID_PREFIX); 
; 646  : 			tmp[0] = 'A' + (UCHAR) Extension->nDosDriveNo;

  00526	8a 47 14	 mov	 al, BYTE PTR [rdi+20]
  00529	f3 0f 6f 05 00
	00 00 00	 movdqu	 xmm0, XMMWORD PTR ??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@FNODOBFM@
  00531	4c 8b 4b 18	 mov	 r9, QWORD PTR [rbx+24]
  00535	04 41		 add	 al, 65			; 00000041H

; 647  : 			strcat (volId, tmp);

  00537	49 83 c8 ff	 or	 r8, -1
  0053b	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR volId$30496[rsp]
  00543	f3 0f 7f 84 24
	80 00 00 00	 movdqu	 XMMWORD PTR volId$30496[rsp], xmm0
  0054c	88 44 24 50	 mov	 BYTE PTR tmp$30497[rsp], al
  00550	33 c0		 xor	 eax, eax
  00552	49 8b c8	 mov	 rcx, r8
  00555	f2 ae		 repne scasb
  00557	48 8d 4c 24 50	 lea	 rcx, QWORD PTR tmp$30497[rsp]
  0055c	33 d2		 xor	 edx, edx
  0055e	c6 44 24 51 00	 mov	 BYTE PTR tmp$30497[rsp+1], 0
$LL57@ProcessVol:
  00563	8a 04 11	 mov	 al, BYTE PTR [rcx+rdx]
  00566	48 ff c2	 inc	 rdx
  00569	88 44 17 fe	 mov	 BYTE PTR [rdi+rdx-2], al
  0056d	84 c0		 test	 al, al
  0056f	75 f2		 jne	 SHORT $LL57@ProcessVol

; 648  : 			
; 649  : 			outputBuffer->UniqueIdLength = (USHORT) strlen (volId);

  00571	33 c0		 xor	 eax, eax
  00573	49 8b c8	 mov	 rcx, r8
  00576	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR volId$30496[rsp]
  0057e	f2 ae		 repne scasb
  00580	48 f7 d1	 not	 rcx
  00583	48 ff c9	 dec	 rcx
  00586	66 41 89 09	 mov	 WORD PTR [r9], cx
  0058a	4c 8b c1	 mov	 r8, rcx

; 650  : 			outLength = (ULONG) (strlen (volId) + sizeof (USHORT));

  0058d	8d 79 02	 lea	 edi, DWORD PTR [rcx+2]

; 651  : 
; 652  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00590	41 39 7c 24 08	 cmp	 DWORD PTR [r12+8], edi

; 653  : 			{
; 654  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);
; 655  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 656  : 				break;

  00595	0f 82 43 ff ff
	ff		 jb	 $LN59@ProcessVol

; 657  : 			}
; 658  : 
; 659  : 			RtlCopyMemory ((PCHAR)outputBuffer->UniqueId, volId, strlen (volId));

  0059b	49 8d 49 02	 lea	 rcx, QWORD PTR [r9+2]
  0059f	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR volId$30496[rsp]

; 660  : 
; 661  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 662  : 			Irp->IoStatus.Information = outLength;
; 663  : 
; 664  : 			Dump ("id = %s\n",volId);
; 665  : 		}
; 666  : 		break;

  005a7	e9 51 ff ff ff	 jmp	 $LN61@ProcessVol
$LN12@ProcessVol:

; 832  : 
; 833  : 	case IOCTL_DISK_CHECK_VERIFY:
; 834  : 	case IOCTL_STORAGE_CHECK_VERIFY:
; 835  : 		{
; 836  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  005ac	41 83 60 30 00	 and	 DWORD PTR [r8+48], 0

; 837  : 			Irp->IoStatus.Information = 0;

  005b1	49 83 60 38 00	 and	 QWORD PTR [r8+56], 0

; 838  : 
; 839  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (ULONG))

  005b6	bd 04 00 00 00	 mov	 ebp, 4
  005bb	41 39 6c 24 08	 cmp	 DWORD PTR [r12+8], ebp
  005c0	72 0b		 jb	 SHORT $LN11@ProcessVol

; 840  : 			{
; 841  : 				*((ULONG *) Irp->AssociatedIrp.SystemBuffer) = 0;

  005c2	49 8b 40 18	 mov	 rax, QWORD PTR [r8+24]
  005c6	83 20 00	 and	 DWORD PTR [rax], 0

; 842  : 				Irp->IoStatus.Information = sizeof (ULONG);

  005c9	49 89 68 38	 mov	 QWORD PTR [r8+56], rbp
$LN11@ProcessVol:

; 886  : 	}
; 887  : 
; 888  : #ifdef DEBUG
; 889  : 	if (!NT_SUCCESS (Irp->IoStatus.Status))
; 890  : 	{
; 891  : 		Dump ("IOCTL error 0x%08x (0x%x %d)\n",
; 892  : 			Irp->IoStatus.Status,
; 893  : 			(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 894  : 			(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));
; 895  : 	}
; 896  : #endif
; 897  : 
; 898  : 	return GSTCompleteDiskIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  005cd	8b 7b 30	 mov	 edi, DWORD PTR [rbx+48]
  005d0	48 8b cb	 mov	 rcx, rbx
  005d3	85 ff		 test	 edi, edi
  005d5	0f 99 c2	 setns	 dl
  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  005de	8b c7		 mov	 eax, edi
$LN44@ProcessVol:

; 899  : }

  005e0	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005e8	48 33 cc	 xor	 rcx, rsp
  005eb	e8 00 00 00 00	 call	 __security_check_cookie
  005f0	4c 8d 9c 24 10
	03 00 00	 lea	 r11, QWORD PTR [rsp+784]
  005f8	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  005fc	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  00600	49 8b e3	 mov	 rsp, r11
  00603	41 5d		 pop	 r13
  00605	41 5c		 pop	 r12
  00607	5f		 pop	 rdi
  00608	c3		 ret	 0
ProcessVolumeDeviceControlIrp ENDP
PUBLIC	ReadDeviceSkipUnreadableSectors
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadDeviceSkipUnreadableSectors DD imagerel $LN15
	DD	imagerel $LN15+223
	DD	imagerel $unwind$ReadDeviceSkipUnreadableSectors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadDeviceSkipUnreadableSectors DD 0a1c01H
	DD	011641cH
	DD	0f541cH
	DD	0e341cH
	DD	0d018921cH
	DD	07014c016H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ReadDeviceSkipUnreadableSectors
_TEXT	SEGMENT
geometry$38911 = 48
deviceObject$ = 112
buffer$ = 120
startOffset$ = 128
size$ = 136
sectorSize$ = 144
badSectorCount$ = 144
ReadDeviceSkipUnreadableSectors PROC			; COMDAT

; 3752 : {

$LN15:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  00013	57		 push	 rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 3753 : 	NTSTATUS status;
; 3754 : 	ULONG sectorSize;
; 3755 : 	ULONG sectorCount;
; 3756 : 
; 3757 : 	*badSectorCount = 0;

  0001c	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR badSectorCount$[rsp]

; 3758 : 
; 3759 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  00024	c7 40 c0 18 00
	00 00		 mov	 DWORD PTR [rax-64], 24
  0002b	48 8d 40 c8	 lea	 rax, QWORD PTR [rax-56]
  0002f	49 83 24 24 00	 and	 QWORD PTR [r12], 0
  00034	41 8b d9	 mov	 ebx, r9d
  00037	48 8b ea	 mov	 rbp, rdx
  0003a	45 33 c9	 xor	 r9d, r9d
  0003d	45 33 c0	 xor	 r8d, r8d
  00040	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  00045	4c 8b e9	 mov	 r13, rcx
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00052	85 c0		 test	 eax, eax
  00054	79 09		 jns	 SHORT $LN8@ReadDevice
  00056	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR sectorSize$[rsp]
  0005d	eb 06		 jmp	 SHORT $LN9@ReadDevice
$LN8@ReadDevice:
  0005f	8b 7c 24 44	 mov	 edi, DWORD PTR geometry$38911[rsp+20]
  00063	33 c0		 xor	 eax, eax
$LN9@ReadDevice:

; 3760 : 	if (!NT_SUCCESS (status))

  00065	85 c0		 test	 eax, eax

; 3761 : 		return status;

  00067	78 5c		 js	 SHORT $LN6@ReadDevice

; 3762 : 
; 3763 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize, buffer += sectorSize)

  00069	33 d2		 xor	 edx, edx
  0006b	8b c3		 mov	 eax, ebx
  0006d	f7 f7		 div	 edi
  0006f	8b d8		 mov	 ebx, eax
  00071	85 c0		 test	 eax, eax
  00073	74 4e		 je	 SHORT $LN2@ReadDevice
  00075	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR startOffset$[rsp]
  0007d	8b f7		 mov	 esi, edi
$LL4@ReadDevice:

; 3764 : 	{
; 3765 : 		status = GSTReadDevice (deviceObject, buffer, startOffset, sectorSize);

  0007f	4c 8b c9	 mov	 r9, rcx
  00082	4c 8b c5	 mov	 r8, rbp
  00085	49 8b d5	 mov	 rdx, r13
  00088	33 c9		 xor	 ecx, ecx
  0008a	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  0008e	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 3766 : 		if (!NT_SUCCESS (status))

  00093	85 c0		 test	 eax, eax
  00095	79 11		 jns	 SHORT $LN3@ReadDevice

; 3767 : 		{
; 3768 : 			Dump ("Skipping bad sector at %I64d\n", startOffset.QuadPart);
; 3769 : 			memset (buffer, 0, sectorSize);

  00097	4c 8b c6	 mov	 r8, rsi
  0009a	33 d2		 xor	 edx, edx
  0009c	48 8b cd	 mov	 rcx, rbp
  0009f	e8 00 00 00 00	 call	 memset

; 3770 : 			++(*badSectorCount);

  000a4	49 ff 04 24	 inc	 QWORD PTR [r12]
$LN3@ReadDevice:
  000a8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR startOffset$[rsp]
  000b0	48 03 ee	 add	 rbp, rsi
  000b3	48 03 ce	 add	 rcx, rsi
  000b6	83 c3 ff	 add	 ebx, -1			; ffffffffH
  000b9	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR startOffset$[rsp], rcx
  000c1	75 bc		 jne	 SHORT $LL4@ReadDevice
$LN2@ReadDevice:

; 3771 : 		}
; 3772 : 	}
; 3773 : 
; 3774 : 	return STATUS_SUCCESS;

  000c3	33 c0		 xor	 eax, eax
$LN6@ReadDevice:

; 3775 : }

  000c5	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  000ca	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  000ce	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  000d2	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  000d6	49 8b e3	 mov	 rsp, r11
  000d9	41 5d		 pop	 r13
  000db	41 5c		 pop	 r12
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
ReadDeviceSkipUnreadableSectors ENDP
_TEXT	ENDS
PUBLIC	ZeroUnreadableSectors
;	COMDAT pdata
pdata	SEGMENT
$pdata$ZeroUnreadableSectors DD imagerel $LN21
	DD	imagerel $LN21+298
	DD	imagerel $unwind$ZeroUnreadableSectors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ZeroUnreadableSectors DD 0a1b01H
	DD	012541bH
	DD	010341bH
	DD	0e017921bH
	DD	0c013d015H
	DD	060107011H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ZeroUnreadableSectors
_TEXT	SEGMENT
geometry$38940 = 48
deviceObject$ = 128
startOffset$ = 136
size$ = 144
sectorSize$ = 152
zeroedSectorCount$ = 152
ZeroUnreadableSectors PROC				; COMDAT

; 3697 : {

$LN21:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 3698 : 	NTSTATUS status;
; 3699 : 	ULONG sectorSize;
; 3700 : 	ULONG sectorCount;
; 3701 : 	byte *sectorBuffer = NULL;
; 3702 : 
; 3703 : 	*zeroedSectorCount = 0;

  0001b	49 83 21 00	 and	 QWORD PTR [r9], 0

; 3704 : 
; 3705 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  0001f	c7 40 b0 18 00
	00 00		 mov	 DWORD PTR [rax-80], 24
  00026	48 8d 40 b8	 lea	 rax, QWORD PTR [rax-72]
  0002a	4d 8b e9	 mov	 r13, r9
  0002d	41 8b f8	 mov	 edi, r8d
  00030	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  00035	45 33 c9	 xor	 r9d, r9d
  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00040	4c 8b f1	 mov	 r14, rcx
  00043	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00048	85 c0		 test	 eax, eax
  0004a	79 09		 jns	 SHORT $LN11@ZeroUnread
  0004c	8b 9c 24 98 00
	00 00		 mov	 ebx, DWORD PTR sectorSize$[rsp]
  00053	eb 06		 jmp	 SHORT $LN12@ZeroUnread
$LN11@ZeroUnread:
  00055	8b 5c 24 44	 mov	 ebx, DWORD PTR geometry$38940[rsp+20]
  00059	33 c0		 xor	 eax, eax
$LN12@ZeroUnread:

; 3706 : 	if (!NT_SUCCESS (status))

  0005b	85 c0		 test	 eax, eax

; 3707 : 		return status;

  0005d	0f 88 ae 00 00
	00		 js	 $LN9@ZeroUnread

; 3708 : 
; 3709 : 	sectorBuffer = GSTalloc (sectorSize);

  00063	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00069	8b d3		 mov	 edx, ebx
  0006b	33 c9		 xor	 ecx, ecx
  0006d	44 8b e3	 mov	 r12d, ebx
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00076	48 8b e8	 mov	 rbp, rax

; 3710 : 	if (!sectorBuffer)

  00079	48 85 c0	 test	 rax, rax
  0007c	75 0a		 jne	 SHORT $LN7@ZeroUnread

; 3711 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0007e	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00083	e9 89 00 00 00	 jmp	 $LN9@ZeroUnread
$LN7@ZeroUnread:

; 3712 : 
; 3713 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)

  00088	33 d2		 xor	 edx, edx
  0008a	8b c7		 mov	 eax, edi
  0008c	f7 f3		 div	 ebx
  0008e	8b f8		 mov	 edi, eax
  00090	85 c0		 test	 eax, eax
  00092	74 6b		 je	 SHORT $LN4@ZeroUnread
  00094	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR startOffset$[rsp]
$LL6@ZeroUnread:

; 3714 : 	{
; 3715 : 		status = GSTReadDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  0009c	4c 8b c9	 mov	 r9, rcx
  0009f	4c 8b c5	 mov	 r8, rbp
  000a2	49 8b d6	 mov	 rdx, r14
  000a5	33 c9		 xor	 ecx, ecx
  000a7	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  000ab	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 3716 : 		if (!NT_SUCCESS (status))

  000b0	85 c0		 test	 eax, eax
  000b2	79 33		 jns	 SHORT $LN5@ZeroUnread

; 3717 : 		{
; 3718 : 			Dump ("Zeroing sector at %I64d\n", startOffset.QuadPart);
; 3719 : 			memset (sectorBuffer, 0, sectorSize);

  000b4	4d 8b c4	 mov	 r8, r12
  000b7	33 d2		 xor	 edx, edx
  000b9	48 8b cd	 mov	 rcx, rbp
  000bc	e8 00 00 00 00	 call	 memset

; 3720 : 
; 3721 : 			status = GSTWriteDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  000c1	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR startOffset$[rsp]
  000c9	4c 8b c5	 mov	 r8, rbp
  000cc	49 8b d6	 mov	 rdx, r14
  000cf	b9 01 00 00 00	 mov	 ecx, 1
  000d4	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  000d8	e8 00 00 00 00	 call	 GSTReadWriteDevice
  000dd	8b f0		 mov	 esi, eax

; 3722 : 			if (!NT_SUCCESS (status))

  000df	85 c0		 test	 eax, eax
  000e1	78 1e		 js	 SHORT $err$31842

; 3723 : 				goto err;
; 3724 : 
; 3725 : 			++(*zeroedSectorCount);

  000e3	49 ff 45 00	 inc	 QWORD PTR [r13]
$LN5@ZeroUnread:

; 3712 : 
; 3713 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)

  000e7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR startOffset$[rsp]
  000ef	49 03 cc	 add	 rcx, r12
  000f2	83 c7 ff	 add	 edi, -1			; ffffffffH
  000f5	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR startOffset$[rsp], rcx
  000fd	75 9d		 jne	 SHORT $LL6@ZeroUnread
$LN4@ZeroUnread:

; 3726 : 		}
; 3727 : 	}
; 3728 : 
; 3729 : 	status = STATUS_SUCCESS;

  000ff	33 f6		 xor	 esi, esi
$err$31842:

; 3730 : 
; 3731 : err:
; 3732 : 	if (sectorBuffer)
; 3733 : 		GSTfree (sectorBuffer);

  00101	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00106	48 8b cd	 mov	 rcx, rbp
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 3734 : 
; 3735 : 	return status;

  0010f	8b c6		 mov	 eax, esi
$LN9@ZeroUnread:

; 3736 : }

  00111	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00116	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  0011a	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  0011e	49 8b e3	 mov	 rsp, r11
  00121	41 5e		 pop	 r14
  00123	41 5d		 pop	 r13
  00125	41 5c		 pop	 r12
  00127	5f		 pop	 rdi
  00128	5e		 pop	 rsi
  00129	c3		 ret	 0
ZeroUnreadableSectors ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	UnmountDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnmountDevice DD imagerel $LN47
	DD	imagerel $LN47+714
	DD	imagerel $unwind$UnmountDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnmountDevice DD 092519H
	DD	0803413H
	DD	0780113H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	03b0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT UnmountDevice
_TEXT	SEGMENT
volumeFileObject$ = 48
volumeHandle$ = 56
symLink$39013 = 64
ntfsData$31509 = 80
buf$39003 = 176
link$39012 = 432
out$39004 = 432
__$ArrayPad$ = 944
unmountRequest$ = 1008
deviceObject$ = 1016
ignoreOpenFiles$ = 1024
UnmountDevice PROC					; COMDAT

; 3012 : {

$LN47:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	48 81 ec c0 03
	00 00		 sub	 rsp, 960		; 000003c0H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3013 : 	PEXTENSION extension = deviceObject->DeviceExtension;

  00025	4c 8b 62 40	 mov	 r12, QWORD PTR [rdx+64]
  00029	41 8b f0	 mov	 esi, r8d
  0002c	48 8b ea	 mov	 rbp, rdx
  0002f	4c 8b e9	 mov	 r13, rcx

; 3014 : 	NTSTATUS ntStatus;
; 3015 : 	HANDLE volumeHandle;
; 3016 : 	PFILE_OBJECT volumeFileObject;
; 3017 : 
; 3018 : 	Dump ("UnmountDevice %d\n", extension->nDosDriveNo);
; 3019 : 
; 3020 : 	ntStatus = GSTOpenFsVolume (extension, &volumeHandle, &volumeFileObject);

  00032	4c 8d 44 24 30	 lea	 r8, QWORD PTR volumeFileObject$[rsp]
  00037	48 8d 54 24 38	 lea	 rdx, QWORD PTR volumeHandle$[rsp]
  0003c	49 8b cc	 mov	 rcx, r12
  0003f	e8 00 00 00 00	 call	 GSTOpenFsVolume

; 3021 : 
; 3022 : 	if (NT_SUCCESS (ntStatus))

  00044	bb 01 00 00 00	 mov	 ebx, 1
  00049	85 c0		 test	 eax, eax
  0004b	0f 88 f0 00 00
	00		 js	 $LN16@UnmountDev
  00051	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR OsMajorVersion
  00057	c1 e0 08	 shl	 eax, 8

; 3023 : 	{
; 3024 : 		int dismountRetry;
; 3025 : 
; 3026 : 		// Dismounting a writable NTFS filesystem prevents the driver from being unloaded on Windows 7
; 3027 : 		if (IsOSAtLeast (WIN_7) && !extension->bReadOnly)

  0005a	0b 05 00 00 00
	00		 or	 eax, DWORD PTR OsMinorVersion
  00060	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00065	3d 01 06 00 00	 cmp	 eax, 1537		; 00000601H
  0006a	72 43		 jb	 SHORT $LN14@UnmountDev
  0006c	41 83 bc 24 40
	03 00 00 00	 cmp	 DWORD PTR [r12+832], 0
  00075	75 38		 jne	 SHORT $LN14@UnmountDev

; 3028 : 		{
; 3029 : 			NTFS_VOLUME_DATA_BUFFER ntfsData;
; 3030 : 
; 3031 : 			if (NT_SUCCESS (GSTFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))

  00077	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  0007c	48 8d 44 24 50	 lea	 rax, QWORD PTR ntfsData$31509[rsp]
  00081	45 33 c9	 xor	 r9d, r9d
  00084	45 33 c0	 xor	 r8d, r8d
  00087	ba 64 00 09 00	 mov	 edx, 589924		; 00090064H
  0008c	c7 44 24 28 60
	00 00 00	 mov	 DWORD PTR [rsp+40], 96	; 00000060H
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	e8 00 00 00 00	 call	 GSTFsctlCall
  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR DriverUnloadDisabled
  000a4	85 c0		 test	 eax, eax
  000a6	0f 49 cb	 cmovns	 ecx, ebx
  000a9	89 0d 00 00 00
	00		 mov	 DWORD PTR DriverUnloadDisabled, ecx
$LN14@UnmountDev:

; 3032 : 				DriverUnloadDisabled = TRUE;
; 3033 : 		}
; 3034 : 
; 3035 : 		// Lock volume
; 3036 : 		ntStatus = GSTFsctlCall (volumeFileObject, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  000b4	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  000b9	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000bf	45 33 c9	 xor	 r9d, r9d
  000c2	45 33 c0	 xor	 r8d, r8d
  000c5	ba 18 00 09 00	 mov	 edx, 589848		; 00090018H
  000ca	e8 00 00 00 00	 call	 GSTFsctlCall

; 3037 : 		Dump ("FSCTL_LOCK_VOLUME returned %X\n", ntStatus);
; 3038 : 
; 3039 : 		if (!NT_SUCCESS (ntStatus) && !ignoreOpenFiles)

  000cf	85 c0		 test	 eax, eax
  000d1	79 27		 jns	 SHORT $LN13@UnmountDev
  000d3	85 f6		 test	 esi, esi
  000d5	75 23		 jne	 SHORT $LN13@UnmountDev
$LN44@UnmountDev:

; 3040 : 		{
; 3041 : 			GSTCloseFsVolume (volumeHandle, volumeFileObject);

  000d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  000dc	48 8b 7c 24 38	 mov	 rdi, QWORD PTR volumeHandle$[rsp]
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
  000e7	48 8b cf	 mov	 rcx, rdi
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN46@UnmountDev:

; 3042 : 			return ERR_FILES_OPEN;

  000f0	b8 06 00 00 00	 mov	 eax, 6
  000f5	e9 a9 01 00 00	 jmp	 $LN17@UnmountDev
$LN13@UnmountDev:

; 3043 : 		}
; 3044 : 
; 3045 : 		// Dismount volume
; 3046 : 		for (dismountRetry = 0; dismountRetry < 200; ++dismountRetry)

  000fa	33 ff		 xor	 edi, edi
$LL12@UnmountDev:

; 3047 : 		{
; 3048 : 			ntStatus = GSTFsctlCall (volumeFileObject, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);

  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  00101	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  00106	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0010c	45 33 c9	 xor	 r9d, r9d
  0010f	45 33 c0	 xor	 r8d, r8d
  00112	ba 20 00 09 00	 mov	 edx, 589856		; 00090020H
  00117	e8 00 00 00 00	 call	 GSTFsctlCall

; 3049 : 			Dump ("FSCTL_DISMOUNT_VOLUME returned %X\n", ntStatus);
; 3050 : 
; 3051 : 			if (NT_SUCCESS (ntStatus) || ntStatus == STATUS_VOLUME_DISMOUNTED)

  0011c	85 c0		 test	 eax, eax
  0011e	79 2b		 jns	 SHORT $LN4@UnmountDev
  00120	3d 6e 02 00 c0	 cmp	 eax, -1073741202	; ffffffffc000026eH
  00125	74 24		 je	 SHORT $LN4@UnmountDev

; 3052 : 				break;
; 3053 : 
; 3054 : 			if (!ignoreOpenFiles)

  00127	85 f6		 test	 esi, esi
  00129	74 ac		 je	 SHORT $LN44@UnmountDev

; 3055 : 			{
; 3056 : 				GSTCloseFsVolume (volumeHandle, volumeFileObject);
; 3057 : 				return ERR_FILES_OPEN;
; 3058 : 			}
; 3059 : 
; 3060 : 			GSTSleep (100);

  0012b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00130	e8 00 00 00 00	 call	 GSTSleep
  00135	03 fb		 add	 edi, ebx
  00137	81 ff c8 00 00
	00		 cmp	 edi, 200		; 000000c8H
  0013d	7c bd		 jl	 SHORT $LL12@UnmountDev

; 3052 : 				break;
; 3053 : 
; 3054 : 			if (!ignoreOpenFiles)

  0013f	eb 0a		 jmp	 SHORT $LN4@UnmountDev
$LN16@UnmountDev:

; 3061 : 		}
; 3062 : 	}
; 3063 : 	else 
; 3064 : 	{
; 3065 : 		// Volume cannot be opened => force dismount if allowed
; 3066 : 		if (!ignoreOpenFiles)

  00141	85 f6		 test	 esi, esi

; 3067 : 			return ERR_FILES_OPEN;

  00143	74 ab		 je	 SHORT $LN46@UnmountDev

; 3068 : 		else
; 3069 : 			volumeHandle = NULL;

  00145	48 83 64 24 38
	00		 and	 QWORD PTR volumeHandle$[rsp], 0
$LN4@UnmountDev:

; 3070 : 	}
; 3071 : 
; 3072 : 	if (extension->bMountManager)

  0014b	41 83 bc 24 50
	03 00 00 00	 cmp	 DWORD PTR [r12+848], 0
  00154	0f 84 8a 00 00
	00		 je	 $LN36@UnmountDev

; 3073 : 		MountManagerUnmount (extension->nDosDriveNo);

  0015a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$39003[rsp]
  00162	33 d2		 xor	 edx, edx
  00164	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0016a	e8 00 00 00 00	 call	 memset
  0016f	41 8b 54 24 14	 mov	 edx, DWORD PTR [r12+20]
  00174	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR buf$39003[rsp+24]
  0017c	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber
  00181	48 83 c9 ff	 or	 rcx, -1
  00185	33 c0		 xor	 eax, eax
  00187	c7 84 24 b0 00
	00 00 18 00 00
	00		 mov	 DWORD PTR buf$39003[rsp], 24
  00192	48 8d bc 24 c8
	00 00 00	 lea	 rdi, QWORD PTR buf$39003[rsp+24]
  0019a	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR buf$39003[rsp]
  001a2	66 f2 af	 repne scasw
  001a5	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR out$39004[rsp]
  001ad	ba 04 c0 6d 00	 mov	 edx, 7192580		; 006dc004H
  001b2	48 f7 d1	 not	 rcx
  001b5	c7 44 24 28 2c
	01 00 00	 mov	 DWORD PTR [rsp+40], 300	; 0000012cH
  001bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c2	48 2b cb	 sub	 rcx, rbx
  001c5	66 03 c9	 add	 cx, cx
  001c8	44 0f b7 c9	 movzx	 r9d, cx
  001cc	66 89 8c 24 b4
	00 00 00	 mov	 WORD PTR buf$39003[rsp+4], cx
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  001db	41 83 c1 18	 add	 r9d, 24
  001df	e8 00 00 00 00	 call	 GSTDeviceIoControl
$LN36@UnmountDev:

; 3074 : 
; 3075 : 	// We always remove symbolic link as mount manager might fail to do so
; 3076 : 	RemoveDriveLink (extension->nDosDriveNo);

  001e4	41 8b 54 24 14	 mov	 edx, DWORD PTR [r12+20]
  001e9	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR link$39012[rsp]
  001f1	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber
  001f6	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR link$39012[rsp]
  001fe	48 8d 4c 24 40	 lea	 rcx, QWORD PTR symLink$39013[rsp]
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString
  00209	48 8d 4c 24 40	 lea	 rcx, QWORD PTR symLink$39013[rsp]
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 3077 : 
; 3078 : 	extension->bShuttingDown = TRUE;
; 3079 : 
; 3080 : 	ntStatus = IoAcquireRemoveLock (&extension->Queue.RemoveLock, NULL);

  00214	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  0021b	49 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR [r12+384]
  00223	be 20 00 00 00	 mov	 esi, 32			; 00000020H
  00228	44 8b cb	 mov	 r9d, ebx
  0022b	33 d2		 xor	 edx, edx
  0022d	41 89 5c 24 18	 mov	 DWORD PTR [r12+24], ebx
  00232	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx

; 3081 : 	ASSERT (NT_SUCCESS (ntStatus));
; 3082 : 	IoReleaseRemoveLockAndWait (&extension->Queue.RemoveLock, NULL);

  0023c	49 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR [r12+384]
  00244	44 8b c6	 mov	 r8d, esi
  00247	33 d2		 xor	 edx, edx
  00249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockAndWaitEx

; 3083 : 
; 3084 : 	if (volumeHandle != NULL)

  0024f	48 8b 7c 24 38	 mov	 rdi, QWORD PTR volumeHandle$[rsp]
  00254	48 85 ff	 test	 rdi, rdi
  00257	74 14		 je	 SHORT $LN40@UnmountDev

; 3085 : 		GSTCloseFsVolume (volumeHandle, volumeFileObject);

  00259	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
  00264	48 8b cf	 mov	 rcx, rdi
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN40@UnmountDev:

; 3086 : 
; 3087 : 	if (unmountRequest)

  0026d	4d 85 ed	 test	 r13, r13
  00270	74 23		 je	 SHORT $LN1@UnmountDev

; 3088 : 	{
; 3089 : 		PCRYPTO_INFO cryptoInfo = ((PEXTENSION) deviceObject->DeviceExtension)->cryptoInfo;

  00272	48 8b 45 40	 mov	 rax, QWORD PTR [rbp+64]
  00276	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]

; 3090 : 		unmountRequest->HiddenVolumeProtectionTriggered = (cryptoInfo->bProtectHiddenVolume && cryptoInfo->bHiddenVolProtectionAction);

  0027d	83 b9 a8 1e 00
	00 00		 cmp	 DWORD PTR [rcx+7848], 0
  00284	74 09		 je	 SHORT $LN19@UnmountDev
  00286	83 b9 ac 1e 00
	00 00		 cmp	 DWORD PTR [rcx+7852], 0
  0028d	75 02		 jne	 SHORT $LN20@UnmountDev
$LN19@UnmountDev:
  0028f	33 db		 xor	 ebx, ebx
$LN20@UnmountDev:
  00291	41 89 5d 08	 mov	 DWORD PTR [r13+8], ebx
$LN1@UnmountDev:

; 3091 : 	}
; 3092 : 
; 3093 : 	GSTDeleteDeviceObject (deviceObject, (PEXTENSION) deviceObject->DeviceExtension);

  00295	48 8b 55 40	 mov	 rdx, QWORD PTR [rbp+64]
  00299	48 8b cd	 mov	 rcx, rbp
  0029c	e8 00 00 00 00	 call	 GSTDeleteDeviceObject

; 3094 : 	return 0;

  002a1	33 c0		 xor	 eax, eax
$LN17@UnmountDev:

; 3095 : }

  002a3	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002ab	48 33 cc	 xor	 rcx, rsp
  002ae	e8 00 00 00 00	 call	 __security_check_cookie
  002b3	48 8b 9c 24 00
	04 00 00	 mov	 rbx, QWORD PTR [rsp+1024]
  002bb	48 81 c4 c0 03
	00 00		 add	 rsp, 960		; 000003c0H
  002c2	41 5d		 pop	 r13
  002c4	41 5c		 pop	 r12
  002c6	5f		 pop	 rdi
  002c7	5e		 pop	 rsi
  002c8	5d		 pop	 rbp
  002c9	c3		 ret	 0
UnmountDevice ENDP
PUBLIC	UnmountAllDevices
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnmountAllDevices DD imagerel $LN31
	DD	imagerel $LN31+219
	DD	imagerel $unwind$UnmountAllDevices
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnmountAllDevices DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT UnmountAllDevices
_TEXT	SEGMENT
unmountRequest$ = 64
ignoreOpenFiles$ = 72
UnmountAllDevices PROC					; COMDAT

; 3140 : {

$LN31:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3141 : 	NTSTATUS status = 0;
; 3142 : 	PDEVICE_OBJECT ListDevice;
; 3143 : 	int maxUniqueId = LastUniqueVolumeId;

  00018	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR LastUniqueVolumeId
  0001e	45 33 e4	 xor	 r12d, r12d
  00021	44 8b ea	 mov	 r13d, edx
  00024	48 8b d9	 mov	 rbx, rcx

; 3144 : 
; 3145 : 	Dump ("Unmounting all volumes\n");
; 3146 : 
; 3147 : 	if (unmountRequest)

  00027	48 85 c9	 test	 rcx, rcx
  0002a	74 04		 je	 SHORT $LL5@UnmountAll

; 3148 : 		unmountRequest->HiddenVolumeProtectionTriggered = FALSE;

  0002c	44 21 61 08	 and	 DWORD PTR [rcx+8], r12d
$LL5@UnmountAll:

; 3149 : 
; 3150 : 	// Dismount volumes in the reverse order they were mounted to properly dismount nested volumes
; 3151 : 	while ((ListDevice = FindVolumeWithHighestUniqueId (maxUniqueId)) != NULL)

  00030	33 c9		 xor	 ecx, ecx
  00032	33 f6		 xor	 esi, esi
  00034	41 83 c8 ff	 or	 r8d, -1
  00038	48 83 f9 19	 cmp	 rcx, 25
$LN30@UnmountAll:
  0003c	77 0d		 ja	 SHORT $LN16@UnmountAll
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:VirtualVolumeDeviceObjects
  00045	48 8b 14 ca	 mov	 rdx, QWORD PTR [rdx+rcx*8]
  00049	eb 02		 jmp	 SHORT $LN18@UnmountAll
$LN16@UnmountAll:
  0004b	33 d2		 xor	 edx, edx
$LN18@UnmountAll:
  0004d	48 85 d2	 test	 rdx, rdx
  00050	74 16		 je	 SHORT $LN12@UnmountAll
  00052	48 8b 42 40	 mov	 rax, QWORD PTR [rdx+64]
  00056	44 39 40 10	 cmp	 DWORD PTR [rax+16], r8d
  0005a	7e 0c		 jle	 SHORT $LN12@UnmountAll
  0005c	39 68 10	 cmp	 DWORD PTR [rax+16], ebp
  0005f	7f 07		 jg	 SHORT $LN12@UnmountAll
  00061	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00065	48 8b f2	 mov	 rsi, rdx
$LN12@UnmountAll:
  00068	48 ff c1	 inc	 rcx
  0006b	48 83 f9 19	 cmp	 rcx, 25
  0006f	7e cb		 jle	 SHORT $LN30@UnmountAll
  00071	48 85 f6	 test	 rsi, rsi
  00074	74 49		 je	 SHORT $LN22@UnmountAll

; 3152 : 	{
; 3153 : 		PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00076	48 8b 7e 40	 mov	 rdi, QWORD PTR [rsi+64]

; 3154 : 		maxUniqueId = ListExtension->UniqueVolumeId - 1;
; 3155 : 
; 3156 : 		if (IsVolumeAccessibleByCurrentUser (ListExtension))

  0007a	48 8b cf	 mov	 rcx, rdi
  0007d	8b 6f 10	 mov	 ebp, DWORD PTR [rdi+16]
  00080	ff cd		 dec	 ebp
  00082	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  00087	85 c0		 test	 eax, eax
  00089	74 a5		 je	 SHORT $LL5@UnmountAll

; 3157 : 		{
; 3158 : 			NTSTATUS ntStatus;
; 3159 : 
; 3160 : 			if (unmountRequest)

  0008b	48 85 db	 test	 rbx, rbx
  0008e	74 05		 je	 SHORT $LN2@UnmountAll

; 3161 : 				unmountRequest->nDosDriveNo = ListExtension->nDosDriveNo;

  00090	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  00093	89 03		 mov	 DWORD PTR [rbx], eax
$LN2@UnmountAll:

; 3162 : 
; 3163 : 			ntStatus = UnmountDevice (unmountRequest, ListDevice, ignoreOpenFiles);

  00095	45 8b c5	 mov	 r8d, r13d
  00098	48 8b d6	 mov	 rdx, rsi
  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 UnmountDevice

; 3164 : 			status = ntStatus == 0 ? status : ntStatus;

  000a3	85 c0		 test	 eax, eax
  000a5	41 0f 44 c4	 cmove	 eax, r12d
  000a9	44 8b e0	 mov	 r12d, eax

; 3165 : 
; 3166 : 			if (unmountRequest && unmountRequest->HiddenVolumeProtectionTriggered)

  000ac	48 85 db	 test	 rbx, rbx
  000af	0f 84 7b ff ff
	ff		 je	 $LL5@UnmountAll
  000b5	83 7b 08 00	 cmp	 DWORD PTR [rbx+8], 0

; 3167 : 				break;
; 3168 : 		}
; 3169 : 	}

  000b9	0f 84 71 ff ff
	ff		 je	 $LL5@UnmountAll
$LN22@UnmountAll:

; 3170 : 
; 3171 : 	return status;
; 3172 : }

  000bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c4	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c9	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ce	41 8b c4	 mov	 eax, r12d
  000d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d5	41 5d		 pop	 r13
  000d7	41 5c		 pop	 r12
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
UnmountAllDevices ENDP
PUBLIC	VolumeThreadProc
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$VolumeThreadProc DD imagerel $LN29
	DD	imagerel $LN29+612
	DD	imagerel $unwind$VolumeThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$VolumeThreadProc DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
xdata	ENDS
;	COMDAT VolumeThreadProc
_TEXT	SEGMENT
Context$ = 96
VolumeThreadProc PROC					; COMDAT

; 1915 : {

$LN29:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1916 : 	PTHREAD_BLOCK pThreadBlock = (PTHREAD_BLOCK) Context;
; 1917 : 	PDEVICE_OBJECT DeviceObject = pThreadBlock->DeviceObject;

  0001c	48 8b 29	 mov	 rbp, QWORD PTR [rcx]
  0001f	48 8b d9	 mov	 rbx, rcx

; 1918 : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;
; 1919 : 	BOOL bDevice;
; 1920 : 
; 1921 : 	/* Set thread priority to lowest realtime level. */
; 1922 : 	KeSetPriorityThread (KeGetCurrentThread (), LOW_REALTIME_PRIORITY);

  00022	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  0002b	48 8b 7d 40	 mov	 rdi, QWORD PTR [rbp+64]
  0002f	ba 10 00 00 00	 mov	 edx, 16
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetPriorityThread

; 1923 : 
; 1924 : 	Dump ("Mount THREAD OPENING VOLUME BEGIN\n");
; 1925 : 
; 1926 : 	if (memcmp (pThreadBlock->mount->wszVolume, WIDE ("\\Device"), 14) != 0)

  0003a	4c 8b 8b 28 02
	00 00		 mov	 r9, QWORD PTR [rbx+552]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
  00048	49 8b 51 10	 mov	 rdx, QWORD PTR [r9+16]
  0004c	45 33 e4	 xor	 r12d, r12d
  0004f	48 3b 11	 cmp	 rdx, QWORD PTR [rcx]
  00052	75 19		 jne	 SHORT $LN27@VolumeThre
  00054	41 8b 51 18	 mov	 edx, DWORD PTR [r9+24]
  00058	3b 51 08	 cmp	 edx, DWORD PTR [rcx+8]
  0005b	75 10		 jne	 SHORT $LN27@VolumeThre
  0005d	66 41 8b 51 1c	 mov	 dx, WORD PTR [r9+28]
  00062	66 3b 51 0c	 cmp	 dx, WORD PTR [rcx+12]
  00066	75 05		 jne	 SHORT $LN27@VolumeThre
  00068	41 8b c4	 mov	 eax, r12d
  0006b	eb 05		 jmp	 SHORT $LN28@VolumeThre
$LN27@VolumeThre:
  0006d	1b c0		 sbb	 eax, eax
  0006f	83 d8 ff	 sbb	 eax, -1
$LN28@VolumeThre:
  00072	41 bd 01 00 00
	00		 mov	 r13d, 1

; 1927 : 	{
; 1928 : 		wcscpy (pThreadBlock->wszMountVolume, WIDE ("\\??\\"));

  00078	48 8d 73 0c	 lea	 rsi, QWORD PTR [rbx+12]
  0007c	41 3b c4	 cmp	 eax, r12d
  0007f	74 3d		 je	 SHORT $LN13@VolumeThre
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
  00088	48 8b d6	 mov	 rdx, rsi
  0008b	48 2b d1	 sub	 rdx, rcx
$LL16@VolumeThre:
  0008e	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00091	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00095	48 83 c1 02	 add	 rcx, 2
  00099	66 41 3b c4	 cmp	 ax, r12w
  0009d	75 ef		 jne	 SHORT $LL16@VolumeThre

; 1929 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1930 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 5);

  0009f	48 8b 93 28 02
	00 00		 mov	 rdx, QWORD PTR [rbx+552]
  000a6	41 b8 07 01 00
	00		 mov	 r8d, 263		; 00000107H
  000ac	48 8b ce	 mov	 rcx, rsi
  000af	48 83 c2 10	 add	 rdx, 16
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 1931 : 		bDevice = FALSE;

  000b9	45 8b dc	 mov	 r11d, r12d

; 1932 : 	}
; 1933 : 	else

  000bc	eb 1a		 jmp	 SHORT $LN12@VolumeThre
$LN13@VolumeThre:

; 1934 : 	{
; 1935 : 		pThreadBlock->wszMountVolume[0] = 0;
; 1936 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1937 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 1);

  000be	49 8d 51 10	 lea	 rdx, QWORD PTR [r9+16]
  000c2	41 b8 0b 01 00
	00		 mov	 r8d, 267		; 0000010bH
  000c8	48 8b ce	 mov	 rcx, rsi
  000cb	66 44 89 26	 mov	 WORD PTR [rsi], r12w
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 1938 : 		bDevice = TRUE;

  000d5	45 8b dd	 mov	 r11d, r13d
$LN12@VolumeThre:

; 1939 : 	}
; 1940 : 
; 1941 : 	Dump ("Mount THREAD request for File %ls DriveNumber %d Device = %d\n",
; 1942 : 	      pThreadBlock->wszMountVolume, pThreadBlock->mount->nDosDriveNo, bDevice);
; 1943 : 
; 1944 : 	pThreadBlock->ntCreateStatus = GSTOpenVolume (DeviceObject,
; 1945 : 		Extension,
; 1946 : 		pThreadBlock->mount,
; 1947 : 		pThreadBlock->wszMountVolume,
; 1948 : 		bDevice);

  000d8	4c 8b 83 28 02
	00 00		 mov	 r8, QWORD PTR [rbx+552]
  000df	4c 8b ce	 mov	 r9, rsi
  000e2	48 8b d7	 mov	 rdx, rdi
  000e5	48 8b cd	 mov	 rcx, rbp
  000e8	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  000ed	e8 00 00 00 00	 call	 GSTOpenVolume

; 1949 : 
; 1950 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus) || pThreadBlock->mount->nReturnCode != 0)

  000f2	41 3b c4	 cmp	 eax, r12d
  000f5	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  000f8	7c 0c		 jl	 SHORT $LN10@VolumeThre
  000fa	48 8b 83 28 02
	00 00		 mov	 rax, QWORD PTR [rbx+552]
  00101	44 39 20	 cmp	 DWORD PTR [rax], r12d
  00104	74 17		 je	 SHORT $LN11@VolumeThre
$LN10@VolumeThre:

; 1951 : 	{
; 1952 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00106	48 8d 4f 28	 lea	 rcx, QWORD PTR [rdi+40]
  0010a	45 33 c0	 xor	 r8d, r8d
  0010d	33 d2		 xor	 edx, edx
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 1953 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  00115	33 c9		 xor	 ecx, ecx
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN11@VolumeThre:

; 1954 : 	}
; 1955 : 
; 1956 : 	// Start IO queue
; 1957 : 	Extension->Queue.IsFilterDevice = FALSE;
; 1958 : 	Extension->Queue.DeviceObject = DeviceObject;
; 1959 : 	Extension->Queue.CryptoInfo = Extension->cryptoInfo;

  0011d	48 8b 87 90 00
	00 00		 mov	 rax, QWORD PTR [rdi+144]
  00124	44 89 a7 48 01
	00 00		 mov	 DWORD PTR [rdi+328], r12d
  0012b	48 89 af e0 00
	00 00		 mov	 QWORD PTR [rdi+224], rbp
  00132	48 89 87 28 01
	00 00		 mov	 QWORD PTR [rdi+296], rax

; 1960 : 	Extension->Queue.HostFileHandle = Extension->hDeviceFile;

  00139	48 8b 47 78	 mov	 rax, QWORD PTR [rdi+120]
  0013d	48 89 87 30 01
	00 00		 mov	 QWORD PTR [rdi+304], rax

; 1961 : 	Extension->Queue.VirtualDeviceLength = Extension->DiskLength;

  00144	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  0014b	48 89 87 38 01
	00 00		 mov	 QWORD PTR [rdi+312], rax

; 1962 : 	Extension->Queue.MaxReadAheadOffset.QuadPart = Extension->HostLength;

  00152	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  00159	48 89 87 b8 02
	00 00		 mov	 QWORD PTR [rdi+696], rax

; 1963 : 
; 1964 : 	if (Extension->SecurityClientContextValid)

  00160	44 39 a7 90 05
	00 00		 cmp	 DWORD PTR [rdi+1424], r12d
  00167	74 10		 je	 SHORT $LN9@VolumeThre

; 1965 : 		Extension->Queue.SecurityClientContext = &Extension->SecurityClientContext;

  00169	48 8d 87 98 05
	00 00		 lea	 rax, QWORD PTR [rdi+1432]
  00170	48 89 87 40 01
	00 00		 mov	 QWORD PTR [rdi+320], rax

; 1966 : 	else

  00177	eb 07		 jmp	 SHORT $LN8@VolumeThre
$LN9@VolumeThre:

; 1967 : 		Extension->Queue.SecurityClientContext = NULL;

  00179	4c 89 a7 40 01
	00 00		 mov	 QWORD PTR [rdi+320], r12
$LN8@VolumeThre:

; 1968 : 
; 1969 : 	pThreadBlock->ntCreateStatus = EncryptedIoQueueStart (&Extension->Queue);

  00180	48 8d 8f e0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+224]
  00187	e8 00 00 00 00	 call	 EncryptedIoQueueStart

; 1970 : 
; 1971 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus))

  0018c	41 3b c4	 cmp	 eax, r12d
  0018f	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  00192	7d 2c		 jge	 SHORT $LN7@VolumeThre

; 1972 : 	{
; 1973 : 		GSTCloseVolume (DeviceObject, Extension);

  00194	48 8b d7	 mov	 rdx, rdi
  00197	48 8b cd	 mov	 rcx, rbp
  0019a	e8 00 00 00 00	 call	 GSTCloseVolume

; 1974 : 
; 1975 : 		pThreadBlock->mount->nReturnCode = ERR_OS_ERROR;

  0019f	4c 8b 9b 28 02
	00 00		 mov	 r11, QWORD PTR [rbx+552]

; 1976 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  001a6	48 8d 4f 28	 lea	 rcx, QWORD PTR [rdi+40]
  001aa	45 33 c0	 xor	 r8d, r8d
  001ad	33 d2		 xor	 edx, edx
  001af	45 89 2b	 mov	 DWORD PTR [r11], r13d
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 1977 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  001b8	33 c9		 xor	 ecx, ecx
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN7@VolumeThre:

; 1978 : 	}
; 1979 : 
; 1980 : 	KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  001c0	48 8d 4f 28	 lea	 rcx, QWORD PTR [rdi+40]
  001c4	45 33 c0	 xor	 r8d, r8d
  001c7	33 d2		 xor	 edx, edx
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LL6@VolumeThre:

; 1981 : 	/* From this point on pThreadBlock cannot be used as it will have been released! */
; 1982 : 	pThreadBlock = NULL;
; 1983 : 
; 1984 : 	for (;;)
; 1985 : 	{
; 1986 : 		/* Wait for a request from the dispatch routines. */
; 1987 : 		KeWaitForSingleObject ((PVOID) & Extension->RequestSemaphore, Executive, KernelMode, FALSE, NULL);

  001cf	48 8d 4f 58	 lea	 rcx, QWORD PTR [rdi+88]
  001d3	45 33 c9	 xor	 r9d, r9d
  001d6	45 33 c0	 xor	 r8d, r8d
  001d9	33 d2		 xor	 edx, edx
  001db	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1988 : 
; 1989 : 		for (;;)
; 1990 : 		{
; 1991 : 			PIO_STACK_LOCATION irpSp;
; 1992 : 			PLIST_ENTRY request;
; 1993 : 			PIRP irp;
; 1994 : 
; 1995 : 			request = ExInterlockedRemoveHeadList (&Extension->ListEntry, &Extension->ListSpinLock);

  001e6	48 8d 57 40	 lea	 rdx, QWORD PTR [rdi+64]
  001ea	48 8d 4f 48	 lea	 rcx, QWORD PTR [rdi+72]
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList

; 1996 : 			if (request == NULL)

  001f4	49 3b c4	 cmp	 rax, r12
  001f7	74 41		 je	 SHORT $LN25@VolumeThre
$LL4@VolumeThre:

; 1997 : 				break;
; 1998 : 
; 1999 : 			irp = CONTAINING_RECORD (request, IRP, Tail.Overlay.ListEntry);

  001f9	48 8d 98 58 ff
	ff ff		 lea	 rbx, QWORD PTR [rax-168]

; 2000 : 			irpSp = IoGetCurrentIrpStackLocation (irp);
; 2001 : 
; 2002 : 			ASSERT (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);
; 2003 : 
; 2004 : 			ProcessVolumeDeviceControlIrp (DeviceObject, Extension, irp);

  00200	48 8b d7	 mov	 rdx, rdi
  00203	48 8b cd	 mov	 rcx, rbp
  00206	4c 8b c3	 mov	 r8, rbx
  00209	e8 00 00 00 00	 call	 ProcessVolumeDeviceControlIrp

; 2005 : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, irp);

  0020e	48 8d 8f 80 01
	00 00		 lea	 rcx, QWORD PTR [rdi+384]
  00215	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0021b	48 8b d3	 mov	 rdx, rbx
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx
  00224	48 8d 57 40	 lea	 rdx, QWORD PTR [rdi+64]
  00228	48 8d 4f 48	 lea	 rcx, QWORD PTR [rdi+72]
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList
  00232	48 85 c0	 test	 rax, rax
  00235	75 c2		 jne	 SHORT $LL4@VolumeThre
  00237	45 33 e4	 xor	 r12d, r12d
$LN25@VolumeThre:

; 2006 : 		}
; 2007 : 
; 2008 : 		if (Extension->bThreadShouldQuit)

  0023a	44 39 67 1c	 cmp	 DWORD PTR [rdi+28], r12d
  0023e	74 8f		 je	 SHORT $LL6@VolumeThre

; 2009 : 		{
; 2010 : 			Dump ("Closing volume\n");
; 2011 : 			EncryptedIoQueueStop (&Extension->Queue);

  00240	48 8d 8f e0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+224]
  00247	e8 00 00 00 00	 call	 EncryptedIoQueueStop

; 2012 : 
; 2013 : 			GSTCloseVolume (DeviceObject, Extension);

  0024c	48 8b d7	 mov	 rdx, rdi
  0024f	48 8b cd	 mov	 rcx, rbp
  00252	e8 00 00 00 00	 call	 GSTCloseVolume

; 2014 : 			PsTerminateSystemThread (STATUS_SUCCESS);

  00257	33 c9		 xor	 ecx, ecx
  00259	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
  0025f	e9 6b ff ff ff	 jmp	 $LL6@VolumeThre
VolumeThreadProc ENDP
_TEXT	ENDS
PUBLIC	GSTStartVolumeThread
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$GSTStartVolumeThread DD imagerel $LN12
	DD	imagerel $LN12+382
	DD	imagerel $unwind$GSTStartVolumeThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTStartVolumeThread DD 081701H
	DD	0146417H
	DD	0135417H
	DD	0123417H
	DD	07010f217H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
xdata	ENDS
;	COMDAT GSTStartVolumeThread
_TEXT	SEGMENT
qos$ = 64
threadObjAttributes$ = 80
DeviceObject$ = 144
Extension$ = 152
mount$ = 160
hThread$ = 168
GSTStartVolumeThread PROC				; COMDAT

; 1762 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	49 8b d8	 mov	 rbx, r8
  0001a	48 8b f2	 mov	 rsi, rdx
  0001d	48 8b e9	 mov	 rbp, rcx

; 1763 : 	PTHREAD_BLOCK pThreadBlock = GSTalloc (sizeof (THREAD_BLOCK));

  00020	ba 30 02 00 00	 mov	 edx, 560		; 00000230H
  00025	33 c9		 xor	 ecx, ecx
  00027	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00033	48 8b f8	 mov	 rdi, rax

; 1764 : 	HANDLE hThread;
; 1765 : 	NTSTATUS ntStatus;
; 1766 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1767 : 	SECURITY_QUALITY_OF_SERVICE qos;
; 1768 : 
; 1769 : 	Dump ("Starting thread...\n");
; 1770 : 
; 1771 : 	if (pThreadBlock == NULL)

  00036	48 85 c0	 test	 rax, rax
  00039	75 0a		 jne	 SHORT $LN5@GSTStartVo

; 1772 : 	{
; 1773 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0003b	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00040	e9 20 01 00 00	 jmp	 $LN6@GSTStartVo
$LN5@GSTStartVo:

; 1774 : 	}
; 1775 : 	else
; 1776 : 	{
; 1777 : 		pThreadBlock->DeviceObject = DeviceObject;

  00045	48 89 28	 mov	 QWORD PTR [rax], rbp

; 1778 : 		pThreadBlock->mount = mount;

  00048	48 89 98 28 02
	00 00		 mov	 QWORD PTR [rax+552], rbx

; 1779 : 	}
; 1780 : 
; 1781 : 	qos.Length = sizeof (qos);

  0004f	c7 44 24 40 0c
	00 00 00	 mov	 DWORD PTR qos$[rsp], 12

; 1782 : 	qos.ContextTrackingMode = SECURITY_STATIC_TRACKING;

  00057	c6 44 24 48 00	 mov	 BYTE PTR qos$[rsp+8], 0

; 1783 : 	qos.EffectiveOnly = TRUE;

  0005c	c6 44 24 49 01	 mov	 BYTE PTR qos$[rsp+9], 1

; 1784 : 	qos.ImpersonationLevel = SecurityImpersonation;

  00061	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR qos$[rsp+4], 2

; 1785 : 
; 1786 : 	ntStatus = SeCreateClientSecurity (PsGetCurrentThread(), &qos, FALSE, &Extension->SecurityClientContext);

  00069	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  00072	4c 8d 8e 98 05
	00 00		 lea	 r9, QWORD PTR [rsi+1432]
  00079	48 8d 54 24 40	 lea	 rdx, QWORD PTR qos$[rsp]
  0007e	45 33 c0	 xor	 r8d, r8d
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCreateClientSecurity
  00087	8b d8		 mov	 ebx, eax

; 1787 : 	if (!NT_SUCCESS (ntStatus))

  00089	85 c0		 test	 eax, eax
  0008b	0f 88 c4 00 00
	00		 js	 $ret$31028

; 1788 : 		goto ret;
; 1789 : 
; 1790 : 	Extension->SecurityClientContextValid = TRUE;
; 1791 : 
; 1792 : 	Extension->bThreadShouldQuit = FALSE;

  00091	83 66 1c 00	 and	 DWORD PTR [rsi+28], 0

; 1793 : 
; 1794 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  00095	48 83 64 24 58
	00		 and	 QWORD PTR threadObjAttributes$[rsp+8], 0
  0009b	48 83 64 24 60
	00		 and	 QWORD PTR threadObjAttributes$[rsp+16], 0
  000a1	48 83 64 24 70
	00		 and	 QWORD PTR threadObjAttributes$[rsp+32], 0
  000a7	48 83 64 24 78
	00		 and	 QWORD PTR threadObjAttributes$[rsp+40], 0

; 1795 : 
; 1796 : 	ntStatus = PsCreateSystemThread (&hThread,
; 1797 : 					 THREAD_ALL_ACCESS,
; 1798 : 					 &threadObjAttributes,
; 1799 : 					 NULL,
; 1800 : 					 NULL,
; 1801 : 					 VolumeThreadProc,
; 1802 : 					 pThreadBlock);

  000ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:VolumeThreadProc
  000b4	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  000b9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000be	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000c4	bd ff 03 1f 00	 mov	 ebp, 2032639		; 001f03ffH
  000c9	4c 8d 44 24 50	 lea	 r8, QWORD PTR threadObjAttributes$[rsp]
  000ce	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR hThread$[rsp]
  000d6	45 33 c9	 xor	 r9d, r9d
  000d9	8b d5		 mov	 edx, ebp
  000db	c7 86 90 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rsi+1424], 1
  000e5	c7 44 24 50 30
	00 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp], 48 ; 00000030H
  000ed	c7 44 24 68 00
	02 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp+24], 512 ; 00000200H
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread
  000fb	8b d8		 mov	 ebx, eax

; 1803 : 
; 1804 : 	if (!NT_SUCCESS (ntStatus))

  000fd	85 c0		 test	 eax, eax
  000ff	78 54		 js	 SHORT $ret$31028

; 1805 : 	{
; 1806 : 		Dump ("PsCreateSystemThread Failed END\n");
; 1807 : 		goto ret;
; 1808 : 	}
; 1809 : 
; 1810 : 	ntStatus = ObReferenceObjectByHandle (hThread,
; 1811 : 				   THREAD_ALL_ACCESS,
; 1812 : 				   NULL,
; 1813 : 				   KernelMode,
; 1814 : 				   &Extension->peThread,
; 1815 : 				   NULL);

  00101	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR hThread$[rsp]
  00109	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  0010f	48 8d 46 20	 lea	 rax, QWORD PTR [rsi+32]
  00113	45 33 c9	 xor	 r9d, r9d
  00116	45 33 c0	 xor	 r8d, r8d
  00119	8b d5		 mov	 edx, ebp
  0011b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle

; 1816 : 
; 1817 : 	ZwClose (hThread);

  00126	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR hThread$[rsp]
  0012e	8b d8		 mov	 ebx, eax
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1818 : 
; 1819 : 	if (!NT_SUCCESS (ntStatus))

  00136	85 db		 test	 ebx, ebx
  00138	78 1b		 js	 SHORT $ret$31028

; 1820 : 		goto ret;
; 1821 : 
; 1822 : 	Dump ("Waiting for thread to initialize...\n");
; 1823 : 
; 1824 : 	KeWaitForSingleObject (&Extension->keCreateEvent,
; 1825 : 			       Executive,
; 1826 : 			       KernelMode,
; 1827 : 			       FALSE,
; 1828 : 			       NULL);

  0013a	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00140	48 8d 4e 28	 lea	 rcx, QWORD PTR [rsi+40]
  00144	45 33 c9	 xor	 r9d, r9d
  00147	45 33 c0	 xor	 r8d, r8d
  0014a	33 d2		 xor	 edx, edx
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1829 : 
; 1830 : 	Dump ("Waiting completed! Thread returns 0x%08x\n", pThreadBlock->ntCreateStatus);
; 1831 : 	ntStatus = pThreadBlock->ntCreateStatus;

  00152	8b 5f 08	 mov	 ebx, DWORD PTR [rdi+8]
$ret$31028:

; 1832 : 
; 1833 : ret:
; 1834 : 	GSTfree (pThreadBlock);

  00155	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0015a	48 8b cf	 mov	 rcx, rdi
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 1835 : 	return ntStatus;

  00163	8b c3		 mov	 eax, ebx
$LN6@GSTStartVo:

; 1836 : }

  00165	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  0016d	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00171	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  00175	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00179	49 8b e3	 mov	 rsp, r11
  0017c	5f		 pop	 rdi
  0017d	c3		 ret	 0
GSTStartVolumeThread ENDP
PUBLIC	mount$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	MountDevice
EXTRN	__GSHandlerCheck_SEH:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountDevice DD imagerel $LN32
	DD	imagerel $LN32+706
	DD	imagerel $unwind$MountDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountDevice DD 072419H
	DD	0596412H
	DD	0583412H
	DD	0540112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck_SEH
	DD	01H
	DD	imagerel $LN32+547
	DD	imagerel $LN32+606
	DD	01H
	DD	imagerel $LN32+606
	DD	0291H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT MountDevice
_TEXT	SEGMENT
NewDeviceObject$ = 48
deviceName$42214 = 56
fsStatus$31488 = 56
tokenUser$31467 = 56
volumeFileObject$31482 = 72
volumeHandle$31481 = 80
mount$GSCopy$ = 88
subContext$31455 = 96
symLink$42215 = 128
dev$42212 = 144
link$42213 = 400
__$ArrayPad$ = 656
DeviceObject$ = 688
mount$ = 696
MountDevice PROC					; COMDAT

; 2870 : {

$LN32:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec a0 02
	00 00		 sub	 rsp, 672		; 000002a0H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00024	48 8b fa	 mov	 rdi, rdx
  00027	48 8b d9	 mov	 rbx, rcx

; 2871 : 	PDEVICE_OBJECT NewDeviceObject;
; 2872 : 	NTSTATUS ntStatus;
; 2873 : 
; 2874 : 	// Make sure the user is asking for a reasonable nDosDriveNo
; 2875 : 	if (mount->nDosDriveNo >= 0 && mount->nDosDriveNo <= 25 && IsDriveLetterAvailable (mount->nDosDriveNo))

  0002a	48 89 54 24 58	 mov	 QWORD PTR mount$GSCopy$[rsp], rdx
  0002f	8b 8a 64 02 00
	00		 mov	 ecx, DWORD PTR [rdx+612]
  00035	85 c9		 test	 ecx, ecx
  00037	0f 88 59 02 00
	00		 js	 $LN20@MountDevic
  0003d	83 f9 19	 cmp	 ecx, 25
  00040	0f 8f 50 02 00
	00		 jg	 $LN20@MountDevic
  00046	e8 00 00 00 00	 call	 IsDriveLetterAvailable
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 43 02 00
	00		 je	 $LN20@MountDevic

; 2883 : 		return ERR_DRIVE_NOT_FOUND;
; 2884 : 	}
; 2885 : 
; 2886 : 	if (!SelfTestsPassed)

  00053	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR SelfTestsPassed, 0
  0005a	75 0c		 jne	 SHORT $LN18@MountDevic

; 2887 : 	{
; 2888 : 		mount->nReturnCode = ERR_SELF_TESTS_FAILED;

  0005c	b8 13 00 00 00	 mov	 eax, 19
  00061	89 07		 mov	 DWORD PTR [rdi], eax

; 2889 : 		return ERR_SELF_TESTS_FAILED;

  00063	e9 35 02 00 00	 jmp	 $LN8@MountDevic
$LN18@MountDevic:

; 2890 : 	}
; 2891 : 
; 2892 : 	ntStatus = GSTCreateDeviceObject (DeviceObject->DriverObject, &NewDeviceObject, mount);

  00068	4c 8b c7	 mov	 r8, rdi
  0006b	48 8d 54 24 30	 lea	 rdx, QWORD PTR NewDeviceObject$[rsp]
  00070	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00074	e8 00 00 00 00	 call	 GSTCreateDeviceObject

; 2893 : 
; 2894 : 	if (!NT_SUCCESS (ntStatus))

  00079	85 c0		 test	 eax, eax

; 2895 : 	{
; 2896 : 		Dump ("Mount CREATE DEVICE ERROR, ntStatus = 0x%08x\n", ntStatus);
; 2897 : 		return ntStatus;

  0007b	0f 88 1c 02 00
	00		 js	 $LN8@MountDevic

; 2898 : 	}
; 2899 : 	else
; 2900 : 	{
; 2901 : 		PEXTENSION NewExtension = (PEXTENSION) NewDeviceObject->DeviceExtension;

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  00086	48 8b 70 40	 mov	 rsi, QWORD PTR [rax+64]

; 2902 : 		SECURITY_SUBJECT_CONTEXT subContext;
; 2903 : 		PACCESS_TOKEN accessToken;
; 2904 : 
; 2905 : 		SeCaptureSubjectContext (&subContext);

  0008a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR subContext$31455[rsp]
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCaptureSubjectContext

; 2906 : 		accessToken = SeQuerySubjectContextToken (&subContext);

  00095	48 8b 4c 24 70	 mov	 rcx, QWORD PTR subContext$31455[rsp+16]
  0009a	48 8b 44 24 60	 mov	 rax, QWORD PTR subContext$31455[rsp]
  0009f	48 85 c0	 test	 rax, rax
  000a2	48 0f 45 c8	 cmovne	 rcx, rax

; 2907 : 
; 2908 : 		if (!accessToken)

  000a6	48 85 c9	 test	 rcx, rcx
  000a9	75 07		 jne	 SHORT $LN15@MountDevic

; 2909 : 		{
; 2910 : 			ntStatus = STATUS_INVALID_PARAMETER;

  000ab	bb 0d 00 00 c0	 mov	 ebx, -1073741811	; ffffffffc000000dH

; 2911 : 		}
; 2912 : 		else

  000b0	eb 6b		 jmp	 SHORT $LN13@MountDevic
$LN15@MountDevic:

; 2913 : 		{
; 2914 : 			PTOKEN_USER tokenUser;
; 2915 : 
; 2916 : 			ntStatus = SeQueryInformationToken (accessToken, TokenUser, &tokenUser);

  000b2	4c 8d 44 24 38	 lea	 r8, QWORD PTR tokenUser$31467[rsp]
  000b7	ba 01 00 00 00	 mov	 edx, 1
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeQueryInformationToken
  000c2	8b d8		 mov	 ebx, eax

; 2917 : 			if (NT_SUCCESS (ntStatus))

  000c4	85 c0		 test	 eax, eax
  000c6	78 55		 js	 SHORT $LN13@MountDevic

; 2918 : 			{
; 2919 : 				ULONG sidLength = RtlLengthSid (tokenUser->User.Sid);

  000c8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tokenUser$31467[rsp]
  000cd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlLengthSid
  000d6	8b d8		 mov	 ebx, eax

; 2920 : 
; 2921 : 				NewExtension->UserSid = GSTalloc (sidLength);

  000d8	8b d0		 mov	 edx, eax
  000da	33 c9		 xor	 ecx, ecx
  000dc	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000e8	48 89 86 88 05
	00 00		 mov	 QWORD PTR [rsi+1416], rax

; 2922 : 				if (!NewExtension->UserSid)

  000ef	48 85 c0	 test	 rax, rax
  000f2	75 07		 jne	 SHORT $LN12@MountDevic

; 2923 : 					ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  000f4	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; ffffffffc000009aH

; 2924 : 				else

  000f9	eb 15		 jmp	 SHORT $LN11@MountDevic
$LN12@MountDevic:

; 2925 : 					ntStatus = RtlCopySid (sidLength, NewExtension->UserSid, tokenUser->User.Sid);

  000fb	4c 8b 44 24 38	 mov	 r8, QWORD PTR tokenUser$31467[rsp]
  00100	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00103	48 8b d0	 mov	 rdx, rax
  00106	8b cb		 mov	 ecx, ebx
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopySid
  0010e	8b d8		 mov	 ebx, eax
$LN11@MountDevic:

; 2926 : 
; 2927 : 				ExFreePool (tokenUser);		// Documented in newer versions of WDK

  00110	33 d2		 xor	 edx, edx
  00112	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tokenUser$31467[rsp]
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN13@MountDevic:

; 2928 : 			}
; 2929 : 		}
; 2930 : 
; 2931 : 		SeReleaseSubjectContext (&subContext);

  0011d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR subContext$31455[rsp]
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeReleaseSubjectContext

; 2932 : 
; 2933 : 		if (NT_SUCCESS (ntStatus))

  00128	85 db		 test	 ebx, ebx
  0012a	78 12		 js	 SHORT $LN10@MountDevic

; 2934 : 			ntStatus = GSTStartVolumeThread (NewDeviceObject, NewExtension, mount);

  0012c	4c 8b c7	 mov	 r8, rdi
  0012f	48 8b d6	 mov	 rdx, rsi
  00132	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  00137	e8 00 00 00 00	 call	 GSTStartVolumeThread
  0013c	8b d8		 mov	 ebx, eax
$LN10@MountDevic:

; 2935 : 
; 2936 : 		if (!NT_SUCCESS (ntStatus))

  0013e	85 db		 test	 ebx, ebx
  00140	79 14		 jns	 SHORT $LN9@MountDevic

; 2937 : 		{
; 2938 : 			Dump ("Mount FAILURE NT ERROR, ntStatus = 0x%08x\n", ntStatus);
; 2939 : 			GSTDeleteDeviceObject (NewDeviceObject, NewExtension);

  00142	48 8b d6	 mov	 rdx, rsi
  00145	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  0014a	e8 00 00 00 00	 call	 GSTDeleteDeviceObject

; 2940 : 			return ntStatus;

  0014f	8b c3		 mov	 eax, ebx
  00151	e9 47 01 00 00	 jmp	 $LN8@MountDevic
$LN9@MountDevic:

; 2941 : 		}
; 2942 : 		else
; 2943 : 		{
; 2944 : 			if (mount->nReturnCode == 0)

  00156	83 3f 00	 cmp	 DWORD PTR [rdi], 0
  00159	0f 85 26 01 00
	00		 jne	 $LN7@MountDevic

; 2945 : 			{
; 2946 : 				HANDLE volumeHandle;
; 2947 : 				PFILE_OBJECT volumeFileObject;
; 2948 : 
; 2949 : 				Dump ("Mount SUCCESS GST code = 0x%08x READ-ONLY = %d\n", mount->nReturnCode, NewExtension->bReadOnly);
; 2950 : 
; 2951 : 				if (NewExtension->bReadOnly)

  0015f	83 be 40 03 00
	00 00		 cmp	 DWORD PTR [rsi+832], 0
  00166	74 09		 je	 SHORT $LN6@MountDevic

; 2952 : 					NewDeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  00168	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  0016d	83 48 34 02	 or	 DWORD PTR [rax+52], 2
$LN6@MountDevic:

; 2953 : 
; 2954 : 				NewDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00171	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  00176	0f ba 70 30 07	 btr	 DWORD PTR [rax+48], 7

; 2955 : 
; 2956 : 				NewExtension->UniqueVolumeId = LastUniqueVolumeId++;

  0017b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR LastUniqueVolumeId
  00181	89 46 10	 mov	 DWORD PTR [rsi+16], eax
  00184	ff c0		 inc	 eax
  00186	89 05 00 00 00
	00		 mov	 DWORD PTR LastUniqueVolumeId, eax

; 2957 : 
; 2958 : 				if (mount->bMountManager)

  0018c	83 bf 78 02 00
	00 00		 cmp	 DWORD PTR [rdi+632], 0
  00193	74 08		 je	 SHORT $LN5@MountDevic

; 2959 : 					MountManagerMount (mount);

  00195	48 8b cf	 mov	 rcx, rdi
  00198	e8 00 00 00 00	 call	 MountManagerMount
$LN5@MountDevic:

; 2960 : 
; 2961 : 				NewExtension->bMountManager = mount->bMountManager;

  0019d	8b 87 78 02 00
	00		 mov	 eax, DWORD PTR [rdi+632]
  001a3	89 86 50 03 00
	00		 mov	 DWORD PTR [rsi+848], eax

; 2962 : 
; 2963 : 				// We create symbolic link even if mount manager is notified of
; 2964 : 				// arriving volume as it apparently sometimes fails to create the link
; 2965 : 				CreateDriveLink (mount->nDosDriveNo);

  001a9	8b 9f 64 02 00
	00		 mov	 ebx, DWORD PTR [rdi+612]
  001af	8b d3		 mov	 edx, ebx
  001b1	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR dev$42212[rsp]
  001b9	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber
  001be	8b d3		 mov	 edx, ebx
  001c0	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR link$42213[rsp]
  001c8	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber
  001cd	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR dev$42212[rsp]
  001d5	48 8d 4c 24 38	 lea	 rcx, QWORD PTR deviceName$42214[rsp]
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString
  001e0	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR link$42213[rsp]
  001e8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR symLink$42215[rsp]
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString
  001f6	48 8d 54 24 38	 lea	 rdx, QWORD PTR deviceName$42214[rsp]
  001fb	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR symLink$42215[rsp]
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink

; 2966 : 
; 2967 : 				mount->FilesystemDirty = FALSE;

  00209	83 67 04 00	 and	 DWORD PTR [rdi+4], 0

; 2968 : 
; 2969 : 				if (NT_SUCCESS (GSTOpenFsVolume (NewExtension, &volumeHandle, &volumeFileObject)))

  0020d	4c 8d 44 24 48	 lea	 r8, QWORD PTR volumeFileObject$31482[rsp]
  00212	48 8d 54 24 50	 lea	 rdx, QWORD PTR volumeHandle$31481[rsp]
  00217	48 8b ce	 mov	 rcx, rsi
  0021a	e8 00 00 00 00	 call	 GSTOpenFsVolume
  0021f	85 c0		 test	 eax, eax
  00221	78 6f		 js	 SHORT $LN1@MountDevic

; 2970 : 				{
; 2971 : 					__try
; 2972 : 					{
; 2973 : 						ULONG fsStatus;
; 2974 : 
; 2975 : 						if (NT_SUCCESS (GSTFsctlCall (volumeFileObject, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &fsStatus, sizeof (fsStatus)))
; 2976 : 							&& (fsStatus & VOLUME_IS_DIRTY))

  00223	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  0022b	48 8d 44 24 38	 lea	 rax, QWORD PTR fsStatus$31488[rsp]
  00230	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00235	45 33 c9	 xor	 r9d, r9d
  00238	45 33 c0	 xor	 r8d, r8d
  0023b	ba 78 00 09 00	 mov	 edx, 589944		; 00090078H
  00240	48 8b 4c 24 48	 mov	 rcx, QWORD PTR volumeFileObject$31482[rsp]
  00245	e8 00 00 00 00	 call	 GSTFsctlCall
  0024a	85 c0		 test	 eax, eax
  0024c	78 0e		 js	 SHORT $LN2@MountDevic
  0024e	f6 44 24 38 01	 test	 BYTE PTR fsStatus$31488[rsp], 1
  00253	74 07		 je	 SHORT $LN2@MountDevic

; 2977 : 						{
; 2978 : 							mount->FilesystemDirty = TRUE;

  00255	c7 47 04 01 00
	00 00		 mov	 DWORD PTR [rdi+4], 1
$LN2@MountDevic:

; 2979 : 						}
; 2980 : 					}

  0025c	eb 0c		 jmp	 SHORT $LN27@MountDevic
$LN25@MountDevic:

; 2981 : 					__except (EXCEPTION_EXECUTE_HANDLER)
; 2982 : 					{
; 2983 : 						mount->FilesystemDirty = TRUE;

  0025e	48 8b 44 24 58	 mov	 rax, QWORD PTR mount$GSCopy$[rsp]
  00263	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1
$LN27@MountDevic:

; 2984 : 					}
; 2985 : 
; 2986 : 
; 2987 : 					GSTCloseFsVolume (volumeHandle, volumeFileObject);

  0026a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR volumeHandle$31481[rsp]
  0026f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR volumeFileObject$31482[rsp]
  00274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
  0027a	48 8b cb	 mov	 rcx, rbx
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 2988 : 				}
; 2989 : 			}
; 2990 : 			else

  00283	eb 0d		 jmp	 SHORT $LN1@MountDevic
$LN7@MountDevic:

; 2991 : 			{
; 2992 : 				Dump ("Mount FAILURE GST code = 0x%08x\n", mount->nReturnCode);
; 2993 : 				GSTDeleteDeviceObject (NewDeviceObject, NewExtension);

  00285	48 8b d6	 mov	 rdx, rsi
  00288	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  0028d	e8 00 00 00 00	 call	 GSTDeleteDeviceObject
$LN1@MountDevic:

; 2994 : 			}
; 2995 : 			
; 2996 : 			return STATUS_SUCCESS;

  00292	33 c0		 xor	 eax, eax
  00294	eb 07		 jmp	 SHORT $LN8@MountDevic
$LN20@MountDevic:

; 2876 : 	{
; 2877 : 		Dump ("Mount request looks valid\n");
; 2878 : 	}
; 2879 : 	else
; 2880 : 	{
; 2881 : 		Dump ("WARNING: MOUNT DRIVE LETTER INVALID\n");
; 2882 : 		mount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  00296	b8 05 00 00 00	 mov	 eax, 5
  0029b	89 07		 mov	 DWORD PTR [rdi], eax
$LN8@MountDevic:

; 2997 : 		}
; 2998 : 	}
; 2999 : }

  0029d	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a5	48 33 cc	 xor	 rcx, rsp
  002a8	e8 00 00 00 00	 call	 __security_check_cookie
  002ad	4c 8d 9c 24 a0
	02 00 00	 lea	 r11, QWORD PTR [rsp+672]
  002b5	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  002b9	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  002bd	49 8b e3	 mov	 rsp, r11
  002c0	5f		 pop	 rdi
  002c1	c3		 ret	 0
MountDevice ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	ProcessMainDeviceControlIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessMainDeviceControlIrp DD imagerel $LN292
	DD	imagerel $LN292+4869
	DD	imagerel $unwind$ProcessMainDeviceControlIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessMainDeviceControlIrp DD 0b2919H
	DD	0873417H
	DD	07e0117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	03e0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ProcessMainDeviceControlIrp
_TEXT	SEGMENT
deviceObjectCount$30640 = 96
NtFileHandle$30666 = 104
NtFileHandle$30718 = 112
IoStatus$30668 = 120
offset$30721 = 136
offset$30669 = 144
lengthInfo$30831 = 152
fileObject$30856 = 160
deviceObject$30857 = 168
ObjectAttributes$30717 = 176
ObjectAttributes$30665 = 224
FullFileName$30667 = 272
FullFileName$30719 = 288
IoStatus$30720 = 304
name$30855 = 320
pi$30821 = 336
readBuffer$30722 = 480
__$ArrayPad$ = 992
DeviceObject$ = 1072
Extension$ = 1080
Irp$ = 1088
ProcessMainDeviceControlIrp PROC			; COMDAT

; 913  : {

$LN292:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 81 ec f0 03
	00 00		 sub	 rsp, 1008		; 000003f0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 914  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00029	4d 8b a0 b8 00
	00 00		 mov	 r12, QWORD PTR [r8+184]
  00030	4c 8b f1	 mov	 r14, rcx

; 915  : 	NTSTATUS ntStatus;
; 916  : 
; 917  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00033	b9 48 20 22 00	 mov	 ecx, 2236488		; 00222048H
  00038	41 8b 44 24 18	 mov	 eax, DWORD PTR [r12+24]
  0003d	49 8b f0	 mov	 rsi, r8
  00040	3b c1		 cmp	 eax, ecx
  00042	0f 87 e8 0c 00
	00		 ja	 $LN150@ProcessMai
  00048	0f 84 d2 0c 00
	00		 je	 $LN24@ProcessMai
  0004e	b9 20 20 22 00	 mov	 ecx, 2236448		; 00222020H
  00053	3b c1		 cmp	 eax, ecx
  00055	0f 87 58 05 00
	00		 ja	 $LN151@ProcessMai
  0005b	0f 84 28 05 00
	00		 je	 $LN141@ProcessMai
  00061	2d 04 20 07 00	 sub	 eax, 466948		; 00072004H
  00066	0f 84 da 04 00
	00		 je	 $LN74@ProcessMai
  0006c	83 e8 14	 sub	 eax, 20
  0006f	0f 84 9c 04 00
	00		 je	 $LN143@ProcessMai
  00075	2d ec ff 1a 00	 sub	 eax, 1769452		; 001affecH
  0007a	0f 84 91 04 00
	00		 je	 $LN143@ProcessMai
  00080	bf 04 00 00 00	 mov	 edi, 4
  00085	2b c7		 sub	 eax, edi
  00087	0f 84 49 04 00
	00		 je	 $LN21@ProcessMai
  0008d	2b c7		 sub	 eax, edi
  0008f	0f 84 a5 03 00
	00		 je	 $LN46@ProcessMai
  00095	2b c7		 sub	 eax, edi
  00097	0f 84 2a 03 00
	00		 je	 $LN32@ProcessMai
  0009d	2b c7		 sub	 eax, edi
  0009f	0f 84 f2 02 00
	00		 je	 $LN28@ProcessMai
  000a5	2b c7		 sub	 eax, edi
  000a7	0f 84 b6 01 00
	00		 je	 $LN87@ProcessMai
  000ad	3b c7		 cmp	 eax, edi
  000af	0f 85 a2 10 00
	00		 jne	 $LN1@ProcessMai

; 1271 : 
; 1272 : 	case GST_IOCTL_GET_VOLUME_PROPERTIES:
; 1273 : 		if (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))

  000b5	41 be 54 02 00
	00		 mov	 r14d, 596		; 00000254H
  000bb	44 8d 47 fe	 lea	 r8d, QWORD PTR [rdi-2]
  000bf	48 8b ce	 mov	 rcx, rsi
  000c2	49 8b d6	 mov	 rdx, r14
  000c5	e8 00 00 00 00	 call	 ValidateIOBufferSize
  000ca	33 db		 xor	 ebx, ebx
  000cc	3b c3		 cmp	 eax, ebx
  000ce	0f 84 f6 11 00
	00		 je	 $LN144@ProcessMai

; 1274 : 		{
; 1275 : 			VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  000d4	48 8b 7e 18	 mov	 rdi, QWORD PTR [rsi+24]

; 1276 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);

  000d8	83 3f 19	 cmp	 DWORD PTR [rdi], 25
  000db	77 14		 ja	 SHORT $LN184@ProcessMai
  000dd	48 63 07	 movsxd	 rax, DWORD PTR [rdi]
  000e0	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:__ImageBase
  000e7	4d 8b a4 c5 00
	00 00 00	 mov	 r12, QWORD PTR VirtualVolumeDeviceObjects[r13+rax*8]
  000ef	eb 03		 jmp	 SHORT $LN186@ProcessMai
$LN184@ProcessMai:
  000f1	4c 8b e3	 mov	 r12, rbx
$LN186@ProcessMai:

; 1277 : 
; 1278 : 			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  000f4	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH

; 1279 : 			Irp->IoStatus.Information = 0;

  000f9	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx
  000fd	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1280 : 
; 1281 : 			if (ListDevice)

  00100	4c 3b e3	 cmp	 r12, rbx
  00103	0f 84 c1 11 00
	00		 je	 $LN144@ProcessMai

; 1282 : 			{
; 1283 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00109	4d 8b 64 24 40	 mov	 r12, QWORD PTR [r12+64]

; 1284 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  0010e	49 8b cc	 mov	 rcx, r12
  00111	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  00116	3b c3		 cmp	 eax, ebx
  00118	0f 84 ac 11 00
	00		 je	 $LN144@ProcessMai

; 1285 : 				{
; 1286 : 					prop->uniqueId = ListExtension->UniqueVolumeId;

  0011e	41 8b 44 24 10	 mov	 eax, DWORD PTR [r12+16]

; 1287 : 					wcscpy (prop->wszVolume, ListExtension->wszVolume);

  00123	49 8d 8c 24 58
	03 00 00	 lea	 rcx, QWORD PTR [r12+856]
  0012b	48 8b d7	 mov	 rdx, rdi
  0012e	89 47 04	 mov	 DWORD PTR [rdi+4], eax
  00131	48 2b d1	 sub	 rdx, rcx
$LL149@ProcessMai:
  00134	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00137	48 83 c1 02	 add	 rcx, 2
  0013b	66 89 44 0a 06	 mov	 WORD PTR [rdx+rcx+6], ax
  00140	66 3b c3	 cmp	 ax, bx
  00143	75 ef		 jne	 SHORT $LL149@ProcessMai

; 1288 : 					prop->diskLength = ListExtension->DiskLength;

  00145	49 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR [r12+160]
  0014d	48 89 87 10 02
	00 00		 mov	 QWORD PTR [rdi+528], rax

; 1289 : 					prop->ea = ListExtension->cryptoInfo->ea;

  00154	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  0015c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0015e	89 8f 18 02 00
	00		 mov	 DWORD PTR [rdi+536], ecx

; 1290 : 					prop->mode = ListExtension->cryptoInfo->mode;

  00164	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  0016c	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  0016f	89 8f 1c 02 00
	00		 mov	 DWORD PTR [rdi+540], ecx

; 1291 : 					prop->pkcs5 = ListExtension->cryptoInfo->pkcs5;

  00175	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  0017d	8b 88 94 1e 00
	00		 mov	 ecx, DWORD PTR [rax+7828]
  00183	89 8f 20 02 00
	00		 mov	 DWORD PTR [rdi+544], ecx

; 1292 : 					prop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;

  00189	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  00191	8b 88 90 1e 00
	00		 mov	 ecx, DWORD PTR [rax+7824]
  00197	89 8f 24 02 00
	00		 mov	 DWORD PTR [rdi+548], ecx

; 1293 : #if 0
; 1294 : 					prop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;
; 1295 : 					prop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;
; 1296 : #endif
; 1297 : 					prop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;

  0019d	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  001a5	8b 88 08 1f 00
	00		 mov	 ecx, DWORD PTR [rax+7944]
  001ab	89 8f 38 02 00
	00		 mov	 DWORD PTR [rdi+568], ecx

; 1298 : 					prop->readOnly = ListExtension->bReadOnly;

  001b1	41 8b 84 24 40
	03 00 00	 mov	 eax, DWORD PTR [r12+832]
  001b9	89 87 2c 02 00
	00		 mov	 DWORD PTR [rdi+556], eax

; 1299 : 					prop->removable = ListExtension->bRemovable;

  001bf	41 8b 84 24 44
	03 00 00	 mov	 eax, DWORD PTR [r12+836]
  001c7	89 87 30 02 00
	00		 mov	 DWORD PTR [rdi+560], eax

; 1300 : 					prop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;

  001cd	41 8b 84 24 48
	03 00 00	 mov	 eax, DWORD PTR [r12+840]
  001d5	89 87 34 02 00
	00		 mov	 DWORD PTR [rdi+564], eax

; 1301 : 					prop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;

  001db	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  001e3	8b 88 48 04 00
	00		 mov	 ecx, DWORD PTR [rax+1096]
  001e9	89 8f 28 02 00
	00		 mov	 DWORD PTR [rdi+552], ecx

; 1302 : 
; 1303 : 					if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  001ef	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  001f7	39 98 a8 1e 00
	00		 cmp	 DWORD PTR [rax+7848], ebx
  001fd	74 16		 je	 SHORT $LN68@ProcessMai

; 1304 : 						prop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;

  001ff	8b 88 ac 1e 00
	00		 mov	 ecx, DWORD PTR [rax+7852]
  00205	f7 d9		 neg	 ecx
  00207	1b c0		 sbb	 eax, eax
  00209	f7 d8		 neg	 eax
  0020b	ff c0		 inc	 eax
  0020d	89 87 4c 02 00
	00		 mov	 DWORD PTR [rdi+588], eax

; 1305 : 					else

  00213	eb 06		 jmp	 SHORT $LN67@ProcessMai
$LN68@ProcessMai:

; 1306 : 						prop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;

  00215	89 9f 4c 02 00
	00		 mov	 DWORD PTR [rdi+588], ebx
$LN67@ProcessMai:

; 1307 : 
; 1308 : 					prop->totalBytesRead = ListExtension->Queue.TotalBytesRead;

  0021b	49 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR [r12+768]
  00223	48 89 87 3c 02
	00 00		 mov	 QWORD PTR [rdi+572], rax

; 1309 : 					prop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;

  0022a	49 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR [r12+776]
  00232	48 89 87 44 02
	00 00		 mov	 QWORD PTR [rdi+580], rax

; 1310 : 
; 1311 : 					prop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? GST_VOLUME_FORMAT_VERSION_PRE_6_0 : GST_VOLUME_FORMAT_VERSION;

  00239	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  00241	8b 88 e4 1e 00
	00		 mov	 ecx, DWORD PTR [rax+7908]
  00247	f7 d9		 neg	 ecx
  00249	1b c0		 sbb	 eax, eax
  0024b	83 e0 f4	 and	 eax, -12
  0024e	83 c0 0d	 add	 eax, 13
  00251	89 87 50 02 00
	00		 mov	 DWORD PTR [rdi+592], eax

; 1312 : 
; 1313 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  00257	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1314 : 					Irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);

  0025a	4c 89 76 38	 mov	 QWORD PTR [rsi+56], r14

; 1315 : 				}
; 1316 : 			}
; 1317 : 		}
; 1318 : 		break;

  0025e	e9 67 10 00 00	 jmp	 $LN144@ProcessMai
$LN87@ProcessMai:

; 1209 : 
; 1210 : 	case GST_IOCTL_GET_MOUNTED_VOLUMES:
; 1211 : 		Dump("IOCTL GetMountedVolume received");
; 1212 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))

  00263	bd 01 00 00 00	 mov	 ebp, 1
  00268	41 bf 74 36 00
	00		 mov	 r15d, 13940		; 00003674H
  0026e	48 8b ce	 mov	 rcx, rsi
  00271	44 8b c5	 mov	 r8d, ebp
  00274	49 8b d7	 mov	 rdx, r15
  00277	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0027c	33 db		 xor	 ebx, ebx
  0027e	3b c3		 cmp	 eax, ebx
  00280	0f 84 44 10 00
	00		 je	 $LN144@ProcessMai

; 1213 : 		{
; 1214 : 			MOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00286	4c 8b 66 18	 mov	 r12, QWORD PTR [rsi+24]

; 1215 : 			PDEVICE_OBJECT ListDevice;
; 1216 : 			int drive;
; 1217 : 
; 1218 : 			list->ulMountedDrives = 0;
; 1219 : 
; 1220 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  0028a	4c 8b f3	 mov	 r14, rbx
  0028d	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:__ImageBase
  00294	41 89 1c 24	 mov	 DWORD PTR [r12], ebx

; 1221 : 			{
; 1222 : 				PEXTENSION ListExtension;
; 1223 : 				Dump("Getting device object for drive %d .", drive );
; 1224 : 				ListDevice = GetVirtualVolumeDeviceObject (drive);

  00298	48 83 fb 19	 cmp	 rbx, 25
$LN276@ProcessMai:
  0029c	77 0a		 ja	 SHORT $LN180@ProcessMai
  0029e	4b 8b bc f5 00
	00 00 00	 mov	 rdi, QWORD PTR VirtualVolumeDeviceObjects[r13+r14*8]
  002a6	eb 03		 jmp	 SHORT $LN182@ProcessMai
$LN180@ProcessMai:
  002a8	48 8b fb	 mov	 rdi, rbx
$LN182@ProcessMai:

; 1225 : 				if (!ListDevice)

  002ab	48 3b fb	 cmp	 rdi, rbx
  002ae	0f 84 ca 00 00
	00		 je	 $LN84@ProcessMai

; 1226 : 					continue;
; 1227 : 				
; 1228 : 				ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  002b4	48 8b 7f 40	 mov	 rdi, QWORD PTR [rdi+64]

; 1229 : 				Dump("Checking if VolumeIsAccessibleForUSer.");
; 1230 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  002b8	48 8b cf	 mov	 rcx, rdi
  002bb	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  002c0	3b c3		 cmp	 eax, ebx
  002c2	0f 84 b6 00 00
	00		 je	 $LN84@ProcessMai

; 1231 : 				{
; 1232 : 					list->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);

  002c8	8b 4f 14	 mov	 ecx, DWORD PTR [rdi+20]
  002cb	8b c5		 mov	 eax, ebp
  002cd	d3 e0		 shl	 eax, cl

; 1233 : 					Dump("Check 1..");
; 1234 : 					wcscpy (list->wszVolume[ListExtension->nDosDriveNo], ListExtension->wszVolume);

  002cf	48 8d 8f 58 03
	00 00		 lea	 rcx, QWORD PTR [rdi+856]
  002d6	41 09 04 24	 or	 DWORD PTR [r12], eax
  002da	48 63 47 14	 movsxd	 rax, DWORD PTR [rdi+20]
  002de	48 69 c0 08 02
	00 00		 imul	 rax, 520		; 00000208H
  002e5	4a 8d 54 20 04	 lea	 rdx, QWORD PTR [rax+r12+4]
$LL148@ProcessMai:
  002ea	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  002ed	48 83 c1 02	 add	 rcx, 2
  002f1	66 89 02	 mov	 WORD PTR [rdx], ax
  002f4	48 83 c2 02	 add	 rdx, 2
  002f8	66 3b c3	 cmp	 ax, bx
  002fb	75 ed		 jne	 SHORT $LL148@ProcessMai

; 1235 : 					Dump("2..");
; 1236 : 					list->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;

  002fd	48 63 4f 14	 movsxd	 rcx, DWORD PTR [rdi+20]
  00301	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  00308	49 89 84 cc d4
	34 00 00	 mov	 QWORD PTR [r12+rcx*8+13524], rax

; 1237 : 					Dump("3..");
; 1238 : 					list->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;

  00310	48 8b 87 90 00
	00 00		 mov	 rax, QWORD PTR [rdi+144]
  00317	48 63 4f 14	 movsxd	 rcx, DWORD PTR [rdi+20]
  0031b	8b 00		 mov	 eax, DWORD PTR [rax]
  0031d	41 89 84 8c a4
	35 00 00	 mov	 DWORD PTR [r12+rcx*4+13732], eax

; 1239 : 					Dump("4..");
; 1240 : 					if (ListExtension->cryptoInfo->hiddenVolume)

  00325	48 8b 87 90 00
	00 00		 mov	 rax, QWORD PTR [rdi+144]
  0032c	39 98 48 04 00
	00		 cmp	 DWORD PTR [rax+1096], ebx
  00332	74 0e		 je	 SHORT $LN80@ProcessMai

; 1241 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;	// Hidden volume

  00334	48 63 47 14	 movsxd	 rax, DWORD PTR [rdi+20]
  00338	41 89 ac 84 0c
	36 00 00	 mov	 DWORD PTR [r12+rax*4+13836], ebp
  00340	eb 3c		 jmp	 SHORT $LN84@ProcessMai
$LN80@ProcessMai:

; 1242 : 					else if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)

  00342	39 98 ac 1e 00
	00		 cmp	 DWORD PTR [rax+7852], ebx
  00348	74 12		 je	 SHORT $LN78@ProcessMai

; 1243 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;	// Normal/outer volume (hidden volume protected AND write already prevented)

  0034a	48 63 47 14	 movsxd	 rax, DWORD PTR [rdi+20]
  0034e	41 c7 84 84 0c
	36 00 00 03 00
	00 00		 mov	 DWORD PTR [r12+rax*4+13836], 3
  0035a	eb 22		 jmp	 SHORT $LN84@ProcessMai
$LN78@ProcessMai:

; 1244 : 					else if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  0035c	39 98 a8 1e 00
	00		 cmp	 DWORD PTR [rax+7848], ebx

; 1245 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;	// Normal/outer volume (hidden volume protected)

  00362	48 63 47 14	 movsxd	 rax, DWORD PTR [rdi+20]
  00366	74 0e		 je	 SHORT $LN76@ProcessMai
  00368	41 c7 84 84 0c
	36 00 00 02 00
	00 00		 mov	 DWORD PTR [r12+rax*4+13836], 2

; 1246 : 					else

  00374	eb 08		 jmp	 SHORT $LN84@ProcessMai
$LN76@ProcessMai:

; 1247 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;	// Normal volume

  00376	41 89 9c 84 0c
	36 00 00	 mov	 DWORD PTR [r12+rax*4+13836], ebx
$LN84@ProcessMai:

; 1215 : 			PDEVICE_OBJECT ListDevice;
; 1216 : 			int drive;
; 1217 : 
; 1218 : 			list->ulMountedDrives = 0;
; 1219 : 
; 1220 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  0037e	4c 03 f5	 add	 r14, rbp
  00381	49 83 fe 19	 cmp	 r14, 25
  00385	0f 8e 11 ff ff
	ff		 jle	 $LN276@ProcessMai

; 1248 : 					Dump("5. ok.\n");
; 1249 : 				}
; 1250 : 			}
; 1251 : 
; 1252 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0038b	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1253 : 			Irp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);

  0038e	4c 89 7e 38	 mov	 QWORD PTR [rsi+56], r15

; 1254 : 		}
; 1255 : 		break;

  00392	e9 33 0f 00 00	 jmp	 $LN144@ProcessMai
$LN28@ProcessMai:

; 1504 : 
; 1505 : 	case GST_IOCTL_DISMOUNT_ALL_VOLUMES:
; 1506 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  00397	41 b8 02 00 00
	00		 mov	 r8d, 2
  0039d	48 8b ce	 mov	 rcx, rsi
  003a0	45 8d 70 0e	 lea	 r14d, QWORD PTR [r8+14]
  003a4	49 8b d6	 mov	 rdx, r14
  003a7	e8 00 00 00 00	 call	 ValidateIOBufferSize
  003ac	33 db		 xor	 ebx, ebx
  003ae	3b c3		 cmp	 eax, ebx
  003b0	0f 84 14 0f 00
	00		 je	 $LN144@ProcessMai

; 1507 : 		{
; 1508 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  003b6	48 8b 7e 18	 mov	 rdi, QWORD PTR [rsi+24]

; 1509 : 
; 1510 : 			unmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);

  003ba	48 8b cf	 mov	 rcx, rdi
  003bd	8b 57 04	 mov	 edx, DWORD PTR [rdi+4]
  003c0	e8 00 00 00 00	 call	 UnmountAllDevices

; 1511 : 
; 1512 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);
; 1513 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1514 : 		}
; 1515 : 		break;

  003c5	eb 67		 jmp	 SHORT $LN290@ProcessMai
$LN32@ProcessMai:

; 1481 : 		}
; 1482 : 		break;
; 1483 : 
; 1484 : 	case GST_IOCTL_DISMOUNT_VOLUME:
; 1485 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  003c7	41 b8 02 00 00
	00		 mov	 r8d, 2
  003cd	48 8b ce	 mov	 rcx, rsi
  003d0	45 8d 70 0e	 lea	 r14d, QWORD PTR [r8+14]
  003d4	49 8b d6	 mov	 rdx, r14
  003d7	e8 00 00 00 00	 call	 ValidateIOBufferSize
  003dc	33 db		 xor	 ebx, ebx
  003de	3b c3		 cmp	 eax, ebx
  003e0	0f 84 e4 0e 00
	00		 je	 $LN144@ProcessMai

; 1486 : 		{
; 1487 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  003e6	48 8b 7e 18	 mov	 rdi, QWORD PTR [rsi+24]

; 1488 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);

  003ea	83 3f 19	 cmp	 DWORD PTR [rdi], 25
  003ed	77 14		 ja	 SHORT $LN202@ProcessMai
  003ef	48 63 07	 movsxd	 rax, DWORD PTR [rdi]
  003f2	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:__ImageBase
  003f9	49 8b ac c5 00
	00 00 00	 mov	 rbp, QWORD PTR VirtualVolumeDeviceObjects[r13+rax*8]
  00401	eb 03		 jmp	 SHORT $LN204@ProcessMai
$LN202@ProcessMai:
  00403	48 8b eb	 mov	 rbp, rbx
$LN204@ProcessMai:

; 1489 : 
; 1490 : 			unmount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  00406	c7 47 0c 05 00
	00 00		 mov	 DWORD PTR [rdi+12], 5

; 1491 : 
; 1492 : 			if (ListDevice)

  0040d	48 3b eb	 cmp	 rbp, rbx
  00410	74 1f		 je	 SHORT $LN29@ProcessMai

; 1493 : 			{
; 1494 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;
; 1495 : 
; 1496 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00412	48 8b 4d 40	 mov	 rcx, QWORD PTR [rbp+64]
  00416	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  0041b	3b c3		 cmp	 eax, ebx
  0041d	74 12		 je	 SHORT $LN29@ProcessMai

; 1497 : 					unmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);

  0041f	44 8b 47 04	 mov	 r8d, DWORD PTR [rdi+4]
  00423	48 8b d5	 mov	 rdx, rbp
  00426	48 8b cf	 mov	 rcx, rdi
  00429	e8 00 00 00 00	 call	 UnmountDevice
$LN290@ProcessMai:
  0042e	89 47 0c	 mov	 DWORD PTR [rdi+12], eax
$LN29@ProcessMai:

; 1498 : 			}
; 1499 : 
; 1500 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  00431	4c 89 76 38	 mov	 QWORD PTR [rsi+56], r14

; 1501 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1502 : 		}
; 1503 : 		break;

  00435	e9 04 01 00 00	 jmp	 $LN285@ProcessMai
$LN46@ProcessMai:

; 1461 : 
; 1462 : 	case GST_IOCTL_MOUNT_VOLUME:
; 1463 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))

  0043a	bf e0 02 00 00	 mov	 edi, 736		; 000002e0H
  0043f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00445	48 8b ce	 mov	 rcx, rsi
  00448	48 8b d7	 mov	 rdx, rdi
  0044b	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00450	33 db		 xor	 ebx, ebx
  00452	3b c3		 cmp	 eax, ebx
  00454	0f 84 70 0e 00
	00		 je	 $LN144@ProcessMai

; 1464 : 		{
; 1465 : 			MOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0045a	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]

; 1466 : 
; 1467 : 			if (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD)

  0045e	4c 8d aa 18 02
	00 00		 lea	 r13, QWORD PTR [rdx+536]
  00465	41 83 7d 00 40	 cmp	 DWORD PTR [r13], 64	; 00000040H
  0046a	77 60		 ja	 SHORT $LN43@ProcessMai
  0046c	4c 8d a2 90 02
	00 00		 lea	 r12, QWORD PTR [rdx+656]
  00473	41 83 3c 24 40	 cmp	 DWORD PTR [r12], 64	; 00000040H
  00478	77 52		 ja	 SHORT $LN43@ProcessMai

; 1472 : 			}
; 1473 : 
; 1474 : 			EnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));

  0047a	66 89 9a 16 02
	00 00		 mov	 WORD PTR [rdx+534], bx

; 1475 : 
; 1476 : 			Irp->IoStatus.Information = sizeof (MOUNT_STRUCT);
; 1477 : 			Irp->IoStatus.Status = MountDevice (DeviceObject, mount);

  00481	49 8b ce	 mov	 rcx, r14
  00484	48 89 7e 38	 mov	 QWORD PTR [rsi+56], rdi
  00488	e8 00 00 00 00	 call	 MountDevice

; 1478 : 
; 1479 : 			burn (&mount->VolumePassword, sizeof (mount->VolumePassword));

  0048d	8d 53 48	 lea	 edx, QWORD PTR [rbx+72]
  00490	49 8b fd	 mov	 rdi, r13
  00493	89 46 30	 mov	 DWORD PTR [rsi+48], eax
  00496	33 c0		 xor	 eax, eax
  00498	48 8b ca	 mov	 rcx, rdx
  0049b	44 8b c2	 mov	 r8d, edx
  0049e	8d 6b 01	 lea	 ebp, QWORD PTR [rbx+1]
  004a1	f3 aa		 rep stosb
$LL39@ProcessMai:
  004a3	44 2b c5	 sub	 r8d, ebp
  004a6	41 88 5d 00	 mov	 BYTE PTR [r13], bl
  004aa	4c 03 ed	 add	 r13, rbp
  004ad	44 3b c3	 cmp	 r8d, ebx
  004b0	75 f1		 jne	 SHORT $LL39@ProcessMai

; 1480 : 			burn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));

  004b2	49 8b fc	 mov	 rdi, r12
  004b5	48 8b ca	 mov	 rcx, rdx
  004b8	f3 aa		 rep stosb
$LL34@ProcessMai:
  004ba	2b d5		 sub	 edx, ebp
  004bc	41 88 1c 24	 mov	 BYTE PTR [r12], bl
  004c0	4c 03 e5	 add	 r12, rbp
  004c3	3b d3		 cmp	 edx, ebx
  004c5	75 f3		 jne	 SHORT $LL34@ProcessMai

; 1035 : 							{
; 1036 : 								// Search for the string "GostCrypt"
; 1037 : 								for (i = 0; i < GST_SECTOR_SIZE_BIOS - strlen (GST_APP_NAME); ++i)

  004c7	e9 fe 0d 00 00	 jmp	 $LN144@ProcessMai
$LN43@ProcessMai:

; 1468 : 			{
; 1469 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  004cc	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH

; 1470 : 				Irp->IoStatus.Information = 0;
; 1471 : 				break;

  004d1	e9 ed 0d 00 00	 jmp	 $LN277@ProcessMai
$LN21@ProcessMai:

; 1539 : 
; 1540 : 	case GST_IOCTL_GET_BOOT_LOADER_VERSION:
; 1541 : 		GetBootLoaderVersion (Irp, irpSp);

  004d6	ba 02 00 00 00	 mov	 edx, 2
  004db	48 8b ce	 mov	 rcx, rsi
  004de	44 8d 42 ff	 lea	 r8d, QWORD PTR [rdx-1]
  004e2	e8 00 00 00 00	 call	 ValidateIOBufferSize
  004e7	33 db		 xor	 ebx, ebx
  004e9	3b c3		 cmp	 eax, ebx
  004eb	0f 84 d9 0d 00
	00		 je	 $LN144@ProcessMai
  004f1	39 1d 00 00 00
	00		 cmp	 DWORD PTR BootArgsValid, ebx
  004f7	74 d3		 je	 SHORT $LN43@ProcessMai
  004f9	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR BootArgs+8
  00500	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00504	66 89 01	 mov	 WORD PTR [rcx], ax
  00507	48 c7 46 38 02
	00 00 00	 mov	 QWORD PTR [rsi+56], 2
  0050f	eb 2d		 jmp	 SHORT $LN285@ProcessMai
$LN143@ProcessMai:

; 918  : 	{
; 919  : 	case GST_IOCTL_GET_DRIVER_VERSION:
; 920  : 	case GST_IOCTL_LEGACY_GET_DRIVER_VERSION:
; 921  : 		if (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))

  00511	bf 04 00 00 00	 mov	 edi, 4
  00516	48 8b ce	 mov	 rcx, rsi
  00519	44 8d 47 fd	 lea	 r8d, QWORD PTR [rdi-3]
  0051d	48 8b d7	 mov	 rdx, rdi
  00520	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00525	33 db		 xor	 ebx, ebx
  00527	3b c3		 cmp	 eax, ebx
  00529	0f 84 9b 0d 00
	00		 je	 $LN144@ProcessMai

; 922  : 		{
; 923  : 			LONG tmp = VERSION_NUM;
; 924  : 			memcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);

  0052f	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00533	ba 00 13 00 00	 mov	 edx, 4864		; 00001300H
  00538	89 10		 mov	 DWORD PTR [rax], edx
$LN284@ProcessMai:

; 925  : 			Irp->IoStatus.Information = sizeof (LONG);

  0053a	48 89 7e 38	 mov	 QWORD PTR [rsi+56], rdi
$LN285@ProcessMai:

; 926  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0053e	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 927  : 		}
; 928  : 		break;

  00541	e9 84 0d 00 00	 jmp	 $LN144@ProcessMai
$LN74@ProcessMai:

; 1256 : 
; 1257 : 	case GST_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:
; 1258 : 		if (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))

  00546	ba 04 00 00 00	 mov	 edx, 4
  0054b	48 8b ce	 mov	 rcx, rsi
  0054e	44 8d 42 fd	 lea	 r8d, QWORD PTR [rdx-3]
  00552	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00557	33 db		 xor	 ebx, ebx
  00559	3b c3		 cmp	 eax, ebx
  0055b	0f 84 69 0d 00
	00		 je	 $LN144@ProcessMai

; 1259 : 		{
; 1260 : 			// Prevent the user from downgrading to versions lower than 5.0 by faking mounted volumes.
; 1261 : 			// The user could render the system unbootable by downgrading when boot encryption
; 1262 : 			// is active or being set up.
; 1263 : 
; 1264 : 			memset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  00561	45 8b 44 24 08	 mov	 r8d, DWORD PTR [r12+8]
  00566	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  0056a	33 d2		 xor	 edx, edx
  0056c	e8 00 00 00 00	 call	 memset

; 1265 : 			*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;

  00571	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]
  00575	83 0a ff	 or	 DWORD PTR [rdx], -1	; ffffffffH

; 1266 : 
; 1267 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00578	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1268 : 			Irp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

  0057b	41 8b 44 24 08	 mov	 eax, DWORD PTR [r12+8]
  00580	48 89 46 38	 mov	 QWORD PTR [rsi+56], rax

; 1269 : 		}
; 1270 : 		break;

  00584	e9 41 0d 00 00	 jmp	 $LN144@ProcessMai
$LN141@ProcessMai:

; 929  : 
; 930  : 	case GST_IOCTL_GET_DEVICE_REFCOUNT:
; 931  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00589	bf 04 00 00 00	 mov	 edi, 4
  0058e	48 8b ce	 mov	 rcx, rsi
  00591	44 8d 47 fd	 lea	 r8d, QWORD PTR [rdi-3]
  00595	48 8b d7	 mov	 rdx, rdi
  00598	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0059d	33 db		 xor	 ebx, ebx
  0059f	3b c3		 cmp	 eax, ebx
  005a1	0f 84 23 0d 00
	00		 je	 $LN144@ProcessMai

; 932  : 		{
; 933  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;

  005a7	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  005ab	41 8b 46 04	 mov	 eax, DWORD PTR [r14+4]
  005af	89 01		 mov	 DWORD PTR [rcx], eax

; 934  : 			Irp->IoStatus.Information = sizeof (int);
; 935  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 936  : 		}
; 937  : 		break;

  005b1	eb 87		 jmp	 SHORT $LN284@ProcessMai
$LN151@ProcessMai:

; 915  : 	NTSTATUS ntStatus;
; 916  : 
; 917  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  005b3	2d 24 20 22 00	 sub	 eax, 2236452		; 00222024H
  005b8	bf 04 00 00 00	 mov	 edi, 4
  005bd	0f 84 f9 06 00
	00		 je	 $LN139@ProcessMai
  005c3	2b c7		 sub	 eax, edi
  005c5	0f 84 7d 06 00
	00		 je	 $LN136@ProcessMai
  005cb	2b c7		 sub	 eax, edi
  005cd	0f 84 56 06 00
	00		 je	 $LN92@ProcessMai
  005d3	2b c7		 sub	 eax, edi
  005d5	0f 84 0d 06 00
	00		 je	 $LN175@ProcessMai
  005db	2b c7		 sub	 eax, edi
  005dd	0f 84 1d 03 00
	00		 je	 $LN129@ProcessMai
  005e3	2b c7		 sub	 eax, edi
  005e5	0f 84 70 01 00
	00		 je	 $LN64@ProcessMai
  005eb	2b c7		 sub	 eax, edi
  005ed	0f 84 14 01 00
	00		 je	 $LN55@ProcessMai
  005f3	2b c7		 sub	 eax, edi
  005f5	74 4e		 je	 SHORT $LN53@ProcessMai
  005f7	3b c7		 cmp	 eax, edi
  005f9	0f 85 58 0b 00
	00		 jne	 $LN1@ProcessMai

; 1319 : 
; 1320 : 	case GST_IOCTL_GET_RESOLVED_SYMLINK:
; 1321 : 		if (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))

  005ff	bf 10 04 00 00	 mov	 edi, 1040		; 00000410H
  00604	41 b8 02 00 00
	00		 mov	 r8d, 2
  0060a	48 8b ce	 mov	 rcx, rsi
  0060d	48 8b d7	 mov	 rdx, rdi
  00610	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00615	33 db		 xor	 ebx, ebx
  00617	3b c3		 cmp	 eax, ebx
  00619	0f 84 ab 0c 00
	00		 je	 $LN144@ProcessMai

; 1322 : 		{
; 1323 : 			RESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0061f	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]

; 1324 : 			{
; 1325 : 				NTSTATUS ntStatus;
; 1326 : 
; 1327 : 				EnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));
; 1328 : 
; 1329 : 				ntStatus = SymbolicLinkToTarget (resolve->symLinkName,
; 1330 : 					resolve->targetName,
; 1331 : 					sizeof (resolve->targetName));

  00623	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  00629	48 8d 91 08 02
	00 00		 lea	 rdx, QWORD PTR [rcx+520]
  00630	66 89 99 06 02
	00 00		 mov	 WORD PTR [rcx+518], bx
  00637	e8 00 00 00 00	 call	 SymbolicLinkToTarget
$LN283@ProcessMai:

; 1332 : 
; 1333 : 				Irp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);

  0063c	48 89 7e 38	 mov	 QWORD PTR [rsi+56], rdi

; 1334 : 				Irp->IoStatus.Status = ntStatus;
; 1335 : 			}
; 1336 : 		}
; 1337 : 		break;

  00640	e9 82 0c 00 00	 jmp	 $LN278@ProcessMai
$LN53@ProcessMai:

; 1418 : 
; 1419 : 	case GST_IOCTL_PROBE_REAL_DRIVE_SIZE:
; 1420 : 		if (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))

  00645	41 bc 14 02 00
	00		 mov	 r12d, 532		; 00000214H
  0064b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00651	48 8b ce	 mov	 rcx, rsi
  00654	49 8b d4	 mov	 rdx, r12
  00657	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0065c	33 db		 xor	 ebx, ebx
  0065e	3b c3		 cmp	 eax, ebx
  00660	0f 84 64 0c 00
	00		 je	 $LN144@ProcessMai

; 1421 : 		{
; 1422 : 			ProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;

  00666	48 8b 7e 18	 mov	 rdi, QWORD PTR [rsi+24]

; 1423 : 			NTSTATUS status;
; 1424 : 			UNICODE_STRING name;
; 1425 : 			PFILE_OBJECT fileObject;
; 1426 : 			PDEVICE_OBJECT deviceObject;
; 1427 : 
; 1428 : 			EnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));
; 1429 : 
; 1430 : 			RtlInitUnicodeString (&name, request->DeviceName);

  0066a	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR name$30855[rsp]
  00672	48 8b d7	 mov	 rdx, rdi
  00675	66 89 9f 06 02
	00 00		 mov	 WORD PTR [rdi+518], bx
  0067c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 1431 : 			status = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  00682	4c 8d 8c 24 a8
	00 00 00	 lea	 r9, QWORD PTR deviceObject$30857[rsp]
  0068a	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR fileObject$30856[rsp]
  00692	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR name$30855[rsp]
  0069a	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0069f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer

; 1432 : 			if (!NT_SUCCESS (status))

  006a5	3b c3		 cmp	 eax, ebx

; 1433 : 			{
; 1434 : 				Irp->IoStatus.Information = 0;
; 1435 : 				Irp->IoStatus.Status = status;
; 1436 : 				break;

  006a7	0f 8c 16 0c 00
	00		 jl	 $LN277@ProcessMai

; 1437 : 			}
; 1438 : 
; 1439 : 			status = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);

  006ad	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$30857[rsp]
  006b5	48 8d 97 08 02
	00 00		 lea	 rdx, QWORD PTR [rdi+520]
  006bc	e8 00 00 00 00	 call	 ProbeRealDriveSize

; 1440 : 			ObDereferenceObject (fileObject);

  006c1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fileObject$30856[rsp]
  006c9	8b e8		 mov	 ebp, eax
  006cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 1441 : 
; 1442 : 			if (status == STATUS_TIMEOUT)

  006d1	81 fd 02 01 00
	00		 cmp	 ebp, 258		; 00000102H
  006d7	75 12		 jne	 SHORT $LN50@ProcessMai

; 1443 : 			{
; 1444 : 				request->TimeOut = TRUE;

  006d9	8d 6b 01	 lea	 ebp, QWORD PTR [rbx+1]
  006dc	89 af 10 02 00
	00		 mov	 DWORD PTR [rdi+528], ebp

; 1445 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  006e2	4c 89 66 38	 mov	 QWORD PTR [rsi+56], r12

; 1446 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  006e6	e9 53 fe ff ff	 jmp	 $LN285@ProcessMai
$LN50@ProcessMai:

; 1447 : 			}
; 1448 : 			else if (!NT_SUCCESS (status))

  006eb	3b eb		 cmp	 ebp, ebx
  006ed	7d 06		 jge	 SHORT $LN48@ProcessMai

; 1449 : 			{
; 1450 : 				Irp->IoStatus.Information = 0;

  006ef	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 1451 : 				Irp->IoStatus.Status = status;
; 1452 : 			}
; 1453 : 			else

  006f3	eb 0a		 jmp	 SHORT $LN288@ProcessMai
$LN48@ProcessMai:

; 1454 : 			{
; 1455 : 				request->TimeOut = FALSE;

  006f5	89 9f 10 02 00
	00		 mov	 DWORD PTR [rdi+528], ebx

; 1456 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  006fb	4c 89 66 38	 mov	 QWORD PTR [rsi+56], r12
$LN288@ProcessMai:

; 1457 : 				Irp->IoStatus.Status = status;

  006ff	89 6e 30	 mov	 DWORD PTR [rsi+48], ebp

; 1458 : 			}
; 1459 : 		}
; 1460 : 		break;

  00702	e9 c3 0b 00 00	 jmp	 $LN144@ProcessMai
$LN55@ProcessMai:

; 1399 : 
; 1400 : 	case GST_IOCTL_GET_DRIVE_GEOMETRY:
; 1401 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))

  00707	bf 20 02 00 00	 mov	 edi, 544		; 00000220H
  0070c	41 b8 02 00 00
	00		 mov	 r8d, 2
  00712	48 8b ce	 mov	 rcx, rsi
  00715	48 8b d7	 mov	 rdx, rdi
  00718	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0071d	33 db		 xor	 ebx, ebx
  0071f	3b c3		 cmp	 eax, ebx
  00721	0f 84 a3 0b 00
	00		 je	 $LN144@ProcessMai

; 1402 : 		{
; 1403 : 			DISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00727	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]

; 1404 : 			{
; 1405 : 				NTSTATUS ntStatus;
; 1406 : 
; 1407 : 				EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));
; 1408 : 
; 1409 : 				ntStatus = GSTDeviceIoControl (g->deviceName,
; 1410 : 					IOCTL_DISK_GET_DRIVE_GEOMETRY,
; 1411 : 					NULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));

  0072b	45 33 c9	 xor	 r9d, r9d
  0072e	45 33 c0	 xor	 r8d, r8d
  00731	48 8d 81 08 02
	00 00		 lea	 rax, QWORD PTR [rcx+520]
  00738	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  0073d	c7 44 24 28 18
	00 00 00	 mov	 DWORD PTR [rsp+40], 24
  00745	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0074a	66 89 99 06 02
	00 00		 mov	 WORD PTR [rcx+518], bx
  00751	e8 00 00 00 00	 call	 GSTDeviceIoControl

; 1412 : 
; 1413 : 				Irp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);
; 1414 : 				Irp->IoStatus.Status = ntStatus;
; 1415 : 			}
; 1416 : 		}
; 1417 : 		break;

  00756	e9 e1 fe ff ff	 jmp	 $LN283@ProcessMai
$LN64@ProcessMai:

; 1338 : 
; 1339 : 	case GST_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1340 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))

  0075b	41 bf 30 02 00
	00		 mov	 r15d, 560		; 00000230H
  00761	41 b8 02 00 00
	00		 mov	 r8d, 2
  00767	48 8b ce	 mov	 rcx, rsi
  0076a	49 8b d7	 mov	 rdx, r15
  0076d	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00772	33 db		 xor	 ebx, ebx
  00774	3b c3		 cmp	 eax, ebx
  00776	0f 84 4e 0b 00
	00		 je	 $LN144@ProcessMai

; 1341 : 		{
; 1342 : 			DISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0077c	4c 8b 66 18	 mov	 r12, QWORD PTR [rsi+24]

; 1343 : 			{
; 1344 : 				PARTITION_INFORMATION_EX pi;
; 1345 : 				NTSTATUS ntStatus;
; 1346 : 
; 1347 : 				EnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));
; 1348 : 
; 1349 : 				ntStatus = GSTDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));

  00780	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR pi$30821[rsp]
  00788	45 33 c9	 xor	 r9d, r9d
  0078b	45 33 c0	 xor	 r8d, r8d
  0078e	ba 48 00 07 00	 mov	 edx, 458824		; 00070048H
  00793	49 8b cc	 mov	 rcx, r12
  00796	c7 44 24 28 90
	00 00 00	 mov	 DWORD PTR [rsp+40], 144	; 00000090H
  0079e	66 41 89 9c 24
	06 02 00 00	 mov	 WORD PTR [r12+518], bx
  007a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007ac	e8 00 00 00 00	 call	 GSTDeviceIoControl

; 1350 : 				if (NT_SUCCESS(ntStatus))
; 1351 : 				{
; 1352 : 					memset (&info->partInfo, 0, sizeof (info->partInfo));

  007b1	4d 8d b4 24 08
	02 00 00	 lea	 r14, QWORD PTR [r12+520]
  007b9	3b c3		 cmp	 eax, ebx
  007bb	44 8b e8	 mov	 r13d, eax
  007be	7c 7a		 jl	 SHORT $LN62@ProcessMai
  007c0	44 8d 43 20	 lea	 r8d, QWORD PTR [rbx+32]
  007c4	33 d2		 xor	 edx, edx
  007c6	49 8b ce	 mov	 rcx, r14
  007c9	e8 00 00 00 00	 call	 memset

; 1353 : 
; 1354 : 					info->partInfo.PartitionLength = pi.PartitionLength;
; 1355 : 					info->partInfo.PartitionNumber = pi.PartitionNumber;

  007ce	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR pi$30821[rsp+24]
  007d5	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pi$30821[rsp+16]
  007dd	41 89 8c 24 1c
	02 00 00	 mov	 DWORD PTR [r12+540], ecx

; 1356 : 					info->partInfo.StartingOffset = pi.StartingOffset;

  007e5	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR pi$30821[rsp+8]
  007ed	49 89 94 24 10
	02 00 00	 mov	 QWORD PTR [r12+528], rdx
  007f5	49 89 0e	 mov	 QWORD PTR [r14], rcx

; 1357 : 
; 1358 : 					if (pi.PartitionStyle == PARTITION_STYLE_MBR)

  007f8	39 9c 24 50 01
	00 00		 cmp	 DWORD PTR pi$30821[rsp], ebx
  007ff	75 1e		 jne	 SHORT $LN61@ProcessMai

; 1359 : 					{
; 1360 : 						info->partInfo.PartitionType = pi.Mbr.PartitionType;

  00801	8a 84 24 70 01
	00 00		 mov	 al, BYTE PTR pi$30821[rsp+32]
  00808	41 88 84 24 20
	02 00 00	 mov	 BYTE PTR [r12+544], al

; 1361 : 						info->partInfo.BootIndicator = pi.Mbr.BootIndicator;

  00810	8a 84 24 71 01
	00 00		 mov	 al, BYTE PTR pi$30821[rsp+33]
  00817	41 88 84 24 21
	02 00 00	 mov	 BYTE PTR [r12+545], al
$LN61@ProcessMai:

; 1362 : 					}
; 1363 : 
; 1364 : 					info->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;

  0081f	8b c3		 mov	 eax, ebx
  00821	bd 01 00 00 00	 mov	 ebp, 1
  00826	39 ac 24 50 01
	00 00		 cmp	 DWORD PTR pi$30821[rsp], ebp
  0082d	0f 94 c0	 sete	 al
  00830	41 89 84 24 28
	02 00 00	 mov	 DWORD PTR [r12+552], eax

; 1365 : 				}
; 1366 : 				else

  00838	eb 2b		 jmp	 SHORT $LN60@ProcessMai
$LN62@ProcessMai:

; 1367 : 				{
; 1368 : 					// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 1369 : 					ntStatus = GSTDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));

  0083a	45 33 c9	 xor	 r9d, r9d
  0083d	45 33 c0	 xor	 r8d, r8d
  00840	ba 04 40 07 00	 mov	 edx, 475140		; 00074004H
  00845	49 8b cc	 mov	 rcx, r12
  00848	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  00850	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00855	e8 00 00 00 00	 call	 GSTDeviceIoControl

; 1370 : 					info->IsGPT = FALSE;

  0085a	41 89 9c 24 28
	02 00 00	 mov	 DWORD PTR [r12+552], ebx
  00862	44 8b e8	 mov	 r13d, eax
$LN60@ProcessMai:

; 1371 : 				}
; 1372 : 
; 1373 : 				if (!NT_SUCCESS (ntStatus))

  00865	44 3b eb	 cmp	 r13d, ebx
  00868	7d 4d		 jge	 SHORT $LN58@ProcessMai

; 1374 : 				{
; 1375 : 					GET_LENGTH_INFORMATION lengthInfo;
; 1376 : 					ntStatus = GSTDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));

  0086a	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR lengthInfo$30831[rsp]
  00872	45 33 c9	 xor	 r9d, r9d
  00875	45 33 c0	 xor	 r8d, r8d
  00878	ba 5c 40 07 00	 mov	 edx, 475228		; 0007405cH
  0087d	49 8b cc	 mov	 rcx, r12
  00880	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  00888	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0088d	e8 00 00 00 00	 call	 GSTDeviceIoControl

; 1377 : 
; 1378 : 					if (NT_SUCCESS (ntStatus))

  00892	3b c3		 cmp	 eax, ebx
  00894	44 8b e8	 mov	 r13d, eax
  00897	7c 1e		 jl	 SHORT $LN58@ProcessMai

; 1379 : 					{
; 1380 : 						memset (&info->partInfo, 0, sizeof (info->partInfo));

  00899	33 d2		 xor	 edx, edx
  0089b	49 8b ce	 mov	 rcx, r14
  0089e	44 8d 42 20	 lea	 r8d, QWORD PTR [rdx+32]
  008a2	e8 00 00 00 00	 call	 memset

; 1381 : 						info->partInfo.PartitionLength = lengthInfo.Length;

  008a7	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR lengthInfo$30831[rsp]
  008af	49 89 94 24 10
	02 00 00	 mov	 QWORD PTR [r12+528], rdx
$LN58@ProcessMai:

; 1382 : 					}
; 1383 : 				}
; 1384 : 
; 1385 : 				info->IsDynamic = FALSE;
; 1386 : 
; 1387 : 				if (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)

  008b7	44 3b eb	 cmp	 r13d, ebx
  008ba	49 8d ac 24 2c
	02 00 00	 lea	 rbp, QWORD PTR [r12+556]
  008c2	89 5d 00	 mov	 DWORD PTR [rbp], ebx
  008c5	7c 2c		 jl	 SHORT $LN56@ProcessMai
  008c7	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR OsMajorVersion, 6
  008ce	72 23		 jb	 SHORT $LN56@ProcessMai

; 1388 : 				{
; 1389 : #					define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)
; 1390 : 					if (!NT_SUCCESS (GSTDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))

  008d0	45 33 c9	 xor	 r9d, r9d
  008d3	45 33 c0	 xor	 r8d, r8d
  008d6	ba 48 00 56 00	 mov	 edx, 5636168		; 00560048H
  008db	49 8b cc	 mov	 rcx, r12
  008de	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  008e2	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  008e7	e8 00 00 00 00	 call	 GSTDeviceIoControl
  008ec	3b c3		 cmp	 eax, ebx
  008ee	7d 03		 jge	 SHORT $LN56@ProcessMai

; 1391 : 						info->IsDynamic = FALSE;

  008f0	89 5d 00	 mov	 DWORD PTR [rbp], ebx
$LN56@ProcessMai:

; 1392 : 				}
; 1393 : 
; 1394 : 				Irp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);

  008f3	4c 89 7e 38	 mov	 QWORD PTR [rsi+56], r15

; 1395 : 				Irp->IoStatus.Status = ntStatus;

  008f7	44 89 6e 30	 mov	 DWORD PTR [rsi+48], r13d

; 1396 : 			}
; 1397 : 		}
; 1398 : 		break;

  008fb	e9 ca 09 00 00	 jmp	 $LN144@ProcessMai
$LN129@ProcessMai:

; 976  : 
; 977  : 	case GST_IOCTL_OPEN_TEST:
; 978  : 		{
; 979  : 			OPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00900	49 8b 78 18	 mov	 rdi, QWORD PTR [r8+24]

; 980  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 981  : 			HANDLE NtFileHandle;
; 982  : 			UNICODE_STRING FullFileName;
; 983  : 			IO_STATUS_BLOCK IoStatus;
; 984  : 			LARGE_INTEGER offset;
; 985  : 			ACCESS_MASK access = FILE_READ_ATTRIBUTES;

  00904	41 bd 80 00 00
	00		 mov	 r13d, 128		; 00000080H

; 986  : 
; 987  : 			if (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))

  0090a	41 be 18 02 00
	00		 mov	 r14d, 536		; 00000218H
  00910	45 8d 45 82	 lea	 r8d, QWORD PTR [r13-126]
  00914	49 8b d6	 mov	 rdx, r14
  00917	48 8b ce	 mov	 rcx, rsi
  0091a	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0091f	33 db		 xor	 ebx, ebx
  00921	3b c3		 cmp	 eax, ebx
  00923	0f 84 a1 09 00
	00		 je	 $LN144@ProcessMai

; 988  : 				break;
; 989  : 
; 990  : 			EnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));
; 991  : 			RtlInitUnicodeString (&FullFileName, opentest->wszFileName);

  00929	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR FullFileName$30667[rsp]
  00931	48 8b d7	 mov	 rdx, rdi
  00934	66 89 9f 06 02
	00 00		 mov	 WORD PTR [rdi+518], bx
  0093b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 992  : 
; 993  : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  00941	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR FullFileName$30667[rsp]
  00949	c7 84 24 e0 00
	00 00 30 00 00
	00		 mov	 DWORD PTR ObjectAttributes$30665[rsp], 48 ; 00000030H
  00954	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR ObjectAttributes$30665[rsp+16], rax
  0095c	48 89 9c 24 e8
	00 00 00	 mov	 QWORD PTR ObjectAttributes$30665[rsp+8], rbx
  00964	c7 84 24 f8 00
	00 00 40 02 00
	00		 mov	 DWORD PTR ObjectAttributes$30665[rsp+24], 576 ; 00000240H
  0096f	48 89 9c 24 00
	01 00 00	 mov	 QWORD PTR ObjectAttributes$30665[rsp+32], rbx
  00977	48 89 9c 24 08
	01 00 00	 mov	 QWORD PTR ObjectAttributes$30665[rsp+40], rbx

; 994  : 
; 995  : 			if (opentest->bDetectGSTBootLoader || opentest->DetectFilesystem)

  0097f	39 9f 08 02 00
	00		 cmp	 DWORD PTR [rdi+520], ebx
  00985	75 08		 jne	 SHORT $LN126@ProcessMai
  00987	39 9f 10 02 00
	00		 cmp	 DWORD PTR [rdi+528], ebx
  0098d	74 06		 je	 SHORT $LN127@ProcessMai
$LN126@ProcessMai:

; 996  : 				access |= FILE_READ_DATA;

  0098f	41 bd 81 00 00
	00		 mov	 r13d, 129		; 00000081H
$LN127@ProcessMai:

; 997  : 
; 998  : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 999  : 						 SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,
; 1000 : 						 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

  00995	89 5c 24 50	 mov	 DWORD PTR [rsp+80], ebx
  00999	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  0099e	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  009a6	41 0f ba ed 14	 bts	 r13d, 20
  009ab	bd 01 00 00 00	 mov	 ebp, 1
  009b0	4c 8d 4c 24 78	 lea	 r9, QWORD PTR IoStatus$30668[rsp]
  009b5	89 6c 24 38	 mov	 DWORD PTR [rsp+56], ebp
  009b9	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  009c1	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR ObjectAttributes$30665[rsp]
  009c9	48 8d 4c 24 68	 lea	 rcx, QWORD PTR NtFileHandle$30666[rsp]
  009ce	41 8b d5	 mov	 edx, r13d
  009d1	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  009d5	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  009da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile

; 1001 : 
; 1002 : 			if (NT_SUCCESS (ntStatus))

  009e0	3b c3		 cmp	 eax, ebx
  009e2	44 8b e0	 mov	 r12d, eax
  009e5	0f 8c e9 01 00
	00		 jl	 $LN125@ProcessMai

; 1003 : 			{
; 1004 : 				opentest->GSTBootLoaderDetected = FALSE;

  009eb	89 9f 0c 02 00
	00		 mov	 DWORD PTR [rdi+524], ebx

; 1005 : 				opentest->FilesystemDetected = FALSE;

  009f1	89 9f 14 02 00
	00		 mov	 DWORD PTR [rdi+532], ebx

; 1006 : 
; 1007 : 				if (opentest->bDetectGSTBootLoader || opentest->DetectFilesystem)

  009f7	39 9f 08 02 00
	00		 cmp	 DWORD PTR [rdi+520], ebx
  009fd	75 0c		 jne	 SHORT $LN123@ProcessMai
  009ff	39 9f 10 02 00
	00		 cmp	 DWORD PTR [rdi+528], ebx
  00a05	0f 84 be 01 00
	00		 je	 $LN121@ProcessMai
$LN123@ProcessMai:

; 1008 : 				{
; 1009 : 					byte *readBuffer = GSTalloc (GST_MAX_VOLUME_SECTOR_SIZE);

  00a0b	41 bf 54 43 4d
	4d		 mov	 r15d, 1296909140	; 4d4d4354H
  00a11	41 bc 00 10 00
	00		 mov	 r12d, 4096		; 00001000H
  00a17	33 c9		 xor	 ecx, ecx
  00a19	45 8b c7	 mov	 r8d, r15d
  00a1c	49 8b d4	 mov	 rdx, r12
  00a1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00a25	4c 8b f0	 mov	 r14, rax

; 1010 : 					if (!readBuffer)

  00a28	48 3b c3	 cmp	 rax, rbx
  00a2b	75 0b		 jne	 SHORT $LN122@ProcessMai

; 1011 : 					{
; 1012 : 						ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00a2d	41 bc 9a 00 00
	c0		 mov	 r12d, -1073741670	; ffffffffc000009aH

; 1013 : 					}
; 1014 : 					else

  00a33	e9 8b 01 00 00	 jmp	 $LN279@ProcessMai
$LN122@ProcessMai:

; 1015 : 					{
; 1016 : 						// Determine if the first sector contains a portion of the GostCrypt Boot Loader
; 1017 : 
; 1018 : 						offset.QuadPart = 0;
; 1019 : 
; 1020 : 						ntStatus = ZwReadFile (NtFileHandle,
; 1021 : 							NULL,
; 1022 : 							NULL,
; 1023 : 							NULL,
; 1024 : 							&IoStatus,
; 1025 : 							readBuffer,
; 1026 : 							GST_MAX_VOLUME_SECTOR_SIZE,
; 1027 : 							&offset,
; 1028 : 							NULL);

  00a38	48 8b 4c 24 68	 mov	 rcx, QWORD PTR NtFileHandle$30666[rsp]
  00a3d	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00a42	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR offset$30669[rsp]
  00a4a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00a4f	48 8d 44 24 78	 lea	 rax, QWORD PTR IoStatus$30668[rsp]
  00a54	44 89 64 24 30	 mov	 DWORD PTR [rsp+48], r12d
  00a59	45 33 c9	 xor	 r9d, r9d
  00a5c	45 33 c0	 xor	 r8d, r8d
  00a5f	33 d2		 xor	 edx, edx
  00a61	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00a66	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR offset$30669[rsp], rbx
  00a6e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile

; 1029 : 
; 1030 : 						if (NT_SUCCESS (ntStatus))

  00a79	3b c3		 cmp	 eax, ebx
  00a7b	44 8b e0	 mov	 r12d, eax
  00a7e	0f 8c 33 01 00
	00		 jl	 $LN112@ProcessMai

; 1031 : 						{
; 1032 : 							size_t i;
; 1033 : 
; 1034 : 							if (opentest->bDetectGSTBootLoader && IoStatus.Information >= GST_SECTOR_SIZE_BIOS)

  00a84	39 9f 08 02 00
	00		 cmp	 DWORD PTR [rdi+520], ebx
  00a8a	74 56		 je	 SHORT $LN275@ProcessMai
  00a8c	48 81 bc 24 80
	00 00 00 00 02
	00 00		 cmp	 QWORD PTR IoStatus$30668[rsp+8], 512 ; 00000200H
  00a98	72 48		 jb	 SHORT $LN275@ProcessMai

; 1035 : 							{
; 1036 : 								// Search for the string "GostCrypt"
; 1037 : 								for (i = 0; i < GST_SECTOR_SIZE_BIOS - strlen (GST_APP_NAME); ++i)

  00a9a	48 8b cb	 mov	 rcx, rbx
  00a9d	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:__ImageBase
$LL118@ProcessMai:

; 1038 : 								{
; 1039 : 									if (memcmp (readBuffer + i, GST_APP_NAME, strlen (GST_APP_NAME)) == 0)

  00aa4	4a 8d 04 31	 lea	 rax, QWORD PTR [rcx+r14]
  00aa8	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00aab	4d 3b 85 00 00
	00 00		 cmp	 r8, QWORD PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@[r13]
  00ab2	75 11		 jne	 SHORT $LN273@ProcessMai
  00ab4	44 8a 40 08	 mov	 r8b, BYTE PTR [rax+8]
  00ab8	45 3a 85 08 00
	00 00		 cmp	 r8b, BYTE PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@[r13+8]
  00abf	75 04		 jne	 SHORT $LN273@ProcessMai
  00ac1	8b c3		 mov	 eax, ebx
  00ac3	eb 05		 jmp	 SHORT $LN274@ProcessMai
$LN273@ProcessMai:
  00ac5	1b c0		 sbb	 eax, eax
  00ac7	83 d8 ff	 sbb	 eax, -1
$LN274@ProcessMai:
  00aca	3b c3		 cmp	 eax, ebx
  00acc	74 0e		 je	 SHORT $LN253@ProcessMai
  00ace	48 03 cd	 add	 rcx, rbp
  00ad1	48 81 f9 f7 01
	00 00		 cmp	 rcx, 503		; 000001f7H
  00ad8	72 ca		 jb	 SHORT $LL118@ProcessMai

; 1145 : 					{
; 1146 : 						if (memcmp (readBuffer + i, GST_APP_NAME, strlen (GST_APP_NAME)) == 0)

  00ada	eb 06		 jmp	 SHORT $LN275@ProcessMai
$LN253@ProcessMai:

; 1040 : 									{
; 1041 : 										opentest->GSTBootLoaderDetected = TRUE;

  00adc	89 af 0c 02 00
	00		 mov	 DWORD PTR [rdi+524], ebp
$LN275@ProcessMai:

; 1042 : 										break;
; 1043 : 									}
; 1044 : 								}
; 1045 : 							}
; 1046 : 
; 1047 : 							if (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))

  00ae2	39 9f 10 02 00
	00		 cmp	 DWORD PTR [rdi+528], ebx
  00ae8	0f 84 c9 00 00
	00		 je	 $LN112@ProcessMai
  00aee	48 83 bc 24 80
	00 00 00 08	 cmp	 QWORD PTR IoStatus$30668[rsp+8], 8
  00af7	0f 82 ba 00 00
	00		 jb	 $LN112@ProcessMai

; 1048 : 							{
; 1049 : 								switch (BE64 (*(uint64 *) readBuffer))

  00afd	49 8b 16	 mov	 rdx, QWORD PTR [r14]
  00b00	48 8b c2	 mov	 rax, rdx
  00b03	48 c1 e8 08	 shr	 rax, 8
  00b07	44 0f b6 c0	 movzx	 r8d, al
  00b0b	0f b6 c2	 movzx	 eax, dl
  00b0e	48 c1 e0 08	 shl	 rax, 8
  00b12	4c 0b c0	 or	 r8, rax
  00b15	48 8b c2	 mov	 rax, rdx
  00b18	49 c1 e0 08	 shl	 r8, 8
  00b1c	48 c1 e8 10	 shr	 rax, 16
  00b20	0f b6 c8	 movzx	 ecx, al
  00b23	48 8b c2	 mov	 rax, rdx
  00b26	4c 0b c1	 or	 r8, rcx
  00b29	48 c1 e8 18	 shr	 rax, 24
  00b2d	49 c1 e0 08	 shl	 r8, 8
  00b31	0f b6 c8	 movzx	 ecx, al
  00b34	48 8b c2	 mov	 rax, rdx
  00b37	4c 0b c1	 or	 r8, rcx
  00b3a	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00b3e	49 c1 e0 08	 shl	 r8, 8
  00b42	0f b6 c8	 movzx	 ecx, al
  00b45	48 8b c2	 mov	 rax, rdx
  00b48	4c 0b c1	 or	 r8, rcx
  00b4b	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  00b4f	49 c1 e0 08	 shl	 r8, 8
  00b53	0f b6 c8	 movzx	 ecx, al
  00b56	48 8b c2	 mov	 rax, rdx
  00b59	4c 0b c1	 or	 r8, rcx
  00b5c	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00b60	48 c1 ea 38	 shr	 rdx, 56			; 00000038H
  00b64	49 c1 e0 08	 shl	 r8, 8
  00b68	0f b6 c8	 movzx	 ecx, al
  00b6b	48 b8 53 4f 44
	53 4d 90 3c eb	 mov	 rax, -1496162314409980077 ; eb3c904d53444f53H
  00b75	4c 0b c1	 or	 r8, rcx
  00b78	49 c1 e0 08	 shl	 r8, 8
  00b7c	4c 0b c2	 or	 r8, rdx
  00b7f	4c 3b c0	 cmp	 r8, rax
  00b82	74 2d		 je	 SHORT $LN111@ProcessMai
  00b84	48 b8 20 53 46
	54 4e 90 52 eb	 mov	 rax, -1489969860610469088 ; eb52904e54465320H
  00b8e	4c 3b c0	 cmp	 r8, rax
  00b91	74 1e		 je	 SHORT $LN111@ProcessMai
  00b93	48 b8 53 4f 44
	53 4d 90 58 eb	 mov	 rax, -1488281015062081709 ; eb58904d53444f53H
  00b9d	4c 3b c0	 cmp	 r8, rax
  00ba0	74 0f		 je	 SHORT $LN111@ProcessMai
  00ba2	48 b8 54 41 46
	58 45 90 76 eb	 mov	 rax, -1479836800036486828 ; eb76904558464154H
  00bac	4c 3b c0	 cmp	 r8, rax
  00baf	75 06		 jne	 SHORT $LN112@ProcessMai
$LN111@ProcessMai:

; 1050 : 								{
; 1051 : 								case 0xEB52904E54465320: // NTFS
; 1052 : 								case 0xEB3C904D53444F53: // FAT16
; 1053 : 								case 0xEB58904D53444F53: // FAT32
; 1054 : 								case 0xEB76904558464154: // exFAT
; 1055 : 
; 1056 : 									opentest->FilesystemDetected = TRUE;

  00bb1	89 af 14 02 00
	00		 mov	 DWORD PTR [rdi+532], ebp
$LN112@ProcessMai:

; 1057 : 									break;
; 1058 : 								}
; 1059 : 							}
; 1060 : 						}
; 1061 : 
; 1062 : 						GSTfree (readBuffer);

  00bb7	41 8b d7	 mov	 edx, r15d
  00bba	49 8b ce	 mov	 rcx, r14
  00bbd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN279@ProcessMai:
  00bc3	41 be 18 02 00
	00		 mov	 r14d, 536		; 00000218H
$LN121@ProcessMai:

; 1063 : 					}
; 1064 : 				}
; 1065 : 
; 1066 : 				ZwClose (NtFileHandle);

  00bc9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR NtFileHandle$30666[rsp]
  00bce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN125@ProcessMai:

; 1067 : 				Dump ("Open test on file %ls success.\n", opentest->wszFileName);
; 1068 : 			}
; 1069 : 			else
; 1070 : 			{
; 1071 : #if 0
; 1072 : 				Dump ("Open test on file %ls failed NTSTATUS 0x%08x\n", opentest->wszFileName, ntStatus);
; 1073 : #endif
; 1074 : 			}
; 1075 : 
; 1076 : 			Irp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;

  00bd4	44 3b e3	 cmp	 r12d, ebx

; 1077 : 			Irp->IoStatus.Status = ntStatus;

  00bd7	44 89 66 30	 mov	 DWORD PTR [rsi+48], r12d
  00bdb	49 0f 4d de	 cmovge	 rbx, r14
  00bdf	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 1078 : 		}
; 1079 : 		break;

  00be3	e9 e2 06 00 00	 jmp	 $LN144@ProcessMai

; 1173 : 			{
; 1174 : 				Irp->IoStatus.Status = ntStatus;
; 1175 : 				Irp->IoStatus.Information = 0;
; 1176 : 			}
; 1177 : 		}
; 1178 : 		break;
; 1179 : 
; 1180 : 	case GST_IOCTL_WIPE_PASSWORD_CACHE:
; 1181 : 		WipeCache ();

$LN175@ProcessMai:
  00be8	33 c0		 xor	 eax, eax
  00bea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CachedPasswords
  00bf1	41 b8 20 01 00
	00		 mov	 r8d, 288		; 00000120H
  00bf7	48 8b fa	 mov	 rdi, rdx
  00bfa	49 8b c8	 mov	 rcx, r8
  00bfd	33 db		 xor	 ebx, ebx
  00bff	f3 aa		 rep stosb
  00c01	8d 68 01	 lea	 ebp, QWORD PTR [rax+1]
$LL172@ProcessMai:
  00c04	44 2b c5	 sub	 r8d, ebp
  00c07	88 1a		 mov	 BYTE PTR [rdx], bl
  00c09	48 03 d5	 add	 rdx, rbp
  00c0c	44 3b c3	 cmp	 r8d, ebx
  00c0f	75 f3		 jne	 SHORT $LL172@ProcessMai
  00c11	89 1d 00 00 00
	00		 mov	 DWORD PTR nPasswordIdx, ebx
  00c17	89 2d 00 00 00
	00		 mov	 DWORD PTR cacheEmpty, ebp
$LN291@ProcessMai:

; 1182 : 
; 1183 : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  00c1d	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx
$LN7@ProcessMai:

; 1184 : 		Irp->IoStatus.Information = 0;

  00c20	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 1185 : 		break;

  00c24	e9 a1 06 00 00	 jmp	 $LN144@ProcessMai
$LN92@ProcessMai:

; 1186 : 
; 1187 : 	case GST_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1188 : 		Irp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;

  00c29	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cacheEmpty
  00c2f	f7 d8		 neg	 eax
  00c31	1b c9		 sbb	 ecx, ecx
$LN286@ProcessMai:
  00c33	81 e1 d9 00 00
	c0		 and	 ecx, -1073741607	; ffffffffc00000d9H
  00c39	41 89 48 30	 mov	 DWORD PTR [r8+48], ecx
$LN287@ProcessMai:

; 1189 : 		Irp->IoStatus.Information = 0;

  00c3d	33 db		 xor	 ebx, ebx
  00c3f	49 89 58 38	 mov	 QWORD PTR [r8+56], rbx

; 1190 : 		break;

  00c43	e9 82 06 00 00	 jmp	 $LN144@ProcessMai
$LN136@ProcessMai:

; 953  : 
; 954  : 	case GST_IOCTL_IS_ANY_VOLUME_MOUNTED:
; 955  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00c48	bd 01 00 00 00	 mov	 ebp, 1
  00c4d	48 8b d7	 mov	 rdx, rdi
  00c50	48 8b ce	 mov	 rcx, rsi
  00c53	44 8b c5	 mov	 r8d, ebp
  00c56	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00c5b	33 db		 xor	 ebx, ebx
  00c5d	3b c3		 cmp	 eax, ebx
  00c5f	0f 84 65 06 00
	00		 je	 $LN144@ProcessMai

; 956  : 		{
; 957  : 			int drive;
; 958  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = 0;

  00c65	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]

; 959  : 
; 960  : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00c69	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:__ImageBase
  00c70	89 18		 mov	 DWORD PTR [rax], ebx
  00c72	48 8b c3	 mov	 rax, rbx

; 961  : 			{
; 962  : 				if (GetVirtualVolumeDeviceObject (drive))

  00c75	48 83 f8 19	 cmp	 rax, 25
$LN280@ProcessMai:
  00c79	77 0a		 ja	 SHORT $LN155@ProcessMai
  00c7b	49 8b 8c c5 00
	00 00 00	 mov	 rcx, QWORD PTR VirtualVolumeDeviceObjects[r13+rax*8]
  00c83	eb 03		 jmp	 SHORT $LN157@ProcessMai
$LN155@ProcessMai:
  00c85	48 8b cb	 mov	 rcx, rbx
$LN157@ProcessMai:
  00c88	48 3b cb	 cmp	 rcx, rbx
  00c8b	75 0b		 jne	 SHORT $LN254@ProcessMai
  00c8d	48 03 c5	 add	 rax, rbp
  00c90	48 83 f8 19	 cmp	 rax, 25
  00c94	7e e3		 jle	 SHORT $LN280@ProcessMai

; 1145 : 					{
; 1146 : 						if (memcmp (readBuffer + i, GST_APP_NAME, strlen (GST_APP_NAME)) == 0)

  00c96	eb 06		 jmp	 SHORT $LN132@ProcessMai
$LN254@ProcessMai:

; 963  : 				{
; 964  : 					*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  00c98	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00c9c	89 28		 mov	 DWORD PTR [rax], ebp
$LN132@ProcessMai:

; 965  : 					break;
; 966  : 				}
; 967  : 			}
; 968  : 
; 969  : 			if (IsBootDriveMounted())

  00c9e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00ca5	48 3b c3	 cmp	 rax, rbx
  00ca8	0f 84 8c f8 ff
	ff		 je	 $LN284@ProcessMai
  00cae	39 98 b8 02 00
	00		 cmp	 DWORD PTR [rax+696], ebx
  00cb4	0f 84 80 f8 ff
	ff		 je	 $LN284@ProcessMai

; 970  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = 1;
; 971  : 
; 972  : 			Irp->IoStatus.Information = sizeof (int);
; 973  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 974  : 		}
; 975  : 		break;

  00cba	eb 59		 jmp	 SHORT $LN289@ProcessMai
$LN139@ProcessMai:

; 938  : 
; 939  : 	case GST_IOCTL_IS_DRIVER_UNLOAD_DISABLED:
; 940  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00cbc	bd 01 00 00 00	 mov	 ebp, 1
  00cc1	48 8b d7	 mov	 rdx, rdi
  00cc4	48 8b ce	 mov	 rcx, rsi
  00cc7	44 8b c5	 mov	 r8d, ebp
  00cca	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00ccf	33 db		 xor	 ebx, ebx
  00cd1	3b c3		 cmp	 eax, ebx
  00cd3	0f 84 f1 05 00
	00		 je	 $LN144@ProcessMai

; 941  : 		{
; 942  : 			LONG deviceObjectCount = 0;
; 943  : 
; 944  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;

  00cd9	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00cdd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DriverUnloadDisabled
  00ce3	89 5c 24 60	 mov	 DWORD PTR deviceObjectCount$30640[rsp], ebx
  00ce7	89 01		 mov	 DWORD PTR [rcx], eax

; 945  : 
; 946  : 			if (IoEnumerateDeviceObjectList (GSTDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)

  00ce9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR GSTDriverObject
  00cf0	4c 8d 4c 24 60	 lea	 r9, QWORD PTR deviceObjectCount$30640[rsp]
  00cf5	45 33 c0	 xor	 r8d, r8d
  00cf8	33 d2		 xor	 edx, edx
  00cfa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoEnumerateDeviceObjectList
  00d00	3d 23 00 00 c0	 cmp	 eax, -1073741789	; ffffffffc0000023H
  00d05	0f 85 2f f8 ff
	ff		 jne	 $LN284@ProcessMai
  00d0b	39 6c 24 60	 cmp	 DWORD PTR deviceObjectCount$30640[rsp], ebp
  00d0f	0f 8e 25 f8 ff
	ff		 jle	 $LN284@ProcessMai
$LN289@ProcessMai:

; 947  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;

  00d15	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00d19	89 28		 mov	 DWORD PTR [rax], ebp

; 948  : 
; 949  : 			Irp->IoStatus.Information = sizeof (int);
; 950  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 951  : 		}
; 952  : 		break;

  00d1b	e9 1a f8 ff ff	 jmp	 $LN284@ProcessMai
$LN24@ProcessMai:

; 1526 : 
; 1527 : 	case GST_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1528 : 		GetBootEncryptionStatus (Irp, irpSp);

  00d20	49 8b d4	 mov	 rdx, r12
  00d23	49 8b c8	 mov	 rcx, r8
  00d26	e8 00 00 00 00	 call	 GetBootEncryptionStatus

; 1529 : 		break;

  00d2b	e9 9a 05 00 00	 jmp	 $LN144@ProcessMai
$LN150@ProcessMai:

; 915  : 	NTSTATUS ntStatus;
; 916  : 
; 917  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00d30	b9 70 20 22 00	 mov	 ecx, 2236528		; 00222070H
  00d35	3b c1		 cmp	 eax, ecx
  00d37	0f 87 d2 03 00
	00		 ja	 $LN152@ProcessMai
  00d3d	0f 84 66 01 00
	00		 je	 $LN109@ProcessMai
  00d43	2d 4c 20 22 00	 sub	 eax, 2236492		; 0022204cH
  00d48	0f 84 48 01 00
	00		 je	 $LN26@ProcessMai
  00d4e	bf 04 00 00 00	 mov	 edi, 4
  00d53	2b c7		 sub	 eax, edi
  00d55	0f 84 31 01 00
	00		 je	 $LN25@ProcessMai
  00d5b	2b c7		 sub	 eax, edi
  00d5d	0f 84 14 01 00
	00		 je	 $LN23@ProcessMai
  00d63	2b c7		 sub	 eax, edi
  00d65	0f 84 fc 00 00
	00		 je	 $LN22@ProcessMai
  00d6b	2b c7		 sub	 eax, edi
  00d6d	0f 84 e4 00 00
	00		 je	 $LN20@ProcessMai
  00d73	2b c7		 sub	 eax, edi
  00d75	0f 84 89 00 00
	00		 je	 $LN19@ProcessMai
  00d7b	2b c7		 sub	 eax, edi
  00d7d	74 74		 je	 SHORT $LN88@ProcessMai
  00d7f	2b c7		 sub	 eax, edi
  00d81	74 4b		 je	 SHORT $LN91@ProcessMai
  00d83	3b c7		 cmp	 eax, edi
  00d85	0f 85 cc 03 00
	00		 jne	 $LN1@ProcessMai

; 1550 : 		break;
; 1551 : 
; 1552 : 	case GST_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1553 : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00d8b	8d 6f fd	 lea	 ebp, QWORD PTR [rdi-3]
  00d8e	48 8b d7	 mov	 rdx, rdi
  00d91	48 8b ce	 mov	 rcx, rsi
  00d94	44 8b c5	 mov	 r8d, ebp
  00d97	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00d9c	33 db		 xor	 ebx, ebx
  00d9e	3b c3		 cmp	 eax, ebx
  00da0	0f 84 24 05 00
	00		 je	 $LN144@ProcessMai

; 1554 : 		{
; 1555 : 			*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;

  00da6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00dad	48 3b c3	 cmp	 rax, rbx
  00db0	74 08		 je	 SHORT $LN220@ProcessMai
  00db2	39 98 e0 02 00
	00		 cmp	 DWORD PTR [rax+736], ebx
  00db8	75 02		 jne	 SHORT $LN221@ProcessMai
$LN220@ProcessMai:
  00dba	8b eb		 mov	 ebp, ebx
$LN221@ProcessMai:
  00dbc	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00dc0	8b cb		 mov	 ecx, ebx
  00dc2	3b eb		 cmp	 ebp, ebx
  00dc4	0f 95 c1	 setne	 cl
  00dc7	89 08		 mov	 DWORD PTR [rax], ecx

; 1556 : 			Irp->IoStatus.Information = sizeof (int);
; 1557 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1558 : 		}
; 1559 : 		break;

  00dc9	e9 6c f7 ff ff	 jmp	 $LN284@ProcessMai
$LN91@ProcessMai:

; 1191 : 
; 1192 : 	case GST_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1193 : 		if (!UserCanAccessDriveDevice())

  00dce	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00dd3	33 db		 xor	 ebx, ebx
  00dd5	3b c3		 cmp	 eax, ebx
  00dd7	75 0a		 jne	 SHORT $LN90@ProcessMai
$LN282@ProcessMai:

; 1194 : 		{
; 1195 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  00dd9	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H

; 1196 : 			Irp->IoStatus.Information = 0;
; 1197 : 		}
; 1198 : 		else

  00dde	e9 e0 04 00 00	 jmp	 $LN277@ProcessMai
$LN90@ProcessMai:

; 1199 : 		{
; 1200 : 			PortableMode = TRUE;

  00de3	bd 01 00 00 00	 mov	 ebp, 1
  00de8	89 2d 00 00 00
	00		 mov	 DWORD PTR PortableMode, ebp

; 1201 : 			Dump ("Setting portable mode\n");
; 1202 : 		}
; 1203 : 		break;

  00dee	e9 d7 04 00 00	 jmp	 $LN144@ProcessMai
$LN88@ProcessMai:

; 1204 : 
; 1205 : 	case GST_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1206 : 		Irp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;

  00df3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PortableMode
  00df9	f7 d8		 neg	 eax
  00dfb	1b c9		 sbb	 ecx, ecx
  00dfd	f7 d1		 not	 ecx

; 1207 : 		Irp->IoStatus.Information = 0;
; 1208 : 		break;

  00dff	e9 2f fe ff ff	 jmp	 $LN286@ProcessMai
$LN19@ProcessMai:

; 1547 : 
; 1548 : 	case GST_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:
; 1549 : 		GetBootEncryptionAlgorithmName (Irp, irpSp);

  00e04	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
  00e09	41 b8 01 00 00
	00		 mov	 r8d, 1
  00e0f	48 8b ce	 mov	 rcx, rsi
  00e12	48 8b d7	 mov	 rdx, rdi
  00e15	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00e1a	33 db		 xor	 ebx, ebx
  00e1c	3b c3		 cmp	 eax, ebx
  00e1e	0f 84 a6 04 00
	00		 je	 $LN144@ProcessMai
  00e24	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00e2b	48 3b c3	 cmp	 rax, rbx
  00e2e	0f 84 98 f6 ff
	ff		 je	 $LN43@ProcessMai
  00e34	39 98 b8 02 00
	00		 cmp	 DWORD PTR [rax+696], ebx
  00e3a	0f 84 8c f6 ff
	ff		 je	 $LN43@ProcessMai
  00e40	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00e47	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00e4b	8b 10		 mov	 edx, DWORD PTR [rax]
  00e4d	e8 00 00 00 00	 call	 EAGetName
  00e52	e9 e3 f6 ff ff	 jmp	 $LN284@ProcessMai
$LN20@ProcessMai:

; 1542 : 		break;
; 1543 : 
; 1544 : 	case GST_IOCTL_REOPEN_BOOT_VOLUME_HEADER:
; 1545 : 		ReopenBootVolumeHeader (Irp, irpSp);

  00e57	49 8b d4	 mov	 rdx, r12
  00e5a	49 8b c8	 mov	 rcx, r8
  00e5d	e8 00 00 00 00	 call	 ReopenBootVolumeHeader

; 1546 : 		break;

  00e62	e9 63 04 00 00	 jmp	 $LN144@ProcessMai
$LN22@ProcessMai:

; 1535 : 
; 1536 : 	case GST_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1537 : 		GetBootDriveVolumeProperties (Irp, irpSp);

  00e67	49 8b d4	 mov	 rdx, r12
  00e6a	49 8b c8	 mov	 rcx, r8
  00e6d	e8 00 00 00 00	 call	 GetBootDriveVolumeProperties

; 1538 : 		break;

  00e72	e9 53 04 00 00	 jmp	 $LN144@ProcessMai
$LN23@ProcessMai:

; 1530 : 
; 1531 : 	case GST_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:
; 1532 : 		Irp->IoStatus.Information = 0;
; 1533 : 		Irp->IoStatus.Status = GetSetupResult();

  00e77	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupResult
  00e7d	33 db		 xor	 ebx, ebx
  00e7f	41 89 40 30	 mov	 DWORD PTR [r8+48], eax
  00e83	49 89 58 38	 mov	 QWORD PTR [r8+56], rbx

; 1534 : 		break;

  00e87	e9 3e 04 00 00	 jmp	 $LN144@ProcessMai
$LN25@ProcessMai:

; 1521 : 
; 1522 : 	case GST_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:
; 1523 : 		Irp->IoStatus.Status = AbortBootEncryptionSetup();

  00e8c	e8 00 00 00 00	 call	 AbortBootEncryptionSetup

; 1524 : 		Irp->IoStatus.Information = 0;
; 1525 : 		break;

  00e91	e9 2b 04 00 00	 jmp	 $LN281@ProcessMai
$LN26@ProcessMai:

; 1516 : 
; 1517 : 	case GST_IOCTL_BOOT_ENCRYPTION_SETUP:
; 1518 : 		Irp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);

  00e96	4d 8b c4	 mov	 r8, r12
  00e99	48 8b d6	 mov	 rdx, rsi
  00e9c	49 8b ce	 mov	 rcx, r14
  00e9f	e8 00 00 00 00	 call	 StartBootEncryptionSetup

; 1519 : 		Irp->IoStatus.Information = 0;
; 1520 : 		break;

  00ea4	e9 18 04 00 00	 jmp	 $LN281@ProcessMai
$LN109@ProcessMai:

; 1080 : 
; 1081 : 	case GST_IOCTL_GET_SYSTEM_DRIVE_CONFIG:
; 1082 : 		{
; 1083 : 			GetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;

  00ea9	4d 8b 60 18	 mov	 r12, QWORD PTR [r8+24]

; 1084 : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 1085 : 			HANDLE NtFileHandle;
; 1086 : 			UNICODE_STRING FullFileName;
; 1087 : 			IO_STATUS_BLOCK IoStatus;
; 1088 : 			LARGE_INTEGER offset;
; 1089 : 			byte readBuffer [GST_SECTOR_SIZE_BIOS];
; 1090 : 
; 1091 : 			if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))

  00ead	41 bf 29 02 00
	00		 mov	 r15d, 553		; 00000229H
  00eb3	48 8b ce	 mov	 rcx, rsi
  00eb6	49 8b d7	 mov	 rdx, r15
  00eb9	41 b8 02 00 00
	00		 mov	 r8d, 2
  00ebf	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00ec4	33 db		 xor	 ebx, ebx
  00ec6	3b c3		 cmp	 eax, ebx
  00ec8	0f 84 fc 03 00
	00		 je	 $LN144@ProcessMai

; 1092 : 				break;
; 1093 : 
; 1094 : 			EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));
; 1095 : 			RtlInitUnicodeString (&FullFileName, request->DevicePath);

  00ece	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR FullFileName$30719[rsp]
  00ed6	49 8b d4	 mov	 rdx, r12
  00ed9	66 41 89 9c 24
	06 02 00 00	 mov	 WORD PTR [r12+518], bx
  00ee2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 1096 : 
; 1097 : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
; 1098 : 
; 1099 : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 1100 : 				SYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,
; 1101 : 				FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);

  00ee8	89 5c 24 50	 mov	 DWORD PTR [rsp+80], ebx
  00eec	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00ef1	c7 44 24 40 20
	08 00 00	 mov	 DWORD PTR [rsp+64], 2080 ; 00000820H
  00ef9	8d 6b 01	 lea	 ebp, QWORD PTR [rbx+1]
  00efc	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR FullFileName$30719[rsp]
  00f04	89 6c 24 38	 mov	 DWORD PTR [rsp+56], ebp
  00f08	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  00f10	44 8d 6d 7f	 lea	 r13d, QWORD PTR [rbp+127]
  00f14	4c 8d 8c 24 30
	01 00 00	 lea	 r9, QWORD PTR IoStatus$30720[rsp]
  00f1c	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR ObjectAttributes$30717[rsp]
  00f24	48 8d 4c 24 70	 lea	 rcx, QWORD PTR NtFileHandle$30718[rsp]
  00f29	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  00f2e	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  00f33	c7 84 24 b0 00
	00 00 30 00 00
	00		 mov	 DWORD PTR ObjectAttributes$30717[rsp], 48 ; 00000030H
  00f3e	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00f43	48 89 9c 24 b8
	00 00 00	 mov	 QWORD PTR ObjectAttributes$30717[rsp+8], rbx
  00f4b	c7 84 24 c8 00
	00 00 40 02 00
	00		 mov	 DWORD PTR ObjectAttributes$30717[rsp+24], 576 ; 00000240H
  00f56	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR ObjectAttributes$30717[rsp+16], rax
  00f5e	48 89 9c 24 d0
	00 00 00	 mov	 QWORD PTR ObjectAttributes$30717[rsp+32], rbx
  00f66	48 89 9c 24 d8
	00 00 00	 mov	 QWORD PTR ObjectAttributes$30717[rsp+40], rbx
  00f6e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile

; 1102 : 
; 1103 : 			if (NT_SUCCESS (ntStatus))

  00f74	3b c3		 cmp	 eax, ebx
  00f76	0f 8c 47 03 00
	00		 jl	 $LN277@ProcessMai

; 1104 : 			{
; 1105 : 				// Determine if the first sector contains a portion of the GostCrypt Boot Loader
; 1106 : 				offset.QuadPart = 0;	// MBR
; 1107 : 
; 1108 : 				ntStatus = ZwReadFile (NtFileHandle,
; 1109 : 					NULL,
; 1110 : 					NULL,
; 1111 : 					NULL,
; 1112 : 					&IoStatus,
; 1113 : 					readBuffer,
; 1114 : 					sizeof(readBuffer),
; 1115 : 					&offset,
; 1116 : 					NULL);

  00f7c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR NtFileHandle$30718[rsp]
  00f81	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00f86	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR offset$30721[rsp]
  00f8e	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00f93	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR readBuffer$30722[rsp]
  00f9b	c7 44 24 30 00
	02 00 00	 mov	 DWORD PTR [rsp+48], 512	; 00000200H
  00fa3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00fa8	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR IoStatus$30720[rsp]
  00fb0	45 33 c9	 xor	 r9d, r9d
  00fb3	45 33 c0	 xor	 r8d, r8d
  00fb6	33 d2		 xor	 edx, edx
  00fb8	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR offset$30721[rsp], rbx
  00fc0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fc5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile

; 1117 : 
; 1118 : 				if (NT_SUCCESS (ntStatus))

  00fcb	3b c3		 cmp	 eax, ebx
  00fcd	0f 8c 25 01 00
	00		 jl	 $LN106@ProcessMai

; 1119 : 				{
; 1120 : 					size_t i;
; 1121 : 
; 1122 : 					// Check for dynamic drive
; 1123 : 					request->DriveIsDynamic = FALSE;

  00fd3	41 89 9c 24 09
	02 00 00	 mov	 DWORD PTR [r12+521], ebx

; 1124 : 
; 1125 : 					if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)

  00fdb	80 bc 24 de 03
	00 00 55	 cmp	 BYTE PTR readBuffer$30722[rsp+510], 85 ; 00000055H
  00fe3	75 36		 jne	 SHORT $LN102@ProcessMai
  00fe5	80 bc 24 df 03
	00 00 aa	 cmp	 BYTE PTR readBuffer$30722[rsp+511], 170 ; 000000aaH
  00fed	75 2c		 jne	 SHORT $LN102@ProcessMai

; 1126 : 					{
; 1127 : 						int i;
; 1128 : 						for (i = 0; i < 4; ++i)

  00fef	48 8b cb	 mov	 rcx, rbx
  00ff2	48 8d 84 24 a2
	03 00 00	 lea	 rax, QWORD PTR readBuffer$30722[rsp+450]
  00ffa	8d 7b 04	 lea	 edi, QWORD PTR [rbx+4]
  00ffd	44 8d 73 10	 lea	 r14d, QWORD PTR [rbx+16]
$LL104@ProcessMai:

; 1129 : 						{
; 1130 : 							if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)

  01001	80 38 42	 cmp	 BYTE PTR [rax], 66	; 00000042H
  01004	74 0d		 je	 SHORT $LN255@ProcessMai
  01006	48 03 cd	 add	 rcx, rbp
  01009	49 03 c6	 add	 rax, r14
  0100c	48 3b cf	 cmp	 rcx, rdi
  0100f	7c f0		 jl	 SHORT $LL104@ProcessMai

; 1145 : 					{
; 1146 : 						if (memcmp (readBuffer + i, GST_APP_NAME, strlen (GST_APP_NAME)) == 0)

  01011	eb 08		 jmp	 SHORT $LN102@ProcessMai
$LN255@ProcessMai:

; 1131 : 							{
; 1132 : 								request->DriveIsDynamic = TRUE;

  01013	41 89 ac 24 09
	02 00 00	 mov	 DWORD PTR [r12+521], ebp
$LN102@ProcessMai:

; 1133 : 								break;
; 1134 : 							}
; 1135 : 						}
; 1136 : 					}
; 1137 : 
; 1138 : 					request->BootLoaderVersion = 0;

  0101b	66 41 89 9c 24
	0d 02 00 00	 mov	 WORD PTR [r12+525], bx

; 1139 : 					request->Configuration = 0;

  01024	41 88 9c 24 08
	02 00 00	 mov	 BYTE PTR [r12+520], bl

; 1140 : 					request->UserConfiguration = 0;

  0102c	41 88 9c 24 0f
	02 00 00	 mov	 BYTE PTR [r12+527], bl

; 1141 : 					request->CustomUserMessage[0] = 0;

  01034	41 88 9c 24 10
	02 00 00	 mov	 BYTE PTR [r12+528], bl

; 1142 : 
; 1143 : 					// Search for the string "GostCrypt"
; 1144 : 					for (i = 0; i < sizeof (readBuffer) - strlen (GST_APP_NAME); ++i)

  0103c	48 8b cb	 mov	 rcx, rbx
  0103f	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:__ImageBase
$LL100@ProcessMai:

; 1145 : 					{
; 1146 : 						if (memcmp (readBuffer + i, GST_APP_NAME, strlen (GST_APP_NAME)) == 0)

  01046	48 8d 84 0c e0
	01 00 00	 lea	 rax, QWORD PTR readBuffer$30722[rsp+rcx]
  0104e	48 8b 38	 mov	 rdi, QWORD PTR [rax]
  01051	49 3b bd 00 00
	00 00		 cmp	 rdi, QWORD PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@[r13]
  01058	75 11		 jne	 SHORT $LN271@ProcessMai
  0105a	40 8a 78 08	 mov	 dil, BYTE PTR [rax+8]
  0105e	41 3a bd 08 00
	00 00		 cmp	 dil, BYTE PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@[r13+8]
  01065	75 04		 jne	 SHORT $LN271@ProcessMai
  01067	8b c3		 mov	 eax, ebx
  01069	eb 05		 jmp	 SHORT $LN272@ProcessMai
$LN271@ProcessMai:
  0106b	1b c0		 sbb	 eax, eax
  0106d	83 d8 ff	 sbb	 eax, -1
$LN272@ProcessMai:
  01070	3b c3		 cmp	 eax, ebx
  01072	74 0e		 je	 SHORT $LN256@ProcessMai
  01074	48 03 cd	 add	 rcx, rbp
  01077	48 81 f9 f7 01
	00 00		 cmp	 rcx, 503		; 000001f7H
  0107e	72 c6		 jb	 SHORT $LL100@ProcessMai
  01080	eb 6d		 jmp	 SHORT $LN96@ProcessMai
$LN256@ProcessMai:

; 1147 : 						{
; 1148 : 							request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + GST_BOOT_SECTOR_VERSION_OFFSET));

  01082	0f b7 8c 24 8e
	03 00 00	 movzx	 ecx, WORD PTR readBuffer$30722[rsp+430]
  0108a	66 c1 c1 08	 rol	 cx, 8
  0108e	66 41 89 8c 24
	0d 02 00 00	 mov	 WORD PTR [r12+525], cx

; 1149 : 							request->Configuration = readBuffer[GST_BOOT_SECTOR_CONFIG_OFFSET];

  01097	8a 84 24 97 03
	00 00		 mov	 al, BYTE PTR readBuffer$30722[rsp+439]
  0109e	41 88 84 24 08
	02 00 00	 mov	 BYTE PTR [r12+520], al

; 1150 : 
; 1151 : 							if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)

  010a6	66 3b cb	 cmp	 cx, bx
  010a9	74 44		 je	 SHORT $LN96@ProcessMai
  010ab	ba 00 13 00 00	 mov	 edx, 4864		; 00001300H
  010b0	66 3b ca	 cmp	 cx, dx
  010b3	77 3a		 ja	 SHORT $LN96@ProcessMai

; 1152 : 							{
; 1153 : 								request->UserConfiguration = readBuffer[GST_BOOT_SECTOR_USER_CONFIG_OFFSET];

  010b5	8a 84 24 96 03
	00 00		 mov	 al, BYTE PTR readBuffer$30722[rsp+438]

; 1154 : 								memcpy (request->CustomUserMessage, readBuffer + GST_BOOT_SECTOR_USER_MESSAGE_OFFSET, GST_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  010bc	48 8d 8c 24 76
	03 00 00	 lea	 rcx, QWORD PTR readBuffer$30722[rsp+406]
  010c4	41 88 84 24 0f
	02 00 00	 mov	 BYTE PTR [r12+527], al
  010cc	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  010cf	49 89 84 24 10
	02 00 00	 mov	 QWORD PTR [r12+528], rax
  010d7	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  010db	49 89 84 24 18
	02 00 00	 mov	 QWORD PTR [r12+536], rax
  010e3	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  010e7	49 89 84 24 20
	02 00 00	 mov	 QWORD PTR [r12+544], rax
$LN96@ProcessMai:

; 1155 : 							}
; 1156 : 							break;
; 1157 : 						}
; 1158 : 					}
; 1159 : 
; 1160 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  010ef	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1161 : 					Irp->IoStatus.Information = sizeof (*request);

  010f2	4c 89 7e 38	 mov	 QWORD PTR [rsi+56], r15

; 1162 : 				}
; 1163 : 				else

  010f6	eb 07		 jmp	 SHORT $LN95@ProcessMai
$LN106@ProcessMai:

; 1164 : 				{
; 1165 : 					Irp->IoStatus.Status = ntStatus;

  010f8	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1166 : 					Irp->IoStatus.Information = 0;

  010fb	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx
$LN95@ProcessMai:

; 1167 : 				}
; 1168 : 
; 1169 : 				ZwClose (NtFileHandle);

  010ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR NtFileHandle$30718[rsp]
  01104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1170 : 
; 1171 : 			}
; 1172 : 			else

  0110a	e9 bb 01 00 00	 jmp	 $LN144@ProcessMai
$LN152@ProcessMai:

; 915  : 	NTSTATUS ntStatus;
; 916  : 
; 917  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0110f	2d 78 20 22 00	 sub	 eax, 2236536		; 00222078H
  01114	0f 84 99 01 00
	00		 je	 $LN16@ProcessMai
  0111a	bf 04 00 00 00	 mov	 edi, 4
  0111f	2b c7		 sub	 eax, edi
  01121	0f 84 85 01 00
	00		 je	 $LN15@ProcessMai
  01127	2b c7		 sub	 eax, edi
  01129	0f 84 70 01 00
	00		 je	 $LN13@ProcessMai
  0112f	2b c7		 sub	 eax, edi
  01131	0f 84 59 01 00
	00		 je	 $LN14@ProcessMai
  01137	2b c7		 sub	 eax, edi
  01139	0f 84 02 01 00
	00		 je	 $LN12@ProcessMai
  0113f	2b c7		 sub	 eax, edi
  01141	0f 84 b1 00 00
	00		 je	 $LN11@ProcessMai
  01147	2b c7		 sub	 eax, edi
  01149	0f 84 83 00 00
	00		 je	 $LN9@ProcessMai
  0114f	2b c7		 sub	 eax, edi
  01151	74 73		 je	 SHORT $LN6@ProcessMai
  01153	3b c7		 cmp	 eax, edi
  01155	74 14		 je	 SHORT $LN5@ProcessMai
$LN1@ProcessMai:

; 1630 : 			{
; 1631 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 1632 : 				Irp->IoStatus.Information = 0;
; 1633 : 			}
; 1634 : 		}
; 1635 : 		break;
; 1636 : 
; 1637 : 	default:
; 1638 : 		return GSTCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  01157	bf 10 00 00 c0	 mov	 edi, -1073741808	; ffffffffc0000010H
  0115c	33 db		 xor	 ebx, ebx
  0115e	41 89 78 30	 mov	 DWORD PTR [r8+48], edi
  01162	49 89 58 38	 mov	 QWORD PTR [r8+56], rbx
  01166	e9 62 01 00 00	 jmp	 $LN270@ProcessMai
$LN5@ProcessMai:

; 1616 : 
; 1617 : 	case GST_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:
; 1618 : 		if (ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))

  0116b	bf 0c 00 00 00	 mov	 edi, 12
  01170	48 8b ce	 mov	 rcx, rsi
  01173	44 8d 47 f5	 lea	 r8d, QWORD PTR [rdi-11]
  01177	48 8b d7	 mov	 rdx, rdi
  0117a	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0117f	33 db		 xor	 ebx, ebx
  01181	3b c3		 cmp	 eax, ebx
  01183	0f 84 41 01 00
	00		 je	 $LN144@ProcessMai

; 1619 : 		{
; 1620 : 			GetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;
; 1621 : 
; 1622 : 			request->BootDriveFilterExtension = GetBootDriveFilterExtension();

  01189	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  01190	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  01194	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1623 : 			if (IsBootDriveMounted() && request->BootDriveFilterExtension)

  01197	48 3b c3	 cmp	 rax, rbx
  0119a	0f 84 2c f3 ff
	ff		 je	 $LN43@ProcessMai
  011a0	39 98 b8 02 00
	00		 cmp	 DWORD PTR [rax+696], ebx
  011a6	0f 84 20 f3 ff
	ff		 je	 $LN43@ProcessMai

; 1624 : 			{
; 1625 : 				request->HwEncryptionEnabled = IsHwEncryptionEnabled();

  011ac	39 1d 00 00 00
	00		 cmp	 DWORD PTR HwEncryptionDisabled, ebx
  011b2	8b c3		 mov	 eax, ebx
  011b4	0f 94 c0	 sete	 al
  011b7	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1626 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  011ba	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1627 : 				Irp->IoStatus.Information = sizeof (*request);

  011bd	48 89 7e 38	 mov	 QWORD PTR [rsi+56], rdi

; 1628 : 			}
; 1629 : 			else

  011c1	e9 04 01 00 00	 jmp	 $LN144@ProcessMai
$LN6@ProcessMai:

; 1611 : 
; 1612 : 	case GST_IOCTL_REREAD_DRIVER_CONFIG:
; 1613 : 		Irp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);

  011c6	33 c9		 xor	 ecx, ecx
  011c8	e8 00 00 00 00	 call	 ReadRegistryConfigFlags

; 1614 : 		Irp->IoStatus.Information = 0;
; 1615 : 		break;

  011cd	e9 ef 00 00 00	 jmp	 $LN281@ProcessMai
$LN9@ProcessMai:

; 1599 : 
; 1600 : 	case GST_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:
; 1601 : 		if (UserCanAccessDriveDevice())

  011d2	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  011d7	33 db		 xor	 ebx, ebx
  011d9	3b c3		 cmp	 eax, ebx
  011db	74 0e		 je	 SHORT $LN8@ProcessMai

; 1602 : 		{
; 1603 : 			SystemFavoriteVolumeDirty = TRUE;

  011dd	8d 6b 01	 lea	 ebp, QWORD PTR [rbx+1]
  011e0	89 2d 00 00 00
	00		 mov	 DWORD PTR SystemFavoriteVolumeDirty, ebp

; 1604 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1605 : 		}
; 1606 : 		else

  011e6	e9 32 fa ff ff	 jmp	 $LN291@ProcessMai
$LN8@ProcessMai:

; 1607 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  011eb	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  011f0	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1608 : 
; 1609 : 		Irp->IoStatus.Information = 0;
; 1610 : 		break;

  011f3	e9 28 fa ff ff	 jmp	 $LN7@ProcessMai
$LN11@ProcessMai:

; 1582 : 		Irp->IoStatus.Information = 0;
; 1583 : 		break;
; 1584 : 
; 1585 : 	case GST_IOCTL_GET_WARNING_FLAGS:
; 1586 : 		if (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))

  011f8	ba 08 00 00 00	 mov	 edx, 8
  011fd	48 8b ce	 mov	 rcx, rsi
  01200	44 8d 42 f9	 lea	 r8d, QWORD PTR [rdx-7]
  01204	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01209	33 db		 xor	 ebx, ebx
  0120b	3b c3		 cmp	 eax, ebx
  0120d	0f 84 b7 00 00
	00		 je	 $LN144@ProcessMai

; 1587 : 		{
; 1588 : 			GetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;
; 1589 : 
; 1590 : 			flags->PagingFileCreationPrevented = PagingFileCreationPrevented;

  01213	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PagingFileCreationPrevented
  01219	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]

; 1591 : 			PagingFileCreationPrevented = FALSE;

  0121d	89 1d 00 00 00
	00		 mov	 DWORD PTR PagingFileCreationPrevented, ebx
  01223	89 01		 mov	 DWORD PTR [rcx], eax

; 1592 : 			flags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;

  01225	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SystemFavoriteVolumeDirty

; 1593 : 			SystemFavoriteVolumeDirty = FALSE;

  0122b	89 1d 00 00 00
	00		 mov	 DWORD PTR SystemFavoriteVolumeDirty, ebx
  01231	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1594 : 
; 1595 : 			Irp->IoStatus.Information = sizeof (GetWarningFlagsRequest);

  01234	48 c7 46 38 08
	00 00 00	 mov	 QWORD PTR [rsi+56], 8

; 1596 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1597 : 		}
; 1598 : 		break;

  0123c	e9 fd f2 ff ff	 jmp	 $LN285@ProcessMai
$LN12@ProcessMai:

; 1579 : 
; 1580 : 	case GST_IOCTL_WRITE_BOOT_DRIVE_SECTOR:
; 1581 : 		Irp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);

  01241	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  01246	33 db		 xor	 ebx, ebx
  01248	3b c3		 cmp	 eax, ebx
  0124a	0f 84 89 fb ff
	ff		 je	 $LN282@ProcessMai
  01250	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR BootDriveFilterExtension
  01257	48 3b d3	 cmp	 rdx, rbx
  0125a	0f 84 6c f2 ff
	ff		 je	 $LN43@ProcessMai
  01260	41 81 7c 24 10
	08 02 00 00	 cmp	 DWORD PTR [r12+16], 520	; 00000208H
  01269	0f 82 5d f2 ff
	ff		 jb	 $LN43@ProcessMai
  0126f	4c 8b 4e 18	 mov	 r9, QWORD PTR [rsi+24]
  01273	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  01277	8d 4b 01	 lea	 ecx, QWORD PTR [rbx+1]
  0127a	4d 8d 41 08	 lea	 r8, QWORD PTR [r9+8]
  0127e	4d 8b 09	 mov	 r9, QWORD PTR [r9]
  01281	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  01289	e8 00 00 00 00	 call	 GSTReadWriteDevice
  0128e	eb 33		 jmp	 SHORT $LN277@ProcessMai
$LN14@ProcessMai:

; 1570 : 
; 1571 : 	case GST_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:
; 1572 : 		Irp->IoStatus.Status = GetDecoySystemWipeResult();

  01290	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeResult
  01296	41 89 40 30	 mov	 DWORD PTR [r8+48], eax

; 1573 : 		Irp->IoStatus.Information = 0;
; 1574 : 		break;

  0129a	e9 9e f9 ff ff	 jmp	 $LN287@ProcessMai
$LN13@ProcessMai:

; 1575 : 
; 1576 : 	case GST_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 1577 : 		GetDecoySystemWipeStatus (Irp, irpSp);

  0129f	49 8b d4	 mov	 rdx, r12
  012a2	49 8b c8	 mov	 rcx, r8
  012a5	e8 00 00 00 00	 call	 GetDecoySystemWipeStatus

; 1578 : 		break;

  012aa	eb 1e		 jmp	 SHORT $LN144@ProcessMai
$LN15@ProcessMai:

; 1564 : 		break;
; 1565 : 
; 1566 : 	case GST_IOCTL_ABORT_DECOY_SYSTEM_WIPE:
; 1567 : 		Irp->IoStatus.Status = AbortDecoySystemWipe();

  012ac	e8 00 00 00 00	 call	 AbortDecoySystemWipe

; 1568 : 		Irp->IoStatus.Information = 0;
; 1569 : 		break;

  012b1	eb 0e		 jmp	 SHORT $LN281@ProcessMai
$LN16@ProcessMai:

; 1560 : 
; 1561 : 	case GST_IOCTL_START_DECOY_SYSTEM_WIPE:
; 1562 : 		Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);

  012b3	4d 8b c4	 mov	 r8, r12
  012b6	48 8b d6	 mov	 rdx, rsi
  012b9	49 8b ce	 mov	 rcx, r14
  012bc	e8 00 00 00 00	 call	 StartDecoySystemWipe
$LN281@ProcessMai:

; 1563 : 		Irp->IoStatus.Information = 0;

  012c1	33 db		 xor	 ebx, ebx
$LN277@ProcessMai:
  012c3	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx
$LN278@ProcessMai:

; 1560 : 
; 1561 : 	case GST_IOCTL_START_DECOY_SYSTEM_WIPE:
; 1562 : 		Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);

  012c7	89 46 30	 mov	 DWORD PTR [rsi+48], eax
$LN144@ProcessMai:

; 1639 : 	}
; 1640 : 
; 1641 : 	
; 1642 : #ifdef DEBUG
; 1643 : 	if (!NT_SUCCESS (Irp->IoStatus.Status))
; 1644 : 	{
; 1645 : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
; 1646 : 		{
; 1647 : 		case GST_IOCTL_GET_MOUNTED_VOLUMES:
; 1648 : 		case GST_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1649 : 		case GST_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1650 : 		case GST_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1651 : 		case GST_IOCTL_OPEN_TEST:
; 1652 : 		case GST_IOCTL_GET_RESOLVED_SYMLINK:
; 1653 : 		case GST_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1654 : 		case GST_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1655 : 		case GST_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1656 : 		case GST_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1657 : 			break;
; 1658 : 
; 1659 : 		default:
; 1660 : 			Dump ("IOCTL error 0x%08x\n", Irp->IoStatus.Status);
; 1661 : 		}
; 1662 : 	}
; 1663 : #endif
; 1664 : 
; 1665 : 	return GSTCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  012ca	8b 7e 30	 mov	 edi, DWORD PTR [rsi+48]
$LN270@ProcessMai:

; 1630 : 			{
; 1631 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 1632 : 				Irp->IoStatus.Information = 0;
; 1633 : 			}
; 1634 : 		}
; 1635 : 		break;
; 1636 : 
; 1637 : 	default:
; 1638 : 		return GSTCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  012cd	33 d2		 xor	 edx, edx
  012cf	48 8b ce	 mov	 rcx, rsi
  012d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  012d8	8b c7		 mov	 eax, edi

; 1666 : }

  012da	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  012e2	48 33 cc	 xor	 rcx, rsp
  012e5	e8 00 00 00 00	 call	 __security_check_cookie
  012ea	48 8b 9c 24 38
	04 00 00	 mov	 rbx, QWORD PTR [rsp+1080]
  012f2	48 81 c4 f0 03
	00 00		 add	 rsp, 1008		; 000003f0H
  012f9	41 5f		 pop	 r15
  012fb	41 5e		 pop	 r14
  012fd	41 5d		 pop	 r13
  012ff	41 5c		 pop	 r12
  01301	5f		 pop	 rdi
  01302	5e		 pop	 rsi
  01303	5d		 pop	 rbp
  01304	c3		 ret	 0
ProcessMainDeviceControlIrp ENDP
PUBLIC	GSTDispatchQueueIRP
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTDispatchQueueIRP DD imagerel $LN65
	DD	imagerel $LN65+742
	DD	imagerel $unwind$GSTDispatchQueueIRP
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTDispatchQueueIRP DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTDispatchQueueIRP
_TEXT	SEGMENT
DeviceObject$ = 64
Irp$ = 72
GSTDispatchQueueIRP PROC				; COMDAT

; 265  : {

$LN65:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 266  : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  00014	48 8b 71 40	 mov	 rsi, QWORD PTR [rcx+64]

; 267  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 268  : 	NTSTATUS ntStatus;
; 269  : 
; 270  : #ifdef _DEBUG
; 271  : 	if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL && (Extension->bRootDevice || Extension->IsVolumeDevice))
; 272  : 	{
; 273  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
; 274  : 		{
; 275  : 		case GST_IOCTL_GET_MOUNTED_VOLUMES:
; 276  : 		case GST_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 277  : 		case GST_IOCTL_GET_PORTABLE_MODE_STATUS:
; 278  : 		case GST_IOCTL_SET_PORTABLE_MODE_STATUS:
; 279  : 		case GST_IOCTL_OPEN_TEST:
; 280  : 		case GST_IOCTL_GET_RESOLVED_SYMLINK:
; 281  : 		case GST_IOCTL_GET_DEVICE_REFCOUNT:
; 282  : 		case GST_IOCTL_GET_DRIVE_PARTITION_INFO:
; 283  : 		case GST_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 284  : 		case GST_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 285  : 		case GST_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 286  : 		case GST_IOCTL_GET_WARNING_FLAGS:
; 287  : 		case GST_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 288  : 		case IOCTL_DISK_CHECK_VERIFY:
; 289  : 			break;
; 290  : 
; 291  : 		default:
; 292  : 			Dump ("%ls (0x%x %d)\n",
; 293  : 				GSTTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode),
; 294  : 				(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 295  : 				(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));
; 296  : 		}
; 297  : 	}
; 298  : #endif
; 299  : 
; 300  : 	if (!Extension->bRootDevice)

  00018	33 ed		 xor	 ebp, ebp
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
  00020	48 8b 92 b8 00
	00 00		 mov	 rdx, QWORD PTR [rdx+184]
  00027	48 8b f9	 mov	 rdi, rcx
  0002a	44 3b c5	 cmp	 r8d, ebp
  0002d	75 24		 jne	 SHORT $LN27@GSTDispatc

; 301  : 	{
; 302  : 		// Drive filter IRP
; 303  : 		if (Extension->IsDriveFilterDevice)

  0002f	39 6e 08	 cmp	 DWORD PTR [rsi+8], ebp
  00032	74 0d		 je	 SHORT $LN28@GSTDispatc

; 304  : 			return DriveFilterDispatchIrp (DeviceObject, Irp);

  00034	48 8b d3	 mov	 rdx, rbx
  00037	e8 00 00 00 00	 call	 DriveFilterDispatchIrp
  0003c	e9 90 02 00 00	 jmp	 $LN30@GSTDispatc
$LN28@GSTDispatc:

; 305  : 
; 306  : 		// Volume filter IRP
; 307  : 		if (Extension->IsVolumeFilterDevice)

  00041	39 6e 0c	 cmp	 DWORD PTR [rsi+12], ebp
  00044	74 0d		 je	 SHORT $LN27@GSTDispatc

; 308  : 			return VolumeFilterDispatchIrp (DeviceObject, Irp);

  00046	48 8b d3	 mov	 rdx, rbx
  00049	e8 00 00 00 00	 call	 VolumeFilterDispatchIrp
  0004e	e9 7e 02 00 00	 jmp	 $LN30@GSTDispatc
$LN27@GSTDispatc:

; 309  : 	}
; 310  : 
; 311  : 	switch (irpSp->MajorFunction)

  00053	8a 0a		 mov	 cl, BYTE PTR [rdx]
  00055	8a c1		 mov	 al, cl
  00057	40 3a cd	 cmp	 cl, bpl
  0005a	0f 84 5d 02 00
	00		 je	 $LN24@GSTDispatc
  00060	41 b1 02	 mov	 r9b, 2
  00063	41 3a c1	 cmp	 al, r9b
  00066	0f 84 51 02 00
	00		 je	 $LN24@GSTDispatc
  0006c	0f 86 41 02 00
	00		 jbe	 $LN8@GSTDispatc
  00072	41 b3 09	 mov	 r11b, 9
  00075	41 b2 0e	 mov	 r10b, 14
  00078	3c 04		 cmp	 al, 4
  0007a	0f 86 e7 00 00
	00		 jbe	 $LN15@GSTDispatc
  00080	41 3a c3	 cmp	 al, r11b
  00083	0f 84 de 00 00
	00		 je	 $LN15@GSTDispatc
  00089	41 3a c2	 cmp	 al, r10b
  0008c	0f 84 d5 00 00
	00		 je	 $LN15@GSTDispatc
  00092	3c 10		 cmp	 al, 16
  00094	74 54		 je	 SHORT $LN23@GSTDispatc
  00096	3c 12		 cmp	 al, 18
  00098	0f 84 1f 02 00
	00		 je	 $LN24@GSTDispatc
  0009e	3c 1b		 cmp	 al, 27
  000a0	0f 85 0d 02 00
	00		 jne	 $LN8@GSTDispatc

; 396  : 		}
; 397  : 
; 398  : 		break;
; 399  : 
; 400  : 	case IRP_MJ_PNP:
; 401  : 		if (!Extension->bRootDevice
; 402  : 			&& Extension->IsVolumeDevice
; 403  : 			&& irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION
; 404  : 			&& irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
; 405  : 			&& irpSp->Parameters.UsageNotification.InPath)

  000a6	44 3b c5	 cmp	 r8d, ebp
  000a9	0f 85 04 02 00
	00		 jne	 $LN8@GSTDispatc
  000af	39 6e 04	 cmp	 DWORD PTR [rsi+4], ebp
  000b2	0f 84 fb 01 00
	00		 je	 $LN8@GSTDispatc
  000b8	80 7a 01 16	 cmp	 BYTE PTR [rdx+1], 22
  000bc	0f 85 f1 01 00
	00		 jne	 $LN8@GSTDispatc
  000c2	83 7a 10 01	 cmp	 DWORD PTR [rdx+16], 1
  000c6	0f 85 e7 01 00
	00		 jne	 $LN8@GSTDispatc
  000cc	40 38 6a 08	 cmp	 BYTE PTR [rdx+8], bpl
  000d0	0f 84 dd 01 00
	00		 je	 $LN8@GSTDispatc

; 406  : 		{
; 407  : 			PagingFileCreationPrevented = TRUE;

  000d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR PagingFileCreationPrevented, 1

; 408  : 			return GSTCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);

  000e0	bf 01 00 00 c0	 mov	 edi, -1073741823	; ffffffffc0000001H
  000e5	e9 dd 00 00 00	 jmp	 $LN61@GSTDispatc
$LN23@GSTDispatc:

; 317  : 
; 318  : 	case IRP_MJ_SHUTDOWN:
; 319  : 		if (Extension->bRootDevice)

  000ea	44 3b c5	 cmp	 r8d, ebp
  000ed	74 6e		 je	 SHORT $LN22@GSTDispatc

; 320  : 		{
; 321  : 			Dump ("Driver shutting down\n");
; 322  : 			DriverShuttingDown = TRUE;

  000ef	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DriverShuttingDown, 1

; 323  : 
; 324  : 			if (EncryptionSetupThread)

  000f9	bf 9a 00 00 c0	 mov	 edi, -1073741670	; ffffffffc000009aH
  000fe	48 39 2d 00 00
	00 00		 cmp	 QWORD PTR EncryptionSetupThread, rbp
  00105	74 24		 je	 SHORT $LN19@GSTDispatc
$LL20@GSTDispatc:

; 325  : 				while (SendDeviceIoControlRequest (RootDeviceObject, GST_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00107	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0010e	45 33 c9	 xor	 r9d, r9d
  00111	45 33 c0	 xor	 r8d, r8d
  00114	ba 50 20 22 00	 mov	 edx, 2236496		; 00222050H
  00119	89 6c 24 28	 mov	 DWORD PTR [rsp+40], ebp
  0011d	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00122	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00127	3b c7		 cmp	 eax, edi
  00129	74 dc		 je	 SHORT $LL20@GSTDispatc
$LN19@GSTDispatc:

; 326  : 
; 327  : 			if (DecoySystemWipeThread)

  0012b	48 39 2d 00 00
	00 00		 cmp	 QWORD PTR DecoySystemWipeThread, rbp
  00132	74 24		 je	 SHORT $LN16@GSTDispatc
$LL17@GSTDispatc:

; 328  : 				while (SendDeviceIoControlRequest (RootDeviceObject, GST_IOCTL_ABORT_DECOY_SYSTEM_WIPE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00134	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0013b	45 33 c9	 xor	 r9d, r9d
  0013e	45 33 c0	 xor	 r8d, r8d
  00141	ba 7c 20 22 00	 mov	 edx, 2236540		; 0022207cH
  00146	89 6c 24 28	 mov	 DWORD PTR [rsp+40], ebp
  0014a	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0014f	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00154	3b c7		 cmp	 eax, edi
  00156	74 dc		 je	 SHORT $LL17@GSTDispatc
$LN16@GSTDispatc:

; 329  : 
; 330  : 			OnShutdownPending();

  00158	e8 00 00 00 00	 call	 OnShutdownPending
$LN22@GSTDispatc:

; 331  : 		}
; 332  : 
; 333  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  0015d	89 6b 30	 mov	 DWORD PTR [rbx+48], ebp
  00160	8b fd		 mov	 edi, ebp
  00162	e9 d8 00 00 00	 jmp	 $LN60@GSTDispatc
$LN15@GSTDispatc:

; 334  : 
; 335  : 	case IRP_MJ_FLUSH_BUFFERS:
; 336  : 	case IRP_MJ_READ:
; 337  : 	case IRP_MJ_WRITE:
; 338  : 	case IRP_MJ_DEVICE_CONTROL:
; 339  : 
; 340  : 		if (Extension->bRootDevice)

  00167	44 3b c5	 cmp	 r8d, ebp
  0016a	74 51		 je	 SHORT $LN14@GSTDispatc

; 341  : 		{
; 342  : 			if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)

  0016c	41 3a ca	 cmp	 cl, r10b
  0016f	0f 85 3e 01 00
	00		 jne	 $LN8@GSTDispatc

; 343  : 			{
; 344  : 				NTSTATUS status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, NULL);

  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  0017c	45 33 c9	 xor	 r9d, r9d
  0017f	45 33 c0	 xor	 r8d, r8d
  00182	33 d2		 xor	 edx, edx
  00184	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 345  : 				if (!NT_SUCCESS (status))

  0018f	3b c5		 cmp	 eax, ebp

; 346  : 					return status;

  00191	0f 8c 3a 01 00
	00		 jl	 $LN30@GSTDispatc

; 347  : 
; 348  : 				status = ProcessMainDeviceControlIrp (DeviceObject, Extension, Irp);

  00197	4c 8b c3	 mov	 r8, rbx
  0019a	48 8b d6	 mov	 rdx, rsi
  0019d	48 8b cf	 mov	 rcx, rdi
  001a0	e8 00 00 00 00	 call	 ProcessMainDeviceControlIrp

; 349  : 
; 350  : 				KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  001ac	33 d2		 xor	 edx, edx
  001ae	8b d8		 mov	 ebx, eax
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex

; 351  : 				return status;

  001b6	8b c3		 mov	 eax, ebx
  001b8	e9 14 01 00 00	 jmp	 $LN30@GSTDispatc
$LN14@GSTDispatc:

; 352  : 			}
; 353  : 			break;
; 354  : 		}
; 355  : 
; 356  : 		if (Extension->bShuttingDown)

  001bd	39 6e 18	 cmp	 DWORD PTR [rsi+24], ebp
  001c0	74 0a		 je	 SHORT $LN11@GSTDispatc

; 357  : 		{
; 358  : 			Dump ("Device %d shutting down: STATUS_DELETE_PENDING\n", Extension->nDosDriveNo);
; 359  : 			return GSTCompleteDiskIrp (Irp, STATUS_DELETE_PENDING, 0);

  001c2	bf 56 00 00 c0	 mov	 edi, -1073741738	; ffffffffc0000056H
$LN61@GSTDispatc:
  001c7	89 7b 30	 mov	 DWORD PTR [rbx+48], edi
  001ca	eb 73		 jmp	 SHORT $LN60@GSTDispatc
$LN11@GSTDispatc:

; 360  : 		}
; 361  : 
; 362  : 		if (Extension->bRemovable
; 363  : 			&& (DeviceObject->Flags & DO_VERIFY_VOLUME)
; 364  : 			&& !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)
; 365  : 			&& irpSp->MajorFunction != IRP_MJ_FLUSH_BUFFERS)

  001cc	39 ae 44 03 00
	00		 cmp	 DWORD PTR [rsi+836], ebp
  001d2	74 18		 je	 SHORT $LN10@GSTDispatc
  001d4	44 84 4f 30	 test	 BYTE PTR [rdi+48], r9b
  001d8	74 12		 je	 SHORT $LN10@GSTDispatc
  001da	44 84 4a 02	 test	 BYTE PTR [rdx+2], r9b
  001de	75 0c		 jne	 SHORT $LN10@GSTDispatc
  001e0	41 3a cb	 cmp	 cl, r11b
  001e3	74 07		 je	 SHORT $LN10@GSTDispatc

; 366  : 		{
; 367  : 			Dump ("Removable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_NOT_READY\n", Extension->nDosDriveNo);
; 368  : 			return GSTCompleteDiskIrp (Irp, STATUS_DEVICE_NOT_READY, 0);

  001e5	bf a3 00 00 c0	 mov	 edi, -1073741661	; ffffffffc00000a3H
  001ea	eb db		 jmp	 SHORT $LN61@GSTDispatc
$LN10@GSTDispatc:

; 369  : 		}
; 370  : 
; 371  : 		switch (irpSp->MajorFunction)

  001ec	8a c1		 mov	 al, cl
  001ee	80 f9 03	 cmp	 cl, 3
  001f1	0f 82 bc 00 00
	00		 jb	 $LN8@GSTDispatc
  001f7	3c 04		 cmp	 al, 4
  001f9	0f 86 92 00 00
	00		 jbe	 $LN7@GSTDispatc
  001ff	41 3a c3	 cmp	 al, r11b
  00202	0f 84 85 00 00
	00		 je	 $LN3@GSTDispatc
  00208	41 3a c2	 cmp	 al, r10b
  0020b	0f 85 a2 00 00
	00		 jne	 $LN8@GSTDispatc

; 381  : 
; 382  : 		case IRP_MJ_DEVICE_CONTROL:
; 383  : 			ntStatus = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00211	48 8d 8e 80 01
	00 00		 lea	 rcx, QWORD PTR [rsi+384]
  00218	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  0021f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00225	48 8b d3	 mov	 rdx, rbx
  00228	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx

; 384  : 			if (!NT_SUCCESS (ntStatus))

  00236	3b c5		 cmp	 eax, ebp
  00238	8b f8		 mov	 edi, eax
  0023a	7d 16		 jge	 SHORT $LN4@GSTDispatc

; 385  : 				return GSTCompleteIrp (Irp, ntStatus, 0);

  0023c	89 43 30	 mov	 DWORD PTR [rbx+48], eax
$LN60@GSTDispatc:

; 331  : 		}
; 332  : 
; 333  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  0023f	33 d2		 xor	 edx, edx
$LN64@GSTDispatc:
  00241	48 8b cb	 mov	 rcx, rbx
  00244	48 89 6b 38	 mov	 QWORD PTR [rbx+56], rbp
  00248	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 378  : 				GSTCompleteDiskIrp (Irp, ntStatus, 0);

$LN44@GSTDispatc:

; 331  : 		}
; 332  : 
; 333  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  0024e	8b c7		 mov	 eax, edi
  00250	eb 7f		 jmp	 SHORT $LN30@GSTDispatc
$LN4@GSTDispatc:

; 386  : 
; 387  : 			IoMarkIrpPending (Irp);

  00252	48 8b 83 b8 00
	00 00		 mov	 rax, QWORD PTR [rbx+184]

; 388  : 			
; 389  : 			ExInterlockedInsertTailList (&Extension->ListEntry, &Irp->Tail.Overlay.ListEntry, &Extension->ListSpinLock);

  00259	4c 8d 46 40	 lea	 r8, QWORD PTR [rsi+64]
  0025d	48 8d 93 a8 00
	00 00		 lea	 rdx, QWORD PTR [rbx+168]
  00264	80 48 03 01	 or	 BYTE PTR [rax+3], 1
  00268	48 8d 4e 48	 lea	 rcx, QWORD PTR [rsi+72]
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedInsertTailList

; 390  : 			KeReleaseSemaphore (&Extension->RequestSemaphore, IO_DISK_INCREMENT, 1, FALSE);

  00272	45 33 c9	 xor	 r9d, r9d
  00275	48 8d 4e 58	 lea	 rcx, QWORD PTR [rsi+88]
  00279	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  0027d	44 8b c2	 mov	 r8d, edx
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSemaphore

; 391  : 			
; 392  : 			return STATUS_PENDING;

  00286	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  0028b	eb 44		 jmp	 SHORT $LN30@GSTDispatc
$LN3@GSTDispatc:

; 393  : 
; 394  : 		case IRP_MJ_FLUSH_BUFFERS:
; 395  : 			return GSTCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  0028d	b2 01		 mov	 dl, 1
  0028f	eb 2e		 jmp	 SHORT $LN62@GSTDispatc
$LN7@GSTDispatc:

; 372  : 		{
; 373  : 		case IRP_MJ_READ:
; 374  : 		case IRP_MJ_WRITE:
; 375  : 			ntStatus = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);

  00291	48 8d 8e e0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+224]
  00298	48 8b d3	 mov	 rdx, rbx
  0029b	e8 00 00 00 00	 call	 EncryptedIoQueueAddIrp
  002a0	8b f8		 mov	 edi, eax

; 376  : 
; 377  : 			if (ntStatus != STATUS_PENDING)

  002a2	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  002a7	74 a5		 je	 SHORT $LN44@GSTDispatc

; 378  : 				GSTCompleteDiskIrp (Irp, ntStatus, 0);

  002a9	3b c5		 cmp	 eax, ebp
  002ab	89 43 30	 mov	 DWORD PTR [rbx+48], eax
  002ae	0f 9d c2	 setge	 dl

; 379  : 
; 380  : 			return ntStatus;

  002b1	eb 8e		 jmp	 SHORT $LN64@GSTDispatc
$LN8@GSTDispatc:

; 409  : 		}
; 410  : 		break;
; 411  : 	}
; 412  : 
; 413  : 	return GSTCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  002b3	bf 10 00 00 c0	 mov	 edi, -1073741808	; ffffffffc0000010H
  002b8	e9 0a ff ff ff	 jmp	 $LN61@GSTDispatc
$LN24@GSTDispatc:

; 312  : 	{
; 313  : 	case IRP_MJ_CLOSE:
; 314  : 	case IRP_MJ_CREATE:
; 315  : 	case IRP_MJ_CLEANUP:
; 316  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  002bd	33 d2		 xor	 edx, edx
$LN62@GSTDispatc:
  002bf	48 8b cb	 mov	 rcx, rbx
  002c2	89 6b 30	 mov	 DWORD PTR [rbx+48], ebp
  002c5	48 89 6b 38	 mov	 QWORD PTR [rbx+56], rbp
  002c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  002cf	33 c0		 xor	 eax, eax
$LN30@GSTDispatc:

; 414  : }

  002d1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  002d6	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  002db	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  002e0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002e4	5f		 pop	 rdi
  002e5	c3		 ret	 0
GSTDispatchQueueIRP ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	DriverEntry
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN33
	DD	imagerel $LN33+663
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 092719H
	DD	0275415H
	DD	0263415H
	DD	0200115H
	DD	0700ce00eH
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	0f0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DriverEntry
INIT	SEGMENT
DeviceObject$42947 = 64
startKeyValue$ = 64
version$ = 72
ntUnicodeString$42944 = 80
Win32NameString$42943 = 96
ntname$42946 = 112
dosname$42945 = 176
__$ArrayPad$ = 240
DriverObject$ = 288
RegistryPath$ = 296
DriverEntry PROC					; COMDAT

; 81   : {

$LN33:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00027	48 8b f2	 mov	 rsi, rdx
  0002a	48 8b d9	 mov	 rbx, rcx

; 82   : 	PKEY_VALUE_PARTIAL_INFORMATION startKeyValue;
; 83   : 	LONG version;
; 84   : 	int i;
; 85   : 
; 86   : 	Dump ("DriverEntry " GST_APP_NAME " " VERSION_STRING "\n");
; 87   : 
; 88   : 	PsGetVersion (&OsMajorVersion, &OsMinorVersion, NULL, NULL);

  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:OsMinorVersion
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:OsMajorVersion
  0003b	45 33 c9	 xor	 r9d, r9d
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsGetVersion

; 89   : 
; 90   : 	// Load dump filter if the main driver is already loaded
; 91   : 	if (NT_SUCCESS (GSTDeviceIoControl (NT_ROOT_PREFIX, GST_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version))))

  00047	48 8d 44 24 48	 lea	 rax, QWORD PTR version$[rsp]
  0004c	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  00053	49 8b ce	 mov	 rcx, r14
  00056	45 33 c9	 xor	 r9d, r9d
  00059	45 33 c0	 xor	 r8d, r8d
  0005c	ba 04 20 22 00	 mov	 edx, 2236420		; 00222004H
  00061	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  00069	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006e	e8 00 00 00 00	 call	 GSTDeviceIoControl
  00073	33 ed		 xor	 ebp, ebp
  00075	3b c5		 cmp	 eax, ebp
  00077	7c 10		 jl	 SHORT $LN7@DriverEntr

; 92   : 		return DumpFilterEntry ((PFILTER_EXTENSION) DriverObject, (PFILTER_INITIALIZATION_DATA) RegistryPath);

  00079	48 8b d6	 mov	 rdx, rsi
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 DumpFilterEntry
  00084	e9 e6 01 00 00	 jmp	 $LN8@DriverEntr
$LN7@DriverEntr:

; 93   : 
; 94   : 	GSTDriverObject = DriverObject;
; 95   : 	memset (VirtualVolumeDeviceObjects, 0, sizeof (VirtualVolumeDeviceObjects));

  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VirtualVolumeDeviceObjects
  00090	33 d2		 xor	 edx, edx
  00092	41 b8 d0 00 00
	00		 mov	 r8d, 208		; 000000d0H
  00098	48 89 1d 00 00
	00 00		 mov	 QWORD PTR GSTDriverObject, rbx
  0009f	e8 00 00 00 00	 call	 memset

; 96   : 
; 97   : 	ReadRegistryConfigFlags (TRUE);

  000a4	b9 01 00 00 00	 mov	 ecx, 1
  000a9	e8 00 00 00 00	 call	 ReadRegistryConfigFlags

; 98   : 	EncryptionThreadPoolStart (EncryptionThreadPoolFreeCpuCountLimit);

  000ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR EncryptionThreadPoolFreeCpuCountLimit
  000b5	e8 00 00 00 00	 call	 EncryptionThreadPoolStart

; 99   : 	SelfTestsPassed = AutoTestAlgorithms();

  000ba	e8 00 00 00 00	 call	 DoAutoTestAlgorithms
  000bf	f7 d8		 neg	 eax
  000c1	1b ff		 sbb	 edi, edi
  000c3	83 e7 01	 and	 edi, 1
  000c6	e8 00 00 00 00	 call	 DoAutoTestAlgorithms

; 100  : 
; 101  : 	// Enable device class filters and load boot arguments if the driver is set to start at system boot
; 102  : 		
; 103  : 	if (NT_SUCCESS (GSTReadRegistryKey (RegistryPath, L"Start", &startKeyValue)))

  000cb	4c 8d 44 24 40	 lea	 r8, QWORD PTR startKeyValue$[rsp]
  000d0	f7 d8		 neg	 eax
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
  000d9	1b c9		 sbb	 ecx, ecx
  000db	23 cf		 and	 ecx, edi
  000dd	89 0d 00 00 00
	00		 mov	 DWORD PTR SelfTestsPassed, ecx
  000e3	48 8b ce	 mov	 rcx, rsi
  000e6	e8 00 00 00 00	 call	 GSTReadRegistryKey
  000eb	3b c5		 cmp	 eax, ebp
  000ed	7c 66		 jl	 SHORT $LN6@DriverEntr

; 104  : 	{
; 105  : 		if (startKeyValue->Type == REG_DWORD && *((uint32 *) startKeyValue->Data) == SERVICE_BOOT_START)

  000ef	48 8b 7c 24 40	 mov	 rdi, QWORD PTR startKeyValue$[rsp]
  000f4	83 7f 04 04	 cmp	 DWORD PTR [rdi+4], 4
  000f8	75 4d		 jne	 SHORT $LN5@DriverEntr
  000fa	39 6f 0c	 cmp	 DWORD PTR [rdi+12], ebp
  000fd	75 48		 jne	 SHORT $LN5@DriverEntr

; 106  : 		{
; 107  : 			if (!SelfTestsPassed)

  000ff	39 2d 00 00 00
	00		 cmp	 DWORD PTR SelfTestsPassed, ebp
  00105	75 21		 jne	 SHORT $LN4@DriverEntr

; 108  : 				GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00107	45 33 c9	 xor	 r9d, r9d
  0010a	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  00111	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0011a	41 8d 51 6c	 lea	 edx, QWORD PTR [r9+108]
  0011e	8d 4a bd	 lea	 ecx, QWORD PTR [rdx-67]
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00127	cc		 int	 3
$LN4@DriverEntr:

; 109  : 
; 110  : 			LoadBootArguments();

  00128	e8 00 00 00 00	 call	 LoadBootArguments

; 111  : 			VolumeClassFilterRegistered = IsVolumeClassFilterRegistered();

  0012d	e8 00 00 00 00	 call	 IsVolumeClassFilterRegistered

; 112  : 
; 113  : 			DriverObject->DriverExtension->AddDevice = DriverAddDevice;

  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DriverAddDevice
  00139	89 05 00 00 00
	00		 mov	 DWORD PTR VolumeClassFilterRegistered, eax
  0013f	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00143	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN5@DriverEntr:

; 114  : 		}
; 115  : 
; 116  : 		GSTfree (startKeyValue);

  00147	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0014c	48 8b cf	 mov	 rcx, rdi
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@DriverEntr:

; 117  : 	}
; 118  : 
; 119  : 	for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)
; 120  : 	{
; 121  : 		DriverObject->MajorFunction[i] = GSTDispatchQueueIRP;

  00155	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:GSTDispatchQueueIRP
  0015c	48 8d 7b 70	 lea	 rdi, QWORD PTR [rbx+112]
  00160	b9 1c 00 00 00	 mov	 ecx, 28
  00165	f3 48 ab	 rep stosq

; 122  : 	}
; 123  : 
; 124  : 	DriverObject->DriverUnload = GSTUnloadDriver;

  00168	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:GSTUnloadDriver

; 125  : 	return GSTCreateRootDeviceObject (DriverObject);

  0016f	48 8b cd	 mov	 rcx, rbp
  00172	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax
$LL26@DriverEntr:
  00176	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  0017d	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00181	48 83 c1 02	 add	 rcx, 2
  00185	66 89 84 0c ae
	00 00 00	 mov	 WORD PTR dosname$42945[rsp+rcx-2], ax
  0018d	66 3b c5	 cmp	 ax, bp
  00190	75 e4		 jne	 SHORT $LL26@DriverEntr
  00192	48 8b cd	 mov	 rcx, rbp
$LL27@DriverEntr:
  00195	42 0f b7 04 31	 movzx	 eax, WORD PTR [rcx+r14]
  0019a	48 83 c1 02	 add	 rcx, 2
  0019e	66 89 44 0c 6e	 mov	 WORD PTR ntname$42946[rsp+rcx-2], ax
  001a3	66 3b c5	 cmp	 ax, bp
  001a6	75 ed		 jne	 SHORT $LL27@DriverEntr
  001a8	48 8d 54 24 70	 lea	 rdx, QWORD PTR ntname$42946[rsp]
  001ad	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ntUnicodeString$42944[rsp]
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString
  001b8	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR dosname$42945[rsp]
  001c0	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Win32NameString$42943[rsp]
  001c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString
  001cb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR DeviceObject$42947[rsp]
  001d0	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  001d6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001db	41 8d 51 e2	 lea	 edx, QWORD PTR [r9-30]
  001df	4c 8d 44 24 50	 lea	 r8, QWORD PTR ntUnicodeString$42944[rsp]
  001e4	48 8b cb	 mov	 rcx, rbx
  001e7	40 88 6c 24 28	 mov	 BYTE PTR [rsp+40], bpl
  001ec	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  001f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice
  001fa	3b c5		 cmp	 eax, ebp
  001fc	8b f8		 mov	 edi, eax
  001fe	7c 6d		 jl	 SHORT $LN24@DriverEntr
  00200	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$42947[rsp]
  00205	33 d2		 xor	 edx, edx
  00207	83 48 30 10	 or	 DWORD PTR [rax+48], 16
  0020b	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$42947[rsp]
  00210	c7 80 98 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+152], 1
  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$42947[rsp]
  0021f	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00223	c7 01 01 00 00
	00		 mov	 DWORD PTR [rcx], 1
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeMutex
  00236	48 8d 54 24 50	 lea	 rdx, QWORD PTR ntUnicodeString$42944[rsp]
  0023b	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Win32NameString$42943[rsp]
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink
  00246	48 8b 4c 24 40	 mov	 rcx, QWORD PTR DeviceObject$42947[rsp]
  0024b	3b c5		 cmp	 eax, ebp
  0024d	8b f8		 mov	 edi, eax
  0024f	7d 08		 jge	 SHORT $LN22@DriverEntr
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice
  00257	eb 14		 jmp	 SHORT $LN24@DriverEntr
$LN22@DriverEntr:
  00259	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoRegisterShutdownNotification
  0025f	48 8b 54 24 40	 mov	 rdx, QWORD PTR DeviceObject$42947[rsp]
  00264	8b fd		 mov	 edi, ebp
  00266	48 89 15 00 00
	00 00		 mov	 QWORD PTR RootDeviceObject, rdx
$LN24@DriverEntr:
  0026d	8b c7		 mov	 eax, edi
$LN8@DriverEntr:

; 126  : }

  0026f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00277	48 33 cc	 xor	 rcx, rsp
  0027a	e8 00 00 00 00	 call	 __security_check_cookie
  0027f	4c 8d 9c 24 00
	01 00 00	 lea	 r11, QWORD PTR [rsp+256]
  00287	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  0028b	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  0028f	49 8b e3	 mov	 rsp, r11
  00292	41 5e		 pop	 r14
  00294	5f		 pop	 rdi
  00295	5e		 pop	 rsi
  00296	c3		 ret	 0
$LN32@DriverEntr:
DriverEntry ENDP
INIT	ENDS
END
