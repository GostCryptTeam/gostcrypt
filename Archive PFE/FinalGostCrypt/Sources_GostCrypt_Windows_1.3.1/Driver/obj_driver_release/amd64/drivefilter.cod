; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	IoSetCompletionRoutine
PUBLIC	IoGetNextIrpStackLocation
PUBLIC	IoCopyCurrentIrpStackLocationToNext
PUBLIC	IoGetCurrentIrpStackLocation
PUBLIC	IoMarkIrpPending
PUBLIC	IoSkipCurrentIrpStackLocation
PUBLIC	KeLowerIrql
PUBLIC	KeGetCurrentIrql
PUBLIC	KfRaiseIrql
PUBLIC	KeRaiseIrqlToDpcLevel
PUBLIC	KeInitializeSpinLock
PUBLIC	RtlSecureZeroMemory
PUBLIC	KeGetCurrentThread
PUBLIC	PsGetCurrentThread
PUBLIC	BootArgsValid
PUBLIC	EncryptionSetupThread
PUBLIC	DecoySystemWipeThread
PUBLIC	??_C@_00CNPNBAHC@?$AA@FNODOBFM@			;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_KeInitializeMutex:PROC
EXTRN	__imp_IoAttachDeviceToDeviceStack:PROC
EXTRN	__imp_IoCreateDevice:PROC
EXTRN	__imp_IoInitializeRemoveLockEx:PROC
EXTRN	__imp_IoDeleteDevice:PROC
EXTRN	__imp_IoDetachDevice:PROC
EXTRN	__imp_IoGetAttachedDeviceReference:PROC
EXTRN	__imp_IoReleaseRemoveLockAndWaitEx:PROC
EXTRN	__imp_ObfDereferenceObject:PROC
EXTRN	__imp_IofCallDriver:PROC
EXTRN	__imp_KeInitializeEvent:PROC
EXTRN	__imp_IoAllocateWorkItem:PROC
EXTRN	__imp_IoFreeWorkItem:PROC
EXTRN	__imp_IoQueueWorkItem:PROC
EXTRN	__imp_KeSetEvent:PROC
EXTRN	__imp_KeReleaseMutex:PROC
EXTRN	__imp_KeWaitForSingleObject:PROC
EXTRN	__imp_MmMapIoSpace:PROC
EXTRN	__imp_MmUnmapIoSpace:PROC
EXTRN	__imp_IoAcquireRemoveLockEx:PROC
EXTRN	__imp_IoReleaseRemoveLockEx:PROC
EXTRN	__imp_PoCallDriver:PROC
EXTRN	__imp_PoStartNextPowerIrp:PROC
EXTRN	__imp_MmBuildMdlForNonPagedPool:PROC
EXTRN	__imp_MmAllocateContiguousMemory:PROC
EXTRN	__imp_MmFreeContiguousMemory:PROC
EXTRN	__imp_IoAllocateMdl:PROC
EXTRN	__imp_IoFreeMdl:PROC
EXTRN	__imp_PsSetLoadImageNotifyRoutine:PROC
EXTRN	__imp_KeBugCheckEx:PROC
EXTRN	__imp_ExAllocatePoolWithTag:PROC
EXTRN	__imp_ExFreePoolWithTag:PROC
EXTRN	__imp_PsTerminateSystemThread:PROC
EXTRN	__imp_KeAcquireSpinLockRaiseToDpc:PROC
EXTRN	__imp_KeReleaseSpinLock:PROC
EXTRN	__imp_IoIsSystemThread:PROC
COMM	BootArgs:BYTE:076H
DeviceFilterActive DD 01H DUP (?)
BootArgsValid DD 01H DUP (?)
BootDriveSignatureValid DD 01H DUP (?)
BootDriveFound DD 01H DUP (?)
BootDriveFilterExtension DQ 01H DUP (?)
CrashDumpEnabled DD 01H DUP (?)
HibernationEnabled DD 01H DUP (?)
LegacyHibernationDriverFilterActive DD 01H DUP (?)
	ALIGN	8

HibernationWriteBuffer DQ 01H DUP (?)
HibernationWriteBufferMdl DQ 01H DUP (?)
HibernationPreventionCount DD 01H DUP (?)
SetupInProgress DD 01H DUP (?)
EncryptionSetupThread DQ 01H DUP (?)
DecoySystemWipeInProgress DD 01H DUP (?)
	ALIGN	8

DecoySystemWipeThread DQ 01H DUP (?)
LastHiberFilterNumber DD 01H DUP (?)
;	COMDAT ??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ DB 'H', 00H
	DB	'I', 00H, 'B', 00H, 'E', 00H, 'R', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB 'H', 00H
	DB	'i', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB 'h', 00H
	DB	'i', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_00CNPNBAHC@?$AA@FNODOBFM@ DB 00H			;  ?? ::FNODOBFM::`string'
PUBLIC	GetBootDriveLength
BootDriveLength DQ 01H DUP (?)
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
;	COMDAT GetBootDriveLength
_TEXT	SEGMENT
GetBootDriveLength PROC					; COMDAT

; 2375 : 	return BootDriveLength.QuadPart;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveLength

; 2376 : }

  00007	c3		 ret	 0
GetBootDriveLength ENDP
_TEXT	ENDS
PUBLIC	GetDecoySystemWipeResult
DecoySystemWipeResult DD 01H DUP (?)
; Function compile flags: /Ogspy
;	COMDAT GetDecoySystemWipeResult
_TEXT	SEGMENT
GetDecoySystemWipeResult PROC				; COMDAT

; 2338 : 	return DecoySystemWipeResult;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeResult

; 2339 : }

  00006	c3		 ret	 0
GetDecoySystemWipeResult ENDP
_TEXT	ENDS
PUBLIC	GetSystemDriveCryptoInfo
; Function compile flags: /Ogspy
;	COMDAT GetSystemDriveCryptoInfo
_TEXT	SEGMENT
GetSystemDriveCryptoInfo PROC				; COMDAT

; 2059 : 	return BootDriveFilterExtension->Queue.CryptoInfo;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00007	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]

; 2060 : }

  0000e	c3		 ret	 0
GetSystemDriveCryptoInfo ENDP
_TEXT	ENDS
PUBLIC	GetBootDriveFilterExtension
; Function compile flags: /Ogspy
;	COMDAT GetBootDriveFilterExtension
_TEXT	SEGMENT
GetBootDriveFilterExtension PROC			; COMDAT

; 2046 : 	return BootDriveFilterExtension;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension

; 2047 : }

  00007	c3		 ret	 0
GetBootDriveFilterExtension ENDP
_TEXT	ENDS
PUBLIC	IsHiddenSystemRunning
; Function compile flags: /Ogspy
;	COMDAT IsHiddenSystemRunning
_TEXT	SEGMENT
IsHiddenSystemRunning PROC				; COMDAT

; 2033 : 	return BootDriveFilterExtension && BootDriveFilterExtension->HiddenSystem;

  00000	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00007	33 c0		 xor	 eax, eax
  00009	48 3b c8	 cmp	 rcx, rax
  0000c	74 0d		 je	 SHORT $LN4@IsHiddenSy
  0000e	39 81 e0 02 00
	00		 cmp	 DWORD PTR [rcx+736], eax
  00014	74 05		 je	 SHORT $LN4@IsHiddenSy
  00016	b8 01 00 00 00	 mov	 eax, 1
$LN4@IsHiddenSy:

; 2034 : }

  0001b	c3		 ret	 0
IsHiddenSystemRunning ENDP
_TEXT	ENDS
PUBLIC	IsBootDriveMounted
; Function compile flags: /Ogspy
;	COMDAT IsBootDriveMounted
_TEXT	SEGMENT
IsBootDriveMounted PROC					; COMDAT

; 2007 : 	return BootDriveFilterExtension && BootDriveFilterExtension->DriveMounted;

  00000	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00007	33 c0		 xor	 eax, eax
  00009	48 3b c8	 cmp	 rcx, rax
  0000c	74 0d		 je	 SHORT $LN4@IsBootDriv
  0000e	39 81 b8 02 00
	00		 cmp	 DWORD PTR [rcx+696], eax
  00014	74 05		 je	 SHORT $LN4@IsBootDriv
  00016	b8 01 00 00 00	 mov	 eax, 1
$LN4@IsBootDriv:

; 2008 : }

  0001b	c3		 ret	 0
IsBootDriveMounted ENDP
_TEXT	ENDS
PUBLIC	GetSetupResult
SetupResult DD	01H DUP (?)
; Function compile flags: /Ogspy
;	COMDAT GetSetupResult
_TEXT	SEGMENT
GetSetupResult PROC					; COMDAT

; 1994 : 	return SetupResult;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupResult

; 1995 : }

  00006	c3		 ret	 0
GetSetupResult ENDP
_TEXT	ENDS
PUBLIC	DriveFilterAddDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriveFilterAddDevice DD imagerel $LN7
	DD	imagerel $LN7+372
	DD	imagerel $unwind$DriveFilterAddDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriveFilterAddDevice DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DriveFilterAddDevice
_TEXT	SEGMENT
driverObject$ = 80
pdo$ = 88
filterDeviceObject$ = 96
DriveFilterAddDevice PROC				; COMDAT

; 166  : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 167  : 	DriveFilterExtension *Extension;
; 168  : 	NTSTATUS status;
; 169  : 	PDEVICE_OBJECT filterDeviceObject = NULL;

  0000f	48 83 64 24 60
	00		 and	 QWORD PTR filterDeviceObject$[rsp], 0
  00015	48 8b f9	 mov	 rdi, rcx

; 170  : 	PDEVICE_OBJECT attachedDeviceObject;
; 171  : 
; 172  : 	Dump ("DriveFilterAddDevice pdo=%p\n", pdo);
; 173  : 
; 174  : 	attachedDeviceObject = IoGetAttachedDeviceReference (pdo);

  00018	48 8b ca	 mov	 rcx, rdx
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetAttachedDeviceReference

; 175  : 	status = IoCreateDevice (driverObject, sizeof (DriveFilterExtension), NULL, attachedDeviceObject->DeviceType, 0, FALSE, &filterDeviceObject);

  00024	45 33 c0	 xor	 r8d, r8d
  00027	48 8b d8	 mov	 rbx, rax
  0002a	48 8d 44 24 60	 lea	 rax, QWORD PTR filterDeviceObject$[rsp]
  0002f	ba e8 02 00 00	 mov	 edx, 744		; 000002e8H
  00034	44 8b 4b 48	 mov	 r9d, DWORD PTR [rbx+72]
  00038	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0003d	48 8b cf	 mov	 rcx, rdi
  00040	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00045	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 176  : 
; 177  : 	ObDereferenceObject (attachedDeviceObject);

  00050	48 8b cb	 mov	 rcx, rbx
  00053	8b f8		 mov	 edi, eax
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 178  : 
; 179  : 	if (!NT_SUCCESS (status))

  0005b	85 ff		 test	 edi, edi

; 180  : 	{
; 181  : 		filterDeviceObject = NULL;
; 182  : 		goto err;

  0005d	0f 88 ff 00 00
	00		 js	 $LN2@DriveFilte

; 183  : 	}
; 184  : 
; 185  : 	Extension = (DriveFilterExtension *) filterDeviceObject->DeviceExtension;

  00063	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]

; 186  : 	memset (Extension, 0, sizeof (DriveFilterExtension));

  00068	33 d2		 xor	 edx, edx
  0006a	41 b8 e8 02 00
	00		 mov	 r8d, 744		; 000002e8H
  00070	48 8b 59 40	 mov	 rbx, QWORD PTR [rcx+64]
  00074	48 8b cb	 mov	 rcx, rbx
  00077	e8 00 00 00 00	 call	 memset

; 187  : 
; 188  : 	Extension->LowerDeviceObject = IoAttachDeviceToDeviceStack (filterDeviceObject, pdo);  // IoAttachDeviceToDeviceStackSafe() is not required in AddDevice routine and is also unavailable on Windows 2000 SP4

  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
  00081	48 8b d6	 mov	 rdx, rsi
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAttachDeviceToDeviceStack
  0008a	4c 8b d8	 mov	 r11, rax
  0008d	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 189  : 	if (!Extension->LowerDeviceObject)

  00091	48 85 c0	 test	 rax, rax
  00094	75 31		 jne	 SHORT $LN3@DriveFilte

; 212  : 	return status;
; 213  : 
; 214  : err:
; 215  : 	if (filterDeviceObject)

  00096	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
  0009b	bf b6 02 00 c0	 mov	 edi, -1073741130	; ffffffffc00002b6H
$err$28118:
  000a0	48 85 c9	 test	 rcx, rcx
  000a3	0f 84 b9 00 00
	00		 je	 $LN2@DriveFilte

; 216  : 	{
; 217  : 		if (Extension->LowerDeviceObject)

  000a9	48 3b c0	 cmp	 rax, rax
  000ac	74 0e		 je	 SHORT $LN1@DriveFilte

; 218  : 			IoDetachDevice (Extension->LowerDeviceObject);

  000ae	48 8b c8	 mov	 rcx, rax
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDetachDevice
  000b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
$LN1@DriveFilte:

; 219  : 
; 220  : 		IoDeleteDevice (filterDeviceObject);

  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice
  000c2	e9 9b 00 00 00	 jmp	 $LN2@DriveFilte
$LN3@DriveFilte:

; 190  : 	{
; 191  : 		status = STATUS_DEVICE_REMOVED;
; 192  : 		goto err;
; 193  : 	}
; 194  : 
; 195  : 	Extension->IsDriveFilterDevice = Extension->Queue.IsFilterDevice = TRUE;

  000c7	c7 83 b8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+184], 1
  000d1	c7 43 08 01 00
	00 00		 mov	 DWORD PTR [rbx+8], 1

; 196  : 	Extension->DeviceObject = Extension->Queue.DeviceObject = filterDeviceObject;

  000d8	48 8b 44 24 60	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  000dd	48 89 43 50	 mov	 QWORD PTR [rbx+80], rax
  000e1	48 8b 44 24 60	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]

; 197  : 	Extension->Pdo = pdo;
; 198  : 	
; 199  : 	Extension->Queue.LowerDeviceObject = Extension->LowerDeviceObject;
; 200  : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  000e6	48 8d 8b f0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+240]
  000ed	45 33 c9	 xor	 r9d, r9d
  000f0	45 33 c0	 xor	 r8d, r8d
  000f3	ba 54 43 52 4c	 mov	 edx, 1280459604		; 4c524354H
  000f8	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
  000fc	48 89 73 28	 mov	 QWORD PTR [rbx+40], rsi
  00100	4c 89 9b c0 00
	00 00		 mov	 QWORD PTR [rbx+192], r11
  00107	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoInitializeRemoveLockEx

; 201  : 
; 202  : 	Extension->ConfiguredEncryptedAreaStart = -1;
; 203  : 	Extension->ConfiguredEncryptedAreaEnd = -1;
; 204  : 	Extension->Queue.EncryptedAreaStart = -1;
; 205  : 	Extension->Queue.EncryptedAreaEnd = -1;
; 206  : 	Extension->Queue.EncryptedAreaEndUpdatePending = FALSE;
; 207  : 
; 208  : 	filterDeviceObject->Flags |= Extension->LowerDeviceObject->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE);

  00115	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00119	49 83 cb ff	 or	 r11, -1

; 209  : 	filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
; 210  : 
; 211  : 	DeviceFilterActive = TRUE;

  0011d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DeviceFilterActive, 1
  00127	4c 89 5b 38	 mov	 QWORD PTR [rbx+56], r11
  0012b	4c 89 5b 40	 mov	 QWORD PTR [rbx+64], r11
  0012f	4c 89 9b c8 00
	00 00		 mov	 QWORD PTR [rbx+200], r11
  00136	4c 89 9b d0 00
	00 00		 mov	 QWORD PTR [rbx+208], r11
  0013d	c7 83 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rbx+216], 0
  00147	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  0014a	48 8b 54 24 60	 mov	 rdx, QWORD PTR filterDeviceObject$[rsp]
  0014f	81 e1 14 20 00
	00		 and	 ecx, 8212		; 00002014H
  00155	09 4a 30	 or	 DWORD PTR [rdx+48], ecx
  00158	48 8b 44 24 60	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  0015d	0f ba 70 30 07	 btr	 DWORD PTR [rax+48], 7
$LN2@DriveFilte:

; 221  : 	}
; 222  : 
; 223  : 	return status;
; 224  : }

  00162	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00167	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0016c	8b c7		 mov	 eax, edi
  0016e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00172	5f		 pop	 rdi
  00173	c3		 ret	 0
DriveFilterAddDevice ENDP
_TEXT	ENDS
PUBLIC	LoadBootArguments
BootLoaderSegment DW 01H DUP (?)
	ALIGN	4

MountMutex DB	038H DUP (?)
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\cache.c
pdata	SEGMENT
$pdata$LoadBootArguments DD imagerel $LN27
	DD	imagerel $LN27+572
	DD	imagerel $unwind$LoadBootArguments
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LoadBootArguments DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0f0145218H
	DD	07010d012H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT LoadBootArguments
_TEXT	SEGMENT
LoadBootArguments PROC					; COMDAT

; 83   : {

$LN27:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 55		 push	 r13
  00012	41 57		 push	 r15
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 84   : 	NTSTATUS status = STATUS_UNSUCCESSFUL;
; 85   : 	PHYSICAL_ADDRESS bootArgsAddr;
; 86   : 	byte *mappedBootArgs;
; 87   : 	uint16 bootLoaderSegment;
; 88   : 
; 89   : 	KeInitializeMutex (&MountMutex, 0);

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MountMutex
  0001f	33 d2		 xor	 edx, edx
  00021	bb 01 00 00 c0	 mov	 ebx, -1073741823	; ffffffffc0000001H
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeMutex

; 90   : 
; 91   : 	for (bootLoaderSegment = GST_BOOT_LOADER_SEGMENT;
; 92   : 		bootLoaderSegment >= GST_BOOT_LOADER_SEGMENT - 64 * 1024 / 16 && status != STATUS_SUCCESS;
; 93   : 		bootLoaderSegment -= 32 * 1024 / 16)

  0002c	33 ed		 xor	 ebp, ebp
  0002e	be 00 90 00 00	 mov	 esi, 36864		; 00009000H
  00033	44 8d 6d 76	 lea	 r13d, QWORD PTR [rbp+118]
  00037	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:CachedPasswords
$LL9@LoadBootAr:
  0003e	3b dd		 cmp	 ebx, ebp
  00040	0f 84 b3 01 00
	00		 je	 $LN7@LoadBootAr

; 94   : 	{
; 95   : 		bootArgsAddr.QuadPart = (bootLoaderSegment << 4) + GST_BOOT_LOADER_ARGS_OFFSET;

  00046	0f b7 c6	 movzx	 eax, si

; 96   : 		Dump ("Checking BootArguments at 0x%x\n", bootArgsAddr.LowPart);
; 97   : 
; 98   : 		mappedBootArgs = MmMapIoSpace (bootArgsAddr, sizeof (BootArguments), MmCached);

  00049	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004f	49 8b d5	 mov	 rdx, r13
  00052	ff c0		 inc	 eax
  00054	c1 e0 04	 shl	 eax, 4
  00057	48 63 c8	 movsxd	 rcx, eax
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapIoSpace
  00060	48 8b f8	 mov	 rdi, rax

; 99   : 		if (!mappedBootArgs)

  00063	48 3b c5	 cmp	 rax, rbp
  00066	0f 84 c9 01 00
	00		 je	 $LN21@LoadBootAr

; 101  : 
; 102  : 		if (GST_IS_BOOT_ARGUMENTS_SIGNATURE (mappedBootArgs))

  0006c	80 38 54	 cmp	 BYTE PTR [rax], 84	; 00000054H
  0006f	0f 85 60 01 00
	00		 jne	 $LN5@LoadBootAr
  00075	80 78 01 52	 cmp	 BYTE PTR [rax+1], 82	; 00000052H
  00079	0f 85 56 01 00
	00		 jne	 $LN5@LoadBootAr
  0007f	80 78 02 55	 cmp	 BYTE PTR [rax+2], 85	; 00000055H
  00083	0f 85 4c 01 00
	00		 jne	 $LN5@LoadBootAr
  00089	80 78 03 45	 cmp	 BYTE PTR [rax+3], 69	; 00000045H
  0008d	0f 85 42 01 00
	00		 jne	 $LN5@LoadBootAr
  00093	80 78 04 11	 cmp	 BYTE PTR [rax+4], 17
  00097	0f 85 38 01 00
	00		 jne	 $LN5@LoadBootAr
  0009d	80 78 05 23	 cmp	 BYTE PTR [rax+5], 35	; 00000023H
  000a1	0f 85 2e 01 00
	00		 jne	 $LN5@LoadBootAr
  000a7	80 78 06 45	 cmp	 BYTE PTR [rax+6], 69	; 00000045H
  000ab	0f 85 24 01 00
	00		 jne	 $LN5@LoadBootAr
  000b1	80 78 07 66	 cmp	 BYTE PTR [rax+7], 102	; 00000066H
  000b5	0f 85 1a 01 00
	00		 jne	 $LN5@LoadBootAr

; 103  : 		{
; 104  : 			BootArguments *bootArguments = (BootArguments *) mappedBootArgs;
; 105  : 			Dump ("BootArguments found at 0x%x\n", bootArgsAddr.LowPart);
; 106  : 
; 107  : 			DumpMem (mappedBootArgs, sizeof (BootArguments));
; 108  : 
; 109  : 			if (bootArguments->BootLoaderVersion == VERSION_NUM
; 110  : 				&& bootArguments->BootArgumentsCrc32 != GetCrc32 ((byte *) bootArguments, (int) ((byte *) &bootArguments->BootArgumentsCrc32 - (byte *) bootArguments)))

  000bb	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  000c0	66 39 47 08	 cmp	 WORD PTR [rdi+8], ax
  000c4	75 16		 jne	 SHORT $LN4@LoadBootAr
  000c6	ba 72 00 00 00	 mov	 edx, 114		; 00000072H
  000cb	48 8b cf	 mov	 rcx, rdi
  000ce	e8 00 00 00 00	 call	 GetCrc32
  000d3	39 47 72	 cmp	 DWORD PTR [rdi+114], eax
  000d6	0f 85 38 01 00
	00		 jne	 $LN22@LoadBootAr
$LN4@LoadBootAr:

; 114  : 			}
; 115  : 
; 116  : 			BootLoaderSegment = bootLoaderSegment;
; 117  : 
; 118  : 			BootArgs = *bootArguments;

  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:BootArgs
  000e3	48 8b d7	 mov	 rdx, rdi
  000e6	4d 8b c5	 mov	 r8, r13
  000e9	66 89 35 00 00
	00 00		 mov	 WORD PTR BootLoaderSegment, si
  000f0	e8 00 00 00 00	 call	 memcpy

; 119  : 			BootArgsValid = TRUE;
; 120  : 			memset (bootArguments, 0, sizeof (*bootArguments));

  000f5	4d 8b c5	 mov	 r8, r13
  000f8	33 d2		 xor	 edx, edx
  000fa	48 8b cf	 mov	 rcx, rdi
  000fd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR BootArgsValid, 1
  00107	e8 00 00 00 00	 call	 memset

; 121  : 
; 122  : 			if (BootArgs.BootLoaderVersion < 0x600)

  0010c	0f b7 0d 08 00
	00 00		 movzx	 ecx, WORD PTR BootArgs+8
  00113	41 bb 00 06 00
	00		 mov	 r11d, 1536		; 00000600H
  00119	66 41 3b cb	 cmp	 cx, r11w
  0011d	73 0e		 jae	 SHORT $LN3@LoadBootAr

; 123  : 			{
; 124  : 				BootArgs.HiddenSystemPartitionStart = 0;

  0011f	48 89 2d 5a 00
	00 00		 mov	 QWORD PTR BootArgs+90, rbp

; 125  : 				BootArgs.DecoySystemPartitionStart = 0;

  00126	48 89 2d 62 00
	00 00		 mov	 QWORD PTR BootArgs+98, rbp
$LN3@LoadBootAr:

; 126  : 			}
; 127  : 
; 128  : 			if (BootArgs.BootLoaderVersion < 0x630)

  0012d	8b 05 6a 00 00
	00		 mov	 eax, DWORD PTR BootArgs+106
  00133	ba 30 06 00 00	 mov	 edx, 1584		; 00000630H
  00138	66 3b ca	 cmp	 cx, dx

; 129  : 				BootArgs.Flags = 0;
; 130  : 
; 131  : 			BootDriveSignatureValid = (BootArgs.BootLoaderVersion >= 0x710);

  0013b	ba 10 07 00 00	 mov	 edx, 1808		; 00000710H
  00140	0f 42 c5	 cmovb	 eax, ebp
  00143	66 3b ca	 cmp	 cx, dx
  00146	89 05 6a 00 00
	00		 mov	 DWORD PTR BootArgs+106, eax
  0014c	8b c5		 mov	 eax, ebp
  0014e	0f 93 c0	 setae	 al
  00151	89 05 00 00 00
	00		 mov	 DWORD PTR BootDriveSignatureValid, eax

; 132  : 
; 133  : 			Dump ("BootLoaderVersion = %x\n", (int) BootArgs.BootLoaderVersion);
; 134  : 			Dump ("HeaderSaltCrc32 = %x\n", (int) BootArgs.HeaderSaltCrc32);
; 135  : 			Dump ("CryptoInfoOffset = %x\n", (int) BootArgs.CryptoInfoOffset);
; 136  : 			Dump ("CryptoInfoLength = %d\n", (int) BootArgs.CryptoInfoLength);
; 137  : 			Dump ("HiddenSystemPartitionStart = %I64u\n", BootArgs.HiddenSystemPartitionStart);
; 138  : 			Dump ("DecoySystemPartitionStart = %I64u\n", BootArgs.DecoySystemPartitionStart);
; 139  : 			Dump ("Flags = %x\n", BootArgs.Flags);
; 140  : 			Dump ("BootDriveSignature = %x\n", BootArgs.BootDriveSignature);
; 141  : 			Dump ("BootArgumentsCrc32 = %x\n", BootArgs.BootArgumentsCrc32);
; 142  : 
; 143  : 			if (CacheBootPassword && BootArgs.BootPassword.Length > 0)

  00157	39 2d 00 00 00
	00		 cmp	 DWORD PTR CacheBootPassword, ebp
  0015d	74 74		 je	 SHORT $LN16@LoadBootAr
  0015f	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR BootArgs+16
  00166	48 c1 e8 10	 shr	 rax, 16
  0016a	3b c5		 cmp	 eax, ebp
  0016c	76 65		 jbe	 SHORT $LN16@LoadBootAr

; 144  : 				AddPasswordToCache (&BootArgs.BootPassword);

  0016e	8b dd		 mov	 ebx, ebp
$LL15@LoadBootAr:
  00170	48 63 c3	 movsxd	 rax, ebx
  00173	48 8d 15 12 00
	00 00		 lea	 rdx, OFFSET FLAT:BootArgs+18
  0017a	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00180	48 8d 0c c0	 lea	 rcx, QWORD PTR [rax+rax*8]
  00184	49 8d 0c cf	 lea	 rcx, QWORD PTR [r15+rcx*8]
  00188	e8 00 00 00 00	 call	 memcmp
  0018d	3b c5		 cmp	 eax, ebp
  0018f	74 42		 je	 SHORT $LN16@LoadBootAr
  00191	ff c3		 inc	 ebx
  00193	83 fb 04	 cmp	 ebx, 4
  00196	7c d8		 jl	 SHORT $LL15@LoadBootAr
  00198	48 63 1d 00 00
	00 00		 movsxd	 rbx, DWORD PTR nPasswordIdx
  0019f	48 8d 15 12 00
	00 00		 lea	 rdx, OFFSET FLAT:BootArgs+18
  001a6	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  001ac	48 8d 0c db	 lea	 rcx, QWORD PTR [rbx+rbx*8]
  001b0	49 8d 0c cf	 lea	 rcx, QWORD PTR [r15+rcx*8]
  001b4	e8 00 00 00 00	 call	 memcpy
  001b9	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  001bc	89 2d 00 00 00
	00		 mov	 DWORD PTR cacheEmpty, ebp
  001c2	99		 cdq
  001c3	83 e2 03	 and	 edx, 3
  001c6	03 c2		 add	 eax, edx
  001c8	83 e0 03	 and	 eax, 3
  001cb	2b c2		 sub	 eax, edx
  001cd	89 05 00 00 00
	00		 mov	 DWORD PTR nPasswordIdx, eax
$LN16@LoadBootAr:

; 145  : 
; 146  : 			status = STATUS_SUCCESS;

  001d3	8b dd		 mov	 ebx, ebp
$LN5@LoadBootAr:

; 147  : 		}
; 148  : 
; 149  : 		MmUnmapIoSpace (mappedBootArgs, sizeof (BootArguments));

  001d5	49 8b d5	 mov	 rdx, r13
  001d8	48 8b cf	 mov	 rcx, rdi
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmUnmapIoSpace
  001e1	41 bb 00 f8 00
	00		 mov	 r11d, 63488		; 0000f800H
  001e7	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  001ec	66 41 03 f3	 add	 si, r11w
  001f0	66 3b f0	 cmp	 si, ax
  001f3	0f 83 45 fe ff
	ff		 jae	 $LL9@LoadBootAr
$LN7@LoadBootAr:

; 150  : 	}
; 151  : 
; 152  : 	return status;

  001f9	8b c3		 mov	 eax, ebx
$LN10@LoadBootAr:

; 153  : }

  001fb	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00200	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00205	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0020a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0020e	41 5f		 pop	 r15
  00210	41 5d		 pop	 r13
  00212	5f		 pop	 rdi
  00213	c3		 ret	 0
$LN22@LoadBootAr:

; 111  : 			{
; 112  : 				Dump ("BootArguments CRC incorrect\n");
; 113  : 				GST_BUG_CHECK (STATUS_CRC_ERROR);

  00214	45 33 c9	 xor	 r9d, r9d
  00217	49 c7 c0 3f 00
	00 c0		 mov	 r8, -1073741761		; ffffffffc000003fH
  0021e	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00227	41 8d 51 71	 lea	 edx, QWORD PTR [r9+113]
  0022b	8d 4a b8	 lea	 ecx, QWORD PTR [rdx-72]
  0022e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00234	cc		 int	 3
$LN21@LoadBootAr:

; 100  : 			return STATUS_INSUFFICIENT_RESOURCES;

  00235	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  0023a	eb bf		 jmp	 SHORT $LN10@LoadBootAr
$LN26@LoadBootAr:
LoadBootArguments ENDP
; Function compile flags: /Ogspy
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT IoSkipCurrentIrpStackLocation
_TEXT	SEGMENT
Irp$ = 8
IoSkipCurrentIrpStackLocation PROC			; COMDAT

; 23946:     ASSERT(Irp->CurrentLocation <= Irp->StackCount);
; 23947:     Irp->CurrentLocation++;

  00000	fe 41 43	 inc	 BYTE PTR [rcx+67]

; 23948:     Irp->Tail.Overlay.CurrentStackLocation++;

  00003	48 83 81 b8 00
	00 00 48	 add	 QWORD PTR [rcx+184], 72	; 00000048H

; 23949: }

  0000b	c3		 ret	 0
IoSkipCurrentIrpStackLocation ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT IoGetNextIrpStackLocation
_TEXT	SEGMENT
Irp$ = 8
IoGetNextIrpStackLocation PROC				; COMDAT

; 23480:     ASSERT(Irp->CurrentLocation > 0);
; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00000	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00007	48 83 e8 48	 sub	 rax, 72			; 00000048H

; 23483: }

  0000b	c3		 ret	 0
IoGetNextIrpStackLocation ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT IoGetCurrentIrpStackLocation
_TEXT	SEGMENT
Irp$ = 8
IoGetCurrentIrpStackLocation PROC			; COMDAT

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00000	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]

; 23319: }

  00007	c3		 ret	 0
IoGetCurrentIrpStackLocation ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT KeInitializeSpinLock
_TEXT	SEGMENT
SpinLock$ = 8
KeInitializeSpinLock PROC				; COMDAT

; 15096: 
; 15097:     *SpinLock = 0;

  00000	48 83 21 00	 and	 QWORD PTR [rcx], 0

; 15098:     return;
; 15099: }

  00004	c3		 ret	 0
KeInitializeSpinLock ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT KeLowerIrql
_TEXT	SEGMENT
NewIrql$ = 8
KeLowerIrql PROC					; COMDAT

; 13393: 
; 13394:     NT_ASSERT(KeGetCurrentIrql() >= NewIrql);
; 13395: 
; 13396:     WriteCR8(NewIrql);

  00000	0f b6 c1	 movzx	 eax, cl
  00003	44 0f 22 c0	 mov	 cr8, rax

; 13397:     return;
; 13398: }

  00007	c3		 ret	 0
KeLowerIrql ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT KeGetCurrentIrql
_TEXT	SEGMENT
KeGetCurrentIrql PROC					; COMDAT

; 13365: 
; 13366:     return (KIRQL)ReadCR8();

  00000	44 0f 20 c0	 mov	 rax, cr8

; 13367: }

  00004	c3		 ret	 0
KeGetCurrentIrql ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlSecureZeroMemory DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$RtlSecureZeroMemory
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlSecureZeroMemory DD 020501H
	DD	017405H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RtlSecureZeroMemory
_TEXT	SEGMENT
ptr$ = 8
cnt$ = 16
RtlSecureZeroMemory PROC				; COMDAT

; 8322 : {

$LN3:
  00000	48 89 7c 24 08	 mov	 QWORD PTR [rsp+8], rdi
  00005	4c 8b c1	 mov	 r8, rcx

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);

  00008	48 8b f9	 mov	 rdi, rcx
  0000b	33 c0		 xor	 eax, eax
  0000d	48 8b ca	 mov	 rcx, rdx
  00010	f3 aa		 rep stosb

; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {
; 8332 :         *vptr = 0;
; 8333 :         vptr++;
; 8334 :         cnt--;
; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;
; 8340 : }

  00012	48 8b 7c 24 08	 mov	 rdi, QWORD PTR [rsp+8]
  00017	49 8b c0	 mov	 rax, r8
  0001a	c3		 ret	 0
RtlSecureZeroMemory ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT KeGetCurrentThread
_TEXT	SEGMENT
KeGetCurrentThread PROC					; COMDAT

; 116  :     return (struct _KTHREAD *)__readgsqword(0x188);

  00000	65 48 8b 04 25
	88 01 00 00	 mov	 rax, QWORD PTR gs:392

; 117  : }

  00009	c3		 ret	 0
KeGetCurrentThread ENDP
PUBLIC	WriteBootDriveSector
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
pdata	SEGMENT
$pdata$WriteBootDriveSector DD imagerel $LN8
	DD	imagerel $LN8+104
	DD	imagerel $unwind$WriteBootDriveSector
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WriteBootDriveSector DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT WriteBootDriveSector
_TEXT	SEGMENT
irp$ = 64
irpSp$ = 72
WriteBootDriveSector PROC				; COMDAT

; 2389 : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 2390 : 	WriteBootDriveSectorRequest *request;
; 2391 : 
; 2392 : 	if (!UserCanAccessDriveDevice())

  00010	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00015	85 c0		 test	 eax, eax
  00017	75 07		 jne	 SHORT $LN3@WriteBootD

; 2393 : 		return STATUS_ACCESS_DENIED;

  00019	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  0001e	eb 3d		 jmp	 SHORT $LN4@WriteBootD
$LN3@WriteBootD:

; 2394 : 
; 2395 : 	if (!BootDriveFilterExtension
; 2396 : 		|| irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (WriteBootDriveSectorRequest))

  00020	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR BootDriveFilterExtension
  00027	48 85 d2	 test	 rdx, rdx
  0002a	74 2c		 je	 SHORT $LN1@WriteBootD
  0002c	81 7b 10 08 02
	00 00		 cmp	 DWORD PTR [rbx+16], 520	; 00000208H
  00033	72 23		 jb	 SHORT $LN1@WriteBootD

; 2398 : 
; 2399 : 	request = (WriteBootDriveSectorRequest *) irp->AssociatedIrp.SystemBuffer;

  00035	4c 8b 4f 18	 mov	 r9, QWORD PTR [rdi+24]

; 2400 : 	return GSTWriteDevice (BootDriveFilterExtension->LowerDeviceObject, request->Data, request->Offset, sizeof (request->Data));

  00039	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  0003d	b9 01 00 00 00	 mov	 ecx, 1
  00042	4d 8d 41 08	 lea	 r8, QWORD PTR [r9+8]
  00046	4d 8b 09	 mov	 r9, QWORD PTR [r9]
  00049	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  00051	e8 00 00 00 00	 call	 GSTReadWriteDevice
  00056	eb 05		 jmp	 SHORT $LN4@WriteBootD
$LN1@WriteBootD:

; 2397 : 		return STATUS_INVALID_PARAMETER;

  00058	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
$LN4@WriteBootD:

; 2401 : }

  0005d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00062	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
WriteBootDriveSector ENDP
_TEXT	ENDS
PUBLIC	GetDecoySystemWipeStatus
DecoySystemWipedAreaEnd DQ 01H DUP (?)
DecoySystemWipeStatusSpinLock DQ 01H DUP (?)
WipeDecoyRequest DB 0104H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetDecoySystemWipeStatus DD imagerel $LN12
	DD	imagerel $LN12+176
	DD	imagerel $unwind$GetDecoySystemWipeStatus
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetDecoySystemWipeStatus DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetDecoySystemWipeStatus
_TEXT	SEGMENT
irp$ = 48
irpSp$ = 56
GetDecoySystemWipeStatus PROC				; COMDAT

; 2297 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2298 : 	if (ValidateIOBufferSize (irp, sizeof (DecoySystemWipeStatus), ValidateOutput))

  0000a	ba 10 00 00 00	 mov	 edx, 16
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	44 8d 42 f1	 lea	 r8d, QWORD PTR [rdx-15]
  00016	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 82 00 00
	00		 je	 $LN3@GetDecoySy

; 2299 : 	{
; 2300 : 		DecoySystemWipeStatus *wipeStatus = (DecoySystemWipeStatus *) irp->AssociatedIrp.SystemBuffer;
; 2301 : 
; 2302 : 		if (!IsHiddenSystemRunning())

  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0002a	48 8b 7b 18	 mov	 rdi, QWORD PTR [rbx+24]
  0002e	48 85 c0	 test	 rax, rax
  00031	74 66		 je	 SHORT $LN10@GetDecoySy
  00033	83 b8 e0 02 00
	00 00		 cmp	 DWORD PTR [rax+736], 0
  0003a	74 5d		 je	 SHORT $LN10@GetDecoySy

; 2306 : 		}
; 2307 : 		else
; 2308 : 		{
; 2309 : 			wipeStatus->WipeInProgress = DecoySystemWipeInProgress;

  0003c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeInProgress
  00042	89 07		 mov	 DWORD PTR [rdi], eax

; 2310 : 			wipeStatus->WipeAlgorithm = WipeDecoyRequest.WipeAlgorithm;

  00044	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR WipeDecoyRequest
  0004a	89 47 04	 mov	 DWORD PTR [rdi+4], eax

; 2311 : 
; 2312 : 			if (DecoySystemWipeInProgress)

  0004d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeInProgress
  00053	85 c0		 test	 eax, eax
  00055	74 29		 je	 SHORT $LN2@GetDecoySy

; 2313 : 			{
; 2314 : 				KIRQL irql;
; 2315 : 				KeAcquireSpinLock (&DecoySystemWipeStatusSpinLock, &irql);

  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeStatusSpinLock
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc

; 2316 : 				wipeStatus->WipedAreaEnd = DecoySystemWipedAreaEnd;

  00064	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR DecoySystemWipedAreaEnd

; 2317 : 				KeReleaseSpinLock (&DecoySystemWipeStatusSpinLock, irql);

  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeStatusSpinLock
  00072	48 89 57 08	 mov	 QWORD PTR [rdi+8], rdx
  00076	8a d0		 mov	 dl, al
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 2318 : 			}
; 2319 : 			else

  0007e	eb 0b		 jmp	 SHORT $LN1@GetDecoySy
$LN2@GetDecoySy:

; 2320 : 				wipeStatus->WipedAreaEnd = DecoySystemWipedAreaEnd;

  00080	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DecoySystemWipedAreaEnd
  00087	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
$LN1@GetDecoySy:

; 2321 : 			
; 2322 : 			irp->IoStatus.Information = sizeof (DecoySystemWipeStatus);
; 2323 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  0008b	83 63 30 00	 and	 DWORD PTR [rbx+48], 0
  0008f	48 c7 43 38 10
	00 00 00	 mov	 QWORD PTR [rbx+56], 16
  00097	eb 0c		 jmp	 SHORT $LN3@GetDecoySy

; 2299 : 	{
; 2300 : 		DecoySystemWipeStatus *wipeStatus = (DecoySystemWipeStatus *) irp->AssociatedIrp.SystemBuffer;
; 2301 : 
; 2302 : 		if (!IsHiddenSystemRunning())

$LN10@GetDecoySy:

; 2303 : 		{
; 2304 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 2305 : 			irp->IoStatus.Information = 0;

  00099	48 83 63 38 00	 and	 QWORD PTR [rbx+56], 0
  0009e	c7 43 30 0d 00
	00 c0		 mov	 DWORD PTR [rbx+48], -1073741811 ; ffffffffc000000dH
$LN3@GetDecoySy:

; 2324 : 		}
; 2325 : 	}
; 2326 : }

  000a5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
GetDecoySystemWipeStatus ENDP
_TEXT	ENDS
PUBLIC	GetBootLoaderVersion
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetBootLoaderVersion DD imagerel $LN6
	DD	imagerel $LN6+81
	DD	imagerel $unwind$GetBootLoaderVersion
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetBootLoaderVersion DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetBootLoaderVersion
_TEXT	SEGMENT
irp$ = 48
irpSp$ = 56
GetBootLoaderVersion PROC				; COMDAT

; 1937 : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1938 : 	if (ValidateIOBufferSize (irp, sizeof (uint16), ValidateOutput))

  00006	ba 02 00 00 00	 mov	 edx, 2
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	44 8d 42 ff	 lea	 r8d, QWORD PTR [rdx-1]
  00012	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00017	33 d2		 xor	 edx, edx
  00019	3b c2		 cmp	 eax, edx
  0001b	74 2e		 je	 SHORT $LN1@GetBootLoa

; 1939 : 	{
; 1940 : 		if (BootArgsValid)

  0001d	39 15 00 00 00
	00		 cmp	 DWORD PTR BootArgsValid, edx
  00023	74 1b		 je	 SHORT $LN2@GetBootLoa

; 1941 : 		{
; 1942 : 			*(uint16 *) irp->AssociatedIrp.SystemBuffer = BootArgs.BootLoaderVersion;

  00025	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR BootArgs+8
  0002c	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00030	66 89 01	 mov	 WORD PTR [rcx], ax

; 1943 : 			irp->IoStatus.Information = sizeof (uint16);

  00033	48 c7 43 38 02
	00 00 00	 mov	 QWORD PTR [rbx+56], 2

; 1944 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  0003b	89 53 30	 mov	 DWORD PTR [rbx+48], edx

; 1945 : 		}
; 1946 : 		else

  0003e	eb 0b		 jmp	 SHORT $LN1@GetBootLoa
$LN2@GetBootLoa:

; 1947 : 		{
; 1948 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00040	c7 43 30 0d 00
	00 c0		 mov	 DWORD PTR [rbx+48], -1073741811 ; ffffffffc000000dH

; 1949 : 			irp->IoStatus.Information = 0;

  00047	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN1@GetBootLoa:

; 1950 : 		}
; 1951 : 	}
; 1952 : }

  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
GetBootLoaderVersion ENDP
_TEXT	ENDS
PUBLIC	GetBootEncryptionStatus
	ALIGN	8

SetupStatusEncryptedAreaEnd DQ 01H DUP (?)
SetupStatusSpinLock DQ 01H DUP (?)
TransformWaitingForIdle DD 01H DUP (?)
SetupRequest DB	010H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetBootEncryptionStatus DD imagerel $LN11
	DD	imagerel $LN11+391
	DD	imagerel $unwind$GetBootEncryptionStatus
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetBootEncryptionStatus DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0c0113215H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetBootEncryptionStatus
_TEXT	SEGMENT
irp$ = 48
irpSp$ = 56
GetBootEncryptionStatus PROC				; COMDAT

; 1867 : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1868 : 	/* IMPORTANT: Do NOT add any potentially time-consuming operations to this function. */
; 1869 : 
; 1870 : 	if (ValidateIOBufferSize (irp, sizeof (BootEncryptionStatus), ValidateOutput))

  00015	41 b8 01 00 00
	00		 mov	 r8d, 1
  0001b	48 8b f1	 mov	 rsi, rcx
  0001e	45 8d 60 5d	 lea	 r12d, QWORD PTR [r8+93]
  00022	49 8b d4	 mov	 rdx, r12
  00025	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 3f 01 00
	00		 je	 $LN8@GetBootEnc

; 1871 : 	{
; 1872 : 		DriveFilterExtension *Extension = BootDriveFilterExtension;
; 1873 : 		BootEncryptionStatus *bootEncStatus = (BootEncryptionStatus *) irp->AssociatedIrp.SystemBuffer;

  00032	48 8b 5e 18	 mov	 rbx, QWORD PTR [rsi+24]
  00036	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR BootDriveFilterExtension

; 1874 : 		memset (bootEncStatus, 0, sizeof (*bootEncStatus));

  0003d	4d 8b c4	 mov	 r8, r12
  00040	48 8b cb	 mov	 rcx, rbx
  00043	33 d2		 xor	 edx, edx
  00045	e8 00 00 00 00	 call	 memset

; 1875 : 
; 1876 : 		if (BootArgsValid)

  0004a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR BootArgsValid, 0
  00051	74 0b		 je	 SHORT $LN7@GetBootEnc

; 1877 : 			bootEncStatus->BootLoaderVersion = BootArgs.BootLoaderVersion;

  00053	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR BootArgs+8
  0005a	66 89 43 04	 mov	 WORD PTR [rbx+4], ax
$LN7@GetBootEnc:

; 1878 : 
; 1879 : 		bootEncStatus->DeviceFilterActive = DeviceFilterActive;

  0005e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DeviceFilterActive
  00064	89 03		 mov	 DWORD PTR [rbx], eax

; 1880 : 		bootEncStatus->SetupInProgress = SetupInProgress;

  00066	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupInProgress
  0006c	89 43 3e	 mov	 DWORD PTR [rbx+62], eax

; 1881 : 		bootEncStatus->SetupMode = SetupRequest.SetupMode;

  0006f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupRequest
  00075	89 43 42	 mov	 DWORD PTR [rbx+66], eax

; 1882 : 		bootEncStatus->TransformWaitingForIdle = TransformWaitingForIdle;

  00078	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR TransformWaitingForIdle
  0007e	89 43 46	 mov	 DWORD PTR [rbx+70], eax

; 1883 : 
; 1884 : 		if (!BootDriveFound || !Extension || !Extension->DriveMounted)

  00081	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR BootDriveFound
  00087	85 c0		 test	 eax, eax
  00089	0f 84 ce 00 00
	00		 je	 $LN5@GetBootEnc
  0008f	48 85 ff	 test	 rdi, rdi
  00092	0f 84 c5 00 00
	00		 je	 $LN5@GetBootEnc
  00098	8b 87 b8 02 00
	00		 mov	 eax, DWORD PTR [rdi+696]
  0009e	85 c0		 test	 eax, eax
  000a0	0f 84 b7 00 00
	00		 je	 $LN5@GetBootEnc

; 1889 : 		}
; 1890 : 		else
; 1891 : 		{
; 1892 : 			bootEncStatus->DriveMounted = Extension->DriveMounted;

  000a6	89 43 06	 mov	 DWORD PTR [rbx+6], eax

; 1893 : 			bootEncStatus->VolumeHeaderPresent = Extension->VolumeHeaderPresent;

  000a9	8b 87 b4 02 00
	00		 mov	 eax, DWORD PTR [rdi+692]
  000af	89 43 0a	 mov	 DWORD PTR [rbx+10], eax

; 1894 : 			bootEncStatus->DriveEncrypted = Extension->Queue.EncryptedAreaStart != -1;

  000b2	33 c0		 xor	 eax, eax
  000b4	48 83 bf c8 00
	00 00 ff	 cmp	 QWORD PTR [rdi+200], -1
  000bc	0f 95 c0	 setne	 al
  000bf	89 43 0e	 mov	 DWORD PTR [rbx+14], eax

; 1895 : 			bootEncStatus->BootDriveLength = BootDriveLength;

  000c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveLength
  000c9	48 89 43 12	 mov	 QWORD PTR [rbx+18], rax

; 1896 : 
; 1897 : 			bootEncStatus->ConfiguredEncryptedAreaStart = Extension->ConfiguredEncryptedAreaStart;

  000cd	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  000d1	48 89 43 1a	 mov	 QWORD PTR [rbx+26], rax

; 1898 : 			bootEncStatus->ConfiguredEncryptedAreaEnd = Extension->ConfiguredEncryptedAreaEnd;

  000d5	48 8b 47 40	 mov	 rax, QWORD PTR [rdi+64]
  000d9	48 89 43 22	 mov	 QWORD PTR [rbx+34], rax

; 1899 : 			bootEncStatus->EncryptedAreaStart = Extension->Queue.EncryptedAreaStart;

  000dd	48 8b 87 c8 00
	00 00		 mov	 rax, QWORD PTR [rdi+200]
  000e4	48 89 43 2a	 mov	 QWORD PTR [rbx+42], rax

; 1900 : 
; 1901 : 			if (SetupInProgress)

  000e8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupInProgress
  000ee	85 c0		 test	 eax, eax
  000f0	74 29		 je	 SHORT $LN3@GetBootEnc

; 1902 : 			{
; 1903 : 				KIRQL irql;
; 1904 : 				KeAcquireSpinLock (&SetupStatusSpinLock, &irql);

  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupStatusSpinLock
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc

; 1905 : 				bootEncStatus->EncryptedAreaEnd = SetupStatusEncryptedAreaEnd;

  000ff	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR SetupStatusEncryptedAreaEnd

; 1906 : 				KeReleaseSpinLock (&SetupStatusSpinLock, irql);

  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupStatusSpinLock
  0010d	48 89 53 32	 mov	 QWORD PTR [rbx+50], rdx
  00111	8a d0		 mov	 dl, al
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 1907 : 			}
; 1908 : 			else

  00119	eb 0b		 jmp	 SHORT $LN2@GetBootEnc
$LN3@GetBootEnc:

; 1909 : 				bootEncStatus->EncryptedAreaEnd = Extension->Queue.EncryptedAreaEnd;

  0011b	48 8b 87 d0 00
	00 00		 mov	 rax, QWORD PTR [rdi+208]
  00122	48 89 43 32	 mov	 QWORD PTR [rbx+50], rax
$LN2@GetBootEnc:

; 1910 : 
; 1911 : 			bootEncStatus->VolumeHeaderSaltCrc32 = Extension->VolumeHeaderSaltCrc32;

  00126	8b 47 48	 mov	 eax, DWORD PTR [rdi+72]
  00129	89 43 3a	 mov	 DWORD PTR [rbx+58], eax

; 1912 : 			bootEncStatus->HibernationPreventionCount = HibernationPreventionCount;

  0012c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR HibernationPreventionCount
  00132	89 43 4a	 mov	 DWORD PTR [rbx+74], eax

; 1913 : 			bootEncStatus->HiddenSysLeakProtectionCount = HiddenSysLeakProtectionCount;

  00135	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR HiddenSysLeakProtectionCount
  0013b	89 43 5a	 mov	 DWORD PTR [rbx+90], eax

; 1914 : 
; 1915 : 			bootEncStatus->HiddenSystem = Extension->HiddenSystem;

  0013e	8b 87 e0 02 00
	00		 mov	 eax, DWORD PTR [rdi+736]
  00144	89 43 4e	 mov	 DWORD PTR [rbx+78], eax

; 1916 : 			
; 1917 : 			if (Extension->HiddenSystem)

  00147	83 bf e0 02 00
	00 00		 cmp	 DWORD PTR [rdi+736], 0
  0014e	74 19		 je	 SHORT $LN1@GetBootEnc

; 1918 : 				bootEncStatus->HiddenSystemPartitionStart = BootArgs.HiddenSystemPartitionStart;

  00150	48 8b 05 5a 00
	00 00		 mov	 rax, QWORD PTR BootArgs+90
  00157	48 89 43 52	 mov	 QWORD PTR [rbx+82], rax
  0015b	eb 0c		 jmp	 SHORT $LN1@GetBootEnc
$LN5@GetBootEnc:

; 1885 : 		{
; 1886 : 			bootEncStatus->DriveEncrypted = FALSE;

  0015d	83 63 0e 00	 and	 DWORD PTR [rbx+14], 0

; 1887 : 			bootEncStatus->DriveMounted = FALSE;

  00161	83 63 06 00	 and	 DWORD PTR [rbx+6], 0

; 1888 : 			bootEncStatus->VolumeHeaderPresent = FALSE;

  00165	83 63 0a 00	 and	 DWORD PTR [rbx+10], 0
$LN1@GetBootEnc:

; 1919 : 		}
; 1920 : 
; 1921 : 		irp->IoStatus.Information = sizeof (BootEncryptionStatus);
; 1922 : 		irp->IoStatus.Status = STATUS_SUCCESS;

  00169	83 66 30 00	 and	 DWORD PTR [rsi+48], 0
  0016d	4c 89 66 38	 mov	 QWORD PTR [rsi+56], r12
$LN8@GetBootEnc:

; 1923 : 	}
; 1924 : }

  00171	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00176	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0017b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00180	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00184	41 5c		 pop	 r12
  00186	c3		 ret	 0
GetBootEncryptionStatus ENDP
_TEXT	ENDS
PUBLIC	GetBootDriveVolumeProperties
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetBootDriveVolumeProperties DD imagerel $LN7
	DD	imagerel $LN7+321
	DD	imagerel $unwind$GetBootDriveVolumeProperties
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetBootDriveVolumeProperties DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0c0113215H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetBootDriveVolumeProperties
_TEXT	SEGMENT
irp$ = 48
irpSp$ = 56
GetBootDriveVolumeProperties PROC			; COMDAT

; 1821 : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1822 : 	if (ValidateIOBufferSize (irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateOutput))

  00015	41 bc 54 02 00
	00		 mov	 r12d, 596		; 00000254H
  0001b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00021	48 8b d9	 mov	 rbx, rcx
  00024	49 8b d4	 mov	 rdx, r12
  00027	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 f7 00 00
	00		 je	 $LN1@GetBootDri

; 1823 : 	{
; 1824 : 		DriveFilterExtension *Extension = BootDriveFilterExtension;
; 1825 : 		VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) irp->AssociatedIrp.SystemBuffer;

  00034	48 8b 73 18	 mov	 rsi, QWORD PTR [rbx+24]
  00038	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR BootDriveFilterExtension

; 1826 : 		memset (prop, 0, sizeof (*prop));

  0003f	4d 8b c4	 mov	 r8, r12
  00042	48 8b ce	 mov	 rcx, rsi
  00045	33 d2		 xor	 edx, edx
  00047	e8 00 00 00 00	 call	 memset

; 1827 : 
; 1828 : 		if (!BootDriveFound || !Extension || !Extension->DriveMounted)

  0004c	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR BootDriveFound
  00053	45 85 db	 test	 r11d, r11d
  00056	0f 84 c3 00 00
	00		 je	 $LN2@GetBootDri
  0005c	48 85 ff	 test	 rdi, rdi
  0005f	0f 84 ba 00 00
	00		 je	 $LN2@GetBootDri
  00065	83 bf b8 02 00
	00 00		 cmp	 DWORD PTR [rdi+696], 0
  0006c	0f 84 ad 00 00
	00		 je	 $LN2@GetBootDri

; 1832 : 		}
; 1833 : 		else
; 1834 : 		{
; 1835 : 			prop->hiddenVolume = Extension->Queue.CryptoInfo->hiddenVolume;

  00072	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  00079	8b 88 48 04 00
	00		 mov	 ecx, DWORD PTR [rax+1096]
  0007f	89 8e 28 02 00
	00		 mov	 DWORD PTR [rsi+552], ecx

; 1836 : 			prop->diskLength = Extension->ConfiguredEncryptedAreaEnd + 1 - Extension->ConfiguredEncryptedAreaStart;

  00085	48 8b 47 40	 mov	 rax, QWORD PTR [rdi+64]
  00089	48 2b 47 38	 sub	 rax, QWORD PTR [rdi+56]
  0008d	48 ff c0	 inc	 rax
  00090	48 89 86 10 02
	00 00		 mov	 QWORD PTR [rsi+528], rax

; 1837 : 			prop->ea = Extension->Queue.CryptoInfo->ea;

  00097	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  0009e	8b 08		 mov	 ecx, DWORD PTR [rax]
  000a0	89 8e 18 02 00
	00		 mov	 DWORD PTR [rsi+536], ecx

; 1838 : 			prop->mode = Extension->Queue.CryptoInfo->mode;

  000a6	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  000ad	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  000b0	89 8e 1c 02 00
	00		 mov	 DWORD PTR [rsi+540], ecx

; 1839 : 			prop->pkcs5 = Extension->Queue.CryptoInfo->pkcs5;

  000b6	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  000bd	8b 88 94 1e 00
	00		 mov	 ecx, DWORD PTR [rax+7828]
  000c3	89 8e 20 02 00
	00		 mov	 DWORD PTR [rsi+544], ecx

; 1840 : 			prop->pkcs5Iterations = Extension->Queue.CryptoInfo->noIterations;

  000c9	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  000d0	8b 88 90 1e 00
	00		 mov	 ecx, DWORD PTR [rax+7824]
  000d6	89 8e 24 02 00
	00		 mov	 DWORD PTR [rsi+548], ecx

; 1841 : #if 0
; 1842 : 			prop->volumeCreationTime = Extension->Queue.CryptoInfo->volume_creation_time;
; 1843 : 			prop->headerCreationTime = Extension->Queue.CryptoInfo->header_creation_time;
; 1844 : #endif
; 1845 : 			prop->volFormatVersion = Extension->Queue.CryptoInfo->LegacyVolume ? GST_VOLUME_FORMAT_VERSION_PRE_6_0 : GST_VOLUME_FORMAT_VERSION;

  000dc	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  000e3	8b 88 e4 1e 00
	00		 mov	 ecx, DWORD PTR [rax+7908]
  000e9	f7 d9		 neg	 ecx
  000eb	1b c0		 sbb	 eax, eax
  000ed	83 e0 f4	 and	 eax, -12
  000f0	83 c0 0d	 add	 eax, 13
  000f3	89 86 50 02 00
	00		 mov	 DWORD PTR [rsi+592], eax

; 1846 : 
; 1847 : 			prop->totalBytesRead = Extension->Queue.TotalBytesRead;

  000f9	48 8b 87 70 02
	00 00		 mov	 rax, QWORD PTR [rdi+624]
  00100	48 89 86 3c 02
	00 00		 mov	 QWORD PTR [rsi+572], rax

; 1848 : 			prop->totalBytesWritten = Extension->Queue.TotalBytesWritten;

  00107	48 8b 87 78 02
	00 00		 mov	 rax, QWORD PTR [rdi+632]
  0010e	48 89 86 44 02
	00 00		 mov	 QWORD PTR [rsi+580], rax

; 1849 : 
; 1850 : 			irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);
; 1851 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  00115	83 63 30 00	 and	 DWORD PTR [rbx+48], 0
  00119	4c 89 63 38	 mov	 QWORD PTR [rbx+56], r12
  0011d	eb 0c		 jmp	 SHORT $LN1@GetBootDri
$LN2@GetBootDri:

; 1829 : 		{
; 1830 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 1831 : 			irp->IoStatus.Information = 0;

  0011f	48 83 63 38 00	 and	 QWORD PTR [rbx+56], 0
  00124	c7 43 30 0d 00
	00 c0		 mov	 DWORD PTR [rbx+48], -1073741811 ; ffffffffc000000dH
$LN1@GetBootDri:

; 1852 : 		}
; 1853 : 	}
; 1854 : }

  0012b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00130	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00135	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0013a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013e	41 5c		 pop	 r12
  00140	c3		 ret	 0
GetBootDriveVolumeProperties ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$DispatchPower DD imagerel DispatchPower
	DD	imagerel DispatchPower+235
	DD	imagerel $unwind$DispatchPower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DispatchPower DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT DispatchPower
_TEXT	SEGMENT
DeviceObject$ = 64
Irp$ = 72
Extension$ = 80
irpSp$ = 88
DispatchPower PROC					; COMDAT

; 807  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 808  : 	NTSTATUS status;
; 809  : 	Dump ("IRP_MJ_POWER minor=%d type=%d shutdown=%d\n", (int) irpSp->MinorFunction, (int) irpSp->Parameters.Power.Type, (int) irpSp->Parameters.Power.ShutdownType);
; 810  : 
; 811  : 	if (SetupInProgress
; 812  : 		&& irpSp->MinorFunction == IRP_MN_SET_POWER
; 813  : 		&& irpSp->Parameters.Power.ShutdownType == PowerActionHibernate)

  00014	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupInProgress
  0001a	49 8b f0	 mov	 rsi, r8
  0001d	48 8b fa	 mov	 rdi, rdx
  00020	85 c0		 test	 eax, eax
  00022	74 37		 je	 SHORT $LN2@DispatchPo@2
  00024	41 80 79 01 02	 cmp	 BYTE PTR [r9+1], 2
  00029	75 30		 jne	 SHORT $LN2@DispatchPo@2
  0002b	41 83 79 20 03	 cmp	 DWORD PTR [r9+32], 3
  00030	75 29		 jne	 SHORT $LN2@DispatchPo@2
$LL3@DispatchPo@2:

; 814  : 	{
; 815  : 		while (SendDeviceIoControlRequest (RootDeviceObject, GST_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00039	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  0003e	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00044	45 33 c9	 xor	 r9d, r9d
  00047	45 33 c0	 xor	 r8d, r8d
  0004a	ba 50 20 22 00	 mov	 edx, 2236496		; 00222050H
  0004f	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00054	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  00059	74 d7		 je	 SHORT $LL3@DispatchPo@2
$LN2@DispatchPo@2:

; 816  : 	}
; 817  : 
; 818  : #if 0	// Dismount of the system drive is disabled until there is a way to do it without causing system errors (see the documentation for more info)
; 819  : 	if (DriverShuttingDown
; 820  : 		&& Extension->BootDrive
; 821  : 		&& Extension->DriveMounted
; 822  : 		&& irpSp->MinorFunction == IRP_MN_SET_POWER
; 823  : 		&& irpSp->Parameters.Power.Type == DevicePowerState)
; 824  : 	{
; 825  : 		DismountDrive (Extension, TRUE);
; 826  : 	}
; 827  : #endif // 0
; 828  : 
; 829  : 	PoStartNextPowerIrp (Irp);

  0005b	48 8b cf	 mov	 rcx, rdi
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PoStartNextPowerIrp

; 830  : 
; 831  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00064	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  0006b	48 8d 8e f0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+240]
  00072	41 b9 01 00 00
	00		 mov	 r9d, 1
  00078	48 8b d7	 mov	 rdx, rdi
  0007b	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00089	8b d8		 mov	 ebx, eax

; 832  : 	if (!NT_SUCCESS (status))

  0008b	85 c0		 test	 eax, eax
  0008d	79 15		 jns	 SHORT $LN1@DispatchPo@2

; 833  : 		return GSTCompleteIrp (Irp, status, 0);

  0008f	48 83 67 38 00	 and	 QWORD PTR [rdi+56], 0
  00094	33 d2		 xor	 edx, edx
  00096	48 8b cf	 mov	 rcx, rdi
  00099	89 47 30	 mov	 DWORD PTR [rdi+48], eax
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  000a2	eb 30		 jmp	 SHORT $LN12@DispatchPo@2
$LN1@DispatchPo@2:

; 834  : 
; 835  : 	IoSkipCurrentIrpStackLocation (Irp);

  000a4	fe 47 43	 inc	 BYTE PTR [rdi+67]
  000a7	48 83 87 b8 00
	00 00 48	 add	 QWORD PTR [rdi+184], 72	; 00000048H

; 836  : 	status = PoCallDriver (Extension->LowerDeviceObject, Irp);

  000af	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  000b3	48 8b d7	 mov	 rdx, rdi
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PoCallDriver

; 837  : 
; 838  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000bc	48 8d 8e f0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+240]
  000c3	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000c9	48 8b d7	 mov	 rdx, rdi
  000cc	8b d8		 mov	 ebx, eax
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx
$LN12@DispatchPo@2:

; 839  : 	return status;
; 840  : }

  000d4	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000d9	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000de	8b c3		 mov	 eax, ebx
  000e0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e9	5f		 pop	 rdi
  000ea	c3		 ret	 0
DispatchPower ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsVolumeDevice DD imagerel IsVolumeDevice
	DD	imagerel IsVolumeDevice+313
	DD	imagerel $unwind$IsVolumeDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsVolumeDevice DD 072519H
	DD	0166413H
	DD	0153413H
	DD	0120113H
	DD	0700cH
	DD	imagerel __GSHandlerCheck
	DD	088H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IsVolumeDevice
_TEXT	SEGMENT
volNumber$ = 112
__$ArrayPad$ = 136
deviceObject$ = 160
IsVolumeDevice PROC					; COMDAT

; 597  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 598  : 	VOLUME_NUMBER volNumber;
; 599  : 	VOLUME_DISK_EXTENTS extents[2];
; 600  : 	NTSTATUS extentStatus = SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0, extents, sizeof (extents));

  00025	49 8d 43 98	 lea	 rax, QWORD PTR [r11-104]
  00029	45 33 c9	 xor	 r9d, r9d
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	ba 00 00 56 00	 mov	 edx, 5636096		; 00560000H
  00034	c7 44 24 28 40
	00 00 00	 mov	 DWORD PTR [rsp+40], 64	; 00000040H
  0003c	48 8b f1	 mov	 rsi, rcx
  0003f	49 89 43 88	 mov	 QWORD PTR [r11-120], rax
  00043	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 601  : 
; 602  : 	return NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE, NULL, 0,  NULL, 0))
; 603  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_IS_OFFLINE, NULL, 0,  NULL, 0))
; 604  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_IS_IO_CAPABLE, NULL, 0,  NULL, 0))
; 605  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_IS_PARTITION, NULL, 0,  NULL, 0))
; 606  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_QUERY_VOLUME_NUMBER, NULL, 0, &volNumber, sizeof (volNumber)))
; 607  : 		|| NT_SUCCESS (extentStatus) || extentStatus == STATUS_BUFFER_OVERFLOW || extentStatus == STATUS_BUFFER_TOO_SMALL;

  00048	33 db		 xor	 ebx, ebx
  0004a	45 33 c9	 xor	 r9d, r9d
  0004d	45 33 c0	 xor	 r8d, r8d
  00050	ba 04 00 56 00	 mov	 edx, 5636100		; 00560004H
  00055	48 8b ce	 mov	 rcx, rsi
  00058	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  0005c	8b f8		 mov	 edi, eax
  0005e	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00063	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00068	3b c3		 cmp	 eax, ebx
  0006a	0f 8d 9d 00 00
	00		 jge	 $LN3@IsVolumeDe
  00070	45 33 c9	 xor	 r9d, r9d
  00073	45 33 c0	 xor	 r8d, r8d
  00076	ba 10 00 56 00	 mov	 edx, 5636112		; 00560010H
  0007b	48 8b ce	 mov	 rcx, rsi
  0007e	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00082	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00087	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0008c	3b c3		 cmp	 eax, ebx
  0008e	7d 7d		 jge	 SHORT $LN3@IsVolumeDe
  00090	45 33 c9	 xor	 r9d, r9d
  00093	45 33 c0	 xor	 r8d, r8d
  00096	ba 14 00 56 00	 mov	 edx, 5636116		; 00560014H
  0009b	48 8b ce	 mov	 rcx, rsi
  0009e	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  000a2	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000a7	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  000ac	3b c3		 cmp	 eax, ebx
  000ae	7d 5d		 jge	 SHORT $LN3@IsVolumeDe
  000b0	45 33 c9	 xor	 r9d, r9d
  000b3	45 33 c0	 xor	 r8d, r8d
  000b6	ba 28 00 56 00	 mov	 edx, 5636136		; 00560028H
  000bb	48 8b ce	 mov	 rcx, rsi
  000be	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  000c2	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000c7	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  000cc	3b c3		 cmp	 eax, ebx
  000ce	7d 3d		 jge	 SHORT $LN3@IsVolumeDe
  000d0	48 8d 44 24 70	 lea	 rax, QWORD PTR volNumber$[rsp]
  000d5	45 33 c9	 xor	 r9d, r9d
  000d8	45 33 c0	 xor	 r8d, r8d
  000db	ba 1c 00 56 00	 mov	 edx, 5636124		; 0056001cH
  000e0	48 8b ce	 mov	 rcx, rsi
  000e3	c7 44 24 28 14
	00 00 00	 mov	 DWORD PTR [rsp+40], 20
  000eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f0	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  000f5	3b c3		 cmp	 eax, ebx
  000f7	7d 14		 jge	 SHORT $LN3@IsVolumeDe
  000f9	3b fb		 cmp	 edi, ebx
  000fb	7d 10		 jge	 SHORT $LN3@IsVolumeDe
  000fd	81 ff 05 00 00
	80		 cmp	 edi, -2147483643	; ffffffff80000005H
  00103	74 08		 je	 SHORT $LN3@IsVolumeDe
  00105	81 ff 23 00 00
	c0		 cmp	 edi, -1073741789	; ffffffffc0000023H
  0010b	75 05		 jne	 SHORT $LN4@IsVolumeDe
$LN3@IsVolumeDe:
  0010d	bb 01 00 00 00	 mov	 ebx, 1
$LN4@IsVolumeDe:
  00112	8b c3		 mov	 eax, ebx

; 608  : }

  00114	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0011c	48 33 cc	 xor	 rcx, rsp
  0011f	e8 00 00 00 00	 call	 __security_check_cookie
  00124	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  0012c	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  00130	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00134	49 8b e3	 mov	 rsp, r11
  00137	5f		 pop	 rdi
  00138	c3		 ret	 0
IsVolumeDevice ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT PassIrp
_TEXT	SEGMENT
deviceObject$ = 8
irp$ = 16
PassIrp	PROC						; COMDAT

; 538  : 	IoSkipCurrentIrpStackLocation (irp);

  00000	fe 42 43	 inc	 BYTE PTR [rdx+67]
  00003	48 83 82 b8 00
	00 00 48	 add	 QWORD PTR [rdx+184], 72	; 00000048H

; 539  : 	return IoCallDriver (deviceObject, irp);
; 540  : }

  0000b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_IofCallDriver
PassIrp	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$IoCopyCurrentIrpStackLocationToNext DD imagerel $LN7
	DD	imagerel $LN7+41
	DD	imagerel $unwind$IoCopyCurrentIrpStackLocationToNext
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoCopyCurrentIrpStackLocationToNext DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IoCopyCurrentIrpStackLocationToNext
_TEXT	SEGMENT
Irp$ = 48
IoCopyCurrentIrpStackLocationToNext PROC		; COMDAT

; 23912: {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 23913:     PIO_STACK_LOCATION irpSp;
; 23914:     PIO_STACK_LOCATION nextIrpSp;
; 23915:     irpSp = IoGetCurrentIrpStackLocation(Irp);

  00006	48 8b 91 b8 00
	00 00		 mov	 rdx, QWORD PTR [rcx+184]

; 23916:     nextIrpSp = IoGetNextIrpStackLocation(Irp);
; 23917:     RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));

  0000d	41 b8 38 00 00
	00		 mov	 r8d, 56			; 00000038H
  00013	48 8d 5a b8	 lea	 rbx, QWORD PTR [rdx-72]
  00017	48 8b cb	 mov	 rcx, rbx
  0001a	e8 00 00 00 00	 call	 memcpy

; 23918:     nextIrpSp->Control = 0;

  0001f	c6 43 03 00	 mov	 BYTE PTR [rbx+3], 0

; 23919: }

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
IoCopyCurrentIrpStackLocationToNext ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT IoSetCompletionRoutine
_TEXT	SEGMENT
Irp$ = 8
CompletionRoutine$ = 16
Context$ = 24
InvokeOnSuccess$ = 32
InvokeOnError$ = 40
InvokeOnCancel$ = 48
IoSetCompletionRoutine PROC				; COMDAT

; 23821:     PIO_STACK_LOCATION irpSp;
; 23822:     ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );
; 23823:     irpSp = IoGetNextIrpStackLocation(Irp);

  00000	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]

; 23824:     irpSp->CompletionRoutine = CompletionRoutine;

  00007	48 89 50 f0	 mov	 QWORD PTR [rax-16], rdx

; 23825:     irpSp->Context = Context;

  0000b	4c 89 40 f8	 mov	 QWORD PTR [rax-8], r8

; 23826:     irpSp->Control = 0;
; 23827: 
; 23828:     if (InvokeOnSuccess) {
; 23829:         irpSp->Control = SL_INVOKE_ON_SUCCESS;
; 23830:     }
; 23831: 
; 23832:     if (InvokeOnError) {
; 23833:         irpSp->Control |= SL_INVOKE_ON_ERROR;
; 23834:     }
; 23835: 
; 23836:     if (InvokeOnCancel) {
; 23837:         irpSp->Control |= SL_INVOKE_ON_CANCEL;

  0000f	c6 40 bb e0	 mov	 BYTE PTR [rax-69], 224	; 000000e0H

; 23838:     }
; 23839: }

  00013	c3		 ret	 0
IoSetCompletionRoutine ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT IoMarkIrpPending
_TEXT	SEGMENT
Irp$ = 8
IoMarkIrpPending PROC					; COMDAT

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00000	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00007	80 48 03 01	 or	 BYTE PTR [rax+3], 1

; 23669: }

  0000b	c3		 ret	 0
IoMarkIrpPending ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT PsGetCurrentThread
_TEXT	SEGMENT
PsGetCurrentThread PROC					; COMDAT

; 19989: 
; 19990:     return (PETHREAD)KeGetCurrentThread();

  00000	65 48 8b 04 25
	88 01 00 00	 mov	 rax, QWORD PTR gs:392

; 19991: }

  00009	c3		 ret	 0
PsGetCurrentThread ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT KfRaiseIrql
_TEXT	SEGMENT
NewIrql$ = 8
KfRaiseIrql PROC					; COMDAT

; 13429: 
; 13430:     KIRQL OldIrql;
; 13431: 
; 13432:     OldIrql = KeGetCurrentIrql();

  00000	44 0f 20 c0	 mov	 rax, cr8

; 13433: 
; 13434:     NT_ASSERT(OldIrql <= NewIrql);
; 13435: 
; 13436:     WriteCR8(NewIrql);

  00004	b9 02 00 00 00	 mov	 ecx, 2
  00009	44 0f 22 c1	 mov	 cr8, rcx

; 13437:     return OldIrql;
; 13438: }

  0000d	c3		 ret	 0
KfRaiseIrql ENDP
PUBLIC	AbortDecoySystemWipe
DecoySystemWipeThreadAbortRequested DD 01H DUP (?)
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
pdata	SEGMENT
$pdata$AbortDecoySystemWipe DD imagerel $LN12
	DD	imagerel $LN12+111
	DD	imagerel $unwind$AbortDecoySystemWipe
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AbortDecoySystemWipe DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT AbortDecoySystemWipe
_TEXT	SEGMENT
AbortDecoySystemWipe PROC				; COMDAT

; 2350 : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2351 : 	if (!IoIsSystemThread (PsGetCurrentThread()) && !UserCanAccessDriveDevice())

  00006	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  00015	84 c0		 test	 al, al
  00017	75 10		 jne	 SHORT $LN2@AbortDecoy
  00019	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN2@AbortDecoy

; 2352 : 		return STATUS_ACCESS_DENIED;

  00022	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00027	eb 40		 jmp	 SHORT $LN3@AbortDecoy
$LN2@AbortDecoy:

; 2353 : 
; 2354 : 	if (DecoySystemWipeThread)

  00029	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR DecoySystemWipeThread
  00030	48 85 db	 test	 rbx, rbx
  00033	74 32		 je	 SHORT $LN1@AbortDecoy

; 2355 : 	{
; 2356 : 		DecoySystemWipeThreadAbortRequested = TRUE;
; 2357 : 
; 2358 : 		GSTStopThread (DecoySystemWipeThread, NULL);

  00035	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0003b	45 33 c9	 xor	 r9d, r9d
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	33 d2		 xor	 edx, edx
  00043	48 8b cb	 mov	 rcx, rbx
  00046	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DecoySystemWipeThreadAbortRequested, 1
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00056	48 8b cb	 mov	 rcx, rbx
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2359 : 		DecoySystemWipeThread = NULL;

  0005f	48 83 25 00 00
	00 00 00	 and	 QWORD PTR DecoySystemWipeThread, 0
$LN1@AbortDecoy:

; 2360 : 	}
; 2361 : 
; 2362 : 	return STATUS_SUCCESS;

  00067	33 c0		 xor	 eax, eax
$LN3@AbortDecoy:

; 2363 : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5b		 pop	 rbx
  0006e	c3		 ret	 0
AbortDecoySystemWipe ENDP
_TEXT	ENDS
PUBLIC	AbortBootEncryptionSetup
EncryptionSetupThreadAbortRequested DD 01H DUP (?)
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
pdata	SEGMENT
$pdata$AbortBootEncryptionSetup DD imagerel $LN12
	DD	imagerel $LN12+111
	DD	imagerel $unwind$AbortBootEncryptionSetup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AbortBootEncryptionSetup DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT AbortBootEncryptionSetup
_TEXT	SEGMENT
AbortBootEncryptionSetup PROC				; COMDAT

; 2071 : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2072 : 	if (!IoIsSystemThread (PsGetCurrentThread()) && !UserCanAccessDriveDevice())

  00006	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  00015	84 c0		 test	 al, al
  00017	75 10		 jne	 SHORT $LN2@AbortBootE
  00019	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN2@AbortBootE

; 2073 : 		return STATUS_ACCESS_DENIED;

  00022	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00027	eb 40		 jmp	 SHORT $LN3@AbortBootE
$LN2@AbortBootE:

; 2074 : 
; 2075 : 	if (EncryptionSetupThread)

  00029	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR EncryptionSetupThread
  00030	48 85 db	 test	 rbx, rbx
  00033	74 32		 je	 SHORT $LN1@AbortBootE

; 2076 : 	{
; 2077 : 		EncryptionSetupThreadAbortRequested = TRUE;
; 2078 : 
; 2079 : 		GSTStopThread (EncryptionSetupThread, NULL);

  00035	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0003b	45 33 c9	 xor	 r9d, r9d
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	33 d2		 xor	 edx, edx
  00043	48 8b cb	 mov	 rcx, rbx
  00046	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR EncryptionSetupThreadAbortRequested, 1
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00056	48 8b cb	 mov	 rcx, rbx
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2080 : 		EncryptionSetupThread = NULL;

  0005f	48 83 25 00 00
	00 00 00	 and	 QWORD PTR EncryptionSetupThread, 0
$LN1@AbortBootE:

; 2081 : 	}
; 2082 : 
; 2083 : 	return STATUS_SUCCESS;

  00067	33 c0		 xor	 eax, eax
$LN3@AbortBootE:

; 2084 : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5b		 pop	 rbx
  0006e	c3		 ret	 0
AbortBootEncryptionSetup ENDP
_TEXT	ENDS
PUBLIC	GetBootEncryptionAlgorithmName
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetBootEncryptionAlgorithmName DD imagerel $LN6
	DD	imagerel $LN6+100
	DD	imagerel $unwind$GetBootEncryptionAlgorithmName
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetBootEncryptionAlgorithmName DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetBootEncryptionAlgorithmName
_TEXT	SEGMENT
irp$ = 48
irpSp$ = 56
GetBootEncryptionAlgorithmName PROC			; COMDAT

; 1965 : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1966 : 	if (ValidateIOBufferSize (irp, sizeof (GetBootEncryptionAlgorithmNameRequest), ValidateOutput))

  00006	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0000b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00019	85 c0		 test	 eax, eax
  0001b	74 41		 je	 SHORT $LN1@GetBootEnc@2

; 1967 : 	{
; 1968 : 		if (BootDriveFilterExtension && BootDriveFilterExtension->DriveMounted)

  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00024	48 85 c0	 test	 rax, rax
  00027	74 29		 je	 SHORT $LN2@GetBootEnc@2
  00029	83 b8 b8 02 00
	00 00		 cmp	 DWORD PTR [rax+696], 0
  00030	74 20		 je	 SHORT $LN2@GetBootEnc@2

; 1969 : 		{
; 1970 : 			GetBootEncryptionAlgorithmNameRequest *request = (GetBootEncryptionAlgorithmNameRequest *) irp->AssociatedIrp.SystemBuffer;
; 1971 : 			EAGetName (request->BootEncryptionAlgorithmName, BootDriveFilterExtension->Queue.CryptoInfo->ea);

  00032	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00039	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  0003d	8b 10		 mov	 edx, DWORD PTR [rax]
  0003f	e8 00 00 00 00	 call	 EAGetName

; 1972 : 
; 1973 : 			irp->IoStatus.Information = sizeof (GetBootEncryptionAlgorithmNameRequest);
; 1974 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  00044	83 63 30 00	 and	 DWORD PTR [rbx+48], 0
  00048	48 c7 43 38 00
	01 00 00	 mov	 QWORD PTR [rbx+56], 256	; 00000100H

; 1975 : 		}
; 1976 : 		else

  00050	eb 0c		 jmp	 SHORT $LN1@GetBootEnc@2
$LN2@GetBootEnc@2:

; 1977 : 		{
; 1978 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 1979 : 			irp->IoStatus.Information = 0;

  00052	48 83 63 38 00	 and	 QWORD PTR [rbx+56], 0
  00057	c7 43 30 0d 00
	00 c0		 mov	 DWORD PTR [rbx+48], -1073741811 ; ffffffffc000000dH
$LN1@GetBootEnc@2:

; 1980 : 		}
; 1981 : 	}
; 1982 : }

  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
GetBootEncryptionAlgorithmName ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$OnDeviceUsageNotificationCompleted DD imagerel OnDeviceUsageNotificationCompleted
	DD	imagerel OnDeviceUsageNotificationCompleted+63
	DD	imagerel $unwind$OnDeviceUsageNotificationCompleted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnDeviceUsageNotificationCompleted DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT OnDeviceUsageNotificationCompleted
_TEXT	SEGMENT
filterDeviceObject$ = 48
Irp$ = 56
Extension$ = 64
OnDeviceUsageNotificationCompleted PROC			; COMDAT

; 576  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 577  : 	if (Irp->PendingReturned)

  00004	80 7a 41 00	 cmp	 BYTE PTR [rdx+65], 0
  00008	74 0b		 je	 SHORT $LN5@OnDeviceUs@2

; 578  : 		IoMarkIrpPending (Irp);

  0000a	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  00011	80 48 03 01	 or	 BYTE PTR [rax+3], 1
$LN5@OnDeviceUs@2:

; 579  : 
; 580  : 	if (!(Extension->LowerDeviceObject->Flags & DO_POWER_PAGABLE))

  00015	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00019	0f ba 60 30 0d	 bt	 DWORD PTR [rax+48], 13
  0001e	72 05		 jb	 SHORT $LN1@OnDeviceUs@2

; 581  : 		filterDeviceObject->Flags &= ~DO_POWER_PAGABLE;

  00020	0f ba 71 30 0d	 btr	 DWORD PTR [rcx+48], 13
$LN1@OnDeviceUs@2:

; 582  : 
; 583  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00025	49 8d 88 f0 00
	00 00		 lea	 rcx, QWORD PTR [r8+240]
  0002c	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 584  : 	return STATUS_CONTINUE_COMPLETION;

  00038	33 c0		 xor	 eax, eax

; 585  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
OnDeviceUsageNotificationCompleted ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$PassFilteredIrp DD imagerel PassFilteredIrp
	DD	imagerel PassFilteredIrp+129
	DD	imagerel $unwind$PassFilteredIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PassFilteredIrp DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0c0153219H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT PassFilteredIrp
_TEXT	SEGMENT
deviceObject$ = 48
irp$ = 56
completionRoutine$ = 64
completionRoutineArg$ = 72
PassFilteredIrp PROC					; COMDAT

; 555  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8b fa	 mov	 rdi, rdx

; 556  : 	IoCopyCurrentIrpStackLocationToNext (irp);

  0001c	48 8b 92 b8 00
	00 00		 mov	 rdx, QWORD PTR [rdx+184]
  00023	49 8b f0	 mov	 rsi, r8
  00026	48 8d 5a b8	 lea	 rbx, QWORD PTR [rdx-72]
  0002a	48 8b e9	 mov	 rbp, rcx
  0002d	41 b8 38 00 00
	00		 mov	 r8d, 56			; 00000038H
  00033	48 8b cb	 mov	 rcx, rbx
  00036	4d 8b e1	 mov	 r12, r9
  00039	e8 00 00 00 00	 call	 memcpy
  0003e	c6 43 03 00	 mov	 BYTE PTR [rbx+3], 0

; 557  : 
; 558  : 	if (completionRoutine)

  00042	48 85 f6	 test	 rsi, rsi
  00045	74 13		 je	 SHORT $LN10@PassFilter@2

; 559  : 		IoSetCompletionRoutine (irp, completionRoutine, completionRoutineArg, TRUE, TRUE, TRUE);

  00047	48 8b 87 b8 00
	00 00		 mov	 rax, QWORD PTR [rdi+184]
  0004e	48 89 70 f0	 mov	 QWORD PTR [rax-16], rsi
  00052	4c 89 60 f8	 mov	 QWORD PTR [rax-8], r12
  00056	c6 40 bb e0	 mov	 BYTE PTR [rax-69], 224	; 000000e0H
$LN10@PassFilter@2:

; 560  : 
; 561  : 	return IoCallDriver (deviceObject, irp);

  0005a	48 8b d7	 mov	 rdx, rdi
  0005d	48 8b cd	 mov	 rcx, rbp

; 562  : }

  00060	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00065	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	41 5c		 pop	 r12
  0007a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_IofCallDriver
PassFilteredIrp ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\encryptedioqueue.c
pdata	SEGMENT
$pdata$DismountDrive DD imagerel DismountDrive
	DD	imagerel DismountDrive+85
	DD	imagerel $unwind$DismountDrive
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DismountDrive DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT DismountDrive
_TEXT	SEGMENT
Extension$ = 48
stopIoQueue$ = 56
DismountDrive PROC					; COMDAT

; 237  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 238  : 	Dump ("Dismounting drive\n");
; 239  : 	ASSERT (Extension->DriveMounted);
; 240  : 	
; 241  : 	if (stopIoQueue && EncryptedIoQueueIsRunning (&Extension->Queue))

  00009	85 d2		 test	 edx, edx
  0000b	74 13		 je	 SHORT $LN1@DismountDr
  0000d	8b 81 90 02 00
	00		 mov	 eax, DWORD PTR [rcx+656]
  00013	85 c0		 test	 eax, eax
  00015	75 09		 jne	 SHORT $LN1@DismountDr

; 242  : 		EncryptedIoQueueStop (&Extension->Queue);

  00017	48 83 c1 50	 add	 rcx, 80			; 00000050H
  0001b	e8 00 00 00 00	 call	 EncryptedIoQueueStop
$LN1@DismountDr:

; 243  : 
; 244  : 	crypto_close (Extension->Queue.CryptoInfo);

  00020	48 8b 8b 98 00
	00 00		 mov	 rcx, QWORD PTR [rbx+152]
  00027	e8 00 00 00 00	 call	 crypto_close

; 245  : 	Extension->Queue.CryptoInfo = NULL;
; 246  : 
; 247  : 	crypto_close (Extension->HeaderCryptoInfo);

  0002c	48 8b 8b d8 02
	00 00		 mov	 rcx, QWORD PTR [rbx+728]
  00033	48 83 a3 98 00
	00 00 00	 and	 QWORD PTR [rbx+152], 0
  0003b	e8 00 00 00 00	 call	 crypto_close

; 248  : 	Extension->HeaderCryptoInfo = NULL;

  00040	48 83 a3 d8 02
	00 00 00	 and	 QWORD PTR [rbx+728], 0

; 249  : 
; 250  : 	Extension->DriveMounted = FALSE;

  00048	83 a3 b8 02 00
	00 00		 and	 DWORD PTR [rbx+696], 0

; 251  : }

  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
DismountDrive ENDP
; Function compile flags: /Ogspy
; File c:\winddk\7600.16385.1\inc\ddk\ntddk.h
_TEXT	ENDS
;	COMDAT KeRaiseIrqlToDpcLevel
_TEXT	SEGMENT
KeRaiseIrqlToDpcLevel PROC				; COMDAT

; 6916 : 
; 6917 :     return KfRaiseIrql(DISPATCH_LEVEL);

  00000	44 0f 20 c0	 mov	 rax, cr8
  00004	b9 02 00 00 00	 mov	 ecx, 2
  00009	44 0f 22 c1	 mov	 cr8, rcx

; 6918 : }

  0000d	c3		 ret	 0
KeRaiseIrqlToDpcLevel ENDP
OriginalHiberDriverWriteFunctionsA DQ 03H DUP (?)
OriginalHiberDriverWriteFunctionsB DQ 03H DUP (?)
HiberPartitionOffset DQ 01H DUP (?)
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionFilter DD imagerel HiberDriverWriteFunctionFilter
	DD	imagerel HiberDriverWriteFunctionFilter+600
	DD	imagerel $unwind$HiberDriverWriteFunctionFilter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionFilter DD 0a1d01H
	DD	010341dH
	DD	0f019521dH
	DD	0d015e017H
	DD	07011c013H
	DD	0500f6010H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionFilter
_TEXT	SEGMENT
filterNumber$ = 112
dataUnit$28536 = 120
writeOffset$ = 120
dataMdl$ = 128
writeB$ = 136
arg0WriteA$ = 144
arg3WriteA$ = 152
HiberDriverWriteFunctionFilter PROC			; COMDAT

; 1037 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	55		 push	 rbp
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001d	4c 8b f2	 mov	 r14, rdx

; 1038 : 	MDL *encryptedDataMdl = dataMdl;
; 1039 : 
; 1040 : 	if (writeOffset && dataMdl && BootDriveFilterExtension && BootDriveFilterExtension->DriveMounted)

  00020	45 33 d2	 xor	 r10d, r10d
  00023	49 8b f0	 mov	 rsi, r8
  00026	8b c1		 mov	 eax, ecx
  00028	49 8b d0	 mov	 rdx, r8
  0002b	4d 3b f2	 cmp	 r14, r10
  0002e	0f 84 cf 01 00
	00		 je	 $LN3@HiberDrive
  00034	4d 3b c2	 cmp	 r8, r10
  00037	0f 84 c6 01 00
	00		 je	 $LN3@HiberDrive
  0003d	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR BootDriveFilterExtension
  00044	49 3b fa	 cmp	 rdi, r10
  00047	0f 84 b6 01 00
	00		 je	 $LN3@HiberDrive
  0004d	44 39 97 b8 02
	00 00		 cmp	 DWORD PTR [rdi+696], r10d
  00054	0f 84 a9 01 00
	00		 je	 $LN3@HiberDrive

; 1041 : 	{
; 1042 : 		ULONG dataLength = MmGetMdlByteCount (dataMdl);

  0005a	45 8b 60 28	 mov	 r12d, DWORD PTR [r8+40]

; 1043 : 
; 1044 : 		if (dataMdl->MappedSystemVa && dataLength > 0)

  0005e	4d 39 50 18	 cmp	 QWORD PTR [r8+24], r10
  00062	0f 84 9b 01 00
	00		 je	 $LN3@HiberDrive
  00068	45 3b e2	 cmp	 r12d, r10d
  0006b	0f 86 92 01 00
	00		 jbe	 $LN3@HiberDrive

; 1045 : 		{
; 1046 : 			uint64 offset = HiberPartitionOffset.QuadPart + writeOffset->QuadPart;

  00071	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR HiberPartitionOffset
  00078	4d 03 2e	 add	 r13, QWORD PTR [r14]

; 1047 : 			uint64 intersectStart;
; 1048 : 			uint32 intersectLength;
; 1049 : 
; 1050 : 			if (dataLength > GST_HIBERNATION_WRITE_BUFFER_SIZE)

  0007b	41 81 fc 00 00
	02 00		 cmp	 r12d, 131072		; 00020000H
  00082	76 23		 jbe	 SHORT $LN6@HiberDrive

; 1051 : 				GST_BUG_CHECK (STATUS_BUFFER_OVERFLOW);

  00084	41 8d 4a 29	 lea	 ecx, QWORD PTR [r10+41]
  00088	45 33 c9	 xor	 r9d, r9d
  0008b	ba 1b 04 00 00	 mov	 edx, 1051		; 0000041bH
  00090	49 c7 c0 05 00
	00 80		 mov	 r8, -2147483643		; ffffffff80000005H
  00097	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  000a6	cc		 int	 3
$LN6@HiberDrive:

; 1052 : 
; 1053 : 			if ((dataLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000a7	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  000ac	44 85 e0	 test	 r12d, eax
  000af	74 23		 je	 SHORT $LN5@HiberDrive

; 1054 : 				GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000b1	45 33 c9	 xor	 r9d, r9d
  000b4	ba 1e 04 00 00	 mov	 edx, 1054		; 0000041eH
  000b9	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  000c0	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  000c4	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  000d3	cc		 int	 3
$LN5@HiberDrive:

; 1055 : 
; 1056 : 			if ((offset & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000d4	4c 85 e8	 test	 r13, rax
  000d7	74 23		 je	 SHORT $LN4@HiberDrive

; 1057 : 				GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000d9	45 33 c9	 xor	 r9d, r9d
  000dc	ba 21 04 00 00	 mov	 edx, 1057		; 00000421H
  000e1	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  000e8	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  000ec	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  000fb	cc		 int	 3
$LN4@HiberDrive:

; 1058 : 
; 1059 : 			GetIntersection (offset,
; 1060 : 				dataLength,
; 1061 : 				BootDriveFilterExtension->Queue.EncryptedAreaStart,
; 1062 : 				BootDriveFilterExtension->Queue.EncryptedAreaEnd,
; 1063 : 				&intersectStart,
; 1064 : 				&intersectLength);

  000fc	48 8b bf d0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+208]
  00103	4c 8b 3d 00 00
	00 00		 mov	 r15, QWORD PTR BootDriveFilterExtension
  0010a	4b 8d 44 2c ff	 lea	 rax, QWORD PTR [r12+r13-1]
  0010f	49 8b af c8 00
	00 00		 mov	 rbp, QWORD PTR [r15+200]
  00116	48 3b c7	 cmp	 rax, rdi
  00119	4d 8b c4	 mov	 r8, r12
  0011c	48 0f 46 f8	 cmovbe	 rdi, rax
  00120	4c 3b ed	 cmp	 r13, rbp
  00123	49 0f 43 ed	 cmovae	 rbp, r13
  00127	48 3b ef	 cmp	 rbp, rdi
  0012a	76 05		 jbe	 SHORT $LN14@HiberDrive
  0012c	41 8b fa	 mov	 edi, r10d
  0012f	eb 07		 jmp	 SHORT $LN16@HiberDrive
$LN14@HiberDrive:
  00131	2b fd		 sub	 edi, ebp
  00133	83 c7 01	 add	 edi, 1
  00136	75 03		 jne	 SHORT $LN11@HiberDrive
$LN16@HiberDrive:
  00138	49 8b ed	 mov	 rbp, r13
$LN11@HiberDrive:

; 1065 : 
; 1066 : 			if (intersectLength > 0)

  0013b	41 3b fa	 cmp	 edi, r10d
  0013e	0f 86 bb 00 00
	00		 jbe	 $LN17@HiberDrive

; 1067 : 			{
; 1068 : 				UINT64_STRUCT dataUnit;
; 1069 : 				dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;
; 1070 : 
; 1071 : 				memcpy (HibernationWriteBuffer, dataMdl->MappedSystemVa, dataLength);

  00144	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]
  00148	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBuffer
  0014f	48 8b dd	 mov	 rbx, rbp
  00152	48 c1 eb 09	 shr	 rbx, 9
  00156	48 89 5c 24 78	 mov	 QWORD PTR dataUnit$28536[rsp], rbx
  0015b	e8 00 00 00 00	 call	 memcpy

; 1072 : 
; 1073 : 				if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  00160	41 83 bf dc 00
	00 00 00	 cmp	 DWORD PTR [r15+220], 0
  00168	74 0c		 je	 SHORT $LN2@HiberDrive

; 1074 : 					dataUnit.Value += BootDriveFilterExtension->Queue.RemappedAreaDataUnitOffset;

  0016a	49 03 9f e8 00
	00 00		 add	 rbx, QWORD PTR [r15+232]
  00171	48 89 5c 24 78	 mov	 QWORD PTR dataUnit$28536[rsp], rbx
$LN2@HiberDrive:

; 1075 : 
; 1076 : 				EncryptDataUnitsCurrentThread (HibernationWriteBuffer + (intersectStart - offset),
; 1077 : 					&dataUnit,
; 1078 : 					intersectLength / ENCRYPTION_DATA_UNIT_SIZE,
; 1079 : 					BootDriveFilterExtension->Queue.CryptoInfo);

  00176	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBuffer
  0017d	4d 8b 8f 98 00
	00 00		 mov	 r9, QWORD PTR [r15+152]
  00184	44 8b c7	 mov	 r8d, edi
  00187	49 2b cd	 sub	 rcx, r13
  0018a	48 8d 54 24 78	 lea	 rdx, QWORD PTR dataUnit$28536[rsp]
  0018f	49 c1 e8 09	 shr	 r8, 9
  00193	48 03 cd	 add	 rcx, rbp
  00196	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread

; 1080 : 
; 1081 : 				encryptedDataMdl = HibernationWriteBufferMdl;

  0019b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR HibernationWriteBufferMdl

; 1082 : 				MmInitializeMdl (encryptedDataMdl, HibernationWriteBuffer, dataLength);

  001a2	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR HibernationWriteBuffer
  001a9	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  001ae	45 33 d2	 xor	 r10d, r10d
  001b1	45 8b c8	 mov	 r9d, r8d
  001b4	44 23 c9	 and	 r9d, ecx
  001b7	66 44 89 52 0a	 mov	 WORD PTR [rdx+10], r10w
  001bc	41 8b c4	 mov	 eax, r12d
  001bf	23 c1		 and	 eax, ecx
  001c1	4c 89 12	 mov	 QWORD PTR [rdx], r10
  001c4	44 89 62 28	 mov	 DWORD PTR [rdx+40], r12d
  001c8	42 8d 8c 08 ff
	0f 00 00	 lea	 ecx, DWORD PTR [rax+r9+4095]
  001d0	41 8b c4	 mov	 eax, r12d
  001d3	44 89 4a 2c	 mov	 DWORD PTR [rdx+44], r9d
  001d7	c1 e9 0c	 shr	 ecx, 12
  001da	c1 e8 0c	 shr	 eax, 12
  001dd	66 03 c8	 add	 cx, ax
  001e0	66 83 c1 06	 add	 cx, 6
  001e4	66 c1 e1 03	 shl	 cx, 3
  001e8	49 81 e0 00 f0
	ff ff		 and	 r8, -4096		; fffffffffffff000H
  001ef	4c 89 42 20	 mov	 QWORD PTR [rdx+32], r8
  001f3	66 89 4a 08	 mov	 WORD PTR [rdx+8], cx

; 1083 : 				encryptedDataMdl->MdlFlags = dataMdl->MdlFlags;

  001f7	0f b7 46 0a	 movzx	 eax, WORD PTR [rsi+10]
  001fb	66 89 42 0a	 mov	 WORD PTR [rdx+10], ax
$LN17@HiberDrive:

; 1037 : {

  001ff	8b 44 24 70	 mov	 eax, DWORD PTR filterNumber$[rsp]
$LN3@HiberDrive:

; 1084 : 			}
; 1085 : 		}
; 1086 : 	}
; 1087 : 
; 1088 : 	if (writeB)

  00203	44 39 94 24 88
	00 00 00	 cmp	 DWORD PTR writeB$[rsp], r10d

; 1089 : 		return (*OriginalHiberDriverWriteFunctionsB[filterNumber]) (writeOffset, encryptedDataMdl);

  0020b	48 98		 cdqe
  0020d	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
  00214	74 0d		 je	 SHORT $LN1@HiberDrive
  00216	49 8b ce	 mov	 rcx, r14
  00219	41 ff 94 c2 00
	00 00 00	 call	 QWORD PTR OriginalHiberDriverWriteFunctionsB[r10+rax*8]
  00221	eb 1d		 jmp	 SHORT $LN9@HiberDrive
$LN1@HiberDrive:

; 1090 : 	
; 1091 : 	return (*OriginalHiberDriverWriteFunctionsA[filterNumber]) (arg0WriteA, writeOffset, encryptedDataMdl, arg3WriteA);

  00223	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR arg3WriteA$[rsp]
  0022b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR arg0WriteA$[rsp]
  00232	4c 8b c2	 mov	 r8, rdx
  00235	49 8b d6	 mov	 rdx, r14
  00238	41 ff 94 c2 00
	00 00 00	 call	 QWORD PTR OriginalHiberDriverWriteFunctionsA[r10+rax*8]
$LN9@HiberDrive:

; 1092 : }

  00240	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00248	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0024c	41 5f		 pop	 r15
  0024e	41 5e		 pop	 r14
  00250	41 5d		 pop	 r13
  00252	41 5c		 pop	 r12
  00254	5f		 pop	 rdi
  00255	5e		 pop	 rsi
  00256	5d		 pop	 rbp
  00257	c3		 ret	 0
$LN18@HiberDrive:
HiberDriverWriteFunctionFilter ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
pdata	SEGMENT
$pdata$SaveDriveVolumeHeader DD imagerel SaveDriveVolumeHeader
	DD	imagerel SaveDriveVolumeHeader+513
	DD	imagerel $unwind$SaveDriveVolumeHeader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SaveDriveVolumeHeader DD 0a1901H
	DD	0c7419H
	DD	0b6419H
	DD	0a5419H
	DD	0e0155219H
	DD	0c011d013H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT SaveDriveVolumeHeader
_TEXT	SEGMENT
Extension$ = 80
SaveDriveVolumeHeader PROC				; COMDAT

; 460  : {

  00000	48 89 6c 24 08	 mov	 QWORD PTR [rsp+8], rbp
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 54		 push	 r12
  00011	41 55		 push	 r13
  00013	41 56		 push	 r14
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b f9	 mov	 rdi, rcx

; 461  : 	NTSTATUS status = STATUS_SUCCESS;
; 462  : 	LARGE_INTEGER offset;
; 463  : 	byte *header;
; 464  : 
; 465  : 	header = GSTalloc (GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  0001c	41 be 00 02 00
	00		 mov	 r14d, 512		; 00000200H
  00022	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00028	49 8b d6	 mov	 rdx, r14
  0002b	33 c9		 xor	 ecx, ecx
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00033	48 8b f0	 mov	 rsi, rax

; 466  : 	if (!header)

  00036	48 85 c0	 test	 rax, rax
  00039	75 0a		 jne	 SHORT $LN8@SaveDriveV

; 467  : 		return STATUS_INSUFFICIENT_RESOURCES;

  0003b	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00040	e9 a2 01 00 00	 jmp	 $LN9@SaveDriveV
$LN8@SaveDriveV:

; 468  : 
; 469  : 	offset.QuadPart = GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET;
; 470  : 
; 471  : 	status = GSTReadDevice (Extension->LowerDeviceObject, header, offset, GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00045	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  00049	41 b9 00 7c 00
	00		 mov	 r9d, 31744		; 00007c00H
  0004f	4c 8b c0	 mov	 r8, rax
  00052	33 c9		 xor	 ecx, ecx
  00054	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00059	e8 00 00 00 00	 call	 GSTReadWriteDevice
  0005e	8b e8		 mov	 ebp, eax

; 472  : 	if (!NT_SUCCESS (status))

  00060	85 c0		 test	 eax, eax
  00062	0f 88 6f 01 00
	00		 js	 $ret$28221

; 473  : 	{
; 474  : 		Dump ("GSTReadDevice error %x", status);
; 475  : 		goto ret;
; 476  : 	}
; 477  : 
; 478  : 	Dump ("Saving: ConfiguredEncryptedAreaStart=%I64d (%I64d)  ConfiguredEncryptedAreaEnd=%I64d (%I64d)\n", Extension->ConfiguredEncryptedAreaStart / 1024 / 1024, Extension->ConfiguredEncryptedAreaStart, Extension->ConfiguredEncryptedAreaEnd / 1024 / 1024, Extension->ConfiguredEncryptedAreaEnd);
; 479  : 	Dump ("Saving: EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d (%I64d)\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024, Extension->Queue.EncryptedAreaEnd);
; 480  : 	
; 481  : 	if (Extension->Queue.EncryptedAreaStart == -1 || Extension->Queue.EncryptedAreaEnd == -1
; 482  : 		|| Extension->Queue.EncryptedAreaEnd <= Extension->Queue.EncryptedAreaStart)

  00068	48 83 bf c8 00
	00 00 ff	 cmp	 QWORD PTR [rdi+200], -1
  00070	0f 84 26 01 00
	00		 je	 $LN5@SaveDriveV
  00076	48 8b 87 d0 00
	00 00		 mov	 rax, QWORD PTR [rdi+208]
  0007d	48 83 f8 ff	 cmp	 rax, -1
  00081	0f 84 15 01 00
	00		 je	 $LN5@SaveDriveV
  00087	48 8b 8f c8 00
	00 00		 mov	 rcx, QWORD PTR [rdi+200]
  0008e	48 8b 87 d0 00
	00 00		 mov	 rax, QWORD PTR [rdi+208]
  00095	48 3b c1	 cmp	 rax, rcx
  00098	0f 8e fe 00 00
	00		 jle	 $LN5@SaveDriveV

; 488  : 		}
; 489  : 	}
; 490  : 	else
; 491  : 	{
; 492  : 		uint32 headerCrc32;
; 493  : 		uint64 encryptedAreaLength = Extension->Queue.EncryptedAreaEnd + 1 - Extension->Queue.EncryptedAreaStart;

  0009e	48 8b 87 d0 00
	00 00		 mov	 rax, QWORD PTR [rdi+208]

; 494  : 		byte *fieldPos = header + GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH;
; 495  : 
; 496  : 		DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, Extension->HeaderCryptoInfo);

  000a5	4c 8b 87 d8 02
	00 00		 mov	 r8, QWORD PTR [rdi+728]
  000ac	41 bc 01 00 00
	00		 mov	 r12d, 1
  000b2	4c 2b e1	 sub	 r12, rcx
  000b5	48 8d 4e 40	 lea	 rcx, QWORD PTR [rsi+64]
  000b9	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  000be	4c 03 e0	 add	 r12, rax
  000c1	e8 00 00 00 00	 call	 DecryptBuffer

; 497  : 
; 498  : 		if (GetHeaderField32 (header, GST_HEADER_OFFSET_MAGIC) != 0x54525545)

  000c6	44 8b 5e 40	 mov	 r11d, DWORD PTR [rsi+64]
  000ca	41 8b c3	 mov	 eax, r11d
  000cd	c1 e8 08	 shr	 eax, 8
  000d0	0f b6 d0	 movzx	 edx, al
  000d3	41 0f b6 c3	 movzx	 eax, r11b
  000d7	c1 e0 08	 shl	 eax, 8
  000da	0b d0		 or	 edx, eax
  000dc	41 8b c3	 mov	 eax, r11d
  000df	41 c1 eb 18	 shr	 r11d, 24
  000e3	c1 e2 08	 shl	 edx, 8
  000e6	c1 e8 10	 shr	 eax, 16
  000e9	0f b6 c8	 movzx	 ecx, al
  000ec	0b d1		 or	 edx, ecx
  000ee	c1 e2 08	 shl	 edx, 8
  000f1	41 0b d3	 or	 edx, r11d
  000f4	81 fa 45 55 52
	54		 cmp	 edx, 1414681925		; 54525545H
  000fa	74 0a		 je	 SHORT $LN2@SaveDriveV

; 499  : 		{
; 500  : 			Dump ("Header not decrypted");
; 501  : 			status = STATUS_UNKNOWN_REVISION;

  000fc	bd 58 00 00 c0	 mov	 ebp, -1073741736	; ffffffffc0000058H

; 502  : 			goto ret;

  00101	e9 d1 00 00 00	 jmp	 $ret$28221
$LN2@SaveDriveV:

; 503  : 		}
; 504  : 
; 505  : 		mputInt64 (fieldPos, encryptedAreaLength);

  00106	49 8b c4	 mov	 rax, r12

; 506  : 
; 507  : 		headerCrc32 = GetCrc32 (header + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC);

  00109	48 8d 4e 40	 lea	 rcx, QWORD PTR [rsi+64]
  0010d	ba bc 00 00 00	 mov	 edx, 188		; 000000bcH
  00112	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  00116	88 46 74	 mov	 BYTE PTR [rsi+116], al
  00119	49 8b c4	 mov	 rax, r12
  0011c	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00120	88 46 75	 mov	 BYTE PTR [rsi+117], al
  00123	49 8b c4	 mov	 rax, r12
  00126	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  0012a	88 46 76	 mov	 BYTE PTR [rsi+118], al
  0012d	49 8b c4	 mov	 rax, r12
  00130	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00134	88 46 77	 mov	 BYTE PTR [rsi+119], al
  00137	49 8b c4	 mov	 rax, r12
  0013a	48 c1 e8 18	 shr	 rax, 24
  0013e	88 46 78	 mov	 BYTE PTR [rsi+120], al
  00141	49 8b c4	 mov	 rax, r12
  00144	48 c1 e8 10	 shr	 rax, 16
  00148	88 46 79	 mov	 BYTE PTR [rsi+121], al
  0014b	49 8b c4	 mov	 rax, r12
  0014e	48 c1 e8 08	 shr	 rax, 8
  00152	88 46 7a	 mov	 BYTE PTR [rsi+122], al
  00155	44 88 66 7b	 mov	 BYTE PTR [rsi+123], r12b
  00159	e8 00 00 00 00	 call	 GetCrc32

; 508  : 		fieldPos = header + GST_HEADER_OFFSET_HEADER_CRC;
; 509  : 		mputLong (fieldPos, headerCrc32);

  0015e	8b d0		 mov	 edx, eax

; 510  : 
; 511  : 		EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, Extension->HeaderCryptoInfo);

  00160	48 8d 4e 40	 lea	 rcx, QWORD PTR [rsi+64]
  00164	c1 ea 18	 shr	 edx, 24
  00167	88 96 fc 00 00
	00		 mov	 BYTE PTR [rsi+252], dl
  0016d	8b d0		 mov	 edx, eax
  0016f	c1 ea 10	 shr	 edx, 16
  00172	88 96 fd 00 00
	00		 mov	 BYTE PTR [rsi+253], dl
  00178	8b d0		 mov	 edx, eax
  0017a	c1 ea 08	 shr	 edx, 8
  0017d	88 96 fe 00 00
	00		 mov	 BYTE PTR [rsi+254], dl
  00183	88 86 ff 00 00
	00		 mov	 BYTE PTR [rsi+255], al
  00189	4c 8b 87 d8 02
	00 00		 mov	 r8, QWORD PTR [rdi+728]
  00190	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  00195	e8 00 00 00 00	 call	 EncryptBuffer
  0019a	eb 1d		 jmp	 SHORT $LN4@SaveDriveV
$LN5@SaveDriveV:

; 483  : 	{
; 484  : 		if (SetupRequest.SetupMode == SetupDecryption)

  0019c	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR SetupRequest, 2
  001a3	75 14		 jne	 SHORT $LN4@SaveDriveV

; 485  : 		{
; 486  : 			memset (header, 0, GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  001a5	4d 8b c6	 mov	 r8, r14
  001a8	33 d2		 xor	 edx, edx
  001aa	48 8b ce	 mov	 rcx, rsi
  001ad	e8 00 00 00 00	 call	 memset

; 487  : 			Extension->VolumeHeaderPresent = FALSE;

  001b2	83 a7 b4 02 00
	00 00		 and	 DWORD PTR [rdi+692], 0
$LN4@SaveDriveV:

; 512  : 	}
; 513  : 
; 514  : 	status = GSTWriteDevice (Extension->LowerDeviceObject, header, offset, GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  001b9	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  001bd	41 b9 00 7c 00
	00		 mov	 r9d, 31744		; 00007c00H
  001c3	4c 8b c6	 mov	 r8, rsi
  001c6	b9 01 00 00 00	 mov	 ecx, 1
  001cb	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  001d0	e8 00 00 00 00	 call	 GSTReadWriteDevice
  001d5	8b e8		 mov	 ebp, eax
$ret$28221:

; 515  : 	if (!NT_SUCCESS (status))
; 516  : 	{
; 517  : 		Dump ("GSTWriteDevice error %x", status);
; 518  : 		goto ret;
; 519  : 	}
; 520  : 
; 521  : ret:
; 522  : 	GSTfree (header);

  001d7	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  001dc	48 8b ce	 mov	 rcx, rsi
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 523  : 	return status;

  001e5	8b c5		 mov	 eax, ebp
$LN9@SaveDriveV:

; 524  : }

  001e7	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001ec	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  001f1	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  001f6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001fa	41 5e		 pop	 r14
  001fc	41 5d		 pop	 r13
  001fe	41 5c		 pop	 r12
  00200	c3		 ret	 0
SaveDriveVolumeHeader ENDP
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\encryptedioqueue.c
pdata	SEGMENT
$pdata$DecoySystemWipeThreadProc DD imagerel DecoySystemWipeThreadProc
	DD	imagerel DecoySystemWipeThreadProc+868
	DD	imagerel $unwind$DecoySystemWipeThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecoySystemWipeThreadProc DD 0a1401H
	DD	0e3414H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT DecoySystemWipeThreadProc
_TEXT	SEGMENT
threadArg$ = 112
wipeRandChars$ = 120
wipeBuffer$1$ = 128
dataUnit$ = 136
DecoySystemWipeThreadProc PROC				; COMDAT

; 2096 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2097 : 	DriveFilterExtension *Extension = BootDriveFilterExtension;

  00014	48 8b 2d 00 00
	00 00		 mov	 rbp, QWORD PTR BootDriveFilterExtension

; 2098 : 
; 2099 : 	LARGE_INTEGER offset;
; 2100 : 	UINT64_STRUCT dataUnit;
; 2101 : 	ULONG wipeBlockSize = GST_ENCRYPTION_SETUP_IO_BLOCK_SIZE;

  0001b	41 bd 00 00 18
	00		 mov	 r13d, 1572864		; 00180000H

; 2102 : 
; 2103 : 	CRYPTO_INFO *wipeCryptoInfo = NULL;
; 2104 : 	byte *wipeBuffer = NULL;
; 2105 : 	byte *wipeRandBuffer = NULL;
; 2106 : 	byte wipeRandChars[GST_WIPE_RAND_CHAR_COUNT];
; 2107 : 	int wipePass;
; 2108 : 	int ea = Extension->Queue.CryptoInfo->ea;
; 2109 : 
; 2110 : 	KIRQL irql;
; 2111 : 	NTSTATUS status;
; 2112 : 
; 2113 : 	DecoySystemWipeResult = STATUS_UNSUCCESSFUL;
; 2114 : 
; 2115 : 	wipeBuffer = GSTalloc (GST_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  00021	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00027	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR [rbp+152]
  0002e	33 c9		 xor	 ecx, ecx
  00030	49 8b d5	 mov	 rdx, r13
  00033	44 8b 20	 mov	 r12d, DWORD PTR [rax]
  00036	c7 05 00 00 00
	00 01 00 00 c0	 mov	 DWORD PTR DecoySystemWipeResult, -1073741823 ; ffffffffc0000001H
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00046	48 8b f8	 mov	 rdi, rax
  00049	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR wipeBuffer$1$[rsp], rax

; 2116 : 	if (!wipeBuffer)

  00051	48 85 c0	 test	 rax, rax
  00054	75 10		 jne	 SHORT $LN26@DecoySyste

; 2117 : 	{
; 2118 : 		DecoySystemWipeResult = STATUS_INSUFFICIENT_RESOURCES;

  00056	b9 9a 00 00 c0	 mov	 ecx, -1073741670	; ffffffffc000009aH
  0005b	89 0d 00 00 00
	00		 mov	 DWORD PTR DecoySystemWipeResult, ecx

; 2119 : 		goto ret;

  00061	e9 cd 02 00 00	 jmp	 $LN1@DecoySyste
$LN26@DecoySyste:

; 2120 : 	}
; 2121 : 	
; 2122 : 	wipeRandBuffer = GSTalloc (GST_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  00066	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0006c	49 8b d5	 mov	 rdx, r13
  0006f	33 c9		 xor	 ecx, ecx
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00077	4c 8b f0	 mov	 r14, rax

; 2123 : 	if (!wipeRandBuffer)

  0007a	48 85 c0	 test	 rax, rax
  0007d	75 10		 jne	 SHORT $LN25@DecoySyste

; 2124 : 	{
; 2125 : 		DecoySystemWipeResult = STATUS_INSUFFICIENT_RESOURCES;

  0007f	b9 9a 00 00 c0	 mov	 ecx, -1073741670	; ffffffffc000009aH
  00084	89 0d 00 00 00
	00		 mov	 DWORD PTR DecoySystemWipeResult, ecx

; 2126 : 		goto ret;

  0008a	e9 7d 02 00 00	 jmp	 $LN3@DecoySyste
$LN25@DecoySyste:

; 2127 : 	}
; 2128 : 
; 2129 : 	wipeCryptoInfo = crypto_open();

  0008f	e8 00 00 00 00	 call	 crypto_open
  00094	48 8b d8	 mov	 rbx, rax

; 2130 : 	if (!wipeCryptoInfo)

  00097	48 85 c0	 test	 rax, rax
  0009a	75 10		 jne	 SHORT $LN24@DecoySyste

; 2131 : 	{
; 2132 : 		DecoySystemWipeResult = STATUS_INSUFFICIENT_RESOURCES;

  0009c	b9 9a 00 00 c0	 mov	 ecx, -1073741670	; ffffffffc000009aH
  000a1	89 0d 00 00 00
	00		 mov	 DWORD PTR DecoySystemWipeResult, ecx

; 2133 : 		goto ret;

  000a7	e9 53 02 00 00	 jmp	 $ret$28970
$LN24@DecoySyste:

; 2134 : 	}
; 2135 : 
; 2136 : 	wipeCryptoInfo->ea = ea;

  000ac	44 89 20	 mov	 DWORD PTR [rax], r12d

; 2137 : 	wipeCryptoInfo->mode = Extension->Queue.CryptoInfo->mode;

  000af	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR [rbp+152]
  000b6	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  000b9	89 4b 04	 mov	 DWORD PTR [rbx+4], ecx

; 2138 : 
; 2139 : 	if (EAInit (ea, WipeDecoyRequest.WipeKey, wipeCryptoInfo->ks) != ERR_SUCCESS)

  000bc	45 85 e4	 test	 r12d, r12d
  000bf	0f 84 93 02 00
	00		 je	 $LN63@DecoySyste
  000c5	48 8d 35 04 00
	00 00		 lea	 rsi, OFFSET FLAT:WipeDecoyRequest+4
  000cc	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  000d0	41 8b cc	 mov	 ecx, r12d
  000d3	48 8b d6	 mov	 rdx, rsi
  000d6	e8 00 00 00 00	 call	 EAInit
  000db	85 c0		 test	 eax, eax
  000dd	0f 85 75 02 00
	00		 jne	 $LN63@DecoySyste

; 2142 : 		goto ret;
; 2143 : 	}
; 2144 : 
; 2145 : 	memcpy (wipeCryptoInfo->k2, WipeDecoyRequest.WipeKey + EAGetKeySize (ea), EAGetKeySize (ea));

  000e3	41 8b cc	 mov	 ecx, r12d
  000e6	e8 00 00 00 00	 call	 EAGetKeySize
  000eb	41 8b cc	 mov	 ecx, r12d
  000ee	48 63 f8	 movsxd	 rdi, eax
  000f1	e8 00 00 00 00	 call	 EAGetKeySize
  000f6	48 8d 8b 50 1d
	00 00		 lea	 rcx, QWORD PTR [rbx+7504]
  000fd	48 63 d0	 movsxd	 rdx, eax
  00100	4c 8b c7	 mov	 r8, rdi
  00103	48 03 d6	 add	 rdx, rsi
  00106	e8 00 00 00 00	 call	 memcpy

; 2146 : 	
; 2147 : 	if (!EAInitMode (wipeCryptoInfo))

  0010b	48 8b cb	 mov	 rcx, rbx
  0010e	e8 00 00 00 00	 call	 EAInitMode
  00113	85 c0		 test	 eax, eax
  00115	75 0f		 jne	 SHORT $LN22@DecoySyste

; 2148 : 	{
; 2149 : 		DecoySystemWipeResult = STATUS_INVALID_PARAMETER;

  00117	c7 05 00 00 00
	00 0d 00 00 c0	 mov	 DWORD PTR DecoySystemWipeResult, -1073741811 ; ffffffffc000000dH

; 2150 : 		goto err;

  00121	e9 be 01 00 00	 jmp	 $err$28980
$LN22@DecoySyste:

; 2151 : 	}
; 2152 : 
; 2153 : 	EncryptDataUnits (wipeRandBuffer, &dataUnit, wipeBlockSize / ENCRYPTION_DATA_UNIT_SIZE, wipeCryptoInfo);

  00126	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR dataUnit$[rsp]
  0012e	41 b9 00 0c 00
	00		 mov	 r9d, 3072		; 00000c00H
  00134	49 8b d6	 mov	 rdx, r14
  00137	33 c9		 xor	 ecx, ecx
  00139	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0013e	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 2154 : 	memcpy (wipeRandChars, wipeRandBuffer, sizeof (wipeRandChars));

  00143	41 0f b7 06	 movzx	 eax, WORD PTR [r14]
  00147	48 8d 54 24 78	 lea	 rdx, QWORD PTR wipeRandChars$[rsp]
  0014c	66 89 02	 mov	 WORD PTR [rdx], ax
  0014f	41 8a 46 02	 mov	 al, BYTE PTR [r14+2]

; 2155 : 
; 2156 : 	burn (WipeDecoyRequest.WipeKey, sizeof (WipeDecoyRequest.WipeKey));

  00153	48 8b fe	 mov	 rdi, rsi
  00156	88 42 02	 mov	 BYTE PTR [rdx+2], al
  00159	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0015e	33 c0		 xor	 eax, eax
  00160	48 8b ca	 mov	 rcx, rdx
  00163	f3 aa		 rep stosb
$LL18@DecoySyste:
  00165	88 06		 mov	 BYTE PTR [rsi], al
  00167	48 ff c6	 inc	 rsi
  0016a	83 ea 01	 sub	 edx, 1
  0016d	75 f6		 jne	 SHORT $LL18@DecoySyste

; 2157 : 
; 2158 : 	offset.QuadPart = Extension->ConfiguredEncryptedAreaStart;
; 2159 : 		
; 2160 : 	Dump ("Wiping decoy system:  start offset = %I64d\n", offset.QuadPart);
; 2161 : 
; 2162 : 	while (!DecoySystemWipeThreadAbortRequested)

  0016f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeThreadAbortRequested
  00175	48 8b 7d 38	 mov	 rdi, QWORD PTR [rbp+56]
  00179	85 c0		 test	 eax, eax
$LN67@DecoySyste:
  0017b	0f 85 5c 01 00
	00		 jne	 $abort$29005

; 2163 : 	{
; 2164 : 		if (offset.QuadPart + wipeBlockSize > Extension->ConfiguredEncryptedAreaEnd + 1)

  00181	48 8b 55 40	 mov	 rdx, QWORD PTR [rbp+64]
  00185	41 8b cd	 mov	 ecx, r13d
  00188	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  0018c	48 03 cf	 add	 rcx, rdi
  0018f	48 3b c8	 cmp	 rcx, rax
  00192	7e 09		 jle	 SHORT $LN14@DecoySyste

; 2165 : 			wipeBlockSize = (ULONG) (Extension->ConfiguredEncryptedAreaEnd + 1 - offset.QuadPart);

  00194	44 8b ea	 mov	 r13d, edx
  00197	44 2b ef	 sub	 r13d, edi
  0019a	41 ff c5	 inc	 r13d
$LN14@DecoySyste:

; 2166 : 
; 2167 : 		if (offset.QuadPart > Extension->ConfiguredEncryptedAreaEnd)

  0019d	48 3b fa	 cmp	 rdi, rdx
  001a0	0f 8f 37 01 00
	00		 jg	 $abort$29005

; 2168 : 			break;
; 2169 : 
; 2170 : 		for (wipePass = 1; wipePass <= GetWipePassCount (WipeDecoyRequest.WipeAlgorithm); ++wipePass)

  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR WipeDecoyRequest
  001ac	be 01 00 00 00	 mov	 esi, 1
  001b1	e8 00 00 00 00	 call	 GetWipePassCount
  001b6	3b c6		 cmp	 eax, esi
  001b8	0f 8c db 00 00
	00		 jl	 $LN10@DecoySyste
  001be	45 8b fd	 mov	 r15d, r13d
$LL12@DecoySyste:

; 2171 : 		{
; 2172 : 			if (!WipeBuffer (WipeDecoyRequest.WipeAlgorithm, wipeRandChars, wipePass, wipeBuffer, wipeBlockSize))

  001c1	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR wipeBuffer$1$[rsp]
  001c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR WipeDecoyRequest
  001cf	48 8d 54 24 78	 lea	 rdx, QWORD PTR wipeRandChars$[rsp]
  001d4	44 8b c6	 mov	 r8d, esi
  001d7	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  001dc	e8 00 00 00 00	 call	 WipeBuffer
  001e1	85 c0		 test	 eax, eax
  001e3	75 5b		 jne	 SHORT $LN55@DecoySyste

; 2173 : 			{
; 2174 : 				dataUnit.Value = offset.QuadPart / ENCRYPTION_DATA_UNIT_SIZE;
; 2175 : 				EncryptDataUnits (wipeRandBuffer, &dataUnit, wipeBlockSize / ENCRYPTION_DATA_UNIT_SIZE, wipeCryptoInfo);

  001e5	45 8b cd	 mov	 r9d, r13d
  001e8	48 8b c7	 mov	 rax, rdi
  001eb	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR dataUnit$[rsp]
  001f3	48 99		 cdq
  001f5	33 c9		 xor	 ecx, ecx
  001f7	41 c1 e9 09	 shr	 r9d, 9
  001fb	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00201	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00206	48 03 c2	 add	 rax, rdx
  00209	49 8b d6	 mov	 rdx, r14
  0020c	48 c1 f8 09	 sar	 rax, 9
  00210	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dataUnit$[rsp], rax
  00218	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 2176 : 				memcpy (wipeBuffer, wipeRandBuffer, wipeBlockSize);

  0021d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR wipeBuffer$1$[rsp]
  00225	4d 8b c7	 mov	 r8, r15
  00228	49 8b d6	 mov	 rdx, r14
  0022b	e8 00 00 00 00	 call	 memcpy

; 2177 : 			}
; 2178 : 
; 2179 : 			while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 500)))

  00230	eb 0e		 jmp	 SHORT $LN55@DecoySyste
$LL8@DecoySyste:

; 2180 : 			{
; 2181 : 				if (DecoySystemWipeThreadAbortRequested)

  00232	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeThreadAbortRequested
  00238	85 c0		 test	 eax, eax
  0023a	0f 85 9d 00 00
	00		 jne	 $abort$29005
$LN55@DecoySyste:

; 2177 : 			}
; 2178 : 
; 2179 : 			while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 500)))

  00240	48 8d 4d 50	 lea	 rcx, QWORD PTR [rbp+80]
  00244	ba f4 01 00 00	 mov	 edx, 500		; 000001f4H
  00249	e8 00 00 00 00	 call	 EncryptedIoQueueHoldWhenIdle
  0024e	85 c0		 test	 eax, eax
  00250	78 e0		 js	 SHORT $LL8@DecoySyste

; 2182 : 					goto abort;
; 2183 : 			}
; 2184 : 
; 2185 : 			status = GSTWriteDevice (BootDriveFilterExtension->LowerDeviceObject, wipeBuffer, offset, wipeBlockSize);

  00252	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00259	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR wipeBuffer$1$[rsp]
  00261	4c 8b cf	 mov	 r9, rdi
  00264	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00268	b9 01 00 00 00	 mov	 ecx, 1
  0026d	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  00272	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 2186 : 
; 2187 : 			if (!NT_SUCCESS (status))

  00277	85 c0		 test	 eax, eax
  00279	78 5a		 js	 SHORT $LN57@DecoySyste

; 2191 : 			}
; 2192 : 
; 2193 : 			EncryptedIoQueueResumeFromHold (&Extension->Queue);

  0027b	48 8d 4d 50	 lea	 rcx, QWORD PTR [rbp+80]
  0027f	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold
  00284	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR WipeDecoyRequest
  0028a	ff c6		 inc	 esi
  0028c	e8 00 00 00 00	 call	 GetWipePassCount
  00291	3b f0		 cmp	 esi, eax
  00293	0f 8e 28 ff ff
	ff		 jle	 $LL12@DecoySyste
$LN10@DecoySyste:

; 2194 : 		}
; 2195 : 
; 2196 : 		offset.QuadPart += wipeBlockSize;

  00299	41 8b c5	 mov	 eax, r13d

; 2197 : 
; 2198 : 		KeAcquireSpinLock (&DecoySystemWipeStatusSpinLock, &irql);

  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeStatusSpinLock
  002a3	48 03 f8	 add	 rdi, rax
  002a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc

; 2199 : 		DecoySystemWipedAreaEnd = offset.QuadPart - 1;

  002ac	48 8d 4f ff	 lea	 rcx, QWORD PTR [rdi-1]
  002b0	48 89 0d 00 00
	00 00		 mov	 QWORD PTR DecoySystemWipedAreaEnd, rcx

; 2200 : 		KeReleaseSpinLock (&DecoySystemWipeStatusSpinLock, irql);

  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeStatusSpinLock
  002be	8a d0		 mov	 dl, al
  002c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock
  002c6	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR DecoySystemWipeThreadAbortRequested
  002cd	45 85 db	 test	 r11d, r11d
  002d0	e9 a6 fe ff ff	 jmp	 $LN67@DecoySyste
$LN57@DecoySyste:

; 2188 : 			{
; 2189 : 				DecoySystemWipeResult = status;

  002d5	89 05 00 00 00
	00		 mov	 DWORD PTR DecoySystemWipeResult, eax

; 2190 : 				goto err;

  002db	eb 07		 jmp	 SHORT $err$28980
$abort$29005:

; 2201 : 	}
; 2202 : 
; 2203 : abort:
; 2204 : 	DecoySystemWipeResult = STATUS_SUCCESS;

  002dd	83 25 00 00 00
	00 00		 and	 DWORD PTR DecoySystemWipeResult, 0
$err$28980:

; 2205 : err:
; 2206 : 
; 2207 : 	if (EncryptedIoQueueIsSuspended (&Extension->Queue))

  002e4	8b 85 88 02 00
	00		 mov	 eax, DWORD PTR [rbp+648]
  002ea	85 c0		 test	 eax, eax
  002ec	74 09		 je	 SHORT $LN65@DecoySyste

; 2208 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  002ee	48 8d 4d 50	 lea	 rcx, QWORD PTR [rbp+80]
  002f2	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold
$LN65@DecoySyste:

; 2102 : 
; 2103 : 	CRYPTO_INFO *wipeCryptoInfo = NULL;
; 2104 : 	byte *wipeBuffer = NULL;
; 2105 : 	byte *wipeRandBuffer = NULL;
; 2106 : 	byte wipeRandChars[GST_WIPE_RAND_CHAR_COUNT];
; 2107 : 	int wipePass;
; 2108 : 	int ea = Extension->Queue.CryptoInfo->ea;
; 2109 : 
; 2110 : 	KIRQL irql;
; 2111 : 	NTSTATUS status;
; 2112 : 
; 2113 : 	DecoySystemWipeResult = STATUS_UNSUCCESSFUL;
; 2114 : 
; 2115 : 	wipeBuffer = GSTalloc (GST_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  002f7	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR wipeBuffer$1$[rsp]
$ret$28970:

; 2209 : 
; 2210 : 	Dump ("Wipe end: DecoySystemWipedAreaEnd=%I64d (%I64d)\n", DecoySystemWipedAreaEnd, DecoySystemWipedAreaEnd / 1024 / 1024);
; 2211 : 
; 2212 : ret:
; 2213 : 	if (wipeCryptoInfo)

  002ff	48 85 db	 test	 rbx, rbx
  00302	74 08		 je	 SHORT $LN3@DecoySyste

; 2214 : 		crypto_close (wipeCryptoInfo);

  00304	48 8b cb	 mov	 rcx, rbx
  00307	e8 00 00 00 00	 call	 crypto_close
$LN3@DecoySyste:

; 2215 : 
; 2216 : 	if (wipeRandBuffer)

  0030c	4d 85 f6	 test	 r14, r14
  0030f	74 0e		 je	 SHORT $LN2@DecoySyste

; 2217 : 		GSTfree (wipeRandBuffer);

  00311	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00316	49 8b ce	 mov	 rcx, r14
  00319	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@DecoySyste:

; 2218 : 
; 2219 : 	if (wipeBuffer)
; 2220 : 		GSTfree (wipeBuffer);

  0031f	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00324	48 8b cf	 mov	 rcx, rdi
  00327	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
  0032d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR DecoySystemWipeResult
$LN1@DecoySyste:

; 2221 : 
; 2222 : 	DecoySystemWipeInProgress = FALSE;

  00333	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DecoySystemWipeInProgress, 0

; 2223 : 	PsTerminateSystemThread (DecoySystemWipeResult);
; 2224 : }

  0033d	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00342	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00346	41 5f		 pop	 r15
  00348	41 5e		 pop	 r14
  0034a	41 5d		 pop	 r13
  0034c	41 5c		 pop	 r12
  0034e	5f		 pop	 rdi
  0034f	5e		 pop	 rsi
  00350	5d		 pop	 rbp
  00351	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_PsTerminateSystemThread
$LN63@DecoySyste:

; 2140 : 	{
; 2141 : 		DecoySystemWipeResult = STATUS_INVALID_PARAMETER;

  00358	c7 05 00 00 00
	00 0d 00 00 c0	 mov	 DWORD PTR DecoySystemWipeResult, -1073741811 ; ffffffffc000000dH
  00362	eb 9b		 jmp	 SHORT $ret$28970
DecoySystemWipeThreadProc ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
pdata	SEGMENT
$pdata$SetupThreadProc DD imagerel SetupThreadProc
	DD	imagerel SetupThreadProc+1841
	DD	imagerel $unwind$SetupThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetupThreadProc DD 0a1401H
	DD	0143414H
	DD	0f010b214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT SetupThreadProc
_TEXT	SEGMENT
wipeBuffer$1$ = 48
dataUnit$ = 56
bytesWrittenSinceHeaderUpdate$1$ = 64
timeout$41088 = 72
zeroedSectorCount$28802 = 80
badSectorCount$28809 = 88
threadArg$ = 160
wipeRandChars$ = 168
wipeRandCharsUpdate$ = 176
headerUpdateRequired$1$ = 184
SetupThreadProc PROC					; COMDAT

; 1443 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1444 : 	DriveFilterExtension *Extension = BootDriveFilterExtension;

  00014	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR BootDriveFilterExtension

; 1445 : 
; 1446 : 	LARGE_INTEGER offset;
; 1447 : 	UINT64_STRUCT dataUnit;
; 1448 : 	ULONG setupBlockSize = GST_ENCRYPTION_SETUP_IO_BLOCK_SIZE;
; 1449 : 	BOOL headerUpdateRequired = FALSE;

  0001b	33 ed		 xor	 ebp, ebp
  0001d	be 00 00 18 00	 mov	 esi, 1572864		; 00180000H

; 1450 : 	int64 bytesWrittenSinceHeaderUpdate = 0;
; 1451 : 
; 1452 : 	byte *buffer = NULL;
; 1453 : 	byte *wipeBuffer = NULL;

  00022	48 8b dd	 mov	 rbx, rbp
  00025	89 ac 24 b8 00
	00 00		 mov	 DWORD PTR headerUpdateRequired$1$[rsp], ebp
  0002c	4c 8b f5	 mov	 r14, rbp
  0002f	48 89 6c 24 40	 mov	 QWORD PTR bytesWrittenSinceHeaderUpdate$1$[rsp], rbp

; 1454 : 	byte wipeRandChars[GST_WIPE_RAND_CHAR_COUNT];
; 1455 : 	byte wipeRandCharsUpdate[GST_WIPE_RAND_CHAR_COUNT];
; 1456 : 	
; 1457 : 	KIRQL irql;
; 1458 : 	NTSTATUS status;
; 1459 : 
; 1460 : 	SetupResult = STATUS_UNSUCCESSFUL;

  00034	c7 05 00 00 00
	00 01 00 00 c0	 mov	 DWORD PTR SetupResult, -1073741823 ; ffffffffc0000001H
  0003e	48 89 5c 24 30	 mov	 QWORD PTR wipeBuffer$1$[rsp], rbx

; 1461 : 
; 1462 : 	// Make sure volume header can be updated
; 1463 : 	if (Extension->HeaderCryptoInfo == NULL)

  00043	48 39 af d8 02
	00 00		 cmp	 QWORD PTR [rdi+728], rbp
  0004a	75 0f		 jne	 SHORT $LN67@SetupThrea

; 1464 : 	{
; 1465 : 		SetupResult = STATUS_INVALID_PARAMETER;

  0004c	c7 05 00 00 00
	00 0d 00 00 c0	 mov	 DWORD PTR SetupResult, -1073741811 ; ffffffffc000000dH

; 1466 : 		goto ret;

  00056	e9 ac 06 00 00	 jmp	 $LN1@SetupThrea
$LN67@SetupThrea:

; 1467 : 	}
; 1468 : 
; 1469 : 	buffer = GSTalloc (GST_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  0005b	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00061	48 8b d6	 mov	 rdx, rsi
  00064	33 c9		 xor	 ecx, ecx
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0006c	4c 8b e8	 mov	 r13, rax

; 1470 : 	if (!buffer)

  0006f	48 3b c5	 cmp	 rax, rbp
  00072	75 0f		 jne	 SHORT $LN66@SetupThrea
$LN149@SetupThrea:

; 1471 : 	{
; 1472 : 		SetupResult = STATUS_INSUFFICIENT_RESOURCES;

  00074	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR SetupResult, -1073741670 ; ffffffffc000009aH

; 1473 : 		goto ret;

  0007e	e9 5e 06 00 00	 jmp	 $ret$28753
$LN66@SetupThrea:

; 1474 : 	}
; 1475 : 
; 1476 : 	if (SetupRequest.SetupMode == SetupEncryption && SetupRequest.WipeAlgorithm != GST_WIPE_NONE)

  00083	41 bf 01 00 00
	00		 mov	 r15d, 1
  00089	44 39 3d 00 00
	00 00		 cmp	 DWORD PTR SetupRequest, r15d
  00090	75 26		 jne	 SHORT $LN107@SetupThrea
  00092	39 2d 04 00 00
	00		 cmp	 DWORD PTR SetupRequest+4, ebp
  00098	74 1e		 je	 SHORT $LN107@SetupThrea

; 1477 : 	{
; 1478 : 		wipeBuffer = GSTalloc (GST_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  0009a	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000a0	48 8b d6	 mov	 rdx, rsi
  000a3	33 c9		 xor	 ecx, ecx
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000ab	48 8b d8	 mov	 rbx, rax
  000ae	48 89 44 24 30	 mov	 QWORD PTR wipeBuffer$1$[rsp], rax

; 1479 : 		if (!wipeBuffer)

  000b3	48 3b c5	 cmp	 rax, rbp

; 1480 : 		{
; 1481 : 			SetupResult = STATUS_INSUFFICIENT_RESOURCES;
; 1482 : 			goto ret;

  000b6	74 bc		 je	 SHORT $LN149@SetupThrea
$LN107@SetupThrea:

; 1483 : 		}
; 1484 : 	}
; 1485 : 
; 1486 : 	while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 1000)))

  000b8	4c 8d 67 50	 lea	 r12, QWORD PTR [rdi+80]
  000bc	bb e8 03 00 00	 mov	 ebx, 1000		; 000003e8H
  000c1	eb 11		 jmp	 SHORT $LN144@SetupThrea
$LL63@SetupThrea:

; 1487 : 	{
; 1488 : 		if (EncryptionSetupThreadAbortRequested)

  000c3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EncryptionSetupThreadAbortRequested
  000c9	3b c5		 cmp	 eax, ebp
  000cb	75 4b		 jne	 SHORT $abort$28766

; 1489 : 			goto abort;
; 1490 : 
; 1491 : 		TransformWaitingForIdle = TRUE;

  000cd	44 89 3d 00 00
	00 00		 mov	 DWORD PTR TransformWaitingForIdle, r15d
$LN144@SetupThrea:

; 1483 : 		}
; 1484 : 	}
; 1485 : 
; 1486 : 	while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 1000)))

  000d4	48 8b d3	 mov	 rdx, rbx
  000d7	49 8b cc	 mov	 rcx, r12
  000da	e8 00 00 00 00	 call	 EncryptedIoQueueHoldWhenIdle
  000df	3b c5		 cmp	 eax, ebp
  000e1	7c e0		 jl	 SHORT $LL63@SetupThrea

; 1492 : 	}
; 1493 : 	TransformWaitingForIdle = FALSE;
; 1494 : 
; 1495 : 	switch (SetupRequest.SetupMode)

  000e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR SetupRequest
  000e9	89 2d 00 00 00
	00		 mov	 DWORD PTR TransformWaitingForIdle, ebp
  000ef	41 2b cf	 sub	 ecx, r15d
  000f2	0f 84 a8 00 00
	00		 je	 $LN58@SetupThrea
  000f8	41 3b cf	 cmp	 ecx, r15d
  000fb	75 21		 jne	 SHORT $err$28776

; 1513 : 		}
; 1514 : 
; 1515 : 		break;
; 1516 : 
; 1517 : 	case SetupDecryption:
; 1518 : 		Dump ("Decrypting...\n");
; 1519 : 		if (Extension->Queue.EncryptedAreaStart == -1 || Extension->Queue.EncryptedAreaEnd == -1)

  000fd	48 83 bf c8 00
	00 00 ff	 cmp	 QWORD PTR [rdi+200], -1
  00105	74 11		 je	 SHORT $abort$28766
  00107	48 8b 87 d0 00
	00 00		 mov	 rax, QWORD PTR [rdi+208]
  0010e	48 83 f8 ff	 cmp	 rax, -1
  00112	0f 85 b0 00 00
	00		 jne	 $LN145@SetupThrea
$abort$28766:

; 1707 : 		}
; 1708 : 	}
; 1709 : 
; 1710 : abort:
; 1711 : 	SetupResult = STATUS_SUCCESS;

  00118	89 2d 00 00 00
	00		 mov	 DWORD PTR SetupResult, ebp
$err$28776:

; 1712 : err:
; 1713 : 
; 1714 : 	if (Extension->Queue.EncryptedAreaEnd == -1)

  0011e	48 8b 87 d0 00
	00 00		 mov	 rax, QWORD PTR [rdi+208]
  00125	48 83 ce ff	 or	 rsi, -1
  00129	48 3b c6	 cmp	 rax, rsi
  0012c	75 07		 jne	 SHORT $LN13@SetupThrea

; 1715 : 		Extension->Queue.EncryptedAreaStart = -1;

  0012e	48 89 b7 c8 00
	00 00		 mov	 QWORD PTR [rdi+200], rsi
$LN13@SetupThrea:

; 1716 : 
; 1717 : 	if (EncryptedIoQueueIsSuspended (&Extension->Queue))

  00135	8b 87 88 02 00
	00		 mov	 eax, DWORD PTR [rdi+648]

; 1718 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  0013b	48 8d 5f 50	 lea	 rbx, QWORD PTR [rdi+80]
  0013f	3b c5		 cmp	 eax, ebp
  00141	74 08		 je	 SHORT $LN12@SetupThrea
  00143	48 8b cb	 mov	 rcx, rbx
  00146	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold
$LN12@SetupThrea:

; 1719 : 
; 1720 : 	if (SetupRequest.SetupMode == SetupDecryption && Extension->Queue.EncryptedAreaStart >= Extension->Queue.EncryptedAreaEnd)

  0014b	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR SetupRequest, 2
  00152	0f 85 a7 04 00
	00		 jne	 $LN141@SetupThrea
  00158	48 8b 87 d0 00
	00 00		 mov	 rax, QWORD PTR [rdi+208]
  0015f	48 39 87 c8 00
	00 00		 cmp	 QWORD PTR [rdi+200], rax
  00166	0f 8c 93 04 00
	00		 jl	 $LN141@SetupThrea
$LL10@SetupThrea:

; 1721 : 	{
; 1722 : 		while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 0)));

  0016c	33 d2		 xor	 edx, edx
  0016e	48 8b cb	 mov	 rcx, rbx
  00171	e8 00 00 00 00	 call	 EncryptedIoQueueHoldWhenIdle
  00176	3b c5		 cmp	 eax, ebp
  00178	7c f2		 jl	 SHORT $LL10@SetupThrea

; 1723 : 
; 1724 : 		Extension->ConfiguredEncryptedAreaStart = Extension->ConfiguredEncryptedAreaEnd = -1;

  0017a	48 89 77 40	 mov	 QWORD PTR [rdi+64], rsi
  0017e	48 89 77 38	 mov	 QWORD PTR [rdi+56], rsi

; 1725 : 		Extension->Queue.EncryptedAreaStart = Extension->Queue.EncryptedAreaEnd = -1;
; 1726 : 
; 1727 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  00182	48 8b cb	 mov	 rcx, rbx
  00185	48 89 b7 d0 00
	00 00		 mov	 QWORD PTR [rdi+208], rsi
  0018c	48 89 b7 c8 00
	00 00		 mov	 QWORD PTR [rdi+200], rsi
  00193	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold

; 1728 : 
; 1729 : 		headerUpdateRequired = TRUE;

  00198	45 8b df	 mov	 r11d, r15d
  0019b	e9 67 04 00 00	 jmp	 $LN128@SetupThrea
$LN58@SetupThrea:

; 1496 : 	{
; 1497 : 	case SetupEncryption:
; 1498 : 		Dump ("Encrypting...\n");
; 1499 : 		if (Extension->Queue.EncryptedAreaStart == -1 || Extension->Queue.EncryptedAreaEnd == -1)

  001a0	48 83 bf c8 00
	00 00 ff	 cmp	 QWORD PTR [rdi+200], -1
  001a8	74 2a		 je	 SHORT $LN56@SetupThrea
  001aa	48 8b 87 d0 00
	00 00		 mov	 rax, QWORD PTR [rdi+208]
  001b1	48 83 f8 ff	 cmp	 rax, -1
  001b5	74 1d		 je	 SHORT $LN56@SetupThrea

; 1505 : 		}
; 1506 : 		else
; 1507 : 		{
; 1508 : 			// Resume aborted encryption
; 1509 : 			if (Extension->Queue.EncryptedAreaEnd == Extension->ConfiguredEncryptedAreaEnd)

  001b7	48 8b 87 d0 00
	00 00		 mov	 rax, QWORD PTR [rdi+208]
  001be	48 3b 47 40	 cmp	 rax, QWORD PTR [rdi+64]
  001c2	0f 84 56 ff ff
	ff		 je	 $err$28776
$LN145@SetupThrea:

; 1510 : 				goto err;
; 1511 : 
; 1512 : 			offset.QuadPart = Extension->Queue.EncryptedAreaEnd + 1;

  001c8	48 8b 9f d0 00
	00 00		 mov	 rbx, QWORD PTR [rdi+208]
  001cf	49 03 df	 add	 rbx, r15
  001d2	eb 1a		 jmp	 SHORT $LN55@SetupThrea
$LN56@SetupThrea:

; 1500 : 		{
; 1501 : 			// Start encryption
; 1502 : 			Extension->Queue.EncryptedAreaStart = Extension->ConfiguredEncryptedAreaStart;

  001d4	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1503 : 			Extension->Queue.EncryptedAreaEnd = -1;
; 1504 : 			offset.QuadPart = Extension->ConfiguredEncryptedAreaStart;

  001d8	48 8b 5f 38	 mov	 rbx, QWORD PTR [rdi+56]
  001dc	48 89 87 c8 00
	00 00		 mov	 QWORD PTR [rdi+200], rax
  001e3	48 c7 87 d0 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rdi+208], -1
$LN55@SetupThrea:

; 1520 : 		{
; 1521 : 			SetupResult = STATUS_SUCCESS;
; 1522 : 			goto abort;
; 1523 : 		}
; 1524 : 
; 1525 : 		offset.QuadPart = Extension->Queue.EncryptedAreaEnd + 1;
; 1526 : 		break;
; 1527 : 
; 1528 : 	default:
; 1529 : 		goto err;
; 1530 : 	}
; 1531 : 
; 1532 : 	EncryptedIoQueueResumeFromHold (&Extension->Queue);

  001ee	49 8b cc	 mov	 rcx, r12
  001f1	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold

; 1533 : 		
; 1534 : 	Dump ("EncryptedAreaStart=%I64d\n", Extension->Queue.EncryptedAreaStart);
; 1535 : 	Dump ("EncryptedAreaEnd=%I64d\n", Extension->Queue.EncryptedAreaEnd);
; 1536 : 	Dump ("ConfiguredEncryptedAreaStart=%I64d\n", Extension->ConfiguredEncryptedAreaStart);
; 1537 : 	Dump ("ConfiguredEncryptedAreaEnd=%I64d\n", Extension->ConfiguredEncryptedAreaEnd);
; 1538 : 	Dump ("offset=%I64d\n", offset.QuadPart);
; 1539 : 	Dump ("EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024);
; 1540 : 
; 1541 : 	while (!EncryptionSetupThreadAbortRequested)

  001f6	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR EncryptionSetupThreadAbortRequested
  001fd	44 3b dd	 cmp	 r11d, ebp
$LN147@SetupThrea:
  00200	0f 85 12 ff ff
	ff		 jne	 $abort$28766

; 1542 : 	{
; 1543 : 		if (SetupRequest.SetupMode == SetupEncryption)

  00206	44 39 3d 00 00
	00 00		 cmp	 DWORD PTR SetupRequest, r15d
  0020d	75 24		 jne	 SHORT $LN47@SetupThrea

; 1544 : 		{
; 1545 : 			if (offset.QuadPart + setupBlockSize > Extension->ConfiguredEncryptedAreaEnd + 1)

  0020f	48 8b 57 40	 mov	 rdx, QWORD PTR [rdi+64]
  00213	8b ce		 mov	 ecx, esi
  00215	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00219	48 03 cb	 add	 rcx, rbx
  0021c	48 3b c8	 cmp	 rcx, rax
  0021f	7e 07		 jle	 SHORT $LN46@SetupThrea

; 1546 : 				setupBlockSize = (ULONG) (Extension->ConfiguredEncryptedAreaEnd + 1 - offset.QuadPart);

  00221	8b f2		 mov	 esi, edx
  00223	2b f3		 sub	 esi, ebx
  00225	41 03 f7	 add	 esi, r15d
$LN46@SetupThrea:

; 1547 : 
; 1548 : 			if (offset.QuadPart > Extension->ConfiguredEncryptedAreaEnd)

  00228	48 3b da	 cmp	 rbx, rdx
  0022b	0f 8f e7 fe ff
	ff		 jg	 $abort$28766

; 1549 : 				break;
; 1550 : 		}
; 1551 : 		else

  00231	eb 45		 jmp	 SHORT $LN109@SetupThrea
$LN47@SetupThrea:

; 1552 : 		{
; 1553 : 			if (offset.QuadPart - setupBlockSize < Extension->Queue.EncryptedAreaStart)

  00233	48 8b 97 c8 00
	00 00		 mov	 rdx, QWORD PTR [rdi+200]
  0023a	8b c6		 mov	 eax, esi
  0023c	48 8b cb	 mov	 rcx, rbx
  0023f	48 2b c8	 sub	 rcx, rax
  00242	48 3b ca	 cmp	 rcx, rdx
  00245	7d 04		 jge	 SHORT $LN43@SetupThrea

; 1554 : 				setupBlockSize = (ULONG) (offset.QuadPart - Extension->Queue.EncryptedAreaStart);

  00247	8b f3		 mov	 esi, ebx
  00249	2b f2		 sub	 esi, edx
$LN43@SetupThrea:

; 1555 : 
; 1556 : 			offset.QuadPart -= setupBlockSize;

  0024b	8b c6		 mov	 eax, esi
  0024d	48 2b d8	 sub	 rbx, rax

; 1557 : 
; 1558 : 			if (setupBlockSize == 0 || offset.QuadPart < Extension->Queue.EncryptedAreaStart)

  00250	3b f5		 cmp	 esi, ebp
  00252	0f 84 c0 fe ff
	ff		 je	 $abort$28766
  00258	48 3b da	 cmp	 rbx, rdx
  0025b	0f 8c b7 fe ff
	ff		 jl	 $abort$28766

; 1559 : 				break;
; 1560 : 		}
; 1561 : 
; 1562 : 		while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 500)))

  00261	eb 15		 jmp	 SHORT $LN109@SetupThrea
$LL40@SetupThrea:

; 1563 : 		{
; 1564 : 			if (EncryptionSetupThreadAbortRequested)

  00263	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EncryptionSetupThreadAbortRequested
  00269	3b c5		 cmp	 eax, ebp
  0026b	0f 85 a7 fe ff
	ff		 jne	 $abort$28766

; 1565 : 				goto abort;
; 1566 : 
; 1567 : 			TransformWaitingForIdle = TRUE;

  00271	44 89 3d 00 00
	00 00		 mov	 DWORD PTR TransformWaitingForIdle, r15d
$LN109@SetupThrea:

; 1559 : 				break;
; 1560 : 		}
; 1561 : 
; 1562 : 		while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 500)))

  00278	ba f4 01 00 00	 mov	 edx, 500		; 000001f4H
  0027d	49 8b cc	 mov	 rcx, r12
  00280	e8 00 00 00 00	 call	 EncryptedIoQueueHoldWhenIdle
  00285	3b c5		 cmp	 eax, ebp
  00287	7c da		 jl	 SHORT $LL40@SetupThrea

; 1568 : 		}
; 1569 : 		TransformWaitingForIdle = FALSE;
; 1570 : 
; 1571 : 		status = GSTReadDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  00289	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00290	4c 8b cb	 mov	 r9, rbx
  00293	4d 8b c5	 mov	 r8, r13
  00296	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0029a	33 c9		 xor	 ecx, ecx
  0029c	89 2d 00 00 00
	00		 mov	 DWORD PTR TransformWaitingForIdle, ebp
  002a2	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  002a6	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 1572 : 		if (!NT_SUCCESS (status))

  002ab	3b c5		 cmp	 eax, ebp
  002ad	0f 8d 94 00 00
	00		 jge	 $LN31@SetupThrea

; 1573 : 		{
; 1574 : 			Dump ("GSTReadDevice error %x  offset=%I64d\n", status, offset.QuadPart);
; 1575 : 
; 1576 : 			if (SetupRequest.ZeroUnreadableSectors && SetupRequest.SetupMode == SetupEncryption)

  002b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR SetupRequest
  002b9	39 2d 08 00 00
	00		 cmp	 DWORD PTR SetupRequest+8, ebp
  002bf	74 46		 je	 SHORT $LN36@SetupThrea
  002c1	41 3b cf	 cmp	 ecx, r15d
  002c4	75 41		 jne	 SHORT $LN36@SetupThrea

; 1577 : 			{
; 1578 : 				// Zero unreadable sectors
; 1579 : 				uint64 zeroedSectorCount;
; 1580 : 
; 1581 : 				status = ZeroUnreadableSectors (BootDriveFilterExtension->LowerDeviceObject, offset, setupBlockSize, &zeroedSectorCount);

  002c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  002cd	4c 8d 4c 24 50	 lea	 r9, QWORD PTR zeroedSectorCount$28802[rsp]
  002d2	44 8b c6	 mov	 r8d, esi
  002d5	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  002d9	48 8b d3	 mov	 rdx, rbx
  002dc	e8 00 00 00 00	 call	 ZeroUnreadableSectors

; 1582 : 				if (!NT_SUCCESS (status))

  002e1	3b c5		 cmp	 eax, ebp
  002e3	0f 8c 90 02 00
	00		 jl	 $LN119@SetupThrea

; 1586 : 				}
; 1587 : 
; 1588 : 				// Retry read
; 1589 : 				status = GSTReadDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  002e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  002f0	4c 8b cb	 mov	 r9, rbx
  002f3	4d 8b c5	 mov	 r8, r13
  002f6	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  002fa	33 c9		 xor	 ecx, ecx
  002fc	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00300	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 1590 : 				if (!NT_SUCCESS (status))
; 1591 : 				{
; 1592 : 					SetupResult = status;
; 1593 : 					goto err;
; 1594 : 				}

  00305	eb 38		 jmp	 SHORT $LN150@SetupThrea
$LN36@SetupThrea:

; 1595 : 			}
; 1596 : /**
; 1597 :  *
; 1598 :  *	\fn else if (SetupRequest.DiscardUnreadableEncryptedSectors && SetupRequest.SetupMode == SetupDecryption)
; 1599 :  *	\brief
; 1600 :  *	\param[in] SetupRequest.DiscardUnreadableEncryptedSectors &&
; 1601 :  *	\return
; 1602 :  *
; 1603 :  */
; 1604 : 			else if (SetupRequest.DiscardUnreadableEncryptedSectors && SetupRequest.SetupMode == SetupDecryption)

  00307	39 2d 0c 00 00
	00		 cmp	 DWORD PTR SetupRequest+12, ebp
  0030d	0f 84 66 02 00
	00		 je	 $LN119@SetupThrea
  00313	83 f9 02	 cmp	 ecx, 2
  00316	0f 85 5d 02 00
	00		 jne	 $LN119@SetupThrea

; 1605 : 			{
; 1606 : 				// Discard unreadable encrypted sectors
; 1607 : 				uint64 badSectorCount;
; 1608 : 
; 1609 : 				status = ReadDeviceSkipUnreadableSectors (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize, &badSectorCount);

  0031c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00323	48 8d 44 24 58	 lea	 rax, QWORD PTR badSectorCount$28809[rsp]
  00328	44 8b ce	 mov	 r9d, esi
  0032b	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0032f	4c 8b c3	 mov	 r8, rbx
  00332	49 8b d5	 mov	 rdx, r13
  00335	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033a	e8 00 00 00 00	 call	 ReadDeviceSkipUnreadableSectors
$LN150@SetupThrea:

; 1610 : 				if (!NT_SUCCESS (status))

  0033f	3b c5		 cmp	 eax, ebp
  00341	0f 8c 32 02 00
	00		 jl	 $LN119@SetupThrea
$LN31@SetupThrea:

; 1611 : 				{
; 1612 : 					SetupResult = status;
; 1613 : 					goto err;
; 1614 : 				}
; 1615 : 			}
; 1616 : 			else
; 1617 : 			{
; 1618 : 				SetupResult = status;
; 1619 : 				goto err;
; 1620 : 			}
; 1621 : 		}
; 1622 : 
; 1623 : 		dataUnit.Value = offset.QuadPart / ENCRYPTION_DATA_UNIT_SIZE;

  00347	48 8b c3	 mov	 rax, rbx

; 1624 : 
; 1625 : 		if (SetupRequest.SetupMode == SetupEncryption)
; 1626 : 		{
; 1627 : 			EncryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  0034a	4c 8d 44 24 38	 lea	 r8, QWORD PTR dataUnit$[rsp]
  0034f	48 99		 cdq
  00351	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00357	48 03 c2	 add	 rax, rdx
  0035a	49 8b d5	 mov	 rdx, r13
  0035d	48 c1 f8 09	 sar	 rax, 9
  00361	48 89 44 24 38	 mov	 QWORD PTR dataUnit$[rsp], rax
  00366	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  0036d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00372	44 39 3d 00 00
	00 00		 cmp	 DWORD PTR SetupRequest, r15d
  00379	0f 85 e6 01 00
	00		 jne	 $LN29@SetupThrea
  0037f	44 8b fe	 mov	 r15d, esi
  00382	33 c9		 xor	 ecx, ecx
  00384	41 c1 ef 09	 shr	 r15d, 9
  00388	45 8b cf	 mov	 r9d, r15d
  0038b	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 1628 : 
; 1629 : 			if (SetupRequest.WipeAlgorithm != GST_WIPE_NONE)

  00390	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR SetupRequest+4
  00396	3b cd		 cmp	 ecx, ebp
  00398	0f 84 00 01 00
	00		 je	 $LN142@SetupThrea

; 1630 : 			{
; 1631 : 				byte wipePass;
; 1632 : 				for (wipePass = 1; wipePass <= GetWipePassCount (SetupRequest.WipeAlgorithm); ++wipePass)

  0039e	41 b4 01	 mov	 r12b, 1
  003a1	e8 00 00 00 00	 call	 GetWipePassCount
  003a6	83 f8 01	 cmp	 eax, 1
  003a9	0f 8c cf 00 00
	00		 jl	 $LN25@SetupThrea
  003af	bd 01 00 00 00	 mov	 ebp, 1
  003b4	44 8b f6	 mov	 r14d, esi
$LL27@SetupThrea:

; 1633 : 				{
; 1634 : 					if (!WipeBuffer (SetupRequest.WipeAlgorithm, wipeRandChars, wipePass, wipeBuffer, setupBlockSize))

  003b7	4c 8b 4c 24 30	 mov	 r9, QWORD PTR wipeBuffer$1$[rsp]
  003bc	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR SetupRequest+4
  003c2	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR wipeRandChars$[rsp]
  003ca	44 8b c5	 mov	 r8d, ebp
  003cd	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  003d2	e8 00 00 00 00	 call	 WipeBuffer

; 1635 : 					{
; 1636 : 						ULONG i;
; 1637 : 						for (i = 0; i < setupBlockSize; ++i)

  003d7	48 8b 6c 24 30	 mov	 rbp, QWORD PTR wipeBuffer$1$[rsp]
  003dc	85 c0		 test	 eax, eax
  003de	75 56		 jne	 SHORT $LN24@SetupThrea
  003e0	85 f6		 test	 esi, esi
  003e2	74 1d		 je	 SHORT $LN21@SetupThrea
  003e4	49 8b d5	 mov	 rdx, r13
  003e7	48 8b cd	 mov	 rcx, rbp
  003ea	4d 8b c6	 mov	 r8, r14
  003ed	48 2b d5	 sub	 rdx, rbp
$LL23@SetupThrea:

; 1638 : 						{
; 1639 : 							wipeBuffer[i] = buffer[i] + wipePass;

  003f0	8a 04 0a	 mov	 al, BYTE PTR [rdx+rcx]
  003f3	41 02 c4	 add	 al, r12b
  003f6	88 01		 mov	 BYTE PTR [rcx], al
  003f8	48 ff c1	 inc	 rcx
  003fb	49 83 e8 01	 sub	 r8, 1
  003ff	75 ef		 jne	 SHORT $LL23@SetupThrea
$LN21@SetupThrea:

; 1640 : 						}
; 1641 : 
; 1642 : 						EncryptDataUnits (wipeBuffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  00401	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  00408	4c 8d 44 24 38	 lea	 r8, QWORD PTR dataUnit$[rsp]
  0040d	45 8b cf	 mov	 r9d, r15d
  00410	48 8b d5	 mov	 rdx, rbp
  00413	33 c9		 xor	 ecx, ecx
  00415	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0041a	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 1643 : 						memcpy (wipeRandCharsUpdate, wipeBuffer, sizeof (wipeRandCharsUpdate)); 

  0041f	0f b7 45 00	 movzx	 eax, WORD PTR [rbp]
  00423	4c 8d 9c 24 b0
	00 00 00	 lea	 r11, QWORD PTR wipeRandCharsUpdate$[rsp]
  0042b	66 41 89 03	 mov	 WORD PTR [r11], ax
  0042f	8a 45 02	 mov	 al, BYTE PTR [rbp+2]
  00432	41 88 43 02	 mov	 BYTE PTR [r11+2], al
$LN24@SetupThrea:

; 1644 : 					}
; 1645 : 
; 1646 : 					status = GSTWriteDevice (BootDriveFilterExtension->LowerDeviceObject, wipeBuffer, offset, setupBlockSize);

  00436	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0043d	4c 8b cb	 mov	 r9, rbx
  00440	4c 8b c5	 mov	 r8, rbp
  00443	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00447	b9 01 00 00 00	 mov	 ecx, 1
  0044c	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00450	e8 00 00 00 00	 call	 GSTReadWriteDevice
  00455	8b e8		 mov	 ebp, eax

; 1647 : 					if (!NT_SUCCESS (status))

  00457	85 c0		 test	 eax, eax
  00459	0f 88 25 01 00
	00		 js	 $LN116@SetupThrea
  0045f	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR SetupRequest+4
  00465	41 fe c4	 inc	 r12b
  00468	41 0f b6 ec	 movzx	 ebp, r12b
  0046c	e8 00 00 00 00	 call	 GetWipePassCount
  00471	3b e8		 cmp	 ebp, eax
  00473	0f 8e 3e ff ff
	ff		 jle	 $LL27@SetupThrea
  00479	4c 8b 74 24 40	 mov	 r14, QWORD PTR bytesWrittenSinceHeaderUpdate$1$[rsp]
$LN25@SetupThrea:

; 1655 : 					}
; 1656 : 				}
; 1657 : 
; 1658 : 				memcpy (wipeRandChars, wipeRandCharsUpdate, sizeof (wipeRandCharsUpdate)); 

  0047e	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR wipeRandCharsUpdate$[rsp]
  00486	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR wipeRandChars$[rsp]

; 1659 : 			}
; 1660 : 		}
; 1661 : 		else

  0048e	4c 8d 67 50	 lea	 r12, QWORD PTR [rdi+80]
  00492	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00495	66 89 02	 mov	 WORD PTR [rdx], ax
  00498	8a 41 02	 mov	 al, BYTE PTR [rcx+2]
  0049b	88 42 02	 mov	 BYTE PTR [rdx+2], al
$LN142@SetupThrea:

; 1706 : 			bytesWrittenSinceHeaderUpdate = 0;

  0049e	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1662 : 		{
; 1663 : 			DecryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

$LN84@SetupThrea:

; 1664 : 		}
; 1665 : 
; 1666 : 		status = GSTWriteDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  004a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  004ab	4c 8b cb	 mov	 r9, rbx
  004ae	4d 8b c5	 mov	 r8, r13
  004b1	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  004b5	41 8b cf	 mov	 ecx, r15d
  004b8	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  004bc	e8 00 00 00 00	 call	 GSTReadWriteDevice
  004c1	8b e8		 mov	 ebp, eax

; 1667 : 		if (!NT_SUCCESS (status))

  004c3	85 c0		 test	 eax, eax
  004c5	0f 88 0c 01 00
	00		 js	 $LN122@SetupThrea

; 1681 : 		}
; 1682 : 
; 1683 : 		if (SetupRequest.SetupMode == SetupEncryption)

  004cb	44 39 3d 00 00
	00 00		 cmp	 DWORD PTR SetupRequest, r15d
  004d2	75 05		 jne	 SHORT $LN15@SetupThrea

; 1684 : 			offset.QuadPart += setupBlockSize;

  004d4	8b c6		 mov	 eax, esi
  004d6	48 03 d8	 add	 rbx, rax
$LN15@SetupThrea:

; 1685 : 
; 1686 : 		Extension->Queue.EncryptedAreaEndUpdatePending = TRUE;

  004d9	44 89 bf d8 00
	00 00		 mov	 DWORD PTR [rdi+216], r15d

; 1687 : 		Extension->Queue.EncryptedAreaEnd = offset.QuadPart - 1;

  004e0	48 8d 43 ff	 lea	 rax, QWORD PTR [rbx-1]

; 1688 : 		Extension->Queue.EncryptedAreaEndUpdatePending = FALSE;

  004e4	33 ed		 xor	 ebp, ebp
  004e6	48 89 87 d0 00
	00 00		 mov	 QWORD PTR [rdi+208], rax
  004ed	89 af d8 00 00
	00		 mov	 DWORD PTR [rdi+216], ebp

; 1689 : 
; 1690 : 		headerUpdateRequired = TRUE;
; 1691 : 
; 1692 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  004f3	49 8b cc	 mov	 rcx, r12
  004f6	44 89 bc 24 b8
	00 00 00	 mov	 DWORD PTR headerUpdateRequired$1$[rsp], r15d
  004fe	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold

; 1693 : 
; 1694 : 		KeAcquireSpinLock (&SetupStatusSpinLock, &irql);

  00503	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupStatusSpinLock
  0050a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc

; 1695 : 		SetupStatusEncryptedAreaEnd = Extension->Queue.EncryptedAreaEnd;

  00510	48 8b 8f d0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+208]
  00517	48 89 0d 00 00
	00 00		 mov	 QWORD PTR SetupStatusEncryptedAreaEnd, rcx

; 1696 : 		KeReleaseSpinLock (&SetupStatusSpinLock, irql);

  0051e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupStatusSpinLock
  00525	8a d0		 mov	 dl, al
  00527	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 1697 : 
; 1698 : 		// Update volume header
; 1699 : 		bytesWrittenSinceHeaderUpdate += setupBlockSize;

  0052d	44 8b de	 mov	 r11d, esi
  00530	4d 03 f3	 add	 r14, r11

; 1700 : 		if (bytesWrittenSinceHeaderUpdate >= GST_ENCRYPTION_SETUP_HEADER_UPDATE_THRESHOLD)

  00533	49 81 fe 00 00
	00 04		 cmp	 r14, 67108864		; 04000000H
  0053a	4c 89 74 24 40	 mov	 QWORD PTR bytesWrittenSinceHeaderUpdate$1$[rsp], r14
  0053f	7c 17		 jl	 SHORT $LN14@SetupThrea

; 1701 : 		{
; 1702 : 			status = SaveDriveVolumeHeader (Extension);

  00541	48 8b cf	 mov	 rcx, rdi
  00544	e8 00 00 00 00	 call	 SaveDriveVolumeHeader

; 1703 : 			ASSERT (NT_SUCCESS (status));
; 1704 : 
; 1705 : 			headerUpdateRequired = FALSE;

  00549	89 ac 24 b8 00
	00 00		 mov	 DWORD PTR headerUpdateRequired$1$[rsp], ebp

; 1706 : 			bytesWrittenSinceHeaderUpdate = 0;

  00550	4c 8b f5	 mov	 r14, rbp
  00553	48 89 6c 24 40	 mov	 QWORD PTR bytesWrittenSinceHeaderUpdate$1$[rsp], rbp
$LN14@SetupThrea:
  00558	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EncryptionSetupThreadAbortRequested
  0055e	3b c5		 cmp	 eax, ebp
  00560	e9 9b fc ff ff	 jmp	 $LN147@SetupThrea
$LN29@SetupThrea:

; 1662 : 		{
; 1663 : 			DecryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  00565	44 8b ce	 mov	 r9d, esi
  00568	41 8b cf	 mov	 ecx, r15d
  0056b	41 c1 e9 09	 shr	 r9d, 9
  0056f	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork
  00574	e9 2b ff ff ff	 jmp	 $LN84@SetupThrea
$LN119@SetupThrea:

; 1583 : 				{
; 1584 : 					SetupResult = status;

  00579	89 05 00 00 00
	00		 mov	 DWORD PTR SetupResult, eax

; 1585 : 					goto err;

  0057f	e9 9a fb ff ff	 jmp	 $err$28776
$LN116@SetupThrea:

; 1648 : 					{
; 1649 : 						// Undo failed write operation
; 1650 : 						DecryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  00584	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  0058b	44 8b ce	 mov	 r9d, esi
  0058e	4c 8d 44 24 38	 lea	 r8, QWORD PTR dataUnit$[rsp]
  00593	41 c1 e9 09	 shr	 r9d, 9
  00597	49 8b d5	 mov	 rdx, r13
  0059a	41 bf 01 00 00
	00		 mov	 r15d, 1
  005a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
$LN151@SetupThrea:
  005a5	41 8b cf	 mov	 ecx, r15d
$LN148@SetupThrea:
  005a8	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 1651 : 						GSTWriteDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  005ad	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR BootDriveFilterExtension
  005b4	4c 8b cb	 mov	 r9, rbx
  005b7	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  005bb	4d 8b c5	 mov	 r8, r13
  005be	41 8b cf	 mov	 ecx, r15d
  005c1	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  005c5	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 1652 : 
; 1653 : 						SetupResult = status;

  005ca	89 2d 00 00 00
	00		 mov	 DWORD PTR SetupResult, ebp

; 1654 : 						goto err;

  005d0	33 ed		 xor	 ebp, ebp
  005d2	e9 47 fb ff ff	 jmp	 $err$28776
$LN122@SetupThrea:

; 1668 : 		{
; 1669 : 			Dump ("GSTWriteDevice error %x\n", status);
; 1670 : 
; 1671 : 			// Undo failed write operation
; 1672 : 			if (SetupRequest.SetupMode == SetupEncryption)
; 1673 : 				DecryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  005d7	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  005de	44 8b ce	 mov	 r9d, esi
  005e1	4c 8d 44 24 38	 lea	 r8, QWORD PTR dataUnit$[rsp]
  005e6	41 c1 e9 09	 shr	 r9d, 9
  005ea	49 8b d5	 mov	 rdx, r13
  005ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f2	44 39 3d 00 00
	00 00		 cmp	 DWORD PTR SetupRequest, r15d

; 1674 : 			else

  005f9	74 aa		 je	 SHORT $LN151@SetupThrea

; 1675 : 				EncryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  005fb	33 c9		 xor	 ecx, ecx

; 1676 : 
; 1677 : 			GSTWriteDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);
; 1678 : 
; 1679 : 			SetupResult = status;
; 1680 : 			goto err;

  005fd	eb a9		 jmp	 SHORT $LN148@SetupThrea
$LN141@SetupThrea:

; 1477 : 	{
; 1478 : 		wipeBuffer = GSTalloc (GST_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  005ff	44 8b 9c 24 b8
	00 00 00	 mov	 r11d, DWORD PTR headerUpdateRequired$1$[rsp]
$LN128@SetupThrea:

; 1730 : 	}
; 1731 : 
; 1732 : 	Dump ("Setup completed:  EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d (%I64d)\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024, Extension->Queue.EncryptedAreaEnd);
; 1733 : 
; 1734 : 	if (headerUpdateRequired)

  00607	44 3b dd	 cmp	 r11d, ebp
  0060a	74 1d		 je	 SHORT $LN129@SetupThrea

; 1735 : 	{
; 1736 : 		status = SaveDriveVolumeHeader (Extension);

  0060c	48 8b cf	 mov	 rcx, rdi
  0060f	e8 00 00 00 00	 call	 SaveDriveVolumeHeader

; 1737 : 
; 1738 : 		if (!NT_SUCCESS (status) && NT_SUCCESS (SetupResult))

  00614	3b c5		 cmp	 eax, ebp
  00616	7d 11		 jge	 SHORT $LN129@SetupThrea
  00618	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR SetupResult
  0061e	3b cd		 cmp	 ecx, ebp
  00620	0f 4d c8	 cmovge	 ecx, eax
  00623	89 0d 00 00 00
	00		 mov	 DWORD PTR SetupResult, ecx
$LN129@SetupThrea:

; 1739 : 			SetupResult = status;
; 1740 : 	}
; 1741 : 
; 1742 : 	if (SetupRequest.SetupMode == SetupDecryption && Extension->ConfiguredEncryptedAreaEnd == -1 && Extension->DriveMounted)

  00629	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR SetupRequest, 2
  00630	0f 85 a6 00 00
	00		 jne	 $LN139@SetupThrea
  00636	48 39 77 40	 cmp	 QWORD PTR [rdi+64], rsi
  0063a	0f 85 9c 00 00
	00		 jne	 $LN139@SetupThrea
  00640	39 af b8 02 00
	00		 cmp	 DWORD PTR [rdi+696], ebp
  00646	0f 84 90 00 00
	00		 je	 $LN139@SetupThrea
$LL5@SetupThrea:

; 1743 : 	{
; 1744 : 		while (!RootDeviceControlMutexAcquireNoWait() && !EncryptionSetupThreadAbortRequested)

  0064c	48 8d 44 24 48	 lea	 rax, QWORD PTR timeout$41088[rsp]
  00651	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00658	45 33 c9	 xor	 r9d, r9d
  0065b	45 33 c0	 xor	 r8d, r8d
  0065e	33 d2		 xor	 edx, edx
  00660	48 89 6c 24 48	 mov	 QWORD PTR timeout$41088[rsp], rbp
  00665	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0066a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00670	3b c5		 cmp	 eax, ebp
  00672	7c 07		 jl	 SHORT $LN98@SetupThrea
  00674	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  00679	75 16		 jne	 SHORT $LN127@SetupThrea
$LN98@SetupThrea:
  0067b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EncryptionSetupThreadAbortRequested
  00681	3b c5		 cmp	 eax, ebp
  00683	75 0c		 jne	 SHORT $LN127@SetupThrea

; 1745 : 		{
; 1746 : 			GSTSleep (10);

  00685	b9 0a 00 00 00	 mov	 ecx, 10
  0068a	e8 00 00 00 00	 call	 GSTSleep

; 1747 : 		}

  0068f	eb bb		 jmp	 SHORT $LL5@SetupThrea
$LN127@SetupThrea:

; 1748 : 
; 1749 : 		// Disable hibernation (resume would fail due to a change in the system memory map)
; 1750 : 		HibernationEnabled = FALSE;
; 1751 : 
; 1752 : 		DismountDrive (Extension, FALSE);

  00691	48 8b 8f 98 00
	00 00		 mov	 rcx, QWORD PTR [rdi+152]
  00698	89 2d 00 00 00
	00		 mov	 DWORD PTR HibernationEnabled, ebp
  0069e	e8 00 00 00 00	 call	 crypto_close
  006a3	48 8b 8f d8 02
	00 00		 mov	 rcx, QWORD PTR [rdi+728]
  006aa	48 89 af 98 00
	00 00		 mov	 QWORD PTR [rdi+152], rbp
  006b1	e8 00 00 00 00	 call	 crypto_close

; 1753 : 
; 1754 : 		if (!EncryptionSetupThreadAbortRequested)

  006b6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EncryptionSetupThreadAbortRequested
  006bc	48 89 af d8 02
	00 00		 mov	 QWORD PTR [rdi+728], rbp
  006c3	89 af b8 02 00
	00		 mov	 DWORD PTR [rdi+696], ebp
  006c9	3b c5		 cmp	 eax, ebp
  006cb	75 0f		 jne	 SHORT $LN139@SetupThrea

; 1755 : 			RootDeviceControlMutexRelease();

  006cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  006d4	33 d2		 xor	 edx, edx
  006d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex
$LN139@SetupThrea:

; 1477 : 	{
; 1478 : 		wipeBuffer = GSTalloc (GST_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  006dc	48 8b 5c 24 30	 mov	 rbx, QWORD PTR wipeBuffer$1$[rsp]
$ret$28753:

; 1756 : 	}
; 1757 : 
; 1758 : ret:
; 1759 : 	if (buffer)

  006e1	4c 3b ed	 cmp	 r13, rbp
  006e4	74 0e		 je	 SHORT $LN2@SetupThrea

; 1760 : 		GSTfree (buffer);

  006e6	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  006eb	49 8b cd	 mov	 rcx, r13
  006ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@SetupThrea:

; 1761 : 	if (wipeBuffer)

  006f4	48 3b dd	 cmp	 rbx, rbp
  006f7	74 0e		 je	 SHORT $LN1@SetupThrea

; 1762 : 		GSTfree (wipeBuffer);

  006f9	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  006fe	48 8b cb	 mov	 rcx, rbx
  00701	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN1@SetupThrea:

; 1763 : 
; 1764 : 	SetupInProgress = FALSE;
; 1765 : 	PsTerminateSystemThread (SetupResult);

  00707	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR SetupResult
  0070d	89 2d 00 00 00
	00		 mov	 DWORD PTR SetupInProgress, ebp

; 1766 : }

  00713	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  0071b	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0071f	41 5f		 pop	 r15
  00721	41 5e		 pop	 r14
  00723	41 5d		 pop	 r13
  00725	41 5c		 pop	 r12
  00727	5f		 pop	 rdi
  00728	5e		 pop	 rsi
  00729	5d		 pop	 rbp
  0072a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_PsTerminateSystemThread
SetupThreadProc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionBFilter2 DD imagerel HiberDriverWriteFunctionBFilter2
	DD	imagerel HiberDriverWriteFunctionBFilter2+41
	DD	imagerel $unwind$HiberDriverWriteFunctionBFilter2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionBFilter2 DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionBFilter2
_TEXT	SEGMENT
writeOffset$ = 64
dataMdl$ = 72
HiberDriverWriteFunctionBFilter2 PROC			; COMDAT

; 1182 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1183 : 	return HiberDriverWriteFunctionFilter (2, writeOffset, dataMdl, TRUE, 0, NULL);

  00004	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  0000a	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  0000f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00015	4c 8b c2	 mov	 r8, rdx
  00018	48 8b d1	 mov	 rdx, rcx
  0001b	41 8d 49 01	 lea	 ecx, QWORD PTR [r9+1]
  0001f	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 1184 : }

  00024	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00028	c3		 ret	 0
HiberDriverWriteFunctionBFilter2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionBFilter1 DD imagerel HiberDriverWriteFunctionBFilter1
	DD	imagerel HiberDriverWriteFunctionBFilter1+41
	DD	imagerel $unwind$HiberDriverWriteFunctionBFilter1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionBFilter1 DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionBFilter1
_TEXT	SEGMENT
writeOffset$ = 64
dataMdl$ = 72
HiberDriverWriteFunctionBFilter1 PROC			; COMDAT

; 1168 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1169 : 	return HiberDriverWriteFunctionFilter (1, writeOffset, dataMdl, TRUE, 0, NULL);

  00004	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  0000a	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  0000f	b8 01 00 00 00	 mov	 eax, 1
  00014	4c 8b c2	 mov	 r8, rdx
  00017	48 8b d1	 mov	 rdx, rcx
  0001a	44 8b c8	 mov	 r9d, eax
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 1170 : }

  00024	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00028	c3		 ret	 0
HiberDriverWriteFunctionBFilter1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionBFilter0 DD imagerel HiberDriverWriteFunctionBFilter0
	DD	imagerel HiberDriverWriteFunctionBFilter0+39
	DD	imagerel $unwind$HiberDriverWriteFunctionBFilter0
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionBFilter0 DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionBFilter0
_TEXT	SEGMENT
writeOffset$ = 64
dataMdl$ = 72
HiberDriverWriteFunctionBFilter0 PROC			; COMDAT

; 1154 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1155 : 	return HiberDriverWriteFunctionFilter (0, writeOffset, dataMdl, TRUE, 0, NULL);

  00004	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  0000a	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  0000f	4c 8b c2	 mov	 r8, rdx
  00012	48 8b d1	 mov	 rdx, rcx
  00015	41 b9 01 00 00
	00		 mov	 r9d, 1
  0001b	33 c9		 xor	 ecx, ecx
  0001d	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 1156 : }

  00022	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00026	c3		 ret	 0
HiberDriverWriteFunctionBFilter0 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionAFilter2 DD imagerel HiberDriverWriteFunctionAFilter2
	DD	imagerel HiberDriverWriteFunctionAFilter2+30
	DD	imagerel $unwind$HiberDriverWriteFunctionAFilter2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionAFilter2 DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionAFilter2
_TEXT	SEGMENT
arg0$ = 64
writeOffset$ = 72
dataMdl$ = 80
arg3$ = 88
HiberDriverWriteFunctionAFilter2 PROC			; COMDAT

; 1139 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1140 : 	return HiberDriverWriteFunctionFilter (2, writeOffset, dataMdl, FALSE, arg0, arg3);

  00004	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  00009	45 33 c9	 xor	 r9d, r9d
  0000c	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00010	41 8d 49 02	 lea	 ecx, QWORD PTR [r9+2]
  00014	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 1141 : }

  00019	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001d	c3		 ret	 0
HiberDriverWriteFunctionAFilter2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionAFilter1 DD imagerel HiberDriverWriteFunctionAFilter1
	DD	imagerel HiberDriverWriteFunctionAFilter1+30
	DD	imagerel $unwind$HiberDriverWriteFunctionAFilter1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionAFilter1 DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionAFilter1
_TEXT	SEGMENT
arg0$ = 64
writeOffset$ = 72
dataMdl$ = 80
arg3$ = 88
HiberDriverWriteFunctionAFilter1 PROC			; COMDAT

; 1123 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1124 : 	return HiberDriverWriteFunctionFilter (1, writeOffset, dataMdl, FALSE, arg0, arg3);

  00004	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  00009	45 33 c9	 xor	 r9d, r9d
  0000c	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00010	41 8d 49 01	 lea	 ecx, QWORD PTR [r9+1]
  00014	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 1125 : }

  00019	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001d	c3		 ret	 0
HiberDriverWriteFunctionAFilter1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionAFilter0 DD imagerel HiberDriverWriteFunctionAFilter0
	DD	imagerel HiberDriverWriteFunctionAFilter0+28
	DD	imagerel $unwind$HiberDriverWriteFunctionAFilter0
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionAFilter0 DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionAFilter0
_TEXT	SEGMENT
arg0$ = 64
writeOffset$ = 72
dataMdl$ = 80
arg3$ = 88
HiberDriverWriteFunctionAFilter0 PROC			; COMDAT

; 1107 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1108 : 	return HiberDriverWriteFunctionFilter (0, writeOffset, dataMdl, FALSE, arg0, arg3);

  00004	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  00009	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0000d	33 c9		 xor	 ecx, ecx
  0000f	45 33 c9	 xor	 r9d, r9d
  00012	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 1109 : }

  00017	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001b	c3		 ret	 0
HiberDriverWriteFunctionAFilter0 ENDP
PUBLIC	StartDecoySystemWipe
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$StartDecoySystemWipe DD imagerel $LN26
	DD	imagerel $LN26+272
	DD	imagerel $unwind$StartDecoySystemWipe
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StartDecoySystemWipe DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT StartDecoySystemWipe
_TEXT	SEGMENT
DeviceObject$ = 48
irp$ = 56
irpSp$ = 64
StartDecoySystemWipe PROC				; COMDAT

; 2238 : {

$LN26:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 2239 : 	NTSTATUS status;
; 2240 : 	WipeDecoySystemRequest *request;
; 2241 : 
; 2242 : 	if (!UserCanAccessDriveDevice())

  00018	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN11@StartDecoy

; 2243 : 		return STATUS_ACCESS_DENIED;

  00021	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00026	e9 d5 00 00 00	 jmp	 $LN12@StartDecoy
$LN11@StartDecoy:

; 2244 : 
; 2245 : 	if (!IsHiddenSystemRunning()
; 2246 : 		|| irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (WipeDecoySystemRequest))

  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00032	48 85 c0	 test	 rax, rax
  00035	0f 84 c0 00 00
	00		 je	 $LN9@StartDecoy
  0003b	83 b8 e0 02 00
	00 00		 cmp	 DWORD PTR [rax+736], 0
  00042	0f 84 b3 00 00
	00		 je	 $LN9@StartDecoy
  00048	81 7f 10 04 01
	00 00		 cmp	 DWORD PTR [rdi+16], 260	; 00000104H
  0004f	0f 82 a6 00 00
	00		 jb	 $LN9@StartDecoy

; 2248 : 
; 2249 : 	if (DecoySystemWipeInProgress)

  00055	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeInProgress
  0005b	85 c0		 test	 eax, eax
  0005d	74 07		 je	 SHORT $LN8@StartDecoy

; 2250 : 		return STATUS_SUCCESS;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 9a 00 00 00	 jmp	 $LN12@StartDecoy
$LN8@StartDecoy:

; 2251 : 
; 2252 : 	if (DecoySystemWipeThread)

  00066	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR DecoySystemWipeThread, 0
  0006e	74 05		 je	 SHORT $LN7@StartDecoy

; 2253 : 		AbortDecoySystemWipe();

  00070	e8 00 00 00 00	 call	 AbortDecoySystemWipe
$LN7@StartDecoy:

; 2254 : 
; 2255 : 	request = (WipeDecoySystemRequest *) irp->AssociatedIrp.SystemBuffer;

  00075	48 8b 7e 18	 mov	 rdi, QWORD PTR [rsi+24]

; 2256 : 	WipeDecoyRequest = *request;

  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WipeDecoyRequest
  00080	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00086	48 8b d7	 mov	 rdx, rdi
  00089	e8 00 00 00 00	 call	 memcpy

; 2257 : 
; 2258 : 	burn (request->WipeKey, sizeof (request->WipeKey));

  0008e	4c 8d 5f 04	 lea	 r11, QWORD PTR [rdi+4]
  00092	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00097	33 c0		 xor	 eax, eax
  00099	48 8b ca	 mov	 rcx, rdx
  0009c	49 8b fb	 mov	 rdi, r11
  0009f	f3 aa		 rep stosb
$LL3@StartDecoy:
  000a1	41 88 03	 mov	 BYTE PTR [r11], al
  000a4	49 ff c3	 inc	 r11
  000a7	83 ea 01	 sub	 edx, 1
  000aa	75 f5		 jne	 SHORT $LL3@StartDecoy

; 2259 : 
; 2260 : 	DecoySystemWipeThreadAbortRequested = FALSE;
; 2261 : 	KeInitializeSpinLock (&DecoySystemWipeStatusSpinLock);

  000ac	48 21 05 00 00
	00 00		 and	 QWORD PTR DecoySystemWipeStatusSpinLock, rax
  000b3	89 05 00 00 00
	00		 mov	 DWORD PTR DecoySystemWipeThreadAbortRequested, eax

; 2262 : 	DecoySystemWipedAreaEnd = BootDriveFilterExtension->ConfiguredEncryptedAreaStart;

  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  000c0	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]

; 2263 : 
; 2264 : 	DecoySystemWipeInProgress = TRUE;
; 2265 : 	status = GSTStartThread (DecoySystemWipeThreadProc, DeviceObject, &DecoySystemWipeThread);

  000c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:DecoySystemWipeThread
  000cb	48 8b d3	 mov	 rdx, rbx
  000ce	48 89 0d 00 00
	00 00		 mov	 QWORD PTR DecoySystemWipedAreaEnd, rcx
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeThreadProc
  000dc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DecoySystemWipeInProgress, 1
  000e6	e8 00 00 00 00	 call	 GSTStartThread

; 2266 : 	
; 2267 : 	if (!NT_SUCCESS (status))

  000eb	85 c0		 test	 eax, eax
  000ed	79 11		 jns	 SHORT $LN12@StartDecoy

; 2268 : 		DecoySystemWipeInProgress = FALSE;

  000ef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DecoySystemWipeInProgress, 0

; 2269 : 
; 2270 : 	return status;

  000f9	eb 05		 jmp	 SHORT $LN12@StartDecoy
$LN9@StartDecoy:

; 2247 : 		return STATUS_INVALID_PARAMETER;

  000fb	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
$LN12@StartDecoy:

; 2271 : }

  00100	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00105	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
StartDecoySystemWipe ENDP
_TEXT	ENDS
PUBLIC	StartBootEncryptionSetup
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$StartBootEncryptionSetup DD imagerel $LN12
	DD	imagerel $LN12+277
	DD	imagerel $unwind$StartBootEncryptionSetup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StartBootEncryptionSetup DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT StartBootEncryptionSetup
_TEXT	SEGMENT
DeviceObject$ = 48
irp$ = 56
irpSp$ = 64
StartBootEncryptionSetup PROC				; COMDAT

; 1780 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b d8	 mov	 rbx, r8
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 1781 : 	NTSTATUS status;
; 1782 : 
; 1783 : 	if (!UserCanAccessDriveDevice())

  00018	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN5@StartBootE

; 1784 : 		return STATUS_ACCESS_DENIED;

  00021	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00026	e9 da 00 00 00	 jmp	 $LN6@StartBootE
$LN5@StartBootE:

; 1785 : 
; 1786 : 	if (SetupInProgress || !BootDriveFound || !BootDriveFilterExtension
; 1787 : 		|| !BootDriveFilterExtension->DriveMounted
; 1788 : 		|| BootDriveFilterExtension->HiddenSystem
; 1789 : 		|| irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (BootEncryptionSetupRequest))

  0002b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupInProgress
  00031	85 c0		 test	 eax, eax
  00033	0f 85 c7 00 00
	00		 jne	 $LN3@StartBootE
  00039	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR BootDriveFound
  0003f	85 c0		 test	 eax, eax
  00041	0f 84 b9 00 00
	00		 je	 $LN3@StartBootE
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  0004e	48 85 c9	 test	 rcx, rcx
  00051	0f 84 a9 00 00
	00		 je	 $LN3@StartBootE
  00057	83 b9 b8 02 00
	00 00		 cmp	 DWORD PTR [rcx+696], 0
  0005e	0f 84 9c 00 00
	00		 je	 $LN3@StartBootE
  00064	83 b9 e0 02 00
	00 00		 cmp	 DWORD PTR [rcx+736], 0
  0006b	0f 85 8f 00 00
	00		 jne	 $LN3@StartBootE
  00071	83 7b 10 10	 cmp	 DWORD PTR [rbx+16], 16
  00075	0f 82 85 00 00
	00		 jb	 $LN3@StartBootE

; 1791 : 
; 1792 : 	if (EncryptionSetupThread)

  0007b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR EncryptionSetupThread, 0
  00083	74 0c		 je	 SHORT $LN2@StartBootE

; 1793 : 		AbortBootEncryptionSetup();

  00085	e8 00 00 00 00	 call	 AbortBootEncryptionSetup
  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
$LN2@StartBootE:

; 1794 : 
; 1795 : 	SetupRequest = *(BootEncryptionSetupRequest *) irp->AssociatedIrp.SystemBuffer;

  00091	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00095	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]

; 1796 : 
; 1797 : 	EncryptionSetupThreadAbortRequested = FALSE;
; 1798 : 	KeInitializeSpinLock (&SetupStatusSpinLock);

  00099	48 83 25 00 00
	00 00 00	 and	 QWORD PTR SetupStatusSpinLock, 0
  000a1	f3 0f 7f 05 00
	00 00 00	 movdqu	 XMMWORD PTR SetupRequest, xmm0
  000a9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EncryptionSetupThreadAbortRequested, 0

; 1799 : 	SetupStatusEncryptedAreaEnd = BootDriveFilterExtension ? BootDriveFilterExtension->Queue.EncryptedAreaEnd : -1;

  000b3	48 85 c9	 test	 rcx, rcx
  000b6	74 10		 je	 SHORT $LN8@StartBootE
  000b8	48 8b 81 d0 00
	00 00		 mov	 rax, QWORD PTR [rcx+208]
  000bf	48 89 05 00 00
	00 00		 mov	 QWORD PTR SetupStatusEncryptedAreaEnd, rax
  000c6	eb 08		 jmp	 SHORT $LN9@StartBootE
$LN8@StartBootE:
  000c8	48 83 0d 00 00
	00 00 ff	 or	 QWORD PTR SetupStatusEncryptedAreaEnd, -1
$LN9@StartBootE:

; 1800 : 
; 1801 : 	SetupInProgress = TRUE;
; 1802 : 	status = GSTStartThread (SetupThreadProc, DeviceObject, &EncryptionSetupThread);

  000d0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:EncryptionSetupThread
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupThreadProc
  000de	48 8b d6	 mov	 rdx, rsi
  000e1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR SetupInProgress, 1
  000eb	e8 00 00 00 00	 call	 GSTStartThread

; 1803 : 	
; 1804 : 	if (!NT_SUCCESS (status))

  000f0	85 c0		 test	 eax, eax
  000f2	79 11		 jns	 SHORT $LN6@StartBootE

; 1805 : 		SetupInProgress = FALSE;

  000f4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR SetupInProgress, 0

; 1806 : 
; 1807 : 	return status;

  000fe	eb 05		 jmp	 SHORT $LN6@StartBootE
$LN3@StartBootE:

; 1790 : 		return STATUS_INVALID_PARAMETER;

  00100	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
$LN6@StartBootE:

; 1808 : }

  00105	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0010f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00113	5f		 pop	 rdi
  00114	c3		 ret	 0
StartBootEncryptionSetup ENDP
	ALIGN	8

OriginalHiberDriverEntries DQ 03H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverEntryFilter DD imagerel HiberDriverEntryFilter
	DD	imagerel HiberDriverEntryFilter+416
	DD	imagerel $unwind$HiberDriverEntryFilter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverEntryFilter DD 0a1901H
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0c0155219H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT HiberDriverEntryFilter
_TEXT	SEGMENT
filterNumber$ = 64
arg0$ = 72
hiberDriverContext$ = 80
HiberDriverEntryFilter PROC				; COMDAT

; 1198 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1199 : 	BOOL filterInstalled = FALSE;
; 1200 : 	NTSTATUS status;
; 1201 : 
; 1202 : 	if (!OriginalHiberDriverEntries[filterNumber])

  00019	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:__ImageBase
  00020	48 63 f9	 movsxd	 rdi, ecx
  00023	33 f6		 xor	 esi, esi
  00025	49 8b 84 fc 00
	00 00 00	 mov	 rax, QWORD PTR OriginalHiberDriverEntries[r12+rdi*8]
  0002d	49 8b d8	 mov	 rbx, r8
  00030	4c 8b c2	 mov	 r8, rdx
  00033	48 85 c0	 test	 rax, rax
  00036	75 0a		 jne	 SHORT $LN20@HiberDrive@2

; 1203 : 		return STATUS_UNSUCCESSFUL;

  00038	b8 01 00 00 c0	 mov	 eax, -1073741823	; ffffffffc0000001H
  0003d	e9 43 01 00 00	 jmp	 $LN18@HiberDrive@2
$LN20@HiberDrive@2:

; 1204 : 
; 1205 : 	status = (*OriginalHiberDriverEntries[filterNumber]) (arg0, hiberDriverContext);

  00042	48 8b d3	 mov	 rdx, rbx
  00045	49 8b c8	 mov	 rcx, r8
  00048	ff d0		 call	 rax

; 1206 : 
; 1207 : 	if (!NT_SUCCESS (status) || !hiberDriverContext)

  0004a	85 c0		 test	 eax, eax
  0004c	0f 88 33 01 00
	00		 js	 $LN18@HiberDrive@2
  00052	48 85 db	 test	 rbx, rbx
  00055	0f 84 2a 01 00
	00		 je	 $LN18@HiberDrive@2

; 1208 : 		return status;
; 1209 : 
; 1210 : 	if (SetupInProgress)

  0005b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupInProgress
  00061	85 c0		 test	 eax, eax
  00063	74 23		 je	 SHORT $LN17@HiberDrive@2

; 1211 : 		GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00065	45 33 c9	 xor	 r9d, r9d
  00068	ba bb 04 00 00	 mov	 edx, 1211		; 000004bbH
  0006d	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  00074	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00078	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00087	cc		 int	 3
$LN17@HiberDrive@2:

; 1212 : 
; 1213 : 	if (hiberDriverContext->WriteFunctionA)

  00088	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  0008f	ba 01 00 00 00	 mov	 edx, 1
  00094	48 85 c0	 test	 rax, rax
  00097	74 57		 je	 SHORT $LN16@HiberDrive@2

; 1214 : 	{
; 1215 : 		Dump ("Filtering WriteFunctionA %d\n", filterNumber);
; 1216 : 		OriginalHiberDriverWriteFunctionsA[filterNumber] = hiberDriverContext->WriteFunctionA;

  00099	49 89 84 fc 00
	00 00 00	 mov	 QWORD PTR OriginalHiberDriverWriteFunctionsA[r12+rdi*8], rax

; 1217 : 
; 1218 : 		switch (filterNumber)

  000a1	8b cf		 mov	 ecx, edi
  000a3	85 ff		 test	 edi, edi
  000a5	74 39		 je	 SHORT $LN13@HiberDrive@2
  000a7	2b ca		 sub	 ecx, edx
  000a9	74 2c		 je	 SHORT $LN12@HiberDrive@2
  000ab	3b ca		 cmp	 ecx, edx
  000ad	74 1f		 je	 SHORT $LN11@HiberDrive@2

; 1223 : 		default: GST_THROW_FATAL_EXCEPTION;

  000af	45 33 c9	 xor	 r9d, r9d
  000b2	45 33 c0	 xor	 r8d, r8d
  000b5	ba c7 04 00 00	 mov	 edx, 1223		; 000004c7H
  000ba	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  000be	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  000cd	cc		 int	 3
$LN11@HiberDrive@2:

; 1222 : 		case 2: hiberDriverContext->WriteFunctionA = HiberDriverWriteFunctionAFilter2; break;

  000ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionAFilter2
  000d5	eb 10		 jmp	 SHORT $LN24@HiberDrive@2
$LN12@HiberDrive@2:

; 1221 : 		case 1: hiberDriverContext->WriteFunctionA = HiberDriverWriteFunctionAFilter1; break;

  000d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionAFilter1
  000de	eb 07		 jmp	 SHORT $LN24@HiberDrive@2
$LN13@HiberDrive@2:

; 1219 : 		{
; 1220 : 		case 0: hiberDriverContext->WriteFunctionA = HiberDriverWriteFunctionAFilter0; break;

  000e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionAFilter0
$LN24@HiberDrive@2:
  000e7	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 1224 : 		}
; 1225 : 
; 1226 : 		filterInstalled = TRUE;

  000ee	8b f2		 mov	 esi, edx
$LN16@HiberDrive@2:

; 1227 : 	}
; 1228 : 
; 1229 : 	if (hiberDriverContext->WriteFunctionB)

  000f0	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  000f4	48 85 c0	 test	 rax, rax
  000f7	74 52		 je	 SHORT $LN9@HiberDrive@2

; 1230 : 	{
; 1231 : 		Dump ("Filtering WriteFunctionB %d\n", filterNumber);
; 1232 : 		OriginalHiberDriverWriteFunctionsB[filterNumber] = hiberDriverContext->WriteFunctionB;

  000f9	49 89 84 fc 00
	00 00 00	 mov	 QWORD PTR OriginalHiberDriverWriteFunctionsB[r12+rdi*8], rax

; 1233 : 
; 1234 : 		switch (filterNumber)

  00101	85 ff		 test	 edi, edi
  00103	74 39		 je	 SHORT $LN6@HiberDrive@2
  00105	2b fa		 sub	 edi, edx
  00107	74 2c		 je	 SHORT $LN5@HiberDrive@2
  00109	3b fa		 cmp	 edi, edx
  0010b	74 1f		 je	 SHORT $LN4@HiberDrive@2

; 1239 : 		default: GST_THROW_FATAL_EXCEPTION;

  0010d	45 33 c9	 xor	 r9d, r9d
  00110	45 33 c0	 xor	 r8d, r8d
  00113	ba d7 04 00 00	 mov	 edx, 1239		; 000004d7H
  00118	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0011c	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0012b	cc		 int	 3
$LN4@HiberDrive@2:

; 1238 : 		case 2: hiberDriverContext->WriteFunctionB = HiberDriverWriteFunctionBFilter2; break;

  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionBFilter2
  00133	eb 10		 jmp	 SHORT $LN25@HiberDrive@2
$LN5@HiberDrive@2:

; 1237 : 		case 1: hiberDriverContext->WriteFunctionB = HiberDriverWriteFunctionBFilter1; break;

  00135	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionBFilter1
  0013c	eb 07		 jmp	 SHORT $LN25@HiberDrive@2
$LN6@HiberDrive@2:

; 1235 : 		{
; 1236 : 		case 0: hiberDriverContext->WriteFunctionB = HiberDriverWriteFunctionBFilter0; break;

  0013e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionBFilter0
$LN25@HiberDrive@2:
  00145	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 1240 : 		}
; 1241 : 
; 1242 : 		filterInstalled = TRUE;

  00149	8b f2		 mov	 esi, edx
$LN9@HiberDrive@2:

; 1243 : 	}
; 1244 : 
; 1245 : 	if (filterInstalled && hiberDriverContext->PartitionStartOffset.QuadPart != 0)

  0014b	85 f6		 test	 esi, esi
  0014d	74 34		 je	 SHORT $LN1@HiberDrive@2
  0014f	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
  00156	48 85 c9	 test	 rcx, rcx
  00159	74 28		 je	 SHORT $LN1@HiberDrive@2

; 1246 : 	{
; 1247 : 		HiberPartitionOffset = hiberDriverContext->PartitionStartOffset;
; 1248 : 
; 1249 : 		if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  0015b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00162	48 89 0d 00 00
	00 00		 mov	 QWORD PTR HiberPartitionOffset, rcx
  00169	83 b8 dc 00 00
	00 00		 cmp	 DWORD PTR [rax+220], 0
  00170	74 11		 je	 SHORT $LN1@HiberDrive@2

; 1250 : 			hiberDriverContext->PartitionStartOffset.QuadPart += BootDriveFilterExtension->Queue.RemappedAreaOffset;

  00172	48 8b 80 e0 00
	00 00		 mov	 rax, QWORD PTR [rax+224]
  00179	48 03 c8	 add	 rcx, rax
  0017c	48 89 8b a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rcx
$LN1@HiberDrive@2:

; 1251 : 	}
; 1252 : 
; 1253 : 	return STATUS_SUCCESS;

  00183	33 c0		 xor	 eax, eax
$LN18@HiberDrive@2:

; 1254 : }

  00185	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0018a	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0018f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00194	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00199	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019d	41 5c		 pop	 r12
  0019f	c3		 ret	 0
$LN23@HiberDrive@2:
HiberDriverEntryFilter ENDP
_TEXT	ENDS
PUBLIC	ReopenBootVolumeHeader
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$ReopenBootVolumeHeader DD imagerel $LN29
	DD	imagerel $LN29+520
	DD	imagerel $unwind$ReopenBootVolumeHeader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReopenBootVolumeHeader DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT ReopenBootVolumeHeader
_TEXT	SEGMENT
irp$ = 64
irpSp$ = 72
ReopenBootVolumeHeader PROC				; COMDAT

; 903  : {

$LN29:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 904  : 	LARGE_INTEGER offset;
; 905  : 	char *header;
; 906  : 	ReopenBootVolumeHeaderRequest *request = (ReopenBootVolumeHeaderRequest *) irp->AssociatedIrp.SystemBuffer;

  00014	48 8b 59 18	 mov	 rbx, QWORD PTR [rcx+24]

; 907  : 
; 908  : 	irp->IoStatus.Information = 0;

  00018	48 83 61 38 00	 and	 QWORD PTR [rcx+56], 0
  0001d	48 8b f9	 mov	 rdi, rcx

; 909  : 
; 910  : 	if (!IoIsSystemThread (PsGetCurrentThread()) && !UserCanAccessDriveDevice())

  00020	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  0002f	84 c0		 test	 al, al
  00031	75 15		 jne	 SHORT $LN15@ReopenBoot
  00033	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00038	85 c0		 test	 eax, eax
  0003a	75 0c		 jne	 SHORT $LN15@ReopenBoot

; 911  : 	{
; 912  : 		irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  0003c	c7 47 30 22 00
	00 c0		 mov	 DWORD PTR [rdi+48], -1073741790 ; ffffffffc0000022H

; 913  : 		return;

  00043	e9 ab 01 00 00	 jmp	 $LN3@ReopenBoot
$LN15@ReopenBoot:

; 914  : 	}
; 915  : 
; 916  : 	if (!ValidateIOBufferSize (irp, sizeof (ReopenBootVolumeHeaderRequest), ValidateInput))

  00048	45 33 c0	 xor	 r8d, r8d
  0004b	48 8b cf	 mov	 rcx, rdi
  0004e	41 8d 70 48	 lea	 esi, QWORD PTR [r8+72]
  00052	48 8b d6	 mov	 rdx, rsi
  00055	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0005a	85 c0		 test	 eax, eax
  0005c	0f 84 91 01 00
	00		 je	 $LN3@ReopenBoot

; 917  : 		return;
; 918  : 
; 919  : 	if (!BootDriveFound || !BootDriveFilterExtension || !BootDriveFilterExtension->DriveMounted || !BootDriveFilterExtension->HeaderCryptoInfo
; 920  : 		|| request->VolumePassword.Length > MAX_PASSWORD)

  00062	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR BootDriveFound
  00068	85 c0		 test	 eax, eax
  0006a	0f 84 68 01 00
	00		 je	 $LN12@ReopenBoot
  00070	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00077	48 85 c0	 test	 rax, rax
  0007a	0f 84 58 01 00
	00		 je	 $LN12@ReopenBoot
  00080	83 b8 b8 02 00
	00 00		 cmp	 DWORD PTR [rax+696], 0
  00087	0f 84 4b 01 00
	00		 je	 $LN12@ReopenBoot
  0008d	48 83 b8 d8 02
	00 00 00	 cmp	 QWORD PTR [rax+728], 0
  00095	0f 84 3d 01 00
	00		 je	 $LN12@ReopenBoot
  0009b	83 3b 40	 cmp	 DWORD PTR [rbx], 64	; 00000040H
  0009e	0f 87 34 01 00
	00		 ja	 $LN12@ReopenBoot

; 923  : 		goto wipe;
; 924  : 	}
; 925  : 
; 926  : 	header = GSTalloc (GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  000a4	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  000a9	33 c9		 xor	 ecx, ecx
  000ab	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000b7	48 8b e8	 mov	 rbp, rax

; 927  : 	if (!header)

  000ba	48 85 c0	 test	 rax, rax
  000bd	75 0c		 jne	 SHORT $LN11@ReopenBoot

; 928  : 	{
; 929  : 		irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  000bf	c7 47 30 9a 00
	00 c0		 mov	 DWORD PTR [rdi+48], -1073741670 ; ffffffffc000009aH

; 930  : 		goto wipe;

  000c6	e9 14 01 00 00	 jmp	 $wipe$28438
$LN11@ReopenBoot:

; 931  : 	}
; 932  : 
; 933  : 	if (BootDriveFilterExtension->HiddenSystem)

  000cb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR BootDriveFilterExtension
  000d2	83 ba e0 02 00
	00 00		 cmp	 DWORD PTR [rdx+736], 0
  000d9	74 10		 je	 SHORT $LN10@ReopenBoot

; 934  : 		offset.QuadPart = BootArgs.HiddenSystemPartitionStart + GST_HIDDEN_VOLUME_HEADER_OFFSET;

  000db	4c 8b 0d 5a 00
	00 00		 mov	 r9, QWORD PTR BootArgs+90
  000e2	49 81 c1 00 00
	01 00		 add	 r9, 65536		; 00010000H

; 935  : 	else

  000e9	eb 06		 jmp	 SHORT $LN9@ReopenBoot
$LN10@ReopenBoot:

; 936  : 		offset.QuadPart = GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET;

  000eb	41 b9 00 7c 00
	00		 mov	 r9d, 31744		; 00007c00H
$LN9@ReopenBoot:

; 937  : 
; 938  : 	irp->IoStatus.Status = GSTReadDevice (BootDriveFilterExtension->LowerDeviceObject, header, offset, GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  000f1	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  000f5	4c 8b c0	 mov	 r8, rax
  000f8	33 c9		 xor	 ecx, ecx
  000fa	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  00102	e8 00 00 00 00	 call	 GSTReadWriteDevice
  00107	89 47 30	 mov	 DWORD PTR [rdi+48], eax

; 939  : 	if (!NT_SUCCESS (irp->IoStatus.Status))

  0010a	85 c0		 test	 eax, eax
  0010c	0f 88 b6 00 00
	00		 js	 $ret$28446

; 940  : 	{
; 941  : 		Dump ("GSTReadDevice error %x\n", irp->IoStatus.Status);
; 942  : 		goto ret;
; 943  : 	}
; 944  : 
; 945  : 	if (ReadVolumeHeader (!BootDriveFilterExtension->HiddenSystem, header, &request->VolumePassword, NULL, BootDriveFilterExtension->HeaderCryptoInfo) == 0)

  00112	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00119	33 c9		 xor	 ecx, ecx
  0011b	4c 8b c3	 mov	 r8, rbx
  0011e	39 88 e0 02 00
	00		 cmp	 DWORD PTR [rax+736], ecx
  00124	48 8b 80 d8 02
	00 00		 mov	 rax, QWORD PTR [rax+728]
  0012b	48 8b d5	 mov	 rdx, rbp
  0012e	0f 94 c1	 sete	 cl
  00131	45 33 c9	 xor	 r9d, r9d
  00134	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00139	e8 00 00 00 00	 call	 ReadVolumeHeader
  0013e	85 c0		 test	 eax, eax
  00140	75 5d		 jne	 SHORT $LN7@ReopenBoot

; 946  : 	{
; 947  : 		Dump ("Header reopened\n");
; 948  : 		
; 949  : 		BootDriveFilterExtension->Queue.CryptoInfo->header_creation_time = BootDriveFilterExtension->HeaderCryptoInfo->header_creation_time;

  00142	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR BootDriveFilterExtension
  00149	48 8b 82 d8 02
	00 00		 mov	 rax, QWORD PTR [rdx+728]
  00150	48 8b 8a 98 00
	00 00		 mov	 rcx, QWORD PTR [rdx+152]
  00157	48 8b 80 a0 1e
	00 00		 mov	 rax, QWORD PTR [rax+7840]
  0015e	48 89 81 a0 1e
	00 00		 mov	 QWORD PTR [rcx+7840], rax

; 950  : 		BootDriveFilterExtension->Queue.CryptoInfo->pkcs5 = BootDriveFilterExtension->HeaderCryptoInfo->pkcs5;

  00165	48 8b 82 d8 02
	00 00		 mov	 rax, QWORD PTR [rdx+728]
  0016c	48 8b 8a 98 00
	00 00		 mov	 rcx, QWORD PTR [rdx+152]
  00173	8b 80 94 1e 00
	00		 mov	 eax, DWORD PTR [rax+7828]
  00179	89 81 94 1e 00
	00		 mov	 DWORD PTR [rcx+7828], eax

; 951  : 		BootDriveFilterExtension->Queue.CryptoInfo->noIterations = BootDriveFilterExtension->HeaderCryptoInfo->noIterations;

  0017f	48 8b 82 d8 02
	00 00		 mov	 rax, QWORD PTR [rdx+728]
  00186	48 8b 8a 98 00
	00 00		 mov	 rcx, QWORD PTR [rdx+152]
  0018d	8b 80 90 1e 00
	00		 mov	 eax, DWORD PTR [rax+7824]
  00193	89 81 90 1e 00
	00		 mov	 DWORD PTR [rcx+7824], eax

; 952  : 
; 953  : 		irp->IoStatus.Status = STATUS_SUCCESS;

  00199	83 67 30 00	 and	 DWORD PTR [rdi+48], 0

; 954  : 	}
; 955  : 	else

  0019d	eb 29		 jmp	 SHORT $ret$28446
$LN7@ReopenBoot:

; 956  : 	{
; 957  : 		crypto_close (BootDriveFilterExtension->HeaderCryptoInfo);

  0019f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  001a6	48 8b 89 d8 02
	00 00		 mov	 rcx, QWORD PTR [rcx+728]
  001ad	e8 00 00 00 00	 call	 crypto_close

; 958  : 		BootDriveFilterExtension->HeaderCryptoInfo = NULL;

  001b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  001b9	48 83 a1 d8 02
	00 00 00	 and	 QWORD PTR [rcx+728], 0

; 959  : 
; 960  : 		Dump ("Header not reopened\n");
; 961  : 		irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  001c1	c7 47 30 0d 00
	00 c0		 mov	 DWORD PTR [rdi+48], -1073741811 ; ffffffffc000000dH
$ret$28446:

; 962  : 	}
; 963  : 
; 964  : ret:
; 965  : 	GSTfree (header);

  001c8	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  001cd	48 8b cd	 mov	 rcx, rbp
  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
  001d6	eb 07		 jmp	 SHORT $wipe$28438
$LN12@ReopenBoot:

; 921  : 	{
; 922  : 		irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  001d8	c7 47 30 0d 00
	00 c0		 mov	 DWORD PTR [rdi+48], -1073741811 ; ffffffffc000000dH
$wipe$28438:

; 966  : wipe:
; 967  : 	burn (request, sizeof (*request));

  001df	48 8b fb	 mov	 rdi, rbx
  001e2	33 c0		 xor	 eax, eax
  001e4	48 8b ce	 mov	 rcx, rsi
  001e7	f3 aa		 rep stosb
$LL2@ReopenBoot:
  001e9	88 03		 mov	 BYTE PTR [rbx], al
  001eb	48 ff c3	 inc	 rbx
  001ee	83 ee 01	 sub	 esi, 1
  001f1	75 f6		 jne	 SHORT $LL2@ReopenBoot
$LN3@ReopenBoot:

; 968  : }

  001f3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001f8	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001fd	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00202	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00206	5f		 pop	 rdi
  00207	c3		 ret	 0
ReopenBootVolumeHeader ENDP
; Function compile flags: /Ogspy
;	COMDAT HiberDriverEntryFilter2
_TEXT	SEGMENT
arg0$ = 8
hiberDriverContext$ = 16
HiberDriverEntryFilter2 PROC				; COMDAT

; 1298 : 	return HiberDriverEntryFilter (2, arg0, hiberDriverContext);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	48 8b d1	 mov	 rdx, rcx
  00006	b9 02 00 00 00	 mov	 ecx, 2

; 1299 : }

  0000b	e9 00 00 00 00	 jmp	 HiberDriverEntryFilter
HiberDriverEntryFilter2 ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT HiberDriverEntryFilter1
_TEXT	SEGMENT
arg0$ = 8
hiberDriverContext$ = 16
HiberDriverEntryFilter1 PROC				; COMDAT

; 1283 : 	return HiberDriverEntryFilter (1, arg0, hiberDriverContext);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	48 8b d1	 mov	 rdx, rcx
  00006	b9 01 00 00 00	 mov	 ecx, 1

; 1284 : }

  0000b	e9 00 00 00 00	 jmp	 HiberDriverEntryFilter
HiberDriverEntryFilter1 ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT HiberDriverEntryFilter0
_TEXT	SEGMENT
arg0$ = 8
hiberDriverContext$ = 16
HiberDriverEntryFilter0 PROC				; COMDAT

; 1268 : 	return HiberDriverEntryFilter (0, arg0, hiberDriverContext);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	48 8b d1	 mov	 rdx, rcx
  00006	33 c9		 xor	 ecx, ecx

; 1269 : }

  00008	e9 00 00 00 00	 jmp	 HiberDriverEntryFilter
HiberDriverEntryFilter0 ENDP
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$LoadImageNotifyRoutine DD imagerel LoadImageNotifyRoutine
	DD	imagerel LoadImageNotifyRoutine+456
	DD	imagerel $unwind$LoadImageNotifyRoutine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LoadImageNotifyRoutine DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT LoadImageNotifyRoutine
_TEXT	SEGMENT
fullImageName$ = 64
processId$ = 72
imageInfo$ = 80
LoadImageNotifyRoutine PROC				; COMDAT

; 1313 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1314 : 	ModuleTableItem *moduleItem;
; 1315 : 	LIST_ENTRY *listEntry;
; 1316 : 	KIRQL origIrql;
; 1317 : 
; 1318 : 	if (!imageInfo || !imageInfo->SystemModeImage || !imageInfo->ImageBase || !GSTDriverObject->DriverSection)

  0000a	45 33 db	 xor	 r11d, r11d
  0000d	4d 3b c3	 cmp	 r8, r11
  00010	0f 84 a7 01 00
	00		 je	 $LN16@LoadImageN
  00016	41 0f ba 20 08	 bt	 DWORD PTR [r8], 8
  0001b	0f 83 9c 01 00
	00		 jae	 $LN16@LoadImageN
  00021	4d 39 58 08	 cmp	 QWORD PTR [r8+8], r11
  00025	0f 84 92 01 00
	00		 je	 $LN16@LoadImageN
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR GSTDriverObject
  00032	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00036	49 3b c3	 cmp	 rax, r11
  00039	0f 84 7e 01 00
	00		 je	 $LN16@LoadImageN

; 1319 : 		return;
; 1320 : 
; 1321 : 	moduleItem = *(ModuleTableItem **) GSTDriverObject->DriverSection;

  0003f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1322 : 	if (!moduleItem || !moduleItem->ModuleList.Flink)

  00042	49 3b c3	 cmp	 rax, r11
  00045	0f 84 72 01 00
	00		 je	 $LN16@LoadImageN
  0004b	4c 39 18	 cmp	 QWORD PTR [rax], r11
  0004e	0f 84 69 01 00
	00		 je	 $LN16@LoadImageN

; 1323 : 		return;
; 1324 : 
; 1325 : 	// Search loaded system modules for hibernation driver
; 1326 : 	origIrql = KeRaiseIrqlToDpcLevel();

  00054	45 0f 20 c2	 mov	 r10, cr8
  00058	41 8d 7b 02	 lea	 edi, QWORD PTR [r11+2]
  0005c	44 0f 22 c7	 mov	 cr8, rdi

; 1327 : 
; 1328 : 	for (listEntry = moduleItem->ModuleList.Flink->Blink;
; 1329 : 		listEntry && listEntry != GSTDriverObject->DriverSection;
; 1330 : 		listEntry = listEntry->Flink)

  00060	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00063	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00067	49 3b cb	 cmp	 rcx, r11
  0006a	0f 84 45 01 00
	00		 je	 $LN39@LoadImageN
  00070	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR GSTDriverObject
  00077	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
$LL15@LoadImageN:
  0007b	48 3b ca	 cmp	 rcx, rdx
  0007e	0f 84 31 01 00
	00		 je	 $LN39@LoadImageN

; 1331 : 	{
; 1332 : 		moduleItem = CONTAINING_RECORD (listEntry, ModuleTableItem, ModuleList);
; 1333 : 
; 1334 : 		if (moduleItem && imageInfo->ImageBase == moduleItem->ModuleBaseAddress)

  00084	49 3b cb	 cmp	 rcx, r11
  00087	74 0a		 je	 SHORT $LN14@LoadImageN
  00089	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  0008d	49 39 40 08	 cmp	 QWORD PTR [r8+8], rax
  00091	74 0e		 je	 SHORT $LN31@LoadImageN
$LN14@LoadImageN:

; 1327 : 
; 1328 : 	for (listEntry = moduleItem->ModuleList.Flink->Blink;
; 1329 : 		listEntry && listEntry != GSTDriverObject->DriverSection;
; 1330 : 		listEntry = listEntry->Flink)

  00093	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00096	49 3b cb	 cmp	 rcx, r11
  00099	0f 84 16 01 00
	00		 je	 $LN39@LoadImageN
  0009f	eb da		 jmp	 SHORT $LL15@LoadImageN
$LN31@LoadImageN:

; 1335 : 		{
; 1336 : 			if (moduleItem->ModuleName.Buffer && moduleItem->ModuleName.Length >= 5 * sizeof (wchar_t))

  000a1	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  000a5	49 3b c3	 cmp	 rax, r11
  000a8	0f 84 07 01 00
	00		 je	 $LN39@LoadImageN
  000ae	66 83 79 58 0a	 cmp	 WORD PTR [rcx+88], 10
  000b3	0f 82 fc 00 00
	00		 jb	 $LN39@LoadImageN

; 1337 : 			{
; 1338 : 				if (memcmp (moduleItem->ModuleName.Buffer, L"hiber", 5 * sizeof (wchar_t)) == 0
; 1339 : 					|| memcmp (moduleItem->ModuleName.Buffer, L"Hiber", 5 * sizeof (wchar_t)) == 0
; 1340 : 					|| memcmp (moduleItem->ModuleName.Buffer, L"HIBER", 5 * sizeof (wchar_t)) == 0)

  000b9	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  000bc	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  000c3	4c 3b 8b 00 00
	00 00		 cmp	 r9, QWORD PTR ??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@[rbx]
  000ca	75 14		 jne	 SHORT $LN37@LoadImageN
  000cc	66 44 8b 48 08	 mov	 r9w, WORD PTR [rax+8]
  000d1	66 44 3b 8b 08
	00 00 00	 cmp	 r9w, WORD PTR ??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@[rbx+8]
  000d9	75 05		 jne	 SHORT $LN37@LoadImageN
  000db	41 8b d3	 mov	 edx, r11d
  000de	eb 05		 jmp	 SHORT $LN38@LoadImageN
$LN37@LoadImageN:
  000e0	1b d2		 sbb	 edx, edx
  000e2	83 da ff	 sbb	 edx, -1
$LN38@LoadImageN:
  000e5	41 3b d3	 cmp	 edx, r11d
  000e8	74 54		 je	 SHORT $LN9@LoadImageN
  000ea	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  000ed	4c 3b 8b 00 00
	00 00		 cmp	 r9, QWORD PTR ??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@[rbx]
  000f4	75 14		 jne	 SHORT $LN35@LoadImageN
  000f6	66 44 8b 48 08	 mov	 r9w, WORD PTR [rax+8]
  000fb	66 44 3b 8b 08
	00 00 00	 cmp	 r9w, WORD PTR ??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@[rbx+8]
  00103	75 05		 jne	 SHORT $LN35@LoadImageN
  00105	41 8b d3	 mov	 edx, r11d
  00108	eb 05		 jmp	 SHORT $LN36@LoadImageN
$LN35@LoadImageN:
  0010a	1b d2		 sbb	 edx, edx
  0010c	83 da ff	 sbb	 edx, -1
$LN36@LoadImageN:
  0010f	41 3b d3	 cmp	 edx, r11d
  00112	74 2a		 je	 SHORT $LN9@LoadImageN
  00114	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00117	4c 3b 83 00 00
	00 00		 cmp	 r8, QWORD PTR ??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@[rbx]
  0011e	75 14		 jne	 SHORT $LN33@LoadImageN
  00120	66 44 8b 40 08	 mov	 r8w, WORD PTR [rax+8]
  00125	66 44 3b 83 08
	00 00 00	 cmp	 r8w, WORD PTR ??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@[rbx+8]
  0012d	75 05		 jne	 SHORT $LN33@LoadImageN
  0012f	41 8b c3	 mov	 eax, r11d
  00132	eb 05		 jmp	 SHORT $LN34@LoadImageN
$LN33@LoadImageN:
  00134	1b c0		 sbb	 eax, eax
  00136	83 d8 ff	 sbb	 eax, -1
$LN34@LoadImageN:
  00139	41 3b c3	 cmp	 eax, r11d
  0013c	75 77		 jne	 SHORT $LN39@LoadImageN
$LN9@LoadImageN:

; 1341 : 				{
; 1342 : 					HiberDriverEntry filterEntry;
; 1343 : 
; 1344 : 					switch (LastHiberFilterNumber)

  0013e	4c 63 05 00 00
	00 00		 movsxd	 r8, DWORD PTR LastHiberFilterNumber
  00145	41 8b d0	 mov	 edx, r8d
  00148	45 3b c3	 cmp	 r8d, r11d
  0014b	74 3b		 je	 SHORT $LN6@LoadImageN
  0014d	83 ea 01	 sub	 edx, 1
  00150	74 2d		 je	 SHORT $LN5@LoadImageN
  00152	83 fa 01	 cmp	 edx, 1
  00155	74 1f		 je	 SHORT $LN4@LoadImageN

; 1349 : 					default: GST_THROW_FATAL_EXCEPTION;

  00157	45 33 c9	 xor	 r9d, r9d
  0015a	45 33 c0	 xor	 r8d, r8d
  0015d	ba 45 05 00 00	 mov	 edx, 1349		; 00000545H
  00162	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00166	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00175	cc		 int	 3
$LN4@LoadImageN:

; 1348 : 					case 2: filterEntry = HiberDriverEntryFilter2; break;

  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:HiberDriverEntryFilter2
  0017d	eb 10		 jmp	 SHORT $LN7@LoadImageN
$LN5@LoadImageN:

; 1347 : 					case 1: filterEntry = HiberDriverEntryFilter1; break;

  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:HiberDriverEntryFilter1
  00186	eb 07		 jmp	 SHORT $LN7@LoadImageN
$LN6@LoadImageN:

; 1345 : 					{
; 1346 : 					case 0: filterEntry = HiberDriverEntryFilter0; break;

  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:HiberDriverEntryFilter0
$LN7@LoadImageN:

; 1350 : 					}
; 1351 : 
; 1352 : 					if (moduleItem->ModuleEntryAddress != filterEntry)

  0018f	4c 8b 49 38	 mov	 r9, QWORD PTR [rcx+56]
  00193	4c 3b ca	 cmp	 r9, rdx
  00196	74 1d		 je	 SHORT $LN39@LoadImageN

; 1353 : 					{
; 1354 : 						// Install filter
; 1355 : 						OriginalHiberDriverEntries[LastHiberFilterNumber] = moduleItem->ModuleEntryAddress;

  00198	4e 89 8c c3 00
	00 00 00	 mov	 QWORD PTR OriginalHiberDriverEntries[rbx+r8*8], r9

; 1356 : 						moduleItem->ModuleEntryAddress = filterEntry;
; 1357 : 
; 1358 : 						if (++LastHiberFilterNumber > GST_MAX_HIBER_FILTER_COUNT - 1)

  001a0	41 ff c0	 inc	 r8d
  001a3	48 89 51 38	 mov	 QWORD PTR [rcx+56], rdx
  001a7	44 3b c7	 cmp	 r8d, edi
  001aa	45 0f 4f c3	 cmovg	 r8d, r11d
  001ae	44 89 05 00 00
	00 00		 mov	 DWORD PTR LastHiberFilterNumber, r8d
$LN39@LoadImageN:

; 1359 : 							LastHiberFilterNumber = 0;
; 1360 : 					}
; 1361 : 				}
; 1362 : 			}
; 1363 : 			break;
; 1364 : 		}
; 1365 : 	}
; 1366 : 
; 1367 : 	KeLowerIrql (origIrql);

  001b5	41 0f b6 c2	 movzx	 eax, r10b
  001b9	44 0f 22 c0	 mov	 cr8, rax
$LN16@LoadImageN:

; 1368 : }

  001bd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001c2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c6	5f		 pop	 rdi
  001c7	c3		 ret	 0
$LN40@LoadImageN:
LoadImageNotifyRoutine ENDP
_TEXT	ENDS
PUBLIC	StartLegacyHibernationDriverFilter
;	COMDAT pdata
pdata	SEGMENT
$pdata$StartLegacyHibernationDriverFilter DD imagerel $LN13
	DD	imagerel $LN13+254
	DD	imagerel $unwind$StartLegacyHibernationDriverFilter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StartLegacyHibernationDriverFilter DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT StartLegacyHibernationDriverFilter
_TEXT	SEGMENT
StartLegacyHibernationDriverFilter PROC			; COMDAT

; 1379 : {

$LN13:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1380 : 	PHYSICAL_ADDRESS highestAcceptableWriteBufferAddr;
; 1381 : 	NTSTATUS status;
; 1382 : 
; 1383 : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
; 1384 : 	ASSERT (!IsOSAtLeast (WIN_VISTA));
; 1385 : 
; 1386 : 	if (!GSTDriverObject->DriverSection || !*(ModuleTableItem **) GSTDriverObject->DriverSection)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR GSTDriverObject
  0000b	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 8e 00 00
	00		 je	 $LN12@StartLegac
  00018	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0001c	0f 84 84 00 00
	00		 je	 $LN12@StartLegac

; 1387 : 		goto err;
; 1388 : 
; 1389 : 	// All buffers required for hibernation must be allocated here
; 1390 : #ifdef _WIN64
; 1391 : 	highestAcceptableWriteBufferAddr.QuadPart = 0x7FFffffFFFFULL;

  00022	48 ba ff ff ff
	ff ff 07 00 00	 mov	 rdx, 8796093022207	; 000007ffffffffffH

; 1392 : #else
; 1393 : 	highestAcceptableWriteBufferAddr.QuadPart = 0xffffFFFFULL;
; 1394 : #endif
; 1395 : 
; 1396 : 	HibernationWriteBuffer = MmAllocateContiguousMemory (GST_HIBERNATION_WRITE_BUFFER_SIZE, highestAcceptableWriteBufferAddr);

  0002c	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmAllocateContiguousMemory
  00037	48 89 05 00 00
	00 00		 mov	 QWORD PTR HibernationWriteBuffer, rax

; 1397 : 	if (!HibernationWriteBuffer)

  0003e	48 85 c0	 test	 rax, rax
  00041	74 5a		 je	 SHORT $LN10@StartLegac

; 1398 : 		goto err;
; 1399 : 
; 1400 : 	HibernationWriteBufferMdl = IoAllocateMdl (HibernationWriteBuffer, GST_HIBERNATION_WRITE_BUFFER_SIZE, FALSE, FALSE, NULL);

  00043	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	45 33 c0	 xor	 r8d, r8d
  0004f	ba 00 00 02 00	 mov	 edx, 131072		; 00020000H
  00054	48 8b c8	 mov	 rcx, rax
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAllocateMdl
  0005d	48 8b c8	 mov	 rcx, rax
  00060	48 89 05 00 00
	00 00		 mov	 QWORD PTR HibernationWriteBufferMdl, rax

; 1401 : 	if (!HibernationWriteBufferMdl)

  00067	48 85 c0	 test	 rax, rax
  0006a	74 41		 je	 SHORT $LN11@StartLegac

; 1402 : 		goto err;
; 1403 : 
; 1404 : 	MmBuildMdlForNonPagedPool (HibernationWriteBufferMdl);

  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmBuildMdlForNonPagedPool

; 1405 : 
; 1406 : 	status = PsSetLoadImageNotifyRoutine (LoadImageNotifyRoutine);

  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:LoadImageNotifyRoutine
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsSetLoadImageNotifyRoutine

; 1407 : 	if (!NT_SUCCESS (status))

  0007f	85 c0		 test	 eax, eax
  00081	78 23		 js	 SHORT $LN12@StartLegac

; 1408 : 		goto err;
; 1409 : 
; 1410 : 	LegacyHibernationDriverFilterActive = TRUE;
; 1411 : 	CrashDumpEnabled = FALSE;

  00083	83 25 00 00 00
	00 00		 and	 DWORD PTR CrashDumpEnabled, 0
  0008a	b8 01 00 00 00	 mov	 eax, 1
  0008f	89 05 00 00 00
	00		 mov	 DWORD PTR LegacyHibernationDriverFilterActive, eax

; 1412 : 	HibernationEnabled = TRUE;

  00095	89 05 00 00 00
	00		 mov	 DWORD PTR HibernationEnabled, eax

; 1413 : 	return;

  0009b	eb 5c		 jmp	 SHORT $LN1@StartLegac
$LN10@StartLegac:
  0009d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBufferMdl
  000a4	eb 0e		 jmp	 SHORT $err$28721
$LN12@StartLegac:
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBufferMdl
$LN11@StartLegac:
  000ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR HibernationWriteBuffer
$err$28721:

; 1414 : 
; 1415 : err:
; 1416 : 	LegacyHibernationDriverFilterActive = FALSE;

  000b4	83 25 00 00 00
	00 00		 and	 DWORD PTR LegacyHibernationDriverFilterActive, 0

; 1417 : 	CrashDumpEnabled = FALSE;

  000bb	83 25 00 00 00
	00 00		 and	 DWORD PTR CrashDumpEnabled, 0

; 1418 : 	HibernationEnabled = FALSE;

  000c2	83 25 00 00 00
	00 00		 and	 DWORD PTR HibernationEnabled, 0

; 1419 : 
; 1420 : 	if (HibernationWriteBufferMdl)

  000c9	48 85 c9	 test	 rcx, rcx
  000cc	74 15		 je	 SHORT $LN2@StartLegac

; 1421 : 	{
; 1422 : 		IoFreeMdl (HibernationWriteBufferMdl);

  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoFreeMdl

; 1423 : 		HibernationWriteBufferMdl = NULL;

  000d4	48 83 25 00 00
	00 00 00	 and	 QWORD PTR HibernationWriteBufferMdl, 0
  000dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR HibernationWriteBuffer
$LN2@StartLegac:

; 1424 : 	}
; 1425 : 
; 1426 : 	if (HibernationWriteBuffer)

  000e3	48 85 c0	 test	 rax, rax
  000e6	74 11		 je	 SHORT $LN1@StartLegac

; 1427 : 	{
; 1428 : 		MmFreeContiguousMemory (HibernationWriteBuffer);

  000e8	48 8b c8	 mov	 rcx, rax
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmFreeContiguousMemory

; 1429 : 		HibernationWriteBuffer = NULL;

  000f1	48 83 25 00 00
	00 00 00	 and	 QWORD PTR HibernationWriteBuffer, 0
$LN1@StartLegac:

; 1430 : 	}
; 1431 : }

  000f9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fd	c3		 ret	 0
StartLegacyHibernationDriverFilter ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountDrive DD imagerel MountDrive
	DD	imagerel MountDrive+1145
	DD	imagerel $unwind$MountDrive
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountDrive DD 0b2b19H
	DD	0535419H
	DD	0523419H
	DD	04a0119H
	DD	0d010e012H
	DD	0700cc00eH
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	0240H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT MountDrive
_TEXT	SEGMENT
storageDeviceNumber$28189 = 48
mbr$28151 = 64
__$ArrayPad$ = 576
Extension$ = 640
password$ = 648
headerSaltCrc32$ = 656
MountDrive PROC						; COMDAT

; 265  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 266  : 	BOOL hiddenVolume = (BootArgs.HiddenSystemPartitionStart != 0);

  0002b	48 8b 05 5a 00
	00 00		 mov	 rax, QWORD PTR BootArgs+90
  00032	33 db		 xor	 ebx, ebx
  00034	49 8b e8	 mov	 rbp, r8
  00037	48 3b c3	 cmp	 rax, rbx
  0003a	44 8b eb	 mov	 r13d, ebx
  0003d	4c 8b f2	 mov	 r14, rdx
  00040	41 0f 95 c5	 setne	 r13b
  00044	48 8b f1	 mov	 rsi, rcx

; 267  : 	int64 hiddenHeaderOffset = BootArgs.HiddenSystemPartitionStart + GST_HIDDEN_VOLUME_HEADER_OFFSET;

  00047	48 8d b8 00 00
	01 00		 lea	 rdi, QWORD PTR [rax+65536]

; 268  : 	NTSTATUS status;
; 269  : 	LARGE_INTEGER offset;
; 270  : 	char *header;
; 271  : 
; 272  : 	Dump ("MountDrive pdo=%p\n", Extension->Pdo);
; 273  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
; 274  : 
; 275  : 	// Check boot drive signature first (header CRC search could fail if a user restored the header to a non-boot drive)
; 276  : 	if (BootDriveSignatureValid)

  0004e	39 1d 00 00 00
	00		 cmp	 DWORD PTR BootDriveSignatureValid, ebx
  00054	74 38		 je	 SHORT $LN28@MountDrive

; 277  : 	{
; 278  : 		byte mbr[GST_SECTOR_SIZE_BIOS];
; 279  : 
; 280  : 		offset.QuadPart = 0;
; 281  : 		status = GSTReadDevice (Extension->LowerDeviceObject, mbr, offset, GST_SECTOR_SIZE_BIOS);

  00056	48 8b 51 20	 mov	 rdx, QWORD PTR [rcx+32]
  0005a	4c 8d 44 24 40	 lea	 r8, QWORD PTR mbr$28151[rsp]
  0005f	4c 8b cb	 mov	 r9, rbx
  00062	33 c9		 xor	 ecx, ecx
  00064	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  0006c	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 282  : 
; 283  : 		if (NT_SUCCESS (status) && BootArgs.BootDriveSignature != *(uint32 *) (mbr + 0x1b8))

  00071	3b c3		 cmp	 eax, ebx
  00073	7c 19		 jl	 SHORT $LN28@MountDrive
  00075	8b 84 24 f8 01
	00 00		 mov	 eax, DWORD PTR mbr$28151[rsp+440]
  0007c	39 05 6e 00 00
	00		 cmp	 DWORD PTR BootArgs+110, eax
  00082	74 0a		 je	 SHORT $LN28@MountDrive

; 284  : 			return STATUS_UNSUCCESSFUL;

  00084	b8 01 00 00 c0	 mov	 eax, -1073741823	; ffffffffc0000001H
  00089	e9 bf 03 00 00	 jmp	 $LN30@MountDrive
$LN28@MountDrive:

; 285  : 	}
; 286  : 
; 287  : 	header = GSTalloc (GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  0008e	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00093	33 c9		 xor	 ecx, ecx
  00095	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000a1	4c 8b e0	 mov	 r12, rax

; 288  : 	if (!header)

  000a4	48 3b c3	 cmp	 rax, rbx
  000a7	75 0a		 jne	 SHORT $LN27@MountDrive

; 289  : 		return STATUS_INSUFFICIENT_RESOURCES;

  000a9	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  000ae	e9 9a 03 00 00	 jmp	 $LN30@MountDrive
$LN27@MountDrive:

; 290  : 
; 291  : 	offset.QuadPart = hiddenVolume ? hiddenHeaderOffset : GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET;
; 292  : 	Dump ("Reading volume header at %I64u\n", offset.QuadPart);
; 293  : 
; 294  : 	status = GSTReadDevice (Extension->LowerDeviceObject, header, offset, GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  000b3	48 8b 56 20	 mov	 rdx, QWORD PTR [rsi+32]
  000b7	41 b9 00 7c 00
	00		 mov	 r9d, 31744		; 00007c00H
  000bd	44 3b eb	 cmp	 r13d, ebx
  000c0	4c 0f 45 cf	 cmovne	 r9, rdi
  000c4	4c 8b c0	 mov	 r8, rax
  000c7	33 c9		 xor	 ecx, ecx
  000c9	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  000d1	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 295  : 	if (!NT_SUCCESS (status))

  000d6	3b c3		 cmp	 eax, ebx
  000d8	8b f8		 mov	 edi, eax
  000da	0f 8c 5d 03 00
	00		 jl	 $ret$28161

; 296  : 	{
; 297  : 		Dump ("GSTReadDevice error %x\n", status);
; 298  : 		goto ret;
; 299  : 	}
; 300  : 
; 301  : 	if (headerSaltCrc32)

  000e0	48 3b eb	 cmp	 rbp, rbx
  000e3	74 19		 je	 SHORT $LN25@MountDrive

; 302  : 	{
; 303  : 		uint32 saltCrc = GetCrc32 (header, PKCS5_SALT_SIZE);

  000e5	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  000ea	49 8b cc	 mov	 rcx, r12
  000ed	e8 00 00 00 00	 call	 GetCrc32

; 304  : 
; 305  : 		if (saltCrc != *headerSaltCrc32)

  000f2	3b 45 00	 cmp	 eax, DWORD PTR [rbp]

; 306  : 		{
; 307  : 			status = STATUS_UNSUCCESSFUL;
; 308  : 			goto ret;

  000f5	0f 85 3d 03 00
	00		 jne	 $LN58@MountDrive

; 309  : 		}
; 310  : 
; 311  : 		Extension->VolumeHeaderSaltCrc32 = saltCrc;

  000fb	89 46 48	 mov	 DWORD PTR [rsi+72], eax
$LN25@MountDrive:

; 312  : 	}
; 313  : 
; 314  : 	Extension->HeaderCryptoInfo = crypto_open();

  000fe	e8 00 00 00 00	 call	 crypto_open
  00103	48 89 86 d8 02
	00 00		 mov	 QWORD PTR [rsi+728], rax

; 315  : 	if (!Extension->HeaderCryptoInfo)

  0010a	48 3b c3	 cmp	 rax, rbx
  0010d	75 0a		 jne	 SHORT $LN23@MountDrive

; 316  : 	{
; 317  : 		status = STATUS_INSUFFICIENT_RESOURCES;

  0010f	bf 9a 00 00 c0	 mov	 edi, -1073741670	; ffffffffc000009aH

; 318  : 		goto ret;

  00114	e9 24 03 00 00	 jmp	 $ret$28161
$LN23@MountDrive:

; 319  : 	}
; 320  : 
; 321  : 	if (ReadVolumeHeader (!hiddenVolume, header, password, &Extension->Queue.CryptoInfo, Extension->HeaderCryptoInfo) == 0)

  00119	8b cb		 mov	 ecx, ebx
  0011b	44 3b eb	 cmp	 r13d, ebx
  0011e	4c 8d 8e 98 00
	00 00		 lea	 r9, QWORD PTR [rsi+152]
  00125	4d 8b c6	 mov	 r8, r14
  00128	49 8b d4	 mov	 rdx, r12
  0012b	0f 94 c1	 sete	 cl
  0012e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00133	e8 00 00 00 00	 call	 ReadVolumeHeader
  00138	3b c3		 cmp	 eax, ebx
  0013a	0f 85 e5 02 00
	00		 jne	 $LN22@MountDrive

; 322  : 	{
; 323  : 		// Header decrypted
; 324  : 		status = STATUS_SUCCESS;
; 325  : 		Dump ("Header decrypted\n");
; 326  : 			
; 327  : 		if (Extension->Queue.CryptoInfo->hiddenVolume)

  00140	48 8b be 98 00
	00 00		 mov	 rdi, QWORD PTR [rsi+152]
  00147	41 bd 01 00 00
	00		 mov	 r13d, 1
  0014d	39 9f 48 04 00
	00		 cmp	 DWORD PTR [rdi+1096], ebx
  00153	0f 84 91 00 00
	00		 je	 $LN21@MountDrive

; 328  : 		{
; 329  : 			int64 hiddenPartitionOffset = BootArgs.HiddenSystemPartitionStart;

  00159	48 8b 15 5a 00
	00 00		 mov	 rdx, QWORD PTR BootArgs+90

; 330  : 			Dump ("Hidden volume start offset = %I64d\n", Extension->Queue.CryptoInfo->EncryptedAreaStart.Value + hiddenPartitionOffset);
; 331  : 			
; 332  : 			Extension->HiddenSystem = TRUE;

  00160	44 89 ae e0 02
	00 00		 mov	 DWORD PTR [rsi+736], r13d

; 333  : 
; 334  : 			Extension->Queue.RemapEncryptedArea = TRUE;

  00167	44 89 ae dc 00
	00 00		 mov	 DWORD PTR [rsi+220], r13d

; 335  : 			Extension->Queue.RemappedAreaOffset = hiddenPartitionOffset + Extension->Queue.CryptoInfo->EncryptedAreaStart.Value - BootArgs.DecoySystemPartitionStart;

  0016e	48 8b 87 f8 1e
	00 00		 mov	 rax, QWORD PTR [rdi+7928]
  00175	48 2b 05 62 00
	00 00		 sub	 rax, QWORD PTR BootArgs+98
  0017c	48 03 c2	 add	 rax, rdx
  0017f	48 89 86 e0 00
	00 00		 mov	 QWORD PTR [rsi+224], rax

; 336  : 			Extension->Queue.RemappedAreaDataUnitOffset = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value / ENCRYPTION_DATA_UNIT_SIZE - BootArgs.DecoySystemPartitionStart / ENCRYPTION_DATA_UNIT_SIZE;

  00186	48 8b 8f f8 1e
	00 00		 mov	 rcx, QWORD PTR [rdi+7928]
  0018d	48 8b 05 62 00
	00 00		 mov	 rax, QWORD PTR BootArgs+98
  00194	48 c1 e8 09	 shr	 rax, 9
  00198	48 c1 e9 09	 shr	 rcx, 9
  0019c	48 2b c8	 sub	 rcx, rax
  0019f	48 89 8e e8 00
	00 00		 mov	 QWORD PTR [rsi+232], rcx

; 337  : 			
; 338  : 			Extension->Queue.CryptoInfo->EncryptedAreaStart.Value = BootArgs.DecoySystemPartitionStart;

  001a6	48 8b 05 62 00
	00 00		 mov	 rax, QWORD PTR BootArgs+98
  001ad	48 89 87 f8 1e
	00 00		 mov	 QWORD PTR [rdi+7928], rax

; 339  : 			
; 340  : 			if (Extension->Queue.CryptoInfo->VolumeSize.Value > hiddenPartitionOffset - BootArgs.DecoySystemPartitionStart)

  001b4	48 8b be 98 00
	00 00		 mov	 rdi, QWORD PTR [rsi+152]
  001bb	48 2b 15 62 00
	00 00		 sub	 rdx, QWORD PTR BootArgs+98
  001c2	48 39 97 f0 1e
	00 00		 cmp	 QWORD PTR [rdi+7920], rdx
  001c9	76 2b		 jbe	 SHORT $LN19@MountDrive

; 341  : 				GST_THROW_FATAL_EXCEPTION;

  001cb	41 8d 4d 28	 lea	 ecx, QWORD PTR [r13+40]
  001cf	45 33 c9	 xor	 r9d, r9d
  001d2	45 33 c0	 xor	 r8d, r8d
  001d5	ba 55 01 00 00	 mov	 edx, 341		; 00000155H
  001da	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  001e9	cc		 int	 3
$LN21@MountDrive:

; 342  : 
; 343  : 			Dump ("RemappedAreaOffset = %I64d\n", Extension->Queue.RemappedAreaOffset);
; 344  : 			Dump ("RemappedAreaDataUnitOffset = %I64d\n", Extension->Queue.RemappedAreaDataUnitOffset);
; 345  : 		}
; 346  : 		else
; 347  : 		{
; 348  : 			Extension->HiddenSystem = FALSE;

  001ea	89 9e e0 02 00
	00		 mov	 DWORD PTR [rsi+736], ebx

; 349  : 			Extension->Queue.RemapEncryptedArea = FALSE;

  001f0	89 9e dc 00 00
	00		 mov	 DWORD PTR [rsi+220], ebx
$LN19@MountDrive:

; 350  : 		}
; 351  : 
; 352  : 		Extension->ConfiguredEncryptedAreaStart = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value;

  001f6	48 8b 87 f8 1e
	00 00		 mov	 rax, QWORD PTR [rdi+7928]
  001fd	48 89 46 38	 mov	 QWORD PTR [rsi+56], rax

; 353  : 		Extension->ConfiguredEncryptedAreaEnd = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value + Extension->Queue.CryptoInfo->VolumeSize.Value - 1;

  00201	48 8b 87 f8 1e
	00 00		 mov	 rax, QWORD PTR [rdi+7928]
  00208	48 8b 8f f0 1e
	00 00		 mov	 rcx, QWORD PTR [rdi+7920]
  0020f	48 8d 4c 01 ff	 lea	 rcx, QWORD PTR [rcx+rax-1]
  00214	48 89 4e 40	 mov	 QWORD PTR [rsi+64], rcx

; 354  : 
; 355  : 		Extension->Queue.EncryptedAreaStart = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value;

  00218	48 8b 87 f8 1e
	00 00		 mov	 rax, QWORD PTR [rdi+7928]
  0021f	48 89 86 c8 00
	00 00		 mov	 QWORD PTR [rsi+200], rax

; 356  : 		Extension->Queue.EncryptedAreaEnd = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value + Extension->Queue.CryptoInfo->EncryptedAreaLength.Value - 1;

  00226	48 8b 87 f8 1e
	00 00		 mov	 rax, QWORD PTR [rdi+7928]
  0022d	48 8b 8f 00 1f
	00 00		 mov	 rcx, QWORD PTR [rdi+7936]
  00234	48 8d 4c 01 ff	 lea	 rcx, QWORD PTR [rcx+rax-1]

; 357  : 
; 358  : 		if (Extension->Queue.CryptoInfo->EncryptedAreaLength.Value == 0)

  00239	48 8b 86 98 00
	00 00		 mov	 rax, QWORD PTR [rsi+152]
  00240	48 89 8e d0 00
	00 00		 mov	 QWORD PTR [rsi+208], rcx
  00247	48 39 98 00 1f
	00 00		 cmp	 QWORD PTR [rax+7936], rbx
  0024e	75 12		 jne	 SHORT $LN18@MountDrive

; 359  : 		{
; 360  : 			Extension->Queue.EncryptedAreaStart = -1;

  00250	48 83 c8 ff	 or	 rax, -1
  00254	48 89 86 c8 00
	00 00		 mov	 QWORD PTR [rsi+200], rax

; 361  : 			Extension->Queue.EncryptedAreaEnd = -1;

  0025b	48 89 86 d0 00
	00 00		 mov	 QWORD PTR [rsi+208], rax
$LN18@MountDrive:

; 362  : 		}
; 363  : 
; 364  : 		Dump ("Loaded: ConfiguredEncryptedAreaStart=%I64d (%I64d)  ConfiguredEncryptedAreaEnd=%I64d (%I64d)\n", Extension->ConfiguredEncryptedAreaStart / 1024 / 1024, Extension->ConfiguredEncryptedAreaStart, Extension->ConfiguredEncryptedAreaEnd / 1024 / 1024, Extension->ConfiguredEncryptedAreaEnd);
; 365  : 		Dump ("Loaded: EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d (%I64d)\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024, Extension->Queue.EncryptedAreaEnd);
; 366  : 
; 367  : 		// Erase boot loader scheduled keys
; 368  : 		if (BootArgs.CryptoInfoLength > 0)

  00262	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR BootArgs+12
  00269	66 3b d3	 cmp	 dx, bx
  0026c	76 4c		 jbe	 SHORT $LN16@MountDrive

; 369  : 		{
; 370  : 			PHYSICAL_ADDRESS cryptoInfoAddress;
; 371  : 			byte *mappedCryptoInfo;
; 372  : 			
; 373  : 			cryptoInfoAddress.QuadPart = (BootLoaderSegment << 4) + BootArgs.CryptoInfoOffset;

  0026e	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR BootLoaderSegment
  00275	0f b7 05 0a 00
	00 00		 movzx	 eax, WORD PTR BootArgs+10

; 374  : 			mappedCryptoInfo = MmMapIoSpace (cryptoInfoAddress, BootArgs.CryptoInfoLength, MmCached);

  0027c	0f b7 d2	 movzx	 edx, dx
  0027f	c1 e1 04	 shl	 ecx, 4
  00282	45 8b c5	 mov	 r8d, r13d
  00285	03 c8		 add	 ecx, eax
  00287	48 63 c9	 movsxd	 rcx, ecx
  0028a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapIoSpace
  00290	48 8b f8	 mov	 rdi, rax

; 375  : 			
; 376  : 			if (mappedCryptoInfo)

  00293	48 3b c3	 cmp	 rax, rbx
  00296	74 22		 je	 SHORT $LN16@MountDrive

; 377  : 			{
; 378  : 				Dump ("Wiping memory %x %d\n", cryptoInfoAddress.LowPart, BootArgs.CryptoInfoLength);
; 379  : 				memset (mappedCryptoInfo, 0, BootArgs.CryptoInfoLength);

  00298	44 0f b7 05 0c
	00 00 00	 movzx	 r8d, WORD PTR BootArgs+12
  002a0	33 d2		 xor	 edx, edx
  002a2	48 8b c8	 mov	 rcx, rax
  002a5	e8 00 00 00 00	 call	 memset

; 380  : 				MmUnmapIoSpace (mappedCryptoInfo, BootArgs.CryptoInfoLength);

  002aa	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR BootArgs+12
  002b1	48 8b cf	 mov	 rcx, rdi
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmUnmapIoSpace
$LN16@MountDrive:

; 381  : 			}
; 382  : 		}
; 383  : 
; 384  : 		BootDriveFilterExtension = Extension;
; 385  : 		BootDriveFound = Extension->BootDrive = Extension->DriveMounted = Extension->VolumeHeaderPresent = TRUE;
; 386  : 		BootDriveFilterExtension->MagicNumber = GST_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER;

  002ba	48 b8 54 58 45
	42 45 55 52 54	 mov	 rax, 6076012603229165652 ; 5452554542455854H
  002c4	44 89 ae b4 02
	00 00		 mov	 DWORD PTR [rsi+692], r13d
  002cb	44 89 ae b8 02
	00 00		 mov	 DWORD PTR [rsi+696], r13d
  002d2	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
  002d6	44 89 ae b0 02
	00 00		 mov	 DWORD PTR [rsi+688], r13d

; 387  : 
; 388  : 		burn (&BootArgs.BootPassword, sizeof (BootArgs.BootPassword));

  002dd	48 8d 15 12 00
	00 00		 lea	 rdx, OFFSET FLAT:BootArgs+18
  002e4	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  002ea	33 c0		 xor	 eax, eax
  002ec	48 8b fa	 mov	 rdi, rdx
  002ef	49 8b c8	 mov	 rcx, r8
  002f2	48 89 35 00 00
	00 00		 mov	 QWORD PTR BootDriveFilterExtension, rsi
  002f9	44 89 2d 00 00
	00 00		 mov	 DWORD PTR BootDriveFound, r13d
  00300	f3 aa		 rep stosb
$LL12@MountDrive:
  00302	45 2b c5	 sub	 r8d, r13d
  00305	88 1a		 mov	 BYTE PTR [rdx], bl
  00307	49 03 d5	 add	 rdx, r13
  0030a	44 3b c3	 cmp	 r8d, ebx
  0030d	75 f3		 jne	 SHORT $LL12@MountDrive

; 389  : 
; 390  : 		{
; 391  : 			STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 392  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  0030f	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  00313	48 8d 44 24 30	 lea	 rax, QWORD PTR storageDeviceNumber$28189[rsp]
  00318	45 33 c9	 xor	 r9d, r9d
  0031b	45 33 c0	 xor	 r8d, r8d
  0031e	ba 80 10 2d 00	 mov	 edx, 2953344		; 002d1080H
  00323	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR [rsp+40], 12
  0032b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00330	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 393  : 
; 394  : 			if (!NT_SUCCESS (status))

  00335	3b c3		 cmp	 eax, ebx
  00337	7d 05		 jge	 SHORT $LN10@MountDrive

; 395  : 			{
; 396  : 				Dump ("Failed to get drive number - error %x\n", status);
; 397  : 				Extension->SystemStorageDeviceNumberValid = FALSE;

  00339	89 5e 34	 mov	 DWORD PTR [rsi+52], ebx

; 398  : 			}
; 399  : 			else

  0033c	eb 0b		 jmp	 SHORT $LN9@MountDrive
$LN10@MountDrive:

; 400  : 			{
; 401  : 				Extension->SystemStorageDeviceNumber = storageDeviceNumber.DeviceNumber;

  0033e	8b 44 24 34	 mov	 eax, DWORD PTR storageDeviceNumber$28189[rsp+4]

; 402  : 				Extension->SystemStorageDeviceNumberValid = TRUE;

  00342	44 89 6e 34	 mov	 DWORD PTR [rsi+52], r13d
  00346	89 46 30	 mov	 DWORD PTR [rsi+48], eax
$LN9@MountDrive:

; 403  : 			}
; 404  : 		}
; 405  : 
; 406  : 		status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &BootDriveLength, sizeof (BootDriveLength));

  00349	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  0034d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:BootDriveLength
  00354	45 33 c9	 xor	 r9d, r9d
  00357	45 33 c0	 xor	 r8d, r8d
  0035a	ba 5c 40 07 00	 mov	 edx, 475228		; 0007405cH
  0035f	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  00367	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0036c	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 407  : 		
; 408  : 		if (!NT_SUCCESS (status))

  00371	3b c3		 cmp	 eax, ebx
  00373	7d 10		 jge	 SHORT $LN8@MountDrive

; 409  : 		{
; 410  : 			Dump ("Failed to get drive length - error %x\n", status);
; 411  : 			BootDriveLength.QuadPart = 0;

  00375	48 89 1d 00 00
	00 00		 mov	 QWORD PTR BootDriveLength, rbx

; 412  : 			Extension->Queue.MaxReadAheadOffset.QuadPart = 0;

  0037c	48 89 9e 28 02
	00 00		 mov	 QWORD PTR [rsi+552], rbx

; 413  : 		}
; 414  : 		else

  00383	eb 0e		 jmp	 SHORT $LN7@MountDrive
$LN8@MountDrive:

; 415  : 			Extension->Queue.MaxReadAheadOffset = BootDriveLength;

  00385	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveLength
  0038c	48 89 86 28 02
	00 00		 mov	 QWORD PTR [rsi+552], rax
$LN7@MountDrive:

; 416  : 		
; 417  : 		status = EncryptedIoQueueStart (&Extension->Queue);

  00393	48 8d 4e 50	 lea	 rcx, QWORD PTR [rsi+80]
  00397	e8 00 00 00 00	 call	 EncryptedIoQueueStart
  0039c	48 63 f8	 movsxd	 rdi, eax

; 418  : 		if (!NT_SUCCESS (status))

  0039f	3b fb		 cmp	 edi, ebx
  003a1	7d 1f		 jge	 SHORT $LN6@MountDrive

; 419  : 			GST_BUG_CHECK (status);

  003a3	45 33 c9	 xor	 r9d, r9d
  003a6	4c 8b c7	 mov	 r8, rdi
  003a9	ba a3 01 00 00	 mov	 edx, 419		; 000001a3H
  003ae	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  003b2	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  003bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  003c1	cc		 int	 3
$LN6@MountDrive:
  003c2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR OsMajorVersion
  003c8	c1 e0 08	 shl	 eax, 8

; 420  : 
; 421  : 		if (IsOSAtLeast (WIN_VISTA))

  003cb	0b 05 00 00 00
	00		 or	 eax, DWORD PTR OsMinorVersion
  003d1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  003d6	3d 00 06 00 00	 cmp	 eax, 1536		; 00000600H
  003db	72 10		 jb	 SHORT $LN5@MountDrive

; 422  : 		{
; 423  : 			CrashDumpEnabled = TRUE;

  003dd	44 89 2d 00 00
	00 00		 mov	 DWORD PTR CrashDumpEnabled, r13d

; 424  : 			HibernationEnabled = TRUE;

  003e4	44 89 2d 00 00
	00 00		 mov	 DWORD PTR HibernationEnabled, r13d
  003eb	eb 0d		 jmp	 SHORT $LN3@MountDrive
$LN5@MountDrive:

; 425  : 		}
; 426  : 		else if (!LegacyHibernationDriverFilterActive)

  003ed	39 1d 00 00 00
	00		 cmp	 DWORD PTR LegacyHibernationDriverFilterActive, ebx
  003f3	75 05		 jne	 SHORT $LN3@MountDrive

; 427  : 			StartLegacyHibernationDriverFilter();

  003f5	e8 00 00 00 00	 call	 StartLegacyHibernationDriverFilter
$LN3@MountDrive:

; 428  : 
; 429  : 		// Hidden system hibernation is not supported if an extra boot partition is present as the system is not allowed to update the boot partition
; 430  : 		if (IsHiddenSystemRunning() && (BootArgs.Flags & GST_BOOT_ARGS_FLAG_EXTRA_BOOT_PARTITION))

  003fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00401	48 3b c3	 cmp	 rax, rbx
  00404	74 37		 je	 SHORT $ret$28161
  00406	39 98 e0 02 00
	00		 cmp	 DWORD PTR [rax+736], ebx
  0040c	74 2f		 je	 SHORT $ret$28161
  0040e	44 84 2d 6a 00
	00 00		 test	 BYTE PTR BootArgs+106, r13b
  00415	74 26		 je	 SHORT $ret$28161

; 431  : 		{
; 432  : 			CrashDumpEnabled = FALSE;

  00417	89 1d 00 00 00
	00		 mov	 DWORD PTR CrashDumpEnabled, ebx

; 433  : 			HibernationEnabled = FALSE;

  0041d	89 1d 00 00 00
	00		 mov	 DWORD PTR HibernationEnabled, ebx

; 434  : 		}
; 435  : 	}
; 436  : 	else

  00423	eb 18		 jmp	 SHORT $ret$28161
$LN22@MountDrive:

; 437  : 	{
; 438  : 		Dump ("Header not decrypted\n");
; 439  : 		crypto_close (Extension->HeaderCryptoInfo);

  00425	48 8b 8e d8 02
	00 00		 mov	 rcx, QWORD PTR [rsi+728]
  0042c	e8 00 00 00 00	 call	 crypto_close

; 440  : 		Extension->HeaderCryptoInfo = NULL;

  00431	48 89 9e d8 02
	00 00		 mov	 QWORD PTR [rsi+728], rbx
$LN58@MountDrive:

; 441  : 
; 442  : 		status = STATUS_UNSUCCESSFUL;

  00438	bf 01 00 00 c0	 mov	 edi, -1073741823	; ffffffffc0000001H
$ret$28161:

; 443  : 	}
; 444  : 
; 445  : ret:
; 446  : 	GSTfree (header);

  0043d	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00442	49 8b cc	 mov	 rcx, r12
  00445	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 447  : 	return status;

  0044b	8b c7		 mov	 eax, edi
$LN30@MountDrive:

; 448  : }

  0044d	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00455	48 33 cc	 xor	 rcx, rsp
  00458	e8 00 00 00 00	 call	 __security_check_cookie
  0045d	4c 8d 9c 24 50
	02 00 00	 lea	 r11, QWORD PTR [rsp+592]
  00465	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  00469	49 8b 6b 48	 mov	 rbp, QWORD PTR [r11+72]
  0046d	49 8b e3	 mov	 rsp, r11
  00470	41 5e		 pop	 r14
  00472	41 5d		 pop	 r13
  00474	41 5c		 pop	 r12
  00476	5f		 pop	 rdi
  00477	5e		 pop	 rsi
  00478	c3		 ret	 0
$LN57@MountDrive:
MountDrive ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckDeviceTypeAndMount DD imagerel CheckDeviceTypeAndMount
	DD	imagerel CheckDeviceTypeAndMount+182
	DD	imagerel $unwind$CheckDeviceTypeAndMount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckDeviceTypeAndMount DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CheckDeviceTypeAndMount
_TEXT	SEGMENT
filterExtension$ = 64
CheckDeviceTypeAndMount PROC				; COMDAT

; 620  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 621  : 	if (BootArgsValid)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR BootArgsValid, 0
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	0f 84 9a 00 00
	00		 je	 $LN3@CheckDevic

; 622  : 	{
; 623  : 		// Windows sometimes merges a removable drive PDO and its volume PDO to a single PDO having no volume interface (GUID_DEVINTERFACE_VOLUME).
; 624  : 		// Therefore, we need to test whether the device supports volume IOCTLs.
; 625  : 		if (VolumeClassFilterRegistered
; 626  : 			&& BootArgs.HiddenSystemPartitionStart != 0
; 627  : 			&& IsVolumeDevice (filterExtension->LowerDeviceObject))

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR VolumeClassFilterRegistered, 0
  0001d	74 24		 je	 SHORT $LN4@CheckDevic
  0001f	48 83 3d 5a 00
	00 00 00	 cmp	 QWORD PTR BootArgs+90, 0
  00027	74 1a		 je	 SHORT $LN4@CheckDevic
  00029	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0002d	e8 00 00 00 00	 call	 IsVolumeDevice
  00032	85 c0		 test	 eax, eax
  00034	74 0d		 je	 SHORT $LN4@CheckDevic

; 628  : 		{
; 629  : 			Dump ("Drive and volume merged pdo=%p", filterExtension->Pdo);
; 630  : 
; 631  : 			filterExtension->IsVolumeFilterDevice = TRUE;
; 632  : 			filterExtension->IsDriveFilterDevice = FALSE;

  00036	83 63 08 00	 and	 DWORD PTR [rbx+8], 0
  0003a	c7 43 0c 01 00
	00 00		 mov	 DWORD PTR [rbx+12], 1

; 633  : 		}
; 634  : 		else

  00041	eb 6d		 jmp	 SHORT $LN3@CheckDevic
$LN4@CheckDevic:

; 635  : 		{
; 636  : 			NTSTATUS status = KeWaitForMutexObject (&MountMutex, Executive, KernelMode, FALSE, NULL);

  00043	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MountMutex
  00050	45 33 c9	 xor	 r9d, r9d
  00053	45 33 c0	 xor	 r8d, r8d
  00056	33 d2		 xor	 edx, edx
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 637  : 			if (!NT_SUCCESS (status))

  0005e	85 c0		 test	 eax, eax
  00060	79 1f		 jns	 SHORT $LN2@CheckDevic

; 638  : 				GST_BUG_CHECK (status);

  00062	45 33 c9	 xor	 r9d, r9d
  00065	4c 63 c0	 movsxd	 r8, eax
  00068	ba 7e 02 00 00	 mov	 edx, 638		; 0000027eH
  0006d	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00071	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00080	cc		 int	 3
$LN2@CheckDevic:

; 639  : 
; 640  : 			if (!BootDriveFound)

  00081	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR BootDriveFound
  00087	85 c0		 test	 eax, eax
  00089	75 16		 jne	 SHORT $LN1@CheckDevic

; 641  : 				MountDrive (filterExtension, &BootArgs.BootPassword, &BootArgs.HeaderSaltCrc32);

  0008b	4c 8d 05 0e 00
	00 00		 lea	 r8, OFFSET FLAT:BootArgs+14
  00092	48 8d 15 12 00
	00 00		 lea	 rdx, OFFSET FLAT:BootArgs+18
  00099	48 8b cb	 mov	 rcx, rbx
  0009c	e8 00 00 00 00	 call	 MountDrive
$LN1@CheckDevic:

; 642  : 
; 643  : 			KeReleaseMutex (&MountMutex, FALSE);

  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MountMutex
  000a8	33 d2		 xor	 edx, edx
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex
$LN3@CheckDevic:

; 644  : 		}
; 645  : 	}
; 646  : }

  000b0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b4	5b		 pop	 rbx
  000b5	c3		 ret	 0
$LN8@CheckDevic:
CheckDeviceTypeAndMount ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountDriveWorkItemRoutine DD imagerel MountDriveWorkItemRoutine
	DD	imagerel MountDriveWorkItemRoutine+41
	DD	imagerel $unwind$MountDriveWorkItemRoutine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountDriveWorkItemRoutine DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT MountDriveWorkItemRoutine
_TEXT	SEGMENT
deviceObject$ = 48
filterExtension$ = 56
MountDriveWorkItemRoutine PROC				; COMDAT

; 659  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 660  : 	CheckDeviceTypeAndMount (filterExtension);

  00006	48 8b ca	 mov	 rcx, rdx
  00009	48 8b da	 mov	 rbx, rdx
  0000c	e8 00 00 00 00	 call	 CheckDeviceTypeAndMount

; 661  : 	KeSetEvent (&filterExtension->MountWorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);

  00011	48 8d 8b c0 02
	00 00		 lea	 rcx, QWORD PTR [rbx+704]
  00018	45 33 c0	 xor	 r8d, r8d
  0001b	33 d2		 xor	 edx, edx

; 662  : }

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeSetEvent
MountDriveWorkItemRoutine ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$OnStartDeviceCompleted DD imagerel OnStartDeviceCompleted
	DD	imagerel OnStartDeviceCompleted+235
	DD	imagerel $unwind$OnStartDeviceCompleted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnStartDeviceCompleted DD 0a1901H
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0c0155219H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT OnStartDeviceCompleted
_TEXT	SEGMENT
filterDeviceObject$ = 64
Irp$ = 72
Extension$ = 80
OnStartDeviceCompleted PROC				; COMDAT

; 676  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 677  : 	if (Irp->PendingReturned)

  00019	33 ff		 xor	 edi, edi
  0001b	49 8b f0	 mov	 rsi, r8
  0001e	48 8b ea	 mov	 rbp, rdx
  00021	40 38 7a 41	 cmp	 BYTE PTR [rdx+65], dil
  00025	74 0b		 je	 SHORT $LN8@OnStartDev@2

; 678  : 		IoMarkIrpPending (Irp);

  00027	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0002e	80 48 03 01	 or	 BYTE PTR [rax+3], 1
$LN8@OnStartDev@2:

; 679  : 
; 680  : 	if (Extension->LowerDeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)

  00032	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00036	f6 40 34 01	 test	 BYTE PTR [rax+52], 1
  0003a	74 04		 je	 SHORT $LN4@OnStartDev@2

; 681  : 		filterDeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;

  0003c	83 49 34 01	 or	 DWORD PTR [rcx+52], 1
$LN4@OnStartDev@2:

; 682  : 
; 683  : 	if (KeGetCurrentIrql() == PASSIVE_LEVEL)

  00040	44 0f 20 c0	 mov	 rax, cr8
  00044	40 3a c7	 cmp	 al, dil
  00047	75 0a		 jne	 SHORT $LN3@OnStartDev@2

; 684  : 	{
; 685  : 		CheckDeviceTypeAndMount (Extension);

  00049	49 8b c8	 mov	 rcx, r8
  0004c	e8 00 00 00 00	 call	 CheckDeviceTypeAndMount

; 686  : 	}
; 687  : 	else

  00051	eb 65		 jmp	 SHORT $LN14@OnStartDev@2
$LN3@OnStartDev@2:

; 688  : 	{
; 689  : 		PIO_WORKITEM workItem = IoAllocateWorkItem (filterDeviceObject);

  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAllocateWorkItem
  00059	4c 8b e0	 mov	 r12, rax

; 690  : 		if (!workItem)

  0005c	48 3b c7	 cmp	 rax, rdi
  0005f	75 07		 jne	 SHORT $LN1@OnStartDev@2
  00061	bf 9a 00 00 c0	 mov	 edi, -1073741670	; ffffffffc000009aH
  00066	eb 50		 jmp	 SHORT $LN14@OnStartDev@2
$LN1@OnStartDev@2:

; 691  : 		{
; 692  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);
; 693  : 			return STATUS_INSUFFICIENT_RESOURCES;
; 694  : 		}
; 695  : 
; 696  : 		KeInitializeEvent (&Extension->MountWorkItemCompletedEvent, SynchronizationEvent, FALSE);

  00068	45 33 c0	 xor	 r8d, r8d
  0006b	48 8d 8e c0 02
	00 00		 lea	 rcx, QWORD PTR [rsi+704]
  00072	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 697  : 		IoQueueWorkItem (workItem, MountDriveWorkItemRoutine, DelayedWorkQueue, Extension); 

  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:MountDriveWorkItemRoutine
  00083	4c 8b ce	 mov	 r9, rsi
  00086	41 b8 01 00 00
	00		 mov	 r8d, 1
  0008c	49 8b cc	 mov	 rcx, r12
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoQueueWorkItem

; 698  : 
; 699  : 		KeWaitForSingleObject (&Extension->MountWorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);

  00095	48 8d 8e c0 02
	00 00		 lea	 rcx, QWORD PTR [rsi+704]
  0009c	45 33 c9	 xor	 r9d, r9d
  0009f	45 33 c0	 xor	 r8d, r8d
  000a2	33 d2		 xor	 edx, edx
  000a4	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 700  : 		IoFreeWorkItem (workItem);

  000af	49 8b cc	 mov	 rcx, r12
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoFreeWorkItem
$LN14@OnStartDev@2:
  000b8	48 8d 8e f0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+240]
  000bf	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000c5	48 8b d5	 mov	 rdx, rbp
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 701  : 	}
; 702  : 
; 703  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);
; 704  : 	return STATUS_CONTINUE_COMPLETION;
; 705  : }

  000ce	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d3	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000d8	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000dd	8b c7		 mov	 eax, edi
  000df	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000e4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e8	41 5c		 pop	 r12
  000ea	c3		 ret	 0
OnStartDeviceCompleted ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$DispatchPnp DD imagerel DispatchPnp
	DD	imagerel DispatchPnp+530
	DD	imagerel $unwind$DispatchPnp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DispatchPnp DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT DispatchPnp
_TEXT	SEGMENT
DeviceObject$ = 80
Irp$ = 88
Extension$ = 96
irpSp$ = 104
DispatchPnp PROC					; COMDAT

; 720  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 721  : 	NTSTATUS status;
; 722  : 
; 723  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00018	4d 8d a8 f0 00
	00 00		 lea	 r13, QWORD PTR [r8+240]
  0001f	49 8b d8	 mov	 rbx, r8
  00022	4d 8b e1	 mov	 r12, r9
  00025	48 8b e9	 mov	 rbp, rcx
  00028	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  0002f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00035	49 8b cd	 mov	 rcx, r13
  00038	48 8b fa	 mov	 rdi, rdx
  0003b	c7 40 d8 20 00
	00 00		 mov	 DWORD PTR [rax-40], 32	; 00000020H
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00048	8b f0		 mov	 esi, eax

; 724  : 	if (!NT_SUCCESS (status))

  0004a	85 c0		 test	 eax, eax
  0004c	79 08		 jns	 SHORT $LN15@DispatchPn@2

; 725  : 		return GSTCompleteIrp (Irp, status, 0);

  0004e	89 47 30	 mov	 DWORD PTR [rdi+48], eax
  00051	e9 c1 00 00 00	 jmp	 $LN35@DispatchPn@2
$LN15@DispatchPn@2:

; 726  : 
; 727  : 	switch (irpSp->MinorFunction)

  00056	41 8a 44 24 01	 mov	 al, BYTE PTR [r12+1]
  0005b	84 c0		 test	 al, al
  0005d	0f 84 80 01 00
	00		 je	 $LN12@DispatchPn@2
  00063	3c 02		 cmp	 al, 2
  00065	0f 84 cf 00 00
	00		 je	 $LN4@DispatchPn@2
  0006b	3c 16		 cmp	 al, 22
  0006d	74 33		 je	 SHORT $LN11@DispatchPn@2

; 785  : 
; 786  : 
; 787  : 	default:
; 788  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  0006f	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00073	fe 47 43	 inc	 BYTE PTR [rdi+67]
  00076	48 83 87 b8 00
	00 00 48	 add	 QWORD PTR [rdi+184], 72	; 00000048H
  0007e	48 8b d7	 mov	 rdx, rdi
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 789  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00087	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0008d	48 8b d7	 mov	 rdx, rdi
  00090	49 8b cd	 mov	 rcx, r13
  00093	8b d8		 mov	 ebx, eax
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 790  : 	}
; 791  : 	return status;

  0009b	8b c3		 mov	 eax, ebx
  0009d	e9 57 01 00 00	 jmp	 $LN16@DispatchPn@2
$LN11@DispatchPn@2:

; 732  : 
; 733  : 
; 734  : 	case IRP_MN_DEVICE_USAGE_NOTIFICATION:
; 735  : 		Dump ("IRP_MN_DEVICE_USAGE_NOTIFICATION type=%d\n", (int) irpSp->Parameters.UsageNotification.Type);
; 736  : 
; 737  : 		{
; 738  : 			PDEVICE_OBJECT attachedDevice = IoGetAttachedDeviceReference (DeviceObject);

  000a2	48 8b cd	 mov	 rcx, rbp
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetAttachedDeviceReference

; 739  : 
; 740  : 			if (attachedDevice == DeviceObject || (attachedDevice->Flags & DO_POWER_PAGABLE))

  000ab	48 3b c5	 cmp	 rax, rbp
  000ae	74 07		 je	 SHORT $LN9@DispatchPn@2
  000b0	0f ba 60 30 0d	 bt	 DWORD PTR [rax+48], 13
  000b5	73 05		 jae	 SHORT $LN10@DispatchPn@2
$LN9@DispatchPn@2:

; 741  : 				DeviceObject->Flags |= DO_POWER_PAGABLE;

  000b7	0f ba 6d 30 0d	 bts	 DWORD PTR [rbp+48], 13
$LN10@DispatchPn@2:

; 742  : 
; 743  : 			ObDereferenceObject (attachedDevice);

  000bc	48 8b c8	 mov	 rcx, rax
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 744  : 		}
; 745  : 
; 746  : 		// Prevent creation of hibernation and crash dump files if required
; 747  : 		if (irpSp->Parameters.UsageNotification.InPath
; 748  : 			&& (
; 749  : 				(irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile && !CrashDumpEnabled)
; 750  : 				|| (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation && !HibernationEnabled)
; 751  : 				)
; 752  : 			)

  000c5	41 80 7c 24 08
	00		 cmp	 BYTE PTR [r12+8], 0
  000cb	74 61		 je	 SHORT $LN8@DispatchPn@2
  000cd	41 83 7c 24 10
	03		 cmp	 DWORD PTR [r12+16], 3
  000d3	75 09		 jne	 SHORT $LN6@DispatchPn@2
  000d5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR CrashDumpEnabled, 0
  000dc	74 11		 je	 SHORT $LN7@DispatchPn@2
$LN6@DispatchPn@2:
  000de	41 83 7c 24 10
	02		 cmp	 DWORD PTR [r12+16], 2
  000e4	75 48		 jne	 SHORT $LN8@DispatchPn@2
  000e6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR HibernationEnabled, 0
  000ed	75 3f		 jne	 SHORT $LN8@DispatchPn@2
$LN7@DispatchPn@2:

; 753  : 		{
; 754  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000ef	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000f5	48 8b d7	 mov	 rdx, rdi
  000f8	49 8b cd	 mov	 rcx, r13
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 755  : 
; 756  : 			if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation)

  00101	41 83 7c 24 10
	02		 cmp	 DWORD PTR [r12+16], 2
  00107	75 06		 jne	 SHORT $LN5@DispatchPn@2

; 757  : 				++HibernationPreventionCount;

  00109	ff 05 00 00 00
	00		 inc	 DWORD PTR HibernationPreventionCount
$LN5@DispatchPn@2:

; 758  : 
; 759  : 			Dump ("Preventing dump type=%d\n", (int) irpSp->Parameters.UsageNotification.Type);
; 760  : 			return GSTCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);

  0010f	be 01 00 00 c0	 mov	 esi, -1073741823	; ffffffffc0000001H
  00114	89 77 30	 mov	 DWORD PTR [rdi+48], esi
$LN35@DispatchPn@2:
  00117	48 83 67 38 00	 and	 QWORD PTR [rdi+56], 0
  0011c	33 d2		 xor	 edx, edx
  0011e	48 8b cf	 mov	 rcx, rdi
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  00127	8b c6		 mov	 eax, esi
  00129	e9 cb 00 00 00	 jmp	 $LN16@DispatchPn@2
$LN8@DispatchPn@2:

; 761  : 		}
; 762  : 
; 763  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnDeviceUsageNotificationCompleted, Extension);

  0012e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:OnDeviceUsageNotificationCompleted
  00135	e9 b0 00 00 00	 jmp	 $LN36@DispatchPn@2
$LN4@DispatchPn@2:

; 764  : 
; 765  : 
; 766  : 	case IRP_MN_REMOVE_DEVICE:
; 767  : 		Dump ("IRP_MN_REMOVE_DEVICE pdo=%p\n", Extension->Pdo);
; 768  : 
; 769  : 		IoReleaseRemoveLockAndWait (&Extension->Queue.RemoveLock, Irp);

  0013a	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00140	48 8b d7	 mov	 rdx, rdi
  00143	49 8b cd	 mov	 rcx, r13
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockAndWaitEx

; 770  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  0014c	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00150	fe 47 43	 inc	 BYTE PTR [rdi+67]
  00153	48 83 87 b8 00
	00 00 48	 add	 QWORD PTR [rdi+184], 72	; 00000048H
  0015b	48 8b d7	 mov	 rdx, rdi
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 771  : 
; 772  : 		IoDetachDevice (Extension->LowerDeviceObject);

  00164	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00168	8b f8		 mov	 edi, eax
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDetachDevice

; 773  : 
; 774  : 		if (Extension->DriveMounted)

  00170	83 bb b8 02 00
	00 00		 cmp	 DWORD PTR [rbx+696], 0
  00177	74 42		 je	 SHORT $LN27@DispatchPn@2

; 775  : 			DismountDrive (Extension, TRUE);

  00179	8b 8b 90 02 00
	00		 mov	 ecx, DWORD PTR [rbx+656]
  0017f	85 c9		 test	 ecx, ecx
  00181	75 09		 jne	 SHORT $LN26@DispatchPn@2
  00183	48 8d 4b 50	 lea	 rcx, QWORD PTR [rbx+80]
  00187	e8 00 00 00 00	 call	 EncryptedIoQueueStop
$LN26@DispatchPn@2:
  0018c	48 8b 8b 98 00
	00 00		 mov	 rcx, QWORD PTR [rbx+152]
  00193	e8 00 00 00 00	 call	 crypto_close
  00198	48 8b 8b d8 02
	00 00		 mov	 rcx, QWORD PTR [rbx+728]
  0019f	48 83 a3 98 00
	00 00 00	 and	 QWORD PTR [rbx+152], 0
  001a7	e8 00 00 00 00	 call	 crypto_close
  001ac	48 83 a3 d8 02
	00 00 00	 and	 QWORD PTR [rbx+728], 0
  001b4	83 a3 b8 02 00
	00 00		 and	 DWORD PTR [rbx+696], 0
$LN27@DispatchPn@2:

; 776  : 
; 777  : 		if (Extension->BootDrive)

  001bb	83 bb b0 02 00
	00 00		 cmp	 DWORD PTR [rbx+688], 0
  001c2	74 12		 je	 SHORT $LN2@DispatchPn@2

; 778  : 		{
; 779  : 			BootDriveFound = FALSE;
; 780  : 			BootDriveFilterExtension = NULL;

  001c4	48 83 25 00 00
	00 00 00	 and	 QWORD PTR BootDriveFilterExtension, 0
  001cc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR BootDriveFound, 0
$LN2@DispatchPn@2:

; 781  : 		}
; 782  : 
; 783  : 		IoDeleteDevice (DeviceObject);

  001d6	48 8b cd	 mov	 rcx, rbp
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 784  : 		return status;

  001df	8b c7		 mov	 eax, edi
  001e1	eb 16		 jmp	 SHORT $LN16@DispatchPn@2
$LN12@DispatchPn@2:

; 728  : 	{
; 729  : 	case IRP_MN_START_DEVICE:
; 730  : 		Dump ("IRP_MN_START_DEVICE pdo=%p\n", Extension->Pdo);
; 731  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnStartDeviceCompleted, Extension);

  001e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:OnStartDeviceCompleted
$LN36@DispatchPn@2:
  001ea	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  001ee	4c 8b cb	 mov	 r9, rbx
  001f1	48 8b d7	 mov	 rdx, rdi
  001f4	e8 00 00 00 00	 call	 PassFilteredIrp
$LN16@DispatchPn@2:

; 792  : }

  001f9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001fe	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00203	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00208	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0020c	41 5d		 pop	 r13
  0020e	41 5c		 pop	 r12
  00210	5f		 pop	 rdi
  00211	c3		 ret	 0
DispatchPnp ENDP
_TEXT	ENDS
PUBLIC	DriveFilterDispatchIrp
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$DriveFilterDispatchIrp DD imagerel $LN21
	DD	imagerel $LN21+272
	DD	imagerel $unwind$DriveFilterDispatchIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriveFilterDispatchIrp DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
xdata	ENDS
;	COMDAT DriveFilterDispatchIrp
_TEXT	SEGMENT
DeviceObject$ = 64
Irp$ = 72
DriveFilterDispatchIrp PROC				; COMDAT

; 853  : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 854  : 	DriveFilterExtension *Extension = (DriveFilterExtension *) DeviceObject->DeviceExtension;
; 855  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00014	4c 8b 8a b8 00
	00 00		 mov	 r9, QWORD PTR [rdx+184]
  0001b	48 8b 59 40	 mov	 rbx, QWORD PTR [rcx+64]
  0001f	48 8b fa	 mov	 rdi, rdx

; 856  : 	NTSTATUS status;
; 857  : 
; 858  : 	ASSERT (!Extension->bRootDevice && Extension->IsDriveFilterDevice);
; 859  : 
; 860  : 	switch (irpSp->MajorFunction)

  00022	41 80 39 03	 cmp	 BYTE PTR [r9], 3
  00026	72 63		 jb	 SHORT $LN5@DriveFilte@2
  00028	41 80 39 04	 cmp	 BYTE PTR [r9], 4
  0002c	76 26		 jbe	 SHORT $LN6@DriveFilte@2
  0002e	41 80 39 16	 cmp	 BYTE PTR [r9], 22
  00032	74 13		 je	 SHORT $LN2@DriveFilte@2
  00034	41 80 39 1b	 cmp	 BYTE PTR [r9], 27
  00038	75 51		 jne	 SHORT $LN5@DriveFilte@2

; 872  : 		}
; 873  : 		break;
; 874  : 
; 875  : 	case IRP_MJ_PNP:
; 876  : 		return DispatchPnp (DeviceObject, Irp, Extension, irpSp);

  0003a	4c 8b c3	 mov	 r8, rbx
  0003d	e8 00 00 00 00	 call	 DispatchPnp
  00042	e9 b4 00 00 00	 jmp	 $LN9@DriveFilte@2
$LN2@DriveFilte@2:

; 877  : 
; 878  : 	case IRP_MJ_POWER:
; 879  : 		return DispatchPower (DeviceObject, Irp, Extension, irpSp);

  00047	4c 8b c3	 mov	 r8, rbx
  0004a	e8 00 00 00 00	 call	 DispatchPower
  0004f	e9 a7 00 00 00	 jmp	 $LN9@DriveFilte@2
$LN6@DriveFilte@2:

; 861  : 	{
; 862  : 	case IRP_MJ_READ:
; 863  : 	case IRP_MJ_WRITE:
; 864  : 		if (Extension->BootDrive)

  00054	83 bb b0 02 00
	00 00		 cmp	 DWORD PTR [rbx+688], 0
  0005b	74 2e		 je	 SHORT $LN5@DriveFilte@2

; 865  : 		{
; 866  : 			status = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);

  0005d	48 8d 4b 50	 lea	 rcx, QWORD PTR [rbx+80]
  00061	e8 00 00 00 00	 call	 EncryptedIoQueueAddIrp
  00066	8b d8		 mov	 ebx, eax

; 867  : 			
; 868  : 			if (status != STATUS_PENDING)

  00068	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  0006d	0f 84 86 00 00
	00		 je	 $LN13@DriveFilte@2

; 869  : 				GSTCompleteDiskIrp (Irp, status, 0);

  00073	48 83 67 38 00	 and	 QWORD PTR [rdi+56], 0
  00078	85 c0		 test	 eax, eax
  0007a	48 8b cf	 mov	 rcx, rdi
  0007d	0f 99 c2	 setns	 dl
  00080	89 47 30	 mov	 DWORD PTR [rdi+48], eax
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 870  : 
; 871  : 			return status;

  00089	eb 6e		 jmp	 SHORT $LN13@DriveFilte@2
$LN5@DriveFilte@2:

; 880  : 	}
; 881  : 
; 882  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0008b	48 8d ab f0 00
	00 00		 lea	 rbp, QWORD PTR [rbx+240]
  00092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00099	41 b9 01 00 00
	00		 mov	 r9d, 1
  0009f	48 8b cd	 mov	 rcx, rbp
  000a2	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  000b0	8b f0		 mov	 esi, eax

; 883  : 	if (!NT_SUCCESS (status))

  000b2	85 c0		 test	 eax, eax
  000b4	79 17		 jns	 SHORT $LN1@DriveFilte@2

; 884  : 		return GSTCompleteIrp (Irp, status, 0);

  000b6	48 83 67 38 00	 and	 QWORD PTR [rdi+56], 0
  000bb	33 d2		 xor	 edx, edx
  000bd	48 8b cf	 mov	 rcx, rdi
  000c0	89 47 30	 mov	 DWORD PTR [rdi+48], eax
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  000c9	8b c6		 mov	 eax, esi
  000cb	eb 2e		 jmp	 SHORT $LN9@DriveFilte@2
$LN1@DriveFilte@2:

; 885  : 
; 886  : 	status = PassIrp (Extension->LowerDeviceObject, Irp);

  000cd	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  000d1	fe 47 43	 inc	 BYTE PTR [rdi+67]
  000d4	48 83 87 b8 00
	00 00 48	 add	 QWORD PTR [rdi+184], 72	; 00000048H
  000dc	48 8b d7	 mov	 rdx, rdi
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 887  : 
; 888  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000e5	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000eb	48 8b d7	 mov	 rdx, rdi
  000ee	48 8b cd	 mov	 rcx, rbp
  000f1	8b d8		 mov	 ebx, eax
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx
$LN13@DriveFilte@2:

; 889  : 	return status;

  000f9	8b c3		 mov	 eax, ebx
$LN9@DriveFilte@2:

; 890  : }

  000fb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00100	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00105	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0010a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
DriveFilterDispatchIrp ENDP
END
