; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\driver\dumpfilter.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_BootDriveFilterExtension DD 01H DUP (?)
_WriteFilterBuffer DD 01H DUP (?)
_BSS	ENDS
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Ogsp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\driver\dumpfilter.c
;	COMDAT _DumpFilterStart@4
_TEXT	SEGMENT
_filterExtension$ = 8					; size = 4
_DumpFilterStart@4 PROC					; COMDAT

; 172  : 	Dump ("DumpFilterStart type=%d\n", filterExtension->DumpType);
; 173  : 
; 174  : 	if (BootDriveFilterExtension->MagicNumber != GST_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00005	81 78 10 54 58
	45 42		 cmp	 DWORD PTR [eax+16], 1111840852 ; 42455854H
  0000c	75 09		 jne	 SHORT $LN4@DumpFilter
  0000e	81 78 14 45 55
	52 54		 cmp	 DWORD PTR [eax+20], 1414681925 ; 54525545H
  00015	74 19		 je	 SHORT $LN1@DumpFilter
$LN4@DumpFilter:

; 175  : 		GST_BUG_CHECK (STATUS_CRC_ERROR);

  00017	68 54 53 47 00	 push	 4674388			; 00475354H
  0001c	6a 00		 push	 0
  0001e	68 3f 00 00 c0	 push	 -1073741761		; c000003fH
  00023	68 af 00 00 00	 push	 175			; 000000afH
  00028	6a 29		 push	 41			; 00000029H
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN6@DumpFilter:
$LN1@DumpFilter:

; 176  : 
; 177  : 	return BootDriveFilterExtension->DriveMounted ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

  00030	8b 80 f0 01 00
	00		 mov	 eax, DWORD PTR [eax+496]
  00036	f7 d8		 neg	 eax
  00038	1b c0		 sbb	 eax, eax
  0003a	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0003f	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H

; 178  : }

  00044	c2 04 00	 ret	 4
$LN5@DumpFilter:
_DumpFilterStart@4 ENDP
_TEXT	ENDS
EXTRN	__imp__MmBuildMdlForNonPagedPool@4:PROC
EXTRN	_EncryptDataUnitsCurrentThread@20:PROC
EXTRN	_GetIntersection@36:PROC
EXTRN	__imp__MmMapLockedPagesSpecifyCache@24:PROC
EXTRN	_memcpy:PROC
_BSS	SEGMENT
_WriteFilterBufferSize DD 01H DUP (?)
	ALIGN	8

_DumpPartitionOffset DQ 01H DUP (?)
; Function compile flags: /Ogsp
_BSS	ENDS
;	COMDAT _DumpFilterWrite@12
_TEXT	SEGMENT
_offset$ = -24						; size = 8
_intersectStart$ = -16					; size = 8
_dataUnit$26452 = -8					; size = 8
_filterExtension$ = 8					; size = 4
_intersectLength$ = 12					; size = 4
_diskWriteOffset$ = 12					; size = 4
_dataLength$ = 16					; size = 4
_writeMdl$ = 16						; size = 4
_DumpFilterWrite@12 PROC				; COMDAT

; 192  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 193  : 	ULONG dataLength = MmGetMdlByteCount (writeMdl);

  0000a	8b 75 10	 mov	 esi, DWORD PTR _writeMdl$[ebp]
  0000d	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00010	57		 push	 edi

; 194  : 	uint64 offset = DumpPartitionOffset.QuadPart + diskWriteOffset->QuadPart;

  00011	8b 7d 0c	 mov	 edi, DWORD PTR _diskWriteOffset$[ebp]
  00014	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00016	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR _DumpPartitionOffset
  0001c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001f	13 05 04 00 00
	00		 adc	 eax, DWORD PTR _DumpPartitionOffset+4
  00025	89 55 10	 mov	 DWORD PTR _dataLength$[ebp], edx
  00028	89 45 ec	 mov	 DWORD PTR _offset$[ebp+4], eax

; 195  : 	uint64 intersectStart;
; 196  : 	uint32 intersectLength;
; 197  : 	PVOID writeBuffer;
; 198  : 	CSHORT origMdlFlags;
; 199  : 
; 200  : 	if (BootDriveFilterExtension->MagicNumber != GST_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00030	81 78 10 54 58
	45 42		 cmp	 DWORD PTR [eax+16], 1111840852 ; 42455854H
  00037	75 09		 jne	 SHORT $LN15@DumpFilter@2
  00039	81 78 14 45 55
	52 54		 cmp	 DWORD PTR [eax+20], 1414681925 ; 54525545H
  00040	74 19		 je	 SHORT $LN10@DumpFilter@2
$LN15@DumpFilter@2:

; 201  : 		GST_BUG_CHECK (STATUS_CRC_ERROR);

  00042	68 54 53 47 00	 push	 4674388			; 00475354H
  00047	6a 00		 push	 0
  00049	68 3f 00 00 c0	 push	 -1073741761		; c000003fH
  0004e	68 c9 00 00 00	 push	 201			; 000000c9H
$LN17@DumpFilter@2:
  00053	6a 29		 push	 41			; 00000029H
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN18@DumpFilter@2:
$LN10@DumpFilter@2:

; 202  : 
; 203  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaEndUpdatePending)	// Hibernation should always abort the setup thread

  0005b	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]
  00061	85 c0		 test	 eax, eax
  00063	74 13		 je	 SHORT $LN9@DumpFilter@2

; 204  : 		GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00065	68 54 53 47 00	 push	 4674388			; 00475354H
  0006a	6a 00		 push	 0
  0006c	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  00071	68 cc 00 00 00	 push	 204			; 000000ccH
  00076	eb db		 jmp	 SHORT $LN17@DumpFilter@2
$LN9@DumpFilter@2:

; 205  : 
; 206  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaStart == -1 || BootDriveFilterExtension->Queue.EncryptedAreaEnd == -1)

  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0007d	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00083	23 88 94 00 00
	00		 and	 ecx, DWORD PTR [eax+148]
  00089	83 f9 ff	 cmp	 ecx, -1
  0008c	0f 84 bc 01 00
	00		 je	 $LN7@DumpFilter@2
  00092	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [eax+152]
  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  0009e	23 81 9c 00 00
	00		 and	 eax, DWORD PTR [ecx+156]
  000a4	83 f8 ff	 cmp	 eax, -1
  000a7	0f 84 a1 01 00
	00		 je	 $LN7@DumpFilter@2

; 207  : 		return STATUS_SUCCESS;
; 208  : 
; 209  : 	if (dataLength > WriteFilterBufferSize)

  000ad	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WriteFilterBufferSize
  000b3	76 13		 jbe	 SHORT $LN6@DumpFilter@2

; 210  : 		GST_BUG_CHECK (STATUS_BUFFER_OVERFLOW);	// Bug check is required as returning an error does not prevent data from being written to disk

  000b5	68 54 53 47 00	 push	 4674388			; 00475354H
  000ba	6a 00		 push	 0
  000bc	68 05 00 00 80	 push	 -2147483643		; 80000005H
  000c1	68 d2 00 00 00	 push	 210			; 000000d2H
  000c6	eb 8b		 jmp	 SHORT $LN17@DumpFilter@2
$LN6@DumpFilter@2:

; 211  : 
; 212  : 	if ((dataLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000c8	b9 ff 01 00 00	 mov	 ecx, 511		; 000001ffH
  000cd	85 d1		 test	 edx, ecx
  000cf	74 16		 je	 SHORT $LN5@DumpFilter@2

; 213  : 		GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000d1	68 54 53 47 00	 push	 4674388			; 00475354H
  000d6	6a 00		 push	 0
  000d8	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000dd	68 d5 00 00 00	 push	 213			; 000000d5H
  000e2	e9 6c ff ff ff	 jmp	 $LN17@DumpFilter@2
$LN5@DumpFilter@2:

; 214  : 
; 215  : 	if ((offset & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000e7	8b c3		 mov	 eax, ebx
  000e9	23 c1		 and	 eax, ecx
  000eb	33 c9		 xor	 ecx, ecx
  000ed	0b c1		 or	 eax, ecx
  000ef	74 15		 je	 SHORT $LN4@DumpFilter@2

; 216  : 		GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000f1	68 54 53 47 00	 push	 4674388			; 00475354H
  000f6	51		 push	 ecx
  000f7	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000fc	68 d8 00 00 00	 push	 216			; 000000d8H
  00101	e9 4d ff ff ff	 jmp	 $LN17@DumpFilter@2
$LN4@DumpFilter@2:

; 217  : 
; 218  : 	writeBuffer = MmGetSystemAddressForMdlSafe (writeMdl, HighPagePriority);

  00106	f6 46 06 05	 test	 BYTE PTR [esi+6], 5
  0010a	74 05		 je	 SHORT $LN13@DumpFilter@2
  0010c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0010f	eb 13		 jmp	 SHORT $LN14@DumpFilter@2
$LN13@DumpFilter@2:
  00111	6a 20		 push	 32			; 00000020H
  00113	33 c0		 xor	 eax, eax
  00115	50		 push	 eax
  00116	50		 push	 eax
  00117	6a 01		 push	 1
  00119	50		 push	 eax
  0011a	56		 push	 esi
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
  00121	8b 55 10	 mov	 edx, DWORD PTR _dataLength$[ebp]
$LN14@DumpFilter@2:

; 219  : 	if (!writeBuffer)

  00124	85 c0		 test	 eax, eax
  00126	75 15		 jne	 SHORT $LN3@DumpFilter@2

; 220  : 		GST_BUG_CHECK (STATUS_INSUFFICIENT_RESOURCES);

  00128	68 54 53 47 00	 push	 4674388			; 00475354H
  0012d	50		 push	 eax
  0012e	68 9a 00 00 c0	 push	 -1073741670		; c000009aH
  00133	68 dc 00 00 00	 push	 220			; 000000dcH
  00138	e9 16 ff ff ff	 jmp	 $LN17@DumpFilter@2
$LN3@DumpFilter@2:

; 221  : 
; 222  : 	memcpy (WriteFilterBuffer, writeBuffer, dataLength);

  0013d	52		 push	 edx
  0013e	50		 push	 eax
  0013f	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteFilterBuffer
  00145	e8 00 00 00 00	 call	 _memcpy
  0014a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 223  : 
; 224  : 	GetIntersection (offset,
; 225  : 		dataLength,
; 226  : 		BootDriveFilterExtension->Queue.EncryptedAreaStart,
; 227  : 		BootDriveFilterExtension->Queue.EncryptedAreaEnd,
; 228  : 		&intersectStart,
; 229  : 		&intersectLength);

  0014d	8d 45 0c	 lea	 eax, DWORD PTR _intersectLength$[ebp]
  00150	50		 push	 eax
  00151	8d 45 f0	 lea	 eax, DWORD PTR _intersectStart$[ebp]
  00154	50		 push	 eax
  00155	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0015a	ff b0 9c 00 00
	00		 push	 DWORD PTR [eax+156]
  00160	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00165	ff b0 98 00 00
	00		 push	 DWORD PTR [eax+152]
  0016b	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00170	ff b0 94 00 00
	00		 push	 DWORD PTR [eax+148]
  00176	ff b0 90 00 00
	00		 push	 DWORD PTR [eax+144]
  0017c	ff 75 10	 push	 DWORD PTR _dataLength$[ebp]
  0017f	ff 75 ec	 push	 DWORD PTR _offset$[ebp+4]
  00182	53		 push	 ebx
  00183	e8 00 00 00 00	 call	 _GetIntersection@36

; 230  : 
; 231  : 	if (intersectLength > 0)

  00188	8b 55 0c	 mov	 edx, DWORD PTR _intersectLength$[ebp]
  0018b	85 d2		 test	 edx, edx
  0018d	76 66		 jbe	 SHORT $LN2@DumpFilter@2

; 232  : 	{
; 233  : 		UINT64_STRUCT dataUnit;
; 234  : 		dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  0018f	8b 4d f4	 mov	 ecx, DWORD PTR _intersectStart$[ebp+4]
  00192	8b 45 f0	 mov	 eax, DWORD PTR _intersectStart$[ebp]
  00195	0f ac c8 09	 shrd	 eax, ecx, 9
  00199	89 45 f8	 mov	 DWORD PTR _dataUnit$26452[ebp], eax

; 235  : 
; 236  : 		if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  0019c	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  001a1	c1 e9 09	 shr	 ecx, 9
  001a4	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  001ab	89 4d fc	 mov	 DWORD PTR _dataUnit$26452[ebp+4], ecx
  001ae	74 28		 je	 SHORT $LN1@DumpFilter@2

; 237  : 		{
; 238  : 			diskWriteOffset->QuadPart += BootDriveFilterExtension->Queue.RemappedAreaOffset;

  001b0	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  001b6	01 17		 add	 DWORD PTR [edi], edx
  001b8	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  001be	11 57 04	 adc	 DWORD PTR [edi+4], edx

; 239  : 			dataUnit.Value += BootDriveFilterExtension->Queue.RemappedAreaDataUnitOffset;

  001c1	8b 90 b0 00 00
	00		 mov	 edx, DWORD PTR [eax+176]
  001c7	01 55 f8	 add	 DWORD PTR _dataUnit$26452[ebp], edx
  001ca	8b 90 b4 00 00
	00		 mov	 edx, DWORD PTR [eax+180]
  001d0	13 ca		 adc	 ecx, edx
  001d2	8b 55 0c	 mov	 edx, DWORD PTR _intersectLength$[ebp]
  001d5	89 4d fc	 mov	 DWORD PTR _dataUnit$26452[ebp+4], ecx
$LN1@DumpFilter@2:

; 240  : 		}
; 241  : 
; 242  : 		EncryptDataUnitsCurrentThread (WriteFilterBuffer + (intersectStart - offset),
; 243  : 			&dataUnit,
; 244  : 			intersectLength / ENCRYPTION_DATA_UNIT_SIZE,
; 245  : 			BootDriveFilterExtension->Queue.CryptoInfo);

  001d8	ff 70 70	 push	 DWORD PTR [eax+112]
  001db	c1 ea 09	 shr	 edx, 9
  001de	6a 00		 push	 0
  001e0	52		 push	 edx
  001e1	8d 45 f8	 lea	 eax, DWORD PTR _dataUnit$26452[ebp]
  001e4	50		 push	 eax
  001e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteFilterBuffer
  001ea	2b c3		 sub	 eax, ebx
  001ec	03 45 f0	 add	 eax, DWORD PTR _intersectStart$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread@20
$LN2@DumpFilter@2:

; 246  : 	}
; 247  : 
; 248  : 	origMdlFlags = writeMdl->MdlFlags;
; 249  : 
; 250  : 	MmInitializeMdl (writeMdl, WriteFilterBuffer, dataLength);

  001f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteFilterBuffer
  001fa	8b 5d 10	 mov	 ebx, DWORD PTR _dataLength$[ebp]
  001fd	0f b7 7e 06	 movzx	 edi, WORD PTR [esi+6]
  00201	83 26 00	 and	 DWORD PTR [esi], 0
  00204	8b c8		 mov	 ecx, eax
  00206	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0020b	23 da		 and	 ebx, edx
  0020d	23 ca		 and	 ecx, edx
  0020f	8d 94 0b ff 0f
	00 00		 lea	 edx, DWORD PTR [ebx+ecx+4095]
  00216	8b 5d 10	 mov	 ebx, DWORD PTR _dataLength$[ebp]
  00219	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  0021c	c1 eb 0c	 shr	 ebx, 12			; 0000000cH
  0021f	03 d3		 add	 edx, ebx
  00221	8d 14 95 1c 00
	00 00		 lea	 edx, DWORD PTR [edx*4+28]
  00228	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  0022d	66 89 56 04	 mov	 WORD PTR [esi+4], dx
  00231	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00234	8b 45 10	 mov	 eax, DWORD PTR _dataLength$[ebp]
  00237	33 d2		 xor	 edx, edx

; 251  : 	MmBuildMdlForNonPagedPool (writeMdl);

  00239	56		 push	 esi
  0023a	66 89 56 06	 mov	 WORD PTR [esi+6], dx
  0023e	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00241	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmBuildMdlForNonPagedPool@4

; 252  : 
; 253  : 	// Instead of using MmGetSystemAddressForMdlSafe(), some buggy custom storage drivers may directly test MDL_MAPPED_TO_SYSTEM_VA flag,
; 254  : 	// disregarding the fact that other MDL flags may be set by the system or a dump filter (e.g. MDL_SOURCE_IS_NONPAGED_POOL flag only).
; 255  : 	// Therefore, to work around this issue, the original flags will be restored even if they do not match the new MDL.
; 256  : 	// MS BitLocker also uses this hack/workaround (it should be safe to use until the MDL structure is changed).
; 257  : 
; 258  : 	writeMdl->MdlFlags = origMdlFlags;

  0024a	66 89 7e 06	 mov	 WORD PTR [esi+6], di
$LN7@DumpFilter@2:
  0024e	5f		 pop	 edi
  0024f	5e		 pop	 esi
  00250	33 c0		 xor	 eax, eax
  00252	5b		 pop	 ebx

; 259  : 
; 260  : 	return STATUS_SUCCESS;
; 261  : }

  00253	c9		 leave
  00254	c2 0c 00	 ret	 12			; 0000000cH
$LN16@DumpFilter@2:
_DumpFilterWrite@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _DumpFilterFinish@4
_TEXT	SEGMENT
_filterExtension$ = 8					; size = 4
_DumpFilterFinish@4 PROC				; COMDAT

; 274  : 	Dump ("DumpFilterFinish type=%d\n", filterExtension->DumpType);
; 275  : 
; 276  : 	return STATUS_SUCCESS;

  00000	33 c0		 xor	 eax, eax

; 277  : }

  00002	c2 04 00	 ret	 4
_DumpFilterFinish@4 ENDP
_TEXT	ENDS
EXTRN	__imp__MmFreeContiguousMemory@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _DumpFilterUnload@4
_TEXT	SEGMENT
_filterExtension$ = 8					; size = 4
_DumpFilterUnload@4 PROC				; COMDAT

; 289  : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 290  : 	Dump ("DumpFilterUnload type=%d\n", filterExtension->DumpType);
; 291  : 
; 292  : 	if (WriteFilterBuffer)

  00003	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _WriteFilterBuffer
  00009	85 f6		 test	 esi, esi
  0000b	74 1f		 je	 SHORT $LN1@DumpFilter@3

; 293  : 	{
; 294  : 		memset (WriteFilterBuffer, 0, WriteFilterBufferSize);

  0000d	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteFilterBufferSize
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 295  : 		MmFreeContiguousMemory (WriteFilterBuffer);

  0001e	56		 push	 esi
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmFreeContiguousMemory@4

; 296  : 		WriteFilterBuffer = NULL;

  00025	83 25 00 00 00
	00 00		 and	 DWORD PTR _WriteFilterBuffer, 0
$LN1@DumpFilter@3:

; 297  : 	}
; 298  : 
; 299  : 	return STATUS_SUCCESS;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 300  : }

  0002f	c2 04 00	 ret	 4
_DumpFilterUnload@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_DumpFilterEntry@8
EXTRN	__imp__MmAllocateContiguousMemory@12:PROC
EXTRN	_SendDeviceIoControlRequest@24:PROC
EXTRN	_AutoTestAlgorithms@0:PROC
EXTRN	_EnableHwEncryption@4:PROC
EXTRN	_GSTDeviceIoControl@24:PROC
;	COMDAT ??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _DumpFilterEntry@8
_TEXT	SEGMENT
_partitionInfo$ = -52					; size = 32
_storageDeviceNumber$ = -20				; size = 12
_dumpConfig$ = -8					; size = 8
_filterExtension$ = 8					; size = 4
_version$ = 12						; size = 4
_filterInitData$ = 12					; size = 4
_DumpFilterEntry@8 PROC					; COMDAT

; 43   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 34	 sub	 esp, 52			; 00000034H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 44   : 	GetSystemDriveDumpConfigRequest dumpConfig;
; 45   : 	PHYSICAL_ADDRESS highestAcceptableWriteBufferAddr;
; 46   : 	STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 47   : 	PARTITION_INFORMATION partitionInfo;
; 48   : 	LONG version;
; 49   : 	NTSTATUS status;
; 50   : 
; 51   : 	Dump ("DumpFilterEntry type=%d\n", filterExtension->DumpType);
; 52   : 
; 53   : 	filterInitData->MajorVersion = DUMP_FILTER_MAJOR_VERSION;

  0000a	8b 75 0c	 mov	 esi, DWORD PTR _filterInitData$[ebp]
  0000d	57		 push	 edi
  0000e	33 c0		 xor	 eax, eax
  00010	40		 inc	 eax

; 54   : 	filterInitData->MinorVersion = DUMP_FILTER_MINOR_VERSION;
; 55   : 	filterInitData->Flags |= DUMP_FILTER_CRITICAL;

  00011	09 46 20	 or	 DWORD PTR [esi+32], eax

; 56   : 
; 57   : 	// Check driver version of the main device
; 58   : 	status = GSTDeviceIoControl (NT_ROOT_PREFIX, GST_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version));

  00014	6a 04		 push	 4
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	8d 45 0c	 lea	 eax, DWORD PTR _version$[ebp]
  0001b	50		 push	 eax
  0001c	33 db		 xor	 ebx, ebx
  0001e	53		 push	 ebx
  0001f	53		 push	 ebx
  00020	68 04 20 22 00	 push	 2236420			; 00222004H
  00025	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  0002a	57		 push	 edi
  0002b	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0002e	e8 00 00 00 00	 call	 _GSTDeviceIoControl@24

; 59   : 	if (!NT_SUCCESS (status))

  00033	3b c3		 cmp	 eax, ebx
  00035	0f 8c 47 01 00
	00		 jl	 $err$26371

; 60   : 		goto err;
; 61   : 
; 62   : 	if (version != VERSION_NUM)

  0003b	81 7d 0c 00 13
	00 00		 cmp	 DWORD PTR _version$[ebp], 4864 ; 00001300H
  00042	74 0a		 je	 SHORT $LN13@DumpFilter@4
$LN21@DumpFilter@4:

; 63   : 	{
; 64   : 		status = STATUS_INVALID_PARAMETER;

  00044	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH

; 65   : 		goto err;

  00049	e9 34 01 00 00	 jmp	 $err$26371
$LN13@DumpFilter@4:

; 66   : 	}
; 67   : 
; 68   : 	// Get dump configuration from the main device
; 69   : 	status = GSTDeviceIoControl (NT_ROOT_PREFIX, GST_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG, NULL, 0, &dumpConfig, sizeof (dumpConfig));

  0004e	6a 08		 push	 8
  00050	8d 45 f8	 lea	 eax, DWORD PTR _dumpConfig$[ebp]
  00053	50		 push	 eax
  00054	53		 push	 ebx
  00055	53		 push	 ebx
  00056	68 98 20 22 00	 push	 2236568			; 00222098H
  0005b	57		 push	 edi
  0005c	e8 00 00 00 00	 call	 _GSTDeviceIoControl@24

; 70   : 	if (!NT_SUCCESS (status))

  00061	3b c3		 cmp	 eax, ebx
  00063	0f 8c 19 01 00
	00		 jl	 $err$26371

; 71   : 		goto err;
; 72   : 
; 73   : 	BootDriveFilterExtension = dumpConfig.BootDriveFilterExtension;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _dumpConfig$[ebp]

; 74   : 
; 75   : 	if (BootDriveFilterExtension->MagicNumber != GST_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  0006c	81 78 10 54 58
	45 42		 cmp	 DWORD PTR [eax+16], 1111840852 ; 42455854H
  00073	a3 00 00 00 00	 mov	 DWORD PTR _BootDriveFilterExtension, eax
  00078	75 09		 jne	 SHORT $LN17@DumpFilter@4
  0007a	81 78 14 45 55
	52 54		 cmp	 DWORD PTR [eax+20], 1414681925 ; 54525545H
  00081	74 0a		 je	 SHORT $LN11@DumpFilter@4
$LN17@DumpFilter@4:

; 76   : 	{
; 77   : 		status = STATUS_CRC_ERROR;

  00083	b8 3f 00 00 c0	 mov	 eax, -1073741761	; c000003fH

; 78   : 		goto err;

  00088	e9 f5 00 00 00	 jmp	 $err$26371
$LN11@DumpFilter@4:

; 79   : 	}
; 80   : 
; 81   : 	// KeSaveFloatingPointState() may generate a bug check during crash dump
; 82   : #if !defined (_WIN64)
; 83   : 	if (filterExtension->DumpType == DumpTypeCrashdump)

  0008d	8b 7d 08	 mov	 edi, DWORD PTR _filterExtension$[ebp]
  00090	83 3f 01	 cmp	 DWORD PTR [edi], 1
  00093	75 03		 jne	 SHORT $LN20@DumpFilter@4

; 84   : 		dumpConfig.HwEncryptionEnabled = FALSE;

  00095	89 5d fc	 mov	 DWORD PTR _dumpConfig$[ebp+4], ebx
$LN20@DumpFilter@4:

; 85   : #endif
; 86   : 
; 87   : 	EnableHwEncryption (dumpConfig.HwEncryptionEnabled);

  00098	ff 75 fc	 push	 DWORD PTR _dumpConfig$[ebp+4]
  0009b	e8 00 00 00 00	 call	 _EnableHwEncryption@4

; 88   : 
; 89   : 	if (!AutoTestAlgorithms())

  000a0	e8 00 00 00 00	 call	 _AutoTestAlgorithms@0
  000a5	85 c0		 test	 eax, eax

; 90   : 	{
; 91   : 		status = STATUS_INVALID_PARAMETER;
; 92   : 		goto err;

  000a7	74 9b		 je	 SHORT $LN21@DumpFilter@4

; 93   : 	}
; 94   : 
; 95   : 	// Check dump volume is located on the system drive
; 96   : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  000a9	6a 0c		 push	 12			; 0000000cH
  000ab	8d 45 ec	 lea	 eax, DWORD PTR _storageDeviceNumber$[ebp]
  000ae	50		 push	 eax
  000af	53		 push	 ebx
  000b0	53		 push	 ebx
  000b1	68 80 10 2d 00	 push	 2953344			; 002d1080H
  000b6	ff 77 04	 push	 DWORD PTR [edi+4]
  000b9	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 97   : 	if (!NT_SUCCESS (status))

  000be	3b c3		 cmp	 eax, ebx
  000c0	0f 8c bc 00 00
	00		 jl	 $err$26371

; 98   : 		goto err;
; 99   : 
; 100  : 	if (!BootDriveFilterExtension->SystemStorageDeviceNumberValid)

  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  000cb	39 58 28	 cmp	 DWORD PTR [eax+40], ebx

; 101  : 	{
; 102  : 		status = STATUS_INVALID_PARAMETER;
; 103  : 		goto err;

  000ce	0f 84 70 ff ff
	ff		 je	 $LN21@DumpFilter@4

; 104  : 	}
; 105  : 
; 106  : 	if (storageDeviceNumber.DeviceNumber != BootDriveFilterExtension->SystemStorageDeviceNumber)

  000d4	8b 4d f0	 mov	 ecx, DWORD PTR _storageDeviceNumber$[ebp+4]
  000d7	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]

; 107  : 	{
; 108  : 		status = STATUS_ACCESS_DENIED;
; 109  : 		goto err;

  000da	0f 85 9d 00 00
	00		 jne	 $LN3@DumpFilter@4

; 110  : 	}
; 111  : 
; 112  : 	// Check dump volume is located within the scope of system encryption
; 113  : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &partitionInfo, sizeof (partitionInfo));

  000e0	6a 20		 push	 32			; 00000020H
  000e2	8d 45 cc	 lea	 eax, DWORD PTR _partitionInfo$[ebp]
  000e5	50		 push	 eax
  000e6	53		 push	 ebx
  000e7	53		 push	 ebx
  000e8	68 04 40 07 00	 push	 475140			; 00074004H
  000ed	ff 77 04	 push	 DWORD PTR [edi+4]
  000f0	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 114  : 	if (!NT_SUCCESS (status))

  000f5	3b c3		 cmp	 eax, ebx
  000f7	0f 8c 85 00 00
	00		 jl	 $err$26371

; 115  : 		goto err;
; 116  : 
; 117  : 	DumpPartitionOffset = partitionInfo.StartingOffset;

  000fd	8b 4d d0	 mov	 ecx, DWORD PTR _partitionInfo$[ebp+4]

; 118  : 
; 119  : 	if (DumpPartitionOffset.QuadPart < BootDriveFilterExtension->ConfiguredEncryptedAreaStart
; 120  : 		|| DumpPartitionOffset.QuadPart > BootDriveFilterExtension->ConfiguredEncryptedAreaEnd)

  00100	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00105	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  00108	8b 55 cc	 mov	 edx, DWORD PTR _partitionInfo$[ebp]
  0010b	89 15 00 00 00
	00		 mov	 DWORD PTR _DumpPartitionOffset, edx
  00111	89 0d 04 00 00
	00		 mov	 DWORD PTR _DumpPartitionOffset+4, ecx
  00117	7c 64		 jl	 SHORT $LN3@DumpFilter@4
  00119	7f 05		 jg	 SHORT $LN18@DumpFilter@4
  0011b	3b 50 30	 cmp	 edx, DWORD PTR [eax+48]
  0011e	72 5d		 jb	 SHORT $LN3@DumpFilter@4
$LN18@DumpFilter@4:
  00120	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  00123	7f 58		 jg	 SHORT $LN3@DumpFilter@4
  00125	7c 05		 jl	 SHORT $LN19@DumpFilter@4
  00127	3b 50 38	 cmp	 edx, DWORD PTR [eax+56]
  0012a	77 51		 ja	 SHORT $LN3@DumpFilter@4
$LN19@DumpFilter@4:

; 123  : 		goto err;
; 124  : 	}
; 125  : 
; 126  : 	// Allocate buffer for encryption
; 127  : 	if (filterInitData->MaxPagesPerWrite == 0)

  0012c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0012f	3b c3		 cmp	 eax, ebx

; 128  : 	{
; 129  : 		status = STATUS_INVALID_PARAMETER;
; 130  : 		goto err;

  00131	0f 84 0d ff ff
	ff		 je	 $LN21@DumpFilter@4

; 131  : 	}
; 132  : 
; 133  : 	WriteFilterBufferSize = filterInitData->MaxPagesPerWrite * PAGE_SIZE;
; 134  : 
; 135  : #ifdef _WIN64
; 136  : 	highestAcceptableWriteBufferAddr.QuadPart = 0x7FFffffFFFFLL;
; 137  : #else
; 138  : 	highestAcceptableWriteBufferAddr.QuadPart = 0xffffFFFFLL;

  00137	33 d2		 xor	 edx, edx

; 139  : #endif
; 140  : 
; 141  : 	WriteFilterBuffer = MmAllocateContiguousMemory (WriteFilterBufferSize, highestAcceptableWriteBufferAddr);

  00139	52		 push	 edx
  0013a	83 c9 ff	 or	 ecx, -1
  0013d	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00140	51		 push	 ecx
  00141	50		 push	 eax
  00142	a3 00 00 00 00	 mov	 DWORD PTR _WriteFilterBufferSize, eax
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmAllocateContiguousMemory@12
  0014d	a3 00 00 00 00	 mov	 DWORD PTR _WriteFilterBuffer, eax

; 142  : 	if (!WriteFilterBuffer)

  00152	3b c3		 cmp	 eax, ebx
  00154	75 07		 jne	 SHORT $LN1@DumpFilter@4

; 143  : 	{
; 144  : 		status = STATUS_INSUFFICIENT_RESOURCES;

  00156	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH

; 145  : 		goto err;

  0015b	eb 25		 jmp	 SHORT $err$26371
$LN1@DumpFilter@4:

; 146  : 	}
; 147  : 
; 148  : 	filterInitData->DumpStart = DumpFilterStart;

  0015d	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET _DumpFilterStart@4

; 149  : 	filterInitData->DumpWrite = DumpFilterWrite;

  00164	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], OFFSET _DumpFilterWrite@12

; 150  : 	filterInitData->DumpFinish = DumpFilterFinish;

  0016b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], OFFSET _DumpFilterFinish@4

; 151  : 	filterInitData->DumpUnload = DumpFilterUnload;

  00172	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], OFFSET _DumpFilterUnload@4

; 152  : 
; 153  : 	Dump ("Dump filter loaded type=%d\n", filterExtension->DumpType);
; 154  : 	return STATUS_SUCCESS;

  00179	33 c0		 xor	 eax, eax
  0017b	eb 05		 jmp	 SHORT $err$26371
$LN3@DumpFilter@4:

; 121  : 	{
; 122  : 		status = STATUS_ACCESS_DENIED;

  0017d	b8 22 00 00 c0	 mov	 eax, -1073741790	; c0000022H
$err$26371:
  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5b		 pop	 ebx

; 155  : 
; 156  : err:
; 157  : 	Dump ("DumpFilterEntry error %x\n", status);
; 158  : 	return status;
; 159  : }

  00185	c9		 leave
  00186	c2 08 00	 ret	 8
_DumpFilterEntry@8 ENDP
_TEXT	ENDS
END
