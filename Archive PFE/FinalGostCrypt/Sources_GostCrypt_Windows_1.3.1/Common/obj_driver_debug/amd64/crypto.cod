; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_09HLDHDDJL@Whirlpool?$AA@			; `string'
PUBLIC	??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@	; `string'
PUBLIC	??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@	; `string'
PUBLIC	??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@	; `string'
PUBLIC	??_C@_0O@POKHNLDL@GOST?528147?989?$AA@		; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
HwEncryptionDisabled DD 01H DUP (?)
;	COMDAT ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@ DB '[unknown]', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@ DB 'XTS 64-bit ver'
	DB	'sion', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@ DB 'XTS', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@ DB '-', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@ DB '?', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09HLDHDDJL@Whirlpool?$AA@
CONST	SEGMENT
??_C@_09HLDHDDJL@Whirlpool?$AA@ DB 'Whirlpool', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@
CONST	SEGMENT
??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@ DB 'GOST R 34.11-94', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@
CONST	SEGMENT
??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@ DB 'GOST R 34.11-2012', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@
CONST	SEGMENT
??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@ DB 'Gost Grasshopper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
CONST	SEGMENT
??_C@_0O@POKHNLDL@GOST?528147?989?$AA@ DB 'GOST 28147-89', 00H ; `string'
Ciphers	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
	DD	08H
	DD	020H
	DD	0220H
	ORG $+4
	DD	02H
	ORG $+4
	DQ	FLAT:??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@
	DD	010H
	DD	020H
	DD	0a0H
	ORG $+4
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
EncryptionAlgorithms DD 00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	ORG $+4
	DD	00H
	DD	01H
	DD	00H
	ORG $+8
	DD	02H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	00H
	ORG $+8
	DD	01H
	DD	00H
	ORG $+4
	DD	01H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	ORG $+4
	DD	00H
Hashes	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@
	DD	00H
	DD	01H
	DD	02H
	ORG $+4
	DQ	FLAT:??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@
	DD	00H
	DD	00H
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_09HLDHDDJL@Whirlpool?$AA@
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
PUBLIC	IsHwEncryptionEnabled
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
pdata	SEGMENT
$pdata$IsHwEncryptionEnabled DD imagerel $LN5
	DD	imagerel $LN5+37
	DD	imagerel $unwind$IsHwEncryptionEnabled
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsHwEncryptionEnabled DD 010401H
	DD	02204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsHwEncryptionEnabled
_TEXT	SEGMENT
tv65 = 0
IsHwEncryptionEnabled PROC				; COMDAT

; 1611 : {

$LN5:
  00000	48 83 ec 18	 sub	 rsp, 24

; 1612 : 	return !HwEncryptionDisabled;

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR HwEncryptionDisabled, 0
  0000b	75 09		 jne	 SHORT $LN3@IsHwEncryp
  0000d	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv65[rsp], 1
  00014	eb 07		 jmp	 SHORT $LN4@IsHwEncryp
$LN3@IsHwEncryp:
  00016	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv65[rsp], 0
$LN4@IsHwEncryp:
  0001d	8b 04 24	 mov	 eax, DWORD PTR tv65[rsp]

; 1613 : }

  00020	48 83 c4 18	 add	 rsp, 24
  00024	c3		 ret	 0
IsHwEncryptionEnabled ENDP
_TEXT	ENDS
PUBLIC	EnableHwEncryption
; Function compile flags: /Odtp
;	COMDAT EnableHwEncryption
_TEXT	SEGMENT
enable$ = 8
EnableHwEncryption PROC					; COMDAT

; 1599 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1600 : 	//Deprecated
; 1601 : }

  00004	c3		 ret	 0
EnableHwEncryption ENDP
_TEXT	ENDS
PUBLIC	crypto_open
;	COMDAT pdata
pdata	SEGMENT
$pdata$crypto_open DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$crypto_open
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$crypto_open DD 020601H
	DD	070025206H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT crypto_open
_TEXT	SEGMENT
cryptoInfo$ = 32
crypto_open PROC					; COMDAT

; 894  : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 895  : #ifndef GST_WINDOWS_BOOT
; 896  : 
; 897  : 	/* Do the crt allocation */
; 898  : 	PCRYPTO_INFO cryptoInfo = (PCRYPTO_INFO) GSTalloc (sizeof (CRYPTO_INFO));

  00006	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0000c	ba 10 1f 00 00	 mov	 edx, 7952		; 00001f10H
  00011	33 c9		 xor	 ecx, ecx
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00019	48 89 44 24 20	 mov	 QWORD PTR cryptoInfo$[rsp], rax

; 899  : 	if (cryptoInfo == NULL)

  0001e	48 83 7c 24 20
	00		 cmp	 QWORD PTR cryptoInfo$[rsp], 0
  00024	75 04		 jne	 SHORT $LN1@crypto_ope

; 900  : 		return NULL;

  00026	33 c0		 xor	 eax, eax
  00028	eb 1e		 jmp	 SHORT $LN2@crypto_ope
$LN1@crypto_ope:

; 901  : 
; 902  : 	memset (cryptoInfo, 0, sizeof (CRYPTO_INFO));

  0002a	48 8b 7c 24 20	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  0002f	33 c0		 xor	 eax, eax
  00031	b9 10 1f 00 00	 mov	 ecx, 7952		; 00001f10H
  00036	f3 aa		 rep stosb

; 903  : 
; 904  : #ifndef DEVICE_DRIVER
; 905  : 	VirtualLock (cryptoInfo, sizeof (CRYPTO_INFO));
; 906  : #endif
; 907  : 
; 908  : 	cryptoInfo->ea = -1;

  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0003d	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1

; 909  : 	return cryptoInfo;

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
$LN2@crypto_ope:

; 910  : 
; 911  : #else // GST_WINDOWS_BOOT
; 912  : 
; 913  : #if 0
; 914  : 	if (CryptoInfoBufferInUse)
; 915  : 		GST_THROW_FATAL_EXCEPTION;
; 916  : #endif
; 917  : 	CryptoInfoBufferInUse = 1;
; 918  : 	return &CryptoInfoBuffer;
; 919  : 
; 920  : #endif // GST_WINDOWS_BOOT
; 921  : }

  00048	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
crypto_open ENDP
_TEXT	ENDS
PUBLIC	EAGetPreviousCipher
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetPreviousCipher DD imagerel $LN7
	DD	imagerel $LN7+164
	DD	imagerel $unwind$EAGetPreviousCipher
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetPreviousCipher DD 010c01H
	DD	0220cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAGetPreviousCipher
_TEXT	SEGMENT
i$ = 0
c$ = 4
ea$ = 32
previousCipherId$ = 40
EAGetPreviousCipher PROC				; COMDAT

; 757  : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 758  : 	int c, i = 0;

  0000c	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0

; 759  : 
; 760  : 	if (EncryptionAlgorithms[ea].Ciphers[i++] == previousCipherId)

  00013	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  00017	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ea$[rsp]
  0001c	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EncryptionAlgorithms
  00027	48 03 c1	 add	 rax, rcx
  0002a	8b 14 90	 mov	 edx, DWORD PTR [rax+rdx*4]
  0002d	8b 4c 24 28	 mov	 ecx, DWORD PTR previousCipherId$[rsp]
  00031	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0003a	3b d1		 cmp	 edx, ecx
  0003c	75 04		 jne	 SHORT $LN4@EAGetPrevi

; 761  : 		return 0;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 5d		 jmp	 SHORT $LN5@EAGetPrevi
$LN4@EAGetPrevi:
$LN3@EAGetPrevi:

; 762  : 
; 763  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00042	48 63 44 24 20	 movsxd	 rax, DWORD PTR ea$[rsp]
  00047	48 6b c0 20	 imul	 rax, 32			; 00000020H
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00052	48 03 c8	 add	 rcx, rax
  00055	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00059	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0005c	89 44 24 04	 mov	 DWORD PTR c$[rsp], eax
  00060	8b 4c 24 04	 mov	 ecx, DWORD PTR c$[rsp]
  00064	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 2c		 je	 SHORT $LN2@EAGetPrevi

; 764  : 	{
; 765  : 		if (c == previousCipherId) 

  00071	8b 44 24 28	 mov	 eax, DWORD PTR previousCipherId$[rsp]
  00075	39 44 24 04	 cmp	 DWORD PTR c$[rsp], eax
  00079	75 20		 jne	 SHORT $LN1@EAGetPrevi

; 766  : 			return EncryptionAlgorithms[ea].Ciphers[i - 2];

  0007b	48 63 44 24 20	 movsxd	 rax, DWORD PTR ea$[rsp]
  00080	48 6b c0 20	 imul	 rax, 32			; 00000020H
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0008b	48 03 c8	 add	 rcx, rax
  0008e	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00091	83 e8 02	 sub	 eax, 2
  00094	48 98		 cdqe
  00096	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00099	eb 04		 jmp	 SHORT $LN5@EAGetPrevi
$LN1@EAGetPrevi:

; 767  : 	}

  0009b	eb a5		 jmp	 SHORT $LN3@EAGetPrevi
$LN2@EAGetPrevi:

; 768  : 
; 769  : 	return 0;

  0009d	33 c0		 xor	 eax, eax
$LN5@EAGetPrevi:

; 770  : }

  0009f	48 83 c4 18	 add	 rsp, 24
  000a3	c3		 ret	 0
EAGetPreviousCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetNextCipher
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetNextCipher DD imagerel $LN6
	DD	imagerel $LN6+113
	DD	imagerel $unwind$EAGetNextCipher
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetNextCipher DD 010c01H
	DD	0220cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAGetNextCipher
_TEXT	SEGMENT
i$ = 0
c$ = 4
ea$ = 32
previousCipherId$ = 40
EAGetNextCipher PROC					; COMDAT

; 735  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 736  : 	int c, i = 0;

  0000c	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
$LN3@EAGetNextC:

; 737  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00013	48 63 44 24 20	 movsxd	 rax, DWORD PTR ea$[rsp]
  00018	48 6b c0 20	 imul	 rax, 32			; 00000020H
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00023	48 03 c8	 add	 rcx, rax
  00026	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0002a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0002d	89 44 24 04	 mov	 DWORD PTR c$[rsp], eax
  00031	8b 4c 24 04	 mov	 ecx, DWORD PTR c$[rsp]
  00035	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00038	83 c0 01	 add	 eax, 1
  0003b	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0003e	85 c9		 test	 ecx, ecx
  00040	74 28		 je	 SHORT $LN2@EAGetNextC

; 738  : 	{
; 739  : 		if (c == previousCipherId) 

  00042	8b 44 24 28	 mov	 eax, DWORD PTR previousCipherId$[rsp]
  00046	39 44 24 04	 cmp	 DWORD PTR c$[rsp], eax
  0004a	75 1c		 jne	 SHORT $LN1@EAGetNextC

; 740  : 			return EncryptionAlgorithms[ea].Ciphers[i];

  0004c	48 63 44 24 20	 movsxd	 rax, DWORD PTR ea$[rsp]
  00051	48 6b c0 20	 imul	 rax, 32			; 00000020H
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0005c	48 03 c8	 add	 rcx, rax
  0005f	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00063	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00066	eb 04		 jmp	 SHORT $LN4@EAGetNextC
$LN1@EAGetNextC:

; 741  : 	}

  00068	eb a9		 jmp	 SHORT $LN3@EAGetNextC
$LN2@EAGetNextC:

; 742  : 
; 743  : 	return 0;

  0006a	33 c0		 xor	 eax, eax
$LN4@EAGetNextC:

; 744  : }

  0006c	48 83 c4 18	 add	 rsp, 24
  00070	c3		 ret	 0
EAGetNextCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetLastCipher
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetLastCipher DD imagerel $LN5
	DD	imagerel $LN5+99
	DD	imagerel $unwind$EAGetLastCipher
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetLastCipher DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAGetLastCipher
_TEXT	SEGMENT
i$ = 0
c$ = 4
ea$ = 32
EAGetLastCipher PROC					; COMDAT

; 717  : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 718  : 	int c, i = 0;

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
$LN2@EAGetLastC:

; 719  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++]);

  0000f	48 63 44 24 20	 movsxd	 rax, DWORD PTR ea$[rsp]
  00014	48 6b c0 20	 imul	 rax, 32			; 00000020H
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0001f	48 03 c8	 add	 rcx, rax
  00022	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00026	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00029	89 44 24 04	 mov	 DWORD PTR c$[rsp], eax
  0002d	8b 4c 24 04	 mov	 ecx, DWORD PTR c$[rsp]
  00031	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 02		 je	 SHORT $LN1@EAGetLastC
  0003e	eb cf		 jmp	 SHORT $LN2@EAGetLastC
$LN1@EAGetLastC:

; 720  : 
; 721  : 	return EncryptionAlgorithms[ea].Ciphers[i - 2];

  00040	48 63 44 24 20	 movsxd	 rax, DWORD PTR ea$[rsp]
  00045	48 6b c0 20	 imul	 rax, 32			; 00000020H
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00050	48 03 c8	 add	 rcx, rax
  00053	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00056	83 e8 02	 sub	 eax, 2
  00059	48 98		 cdqe
  0005b	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]

; 722  : }

  0005e	48 83 c4 18	 add	 rsp, 24
  00062	c3		 ret	 0
EAGetLastCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetFirstCipher
; Function compile flags: /Odtp
;	COMDAT EAGetFirstCipher
_TEXT	SEGMENT
ea$ = 8
EAGetFirstCipher PROC					; COMDAT

; 703  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 704  : 	return EncryptionAlgorithms[ea].Ciphers[0];

  00004	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR ea$[rsp]
  00009	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  0000d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EncryptionAlgorithms
  00014	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]

; 705  : }

  00017	c3		 ret	 0
EAGetFirstCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetNextMode
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetNextMode DD imagerel $LN6
	DD	imagerel $LN6+115
	DD	imagerel $unwind$EAGetNextMode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetNextMode DD 010c01H
	DD	0220cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAGetNextMode
_TEXT	SEGMENT
i$ = 0
c$ = 4
ea$ = 32
previousModeId$ = 40
EAGetNextMode PROC					; COMDAT

; 566  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 567  : 	int c, i = 0;

  0000c	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
$LN3@EAGetNextM:

; 568  : 	while (c = EncryptionAlgorithms[ea].Modes[i++])

  00013	48 63 44 24 20	 movsxd	 rax, DWORD PTR ea$[rsp]
  00018	48 6b c0 20	 imul	 rax, 32			; 00000020H
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00023	48 03 c8	 add	 rcx, rax
  00026	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0002a	8b 44 81 10	 mov	 eax, DWORD PTR [rcx+rax*4+16]
  0002e	89 44 24 04	 mov	 DWORD PTR c$[rsp], eax
  00032	8b 4c 24 04	 mov	 ecx, DWORD PTR c$[rsp]
  00036	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0003f	85 c9		 test	 ecx, ecx
  00041	74 29		 je	 SHORT $LN2@EAGetNextM

; 569  : 	{
; 570  : 		if (c == previousModeId) 

  00043	8b 44 24 28	 mov	 eax, DWORD PTR previousModeId$[rsp]
  00047	39 44 24 04	 cmp	 DWORD PTR c$[rsp], eax
  0004b	75 1d		 jne	 SHORT $LN1@EAGetNextM

; 571  : 			return EncryptionAlgorithms[ea].Modes[i];

  0004d	48 63 44 24 20	 movsxd	 rax, DWORD PTR ea$[rsp]
  00052	48 6b c0 20	 imul	 rax, 32			; 00000020H
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0005d	48 03 c8	 add	 rcx, rax
  00060	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00064	8b 44 81 10	 mov	 eax, DWORD PTR [rcx+rax*4+16]
  00068	eb 04		 jmp	 SHORT $LN4@EAGetNextM
$LN1@EAGetNextM:

; 572  : 	}

  0006a	eb a7		 jmp	 SHORT $LN3@EAGetNextM
$LN2@EAGetNextM:

; 573  : 
; 574  : 	return 0;

  0006c	33 c0		 xor	 eax, eax
$LN4@EAGetNextM:

; 575  : }

  0006e	48 83 c4 18	 add	 rsp, 24
  00072	c3		 ret	 0
EAGetNextMode ENDP
_TEXT	ENDS
PUBLIC	EAGetFirstMode
; Function compile flags: /Odtp
;	COMDAT EAGetFirstMode
_TEXT	SEGMENT
ea$ = 8
EAGetFirstMode PROC					; COMDAT

; 551  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 552  : 	return (EncryptionAlgorithms[ea].Modes[0]);

  00004	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR ea$[rsp]
  00009	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  0000d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EncryptionAlgorithms
  00014	8b 44 08 10	 mov	 eax, DWORD PTR [rax+rcx+16]

; 553  : }

  00018	c3		 ret	 0
EAGetFirstMode ENDP
_TEXT	ENDS
PUBLIC	EAGetNext
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetNext DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$EAGetNext
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetNext DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAGetNext
_TEXT	SEGMENT
id$ = 0
previousEA$ = 32
EAGetNext PROC						; COMDAT

; 385  : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 386  : 	int id = previousEA + 1;

  00008	8b 44 24 20	 mov	 eax, DWORD PTR previousEA$[rsp]
  0000c	83 c0 01	 add	 eax, 1
  0000f	89 04 24	 mov	 DWORD PTR id$[rsp], eax

; 387  : 	if (EncryptionAlgorithms[id].Ciphers[0] != 0) return id;

  00012	48 63 0c 24	 movsxd	 rcx, DWORD PTR id$[rsp]
  00016	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EncryptionAlgorithms
  00021	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00025	74 05		 je	 SHORT $LN1@EAGetNext
  00027	8b 04 24	 mov	 eax, DWORD PTR id$[rsp]
  0002a	eb 02		 jmp	 SHORT $LN2@EAGetNext
$LN1@EAGetNext:

; 388  : 	return 0;

  0002c	33 c0		 xor	 eax, eax
$LN2@EAGetNext:

; 389  : }

  0002e	48 83 c4 18	 add	 rsp, 24
  00032	c3		 ret	 0
EAGetNext ENDP
_TEXT	ENDS
PUBLIC	EAGetFirst
; Function compile flags: /Odtp
;	COMDAT EAGetFirst
_TEXT	SEGMENT
EAGetFirst PROC						; COMDAT

; 354  : 	return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 355  : }

  00005	c3		 ret	 0
EAGetFirst ENDP
_TEXT	ENDS
PUBLIC	XorKeySchedule
;	COMDAT pdata
pdata	SEGMENT
$pdata$XorKeySchedule DD imagerel $LN8
	DD	imagerel $LN8+163
	DD	imagerel $unwind$XorKeySchedule
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$XorKeySchedule DD 011701H
	DD	08217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT XorKeySchedule
_TEXT	SEGMENT
tv64 = 48
cipher$ = 80
ks$ = 88
out_ks$ = 96
data$ = 104
len$ = 112
XorKeySchedule PROC					; COMDAT

; 329  : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 330  : 	switch (cipher)

  00017	8b 44 24 50	 mov	 eax, DWORD PTR cipher$[rsp]
  0001b	89 44 24 30	 mov	 DWORD PTR tv64[rsp], eax
  0001f	83 7c 24 30 01	 cmp	 DWORD PTR tv64[rsp], 1
  00024	74 09		 je	 SHORT $LN3@XorKeySche
  00026	83 7c 24 30 02	 cmp	 DWORD PTR tv64[rsp], 2
  0002b	74 2a		 je	 SHORT $LN2@XorKeySche
  0002d	eb 50		 jmp	 SHORT $LN1@XorKeySche
$LN3@XorKeySche:

; 331  : 	{
; 332  : 	case GOST:
; 333  : 		gost_xor_ks(ks, out_ks, data, len / sizeof(__int32));

  0002f	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  00034	33 d2		 xor	 edx, edx
  00036	b9 04 00 00 00	 mov	 ecx, 4
  0003b	48 f7 f1	 div	 rcx
  0003e	44 8b c8	 mov	 r9d, eax
  00041	4c 8b 44 24 68	 mov	 r8, QWORD PTR data$[rsp]
  00046	48 8b 54 24 60	 mov	 rdx, QWORD PTR out_ks$[rsp]
  0004b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ks$[rsp]
  00050	e8 00 00 00 00	 call	 gost_xor_ks

; 334  : 		break;

  00055	eb 47		 jmp	 SHORT $LN4@XorKeySche
$LN2@XorKeySche:

; 335  : 	case GRASSHOPPER:
; 336  : 		grasshopper_xor_ks(ks, out_ks, data, len / sizeof(__int32));

  00057	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  0005c	33 d2		 xor	 edx, edx
  0005e	b9 04 00 00 00	 mov	 ecx, 4
  00063	48 f7 f1	 div	 rcx
  00066	44 8b c8	 mov	 r9d, eax
  00069	4c 8b 44 24 68	 mov	 r8, QWORD PTR data$[rsp]
  0006e	48 8b 54 24 60	 mov	 rdx, QWORD PTR out_ks$[rsp]
  00073	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ks$[rsp]
  00078	e8 00 00 00 00	 call	 grasshopper_xor_ks

; 337  : 		break;

  0007d	eb 1f		 jmp	 SHORT $LN4@XorKeySche
$LN1@XorKeySche:

; 338  : 	default:
; 339  : 		GST_THROW_FATAL_EXCEPTION;

  0007f	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00088	45 33 c9	 xor	 r9d, r9d
  0008b	45 33 c0	 xor	 r8d, r8d
  0008e	ba 53 01 00 00	 mov	 edx, 339		; 00000153H
  00093	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN4@XorKeySche:
$LN7@XorKeySche:

; 340  : 	}
; 341  : }

  0009e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a2	c3		 ret	 0
XorKeySchedule ENDP
_TEXT	ENDS
PUBLIC	CipherSupportsIntraDataUnitParallelization
; Function compile flags: /Odtp
;	COMDAT CipherSupportsIntraDataUnitParallelization
_TEXT	SEGMENT
cipher$ = 8
CipherSupportsIntraDataUnitParallelization PROC		; COMDAT

; 310  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 311  : 	return 0;

  00004	33 c0		 xor	 eax, eax

; 312  : }

  00006	c3		 ret	 0
CipherSupportsIntraDataUnitParallelization ENDP
_TEXT	ENDS
PUBLIC	CipherGet
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGet DD imagerel $LN7
	DD	imagerel $LN7+100
	DD	imagerel $unwind$CipherGet
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGet DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CipherGet
_TEXT	SEGMENT
i$ = 0
id$ = 32
CipherGet PROC						; COMDAT

; 238  : {

$LN7:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 239  : 	int i;
; 240  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0000f	eb 09		 jmp	 SHORT $LN4@CipherGet
$LN3@CipherGet:
  00011	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00014	83 c0 01	 add	 eax, 1
  00017	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@CipherGet:
  0001a	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  0001e	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Ciphers
  00029	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  0002d	74 2e		 je	 SHORT $LN2@CipherGet

; 241  : 		if (Ciphers[i].Id == id)

  0002f	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  00033	48 6b d2 20	 imul	 rdx, 32			; 00000020H
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ciphers
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR id$[rsp]
  00042	39 04 11	 cmp	 DWORD PTR [rcx+rdx], eax
  00045	75 14		 jne	 SHORT $LN1@CipherGet

; 242  : 			return &Ciphers[i];

  00047	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  0004b	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Ciphers
  00056	48 03 c1	 add	 rax, rcx
  00059	eb 04		 jmp	 SHORT $LN5@CipherGet
$LN1@CipherGet:

; 243  : 
; 244  : 	return NULL;

  0005b	eb b4		 jmp	 SHORT $LN3@CipherGet
$LN2@CipherGet:
  0005d	33 c0		 xor	 eax, eax
$LN5@CipherGet:

; 245  : }

  0005f	48 83 c4 18	 add	 rsp, 24
  00063	c3		 ret	 0
CipherGet ENDP
PUBLIC	crypto_close
;	COMDAT pdata
pdata	SEGMENT
$pdata$crypto_close DD imagerel $LN9
	DD	imagerel $LN9+120
	DD	imagerel $unwind$crypto_close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$crypto_close DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT crypto_close
_TEXT	SEGMENT
burnc$27634 = 32
burnm$27632 = 40
cryptoInfo$ = 64
crypto_close PROC					; COMDAT

; 949  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 950  : #ifndef GST_WINDOWS_BOOT
; 951  : 
; 952  : 	if (cryptoInfo != NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR cryptoInfo$[rsp], 0
  0000f	74 62		 je	 SHORT $LN6@crypto_clo
$LN5@crypto_clo:

; 953  : 	{
; 954  : 		burn (cryptoInfo, sizeof (CRYPTO_INFO));

  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00016	48 89 44 24 28	 mov	 QWORD PTR burnm$27632[rsp], rax
  0001b	c7 44 24 20 10
	1f 00 00	 mov	 DWORD PTR burnc$27634[rsp], 7952 ; 00001f10H
  00023	ba 10 1f 00 00	 mov	 edx, 7952		; 00001f10H
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  0002d	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@crypto_clo:
  00032	8b 4c 24 20	 mov	 ecx, DWORD PTR burnc$27634[rsp]
  00036	8b 44 24 20	 mov	 eax, DWORD PTR burnc$27634[rsp]
  0003a	83 e8 01	 sub	 eax, 1
  0003d	89 44 24 20	 mov	 DWORD PTR burnc$27634[rsp], eax
  00041	85 c9		 test	 ecx, ecx
  00043	74 18		 je	 SHORT $LN1@crypto_clo
  00045	48 8b 44 24 28	 mov	 rax, QWORD PTR burnm$27632[rsp]
  0004a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR burnm$27632[rsp]
  00052	48 83 c0 01	 add	 rax, 1
  00056	48 89 44 24 28	 mov	 QWORD PTR burnm$27632[rsp], rax
  0005b	eb d5		 jmp	 SHORT $LN2@crypto_clo
$LN1@crypto_clo:
  0005d	33 c0		 xor	 eax, eax
  0005f	85 c0		 test	 eax, eax
  00061	75 ae		 jne	 SHORT $LN5@crypto_clo

; 955  : #ifndef DEVICE_DRIVER
; 956  : 		VirtualUnlock (cryptoInfo, sizeof (CRYPTO_INFO));
; 957  : #endif
; 958  : 		GSTfree (cryptoInfo);

  00063	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@crypto_clo:

; 959  : 	}
; 960  : 
; 961  : #else // GST_WINDOWS_BOOT
; 962  : 
; 963  : 	burn (&CryptoInfoBuffer, sizeof (CryptoInfoBuffer));
; 964  : 	CryptoInfoBufferInUse = FALSE;
; 965  : 
; 966  : #endif // GST_WINDOWS_BOOT
; 967  : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
crypto_close ENDP
_TEXT	ENDS
PUBLIC	crypto_loadkey
;	COMDAT pdata
pdata	SEGMENT
$pdata$crypto_loadkey DD imagerel $LN8
	DD	imagerel $LN8+151
	DD	imagerel $unwind$crypto_loadkey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$crypto_loadkey DD 031501H
	DD	070116215H
	DD	06010H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT crypto_loadkey
_TEXT	SEGMENT
burnc$27620 = 32
burnm$27618 = 40
keyInfo$ = 80
lpszUserKey$ = 88
nUserKeyLen$ = 96
crypto_loadkey PROC					; COMDAT

; 934  : {

$LN8:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 935  : 	keyInfo->keyLength = nUserKeyLen;

  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR keyInfo$[rsp]
  0001a	8b 44 24 60	 mov	 eax, DWORD PTR nUserKeyLen$[rsp]
  0001e	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN5@crypto_loa:

; 936  : 	burn (keyInfo->userKey, sizeof (keyInfo->userKey));

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR keyInfo$[rsp]
  00026	48 83 c0 08	 add	 rax, 8
  0002a	48 89 44 24 28	 mov	 QWORD PTR burnm$27618[rsp], rax
  0002f	c7 44 24 20 40
	00 00 00	 mov	 DWORD PTR burnc$27620[rsp], 64 ; 00000040H
  00037	48 8b 4c 24 50	 mov	 rcx, QWORD PTR keyInfo$[rsp]
  0003c	48 83 c1 08	 add	 rcx, 8
  00040	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00045	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@crypto_loa:
  0004a	8b 4c 24 20	 mov	 ecx, DWORD PTR burnc$27620[rsp]
  0004e	8b 44 24 20	 mov	 eax, DWORD PTR burnc$27620[rsp]
  00052	83 e8 01	 sub	 eax, 1
  00055	89 44 24 20	 mov	 DWORD PTR burnc$27620[rsp], eax
  00059	85 c9		 test	 ecx, ecx
  0005b	74 18		 je	 SHORT $LN1@crypto_loa
  0005d	48 8b 44 24 28	 mov	 rax, QWORD PTR burnm$27618[rsp]
  00062	c6 00 00	 mov	 BYTE PTR [rax], 0
  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR burnm$27618[rsp]
  0006a	48 83 c0 01	 add	 rax, 1
  0006e	48 89 44 24 28	 mov	 QWORD PTR burnm$27618[rsp], rax
  00073	eb d5		 jmp	 SHORT $LN2@crypto_loa
$LN1@crypto_loa:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 a6		 jne	 SHORT $LN5@crypto_loa

; 937  : 	memcpy (keyInfo->userKey, lpszUserKey, nUserKeyLen);

  0007b	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR nUserKeyLen$[rsp]
  00080	48 8b 7c 24 50	 mov	 rdi, QWORD PTR keyInfo$[rsp]
  00085	48 83 c7 08	 add	 rdi, 8
  00089	48 8b 74 24 58	 mov	 rsi, QWORD PTR lpszUserKey$[rsp]
  0008e	f3 a4		 rep movsb

; 938  : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	5f		 pop	 rdi
  00095	5e		 pop	 rsi
  00096	c3		 ret	 0
crypto_loadkey ENDP
_TEXT	ENDS
PUBLIC	EAIsModeSupported
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAIsModeSupported DD imagerel $LN7
	DD	imagerel $LN7+77
	DD	imagerel $unwind$EAIsModeSupported
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAIsModeSupported DD 010c01H
	DD	0620cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAIsModeSupported
_TEXT	SEGMENT
mode$ = 32
ea$ = 64
testedMode$ = 72
EAIsModeSupported PROC					; COMDAT

; 798  : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 799  : 	int mode;
; 800  : 
; 801  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  0000c	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  00010	e8 00 00 00 00	 call	 EAGetFirstMode
  00015	89 44 24 20	 mov	 DWORD PTR mode$[rsp], eax
  00019	eb 11		 jmp	 SHORT $LN4@EAIsModeSu
$LN3@EAIsModeSu:
  0001b	8b 54 24 20	 mov	 edx, DWORD PTR mode$[rsp]
  0001f	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  00023	e8 00 00 00 00	 call	 EAGetNextMode
  00028	89 44 24 20	 mov	 DWORD PTR mode$[rsp], eax
$LN4@EAIsModeSu:
  0002c	83 7c 24 20 00	 cmp	 DWORD PTR mode$[rsp], 0
  00031	74 13		 je	 SHORT $LN2@EAIsModeSu

; 802  : 	{
; 803  : 		if (mode == testedMode)

  00033	8b 44 24 48	 mov	 eax, DWORD PTR testedMode$[rsp]
  00037	39 44 24 20	 cmp	 DWORD PTR mode$[rsp], eax
  0003b	75 07		 jne	 SHORT $LN1@EAIsModeSu

; 804  : 			return TRUE;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	eb 04		 jmp	 SHORT $LN5@EAIsModeSu
$LN1@EAIsModeSu:

; 805  : 	}

  00044	eb d5		 jmp	 SHORT $LN3@EAIsModeSu
$LN2@EAIsModeSu:

; 806  : 	return FALSE;

  00046	33 c0		 xor	 eax, eax
$LN5@EAIsModeSu:

; 807  : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
EAIsModeSupported ENDP
_TEXT	ENDS
PUBLIC	CipherGetKeyScheduleSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetKeyScheduleSize DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$CipherGetKeyScheduleSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetKeyScheduleSize DD 010801H
	DD	04208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CipherGetKeyScheduleSize
_TEXT	SEGMENT
cipherId$ = 48
CipherGetKeyScheduleSize PROC				; COMDAT

; 295  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 296  : 	return CipherGet (cipherId) -> KeyScheduleSize;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR cipherId$[rsp]
  0000c	e8 00 00 00 00	 call	 CipherGet
  00011	8b 40 18	 mov	 eax, DWORD PTR [rax+24]

; 297  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
CipherGetKeyScheduleSize ENDP
_TEXT	ENDS
PUBLIC	CipherGetKeySize
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetKeySize DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$CipherGetKeySize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetKeySize DD 010801H
	DD	04208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CipherGetKeySize
_TEXT	SEGMENT
cipherId$ = 48
CipherGetKeySize PROC					; COMDAT

; 282  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 283  : 	return CipherGet (cipherId) -> KeySize;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR cipherId$[rsp]
  0000c	e8 00 00 00 00	 call	 CipherGet
  00011	8b 40 14	 mov	 eax, DWORD PTR [rax+20]

; 284  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
CipherGetKeySize ENDP
_TEXT	ENDS
PUBLIC	CipherGetBlockSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetBlockSize DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$CipherGetBlockSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetBlockSize DD 010801H
	DD	04208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CipherGetBlockSize
_TEXT	SEGMENT
cipherId$ = 48
CipherGetBlockSize PROC					; COMDAT

; 269  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 270  : 	return CipherGet (cipherId) -> BlockSize;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR cipherId$[rsp]
  0000c	e8 00 00 00 00	 call	 CipherGet
  00011	8b 40 10	 mov	 eax, DWORD PTR [rax+16]

; 271  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
CipherGetBlockSize ENDP
_TEXT	ENDS
PUBLIC	CipherGetName
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetName DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$CipherGetName
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetName DD 010801H
	DD	04208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CipherGetName
_TEXT	SEGMENT
cipherId$ = 48
CipherGetName PROC					; COMDAT

; 256  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 257  : 	return CipherGet (cipherId) -> Name;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR cipherId$[rsp]
  0000c	e8 00 00 00 00	 call	 CipherGet
  00011	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 258  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
CipherGetName ENDP
PUBLIC	EAGetKeyScheduleSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetKeyScheduleSize DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$EAGetKeyScheduleSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetKeyScheduleSize DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAGetKeyScheduleSize
_TEXT	SEGMENT
i$ = 32
size$ = 36
ea$ = 64
EAGetKeyScheduleSize PROC				; COMDAT

; 616  : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 617  : 	int i = EAGetFirstCipher(ea);

  00008	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  0000c	e8 00 00 00 00	 call	 EAGetFirstCipher
  00011	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 618  : 	int size = CipherGetKeyScheduleSize (i);

  00015	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00019	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  0001e	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax
$LN2@EAGetKeySc:

; 619  : 
; 620  : 	while (i = EAGetNextCipher(ea, i))

  00022	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00026	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  0002a	e8 00 00 00 00	 call	 EAGetNextCipher
  0002f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00033	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00038	74 19		 je	 SHORT $LN1@EAGetKeySc

; 621  : 	{
; 622  : 		size += CipherGetKeyScheduleSize (i);

  0003a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0003e	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  00043	44 8b d8	 mov	 r11d, eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  0004a	41 03 c3	 add	 eax, r11d
  0004d	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 623  : 	}

  00051	eb cf		 jmp	 SHORT $LN2@EAGetKeySc
$LN1@EAGetKeySc:

; 624  : 
; 625  : 	return size;

  00053	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]

; 626  : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
EAGetKeyScheduleSize ENDP
_TEXT	ENDS
PUBLIC	EAGetKeySize
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetKeySize DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$EAGetKeySize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetKeySize DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAGetKeySize
_TEXT	SEGMENT
i$ = 32
size$ = 36
ea$ = 64
EAGetKeySize PROC					; COMDAT

; 528  : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 529  : 	int i = EAGetFirstCipher (ea);

  00008	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  0000c	e8 00 00 00 00	 call	 EAGetFirstCipher
  00011	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 530  : 	int size = CipherGetKeySize (i);

  00015	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00019	e8 00 00 00 00	 call	 CipherGetKeySize
  0001e	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax
$LN2@EAGetKeySi:

; 531  : 
; 532  : 	while (i = EAGetNextCipher (ea, i))

  00022	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00026	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  0002a	e8 00 00 00 00	 call	 EAGetNextCipher
  0002f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00033	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00038	74 19		 je	 SHORT $LN1@EAGetKeySi

; 533  : 	{
; 534  : 		size += CipherGetKeySize (i);

  0003a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0003e	e8 00 00 00 00	 call	 CipherGetKeySize
  00043	44 8b d8	 mov	 r11d, eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  0004a	41 03 c3	 add	 eax, r11d
  0004d	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 535  : 	}

  00051	eb cf		 jmp	 SHORT $LN2@EAGetKeySi
$LN1@EAGetKeySi:

; 536  : 
; 537  : 	return size;

  00053	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]

; 538  : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
EAGetKeySize ENDP
_TEXT	ENDS
PUBLIC	EAGetName
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetName DD imagerel $LN9
	DD	imagerel $LN9+273
	DD	imagerel $unwind$EAGetName
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetName DD 030f01H
	DD	0700ba20fH
	DD	0600aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAGetName
_TEXT	SEGMENT
i$ = 32
tv70 = 40
tv71 = 48
tv72 = 56
tv73 = 64
tv74 = 72
buf$ = 112
ea$ = 120
EAGetName PROC						; COMDAT

; 478  : {

$LN9:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 479  : 	int i = EAGetLastCipher(ea);

  0000f	8b 4c 24 78	 mov	 ecx, DWORD PTR ea$[rsp]
  00013	e8 00 00 00 00	 call	 EAGetLastCipher
  00018	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 480  : 	strcpy (buf, (i != 0) ? CipherGetName (i) : "?");

  0001c	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00021	74 10		 je	 SHORT $LN5@EAGetName
  00023	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00027	e8 00 00 00 00	 call	 CipherGetName
  0002c	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00031	eb 0c		 jmp	 SHORT $LN6@EAGetName
$LN5@EAGetName:
  00033	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
  0003a	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN6@EAGetName:
  0003f	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  00044	48 89 44 24 30	 mov	 QWORD PTR tv71[rsp], rax
  00049	48 8b 44 24 70	 mov	 rax, QWORD PTR buf$[rsp]
  0004e	48 89 44 24 38	 mov	 QWORD PTR tv72[rsp], rax
  00053	48 8b 44 24 38	 mov	 rax, QWORD PTR tv72[rsp]
  00058	48 89 44 24 40	 mov	 QWORD PTR tv73[rsp], rax
$LN7@EAGetName:
  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR tv71[rsp]
  00062	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00065	88 44 24 48	 mov	 BYTE PTR tv74[rsp], al
  00069	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv72[rsp]
  0006e	0f b6 44 24 48	 movzx	 eax, BYTE PTR tv74[rsp]
  00073	88 01		 mov	 BYTE PTR [rcx], al
  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR tv71[rsp]
  0007a	48 83 c0 01	 add	 rax, 1
  0007e	48 89 44 24 30	 mov	 QWORD PTR tv71[rsp], rax
  00083	48 8b 44 24 38	 mov	 rax, QWORD PTR tv72[rsp]
  00088	48 83 c0 01	 add	 rax, 1
  0008c	48 89 44 24 38	 mov	 QWORD PTR tv72[rsp], rax
  00091	80 7c 24 48 00	 cmp	 BYTE PTR tv74[rsp], 0
  00096	75 c5		 jne	 SHORT $LN7@EAGetName
$LN2@EAGetName:

; 481  : 
; 482  : 	while (i = EAGetPreviousCipher(ea, i))

  00098	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  0009c	8b 4c 24 78	 mov	 ecx, DWORD PTR ea$[rsp]
  000a0	e8 00 00 00 00	 call	 EAGetPreviousCipher
  000a5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000a9	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  000ae	74 55		 je	 SHORT $LN1@EAGetName

; 483  : 	{
; 484  : 		strcat (buf, "-");

  000b0	48 8b 7c 24 70	 mov	 rdi, QWORD PTR buf$[rsp]
  000b5	33 c0		 xor	 eax, eax
  000b7	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  000be	f2 ae		 repne scasb
  000c0	48 83 ef 01	 sub	 rdi, 1
  000c4	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
  000cb	b9 02 00 00 00	 mov	 ecx, 2
  000d0	f3 a4		 rep movsb

; 485  : 		strcat (buf, CipherGetName (i));

  000d2	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000d6	e8 00 00 00 00	 call	 CipherGetName
  000db	48 8b d0	 mov	 rdx, rax
  000de	48 8b 7c 24 70	 mov	 rdi, QWORD PTR buf$[rsp]
  000e3	33 c0		 xor	 eax, eax
  000e5	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  000ec	f2 ae		 repne scasb
  000ee	48 83 ef 01	 sub	 rdi, 1
  000f2	33 c9		 xor	 ecx, ecx
$LL8@EAGetName:
  000f4	0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+rcx]
  000f8	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
  000fb	48 83 c1 01	 add	 rcx, 1
  000ff	84 c0		 test	 al, al
  00101	75 f1		 jne	 SHORT $LL8@EAGetName

; 486  : 	}

  00103	eb 93		 jmp	 SHORT $LN2@EAGetName
$LN1@EAGetName:

; 487  : 
; 488  : 	return buf;

  00105	48 8b 44 24 70	 mov	 rax, QWORD PTR buf$[rsp]

; 489  : }

  0010a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010e	5f		 pop	 rdi
  0010f	5e		 pop	 rsi
  00110	c3		 ret	 0
EAGetName ENDP
PUBLIC	EAGetLargestKeyForMode
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetLargestKeyForMode DD imagerel $LN8
	DD	imagerel $LN8+105
	DD	imagerel $unwind$EAGetLargestKeyForMode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetLargestKeyForMode DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAGetLargestKeyForMode
_TEXT	SEGMENT
key$ = 32
ea$ = 36
mode$ = 64
EAGetLargestKeyForMode PROC				; COMDAT

; 639  : {

$LN8:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 640  : 	int ea, key = 0;

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR key$[rsp], 0

; 641  : 
; 642  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00010	e8 00 00 00 00	 call	 EAGetFirst
  00015	89 44 24 24	 mov	 DWORD PTR ea$[rsp], eax
  00019	eb 0d		 jmp	 SHORT $LN5@EAGetLarge
$LN4@EAGetLarge:
  0001b	8b 4c 24 24	 mov	 ecx, DWORD PTR ea$[rsp]
  0001f	e8 00 00 00 00	 call	 EAGetNext
  00024	89 44 24 24	 mov	 DWORD PTR ea$[rsp], eax
$LN5@EAGetLarge:
  00028	83 7c 24 24 00	 cmp	 DWORD PTR ea$[rsp], 0
  0002d	74 31		 je	 SHORT $LN3@EAGetLarge

; 643  : 	{
; 644  : 		if (!EAIsModeSupported (ea, mode))

  0002f	8b 54 24 40	 mov	 edx, DWORD PTR mode$[rsp]
  00033	8b 4c 24 24	 mov	 ecx, DWORD PTR ea$[rsp]
  00037	e8 00 00 00 00	 call	 EAIsModeSupported
  0003c	85 c0		 test	 eax, eax
  0003e	75 02		 jne	 SHORT $LN2@EAGetLarge

; 645  : 			continue;

  00040	eb d9		 jmp	 SHORT $LN4@EAGetLarge
$LN2@EAGetLarge:

; 646  : 
; 647  : 		if (EAGetKeySize (ea) >= key)

  00042	8b 4c 24 24	 mov	 ecx, DWORD PTR ea$[rsp]
  00046	e8 00 00 00 00	 call	 EAGetKeySize
  0004b	3b 44 24 20	 cmp	 eax, DWORD PTR key$[rsp]
  0004f	7c 0d		 jl	 SHORT $LN1@EAGetLarge

; 648  : 			key = EAGetKeySize (ea);

  00051	8b 4c 24 24	 mov	 ecx, DWORD PTR ea$[rsp]
  00055	e8 00 00 00 00	 call	 EAGetKeySize
  0005a	89 44 24 20	 mov	 DWORD PTR key$[rsp], eax
$LN1@EAGetLarge:

; 649  : 	}

  0005e	eb bb		 jmp	 SHORT $LN4@EAGetLarge
$LN3@EAGetLarge:

; 650  : 	return key;

  00060	8b 44 24 20	 mov	 eax, DWORD PTR key$[rsp]

; 651  : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
EAGetLargestKeyForMode ENDP
_TEXT	ENDS
PUBLIC	DecipherBlock
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecipherBlock DD imagerel $LN8
	DD	imagerel $LN8+122
	DD	imagerel $unwind$DecipherBlock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecipherBlock DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecipherBlock
_TEXT	SEGMENT
tv64 = 48
cipher$ = 80
data$ = 88
ks$ = 96
DecipherBlock PROC					; COMDAT

; 187  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 188  : 	switch (cipher)

  00012	8b 44 24 50	 mov	 eax, DWORD PTR cipher$[rsp]
  00016	89 44 24 30	 mov	 DWORD PTR tv64[rsp], eax
  0001a	83 7c 24 30 01	 cmp	 DWORD PTR tv64[rsp], 1
  0001f	74 09		 je	 SHORT $LN3@DecipherBl
  00021	83 7c 24 30 02	 cmp	 DWORD PTR tv64[rsp], 2
  00026	74 18		 je	 SHORT $LN2@DecipherBl
  00028	eb 2c		 jmp	 SHORT $LN1@DecipherBl
$LN3@DecipherBl:

; 189  : 	{
; 190  : 	case GOST:
; 191  : 		gost_decrypt((byte *)data, (byte *)data, ks);

  0002a	4c 8b 44 24 60	 mov	 r8, QWORD PTR ks$[rsp]
  0002f	48 8b 54 24 58	 mov	 rdx, QWORD PTR data$[rsp]
  00034	48 8b 4c 24 58	 mov	 rcx, QWORD PTR data$[rsp]
  00039	e8 00 00 00 00	 call	 gost_decrypt

; 192  : 		break;

  0003e	eb 35		 jmp	 SHORT $LN4@DecipherBl
$LN2@DecipherBl:

; 193  : 	case GRASSHOPPER:
; 194  : 		grasshopper_decrypt(ks, (unsigned long*)data, (unsigned long*)data);

  00040	4c 8b 44 24 58	 mov	 r8, QWORD PTR data$[rsp]
  00045	48 8b 54 24 58	 mov	 rdx, QWORD PTR data$[rsp]
  0004a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ks$[rsp]
  0004f	e8 00 00 00 00	 call	 grasshopper_decrypt

; 195  : 		break;

  00054	eb 1f		 jmp	 SHORT $LN4@DecipherBl
$LN1@DecipherBl:

; 196  : 	default:		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00056	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0005f	45 33 c9	 xor	 r9d, r9d
  00062	45 33 c0	 xor	 r8d, r8d
  00065	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  0006a	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN4@DecipherBl:
$LN7@DecipherBl:

; 197  : 	}
; 198  : }

  00075	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00079	c3		 ret	 0
DecipherBlock ENDP
_TEXT	ENDS
PUBLIC	EncipherBlock
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncipherBlock DD imagerel $LN8
	DD	imagerel $LN8+122
	DD	imagerel $unwind$EncipherBlock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncipherBlock DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncipherBlock
_TEXT	SEGMENT
tv64 = 48
cipher$ = 80
data$ = 88
ks$ = 96
EncipherBlock PROC					; COMDAT

; 137  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 138  : 	switch (cipher)

  00012	8b 44 24 50	 mov	 eax, DWORD PTR cipher$[rsp]
  00016	89 44 24 30	 mov	 DWORD PTR tv64[rsp], eax
  0001a	83 7c 24 30 01	 cmp	 DWORD PTR tv64[rsp], 1
  0001f	74 09		 je	 SHORT $LN3@EncipherBl
  00021	83 7c 24 30 02	 cmp	 DWORD PTR tv64[rsp], 2
  00026	74 18		 je	 SHORT $LN2@EncipherBl
  00028	eb 2c		 jmp	 SHORT $LN1@EncipherBl
$LN3@EncipherBl:

; 139  : 	{
; 140  : 	case GOST:
; 141  : 		gost_encrypt((byte *)data, (byte *)data, ks);

  0002a	4c 8b 44 24 60	 mov	 r8, QWORD PTR ks$[rsp]
  0002f	48 8b 54 24 58	 mov	 rdx, QWORD PTR data$[rsp]
  00034	48 8b 4c 24 58	 mov	 rcx, QWORD PTR data$[rsp]
  00039	e8 00 00 00 00	 call	 gost_encrypt

; 142  : 		break;

  0003e	eb 35		 jmp	 SHORT $LN4@EncipherBl
$LN2@EncipherBl:

; 143  : 	case GRASSHOPPER:
; 144  : 		grasshopper_encrypt(ks, (unsigned long *)data, (unsigned long *)data);

  00040	4c 8b 44 24 58	 mov	 r8, QWORD PTR data$[rsp]
  00045	48 8b 54 24 58	 mov	 rdx, QWORD PTR data$[rsp]
  0004a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ks$[rsp]
  0004f	e8 00 00 00 00	 call	 grasshopper_encrypt

; 145  : 		break;

  00054	eb 1f		 jmp	 SHORT $LN4@EncipherBl
$LN1@EncipherBl:

; 146  : 	default:			GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00056	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0005f	45 33 c9	 xor	 r9d, r9d
  00062	45 33 c0	 xor	 r8d, r8d
  00065	ba 92 00 00 00	 mov	 edx, 146		; 00000092H
  0006a	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN4@EncipherBl:
$LN7@EncipherBl:

; 147  : 	}
; 148  : }

  00075	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00079	c3		 ret	 0
EncipherBlock ENDP
PUBLIC	GetMaxPkcs5OutSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetMaxPkcs5OutSize DD imagerel $LN7
	DD	imagerel $LN7+125
	DD	imagerel $unwind$GetMaxPkcs5OutSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetMaxPkcs5OutSize DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetMaxPkcs5OutSize
_TEXT	SEGMENT
size$ = 32
tv71 = 36
tv79 = 40
GetMaxPkcs5OutSize PROC					; COMDAT

; 1319 : {

$LN7:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1320 : 	int size = 32;

  00004	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR size$[rsp], 32 ; 00000020H

; 1321 : 
; 1322 : 	size = max (size, EAGetLargestKeyForMode (XTS) * 2);	// Sizes of primary + secondary keys

  0000c	b9 01 00 00 00	 mov	 ecx, 1
  00011	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  00016	d1 e0		 shl	 eax, 1
  00018	39 44 24 20	 cmp	 DWORD PTR size$[rsp], eax
  0001c	7e 0a		 jle	 SHORT $LN3@GetMaxPkcs
  0001e	8b 44 24 20	 mov	 eax, DWORD PTR size$[rsp]
  00022	89 44 24 24	 mov	 DWORD PTR tv71[rsp], eax
  00026	eb 10		 jmp	 SHORT $LN4@GetMaxPkcs
$LN3@GetMaxPkcs:
  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  00032	d1 e0		 shl	 eax, 1
  00034	89 44 24 24	 mov	 DWORD PTR tv71[rsp], eax
$LN4@GetMaxPkcs:
  00038	8b 44 24 24	 mov	 eax, DWORD PTR tv71[rsp]
  0003c	89 44 24 20	 mov	 DWORD PTR size$[rsp], eax

; 1323 : 	size = max (size, EAGetLargestKeyForMode (XTS8) * 2);

  00040	b9 02 00 00 00	 mov	 ecx, 2
  00045	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  0004a	d1 e0		 shl	 eax, 1
  0004c	39 44 24 20	 cmp	 DWORD PTR size$[rsp], eax
  00050	7e 0a		 jle	 SHORT $LN5@GetMaxPkcs
  00052	8b 44 24 20	 mov	 eax, DWORD PTR size$[rsp]
  00056	89 44 24 28	 mov	 DWORD PTR tv79[rsp], eax
  0005a	eb 10		 jmp	 SHORT $LN6@GetMaxPkcs
$LN5@GetMaxPkcs:
  0005c	b9 02 00 00 00	 mov	 ecx, 2
  00061	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  00066	d1 e0		 shl	 eax, 1
  00068	89 44 24 28	 mov	 DWORD PTR tv79[rsp], eax
$LN6@GetMaxPkcs:
  0006c	8b 44 24 28	 mov	 eax, DWORD PTR tv79[rsp]
  00070	89 44 24 20	 mov	 DWORD PTR size$[rsp], eax

; 1324 : 
; 1325 : 	return size;

  00074	8b 44 24 20	 mov	 eax, DWORD PTR size$[rsp]

; 1326 : }

  00078	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007c	c3		 ret	 0
GetMaxPkcs5OutSize ENDP
_TEXT	ENDS
PUBLIC	DecipherBlocks
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecipherBlocks DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$DecipherBlocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecipherBlocks DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecipherBlocks
_TEXT	SEGMENT
data$ = 32
blockSize$ = 40
cipher$ = 64
dataPtr$ = 72
ks$ = 80
blockCount$ = 88
DecipherBlocks PROC					; COMDAT

; 214  : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 215  : 	byte *data = dataPtr;

  00017	48 8b 44 24 48	 mov	 rax, QWORD PTR dataPtr$[rsp]
  0001c	48 89 44 24 20	 mov	 QWORD PTR data$[rsp], rax

; 216  : 	size_t blockSize = CipherGetBlockSize (cipher);

  00021	8b 4c 24 40	 mov	 ecx, DWORD PTR cipher$[rsp]
  00025	e8 00 00 00 00	 call	 CipherGetBlockSize
  0002a	48 98		 cdqe
  0002c	48 89 44 24 28	 mov	 QWORD PTR blockSize$[rsp], rax
$LN2@DecipherBl@2:

; 217  : 	while (blockCount-- > 0)

  00031	48 8b 4c 24 58	 mov	 rcx, QWORD PTR blockCount$[rsp]
  00036	48 8b 44 24 58	 mov	 rax, QWORD PTR blockCount$[rsp]
  0003b	48 83 e8 01	 sub	 rax, 1
  0003f	48 89 44 24 58	 mov	 QWORD PTR blockCount$[rsp], rax
  00044	48 85 c9	 test	 rcx, rcx
  00047	76 27		 jbe	 SHORT $LN1@DecipherBl@2

; 218  : 	{
; 219  : 		DecipherBlock (cipher, data, ks);

  00049	4c 8b 44 24 50	 mov	 r8, QWORD PTR ks$[rsp]
  0004e	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  00053	8b 4c 24 40	 mov	 ecx, DWORD PTR cipher$[rsp]
  00057	e8 00 00 00 00	 call	 DecipherBlock

; 220  : 		data += blockSize;

  0005c	4c 8b 5c 24 28	 mov	 r11, QWORD PTR blockSize$[rsp]
  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00066	49 03 c3	 add	 rax, r11
  00069	48 89 44 24 20	 mov	 QWORD PTR data$[rsp], rax

; 221  : 	}

  0006e	eb c1		 jmp	 SHORT $LN2@DecipherBl@2
$LN1@DecipherBl@2:

; 222  : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
DecipherBlocks ENDP
_TEXT	ENDS
PUBLIC	EncipherBlocks
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncipherBlocks DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$EncipherBlocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncipherBlocks DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncipherBlocks
_TEXT	SEGMENT
data$ = 32
blockSize$ = 40
cipher$ = 64
dataPtr$ = 72
ks$ = 80
blockCount$ = 88
EncipherBlocks PROC					; COMDAT

; 164  : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 165  : 	byte *data = dataPtr;

  00017	48 8b 44 24 48	 mov	 rax, QWORD PTR dataPtr$[rsp]
  0001c	48 89 44 24 20	 mov	 QWORD PTR data$[rsp], rax

; 166  : 	size_t blockSize = CipherGetBlockSize (cipher);

  00021	8b 4c 24 40	 mov	 ecx, DWORD PTR cipher$[rsp]
  00025	e8 00 00 00 00	 call	 CipherGetBlockSize
  0002a	48 98		 cdqe
  0002c	48 89 44 24 28	 mov	 QWORD PTR blockSize$[rsp], rax
$LN2@EncipherBl@2:

; 167  : 	while (blockCount-- > 0)

  00031	48 8b 4c 24 58	 mov	 rcx, QWORD PTR blockCount$[rsp]
  00036	48 8b 44 24 58	 mov	 rax, QWORD PTR blockCount$[rsp]
  0003b	48 83 e8 01	 sub	 rax, 1
  0003f	48 89 44 24 58	 mov	 QWORD PTR blockCount$[rsp], rax
  00044	48 85 c9	 test	 rcx, rcx
  00047	76 27		 jbe	 SHORT $LN1@EncipherBl@2

; 168  : 	{
; 169  : 		EncipherBlock (cipher, data, ks);

  00049	4c 8b 44 24 50	 mov	 r8, QWORD PTR ks$[rsp]
  0004e	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  00053	8b 4c 24 40	 mov	 ecx, DWORD PTR cipher$[rsp]
  00057	e8 00 00 00 00	 call	 EncipherBlock

; 170  : 		data += blockSize;

  0005c	4c 8b 5c 24 28	 mov	 r11, QWORD PTR blockSize$[rsp]
  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00066	49 03 c3	 add	 rax, r11
  00069	48 89 44 24 20	 mov	 QWORD PTR data$[rsp], rax

; 171  : 	}

  0006e	eb c1		 jmp	 SHORT $LN2@EncipherBl@2
$LN1@EncipherBl@2:

; 172  : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
EncipherBlocks ENDP
_TEXT	ENDS
PUBLIC	CipherInit
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherInit DD imagerel $LN8
	DD	imagerel $LN8+100
	DD	imagerel $unwind$CipherInit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherInit DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CipherInit
_TEXT	SEGMENT
retVal$ = 32
tv64 = 36
cipher$ = 64
key$ = 72
ks$ = 80
CipherInit PROC						; COMDAT

; 107  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 108  : 	int retVal = ERR_SUCCESS;

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR retVal$[rsp], 0

; 109  : 
; 110  : 	switch (cipher)

  0001a	8b 44 24 40	 mov	 eax, DWORD PTR cipher$[rsp]
  0001e	89 44 24 24	 mov	 DWORD PTR tv64[rsp], eax
  00022	83 7c 24 24 01	 cmp	 DWORD PTR tv64[rsp], 1
  00027	74 09		 je	 SHORT $LN3@CipherInit
  00029	83 7c 24 24 02	 cmp	 DWORD PTR tv64[rsp], 2
  0002e	74 13		 je	 SHORT $LN2@CipherInit
  00030	eb 22		 jmp	 SHORT $LN1@CipherInit
$LN3@CipherInit:

; 111  : 	{
; 112  : 	case GOST:
; 113  : 		gost_set_key(key, (gost_kds *)ks);

  00032	48 8b 54 24 50	 mov	 rdx, QWORD PTR ks$[rsp]
  00037	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0003c	e8 00 00 00 00	 call	 gost_set_key

; 114  : 		break;

  00041	eb 18		 jmp	 SHORT $LN4@CipherInit
$LN2@CipherInit:

; 115  : 	case GRASSHOPPER:
; 116  : 		grasshopper_set_key((unsigned long *)key, (grasshopper_kds*)ks);

  00043	48 8b 54 24 50	 mov	 rdx, QWORD PTR ks$[rsp]
  00048	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0004d	e8 00 00 00 00	 call	 grasshopper_set_key

; 117  : 		break;

  00052	eb 07		 jmp	 SHORT $LN4@CipherInit
$LN1@CipherInit:

; 118  : 	default:
; 119  : 		// Unknown/wrong cipher ID
; 120  : 		return ERR_CIPHER_INIT_FAILURE;

  00054	b8 11 00 00 00	 mov	 eax, 17
  00059	eb 04		 jmp	 SHORT $LN6@CipherInit
$LN4@CipherInit:

; 121  : 	}
; 122  : 
; 123  : 	return retVal;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR retVal$[rsp]
$LN6@CipherInit:

; 124  : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
CipherInit ENDP
PUBLIC	DecryptDataUnitsCurrentThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptDataUnitsCurrentThread DD imagerel $LN14
	DD	imagerel $LN14+577
	DD	imagerel $unwind$DecryptDataUnitsCurrentThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptDataUnitsCurrentThread DD 011801H
	DD	0e218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecryptDataUnitsCurrentThread
_TEXT	SEGMENT
ea$ = 64
ks$ = 72
cipher$ = 80
ks2$ = 88
tv67 = 96
buf$ = 128
structUnitNo$ = 136
nbrUnits$ = 144
ci$ = 152
DecryptDataUnitsCurrentThread PROC			; COMDAT

; 1259 : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1260 : 	int ea = ci->ea;

  00018	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ci$[rsp]
  00020	8b 00		 mov	 eax, DWORD PTR [rax]
  00022	89 44 24 40	 mov	 DWORD PTR ea$[rsp], eax

; 1261 : 	unsigned __int8 *ks = ci->ks;

  00026	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ci$[rsp]
  0002e	48 83 c0 08	 add	 rax, 8
  00032	48 89 44 24 48	 mov	 QWORD PTR ks$[rsp], rax

; 1262 : 	unsigned __int8 *ks2 = ci->ks2;

  00037	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ci$[rsp]
  0003f	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00045	48 89 44 24 58	 mov	 QWORD PTR ks2$[rsp], rax

; 1263 : 	int cipher;
; 1264 : 
; 1265 : 	switch (ci->mode)

  0004a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ci$[rsp]
  00052	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00055	89 44 24 60	 mov	 DWORD PTR tv67[rsp], eax
  00059	83 7c 24 60 01	 cmp	 DWORD PTR tv67[rsp], 1
  0005e	74 10		 je	 SHORT $LN9@DecryptDat
  00060	83 7c 24 60 02	 cmp	 DWORD PTR tv67[rsp], 2
  00065	0f 84 dd 00 00
	00		 je	 $LN5@DecryptDat
  0006b	e9 ad 01 00 00	 jmp	 $LN1@DecryptDat
$LN9@DecryptDat:

; 1266 : 	{
; 1267 : 	case XTS:
; 1268 : 		ks += EAGetKeyScheduleSize (ea);

  00070	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  00074	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  00079	48 63 c8	 movsxd	 rcx, eax
  0007c	48 8b 44 24 48	 mov	 rax, QWORD PTR ks$[rsp]
  00081	48 03 c1	 add	 rax, rcx
  00084	48 89 44 24 48	 mov	 QWORD PTR ks$[rsp], rax

; 1269 : 		ks2 += EAGetKeyScheduleSize (ea);

  00089	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  0008d	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  00092	48 63 c8	 movsxd	 rcx, eax
  00095	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$[rsp]
  0009a	48 03 c1	 add	 rax, rcx
  0009d	48 89 44 24 58	 mov	 QWORD PTR ks2$[rsp], rax

; 1270 : 
; 1271 : 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  000a2	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  000a6	e8 00 00 00 00	 call	 EAGetLastCipher
  000ab	89 44 24 50	 mov	 DWORD PTR cipher$[rsp], eax
  000af	eb 11		 jmp	 SHORT $LN8@DecryptDat
$LN7@DecryptDat:
  000b1	8b 54 24 50	 mov	 edx, DWORD PTR cipher$[rsp]
  000b5	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  000b9	e8 00 00 00 00	 call	 EAGetPreviousCipher
  000be	89 44 24 50	 mov	 DWORD PTR cipher$[rsp], eax
$LN8@DecryptDat:
  000c2	83 7c 24 50 00	 cmp	 DWORD PTR cipher$[rsp], 0
  000c7	74 7a		 je	 SHORT $LN6@DecryptDat

; 1272 : 		{
; 1273 : 			ks -= CipherGetKeyScheduleSize (cipher);

  000c9	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$[rsp]
  000cd	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  000d2	48 63 c8	 movsxd	 rcx, eax
  000d5	48 8b 44 24 48	 mov	 rax, QWORD PTR ks$[rsp]
  000da	48 2b c1	 sub	 rax, rcx
  000dd	48 89 44 24 48	 mov	 QWORD PTR ks$[rsp], rax

; 1274 : 			ks2 -= CipherGetKeyScheduleSize (cipher);

  000e2	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$[rsp]
  000e6	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  000eb	48 63 c8	 movsxd	 rcx, eax
  000ee	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$[rsp]
  000f3	48 2b c1	 sub	 rax, rcx
  000f6	48 89 44 24 58	 mov	 QWORD PTR ks2$[rsp], rax

; 1275 : 
; 1276 : 			DecryptBufferXTS (buf,
; 1277 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1278 : 				structUnitNo,
; 1279 : 				0,
; 1280 : 				ks,
; 1281 : 				ks2,
; 1282 : 				cipher);

  000fb	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR nbrUnits$[rsp]
  00103	48 69 d2 00 02
	00 00		 imul	 rdx, 512		; 00000200H
  0010a	8b 44 24 50	 mov	 eax, DWORD PTR cipher$[rsp]
  0010e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00112	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$[rsp]
  00117	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011c	48 8b 44 24 48	 mov	 rax, QWORD PTR ks$[rsp]
  00121	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00126	45 33 c9	 xor	 r9d, r9d
  00129	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR structUnitNo$[rsp]
  00131	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00139	e8 00 00 00 00	 call	 DecryptBufferXTS

; 1283 : 		}

  0013e	e9 6e ff ff ff	 jmp	 $LN7@DecryptDat
$LN6@DecryptDat:

; 1284 : 		break;

  00143	e9 f4 00 00 00	 jmp	 $LN10@DecryptDat
$LN5@DecryptDat:

; 1285 : 	case XTS8:
; 1286 : 		ks += EAGetKeyScheduleSize(ea);

  00148	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  0014c	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  00151	48 63 c8	 movsxd	 rcx, eax
  00154	48 8b 44 24 48	 mov	 rax, QWORD PTR ks$[rsp]
  00159	48 03 c1	 add	 rax, rcx
  0015c	48 89 44 24 48	 mov	 QWORD PTR ks$[rsp], rax

; 1287 : 		ks2 += EAGetKeyScheduleSize(ea);

  00161	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  00165	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  0016a	48 63 c8	 movsxd	 rcx, eax
  0016d	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$[rsp]
  00172	48 03 c1	 add	 rax, rcx
  00175	48 89 44 24 58	 mov	 QWORD PTR ks2$[rsp], rax

; 1288 : 
; 1289 : 		for (cipher = EAGetLastCipher(ea); cipher != 0; cipher = EAGetPreviousCipher(ea, cipher))

  0017a	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  0017e	e8 00 00 00 00	 call	 EAGetLastCipher
  00183	89 44 24 50	 mov	 DWORD PTR cipher$[rsp], eax
  00187	eb 11		 jmp	 SHORT $LN4@DecryptDat
$LN3@DecryptDat:
  00189	8b 54 24 50	 mov	 edx, DWORD PTR cipher$[rsp]
  0018d	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  00191	e8 00 00 00 00	 call	 EAGetPreviousCipher
  00196	89 44 24 50	 mov	 DWORD PTR cipher$[rsp], eax
$LN4@DecryptDat:
  0019a	83 7c 24 50 00	 cmp	 DWORD PTR cipher$[rsp], 0
  0019f	74 7a		 je	 SHORT $LN2@DecryptDat

; 1290 : 		{
; 1291 : 			ks -= CipherGetKeyScheduleSize(cipher);

  001a1	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$[rsp]
  001a5	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  001aa	48 63 c8	 movsxd	 rcx, eax
  001ad	48 8b 44 24 48	 mov	 rax, QWORD PTR ks$[rsp]
  001b2	48 2b c1	 sub	 rax, rcx
  001b5	48 89 44 24 48	 mov	 QWORD PTR ks$[rsp], rax

; 1292 : 			ks2 -= CipherGetKeyScheduleSize(cipher);

  001ba	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$[rsp]
  001be	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  001c3	48 63 c8	 movsxd	 rcx, eax
  001c6	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$[rsp]
  001cb	48 2b c1	 sub	 rax, rcx
  001ce	48 89 44 24 58	 mov	 QWORD PTR ks2$[rsp], rax

; 1293 : 
; 1294 : 			DecryptBufferXTS8Byte(buf,
; 1295 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1296 : 				structUnitNo,
; 1297 : 				0,
; 1298 : 				ks,
; 1299 : 				ks2,
; 1300 : 				cipher);

  001d3	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR nbrUnits$[rsp]
  001db	48 69 d2 00 02
	00 00		 imul	 rdx, 512		; 00000200H
  001e2	8b 44 24 50	 mov	 eax, DWORD PTR cipher$[rsp]
  001e6	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001ea	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$[rsp]
  001ef	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f4	48 8b 44 24 48	 mov	 rax, QWORD PTR ks$[rsp]
  001f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fe	45 33 c9	 xor	 r9d, r9d
  00201	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR structUnitNo$[rsp]
  00209	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00211	e8 00 00 00 00	 call	 DecryptBufferXTS8Byte

; 1301 : 		}

  00216	e9 6e ff ff ff	 jmp	 $LN3@DecryptDat
$LN2@DecryptDat:

; 1302 : 		break;

  0021b	eb 1f		 jmp	 SHORT $LN10@DecryptDat
$LN1@DecryptDat:

; 1303 : 	default:		
; 1304 : 		// Unknown/wrong ID
; 1305 : 		GST_THROW_FATAL_EXCEPTION;

  0021d	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00226	45 33 c9	 xor	 r9d, r9d
  00229	45 33 c0	 xor	 r8d, r8d
  0022c	ba 19 05 00 00	 mov	 edx, 1305		; 00000519H
  00231	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN10@DecryptDat:
$LN13@DecryptDat:

; 1306 : 	}
; 1307 : }

  0023c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00240	c3		 ret	 0
DecryptDataUnitsCurrentThread ENDP
_TEXT	ENDS
PUBLIC	DecryptBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBuffer DD imagerel $LN14
	DD	imagerel $LN14+623
	DD	imagerel $unwind$DecryptBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBuffer DD 021601H
	DD	0130116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecryptBuffer
_TEXT	SEGMENT
ks$27729 = 64
dataUnitNo$27731 = 72
cipher$27732 = 80
ks2$27730 = 88
ks$27737 = 96
dataUnitNo$27739 = 104
cipher$27740 = 112
ks2$27738 = 120
tv65 = 128
buf$ = 160
len$ = 168
cryptoInfo$ = 176
DecryptBuffer PROC					; COMDAT

; 1168 : {

$LN14:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1169 : 	switch (cryptoInfo->mode)

  00016	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00021	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00028	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR tv65[rsp], 1
  00030	74 13		 je	 SHORT $LN9@DecryptBuf@5
  00032	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR tv65[rsp], 2
  0003a	0f 84 08 01 00
	00		 je	 $LN5@DecryptBuf@5
  00040	e9 03 02 00 00	 jmp	 $LN1@DecryptBuf@5
$LN9@DecryptBuf@5:

; 1170 : 	{
; 1171 : 	case XTS:
; 1172 : 		{
; 1173 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  00045	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0004d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0004f	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  00054	48 63 c8	 movsxd	 rcx, eax
  00057	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0005f	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  00064	48 89 44 24 40	 mov	 QWORD PTR ks$27729[rsp], rax

; 1174 : 			unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize (cryptoInfo->ea);

  00069	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00071	8b 08		 mov	 ecx, DWORD PTR [rax]
  00073	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  00078	48 63 c8	 movsxd	 rcx, eax
  0007b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00083	48 8d 84 08 28
	02 00 00	 lea	 rax, QWORD PTR [rax+rcx+552]
  0008b	48 89 44 24 58	 mov	 QWORD PTR ks2$27730[rsp], rax

; 1175 : 			UINT64_STRUCT dataUnitNo;
; 1176 : 			int cipher;
; 1177 : 
; 1178 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1179 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1180 : 			// always assumed to be aligned with the start of the data unit 0.
; 1181 : 			dataUnitNo.LowPart = 0;

  00090	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR dataUnitNo$27731[rsp], 0

; 1182 : 			dataUnitNo.HighPart = 0;

  00098	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR dataUnitNo$27731[rsp+4], 0

; 1183 : 
; 1184 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 1185 : 				cipher != 0;
; 1186 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  000a0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  000a8	8b 08		 mov	 ecx, DWORD PTR [rax]
  000aa	e8 00 00 00 00	 call	 EAGetLastCipher
  000af	89 44 24 50	 mov	 DWORD PTR cipher$27732[rsp], eax
  000b3	eb 17		 jmp	 SHORT $LN8@DecryptBuf@5
$LN7@DecryptBuf@5:
  000b5	8b 54 24 50	 mov	 edx, DWORD PTR cipher$27732[rsp]
  000b9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  000c1	8b 08		 mov	 ecx, DWORD PTR [rax]
  000c3	e8 00 00 00 00	 call	 EAGetPreviousCipher
  000c8	89 44 24 50	 mov	 DWORD PTR cipher$27732[rsp], eax
$LN8@DecryptBuf@5:
  000cc	83 7c 24 50 00	 cmp	 DWORD PTR cipher$27732[rsp], 0
  000d1	74 70		 je	 SHORT $LN6@DecryptBuf@5

; 1187 : 			{
; 1188 : 				ks -= CipherGetKeyScheduleSize (cipher);

  000d3	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$27732[rsp]
  000d7	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  000dc	48 63 c8	 movsxd	 rcx, eax
  000df	48 8b 44 24 40	 mov	 rax, QWORD PTR ks$27729[rsp]
  000e4	48 2b c1	 sub	 rax, rcx
  000e7	48 89 44 24 40	 mov	 QWORD PTR ks$27729[rsp], rax

; 1189 : 				ks2 -= CipherGetKeyScheduleSize (cipher);

  000ec	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$27732[rsp]
  000f0	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  000f5	48 63 c8	 movsxd	 rcx, eax
  000f8	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$27730[rsp]
  000fd	48 2b c1	 sub	 rax, rcx
  00100	48 89 44 24 58	 mov	 QWORD PTR ks2$27730[rsp], rax

; 1190 : 
; 1191 : 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00105	8b 44 24 50	 mov	 eax, DWORD PTR cipher$27732[rsp]
  00109	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0010d	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$27730[rsp]
  00112	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00117	48 8b 44 24 40	 mov	 rax, QWORD PTR ks$27729[rsp]
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	45 33 c9	 xor	 r9d, r9d
  00124	4c 8d 44 24 48	 lea	 r8, QWORD PTR dataUnitNo$27731[rsp]
  00129	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR len$[rsp]
  00131	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00139	e8 00 00 00 00	 call	 DecryptBufferXTS

; 1192 : 			}

  0013e	e9 72 ff ff ff	 jmp	 $LN7@DecryptBuf@5
$LN6@DecryptBuf@5:

; 1193 : 		}
; 1194 : 		break;

  00143	e9 1f 01 00 00	 jmp	 $LN10@DecryptBuf@5
$LN5@DecryptBuf@5:

; 1195 : 	case XTS8:
; 1196 : 	{
; 1197 : 				 unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize(cryptoInfo->ea);

  00148	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00150	8b 08		 mov	 ecx, DWORD PTR [rax]
  00152	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  00157	48 63 c8	 movsxd	 rcx, eax
  0015a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00162	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  00167	48 89 44 24 60	 mov	 QWORD PTR ks$27737[rsp], rax

; 1198 : 				 unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize(cryptoInfo->ea);

  0016c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00174	8b 08		 mov	 ecx, DWORD PTR [rax]
  00176	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  0017b	48 63 c8	 movsxd	 rcx, eax
  0017e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00186	48 8d 84 08 28
	02 00 00	 lea	 rax, QWORD PTR [rax+rcx+552]
  0018e	48 89 44 24 78	 mov	 QWORD PTR ks2$27738[rsp], rax

; 1199 : 				 UINT64_STRUCT dataUnitNo;
; 1200 : 				 int cipher;
; 1201 : 
; 1202 : 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1203 : 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1204 : 				 // always assumed to be aligned with the start of the data unit 0.
; 1205 : 				 dataUnitNo.LowPart = 0;

  00193	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR dataUnitNo$27739[rsp], 0

; 1206 : 				 dataUnitNo.HighPart = 0;

  0019b	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR dataUnitNo$27739[rsp+4], 0

; 1207 : 
; 1208 : 				 for (cipher = EAGetLastCipher(cryptoInfo->ea);
; 1209 : 					 cipher != 0;
; 1210 : 					 cipher = EAGetPreviousCipher(cryptoInfo->ea, cipher))

  001a3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  001ab	8b 08		 mov	 ecx, DWORD PTR [rax]
  001ad	e8 00 00 00 00	 call	 EAGetLastCipher
  001b2	89 44 24 70	 mov	 DWORD PTR cipher$27740[rsp], eax
  001b6	eb 17		 jmp	 SHORT $LN4@DecryptBuf@5
$LN3@DecryptBuf@5:
  001b8	8b 54 24 70	 mov	 edx, DWORD PTR cipher$27740[rsp]
  001bc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  001c4	8b 08		 mov	 ecx, DWORD PTR [rax]
  001c6	e8 00 00 00 00	 call	 EAGetPreviousCipher
  001cb	89 44 24 70	 mov	 DWORD PTR cipher$27740[rsp], eax
$LN4@DecryptBuf@5:
  001cf	83 7c 24 70 00	 cmp	 DWORD PTR cipher$27740[rsp], 0
  001d4	74 70		 je	 SHORT $LN2@DecryptBuf@5

; 1211 : 				 {
; 1212 : 					 ks -= CipherGetKeyScheduleSize(cipher);

  001d6	8b 4c 24 70	 mov	 ecx, DWORD PTR cipher$27740[rsp]
  001da	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  001df	48 63 c8	 movsxd	 rcx, eax
  001e2	48 8b 44 24 60	 mov	 rax, QWORD PTR ks$27737[rsp]
  001e7	48 2b c1	 sub	 rax, rcx
  001ea	48 89 44 24 60	 mov	 QWORD PTR ks$27737[rsp], rax

; 1213 : 					 ks2 -= CipherGetKeyScheduleSize(cipher);

  001ef	8b 4c 24 70	 mov	 ecx, DWORD PTR cipher$27740[rsp]
  001f3	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  001f8	48 63 c8	 movsxd	 rcx, eax
  001fb	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$27738[rsp]
  00200	48 2b c1	 sub	 rax, rcx
  00203	48 89 44 24 78	 mov	 QWORD PTR ks2$27738[rsp], rax

; 1214 : 
; 1215 : 					 DecryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00208	8b 44 24 70	 mov	 eax, DWORD PTR cipher$27740[rsp]
  0020c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00210	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$27738[rsp]
  00215	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0021a	48 8b 44 24 60	 mov	 rax, QWORD PTR ks$27737[rsp]
  0021f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00224	45 33 c9	 xor	 r9d, r9d
  00227	4c 8d 44 24 68	 lea	 r8, QWORD PTR dataUnitNo$27739[rsp]
  0022c	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR len$[rsp]
  00234	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0023c	e8 00 00 00 00	 call	 DecryptBufferXTS8Byte

; 1216 : 				 }

  00241	e9 72 ff ff ff	 jmp	 $LN3@DecryptBuf@5
$LN2@DecryptBuf@5:

; 1217 : 	}
; 1218 : 		break;

  00246	eb 1f		 jmp	 SHORT $LN10@DecryptBuf@5
$LN1@DecryptBuf@5:

; 1219 : 	default:		
; 1220 : 		// Unknown/wrong ID
; 1221 : 		GST_THROW_FATAL_EXCEPTION;

  00248	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00251	45 33 c9	 xor	 r9d, r9d
  00254	45 33 c0	 xor	 r8d, r8d
  00257	ba c5 04 00 00	 mov	 edx, 1221		; 000004c5H
  0025c	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN10@DecryptBuf@5:
$LN13@DecryptBuf@5:

; 1222 : 	}
; 1223 : }

  00267	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0026e	c3		 ret	 0
DecryptBuffer ENDP
_TEXT	ENDS
PUBLIC	EncryptDataUnitsCurrentThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptDataUnitsCurrentThread DD imagerel $LN14
	DD	imagerel $LN14+477
	DD	imagerel $unwind$EncryptDataUnitsCurrentThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptDataUnitsCurrentThread DD 011801H
	DD	0e218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptDataUnitsCurrentThread
_TEXT	SEGMENT
ea$ = 64
ks$ = 72
cipher$ = 80
ks2$ = 88
tv67 = 96
buf$ = 128
structUnitNo$ = 136
nbrUnits$ = 144
ci$ = 152
EncryptDataUnitsCurrentThread PROC			; COMDAT

; 1112 : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1113 : 	int ea = ci->ea;

  00018	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ci$[rsp]
  00020	8b 00		 mov	 eax, DWORD PTR [rax]
  00022	89 44 24 40	 mov	 DWORD PTR ea$[rsp], eax

; 1114 : 	unsigned __int8 *ks = ci->ks;

  00026	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ci$[rsp]
  0002e	48 83 c0 08	 add	 rax, 8
  00032	48 89 44 24 48	 mov	 QWORD PTR ks$[rsp], rax

; 1115 : 	unsigned __int8 *ks2 = ci->ks2;

  00037	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ci$[rsp]
  0003f	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00045	48 89 44 24 58	 mov	 QWORD PTR ks2$[rsp], rax

; 1116 : 	int cipher;
; 1117 : 
; 1118 : 	switch (ci->mode)

  0004a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ci$[rsp]
  00052	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00055	89 44 24 60	 mov	 DWORD PTR tv67[rsp], eax
  00059	83 7c 24 60 01	 cmp	 DWORD PTR tv67[rsp], 1
  0005e	74 10		 je	 SHORT $LN9@EncryptDat
  00060	83 7c 24 60 02	 cmp	 DWORD PTR tv67[rsp], 2
  00065	0f 84 ab 00 00
	00		 je	 $LN5@EncryptDat
  0006b	e9 49 01 00 00	 jmp	 $LN1@EncryptDat
$LN9@EncryptDat:

; 1119 : 	{
; 1120 : 	case XTS:
; 1121 : 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  00070	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  00074	e8 00 00 00 00	 call	 EAGetFirstCipher
  00079	89 44 24 50	 mov	 DWORD PTR cipher$[rsp], eax
  0007d	eb 11		 jmp	 SHORT $LN8@EncryptDat
$LN7@EncryptDat:
  0007f	8b 54 24 50	 mov	 edx, DWORD PTR cipher$[rsp]
  00083	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  00087	e8 00 00 00 00	 call	 EAGetNextCipher
  0008c	89 44 24 50	 mov	 DWORD PTR cipher$[rsp], eax
$LN8@EncryptDat:
  00090	83 7c 24 50 00	 cmp	 DWORD PTR cipher$[rsp], 0
  00095	74 7a		 je	 SHORT $LN6@EncryptDat

; 1122 : 		{
; 1123 : 			EncryptBufferXTS (buf,
; 1124 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1125 : 				structUnitNo,
; 1126 : 				0,
; 1127 : 				ks,
; 1128 : 				ks2,
; 1129 : 				cipher);

  00097	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR nbrUnits$[rsp]
  0009f	48 69 d2 00 02
	00 00		 imul	 rdx, 512		; 00000200H
  000a6	8b 44 24 50	 mov	 eax, DWORD PTR cipher$[rsp]
  000aa	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000ae	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$[rsp]
  000b3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b8	48 8b 44 24 48	 mov	 rax, QWORD PTR ks$[rsp]
  000bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c2	45 33 c9	 xor	 r9d, r9d
  000c5	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR structUnitNo$[rsp]
  000cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000d5	e8 00 00 00 00	 call	 EncryptBufferXTS

; 1130 : 
; 1131 : 			ks += CipherGetKeyScheduleSize (cipher);

  000da	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$[rsp]
  000de	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  000e3	48 63 c8	 movsxd	 rcx, eax
  000e6	48 8b 44 24 48	 mov	 rax, QWORD PTR ks$[rsp]
  000eb	48 03 c1	 add	 rax, rcx
  000ee	48 89 44 24 48	 mov	 QWORD PTR ks$[rsp], rax

; 1132 : 			ks2 += CipherGetKeyScheduleSize (cipher);

  000f3	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$[rsp]
  000f7	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  000fc	48 63 c8	 movsxd	 rcx, eax
  000ff	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$[rsp]
  00104	48 03 c1	 add	 rax, rcx
  00107	48 89 44 24 58	 mov	 QWORD PTR ks2$[rsp], rax

; 1133 : 		}

  0010c	e9 6e ff ff ff	 jmp	 $LN7@EncryptDat
$LN6@EncryptDat:

; 1134 : 		break;

  00111	e9 c2 00 00 00	 jmp	 $LN10@EncryptDat
$LN5@EncryptDat:

; 1135 : 	case XTS8:
; 1136 : 		for (cipher = EAGetFirstCipher(ea); cipher != 0; cipher = EAGetNextCipher(ea, cipher))

  00116	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  0011a	e8 00 00 00 00	 call	 EAGetFirstCipher
  0011f	89 44 24 50	 mov	 DWORD PTR cipher$[rsp], eax
  00123	eb 11		 jmp	 SHORT $LN4@EncryptDat
$LN3@EncryptDat:
  00125	8b 54 24 50	 mov	 edx, DWORD PTR cipher$[rsp]
  00129	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  0012d	e8 00 00 00 00	 call	 EAGetNextCipher
  00132	89 44 24 50	 mov	 DWORD PTR cipher$[rsp], eax
$LN4@EncryptDat:
  00136	83 7c 24 50 00	 cmp	 DWORD PTR cipher$[rsp], 0
  0013b	74 7a		 je	 SHORT $LN2@EncryptDat

; 1137 : 		{
; 1138 : 			EncryptBufferXTS8Byte(buf,
; 1139 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1140 : 				structUnitNo,
; 1141 : 				0,
; 1142 : 				ks,
; 1143 : 				ks2,
; 1144 : 				cipher);

  0013d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR nbrUnits$[rsp]
  00145	48 69 d2 00 02
	00 00		 imul	 rdx, 512		; 00000200H
  0014c	8b 44 24 50	 mov	 eax, DWORD PTR cipher$[rsp]
  00150	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00154	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$[rsp]
  00159	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0015e	48 8b 44 24 48	 mov	 rax, QWORD PTR ks$[rsp]
  00163	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00168	45 33 c9	 xor	 r9d, r9d
  0016b	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR structUnitNo$[rsp]
  00173	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0017b	e8 00 00 00 00	 call	 EncryptBufferXTS8Byte

; 1145 : 
; 1146 : 			ks += CipherGetKeyScheduleSize(cipher);

  00180	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$[rsp]
  00184	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  00189	48 63 c8	 movsxd	 rcx, eax
  0018c	48 8b 44 24 48	 mov	 rax, QWORD PTR ks$[rsp]
  00191	48 03 c1	 add	 rax, rcx
  00194	48 89 44 24 48	 mov	 QWORD PTR ks$[rsp], rax

; 1147 : 			ks2 += CipherGetKeyScheduleSize(cipher);

  00199	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$[rsp]
  0019d	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  001a2	48 63 c8	 movsxd	 rcx, eax
  001a5	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$[rsp]
  001aa	48 03 c1	 add	 rax, rcx
  001ad	48 89 44 24 58	 mov	 QWORD PTR ks2$[rsp], rax

; 1148 : 		}

  001b2	e9 6e ff ff ff	 jmp	 $LN3@EncryptDat
$LN2@EncryptDat:

; 1149 : 		break;

  001b7	eb 1f		 jmp	 SHORT $LN10@EncryptDat
$LN1@EncryptDat:

; 1150 : 	default:		
; 1151 : 		// Unknown/wrong ID
; 1152 : 		GST_THROW_FATAL_EXCEPTION;

  001b9	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  001c2	45 33 c9	 xor	 r9d, r9d
  001c5	45 33 c0	 xor	 r8d, r8d
  001c8	ba 80 04 00 00	 mov	 edx, 1152		; 00000480H
  001cd	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN10@EncryptDat:
$LN13@EncryptDat:

; 1153 : 	}
; 1154 : }

  001d8	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001dc	c3		 ret	 0
EncryptDataUnitsCurrentThread ENDP
_TEXT	ENDS
PUBLIC	EncryptBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBuffer DD imagerel $LN14
	DD	imagerel $LN14+545
	DD	imagerel $unwind$EncryptBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBuffer DD 021601H
	DD	0130116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptBuffer
_TEXT	SEGMENT
ks$27664 = 64
dataUnitNo$27666 = 72
cipher$27667 = 80
ks2$27665 = 88
ks$27672 = 96
dataUnitNo$27674 = 104
cipher$27675 = 112
ks2$27673 = 120
tv65 = 128
buf$ = 160
len$ = 168
cryptoInfo$ = 176
EncryptBuffer PROC					; COMDAT

; 1023 : {

$LN14:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1024 : 	switch (cryptoInfo->mode)

  00016	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00021	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00028	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR tv65[rsp], 1
  00030	74 13		 je	 SHORT $LN9@EncryptBuf@5
  00032	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR tv65[rsp], 2
  0003a	0f 84 e1 00 00
	00		 je	 $LN5@EncryptBuf@5
  00040	e9 b5 01 00 00	 jmp	 $LN1@EncryptBuf@5
$LN9@EncryptBuf@5:

; 1025 : 	{
; 1026 : 	case XTS:
; 1027 : 		{
; 1028 : 			unsigned __int8 *ks = cryptoInfo->ks;

  00045	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0004d	48 83 c0 08	 add	 rax, 8
  00051	48 89 44 24 40	 mov	 QWORD PTR ks$27664[rsp], rax

; 1029 : 			unsigned __int8 *ks2 = cryptoInfo->ks2;

  00056	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0005e	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00064	48 89 44 24 58	 mov	 QWORD PTR ks2$27665[rsp], rax

; 1030 : 			UINT64_STRUCT dataUnitNo;
; 1031 : 			int cipher;
; 1032 : 
; 1033 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1034 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1035 : 			// always assumed to be aligned with the start of a data unit.
; 1036 : 			dataUnitNo.LowPart = 0;

  00069	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR dataUnitNo$27666[rsp], 0

; 1037 : 			dataUnitNo.HighPart = 0;

  00071	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR dataUnitNo$27666[rsp+4], 0

; 1038 : 
; 1039 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1040 : 				cipher != 0;
; 1041 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  00079	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00081	8b 08		 mov	 ecx, DWORD PTR [rax]
  00083	e8 00 00 00 00	 call	 EAGetFirstCipher
  00088	89 44 24 50	 mov	 DWORD PTR cipher$27667[rsp], eax
  0008c	eb 17		 jmp	 SHORT $LN8@EncryptBuf@5
$LN7@EncryptBuf@5:
  0008e	8b 54 24 50	 mov	 edx, DWORD PTR cipher$27667[rsp]
  00092	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0009a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0009c	e8 00 00 00 00	 call	 EAGetNextCipher
  000a1	89 44 24 50	 mov	 DWORD PTR cipher$27667[rsp], eax
$LN8@EncryptBuf@5:
  000a5	83 7c 24 50 00	 cmp	 DWORD PTR cipher$27667[rsp], 0
  000aa	74 70		 je	 SHORT $LN6@EncryptBuf@5

; 1042 : 			{
; 1043 : 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  000ac	8b 44 24 50	 mov	 eax, DWORD PTR cipher$27667[rsp]
  000b0	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000b4	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$27665[rsp]
  000b9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000be	48 8b 44 24 40	 mov	 rax, QWORD PTR ks$27664[rsp]
  000c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c8	45 33 c9	 xor	 r9d, r9d
  000cb	4c 8d 44 24 48	 lea	 r8, QWORD PTR dataUnitNo$27666[rsp]
  000d0	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR len$[rsp]
  000d8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000e0	e8 00 00 00 00	 call	 EncryptBufferXTS

; 1044 : 
; 1045 : 				ks += CipherGetKeyScheduleSize (cipher);

  000e5	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$27667[rsp]
  000e9	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  000ee	48 63 c8	 movsxd	 rcx, eax
  000f1	48 8b 44 24 40	 mov	 rax, QWORD PTR ks$27664[rsp]
  000f6	48 03 c1	 add	 rax, rcx
  000f9	48 89 44 24 40	 mov	 QWORD PTR ks$27664[rsp], rax

; 1046 : 				ks2 += CipherGetKeyScheduleSize (cipher);

  000fe	8b 4c 24 50	 mov	 ecx, DWORD PTR cipher$27667[rsp]
  00102	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  00107	48 63 c8	 movsxd	 rcx, eax
  0010a	48 8b 44 24 58	 mov	 rax, QWORD PTR ks2$27665[rsp]
  0010f	48 03 c1	 add	 rax, rcx
  00112	48 89 44 24 58	 mov	 QWORD PTR ks2$27665[rsp], rax

; 1047 : 			}

  00117	e9 72 ff ff ff	 jmp	 $LN7@EncryptBuf@5
$LN6@EncryptBuf@5:

; 1048 : 		}
; 1049 : 		break;

  0011c	e9 f8 00 00 00	 jmp	 $LN10@EncryptBuf@5
$LN5@EncryptBuf@5:

; 1050 : 	case XTS8:
; 1051 : 		{
; 1052 : 				 unsigned __int8 *ks = cryptoInfo->ks;

  00121	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00129	48 83 c0 08	 add	 rax, 8
  0012d	48 89 44 24 60	 mov	 QWORD PTR ks$27672[rsp], rax

; 1053 : 				 unsigned __int8 *ks2 = cryptoInfo->ks2;

  00132	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0013a	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00140	48 89 44 24 78	 mov	 QWORD PTR ks2$27673[rsp], rax

; 1054 : 				 UINT64_STRUCT dataUnitNo;
; 1055 : 				 int cipher;
; 1056 : 
; 1057 : 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1058 : 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1059 : 				 // always assumed to be aligned with the start of a data unit.
; 1060 : 				 dataUnitNo.LowPart = 0;

  00145	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR dataUnitNo$27674[rsp], 0

; 1061 : 				 dataUnitNo.HighPart = 0;

  0014d	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR dataUnitNo$27674[rsp+4], 0

; 1062 : 
; 1063 : 				 for (cipher = EAGetFirstCipher(cryptoInfo->ea);
; 1064 : 					 cipher != 0;
; 1065 : 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))

  00155	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0015d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0015f	e8 00 00 00 00	 call	 EAGetFirstCipher
  00164	89 44 24 70	 mov	 DWORD PTR cipher$27675[rsp], eax
  00168	eb 17		 jmp	 SHORT $LN4@EncryptBuf@5
$LN3@EncryptBuf@5:
  0016a	8b 54 24 70	 mov	 edx, DWORD PTR cipher$27675[rsp]
  0016e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00176	8b 08		 mov	 ecx, DWORD PTR [rax]
  00178	e8 00 00 00 00	 call	 EAGetNextCipher
  0017d	89 44 24 70	 mov	 DWORD PTR cipher$27675[rsp], eax
$LN4@EncryptBuf@5:
  00181	83 7c 24 70 00	 cmp	 DWORD PTR cipher$27675[rsp], 0
  00186	74 70		 je	 SHORT $LN2@EncryptBuf@5

; 1066 : 				 {
; 1067 : 					 EncryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00188	8b 44 24 70	 mov	 eax, DWORD PTR cipher$27675[rsp]
  0018c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00190	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$27673[rsp]
  00195	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0019a	48 8b 44 24 60	 mov	 rax, QWORD PTR ks$27672[rsp]
  0019f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a4	45 33 c9	 xor	 r9d, r9d
  001a7	4c 8d 44 24 68	 lea	 r8, QWORD PTR dataUnitNo$27674[rsp]
  001ac	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR len$[rsp]
  001b4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  001bc	e8 00 00 00 00	 call	 EncryptBufferXTS8Byte

; 1068 : 
; 1069 : 					 ks += CipherGetKeyScheduleSize(cipher);

  001c1	8b 4c 24 70	 mov	 ecx, DWORD PTR cipher$27675[rsp]
  001c5	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  001ca	48 63 c8	 movsxd	 rcx, eax
  001cd	48 8b 44 24 60	 mov	 rax, QWORD PTR ks$27672[rsp]
  001d2	48 03 c1	 add	 rax, rcx
  001d5	48 89 44 24 60	 mov	 QWORD PTR ks$27672[rsp], rax

; 1070 : 					 ks2 += CipherGetKeyScheduleSize(cipher);

  001da	8b 4c 24 70	 mov	 ecx, DWORD PTR cipher$27675[rsp]
  001de	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  001e3	48 63 c8	 movsxd	 rcx, eax
  001e6	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$27673[rsp]
  001eb	48 03 c1	 add	 rax, rcx
  001ee	48 89 44 24 78	 mov	 QWORD PTR ks2$27673[rsp], rax

; 1071 : 				 }

  001f3	e9 72 ff ff ff	 jmp	 $LN3@EncryptBuf@5
$LN2@EncryptBuf@5:

; 1072 : 		}
; 1073 : 		break;

  001f8	eb 1f		 jmp	 SHORT $LN10@EncryptBuf@5
$LN1@EncryptBuf@5:

; 1074 : 
; 1075 : 	default:		
; 1076 : 		// Unknown/wrong ID
; 1077 : 		GST_THROW_FATAL_EXCEPTION;

  001fa	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00203	45 33 c9	 xor	 r9d, r9d
  00206	45 33 c0	 xor	 r8d, r8d
  00209	ba 35 04 00 00	 mov	 edx, 1077		; 00000435H
  0020e	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN10@EncryptBuf@5:
$LN13@EncryptBuf@5:

; 1078 : 	}
; 1079 : }

  00219	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00220	c3		 ret	 0
EncryptBuffer ENDP
_TEXT	ENDS
PUBLIC	EAInit
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAInit DD imagerel $LN11
	DD	imagerel $LN11+200
	DD	imagerel $unwind$EAInit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAInit DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAInit
_TEXT	SEGMENT
retVal$ = 32
c$ = 36
tv75 = 40
ea$ = 64
key$ = 72
ks$ = 80
EAInit	PROC						; COMDAT

; 404  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 405  : 	int c, retVal = ERR_SUCCESS;

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR retVal$[rsp], 0

; 406  : 
; 407  : 	if (ea == 0)

  0001a	83 7c 24 40 00	 cmp	 DWORD PTR ea$[rsp], 0
  0001f	75 0a		 jne	 SHORT $LN8@EAInit

; 408  : 		return ERR_CIPHER_INIT_FAILURE;

  00021	b8 11 00 00 00	 mov	 eax, 17
  00026	e9 98 00 00 00	 jmp	 $LN9@EAInit
$LN8@EAInit:

; 409  : 
; 410  : 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))

  0002b	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  0002f	e8 00 00 00 00	 call	 EAGetFirstCipher
  00034	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax
  00038	eb 11		 jmp	 SHORT $LN7@EAInit
$LN6@EAInit:
  0003a	8b 54 24 24	 mov	 edx, DWORD PTR c$[rsp]
  0003e	8b 4c 24 40	 mov	 ecx, DWORD PTR ea$[rsp]
  00042	e8 00 00 00 00	 call	 EAGetNextCipher
  00047	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax
$LN7@EAInit:
  0004b	83 7c 24 24 00	 cmp	 DWORD PTR c$[rsp], 0
  00050	74 6d		 je	 SHORT $LN5@EAInit

; 411  : 	{
; 412  : 		switch (CipherInit (c, key, ks))

  00052	4c 8b 44 24 50	 mov	 r8, QWORD PTR ks$[rsp]
  00057	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  0005c	8b 4c 24 24	 mov	 ecx, DWORD PTR c$[rsp]
  00060	e8 00 00 00 00	 call	 CipherInit
  00065	89 44 24 28	 mov	 DWORD PTR tv75[rsp], eax
  00069	83 7c 24 28 11	 cmp	 DWORD PTR tv75[rsp], 17
  0006e	74 09		 je	 SHORT $LN2@EAInit
  00070	83 7c 24 28 12	 cmp	 DWORD PTR tv75[rsp], 18
  00075	74 09		 je	 SHORT $LN1@EAInit
  00077	eb 0f		 jmp	 SHORT $LN3@EAInit
$LN2@EAInit:

; 413  : 		{
; 414  : 		case ERR_CIPHER_INIT_FAILURE:
; 415  : 			return ERR_CIPHER_INIT_FAILURE;

  00079	b8 11 00 00 00	 mov	 eax, 17
  0007e	eb 43		 jmp	 SHORT $LN9@EAInit
$LN1@EAInit:

; 416  : 
; 417  : 		case ERR_CIPHER_INIT_WEAK_KEY:
; 418  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  00080	c7 44 24 20 12
	00 00 00	 mov	 DWORD PTR retVal$[rsp], 18
$LN3@EAInit:

; 419  : 			break;
; 420  : 		}
; 421  : 
; 422  : 		key += CipherGetKeySize (c);

  00088	8b 4c 24 24	 mov	 ecx, DWORD PTR c$[rsp]
  0008c	e8 00 00 00 00	 call	 CipherGetKeySize
  00091	48 63 c8	 movsxd	 rcx, eax
  00094	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  00099	48 03 c1	 add	 rax, rcx
  0009c	48 89 44 24 48	 mov	 QWORD PTR key$[rsp], rax

; 423  : 		ks += CipherGetKeyScheduleSize (c);

  000a1	8b 4c 24 24	 mov	 ecx, DWORD PTR c$[rsp]
  000a5	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  000aa	48 63 c8	 movsxd	 rcx, eax
  000ad	48 8b 44 24 50	 mov	 rax, QWORD PTR ks$[rsp]
  000b2	48 03 c1	 add	 rax, rcx
  000b5	48 89 44 24 50	 mov	 QWORD PTR ks$[rsp], rax

; 424  : 	}

  000ba	e9 7b ff ff ff	 jmp	 $LN6@EAInit
$LN5@EAInit:

; 425  : 	return retVal;

  000bf	8b 44 24 20	 mov	 eax, DWORD PTR retVal$[rsp]
$LN9@EAInit:

; 426  : }

  000c3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c7	c3		 ret	 0
EAInit	ENDP
PUBLIC	DecryptDataUnits
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptDataUnits DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$DecryptDataUnits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptDataUnits DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecryptDataUnits
_TEXT	SEGMENT
buf$ = 64
structUnitNo$ = 72
nbrUnits$ = 80
ci$ = 88
DecryptDataUnits PROC					; COMDAT

; 1240 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1241 : 	EncryptionThreadPoolDoWork (DecryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR ci$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	44 8b 4c 24 50	 mov	 r9d, DWORD PTR nbrUnits$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR structUnitNo$[rsp]
  0002c	48 8b 54 24 40	 mov	 rdx, QWORD PTR buf$[rsp]
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 1242 : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
DecryptDataUnits ENDP
_TEXT	ENDS
PUBLIC	EncryptDataUnits
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptDataUnits DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$EncryptDataUnits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptDataUnits DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptDataUnits
_TEXT	SEGMENT
buf$ = 64
structUnitNo$ = 72
nbrUnits$ = 80
ci$ = 88
EncryptDataUnits PROC					; COMDAT

; 1096 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1097 : 	EncryptionThreadPoolDoWork (EncryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR ci$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	44 8b 4c 24 50	 mov	 r9d, DWORD PTR nbrUnits$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR structUnitNo$[rsp]
  0002c	48 8b 54 24 40	 mov	 rdx, QWORD PTR buf$[rsp]
  00031	33 c9		 xor	 ecx, ecx
  00033	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 1098 : }

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	c3		 ret	 0
EncryptDataUnits ENDP
_TEXT	ENDS
PUBLIC	EAInitMode
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAInitMode DD imagerel $LN10
	DD	imagerel $LN10+170
	DD	imagerel $unwind$EAInitMode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAInitMode DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EAInitMode
_TEXT	SEGMENT
tv65 = 48
ci$ = 80
EAInitMode PROC						; COMDAT

; 440  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 441  : 	switch (ci->mode)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR ci$[rsp]
  0000e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00011	89 44 24 30	 mov	 DWORD PTR tv65[rsp], eax
  00015	83 7c 24 30 01	 cmp	 DWORD PTR tv65[rsp], 1
  0001a	74 09		 je	 SHORT $LN5@EAInitMode
  0001c	83 7c 24 30 02	 cmp	 DWORD PTR tv65[rsp], 2
  00021	74 30		 je	 SHORT $LN3@EAInitMode
  00023	eb 5c		 jmp	 SHORT $LN1@EAInitMode
$LN5@EAInitMode:

; 442  : 	{
; 443  : 	case XTS:
; 444  : 		// Secondary key schedule
; 445  : 		if (EAInit (ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)

  00025	4c 8b 44 24 50	 mov	 r8, QWORD PTR ci$[rsp]
  0002a	49 81 c0 28 02
	00 00		 add	 r8, 552			; 00000228H
  00031	48 8b 54 24 50	 mov	 rdx, QWORD PTR ci$[rsp]
  00036	48 81 c2 50 1d
	00 00		 add	 rdx, 7504		; 00001d50H
  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR ci$[rsp]
  00042	8b 08		 mov	 ecx, DWORD PTR [rax]
  00044	e8 00 00 00 00	 call	 EAInit
  00049	85 c0		 test	 eax, eax
  0004b	74 04		 je	 SHORT $LN4@EAInitMode

; 446  : 			return FALSE;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 54		 jmp	 SHORT $LN8@EAInitMode
$LN4@EAInitMode:

; 447  : 
; 448  : 		/* Note: XTS mode could potentially be initialized with a weak key causing all blocks in one data unit
; 449  : 		on the volume to be tweaked with zero tweaks (i.e. 512 bytes of the volume would be encrypted in ECB
; 450  : 		mode). However, to create a GostCrypt volume with such a weak key, each human being on Earth would have
; 451  : 		to create approximately 11,378,125,361,078,862 (about eleven quadrillion) GostCrypt volumes (provided 
; 452  : 		that the size of each of the volumes is 1024 terabytes). */
; 453  : 		break;

  00051	eb 4d		 jmp	 SHORT $LN6@EAInitMode
$LN3@EAInitMode:

; 454  : 	case XTS8:
; 455  : 		if (EAInit(ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)

  00053	4c 8b 44 24 50	 mov	 r8, QWORD PTR ci$[rsp]
  00058	49 81 c0 28 02
	00 00		 add	 r8, 552			; 00000228H
  0005f	48 8b 54 24 50	 mov	 rdx, QWORD PTR ci$[rsp]
  00064	48 81 c2 50 1d
	00 00		 add	 rdx, 7504		; 00001d50H
  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR ci$[rsp]
  00070	8b 08		 mov	 ecx, DWORD PTR [rax]
  00072	e8 00 00 00 00	 call	 EAInit
  00077	85 c0		 test	 eax, eax
  00079	74 04		 je	 SHORT $LN2@EAInitMode

; 456  : 			return FALSE;

  0007b	33 c0		 xor	 eax, eax
  0007d	eb 26		 jmp	 SHORT $LN8@EAInitMode
$LN2@EAInitMode:

; 457  : 		break;

  0007f	eb 1f		 jmp	 SHORT $LN6@EAInitMode
$LN1@EAInitMode:

; 458  : 
; 459  : 	default:		
; 460  : 		// Unknown/wrong ID
; 461  : 		GST_THROW_FATAL_EXCEPTION;

  00081	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0008a	45 33 c9	 xor	 r9d, r9d
  0008d	45 33 c0	 xor	 r8d, r8d
  00090	ba cd 01 00 00	 mov	 edx, 461		; 000001cdH
  00095	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN6@EAInitMode:

; 462  : 	}
; 463  : 	return TRUE;

  000a0	b8 01 00 00 00	 mov	 eax, 1
$LN8@EAInitMode:
$LN9@EAInitMode:

; 464  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
EAInitMode ENDP
END
