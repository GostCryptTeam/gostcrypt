; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xts.c
pdata	SEGMENT
$pdata$DecryptBufferXTSNonParallel DD imagerel DecryptBufferXTSNonParallel
	DD	imagerel DecryptBufferXTSNonParallel+1001
	DD	imagerel $unwind$DecryptBufferXTSNonParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTSNonParallel DD 022d19H
	DD	017011bH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecryptBufferXTSNonParallel
_TEXT	SEGMENT
endBlock$ = 48
bufPtr$ = 56
blockCount$ = 64
whiteningValuePtr64$ = 72
byteBufUnitNo$ = 88
whiteningValue$ = 104
finalCarry$ = 120
dataUnitNo$ = 128
block$ = 136
startBlock$ = 140
burnc$27576 = 144
burnm$27574 = 152
tv132 = 160
__$ArrayPad$ = 168
buffer$ = 192
length$ = 200
startDataUnitNo$ = 208
startCipherBlockNo$ = 216
ks$ = 224
ks2$ = 232
cipher$ = 240
DecryptBufferXTSNonParallel PROC			; COMDAT

; 677  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 678  : 	unsigned __int8 finalCarry;
; 679  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 680  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 681  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0002d	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00032	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 682  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  00037	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0003f	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 683  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00044	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR startCipherBlockNo$[rsp]
  0004b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR startBlock$[rsp], eax

; 684  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 685  : 
; 686  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 687  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 688  : 	dataUnitNo = startDataUnitNo->Value;

  00052	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR startDataUnitNo$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 689  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00065	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  0006d	48 89 44 24 58	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 690  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  00072	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp+8], 0

; 691  : 
; 692  : 	if (length % BYTES_PER_XTS_BLOCK)

  0007b	33 d2		 xor	 edx, edx
  0007d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR length$[rsp]
  00085	b9 10 00 00 00	 mov	 ecx, 16
  0008a	48 f7 f1	 div	 rcx
  0008d	48 85 d2	 test	 rdx, rdx
  00090	74 1f		 je	 SHORT $LN16@DecryptBuf

; 693  : 		GST_THROW_FATAL_EXCEPTION;

  00092	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0009b	45 33 c9	 xor	 r9d, r9d
  0009e	45 33 c0	 xor	 r8d, r8d
  000a1	ba b5 02 00 00	 mov	 edx, 693		; 000002b5H
  000a6	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN16@DecryptBuf:

; 694  : 
; 695  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000b1	33 d2		 xor	 edx, edx
  000b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000bb	b9 10 00 00 00	 mov	 ecx, 16
  000c0	48 f7 f1	 div	 rcx
  000c3	48 89 44 24 40	 mov	 QWORD PTR blockCount$[rsp], rax
$LN15@DecryptBuf:

; 696  : 
; 697  : 	// Process all blocks in the buffer
; 698  : 	while (blockCount > 0)

  000c8	48 83 7c 24 40
	00		 cmp	 QWORD PTR blockCount$[rsp], 0
  000ce	0f 86 9e 02 00
	00		 jbe	 $LN14@DecryptBuf

; 699  : 	{
; 700  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  000d4	48 83 7c 24 40
	20		 cmp	 QWORD PTR blockCount$[rsp], 32 ; 00000020H
  000da	73 13		 jae	 SHORT $LN13@DecryptBuf

; 701  : 			endBlock = startBlock + (unsigned int) blockCount;

  000dc	8b 4c 24 40	 mov	 ecx, DWORD PTR blockCount$[rsp]
  000e0	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  000e7	03 c1		 add	 eax, ecx
  000e9	89 44 24 30	 mov	 DWORD PTR endBlock$[rsp], eax

; 702  : 		else

  000ed	eb 08		 jmp	 SHORT $LN12@DecryptBuf
$LN13@DecryptBuf:

; 703  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000ef	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR endBlock$[rsp], 32 ; 00000020H
$LN12@DecryptBuf:

; 704  : 
; 705  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  000f7	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  000fc	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 706  : 
; 707  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 708  : 		// whitening value for this data unit)
; 709  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  00101	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR byteBufUnitNo$[rsp]
  0010b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 710  : 		*(whiteningValuePtr64 + 1) = 0;

  0010e	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00113	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 711  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0011b	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR ks2$[rsp]
  00123	48 8d 54 24 68	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00128	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0012f	e8 00 00 00 00	 call	 EncipherBlock

; 712  : 
; 713  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 714  : 		// decrypt all relevant blocks in this data unit
; 715  : 		for (block = 0; block < endBlock; block++)

  00134	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR block$[rsp], 0
  0013f	eb 11		 jmp	 SHORT $LN11@DecryptBuf
$LN10@DecryptBuf:
  00141	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00148	83 c0 01	 add	 eax, 1
  0014b	89 84 24 88 00
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN11@DecryptBuf:
  00152	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00156	39 84 24 88 00
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  0015d	0f 83 c2 01 00
	00		 jae	 $LN9@DecryptBuf

; 716  : 		{
; 717  : 			if (block >= startBlock)

  00163	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  0016a	39 84 24 88 00
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  00171	0f 82 e9 00 00
	00		 jb	 $LN8@DecryptBuf

; 718  : 			{
; 719  : 				// Post-whitening
; 720  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00177	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0017c	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00181	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00184	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00187	48 33 c8	 xor	 rcx, rax
  0018a	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0018f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00192	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00197	48 83 c0 08	 add	 rax, 8
  0019b	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  001a0	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001a5	48 83 c0 08	 add	 rax, 8
  001a9	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 721  : 				*bufPtr-- ^= *whiteningValuePtr64--;

  001ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  001b3	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001bb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001be	48 33 c8	 xor	 rcx, rax
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001c6	48 89 08	 mov	 QWORD PTR [rax], rcx
  001c9	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001ce	48 83 e8 08	 sub	 rax, 8
  001d2	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  001d7	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001dc	48 83 e8 08	 sub	 rax, 8
  001e0	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 722  : 
; 723  : 				// Actual decryption
; 724  : 				DecipherBlock (cipher, bufPtr, ks);

  001e5	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR ks$[rsp]
  001ed	48 8b 54 24 38	 mov	 rdx, QWORD PTR bufPtr$[rsp]
  001f2	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  001f9	e8 00 00 00 00	 call	 DecipherBlock

; 725  : 
; 726  : 				// Pre-whitening
; 727  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  001fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  00203	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00208	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0020e	48 33 c8	 xor	 rcx, rax
  00211	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00216	48 89 08	 mov	 QWORD PTR [rax], rcx
  00219	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0021e	48 83 c0 08	 add	 rax, 8
  00222	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  00227	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0022c	48 83 c0 08	 add	 rax, 8
  00230	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 728  : 				*bufPtr++ ^= *whiteningValuePtr64;

  00235	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0023a	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0023f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00242	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00245	48 33 c8	 xor	 rcx, rax
  00248	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0024d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00250	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00255	48 83 c0 08	 add	 rax, 8
  00259	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 729  : 			}
; 730  : 			else

  0025e	eb 0e		 jmp	 SHORT $LN7@DecryptBuf
$LN8@DecryptBuf:

; 731  : 				whiteningValuePtr64++;

  00260	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00265	48 83 c0 08	 add	 rax, 8
  00269	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
$LN7@DecryptBuf:

; 732  : 
; 733  : 			// Derive the next whitening value
; 734  : 
; 735  : #if BYTE_ORDER == LITTLE_ENDIAN
; 736  : 
; 737  : 			// Little-endian platforms
; 738  : 
; 739  : 			finalCarry = 
; 740  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 741  : 				135 : 0;

  0026e	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00273	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0027d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00280	48 23 c1	 and	 rax, rcx
  00283	48 85 c0	 test	 rax, rax
  00286	74 0d		 je	 SHORT $LN19@DecryptBuf
  00288	c7 84 24 a0 00
	00 00 87 00 00
	00		 mov	 DWORD PTR tv132[rsp], 135 ; 00000087H
  00293	eb 0b		 jmp	 SHORT $LN20@DecryptBuf
$LN19@DecryptBuf:
  00295	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
$LN20@DecryptBuf:
  002a0	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR tv132[rsp]
  002a8	88 44 24 78	 mov	 BYTE PTR finalCarry$[rsp], al

; 742  : 
; 743  : 			*whiteningValuePtr64-- <<= 1;

  002ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002b1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002b4	48 d1 e1	 shl	 rcx, 1
  002b7	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002bc	48 89 08	 mov	 QWORD PTR [rax], rcx
  002bf	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002c4	48 83 e8 08	 sub	 rax, 8
  002c8	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 744  : 
; 745  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002cd	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002d2	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002df	48 23 c1	 and	 rax, rcx
  002e2	48 85 c0	 test	 rax, rax
  002e5	74 16		 je	 SHORT $LN6@DecryptBuf

; 746  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002e7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002ec	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  002f0	48 83 c9 01	 or	 rcx, 1
  002f4	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002f9	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN6@DecryptBuf:

; 747  : 
; 748  : 			*whiteningValuePtr64 <<= 1;

  002fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00302	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00305	48 d1 e1	 shl	 rcx, 1
  00308	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0030d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 749  : 
; 750  : #else
; 751  : 			// Big-endian platforms
; 752  : 
; 753  : 			finalCarry = 
; 754  : 				(*whiteningValuePtr64 & 0x80) ?
; 755  : 				135 : 0;
; 756  : 
; 757  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 758  : 
; 759  : 			whiteningValuePtr64--;
; 760  : 
; 761  : 			if (*whiteningValuePtr64 & 0x80)
; 762  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 763  : 
; 764  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 765  : #endif
; 766  : 
; 767  : 			whiteningValue[0] ^= finalCarry;

  00310	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR finalCarry$[rsp]
  00315	0f b6 44 24 68	 movzx	 eax, BYTE PTR whiteningValue$[rsp]
  0031a	33 c1		 xor	 eax, ecx
  0031c	88 44 24 68	 mov	 BYTE PTR whiteningValue$[rsp], al

; 768  : 		}

  00320	e9 1c fe ff ff	 jmp	 $LN10@DecryptBuf
$LN9@DecryptBuf:

; 769  : 
; 770  : 		blockCount -= endBlock - startBlock;

  00325	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  0032c	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00330	2b c1		 sub	 eax, ecx
  00332	8b c8		 mov	 ecx, eax
  00334	48 8b 44 24 40	 mov	 rax, QWORD PTR blockCount$[rsp]
  00339	48 2b c1	 sub	 rax, rcx
  0033c	48 89 44 24 40	 mov	 QWORD PTR blockCount$[rsp], rax

; 771  : 		startBlock = 0;

  00341	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR startBlock$[rsp], 0

; 772  : 		dataUnitNo++;

  0034c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00354	48 83 c0 01	 add	 rax, 1
  00358	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 773  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00360	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00368	48 89 44 24 58	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 774  : 	}

  0036d	e9 56 fd ff ff	 jmp	 $LN15@DecryptBuf
$LN14@DecryptBuf:
$LN5@DecryptBuf:

; 775  : 
; 776  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00372	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00377	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR burnm$27574[rsp], rax
  0037f	c7 84 24 90 00
	00 00 02 00 00
	00		 mov	 DWORD PTR burnc$27576[rsp], 2
$LN2@DecryptBuf:
  0038a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR burnc$27576[rsp]
  00391	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR burnc$27576[rsp]
  00398	83 e8 01	 sub	 eax, 1
  0039b	89 84 24 90 00
	00 00		 mov	 DWORD PTR burnc$27576[rsp], eax
  003a2	85 c9		 test	 ecx, ecx
  003a4	74 25		 je	 SHORT $LN1@DecryptBuf
  003a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR burnm$27574[rsp]
  003ae	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  003b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR burnm$27574[rsp]
  003bd	48 83 c0 08	 add	 rax, 8
  003c1	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR burnm$27574[rsp], rax
  003c9	eb bf		 jmp	 SHORT $LN2@DecryptBuf
$LN1@DecryptBuf:
  003cb	33 c0		 xor	 eax, eax
  003cd	85 c0		 test	 eax, eax
  003cf	75 a1		 jne	 SHORT $LN5@DecryptBuf
$LN18@DecryptBuf:

; 777  : }

  003d1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003d9	48 33 cc	 xor	 rcx, rsp
  003dc	e8 00 00 00 00	 call	 __security_check_cookie
  003e1	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003e8	c3		 ret	 0
DecryptBufferXTSNonParallel ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	DecryptBufferXTS8Byte
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBufferXTS8Byte DD imagerel $LN21
	DD	imagerel $LN21+1147
	DD	imagerel $unwind$DecryptBufferXTS8Byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTS8Byte DD 042f19H
	DD	05b011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecryptBufferXTS8Byte
_TEXT	SEGMENT
endBlock$ = 48
bufPtr$ = 56
xor_ks$ = 80
whiteningValuePtr32$ = 624
blockCount$ = 632
byteBufUnitNo$ = 640
whiteningValue$ = 648
finalCarry$ = 656
dataUnitNo$ = 664
block$ = 672
startBlock$ = 676
burnc$27446 = 680
burnm$27444 = 688
tv145 = 696
__$ArrayPad$ = 704
buffer$ = 752
length$ = 760
startDataUnitNo$ = 768
startCipherBlockNo$ = 776
ks$ = 784
ks2$ = 792
cipher$ = 800
DecryptBufferXTS8Byte PROC				; COMDAT

; 442  : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec d8 02
	00 00		 sub	 rsp, 728		; 000002d8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 443  : 	unsigned __int8 finalCarry;
; 444  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
; 445  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
; 446  : 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;

  0002f	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00037	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax

; 447  : 	unsigned __int32 *bufPtr = (unsigned __int32 *) buffer;

  0003f	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  00047	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 448  : 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;

  0004c	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR startCipherBlockNo$[rsp]
  00053	89 84 24 a4 02
	00 00		 mov	 DWORD PTR startBlock$[rsp], eax

; 449  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 450  : 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
; 451  : 
; 452  : 	dataUnitNo = startDataUnitNo->Value;

  0005a	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR startDataUnitNo$[rsp]
  00062	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00065	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 453  : 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  0006d	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00075	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 454  : 
; 455  : 	if (length % BYTES_PER_XTS_BLOCK_SMALL)

  0007d	33 d2		 xor	 edx, edx
  0007f	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  00087	b9 08 00 00 00	 mov	 ecx, 8
  0008c	48 f7 f1	 div	 rcx
  0008f	48 85 d2	 test	 rdx, rdx
  00092	74 1f		 je	 SHORT $LN16@DecryptBuf@2

; 456  : 		GST_THROW_FATAL_EXCEPTION;

  00094	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0009d	45 33 c9	 xor	 r9d, r9d
  000a0	45 33 c0	 xor	 r8d, r8d
  000a3	ba c8 01 00 00	 mov	 edx, 456		; 000001c8H
  000a8	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN16@DecryptBuf@2:

; 457  : 
; 458  : 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;

  000b3	33 d2		 xor	 edx, edx
  000b5	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000bd	b9 08 00 00 00	 mov	 ecx, 8
  000c2	48 f7 f1	 div	 rcx
  000c5	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax

; 459  : 
; 460  : 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));

  000cd	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000d4	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  000d9	48 63 c8	 movsxd	 rcx, eax
  000dc	48 8d 7c 24 50	 lea	 rdi, QWORD PTR xor_ks$[rsp]
  000e1	48 8b b4 24 10
	03 00 00	 mov	 rsi, QWORD PTR ks$[rsp]
  000e9	f3 a4		 rep movsb
$LN15@DecryptBuf@2:

; 461  : 
; 462  : 	while (blockCount > 0)

  000eb	48 83 bc 24 78
	02 00 00 00	 cmp	 QWORD PTR blockCount$[rsp], 0
  000f4	0f 86 06 03 00
	00		 jbe	 $LN14@DecryptBuf@2

; 463  : 	{
; 464  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)

  000fa	48 83 bc 24 78
	02 00 00 40	 cmp	 QWORD PTR blockCount$[rsp], 64 ; 00000040H
  00103	73 16		 jae	 SHORT $LN13@DecryptBuf@2

; 465  : 			endBlock = startBlock + (unsigned __int32) blockCount;

  00105	8b 8c 24 78 02
	00 00		 mov	 ecx, DWORD PTR blockCount$[rsp]
  0010c	8b 84 24 a4 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00113	03 c1		 add	 eax, ecx
  00115	89 44 24 30	 mov	 DWORD PTR endBlock$[rsp], eax

; 466  : 		else

  00119	eb 08		 jmp	 SHORT $LN12@DecryptBuf@2
$LN13@DecryptBuf@2:

; 467  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;

  0011b	c7 44 24 30 40
	00 00 00	 mov	 DWORD PTR endBlock$[rsp], 64 ; 00000040H
$LN12@DecryptBuf@2:

; 468  : 
; 469  : 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;

  00123	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  0012b	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax

; 470  : 
; 471  : 		//Encrypt data unit using the second key to generate the first whitening value
; 472  : 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);

  00133	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr32$[rsp]
  0013b	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR byteBufUnitNo$[rsp]
  00142	89 01		 mov	 DWORD PTR [rcx], eax

; 473  : 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);

  00144	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr32$[rsp]
  0014c	8b 84 24 84 02
	00 00		 mov	 eax, DWORD PTR byteBufUnitNo$[rsp+4]
  00153	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 474  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00156	4c 8b 84 24 18
	03 00 00	 mov	 r8, QWORD PTR ks2$[rsp]
  0015e	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00166	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0016d	e8 00 00 00 00	 call	 EncipherBlock

; 475  : 
; 476  : 		//XOR ks with the current DataUnitNo
; 477  : 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);

  00172	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  0017a	4c 8d 8c 24 80
	02 00 00	 lea	 r9, QWORD PTR byteBufUnitNo$[rsp]
  00182	4c 8d 44 24 50	 lea	 r8, QWORD PTR xor_ks$[rsp]
  00187	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR ks$[rsp]
  0018f	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00196	e8 00 00 00 00	 call	 XorKeySchedule

; 478  : 
; 479  : 		for (block = 0; block < endBlock; block++)

  0019b	c7 84 24 a0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR block$[rsp], 0
  001a6	eb 11		 jmp	 SHORT $LN11@DecryptBuf@2
$LN10@DecryptBuf@2:
  001a8	8b 84 24 a0 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  001af	83 c0 01	 add	 eax, 1
  001b2	89 84 24 a0 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN11@DecryptBuf@2:
  001b9	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  001bd	39 84 24 a0 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001c4	0f 83 e0 01 00
	00		 jae	 $LN9@DecryptBuf@2

; 480  : 		{
; 481  : 			if (block >= startBlock)

  001ca	8b 84 24 a4 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  001d1	39 84 24 a0 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001d8	0f 82 f4 00 00
	00		 jb	 $LN8@DecryptBuf@2

; 482  : 			{
; 483  : 				//Post-whitening
; 484  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  001de	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  001e3	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  001eb	8b 00		 mov	 eax, DWORD PTR [rax]
  001ed	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001ef	33 c8		 xor	 ecx, eax
  001f1	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001f6	89 08		 mov	 DWORD PTR [rax], ecx
  001f8	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00200	48 83 c0 04	 add	 rax, 4
  00204	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax
  0020c	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00211	48 83 c0 04	 add	 rax, 4
  00215	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 485  : 				*bufPtr-- ^= *whiteningValuePtr32--;

  0021a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0021f	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00227	8b 00		 mov	 eax, DWORD PTR [rax]
  00229	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0022b	33 c8		 xor	 ecx, eax
  0022d	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00232	89 08		 mov	 DWORD PTR [rax], ecx
  00234	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  0023c	48 83 e8 04	 sub	 rax, 4
  00240	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax
  00248	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0024d	48 83 e8 04	 sub	 rax, 4
  00251	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 486  : 
; 487  : 				//Actual decryption
; 488  : 				DecipherBlock (cipher, bufPtr, xor_ks);

  00256	4c 8d 44 24 50	 lea	 r8, QWORD PTR xor_ks$[rsp]
  0025b	48 8b 54 24 38	 mov	 rdx, QWORD PTR bufPtr$[rsp]
  00260	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00267	e8 00 00 00 00	 call	 DecipherBlock

; 489  : 
; 490  : 				//Pre-whitening
; 491  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  0026c	48 8b 54 24 38	 mov	 rdx, QWORD PTR bufPtr$[rsp]
  00271	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00279	8b 00		 mov	 eax, DWORD PTR [rax]
  0027b	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  0027d	33 c8		 xor	 ecx, eax
  0027f	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00284	89 08		 mov	 DWORD PTR [rax], ecx
  00286	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  0028e	48 83 c0 04	 add	 rax, 4
  00292	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax
  0029a	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0029f	48 83 c0 04	 add	 rax, 4
  002a3	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 492  : 				*bufPtr++ ^= *whiteningValuePtr32;

  002a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  002ad	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  002b5	8b 00		 mov	 eax, DWORD PTR [rax]
  002b7	8b 09		 mov	 ecx, DWORD PTR [rcx]
  002b9	33 c8		 xor	 ecx, eax
  002bb	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  002c0	89 08		 mov	 DWORD PTR [rax], ecx
  002c2	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  002c7	48 83 c0 04	 add	 rax, 4
  002cb	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 493  : 			}
; 494  : 			else

  002d0	eb 14		 jmp	 SHORT $LN7@DecryptBuf@2
$LN8@DecryptBuf@2:

; 495  : 				whiteningValuePtr32++;

  002d2	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  002da	48 83 c0 04	 add	 rax, 4
  002de	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax
$LN7@DecryptBuf@2:

; 496  : 
; 497  : 			//Derive the next whitening value
; 498  : 
; 499  : #if BYTE_ORDER == LITTLE_ENDIAN
; 500  : 
; 501  : 			//Little-endian platforms
; 502  : 
; 503  : 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;

  002e6	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  002ee	8b 00		 mov	 eax, DWORD PTR [rax]
  002f0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002f5	85 c0		 test	 eax, eax
  002f7	74 0d		 je	 SHORT $LN19@DecryptBuf@2
  002f9	c7 84 24 b8 02
	00 00 1b 00 00
	00		 mov	 DWORD PTR tv145[rsp], 27
  00304	eb 0b		 jmp	 SHORT $LN20@DecryptBuf@2
$LN19@DecryptBuf@2:
  00306	c7 84 24 b8 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN20@DecryptBuf@2:
  00311	0f b6 84 24 b8
	02 00 00	 movzx	 eax, BYTE PTR tv145[rsp]
  00319	88 84 24 90 02
	00 00		 mov	 BYTE PTR finalCarry$[rsp], al

; 504  : 
; 505  : 			*whiteningValuePtr32-- <<= 1;

  00320	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00328	8b 08		 mov	 ecx, DWORD PTR [rax]
  0032a	d1 e1		 shl	 ecx, 1
  0032c	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00334	89 08		 mov	 DWORD PTR [rax], ecx
  00336	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  0033e	48 83 e8 04	 sub	 rax, 4
  00342	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax

; 506  : 
; 507  : 			if (*whiteningValuePtr32 & 0x80000000)

  0034a	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00352	8b 00		 mov	 eax, DWORD PTR [rax]
  00354	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00359	85 c0		 test	 eax, eax
  0035b	74 19		 je	 SHORT $LN6@DecryptBuf@2

; 508  : 				*(whiteningValuePtr32 + 1) |= 1;

  0035d	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00365	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00368	83 c9 01	 or	 ecx, 1
  0036b	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00373	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN6@DecryptBuf@2:

; 509  : 
; 510  : 			*whiteningValuePtr32 <<= 1;

  00376	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  0037e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00380	d1 e1		 shl	 ecx, 1
  00382	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  0038a	89 08		 mov	 DWORD PTR [rax], ecx

; 511  : #else
; 512  : 			//Big-endian platforms
; 513  : 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
; 514  : 
; 515  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 516  : 
; 517  : 			whiteningValuePtr32--;
; 518  : 
; 519  : 			if (*whiteningValuePtr32 & 0x80)
; 520  : 				*(whiteningValuePtr32 + 1) |= 0x1000000;
; 521  : 
; 522  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 523  : #endif
; 524  : 
; 525  : 			whiteningValue[0] ^= finalCarry;

  0038c	0f b6 8c 24 90
	02 00 00	 movzx	 ecx, BYTE PTR finalCarry$[rsp]
  00394	0f b6 84 24 88
	02 00 00	 movzx	 eax, BYTE PTR whiteningValue$[rsp]
  0039c	33 c1		 xor	 eax, ecx
  0039e	88 84 24 88 02
	00 00		 mov	 BYTE PTR whiteningValue$[rsp], al

; 526  : 		}

  003a5	e9 fe fd ff ff	 jmp	 $LN10@DecryptBuf@2
$LN9@DecryptBuf@2:

; 527  : 
; 528  : 		blockCount -= endBlock - startBlock;

  003aa	8b 8c 24 a4 02
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  003b1	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  003b5	2b c1		 sub	 eax, ecx
  003b7	8b c8		 mov	 ecx, eax
  003b9	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR blockCount$[rsp]
  003c1	48 2b c1	 sub	 rax, rcx
  003c4	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax

; 529  : 		startBlock = 0;

  003cc	c7 84 24 a4 02
	00 00 00 00 00
	00		 mov	 DWORD PTR startBlock$[rsp], 0

; 530  : 		dataUnitNo++;

  003d7	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  003df	48 83 c0 01	 add	 rax, 1
  003e3	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 531  : 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  003eb	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  003f3	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 532  : 	}

  003fb	e9 eb fc ff ff	 jmp	 $LN15@DecryptBuf@2
$LN14@DecryptBuf@2:
$LN5@DecryptBuf@2:

; 533  : 
; 534  : 	FAST_ERASE32 (whiteningValue, sizeof (whiteningValue));

  00400	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00408	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR burnm$27444[rsp], rax
  00410	c7 84 24 a8 02
	00 00 01 00 00
	00		 mov	 DWORD PTR burnc$27446[rsp], 1
$LN2@DecryptBuf@2:
  0041b	8b 8c 24 a8 02
	00 00		 mov	 ecx, DWORD PTR burnc$27446[rsp]
  00422	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR burnc$27446[rsp]
  00429	83 e8 01	 sub	 eax, 1
  0042c	89 84 24 a8 02
	00 00		 mov	 DWORD PTR burnc$27446[rsp], eax
  00433	85 c9		 test	 ecx, ecx
  00435	74 24		 je	 SHORT $LN1@DecryptBuf@2
  00437	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR burnm$27444[rsp]
  0043f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00445	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR burnm$27444[rsp]
  0044d	48 83 c0 04	 add	 rax, 4
  00451	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR burnm$27444[rsp], rax
  00459	eb c0		 jmp	 SHORT $LN2@DecryptBuf@2
$LN1@DecryptBuf@2:
  0045b	33 c0		 xor	 eax, eax
  0045d	85 c0		 test	 eax, eax
  0045f	75 9f		 jne	 SHORT $LN5@DecryptBuf@2
$LN18@DecryptBuf@2:

; 535  : }

  00461	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00469	48 33 cc	 xor	 rcx, rsp
  0046c	e8 00 00 00 00	 call	 __security_check_cookie
  00471	48 81 c4 d8 02
	00 00		 add	 rsp, 728		; 000002d8H
  00478	5f		 pop	 rdi
  00479	5e		 pop	 rsi
  0047a	c3		 ret	 0
DecryptBufferXTS8Byte ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferXTSNonParallel DD imagerel EncryptBufferXTSNonParallel
	DD	imagerel EncryptBufferXTSNonParallel+1001
	DD	imagerel $unwind$EncryptBufferXTSNonParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTSNonParallel DD 022d19H
	DD	017011bH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptBufferXTSNonParallel
_TEXT	SEGMENT
endBlock$ = 48
bufPtr$ = 56
blockCount$ = 64
whiteningValuePtr64$ = 72
byteBufUnitNo$ = 88
whiteningValue$ = 104
finalCarry$ = 120
dataUnitNo$ = 128
block$ = 136
startBlock$ = 140
burnc$27370 = 144
burnm$27368 = 152
tv132 = 160
__$ArrayPad$ = 168
buffer$ = 192
length$ = 200
startDataUnitNo$ = 208
startCipherBlockNo$ = 216
ks$ = 224
ks2$ = 232
cipher$ = 240
EncryptBufferXTSNonParallel PROC			; COMDAT

; 310  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 311  : 	unsigned __int8 finalCarry;
; 312  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 313  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 314  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0002d	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00032	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 315  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  00037	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0003f	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 316  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00044	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR startCipherBlockNo$[rsp]
  0004b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR startBlock$[rsp], eax

; 317  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 318  : 
; 319  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 320  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 321  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 322  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 323  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 324  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 325  : 
; 326  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 327  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 328  : 	dataUnitNo = startDataUnitNo->Value;

  00052	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR startDataUnitNo$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 329  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00065	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  0006d	48 89 44 24 58	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 330  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  00072	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp+8], 0

; 331  : 
; 332  : 	if (length % BYTES_PER_XTS_BLOCK)

  0007b	33 d2		 xor	 edx, edx
  0007d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR length$[rsp]
  00085	b9 10 00 00 00	 mov	 ecx, 16
  0008a	48 f7 f1	 div	 rcx
  0008d	48 85 d2	 test	 rdx, rdx
  00090	74 1f		 je	 SHORT $LN16@EncryptBuf

; 333  : 		GST_THROW_FATAL_EXCEPTION;

  00092	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0009b	45 33 c9	 xor	 r9d, r9d
  0009e	45 33 c0	 xor	 r8d, r8d
  000a1	ba 4d 01 00 00	 mov	 edx, 333		; 0000014dH
  000a6	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN16@EncryptBuf:

; 334  : 
; 335  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000b1	33 d2		 xor	 edx, edx
  000b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000bb	b9 10 00 00 00	 mov	 ecx, 16
  000c0	48 f7 f1	 div	 rcx
  000c3	48 89 44 24 40	 mov	 QWORD PTR blockCount$[rsp], rax
$LN15@EncryptBuf:

; 336  : 
; 337  : 	// Process all blocks in the buffer
; 338  : 	while (blockCount > 0)

  000c8	48 83 7c 24 40
	00		 cmp	 QWORD PTR blockCount$[rsp], 0
  000ce	0f 86 9e 02 00
	00		 jbe	 $LN14@EncryptBuf

; 339  : 	{
; 340  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  000d4	48 83 7c 24 40
	20		 cmp	 QWORD PTR blockCount$[rsp], 32 ; 00000020H
  000da	73 13		 jae	 SHORT $LN13@EncryptBuf

; 341  : 			endBlock = startBlock + (unsigned int) blockCount;

  000dc	8b 4c 24 40	 mov	 ecx, DWORD PTR blockCount$[rsp]
  000e0	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  000e7	03 c1		 add	 eax, ecx
  000e9	89 44 24 30	 mov	 DWORD PTR endBlock$[rsp], eax

; 342  : 		else

  000ed	eb 08		 jmp	 SHORT $LN12@EncryptBuf
$LN13@EncryptBuf:

; 343  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000ef	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR endBlock$[rsp], 32 ; 00000020H
$LN12@EncryptBuf:

; 344  : 
; 345  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  000f7	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  000fc	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 346  : 
; 347  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 348  : 		// whitening value for this data unit)
; 349  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  00101	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR byteBufUnitNo$[rsp]
  0010b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 350  : 		*(whiteningValuePtr64 + 1) = 0;

  0010e	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00113	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 351  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0011b	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR ks2$[rsp]
  00123	48 8d 54 24 68	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00128	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0012f	e8 00 00 00 00	 call	 EncipherBlock

; 352  : 
; 353  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 354  : 		// encrypt all relevant blocks in this data unit
; 355  : 		for (block = 0; block < endBlock; block++)

  00134	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR block$[rsp], 0
  0013f	eb 11		 jmp	 SHORT $LN11@EncryptBuf
$LN10@EncryptBuf:
  00141	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00148	83 c0 01	 add	 eax, 1
  0014b	89 84 24 88 00
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN11@EncryptBuf:
  00152	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00156	39 84 24 88 00
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  0015d	0f 83 c2 01 00
	00		 jae	 $LN9@EncryptBuf

; 356  : 		{
; 357  : 			if (block >= startBlock)

  00163	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  0016a	39 84 24 88 00
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  00171	0f 82 e9 00 00
	00		 jb	 $LN8@EncryptBuf

; 358  : 			{
; 359  : 				// Pre-whitening
; 360  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00177	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0017c	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00181	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00184	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00187	48 33 c8	 xor	 rcx, rax
  0018a	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0018f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00192	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00197	48 83 c0 08	 add	 rax, 8
  0019b	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  001a0	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001a5	48 83 c0 08	 add	 rax, 8
  001a9	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 361  : 				*bufPtr-- ^= *whiteningValuePtr64--;

  001ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  001b3	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001bb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001be	48 33 c8	 xor	 rcx, rax
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001c6	48 89 08	 mov	 QWORD PTR [rax], rcx
  001c9	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001ce	48 83 e8 08	 sub	 rax, 8
  001d2	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  001d7	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001dc	48 83 e8 08	 sub	 rax, 8
  001e0	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 362  : 
; 363  : 				// Actual encryption
; 364  : 				EncipherBlock (cipher, bufPtr, ks);

  001e5	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR ks$[rsp]
  001ed	48 8b 54 24 38	 mov	 rdx, QWORD PTR bufPtr$[rsp]
  001f2	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  001f9	e8 00 00 00 00	 call	 EncipherBlock

; 365  : 
; 366  : 				// Post-whitening
; 367  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  001fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  00203	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00208	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0020e	48 33 c8	 xor	 rcx, rax
  00211	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00216	48 89 08	 mov	 QWORD PTR [rax], rcx
  00219	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0021e	48 83 c0 08	 add	 rax, 8
  00222	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  00227	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0022c	48 83 c0 08	 add	 rax, 8
  00230	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 368  : 				*bufPtr++ ^= *whiteningValuePtr64;

  00235	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0023a	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0023f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00242	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00245	48 33 c8	 xor	 rcx, rax
  00248	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0024d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00250	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00255	48 83 c0 08	 add	 rax, 8
  00259	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 369  : 			}
; 370  : 			else

  0025e	eb 0e		 jmp	 SHORT $LN7@EncryptBuf
$LN8@EncryptBuf:

; 371  : 				whiteningValuePtr64++;

  00260	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00265	48 83 c0 08	 add	 rax, 8
  00269	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
$LN7@EncryptBuf:

; 372  : 
; 373  : 			// Derive the next whitening value
; 374  : 
; 375  : #if BYTE_ORDER == LITTLE_ENDIAN
; 376  : 
; 377  : 			// Little-endian platforms
; 378  : 
; 379  : 			finalCarry = 
; 380  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 381  : 				135 : 0;

  0026e	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00273	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0027d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00280	48 23 c1	 and	 rax, rcx
  00283	48 85 c0	 test	 rax, rax
  00286	74 0d		 je	 SHORT $LN19@EncryptBuf
  00288	c7 84 24 a0 00
	00 00 87 00 00
	00		 mov	 DWORD PTR tv132[rsp], 135 ; 00000087H
  00293	eb 0b		 jmp	 SHORT $LN20@EncryptBuf
$LN19@EncryptBuf:
  00295	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
$LN20@EncryptBuf:
  002a0	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR tv132[rsp]
  002a8	88 44 24 78	 mov	 BYTE PTR finalCarry$[rsp], al

; 382  : 
; 383  : 			*whiteningValuePtr64-- <<= 1;

  002ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002b1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002b4	48 d1 e1	 shl	 rcx, 1
  002b7	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002bc	48 89 08	 mov	 QWORD PTR [rax], rcx
  002bf	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002c4	48 83 e8 08	 sub	 rax, 8
  002c8	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 384  : 
; 385  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002cd	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002d2	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002df	48 23 c1	 and	 rax, rcx
  002e2	48 85 c0	 test	 rax, rax
  002e5	74 16		 je	 SHORT $LN6@EncryptBuf

; 386  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002e7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002ec	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  002f0	48 83 c9 01	 or	 rcx, 1
  002f4	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002f9	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN6@EncryptBuf:

; 387  : 
; 388  : 			*whiteningValuePtr64 <<= 1;

  002fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00302	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00305	48 d1 e1	 shl	 rcx, 1
  00308	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0030d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 389  : #else
; 390  : 
; 391  : 			// Big-endian platforms
; 392  : 
; 393  : 			finalCarry = 
; 394  : 				(*whiteningValuePtr64 & 0x80) ?
; 395  : 				135 : 0;
; 396  : 
; 397  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 398  : 
; 399  : 			whiteningValuePtr64--;
; 400  : 
; 401  : 			if (*whiteningValuePtr64 & 0x80)
; 402  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 403  : 
; 404  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 405  : #endif
; 406  : 
; 407  : 			whiteningValue[0] ^= finalCarry;

  00310	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR finalCarry$[rsp]
  00315	0f b6 44 24 68	 movzx	 eax, BYTE PTR whiteningValue$[rsp]
  0031a	33 c1		 xor	 eax, ecx
  0031c	88 44 24 68	 mov	 BYTE PTR whiteningValue$[rsp], al

; 408  : 		}

  00320	e9 1c fe ff ff	 jmp	 $LN10@EncryptBuf
$LN9@EncryptBuf:

; 409  : 
; 410  : 		blockCount -= endBlock - startBlock;

  00325	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  0032c	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00330	2b c1		 sub	 eax, ecx
  00332	8b c8		 mov	 ecx, eax
  00334	48 8b 44 24 40	 mov	 rax, QWORD PTR blockCount$[rsp]
  00339	48 2b c1	 sub	 rax, rcx
  0033c	48 89 44 24 40	 mov	 QWORD PTR blockCount$[rsp], rax

; 411  : 		startBlock = 0;

  00341	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR startBlock$[rsp], 0

; 412  : 		dataUnitNo++;

  0034c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00354	48 83 c0 01	 add	 rax, 1
  00358	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 413  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00360	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00368	48 89 44 24 58	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 414  : 	}

  0036d	e9 56 fd ff ff	 jmp	 $LN15@EncryptBuf
$LN14@EncryptBuf:
$LN5@EncryptBuf:

; 415  : 
; 416  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00372	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00377	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR burnm$27368[rsp], rax
  0037f	c7 84 24 90 00
	00 00 02 00 00
	00		 mov	 DWORD PTR burnc$27370[rsp], 2
$LN2@EncryptBuf:
  0038a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR burnc$27370[rsp]
  00391	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR burnc$27370[rsp]
  00398	83 e8 01	 sub	 eax, 1
  0039b	89 84 24 90 00
	00 00		 mov	 DWORD PTR burnc$27370[rsp], eax
  003a2	85 c9		 test	 ecx, ecx
  003a4	74 25		 je	 SHORT $LN1@EncryptBuf
  003a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR burnm$27368[rsp]
  003ae	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  003b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR burnm$27368[rsp]
  003bd	48 83 c0 08	 add	 rax, 8
  003c1	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR burnm$27368[rsp], rax
  003c9	eb bf		 jmp	 SHORT $LN2@EncryptBuf
$LN1@EncryptBuf:
  003cb	33 c0		 xor	 eax, eax
  003cd	85 c0		 test	 eax, eax
  003cf	75 a1		 jne	 SHORT $LN5@EncryptBuf
$LN18@EncryptBuf:

; 417  : }

  003d1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003d9	48 33 cc	 xor	 rcx, rsp
  003dc	e8 00 00 00 00	 call	 __security_check_cookie
  003e1	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003e8	c3		 ret	 0
EncryptBufferXTSNonParallel ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	EncryptBufferXTS8Byte
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferXTS8Byte DD imagerel $LN21
	DD	imagerel $LN21+1147
	DD	imagerel $unwind$EncryptBufferXTS8Byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTS8Byte DD 042f19H
	DD	05b011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptBufferXTS8Byte
_TEXT	SEGMENT
endBlock$ = 48
bufPtr$ = 56
xor_ks$ = 80
whiteningValuePtr32$ = 624
blockCount$ = 632
byteBufUnitNo$ = 640
whiteningValue$ = 648
finalCarry$ = 656
dataUnitNo$ = 664
block$ = 672
startBlock$ = 676
burnc$27240 = 680
burnm$27238 = 688
tv145 = 696
__$ArrayPad$ = 704
buffer$ = 752
length$ = 760
startDataUnitNo$ = 768
startCipherBlockNo$ = 776
ks$ = 784
ks2$ = 792
cipher$ = 800
EncryptBufferXTS8Byte PROC				; COMDAT

; 70   : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec d8 02
	00 00		 sub	 rsp, 728		; 000002d8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 71   : 	unsigned __int8 finalCarry;
; 72   : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
; 73   : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
; 74   : 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *)whiteningValue;

  0002f	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00037	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax

; 75   : 	unsigned __int32 *bufPtr = (unsigned __int32 *)buffer;

  0003f	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  00047	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 76   : 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;

  0004c	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR startCipherBlockNo$[rsp]
  00053	89 84 24 a4 02
	00 00		 mov	 DWORD PTR startBlock$[rsp], eax

; 77   : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 78   : 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
; 79   : 
; 80   : 	dataUnitNo = startDataUnitNo->Value;

  0005a	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR startDataUnitNo$[rsp]
  00062	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00065	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 81   : 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64(dataUnitNo);

  0006d	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00075	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 82   : 
; 83   : 	if (length % BYTES_PER_XTS_BLOCK_SMALL)

  0007d	33 d2		 xor	 edx, edx
  0007f	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  00087	b9 08 00 00 00	 mov	 ecx, 8
  0008c	48 f7 f1	 div	 rcx
  0008f	48 85 d2	 test	 rdx, rdx
  00092	74 1f		 je	 SHORT $LN16@EncryptBuf@2

; 84   : 		GST_THROW_FATAL_EXCEPTION;

  00094	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0009d	45 33 c9	 xor	 r9d, r9d
  000a0	45 33 c0	 xor	 r8d, r8d
  000a3	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  000a8	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN16@EncryptBuf@2:

; 85   : 
; 86   : 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;

  000b3	33 d2		 xor	 edx, edx
  000b5	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000bd	b9 08 00 00 00	 mov	 ecx, 8
  000c2	48 f7 f1	 div	 rcx
  000c5	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax

; 87   : 
; 88   : 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));

  000cd	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000d4	e8 00 00 00 00	 call	 CipherGetKeyScheduleSize
  000d9	48 63 c8	 movsxd	 rcx, eax
  000dc	48 8d 7c 24 50	 lea	 rdi, QWORD PTR xor_ks$[rsp]
  000e1	48 8b b4 24 10
	03 00 00	 mov	 rsi, QWORD PTR ks$[rsp]
  000e9	f3 a4		 rep movsb
$LN15@EncryptBuf@2:

; 89   : 
; 90   : 	while (blockCount > 0)

  000eb	48 83 bc 24 78
	02 00 00 00	 cmp	 QWORD PTR blockCount$[rsp], 0
  000f4	0f 86 06 03 00
	00		 jbe	 $LN14@EncryptBuf@2

; 91   : 	{
; 92   : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)

  000fa	48 83 bc 24 78
	02 00 00 40	 cmp	 QWORD PTR blockCount$[rsp], 64 ; 00000040H
  00103	73 16		 jae	 SHORT $LN13@EncryptBuf@2

; 93   : 			endBlock = startBlock + (unsigned __int32) blockCount;

  00105	8b 8c 24 78 02
	00 00		 mov	 ecx, DWORD PTR blockCount$[rsp]
  0010c	8b 84 24 a4 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00113	03 c1		 add	 eax, ecx
  00115	89 44 24 30	 mov	 DWORD PTR endBlock$[rsp], eax

; 94   : 		else

  00119	eb 08		 jmp	 SHORT $LN12@EncryptBuf@2
$LN13@EncryptBuf@2:

; 95   : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;

  0011b	c7 44 24 30 40
	00 00 00	 mov	 DWORD PTR endBlock$[rsp], 64 ; 00000040H
$LN12@EncryptBuf@2:

; 96   : 
; 97   : 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;

  00123	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  0012b	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax

; 98   : 
; 99   : 		//Generate first whitening value
; 100  : 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);

  00133	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr32$[rsp]
  0013b	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR byteBufUnitNo$[rsp]
  00142	89 01		 mov	 DWORD PTR [rcx], eax

; 101  : 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);

  00144	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr32$[rsp]
  0014c	8b 84 24 84 02
	00 00		 mov	 eax, DWORD PTR byteBufUnitNo$[rsp+4]
  00153	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 102  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00156	4c 8b 84 24 18
	03 00 00	 mov	 r8, QWORD PTR ks2$[rsp]
  0015e	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00166	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0016d	e8 00 00 00 00	 call	 EncipherBlock

; 103  : 
; 104  : 		//XOR ks with the current DataUnitNo
; 105  : 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);

  00172	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  0017a	4c 8d 8c 24 80
	02 00 00	 lea	 r9, QWORD PTR byteBufUnitNo$[rsp]
  00182	4c 8d 44 24 50	 lea	 r8, QWORD PTR xor_ks$[rsp]
  00187	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR ks$[rsp]
  0018f	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00196	e8 00 00 00 00	 call	 XorKeySchedule

; 106  : 
; 107  : 		//Generate subsequent whitening values for blocks
; 108  : 		for (block = 0; block < endBlock; block++)

  0019b	c7 84 24 a0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR block$[rsp], 0
  001a6	eb 11		 jmp	 SHORT $LN11@EncryptBuf@2
$LN10@EncryptBuf@2:
  001a8	8b 84 24 a0 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  001af	83 c0 01	 add	 eax, 1
  001b2	89 84 24 a0 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN11@EncryptBuf@2:
  001b9	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  001bd	39 84 24 a0 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001c4	0f 83 e0 01 00
	00		 jae	 $LN9@EncryptBuf@2

; 109  : 		{
; 110  : 			if (block >= startBlock)

  001ca	8b 84 24 a4 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  001d1	39 84 24 a0 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001d8	0f 82 f4 00 00
	00		 jb	 $LN8@EncryptBuf@2

; 111  : 			{
; 112  : 				//Pre-whitening
; 113  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  001de	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  001e3	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  001eb	8b 00		 mov	 eax, DWORD PTR [rax]
  001ed	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001ef	33 c8		 xor	 ecx, eax
  001f1	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001f6	89 08		 mov	 DWORD PTR [rax], ecx
  001f8	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00200	48 83 c0 04	 add	 rax, 4
  00204	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax
  0020c	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00211	48 83 c0 04	 add	 rax, 4
  00215	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 114  : 				*bufPtr-- ^= *whiteningValuePtr32--;

  0021a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0021f	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00227	8b 00		 mov	 eax, DWORD PTR [rax]
  00229	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0022b	33 c8		 xor	 ecx, eax
  0022d	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00232	89 08		 mov	 DWORD PTR [rax], ecx
  00234	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  0023c	48 83 e8 04	 sub	 rax, 4
  00240	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax
  00248	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0024d	48 83 e8 04	 sub	 rax, 4
  00251	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 115  : 
; 116  : 				//Actual encryption
; 117  : 				EncipherBlock(cipher, bufPtr, xor_ks);

  00256	4c 8d 44 24 50	 lea	 r8, QWORD PTR xor_ks$[rsp]
  0025b	48 8b 54 24 38	 mov	 rdx, QWORD PTR bufPtr$[rsp]
  00260	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00267	e8 00 00 00 00	 call	 EncipherBlock

; 118  : 
; 119  : 				//Post-whitening
; 120  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  0026c	48 8b 54 24 38	 mov	 rdx, QWORD PTR bufPtr$[rsp]
  00271	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00279	8b 00		 mov	 eax, DWORD PTR [rax]
  0027b	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  0027d	33 c8		 xor	 ecx, eax
  0027f	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00284	89 08		 mov	 DWORD PTR [rax], ecx
  00286	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  0028e	48 83 c0 04	 add	 rax, 4
  00292	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax
  0029a	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0029f	48 83 c0 04	 add	 rax, 4
  002a3	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 121  : 				*bufPtr++ ^= *whiteningValuePtr32;

  002a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  002ad	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  002b5	8b 00		 mov	 eax, DWORD PTR [rax]
  002b7	8b 09		 mov	 ecx, DWORD PTR [rcx]
  002b9	33 c8		 xor	 ecx, eax
  002bb	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  002c0	89 08		 mov	 DWORD PTR [rax], ecx
  002c2	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  002c7	48 83 c0 04	 add	 rax, 4
  002cb	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 122  : 			}
; 123  : 			else

  002d0	eb 14		 jmp	 SHORT $LN7@EncryptBuf@2
$LN8@EncryptBuf@2:

; 124  : 				whiteningValuePtr32++;

  002d2	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  002da	48 83 c0 04	 add	 rax, 4
  002de	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax
$LN7@EncryptBuf@2:

; 125  : 
; 126  : 			//Derive the next whitening value
; 127  : #if BYTE_ORDER == LITTLE_ENDIAN
; 128  : 
; 129  : 			//Little-endian platforms
; 130  : 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;

  002e6	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  002ee	8b 00		 mov	 eax, DWORD PTR [rax]
  002f0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002f5	85 c0		 test	 eax, eax
  002f7	74 0d		 je	 SHORT $LN19@EncryptBuf@2
  002f9	c7 84 24 b8 02
	00 00 1b 00 00
	00		 mov	 DWORD PTR tv145[rsp], 27
  00304	eb 0b		 jmp	 SHORT $LN20@EncryptBuf@2
$LN19@EncryptBuf@2:
  00306	c7 84 24 b8 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN20@EncryptBuf@2:
  00311	0f b6 84 24 b8
	02 00 00	 movzx	 eax, BYTE PTR tv145[rsp]
  00319	88 84 24 90 02
	00 00		 mov	 BYTE PTR finalCarry$[rsp], al

; 131  : 
; 132  : 			*whiteningValuePtr32-- <<= 1;

  00320	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00328	8b 08		 mov	 ecx, DWORD PTR [rax]
  0032a	d1 e1		 shl	 ecx, 1
  0032c	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00334	89 08		 mov	 DWORD PTR [rax], ecx
  00336	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  0033e	48 83 e8 04	 sub	 rax, 4
  00342	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuePtr32$[rsp], rax

; 133  : 
; 134  : 			if (*whiteningValuePtr32 & 0x80000000)

  0034a	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00352	8b 00		 mov	 eax, DWORD PTR [rax]
  00354	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00359	85 c0		 test	 eax, eax
  0035b	74 19		 je	 SHORT $LN6@EncryptBuf@2

; 135  : 				*(whiteningValuePtr32 + 1) |= 1;

  0035d	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00365	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00368	83 c9 01	 or	 ecx, 1
  0036b	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  00373	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN6@EncryptBuf@2:

; 136  : 
; 137  : 			*whiteningValuePtr32 <<= 1;

  00376	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  0037e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00380	d1 e1		 shl	 ecx, 1
  00382	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr32$[rsp]
  0038a	89 08		 mov	 DWORD PTR [rax], ecx

; 138  : #else
; 139  : 			//Big-endian platforms
; 140  : 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
; 141  : 
; 142  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 143  : 
; 144  : 			whiteningValuePtr32--;
; 145  : 
; 146  : 			if (*whiteningValuePtr32 & 0x80)
; 147  : 				*(whiteningValuePtr32 + 1) |= 0x01000000;
; 148  : 
; 149  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 150  : #endif
; 151  : 			whiteningValue[0] ^= finalCarry;

  0038c	0f b6 8c 24 90
	02 00 00	 movzx	 ecx, BYTE PTR finalCarry$[rsp]
  00394	0f b6 84 24 88
	02 00 00	 movzx	 eax, BYTE PTR whiteningValue$[rsp]
  0039c	33 c1		 xor	 eax, ecx
  0039e	88 84 24 88 02
	00 00		 mov	 BYTE PTR whiteningValue$[rsp], al

; 152  : 		}

  003a5	e9 fe fd ff ff	 jmp	 $LN10@EncryptBuf@2
$LN9@EncryptBuf@2:

; 153  : 		blockCount -= endBlock - startBlock;

  003aa	8b 8c 24 a4 02
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  003b1	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  003b5	2b c1		 sub	 eax, ecx
  003b7	8b c8		 mov	 ecx, eax
  003b9	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR blockCount$[rsp]
  003c1	48 2b c1	 sub	 rax, rcx
  003c4	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax

; 154  : 		startBlock = 0;

  003cc	c7 84 24 a4 02
	00 00 00 00 00
	00		 mov	 DWORD PTR startBlock$[rsp], 0

; 155  : 		dataUnitNo++;

  003d7	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  003df	48 83 c0 01	 add	 rax, 1
  003e3	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 156  : 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  003eb	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  003f3	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 157  : 	}

  003fb	e9 eb fc ff ff	 jmp	 $LN15@EncryptBuf@2
$LN14@EncryptBuf@2:
$LN5@EncryptBuf@2:

; 158  : 	FAST_ERASE32(whiteningValue, sizeof(whiteningValue));

  00400	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00408	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR burnm$27238[rsp], rax
  00410	c7 84 24 a8 02
	00 00 01 00 00
	00		 mov	 DWORD PTR burnc$27240[rsp], 1
$LN2@EncryptBuf@2:
  0041b	8b 8c 24 a8 02
	00 00		 mov	 ecx, DWORD PTR burnc$27240[rsp]
  00422	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR burnc$27240[rsp]
  00429	83 e8 01	 sub	 eax, 1
  0042c	89 84 24 a8 02
	00 00		 mov	 DWORD PTR burnc$27240[rsp], eax
  00433	85 c9		 test	 ecx, ecx
  00435	74 24		 je	 SHORT $LN1@EncryptBuf@2
  00437	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR burnm$27238[rsp]
  0043f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00445	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR burnm$27238[rsp]
  0044d	48 83 c0 04	 add	 rax, 4
  00451	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR burnm$27238[rsp], rax
  00459	eb c0		 jmp	 SHORT $LN2@EncryptBuf@2
$LN1@EncryptBuf@2:
  0045b	33 c0		 xor	 eax, eax
  0045d	85 c0		 test	 eax, eax
  0045f	75 9f		 jne	 SHORT $LN5@EncryptBuf@2
$LN18@EncryptBuf@2:

; 159  : }

  00461	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00469	48 33 cc	 xor	 rcx, rsp
  0046c	e8 00 00 00 00	 call	 __security_check_cookie
  00471	48 81 c4 d8 02
	00 00		 add	 rsp, 728		; 000002d8H
  00478	5f		 pop	 rdi
  00479	5e		 pop	 rsi
  0047a	c3		 ret	 0
EncryptBufferXTS8Byte ENDP
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBufferXTSParallel DD imagerel DecryptBufferXTSParallel
	DD	imagerel DecryptBufferXTSParallel+1631
	DD	imagerel $unwind$DecryptBufferXTSParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTSParallel DD 022d19H
	DD	05d011bH
	DD	imagerel __GSHandlerCheck
	DD	02d8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecryptBufferXTSParallel
_TEXT	SEGMENT
endBlock$ = 48
finalInt64WhiteningValuesPtr$ = 56
whiteningValues$ = 80
bufPtr$ = 592
dataUnitBufPtr$ = 600
blockCount$ = 608
whiteningValuePtr64$ = 616
whiteningValuesPtr64$ = 624
byteBufUnitNo$ = 632
whiteningValue$ = 648
finalCarry$ = 664
dataUnitNo$ = 672
block$ = 680
startBlock$ = 684
burnc$27512 = 688
burnm$27510 = 696
burnc$27521 = 704
burnm$27519 = 712
tv91 = 720
__$ArrayPad$ = 728
buffer$ = 752
length$ = 760
startDataUnitNo$ = 768
startCipherBlockNo$ = 776
ks$ = 784
ks2$ = 792
cipher$ = 800
DecryptBufferXTSParallel PROC				; COMDAT

; 545  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 02
	00 00		 sub	 rsp, 744		; 000002e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 546  : 	unsigned __int8 finalCarry;
; 547  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 548  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 549  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 550  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;

  0002d	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  00032	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 551  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0003a	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00042	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 552  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  0004a	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  00052	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 553  : 	unsigned __int64 *dataUnitBufPtr;
; 554  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0005a	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR startCipherBlockNo$[rsp]
  00061	89 84 24 ac 02
	00 00		 mov	 DWORD PTR startBlock$[rsp], eax

; 555  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;

  00068	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  00070	48 05 f8 01 00
	00		 add	 rax, 504		; 000001f8H
  00076	48 89 44 24 38	 mov	 QWORD PTR finalInt64WhiteningValuesPtr$[rsp], rax

; 556  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 557  : 
; 558  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 559  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 560  : 	dataUnitNo = startDataUnitNo->Value;

  0007b	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR startDataUnitNo$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 561  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  0008e	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00096	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 562  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0009e	48 c7 84 24 80
	02 00 00 00 00
	00 00		 mov	 QWORD PTR byteBufUnitNo$[rsp+8], 0

; 563  : 
; 564  : 	if (length % BYTES_PER_XTS_BLOCK)

  000aa	33 d2		 xor	 edx, edx
  000ac	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000b4	b9 10 00 00 00	 mov	 ecx, 16
  000b9	48 f7 f1	 div	 rcx
  000bc	48 85 d2	 test	 rdx, rdx
  000bf	74 1f		 je	 SHORT $LN27@DecryptBuf@3

; 565  : 		GST_THROW_FATAL_EXCEPTION;

  000c1	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  000ca	45 33 c9	 xor	 r9d, r9d
  000cd	45 33 c0	 xor	 r8d, r8d
  000d0	ba 35 02 00 00	 mov	 edx, 565		; 00000235H
  000d5	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN27@DecryptBuf@3:

; 566  : 
; 567  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000e0	33 d2		 xor	 edx, edx
  000e2	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000ea	b9 10 00 00 00	 mov	 ecx, 16
  000ef	48 f7 f1	 div	 rcx
  000f2	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax
$LN26@DecryptBuf@3:

; 568  : 
; 569  : 	// Process all blocks in the buffer
; 570  : 	while (blockCount > 0)

  000fa	48 83 bc 24 60
	02 00 00 00	 cmp	 QWORD PTR blockCount$[rsp], 0
  00103	0f 86 7d 04 00
	00		 jbe	 $LN25@DecryptBuf@3

; 571  : 	{
; 572  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00109	48 83 bc 24 60
	02 00 00 20	 cmp	 QWORD PTR blockCount$[rsp], 32 ; 00000020H
  00112	73 16		 jae	 SHORT $LN24@DecryptBuf@3

; 573  : 			endBlock = startBlock + (unsigned int) blockCount;

  00114	8b 8c 24 60 02
	00 00		 mov	 ecx, DWORD PTR blockCount$[rsp]
  0011b	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00122	03 c1		 add	 eax, ecx
  00124	89 44 24 30	 mov	 DWORD PTR endBlock$[rsp], eax

; 574  : 		else

  00128	eb 08		 jmp	 SHORT $LN23@DecryptBuf@3
$LN24@DecryptBuf@3:

; 575  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  0012a	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR endBlock$[rsp], 32 ; 00000020H
$LN23@DecryptBuf@3:

; 576  : 
; 577  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00132	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00137	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 578  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0013f	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00147	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 579  : 
; 580  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 581  : 		// whitening value for this data unit)
; 582  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0014f	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00157	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR byteBufUnitNo$[rsp]
  0015f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 583  : 		*(whiteningValuePtr64 + 1) = 0;

  00162	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0016a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 584  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00172	4c 8b 84 24 18
	03 00 00	 mov	 r8, QWORD PTR ks2$[rsp]
  0017a	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00182	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00189	e8 00 00 00 00	 call	 EncipherBlock

; 585  : 
; 586  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 587  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 588  : 		for (block = 0; block < endBlock; block++)

  0018e	c7 84 24 a8 02
	00 00 00 00 00
	00		 mov	 DWORD PTR block$[rsp], 0
  00199	eb 11		 jmp	 SHORT $LN22@DecryptBuf@3
$LN21@DecryptBuf@3:
  0019b	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  001a2	83 c0 01	 add	 eax, 1
  001a5	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN22@DecryptBuf@3:
  001ac	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  001b0	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001b7	0f 83 6f 01 00
	00		 jae	 $LN20@DecryptBuf@3

; 589  : 		{
; 590  : 			if (block >= startBlock)

  001bd	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  001c4	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001cb	72 6a		 jb	 SHORT $LN19@DecryptBuf@3

; 591  : 			{
; 592  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  001cd	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuesPtr64$[rsp]
  001d5	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e0	48 89 01	 mov	 QWORD PTR [rcx], rax
  001e3	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  001eb	48 83 e8 08	 sub	 rax, 8
  001ef	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  001f7	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001ff	48 83 c0 08	 add	 rax, 8
  00203	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 593  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  0020b	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuesPtr64$[rsp]
  00213	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0021b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0021e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00221	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  00229	48 83 e8 08	 sub	 rax, 8
  0022d	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 594  : 			}
; 595  : 			else

  00235	eb 14		 jmp	 SHORT $LN18@DecryptBuf@3
$LN19@DecryptBuf@3:

; 596  : 				whiteningValuePtr64++;

  00237	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0023f	48 83 c0 08	 add	 rax, 8
  00243	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
$LN18@DecryptBuf@3:

; 597  : 
; 598  : 			// Derive the next whitening value
; 599  : 
; 600  : #if BYTE_ORDER == LITTLE_ENDIAN
; 601  : 
; 602  : 			// Little-endian platforms
; 603  : 
; 604  : 			finalCarry = 
; 605  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 606  : 				135 : 0;

  0024b	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00253	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0025d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00260	48 23 c1	 and	 rax, rcx
  00263	48 85 c0	 test	 rax, rax
  00266	74 0d		 je	 SHORT $LN30@DecryptBuf@3
  00268	c7 84 24 d0 02
	00 00 87 00 00
	00		 mov	 DWORD PTR tv91[rsp], 135 ; 00000087H
  00273	eb 0b		 jmp	 SHORT $LN31@DecryptBuf@3
$LN30@DecryptBuf@3:
  00275	c7 84 24 d0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv91[rsp], 0
$LN31@DecryptBuf@3:
  00280	0f b6 84 24 d0
	02 00 00	 movzx	 eax, BYTE PTR tv91[rsp]
  00288	88 84 24 98 02
	00 00		 mov	 BYTE PTR finalCarry$[rsp], al

; 607  : 
; 608  : 			*whiteningValuePtr64-- <<= 1;

  0028f	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00297	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0029a	48 d1 e1	 shl	 rcx, 1
  0029d	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002a5	48 89 08	 mov	 QWORD PTR [rax], rcx
  002a8	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002b0	48 83 e8 08	 sub	 rax, 8
  002b4	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 609  : 
; 610  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002bc	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002c4	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d1	48 23 c1	 and	 rax, rcx
  002d4	48 85 c0	 test	 rax, rax
  002d7	74 1c		 je	 SHORT $LN17@DecryptBuf@3

; 611  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002d9	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002e1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  002e5	48 83 c9 01	 or	 rcx, 1
  002e9	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002f1	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN17@DecryptBuf@3:

; 612  : 
; 613  : 			*whiteningValuePtr64 <<= 1;

  002f5	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002fd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00300	48 d1 e1	 shl	 rcx, 1
  00303	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0030b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 614  : 
; 615  : #else
; 616  : 			// Big-endian platforms
; 617  : 
; 618  : 			finalCarry = 
; 619  : 				(*whiteningValuePtr64 & 0x80) ?
; 620  : 				135 : 0;
; 621  : 
; 622  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 623  : 
; 624  : 			whiteningValuePtr64--;
; 625  : 
; 626  : 			if (*whiteningValuePtr64 & 0x80)
; 627  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 628  : 
; 629  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 630  : #endif
; 631  : 
; 632  : 			whiteningValue[0] ^= finalCarry;

  0030e	0f b6 8c 24 98
	02 00 00	 movzx	 ecx, BYTE PTR finalCarry$[rsp]
  00316	0f b6 84 24 88
	02 00 00	 movzx	 eax, BYTE PTR whiteningValue$[rsp]
  0031e	33 c1		 xor	 eax, ecx
  00320	88 84 24 88 02
	00 00		 mov	 BYTE PTR whiteningValue$[rsp], al

; 633  : 		}

  00327	e9 6f fe ff ff	 jmp	 $LN21@DecryptBuf@3
$LN20@DecryptBuf@3:

; 634  : 
; 635  : 		dataUnitBufPtr = bufPtr;

  0032c	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00334	48 89 84 24 58
	02 00 00	 mov	 QWORD PTR dataUnitBufPtr$[rsp], rax

; 636  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0033c	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00341	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 637  : 
; 638  : 		// Decrypt blocks in this data unit
; 639  : 
; 640  : 		for (block = startBlock; block < endBlock; block++)

  00349	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00350	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
  00357	eb 11		 jmp	 SHORT $LN16@DecryptBuf@3
$LN15@DecryptBuf@3:
  00359	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00360	83 c0 01	 add	 eax, 1
  00363	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN16@DecryptBuf@3:
  0036a	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  0036e	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  00375	0f 83 9d 00 00
	00		 jae	 $LN14@DecryptBuf@3

; 641  : 		{
; 642  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0037b	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  00383	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  0038b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0038e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00391	48 33 c8	 xor	 rcx, rax
  00394	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0039c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0039f	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003a7	48 83 e8 08	 sub	 rax, 8
  003ab	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  003b3	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  003bb	48 83 c0 08	 add	 rax, 8
  003bf	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 643  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  003c7	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  003cf	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003d7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003da	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003dd	48 33 c8	 xor	 rcx, rax
  003e0	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  003e8	48 89 08	 mov	 QWORD PTR [rax], rcx
  003eb	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003f3	48 83 e8 08	 sub	 rax, 8
  003f7	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  003ff	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00407	48 83 c0 08	 add	 rax, 8
  0040b	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 644  : 		}

  00413	e9 41 ff ff ff	 jmp	 $LN15@DecryptBuf@3
$LN14@DecryptBuf@3:

; 645  : 
; 646  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00418	8b 8c 24 ac 02
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  0041f	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00423	2b c1		 sub	 eax, ecx
  00425	44 8b c8	 mov	 r9d, eax
  00428	4c 8b 84 24 10
	03 00 00	 mov	 r8, QWORD PTR ks$[rsp]
  00430	48 8b 94 24 58
	02 00 00	 mov	 rdx, QWORD PTR dataUnitBufPtr$[rsp]
  00438	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0043f	e8 00 00 00 00	 call	 DecipherBlocks

; 647  : 
; 648  : 		bufPtr = dataUnitBufPtr;

  00444	4c 8b 9c 24 58
	02 00 00	 mov	 r11, QWORD PTR dataUnitBufPtr$[rsp]
  0044c	4c 89 9c 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], r11

; 649  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00454	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00459	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 650  : 
; 651  : 		for (block = startBlock; block < endBlock; block++)

  00461	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00468	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
  0046f	eb 11		 jmp	 SHORT $LN13@DecryptBuf@3
$LN12@DecryptBuf@3:
  00471	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00478	83 c0 01	 add	 eax, 1
  0047b	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN13@DecryptBuf@3:
  00482	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00486	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  0048d	0f 83 9d 00 00
	00		 jae	 $LN11@DecryptBuf@3

; 652  : 		{
; 653  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00493	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0049b	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004a3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004a6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004a9	48 33 c8	 xor	 rcx, rax
  004ac	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  004b4	48 89 08	 mov	 QWORD PTR [rax], rcx
  004b7	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004bf	48 83 e8 08	 sub	 rax, 8
  004c3	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  004cb	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  004d3	48 83 c0 08	 add	 rax, 8
  004d7	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 654  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  004df	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  004e7	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004f5	48 33 c8	 xor	 rcx, rax
  004f8	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00500	48 89 08	 mov	 QWORD PTR [rax], rcx
  00503	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  0050b	48 83 e8 08	 sub	 rax, 8
  0050f	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  00517	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0051f	48 83 c0 08	 add	 rax, 8
  00523	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 655  : 		}

  0052b	e9 41 ff ff ff	 jmp	 $LN12@DecryptBuf@3
$LN11@DecryptBuf@3:

; 656  : 
; 657  : 		blockCount -= endBlock - startBlock;

  00530	8b 8c 24 ac 02
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  00537	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  0053b	2b c1		 sub	 eax, ecx
  0053d	8b c8		 mov	 ecx, eax
  0053f	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR blockCount$[rsp]
  00547	48 2b c1	 sub	 rax, rcx
  0054a	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax

; 658  : 		startBlock = 0;

  00552	c7 84 24 ac 02
	00 00 00 00 00
	00		 mov	 DWORD PTR startBlock$[rsp], 0

; 659  : 		dataUnitNo++;

  0055d	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00565	48 83 c0 01	 add	 rax, 1
  00569	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 660  : 
; 661  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00571	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00579	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 662  : 	}

  00581	e9 74 fb ff ff	 jmp	 $LN26@DecryptBuf@3
$LN25@DecryptBuf@3:
$LN10@DecryptBuf@3:

; 663  : 
; 664  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00586	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  0058e	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR burnm$27510[rsp], rax
  00596	c7 84 24 b0 02
	00 00 02 00 00
	00		 mov	 DWORD PTR burnc$27512[rsp], 2
$LN7@DecryptBuf@3:
  005a1	8b 8c 24 b0 02
	00 00		 mov	 ecx, DWORD PTR burnc$27512[rsp]
  005a8	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR burnc$27512[rsp]
  005af	83 e8 01	 sub	 eax, 1
  005b2	89 84 24 b0 02
	00 00		 mov	 DWORD PTR burnc$27512[rsp], eax
  005b9	85 c9		 test	 ecx, ecx
  005bb	74 25		 je	 SHORT $LN6@DecryptBuf@3
  005bd	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR burnm$27510[rsp]
  005c5	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  005cc	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR burnm$27510[rsp]
  005d4	48 83 c0 08	 add	 rax, 8
  005d8	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR burnm$27510[rsp], rax
  005e0	eb bf		 jmp	 SHORT $LN7@DecryptBuf@3
$LN6@DecryptBuf@3:
  005e2	33 c0		 xor	 eax, eax
  005e4	85 c0		 test	 eax, eax
  005e6	75 9e		 jne	 SHORT $LN10@DecryptBuf@3
$LN5@DecryptBuf@3:

; 665  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  005e8	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  005ed	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR burnm$27519[rsp], rax
  005f5	c7 84 24 c0 02
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27521[rsp], 64 ; 00000040H
$LN2@DecryptBuf@3:
  00600	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR burnc$27521[rsp]
  00607	8b 84 24 c0 02
	00 00		 mov	 eax, DWORD PTR burnc$27521[rsp]
  0060e	83 e8 01	 sub	 eax, 1
  00611	89 84 24 c0 02
	00 00		 mov	 DWORD PTR burnc$27521[rsp], eax
  00618	85 c9		 test	 ecx, ecx
  0061a	74 25		 je	 SHORT $LN1@DecryptBuf@3
  0061c	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR burnm$27519[rsp]
  00624	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  0062b	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR burnm$27519[rsp]
  00633	48 83 c0 08	 add	 rax, 8
  00637	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR burnm$27519[rsp], rax
  0063f	eb bf		 jmp	 SHORT $LN2@DecryptBuf@3
$LN1@DecryptBuf@3:
  00641	33 c0		 xor	 eax, eax
  00643	85 c0		 test	 eax, eax
  00645	75 a1		 jne	 SHORT $LN5@DecryptBuf@3
$LN29@DecryptBuf@3:

; 666  : }

  00647	48 8b 8c 24 d8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0064f	48 33 cc	 xor	 rcx, rsp
  00652	e8 00 00 00 00	 call	 __security_check_cookie
  00657	48 81 c4 e8 02
	00 00		 add	 rsp, 744		; 000002e8H
  0065e	c3		 ret	 0
DecryptBufferXTSParallel ENDP
_TEXT	ENDS
PUBLIC	DecryptBufferXTS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBufferXTS DD imagerel $LN5
	DD	imagerel $LN5+159
	DD	imagerel $unwind$DecryptBufferXTS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTS DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecryptBufferXTS
_TEXT	SEGMENT
buffer$ = 80
length$ = 88
startDataUnitNo$ = 96
startCipherBlockNo$ = 104
ks$ = 112
ks2$ = 120
cipher$ = 128
DecryptBufferXTS PROC					; COMDAT

; 428  : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 429  : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00018	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0001f	e8 00 00 00 00	 call	 CipherSupportsIntraDataUnitParallelization
  00024	85 c0		 test	 eax, eax
  00026	74 3a		 je	 SHORT $LN2@DecryptBuf@4

; 430  : 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00028	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR cipher$[rsp]
  0002f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00033	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00038	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003d	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	44 8b 4c 24 68	 mov	 r9d, DWORD PTR startCipherBlockNo$[rsp]
  0004c	4c 8b 44 24 60	 mov	 r8, QWORD PTR startDataUnitNo$[rsp]
  00051	48 8b 54 24 58	 mov	 rdx, QWORD PTR length$[rsp]
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buffer$[rsp]
  0005b	e8 00 00 00 00	 call	 DecryptBufferXTSParallel

; 431  : 	else

  00060	eb 38		 jmp	 SHORT $LN1@DecryptBuf@4
$LN2@DecryptBuf@4:

; 432  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00062	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR cipher$[rsp]
  00069	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0006d	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00072	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00077	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	44 8b 4c 24 68	 mov	 r9d, DWORD PTR startCipherBlockNo$[rsp]
  00086	4c 8b 44 24 60	 mov	 r8, QWORD PTR startDataUnitNo$[rsp]
  0008b	48 8b 54 24 58	 mov	 rdx, QWORD PTR length$[rsp]
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buffer$[rsp]
  00095	e8 00 00 00 00	 call	 DecryptBufferXTSNonParallel
$LN1@DecryptBuf@4:

; 433  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
DecryptBufferXTS ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferXTSParallel DD imagerel EncryptBufferXTSParallel
	DD	imagerel EncryptBufferXTSParallel+1631
	DD	imagerel $unwind$EncryptBufferXTSParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTSParallel DD 022d19H
	DD	05d011bH
	DD	imagerel __GSHandlerCheck
	DD	02d8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptBufferXTSParallel
_TEXT	SEGMENT
endBlock$ = 48
finalInt64WhiteningValuesPtr$ = 56
whiteningValues$ = 80
bufPtr$ = 592
dataUnitBufPtr$ = 600
blockCount$ = 608
whiteningValuePtr64$ = 616
whiteningValuesPtr64$ = 624
byteBufUnitNo$ = 632
whiteningValue$ = 648
finalCarry$ = 664
dataUnitNo$ = 672
block$ = 680
startBlock$ = 684
burnc$27306 = 688
burnm$27304 = 696
burnc$27315 = 704
burnm$27313 = 712
tv91 = 720
__$ArrayPad$ = 728
buffer$ = 752
length$ = 760
startDataUnitNo$ = 768
startCipherBlockNo$ = 776
ks$ = 784
ks2$ = 792
cipher$ = 800
EncryptBufferXTSParallel PROC				; COMDAT

; 169  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 02
	00 00		 sub	 rsp, 744		; 000002e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 170  : 	unsigned __int8 finalCarry;
; 171  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 172  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 173  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 174  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;

  0002d	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  00032	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 175  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0003a	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00042	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 176  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  0004a	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  00052	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 177  : 	unsigned __int64 *dataUnitBufPtr;
; 178  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0005a	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR startCipherBlockNo$[rsp]
  00061	89 84 24 ac 02
	00 00		 mov	 DWORD PTR startBlock$[rsp], eax

; 179  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;

  00068	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  00070	48 05 f8 01 00
	00		 add	 rax, 504		; 000001f8H
  00076	48 89 44 24 38	 mov	 QWORD PTR finalInt64WhiteningValuesPtr$[rsp], rax

; 180  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 181  : 
; 182  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 183  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 184  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 185  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 186  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 187  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 188  : 
; 189  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 190  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 191  : 	dataUnitNo = startDataUnitNo->Value;

  0007b	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR startDataUnitNo$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 192  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  0008e	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00096	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 193  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0009e	48 c7 84 24 80
	02 00 00 00 00
	00 00		 mov	 QWORD PTR byteBufUnitNo$[rsp+8], 0

; 194  : 
; 195  : 	if (length % BYTES_PER_XTS_BLOCK)

  000aa	33 d2		 xor	 edx, edx
  000ac	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000b4	b9 10 00 00 00	 mov	 ecx, 16
  000b9	48 f7 f1	 div	 rcx
  000bc	48 85 d2	 test	 rdx, rdx
  000bf	74 1f		 je	 SHORT $LN27@EncryptBuf@3

; 196  : 		GST_THROW_FATAL_EXCEPTION;

  000c1	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  000ca	45 33 c9	 xor	 r9d, r9d
  000cd	45 33 c0	 xor	 r8d, r8d
  000d0	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  000d5	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN27@EncryptBuf@3:

; 197  : 
; 198  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000e0	33 d2		 xor	 edx, edx
  000e2	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000ea	b9 10 00 00 00	 mov	 ecx, 16
  000ef	48 f7 f1	 div	 rcx
  000f2	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax
$LN26@EncryptBuf@3:

; 199  : 
; 200  : 	// Process all blocks in the buffer
; 201  : 	while (blockCount > 0)

  000fa	48 83 bc 24 60
	02 00 00 00	 cmp	 QWORD PTR blockCount$[rsp], 0
  00103	0f 86 7d 04 00
	00		 jbe	 $LN25@EncryptBuf@3

; 202  : 	{
; 203  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00109	48 83 bc 24 60
	02 00 00 20	 cmp	 QWORD PTR blockCount$[rsp], 32 ; 00000020H
  00112	73 16		 jae	 SHORT $LN24@EncryptBuf@3

; 204  : 			endBlock = startBlock + (unsigned int) blockCount;

  00114	8b 8c 24 60 02
	00 00		 mov	 ecx, DWORD PTR blockCount$[rsp]
  0011b	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00122	03 c1		 add	 eax, ecx
  00124	89 44 24 30	 mov	 DWORD PTR endBlock$[rsp], eax

; 205  : 		else

  00128	eb 08		 jmp	 SHORT $LN23@EncryptBuf@3
$LN24@EncryptBuf@3:

; 206  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  0012a	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR endBlock$[rsp], 32 ; 00000020H
$LN23@EncryptBuf@3:

; 207  : 
; 208  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00132	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00137	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 209  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0013f	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00147	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 210  : 
; 211  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 212  : 		// whitening value for this data unit)
; 213  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0014f	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00157	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR byteBufUnitNo$[rsp]
  0015f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 214  : 		*(whiteningValuePtr64 + 1) = 0;

  00162	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0016a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 215  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00172	4c 8b 84 24 18
	03 00 00	 mov	 r8, QWORD PTR ks2$[rsp]
  0017a	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00182	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00189	e8 00 00 00 00	 call	 EncipherBlock

; 216  : 
; 217  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 218  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 219  : 		for (block = 0; block < endBlock; block++)

  0018e	c7 84 24 a8 02
	00 00 00 00 00
	00		 mov	 DWORD PTR block$[rsp], 0
  00199	eb 11		 jmp	 SHORT $LN22@EncryptBuf@3
$LN21@EncryptBuf@3:
  0019b	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  001a2	83 c0 01	 add	 eax, 1
  001a5	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN22@EncryptBuf@3:
  001ac	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  001b0	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001b7	0f 83 6f 01 00
	00		 jae	 $LN20@EncryptBuf@3

; 220  : 		{
; 221  : 			if (block >= startBlock)

  001bd	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  001c4	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001cb	72 6a		 jb	 SHORT $LN19@EncryptBuf@3

; 222  : 			{
; 223  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  001cd	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuesPtr64$[rsp]
  001d5	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e0	48 89 01	 mov	 QWORD PTR [rcx], rax
  001e3	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  001eb	48 83 e8 08	 sub	 rax, 8
  001ef	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  001f7	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001ff	48 83 c0 08	 add	 rax, 8
  00203	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 224  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  0020b	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuesPtr64$[rsp]
  00213	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0021b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0021e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00221	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  00229	48 83 e8 08	 sub	 rax, 8
  0022d	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 225  : 			}
; 226  : 			else

  00235	eb 14		 jmp	 SHORT $LN18@EncryptBuf@3
$LN19@EncryptBuf@3:

; 227  : 				whiteningValuePtr64++;

  00237	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0023f	48 83 c0 08	 add	 rax, 8
  00243	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
$LN18@EncryptBuf@3:

; 228  : 
; 229  : 			// Derive the next whitening value
; 230  : 
; 231  : #if BYTE_ORDER == LITTLE_ENDIAN
; 232  : 
; 233  : 			// Little-endian platforms
; 234  : 
; 235  : 			finalCarry = 
; 236  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 237  : 				135 : 0;

  0024b	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00253	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0025d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00260	48 23 c1	 and	 rax, rcx
  00263	48 85 c0	 test	 rax, rax
  00266	74 0d		 je	 SHORT $LN30@EncryptBuf@3
  00268	c7 84 24 d0 02
	00 00 87 00 00
	00		 mov	 DWORD PTR tv91[rsp], 135 ; 00000087H
  00273	eb 0b		 jmp	 SHORT $LN31@EncryptBuf@3
$LN30@EncryptBuf@3:
  00275	c7 84 24 d0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv91[rsp], 0
$LN31@EncryptBuf@3:
  00280	0f b6 84 24 d0
	02 00 00	 movzx	 eax, BYTE PTR tv91[rsp]
  00288	88 84 24 98 02
	00 00		 mov	 BYTE PTR finalCarry$[rsp], al

; 238  : 
; 239  : 			*whiteningValuePtr64-- <<= 1;

  0028f	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00297	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0029a	48 d1 e1	 shl	 rcx, 1
  0029d	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002a5	48 89 08	 mov	 QWORD PTR [rax], rcx
  002a8	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002b0	48 83 e8 08	 sub	 rax, 8
  002b4	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 240  : 
; 241  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002bc	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002c4	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d1	48 23 c1	 and	 rax, rcx
  002d4	48 85 c0	 test	 rax, rax
  002d7	74 1c		 je	 SHORT $LN17@EncryptBuf@3

; 242  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002d9	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002e1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  002e5	48 83 c9 01	 or	 rcx, 1
  002e9	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002f1	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN17@EncryptBuf@3:

; 243  : 
; 244  : 			*whiteningValuePtr64 <<= 1;

  002f5	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002fd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00300	48 d1 e1	 shl	 rcx, 1
  00303	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0030b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 245  : #else
; 246  : 
; 247  : 			// Big-endian platforms
; 248  : 
; 249  : 			finalCarry = 
; 250  : 				(*whiteningValuePtr64 & 0x80) ?
; 251  : 				135 : 0;
; 252  : 
; 253  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 254  : 
; 255  : 			whiteningValuePtr64--;
; 256  : 
; 257  : 			if (*whiteningValuePtr64 & 0x80)
; 258  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 259  : 
; 260  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 261  : #endif
; 262  : 
; 263  : 			whiteningValue[0] ^= finalCarry;

  0030e	0f b6 8c 24 98
	02 00 00	 movzx	 ecx, BYTE PTR finalCarry$[rsp]
  00316	0f b6 84 24 88
	02 00 00	 movzx	 eax, BYTE PTR whiteningValue$[rsp]
  0031e	33 c1		 xor	 eax, ecx
  00320	88 84 24 88 02
	00 00		 mov	 BYTE PTR whiteningValue$[rsp], al

; 264  : 		}

  00327	e9 6f fe ff ff	 jmp	 $LN21@EncryptBuf@3
$LN20@EncryptBuf@3:

; 265  : 
; 266  : 		dataUnitBufPtr = bufPtr;

  0032c	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00334	48 89 84 24 58
	02 00 00	 mov	 QWORD PTR dataUnitBufPtr$[rsp], rax

; 267  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0033c	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00341	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 268  : 
; 269  : 		// Encrypt all blocks in this data unit
; 270  : 
; 271  : 		for (block = startBlock; block < endBlock; block++)

  00349	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00350	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
  00357	eb 11		 jmp	 SHORT $LN16@EncryptBuf@3
$LN15@EncryptBuf@3:
  00359	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00360	83 c0 01	 add	 eax, 1
  00363	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN16@EncryptBuf@3:
  0036a	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  0036e	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  00375	0f 83 9d 00 00
	00		 jae	 $LN14@EncryptBuf@3

; 272  : 		{
; 273  : 			// Pre-whitening
; 274  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0037b	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  00383	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  0038b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0038e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00391	48 33 c8	 xor	 rcx, rax
  00394	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0039c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0039f	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003a7	48 83 e8 08	 sub	 rax, 8
  003ab	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  003b3	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  003bb	48 83 c0 08	 add	 rax, 8
  003bf	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 275  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  003c7	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  003cf	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003d7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003da	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003dd	48 33 c8	 xor	 rcx, rax
  003e0	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  003e8	48 89 08	 mov	 QWORD PTR [rax], rcx
  003eb	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003f3	48 83 e8 08	 sub	 rax, 8
  003f7	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  003ff	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00407	48 83 c0 08	 add	 rax, 8
  0040b	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 276  : 		}

  00413	e9 41 ff ff ff	 jmp	 $LN15@EncryptBuf@3
$LN14@EncryptBuf@3:

; 277  : 
; 278  : 		// Actual encryption
; 279  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00418	8b 8c 24 ac 02
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  0041f	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00423	2b c1		 sub	 eax, ecx
  00425	44 8b c8	 mov	 r9d, eax
  00428	4c 8b 84 24 10
	03 00 00	 mov	 r8, QWORD PTR ks$[rsp]
  00430	48 8b 94 24 58
	02 00 00	 mov	 rdx, QWORD PTR dataUnitBufPtr$[rsp]
  00438	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0043f	e8 00 00 00 00	 call	 EncipherBlocks

; 280  : 		
; 281  : 		bufPtr = dataUnitBufPtr;

  00444	4c 8b 9c 24 58
	02 00 00	 mov	 r11, QWORD PTR dataUnitBufPtr$[rsp]
  0044c	4c 89 9c 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], r11

; 282  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00454	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00459	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 283  : 
; 284  : 		for (block = startBlock; block < endBlock; block++)

  00461	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00468	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
  0046f	eb 11		 jmp	 SHORT $LN13@EncryptBuf@3
$LN12@EncryptBuf@3:
  00471	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00478	83 c0 01	 add	 eax, 1
  0047b	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN13@EncryptBuf@3:
  00482	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00486	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  0048d	0f 83 9d 00 00
	00		 jae	 $LN11@EncryptBuf@3

; 285  : 		{
; 286  : 			// Post-whitening
; 287  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00493	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0049b	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004a3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004a6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004a9	48 33 c8	 xor	 rcx, rax
  004ac	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  004b4	48 89 08	 mov	 QWORD PTR [rax], rcx
  004b7	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004bf	48 83 e8 08	 sub	 rax, 8
  004c3	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  004cb	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  004d3	48 83 c0 08	 add	 rax, 8
  004d7	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 288  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  004df	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  004e7	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004f5	48 33 c8	 xor	 rcx, rax
  004f8	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00500	48 89 08	 mov	 QWORD PTR [rax], rcx
  00503	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  0050b	48 83 e8 08	 sub	 rax, 8
  0050f	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  00517	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0051f	48 83 c0 08	 add	 rax, 8
  00523	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 289  : 		}

  0052b	e9 41 ff ff ff	 jmp	 $LN12@EncryptBuf@3
$LN11@EncryptBuf@3:

; 290  : 
; 291  : 		blockCount -= endBlock - startBlock;

  00530	8b 8c 24 ac 02
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  00537	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  0053b	2b c1		 sub	 eax, ecx
  0053d	8b c8		 mov	 ecx, eax
  0053f	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR blockCount$[rsp]
  00547	48 2b c1	 sub	 rax, rcx
  0054a	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax

; 292  : 		startBlock = 0;

  00552	c7 84 24 ac 02
	00 00 00 00 00
	00		 mov	 DWORD PTR startBlock$[rsp], 0

; 293  : 		dataUnitNo++;

  0055d	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00565	48 83 c0 01	 add	 rax, 1
  00569	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 294  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00571	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00579	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 295  : 	}

  00581	e9 74 fb ff ff	 jmp	 $LN26@EncryptBuf@3
$LN25@EncryptBuf@3:
$LN10@EncryptBuf@3:

; 296  : 
; 297  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00586	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  0058e	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR burnm$27304[rsp], rax
  00596	c7 84 24 b0 02
	00 00 02 00 00
	00		 mov	 DWORD PTR burnc$27306[rsp], 2
$LN7@EncryptBuf@3:
  005a1	8b 8c 24 b0 02
	00 00		 mov	 ecx, DWORD PTR burnc$27306[rsp]
  005a8	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR burnc$27306[rsp]
  005af	83 e8 01	 sub	 eax, 1
  005b2	89 84 24 b0 02
	00 00		 mov	 DWORD PTR burnc$27306[rsp], eax
  005b9	85 c9		 test	 ecx, ecx
  005bb	74 25		 je	 SHORT $LN6@EncryptBuf@3
  005bd	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR burnm$27304[rsp]
  005c5	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  005cc	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR burnm$27304[rsp]
  005d4	48 83 c0 08	 add	 rax, 8
  005d8	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR burnm$27304[rsp], rax
  005e0	eb bf		 jmp	 SHORT $LN7@EncryptBuf@3
$LN6@EncryptBuf@3:
  005e2	33 c0		 xor	 eax, eax
  005e4	85 c0		 test	 eax, eax
  005e6	75 9e		 jne	 SHORT $LN10@EncryptBuf@3
$LN5@EncryptBuf@3:

; 298  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  005e8	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  005ed	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR burnm$27313[rsp], rax
  005f5	c7 84 24 c0 02
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27315[rsp], 64 ; 00000040H
$LN2@EncryptBuf@3:
  00600	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR burnc$27315[rsp]
  00607	8b 84 24 c0 02
	00 00		 mov	 eax, DWORD PTR burnc$27315[rsp]
  0060e	83 e8 01	 sub	 eax, 1
  00611	89 84 24 c0 02
	00 00		 mov	 DWORD PTR burnc$27315[rsp], eax
  00618	85 c9		 test	 ecx, ecx
  0061a	74 25		 je	 SHORT $LN1@EncryptBuf@3
  0061c	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR burnm$27313[rsp]
  00624	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  0062b	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR burnm$27313[rsp]
  00633	48 83 c0 08	 add	 rax, 8
  00637	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR burnm$27313[rsp], rax
  0063f	eb bf		 jmp	 SHORT $LN2@EncryptBuf@3
$LN1@EncryptBuf@3:
  00641	33 c0		 xor	 eax, eax
  00643	85 c0		 test	 eax, eax
  00645	75 a1		 jne	 SHORT $LN5@EncryptBuf@3
$LN29@EncryptBuf@3:

; 299  : }

  00647	48 8b 8c 24 d8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0064f	48 33 cc	 xor	 rcx, rsp
  00652	e8 00 00 00 00	 call	 __security_check_cookie
  00657	48 81 c4 e8 02
	00 00		 add	 rsp, 744		; 000002e8H
  0065e	c3		 ret	 0
EncryptBufferXTSParallel ENDP
_TEXT	ENDS
PUBLIC	EncryptBufferXTS
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferXTS DD imagerel $LN5
	DD	imagerel $LN5+159
	DD	imagerel $unwind$EncryptBufferXTS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTS DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptBufferXTS
_TEXT	SEGMENT
buffer$ = 80
length$ = 88
startDataUnitNo$ = 96
startCipherBlockNo$ = 104
ks$ = 112
ks2$ = 120
cipher$ = 128
EncryptBufferXTS PROC					; COMDAT

; 56   : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 57   : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00018	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0001f	e8 00 00 00 00	 call	 CipherSupportsIntraDataUnitParallelization
  00024	85 c0		 test	 eax, eax
  00026	74 3a		 je	 SHORT $LN2@EncryptBuf@4

; 58   : 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00028	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR cipher$[rsp]
  0002f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00033	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00038	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003d	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	44 8b 4c 24 68	 mov	 r9d, DWORD PTR startCipherBlockNo$[rsp]
  0004c	4c 8b 44 24 60	 mov	 r8, QWORD PTR startDataUnitNo$[rsp]
  00051	48 8b 54 24 58	 mov	 rdx, QWORD PTR length$[rsp]
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buffer$[rsp]
  0005b	e8 00 00 00 00	 call	 EncryptBufferXTSParallel

; 59   : 	else

  00060	eb 38		 jmp	 SHORT $LN1@EncryptBuf@4
$LN2@EncryptBuf@4:

; 60   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00062	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR cipher$[rsp]
  00069	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0006d	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00072	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00077	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	44 8b 4c 24 68	 mov	 r9d, DWORD PTR startCipherBlockNo$[rsp]
  00086	4c 8b 44 24 60	 mov	 r8, QWORD PTR startDataUnitNo$[rsp]
  0008b	48 8b 54 24 58	 mov	 rdx, QWORD PTR length$[rsp]
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buffer$[rsp]
  00095	e8 00 00 00 00	 call	 EncryptBufferXTSNonParallel
$LN1@EncryptBuf@4:

; 61   : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
EncryptBufferXTS ENDP
END
