; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ReadVolumeHeaderRecoveryMode
ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
PUBLIC	GetHeaderField64
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\volumes.c
pdata	SEGMENT
$pdata$GetHeaderField64 DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$GetHeaderField64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetHeaderField64 DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetHeaderField64
_TEXT	SEGMENT
uint64Struct$ = 32
header$ = 64
offset$ = 72
GetHeaderField64 PROC					; COMDAT

; 173  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 174  : 	UINT64_STRUCT uint64Struct;
; 175  : 
; 176  : #ifndef GST_NO_COMPILER_INT64
; 177  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  0000d	48 63 44 24 48	 movsxd	 rax, DWORD PTR offset$[rsp]
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR header$[rsp]
  00017	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0001b	e8 00 00 00 00	 call	 MirrorBytes64
  00020	48 89 44 24 20	 mov	 QWORD PTR uint64Struct$[rsp], rax

; 178  : #else
; 179  : 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; 180  : 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; 181  : #endif
; 182  : 	return uint64Struct;

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR uint64Struct$[rsp]

; 183  : }

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
GetHeaderField64 ENDP
_TEXT	ENDS
PUBLIC	GetHeaderField32
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetHeaderField32 DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$GetHeaderField32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetHeaderField32 DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetHeaderField32
_TEXT	SEGMENT
header$ = 48
offset$ = 56
GetHeaderField32 PROC					; COMDAT

; 158  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 159  : 	return BE32 (*(uint32 *) (header + offset));

  0000d	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR offset$[rsp]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR header$[rsp]
  00017	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]
  0001a	e8 00 00 00 00	 call	 MirrorBytes32

; 160  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
GetHeaderField32 ENDP
_TEXT	ENDS
PUBLIC	GetHeaderField16
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetHeaderField16 DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$GetHeaderField16
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetHeaderField16 DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetHeaderField16
_TEXT	SEGMENT
header$ = 48
offset$ = 56
GetHeaderField16 PROC					; COMDAT

; 143  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 144  : 	return BE16 (*(uint16 *) (header + offset));

  0000d	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR offset$[rsp]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR header$[rsp]
  00017	0f b7 0c 08	 movzx	 ecx, WORD PTR [rax+rcx]
  0001b	e8 00 00 00 00	 call	 MirrorBytes16

; 145  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
GetHeaderField16 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	ReadVolumeHeader
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadVolumeHeader DD imagerel $LN91
	DD	imagerel $LN91+3714
	DD	imagerel $unwind$ReadVolumeHeader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadVolumeHeader DD 052f19H
	DD	0bc011dH
	DD	060157016H
	DD	03014H
	DD	imagerel __GSHandlerCheck
	DD	05d0H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReadVolumeHeader
_TEXT	SEGMENT
cryptoInfo$ = 80
dk$ = 96
i$ = 352
noOutstandingWorkItemEvent$ = 360
headerVersion$ = 384
encryptionThreadCount$ = 392
primaryKeyOffset$ = 400
keyDerivationCompletedEvent$ = 408
keyInfo$ = 432
keyDerivationWorkItems$ = 832
outstandingWorkItemCount$ = 840
queuedWorkItems$ = 848
enqPkcs5Prf$ = 856
status$ = 860
pkcs5PrfCount$ = 864
pkcs5_prf$ = 868
item$ = 872
header$ = 880
blockSize$28357 = 1392
burnc$28395 = 1396
burnm$28393 = 1400
burnc$28404 = 1408
burnm$28402 = 1416
burnc$28415 = 1424
burnm$28413 = 1432
$T37997 = 1440
$T37998 = 1448
$T37999 = 1456
tv199 = 1464
tv240 = 1468
tv325 = 1472
tv386 = 1476
tv463 = 1480
__$ArrayPad$ = 1488
bBoot$ = 1536
encryptedHeader$ = 1544
password$ = 1552
retInfo$ = 1560
retHeaderCryptoInfo$ = 1568
ReadVolumeHeader PROC					; COMDAT

; 212  : {

$LN91:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	53		 push	 rbx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec e0 05
	00 00		 sub	 rsp, 1504		; 000005e0H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 d0
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 213  : 	char header[GST_VOLUME_HEADER_EFFECTIVE_SIZE];
; 214  : 	KEY_INFO keyInfo;
; 215  : 	PCRYPTO_INFO cryptoInfo;
; 216  : 	char dk[MASTER_KEYDATA_SIZE];
; 217  : 	int enqPkcs5Prf, pkcs5_prf;
; 218  : 	uint16 headerVersion;
; 219  : 	int status = ERR_PARAMETER_INCORRECT;

  0002f	c7 84 24 5c 03
	00 00 1e 00 00
	00		 mov	 DWORD PTR status$[rsp], 30

; 220  : 	int primaryKeyOffset;
; 221  : 
; 222  : 	GST_EVENT keyDerivationCompletedEvent;
; 223  : 	GST_EVENT noOutstandingWorkItemEvent;
; 224  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 225  : 	KeyDerivationWorkItem *item;
; 226  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;

  0003a	c7 84 24 60 03
	00 00 03 00 00
	00		 mov	 DWORD PTR pkcs5PrfCount$[rsp], 3

; 227  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  00045	e8 00 00 00 00	 call	 GetEncryptionThreadCount
  0004a	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR encryptionThreadCount$[rsp], rax

; 228  : 	size_t queuedWorkItems = 0;

  00052	48 c7 84 24 50
	03 00 00 00 00
	00 00		 mov	 QWORD PTR queuedWorkItems$[rsp], 0

; 229  : 	LONG outstandingWorkItemCount = 0;

  0005e	c7 84 24 48 03
	00 00 00 00 00
	00		 mov	 DWORD PTR outstandingWorkItemCount$[rsp], 0

; 230  : 	int i;
; 231  : 
; 232  : 	if (retHeaderCryptoInfo != NULL)

  00069	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR retHeaderCryptoInfo$[rsp], 0
  00072	74 0f		 je	 SHORT $LN84@ReadVolume

; 233  : 	{
; 234  : 		cryptoInfo = retHeaderCryptoInfo;

  00074	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR retHeaderCryptoInfo$[rsp]
  0007c	48 89 44 24 50	 mov	 QWORD PTR cryptoInfo$[rsp], rax

; 235  : 	}
; 236  : 	else

  00081	eb 35		 jmp	 SHORT $LN83@ReadVolume
$LN84@ReadVolume:

; 237  : 	{
; 238  : 		cryptoInfo = *retInfo = crypto_open ();

  00083	e8 00 00 00 00	 call	 crypto_open
  00088	48 8b d0	 mov	 rdx, rax
  0008b	48 8b 84 24 18
	06 00 00	 mov	 rax, QWORD PTR retInfo$[rsp]
  00093	48 89 10	 mov	 QWORD PTR [rax], rdx
  00096	48 8b 84 24 18
	06 00 00	 mov	 rax, QWORD PTR retInfo$[rsp]
  0009e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a1	48 89 44 24 50	 mov	 QWORD PTR cryptoInfo$[rsp], rax

; 239  : 		if (cryptoInfo == NULL)

  000a6	48 83 7c 24 50
	00		 cmp	 QWORD PTR cryptoInfo$[rsp], 0
  000ac	75 0a		 jne	 SHORT $LN82@ReadVolume

; 240  : 			return ERR_OUTOFMEMORY;

  000ae	b8 02 00 00 00	 mov	 eax, 2
  000b3	e9 af 0d 00 00	 jmp	 $LN85@ReadVolume
$LN82@ReadVolume:
$LN83@ReadVolume:

; 241  : 	}
; 242  : 
; 243  : 	if (encryptionThreadCount > 1)

  000b8	48 83 bc 24 88
	01 00 00 01	 cmp	 QWORD PTR encryptionThreadCount$[rsp], 1
  000c1	0f 86 b8 00 00
	00		 jbe	 $LN81@ReadVolume

; 244  : 	{
; 245  : 		keyDerivationWorkItems = GSTalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  000c7	48 63 94 24 60
	03 00 00	 movsxd	 rdx, DWORD PTR pkcs5PrfCount$[rsp]
  000cf	48 69 d2 0c 01
	00 00		 imul	 rdx, 268		; 0000010cH
  000d6	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000dc	33 c9		 xor	 ecx, ecx
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000e4	48 89 84 24 40
	03 00 00	 mov	 QWORD PTR keyDerivationWorkItems$[rsp], rax

; 246  : 		if (!keyDerivationWorkItems)

  000ec	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR keyDerivationWorkItems$[rsp], 0
  000f5	75 0a		 jne	 SHORT $LN80@ReadVolume

; 247  : 			return ERR_OUTOFMEMORY;

  000f7	b8 02 00 00 00	 mov	 eax, 2
  000fc	e9 66 0d 00 00	 jmp	 $LN85@ReadVolume
$LN80@ReadVolume:

; 248  : 
; 249  : 		for (i = 0; i < pkcs5PrfCount; ++i)

  00101	c7 84 24 60 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0010c	eb 11		 jmp	 SHORT $LN79@ReadVolume
$LN78@ReadVolume:
  0010e	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 84 24 60 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN79@ReadVolume:
  0011f	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR pkcs5PrfCount$[rsp]
  00126	39 84 24 60 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  0012d	7d 24		 jge	 SHORT $LN77@ReadVolume

; 250  : 			keyDerivationWorkItems[i].Free = TRUE;

  0012f	48 63 8c 24 60
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00137	48 69 c9 0c 01
	00 00		 imul	 rcx, 268		; 0000010cH
  0013e	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR keyDerivationWorkItems$[rsp]
  00146	c7 84 08 00 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx+256], 1
  00151	eb bb		 jmp	 SHORT $LN78@ReadVolume
$LN77@ReadVolume:

; 251  : 
; 252  : #ifdef DEVICE_DRIVER
; 253  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);

  00153	45 33 c0	 xor	 r8d, r8d
  00156	ba 01 00 00 00	 mov	 edx, 1
  0015b	48 8d 8c 24 98
	01 00 00	 lea	 rcx, QWORD PTR keyDerivationCompletedEvent$[rsp]
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 254  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);

  00169	41 b0 01	 mov	 r8b, 1
  0016c	ba 01 00 00 00	 mov	 edx, 1
  00171	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent
$LN81@ReadVolume:

; 255  : #else
; 256  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 257  : 		if (!keyDerivationCompletedEvent)
; 258  : 		{
; 259  : 			GSTfree (keyDerivationWorkItems);
; 260  : 			return ERR_OUTOFMEMORY;
; 261  : 		}
; 262  : 
; 263  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);
; 264  : 		if (!noOutstandingWorkItemEvent)
; 265  : 		{
; 266  : 			CloseHandle (keyDerivationCompletedEvent);
; 267  : 			GSTfree (keyDerivationWorkItems);
; 268  : 			return ERR_OUTOFMEMORY;
; 269  : 		}
; 270  : #endif
; 271  : 	}
; 272  : 		
; 273  : #ifndef DEVICE_DRIVER
; 274  : 	VirtualLock (&keyInfo, sizeof (keyInfo));
; 275  : 	VirtualLock (&dk, sizeof (dk));
; 276  : #endif
; 277  : 
; 278  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  0017f	48 8b 94 24 10
	06 00 00	 mov	 rdx, QWORD PTR password$[rsp]
  00187	48 83 c2 04	 add	 rdx, 4
  0018b	48 8b 84 24 10
	06 00 00	 mov	 rax, QWORD PTR password$[rsp]
  00193	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00196	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp]
  0019e	e8 00 00 00 00	 call	 crypto_loadkey

; 279  : 
; 280  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 281  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  001a3	48 8d bc 24 f8
	01 00 00	 lea	 rdi, QWORD PTR keyInfo$[rsp+72]
  001ab	48 8b b4 24 08
	06 00 00	 mov	 rsi, QWORD PTR encryptedHeader$[rsp]
  001b3	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001b8	f3 a4		 rep movsb

; 282  : 
; 283  : 	// Test all available PKCS5 PRFs
; 284  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  001ba	c7 84 24 58 03
	00 00 01 00 00
	00		 mov	 DWORD PTR enqPkcs5Prf$[rsp], 1
  001c5	eb 11		 jmp	 SHORT $LN76@ReadVolume
$LN75@ReadVolume:
  001c7	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR enqPkcs5Prf$[rsp]
  001ce	83 c0 01	 add	 eax, 1
  001d1	89 84 24 58 03
	00 00		 mov	 DWORD PTR enqPkcs5Prf$[rsp], eax
$LN76@ReadVolume:
  001d8	83 bc 24 58 03
	00 00 03	 cmp	 DWORD PTR enqPkcs5Prf$[rsp], 3
  001e0	7e 0f		 jle	 SHORT $LN73@ReadVolume
  001e2	48 83 bc 24 50
	03 00 00 00	 cmp	 QWORD PTR queuedWorkItems$[rsp], 0
  001eb	0f 86 98 0a 00
	00		 jbe	 $LN74@ReadVolume
$LN73@ReadVolume:

; 285  : 	{
; 286  : 
; 287  : 		if (encryptionThreadCount > 1)

  001f1	48 83 bc 24 88
	01 00 00 01	 cmp	 QWORD PTR encryptionThreadCount$[rsp], 1
  001fa	0f 86 c1 02 00
	00		 jbe	 $LN72@ReadVolume

; 288  : 		{
; 289  : 			// Enqueue key derivation on thread pool
; 290  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  00200	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR encryptionThreadCount$[rsp]
  00208	48 39 84 24 50
	03 00 00	 cmp	 QWORD PTR queuedWorkItems$[rsp], rax
  00210	0f 83 5e 01 00
	00		 jae	 $LN71@ReadVolume
  00216	83 bc 24 58 03
	00 00 03	 cmp	 DWORD PTR enqPkcs5Prf$[rsp], 3
  0021e	0f 8f 50 01 00
	00		 jg	 $LN71@ReadVolume

; 291  : 			{
; 292  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00224	c7 84 24 60 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0022f	eb 11		 jmp	 SHORT $LN70@ReadVolume
$LN69@ReadVolume:
  00231	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00238	83 c0 01	 add	 eax, 1
  0023b	89 84 24 60 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN70@ReadVolume:
  00242	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR pkcs5PrfCount$[rsp]
  00249	39 84 24 60 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00250	0f 8d 0d 01 00
	00		 jge	 $LN68@ReadVolume

; 293  : 				{
; 294  : 					item = &keyDerivationWorkItems[i];

  00256	48 63 8c 24 60
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  0025e	48 69 c9 0c 01
	00 00		 imul	 rcx, 268		; 0000010cH
  00265	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR keyDerivationWorkItems$[rsp]
  0026d	48 03 c1	 add	 rax, rcx
  00270	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR item$[rsp], rax

; 295  : 					if (item->Free)

  00278	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00280	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR [rax+256], 0
  00287	0f 84 d1 00 00
	00		 je	 $LN67@ReadVolume

; 296  : 					{
; 297  : 						item->Free = FALSE;

  0028d	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00295	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+256], 0

; 298  : 						item->KeyReady = FALSE;

  0029f	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  002a7	c7 80 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+260], 0

; 299  : 						item->Pkcs5Prf = enqPkcs5Prf;

  002b1	48 8b 8c 24 68
	03 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  002b9	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR enqPkcs5Prf$[rsp]
  002c0	89 81 08 01 00
	00		 mov	 DWORD PTR [rcx+264], eax

; 300  : 
; 301  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 302  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 303  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  002c6	8b 94 24 00 06
	00 00		 mov	 edx, DWORD PTR bBoot$[rsp]
  002cd	8b 8c 24 58 03
	00 00		 mov	 ecx, DWORD PTR enqPkcs5Prf$[rsp]
  002d4	e8 00 00 00 00	 call	 get_pkcs5_iteration_count
  002d9	8b d0		 mov	 edx, eax
  002db	4c 8b 84 24 68
	03 00 00	 mov	 r8, QWORD PTR item$[rsp]
  002e3	49 81 c0 04 01
	00 00		 add	 r8, 260			; 00000104H
  002ea	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  002f2	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  002f7	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  002fb	48 8d 84 24 f8
	01 00 00	 lea	 rax, QWORD PTR keyInfo$[rsp+72]
  00303	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00308	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp+4]
  0030f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00313	48 8d 84 24 b8
	01 00 00	 lea	 rax, QWORD PTR keyInfo$[rsp+8]
  0031b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00320	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR enqPkcs5Prf$[rsp]
  00327	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0032b	4c 8d 8c 24 48
	03 00 00	 lea	 r9, QWORD PTR outstandingWorkItemCount$[rsp]
  00333	48 8d 94 24 68
	01 00 00	 lea	 rdx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  0033b	48 8d 8c 24 98
	01 00 00	 lea	 rcx, QWORD PTR keyDerivationCompletedEvent$[rsp]
  00343	e8 00 00 00 00	 call	 EncryptionThreadPoolBeginKeyDerivation

; 304  : 						
; 305  : 						++queuedWorkItems;

  00348	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR queuedWorkItems$[rsp]
  00350	48 83 c0 01	 add	 rax, 1
  00354	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR queuedWorkItems$[rsp], rax

; 306  : 						break;

  0035c	eb 05		 jmp	 SHORT $LN68@ReadVolume
$LN67@ReadVolume:

; 307  : 					}
; 308  : 				}

  0035e	e9 ce fe ff ff	 jmp	 $LN69@ReadVolume
$LN68@ReadVolume:

; 309  : 
; 310  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  00363	83 bc 24 58 03
	00 00 03	 cmp	 DWORD PTR enqPkcs5Prf$[rsp], 3
  0036b	7d 05		 jge	 SHORT $LN66@ReadVolume

; 311  : 					continue;

  0036d	e9 55 fe ff ff	 jmp	 $LN75@ReadVolume
$LN66@ReadVolume:

; 312  : 			}
; 313  : 			else

  00372	eb 11		 jmp	 SHORT $LN65@ReadVolume
$LN71@ReadVolume:

; 314  : 				--enqPkcs5Prf;

  00374	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR enqPkcs5Prf$[rsp]
  0037b	83 e8 01	 sub	 eax, 1
  0037e	89 84 24 58 03
	00 00		 mov	 DWORD PTR enqPkcs5Prf$[rsp], eax
$LN65@ReadVolume:
$LN64@ReadVolume:

; 315  : 
; 316  : 			// Wait for completion of a key derivation
; 317  : 			while (queuedWorkItems > 0)

  00385	48 83 bc 24 50
	03 00 00 00	 cmp	 QWORD PTR queuedWorkItems$[rsp], 0
  0038e	0f 86 23 01 00
	00		 jbe	 $LN63@ReadVolume

; 318  : 			{
; 319  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00394	c7 84 24 60 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0039f	eb 11		 jmp	 SHORT $LN62@ReadVolume
$LN61@ReadVolume:
  003a1	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  003a8	83 c0 01	 add	 eax, 1
  003ab	89 84 24 60 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN62@ReadVolume:
  003b2	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR pkcs5PrfCount$[rsp]
  003b9	39 84 24 60 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  003c0	0f 8d c2 00 00
	00		 jge	 $LN60@ReadVolume

; 320  : 				{
; 321  : 					item = &keyDerivationWorkItems[i];

  003c6	48 63 8c 24 60
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  003ce	48 69 c9 0c 01
	00 00		 imul	 rcx, 268		; 0000010cH
  003d5	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR keyDerivationWorkItems$[rsp]
  003dd	48 03 c1	 add	 rax, rcx
  003e0	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR item$[rsp], rax

; 322  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  003e8	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  003f0	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR [rax+256], 0
  003f7	0f 85 86 00 00
	00		 jne	 $LN59@ReadVolume
  003fd	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00405	48 05 04 01 00
	00		 add	 rax, 260		; 00000104H
  0040b	33 c9		 xor	 ecx, ecx
  0040d	f0 0f c1 08	 lock xadd DWORD PTR [rax], ecx
  00411	8b c1		 mov	 eax, ecx
  00413	83 f8 01	 cmp	 eax, 1
  00416	75 6b		 jne	 SHORT $LN59@ReadVolume

; 323  : 					{
; 324  : 						pkcs5_prf = item->Pkcs5Prf;

  00418	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00420	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  00426	89 84 24 64 03
	00 00		 mov	 DWORD PTR pkcs5_prf$[rsp], eax

; 325  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  0042d	8b 94 24 00 06
	00 00		 mov	 edx, DWORD PTR bBoot$[rsp]
  00434	8b 8c 24 64 03
	00 00		 mov	 ecx, DWORD PTR pkcs5_prf$[rsp]
  0043b	e8 00 00 00 00	 call	 get_pkcs5_iteration_count
  00440	89 84 24 b0 01
	00 00		 mov	 DWORD PTR keyInfo$[rsp], eax

; 326  : 						memcpy (dk, item->DerivedKey, sizeof (dk));

  00447	48 8d 7c 24 60	 lea	 rdi, QWORD PTR dk$[rsp]
  0044c	48 8b b4 24 68
	03 00 00	 mov	 rsi, QWORD PTR item$[rsp]
  00454	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00459	f3 a4		 rep movsb

; 327  : 
; 328  : 						item->Free = TRUE;

  0045b	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00463	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+256], 1

; 329  : 						--queuedWorkItems;

  0046d	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR queuedWorkItems$[rsp]
  00475	48 83 e8 01	 sub	 rax, 1
  00479	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR queuedWorkItems$[rsp], rax

; 330  : 						goto KeyReady;

  00481	eb 39		 jmp	 SHORT $KeyReady$28333
$LN59@ReadVolume:

; 331  : 					}
; 332  : 				}

  00483	e9 19 ff ff ff	 jmp	 $LN61@ReadVolume
$LN60@ReadVolume:

; 333  : 
; 334  : 				if (queuedWorkItems > 0)

  00488	48 83 bc 24 50
	03 00 00 00	 cmp	 QWORD PTR queuedWorkItems$[rsp], 0
  00491	76 1f		 jbe	 SHORT $LN58@ReadVolume

; 335  : 					GST_WAIT_EVENT (keyDerivationCompletedEvent);

  00493	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0049c	45 33 c9	 xor	 r9d, r9d
  0049f	45 33 c0	 xor	 r8d, r8d
  004a2	33 d2		 xor	 edx, edx
  004a4	48 8d 8c 24 98
	01 00 00	 lea	 rcx, QWORD PTR keyDerivationCompletedEvent$[rsp]
  004ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
$LN58@ReadVolume:

; 336  : 			}

  004b2	e9 ce fe ff ff	 jmp	 $LN64@ReadVolume
$LN63@ReadVolume:

; 337  : 			continue;

  004b7	e9 0b fd ff ff	 jmp	 $LN75@ReadVolume
$KeyReady$28333:

; 338  : KeyReady:	;
; 339  : 		}
; 340  : 		else

  004bc	e9 45 01 00 00	 jmp	 $LN57@ReadVolume
$LN72@ReadVolume:

; 341  : 		{
; 342  : 			pkcs5_prf = enqPkcs5Prf;

  004c1	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR enqPkcs5Prf$[rsp]
  004c8	89 84 24 64 03
	00 00		 mov	 DWORD PTR pkcs5_prf$[rsp], eax

; 343  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  004cf	8b 94 24 00 06
	00 00		 mov	 edx, DWORD PTR bBoot$[rsp]
  004d6	8b 8c 24 58 03
	00 00		 mov	 ecx, DWORD PTR enqPkcs5Prf$[rsp]
  004dd	e8 00 00 00 00	 call	 get_pkcs5_iteration_count
  004e2	89 84 24 b0 01
	00 00		 mov	 DWORD PTR keyInfo$[rsp], eax

; 344  : 
; 345  : 			switch (pkcs5_prf)

  004e9	8b 84 24 64 03
	00 00		 mov	 eax, DWORD PTR pkcs5_prf$[rsp]
  004f0	89 84 24 b8 05
	00 00		 mov	 DWORD PTR tv199[rsp], eax
  004f7	83 bc 24 b8 05
	00 00 01	 cmp	 DWORD PTR tv199[rsp], 1
  004ff	74 62		 je	 SHORT $LN53@ReadVolume
  00501	83 bc 24 b8 05
	00 00 02	 cmp	 DWORD PTR tv199[rsp], 2
  00509	0f 84 96 00 00
	00		 je	 $LN52@ReadVolume
  0050f	83 bc 24 b8 05
	00 00 03	 cmp	 DWORD PTR tv199[rsp], 3
  00517	74 05		 je	 SHORT $LN54@ReadVolume
  00519	e9 c9 00 00 00	 jmp	 $LN51@ReadVolume
$LN54@ReadVolume:

; 346  : 			{
; 347  : 			case WHIRLPOOL:
; 348  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 349  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  0051e	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00523	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00527	48 8d 44 24 60	 lea	 rax, QWORD PTR dk$[rsp]
  0052c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00531	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  00538	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0053c	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00542	4c 8d 84 24 f8
	01 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  0054a	8b 94 24 b4 01
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  00551	48 8d 8c 24 b8
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  00559	e8 00 00 00 00	 call	 derive_key_whirlpool

; 350  : 				break;

  0055e	e9 a3 00 00 00	 jmp	 $LN55@ReadVolume
$LN53@ReadVolume:

; 351  : 			case STRIBOG:
; 352  : 				derive_key_stribog (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 353  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00563	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00568	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0056c	48 8d 44 24 60	 lea	 rax, QWORD PTR dk$[rsp]
  00571	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00576	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  0057d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00581	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00587	4c 8d 84 24 f8
	01 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  0058f	8b 94 24 b4 01
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  00596	48 8d 8c 24 b8
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  0059e	e8 00 00 00 00	 call	 derive_key_stribog

; 354  : 				break;

  005a3	eb 61		 jmp	 SHORT $LN55@ReadVolume
$LN52@ReadVolume:

; 355  : 			case GOSTHASH:
; 356  : 				derive_key_gosthash (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 357  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  005a5	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  005aa	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005ae	48 8d 44 24 60	 lea	 rax, QWORD PTR dk$[rsp]
  005b3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005b8	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  005bf	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005c3	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  005c9	4c 8d 84 24 f8
	01 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  005d1	8b 94 24 b4 01
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  005d8	48 8d 8c 24 b8
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  005e0	e8 00 00 00 00	 call	 derive_key_gosthash

; 358  : 				break;

  005e5	eb 1f		 jmp	 SHORT $LN55@ReadVolume
$LN51@ReadVolume:

; 359  : 			default:		
; 360  : 				// Unknown/wrong ID
; 361  : 				GST_THROW_FATAL_EXCEPTION;

  005e7	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  005f0	45 33 c9	 xor	 r9d, r9d
  005f3	45 33 c0	 xor	 r8d, r8d
  005f6	ba 69 01 00 00	 mov	 edx, 361		; 00000169H
  005fb	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00600	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN55@ReadVolume:
$LN57@ReadVolume:

; 362  : 			} 
; 363  : 		}
; 364  : 
; 365  : 		// Test all available modes of operation
; 366  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; 367  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 368  : 			cryptoInfo->mode++)

  00606	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0060b	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1
  00612	eb 13		 jmp	 SHORT $LN50@ReadVolume
$LN49@ReadVolume:
  00614	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00619	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  0061c	83 c1 01	 add	 ecx, 1
  0061f	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00624	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN50@ReadVolume:
  00627	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0062c	83 78 04 02	 cmp	 DWORD PTR [rax+4], 2
  00630	0f 8f 4e 06 00
	00		 jg	 $LN48@ReadVolume

; 369  : 		{
; 370  : 			switch (cryptoInfo->mode)

  00636	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0063b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0063e	89 84 24 bc 05
	00 00		 mov	 DWORD PTR tv240[rsp], eax

; 371  : 			{
; 372  : 			default:
; 373  : 				primaryKeyOffset = 0;

  00645	c7 84 24 90 01
	00 00 00 00 00
	00		 mov	 DWORD PTR primaryKeyOffset$[rsp], 0

; 374  : 			}
; 375  : 
; 376  : 			// Test all available encryption algorithms
; 377  : 			for (cryptoInfo->ea = EAGetFirst ();
; 378  : 				cryptoInfo->ea != 0;
; 379  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  00650	e8 00 00 00 00	 call	 EAGetFirst
  00655	8b d0		 mov	 edx, eax
  00657	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0065c	89 10		 mov	 DWORD PTR [rax], edx
  0065e	eb 15		 jmp	 SHORT $LN44@ReadVolume
$LN43@ReadVolume:
  00660	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00665	8b 08		 mov	 ecx, DWORD PTR [rax]
  00667	e8 00 00 00 00	 call	 EAGetNext
  0066c	8b d0		 mov	 edx, eax
  0066e	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00673	89 10		 mov	 DWORD PTR [rax], edx
$LN44@ReadVolume:
  00675	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0067a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0067d	0f 84 fc 05 00
	00		 je	 $LN42@ReadVolume

; 380  : 			{
; 381  : 				int blockSize;
; 382  : 
; 383  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  00683	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00688	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  0068b	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00690	8b 08		 mov	 ecx, DWORD PTR [rax]
  00692	e8 00 00 00 00	 call	 EAIsModeSupported
  00697	85 c0		 test	 eax, eax
  00699	75 02		 jne	 SHORT $LN41@ReadVolume

; 384  : 					continue;	// This encryption algorithm has never been available with this mode of operation

  0069b	eb c3		 jmp	 SHORT $LN43@ReadVolume
$LN41@ReadVolume:

; 385  : 
; 386  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));

  0069d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  006a2	8b 08		 mov	 ecx, DWORD PTR [rax]
  006a4	e8 00 00 00 00	 call	 EAGetFirstCipher
  006a9	8b c8		 mov	 ecx, eax
  006ab	e8 00 00 00 00	 call	 CipherGetBlockSize
  006b0	89 84 24 70 05
	00 00		 mov	 DWORD PTR blockSize$28357[rsp], eax

; 387  : 
; 388  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  006b7	4c 8b 44 24 50	 mov	 r8, QWORD PTR cryptoInfo$[rsp]
  006bc	49 83 c0 08	 add	 r8, 8
  006c0	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR primaryKeyOffset$[rsp]
  006c8	48 8d 54 04 60	 lea	 rdx, QWORD PTR dk$[rsp+rax]
  006cd	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  006d2	8b 08		 mov	 ecx, DWORD PTR [rax]
  006d4	e8 00 00 00 00	 call	 EAInit
  006d9	89 84 24 5c 03
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 389  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  006e0	83 bc 24 5c 03
	00 00 11	 cmp	 DWORD PTR status$[rsp], 17
  006e8	75 05		 jne	 SHORT $LN40@ReadVolume

; 390  : 					goto err;

  006ea	e9 a5 05 00 00	 jmp	 $err$28360
$LN40@ReadVolume:

; 391  : 
; 392  : 				// Init objects related to the mode of operation
; 393  : 
; 394  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  006ef	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  006f4	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  006f8	74 0b		 je	 SHORT $LN38@ReadVolume
  006fa	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  006ff	83 78 04 02	 cmp	 DWORD PTR [rax+4], 2
  00703	75 51		 jne	 SHORT $LN39@ReadVolume
$LN38@ReadVolume:

; 395  : 				{
; 396  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 397  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00705	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0070a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0070c	e8 00 00 00 00	 call	 EAGetKeySize
  00711	48 63 d8	 movsxd	 rbx, eax
  00714	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00719	8b 08		 mov	 ecx, DWORD PTR [rax]
  0071b	e8 00 00 00 00	 call	 EAGetKeySize
  00720	48 98		 cdqe
  00722	48 8d 74 04 60	 lea	 rsi, QWORD PTR dk$[rsp+rax]
  00727	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  0072c	48 81 c7 50 1d
	00 00		 add	 rdi, 7504		; 00001d50H
  00733	48 8b cb	 mov	 rcx, rbx
  00736	f3 a4		 rep movsb

; 398  : 
; 399  : 					// Secondary key schedule
; 400  : 					if (!EAInitMode (cryptoInfo))

  00738	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  0073d	e8 00 00 00 00	 call	 EAInitMode
  00742	85 c0		 test	 eax, eax
  00744	75 10		 jne	 SHORT $LN37@ReadVolume

; 401  : 					{
; 402  : 						status = ERR_MODE_INIT_FAILED;

  00746	c7 84 24 5c 03
	00 00 1b 00 00
	00		 mov	 DWORD PTR status$[rsp], 27

; 403  : 						goto err;

  00751	e9 3e 05 00 00	 jmp	 $err$28360
$LN37@ReadVolume:
$LN39@ReadVolume:

; 404  : 					}
; 405  : 				}
; 406  : 
; 407  : 				// Copy the header for decryption
; 408  : 				memcpy (header, encryptedHeader, sizeof (header));

  00756	48 8d bc 24 70
	03 00 00	 lea	 rdi, QWORD PTR header$[rsp]
  0075e	48 8b b4 24 08
	06 00 00	 mov	 rsi, QWORD PTR encryptedHeader$[rsp]
  00766	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0076b	f3 a4		 rep movsb

; 409  : 
; 410  : 				// Try to decrypt header 
; 411  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  0076d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00772	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  00776	74 0b		 je	 SHORT $LN35@ReadVolume
  00778	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0077d	83 78 04 02	 cmp	 DWORD PTR [rax+4], 2
  00781	75 17		 jne	 SHORT $LN36@ReadVolume
$LN35@ReadVolume:

; 412  : 					DecryptBuffer(header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  00783	48 8d 8c 24 b0
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp+64]
  0078b	4c 8b 44 24 50	 mov	 r8, QWORD PTR cryptoInfo$[rsp]
  00790	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  00795	e8 00 00 00 00	 call	 DecryptBuffer
$LN36@ReadVolume:

; 413  : 
; 414  : 				// Magic 'TRUE'
; 415  : 				if (GetHeaderField32 (header, GST_HEADER_OFFSET_MAGIC) != 0x54525545)

  0079a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0079f	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  007a7	e8 00 00 00 00	 call	 GetHeaderField32
  007ac	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  007b1	74 05		 je	 SHORT $LN34@ReadVolume

; 416  : 					continue;

  007b3	e9 a8 fe ff ff	 jmp	 $LN43@ReadVolume
$LN34@ReadVolume:

; 417  : 
; 418  : 				// Header version
; 419  : 				headerVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_VERSION);

  007b8	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  007bd	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  007c5	e8 00 00 00 00	 call	 GetHeaderField16
  007ca	66 89 84 24 80
	01 00 00	 mov	 WORD PTR headerVersion$[rsp], ax

; 420  : 				
; 421  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  007d2	0f b7 84 24 80
	01 00 00	 movzx	 eax, WORD PTR headerVersion$[rsp]
  007da	3d 00 13 00 00	 cmp	 eax, 4864		; 00001300H
  007df	7e 10		 jle	 SHORT $LN33@ReadVolume

; 422  : 				{
; 423  : 					status = ERR_NEW_VERSION_REQUIRED;

  007e1	c7 84 24 5c 03
	00 00 10 00 00
	00		 mov	 DWORD PTR status$[rsp], 16

; 424  : 					goto err;

  007ec	e9 a3 04 00 00	 jmp	 $err$28360
$LN33@ReadVolume:

; 425  : 				}
; 426  : 
; 427  : 				// Check CRC of the header fields
; 428  : 				if (!ReadVolumeHeaderRecoveryMode
; 429  : 					&& headerVersion >= 4
; 430  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC))

  007f1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ReadVolumeHeaderRecoveryMode, 0
  007f8	75 3c		 jne	 SHORT $LN32@ReadVolume
  007fa	0f b7 84 24 80
	01 00 00	 movzx	 eax, WORD PTR headerVersion$[rsp]
  00802	83 f8 04	 cmp	 eax, 4
  00805	7c 2f		 jl	 SHORT $LN32@ReadVolume
  00807	ba fc 00 00 00	 mov	 edx, 252		; 000000fcH
  0080c	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00814	e8 00 00 00 00	 call	 GetHeaderField32
  00819	8b f8		 mov	 edi, eax
  0081b	48 8d 8c 24 b0
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp+64]
  00823	ba bc 00 00 00	 mov	 edx, 188		; 000000bcH
  00828	e8 00 00 00 00	 call	 GetCrc32
  0082d	3b f8		 cmp	 edi, eax
  0082f	74 05		 je	 SHORT $LN32@ReadVolume

; 431  : 					continue;

  00831	e9 2a fe ff ff	 jmp	 $LN43@ReadVolume
$LN32@ReadVolume:

; 432  : 
; 433  : 				// Required program version
; 434  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_REQUIRED_VERSION);

  00836	ba 46 00 00 00	 mov	 edx, 70			; 00000046H
  0083b	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00843	e8 00 00 00 00	 call	 GetHeaderField16
  00848	0f b7 d0	 movzx	 edx, ax
  0084b	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00850	66 89 90 e0 1e
	00 00		 mov	 WORD PTR [rax+7904], dx

; 435  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  00857	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0085c	0f b7 80 e0 1e
	00 00		 movzx	 eax, WORD PTR [rax+7904]
  00863	3d 00 06 00 00	 cmp	 eax, 1536		; 00000600H
  00868	7d 0d		 jge	 SHORT $LN87@ReadVolume
  0086a	c7 84 24 c0 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv325[rsp], 1
  00875	eb 0b		 jmp	 SHORT $LN88@ReadVolume
$LN87@ReadVolume:
  00877	c7 84 24 c0 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv325[rsp], 0
$LN88@ReadVolume:
  00882	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00887	8b 84 24 c0 05
	00 00		 mov	 eax, DWORD PTR tv325[rsp]
  0088e	89 81 e4 1e 00
	00		 mov	 DWORD PTR [rcx+7908], eax

; 436  : 
; 437  : 				// Check CRC of the key set
; 438  : 				if (!ReadVolumeHeaderRecoveryMode
; 439  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  00894	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ReadVolumeHeaderRecoveryMode, 0
  0089b	75 2f		 jne	 SHORT $LN31@ReadVolume
  0089d	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  008a2	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  008aa	e8 00 00 00 00	 call	 GetHeaderField32
  008af	8b f8		 mov	 edi, eax
  008b1	48 8d 8c 24 70
	04 00 00	 lea	 rcx, QWORD PTR header$[rsp+256]
  008b9	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  008be	e8 00 00 00 00	 call	 GetCrc32
  008c3	3b f8		 cmp	 edi, eax
  008c5	74 05		 je	 SHORT $LN31@ReadVolume

; 440  : 					continue;

  008c7	e9 94 fd ff ff	 jmp	 $LN43@ReadVolume
$LN31@ReadVolume:

; 441  : 
; 442  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 443  : 
; 444  : 				// Check the version required to handle this volume
; 445  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  008cc	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  008d1	0f b7 80 e0 1e
	00 00		 movzx	 eax, WORD PTR [rax+7904]
  008d8	3d 00 13 00 00	 cmp	 eax, 4864		; 00001300H
  008dd	7e 10		 jle	 SHORT $LN30@ReadVolume

; 446  : 				{
; 447  : 					status = ERR_NEW_VERSION_REQUIRED;

  008df	c7 84 24 5c 03
	00 00 10 00 00
	00		 mov	 DWORD PTR status$[rsp], 16

; 448  : 					goto err;

  008ea	e9 a5 03 00 00	 jmp	 $err$28360
$LN30@ReadVolume:

; 449  : 				}
; 450  : 
; 451  : 				// Header version
; 452  : 				cryptoInfo->HeaderVersion = headerVersion;

  008ef	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  008f4	0f b7 84 24 80
	01 00 00	 movzx	 eax, WORD PTR headerVersion$[rsp]
  008fc	66 89 81 4c 04
	00 00		 mov	 WORD PTR [rcx+1100], ax

; 453  : 
; 454  : 				// Volume creation time (legacy)
; 455  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  00903	ba 4c 00 00 00	 mov	 edx, 76			; 0000004cH
  00908	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00910	e8 00 00 00 00	 call	 GetHeaderField64
  00915	48 89 84 24 a0
	05 00 00	 mov	 QWORD PTR $T37997[rsp], rax
  0091d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00922	48 8b 84 24 a0
	05 00 00	 mov	 rax, QWORD PTR $T37997[rsp]
  0092a	48 89 81 98 1e
	00 00		 mov	 QWORD PTR [rcx+7832], rax

; 456  : 
; 457  : 				// Header creation time (legacy)
; 458  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_MODIFICATION_TIME).Value;

  00931	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  00936	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  0093e	e8 00 00 00 00	 call	 GetHeaderField64
  00943	48 89 84 24 a8
	05 00 00	 mov	 QWORD PTR $T37998[rsp], rax
  0094b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00950	48 8b 84 24 a8
	05 00 00	 mov	 rax, QWORD PTR $T37998[rsp]
  00958	48 89 81 a0 1e
	00 00		 mov	 QWORD PTR [rcx+7840], rax

; 459  : 
; 460  : 				// Hidden volume size (if any)
; 461  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  0095f	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00964	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  0096c	e8 00 00 00 00	 call	 GetHeaderField64
  00971	48 89 84 24 b0
	05 00 00	 mov	 QWORD PTR $T37999[rsp], rax
  00979	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  0097e	48 8b 84 24 b0
	05 00 00	 mov	 rax, QWORD PTR $T37999[rsp]
  00986	48 89 81 b8 1e
	00 00		 mov	 QWORD PTR [rcx+7864], rax

; 462  : 
; 463  : 				// Hidden volume status
; 464  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  0098d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00992	48 83 b8 b8 1e
	00 00 00	 cmp	 QWORD PTR [rax+7864], 0
  0099a	74 0d		 je	 SHORT $LN89@ReadVolume
  0099c	c7 84 24 c4 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv386[rsp], 1
  009a7	eb 0b		 jmp	 SHORT $LN90@ReadVolume
$LN89@ReadVolume:
  009a9	c7 84 24 c4 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv386[rsp], 0
$LN90@ReadVolume:
  009b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  009b9	8b 84 24 c4 05
	00 00		 mov	 eax, DWORD PTR tv386[rsp]
  009c0	89 81 48 04 00
	00		 mov	 DWORD PTR [rcx+1096], eax

; 465  : 
; 466  : 				// Volume size
; 467  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_SIZE);

  009c6	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  009cb	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  009d3	e8 00 00 00 00	 call	 GetHeaderField64
  009d8	48 8b d0	 mov	 rdx, rax
  009db	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  009e0	48 89 90 f0 1e
	00 00		 mov	 QWORD PTR [rax+7920], rdx

; 468  : 				
; 469  : 				// Encrypted area size and length
; 470  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_START);

  009e7	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  009ec	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  009f4	e8 00 00 00 00	 call	 GetHeaderField64
  009f9	48 8b d0	 mov	 rdx, rax
  009fc	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00a01	48 89 90 f8 1e
	00 00		 mov	 QWORD PTR [rax+7928], rdx

; 471  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  00a08	ba 74 00 00 00	 mov	 edx, 116		; 00000074H
  00a0d	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00a15	e8 00 00 00 00	 call	 GetHeaderField64
  00a1a	48 8b d0	 mov	 rdx, rax
  00a1d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00a22	48 89 90 00 1f
	00 00		 mov	 QWORD PTR [rax+7936], rdx

; 472  : 
; 473  : 				// Flags
; 474  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, GST_HEADER_OFFSET_FLAGS);

  00a29	ba 7c 00 00 00	 mov	 edx, 124		; 0000007cH
  00a2e	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00a36	e8 00 00 00 00	 call	 GetHeaderField32
  00a3b	8b d0		 mov	 edx, eax
  00a3d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00a42	89 90 08 1f 00
	00		 mov	 DWORD PTR [rax+7944], edx

; 475  : 
; 476  : 				// Sector size
; 477  : 				if (headerVersion >= 5)

  00a48	0f b7 84 24 80
	01 00 00	 movzx	 eax, WORD PTR headerVersion$[rsp]
  00a50	83 f8 05	 cmp	 eax, 5
  00a53	7c 21		 jl	 SHORT $LN29@ReadVolume

; 478  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, GST_HEADER_OFFSET_SECTOR_SIZE);

  00a55	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00a5a	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00a62	e8 00 00 00 00	 call	 GetHeaderField32
  00a67	8b d0		 mov	 edx, eax
  00a69	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00a6e	89 90 e8 1e 00
	00		 mov	 DWORD PTR [rax+7912], edx

; 479  : 				else

  00a74	eb 0f		 jmp	 SHORT $LN28@ReadVolume
$LN29@ReadVolume:

; 480  : 					cryptoInfo->SectorSize = GST_SECTOR_SIZE_LEGACY;

  00a76	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00a7b	c7 80 e8 1e 00
	00 00 02 00 00	 mov	 DWORD PTR [rax+7912], 512 ; 00000200H
$LN28@ReadVolume:

; 481  : 
; 482  : 				if (cryptoInfo->SectorSize < GST_MIN_VOLUME_SECTOR_SIZE
; 483  : 					|| cryptoInfo->SectorSize > GST_MAX_VOLUME_SECTOR_SIZE
; 484  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  00a85	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00a8a	81 b8 e8 1e 00
	00 00 02 00 00	 cmp	 DWORD PTR [rax+7912], 512 ; 00000200H
  00a94	72 29		 jb	 SHORT $LN26@ReadVolume
  00a96	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00a9b	81 b8 e8 1e 00
	00 00 10 00 00	 cmp	 DWORD PTR [rax+7912], 4096 ; 00001000H
  00aa5	77 18		 ja	 SHORT $LN26@ReadVolume
  00aa7	33 d2		 xor	 edx, edx
  00aa9	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00aae	8b 80 e8 1e 00
	00		 mov	 eax, DWORD PTR [rax+7912]
  00ab4	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00ab9	f7 f1		 div	 ecx
  00abb	85 d2		 test	 edx, edx
  00abd	74 10		 je	 SHORT $LN27@ReadVolume
$LN26@ReadVolume:

; 485  : 				{
; 486  : 					status = ERR_PARAMETER_INCORRECT;

  00abf	c7 84 24 5c 03
	00 00 1e 00 00
	00		 mov	 DWORD PTR status$[rsp], 30

; 487  : 					goto err;

  00aca	e9 c5 01 00 00	 jmp	 $err$28360
$LN27@ReadVolume:

; 488  : 				}
; 489  : 
; 490  : 				// Preserve scheduled header keys if requested			
; 491  : 				if (retHeaderCryptoInfo)

  00acf	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR retHeaderCryptoInfo$[rsp], 0
  00ad8	0f 84 83 00 00
	00		 je	 $LN25@ReadVolume

; 492  : 				{
; 493  : 					if (retInfo == NULL)

  00ade	48 83 bc 24 18
	06 00 00 00	 cmp	 QWORD PTR retInfo$[rsp], 0
  00ae7	75 29		 jne	 SHORT $LN24@ReadVolume

; 494  : 					{
; 495  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  00ae9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00aee	8b 84 24 64 03
	00 00		 mov	 eax, DWORD PTR pkcs5_prf$[rsp]
  00af5	89 81 94 1e 00
	00		 mov	 DWORD PTR [rcx+7828], eax

; 496  : 						cryptoInfo->noIterations = keyInfo.noIterations;

  00afb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00b00	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  00b07	89 81 90 1e 00
	00		 mov	 DWORD PTR [rcx+7824], eax

; 497  : 						goto ret;

  00b0d	e9 aa 01 00 00	 jmp	 $ret$28378
$LN24@ReadVolume:

; 498  : 					}
; 499  : 
; 500  : 					cryptoInfo = *retInfo = crypto_open ();

  00b12	e8 00 00 00 00	 call	 crypto_open
  00b17	48 8b d0	 mov	 rdx, rax
  00b1a	48 8b 84 24 18
	06 00 00	 mov	 rax, QWORD PTR retInfo$[rsp]
  00b22	48 89 10	 mov	 QWORD PTR [rax], rdx
  00b25	48 8b 84 24 18
	06 00 00	 mov	 rax, QWORD PTR retInfo$[rsp]
  00b2d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b30	48 89 44 24 50	 mov	 QWORD PTR cryptoInfo$[rsp], rax

; 501  : 					if (cryptoInfo == NULL)

  00b35	48 83 7c 24 50
	00		 cmp	 QWORD PTR cryptoInfo$[rsp], 0
  00b3b	75 10		 jne	 SHORT $LN23@ReadVolume

; 502  : 					{
; 503  : 						status = ERR_OUTOFMEMORY;

  00b3d	c7 84 24 5c 03
	00 00 02 00 00
	00		 mov	 DWORD PTR status$[rsp], 2

; 504  : 						goto err;

  00b48	e9 47 01 00 00	 jmp	 $err$28360
$LN23@ReadVolume:

; 505  : 					}
; 506  : 
; 507  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  00b4d	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  00b52	48 8b b4 24 20
	06 00 00	 mov	 rsi, QWORD PTR retHeaderCryptoInfo$[rsp]
  00b5a	b9 10 1f 00 00	 mov	 ecx, 7952		; 00001f10H
  00b5f	f3 a4		 rep movsb
$LN25@ReadVolume:

; 508  : 				}
; 509  : 
; 510  : 				// Master key data
; 511  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);

  00b61	48 8d bc 24 38
	02 00 00	 lea	 rdi, QWORD PTR keyInfo$[rsp+136]
  00b69	48 8d b4 24 70
	04 00 00	 lea	 rsi, QWORD PTR header$[rsp+256]
  00b71	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00b76	f3 a4		 rep movsb

; 512  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  00b78	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  00b7d	48 8d b4 24 38
	02 00 00	 lea	 rsi, QWORD PTR keyInfo$[rsp+136]
  00b85	48 81 c7 50 1c
	00 00		 add	 rdi, 7248		; 00001c50H
  00b8c	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00b91	f3 a4		 rep movsb

; 513  : 
; 514  : 				// PKCS #5
; 515  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);

  00b93	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  00b98	48 8d b4 24 f8
	01 00 00	 lea	 rsi, QWORD PTR keyInfo$[rsp+72]
  00ba0	48 81 c7 50 1e
	00 00		 add	 rdi, 7760		; 00001e50H
  00ba7	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00bac	f3 a4		 rep movsb

; 516  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  00bae	48 8b 54 24 50	 mov	 rdx, QWORD PTR cryptoInfo$[rsp]
  00bb3	8b 84 24 64 03
	00 00		 mov	 eax, DWORD PTR pkcs5_prf$[rsp]
  00bba	89 82 94 1e 00
	00		 mov	 DWORD PTR [rdx+7828], eax

; 517  : 				cryptoInfo->noIterations = keyInfo.noIterations;

  00bc0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00bc5	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  00bcc	89 81 90 1e 00
	00		 mov	 DWORD PTR [rcx+7824], eax

; 518  : 
; 519  : 				// Init the cipher with the decrypted master key
; 520  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  00bd2	4c 8b 44 24 50	 mov	 r8, QWORD PTR cryptoInfo$[rsp]
  00bd7	49 83 c0 08	 add	 r8, 8
  00bdb	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR primaryKeyOffset$[rsp]
  00be3	48 8d 94 04 38
	02 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+rax+136]
  00beb	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00bf0	8b 08		 mov	 ecx, DWORD PTR [rax]
  00bf2	e8 00 00 00 00	 call	 EAInit
  00bf7	89 84 24 5c 03
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 521  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00bfe	83 bc 24 5c 03
	00 00 11	 cmp	 DWORD PTR status$[rsp], 17
  00c06	75 05		 jne	 SHORT $LN22@ReadVolume

; 522  : 					goto err;

  00c08	e9 87 00 00 00	 jmp	 $err$28360
$LN22@ReadVolume:

; 523  : 
; 524  : 				switch (cryptoInfo->mode)

  00c0d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00c12	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00c15	89 84 24 c8 05
	00 00		 mov	 DWORD PTR tv463[rsp], eax

; 525  : 				{
; 526  : 				default:
; 527  : 					// The secondary master key (if cascade, multiple concatenated)
; 528  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00c1c	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00c21	8b 08		 mov	 ecx, DWORD PTR [rax]
  00c23	e8 00 00 00 00	 call	 EAGetKeySize
  00c28	48 63 d8	 movsxd	 rbx, eax
  00c2b	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00c30	8b 08		 mov	 ecx, DWORD PTR [rax]
  00c32	e8 00 00 00 00	 call	 EAGetKeySize
  00c37	48 98		 cdqe
  00c39	48 8d b4 04 38
	02 00 00	 lea	 rsi, QWORD PTR keyInfo$[rsp+rax+136]
  00c41	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  00c46	48 81 c7 50 1d
	00 00		 add	 rdi, 7504		; 00001d50H
  00c4d	48 8b cb	 mov	 rcx, rbx
  00c50	f3 a4		 rep movsb

; 529  : 
; 530  : 				}
; 531  : 
; 532  : 				if (!EAInitMode (cryptoInfo))

  00c52	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00c57	e8 00 00 00 00	 call	 EAInitMode
  00c5c	85 c0		 test	 eax, eax
  00c5e	75 0d		 jne	 SHORT $LN18@ReadVolume

; 533  : 				{
; 534  : 					status = ERR_MODE_INIT_FAILED;

  00c60	c7 84 24 5c 03
	00 00 1b 00 00
	00		 mov	 DWORD PTR status$[rsp], 27

; 535  : 					goto err;

  00c6b	eb 27		 jmp	 SHORT $err$28360
$LN18@ReadVolume:

; 536  : 				}
; 537  : 
; 538  : 				status = ERR_SUCCESS;

  00c6d	c7 84 24 5c 03
	00 00 00 00 00
	00		 mov	 DWORD PTR status$[rsp], 0

; 539  : 				goto ret;

  00c78	eb 42		 jmp	 SHORT $ret$28378

; 540  : 			}

  00c7a	e9 e1 f9 ff ff	 jmp	 $LN43@ReadVolume
$LN42@ReadVolume:

; 541  : 		}

  00c7f	e9 90 f9 ff ff	 jmp	 $LN49@ReadVolume
$LN48@ReadVolume:

; 542  : 	}

  00c84	e9 3e f5 ff ff	 jmp	 $LN75@ReadVolume
$LN74@ReadVolume:

; 543  : 	status = ERR_PASSWORD_WRONG;

  00c89	c7 84 24 5c 03
	00 00 03 00 00
	00		 mov	 DWORD PTR status$[rsp], 3
$err$28360:

; 544  : 
; 545  : err:
; 546  : 	if (cryptoInfo != retHeaderCryptoInfo)

  00c94	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR retHeaderCryptoInfo$[rsp]
  00c9c	48 39 44 24 50	 cmp	 QWORD PTR cryptoInfo$[rsp], rax
  00ca1	74 19		 je	 SHORT $LN17@ReadVolume

; 547  : 	{
; 548  : 		crypto_close(cryptoInfo);

  00ca3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00ca8	e8 00 00 00 00	 call	 crypto_close

; 549  : 		*retInfo = NULL; 

  00cad	48 8b 94 24 18
	06 00 00	 mov	 rdx, QWORD PTR retInfo$[rsp]
  00cb5	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN17@ReadVolume:
$ret$28378:
$LN16@ReadVolume:

; 550  : 	}
; 551  : 
; 552  : ret:
; 553  : 	burn (&keyInfo, sizeof (keyInfo));

  00cbc	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR keyInfo$[rsp]
  00cc4	48 89 84 24 78
	05 00 00	 mov	 QWORD PTR burnm$28393[rsp], rax
  00ccc	c7 84 24 74 05
	00 00 88 01 00
	00		 mov	 DWORD PTR burnc$28395[rsp], 392 ; 00000188H
  00cd7	ba 88 01 00 00	 mov	 edx, 392		; 00000188H
  00cdc	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp]
  00ce4	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN13@ReadVolume:
  00ce9	8b 8c 24 74 05
	00 00		 mov	 ecx, DWORD PTR burnc$28395[rsp]
  00cf0	8b 84 24 74 05
	00 00		 mov	 eax, DWORD PTR burnc$28395[rsp]
  00cf7	83 e8 01	 sub	 eax, 1
  00cfa	89 84 24 74 05
	00 00		 mov	 DWORD PTR burnc$28395[rsp], eax
  00d01	85 c9		 test	 ecx, ecx
  00d03	74 21		 je	 SHORT $LN12@ReadVolume
  00d05	48 8b 84 24 78
	05 00 00	 mov	 rax, QWORD PTR burnm$28393[rsp]
  00d0d	c6 00 00	 mov	 BYTE PTR [rax], 0
  00d10	48 8b 84 24 78
	05 00 00	 mov	 rax, QWORD PTR burnm$28393[rsp]
  00d18	48 83 c0 01	 add	 rax, 1
  00d1c	48 89 84 24 78
	05 00 00	 mov	 QWORD PTR burnm$28393[rsp], rax
  00d24	eb c3		 jmp	 SHORT $LN13@ReadVolume
$LN12@ReadVolume:
  00d26	33 c0		 xor	 eax, eax
  00d28	85 c0		 test	 eax, eax
  00d2a	75 90		 jne	 SHORT $LN16@ReadVolume
$LN11@ReadVolume:

; 554  : 	burn (dk, sizeof(dk));

  00d2c	48 8d 44 24 60	 lea	 rax, QWORD PTR dk$[rsp]
  00d31	48 89 84 24 88
	05 00 00	 mov	 QWORD PTR burnm$28402[rsp], rax
  00d39	c7 84 24 80 05
	00 00 00 01 00
	00		 mov	 DWORD PTR burnc$28404[rsp], 256 ; 00000100H
  00d44	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00d49	48 8d 4c 24 60	 lea	 rcx, QWORD PTR dk$[rsp]
  00d4e	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN8@ReadVolume:
  00d53	8b 8c 24 80 05
	00 00		 mov	 ecx, DWORD PTR burnc$28404[rsp]
  00d5a	8b 84 24 80 05
	00 00		 mov	 eax, DWORD PTR burnc$28404[rsp]
  00d61	83 e8 01	 sub	 eax, 1
  00d64	89 84 24 80 05
	00 00		 mov	 DWORD PTR burnc$28404[rsp], eax
  00d6b	85 c9		 test	 ecx, ecx
  00d6d	74 21		 je	 SHORT $LN7@ReadVolume
  00d6f	48 8b 84 24 88
	05 00 00	 mov	 rax, QWORD PTR burnm$28402[rsp]
  00d77	c6 00 00	 mov	 BYTE PTR [rax], 0
  00d7a	48 8b 84 24 88
	05 00 00	 mov	 rax, QWORD PTR burnm$28402[rsp]
  00d82	48 83 c0 01	 add	 rax, 1
  00d86	48 89 84 24 88
	05 00 00	 mov	 QWORD PTR burnm$28402[rsp], rax
  00d8e	eb c3		 jmp	 SHORT $LN8@ReadVolume
$LN7@ReadVolume:
  00d90	33 c0		 xor	 eax, eax
  00d92	85 c0		 test	 eax, eax
  00d94	75 96		 jne	 SHORT $LN11@ReadVolume

; 555  : 
; 556  : #ifndef DEVICE_DRIVER
; 557  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));
; 558  : 	VirtualUnlock (&dk, sizeof (dk));
; 559  : #endif
; 560  : 
; 561  : 	if (encryptionThreadCount > 1)

  00d96	48 83 bc 24 88
	01 00 00 01	 cmp	 QWORD PTR encryptionThreadCount$[rsp], 1
  00d9f	0f 86 bb 00 00
	00		 jbe	 $LN6@ReadVolume

; 562  : 	{
; 563  : 		GST_WAIT_EVENT (noOutstandingWorkItemEvent);

  00da5	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00dae	45 33 c9	 xor	 r9d, r9d
  00db1	45 33 c0	 xor	 r8d, r8d
  00db4	33 d2		 xor	 edx, edx
  00db6	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  00dbe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
$LN5@ReadVolume:

; 564  : 
; 565  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00dc4	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR keyDerivationWorkItems$[rsp]
  00dcc	48 89 84 24 98
	05 00 00	 mov	 QWORD PTR burnm$28413[rsp], rax
  00dd4	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR pkcs5PrfCount$[rsp]
  00ddc	48 69 c0 0c 01
	00 00		 imul	 rax, 268		; 0000010cH
  00de3	89 84 24 90 05
	00 00		 mov	 DWORD PTR burnc$28415[rsp], eax
  00dea	48 63 94 24 60
	03 00 00	 movsxd	 rdx, DWORD PTR pkcs5PrfCount$[rsp]
  00df2	48 69 d2 0c 01
	00 00		 imul	 rdx, 268		; 0000010cH
  00df9	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR keyDerivationWorkItems$[rsp]
  00e01	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@ReadVolume:
  00e06	8b 8c 24 90 05
	00 00		 mov	 ecx, DWORD PTR burnc$28415[rsp]
  00e0d	8b 84 24 90 05
	00 00		 mov	 eax, DWORD PTR burnc$28415[rsp]
  00e14	83 e8 01	 sub	 eax, 1
  00e17	89 84 24 90 05
	00 00		 mov	 DWORD PTR burnc$28415[rsp], eax
  00e1e	85 c9		 test	 ecx, ecx
  00e20	74 21		 je	 SHORT $LN1@ReadVolume
  00e22	48 8b 84 24 98
	05 00 00	 mov	 rax, QWORD PTR burnm$28413[rsp]
  00e2a	c6 00 00	 mov	 BYTE PTR [rax], 0
  00e2d	48 8b 84 24 98
	05 00 00	 mov	 rax, QWORD PTR burnm$28413[rsp]
  00e35	48 83 c0 01	 add	 rax, 1
  00e39	48 89 84 24 98
	05 00 00	 mov	 QWORD PTR burnm$28413[rsp], rax
  00e41	eb c3		 jmp	 SHORT $LN2@ReadVolume
$LN1@ReadVolume:
  00e43	33 c0		 xor	 eax, eax
  00e45	85 c0		 test	 eax, eax
  00e47	0f 85 77 ff ff
	ff		 jne	 $LN5@ReadVolume

; 566  : 		GSTfree (keyDerivationWorkItems);

  00e4d	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00e52	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR keyDerivationWorkItems$[rsp]
  00e5a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@ReadVolume:

; 567  : 
; 568  : #ifndef DEVICE_DRIVER
; 569  : 		CloseHandle (keyDerivationCompletedEvent);
; 570  : 		CloseHandle (noOutstandingWorkItemEvent);
; 571  : #endif
; 572  : 	}
; 573  : 
; 574  : 	return status;

  00e60	8b 84 24 5c 03
	00 00		 mov	 eax, DWORD PTR status$[rsp]
$LN85@ReadVolume:
$LN86@ReadVolume:

; 575  : }

  00e67	48 8b 8c 24 d0
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00e6f	48 33 cc	 xor	 rcx, rsp
  00e72	e8 00 00 00 00	 call	 __security_check_cookie
  00e77	48 81 c4 e0 05
	00 00		 add	 rsp, 1504		; 000005e0H
  00e7e	5f		 pop	 rdi
  00e7f	5e		 pop	 rsi
  00e80	5b		 pop	 rbx
  00e81	c3		 ret	 0
ReadVolumeHeader ENDP
END
