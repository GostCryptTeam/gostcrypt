; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_09HLDHDDJL@Whirlpool?$AA@			; `string'
PUBLIC	??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@	; `string'
PUBLIC	??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@	; `string'
PUBLIC	??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@	; `string'
PUBLIC	??_C@_0O@POKHNLDL@GOST?528147?989?$AA@		; `string'
_BSS	SEGMENT
_HwEncryptionDisabled DD 01H DUP (?)
?state@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::state
?stateValid@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::stateValid
_BSS	ENDS
;	COMDAT ??_C@_09HLDHDDJL@Whirlpool?$AA@
CONST	SEGMENT
??_C@_09HLDHDDJL@Whirlpool?$AA@ DB 'Whirlpool', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@
CONST	SEGMENT
??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@ DB 'GOST R 34.11-94', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@
CONST	SEGMENT
??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@ DB 'GOST R 34.11-2012', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_Ciphers DD	01H
	DD	FLAT:??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
	DD	08H
	DD	020H
	DD	0220H
	DD	02H
	DD	FLAT:??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@
	DD	010H
	DD	020H
	DD	0a0H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_EncryptionAlgorithms DD 00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	ORG $+4
	DD	00H
	DD	01H
	DD	00H
	ORG $+8
	DD	02H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	00H
	ORG $+8
	DD	01H
	DD	00H
	ORG $+4
	DD	01H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	ORG $+4
	DD	00H
_Hashes	DD	01H
	DD	FLAT:??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_09HLDHDDJL@Whirlpool?$AA@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
;	COMDAT ??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@
CONST	SEGMENT
??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@ DB 'Gost Grasshopper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
CONST	SEGMENT
??_C@_0O@POKHNLDL@GOST?528147?989?$AA@ DB 'GOST 28147-89', 00H ; `string'
CONST	ENDS
PUBLIC	_CipherInit@12
EXTRN	_grasshopper_set_key@8:PROC
EXTRN	_gost_set_key@8:PROC
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _CipherInit@12
_TEXT	SEGMENT
tv64 = -8						; size = 4
_retVal$ = -4						; size = 4
_cipher$ = 8						; size = 4
_key$ = 12						; size = 4
_ks$ = 16						; size = 4
_CipherInit@12 PROC					; COMDAT

; 107  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 108  : 	int retVal = ERR_SUCCESS;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 0

; 109  : 
; 110  : 	switch (cipher)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR tv64[ebp], eax
  00015	83 7d f8 01	 cmp	 DWORD PTR tv64[ebp], 1
  00019	74 08		 je	 SHORT $LN3@CipherInit
  0001b	83 7d f8 02	 cmp	 DWORD PTR tv64[ebp], 2
  0001f	74 11		 je	 SHORT $LN2@CipherInit
  00021	eb 1e		 jmp	 SHORT $LN1@CipherInit
$LN3@CipherInit:

; 111  : 	{
; 112  : 	case GOST:
; 113  : 		gost_set_key(key, (gost_kds *)ks);

  00023	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 _gost_set_key@8

; 114  : 		break;

  00030	eb 16		 jmp	 SHORT $LN4@CipherInit
$LN2@CipherInit:

; 115  : 	case GRASSHOPPER:
; 116  : 		grasshopper_set_key((unsigned long *)key, (grasshopper_kds*)ks);

  00032	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _grasshopper_set_key@8

; 117  : 		break;

  0003f	eb 07		 jmp	 SHORT $LN4@CipherInit
$LN1@CipherInit:

; 118  : 	default:
; 119  : 		// Unknown/wrong cipher ID
; 120  : 		return ERR_CIPHER_INIT_FAILURE;

  00041	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00046	eb 03		 jmp	 SHORT $LN6@CipherInit
$LN4@CipherInit:

; 121  : 	}
; 122  : 
; 123  : 	return retVal;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _retVal$[ebp]
$LN6@CipherInit:

; 124  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
_CipherInit@12 ENDP
_TEXT	ENDS
PUBLIC	_EncipherBlock@12
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_grasshopper_encrypt@12:PROC
EXTRN	_gost_encrypt@12:PROC
; Function compile flags: /Odtp
;	COMDAT _EncipherBlock@12
_TEXT	SEGMENT
tv64 = -4						; size = 4
_cipher$ = 8						; size = 4
_data$ = 12						; size = 4
_ks$ = 16						; size = 4
_EncipherBlock@12 PROC					; COMDAT

; 137  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 138  : 	switch (cipher)

  00006	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	83 7d fc 01	 cmp	 DWORD PTR tv64[ebp], 1
  00010	74 08		 je	 SHORT $LN3@EncipherBl
  00012	83 7d fc 02	 cmp	 DWORD PTR tv64[ebp], 2
  00016	74 15		 je	 SHORT $LN2@EncipherBl
  00018	eb 26		 jmp	 SHORT $LN1@EncipherBl
$LN3@EncipherBl:

; 139  : 	{
; 140  : 	case GOST:
; 141  : 		gost_encrypt((byte *)data, (byte *)data, ks);

  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00021	52		 push	 edx
  00022	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _gost_encrypt@12

; 142  : 		break;

  0002b	eb 29		 jmp	 SHORT $LN7@EncipherBl
$LN2@EncipherBl:

; 143  : 	case GRASSHOPPER:
; 144  : 		grasshopper_encrypt(ks, (unsigned long *)data, (unsigned long *)data);

  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00034	52		 push	 edx
  00035	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _grasshopper_encrypt@12

; 145  : 		break;

  0003e	eb 16		 jmp	 SHORT $LN7@EncipherBl
$LN1@EncipherBl:

; 146  : 	default:			GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00040	68 54 53 47 00	 push	 4674388			; 00475354H
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	68 92 00 00 00	 push	 146			; 00000092H
  0004e	6a 29		 push	 41			; 00000029H
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN7@EncipherBl:

; 147  : 	}
; 148  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 0c 00	 ret	 12			; 0000000cH
_EncipherBlock@12 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetBlockSize@4
PUBLIC	_EncipherBlocks@16
; Function compile flags: /Odtp
;	COMDAT _EncipherBlocks@16
_TEXT	SEGMENT
_blockSize$ = -8					; size = 4
_data$ = -4						; size = 4
_cipher$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_ks$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_EncipherBlocks@16 PROC					; COMDAT

; 164  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 165  : 	byte *data = dataPtr;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _dataPtr$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 166  : 	size_t blockSize = CipherGetBlockSize (cipher);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  00017	89 45 f8	 mov	 DWORD PTR _blockSize$[ebp], eax
$LN2@EncipherBl@2:

; 167  : 	while (blockCount-- > 0)

  0001a	8b 55 14	 mov	 edx, DWORD PTR _blockCount$[ebp]
  0001d	8b 45 14	 mov	 eax, DWORD PTR _blockCount$[ebp]
  00020	83 e8 01	 sub	 eax, 1
  00023	89 45 14	 mov	 DWORD PTR _blockCount$[ebp], eax
  00026	85 d2		 test	 edx, edx
  00028	76 1c		 jbe	 SHORT $LN3@EncipherBl@2

; 168  : 	{
; 169  : 		EncipherBlock (cipher, data, ks);

  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _data$[ebp]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _EncipherBlock@12

; 170  : 		data += blockSize;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _data$[ebp]
  0003e	03 4d f8	 add	 ecx, DWORD PTR _blockSize$[ebp]
  00041	89 4d fc	 mov	 DWORD PTR _data$[ebp], ecx

; 171  : 	}

  00044	eb d4		 jmp	 SHORT $LN2@EncipherBl@2
$LN3@EncipherBl@2:

; 172  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
_EncipherBlocks@16 ENDP
_TEXT	ENDS
PUBLIC	_DecipherBlock@12
EXTRN	_grasshopper_decrypt@12:PROC
EXTRN	_gost_decrypt@12:PROC
; Function compile flags: /Odtp
;	COMDAT _DecipherBlock@12
_TEXT	SEGMENT
tv64 = -4						; size = 4
_cipher$ = 8						; size = 4
_data$ = 12						; size = 4
_ks$ = 16						; size = 4
_DecipherBlock@12 PROC					; COMDAT

; 187  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 188  : 	switch (cipher)

  00006	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	83 7d fc 01	 cmp	 DWORD PTR tv64[ebp], 1
  00010	74 08		 je	 SHORT $LN3@DecipherBl
  00012	83 7d fc 02	 cmp	 DWORD PTR tv64[ebp], 2
  00016	74 15		 je	 SHORT $LN2@DecipherBl
  00018	eb 26		 jmp	 SHORT $LN1@DecipherBl
$LN3@DecipherBl:

; 189  : 	{
; 190  : 	case GOST:
; 191  : 		gost_decrypt((byte *)data, (byte *)data, ks);

  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00021	52		 push	 edx
  00022	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _gost_decrypt@12

; 192  : 		break;

  0002b	eb 29		 jmp	 SHORT $LN7@DecipherBl
$LN2@DecipherBl:

; 193  : 	case GRASSHOPPER:
; 194  : 		grasshopper_decrypt(ks, (unsigned long*)data, (unsigned long*)data);

  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00034	52		 push	 edx
  00035	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _grasshopper_decrypt@12

; 195  : 		break;

  0003e	eb 16		 jmp	 SHORT $LN7@DecipherBl
$LN1@DecipherBl:

; 196  : 	default:		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00040	68 54 53 47 00	 push	 4674388			; 00475354H
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	68 c4 00 00 00	 push	 196			; 000000c4H
  0004e	6a 29		 push	 41			; 00000029H
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN7@DecipherBl:

; 197  : 	}
; 198  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 0c 00	 ret	 12			; 0000000cH
_DecipherBlock@12 ENDP
_TEXT	ENDS
PUBLIC	_DecipherBlocks@16
; Function compile flags: /Odtp
;	COMDAT _DecipherBlocks@16
_TEXT	SEGMENT
_blockSize$ = -8					; size = 4
_data$ = -4						; size = 4
_cipher$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_ks$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_DecipherBlocks@16 PROC					; COMDAT

; 214  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 215  : 	byte *data = dataPtr;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _dataPtr$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 216  : 	size_t blockSize = CipherGetBlockSize (cipher);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  00017	89 45 f8	 mov	 DWORD PTR _blockSize$[ebp], eax
$LN2@DecipherBl@2:

; 217  : 	while (blockCount-- > 0)

  0001a	8b 55 14	 mov	 edx, DWORD PTR _blockCount$[ebp]
  0001d	8b 45 14	 mov	 eax, DWORD PTR _blockCount$[ebp]
  00020	83 e8 01	 sub	 eax, 1
  00023	89 45 14	 mov	 DWORD PTR _blockCount$[ebp], eax
  00026	85 d2		 test	 edx, edx
  00028	76 1c		 jbe	 SHORT $LN3@DecipherBl@2

; 218  : 	{
; 219  : 		DecipherBlock (cipher, data, ks);

  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _data$[ebp]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _DecipherBlock@12

; 220  : 		data += blockSize;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _data$[ebp]
  0003e	03 4d f8	 add	 ecx, DWORD PTR _blockSize$[ebp]
  00041	89 4d fc	 mov	 DWORD PTR _data$[ebp], ecx

; 221  : 	}

  00044	eb d4		 jmp	 SHORT $LN2@DecipherBl@2
$LN3@DecipherBl@2:

; 222  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
_DecipherBlocks@16 ENDP
_TEXT	ENDS
PUBLIC	_CipherGet@4
; Function compile flags: /Odtp
;	COMDAT _CipherGet@4
_TEXT	SEGMENT
_i$ = -4						; size = 4
_id$ = 8						; size = 4
_CipherGet@4 PROC					; COMDAT

; 238  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 239  : 	int i;
; 240  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN4@CipherGet
$LN3@CipherGet:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CipherGet:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	6b c9 14	 imul	 ecx, 20			; 00000014H
  0001e	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _Ciphers[ecx], 0
  00025	74 20		 je	 SHORT $LN2@CipherGet

; 241  : 		if (Ciphers[i].Id == id)

  00027	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002a	6b d2 14	 imul	 edx, 20			; 00000014H
  0002d	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _Ciphers[edx]
  00033	3b 45 08	 cmp	 eax, DWORD PTR _id$[ebp]
  00036	75 0d		 jne	 SHORT $LN1@CipherGet

; 242  : 			return &Ciphers[i];

  00038	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003b	6b c0 14	 imul	 eax, 20			; 00000014H
  0003e	05 00 00 00 00	 add	 eax, OFFSET _Ciphers
  00043	eb 04		 jmp	 SHORT $LN5@CipherGet
$LN1@CipherGet:

; 243  : 
; 244  : 	return NULL;

  00045	eb c8		 jmp	 SHORT $LN3@CipherGet
$LN2@CipherGet:
  00047	33 c0		 xor	 eax, eax
$LN5@CipherGet:

; 245  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_CipherGet@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetName@4
; Function compile flags: /Odtp
;	COMDAT _CipherGetName@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetName@4 PROC					; COMDAT

; 256  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 257  : 	return CipherGet (cipherId) -> Name;

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipherId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherGet@4
  0000e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 258  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_CipherGetName@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _CipherGetBlockSize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetBlockSize@4 PROC				; COMDAT

; 269  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 270  : 	return CipherGet (cipherId) -> BlockSize;

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipherId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherGet@4
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 271  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_CipherGetBlockSize@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetKeySize@4
; Function compile flags: /Odtp
;	COMDAT _CipherGetKeySize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetKeySize@4 PROC				; COMDAT

; 282  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 283  : 	return CipherGet (cipherId) -> KeySize;

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipherId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherGet@4
  0000e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 284  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_CipherGetKeySize@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetKeyScheduleSize@4
; Function compile flags: /Odtp
;	COMDAT _CipherGetKeyScheduleSize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetKeyScheduleSize@4 PROC			; COMDAT

; 295  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 296  : 	return CipherGet (cipherId) -> KeyScheduleSize;

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipherId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherGet@4
  0000e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 297  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_CipherGetKeyScheduleSize@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherSupportsIntraDataUnitParallelization@4
; Function compile flags: /Odtp
;	COMDAT _CipherSupportsIntraDataUnitParallelization@4
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_CipherSupportsIntraDataUnitParallelization@4 PROC	; COMDAT

; 310  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 311  : 	return 0;

  00005	33 c0		 xor	 eax, eax

; 312  : }

  00007	5d		 pop	 ebp
  00008	c2 04 00	 ret	 4
_CipherSupportsIntraDataUnitParallelization@4 ENDP
_TEXT	ENDS
PUBLIC	_XorKeySchedule@20
EXTRN	_grasshopper_xor_ks@16:PROC
EXTRN	_gost_xor_ks@16:PROC
; Function compile flags: /Odtp
;	COMDAT _XorKeySchedule@20
_TEXT	SEGMENT
tv64 = -4						; size = 4
_cipher$ = 8						; size = 4
_ks$ = 12						; size = 4
_out_ks$ = 16						; size = 4
_data$ = 20						; size = 4
_len$ = 24						; size = 4
_XorKeySchedule@20 PROC					; COMDAT

; 329  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 330  : 	switch (cipher)

  00006	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	83 7d fc 01	 cmp	 DWORD PTR tv64[ebp], 1
  00010	74 08		 je	 SHORT $LN3@XorKeySche
  00012	83 7d fc 02	 cmp	 DWORD PTR tv64[ebp], 2
  00016	74 1c		 je	 SHORT $LN2@XorKeySche
  00018	eb 34		 jmp	 SHORT $LN1@XorKeySche
$LN3@XorKeySche:

; 331  : 	{
; 332  : 	case GOST:
; 333  : 		gost_xor_ks(ks, out_ks, data, len / sizeof(__int32));

  0001a	8b 4d 18	 mov	 ecx, DWORD PTR _len$[ebp]
  0001d	c1 e9 02	 shr	 ecx, 2
  00020	51		 push	 ecx
  00021	8b 55 14	 mov	 edx, DWORD PTR _data$[ebp]
  00024	52		 push	 edx
  00025	8b 45 10	 mov	 eax, DWORD PTR _out_ks$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _ks$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _gost_xor_ks@16

; 334  : 		break;

  00032	eb 30		 jmp	 SHORT $LN7@XorKeySche
$LN2@XorKeySche:

; 335  : 	case GRASSHOPPER:
; 336  : 		grasshopper_xor_ks(ks, out_ks, data, len / sizeof(__int32));

  00034	8b 55 18	 mov	 edx, DWORD PTR _len$[ebp]
  00037	c1 ea 02	 shr	 edx, 2
  0003a	52		 push	 edx
  0003b	8b 45 14	 mov	 eax, DWORD PTR _data$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 10	 mov	 ecx, DWORD PTR _out_ks$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 0c	 mov	 edx, DWORD PTR _ks$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _grasshopper_xor_ks@16

; 337  : 		break;

  0004c	eb 16		 jmp	 SHORT $LN7@XorKeySche
$LN1@XorKeySche:

; 338  : 	default:
; 339  : 		GST_THROW_FATAL_EXCEPTION;

  0004e	68 54 53 47 00	 push	 4674388			; 00475354H
  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	68 53 01 00 00	 push	 339			; 00000153H
  0005c	6a 29		 push	 41			; 00000029H
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN7@XorKeySche:

; 340  : 	}
; 341  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 14 00	 ret	 20			; 00000014H
_XorKeySchedule@20 ENDP
_TEXT	ENDS
PUBLIC	_EAGetFirst@0
; Function compile flags: /Odtp
;	COMDAT _EAGetFirst@0
_TEXT	SEGMENT
_EAGetFirst@0 PROC					; COMDAT

; 353  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 354  : 	return 1;

  00005	b8 01 00 00 00	 mov	 eax, 1

; 355  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_EAGetFirst@0 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNext@4
PUBLIC	_EAGetCount@0
; Function compile flags: /Odtp
;	COMDAT _EAGetCount@0
_TEXT	SEGMENT
_ea$ = -8						; size = 4
_count$ = -4						; size = 4
_EAGetCount@0 PROC					; COMDAT

; 366  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 367  : 	int ea, count = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 368  : 
; 369  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  0000f	e8 00 00 00 00	 call	 _EAGetFirst@0
  00014	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
  00017	eb 0c		 jmp	 SHORT $LN3@EAGetCount
$LN2@EAGetCount:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _ea$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _EAGetNext@4
  00022	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
$LN3@EAGetCount:
  00025	83 7d f8 00	 cmp	 DWORD PTR _ea$[ebp], 0
  00029	74 0b		 je	 SHORT $LN1@EAGetCount

; 370  : 	{
; 371  : 		count++;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0002e	83 c1 01	 add	 ecx, 1
  00031	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 372  : 	}

  00034	eb e3		 jmp	 SHORT $LN2@EAGetCount
$LN1@EAGetCount:

; 373  : 	return count;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]

; 374  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_EAGetCount@0 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAGetNext@4
_TEXT	SEGMENT
_id$ = -4						; size = 4
_previousEA$ = 8					; size = 4
_EAGetNext@4 PROC					; COMDAT

; 385  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 386  : 	int id = previousEA + 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR _previousEA$[ebp]
  00009	83 c0 01	 add	 eax, 1
  0000c	89 45 fc	 mov	 DWORD PTR _id$[ebp], eax

; 387  : 	if (EncryptionAlgorithms[id].Ciphers[0] != 0) return id;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _id$[ebp]
  00012	c1 e1 05	 shl	 ecx, 5
  00015	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _EncryptionAlgorithms[ecx], 0
  0001c	74 05		 je	 SHORT $LN1@EAGetNext
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _id$[ebp]
  00021	eb 02		 jmp	 SHORT $LN2@EAGetNext
$LN1@EAGetNext:

; 388  : 	return 0;

  00023	33 c0		 xor	 eax, eax
$LN2@EAGetNext:

; 389  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
_EAGetNext@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNextCipher@8
PUBLIC	_EAGetFirstCipher@4
PUBLIC	_EAInit@12
; Function compile flags: /Odtp
;	COMDAT _EAInit@12
_TEXT	SEGMENT
tv75 = -12						; size = 4
_c$ = -8						; size = 4
_retVal$ = -4						; size = 4
_ea$ = 8						; size = 4
_key$ = 12						; size = 4
_ks$ = 16						; size = 4
_EAInit@12 PROC						; COMDAT

; 404  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 405  : 	int c, retVal = ERR_SUCCESS;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 0

; 406  : 
; 407  : 	if (ea == 0)

  0000f	83 7d 08 00	 cmp	 DWORD PTR _ea$[ebp], 0
  00013	75 07		 jne	 SHORT $LN8@EAInit

; 408  : 		return ERR_CIPHER_INIT_FAILURE;

  00015	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0001a	eb 77		 jmp	 SHORT $LN9@EAInit
$LN8@EAInit:

; 409  : 
; 410  : 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))

  0001c	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00025	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax
  00028	eb 10		 jmp	 SHORT $LN7@EAInit
$LN6@EAInit:
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  00037	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax
$LN7@EAInit:
  0003a	83 7d f8 00	 cmp	 DWORD PTR _c$[ebp], 0
  0003e	74 50		 je	 SHORT $LN5@EAInit

; 411  : 	{
; 412  : 		switch (CipherInit (c, key, ks))

  00040	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  00047	51		 push	 ecx
  00048	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 _CipherInit@12
  00051	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00054	83 7d f4 11	 cmp	 DWORD PTR tv75[ebp], 17	; 00000011H
  00058	74 08		 je	 SHORT $LN2@EAInit
  0005a	83 7d f4 12	 cmp	 DWORD PTR tv75[ebp], 18	; 00000012H
  0005e	74 09		 je	 SHORT $LN1@EAInit
  00060	eb 0e		 jmp	 SHORT $LN3@EAInit
$LN2@EAInit:

; 413  : 		{
; 414  : 		case ERR_CIPHER_INIT_FAILURE:
; 415  : 			return ERR_CIPHER_INIT_FAILURE;

  00062	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00067	eb 2a		 jmp	 SHORT $LN9@EAInit
$LN1@EAInit:

; 416  : 
; 417  : 		case ERR_CIPHER_INIT_WEAK_KEY:
; 418  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  00069	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 18 ; 00000012H
$LN3@EAInit:

; 419  : 			break;
; 420  : 		}
; 421  : 
; 422  : 		key += CipherGetKeySize (c);

  00070	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  00079	03 45 0c	 add	 eax, DWORD PTR _key$[ebp]
  0007c	89 45 0c	 mov	 DWORD PTR _key$[ebp], eax

; 423  : 		ks += CipherGetKeyScheduleSize (c);

  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00088	03 45 10	 add	 eax, DWORD PTR _ks$[ebp]
  0008b	89 45 10	 mov	 DWORD PTR _ks$[ebp], eax

; 424  : 	}

  0008e	eb 9a		 jmp	 SHORT $LN6@EAInit
$LN5@EAInit:

; 425  : 	return retVal;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _retVal$[ebp]
$LN9@EAInit:

; 426  : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 0c 00	 ret	 12			; 0000000cH
_EAInit@12 ENDP
_TEXT	ENDS
PUBLIC	_EAInitMode@4
; Function compile flags: /Odtp
;	COMDAT _EAInitMode@4
_TEXT	SEGMENT
tv65 = -4						; size = 4
_ci$ = 8						; size = 4
_EAInitMode@4 PROC					; COMDAT

; 440  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 441  : 	switch (ci->mode)

  00006	8b 45 08	 mov	 eax, DWORD PTR _ci$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
  0000f	83 7d fc 01	 cmp	 DWORD PTR tv65[ebp], 1
  00013	74 08		 je	 SHORT $LN5@EAInitMode
  00015	83 7d fc 02	 cmp	 DWORD PTR tv65[ebp], 2
  00019	74 2a		 je	 SHORT $LN3@EAInitMode
  0001b	eb 50		 jmp	 SHORT $LN1@EAInitMode
$LN5@EAInitMode:

; 442  : 	{
; 443  : 	case XTS:
; 444  : 		// Secondary key schedule
; 445  : 		if (EAInit (ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)

  0001d	8b 55 08	 mov	 edx, DWORD PTR _ci$[ebp]
  00020	81 c2 28 02 00
	00		 add	 edx, 552		; 00000228H
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR _ci$[ebp]
  0002a	05 50 1d 00 00	 add	 eax, 7504		; 00001d50H
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _ci$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _EAInit@12
  0003b	85 c0		 test	 eax, eax
  0003d	74 04		 je	 SHORT $LN4@EAInitMode

; 446  : 			return FALSE;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 45		 jmp	 SHORT $LN9@EAInitMode
$LN4@EAInitMode:

; 447  : 
; 448  : 		/* Note: XTS mode could potentially be initialized with a weak key causing all blocks in one data unit
; 449  : 		on the volume to be tweaked with zero tweaks (i.e. 512 bytes of the volume would be encrypted in ECB
; 450  : 		mode). However, to create a GostCrypt volume with such a weak key, each human being on Earth would have
; 451  : 		to create approximately 11,378,125,361,078,862 (about eleven quadrillion) GostCrypt volumes (provided 
; 452  : 		that the size of each of the volumes is 1024 terabytes). */
; 453  : 		break;

  00043	eb 3e		 jmp	 SHORT $LN6@EAInitMode
$LN3@EAInitMode:

; 454  : 	case XTS8:
; 455  : 		if (EAInit(ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)

  00045	8b 45 08	 mov	 eax, DWORD PTR _ci$[ebp]
  00048	05 28 02 00 00	 add	 eax, 552		; 00000228H
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _ci$[ebp]
  00051	81 c1 50 1d 00
	00		 add	 ecx, 7504		; 00001d50H
  00057	51		 push	 ecx
  00058	8b 55 08	 mov	 edx, DWORD PTR _ci$[ebp]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _EAInit@12
  00063	85 c0		 test	 eax, eax
  00065	74 04		 je	 SHORT $LN2@EAInitMode

; 456  : 			return FALSE;

  00067	33 c0		 xor	 eax, eax
  00069	eb 1d		 jmp	 SHORT $LN9@EAInitMode
$LN2@EAInitMode:

; 457  : 		break;

  0006b	eb 16		 jmp	 SHORT $LN6@EAInitMode
$LN1@EAInitMode:

; 458  : 
; 459  : 	default:		
; 460  : 		// Unknown/wrong ID
; 461  : 		GST_THROW_FATAL_EXCEPTION;

  0006d	68 54 53 47 00	 push	 4674388			; 00475354H
  00072	6a 00		 push	 0
  00074	6a 00		 push	 0
  00076	68 cd 01 00 00	 push	 461			; 000001cdH
  0007b	6a 29		 push	 41			; 00000029H
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN6@EAInitMode:

; 462  : 	}
; 463  : 	return TRUE;

  00083	b8 01 00 00 00	 mov	 eax, 1
$LN9@EAInitMode:

; 464  : }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
_EAInitMode@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	_EAGetPreviousCipher@8
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	_EAGetLastCipher@4
PUBLIC	_EAGetName@8
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@ DB '-', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@ DB '?', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _EAGetName@8
_TEXT	SEGMENT
tv171 = -57						; size = 1
tv168 = -56						; size = 4
tv165 = -52						; size = 4
tv164 = -48						; size = 4
tv159 = -41						; size = 1
tv156 = -40						; size = 4
tv154 = -36						; size = 4
tv145 = -29						; size = 1
tv142 = -28						; size = 4
tv74 = -21						; size = 1
tv73 = -20						; size = 4
tv72 = -16						; size = 4
tv71 = -12						; size = 4
tv70 = -8						; size = 4
_i$ = -4						; size = 4
_buf$ = 8						; size = 4
_ea$ = 12						; size = 4
_EAGetName@8 PROC					; COMDAT

; 478  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00008	56		 push	 esi
  00009	57		 push	 edi

; 479  : 	int i = EAGetLastCipher(ea);

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _ea$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00013	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 480  : 	strcpy (buf, (i != 0) ? CipherGetName (i) : "?");

  00016	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0001a	74 0e		 je	 SHORT $LN5@EAGetName
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _CipherGetName@4
  00025	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00028	eb 07		 jmp	 SHORT $LN6@EAGetName
$LN5@EAGetName:
  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
$LN6@EAGetName:
  00031	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00034	89 55 f4	 mov	 DWORD PTR tv71[ebp], edx
  00037	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0003a	89 45 f0	 mov	 DWORD PTR tv72[ebp], eax
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR tv72[ebp]
  00040	89 4d ec	 mov	 DWORD PTR tv73[ebp], ecx
$LN7@EAGetName:
  00043	8b 55 f4	 mov	 edx, DWORD PTR tv71[ebp]
  00046	8a 02		 mov	 al, BYTE PTR [edx]
  00048	88 45 eb	 mov	 BYTE PTR tv74[ebp], al
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR tv72[ebp]
  0004e	8a 55 eb	 mov	 dl, BYTE PTR tv74[ebp]
  00051	88 11		 mov	 BYTE PTR [ecx], dl
  00053	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR tv72[ebp]
  0005f	83 c1 01	 add	 ecx, 1
  00062	89 4d f0	 mov	 DWORD PTR tv72[ebp], ecx
  00065	80 7d eb 00	 cmp	 BYTE PTR tv74[ebp], 0
  00069	75 d8		 jne	 SHORT $LN7@EAGetName
$LN2@EAGetName:

; 481  : 
; 482  : 	while (i = EAGetPreviousCipher(ea, i))

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0006e	52		 push	 edx
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _ea$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  00078	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0007b	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0007f	0f 84 94 00 00
	00		 je	 $LN1@EAGetName

; 483  : 	{
; 484  : 		strcat (buf, "-");

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00088	83 c1 ff	 add	 ecx, -1
  0008b	89 4d e4	 mov	 DWORD PTR tv142[ebp], ecx
$LL8@EAGetName:
  0008e	8b 55 e4	 mov	 edx, DWORD PTR tv142[ebp]
  00091	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00094	88 45 e3	 mov	 BYTE PTR tv145[ebp], al
  00097	83 45 e4 01	 add	 DWORD PTR tv142[ebp], 1
  0009b	80 7d e3 00	 cmp	 BYTE PTR tv145[ebp], 0
  0009f	75 ed		 jne	 SHORT $LL8@EAGetName
  000a1	8b 7d e4	 mov	 edi, DWORD PTR tv142[ebp]
  000a4	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
  000ab	66 89 0f	 mov	 WORD PTR [edi], cx

; 485  : 		strcat (buf, CipherGetName (i));

  000ae	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 _CipherGetName@4
  000b7	89 45 dc	 mov	 DWORD PTR tv154[ebp], eax
  000ba	8b 45 dc	 mov	 eax, DWORD PTR tv154[ebp]
  000bd	89 45 d8	 mov	 DWORD PTR tv156[ebp], eax
$LL9@EAGetName:
  000c0	8b 4d dc	 mov	 ecx, DWORD PTR tv154[ebp]
  000c3	8a 11		 mov	 dl, BYTE PTR [ecx]
  000c5	88 55 d7	 mov	 BYTE PTR tv159[ebp], dl
  000c8	83 45 dc 01	 add	 DWORD PTR tv154[ebp], 1
  000cc	80 7d d7 00	 cmp	 BYTE PTR tv159[ebp], 0
  000d0	75 ee		 jne	 SHORT $LL9@EAGetName
  000d2	8b 45 dc	 mov	 eax, DWORD PTR tv154[ebp]
  000d5	2b 45 d8	 sub	 eax, DWORD PTR tv156[ebp]
  000d8	8b 4d d8	 mov	 ecx, DWORD PTR tv156[ebp]
  000db	89 4d d0	 mov	 DWORD PTR tv164[ebp], ecx
  000de	89 45 cc	 mov	 DWORD PTR tv165[ebp], eax
  000e1	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000e4	83 c2 ff	 add	 edx, -1
  000e7	89 55 c8	 mov	 DWORD PTR tv168[ebp], edx
$LL10@EAGetName:
  000ea	8b 45 c8	 mov	 eax, DWORD PTR tv168[ebp]
  000ed	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000f0	88 4d c7	 mov	 BYTE PTR tv171[ebp], cl
  000f3	83 45 c8 01	 add	 DWORD PTR tv168[ebp], 1
  000f7	80 7d c7 00	 cmp	 BYTE PTR tv171[ebp], 0
  000fb	75 ed		 jne	 SHORT $LL10@EAGetName
  000fd	8b 7d c8	 mov	 edi, DWORD PTR tv168[ebp]
  00100	8b 75 d0	 mov	 esi, DWORD PTR tv164[ebp]
  00103	8b 55 cc	 mov	 edx, DWORD PTR tv165[ebp]
  00106	8b ca		 mov	 ecx, edx
  00108	c1 e9 02	 shr	 ecx, 2
  0010b	f3 a5		 rep movsd
  0010d	8b ca		 mov	 ecx, edx
  0010f	83 e1 03	 and	 ecx, 3
  00112	f3 a4		 rep movsb

; 486  : 	}

  00114	e9 52 ff ff ff	 jmp	 $LN2@EAGetName
$LN1@EAGetName:

; 487  : 
; 488  : 	return buf;

  00119	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]

; 489  : }

  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 08 00	 ret	 8
_EAGetName@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_EAGetByName@4
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
;	COMDAT _EAGetByName@4
_TEXT	SEGMENT
tv70 = -160						; size = 4
tv128 = -156						; size = 4
tv91 = -150						; size = 1
tv84 = -149						; size = 1
tv78 = -148						; size = 4
tv80 = -144						; size = 4
_ea$ = -140						; size = 4
_n$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_EAGetByName@4 PROC					; COMDAT

; 501  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 502  : 	int ea = EAGetFirst ();

  00015	e8 00 00 00 00	 call	 _EAGetFirst@0
  0001a	89 85 74 ff ff
	ff		 mov	 DWORD PTR _ea$[ebp], eax
$LN4@EAGetByNam:

; 503  : 	char n[128];
; 504  : 
; 505  : 	do
; 506  : 	{
; 507  : 		EAGetName (n, ea);

  00020	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ea$[ebp]
  00026	50		 push	 eax
  00027	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _n$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _EAGetName@8

; 508  : 		if (strcmp (n, name) == 0)

  00033	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  00036	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv80[ebp], edx
  0003c	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  00042	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
$LL7@EAGetByNam:
  00048	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  0004e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00050	88 95 6b ff ff
	ff		 mov	 BYTE PTR tv84[ebp], dl
  00056	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv80[ebp]
  0005c	3a 10		 cmp	 dl, BYTE PTR [eax]
  0005e	75 46		 jne	 SHORT $LN8@EAGetByNam
  00060	80 bd 6b ff ff
	ff 00		 cmp	 BYTE PTR tv84[ebp], 0
  00067	74 31		 je	 SHORT $LN9@EAGetByNam
  00069	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  0006f	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00072	88 95 6a ff ff
	ff		 mov	 BYTE PTR tv91[ebp], dl
  00078	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv80[ebp]
  0007e	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00081	75 23		 jne	 SHORT $LN8@EAGetByNam
  00083	83 85 6c ff ff
	ff 02		 add	 DWORD PTR tv78[ebp], 2
  0008a	83 85 70 ff ff
	ff 02		 add	 DWORD PTR tv80[ebp], 2
  00091	80 bd 6a ff ff
	ff 00		 cmp	 BYTE PTR tv91[ebp], 0
  00098	75 ae		 jne	 SHORT $LL7@EAGetByNam
$LN9@EAGetByNam:
  0009a	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv128[ebp], 0
  000a4	eb 0b		 jmp	 SHORT $LN10@EAGetByNam
$LN8@EAGetByNam:
  000a6	1b c9		 sbb	 ecx, ecx
  000a8	83 d9 ff	 sbb	 ecx, -1
  000ab	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv128[ebp], ecx
$LN10@EAGetByNam:
  000b1	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv128[ebp]
  000b7	89 95 60 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], edx
  000bd	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR tv70[ebp], 0
  000c4	75 08		 jne	 SHORT $LN3@EAGetByNam

; 509  : 			return ea;

  000c6	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ea$[ebp]
  000cc	eb 21		 jmp	 SHORT $LN5@EAGetByNam
$LN3@EAGetByNam:

; 510  : 	}
; 511  : 	while (ea = EAGetNext (ea));

  000ce	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ea$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _EAGetNext@4
  000da	89 85 74 ff ff
	ff		 mov	 DWORD PTR _ea$[ebp], eax
  000e0	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _ea$[ebp], 0
  000e7	0f 85 33 ff ff
	ff		 jne	 $LN4@EAGetByNam

; 512  : 
; 513  : 	return 0;

  000ed	33 c0		 xor	 eax, eax
$LN5@EAGetByNam:

; 514  : }

  000ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f2	33 cd		 xor	 ecx, ebp
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 04 00	 ret	 4
_EAGetByName@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetKeySize@4
; Function compile flags: /Odtp
;	COMDAT _EAGetKeySize@4
_TEXT	SEGMENT
_size$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_EAGetKeySize@4 PROC					; COMDAT

; 528  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 529  : 	int i = EAGetFirstCipher (ea);

  00008	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00011	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 530  : 	int size = CipherGetKeySize (i);

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  0001d	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax
$LN2@EAGetKeySi:

; 531  : 
; 532  : 	while (i = EAGetNextCipher (ea, i))

  00020	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0002d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00030	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00034	74 11		 je	 SHORT $LN1@EAGetKeySi

; 533  : 	{
; 534  : 		size += CipherGetKeySize (i);

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  0003f	03 45 f8	 add	 eax, DWORD PTR _size$[ebp]
  00042	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax

; 535  : 	}

  00045	eb d9		 jmp	 SHORT $LN2@EAGetKeySi
$LN1@EAGetKeySi:

; 536  : 
; 537  : 	return size;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]

; 538  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
_EAGetKeySize@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetFirstMode@4
; Function compile flags: /Odtp
;	COMDAT _EAGetFirstMode@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetFirstMode@4 PROC					; COMDAT

; 551  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 552  : 	return (EncryptionAlgorithms[ea].Modes[0]);

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	c1 e0 05	 shl	 eax, 5
  0000b	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+16]

; 553  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAGetFirstMode@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNextMode@8
; Function compile flags: /Odtp
;	COMDAT _EAGetNextMode@8
_TEXT	SEGMENT
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_previousModeId$ = 12					; size = 4
_EAGetNextMode@8 PROC					; COMDAT

; 566  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 567  : 	int c, i = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN3@EAGetNextM:

; 568  : 	while (c = EncryptionAlgorithms[ea].Modes[i++])

  0000f	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00012	c1 e0 05	 shl	 eax, 5
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00018	8b 94 88 10 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax+ecx*4+16]
  0001f	89 55 f8	 mov	 DWORD PTR _c$[ebp], edx
  00022	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00028	83 c1 01	 add	 ecx, 1
  0002b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0002e	85 c0		 test	 eax, eax
  00030	74 1c		 je	 SHORT $LN2@EAGetNextM

; 569  : 	{
; 570  : 		if (c == previousModeId) 

  00032	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  00035	3b 55 0c	 cmp	 edx, DWORD PTR _previousModeId$[ebp]
  00038	75 12		 jne	 SHORT $LN1@EAGetNextM

; 571  : 			return EncryptionAlgorithms[ea].Modes[i];

  0003a	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0003d	c1 e0 05	 shl	 eax, 5
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00043	8b 84 88 10 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+ecx*4+16]
  0004a	eb 04		 jmp	 SHORT $LN4@EAGetNextM
$LN1@EAGetNextM:

; 572  : 	}

  0004c	eb c1		 jmp	 SHORT $LN3@EAGetNextM
$LN2@EAGetNextM:

; 573  : 
; 574  : 	return 0;

  0004e	33 c0		 xor	 eax, eax
$LN4@EAGetNextM:

; 575  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
_EAGetNextMode@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	_EAGetModeName@12
;	COMDAT ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@ DB '[unknown]', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@ DB 'XTS 64-bit ver'
	DB	'sion', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@ DB 'XTS', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _EAGetModeName@12
_TEXT	SEGMENT
tv64 = -4						; size = 4
_ea$ = 8						; size = 4
_mode$ = 12						; size = 4
_capitalLetters$ = 16					; size = 4
_EAGetModeName@12 PROC					; COMDAT

; 592  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 593  : 	switch (mode)

  00006	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	83 7d fc 01	 cmp	 DWORD PTR tv64[ebp], 1
  00010	74 08		 je	 SHORT $LN2@EAGetModeN
  00012	83 7d fc 02	 cmp	 DWORD PTR tv64[ebp], 2
  00016	74 09		 je	 SHORT $LN1@EAGetModeN
  00018	eb 0e		 jmp	 SHORT $LN3@EAGetModeN
$LN2@EAGetModeN:

; 594  : 	{
; 595  : 	case XTS:
; 596  : 		return "XTS";

  0001a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
  0001f	eb 0c		 jmp	 SHORT $LN5@EAGetModeN
$LN1@EAGetModeN:

; 597  : 	case XTS8:
; 598  : 		return "XTS 64-bit version";

  00021	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@
  00026	eb 05		 jmp	 SHORT $LN5@EAGetModeN
$LN3@EAGetModeN:

; 599  : 	}
; 600  : 	return "[unknown]";

  00028	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
$LN5@EAGetModeN:

; 601  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
_EAGetModeName@12 ENDP
_TEXT	ENDS
PUBLIC	_EAGetKeyScheduleSize@4
; Function compile flags: /Odtp
;	COMDAT _EAGetKeyScheduleSize@4
_TEXT	SEGMENT
_size$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_EAGetKeyScheduleSize@4 PROC				; COMDAT

; 616  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 617  : 	int i = EAGetFirstCipher(ea);

  00008	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00011	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 618  : 	int size = CipherGetKeyScheduleSize (i);

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0001d	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax
$LN2@EAGetKeySc:

; 619  : 
; 620  : 	while (i = EAGetNextCipher(ea, i))

  00020	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0002d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00030	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00034	74 11		 je	 SHORT $LN1@EAGetKeySc

; 621  : 	{
; 622  : 		size += CipherGetKeyScheduleSize (i);

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0003f	03 45 f8	 add	 eax, DWORD PTR _size$[ebp]
  00042	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax

; 623  : 	}

  00045	eb d9		 jmp	 SHORT $LN2@EAGetKeySc
$LN1@EAGetKeySc:

; 624  : 
; 625  : 	return size;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]

; 626  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
_EAGetKeyScheduleSize@4 ENDP
_TEXT	ENDS
PUBLIC	_EAIsModeSupported@8
PUBLIC	_EAGetLargestKeyForMode@4
; Function compile flags: /Odtp
;	COMDAT _EAGetLargestKeyForMode@4
_TEXT	SEGMENT
_ea$ = -8						; size = 4
_key$ = -4						; size = 4
_mode$ = 8						; size = 4
_EAGetLargestKeyForMode@4 PROC				; COMDAT

; 639  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 640  : 	int ea, key = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _key$[ebp], 0

; 641  : 
; 642  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  0000f	e8 00 00 00 00	 call	 _EAGetFirst@0
  00014	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
  00017	eb 0c		 jmp	 SHORT $LN5@EAGetLarge
$LN4@EAGetLarge:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _ea$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _EAGetNext@4
  00022	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
$LN5@EAGetLarge:
  00025	83 7d f8 00	 cmp	 DWORD PTR _ea$[ebp], 0
  00029	74 2f		 je	 SHORT $LN3@EAGetLarge

; 643  : 	{
; 644  : 		if (!EAIsModeSupported (ea, mode))

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _mode$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 f8	 mov	 edx, DWORD PTR _ea$[ebp]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 _EAIsModeSupported@8
  00038	85 c0		 test	 eax, eax
  0003a	75 02		 jne	 SHORT $LN2@EAGetLarge

; 645  : 			continue;

  0003c	eb db		 jmp	 SHORT $LN4@EAGetLarge
$LN2@EAGetLarge:

; 646  : 
; 647  : 		if (EAGetKeySize (ea) >= key)

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _ea$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00047	3b 45 fc	 cmp	 eax, DWORD PTR _key$[ebp]
  0004a	7c 0c		 jl	 SHORT $LN1@EAGetLarge

; 648  : 			key = EAGetKeySize (ea);

  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _ea$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00055	89 45 fc	 mov	 DWORD PTR _key$[ebp], eax
$LN1@EAGetLarge:

; 649  : 	}

  00058	eb bf		 jmp	 SHORT $LN4@EAGetLarge
$LN3@EAGetLarge:

; 650  : 	return key;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _key$[ebp]

; 651  : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_EAGetLargestKeyForMode@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetLargestKey@0
; Function compile flags: /Odtp
;	COMDAT _EAGetLargestKey@0
_TEXT	SEGMENT
_ea$ = -8						; size = 4
_key$ = -4						; size = 4
_EAGetLargestKey@0 PROC					; COMDAT

; 663  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 664  : 	int ea, key = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _key$[ebp], 0

; 665  : 
; 666  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  0000f	e8 00 00 00 00	 call	 _EAGetFirst@0
  00014	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
  00017	eb 0c		 jmp	 SHORT $LN4@EAGetLarge@2
$LN3@EAGetLarge@2:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _ea$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _EAGetNext@4
  00022	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
$LN4@EAGetLarge@2:
  00025	83 7d f8 00	 cmp	 DWORD PTR _ea$[ebp], 0
  00029	74 1c		 je	 SHORT $LN2@EAGetLarge@2

; 667  : 	{
; 668  : 		if (EAGetKeySize (ea) >= key)

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _ea$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00034	3b 45 fc	 cmp	 eax, DWORD PTR _key$[ebp]
  00037	7c 0c		 jl	 SHORT $LN1@EAGetLarge@2

; 669  : 			key = EAGetKeySize (ea);

  00039	8b 55 f8	 mov	 edx, DWORD PTR _ea$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00042	89 45 fc	 mov	 DWORD PTR _key$[ebp], eax
$LN1@EAGetLarge@2:

; 670  : 	}

  00045	eb d2		 jmp	 SHORT $LN3@EAGetLarge@2
$LN2@EAGetLarge@2:

; 671  : 
; 672  : 	return key;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _key$[ebp]

; 673  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_EAGetLargestKey@0 ENDP
_TEXT	ENDS
PUBLIC	_EAGetCipherCount@4
; Function compile flags: /Odtp
;	COMDAT _EAGetCipherCount@4
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_EAGetCipherCount@4 PROC				; COMDAT

; 686  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 687  : 	int i = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@EAGetCiphe:

; 688  : 	while (EncryptionAlgorithms[ea].Ciphers[i++]);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00010	c1 e0 05	 shl	 eax, 5
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00016	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax+ecx*4]
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00020	83 c0 01	 add	 eax, 1
  00023	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00026	85 d2		 test	 edx, edx
  00028	74 02		 je	 SHORT $LN1@EAGetCiphe
  0002a	eb e1		 jmp	 SHORT $LN2@EAGetCiphe
$LN1@EAGetCiphe:

; 689  : 
; 690  : 	return i - 1;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002f	83 e8 01	 sub	 eax, 1

; 691  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_EAGetCipherCount@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAGetFirstCipher@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetFirstCipher@4 PROC				; COMDAT

; 703  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 704  : 	return EncryptionAlgorithms[ea].Ciphers[0];

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	c1 e0 05	 shl	 eax, 5
  0000b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]

; 705  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAGetFirstCipher@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAGetLastCipher@4
_TEXT	SEGMENT
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_EAGetLastCipher@4 PROC					; COMDAT

; 717  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 718  : 	int c, i = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@EAGetLastC:

; 719  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++]);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00012	c1 e0 05	 shl	 eax, 5
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00018	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax+ecx*4]
  0001f	89 55 f8	 mov	 DWORD PTR _c$[ebp], edx
  00022	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00028	83 c1 01	 add	 ecx, 1
  0002b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0002e	85 c0		 test	 eax, eax
  00030	74 02		 je	 SHORT $LN1@EAGetLastC
  00032	eb db		 jmp	 SHORT $LN2@EAGetLastC
$LN1@EAGetLastC:

; 720  : 
; 721  : 	return EncryptionAlgorithms[ea].Ciphers[i - 2];

  00034	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00037	c1 e2 05	 shl	 edx, 5
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	8b 84 82 f8 ff
	ff ff		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edx+eax*4-8]

; 722  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
_EAGetLastCipher@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAGetNextCipher@8
_TEXT	SEGMENT
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_previousCipherId$ = 12					; size = 4
_EAGetNextCipher@8 PROC					; COMDAT

; 735  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 736  : 	int c, i = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN3@EAGetNextC:

; 737  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  0000f	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00012	c1 e0 05	 shl	 eax, 5
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00018	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax+ecx*4]
  0001f	89 55 f8	 mov	 DWORD PTR _c$[ebp], edx
  00022	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00028	83 c1 01	 add	 ecx, 1
  0002b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0002e	85 c0		 test	 eax, eax
  00030	74 1c		 je	 SHORT $LN2@EAGetNextC

; 738  : 	{
; 739  : 		if (c == previousCipherId) 

  00032	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  00035	3b 55 0c	 cmp	 edx, DWORD PTR _previousCipherId$[ebp]
  00038	75 12		 jne	 SHORT $LN1@EAGetNextC

; 740  : 			return EncryptionAlgorithms[ea].Ciphers[i];

  0003a	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0003d	c1 e0 05	 shl	 eax, 5
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00043	8b 84 88 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+ecx*4]
  0004a	eb 04		 jmp	 SHORT $LN4@EAGetNextC
$LN1@EAGetNextC:

; 741  : 	}

  0004c	eb c1		 jmp	 SHORT $LN3@EAGetNextC
$LN2@EAGetNextC:

; 742  : 
; 743  : 	return 0;

  0004e	33 c0		 xor	 eax, eax
$LN4@EAGetNextC:

; 744  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
_EAGetNextCipher@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAGetPreviousCipher@8
_TEXT	SEGMENT
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_previousCipherId$ = 12					; size = 4
_EAGetPreviousCipher@8 PROC				; COMDAT

; 757  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 758  : 	int c, i = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 759  : 
; 760  : 	if (EncryptionAlgorithms[ea].Ciphers[i++] == previousCipherId)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00012	c1 e0 05	 shl	 eax, 5
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00018	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax+ecx*4]
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _previousCipherId$[ebp]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00025	83 c1 01	 add	 ecx, 1
  00028	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0002b	3b d0		 cmp	 edx, eax
  0002d	75 04		 jne	 SHORT $LN3@EAGetPrevi

; 761  : 		return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 41		 jmp	 SHORT $LN5@EAGetPrevi
$LN3@EAGetPrevi:

; 762  : 
; 763  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00033	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00036	c1 e2 05	 shl	 edx, 5
  00039	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR _EncryptionAlgorithms[edx+eax*4]
  00043	89 4d f8	 mov	 DWORD PTR _c$[ebp], ecx
  00046	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  00049	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00052	85 d2		 test	 edx, edx
  00054	74 1c		 je	 SHORT $LN2@EAGetPrevi

; 764  : 	{
; 765  : 		if (c == previousCipherId) 

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  00059	3b 4d 0c	 cmp	 ecx, DWORD PTR _previousCipherId$[ebp]
  0005c	75 12		 jne	 SHORT $LN1@EAGetPrevi

; 766  : 			return EncryptionAlgorithms[ea].Ciphers[i - 2];

  0005e	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00061	c1 e2 05	 shl	 edx, 5
  00064	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00067	8b 84 82 f8 ff
	ff ff		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edx+eax*4-8]
  0006e	eb 04		 jmp	 SHORT $LN5@EAGetPrevi
$LN1@EAGetPrevi:

; 767  : 	}

  00070	eb c1		 jmp	 SHORT $LN3@EAGetPrevi
$LN2@EAGetPrevi:

; 768  : 
; 769  : 	return 0;

  00072	33 c0		 xor	 eax, eax
$LN5@EAGetPrevi:

; 770  : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
_EAGetPreviousCipher@8 ENDP
_TEXT	ENDS
PUBLIC	_EAIsFormatEnabled@4
; Function compile flags: /Odtp
;	COMDAT _EAIsFormatEnabled@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAIsFormatEnabled@4 PROC				; COMDAT

; 782  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 783  : 	return EncryptionAlgorithms[ea].FormatEnabled;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	c1 e0 05	 shl	 eax, 5
  0000b	8b 80 1c 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+28]

; 784  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAIsFormatEnabled@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAIsModeSupported@8
_TEXT	SEGMENT
_mode$ = -4						; size = 4
_ea$ = 8						; size = 4
_testedMode$ = 12					; size = 4
_EAIsModeSupported@8 PROC				; COMDAT

; 798  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 799  : 	int mode;
; 800  : 
; 801  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  00006	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _EAGetFirstMode@4
  0000f	89 45 fc	 mov	 DWORD PTR _mode$[ebp], eax
  00012	eb 10		 jmp	 SHORT $LN4@EAIsModeSu
$LN3@EAIsModeSu:
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _mode$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _EAGetNextMode@8
  00021	89 45 fc	 mov	 DWORD PTR _mode$[ebp], eax
$LN4@EAIsModeSu:
  00024	83 7d fc 00	 cmp	 DWORD PTR _mode$[ebp], 0
  00028	74 11		 je	 SHORT $LN2@EAIsModeSu

; 802  : 	{
; 803  : 		if (mode == testedMode)

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _mode$[ebp]
  0002d	3b 45 0c	 cmp	 eax, DWORD PTR _testedMode$[ebp]
  00030	75 07		 jne	 SHORT $LN1@EAIsModeSu

; 804  : 			return TRUE;

  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	eb 04		 jmp	 SHORT $LN5@EAIsModeSu
$LN1@EAIsModeSu:

; 805  : 	}

  00039	eb d9		 jmp	 SHORT $LN3@EAIsModeSu
$LN2@EAIsModeSu:

; 806  : 	return FALSE;

  0003b	33 c0		 xor	 eax, eax
$LN5@EAIsModeSu:

; 807  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
_EAIsModeSupported@8 ENDP
_TEXT	ENDS
PUBLIC	_HashGet@4
; Function compile flags: /Odtp
;	COMDAT _HashGet@4
_TEXT	SEGMENT
_i$ = -4						; size = 4
_id$ = 8						; size = 4
_HashGet@4 PROC						; COMDAT

; 819  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 820  : 	int i;
; 821  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN4@HashGet
$LN3@HashGet:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HashGet:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	c1 e1 04	 shl	 ecx, 4
  0001e	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _Hashes[ecx], 0
  00025	74 20		 je	 SHORT $LN2@HashGet

; 822  : 		if (Hashes[i].Id == id)

  00027	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002a	c1 e2 04	 shl	 edx, 4
  0002d	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _Hashes[edx]
  00033	3b 45 08	 cmp	 eax, DWORD PTR _id$[ebp]
  00036	75 0d		 jne	 SHORT $LN1@HashGet

; 823  : 			return &Hashes[i];

  00038	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003b	c1 e0 04	 shl	 eax, 4
  0003e	05 00 00 00 00	 add	 eax, OFFSET _Hashes
  00043	eb 04		 jmp	 SHORT $LN5@HashGet
$LN1@HashGet:

; 824  : 
; 825  : 	return 0;

  00045	eb c8		 jmp	 SHORT $LN3@HashGet
$LN2@HashGet:
  00047	33 c0		 xor	 eax, eax
$LN5@HashGet:

; 826  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_HashGet@4 ENDP
_TEXT	ENDS
PUBLIC	_HashGetIdByName@4
; Function compile flags: /Odtp
;	COMDAT _HashGetIdByName@4
_TEXT	SEGMENT
tv74 = -24						; size = 4
tv131 = -20						; size = 4
tv94 = -14						; size = 1
tv87 = -13						; size = 1
tv81 = -12						; size = 4
tv83 = -8						; size = 4
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_HashGetIdByName@4 PROC					; COMDAT

; 838  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 839  : 	int i;
; 840  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000f	eb 09		 jmp	 SHORT $LN4@HashGetIdB
$LN3@HashGetIdB:
  00011	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00014	83 c0 01	 add	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HashGetIdB:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001d	c1 e1 04	 shl	 ecx, 4
  00020	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _Hashes[ecx], 0
  00027	74 79		 je	 SHORT $LN2@HashGetIdB

; 841  : 		if (strcmp (Hashes[i].Name, name) == 0)

  00029	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  0002c	89 55 f8	 mov	 DWORD PTR tv83[ebp], edx
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00032	c1 e0 04	 shl	 eax, 4
  00035	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _Hashes[eax+4]
  0003b	89 4d f4	 mov	 DWORD PTR tv81[ebp], ecx
$LL7@HashGetIdB:
  0003e	8b 55 f4	 mov	 edx, DWORD PTR tv81[ebp]
  00041	8a 02		 mov	 al, BYTE PTR [edx]
  00043	88 45 f3	 mov	 BYTE PTR tv87[ebp], al
  00046	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  00049	3a 01		 cmp	 al, BYTE PTR [ecx]
  0004b	75 2e		 jne	 SHORT $LN8@HashGetIdB
  0004d	80 7d f3 00	 cmp	 BYTE PTR tv87[ebp], 0
  00051	74 1f		 je	 SHORT $LN9@HashGetIdB
  00053	8b 55 f4	 mov	 edx, DWORD PTR tv81[ebp]
  00056	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00059	88 45 f2	 mov	 BYTE PTR tv94[ebp], al
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  0005f	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  00062	75 17		 jne	 SHORT $LN8@HashGetIdB
  00064	83 45 f4 02	 add	 DWORD PTR tv81[ebp], 2
  00068	83 45 f8 02	 add	 DWORD PTR tv83[ebp], 2
  0006c	80 7d f2 00	 cmp	 BYTE PTR tv94[ebp], 0
  00070	75 cc		 jne	 SHORT $LL7@HashGetIdB
$LN9@HashGetIdB:
  00072	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv131[ebp], 0
  00079	eb 08		 jmp	 SHORT $LN10@HashGetIdB
$LN8@HashGetIdB:
  0007b	1b d2		 sbb	 edx, edx
  0007d	83 da ff	 sbb	 edx, -1
  00080	89 55 ec	 mov	 DWORD PTR tv131[ebp], edx
$LN10@HashGetIdB:
  00083	8b 45 ec	 mov	 eax, DWORD PTR tv131[ebp]
  00086	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  00089	83 7d e8 00	 cmp	 DWORD PTR tv74[ebp], 0
  0008d	75 0e		 jne	 SHORT $LN1@HashGetIdB

; 842  : 			return Hashes[i].Id;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00092	c1 e1 04	 shl	 ecx, 4
  00095	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _Hashes[ecx]
  0009b	eb 07		 jmp	 SHORT $LN5@HashGetIdB
$LN1@HashGetIdB:

; 843  : 
; 844  : 	return 0;

  0009d	e9 6f ff ff ff	 jmp	 $LN3@HashGetIdB
$LN2@HashGetIdB:
  000a2	33 c0		 xor	 eax, eax
$LN5@HashGetIdB:

; 845  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_HashGetIdByName@4 ENDP
_TEXT	ENDS
PUBLIC	_HashGetName@4
; Function compile flags: /Odtp
;	COMDAT _HashGetName@4
_TEXT	SEGMENT
_hashId$ = 8						; size = 4
_HashGetName@4 PROC					; COMDAT

; 857  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 858  : 	return HashGet (hashId) -> Name;

  00005	8b 45 08	 mov	 eax, DWORD PTR _hashId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _HashGet@4
  0000e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 859  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_HashGetName@4 ENDP
_TEXT	ENDS
PUBLIC	_HashIsDeprecated@4
; Function compile flags: /Odtp
;	COMDAT _HashIsDeprecated@4
_TEXT	SEGMENT
_hashId$ = 8						; size = 4
_HashIsDeprecated@4 PROC				; COMDAT

; 871  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 872  : 	return HashGet (hashId) -> Deprecated;

  00005	8b 45 08	 mov	 eax, DWORD PTR _hashId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _HashGet@4
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 873  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_HashIsDeprecated@4 ENDP
_TEXT	ENDS
PUBLIC	_crypto_open@0
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp
;	COMDAT _crypto_open@0
_TEXT	SEGMENT
_cryptoInfo$ = -4					; size = 4
_crypto_open@0 PROC					; COMDAT

; 894  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 895  : #ifndef GST_WINDOWS_BOOT
; 896  : 
; 897  : 	/* Do the crt allocation */
; 898  : 	PCRYPTO_INFO cryptoInfo = (PCRYPTO_INFO) GSTalloc (sizeof (CRYPTO_INFO));

  00006	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0000b	68 10 1f 00 00	 push	 7952			; 00001f10H
  00010	6a 00		 push	 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00018	89 45 fc	 mov	 DWORD PTR _cryptoInfo$[ebp], eax

; 899  : 	if (cryptoInfo == NULL)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _cryptoInfo$[ebp], 0
  0001f	75 04		 jne	 SHORT $LN1@crypto_ope

; 900  : 		return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	eb 1f		 jmp	 SHORT $LN2@crypto_ope
$LN1@crypto_ope:

; 901  : 
; 902  : 	memset (cryptoInfo, 0, sizeof (CRYPTO_INFO));

  00025	68 10 1f 00 00	 push	 7952			; 00001f10H
  0002a	6a 00		 push	 0
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _memset
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 903  : 
; 904  : #ifndef DEVICE_DRIVER
; 905  : 	VirtualLock (cryptoInfo, sizeof (CRYPTO_INFO));
; 906  : #endif
; 907  : 
; 908  : 	cryptoInfo->ea = -1;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0003b	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 909  : 	return cryptoInfo;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
$LN2@crypto_ope:

; 910  : 
; 911  : #else // GST_WINDOWS_BOOT
; 912  : 
; 913  : #if 0
; 914  : 	if (CryptoInfoBufferInUse)
; 915  : 		GST_THROW_FATAL_EXCEPTION;
; 916  : #endif
; 917  : 	CryptoInfoBufferInUse = 1;
; 918  : 	return &CryptoInfoBuffer;
; 919  : 
; 920  : #endif // GST_WINDOWS_BOOT
; 921  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_crypto_open@0 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	_crypto_loadkey@12
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT _crypto_loadkey@12
_TEXT	SEGMENT
_burnm$25967 = -8					; size = 4
_burnc$25969 = -4					; size = 4
_keyInfo$ = 8						; size = 4
_lpszUserKey$ = 12					; size = 4
_nUserKeyLen$ = 16					; size = 4
_crypto_loadkey@12 PROC					; COMDAT

; 934  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 935  : 	keyInfo->keyLength = nUserKeyLen;

  00008	8b 45 08	 mov	 eax, DWORD PTR _keyInfo$[ebp]
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _nUserKeyLen$[ebp]
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@crypto_loa:

; 936  : 	burn (keyInfo->userKey, sizeof (keyInfo->userKey));

  00011	8b 55 08	 mov	 edx, DWORD PTR _keyInfo$[ebp]
  00014	83 c2 08	 add	 edx, 8
  00017	89 55 f8	 mov	 DWORD PTR _burnm$25967[ebp], edx
  0001a	c7 45 fc 40 00
	00 00		 mov	 DWORD PTR _burnc$25969[ebp], 64 ; 00000040H
  00021	6a 40		 push	 64			; 00000040H
  00023	8b 45 08	 mov	 eax, DWORD PTR _keyInfo$[ebp]
  00026	83 c0 08	 add	 eax, 8
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@crypto_loa:
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _burnc$25969[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _burnc$25969[ebp]
  00035	83 ea 01	 sub	 edx, 1
  00038	89 55 fc	 mov	 DWORD PTR _burnc$25969[ebp], edx
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 11		 je	 SHORT $LN4@crypto_loa
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _burnm$25967[ebp]
  00042	c6 00 00	 mov	 BYTE PTR [eax], 0
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _burnm$25967[ebp]
  00048	83 c1 01	 add	 ecx, 1
  0004b	89 4d f8	 mov	 DWORD PTR _burnm$25967[ebp], ecx
  0004e	eb df		 jmp	 SHORT $LN2@crypto_loa
$LN4@crypto_loa:
  00050	33 d2		 xor	 edx, edx
  00052	75 bd		 jne	 SHORT $LN5@crypto_loa

; 937  : 	memcpy (keyInfo->userKey, lpszUserKey, nUserKeyLen);

  00054	8b 45 10	 mov	 eax, DWORD PTR _nUserKeyLen$[ebp]
  00057	50		 push	 eax
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _lpszUserKey$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 08	 mov	 edx, DWORD PTR _keyInfo$[ebp]
  0005f	83 c2 08	 add	 edx, 8
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 _memcpy
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH

; 938  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
_crypto_loadkey@12 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_crypto_close@4
EXTRN	__imp__ExFreePoolWithTag@8:PROC
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _crypto_close@4
_TEXT	SEGMENT
_burnm$25981 = -8					; size = 4
_burnc$25983 = -4					; size = 4
_cryptoInfo$ = 8					; size = 4
_crypto_close@4 PROC					; COMDAT

; 949  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 950  : #ifndef GST_WINDOWS_BOOT
; 951  : 
; 952  : 	if (cryptoInfo != NULL)

  00008	83 7d 08 00	 cmp	 DWORD PTR _cryptoInfo$[ebp], 0
  0000c	74 4f		 je	 SHORT $LN7@crypto_clo
$LN5@crypto_clo:

; 953  : 	{
; 954  : 		burn (cryptoInfo, sizeof (CRYPTO_INFO));

  0000e	8b 45 08	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR _burnm$25981[ebp], eax
  00014	c7 45 fc 10 1f
	00 00		 mov	 DWORD PTR _burnc$25983[ebp], 7952 ; 00001f10H
  0001b	68 10 1f 00 00	 push	 7952			; 00001f10H
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@crypto_clo:
  00029	8b 55 fc	 mov	 edx, DWORD PTR _burnc$25983[ebp]
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _burnc$25983[ebp]
  0002f	83 e8 01	 sub	 eax, 1
  00032	89 45 fc	 mov	 DWORD PTR _burnc$25983[ebp], eax
  00035	85 d2		 test	 edx, edx
  00037	74 11		 je	 SHORT $LN4@crypto_clo
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _burnm$25981[ebp]
  0003c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0003f	8b 55 f8	 mov	 edx, DWORD PTR _burnm$25981[ebp]
  00042	83 c2 01	 add	 edx, 1
  00045	89 55 f8	 mov	 DWORD PTR _burnm$25981[ebp], edx
  00048	eb df		 jmp	 SHORT $LN2@crypto_clo
$LN4@crypto_clo:
  0004a	33 c0		 xor	 eax, eax
  0004c	75 c0		 jne	 SHORT $LN5@crypto_clo

; 955  : #ifndef DEVICE_DRIVER
; 956  : 		VirtualUnlock (cryptoInfo, sizeof (CRYPTO_INFO));
; 957  : #endif
; 958  : 		GSTfree (cryptoInfo);

  0004e	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00056	51		 push	 ecx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN7@crypto_clo:

; 959  : 	}
; 960  : 
; 961  : #else // GST_WINDOWS_BOOT
; 962  : 
; 963  : 	burn (&CryptoInfoBuffer, sizeof (CryptoInfoBuffer));
; 964  : 	CryptoInfoBufferInUse = FALSE;
; 965  : 
; 966  : #endif // GST_WINDOWS_BOOT
; 967  : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_crypto_close@4 ENDP
_TEXT	ENDS
PUBLIC	_Xor128@8
; Function compile flags: /Odtp
;	COMDAT _Xor128@8
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_Xor128@8 PROC						; COMDAT

; 984  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 985  : 	*a++ ^= *b++;

  00005	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	33 11		 xor	 edx, DWORD PTR [ecx]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00018	89 11		 mov	 DWORD PTR [ecx], edx
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001d	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00020	83 c2 08	 add	 edx, 8
  00023	89 55 0c	 mov	 DWORD PTR _b$[ebp], edx
  00026	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00029	83 c0 08	 add	 eax, 8
  0002c	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 986  : 	*a ^= *b;

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00032	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	33 02		 xor	 eax, DWORD PTR [edx]
  00039	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003c	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  0003f	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00042	89 02		 mov	 DWORD PTR [edx], eax
  00044	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : }

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
_Xor128@8 ENDP
_TEXT	ENDS
PUBLIC	_Xor64@8
; Function compile flags: /Odtp
;	COMDAT _Xor64@8
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_Xor64@8 PROC						; COMDAT

; 1000 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1001 : 	*a ^= *b;

  00005	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	33 11		 xor	 edx, DWORD PTR [ecx]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00018	89 11		 mov	 DWORD PTR [ecx], edx
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1002 : }

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
_Xor64@8 ENDP
_TEXT	ENDS
PUBLIC	_EncryptBuffer@16
EXTRN	_EncryptBufferXTS8Byte@32:PROC
EXTRN	_EncryptBufferXTS@32:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptBuffer@16
_TEXT	SEGMENT
tv65 = -52						; size = 4
_ks2$26022 = -48					; size = 4
_cipher$26024 = -44					; size = 4
_dataUnitNo$26023 = -40					; size = 8
_ks$26021 = -28						; size = 4
_ks2$26014 = -24					; size = 4
_cipher$26016 = -20					; size = 4
_dataUnitNo$26015 = -16					; size = 8
_ks$26013 = -4						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 8
_cryptoInfo$ = 20					; size = 4
_EncryptBuffer@16 PROC					; COMDAT

; 1023 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 34	 sub	 esp, 52			; 00000034H

; 1024 : 	switch (cryptoInfo->mode)

  00008	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	89 4d cc	 mov	 DWORD PTR tv65[ebp], ecx
  00011	83 7d cc 01	 cmp	 DWORD PTR tv65[ebp], 1
  00015	74 0f		 je	 SHORT $LN9@EncryptBuf
  00017	83 7d cc 02	 cmp	 DWORD PTR tv65[ebp], 2
  0001b	0f 84 97 00 00
	00		 je	 $LN5@EncryptBuf
  00021	e9 22 01 00 00	 jmp	 $LN1@EncryptBuf
$LN9@EncryptBuf:

; 1025 : 	{
; 1026 : 	case XTS:
; 1027 : 		{
; 1028 : 			unsigned __int8 *ks = cryptoInfo->ks;

  00026	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00029	83 c2 08	 add	 edx, 8
  0002c	89 55 fc	 mov	 DWORD PTR _ks$26013[ebp], edx

; 1029 : 			unsigned __int8 *ks2 = cryptoInfo->ks2;

  0002f	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00032	05 28 02 00 00	 add	 eax, 552		; 00000228H
  00037	89 45 e8	 mov	 DWORD PTR _ks2$26014[ebp], eax

; 1030 : 			UINT64_STRUCT dataUnitNo;
; 1031 : 			int cipher;
; 1032 : 
; 1033 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1034 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1035 : 			// always assumed to be aligned with the start of a data unit.
; 1036 : 			dataUnitNo.LowPart = 0;

  0003a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$26015[ebp], 0

; 1037 : 			dataUnitNo.HighPart = 0;

  00041	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$26015[ebp+4], 0

; 1038 : 
; 1039 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1040 : 				cipher != 0;
; 1041 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  00048	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0004b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00053	89 45 ec	 mov	 DWORD PTR _cipher$26016[ebp], eax
  00056	eb 12		 jmp	 SHORT $LN8@EncryptBuf
$LN7@EncryptBuf:
  00058	8b 45 ec	 mov	 eax, DWORD PTR _cipher$26016[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  00067	89 45 ec	 mov	 DWORD PTR _cipher$26016[ebp], eax
$LN8@EncryptBuf:
  0006a	83 7d ec 00	 cmp	 DWORD PTR _cipher$26016[ebp], 0
  0006e	74 43		 je	 SHORT $LN6@EncryptBuf

; 1042 : 			{
; 1043 : 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00070	8b 45 ec	 mov	 eax, DWORD PTR _cipher$26016[ebp]
  00073	50		 push	 eax
  00074	8b 4d e8	 mov	 ecx, DWORD PTR _ks2$26014[ebp]
  00077	51		 push	 ecx
  00078	8b 55 fc	 mov	 edx, DWORD PTR _ks$26013[ebp]
  0007b	52		 push	 edx
  0007c	6a 00		 push	 0
  0007e	8d 45 f0	 lea	 eax, DWORD PTR _dataUnitNo$26015[ebp]
  00081	50		 push	 eax
  00082	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp+4]
  00085	51		 push	 ecx
  00086	8b 55 0c	 mov	 edx, DWORD PTR _len$[ebp]
  00089	52		 push	 edx
  0008a	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _EncryptBufferXTS@32

; 1044 : 
; 1045 : 				ks += CipherGetKeyScheduleSize (cipher);

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _cipher$26016[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0009c	03 45 fc	 add	 eax, DWORD PTR _ks$26013[ebp]
  0009f	89 45 fc	 mov	 DWORD PTR _ks$26013[ebp], eax

; 1046 : 				ks2 += CipherGetKeyScheduleSize (cipher);

  000a2	8b 55 ec	 mov	 edx, DWORD PTR _cipher$26016[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000ab	03 45 e8	 add	 eax, DWORD PTR _ks2$26014[ebp]
  000ae	89 45 e8	 mov	 DWORD PTR _ks2$26014[ebp], eax

; 1047 : 			}

  000b1	eb a5		 jmp	 SHORT $LN7@EncryptBuf
$LN6@EncryptBuf:

; 1048 : 		}
; 1049 : 		break;

  000b3	e9 a6 00 00 00	 jmp	 $LN13@EncryptBuf
$LN5@EncryptBuf:

; 1050 : 	case XTS8:
; 1051 : 		{
; 1052 : 				 unsigned __int8 *ks = cryptoInfo->ks;

  000b8	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  000bb	83 c0 08	 add	 eax, 8
  000be	89 45 e4	 mov	 DWORD PTR _ks$26021[ebp], eax

; 1053 : 				 unsigned __int8 *ks2 = cryptoInfo->ks2;

  000c1	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  000c4	81 c1 28 02 00
	00		 add	 ecx, 552		; 00000228H
  000ca	89 4d d0	 mov	 DWORD PTR _ks2$26022[ebp], ecx

; 1054 : 				 UINT64_STRUCT dataUnitNo;
; 1055 : 				 int cipher;
; 1056 : 
; 1057 : 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1058 : 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1059 : 				 // always assumed to be aligned with the start of a data unit.
; 1060 : 				 dataUnitNo.LowPart = 0;

  000cd	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$26023[ebp], 0

; 1061 : 				 dataUnitNo.HighPart = 0;

  000d4	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$26023[ebp+4], 0

; 1062 : 
; 1063 : 				 for (cipher = EAGetFirstCipher(cryptoInfo->ea);
; 1064 : 					 cipher != 0;
; 1065 : 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))

  000db	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  000de	8b 02		 mov	 eax, DWORD PTR [edx]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  000e6	89 45 d4	 mov	 DWORD PTR _cipher$26024[ebp], eax
  000e9	eb 12		 jmp	 SHORT $LN4@EncryptBuf
$LN3@EncryptBuf:
  000eb	8b 4d d4	 mov	 ecx, DWORD PTR _cipher$26024[ebp]
  000ee	51		 push	 ecx
  000ef	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  000f2	8b 02		 mov	 eax, DWORD PTR [edx]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  000fa	89 45 d4	 mov	 DWORD PTR _cipher$26024[ebp], eax
$LN4@EncryptBuf:
  000fd	83 7d d4 00	 cmp	 DWORD PTR _cipher$26024[ebp], 0
  00101	74 43		 je	 SHORT $LN2@EncryptBuf

; 1066 : 				 {
; 1067 : 					 EncryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00103	8b 4d d4	 mov	 ecx, DWORD PTR _cipher$26024[ebp]
  00106	51		 push	 ecx
  00107	8b 55 d0	 mov	 edx, DWORD PTR _ks2$26022[ebp]
  0010a	52		 push	 edx
  0010b	8b 45 e4	 mov	 eax, DWORD PTR _ks$26021[ebp]
  0010e	50		 push	 eax
  0010f	6a 00		 push	 0
  00111	8d 4d d8	 lea	 ecx, DWORD PTR _dataUnitNo$26023[ebp]
  00114	51		 push	 ecx
  00115	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp+4]
  00118	52		 push	 edx
  00119	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00120	51		 push	 ecx
  00121	e8 00 00 00 00	 call	 _EncryptBufferXTS8Byte@32

; 1068 : 
; 1069 : 					 ks += CipherGetKeyScheduleSize(cipher);

  00126	8b 55 d4	 mov	 edx, DWORD PTR _cipher$26024[ebp]
  00129	52		 push	 edx
  0012a	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0012f	03 45 e4	 add	 eax, DWORD PTR _ks$26021[ebp]
  00132	89 45 e4	 mov	 DWORD PTR _ks$26021[ebp], eax

; 1070 : 					 ks2 += CipherGetKeyScheduleSize(cipher);

  00135	8b 45 d4	 mov	 eax, DWORD PTR _cipher$26024[ebp]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0013e	03 45 d0	 add	 eax, DWORD PTR _ks2$26022[ebp]
  00141	89 45 d0	 mov	 DWORD PTR _ks2$26022[ebp], eax

; 1071 : 				 }

  00144	eb a5		 jmp	 SHORT $LN3@EncryptBuf
$LN2@EncryptBuf:

; 1072 : 		}
; 1073 : 		break;

  00146	eb 16		 jmp	 SHORT $LN13@EncryptBuf
$LN1@EncryptBuf:

; 1074 : 
; 1075 : 	default:		
; 1076 : 		// Unknown/wrong ID
; 1077 : 		GST_THROW_FATAL_EXCEPTION;

  00148	68 54 53 47 00	 push	 4674388			; 00475354H
  0014d	6a 00		 push	 0
  0014f	6a 00		 push	 0
  00151	68 35 04 00 00	 push	 1077			; 00000435H
  00156	6a 29		 push	 41			; 00000029H
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN13@EncryptBuf:

; 1078 : 	}
; 1079 : }

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 10 00	 ret	 16			; 00000010H
_EncryptBuffer@16 ENDP
_TEXT	ENDS
PUBLIC	_EncryptDataUnits@16
EXTRN	_EncryptionThreadPoolDoWork@20:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptDataUnits@16
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 4
_ci$ = 20						; size = 4
_EncryptDataUnits@16 PROC				; COMDAT

; 1096 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1097 : 	EncryptionThreadPoolDoWork (EncryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00005	8b 45 14	 mov	 eax, DWORD PTR _ci$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _structUnitNo$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	e8 00 00 00 00	 call	 _EncryptionThreadPoolDoWork@20

; 1098 : }

  0001c	5d		 pop	 ebp
  0001d	c2 10 00	 ret	 16			; 00000010H
_EncryptDataUnits@16 ENDP
_TEXT	ENDS
PUBLIC	_EncryptDataUnitsCurrentThread@20
EXTRN	__allmul:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptDataUnitsCurrentThread@20
_TEXT	SEGMENT
tv67 = -20						; size = 4
_ks2$ = -16						; size = 4
_cipher$ = -12						; size = 4
_ks$ = -8						; size = 4
_ea$ = -4						; size = 4
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 8
_ci$ = 24						; size = 4
_EncryptDataUnitsCurrentThread@20 PROC			; COMDAT

; 1112 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 1113 : 	int ea = ci->ea;

  00008	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	89 4d fc	 mov	 DWORD PTR _ea$[ebp], ecx

; 1114 : 	unsigned __int8 *ks = ci->ks;

  00010	8b 55 18	 mov	 edx, DWORD PTR _ci$[ebp]
  00013	83 c2 08	 add	 edx, 8
  00016	89 55 f8	 mov	 DWORD PTR _ks$[ebp], edx

; 1115 : 	unsigned __int8 *ks2 = ci->ks2;

  00019	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  0001c	05 28 02 00 00	 add	 eax, 552		; 00000228H
  00021	89 45 f0	 mov	 DWORD PTR _ks2$[ebp], eax

; 1116 : 	int cipher;
; 1117 : 
; 1118 : 	switch (ci->mode)

  00024	8b 4d 18	 mov	 ecx, DWORD PTR _ci$[ebp]
  00027	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002a	89 55 ec	 mov	 DWORD PTR tv67[ebp], edx
  0002d	83 7d ec 01	 cmp	 DWORD PTR tv67[ebp], 1
  00031	74 0b		 je	 SHORT $LN9@EncryptDat
  00033	83 7d ec 02	 cmp	 DWORD PTR tv67[ebp], 2
  00037	74 7f		 je	 SHORT $LN5@EncryptDat
  00039	e9 f1 00 00 00	 jmp	 $LN1@EncryptDat
$LN9@EncryptDat:

; 1119 : 	{
; 1120 : 	case XTS:
; 1121 : 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _ea$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00047	89 45 f4	 mov	 DWORD PTR _cipher$[ebp], eax
  0004a	eb 10		 jmp	 SHORT $LN8@EncryptDat
$LN7@EncryptDat:
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR _cipher$[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 fc	 mov	 edx, DWORD PTR _ea$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  00059	89 45 f4	 mov	 DWORD PTR _cipher$[ebp], eax
$LN8@EncryptDat:
  0005c	83 7d f4 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  00060	74 51		 je	 SHORT $LN6@EncryptDat

; 1122 : 		{
; 1123 : 			EncryptBufferXTS (buf,
; 1124 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1125 : 				structUnitNo,
; 1126 : 				0,
; 1127 : 				ks,
; 1128 : 				ks2,
; 1129 : 				cipher);

  00062	8b 45 f4	 mov	 eax, DWORD PTR _cipher$[ebp]
  00065	50		 push	 eax
  00066	8b 4d f0	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 f8	 mov	 edx, DWORD PTR _ks$[ebp]
  0006d	52		 push	 edx
  0006e	6a 00		 push	 0
  00070	8b 45 0c	 mov	 eax, DWORD PTR _structUnitNo$[ebp]
  00073	50		 push	 eax
  00074	6a 00		 push	 0
  00076	68 00 02 00 00	 push	 512			; 00000200H
  0007b	8b 4d 14	 mov	 ecx, DWORD PTR _nbrUnits$[ebp+4]
  0007e	51		 push	 ecx
  0007f	8b 55 10	 mov	 edx, DWORD PTR _nbrUnits$[ebp]
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 __allmul
  00088	52		 push	 edx
  00089	50		 push	 eax
  0008a	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _EncryptBufferXTS@32

; 1130 : 
; 1131 : 			ks += CipherGetKeyScheduleSize (cipher);

  00093	8b 4d f4	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0009c	03 45 f8	 add	 eax, DWORD PTR _ks$[ebp]
  0009f	89 45 f8	 mov	 DWORD PTR _ks$[ebp], eax

; 1132 : 			ks2 += CipherGetKeyScheduleSize (cipher);

  000a2	8b 55 f4	 mov	 edx, DWORD PTR _cipher$[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000ab	03 45 f0	 add	 eax, DWORD PTR _ks2$[ebp]
  000ae	89 45 f0	 mov	 DWORD PTR _ks2$[ebp], eax

; 1133 : 		}

  000b1	eb 99		 jmp	 SHORT $LN7@EncryptDat
$LN6@EncryptDat:

; 1134 : 		break;

  000b3	e9 8d 00 00 00	 jmp	 $LN13@EncryptDat
$LN5@EncryptDat:

; 1135 : 	case XTS8:
; 1136 : 		for (cipher = EAGetFirstCipher(ea); cipher != 0; cipher = EAGetNextCipher(ea, cipher))

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _ea$[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  000c1	89 45 f4	 mov	 DWORD PTR _cipher$[ebp], eax
  000c4	eb 10		 jmp	 SHORT $LN4@EncryptDat
$LN3@EncryptDat:
  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _cipher$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 55 fc	 mov	 edx, DWORD PTR _ea$[ebp]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  000d3	89 45 f4	 mov	 DWORD PTR _cipher$[ebp], eax
$LN4@EncryptDat:
  000d6	83 7d f4 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  000da	74 51		 je	 SHORT $LN2@EncryptDat

; 1137 : 		{
; 1138 : 			EncryptBufferXTS8Byte(buf,
; 1139 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1140 : 				structUnitNo,
; 1141 : 				0,
; 1142 : 				ks,
; 1143 : 				ks2,
; 1144 : 				cipher);

  000dc	8b 45 f4	 mov	 eax, DWORD PTR _cipher$[ebp]
  000df	50		 push	 eax
  000e0	8b 4d f0	 mov	 ecx, DWORD PTR _ks2$[ebp]
  000e3	51		 push	 ecx
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _ks$[ebp]
  000e7	52		 push	 edx
  000e8	6a 00		 push	 0
  000ea	8b 45 0c	 mov	 eax, DWORD PTR _structUnitNo$[ebp]
  000ed	50		 push	 eax
  000ee	6a 00		 push	 0
  000f0	68 00 02 00 00	 push	 512			; 00000200H
  000f5	8b 4d 14	 mov	 ecx, DWORD PTR _nbrUnits$[ebp+4]
  000f8	51		 push	 ecx
  000f9	8b 55 10	 mov	 edx, DWORD PTR _nbrUnits$[ebp]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 __allmul
  00102	52		 push	 edx
  00103	50		 push	 eax
  00104	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _EncryptBufferXTS8Byte@32

; 1145 : 
; 1146 : 			ks += CipherGetKeyScheduleSize(cipher);

  0010d	8b 4d f4	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00116	03 45 f8	 add	 eax, DWORD PTR _ks$[ebp]
  00119	89 45 f8	 mov	 DWORD PTR _ks$[ebp], eax

; 1147 : 			ks2 += CipherGetKeyScheduleSize(cipher);

  0011c	8b 55 f4	 mov	 edx, DWORD PTR _cipher$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00125	03 45 f0	 add	 eax, DWORD PTR _ks2$[ebp]
  00128	89 45 f0	 mov	 DWORD PTR _ks2$[ebp], eax

; 1148 : 		}

  0012b	eb 99		 jmp	 SHORT $LN3@EncryptDat
$LN2@EncryptDat:

; 1149 : 		break;

  0012d	eb 16		 jmp	 SHORT $LN13@EncryptDat
$LN1@EncryptDat:

; 1150 : 	default:		
; 1151 : 		// Unknown/wrong ID
; 1152 : 		GST_THROW_FATAL_EXCEPTION;

  0012f	68 54 53 47 00	 push	 4674388			; 00475354H
  00134	6a 00		 push	 0
  00136	6a 00		 push	 0
  00138	68 80 04 00 00	 push	 1152			; 00000480H
  0013d	6a 29		 push	 41			; 00000029H
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN13@EncryptDat:

; 1153 : 	}
; 1154 : }

  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 14 00	 ret	 20			; 00000014H
_EncryptDataUnitsCurrentThread@20 ENDP
_TEXT	ENDS
PUBLIC	_DecryptBuffer@16
EXTRN	_DecryptBufferXTS8Byte@32:PROC
EXTRN	_DecryptBufferXTS@32:PROC
; Function compile flags: /Odtp
;	COMDAT _DecryptBuffer@16
_TEXT	SEGMENT
tv65 = -52						; size = 4
_ks2$26087 = -48					; size = 4
_cipher$26089 = -44					; size = 4
_dataUnitNo$26088 = -40					; size = 8
_ks$26086 = -28						; size = 4
_ks2$26079 = -24					; size = 4
_cipher$26081 = -20					; size = 4
_dataUnitNo$26080 = -16					; size = 8
_ks$26078 = -4						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 8
_cryptoInfo$ = 20					; size = 4
_DecryptBuffer@16 PROC					; COMDAT

; 1168 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 34	 sub	 esp, 52			; 00000034H

; 1169 : 	switch (cryptoInfo->mode)

  00008	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	89 4d cc	 mov	 DWORD PTR tv65[ebp], ecx
  00011	83 7d cc 01	 cmp	 DWORD PTR tv65[ebp], 1
  00015	74 0f		 je	 SHORT $LN9@DecryptBuf
  00017	83 7d cc 02	 cmp	 DWORD PTR tv65[ebp], 2
  0001b	0f 84 b4 00 00
	00		 je	 $LN5@DecryptBuf
  00021	e9 5b 01 00 00	 jmp	 $LN1@DecryptBuf
$LN9@DecryptBuf:

; 1170 : 	{
; 1171 : 	case XTS:
; 1172 : 		{
; 1173 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  00026	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00029	8b 02		 mov	 eax, DWORD PTR [edx]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  00031	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00034	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00038	89 55 fc	 mov	 DWORD PTR _ks$26078[ebp], edx

; 1174 : 			unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize (cryptoInfo->ea);

  0003b	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  00046	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00049	8d 84 02 28 02
	00 00		 lea	 eax, DWORD PTR [edx+eax+552]
  00050	89 45 e8	 mov	 DWORD PTR _ks2$26079[ebp], eax

; 1175 : 			UINT64_STRUCT dataUnitNo;
; 1176 : 			int cipher;
; 1177 : 
; 1178 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1179 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1180 : 			// always assumed to be aligned with the start of the data unit 0.
; 1181 : 			dataUnitNo.LowPart = 0;

  00053	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$26080[ebp], 0

; 1182 : 			dataUnitNo.HighPart = 0;

  0005a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$26080[ebp+4], 0

; 1183 : 
; 1184 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 1185 : 				cipher != 0;
; 1186 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  00061	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  0006c	89 45 ec	 mov	 DWORD PTR _cipher$26081[ebp], eax
  0006f	eb 12		 jmp	 SHORT $LN8@DecryptBuf
$LN7@DecryptBuf:
  00071	8b 45 ec	 mov	 eax, DWORD PTR _cipher$26081[ebp]
  00074	50		 push	 eax
  00075	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00078	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  00080	89 45 ec	 mov	 DWORD PTR _cipher$26081[ebp], eax
$LN8@DecryptBuf:
  00083	83 7d ec 00	 cmp	 DWORD PTR _cipher$26081[ebp], 0
  00087	74 47		 je	 SHORT $LN6@DecryptBuf

; 1187 : 			{
; 1188 : 				ks -= CipherGetKeyScheduleSize (cipher);

  00089	8b 45 ec	 mov	 eax, DWORD PTR _cipher$26081[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _ks$26078[ebp]
  00095	2b c8		 sub	 ecx, eax
  00097	89 4d fc	 mov	 DWORD PTR _ks$26078[ebp], ecx

; 1189 : 				ks2 -= CipherGetKeyScheduleSize (cipher);

  0009a	8b 55 ec	 mov	 edx, DWORD PTR _cipher$26081[ebp]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000a3	8b 4d e8	 mov	 ecx, DWORD PTR _ks2$26079[ebp]
  000a6	2b c8		 sub	 ecx, eax
  000a8	89 4d e8	 mov	 DWORD PTR _ks2$26079[ebp], ecx

; 1190 : 
; 1191 : 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  000ab	8b 55 ec	 mov	 edx, DWORD PTR _cipher$26081[ebp]
  000ae	52		 push	 edx
  000af	8b 45 e8	 mov	 eax, DWORD PTR _ks2$26079[ebp]
  000b2	50		 push	 eax
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _ks$26078[ebp]
  000b6	51		 push	 ecx
  000b7	6a 00		 push	 0
  000b9	8d 55 f0	 lea	 edx, DWORD PTR _dataUnitNo$26080[ebp]
  000bc	52		 push	 edx
  000bd	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp+4]
  000c0	50		 push	 eax
  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _DecryptBufferXTS@32

; 1192 : 			}

  000ce	eb a1		 jmp	 SHORT $LN7@DecryptBuf
$LN6@DecryptBuf:

; 1193 : 		}
; 1194 : 		break;

  000d0	e9 c2 00 00 00	 jmp	 $LN13@DecryptBuf
$LN5@DecryptBuf:

; 1195 : 	case XTS8:
; 1196 : 	{
; 1197 : 				 unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize(cryptoInfo->ea);

  000d5	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  000e0	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  000e3	8d 44 02 08	 lea	 eax, DWORD PTR [edx+eax+8]
  000e7	89 45 e4	 mov	 DWORD PTR _ks$26086[ebp], eax

; 1198 : 				 unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize(cryptoInfo->ea);

  000ea	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  000ed	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  000f5	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  000f8	8d 94 01 28 02
	00 00		 lea	 edx, DWORD PTR [ecx+eax+552]
  000ff	89 55 d0	 mov	 DWORD PTR _ks2$26087[ebp], edx

; 1199 : 				 UINT64_STRUCT dataUnitNo;
; 1200 : 				 int cipher;
; 1201 : 
; 1202 : 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1203 : 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1204 : 				 // always assumed to be aligned with the start of the data unit 0.
; 1205 : 				 dataUnitNo.LowPart = 0;

  00102	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$26088[ebp], 0

; 1206 : 				 dataUnitNo.HighPart = 0;

  00109	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$26088[ebp+4], 0

; 1207 : 
; 1208 : 				 for (cipher = EAGetLastCipher(cryptoInfo->ea);
; 1209 : 					 cipher != 0;
; 1210 : 					 cipher = EAGetPreviousCipher(cryptoInfo->ea, cipher))

  00110	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00113	8b 08		 mov	 ecx, DWORD PTR [eax]
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  0011b	89 45 d4	 mov	 DWORD PTR _cipher$26089[ebp], eax
  0011e	eb 12		 jmp	 SHORT $LN4@DecryptBuf
$LN3@DecryptBuf:
  00120	8b 55 d4	 mov	 edx, DWORD PTR _cipher$26089[ebp]
  00123	52		 push	 edx
  00124	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00127	8b 08		 mov	 ecx, DWORD PTR [eax]
  00129	51		 push	 ecx
  0012a	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  0012f	89 45 d4	 mov	 DWORD PTR _cipher$26089[ebp], eax
$LN4@DecryptBuf:
  00132	83 7d d4 00	 cmp	 DWORD PTR _cipher$26089[ebp], 0
  00136	74 47		 je	 SHORT $LN2@DecryptBuf

; 1211 : 				 {
; 1212 : 					 ks -= CipherGetKeyScheduleSize(cipher);

  00138	8b 55 d4	 mov	 edx, DWORD PTR _cipher$26089[ebp]
  0013b	52		 push	 edx
  0013c	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00141	8b 4d e4	 mov	 ecx, DWORD PTR _ks$26086[ebp]
  00144	2b c8		 sub	 ecx, eax
  00146	89 4d e4	 mov	 DWORD PTR _ks$26086[ebp], ecx

; 1213 : 					 ks2 -= CipherGetKeyScheduleSize(cipher);

  00149	8b 55 d4	 mov	 edx, DWORD PTR _cipher$26089[ebp]
  0014c	52		 push	 edx
  0014d	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00152	8b 4d d0	 mov	 ecx, DWORD PTR _ks2$26087[ebp]
  00155	2b c8		 sub	 ecx, eax
  00157	89 4d d0	 mov	 DWORD PTR _ks2$26087[ebp], ecx

; 1214 : 
; 1215 : 					 DecryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  0015a	8b 55 d4	 mov	 edx, DWORD PTR _cipher$26089[ebp]
  0015d	52		 push	 edx
  0015e	8b 45 d0	 mov	 eax, DWORD PTR _ks2$26087[ebp]
  00161	50		 push	 eax
  00162	8b 4d e4	 mov	 ecx, DWORD PTR _ks$26086[ebp]
  00165	51		 push	 ecx
  00166	6a 00		 push	 0
  00168	8d 55 d8	 lea	 edx, DWORD PTR _dataUnitNo$26088[ebp]
  0016b	52		 push	 edx
  0016c	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp+4]
  0016f	50		 push	 eax
  00170	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00173	51		 push	 ecx
  00174	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00177	52		 push	 edx
  00178	e8 00 00 00 00	 call	 _DecryptBufferXTS8Byte@32

; 1216 : 				 }

  0017d	eb a1		 jmp	 SHORT $LN3@DecryptBuf
$LN2@DecryptBuf:

; 1217 : 	}
; 1218 : 		break;

  0017f	eb 16		 jmp	 SHORT $LN13@DecryptBuf
$LN1@DecryptBuf:

; 1219 : 	default:		
; 1220 : 		// Unknown/wrong ID
; 1221 : 		GST_THROW_FATAL_EXCEPTION;

  00181	68 54 53 47 00	 push	 4674388			; 00475354H
  00186	6a 00		 push	 0
  00188	6a 00		 push	 0
  0018a	68 c5 04 00 00	 push	 1221			; 000004c5H
  0018f	6a 29		 push	 41			; 00000029H
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN13@DecryptBuf:

; 1222 : 	}
; 1223 : }

  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c2 10 00	 ret	 16			; 00000010H
_DecryptBuffer@16 ENDP
_TEXT	ENDS
PUBLIC	_DecryptDataUnits@16
; Function compile flags: /Odtp
;	COMDAT _DecryptDataUnits@16
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 4
_ci$ = 20						; size = 4
_DecryptDataUnits@16 PROC				; COMDAT

; 1240 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1241 : 	EncryptionThreadPoolDoWork (DecryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00005	8b 45 14	 mov	 eax, DWORD PTR _ci$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _structUnitNo$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00014	50		 push	 eax
  00015	6a 01		 push	 1
  00017	e8 00 00 00 00	 call	 _EncryptionThreadPoolDoWork@20

; 1242 : }

  0001c	5d		 pop	 ebp
  0001d	c2 10 00	 ret	 16			; 00000010H
_DecryptDataUnits@16 ENDP
_TEXT	ENDS
PUBLIC	_DecryptDataUnitsCurrentThread@20
; Function compile flags: /Odtp
;	COMDAT _DecryptDataUnitsCurrentThread@20
_TEXT	SEGMENT
tv67 = -20						; size = 4
_ks2$ = -16						; size = 4
_cipher$ = -12						; size = 4
_ks$ = -8						; size = 4
_ea$ = -4						; size = 4
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 8
_ci$ = 24						; size = 4
_DecryptDataUnitsCurrentThread@20 PROC			; COMDAT

; 1259 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 1260 : 	int ea = ci->ea;

  00008	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	89 4d fc	 mov	 DWORD PTR _ea$[ebp], ecx

; 1261 : 	unsigned __int8 *ks = ci->ks;

  00010	8b 55 18	 mov	 edx, DWORD PTR _ci$[ebp]
  00013	83 c2 08	 add	 edx, 8
  00016	89 55 f8	 mov	 DWORD PTR _ks$[ebp], edx

; 1262 : 	unsigned __int8 *ks2 = ci->ks2;

  00019	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  0001c	05 28 02 00 00	 add	 eax, 552		; 00000228H
  00021	89 45 f0	 mov	 DWORD PTR _ks2$[ebp], eax

; 1263 : 	int cipher;
; 1264 : 
; 1265 : 	switch (ci->mode)

  00024	8b 4d 18	 mov	 ecx, DWORD PTR _ci$[ebp]
  00027	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002a	89 55 ec	 mov	 DWORD PTR tv67[ebp], edx
  0002d	83 7d ec 01	 cmp	 DWORD PTR tv67[ebp], 1
  00031	74 0f		 je	 SHORT $LN9@DecryptDat
  00033	83 7d ec 02	 cmp	 DWORD PTR tv67[ebp], 2
  00037	0f 84 a1 00 00
	00		 je	 $LN5@DecryptDat
  0003d	e9 35 01 00 00	 jmp	 $LN1@DecryptDat
$LN9@DecryptDat:

; 1266 : 	{
; 1267 : 	case XTS:
; 1268 : 		ks += EAGetKeyScheduleSize (ea);

  00042	8b 45 fc	 mov	 eax, DWORD PTR _ea$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  0004b	03 45 f8	 add	 eax, DWORD PTR _ks$[ebp]
  0004e	89 45 f8	 mov	 DWORD PTR _ks$[ebp], eax

; 1269 : 		ks2 += EAGetKeyScheduleSize (ea);

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _ea$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  0005a	03 45 f0	 add	 eax, DWORD PTR _ks2$[ebp]
  0005d	89 45 f0	 mov	 DWORD PTR _ks2$[ebp], eax

; 1270 : 
; 1271 : 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  00060	8b 55 fc	 mov	 edx, DWORD PTR _ea$[ebp]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00069	89 45 f4	 mov	 DWORD PTR _cipher$[ebp], eax
  0006c	eb 10		 jmp	 SHORT $LN8@DecryptDat
$LN7@DecryptDat:
  0006e	8b 45 f4	 mov	 eax, DWORD PTR _cipher$[ebp]
  00071	50		 push	 eax
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _ea$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  0007b	89 45 f4	 mov	 DWORD PTR _cipher$[ebp], eax
$LN8@DecryptDat:
  0007e	83 7d f4 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  00082	74 55		 je	 SHORT $LN6@DecryptDat

; 1272 : 		{
; 1273 : 			ks -= CipherGetKeyScheduleSize (cipher);

  00084	8b 55 f4	 mov	 edx, DWORD PTR _cipher$[ebp]
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _ks$[ebp]
  00090	2b c8		 sub	 ecx, eax
  00092	89 4d f8	 mov	 DWORD PTR _ks$[ebp], ecx

; 1274 : 			ks2 -= CipherGetKeyScheduleSize (cipher);

  00095	8b 55 f4	 mov	 edx, DWORD PTR _cipher$[ebp]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0009e	8b 4d f0	 mov	 ecx, DWORD PTR _ks2$[ebp]
  000a1	2b c8		 sub	 ecx, eax
  000a3	89 4d f0	 mov	 DWORD PTR _ks2$[ebp], ecx

; 1275 : 
; 1276 : 			DecryptBufferXTS (buf,
; 1277 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1278 : 				structUnitNo,
; 1279 : 				0,
; 1280 : 				ks,
; 1281 : 				ks2,
; 1282 : 				cipher);

  000a6	8b 55 f4	 mov	 edx, DWORD PTR _cipher$[ebp]
  000a9	52		 push	 edx
  000aa	8b 45 f0	 mov	 eax, DWORD PTR _ks2$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR _ks$[ebp]
  000b1	51		 push	 ecx
  000b2	6a 00		 push	 0
  000b4	8b 55 0c	 mov	 edx, DWORD PTR _structUnitNo$[ebp]
  000b7	52		 push	 edx
  000b8	6a 00		 push	 0
  000ba	68 00 02 00 00	 push	 512			; 00000200H
  000bf	8b 45 14	 mov	 eax, DWORD PTR _nbrUnits$[ebp+4]
  000c2	50		 push	 eax
  000c3	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  000c6	51		 push	 ecx
  000c7	e8 00 00 00 00	 call	 __allmul
  000cc	52		 push	 edx
  000cd	50		 push	 eax
  000ce	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 _DecryptBufferXTS@32

; 1283 : 		}

  000d7	eb 95		 jmp	 SHORT $LN7@DecryptDat
$LN6@DecryptDat:

; 1284 : 		break;

  000d9	e9 af 00 00 00	 jmp	 $LN13@DecryptDat
$LN5@DecryptDat:

; 1285 : 	case XTS8:
; 1286 : 		ks += EAGetKeyScheduleSize(ea);

  000de	8b 45 fc	 mov	 eax, DWORD PTR _ea$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  000e7	03 45 f8	 add	 eax, DWORD PTR _ks$[ebp]
  000ea	89 45 f8	 mov	 DWORD PTR _ks$[ebp], eax

; 1287 : 		ks2 += EAGetKeyScheduleSize(ea);

  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _ea$[ebp]
  000f0	51		 push	 ecx
  000f1	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  000f6	03 45 f0	 add	 eax, DWORD PTR _ks2$[ebp]
  000f9	89 45 f0	 mov	 DWORD PTR _ks2$[ebp], eax

; 1288 : 
; 1289 : 		for (cipher = EAGetLastCipher(ea); cipher != 0; cipher = EAGetPreviousCipher(ea, cipher))

  000fc	8b 55 fc	 mov	 edx, DWORD PTR _ea$[ebp]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00105	89 45 f4	 mov	 DWORD PTR _cipher$[ebp], eax
  00108	eb 10		 jmp	 SHORT $LN4@DecryptDat
$LN3@DecryptDat:
  0010a	8b 45 f4	 mov	 eax, DWORD PTR _cipher$[ebp]
  0010d	50		 push	 eax
  0010e	8b 4d fc	 mov	 ecx, DWORD PTR _ea$[ebp]
  00111	51		 push	 ecx
  00112	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  00117	89 45 f4	 mov	 DWORD PTR _cipher$[ebp], eax
$LN4@DecryptDat:
  0011a	83 7d f4 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  0011e	74 55		 je	 SHORT $LN2@DecryptDat

; 1290 : 		{
; 1291 : 			ks -= CipherGetKeyScheduleSize(cipher);

  00120	8b 55 f4	 mov	 edx, DWORD PTR _cipher$[ebp]
  00123	52		 push	 edx
  00124	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00129	8b 4d f8	 mov	 ecx, DWORD PTR _ks$[ebp]
  0012c	2b c8		 sub	 ecx, eax
  0012e	89 4d f8	 mov	 DWORD PTR _ks$[ebp], ecx

; 1292 : 			ks2 -= CipherGetKeyScheduleSize(cipher);

  00131	8b 55 f4	 mov	 edx, DWORD PTR _cipher$[ebp]
  00134	52		 push	 edx
  00135	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0013a	8b 4d f0	 mov	 ecx, DWORD PTR _ks2$[ebp]
  0013d	2b c8		 sub	 ecx, eax
  0013f	89 4d f0	 mov	 DWORD PTR _ks2$[ebp], ecx

; 1293 : 
; 1294 : 			DecryptBufferXTS8Byte(buf,
; 1295 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1296 : 				structUnitNo,
; 1297 : 				0,
; 1298 : 				ks,
; 1299 : 				ks2,
; 1300 : 				cipher);

  00142	8b 55 f4	 mov	 edx, DWORD PTR _cipher$[ebp]
  00145	52		 push	 edx
  00146	8b 45 f0	 mov	 eax, DWORD PTR _ks2$[ebp]
  00149	50		 push	 eax
  0014a	8b 4d f8	 mov	 ecx, DWORD PTR _ks$[ebp]
  0014d	51		 push	 ecx
  0014e	6a 00		 push	 0
  00150	8b 55 0c	 mov	 edx, DWORD PTR _structUnitNo$[ebp]
  00153	52		 push	 edx
  00154	6a 00		 push	 0
  00156	68 00 02 00 00	 push	 512			; 00000200H
  0015b	8b 45 14	 mov	 eax, DWORD PTR _nbrUnits$[ebp+4]
  0015e	50		 push	 eax
  0015f	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  00162	51		 push	 ecx
  00163	e8 00 00 00 00	 call	 __allmul
  00168	52		 push	 edx
  00169	50		 push	 eax
  0016a	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  0016d	52		 push	 edx
  0016e	e8 00 00 00 00	 call	 _DecryptBufferXTS8Byte@32

; 1301 : 		}

  00173	eb 95		 jmp	 SHORT $LN3@DecryptDat
$LN2@DecryptDat:

; 1302 : 		break;

  00175	eb 16		 jmp	 SHORT $LN13@DecryptDat
$LN1@DecryptDat:

; 1303 : 	default:		
; 1304 : 		// Unknown/wrong ID
; 1305 : 		GST_THROW_FATAL_EXCEPTION;

  00177	68 54 53 47 00	 push	 4674388			; 00475354H
  0017c	6a 00		 push	 0
  0017e	6a 00		 push	 0
  00180	68 19 05 00 00	 push	 1305			; 00000519H
  00185	6a 29		 push	 41			; 00000029H
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN13@DecryptDat:

; 1306 : 	}
; 1307 : }

  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c2 14 00	 ret	 20			; 00000014H
_DecryptDataUnitsCurrentThread@20 ENDP
_TEXT	ENDS
PUBLIC	_GetMaxPkcs5OutSize@0
; Function compile flags: /Odtp
;	COMDAT _GetMaxPkcs5OutSize@0
_TEXT	SEGMENT
tv79 = -12						; size = 4
tv71 = -8						; size = 4
_size$ = -4						; size = 4
_GetMaxPkcs5OutSize@0 PROC				; COMDAT

; 1319 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1320 : 	int size = 32;

  00008	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _size$[ebp], 32 ; 00000020H

; 1321 : 
; 1322 : 	size = max (size, EAGetLargestKeyForMode (XTS) * 2);	// Sizes of primary + secondary keys

  0000f	6a 01		 push	 1
  00011	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00016	d1 e0		 shl	 eax, 1
  00018	39 45 fc	 cmp	 DWORD PTR _size$[ebp], eax
  0001b	7e 08		 jle	 SHORT $LN3@GetMaxPkcs
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _size$[ebp]
  00020	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  00023	eb 0c		 jmp	 SHORT $LN4@GetMaxPkcs
$LN3@GetMaxPkcs:
  00025	6a 01		 push	 1
  00027	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  0002c	d1 e0		 shl	 eax, 1
  0002e	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
$LN4@GetMaxPkcs:
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv71[ebp]
  00034	89 4d fc	 mov	 DWORD PTR _size$[ebp], ecx

; 1323 : 	size = max (size, EAGetLargestKeyForMode (XTS8) * 2);

  00037	6a 02		 push	 2
  00039	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  0003e	d1 e0		 shl	 eax, 1
  00040	39 45 fc	 cmp	 DWORD PTR _size$[ebp], eax
  00043	7e 08		 jle	 SHORT $LN5@GetMaxPkcs
  00045	8b 55 fc	 mov	 edx, DWORD PTR _size$[ebp]
  00048	89 55 f4	 mov	 DWORD PTR tv79[ebp], edx
  0004b	eb 0c		 jmp	 SHORT $LN6@GetMaxPkcs
$LN5@GetMaxPkcs:
  0004d	6a 02		 push	 2
  0004f	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00054	d1 e0		 shl	 eax, 1
  00056	89 45 f4	 mov	 DWORD PTR tv79[ebp], eax
$LN6@GetMaxPkcs:
  00059	8b 45 f4	 mov	 eax, DWORD PTR tv79[ebp]
  0005c	89 45 fc	 mov	 DWORD PTR _size$[ebp], eax

; 1324 : 
; 1325 : 	return size;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _size$[ebp]

; 1326 : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_GetMaxPkcs5OutSize@0 ENDP
_TEXT	ENDS
PUBLIC	_IsAesHwCpuSupported@0
; Function compile flags: /Odtp
;	COMDAT _IsAesHwCpuSupported@0
_TEXT	SEGMENT
_IsAesHwCpuSupported@0 PROC				; COMDAT

; 1577 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1578 : 	static BOOL state = FALSE;
; 1579 : 	static BOOL stateValid = FALSE;
; 1580 : 
; 1581 : 	if (!stateValid)

  00005	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, 0
  0000c	75 14		 jne	 SHORT $LN1@IsAesHwCpu

; 1582 : 	{
; 1583 : 		state = FALSE;//state = is_aes_hw_cpu_supported() ? TRUE : FALSE;

  0000e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?state@?1??IsAesHwCpuSupported@@9@9, 0

; 1584 : 		stateValid = TRUE;

  00018	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, 1
$LN1@IsAesHwCpu:

; 1585 : 	}
; 1586 : 
; 1587 : 	return FALSE;//state && !HwEncryptionDisabled;

  00022	33 c0		 xor	 eax, eax

; 1588 : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_IsAesHwCpuSupported@0 ENDP
_TEXT	ENDS
PUBLIC	_EnableHwEncryption@4
; Function compile flags: /Odtp
;	COMDAT _EnableHwEncryption@4
_TEXT	SEGMENT
_enable$ = 8						; size = 4
_EnableHwEncryption@4 PROC				; COMDAT

; 1599 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1600 : 	//Deprecated
; 1601 : }

  00005	5d		 pop	 ebp
  00006	c2 04 00	 ret	 4
_EnableHwEncryption@4 ENDP
_TEXT	ENDS
PUBLIC	_IsHwEncryptionEnabled@0
; Function compile flags: /Odtp
;	COMDAT _IsHwEncryptionEnabled@0
_TEXT	SEGMENT
_IsHwEncryptionEnabled@0 PROC				; COMDAT

; 1611 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1612 : 	return !HwEncryptionDisabled;

  00005	33 c0		 xor	 eax, eax
  00007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HwEncryptionDisabled, 0
  0000e	0f 94 c0	 sete	 al

; 1613 : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_IsHwEncryptionEnabled@0 ENDP
_TEXT	ENDS
END
