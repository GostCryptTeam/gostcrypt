; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xts.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_EncryptBufferXTS@32
EXTRN	_CipherSupportsIntraDataUnitParallelization@4:PROC
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xts.c
;	COMDAT _EncryptBufferXTS@32
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTS@32 PROC				; COMDAT

; 56   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 57   : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00005	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization@4
  0000e	85 c0		 test	 eax, eax
  00010	74 27		 je	 SHORT $LN2@EncryptBuf

; 58   : 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00012	8b 4d 24	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 20	 mov	 edx, DWORD PTR _ks2$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 18	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 14	 mov	 edx, DWORD PTR _startDataUnitNo$[ebp]
  00025	52		 push	 edx
  00026	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp+4]
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _EncryptBufferXTSParallel@32

; 59   : 	else

  00037	eb 25		 jmp	 SHORT $LN3@EncryptBuf
$LN2@EncryptBuf:

; 60   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00039	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 1c	 mov	 edx, DWORD PTR _ks$[ebp]
  00044	52		 push	 edx
  00045	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 14	 mov	 ecx, DWORD PTR _startDataUnitNo$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00050	52		 push	 edx
  00051	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _EncryptBufferXTSNonParallel@32
$LN3@EncryptBuf:

; 61   : }

  0005e	5d		 pop	 ebp
  0005f	c2 20 00	 ret	 32			; 00000020H
_EncryptBufferXTS@32 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_EncryptBufferXTS8Byte@32
EXTRN	_XorKeySchedule@20:PROC
EXTRN	_EncipherBlock@12:PROC
EXTRN	_CipherGetKeyScheduleSize@4:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptBufferXTS8Byte@32
_TEXT	SEGMENT
tv189 = -632						; size = 8
_burnm$25587 = -624					; size = 4
_burnc$25589 = -620					; size = 4
_startBlock$ = -616					; size = 4
_block$ = -612						; size = 4
_dataUnitNo$ = -608					; size = 8
_finalCarry$ = -593					; size = 1
_whiteningValue$ = -592					; size = 8
_byteBufUnitNo$ = -584					; size = 8
_blockCount$ = -576					; size = 8
_whiteningValuePtr32$ = -564				; size = 4
_xor_ks$ = -560						; size = 544
__$ArrayPad$ = -12					; size = 4
_bufPtr$ = -8						; size = 4
_endBlock$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTS8Byte@32 PROC				; COMDAT

; 70   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 78 02 00
	00		 sub	 esp, 632		; 00000278H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 71   : 	unsigned __int8 finalCarry;
; 72   : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
; 73   : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
; 74   : 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *)whiteningValue;

  00015	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  0001b	89 85 cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], eax

; 75   : 	unsigned __int32 *bufPtr = (unsigned __int32 *)buffer;

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00024	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 76   : 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;

  00027	8b 55 18	 mov	 edx, DWORD PTR _startCipherBlockNo$[ebp]
  0002a	89 95 98 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], edx

; 77   : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 78   : 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
; 79   : 
; 80   : 	dataUnitNo = startDataUnitNo->Value;

  00030	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 8d a0 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0003b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003e	89 95 a4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], edx

; 81   : 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64(dataUnitNo);

  00044	8b 85 a0 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp]
  0004a	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], eax
  00050	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp+4]
  00056	89 8d bc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx

; 82   : 
; 83   : 	if (length % BYTES_PER_XTS_BLOCK_SMALL)

  0005c	6a 00		 push	 0
  0005e	6a 08		 push	 8
  00060	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00063	52		 push	 edx
  00064	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 __aullrem
  0006d	89 85 88 fd ff
	ff		 mov	 DWORD PTR tv189[ebp], eax
  00073	89 95 8c fd ff
	ff		 mov	 DWORD PTR tv189[ebp+4], edx
  00079	8b 8d 88 fd ff
	ff		 mov	 ecx, DWORD PTR tv189[ebp]
  0007f	0b 8d 8c fd ff
	ff		 or	 ecx, DWORD PTR tv189[ebp+4]
  00085	74 13		 je	 SHORT $LN16@EncryptBuf@2

; 84   : 		GST_THROW_FATAL_EXCEPTION;

  00087	68 54 53 47 00	 push	 4674388			; 00475354H
  0008c	6a 00		 push	 0
  0008e	6a 00		 push	 0
  00090	6a 54		 push	 84			; 00000054H
  00092	6a 29		 push	 41			; 00000029H
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN16@EncryptBuf@2:

; 85   : 
; 86   : 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;

  0009a	6a 00		 push	 0
  0009c	6a 08		 push	 8
  0009e	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  000a1	52		 push	 edx
  000a2	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 __aulldiv
  000ab	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], eax
  000b1	89 95 c4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], edx

; 87   : 
; 88   : 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));

  000b7	8b 4d 24	 mov	 ecx, DWORD PTR _cipher$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000c0	50		 push	 eax
  000c1	8b 55 1c	 mov	 edx, DWORD PTR _ks$[ebp]
  000c4	52		 push	 edx
  000c5	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _memcpy
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@EncryptBuf@2:

; 89   : 
; 90   : 	while (blockCount > 0)

  000d4	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000db	77 0d		 ja	 SHORT $LN19@EncryptBuf@2
  000dd	83 bd c0 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp], 0
  000e4	0f 86 78 02 00
	00		 jbe	 $LN5@EncryptBuf@2
$LN19@EncryptBuf@2:

; 91   : 	{
; 92   : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)

  000ea	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000f1	77 1c		 ja	 SHORT $LN13@EncryptBuf@2
  000f3	72 09		 jb	 SHORT $LN20@EncryptBuf@2
  000f5	83 bd c0 fd ff
	ff 40		 cmp	 DWORD PTR _blockCount$[ebp], 64 ; 00000040H
  000fc	73 11		 jae	 SHORT $LN13@EncryptBuf@2
$LN20@EncryptBuf@2:

; 93   : 			endBlock = startBlock + (unsigned __int32) blockCount;

  000fe	8b 8d c0 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp]
  00104	03 8d 98 fd ff
	ff		 add	 ecx, DWORD PTR _startBlock$[ebp]
  0010a	89 4d fc	 mov	 DWORD PTR _endBlock$[ebp], ecx

; 94   : 		else

  0010d	eb 07		 jmp	 SHORT $LN12@EncryptBuf@2
$LN13@EncryptBuf@2:

; 95   : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;

  0010f	c7 45 fc 40 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 64 ; 00000040H
$LN12@EncryptBuf@2:

; 96   : 
; 97   : 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;

  00116	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  0011c	89 95 cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], edx

; 98   : 
; 99   : 		//Generate first whitening value
; 100  : 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);

  00122	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  00128	8b 8d b8 fd ff
	ff		 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  0012e	89 08		 mov	 DWORD PTR [eax], ecx

; 101  : 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);

  00130	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr32$[ebp]
  00136	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _byteBufUnitNo$[ebp+4]
  0013c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 102  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0013f	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00142	51		 push	 ecx
  00143	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  00149	52		 push	 edx
  0014a	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _EncipherBlock@12

; 103  : 
; 104  : 		//XOR ks with the current DataUnitNo
; 105  : 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);

  00153	6a 08		 push	 8
  00155	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  0015b	51		 push	 ecx
  0015c	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR _xor_ks$[ebp]
  00162	52		 push	 edx
  00163	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  00166	50		 push	 eax
  00167	8b 4d 24	 mov	 ecx, DWORD PTR _cipher$[ebp]
  0016a	51		 push	 ecx
  0016b	e8 00 00 00 00	 call	 _XorKeySchedule@20

; 106  : 
; 107  : 		//Generate subsequent whitening values for blocks
; 108  : 		for (block = 0; block < endBlock; block++)

  00170	c7 85 9c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _block$[ebp], 0
  0017a	eb 0f		 jmp	 SHORT $LN11@EncryptBuf@2
$LN10@EncryptBuf@2:
  0017c	8b 95 9c fd ff
	ff		 mov	 edx, DWORD PTR _block$[ebp]
  00182	83 c2 01	 add	 edx, 1
  00185	89 95 9c fd ff
	ff		 mov	 DWORD PTR _block$[ebp], edx
$LN11@EncryptBuf@2:
  0018b	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  00191	3b 45 fc	 cmp	 eax, DWORD PTR _endBlock$[ebp]
  00194	0f 83 5c 01 00
	00		 jae	 $LN9@EncryptBuf@2

; 109  : 		{
; 110  : 			if (block >= startBlock)

  0019a	8b 8d 9c fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  001a0	3b 8d 98 fd ff
	ff		 cmp	 ecx, DWORD PTR _startBlock$[ebp]
  001a6	0f 82 af 00 00
	00		 jb	 $LN8@EncryptBuf@2

; 111  : 			{
; 112  : 				//Pre-whitening
; 113  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  001ac	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001af	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  001b5	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001b7	33 08		 xor	 ecx, DWORD PTR [eax]
  001b9	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001bc	89 0a		 mov	 DWORD PTR [edx], ecx
  001be	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  001c4	83 c0 04	 add	 eax, 4
  001c7	89 85 cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], eax
  001cd	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001d0	83 c1 04	 add	 ecx, 4
  001d3	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 114  : 				*bufPtr-- ^= *whiteningValuePtr32--;

  001d6	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001d9	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  001df	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001e1	33 08		 xor	 ecx, DWORD PTR [eax]
  001e3	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001e6	89 0a		 mov	 DWORD PTR [edx], ecx
  001e8	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  001ee	83 e8 04	 sub	 eax, 4
  001f1	89 85 cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], eax
  001f7	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001fa	83 e9 04	 sub	 ecx, 4
  001fd	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 115  : 
; 116  : 				//Actual encryption
; 117  : 				EncipherBlock(cipher, bufPtr, xor_ks);

  00200	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR _xor_ks$[ebp]
  00206	52		 push	 edx
  00207	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  0020a	50		 push	 eax
  0020b	8b 4d 24	 mov	 ecx, DWORD PTR _cipher$[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 _EncipherBlock@12

; 118  : 
; 119  : 				//Post-whitening
; 120  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  00214	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00217	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  0021d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0021f	33 08		 xor	 ecx, DWORD PTR [eax]
  00221	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00224	89 0a		 mov	 DWORD PTR [edx], ecx
  00226	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  0022c	83 c0 04	 add	 eax, 4
  0022f	89 85 cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], eax
  00235	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  00238	83 c1 04	 add	 ecx, 4
  0023b	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 121  : 				*bufPtr++ ^= *whiteningValuePtr32;

  0023e	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00241	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  00247	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00249	33 08		 xor	 ecx, DWORD PTR [eax]
  0024b	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0024e	89 0a		 mov	 DWORD PTR [edx], ecx
  00250	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00253	83 c0 04	 add	 eax, 4
  00256	89 45 f8	 mov	 DWORD PTR _bufPtr$[ebp], eax

; 122  : 			}
; 123  : 			else

  00259	eb 0f		 jmp	 SHORT $LN7@EncryptBuf@2
$LN8@EncryptBuf@2:

; 124  : 				whiteningValuePtr32++;

  0025b	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr32$[ebp]
  00261	83 c1 04	 add	 ecx, 4
  00264	89 8d cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], ecx
$LN7@EncryptBuf@2:

; 125  : 
; 126  : 			//Derive the next whitening value
; 127  : #if BYTE_ORDER == LITTLE_ENDIAN
; 128  : 
; 129  : 			//Little-endian platforms
; 130  : 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;

  0026a	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr32$[ebp]
  00270	8b 02		 mov	 eax, DWORD PTR [edx]
  00272	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00277	f7 d8		 neg	 eax
  00279	1b c0		 sbb	 eax, eax
  0027b	83 e0 1b	 and	 eax, 27			; 0000001bH
  0027e	88 85 af fd ff
	ff		 mov	 BYTE PTR _finalCarry$[ebp], al

; 131  : 
; 132  : 			*whiteningValuePtr32-- <<= 1;

  00284	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr32$[ebp]
  0028a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0028c	d1 e2		 shl	 edx, 1
  0028e	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  00294	89 10		 mov	 DWORD PTR [eax], edx
  00296	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr32$[ebp]
  0029c	83 e9 04	 sub	 ecx, 4
  0029f	89 8d cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], ecx

; 133  : 
; 134  : 			if (*whiteningValuePtr32 & 0x80000000)

  002a5	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr32$[ebp]
  002ab	8b 02		 mov	 eax, DWORD PTR [edx]
  002ad	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002b2	74 15		 je	 SHORT $LN6@EncryptBuf@2

; 135  : 				*(whiteningValuePtr32 + 1) |= 1;

  002b4	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr32$[ebp]
  002ba	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002bd	83 ca 01	 or	 edx, 1
  002c0	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  002c6	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN6@EncryptBuf@2:

; 136  : 
; 137  : 			*whiteningValuePtr32 <<= 1;

  002c9	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr32$[ebp]
  002cf	8b 11		 mov	 edx, DWORD PTR [ecx]
  002d1	d1 e2		 shl	 edx, 1
  002d3	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  002d9	89 10		 mov	 DWORD PTR [eax], edx

; 138  : #else
; 139  : 			//Big-endian platforms
; 140  : 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
; 141  : 
; 142  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 143  : 
; 144  : 			whiteningValuePtr32--;
; 145  : 
; 146  : 			if (*whiteningValuePtr32 & 0x80)
; 147  : 				*(whiteningValuePtr32 + 1) |= 0x01000000;
; 148  : 
; 149  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 150  : #endif
; 151  : 			whiteningValue[0] ^= finalCarry;

  002db	0f b6 8d af fd
	ff ff		 movzx	 ecx, BYTE PTR _finalCarry$[ebp]
  002e2	0f b6 95 b0 fd
	ff ff		 movzx	 edx, BYTE PTR _whiteningValue$[ebp]
  002e9	33 d1		 xor	 edx, ecx
  002eb	88 95 b0 fd ff
	ff		 mov	 BYTE PTR _whiteningValue$[ebp], dl

; 152  : 		}

  002f1	e9 86 fe ff ff	 jmp	 $LN10@EncryptBuf@2
$LN9@EncryptBuf@2:

; 153  : 		blockCount -= endBlock - startBlock;

  002f6	8b 45 fc	 mov	 eax, DWORD PTR _endBlock$[ebp]
  002f9	2b 85 98 fd ff
	ff		 sub	 eax, DWORD PTR _startBlock$[ebp]
  002ff	33 c9		 xor	 ecx, ecx
  00301	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR _blockCount$[ebp]
  00307	2b d0		 sub	 edx, eax
  00309	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp+4]
  0030f	1b c1		 sbb	 eax, ecx
  00311	89 95 c0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], edx
  00317	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], eax

; 154  : 		startBlock = 0;

  0031d	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _startBlock$[ebp], 0

; 155  : 		dataUnitNo++;

  00327	8b 8d a0 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  0032d	83 c1 01	 add	 ecx, 1
  00330	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp+4]
  00336	83 d2 00	 adc	 edx, 0
  00339	89 8d a0 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0033f	89 95 a4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], edx

; 156  : 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  00345	8b 85 a0 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp]
  0034b	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], eax
  00351	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp+4]
  00357	89 8d bc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx

; 157  : 	}

  0035d	e9 72 fd ff ff	 jmp	 $LN15@EncryptBuf@2
$LN5@EncryptBuf@2:

; 158  : 	FAST_ERASE32(whiteningValue, sizeof(whiteningValue));

  00362	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  00368	89 95 90 fd ff
	ff		 mov	 DWORD PTR _burnm$25587[ebp], edx
  0036e	c7 85 94 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _burnc$25589[ebp], 1
$LN2@EncryptBuf@2:
  00378	8b 85 94 fd ff
	ff		 mov	 eax, DWORD PTR _burnc$25589[ebp]
  0037e	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$25589[ebp]
  00384	83 e9 01	 sub	 ecx, 1
  00387	89 8d 94 fd ff
	ff		 mov	 DWORD PTR _burnc$25589[ebp], ecx
  0038d	85 c0		 test	 eax, eax
  0038f	74 1d		 je	 SHORT $LN4@EncryptBuf@2
  00391	8b 95 90 fd ff
	ff		 mov	 edx, DWORD PTR _burnm$25587[ebp]
  00397	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0039d	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$25587[ebp]
  003a3	83 c0 04	 add	 eax, 4
  003a6	89 85 90 fd ff
	ff		 mov	 DWORD PTR _burnm$25587[ebp], eax
  003ac	eb ca		 jmp	 SHORT $LN2@EncryptBuf@2
$LN4@EncryptBuf@2:
  003ae	33 c9		 xor	 ecx, ecx
  003b0	75 b0		 jne	 SHORT $LN5@EncryptBuf@2
$LN18@EncryptBuf@2:

; 159  : }

  003b2	8b 4d f4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b5	33 cd		 xor	 ecx, ebp
  003b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003bc	8b e5		 mov	 esp, ebp
  003be	5d		 pop	 ebp
  003bf	c2 20 00	 ret	 32			; 00000020H
_EncryptBufferXTS8Byte@32 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_EncipherBlocks@16:PROC
EXTRN	__allshl:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptBufferXTSParallel@32
_TEXT	SEGMENT
tv312 = -652						; size = 8
tv92 = -644						; size = 4
tv285 = -640						; size = 8
tv227 = -632						; size = 8
_burnm$25662 = -624					; size = 4
_burnc$25664 = -620					; size = 4
_burnm$25653 = -616					; size = 4
_burnc$25655 = -612					; size = 4
_startBlock$ = -608					; size = 4
_block$ = -604						; size = 4
_dataUnitNo$ = -600					; size = 8
_finalCarry$ = -585					; size = 1
_whiteningValue$ = -584					; size = 16
_byteBufUnitNo$ = -568					; size = 16
_whiteningValuesPtr64$ = -552				; size = 4
_whiteningValuePtr64$ = -548				; size = 4
_blockCount$ = -544					; size = 8
_dataUnitBufPtr$ = -536					; size = 4
_bufPtr$ = -532						; size = 4
_whiteningValues$ = -528				; size = 512
__$ArrayPad$ = -12					; size = 4
_finalInt64WhiteningValuesPtr$ = -8			; size = 4
_endBlock$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTSParallel@32 PROC			; COMDAT

; 169  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 8c 02 00
	00		 sub	 esp, 652		; 0000028cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 170  : 	unsigned __int8 finalCarry;
; 171  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 172  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 173  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 174  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;

  00015	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  0001b	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax

; 175  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00021	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _whiteningValue$[ebp]
  00027	89 8d dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx

; 176  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  0002d	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00030	89 95 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], edx

; 177  : 	unsigned __int64 *dataUnitBufPtr;
; 178  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00036	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00039	89 85 a0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], eax

; 179  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;

  0003f	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  00045	81 c1 f8 01 00
	00		 add	 ecx, 504		; 000001f8H
  0004b	89 4d f8	 mov	 DWORD PTR _finalInt64WhiteningValuesPtr$[ebp], ecx

; 180  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 181  : 
; 182  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 183  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 184  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 185  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 186  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 187  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 188  : 
; 189  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 190  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 191  : 	dataUnitNo = startDataUnitNo->Value;

  0004e	8b 55 14	 mov	 edx, DWORD PTR _startDataUnitNo$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], eax
  00059	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0005c	89 8d ac fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], ecx

; 192  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00062	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  00068	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], edx
  0006e	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  00074	89 85 cc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], eax

; 193  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0007a	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _byteBufUnitNo$[ebp+8], 0
  00084	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _byteBufUnitNo$[ebp+12], 0

; 194  : 
; 195  : 	if (length % BYTES_PER_XTS_BLOCK)

  0008e	6a 00		 push	 0
  00090	6a 10		 push	 16			; 00000010H
  00092	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp+4]
  00095	51		 push	 ecx
  00096	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 __aullrem
  0009f	89 85 88 fd ff
	ff		 mov	 DWORD PTR tv227[ebp], eax
  000a5	89 95 8c fd ff
	ff		 mov	 DWORD PTR tv227[ebp+4], edx
  000ab	8b 85 88 fd ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  000b1	0b 85 8c fd ff
	ff		 or	 eax, DWORD PTR tv227[ebp+4]
  000b7	74 16		 je	 SHORT $LN27@EncryptBuf@3

; 196  : 		GST_THROW_FATAL_EXCEPTION;

  000b9	68 54 53 47 00	 push	 4674388			; 00475354H
  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	68 c4 00 00 00	 push	 196			; 000000c4H
  000c7	6a 29		 push	 41			; 00000029H
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN27@EncryptBuf@3:

; 197  : 
; 198  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000cf	6a 00		 push	 0
  000d1	6a 10		 push	 16			; 00000010H
  000d3	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp+4]
  000d6	51		 push	 ecx
  000d7	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  000da	52		 push	 edx
  000db	e8 00 00 00 00	 call	 __aulldiv
  000e0	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], eax
  000e6	89 95 e4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], edx
$LN26@EncryptBuf@3:

; 199  : 
; 200  : 	// Process all blocks in the buffer
; 201  : 	while (blockCount > 0)

  000ec	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000f3	77 0d		 ja	 SHORT $LN32@EncryptBuf@3
  000f5	83 bd e0 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp], 0
  000fc	0f 86 31 04 00
	00		 jbe	 $LN10@EncryptBuf@3
$LN32@EncryptBuf@3:

; 202  : 	{
; 203  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00102	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  00109	77 1c		 ja	 SHORT $LN24@EncryptBuf@3
  0010b	72 09		 jb	 SHORT $LN33@EncryptBuf@3
  0010d	83 bd e0 fd ff
	ff 20		 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  00114	73 11		 jae	 SHORT $LN24@EncryptBuf@3
$LN33@EncryptBuf@3:

; 204  : 			endBlock = startBlock + (unsigned int) blockCount;

  00116	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp]
  0011c	03 85 a0 fd ff
	ff		 add	 eax, DWORD PTR _startBlock$[ebp]
  00122	89 45 fc	 mov	 DWORD PTR _endBlock$[ebp], eax

; 205  : 		else

  00125	eb 07		 jmp	 SHORT $LN23@EncryptBuf@3
$LN24@EncryptBuf@3:

; 206  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00127	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN23@EncryptBuf@3:

; 207  : 
; 208  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  00131	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 209  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00137	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  0013d	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 210  : 
; 211  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 212  : 		// whitening value for this data unit)
; 213  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  00143	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00149	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  0014f	89 08		 mov	 DWORD PTR [eax], ecx
  00151	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _byteBufUnitNo$[ebp+4]
  00157	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 214  : 		*(whiteningValuePtr64 + 1) = 0;

  0015a	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00160	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00167	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 215  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0016e	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00171	51		 push	 ecx
  00172	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  00178	52		 push	 edx
  00179	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _EncipherBlock@12

; 216  : 
; 217  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 218  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 219  : 		for (block = 0; block < endBlock; block++)

  00182	c7 85 a4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _block$[ebp], 0
  0018c	eb 0f		 jmp	 SHORT $LN22@EncryptBuf@3
$LN21@EncryptBuf@3:
  0018e	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  00194	83 c1 01	 add	 ecx, 1
  00197	89 8d a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], ecx
$LN22@EncryptBuf@3:
  0019d	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _block$[ebp]
  001a3	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  001a6	0f 83 75 01 00
	00		 jae	 $LN20@EncryptBuf@3

; 220  : 		{
; 221  : 			if (block >= startBlock)

  001ac	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  001b2	3b 85 a0 fd ff
	ff		 cmp	 eax, DWORD PTR _startBlock$[ebp]
  001b8	72 5b		 jb	 SHORT $LN19@EncryptBuf@3

; 222  : 			{
; 223  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  001ba	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  001c0	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001c6	8b 02		 mov	 eax, DWORD PTR [edx]
  001c8	89 01		 mov	 DWORD PTR [ecx], eax
  001ca	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001cd	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001d0	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  001d6	83 e8 08	 sub	 eax, 8
  001d9	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax
  001df	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  001e5	83 c1 08	 add	 ecx, 8
  001e8	89 8d dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx

; 224  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  001ee	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  001f4	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  001fa	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fc	89 0a		 mov	 DWORD PTR [edx], ecx
  001fe	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00201	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00204	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0020a	83 e9 08	 sub	 ecx, 8
  0020d	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 225  : 			}
; 226  : 			else

  00213	eb 0f		 jmp	 SHORT $LN18@EncryptBuf@3
$LN19@EncryptBuf@3:

; 227  : 				whiteningValuePtr64++;

  00215	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0021b	83 c2 08	 add	 edx, 8
  0021e	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx
$LN18@EncryptBuf@3:

; 228  : 
; 229  : 			// Derive the next whitening value
; 230  : 
; 231  : #if BYTE_ORDER == LITTLE_ENDIAN
; 232  : 
; 233  : 			// Little-endian platforms
; 234  : 
; 235  : 			finalCarry = 
; 236  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 237  : 				135 : 0;

  00224	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  0022a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022c	83 e1 00	 and	 ecx, 0
  0022f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00232	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00238	89 8d 80 fd ff
	ff		 mov	 DWORD PTR tv285[ebp], ecx
  0023e	89 95 84 fd ff
	ff		 mov	 DWORD PTR tv285[ebp+4], edx
  00244	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR tv285[ebp]
  0024a	0b 85 84 fd ff
	ff		 or	 eax, DWORD PTR tv285[ebp+4]
  00250	74 0c		 je	 SHORT $LN30@EncryptBuf@3
  00252	c7 85 7c fd ff
	ff 87 00 00 00	 mov	 DWORD PTR tv92[ebp], 135 ; 00000087H
  0025c	eb 0a		 jmp	 SHORT $LN31@EncryptBuf@3
$LN30@EncryptBuf@3:
  0025e	c7 85 7c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
$LN31@EncryptBuf@3:
  00268	8a 8d 7c fd ff
	ff		 mov	 cl, BYTE PTR tv92[ebp]
  0026e	88 8d b7 fd ff
	ff		 mov	 BYTE PTR _finalCarry$[ebp], cl

; 238  : 
; 239  : 			*whiteningValuePtr64-- <<= 1;

  00274	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0027a	8b 02		 mov	 eax, DWORD PTR [edx]
  0027c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0027f	b1 01		 mov	 cl, 1
  00281	e8 00 00 00 00	 call	 __allshl
  00286	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0028c	89 01		 mov	 DWORD PTR [ecx], eax
  0028e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00291	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  00297	83 ea 08	 sub	 edx, 8
  0029a	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 240  : 
; 241  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002a0	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  002a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a8	83 e1 00	 and	 ecx, 0
  002ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002ae	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  002b4	89 8d 74 fd ff
	ff		 mov	 DWORD PTR tv312[ebp], ecx
  002ba	89 95 78 fd ff
	ff		 mov	 DWORD PTR tv312[ebp+4], edx
  002c0	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR tv312[ebp]
  002c6	0b 85 78 fd ff
	ff		 or	 eax, DWORD PTR tv312[ebp+4]
  002cc	74 1b		 je	 SHORT $LN17@EncryptBuf@3

; 242  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002ce	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  002d4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002d7	83 ca 01	 or	 edx, 1
  002da	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  002dd	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  002e3	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  002e6	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN17@EncryptBuf@3:

; 243  : 
; 244  : 			*whiteningValuePtr64 <<= 1;

  002e9	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  002ef	8b 02		 mov	 eax, DWORD PTR [edx]
  002f1	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  002f4	b1 01		 mov	 cl, 1
  002f6	e8 00 00 00 00	 call	 __allshl
  002fb	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00301	89 01		 mov	 DWORD PTR [ecx], eax
  00303	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 245  : #else
; 246  : 
; 247  : 			// Big-endian platforms
; 248  : 
; 249  : 			finalCarry = 
; 250  : 				(*whiteningValuePtr64 & 0x80) ?
; 251  : 				135 : 0;
; 252  : 
; 253  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 254  : 
; 255  : 			whiteningValuePtr64--;
; 256  : 
; 257  : 			if (*whiteningValuePtr64 & 0x80)
; 258  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 259  : 
; 260  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 261  : #endif
; 262  : 
; 263  : 			whiteningValue[0] ^= finalCarry;

  00306	0f b6 95 b7 fd
	ff ff		 movzx	 edx, BYTE PTR _finalCarry$[ebp]
  0030d	0f b6 85 b8 fd
	ff ff		 movzx	 eax, BYTE PTR _whiteningValue$[ebp]
  00314	33 c2		 xor	 eax, edx
  00316	88 85 b8 fd ff
	ff		 mov	 BYTE PTR _whiteningValue$[ebp], al

; 264  : 		}

  0031c	e9 6d fe ff ff	 jmp	 $LN21@EncryptBuf@3
$LN20@EncryptBuf@3:

; 265  : 
; 266  : 		dataUnitBufPtr = bufPtr;

  00321	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  00327	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _dataUnitBufPtr$[ebp], ecx

; 267  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0032d	8b 55 f8	 mov	 edx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  00330	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx

; 268  : 
; 269  : 		// Encrypt all blocks in this data unit
; 270  : 
; 271  : 		for (block = startBlock; block < endBlock; block++)

  00336	8b 85 a0 fd ff
	ff		 mov	 eax, DWORD PTR _startBlock$[ebp]
  0033c	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], eax
  00342	eb 0f		 jmp	 SHORT $LN16@EncryptBuf@3
$LN15@EncryptBuf@3:
  00344	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  0034a	83 c1 01	 add	 ecx, 1
  0034d	89 8d a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], ecx
$LN16@EncryptBuf@3:
  00353	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _block$[ebp]
  00359	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  0035c	0f 83 83 00 00
	00		 jae	 $LN14@EncryptBuf@3

; 272  : 		{
; 273  : 			// Pre-whitening
; 274  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00362	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00368	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0036e	8b 10		 mov	 edx, DWORD PTR [eax]
  00370	33 11		 xor	 edx, DWORD PTR [ecx]
  00372	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00375	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00378	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0037e	89 11		 mov	 DWORD PTR [ecx], edx
  00380	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00383	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  00389	83 ea 08	 sub	 edx, 8
  0038c	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx
  00392	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00398	83 c0 08	 add	 eax, 8
  0039b	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 275  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  003a1	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  003a7	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  003ad	8b 01		 mov	 eax, DWORD PTR [ecx]
  003af	33 02		 xor	 eax, DWORD PTR [edx]
  003b1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  003b4	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  003b7	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  003bd	89 02		 mov	 DWORD PTR [edx], eax
  003bf	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  003c2	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  003c8	83 e8 08	 sub	 eax, 8
  003cb	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax
  003d1	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  003d7	83 c1 08	 add	 ecx, 8
  003da	89 8d ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 276  : 		}

  003e0	e9 5f ff ff ff	 jmp	 $LN15@EncryptBuf@3
$LN14@EncryptBuf@3:

; 277  : 
; 278  : 		// Actual encryption
; 279  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  003e5	8b 55 fc	 mov	 edx, DWORD PTR _endBlock$[ebp]
  003e8	2b 95 a0 fd ff
	ff		 sub	 edx, DWORD PTR _startBlock$[ebp]
  003ee	52		 push	 edx
  003ef	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  003f2	50		 push	 eax
  003f3	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitBufPtr$[ebp]
  003f9	51		 push	 ecx
  003fa	8b 55 24	 mov	 edx, DWORD PTR _cipher$[ebp]
  003fd	52		 push	 edx
  003fe	e8 00 00 00 00	 call	 _EncipherBlocks@16

; 280  : 		
; 281  : 		bufPtr = dataUnitBufPtr;

  00403	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitBufPtr$[ebp]
  00409	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 282  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0040f	8b 4d f8	 mov	 ecx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  00412	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 283  : 
; 284  : 		for (block = startBlock; block < endBlock; block++)

  00418	8b 95 a0 fd ff
	ff		 mov	 edx, DWORD PTR _startBlock$[ebp]
  0041e	89 95 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], edx
  00424	eb 0f		 jmp	 SHORT $LN13@EncryptBuf@3
$LN12@EncryptBuf@3:
  00426	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  0042c	83 c0 01	 add	 eax, 1
  0042f	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], eax
$LN13@EncryptBuf@3:
  00435	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  0043b	3b 4d fc	 cmp	 ecx, DWORD PTR _endBlock$[ebp]
  0043e	0f 83 83 00 00
	00		 jae	 $LN11@EncryptBuf@3

; 285  : 		{
; 286  : 			// Post-whitening
; 287  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00444	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0044a	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  00450	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00452	33 08		 xor	 ecx, DWORD PTR [eax]
  00454	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00457	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  0045a	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00460	89 08		 mov	 DWORD PTR [eax], ecx
  00462	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00465	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0046b	83 e9 08	 sub	 ecx, 8
  0046e	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx
  00474	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0047a	83 c2 08	 add	 edx, 8
  0047d	89 95 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], edx

; 288  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00483	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00489	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0048f	8b 10		 mov	 edx, DWORD PTR [eax]
  00491	33 11		 xor	 edx, DWORD PTR [ecx]
  00493	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00496	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00499	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0049f	89 11		 mov	 DWORD PTR [ecx], edx
  004a1	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  004a4	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  004aa	83 ea 08	 sub	 edx, 8
  004ad	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx
  004b3	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  004b9	83 c0 08	 add	 eax, 8
  004bc	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 289  : 		}

  004c2	e9 5f ff ff ff	 jmp	 $LN12@EncryptBuf@3
$LN11@EncryptBuf@3:

; 290  : 
; 291  : 		blockCount -= endBlock - startBlock;

  004c7	8b 4d fc	 mov	 ecx, DWORD PTR _endBlock$[ebp]
  004ca	2b 8d a0 fd ff
	ff		 sub	 ecx, DWORD PTR _startBlock$[ebp]
  004d0	33 d2		 xor	 edx, edx
  004d2	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp]
  004d8	2b c1		 sub	 eax, ecx
  004da	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp+4]
  004e0	1b ca		 sbb	 ecx, edx
  004e2	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], eax
  004e8	89 8d e4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], ecx

; 292  : 		startBlock = 0;

  004ee	c7 85 a0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _startBlock$[ebp], 0

; 293  : 		dataUnitNo++;

  004f8	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  004fe	83 c2 01	 add	 edx, 1
  00501	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  00507	83 d0 00	 adc	 eax, 0
  0050a	89 95 a8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], edx
  00510	89 85 ac fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax

; 294  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00516	8b 8d a8 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  0051c	89 8d c8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  00522	8b 95 ac fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp+4]
  00528	89 95 cc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], edx

; 295  : 	}

  0052e	e9 b9 fb ff ff	 jmp	 $LN26@EncryptBuf@3
$LN10@EncryptBuf@3:

; 296  : 
; 297  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00533	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00539	89 85 98 fd ff
	ff		 mov	 DWORD PTR _burnm$25653[ebp], eax
  0053f	c7 85 9c fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _burnc$25655[ebp], 2
$LN7@EncryptBuf@3:
  00549	8b 8d 9c fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$25655[ebp]
  0054f	8b 95 9c fd ff
	ff		 mov	 edx, DWORD PTR _burnc$25655[ebp]
  00555	83 ea 01	 sub	 edx, 1
  00558	89 95 9c fd ff
	ff		 mov	 DWORD PTR _burnc$25655[ebp], edx
  0055e	85 c9		 test	 ecx, ecx
  00560	74 24		 je	 SHORT $LN9@EncryptBuf@3
  00562	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$25653[ebp]
  00568	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0056e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00575	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$25653[ebp]
  0057b	83 c1 08	 add	 ecx, 8
  0057e	89 8d 98 fd ff
	ff		 mov	 DWORD PTR _burnm$25653[ebp], ecx
  00584	eb c3		 jmp	 SHORT $LN7@EncryptBuf@3
$LN9@EncryptBuf@3:
  00586	33 d2		 xor	 edx, edx
  00588	75 a9		 jne	 SHORT $LN10@EncryptBuf@3
$LN5@EncryptBuf@3:

; 298  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  0058a	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  00590	89 85 90 fd ff
	ff		 mov	 DWORD PTR _burnm$25662[ebp], eax
  00596	c7 85 94 fd ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25664[ebp], 64 ; 00000040H
$LN2@EncryptBuf@3:
  005a0	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$25664[ebp]
  005a6	8b 95 94 fd ff
	ff		 mov	 edx, DWORD PTR _burnc$25664[ebp]
  005ac	83 ea 01	 sub	 edx, 1
  005af	89 95 94 fd ff
	ff		 mov	 DWORD PTR _burnc$25664[ebp], edx
  005b5	85 c9		 test	 ecx, ecx
  005b7	74 24		 je	 SHORT $LN4@EncryptBuf@3
  005b9	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$25662[ebp]
  005bf	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  005c5	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  005cc	8b 8d 90 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$25662[ebp]
  005d2	83 c1 08	 add	 ecx, 8
  005d5	89 8d 90 fd ff
	ff		 mov	 DWORD PTR _burnm$25662[ebp], ecx
  005db	eb c3		 jmp	 SHORT $LN2@EncryptBuf@3
$LN4@EncryptBuf@3:
  005dd	33 d2		 xor	 edx, edx
  005df	75 a9		 jne	 SHORT $LN5@EncryptBuf@3
$LN29@EncryptBuf@3:

; 299  : }

  005e1	8b 4d f4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e4	33 cd		 xor	 ecx, ebp
  005e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005eb	8b e5		 mov	 esp, ebp
  005ed	5d		 pop	 ebp
  005ee	c2 20 00	 ret	 32			; 00000020H
_EncryptBufferXTSParallel@32 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
;	COMDAT _EncryptBufferXTSNonParallel@32
_TEXT	SEGMENT
tv328 = -116						; size = 8
tv133 = -108						; size = 4
tv301 = -104						; size = 8
tv177 = -96						; size = 8
_burnm$25717 = -88					; size = 4
_burnc$25719 = -84					; size = 4
_startBlock$ = -80					; size = 4
_block$ = -76						; size = 4
_dataUnitNo$ = -72					; size = 8
_finalCarry$ = -57					; size = 1
_whiteningValue$ = -56					; size = 16
_byteBufUnitNo$ = -40					; size = 16
__$ArrayPad$ = -24					; size = 4
_whiteningValuePtr64$ = -20				; size = 4
_blockCount$ = -16					; size = 8
_bufPtr$ = -8						; size = 4
_endBlock$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTSNonParallel@32 PROC			; COMDAT

; 310  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 74	 sub	 esp, 116		; 00000074H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 311  : 	unsigned __int8 finalCarry;
; 312  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 313  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 314  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00012	8d 45 c8	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00015	89 45 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], eax

; 315  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0001b	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 316  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0001e	8b 55 18	 mov	 edx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	89 55 b0	 mov	 DWORD PTR _startBlock$[ebp], edx

; 317  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 318  : 
; 319  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 320  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 321  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 322  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 323  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 324  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 325  : 
; 326  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 327  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 328  : 	dataUnitNo = startDataUnitNo->Value;

  00024	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d b8	 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0002c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002f	89 55 bc	 mov	 DWORD PTR _dataUnitNo$[ebp+4], edx

; 329  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00032	8b 45 b8	 mov	 eax, DWORD PTR _dataUnitNo$[ebp]
  00035	89 45 d8	 mov	 DWORD PTR _byteBufUnitNo$[ebp], eax
  00038	8b 4d bc	 mov	 ecx, DWORD PTR _dataUnitNo$[ebp+4]
  0003b	89 4d dc	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx

; 330  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0003e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _byteBufUnitNo$[ebp+8], 0
  00045	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _byteBufUnitNo$[ebp+12], 0

; 331  : 
; 332  : 	if (length % BYTES_PER_XTS_BLOCK)

  0004c	6a 00		 push	 0
  0004e	6a 10		 push	 16			; 00000010H
  00050	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00053	52		 push	 edx
  00054	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 __aullrem
  0005d	89 45 a0	 mov	 DWORD PTR tv177[ebp], eax
  00060	89 55 a4	 mov	 DWORD PTR tv177[ebp+4], edx
  00063	8b 4d a0	 mov	 ecx, DWORD PTR tv177[ebp]
  00066	0b 4d a4	 or	 ecx, DWORD PTR tv177[ebp+4]
  00069	74 16		 je	 SHORT $LN16@EncryptBuf@4

; 333  : 		GST_THROW_FATAL_EXCEPTION;

  0006b	68 54 53 47 00	 push	 4674388			; 00475354H
  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	68 4d 01 00 00	 push	 333			; 0000014dH
  00079	6a 29		 push	 41			; 00000029H
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN16@EncryptBuf@4:

; 334  : 
; 335  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00081	6a 00		 push	 0
  00083	6a 10		 push	 16			; 00000010H
  00085	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00088	52		 push	 edx
  00089	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 __aulldiv
  00092	89 45 f0	 mov	 DWORD PTR _blockCount$[ebp], eax
  00095	89 55 f4	 mov	 DWORD PTR _blockCount$[ebp+4], edx
$LN15@EncryptBuf@4:

; 336  : 
; 337  : 	// Process all blocks in the buffer
; 338  : 	while (blockCount > 0)

  00098	83 7d f4 00	 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  0009c	77 0a		 ja	 SHORT $LN21@EncryptBuf@4
  0009e	83 7d f0 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  000a2	0f 86 2f 02 00
	00		 jbe	 $LN5@EncryptBuf@4
$LN21@EncryptBuf@4:

; 339  : 	{
; 340  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  000a8	83 7d f4 00	 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000ac	77 13		 ja	 SHORT $LN13@EncryptBuf@4
  000ae	72 06		 jb	 SHORT $LN22@EncryptBuf@4
  000b0	83 7d f0 20	 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  000b4	73 0b		 jae	 SHORT $LN13@EncryptBuf@4
$LN22@EncryptBuf@4:

; 341  : 			endBlock = startBlock + (unsigned int) blockCount;

  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  000b9	03 4d b0	 add	 ecx, DWORD PTR _startBlock$[ebp]
  000bc	89 4d fc	 mov	 DWORD PTR _endBlock$[ebp], ecx

; 342  : 		else

  000bf	eb 07		 jmp	 SHORT $LN12@EncryptBuf@4
$LN13@EncryptBuf@4:

; 343  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000c1	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN12@EncryptBuf@4:

; 344  : 
; 345  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  000c8	8d 55 c8	 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  000cb	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 346  : 
; 347  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 348  : 		// whitening value for this data unit)
; 349  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  000ce	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  000d1	8b 4d d8	 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  000d4	89 08		 mov	 DWORD PTR [eax], ecx
  000d6	8b 55 dc	 mov	 edx, DWORD PTR _byteBufUnitNo$[ebp+4]
  000d9	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 350  : 		*(whiteningValuePtr64 + 1) = 0;

  000dc	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  000df	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  000e6	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 351  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000ed	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  000f0	51		 push	 ecx
  000f1	8d 55 c8	 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  000f4	52		 push	 edx
  000f5	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 _EncipherBlock@12

; 352  : 
; 353  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 354  : 		// encrypt all relevant blocks in this data unit
; 355  : 		for (block = 0; block < endBlock; block++)

  000fe	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _block$[ebp], 0
  00105	eb 09		 jmp	 SHORT $LN11@EncryptBuf@4
$LN10@EncryptBuf@4:
  00107	8b 4d b4	 mov	 ecx, DWORD PTR _block$[ebp]
  0010a	83 c1 01	 add	 ecx, 1
  0010d	89 4d b4	 mov	 DWORD PTR _block$[ebp], ecx
$LN11@EncryptBuf@4:
  00110	8b 55 b4	 mov	 edx, DWORD PTR _block$[ebp]
  00113	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  00116	0f 83 79 01 00
	00		 jae	 $LN9@EncryptBuf@4

; 356  : 		{
; 357  : 			if (block >= startBlock)

  0011c	8b 45 b4	 mov	 eax, DWORD PTR _block$[ebp]
  0011f	3b 45 b0	 cmp	 eax, DWORD PTR _startBlock$[ebp]
  00122	0f 82 b2 00 00
	00		 jb	 $LN8@EncryptBuf@4

; 358  : 			{
; 359  : 				// Pre-whitening
; 360  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00128	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0012b	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0012e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00130	33 02		 xor	 eax, DWORD PTR [edx]
  00132	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00135	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  00138	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0013b	89 02		 mov	 DWORD PTR [edx], eax
  0013d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00140	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00143	83 c0 08	 add	 eax, 8
  00146	89 45 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], eax
  00149	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0014c	83 c1 08	 add	 ecx, 8
  0014f	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 361  : 				*bufPtr-- ^= *whiteningValuePtr64--;

  00152	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00155	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00158	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0015a	33 08		 xor	 ecx, DWORD PTR [eax]
  0015c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0015f	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  00162	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00165	89 08		 mov	 DWORD PTR [eax], ecx
  00167	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0016a	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0016d	83 e9 08	 sub	 ecx, 8
  00170	89 4d ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx
  00173	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00176	83 ea 08	 sub	 edx, 8
  00179	89 55 f8	 mov	 DWORD PTR _bufPtr$[ebp], edx

; 362  : 
; 363  : 				// Actual encryption
; 364  : 				EncipherBlock (cipher, bufPtr, ks);

  0017c	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  00183	51		 push	 ecx
  00184	8b 55 24	 mov	 edx, DWORD PTR _cipher$[ebp]
  00187	52		 push	 edx
  00188	e8 00 00 00 00	 call	 _EncipherBlock@12

; 365  : 
; 366  : 				// Post-whitening
; 367  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  0018d	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00190	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00193	8b 10		 mov	 edx, DWORD PTR [eax]
  00195	33 11		 xor	 edx, DWORD PTR [ecx]
  00197	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019a	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  0019d	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001a0	89 11		 mov	 DWORD PTR [ecx], edx
  001a2	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001a5	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001a8	83 c2 08	 add	 edx, 8
  001ab	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx
  001ae	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  001b1	83 c0 08	 add	 eax, 8
  001b4	89 45 f8	 mov	 DWORD PTR _bufPtr$[ebp], eax

; 368  : 				*bufPtr++ ^= *whiteningValuePtr64;

  001b7	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001ba	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  001bf	33 02		 xor	 eax, DWORD PTR [edx]
  001c1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001c4	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  001c7	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001ca	89 02		 mov	 DWORD PTR [edx], eax
  001cc	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001cf	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  001d2	83 c0 08	 add	 eax, 8
  001d5	89 45 f8	 mov	 DWORD PTR _bufPtr$[ebp], eax

; 369  : 			}
; 370  : 			else

  001d8	eb 09		 jmp	 SHORT $LN7@EncryptBuf@4
$LN8@EncryptBuf@4:

; 371  : 				whiteningValuePtr64++;

  001da	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  001dd	83 c1 08	 add	 ecx, 8
  001e0	89 4d ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx
$LN7@EncryptBuf@4:

; 372  : 
; 373  : 			// Derive the next whitening value
; 374  : 
; 375  : #if BYTE_ORDER == LITTLE_ENDIAN
; 376  : 
; 377  : 			// Little-endian platforms
; 378  : 
; 379  : 			finalCarry = 
; 380  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 381  : 				135 : 0;

  001e3	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001e6	8b 02		 mov	 eax, DWORD PTR [edx]
  001e8	83 e0 00	 and	 eax, 0
  001eb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001ee	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  001f4	89 45 98	 mov	 DWORD PTR tv301[ebp], eax
  001f7	89 4d 9c	 mov	 DWORD PTR tv301[ebp+4], ecx
  001fa	8b 55 98	 mov	 edx, DWORD PTR tv301[ebp]
  001fd	0b 55 9c	 or	 edx, DWORD PTR tv301[ebp+4]
  00200	74 09		 je	 SHORT $LN19@EncryptBuf@4
  00202	c7 45 94 87 00
	00 00		 mov	 DWORD PTR tv133[ebp], 135 ; 00000087H
  00209	eb 07		 jmp	 SHORT $LN20@EncryptBuf@4
$LN19@EncryptBuf@4:
  0020b	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$LN20@EncryptBuf@4:
  00212	8a 45 94	 mov	 al, BYTE PTR tv133[ebp]
  00215	88 45 c7	 mov	 BYTE PTR _finalCarry$[ebp], al

; 382  : 
; 383  : 			*whiteningValuePtr64-- <<= 1;

  00218	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0021b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0021d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00220	b1 01		 mov	 cl, 1
  00222	e8 00 00 00 00	 call	 __allshl
  00227	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0022a	89 01		 mov	 DWORD PTR [ecx], eax
  0022c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0022f	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  00232	83 ea 08	 sub	 edx, 8
  00235	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 384  : 
; 385  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00238	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  0023b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023d	83 e1 00	 and	 ecx, 0
  00240	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00243	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00249	89 4d 8c	 mov	 DWORD PTR tv328[ebp], ecx
  0024c	89 55 90	 mov	 DWORD PTR tv328[ebp+4], edx
  0024f	8b 45 8c	 mov	 eax, DWORD PTR tv328[ebp]
  00252	0b 45 90	 or	 eax, DWORD PTR tv328[ebp+4]
  00255	74 15		 je	 SHORT $LN6@EncryptBuf@4

; 386  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00257	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0025a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0025d	83 ca 01	 or	 edx, 1
  00260	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00263	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00266	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00269	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN6@EncryptBuf@4:

; 387  : 
; 388  : 			*whiteningValuePtr64 <<= 1;

  0026c	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0026f	8b 02		 mov	 eax, DWORD PTR [edx]
  00271	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00274	b1 01		 mov	 cl, 1
  00276	e8 00 00 00 00	 call	 __allshl
  0027b	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0027e	89 01		 mov	 DWORD PTR [ecx], eax
  00280	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 389  : #else
; 390  : 
; 391  : 			// Big-endian platforms
; 392  : 
; 393  : 			finalCarry = 
; 394  : 				(*whiteningValuePtr64 & 0x80) ?
; 395  : 				135 : 0;
; 396  : 
; 397  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 398  : 
; 399  : 			whiteningValuePtr64--;
; 400  : 
; 401  : 			if (*whiteningValuePtr64 & 0x80)
; 402  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 403  : 
; 404  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 405  : #endif
; 406  : 
; 407  : 			whiteningValue[0] ^= finalCarry;

  00283	0f b6 55 c7	 movzx	 edx, BYTE PTR _finalCarry$[ebp]
  00287	0f b6 45 c8	 movzx	 eax, BYTE PTR _whiteningValue$[ebp]
  0028b	33 c2		 xor	 eax, edx
  0028d	88 45 c8	 mov	 BYTE PTR _whiteningValue$[ebp], al

; 408  : 		}

  00290	e9 72 fe ff ff	 jmp	 $LN10@EncryptBuf@4
$LN9@EncryptBuf@4:

; 409  : 
; 410  : 		blockCount -= endBlock - startBlock;

  00295	8b 4d fc	 mov	 ecx, DWORD PTR _endBlock$[ebp]
  00298	2b 4d b0	 sub	 ecx, DWORD PTR _startBlock$[ebp]
  0029b	33 d2		 xor	 edx, edx
  0029d	8b 45 f0	 mov	 eax, DWORD PTR _blockCount$[ebp]
  002a0	2b c1		 sub	 eax, ecx
  002a2	8b 4d f4	 mov	 ecx, DWORD PTR _blockCount$[ebp+4]
  002a5	1b ca		 sbb	 ecx, edx
  002a7	89 45 f0	 mov	 DWORD PTR _blockCount$[ebp], eax
  002aa	89 4d f4	 mov	 DWORD PTR _blockCount$[ebp+4], ecx

; 411  : 		startBlock = 0;

  002ad	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _startBlock$[ebp], 0

; 412  : 		dataUnitNo++;

  002b4	8b 55 b8	 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  002b7	83 c2 01	 add	 edx, 1
  002ba	8b 45 bc	 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  002bd	83 d0 00	 adc	 eax, 0
  002c0	89 55 b8	 mov	 DWORD PTR _dataUnitNo$[ebp], edx
  002c3	89 45 bc	 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax

; 413  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  002c6	8b 4d b8	 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  002c9	89 4d d8	 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  002cc	8b 55 bc	 mov	 edx, DWORD PTR _dataUnitNo$[ebp+4]
  002cf	89 55 dc	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], edx

; 414  : 	}

  002d2	e9 c1 fd ff ff	 jmp	 $LN15@EncryptBuf@4
$LN5@EncryptBuf@4:

; 415  : 
; 416  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  002d7	8d 45 c8	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  002da	89 45 a8	 mov	 DWORD PTR _burnm$25717[ebp], eax
  002dd	c7 45 ac 02 00
	00 00		 mov	 DWORD PTR _burnc$25719[ebp], 2
$LN2@EncryptBuf@4:
  002e4	8b 4d ac	 mov	 ecx, DWORD PTR _burnc$25719[ebp]
  002e7	8b 55 ac	 mov	 edx, DWORD PTR _burnc$25719[ebp]
  002ea	83 ea 01	 sub	 edx, 1
  002ed	89 55 ac	 mov	 DWORD PTR _burnc$25719[ebp], edx
  002f0	85 c9		 test	 ecx, ecx
  002f2	74 1b		 je	 SHORT $LN4@EncryptBuf@4
  002f4	8b 45 a8	 mov	 eax, DWORD PTR _burnm$25717[ebp]
  002f7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002fd	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00304	8b 4d a8	 mov	 ecx, DWORD PTR _burnm$25717[ebp]
  00307	83 c1 08	 add	 ecx, 8
  0030a	89 4d a8	 mov	 DWORD PTR _burnm$25717[ebp], ecx
  0030d	eb d5		 jmp	 SHORT $LN2@EncryptBuf@4
$LN4@EncryptBuf@4:
  0030f	33 d2		 xor	 edx, edx
  00311	75 c4		 jne	 SHORT $LN5@EncryptBuf@4
$LN18@EncryptBuf@4:

; 417  : }

  00313	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00316	33 cd		 xor	 ecx, ebp
  00318	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031d	8b e5		 mov	 esp, ebp
  0031f	5d		 pop	 ebp
  00320	c2 20 00	 ret	 32			; 00000020H
_EncryptBufferXTSNonParallel@32 ENDP
_TEXT	ENDS
PUBLIC	_DecryptBufferXTS@32
; Function compile flags: /Odtp
;	COMDAT _DecryptBufferXTS@32
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTS@32 PROC				; COMDAT

; 428  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 429  : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00005	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization@4
  0000e	85 c0		 test	 eax, eax
  00010	74 27		 je	 SHORT $LN2@DecryptBuf

; 430  : 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00012	8b 4d 24	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 20	 mov	 edx, DWORD PTR _ks2$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 18	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 14	 mov	 edx, DWORD PTR _startDataUnitNo$[ebp]
  00025	52		 push	 edx
  00026	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp+4]
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _DecryptBufferXTSParallel@32

; 431  : 	else

  00037	eb 25		 jmp	 SHORT $LN3@DecryptBuf
$LN2@DecryptBuf:

; 432  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00039	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 1c	 mov	 edx, DWORD PTR _ks$[ebp]
  00044	52		 push	 edx
  00045	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 14	 mov	 ecx, DWORD PTR _startDataUnitNo$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00050	52		 push	 edx
  00051	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _DecryptBufferXTSNonParallel@32
$LN3@DecryptBuf:

; 433  : }

  0005e	5d		 pop	 ebp
  0005f	c2 20 00	 ret	 32			; 00000020H
_DecryptBufferXTS@32 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_DecryptBufferXTS8Byte@32
EXTRN	_DecipherBlock@12:PROC
; Function compile flags: /Odtp
;	COMDAT _DecryptBufferXTS8Byte@32
_TEXT	SEGMENT
tv189 = -632						; size = 8
_burnm$25793 = -624					; size = 4
_burnc$25795 = -620					; size = 4
_startBlock$ = -616					; size = 4
_block$ = -612						; size = 4
_dataUnitNo$ = -608					; size = 8
_finalCarry$ = -593					; size = 1
_whiteningValue$ = -592					; size = 8
_byteBufUnitNo$ = -584					; size = 8
_blockCount$ = -576					; size = 8
_whiteningValuePtr32$ = -564				; size = 4
_xor_ks$ = -560						; size = 544
__$ArrayPad$ = -12					; size = 4
_bufPtr$ = -8						; size = 4
_endBlock$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTS8Byte@32 PROC				; COMDAT

; 442  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 78 02 00
	00		 sub	 esp, 632		; 00000278H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 443  : 	unsigned __int8 finalCarry;
; 444  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
; 445  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
; 446  : 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;

  00015	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  0001b	89 85 cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], eax

; 447  : 	unsigned __int32 *bufPtr = (unsigned __int32 *) buffer;

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00024	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 448  : 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;

  00027	8b 55 18	 mov	 edx, DWORD PTR _startCipherBlockNo$[ebp]
  0002a	89 95 98 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], edx

; 449  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 450  : 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
; 451  : 
; 452  : 	dataUnitNo = startDataUnitNo->Value;

  00030	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 8d a0 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0003b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003e	89 95 a4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], edx

; 453  : 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  00044	8b 85 a0 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp]
  0004a	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], eax
  00050	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp+4]
  00056	89 8d bc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx

; 454  : 
; 455  : 	if (length % BYTES_PER_XTS_BLOCK_SMALL)

  0005c	6a 00		 push	 0
  0005e	6a 08		 push	 8
  00060	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00063	52		 push	 edx
  00064	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 __aullrem
  0006d	89 85 88 fd ff
	ff		 mov	 DWORD PTR tv189[ebp], eax
  00073	89 95 8c fd ff
	ff		 mov	 DWORD PTR tv189[ebp+4], edx
  00079	8b 8d 88 fd ff
	ff		 mov	 ecx, DWORD PTR tv189[ebp]
  0007f	0b 8d 8c fd ff
	ff		 or	 ecx, DWORD PTR tv189[ebp+4]
  00085	74 16		 je	 SHORT $LN16@DecryptBuf@2

; 456  : 		GST_THROW_FATAL_EXCEPTION;

  00087	68 54 53 47 00	 push	 4674388			; 00475354H
  0008c	6a 00		 push	 0
  0008e	6a 00		 push	 0
  00090	68 c8 01 00 00	 push	 456			; 000001c8H
  00095	6a 29		 push	 41			; 00000029H
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN16@DecryptBuf@2:

; 457  : 
; 458  : 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;

  0009d	6a 00		 push	 0
  0009f	6a 08		 push	 8
  000a1	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  000a4	52		 push	 edx
  000a5	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 __aulldiv
  000ae	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], eax
  000b4	89 95 c4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], edx

; 459  : 
; 460  : 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));

  000ba	8b 4d 24	 mov	 ecx, DWORD PTR _cipher$[ebp]
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000c3	50		 push	 eax
  000c4	8b 55 1c	 mov	 edx, DWORD PTR _ks$[ebp]
  000c7	52		 push	 edx
  000c8	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@DecryptBuf@2:

; 461  : 
; 462  : 	while (blockCount > 0)

  000d7	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000de	77 0d		 ja	 SHORT $LN19@DecryptBuf@2
  000e0	83 bd c0 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp], 0
  000e7	0f 86 78 02 00
	00		 jbe	 $LN5@DecryptBuf@2
$LN19@DecryptBuf@2:

; 463  : 	{
; 464  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)

  000ed	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000f4	77 1c		 ja	 SHORT $LN13@DecryptBuf@2
  000f6	72 09		 jb	 SHORT $LN20@DecryptBuf@2
  000f8	83 bd c0 fd ff
	ff 40		 cmp	 DWORD PTR _blockCount$[ebp], 64 ; 00000040H
  000ff	73 11		 jae	 SHORT $LN13@DecryptBuf@2
$LN20@DecryptBuf@2:

; 465  : 			endBlock = startBlock + (unsigned __int32) blockCount;

  00101	8b 8d c0 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp]
  00107	03 8d 98 fd ff
	ff		 add	 ecx, DWORD PTR _startBlock$[ebp]
  0010d	89 4d fc	 mov	 DWORD PTR _endBlock$[ebp], ecx

; 466  : 		else

  00110	eb 07		 jmp	 SHORT $LN12@DecryptBuf@2
$LN13@DecryptBuf@2:

; 467  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;

  00112	c7 45 fc 40 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 64 ; 00000040H
$LN12@DecryptBuf@2:

; 468  : 
; 469  : 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;

  00119	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  0011f	89 95 cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], edx

; 470  : 
; 471  : 		//Encrypt data unit using the second key to generate the first whitening value
; 472  : 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);

  00125	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  0012b	8b 8d b8 fd ff
	ff		 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  00131	89 08		 mov	 DWORD PTR [eax], ecx

; 473  : 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);

  00133	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr32$[ebp]
  00139	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _byteBufUnitNo$[ebp+4]
  0013f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 474  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00142	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00145	51		 push	 ecx
  00146	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  0014c	52		 push	 edx
  0014d	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _EncipherBlock@12

; 475  : 
; 476  : 		//XOR ks with the current DataUnitNo
; 477  : 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);

  00156	6a 08		 push	 8
  00158	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  0015e	51		 push	 ecx
  0015f	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR _xor_ks$[ebp]
  00165	52		 push	 edx
  00166	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  00169	50		 push	 eax
  0016a	8b 4d 24	 mov	 ecx, DWORD PTR _cipher$[ebp]
  0016d	51		 push	 ecx
  0016e	e8 00 00 00 00	 call	 _XorKeySchedule@20

; 478  : 
; 479  : 		for (block = 0; block < endBlock; block++)

  00173	c7 85 9c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _block$[ebp], 0
  0017d	eb 0f		 jmp	 SHORT $LN11@DecryptBuf@2
$LN10@DecryptBuf@2:
  0017f	8b 95 9c fd ff
	ff		 mov	 edx, DWORD PTR _block$[ebp]
  00185	83 c2 01	 add	 edx, 1
  00188	89 95 9c fd ff
	ff		 mov	 DWORD PTR _block$[ebp], edx
$LN11@DecryptBuf@2:
  0018e	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  00194	3b 45 fc	 cmp	 eax, DWORD PTR _endBlock$[ebp]
  00197	0f 83 5c 01 00
	00		 jae	 $LN9@DecryptBuf@2

; 480  : 		{
; 481  : 			if (block >= startBlock)

  0019d	8b 8d 9c fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  001a3	3b 8d 98 fd ff
	ff		 cmp	 ecx, DWORD PTR _startBlock$[ebp]
  001a9	0f 82 af 00 00
	00		 jb	 $LN8@DecryptBuf@2

; 482  : 			{
; 483  : 				//Post-whitening
; 484  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  001af	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001b2	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  001b8	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001ba	33 08		 xor	 ecx, DWORD PTR [eax]
  001bc	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001bf	89 0a		 mov	 DWORD PTR [edx], ecx
  001c1	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  001c7	83 c0 04	 add	 eax, 4
  001ca	89 85 cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], eax
  001d0	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001d3	83 c1 04	 add	 ecx, 4
  001d6	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 485  : 				*bufPtr-- ^= *whiteningValuePtr32--;

  001d9	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001dc	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  001e2	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001e4	33 08		 xor	 ecx, DWORD PTR [eax]
  001e6	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001e9	89 0a		 mov	 DWORD PTR [edx], ecx
  001eb	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  001f1	83 e8 04	 sub	 eax, 4
  001f4	89 85 cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], eax
  001fa	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001fd	83 e9 04	 sub	 ecx, 4
  00200	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 486  : 
; 487  : 				//Actual decryption
; 488  : 				DecipherBlock (cipher, bufPtr, xor_ks);

  00203	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR _xor_ks$[ebp]
  00209	52		 push	 edx
  0020a	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  0020d	50		 push	 eax
  0020e	8b 4d 24	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00211	51		 push	 ecx
  00212	e8 00 00 00 00	 call	 _DecipherBlock@12

; 489  : 
; 490  : 				//Pre-whitening
; 491  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  00217	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0021a	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  00220	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00222	33 08		 xor	 ecx, DWORD PTR [eax]
  00224	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00227	89 0a		 mov	 DWORD PTR [edx], ecx
  00229	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  0022f	83 c0 04	 add	 eax, 4
  00232	89 85 cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], eax
  00238	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0023b	83 c1 04	 add	 ecx, 4
  0023e	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 492  : 				*bufPtr++ ^= *whiteningValuePtr32;

  00241	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00244	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  0024a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0024c	33 08		 xor	 ecx, DWORD PTR [eax]
  0024e	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00251	89 0a		 mov	 DWORD PTR [edx], ecx
  00253	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00256	83 c0 04	 add	 eax, 4
  00259	89 45 f8	 mov	 DWORD PTR _bufPtr$[ebp], eax

; 493  : 			}
; 494  : 			else

  0025c	eb 0f		 jmp	 SHORT $LN7@DecryptBuf@2
$LN8@DecryptBuf@2:

; 495  : 				whiteningValuePtr32++;

  0025e	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr32$[ebp]
  00264	83 c1 04	 add	 ecx, 4
  00267	89 8d cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], ecx
$LN7@DecryptBuf@2:

; 496  : 
; 497  : 			//Derive the next whitening value
; 498  : 
; 499  : #if BYTE_ORDER == LITTLE_ENDIAN
; 500  : 
; 501  : 			//Little-endian platforms
; 502  : 
; 503  : 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;

  0026d	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr32$[ebp]
  00273	8b 02		 mov	 eax, DWORD PTR [edx]
  00275	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0027a	f7 d8		 neg	 eax
  0027c	1b c0		 sbb	 eax, eax
  0027e	83 e0 1b	 and	 eax, 27			; 0000001bH
  00281	88 85 af fd ff
	ff		 mov	 BYTE PTR _finalCarry$[ebp], al

; 504  : 
; 505  : 			*whiteningValuePtr32-- <<= 1;

  00287	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr32$[ebp]
  0028d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0028f	d1 e2		 shl	 edx, 1
  00291	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  00297	89 10		 mov	 DWORD PTR [eax], edx
  00299	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr32$[ebp]
  0029f	83 e9 04	 sub	 ecx, 4
  002a2	89 8d cc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr32$[ebp], ecx

; 506  : 
; 507  : 			if (*whiteningValuePtr32 & 0x80000000)

  002a8	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr32$[ebp]
  002ae	8b 02		 mov	 eax, DWORD PTR [edx]
  002b0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002b5	74 15		 je	 SHORT $LN6@DecryptBuf@2

; 508  : 				*(whiteningValuePtr32 + 1) |= 1;

  002b7	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr32$[ebp]
  002bd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002c0	83 ca 01	 or	 edx, 1
  002c3	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  002c9	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN6@DecryptBuf@2:

; 509  : 
; 510  : 			*whiteningValuePtr32 <<= 1;

  002cc	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr32$[ebp]
  002d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  002d4	d1 e2		 shl	 edx, 1
  002d6	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr32$[ebp]
  002dc	89 10		 mov	 DWORD PTR [eax], edx

; 511  : #else
; 512  : 			//Big-endian platforms
; 513  : 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
; 514  : 
; 515  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 516  : 
; 517  : 			whiteningValuePtr32--;
; 518  : 
; 519  : 			if (*whiteningValuePtr32 & 0x80)
; 520  : 				*(whiteningValuePtr32 + 1) |= 0x1000000;
; 521  : 
; 522  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 523  : #endif
; 524  : 
; 525  : 			whiteningValue[0] ^= finalCarry;

  002de	0f b6 8d af fd
	ff ff		 movzx	 ecx, BYTE PTR _finalCarry$[ebp]
  002e5	0f b6 95 b0 fd
	ff ff		 movzx	 edx, BYTE PTR _whiteningValue$[ebp]
  002ec	33 d1		 xor	 edx, ecx
  002ee	88 95 b0 fd ff
	ff		 mov	 BYTE PTR _whiteningValue$[ebp], dl

; 526  : 		}

  002f4	e9 86 fe ff ff	 jmp	 $LN10@DecryptBuf@2
$LN9@DecryptBuf@2:

; 527  : 
; 528  : 		blockCount -= endBlock - startBlock;

  002f9	8b 45 fc	 mov	 eax, DWORD PTR _endBlock$[ebp]
  002fc	2b 85 98 fd ff
	ff		 sub	 eax, DWORD PTR _startBlock$[ebp]
  00302	33 c9		 xor	 ecx, ecx
  00304	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR _blockCount$[ebp]
  0030a	2b d0		 sub	 edx, eax
  0030c	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp+4]
  00312	1b c1		 sbb	 eax, ecx
  00314	89 95 c0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], edx
  0031a	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], eax

; 529  : 		startBlock = 0;

  00320	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _startBlock$[ebp], 0

; 530  : 		dataUnitNo++;

  0032a	8b 8d a0 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  00330	83 c1 01	 add	 ecx, 1
  00333	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp+4]
  00339	83 d2 00	 adc	 edx, 0
  0033c	89 8d a0 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  00342	89 95 a4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], edx

; 531  : 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  00348	8b 85 a0 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp]
  0034e	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], eax
  00354	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp+4]
  0035a	89 8d bc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx

; 532  : 	}

  00360	e9 72 fd ff ff	 jmp	 $LN15@DecryptBuf@2
$LN5@DecryptBuf@2:

; 533  : 
; 534  : 	FAST_ERASE32 (whiteningValue, sizeof (whiteningValue));

  00365	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  0036b	89 95 90 fd ff
	ff		 mov	 DWORD PTR _burnm$25793[ebp], edx
  00371	c7 85 94 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _burnc$25795[ebp], 1
$LN2@DecryptBuf@2:
  0037b	8b 85 94 fd ff
	ff		 mov	 eax, DWORD PTR _burnc$25795[ebp]
  00381	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$25795[ebp]
  00387	83 e9 01	 sub	 ecx, 1
  0038a	89 8d 94 fd ff
	ff		 mov	 DWORD PTR _burnc$25795[ebp], ecx
  00390	85 c0		 test	 eax, eax
  00392	74 1d		 je	 SHORT $LN4@DecryptBuf@2
  00394	8b 95 90 fd ff
	ff		 mov	 edx, DWORD PTR _burnm$25793[ebp]
  0039a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  003a0	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$25793[ebp]
  003a6	83 c0 04	 add	 eax, 4
  003a9	89 85 90 fd ff
	ff		 mov	 DWORD PTR _burnm$25793[ebp], eax
  003af	eb ca		 jmp	 SHORT $LN2@DecryptBuf@2
$LN4@DecryptBuf@2:
  003b1	33 c9		 xor	 ecx, ecx
  003b3	75 b0		 jne	 SHORT $LN5@DecryptBuf@2
$LN18@DecryptBuf@2:

; 535  : }

  003b5	8b 4d f4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b8	33 cd		 xor	 ecx, ebp
  003ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003bf	8b e5		 mov	 esp, ebp
  003c1	5d		 pop	 ebp
  003c2	c2 20 00	 ret	 32			; 00000020H
_DecryptBufferXTS8Byte@32 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_DecipherBlocks@16:PROC
; Function compile flags: /Odtp
;	COMDAT _DecryptBufferXTSParallel@32
_TEXT	SEGMENT
tv312 = -652						; size = 8
tv92 = -644						; size = 4
tv285 = -640						; size = 8
tv227 = -632						; size = 8
_burnm$25868 = -624					; size = 4
_burnc$25870 = -620					; size = 4
_burnm$25859 = -616					; size = 4
_burnc$25861 = -612					; size = 4
_startBlock$ = -608					; size = 4
_block$ = -604						; size = 4
_dataUnitNo$ = -600					; size = 8
_finalCarry$ = -585					; size = 1
_whiteningValue$ = -584					; size = 16
_byteBufUnitNo$ = -568					; size = 16
_whiteningValuesPtr64$ = -552				; size = 4
_whiteningValuePtr64$ = -548				; size = 4
_blockCount$ = -544					; size = 8
_dataUnitBufPtr$ = -536					; size = 4
_bufPtr$ = -532						; size = 4
_whiteningValues$ = -528				; size = 512
__$ArrayPad$ = -12					; size = 4
_finalInt64WhiteningValuesPtr$ = -8			; size = 4
_endBlock$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTSParallel@32 PROC			; COMDAT

; 545  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 8c 02 00
	00		 sub	 esp, 652		; 0000028cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 546  : 	unsigned __int8 finalCarry;
; 547  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 548  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 549  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 550  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;

  00015	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  0001b	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax

; 551  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00021	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _whiteningValue$[ebp]
  00027	89 8d dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx

; 552  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  0002d	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00030	89 95 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], edx

; 553  : 	unsigned __int64 *dataUnitBufPtr;
; 554  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00036	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00039	89 85 a0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], eax

; 555  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;

  0003f	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  00045	81 c1 f8 01 00
	00		 add	 ecx, 504		; 000001f8H
  0004b	89 4d f8	 mov	 DWORD PTR _finalInt64WhiteningValuesPtr$[ebp], ecx

; 556  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 557  : 
; 558  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 559  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 560  : 	dataUnitNo = startDataUnitNo->Value;

  0004e	8b 55 14	 mov	 edx, DWORD PTR _startDataUnitNo$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], eax
  00059	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0005c	89 8d ac fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], ecx

; 561  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00062	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  00068	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], edx
  0006e	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  00074	89 85 cc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], eax

; 562  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0007a	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _byteBufUnitNo$[ebp+8], 0
  00084	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _byteBufUnitNo$[ebp+12], 0

; 563  : 
; 564  : 	if (length % BYTES_PER_XTS_BLOCK)

  0008e	6a 00		 push	 0
  00090	6a 10		 push	 16			; 00000010H
  00092	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp+4]
  00095	51		 push	 ecx
  00096	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 __aullrem
  0009f	89 85 88 fd ff
	ff		 mov	 DWORD PTR tv227[ebp], eax
  000a5	89 95 8c fd ff
	ff		 mov	 DWORD PTR tv227[ebp+4], edx
  000ab	8b 85 88 fd ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  000b1	0b 85 8c fd ff
	ff		 or	 eax, DWORD PTR tv227[ebp+4]
  000b7	74 16		 je	 SHORT $LN27@DecryptBuf@3

; 565  : 		GST_THROW_FATAL_EXCEPTION;

  000b9	68 54 53 47 00	 push	 4674388			; 00475354H
  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	68 35 02 00 00	 push	 565			; 00000235H
  000c7	6a 29		 push	 41			; 00000029H
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN27@DecryptBuf@3:

; 566  : 
; 567  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000cf	6a 00		 push	 0
  000d1	6a 10		 push	 16			; 00000010H
  000d3	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp+4]
  000d6	51		 push	 ecx
  000d7	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  000da	52		 push	 edx
  000db	e8 00 00 00 00	 call	 __aulldiv
  000e0	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], eax
  000e6	89 95 e4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], edx
$LN26@DecryptBuf@3:

; 568  : 
; 569  : 	// Process all blocks in the buffer
; 570  : 	while (blockCount > 0)

  000ec	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000f3	77 0d		 ja	 SHORT $LN32@DecryptBuf@3
  000f5	83 bd e0 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp], 0
  000fc	0f 86 31 04 00
	00		 jbe	 $LN10@DecryptBuf@3
$LN32@DecryptBuf@3:

; 571  : 	{
; 572  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00102	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  00109	77 1c		 ja	 SHORT $LN24@DecryptBuf@3
  0010b	72 09		 jb	 SHORT $LN33@DecryptBuf@3
  0010d	83 bd e0 fd ff
	ff 20		 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  00114	73 11		 jae	 SHORT $LN24@DecryptBuf@3
$LN33@DecryptBuf@3:

; 573  : 			endBlock = startBlock + (unsigned int) blockCount;

  00116	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp]
  0011c	03 85 a0 fd ff
	ff		 add	 eax, DWORD PTR _startBlock$[ebp]
  00122	89 45 fc	 mov	 DWORD PTR _endBlock$[ebp], eax

; 574  : 		else

  00125	eb 07		 jmp	 SHORT $LN23@DecryptBuf@3
$LN24@DecryptBuf@3:

; 575  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00127	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN23@DecryptBuf@3:

; 576  : 
; 577  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  00131	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 578  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00137	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  0013d	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 579  : 
; 580  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 581  : 		// whitening value for this data unit)
; 582  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  00143	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00149	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  0014f	89 08		 mov	 DWORD PTR [eax], ecx
  00151	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _byteBufUnitNo$[ebp+4]
  00157	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 583  : 		*(whiteningValuePtr64 + 1) = 0;

  0015a	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00160	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00167	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 584  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0016e	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00171	51		 push	 ecx
  00172	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  00178	52		 push	 edx
  00179	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _EncipherBlock@12

; 585  : 
; 586  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 587  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 588  : 		for (block = 0; block < endBlock; block++)

  00182	c7 85 a4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _block$[ebp], 0
  0018c	eb 0f		 jmp	 SHORT $LN22@DecryptBuf@3
$LN21@DecryptBuf@3:
  0018e	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  00194	83 c1 01	 add	 ecx, 1
  00197	89 8d a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], ecx
$LN22@DecryptBuf@3:
  0019d	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _block$[ebp]
  001a3	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  001a6	0f 83 75 01 00
	00		 jae	 $LN20@DecryptBuf@3

; 589  : 		{
; 590  : 			if (block >= startBlock)

  001ac	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  001b2	3b 85 a0 fd ff
	ff		 cmp	 eax, DWORD PTR _startBlock$[ebp]
  001b8	72 5b		 jb	 SHORT $LN19@DecryptBuf@3

; 591  : 			{
; 592  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  001ba	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  001c0	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001c6	8b 02		 mov	 eax, DWORD PTR [edx]
  001c8	89 01		 mov	 DWORD PTR [ecx], eax
  001ca	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001cd	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001d0	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  001d6	83 e8 08	 sub	 eax, 8
  001d9	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax
  001df	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  001e5	83 c1 08	 add	 ecx, 8
  001e8	89 8d dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx

; 593  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  001ee	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  001f4	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  001fa	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fc	89 0a		 mov	 DWORD PTR [edx], ecx
  001fe	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00201	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00204	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0020a	83 e9 08	 sub	 ecx, 8
  0020d	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 594  : 			}
; 595  : 			else

  00213	eb 0f		 jmp	 SHORT $LN18@DecryptBuf@3
$LN19@DecryptBuf@3:

; 596  : 				whiteningValuePtr64++;

  00215	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0021b	83 c2 08	 add	 edx, 8
  0021e	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx
$LN18@DecryptBuf@3:

; 597  : 
; 598  : 			// Derive the next whitening value
; 599  : 
; 600  : #if BYTE_ORDER == LITTLE_ENDIAN
; 601  : 
; 602  : 			// Little-endian platforms
; 603  : 
; 604  : 			finalCarry = 
; 605  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 606  : 				135 : 0;

  00224	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  0022a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022c	83 e1 00	 and	 ecx, 0
  0022f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00232	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00238	89 8d 80 fd ff
	ff		 mov	 DWORD PTR tv285[ebp], ecx
  0023e	89 95 84 fd ff
	ff		 mov	 DWORD PTR tv285[ebp+4], edx
  00244	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR tv285[ebp]
  0024a	0b 85 84 fd ff
	ff		 or	 eax, DWORD PTR tv285[ebp+4]
  00250	74 0c		 je	 SHORT $LN30@DecryptBuf@3
  00252	c7 85 7c fd ff
	ff 87 00 00 00	 mov	 DWORD PTR tv92[ebp], 135 ; 00000087H
  0025c	eb 0a		 jmp	 SHORT $LN31@DecryptBuf@3
$LN30@DecryptBuf@3:
  0025e	c7 85 7c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
$LN31@DecryptBuf@3:
  00268	8a 8d 7c fd ff
	ff		 mov	 cl, BYTE PTR tv92[ebp]
  0026e	88 8d b7 fd ff
	ff		 mov	 BYTE PTR _finalCarry$[ebp], cl

; 607  : 
; 608  : 			*whiteningValuePtr64-- <<= 1;

  00274	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0027a	8b 02		 mov	 eax, DWORD PTR [edx]
  0027c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0027f	b1 01		 mov	 cl, 1
  00281	e8 00 00 00 00	 call	 __allshl
  00286	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0028c	89 01		 mov	 DWORD PTR [ecx], eax
  0028e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00291	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  00297	83 ea 08	 sub	 edx, 8
  0029a	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 609  : 
; 610  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002a0	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  002a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a8	83 e1 00	 and	 ecx, 0
  002ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002ae	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  002b4	89 8d 74 fd ff
	ff		 mov	 DWORD PTR tv312[ebp], ecx
  002ba	89 95 78 fd ff
	ff		 mov	 DWORD PTR tv312[ebp+4], edx
  002c0	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR tv312[ebp]
  002c6	0b 85 78 fd ff
	ff		 or	 eax, DWORD PTR tv312[ebp+4]
  002cc	74 1b		 je	 SHORT $LN17@DecryptBuf@3

; 611  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002ce	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  002d4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002d7	83 ca 01	 or	 edx, 1
  002da	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  002dd	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  002e3	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  002e6	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN17@DecryptBuf@3:

; 612  : 
; 613  : 			*whiteningValuePtr64 <<= 1;

  002e9	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  002ef	8b 02		 mov	 eax, DWORD PTR [edx]
  002f1	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  002f4	b1 01		 mov	 cl, 1
  002f6	e8 00 00 00 00	 call	 __allshl
  002fb	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00301	89 01		 mov	 DWORD PTR [ecx], eax
  00303	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 614  : 
; 615  : #else
; 616  : 			// Big-endian platforms
; 617  : 
; 618  : 			finalCarry = 
; 619  : 				(*whiteningValuePtr64 & 0x80) ?
; 620  : 				135 : 0;
; 621  : 
; 622  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 623  : 
; 624  : 			whiteningValuePtr64--;
; 625  : 
; 626  : 			if (*whiteningValuePtr64 & 0x80)
; 627  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 628  : 
; 629  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 630  : #endif
; 631  : 
; 632  : 			whiteningValue[0] ^= finalCarry;

  00306	0f b6 95 b7 fd
	ff ff		 movzx	 edx, BYTE PTR _finalCarry$[ebp]
  0030d	0f b6 85 b8 fd
	ff ff		 movzx	 eax, BYTE PTR _whiteningValue$[ebp]
  00314	33 c2		 xor	 eax, edx
  00316	88 85 b8 fd ff
	ff		 mov	 BYTE PTR _whiteningValue$[ebp], al

; 633  : 		}

  0031c	e9 6d fe ff ff	 jmp	 $LN21@DecryptBuf@3
$LN20@DecryptBuf@3:

; 634  : 
; 635  : 		dataUnitBufPtr = bufPtr;

  00321	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  00327	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _dataUnitBufPtr$[ebp], ecx

; 636  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0032d	8b 55 f8	 mov	 edx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  00330	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx

; 637  : 
; 638  : 		// Decrypt blocks in this data unit
; 639  : 
; 640  : 		for (block = startBlock; block < endBlock; block++)

  00336	8b 85 a0 fd ff
	ff		 mov	 eax, DWORD PTR _startBlock$[ebp]
  0033c	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], eax
  00342	eb 0f		 jmp	 SHORT $LN16@DecryptBuf@3
$LN15@DecryptBuf@3:
  00344	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  0034a	83 c1 01	 add	 ecx, 1
  0034d	89 8d a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], ecx
$LN16@DecryptBuf@3:
  00353	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _block$[ebp]
  00359	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  0035c	0f 83 83 00 00
	00		 jae	 $LN14@DecryptBuf@3

; 641  : 		{
; 642  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00362	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00368	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0036e	8b 10		 mov	 edx, DWORD PTR [eax]
  00370	33 11		 xor	 edx, DWORD PTR [ecx]
  00372	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00375	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00378	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0037e	89 11		 mov	 DWORD PTR [ecx], edx
  00380	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00383	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  00389	83 ea 08	 sub	 edx, 8
  0038c	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx
  00392	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00398	83 c0 08	 add	 eax, 8
  0039b	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 643  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  003a1	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  003a7	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  003ad	8b 01		 mov	 eax, DWORD PTR [ecx]
  003af	33 02		 xor	 eax, DWORD PTR [edx]
  003b1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  003b4	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  003b7	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  003bd	89 02		 mov	 DWORD PTR [edx], eax
  003bf	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  003c2	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  003c8	83 e8 08	 sub	 eax, 8
  003cb	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax
  003d1	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  003d7	83 c1 08	 add	 ecx, 8
  003da	89 8d ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 644  : 		}

  003e0	e9 5f ff ff ff	 jmp	 $LN15@DecryptBuf@3
$LN14@DecryptBuf@3:

; 645  : 
; 646  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  003e5	8b 55 fc	 mov	 edx, DWORD PTR _endBlock$[ebp]
  003e8	2b 95 a0 fd ff
	ff		 sub	 edx, DWORD PTR _startBlock$[ebp]
  003ee	52		 push	 edx
  003ef	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  003f2	50		 push	 eax
  003f3	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitBufPtr$[ebp]
  003f9	51		 push	 ecx
  003fa	8b 55 24	 mov	 edx, DWORD PTR _cipher$[ebp]
  003fd	52		 push	 edx
  003fe	e8 00 00 00 00	 call	 _DecipherBlocks@16

; 647  : 
; 648  : 		bufPtr = dataUnitBufPtr;

  00403	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitBufPtr$[ebp]
  00409	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 649  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0040f	8b 4d f8	 mov	 ecx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  00412	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 650  : 
; 651  : 		for (block = startBlock; block < endBlock; block++)

  00418	8b 95 a0 fd ff
	ff		 mov	 edx, DWORD PTR _startBlock$[ebp]
  0041e	89 95 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], edx
  00424	eb 0f		 jmp	 SHORT $LN13@DecryptBuf@3
$LN12@DecryptBuf@3:
  00426	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  0042c	83 c0 01	 add	 eax, 1
  0042f	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], eax
$LN13@DecryptBuf@3:
  00435	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  0043b	3b 4d fc	 cmp	 ecx, DWORD PTR _endBlock$[ebp]
  0043e	0f 83 83 00 00
	00		 jae	 $LN11@DecryptBuf@3

; 652  : 		{
; 653  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00444	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0044a	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  00450	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00452	33 08		 xor	 ecx, DWORD PTR [eax]
  00454	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00457	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  0045a	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00460	89 08		 mov	 DWORD PTR [eax], ecx
  00462	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00465	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0046b	83 e9 08	 sub	 ecx, 8
  0046e	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx
  00474	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0047a	83 c2 08	 add	 edx, 8
  0047d	89 95 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], edx

; 654  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00483	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00489	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0048f	8b 10		 mov	 edx, DWORD PTR [eax]
  00491	33 11		 xor	 edx, DWORD PTR [ecx]
  00493	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00496	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00499	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0049f	89 11		 mov	 DWORD PTR [ecx], edx
  004a1	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  004a4	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  004aa	83 ea 08	 sub	 edx, 8
  004ad	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx
  004b3	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  004b9	83 c0 08	 add	 eax, 8
  004bc	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 655  : 		}

  004c2	e9 5f ff ff ff	 jmp	 $LN12@DecryptBuf@3
$LN11@DecryptBuf@3:

; 656  : 
; 657  : 		blockCount -= endBlock - startBlock;

  004c7	8b 4d fc	 mov	 ecx, DWORD PTR _endBlock$[ebp]
  004ca	2b 8d a0 fd ff
	ff		 sub	 ecx, DWORD PTR _startBlock$[ebp]
  004d0	33 d2		 xor	 edx, edx
  004d2	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp]
  004d8	2b c1		 sub	 eax, ecx
  004da	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp+4]
  004e0	1b ca		 sbb	 ecx, edx
  004e2	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], eax
  004e8	89 8d e4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], ecx

; 658  : 		startBlock = 0;

  004ee	c7 85 a0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _startBlock$[ebp], 0

; 659  : 		dataUnitNo++;

  004f8	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  004fe	83 c2 01	 add	 edx, 1
  00501	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  00507	83 d0 00	 adc	 eax, 0
  0050a	89 95 a8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], edx
  00510	89 85 ac fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax

; 660  : 
; 661  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00516	8b 8d a8 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  0051c	89 8d c8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  00522	8b 95 ac fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp+4]
  00528	89 95 cc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], edx

; 662  : 	}

  0052e	e9 b9 fb ff ff	 jmp	 $LN26@DecryptBuf@3
$LN10@DecryptBuf@3:

; 663  : 
; 664  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00533	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00539	89 85 98 fd ff
	ff		 mov	 DWORD PTR _burnm$25859[ebp], eax
  0053f	c7 85 9c fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _burnc$25861[ebp], 2
$LN7@DecryptBuf@3:
  00549	8b 8d 9c fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$25861[ebp]
  0054f	8b 95 9c fd ff
	ff		 mov	 edx, DWORD PTR _burnc$25861[ebp]
  00555	83 ea 01	 sub	 edx, 1
  00558	89 95 9c fd ff
	ff		 mov	 DWORD PTR _burnc$25861[ebp], edx
  0055e	85 c9		 test	 ecx, ecx
  00560	74 24		 je	 SHORT $LN9@DecryptBuf@3
  00562	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$25859[ebp]
  00568	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0056e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00575	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$25859[ebp]
  0057b	83 c1 08	 add	 ecx, 8
  0057e	89 8d 98 fd ff
	ff		 mov	 DWORD PTR _burnm$25859[ebp], ecx
  00584	eb c3		 jmp	 SHORT $LN7@DecryptBuf@3
$LN9@DecryptBuf@3:
  00586	33 d2		 xor	 edx, edx
  00588	75 a9		 jne	 SHORT $LN10@DecryptBuf@3
$LN5@DecryptBuf@3:

; 665  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  0058a	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  00590	89 85 90 fd ff
	ff		 mov	 DWORD PTR _burnm$25868[ebp], eax
  00596	c7 85 94 fd ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25870[ebp], 64 ; 00000040H
$LN2@DecryptBuf@3:
  005a0	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$25870[ebp]
  005a6	8b 95 94 fd ff
	ff		 mov	 edx, DWORD PTR _burnc$25870[ebp]
  005ac	83 ea 01	 sub	 edx, 1
  005af	89 95 94 fd ff
	ff		 mov	 DWORD PTR _burnc$25870[ebp], edx
  005b5	85 c9		 test	 ecx, ecx
  005b7	74 24		 je	 SHORT $LN4@DecryptBuf@3
  005b9	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$25868[ebp]
  005bf	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  005c5	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  005cc	8b 8d 90 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$25868[ebp]
  005d2	83 c1 08	 add	 ecx, 8
  005d5	89 8d 90 fd ff
	ff		 mov	 DWORD PTR _burnm$25868[ebp], ecx
  005db	eb c3		 jmp	 SHORT $LN2@DecryptBuf@3
$LN4@DecryptBuf@3:
  005dd	33 d2		 xor	 edx, edx
  005df	75 a9		 jne	 SHORT $LN5@DecryptBuf@3
$LN29@DecryptBuf@3:

; 666  : }

  005e1	8b 4d f4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e4	33 cd		 xor	 ecx, ebp
  005e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005eb	8b e5		 mov	 esp, ebp
  005ed	5d		 pop	 ebp
  005ee	c2 20 00	 ret	 32			; 00000020H
_DecryptBufferXTSParallel@32 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
;	COMDAT _DecryptBufferXTSNonParallel@32
_TEXT	SEGMENT
tv328 = -116						; size = 8
tv133 = -108						; size = 4
tv301 = -104						; size = 8
tv177 = -96						; size = 8
_burnm$25923 = -88					; size = 4
_burnc$25925 = -84					; size = 4
_startBlock$ = -80					; size = 4
_block$ = -76						; size = 4
_dataUnitNo$ = -72					; size = 8
_finalCarry$ = -57					; size = 1
_whiteningValue$ = -56					; size = 16
_byteBufUnitNo$ = -40					; size = 16
__$ArrayPad$ = -24					; size = 4
_whiteningValuePtr64$ = -20				; size = 4
_blockCount$ = -16					; size = 8
_bufPtr$ = -8						; size = 4
_endBlock$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTSNonParallel@32 PROC			; COMDAT

; 677  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 74	 sub	 esp, 116		; 00000074H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 678  : 	unsigned __int8 finalCarry;
; 679  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 680  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 681  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00012	8d 45 c8	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00015	89 45 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], eax

; 682  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0001b	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 683  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0001e	8b 55 18	 mov	 edx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	89 55 b0	 mov	 DWORD PTR _startBlock$[ebp], edx

; 684  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 685  : 
; 686  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 687  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 688  : 	dataUnitNo = startDataUnitNo->Value;

  00024	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d b8	 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0002c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002f	89 55 bc	 mov	 DWORD PTR _dataUnitNo$[ebp+4], edx

; 689  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00032	8b 45 b8	 mov	 eax, DWORD PTR _dataUnitNo$[ebp]
  00035	89 45 d8	 mov	 DWORD PTR _byteBufUnitNo$[ebp], eax
  00038	8b 4d bc	 mov	 ecx, DWORD PTR _dataUnitNo$[ebp+4]
  0003b	89 4d dc	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx

; 690  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0003e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _byteBufUnitNo$[ebp+8], 0
  00045	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _byteBufUnitNo$[ebp+12], 0

; 691  : 
; 692  : 	if (length % BYTES_PER_XTS_BLOCK)

  0004c	6a 00		 push	 0
  0004e	6a 10		 push	 16			; 00000010H
  00050	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00053	52		 push	 edx
  00054	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 __aullrem
  0005d	89 45 a0	 mov	 DWORD PTR tv177[ebp], eax
  00060	89 55 a4	 mov	 DWORD PTR tv177[ebp+4], edx
  00063	8b 4d a0	 mov	 ecx, DWORD PTR tv177[ebp]
  00066	0b 4d a4	 or	 ecx, DWORD PTR tv177[ebp+4]
  00069	74 16		 je	 SHORT $LN16@DecryptBuf@4

; 693  : 		GST_THROW_FATAL_EXCEPTION;

  0006b	68 54 53 47 00	 push	 4674388			; 00475354H
  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	68 b5 02 00 00	 push	 693			; 000002b5H
  00079	6a 29		 push	 41			; 00000029H
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN16@DecryptBuf@4:

; 694  : 
; 695  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00081	6a 00		 push	 0
  00083	6a 10		 push	 16			; 00000010H
  00085	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00088	52		 push	 edx
  00089	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 __aulldiv
  00092	89 45 f0	 mov	 DWORD PTR _blockCount$[ebp], eax
  00095	89 55 f4	 mov	 DWORD PTR _blockCount$[ebp+4], edx
$LN15@DecryptBuf@4:

; 696  : 
; 697  : 	// Process all blocks in the buffer
; 698  : 	while (blockCount > 0)

  00098	83 7d f4 00	 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  0009c	77 0a		 ja	 SHORT $LN21@DecryptBuf@4
  0009e	83 7d f0 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  000a2	0f 86 2f 02 00
	00		 jbe	 $LN5@DecryptBuf@4
$LN21@DecryptBuf@4:

; 699  : 	{
; 700  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  000a8	83 7d f4 00	 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000ac	77 13		 ja	 SHORT $LN13@DecryptBuf@4
  000ae	72 06		 jb	 SHORT $LN22@DecryptBuf@4
  000b0	83 7d f0 20	 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  000b4	73 0b		 jae	 SHORT $LN13@DecryptBuf@4
$LN22@DecryptBuf@4:

; 701  : 			endBlock = startBlock + (unsigned int) blockCount;

  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  000b9	03 4d b0	 add	 ecx, DWORD PTR _startBlock$[ebp]
  000bc	89 4d fc	 mov	 DWORD PTR _endBlock$[ebp], ecx

; 702  : 		else

  000bf	eb 07		 jmp	 SHORT $LN12@DecryptBuf@4
$LN13@DecryptBuf@4:

; 703  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000c1	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN12@DecryptBuf@4:

; 704  : 
; 705  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  000c8	8d 55 c8	 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  000cb	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 706  : 
; 707  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 708  : 		// whitening value for this data unit)
; 709  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  000ce	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  000d1	8b 4d d8	 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  000d4	89 08		 mov	 DWORD PTR [eax], ecx
  000d6	8b 55 dc	 mov	 edx, DWORD PTR _byteBufUnitNo$[ebp+4]
  000d9	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 710  : 		*(whiteningValuePtr64 + 1) = 0;

  000dc	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  000df	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  000e6	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 711  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000ed	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  000f0	51		 push	 ecx
  000f1	8d 55 c8	 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  000f4	52		 push	 edx
  000f5	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 _EncipherBlock@12

; 712  : 
; 713  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 714  : 		// decrypt all relevant blocks in this data unit
; 715  : 		for (block = 0; block < endBlock; block++)

  000fe	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _block$[ebp], 0
  00105	eb 09		 jmp	 SHORT $LN11@DecryptBuf@4
$LN10@DecryptBuf@4:
  00107	8b 4d b4	 mov	 ecx, DWORD PTR _block$[ebp]
  0010a	83 c1 01	 add	 ecx, 1
  0010d	89 4d b4	 mov	 DWORD PTR _block$[ebp], ecx
$LN11@DecryptBuf@4:
  00110	8b 55 b4	 mov	 edx, DWORD PTR _block$[ebp]
  00113	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  00116	0f 83 79 01 00
	00		 jae	 $LN9@DecryptBuf@4

; 716  : 		{
; 717  : 			if (block >= startBlock)

  0011c	8b 45 b4	 mov	 eax, DWORD PTR _block$[ebp]
  0011f	3b 45 b0	 cmp	 eax, DWORD PTR _startBlock$[ebp]
  00122	0f 82 b2 00 00
	00		 jb	 $LN8@DecryptBuf@4

; 718  : 			{
; 719  : 				// Post-whitening
; 720  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00128	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0012b	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0012e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00130	33 02		 xor	 eax, DWORD PTR [edx]
  00132	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00135	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  00138	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0013b	89 02		 mov	 DWORD PTR [edx], eax
  0013d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00140	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00143	83 c0 08	 add	 eax, 8
  00146	89 45 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], eax
  00149	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0014c	83 c1 08	 add	 ecx, 8
  0014f	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 721  : 				*bufPtr-- ^= *whiteningValuePtr64--;

  00152	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00155	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00158	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0015a	33 08		 xor	 ecx, DWORD PTR [eax]
  0015c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0015f	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  00162	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00165	89 08		 mov	 DWORD PTR [eax], ecx
  00167	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0016a	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0016d	83 e9 08	 sub	 ecx, 8
  00170	89 4d ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx
  00173	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00176	83 ea 08	 sub	 edx, 8
  00179	89 55 f8	 mov	 DWORD PTR _bufPtr$[ebp], edx

; 722  : 
; 723  : 				// Actual decryption
; 724  : 				DecipherBlock (cipher, bufPtr, ks);

  0017c	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  00183	51		 push	 ecx
  00184	8b 55 24	 mov	 edx, DWORD PTR _cipher$[ebp]
  00187	52		 push	 edx
  00188	e8 00 00 00 00	 call	 _DecipherBlock@12

; 725  : 
; 726  : 				// Pre-whitening
; 727  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  0018d	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00190	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00193	8b 10		 mov	 edx, DWORD PTR [eax]
  00195	33 11		 xor	 edx, DWORD PTR [ecx]
  00197	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019a	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  0019d	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001a0	89 11		 mov	 DWORD PTR [ecx], edx
  001a2	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001a5	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001a8	83 c2 08	 add	 edx, 8
  001ab	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx
  001ae	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  001b1	83 c0 08	 add	 eax, 8
  001b4	89 45 f8	 mov	 DWORD PTR _bufPtr$[ebp], eax

; 728  : 				*bufPtr++ ^= *whiteningValuePtr64;

  001b7	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001ba	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  001bf	33 02		 xor	 eax, DWORD PTR [edx]
  001c1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001c4	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  001c7	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001ca	89 02		 mov	 DWORD PTR [edx], eax
  001cc	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001cf	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  001d2	83 c0 08	 add	 eax, 8
  001d5	89 45 f8	 mov	 DWORD PTR _bufPtr$[ebp], eax

; 729  : 			}
; 730  : 			else

  001d8	eb 09		 jmp	 SHORT $LN7@DecryptBuf@4
$LN8@DecryptBuf@4:

; 731  : 				whiteningValuePtr64++;

  001da	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  001dd	83 c1 08	 add	 ecx, 8
  001e0	89 4d ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx
$LN7@DecryptBuf@4:

; 732  : 
; 733  : 			// Derive the next whitening value
; 734  : 
; 735  : #if BYTE_ORDER == LITTLE_ENDIAN
; 736  : 
; 737  : 			// Little-endian platforms
; 738  : 
; 739  : 			finalCarry = 
; 740  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 741  : 				135 : 0;

  001e3	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001e6	8b 02		 mov	 eax, DWORD PTR [edx]
  001e8	83 e0 00	 and	 eax, 0
  001eb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001ee	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  001f4	89 45 98	 mov	 DWORD PTR tv301[ebp], eax
  001f7	89 4d 9c	 mov	 DWORD PTR tv301[ebp+4], ecx
  001fa	8b 55 98	 mov	 edx, DWORD PTR tv301[ebp]
  001fd	0b 55 9c	 or	 edx, DWORD PTR tv301[ebp+4]
  00200	74 09		 je	 SHORT $LN19@DecryptBuf@4
  00202	c7 45 94 87 00
	00 00		 mov	 DWORD PTR tv133[ebp], 135 ; 00000087H
  00209	eb 07		 jmp	 SHORT $LN20@DecryptBuf@4
$LN19@DecryptBuf@4:
  0020b	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$LN20@DecryptBuf@4:
  00212	8a 45 94	 mov	 al, BYTE PTR tv133[ebp]
  00215	88 45 c7	 mov	 BYTE PTR _finalCarry$[ebp], al

; 742  : 
; 743  : 			*whiteningValuePtr64-- <<= 1;

  00218	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0021b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0021d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00220	b1 01		 mov	 cl, 1
  00222	e8 00 00 00 00	 call	 __allshl
  00227	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0022a	89 01		 mov	 DWORD PTR [ecx], eax
  0022c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0022f	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  00232	83 ea 08	 sub	 edx, 8
  00235	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 744  : 
; 745  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00238	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  0023b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023d	83 e1 00	 and	 ecx, 0
  00240	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00243	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00249	89 4d 8c	 mov	 DWORD PTR tv328[ebp], ecx
  0024c	89 55 90	 mov	 DWORD PTR tv328[ebp+4], edx
  0024f	8b 45 8c	 mov	 eax, DWORD PTR tv328[ebp]
  00252	0b 45 90	 or	 eax, DWORD PTR tv328[ebp+4]
  00255	74 15		 je	 SHORT $LN6@DecryptBuf@4

; 746  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00257	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0025a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0025d	83 ca 01	 or	 edx, 1
  00260	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00263	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00266	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00269	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN6@DecryptBuf@4:

; 747  : 
; 748  : 			*whiteningValuePtr64 <<= 1;

  0026c	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0026f	8b 02		 mov	 eax, DWORD PTR [edx]
  00271	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00274	b1 01		 mov	 cl, 1
  00276	e8 00 00 00 00	 call	 __allshl
  0027b	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0027e	89 01		 mov	 DWORD PTR [ecx], eax
  00280	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 749  : 
; 750  : #else
; 751  : 			// Big-endian platforms
; 752  : 
; 753  : 			finalCarry = 
; 754  : 				(*whiteningValuePtr64 & 0x80) ?
; 755  : 				135 : 0;
; 756  : 
; 757  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 758  : 
; 759  : 			whiteningValuePtr64--;
; 760  : 
; 761  : 			if (*whiteningValuePtr64 & 0x80)
; 762  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 763  : 
; 764  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 765  : #endif
; 766  : 
; 767  : 			whiteningValue[0] ^= finalCarry;

  00283	0f b6 55 c7	 movzx	 edx, BYTE PTR _finalCarry$[ebp]
  00287	0f b6 45 c8	 movzx	 eax, BYTE PTR _whiteningValue$[ebp]
  0028b	33 c2		 xor	 eax, edx
  0028d	88 45 c8	 mov	 BYTE PTR _whiteningValue$[ebp], al

; 768  : 		}

  00290	e9 72 fe ff ff	 jmp	 $LN10@DecryptBuf@4
$LN9@DecryptBuf@4:

; 769  : 
; 770  : 		blockCount -= endBlock - startBlock;

  00295	8b 4d fc	 mov	 ecx, DWORD PTR _endBlock$[ebp]
  00298	2b 4d b0	 sub	 ecx, DWORD PTR _startBlock$[ebp]
  0029b	33 d2		 xor	 edx, edx
  0029d	8b 45 f0	 mov	 eax, DWORD PTR _blockCount$[ebp]
  002a0	2b c1		 sub	 eax, ecx
  002a2	8b 4d f4	 mov	 ecx, DWORD PTR _blockCount$[ebp+4]
  002a5	1b ca		 sbb	 ecx, edx
  002a7	89 45 f0	 mov	 DWORD PTR _blockCount$[ebp], eax
  002aa	89 4d f4	 mov	 DWORD PTR _blockCount$[ebp+4], ecx

; 771  : 		startBlock = 0;

  002ad	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _startBlock$[ebp], 0

; 772  : 		dataUnitNo++;

  002b4	8b 55 b8	 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  002b7	83 c2 01	 add	 edx, 1
  002ba	8b 45 bc	 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  002bd	83 d0 00	 adc	 eax, 0
  002c0	89 55 b8	 mov	 DWORD PTR _dataUnitNo$[ebp], edx
  002c3	89 45 bc	 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax

; 773  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  002c6	8b 4d b8	 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  002c9	89 4d d8	 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  002cc	8b 55 bc	 mov	 edx, DWORD PTR _dataUnitNo$[ebp+4]
  002cf	89 55 dc	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], edx

; 774  : 	}

  002d2	e9 c1 fd ff ff	 jmp	 $LN15@DecryptBuf@4
$LN5@DecryptBuf@4:

; 775  : 
; 776  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  002d7	8d 45 c8	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  002da	89 45 a8	 mov	 DWORD PTR _burnm$25923[ebp], eax
  002dd	c7 45 ac 02 00
	00 00		 mov	 DWORD PTR _burnc$25925[ebp], 2
$LN2@DecryptBuf@4:
  002e4	8b 4d ac	 mov	 ecx, DWORD PTR _burnc$25925[ebp]
  002e7	8b 55 ac	 mov	 edx, DWORD PTR _burnc$25925[ebp]
  002ea	83 ea 01	 sub	 edx, 1
  002ed	89 55 ac	 mov	 DWORD PTR _burnc$25925[ebp], edx
  002f0	85 c9		 test	 ecx, ecx
  002f2	74 1b		 je	 SHORT $LN4@DecryptBuf@4
  002f4	8b 45 a8	 mov	 eax, DWORD PTR _burnm$25923[ebp]
  002f7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002fd	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00304	8b 4d a8	 mov	 ecx, DWORD PTR _burnm$25923[ebp]
  00307	83 c1 08	 add	 ecx, 8
  0030a	89 4d a8	 mov	 DWORD PTR _burnm$25923[ebp], ecx
  0030d	eb d5		 jmp	 SHORT $LN2@DecryptBuf@4
$LN4@DecryptBuf@4:
  0030f	33 d2		 xor	 edx, edx
  00311	75 c4		 jne	 SHORT $LN5@DecryptBuf@4
$LN18@DecryptBuf@4:

; 777  : }

  00313	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00316	33 cd		 xor	 ecx, ebp
  00318	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031d	8b e5		 mov	 esp, ebp
  0031f	5d		 pop	 ebp
  00320	c2 20 00	 ret	 32			; 00000020H
_DecryptBufferXTSNonParallel@32 ENDP
_TEXT	ENDS
END
