; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_ThreadPoolRunning DD 01H DUP (?)
_StopPending DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_EncryptionThreadPoolStop@0
PUBLIC	_ExInitializeFastMutex@4
PUBLIC	_EncryptionThreadPoolStart@4
EXTRN	_GSTStartThread@12:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	_GetCpuCount@0:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_ThreadHandles DD 040H DUP (?)
_ThreadCount DD	01H DUP (?)
_WorkItemQueue DB 02400H DUP (?)
_EnqueueMutex DB 020H DUP (?)
_DequeueMutex DB 020H DUP (?)
_WorkItemCompletedEvent DB 010H DUP (?)
_WorkItemReadyEvent DB 010H DUP (?)
_EnqueuePosition DD 01H DUP (?)
_DequeuePosition DD 01H DUP (?)
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
_BSS	ENDS
;	COMDAT _EncryptionThreadPoolStart@4
_TEXT	SEGMENT
_cpuCount$ = -8						; size = 4
_i$ = -4						; size = 4
_encryptionFreeCpuCount$ = 8				; size = 4
_EncryptionThreadPoolStart@4 PROC			; COMDAT

; 255  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 256  : 	size_t cpuCount, i;
; 257  : 
; 258  : 	if (ThreadPoolRunning)

  00008	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  0000f	74 0a		 je	 SHORT $LN11@Encryption

; 259  : 		return TRUE;

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	e9 3b 01 00 00	 jmp	 $LN12@Encryption
$LN11@Encryption:

; 260  : 
; 261  : #ifdef DEVICE_DRIVER
; 262  : 	cpuCount = GetCpuCount();

  0001b	e8 00 00 00 00	 call	 _GetCpuCount@0
  00020	89 45 f8	 mov	 DWORD PTR _cpuCount$[ebp], eax

; 263  : #else
; 264  : 	{
; 265  : 		SYSTEM_INFO sysInfo;
; 266  : 		GetSystemInfo (&sysInfo);
; 267  : 		cpuCount = sysInfo.dwNumberOfProcessors;
; 268  : 	}
; 269  : #endif
; 270  : 
; 271  : 	if (cpuCount > encryptionFreeCpuCount)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _cpuCount$[ebp]
  00026	3b 45 08	 cmp	 eax, DWORD PTR _encryptionFreeCpuCount$[ebp]
  00029	76 09		 jbe	 SHORT $LN10@Encryption

; 272  : 		cpuCount -= encryptionFreeCpuCount;

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _cpuCount$[ebp]
  0002e	2b 4d 08	 sub	 ecx, DWORD PTR _encryptionFreeCpuCount$[ebp]
  00031	89 4d f8	 mov	 DWORD PTR _cpuCount$[ebp], ecx
$LN10@Encryption:

; 273  : 
; 274  : 	if (cpuCount < 2)

  00034	83 7d f8 02	 cmp	 DWORD PTR _cpuCount$[ebp], 2
  00038	73 0a		 jae	 SHORT $LN9@Encryption

; 275  : 		return TRUE;

  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	e9 12 01 00 00	 jmp	 $LN12@Encryption
$LN9@Encryption:

; 276  : 
; 277  : 	if (cpuCount > GST_ENC_THREAD_POOL_MAX_THREAD_COUNT)

  00044	83 7d f8 40	 cmp	 DWORD PTR _cpuCount$[ebp], 64 ; 00000040H
  00048	76 07		 jbe	 SHORT $LN8@Encryption

; 278  : 		cpuCount = GST_ENC_THREAD_POOL_MAX_THREAD_COUNT;

  0004a	c7 45 f8 40 00
	00 00		 mov	 DWORD PTR _cpuCount$[ebp], 64 ; 00000040H
$LN8@Encryption:

; 279  : 
; 280  : 	StopPending = FALSE;

  00051	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _StopPending, 0

; 281  : 	DequeuePosition = 0;

  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DequeuePosition, 0

; 282  : 	EnqueuePosition = 0;

  00065	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0

; 283  : 
; 284  : #ifdef DEVICE_DRIVER
; 285  : 	KeInitializeEvent (&WorkItemReadyEvent, SynchronizationEvent, FALSE);

  0006f	6a 00		 push	 0
  00071	6a 01		 push	 1
  00073	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 286  : 	KeInitializeEvent (&WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  0007e	6a 00		 push	 0
  00080	6a 01		 push	 1
  00082	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 287  : #else
; 288  : 	WorkItemReadyEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 289  : 	if (!WorkItemReadyEvent)
; 290  : 		return FALSE;
; 291  : 	
; 292  : 	WorkItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 293  : 	if (!WorkItemCompletedEvent)
; 294  : 		return FALSE;
; 295  : #endif
; 296  : 	
; 297  : #ifdef DEVICE_DRIVER
; 298  : 	ExInitializeFastMutex (&DequeueMutex);

  0008d	68 00 00 00 00	 push	 OFFSET _DequeueMutex
  00092	e8 00 00 00 00	 call	 _ExInitializeFastMutex@4

; 299  : 	ExInitializeFastMutex (&EnqueueMutex);

  00097	68 00 00 00 00	 push	 OFFSET _EnqueueMutex
  0009c	e8 00 00 00 00	 call	 _ExInitializeFastMutex@4

; 300  : #else
; 301  : 	DequeueMutex = CreateMutex (NULL, FALSE, NULL);
; 302  : 	if (!DequeueMutex)
; 303  : 		return FALSE;
; 304  : 
; 305  : 	EnqueueMutex = CreateMutex (NULL, FALSE, NULL);
; 306  : 	if (!EnqueueMutex)
; 307  : 		return FALSE;
; 308  : #endif
; 309  : 
; 310  : 	memset (WorkItemQueue, 0, sizeof (WorkItemQueue));

  000a1	68 00 24 00 00	 push	 9216			; 00002400H
  000a6	6a 00		 push	 0
  000a8	68 00 00 00 00	 push	 OFFSET _WorkItemQueue
  000ad	e8 00 00 00 00	 call	 _memset
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 311  : 
; 312  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)

  000b5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000bc	eb 09		 jmp	 SHORT $LN7@Encryption
$LN6@Encryption:
  000be	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000c1	83 c2 01	 add	 edx, 1
  000c4	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN7@Encryption:
  000c7	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 128	; 00000080H
  000ce	73 29		 jae	 SHORT $LN5@Encryption

; 313  : 	{
; 314  : 		WorkItemQueue[i].State = WorkItemFree;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d3	6b c0 48	 imul	 eax, 72			; 00000048H
  000d6	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WorkItemQueue[eax], 0

; 315  : 
; 316  : #ifdef DEVICE_DRIVER
; 317  : 		KeInitializeEvent (&WorkItemQueue[i].ItemCompletedEvent, SynchronizationEvent, FALSE);

  000e0	6a 00		 push	 0
  000e2	6a 01		 push	 1
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e7	6b c9 48	 imul	 ecx, 72			; 00000048H
  000ea	81 c1 08 00 00
	00		 add	 ecx, OFFSET _WorkItemQueue+8
  000f0	51		 push	 ecx
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 318  : #else
; 319  : 		WorkItemQueue[i].ItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 320  : 		if (!WorkItemQueue[i].ItemCompletedEvent)
; 321  : 		{
; 322  : 			EncryptionThreadPoolStop();
; 323  : 			return FALSE;
; 324  : 		}
; 325  : #endif
; 326  : 	}

  000f7	eb c5		 jmp	 SHORT $LN6@Encryption
$LN5@Encryption:

; 327  : 
; 328  : 	for (ThreadCount = 0; ThreadCount < cpuCount; ++ThreadCount)

  000f9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadCount, 0
  00103	eb 0f		 jmp	 SHORT $LN4@Encryption
$LN3@Encryption:
  00105	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ThreadCount
  0010b	83 c2 01	 add	 edx, 1
  0010e	89 15 00 00 00
	00		 mov	 DWORD PTR _ThreadCount, edx
$LN4@Encryption:
  00114	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadCount
  00119	3b 45 f8	 cmp	 eax, DWORD PTR _cpuCount$[ebp]
  0011c	73 29		 jae	 SHORT $LN2@Encryption

; 329  : 	{
; 330  : #ifdef DEVICE_DRIVER
; 331  : 		if (!NT_SUCCESS (GSTStartThread (EncryptionThreadProc, NULL, &ThreadHandles[ThreadCount])))

  0011e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ThreadCount
  00124	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR _ThreadHandles[ecx*4]
  0012b	52		 push	 edx
  0012c	6a 00		 push	 0
  0012e	68 00 00 00 00	 push	 OFFSET _EncryptionThreadProc@4
  00133	e8 00 00 00 00	 call	 _GSTStartThread@12
  00138	85 c0		 test	 eax, eax
  0013a	7d 09		 jge	 SHORT $LN1@Encryption

; 332  : #else
; 333  : 		if (!(ThreadHandles[ThreadCount] = (HANDLE) _beginthreadex (NULL, 0, EncryptionThreadProc, NULL, 0, NULL)))
; 334  : #endif
; 335  : 		{
; 336  : 			EncryptionThreadPoolStop();

  0013c	e8 00 00 00 00	 call	 _EncryptionThreadPoolStop@0

; 337  : 			return FALSE;

  00141	33 c0		 xor	 eax, eax
  00143	eb 11		 jmp	 SHORT $LN12@Encryption
$LN1@Encryption:

; 338  : 		}
; 339  : 	}

  00145	eb be		 jmp	 SHORT $LN3@Encryption
$LN2@Encryption:

; 340  : 
; 341  : 	ThreadPoolRunning = TRUE;

  00147	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ThreadPoolRunning, 1

; 342  : 	return TRUE;

  00151	b8 01 00 00 00	 mov	 eax, 1
$LN12@Encryption:

; 343  : }

  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c2 04 00	 ret	 4
_EncryptionThreadPoolStart@4 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _ExInitializeFastMutex@4
_TEXT	SEGMENT
_FastMutex$ = 8						; size = 4
_ExInitializeFastMutex@4 PROC				; COMDAT

; 16362: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 16363: 
; 16364:     FastMutex->Count = FM_LOCK_BIT;

  00005	8b 45 08	 mov	 eax, DWORD PTR _FastMutex$[ebp]
  00008	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 16365:     FastMutex->Owner = NULL;

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _FastMutex$[ebp]
  00011	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 16366:     FastMutex->Contention = 0;

  00018	8b 55 08	 mov	 edx, DWORD PTR _FastMutex$[ebp]
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 16367:     KeInitializeEvent(&FastMutex->Event, SynchronizationEvent, FALSE);

  00022	6a 00		 push	 0
  00024	6a 01		 push	 1
  00026	8b 45 08	 mov	 eax, DWORD PTR _FastMutex$[ebp]
  00029	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 16368:     return;
; 16369: }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
_ExInitializeFastMutex@4 ENDP
_TEXT	ENDS
EXTRN	__imp__PsTerminateSystemThread@4:PROC
EXTRN	__imp__KeSetEvent@12:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_derive_key_stribog@28:PROC
EXTRN	_derive_key_gosthash@28:PROC
EXTRN	_derive_key_whirlpool@28:PROC
EXTRN	_GetMaxPkcs5OutSize@0:PROC
EXTRN	_EncryptDataUnitsCurrentThread@20:PROC
EXTRN	_DecryptDataUnitsCurrentThread@20:PROC
EXTRN	__imp_@ExReleaseFastMutex@4:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	__imp_@ExAcquireFastMutex@4:PROC
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _EncryptionThreadProc@4
_TEXT	SEGMENT
tv142 = -12						; size = 4
tv90 = -8						; size = 4
_workItem$ = -4						; size = 4
_threadArg$ = 8						; size = 4
_EncryptionThreadProc@4 PROC				; COMDAT

; 158  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
$LN21@Encryption@2:

; 159  : 	EncryptionThreadPoolWorkItem *workItem;
; 160  : 
; 161  : 	while (!StopPending)

  00008	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  0000f	0f 85 93 02 00
	00		 jne	 $LN20@Encryption@2

; 162  : 	{
; 163  : 		GST_ACQUIRE_MUTEX (&DequeueMutex);

  00015	b9 00 00 00 00	 mov	 ecx, OFFSET _DequeueMutex
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutex@4

; 164  : 
; 165  : 		workItem = &WorkItemQueue[DequeuePosition++];

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _DequeuePosition
  00025	6b c0 48	 imul	 eax, 72			; 00000048H
  00028	05 00 00 00 00	 add	 eax, OFFSET _WorkItemQueue
  0002d	89 45 fc	 mov	 DWORD PTR _workItem$[ebp], eax
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DequeuePosition
  00036	83 c1 01	 add	 ecx, 1
  00039	89 0d 00 00 00
	00		 mov	 DWORD PTR _DequeuePosition, ecx

; 166  : 
; 167  : 		if (DequeuePosition >= GST_ENC_THREAD_POOL_QUEUE_SIZE)

  0003f	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR _DequeuePosition, 128 ; 00000080H
  00049	7c 0a		 jl	 SHORT $LN18@Encryption@2

; 168  : 			DequeuePosition = 0;

  0004b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DequeuePosition, 0
$LN18@Encryption@2:

; 169  : 
; 170  : 		while (!StopPending && GetWorkItemState (workItem) != WorkItemReady)

  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  0005c	75 23		 jne	 SHORT $LN17@Encryption@2
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 _GetWorkItemState@4
  00067	83 f8 01	 cmp	 eax, 1
  0006a	74 15		 je	 SHORT $LN17@Encryption@2

; 171  : 		{
; 172  : 			GST_WAIT_EVENT (WorkItemReadyEvent);

  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 173  : 		}

  0007f	eb d4		 jmp	 SHORT $LN18@Encryption@2
$LN17@Encryption@2:

; 174  : 
; 175  : 		SetWorkItemState (workItem, WorkItemBusy);

  00081	6a 02		 push	 2
  00083	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 176  : 
; 177  : 		GST_RELEASE_MUTEX (&DequeueMutex);

  0008c	b9 00 00 00 00	 mov	 ecx, OFFSET _DequeueMutex
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutex@4

; 178  : 
; 179  : 		if (StopPending)

  00097	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  0009e	74 05		 je	 SHORT $LN16@Encryption@2

; 180  : 			break;

  000a0	e9 03 02 00 00	 jmp	 $LN20@Encryption@2
$LN16@Encryption@2:

; 181  : 
; 182  : 		switch (workItem->Type)

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  000a8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ab	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  000ae	83 7d f8 00	 cmp	 DWORD PTR tv90[ebp], 0
  000b2	74 3a		 je	 SHORT $LN12@Encryption@2
  000b4	83 7d f8 01	 cmp	 DWORD PTR tv90[ebp], 1
  000b8	74 0b		 je	 SHORT $LN13@Encryption@2
  000ba	83 7d f8 02	 cmp	 DWORD PTR tv90[ebp], 2
  000be	74 57		 je	 SHORT $LN11@Encryption@2
  000c0	e9 7c 01 00 00	 jmp	 $LN3@Encryption@2
$LN13@Encryption@2:

; 183  : 		{
; 184  : 		case DecryptDataUnitsWork:
; 185  : 			DecryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  000c8	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000cb	51		 push	 ecx
  000cc	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000cf	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000d2	33 c9		 xor	 ecx, ecx
  000d4	51		 push	 ecx
  000d5	50		 push	 eax
  000d6	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000d9	83 c2 28	 add	 edx, 40			; 00000028H
  000dc	52		 push	 edx
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  000e0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 _DecryptDataUnitsCurrentThread@20

; 186  : 			break;

  000e9	e9 69 01 00 00	 jmp	 $LN14@Encryption@2
$LN12@Encryption@2:

; 187  : 
; 188  : 		case EncryptDataUnitsWork:
; 189  : 			EncryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  000ee	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000f1	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000f4	50		 push	 eax
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  000f8	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000fb	33 c0		 xor	 eax, eax
  000fd	50		 push	 eax
  000fe	52		 push	 edx
  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00102	83 c1 28	 add	 ecx, 40			; 00000028H
  00105	51		 push	 ecx
  00106	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00109	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread@20

; 190  : 			break;

  00112	e9 40 01 00 00	 jmp	 $LN14@Encryption@2
$LN11@Encryption@2:

; 191  : 
; 192  : 		case DeriveKeyWork:
; 193  : 			switch (workItem->KeyDerivation.Pkcs5Prf)

  00117	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  0011a	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0011d	89 55 f4	 mov	 DWORD PTR tv142[ebp], edx
  00120	83 7d f4 01	 cmp	 DWORD PTR tv142[ebp], 1
  00124	74 75		 je	 SHORT $LN6@Encryption@2
  00126	83 7d f4 02	 cmp	 DWORD PTR tv142[ebp], 2
  0012a	74 3d		 je	 SHORT $LN7@Encryption@2
  0012c	83 7d f4 03	 cmp	 DWORD PTR tv142[ebp], 3
  00130	74 05		 je	 SHORT $LN8@Encryption@2
  00132	e9 96 00 00 00	 jmp	 $LN5@Encryption@2
$LN8@Encryption@2:

; 194  : 			{
; 195  : #ifndef GST_WINDOWS_BOOT
; 196  : 			case WHIRLPOOL:
; 197  : 				derive_key_whirlpool (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 198  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00137	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  0013c	50		 push	 eax
  0013d	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00140	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00143	51		 push	 ecx
  00144	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00147	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0014a	50		 push	 eax
  0014b	6a 40		 push	 64			; 00000040H
  0014d	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00150	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00153	52		 push	 edx
  00154	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00157	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0015a	51		 push	 ecx
  0015b	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  0015e	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 _derive_key_whirlpool@28

; 199  : 				break;

  00167	eb 7a		 jmp	 SHORT $LN9@Encryption@2
$LN7@Encryption@2:

; 200  : 			case GOSTHASH:
; 201  : 				derive_key_gosthash (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 202  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00169	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  0016e	50		 push	 eax
  0016f	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00172	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00175	52		 push	 edx
  00176	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00179	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0017c	51		 push	 ecx
  0017d	6a 40		 push	 64			; 00000040H
  0017f	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00182	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00185	50		 push	 eax
  00186	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00189	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0018c	52		 push	 edx
  0018d	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00190	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00193	51		 push	 ecx
  00194	e8 00 00 00 00	 call	 _derive_key_gosthash@28

; 203  : 				break;

  00199	eb 48		 jmp	 SHORT $LN9@Encryption@2
$LN6@Encryption@2:

; 204  : #endif
; 205  : 			case STRIBOG:
; 206  : 				derive_key_stribog (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 207  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  0019b	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  001a0	50		 push	 eax
  001a1	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  001a4	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  001a7	50		 push	 eax
  001a8	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001ab	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  001ae	52		 push	 edx
  001af	6a 40		 push	 64			; 00000040H
  001b1	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  001b4	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  001b7	51		 push	 ecx
  001b8	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  001bb	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  001be	50		 push	 eax
  001bf	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001c2	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001c5	52		 push	 edx
  001c6	e8 00 00 00 00	 call	 _derive_key_stribog@28

; 208  : 				break;

  001cb	eb 16		 jmp	 SHORT $LN9@Encryption@2
$LN5@Encryption@2:

; 209  : 			default:		
; 210  : 				GST_THROW_FATAL_EXCEPTION;

  001cd	68 54 53 47 00	 push	 4674388			; 00475354H
  001d2	6a 00		 push	 0
  001d4	6a 00		 push	 0
  001d6	68 d2 00 00 00	 push	 210			; 000000d2H
  001db	6a 29		 push	 41			; 00000029H
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN9@Encryption@2:

; 211  : 			} 
; 212  : 
; 213  : 			InterlockedExchange (workItem->KeyDerivation.CompletionFlag, TRUE);

  001e3	b8 01 00 00 00	 mov	 eax, 1
  001e8	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001eb	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  001ee	87 02		 xchg	 DWORD PTR [edx], eax

; 214  : 			GST_SET_EVENT (*workItem->KeyDerivation.CompletionEvent);

  001f0	6a 00		 push	 0
  001f2	6a 01		 push	 1
  001f4	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  001f7	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001fa	51		 push	 ecx
  001fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 215  : 			
; 216  : 			if (InterlockedDecrement (workItem->KeyDerivation.OutstandingWorkItemCount) == 0)

  00201	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00204	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00207	83 c9 ff	 or	 ecx, -1
  0020a	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0020e	49		 dec	 ecx
  0020f	75 11		 jne	 SHORT $LN4@Encryption@2

; 217  : 				GST_SET_EVENT (*workItem->KeyDerivation.NoOutstandingWorkItemEvent);

  00211	6a 00		 push	 0
  00213	6a 01		 push	 1
  00215	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00218	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0021b	50		 push	 eax
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN4@Encryption@2:

; 218  : 
; 219  : 			SetWorkItemState (workItem, WorkItemFree);

  00222	6a 00		 push	 0
  00224	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00227	51		 push	 ecx
  00228	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 220  : 			GST_SET_EVENT (WorkItemCompletedEvent);

  0022d	6a 00		 push	 0
  0022f	6a 01		 push	 1
  00231	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 221  : 			continue;

  0023c	e9 c7 fd ff ff	 jmp	 $LN21@Encryption@2
$LN3@Encryption@2:

; 222  : 
; 223  : 		default:
; 224  : 			GST_THROW_FATAL_EXCEPTION;

  00241	68 54 53 47 00	 push	 4674388			; 00475354H
  00246	6a 00		 push	 0
  00248	6a 00		 push	 0
  0024a	68 e0 00 00 00	 push	 224			; 000000e0H
  0024f	6a 29		 push	 41			; 00000029H
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN14@Encryption@2:

; 225  : 		}
; 226  : 
; 227  : 		if (workItem != workItem->FirstFragment)

  00257	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  0025a	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  0025d	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  00260	74 1a		 je	 SHORT $LN2@Encryption@2

; 228  : 		{
; 229  : 			SetWorkItemState (workItem, WorkItemFree);

  00262	6a 00		 push	 0
  00264	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00267	51		 push	 ecx
  00268	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 230  : 			GST_SET_EVENT (WorkItemCompletedEvent);

  0026d	6a 00		 push	 0
  0026f	6a 01		 push	 1
  00271	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  00276	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN2@Encryption@2:

; 231  : 		}
; 232  : 
; 233  : 		if (InterlockedDecrement (&workItem->FirstFragment->OutstandingFragmentCount) == 0)

  0027c	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  0027f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00282	83 c0 1c	 add	 eax, 28			; 0000001cH
  00285	83 c9 ff	 or	 ecx, -1
  00288	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0028c	49		 dec	 ecx
  0028d	75 14		 jne	 SHORT $LN1@Encryption@2

; 234  : 			GST_SET_EVENT (workItem->FirstFragment->ItemCompletedEvent);

  0028f	6a 00		 push	 0
  00291	6a 01		 push	 1
  00293	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00296	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00299	83 c0 08	 add	 eax, 8
  0029c	50		 push	 eax
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN1@Encryption@2:

; 235  : 	}

  002a3	e9 60 fd ff ff	 jmp	 $LN21@Encryption@2
$LN20@Encryption@2:

; 236  : 
; 237  : #ifdef DEVICE_DRIVER
; 238  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  002a8	6a 00		 push	 0
  002aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
$LN23@Encryption@2:

; 239  : #else
; 240  : 	_endthreadex (0);
; 241  :     return 0;
; 242  : #endif
; 243  : }

  002b0	8b e5		 mov	 esp, ebp
  002b2	5d		 pop	 ebp
  002b3	c2 04 00	 ret	 4
_EncryptionThreadProc@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _GetWorkItemState@4
_TEXT	SEGMENT
_workItem$ = 8						; size = 4
_GetWorkItemState@4 PROC				; COMDAT

; 129  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 130  : 	return InterlockedExchangeAdd ((LONG *) &workItem->State, 0);

  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _workItem$[ebp]
  0000a	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax

; 131  : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_GetWorkItemState@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _SetWorkItemState@8
_TEXT	SEGMENT
_workItem$ = 8						; size = 4
_newState$ = 12						; size = 4
_SetWorkItemState@8 PROC				; COMDAT

; 144  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 145  : 	InterlockedExchange ((LONG *) &workItem->State, (LONG) newState);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _newState$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _workItem$[ebp]
  0000b	87 01		 xchg	 DWORD PTR [ecx], eax

; 146  : }

  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
_SetWorkItemState@8 ENDP
_TEXT	ENDS
EXTRN	_GSTStopThread@8:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptionThreadPoolStop@0
_TEXT	SEGMENT
_i$ = -4						; size = 4
_EncryptionThreadPoolStop@0 PROC			; COMDAT

; 354  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 355  : 	size_t i;
; 356  : 
; 357  : 	if (!ThreadPoolRunning)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  0000d	75 02		 jne	 SHORT $LN4@Encryption@3

; 358  : 		return;

  0000f	eb 61		 jmp	 SHORT $LN5@Encryption@3
$LN4@Encryption@3:

; 359  : 
; 360  : 	StopPending = TRUE;

  00011	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _StopPending, 1

; 361  : 	GST_SET_EVENT (WorkItemReadyEvent);

  0001b	6a 00		 push	 0
  0001d	6a 01		 push	 1
  0001f	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 362  : 
; 363  : 	for (i = 0; i < ThreadCount; ++i)

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN3@Encryption@3
$LN2@Encryption@3:
  00033	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@Encryption@3:
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0003f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _ThreadCount
  00045	73 17		 jae	 SHORT $LN1@Encryption@3

; 364  : 	{
; 365  : #ifdef DEVICE_DRIVER
; 366  : 		GSTStopThread (ThreadHandles[i], &WorkItemReadyEvent);

  00047	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0004f	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _ThreadHandles[edx*4]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _GSTStopThread@8

; 367  : #else
; 368  : 		GST_WAIT_EVENT (ThreadHandles[i]);
; 369  : #endif
; 370  : 	}

  0005c	eb d5		 jmp	 SHORT $LN2@Encryption@3
$LN1@Encryption@3:

; 371  : 
; 372  : 	ThreadCount = 0;

  0005e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadCount, 0

; 373  : 
; 374  : #ifndef DEVICE_DRIVER
; 375  : 	CloseHandle (DequeueMutex);
; 376  : 	CloseHandle (EnqueueMutex);
; 377  : 
; 378  : 	CloseHandle (WorkItemReadyEvent);
; 379  : 	CloseHandle (WorkItemCompletedEvent);
; 380  : 
; 381  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)
; 382  : 	{
; 383  : 		if (WorkItemQueue[i].ItemCompletedEvent)
; 384  : 			CloseHandle (WorkItemQueue[i].ItemCompletedEvent);
; 385  : 	}
; 386  : #endif
; 387  : 
; 388  : 	ThreadPoolRunning = FALSE;

  00068	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadPoolRunning, 0
$LN5@Encryption@3:

; 389  : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_EncryptionThreadPoolStop@0 ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolBeginKeyDerivation@40
EXTRN	__imp__KeClearEvent@4:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptionThreadPoolBeginKeyDerivation@40
_TEXT	SEGMENT
_workItem$ = -4						; size = 4
_completionEvent$ = 8					; size = 4
_noOutstandingWorkItemEvent$ = 12			; size = 4
_completionFlag$ = 16					; size = 4
_outstandingWorkItemCount$ = 20				; size = 4
_pkcs5Prf$ = 24						; size = 4
_password$ = 28						; size = 4
_passwordLength$ = 32					; size = 4
_salt$ = 36						; size = 4
_iterationCount$ = 40					; size = 4
_derivedKey$ = 44					; size = 4
_EncryptionThreadPoolBeginKeyDerivation@40 PROC		; COMDAT

; 410  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 411  : 	EncryptionThreadPoolWorkItem *workItem;
; 412  : 
; 413  : 	if (!ThreadPoolRunning)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  0000d	75 16		 jne	 SHORT $LN4@Encryption@4

; 414  : 		GST_THROW_FATAL_EXCEPTION;

  0000f	68 54 53 47 00	 push	 4674388			; 00475354H
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	68 9e 01 00 00	 push	 414			; 0000019eH
  0001d	6a 29		 push	 41			; 00000029H
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN4@Encryption@4:

; 415  : 
; 416  : 	GST_ACQUIRE_MUTEX (&EnqueueMutex);

  00025	b9 00 00 00 00	 mov	 ecx, OFFSET _EnqueueMutex
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutex@4

; 417  : 
; 418  : 	workItem = &WorkItemQueue[EnqueuePosition++];

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR _EnqueuePosition
  00035	6b c0 48	 imul	 eax, 72			; 00000048H
  00038	05 00 00 00 00	 add	 eax, OFFSET _WorkItemQueue
  0003d	89 45 fc	 mov	 DWORD PTR _workItem$[ebp], eax
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueuePosition
  00046	83 c1 01	 add	 ecx, 1
  00049	89 0d 00 00 00
	00		 mov	 DWORD PTR _EnqueuePosition, ecx

; 419  : 	if (EnqueuePosition >= GST_ENC_THREAD_POOL_QUEUE_SIZE)

  0004f	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR _EnqueuePosition, 128 ; 00000080H
  00059	7c 0a		 jl	 SHORT $LN2@Encryption@4

; 420  : 		EnqueuePosition = 0;

  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0
$LN2@Encryption@4:

; 421  : 
; 422  : 	while (GetWorkItemState (workItem) != WorkItemFree)

  00065	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _GetWorkItemState@4
  0006e	85 c0		 test	 eax, eax
  00070	74 15		 je	 SHORT $LN1@Encryption@4

; 423  : 	{
; 424  : 		GST_WAIT_EVENT (WorkItemCompletedEvent);

  00072	6a 00		 push	 0
  00074	6a 00		 push	 0
  00076	6a 00		 push	 0
  00078	6a 00		 push	 0
  0007a	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 425  : 	}

  00085	eb de		 jmp	 SHORT $LN2@Encryption@4
$LN1@Encryption@4:

; 426  : 
; 427  : 	workItem->Type = DeriveKeyWork;

  00087	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  0008a	c7 40 04 02 00
	00 00		 mov	 DWORD PTR [eax+4], 2

; 428  : 	workItem->KeyDerivation.CompletionEvent = completionEvent;

  00091	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00094	8b 55 08	 mov	 edx, DWORD PTR _completionEvent$[ebp]
  00097	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 429  : 	workItem->KeyDerivation.CompletionFlag = completionFlag;

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  0009d	8b 4d 10	 mov	 ecx, DWORD PTR _completionFlag$[ebp]
  000a0	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 430  : 	workItem->KeyDerivation.DerivedKey = derivedKey;

  000a3	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000a6	8b 45 2c	 mov	 eax, DWORD PTR _derivedKey$[ebp]
  000a9	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 431  : 	workItem->KeyDerivation.IterationCount = iterationCount;

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  000af	8b 55 28	 mov	 edx, DWORD PTR _iterationCount$[ebp]
  000b2	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 432  : 	workItem->KeyDerivation.NoOutstandingWorkItemEvent = noOutstandingWorkItemEvent;

  000b5	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  000bb	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 433  : 	workItem->KeyDerivation.OutstandingWorkItemCount = outstandingWorkItemCount;

  000be	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000c1	8b 45 14	 mov	 eax, DWORD PTR _outstandingWorkItemCount$[ebp]
  000c4	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 434  : 	workItem->KeyDerivation.Password = password;

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  000ca	8b 55 1c	 mov	 edx, DWORD PTR _password$[ebp]
  000cd	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 435  : 	workItem->KeyDerivation.PasswordLength = passwordLength;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  000d3	8b 4d 20	 mov	 ecx, DWORD PTR _passwordLength$[ebp]
  000d6	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 436  : 	workItem->KeyDerivation.Pkcs5Prf = pkcs5Prf;

  000d9	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000dc	8b 45 18	 mov	 eax, DWORD PTR _pkcs5Prf$[ebp]
  000df	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 437  : 	workItem->KeyDerivation.Salt = salt;

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  000e5	8b 55 24	 mov	 edx, DWORD PTR _salt$[ebp]
  000e8	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 438  : 
; 439  : 	InterlockedIncrement (outstandingWorkItemCount);

  000eb	8b 45 14	 mov	 eax, DWORD PTR _outstandingWorkItemCount$[ebp]
  000ee	b9 01 00 00 00	 mov	 ecx, 1
  000f3	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx

; 440  : 	GST_CLEAR_EVENT (*noOutstandingWorkItemEvent);

  000f7	8b 55 0c	 mov	 edx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  000fa	52		 push	 edx
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeClearEvent@4

; 441  : 
; 442  : 	SetWorkItemState (workItem, WorkItemReady);

  00101	6a 01		 push	 1
  00103	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 443  : 	GST_SET_EVENT (WorkItemReadyEvent);

  0010c	6a 00		 push	 0
  0010e	6a 01		 push	 1
  00110	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 444  : 	GST_RELEASE_MUTEX (&EnqueueMutex);

  0011b	b9 00 00 00 00	 mov	 ecx, OFFSET _EnqueueMutex
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutex@4
$LN6@Encryption@4:

; 445  : }

  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 28 00	 ret	 40			; 00000028H
_EncryptionThreadPoolBeginKeyDerivation@40 ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolDoWork@20
; Function compile flags: /Odtp
;	COMDAT _EncryptionThreadPoolDoWork@20
_TEXT	SEGMENT
tv68 = -40						; size = 4
_firstFragmentWorkItem$ = -36				; size = 4
_fragmentStartUnitNo$ = -32				; size = 8
_fragmentData$ = -20					; size = 4
_fragmentCount$ = -16					; size = 4
_unitsPerFragment$ = -12				; size = 4
_workItem$ = -8						; size = 4
_remainder$ = -4					; size = 4
_type$ = 8						; size = 4
_data$ = 12						; size = 4
_startUnitNo$ = 16					; size = 4
_unitCount$ = 20					; size = 4
_cryptoInfo$ = 24					; size = 4
_EncryptionThreadPoolDoWork@20 PROC			; COMDAT

; 461  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 462  : 	uint32 fragmentCount;
; 463  : 	uint32 unitsPerFragment;
; 464  : 	uint32 remainder;
; 465  : 
; 466  : 	byte *fragmentData;
; 467  : 	uint64 fragmentStartUnitNo;
; 468  : 
; 469  : 	EncryptionThreadPoolWorkItem *workItem;
; 470  : 	EncryptionThreadPoolWorkItem *firstFragmentWorkItem;
; 471  : 	
; 472  : 	if (unitCount == 0)

  00008	83 7d 14 00	 cmp	 DWORD PTR _unitCount$[ebp], 0
  0000c	75 05		 jne	 SHORT $LN19@Encryption@5

; 473  : 		return;

  0000e	e9 5e 02 00 00	 jmp	 $LN21@Encryption@5
$LN19@Encryption@5:

; 474  : 	
; 475  : 	if (!ThreadPoolRunning || unitCount == 1)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  0001a	74 06		 je	 SHORT $LN17@Encryption@5
  0001c	83 7d 14 01	 cmp	 DWORD PTR _unitCount$[ebp], 1
  00020	75 63		 jne	 SHORT $LN18@Encryption@5
$LN17@Encryption@5:

; 476  : 	{
; 477  : 		switch (type)

  00022	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00025	89 45 d8	 mov	 DWORD PTR tv68[ebp], eax
  00028	83 7d d8 00	 cmp	 DWORD PTR tv68[ebp], 0
  0002c	74 22		 je	 SHORT $LN13@Encryption@5
  0002e	83 7d d8 01	 cmp	 DWORD PTR tv68[ebp], 1
  00032	74 02		 je	 SHORT $LN14@Encryption@5
  00034	eb 34		 jmp	 SHORT $LN12@Encryption@5
$LN14@Encryption@5:

; 478  : 		{
; 479  : 		case DecryptDataUnitsWork:
; 480  : 			DecryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00036	8b 4d 18	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 14	 mov	 edx, DWORD PTR _unitCount$[ebp]
  0003d	33 c0		 xor	 eax, eax
  0003f	50		 push	 eax
  00040	52		 push	 edx
  00041	8b 4d 10	 mov	 ecx, DWORD PTR _startUnitNo$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 _DecryptDataUnitsCurrentThread@20

; 481  : 			break;

  0004e	eb 30		 jmp	 SHORT $LN15@Encryption@5
$LN13@Encryption@5:

; 482  : 
; 483  : 		case EncryptDataUnitsWork:
; 484  : 			EncryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00050	8b 45 18	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 14	 mov	 ecx, DWORD PTR _unitCount$[ebp]
  00057	33 d2		 xor	 edx, edx
  00059	52		 push	 edx
  0005a	51		 push	 ecx
  0005b	8b 45 10	 mov	 eax, DWORD PTR _startUnitNo$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread@20

; 485  : 			break;

  00068	eb 16		 jmp	 SHORT $LN15@Encryption@5
$LN12@Encryption@5:

; 486  : 
; 487  : 		default:
; 488  : 			GST_THROW_FATAL_EXCEPTION;

  0006a	68 54 53 47 00	 push	 4674388			; 00475354H
  0006f	6a 00		 push	 0
  00071	6a 00		 push	 0
  00073	68 e8 01 00 00	 push	 488			; 000001e8H
  00078	6a 29		 push	 41			; 00000029H
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN15@Encryption@5:

; 489  : 		}
; 490  : 
; 491  : 		return;

  00080	e9 ec 01 00 00	 jmp	 $LN21@Encryption@5
$LN18@Encryption@5:

; 492  : 	}
; 493  : 
; 494  : 	if (unitCount <= ThreadCount)

  00085	8b 55 14	 mov	 edx, DWORD PTR _unitCount$[ebp]
  00088	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _ThreadCount
  0008e	77 16		 ja	 SHORT $LN11@Encryption@5

; 495  : 	{
; 496  : 		fragmentCount = unitCount;

  00090	8b 45 14	 mov	 eax, DWORD PTR _unitCount$[ebp]
  00093	89 45 f0	 mov	 DWORD PTR _fragmentCount$[ebp], eax

; 497  : 		unitsPerFragment = 1;

  00096	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _unitsPerFragment$[ebp], 1

; 498  : 		remainder = 0;

  0009d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _remainder$[ebp], 0

; 499  : 	}
; 500  : 	else

  000a4	eb 34		 jmp	 SHORT $LN10@Encryption@5
$LN11@Encryption@5:

; 501  : 	{
; 502  : 		/* Note that it is not efficient to divide the data into fragments smaller than a few hundred bytes.
; 503  : 		The reason is that the overhead associated with thread handling would in most cases make a multi-threaded 
; 504  : 		process actually slower than a single-threaded process. */
; 505  : 
; 506  : 		fragmentCount = ThreadCount;

  000a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ThreadCount
  000ac	89 4d f0	 mov	 DWORD PTR _fragmentCount$[ebp], ecx

; 507  : 		unitsPerFragment = unitCount / ThreadCount;

  000af	8b 45 14	 mov	 eax, DWORD PTR _unitCount$[ebp]
  000b2	33 d2		 xor	 edx, edx
  000b4	f7 35 00 00 00
	00		 div	 DWORD PTR _ThreadCount
  000ba	89 45 f4	 mov	 DWORD PTR _unitsPerFragment$[ebp], eax

; 508  : 		remainder = unitCount % ThreadCount;

  000bd	8b 45 14	 mov	 eax, DWORD PTR _unitCount$[ebp]
  000c0	33 d2		 xor	 edx, edx
  000c2	f7 35 00 00 00
	00		 div	 DWORD PTR _ThreadCount
  000c8	89 55 fc	 mov	 DWORD PTR _remainder$[ebp], edx

; 509  : 
; 510  : 		if (remainder > 0)

  000cb	83 7d fc 00	 cmp	 DWORD PTR _remainder$[ebp], 0
  000cf	76 09		 jbe	 SHORT $LN10@Encryption@5

; 511  : 			++unitsPerFragment;

  000d1	8b 55 f4	 mov	 edx, DWORD PTR _unitsPerFragment$[ebp]
  000d4	83 c2 01	 add	 edx, 1
  000d7	89 55 f4	 mov	 DWORD PTR _unitsPerFragment$[ebp], edx
$LN10@Encryption@5:

; 512  : 	}
; 513  : 	
; 514  : 	fragmentData = data;

  000da	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000dd	89 45 ec	 mov	 DWORD PTR _fragmentData$[ebp], eax

; 515  : 	fragmentStartUnitNo = startUnitNo->Value;

  000e0	8b 4d 10	 mov	 ecx, DWORD PTR _startUnitNo$[ebp]
  000e3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e5	89 55 e0	 mov	 DWORD PTR _fragmentStartUnitNo$[ebp], edx
  000e8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000eb	89 45 e4	 mov	 DWORD PTR _fragmentStartUnitNo$[ebp+4], eax

; 516  : 
; 517  : 	GST_ACQUIRE_MUTEX (&EnqueueMutex);

  000ee	b9 00 00 00 00	 mov	 ecx, OFFSET _EnqueueMutex
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutex@4

; 518  : 	firstFragmentWorkItem = &WorkItemQueue[EnqueuePosition];

  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueuePosition
  000ff	6b c9 48	 imul	 ecx, 72			; 00000048H
  00102	81 c1 00 00 00
	00		 add	 ecx, OFFSET _WorkItemQueue
  00108	89 4d dc	 mov	 DWORD PTR _firstFragmentWorkItem$[ebp], ecx
$LN8@Encryption@5:

; 519  : 
; 520  : 	while (GetWorkItemState (firstFragmentWorkItem) != WorkItemFree)

  0010b	8b 55 dc	 mov	 edx, DWORD PTR _firstFragmentWorkItem$[ebp]
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 _GetWorkItemState@4
  00114	85 c0		 test	 eax, eax
  00116	74 15		 je	 SHORT $LN7@Encryption@5

; 521  : 	{
; 522  : 		GST_WAIT_EVENT (WorkItemCompletedEvent);

  00118	6a 00		 push	 0
  0011a	6a 00		 push	 0
  0011c	6a 00		 push	 0
  0011e	6a 00		 push	 0
  00120	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 523  : 	}

  0012b	eb de		 jmp	 SHORT $LN8@Encryption@5
$LN7@Encryption@5:

; 524  : 
; 525  : 	firstFragmentWorkItem->OutstandingFragmentCount = fragmentCount;

  0012d	8b 45 dc	 mov	 eax, DWORD PTR _firstFragmentWorkItem$[ebp]
  00130	8b 4d f0	 mov	 ecx, DWORD PTR _fragmentCount$[ebp]
  00133	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$LN6@Encryption@5:

; 526  : 
; 527  : 	while (fragmentCount-- > 0)

  00136	8b 55 f0	 mov	 edx, DWORD PTR _fragmentCount$[ebp]
  00139	8b 45 f0	 mov	 eax, DWORD PTR _fragmentCount$[ebp]
  0013c	83 e8 01	 sub	 eax, 1
  0013f	89 45 f0	 mov	 DWORD PTR _fragmentCount$[ebp], eax
  00142	85 d2		 test	 edx, edx
  00144	0f 86 ed 00 00
	00		 jbe	 $LN5@Encryption@5

; 528  : 	{
; 529  : 		workItem = &WorkItemQueue[EnqueuePosition++];

  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueuePosition
  00150	6b c9 48	 imul	 ecx, 72			; 00000048H
  00153	81 c1 00 00 00
	00		 add	 ecx, OFFSET _WorkItemQueue
  00159	89 4d f8	 mov	 DWORD PTR _workItem$[ebp], ecx
  0015c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _EnqueuePosition
  00162	83 c2 01	 add	 edx, 1
  00165	89 15 00 00 00
	00		 mov	 DWORD PTR _EnqueuePosition, edx

; 530  : 		if (EnqueuePosition >= GST_ENC_THREAD_POOL_QUEUE_SIZE)

  0016b	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR _EnqueuePosition, 128 ; 00000080H
  00175	7c 0a		 jl	 SHORT $LN3@Encryption@5

; 531  : 			EnqueuePosition = 0;

  00177	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0
$LN3@Encryption@5:

; 532  : 
; 533  : 		while (GetWorkItemState (workItem) != WorkItemFree)

  00181	8b 45 f8	 mov	 eax, DWORD PTR _workItem$[ebp]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _GetWorkItemState@4
  0018a	85 c0		 test	 eax, eax
  0018c	74 15		 je	 SHORT $LN2@Encryption@5

; 534  : 		{
; 535  : 			GST_WAIT_EVENT (WorkItemCompletedEvent);

  0018e	6a 00		 push	 0
  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	6a 00		 push	 0
  00196	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 536  : 		}

  001a1	eb de		 jmp	 SHORT $LN3@Encryption@5
$LN2@Encryption@5:

; 537  : 
; 538  : 		workItem->Type = type;

  001a3	8b 4d f8	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001a6	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  001a9	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 539  : 		workItem->FirstFragment = firstFragmentWorkItem;

  001ac	8b 45 f8	 mov	 eax, DWORD PTR _workItem$[ebp]
  001af	8b 4d dc	 mov	 ecx, DWORD PTR _firstFragmentWorkItem$[ebp]
  001b2	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 540  : 
; 541  : 		workItem->Encryption.CryptoInfo = cryptoInfo;

  001b5	8b 55 f8	 mov	 edx, DWORD PTR _workItem$[ebp]
  001b8	8b 45 18	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  001bb	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 542  : 		workItem->Encryption.Data = fragmentData;

  001be	8b 4d f8	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001c1	8b 55 ec	 mov	 edx, DWORD PTR _fragmentData$[ebp]
  001c4	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 543  : 		workItem->Encryption.UnitCount = unitsPerFragment;

  001c7	8b 45 f8	 mov	 eax, DWORD PTR _workItem$[ebp]
  001ca	8b 4d f4	 mov	 ecx, DWORD PTR _unitsPerFragment$[ebp]
  001cd	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 544  : 		workItem->Encryption.StartUnitNo.Value = fragmentStartUnitNo;

  001d0	8b 55 f8	 mov	 edx, DWORD PTR _workItem$[ebp]
  001d3	8b 45 e0	 mov	 eax, DWORD PTR _fragmentStartUnitNo$[ebp]
  001d6	89 42 28	 mov	 DWORD PTR [edx+40], eax
  001d9	8b 4d e4	 mov	 ecx, DWORD PTR _fragmentStartUnitNo$[ebp+4]
  001dc	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 545  : 
; 546  :  		fragmentData += unitsPerFragment * ENCRYPTION_DATA_UNIT_SIZE;

  001df	8b 55 f4	 mov	 edx, DWORD PTR _unitsPerFragment$[ebp]
  001e2	c1 e2 09	 shl	 edx, 9
  001e5	03 55 ec	 add	 edx, DWORD PTR _fragmentData$[ebp]
  001e8	89 55 ec	 mov	 DWORD PTR _fragmentData$[ebp], edx

; 547  : 		fragmentStartUnitNo += unitsPerFragment;

  001eb	8b 45 f4	 mov	 eax, DWORD PTR _unitsPerFragment$[ebp]
  001ee	33 c9		 xor	 ecx, ecx
  001f0	03 45 e0	 add	 eax, DWORD PTR _fragmentStartUnitNo$[ebp]
  001f3	8b 55 e4	 mov	 edx, DWORD PTR _fragmentStartUnitNo$[ebp+4]
  001f6	13 d1		 adc	 edx, ecx
  001f8	89 45 e0	 mov	 DWORD PTR _fragmentStartUnitNo$[ebp], eax
  001fb	89 55 e4	 mov	 DWORD PTR _fragmentStartUnitNo$[ebp+4], edx

; 548  : 
; 549  : 		if (remainder > 0 && --remainder == 0)

  001fe	83 7d fc 00	 cmp	 DWORD PTR _remainder$[ebp], 0
  00202	76 14		 jbe	 SHORT $LN1@Encryption@5
  00204	8b 45 fc	 mov	 eax, DWORD PTR _remainder$[ebp]
  00207	83 e8 01	 sub	 eax, 1
  0020a	89 45 fc	 mov	 DWORD PTR _remainder$[ebp], eax
  0020d	75 09		 jne	 SHORT $LN1@Encryption@5

; 550  : 			--unitsPerFragment;

  0020f	8b 4d f4	 mov	 ecx, DWORD PTR _unitsPerFragment$[ebp]
  00212	83 e9 01	 sub	 ecx, 1
  00215	89 4d f4	 mov	 DWORD PTR _unitsPerFragment$[ebp], ecx
$LN1@Encryption@5:

; 551  : 
; 552  : 		SetWorkItemState (workItem, WorkItemReady);

  00218	6a 01		 push	 1
  0021a	8b 55 f8	 mov	 edx, DWORD PTR _workItem$[ebp]
  0021d	52		 push	 edx
  0021e	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 553  : 		GST_SET_EVENT (WorkItemReadyEvent);

  00223	6a 00		 push	 0
  00225	6a 01		 push	 1
  00227	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 554  : 	}

  00232	e9 ff fe ff ff	 jmp	 $LN6@Encryption@5
$LN5@Encryption@5:

; 555  : 
; 556  : 	GST_RELEASE_MUTEX (&EnqueueMutex);

  00237	b9 00 00 00 00	 mov	 ecx, OFFSET _EnqueueMutex
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutex@4

; 557  : 
; 558  : 	GST_WAIT_EVENT (firstFragmentWorkItem->ItemCompletedEvent);

  00242	6a 00		 push	 0
  00244	6a 00		 push	 0
  00246	6a 00		 push	 0
  00248	6a 00		 push	 0
  0024a	8b 45 dc	 mov	 eax, DWORD PTR _firstFragmentWorkItem$[ebp]
  0024d	83 c0 08	 add	 eax, 8
  00250	50		 push	 eax
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 559  : 	SetWorkItemState (firstFragmentWorkItem, WorkItemFree);

  00257	6a 00		 push	 0
  00259	8b 4d dc	 mov	 ecx, DWORD PTR _firstFragmentWorkItem$[ebp]
  0025c	51		 push	 ecx
  0025d	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 560  : 	GST_SET_EVENT (WorkItemCompletedEvent);

  00262	6a 00		 push	 0
  00264	6a 01		 push	 1
  00266	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN21@Encryption@5:

; 561  : }

  00271	8b e5		 mov	 esp, ebp
  00273	5d		 pop	 ebp
  00274	c2 14 00	 ret	 20			; 00000014H
_EncryptionThreadPoolDoWork@20 ENDP
_TEXT	ENDS
PUBLIC	_GetEncryptionThreadCount@0
; Function compile flags: /Odtp
;	COMDAT _GetEncryptionThreadCount@0
_TEXT	SEGMENT
_GetEncryptionThreadCount@0 PROC			; COMDAT

; 572  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 573  : 	return ThreadPoolRunning ? ThreadCount : 0;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	23 05 00 00 00
	00		 and	 eax, DWORD PTR _ThreadCount

; 574  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_GetEncryptionThreadCount@0 ENDP
_TEXT	ENDS
PUBLIC	_GetMaxEncryptionThreadCount@0
; Function compile flags: /Odtp
;	COMDAT _GetMaxEncryptionThreadCount@0
_TEXT	SEGMENT
_GetMaxEncryptionThreadCount@0 PROC			; COMDAT

; 585  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 586  : 	return GST_ENC_THREAD_POOL_MAX_THREAD_COUNT;

  00005	b8 40 00 00 00	 mov	 eax, 64			; 00000040H

; 587  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_GetMaxEncryptionThreadCount@0 ENDP
_TEXT	ENDS
PUBLIC	_IsEncryptionThreadPoolRunning@0
; Function compile flags: /Odtp
;	COMDAT _IsEncryptionThreadPoolRunning@0
_TEXT	SEGMENT
_IsEncryptionThreadPoolRunning@0 PROC			; COMDAT

; 598  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 599  : 	return ThreadPoolRunning;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning

; 600  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_IsEncryptionThreadPoolRunning@0 ENDP
_TEXT	ENDS
END
