; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xts.c
pdata	SEGMENT
$pdata$DecryptBufferXTSNonParallel DD imagerel DecryptBufferXTSNonParallel
	DD	imagerel DecryptBufferXTSNonParallel+378
	DD	imagerel $unwind$DecryptBufferXTSNonParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTSNonParallel DD 0c2b19H
	DD	013641cH
	DD	012541cH
	DD	011341cH
	DD	0f018921cH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __GSHandlerCheck
	DD	048H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptBufferXTSNonParallel
_TEXT	SEGMENT
ks2$GSCopy$1$ = 48
whiteningValue$ = 56
__$ArrayPad$ = 72
buffer$ = 128
length$ = 136
startDataUnitNo$ = 144
startCipherBlockNo$ = 152
ks$ = 160
ks2$ = 168
cipher$ = 176
DecryptBufferXTSNonParallel PROC			; COMDAT

; 677  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0002b	4c 8b b4 24 a8
	00 00 00	 mov	 r14, QWORD PTR ks2$[rsp]
  00033	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR ks$[rsp]

; 678  : 	unsigned __int8 finalCarry;
; 679  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 680  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 681  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 682  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 683  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 684  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 685  : 
; 686  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 687  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 688  : 	dataUnitNo = startDataUnitNo->Value;

  0003b	49 8b 28	 mov	 rbp, QWORD PTR [r8]
  0003e	4c 89 74 24 30	 mov	 QWORD PTR ks2$GSCopy$1$[rsp], r14
  00043	48 8b da	 mov	 rbx, rdx
  00046	4c 8b e9	 mov	 r13, rcx

; 689  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 690  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 691  : 
; 692  : 	if (length % BYTES_PER_XTS_BLOCK)

  00049	f6 c2 0f	 test	 dl, 15
  0004c	74 1e		 je	 SHORT $LN16@DecryptBuf

; 693  : 		GST_THROW_FATAL_EXCEPTION;

  0004e	45 33 c9	 xor	 r9d, r9d
  00051	45 33 c0	 xor	 r8d, r8d
  00054	ba b5 02 00 00	 mov	 edx, 693		; 000002b5H
  00059	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0005d	49 c7 43 a8 54
	53 47 00	 mov	 QWORD PTR [r11-88], 4674388 ; 00475354H
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0006b	cc		 int	 3
$LN16@DecryptBuf:

; 694  : 
; 695  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  0006c	48 c1 eb 04	 shr	 rbx, 4

; 696  : 
; 697  : 	// Process all blocks in the buffer
; 698  : 	while (blockCount > 0)

  00070	48 85 db	 test	 rbx, rbx
  00073	0f 84 bc 00 00
	00		 je	 $LN5@DecryptBuf
$LL15@DecryptBuf:

; 699  : 	{
; 700  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
; 701  : 			endBlock = startBlock + (unsigned int) blockCount;
; 702  : 		else
; 703  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
; 704  : 
; 705  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 706  : 
; 707  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 708  : 		// whitening value for this data unit)
; 709  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
; 710  : 		*(whiteningValuePtr64 + 1) = 0;
; 711  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00079	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00080	bf 20 00 00 00	 mov	 edi, 32			; 00000020H
  00085	48 8d 54 24 38	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  0008a	48 3b df	 cmp	 rbx, rdi
  0008d	4d 8b c6	 mov	 r8, r14
  00090	48 8d 74 24 38	 lea	 rsi, QWORD PTR whiteningValue$[rsp]
  00095	0f 42 fb	 cmovb	 edi, ebx
  00098	48 83 64 24 40
	00		 and	 QWORD PTR whiteningValue$[rsp+8], 0
  0009e	48 89 6c 24 38	 mov	 QWORD PTR whiteningValue$[rsp], rbp
  000a3	e8 00 00 00 00	 call	 EncipherBlock

; 712  : 
; 713  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 714  : 		// decrypt all relevant blocks in this data unit
; 715  : 		for (block = 0; block < endBlock; block++)

  000a8	45 33 e4	 xor	 r12d, r12d
  000ab	85 ff		 test	 edi, edi
  000ad	74 78		 je	 SHORT $LN9@DecryptBuf
  000af	49 be 00 00 00
	00 00 00 00 80	 mov	 r14, -9223372036854775808 ; 8000000000000000H
$LL11@DecryptBuf:

; 716  : 		{
; 717  : 			if (block >= startBlock)
; 718  : 			{
; 719  : 				// Post-whitening
; 720  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000b9	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 721  : 				*bufPtr-- ^= *whiteningValuePtr64--;
; 722  : 
; 723  : 				// Actual decryption
; 724  : 				DecipherBlock (cipher, bufPtr, ks);

  000bc	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000c3	4d 8b c7	 mov	 r8, r15
  000c6	49 31 45 00	 xor	 QWORD PTR [r13], rax
  000ca	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000ce	49 8b d5	 mov	 rdx, r13
  000d1	49 31 45 08	 xor	 QWORD PTR [r13+8], rax
  000d5	e8 00 00 00 00	 call	 DecipherBlock

; 725  : 
; 726  : 				// Pre-whitening
; 727  : 				*bufPtr++ ^= *whiteningValuePtr64++;
; 728  : 				*bufPtr++ ^= *whiteningValuePtr64;

  000da	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000de	4c 8b 1e	 mov	 r11, QWORD PTR [rsi]

; 729  : 			}
; 730  : 			else
; 731  : 				whiteningValuePtr64++;
; 732  : 
; 733  : 			// Derive the next whitening value
; 734  : 
; 735  : #if BYTE_ORDER == LITTLE_ENDIAN
; 736  : 
; 737  : 			// Little-endian platforms
; 738  : 
; 739  : 			finalCarry = 
; 740  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 741  : 				135 : 0;

  000e1	48 8b c8	 mov	 rcx, rax
  000e4	4d 31 5d 00	 xor	 QWORD PTR [r13], r11
  000e8	49 31 45 08	 xor	 QWORD PTR [r13+8], rax
  000ec	49 23 c6	 and	 rax, r14
  000ef	49 83 c5 10	 add	 r13, 16
  000f3	48 f7 d8	 neg	 rax

; 742  : 
; 743  : 			*whiteningValuePtr64-- <<= 1;

  000f6	48 8d 04 09	 lea	 rax, QWORD PTR [rcx+rcx]
  000fa	1a d2		 sbb	 dl, dl
  000fc	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 744  : 
; 745  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00100	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00103	80 e2 87	 and	 dl, 135			; 00000087H
  00106	49 85 c6	 test	 rax, r14
  00109	74 05		 je	 SHORT $LN6@DecryptBuf

; 746  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0010b	48 83 4e 08 01	 or	 QWORD PTR [rsi+8], 1
$LN6@DecryptBuf:

; 747  : 
; 748  : 			*whiteningValuePtr64 <<= 1;

  00110	48 03 c0	 add	 rax, rax
  00113	41 ff c4	 inc	 r12d
  00116	48 89 06	 mov	 QWORD PTR [rsi], rax

; 749  : 
; 750  : #else
; 751  : 			// Big-endian platforms
; 752  : 
; 753  : 			finalCarry = 
; 754  : 				(*whiteningValuePtr64 & 0x80) ?
; 755  : 				135 : 0;
; 756  : 
; 757  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 758  : 
; 759  : 			whiteningValuePtr64--;
; 760  : 
; 761  : 			if (*whiteningValuePtr64 & 0x80)
; 762  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 763  : 
; 764  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 765  : #endif
; 766  : 
; 767  : 			whiteningValue[0] ^= finalCarry;

  00119	30 54 24 38	 xor	 BYTE PTR whiteningValue$[rsp], dl
  0011d	44 3b e7	 cmp	 r12d, edi
  00120	72 97		 jb	 SHORT $LL11@DecryptBuf
  00122	4c 8b 74 24 30	 mov	 r14, QWORD PTR ks2$GSCopy$1$[rsp]
$LN9@DecryptBuf:

; 768  : 		}
; 769  : 
; 770  : 		blockCount -= endBlock - startBlock;

  00127	8b c7		 mov	 eax, edi

; 771  : 		startBlock = 0;
; 772  : 		dataUnitNo++;

  00129	48 ff c5	 inc	 rbp
  0012c	48 2b d8	 sub	 rbx, rax
  0012f	0f 85 44 ff ff
	ff		 jne	 $LL15@DecryptBuf
$LN5@DecryptBuf:

; 773  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 774  : 	}
; 775  : 
; 776  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00135	48 8d 44 24 38	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  0013a	b9 02 00 00 00	 mov	 ecx, 2
$LL2@DecryptBuf:
  0013f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00146	48 83 c0 08	 add	 rax, 8
  0014a	83 e9 01	 sub	 ecx, 1
  0014d	75 f0		 jne	 SHORT $LL2@DecryptBuf

; 777  : }

  0014f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00154	48 33 cc	 xor	 rcx, rsp
  00157	e8 00 00 00 00	 call	 __security_check_cookie
  0015c	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00161	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00165	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  00169	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0016d	49 8b e3	 mov	 rsp, r11
  00170	41 5f		 pop	 r15
  00172	41 5e		 pop	 r14
  00174	41 5d		 pop	 r13
  00176	41 5c		 pop	 r12
  00178	5f		 pop	 rdi
  00179	c3		 ret	 0
$LN26@DecryptBuf:
DecryptBufferXTSNonParallel ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	DecryptBufferXTS8Byte
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
pdata	SEGMENT
$pdata$DecryptBufferXTS8Byte DD imagerel $LN29
	DD	imagerel $LN29+420
	DD	imagerel $unwind$DecryptBufferXTS8Byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTS8Byte DD 0b2b19H
	DD	0585419H
	DD	0573419H
	DD	0500119H
	DD	0e010f012H
	DD	0700cc00eH
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	0270H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xts.c
xdata	ENDS
;	COMDAT DecryptBufferXTS8Byte
_TEXT	SEGMENT
ks2$GSCopy$1$ = 48
whiteningValue$ = 56
byteBufUnitNo$ = 64
xor_ks$ = 80
__$ArrayPad$ = 624
buffer$ = 688
length$ = 696
startDataUnitNo$ = 704
startCipherBlockNo$ = 712
ks$ = 720
ks2$ = 728
cipher$ = 736
DecryptBufferXTS8Byte PROC				; COMDAT

; 442  : {

$LN29:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 81 ec 80 02
	00 00		 sub	 rsp, 640		; 00000280H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0002b	4c 8b a4 24 d8
	02 00 00	 mov	 r12, QWORD PTR ks2$[rsp]

; 443  : 	unsigned __int8 finalCarry;
; 444  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
; 445  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
; 446  : 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
; 447  : 	unsigned __int32 *bufPtr = (unsigned __int32 *) buffer;
; 448  : 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;
; 449  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 450  : 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
; 451  : 
; 452  : 	dataUnitNo = startDataUnitNo->Value;

  00033	49 8b 38	 mov	 rdi, QWORD PTR [r8]
  00036	4c 8b b4 24 d0
	02 00 00	 mov	 r14, QWORD PTR ks$[rsp]
  0003e	4c 89 64 24 30	 mov	 QWORD PTR ks2$GSCopy$1$[rsp], r12

; 453  : 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  00043	48 89 7c 24 40	 mov	 QWORD PTR byteBufUnitNo$[rsp], rdi
  00048	48 8b da	 mov	 rbx, rdx
  0004b	4c 8b f9	 mov	 r15, rcx

; 454  : 
; 455  : 	if (length % BYTES_PER_XTS_BLOCK_SMALL)

  0004e	f6 c2 07	 test	 dl, 7
  00051	74 1f		 je	 SHORT $LN16@DecryptBuf@2

; 456  : 		GST_THROW_FATAL_EXCEPTION;

  00053	45 33 c9	 xor	 r9d, r9d
  00056	45 33 c0	 xor	 r8d, r8d
  00059	ba c8 01 00 00	 mov	 edx, 456		; 000001c8H
  0005e	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00062	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00071	cc		 int	 3
$LN16@DecryptBuf@2:

; 457  : 
; 458  : 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;
; 459  : 
; 460  : 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));

  00072	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00079	48 c1 eb 03	 shr	 rbx, 3
  0007d	e8 00 00 00 00	 call	 CipherGet
  00082	48 8d 4c 24 50	 lea	 rcx, QWORD PTR xor_ks$[rsp]
  00087	49 8b d6	 mov	 rdx, r14
  0008a	4c 63 40 18	 movsxd	 r8, DWORD PTR [rax+24]
  0008e	e8 00 00 00 00	 call	 memcpy

; 461  : 
; 462  : 	while (blockCount > 0)

  00093	48 85 db	 test	 rbx, rbx
  00096	0f 84 d4 00 00
	00		 je	 $LN5@DecryptBuf@2
$LL15@DecryptBuf@2:

; 463  : 	{
; 464  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)
; 465  : 			endBlock = startBlock + (unsigned __int32) blockCount;
; 466  : 		else
; 467  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;
; 468  : 
; 469  : 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
; 470  : 
; 471  : 		//Encrypt data unit using the second key to generate the first whitening value
; 472  : 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);
; 473  : 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);
; 474  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0009c	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000a3	bd 40 00 00 00	 mov	 ebp, 64			; 00000040H
  000a8	48 8b c7	 mov	 rax, rdi
  000ab	48 3b dd	 cmp	 rbx, rbp
  000ae	48 8d 54 24 38	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  000b3	4d 8b c4	 mov	 r8, r12
  000b6	0f 42 eb	 cmovb	 ebp, ebx
  000b9	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  000bd	48 8d 74 24 38	 lea	 rsi, QWORD PTR whiteningValue$[rsp]
  000c2	89 44 24 3c	 mov	 DWORD PTR whiteningValue$[rsp+4], eax
  000c6	89 7c 24 38	 mov	 DWORD PTR whiteningValue$[rsp], edi
  000ca	e8 00 00 00 00	 call	 EncipherBlock

; 475  : 
; 476  : 		//XOR ks with the current DataUnitNo
; 477  : 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);

  000cf	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000d6	4c 8d 4c 24 40	 lea	 r9, QWORD PTR byteBufUnitNo$[rsp]
  000db	4c 8d 44 24 50	 lea	 r8, QWORD PTR xor_ks$[rsp]
  000e0	49 8b d6	 mov	 rdx, r14
  000e3	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  000eb	e8 00 00 00 00	 call	 XorKeySchedule

; 478  : 
; 479  : 		for (block = 0; block < endBlock; block++)

  000f0	45 33 e4	 xor	 r12d, r12d
  000f3	85 ed		 test	 ebp, ebp
  000f5	74 61		 je	 SHORT $LN9@DecryptBuf@2
$LL11@DecryptBuf@2:

; 480  : 		{
; 481  : 			if (block >= startBlock)
; 482  : 			{
; 483  : 				//Post-whitening
; 484  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  000f7	8b 06		 mov	 eax, DWORD PTR [rsi]

; 485  : 				*bufPtr-- ^= *whiteningValuePtr32--;
; 486  : 
; 487  : 				//Actual decryption
; 488  : 				DecipherBlock (cipher, bufPtr, xor_ks);

  000f9	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00100	4c 8d 44 24 50	 lea	 r8, QWORD PTR xor_ks$[rsp]
  00105	41 31 07	 xor	 DWORD PTR [r15], eax
  00108	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  0010b	49 8b d7	 mov	 rdx, r15
  0010e	41 31 47 04	 xor	 DWORD PTR [r15+4], eax
  00112	e8 00 00 00 00	 call	 DecipherBlock

; 489  : 
; 490  : 				//Pre-whitening
; 491  : 				*bufPtr++ ^= *whiteningValuePtr32++;
; 492  : 				*bufPtr++ ^= *whiteningValuePtr32;

  00117	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  0011a	44 8b 1e	 mov	 r11d, DWORD PTR [rsi]

; 493  : 			}
; 494  : 			else
; 495  : 				whiteningValuePtr32++;
; 496  : 
; 497  : 			//Derive the next whitening value
; 498  : 
; 499  : #if BYTE_ORDER == LITTLE_ENDIAN
; 500  : 
; 501  : 			//Little-endian platforms
; 502  : 
; 503  : 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;

  0011d	8b c8		 mov	 ecx, eax
  0011f	45 31 1f	 xor	 DWORD PTR [r15], r11d
  00122	41 31 47 04	 xor	 DWORD PTR [r15+4], eax
  00126	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0012b	49 83 c7 08	 add	 r15, 8
  0012f	f7 d8		 neg	 eax

; 504  : 
; 505  : 			*whiteningValuePtr32-- <<= 1;

  00131	8d 04 09	 lea	 eax, DWORD PTR [rcx+rcx]
  00134	1a d2		 sbb	 dl, dl
  00136	89 46 04	 mov	 DWORD PTR [rsi+4], eax

; 506  : 
; 507  : 			if (*whiteningValuePtr32 & 0x80000000)

  00139	8b 06		 mov	 eax, DWORD PTR [rsi]
  0013b	80 e2 1b	 and	 dl, 27
  0013e	0f ba e0 1f	 bt	 eax, 31
  00142	73 04		 jae	 SHORT $LN6@DecryptBuf@2

; 508  : 				*(whiteningValuePtr32 + 1) |= 1;

  00144	83 4e 04 01	 or	 DWORD PTR [rsi+4], 1
$LN6@DecryptBuf@2:

; 509  : 
; 510  : 			*whiteningValuePtr32 <<= 1;

  00148	03 c0		 add	 eax, eax
  0014a	41 ff c4	 inc	 r12d
  0014d	89 06		 mov	 DWORD PTR [rsi], eax

; 511  : #else
; 512  : 			//Big-endian platforms
; 513  : 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
; 514  : 
; 515  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 516  : 
; 517  : 			whiteningValuePtr32--;
; 518  : 
; 519  : 			if (*whiteningValuePtr32 & 0x80)
; 520  : 				*(whiteningValuePtr32 + 1) |= 0x1000000;
; 521  : 
; 522  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 523  : #endif
; 524  : 
; 525  : 			whiteningValue[0] ^= finalCarry;

  0014f	30 54 24 38	 xor	 BYTE PTR whiteningValue$[rsp], dl
  00153	44 3b e5	 cmp	 r12d, ebp
  00156	72 9f		 jb	 SHORT $LL11@DecryptBuf@2
$LN9@DecryptBuf@2:

; 461  : 
; 462  : 	while (blockCount > 0)

  00158	4c 8b 64 24 30	 mov	 r12, QWORD PTR ks2$GSCopy$1$[rsp]

; 526  : 		}
; 527  : 
; 528  : 		blockCount -= endBlock - startBlock;
; 529  : 		startBlock = 0;
; 530  : 		dataUnitNo++;

  0015d	48 ff c7	 inc	 rdi
  00160	8b c5		 mov	 eax, ebp
  00162	48 2b d8	 sub	 rbx, rax

; 531  : 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  00165	48 89 7c 24 40	 mov	 QWORD PTR byteBufUnitNo$[rsp], rdi
  0016a	0f 85 2c ff ff
	ff		 jne	 $LL15@DecryptBuf@2
$LN5@DecryptBuf@2:

; 532  : 	}
; 533  : 
; 534  : 	FAST_ERASE32 (whiteningValue, sizeof (whiteningValue));

  00170	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR whiteningValue$[rsp], 0

; 535  : }

  00178	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00180	48 33 cc	 xor	 rcx, rsp
  00183	e8 00 00 00 00	 call	 __security_check_cookie
  00188	4c 8d 9c 24 80
	02 00 00	 lea	 r11, QWORD PTR [rsp+640]
  00190	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00194	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  00198	49 8b e3	 mov	 rsp, r11
  0019b	41 5f		 pop	 r15
  0019d	41 5e		 pop	 r14
  0019f	41 5c		 pop	 r12
  001a1	5f		 pop	 rdi
  001a2	5e		 pop	 rsi
  001a3	c3		 ret	 0
$LN28@DecryptBuf@2:
DecryptBufferXTS8Byte ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferXTSNonParallel DD imagerel EncryptBufferXTSNonParallel
	DD	imagerel EncryptBufferXTSNonParallel+378
	DD	imagerel $unwind$EncryptBufferXTSNonParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTSNonParallel DD 0c2b19H
	DD	013641cH
	DD	012541cH
	DD	011341cH
	DD	0f018921cH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __GSHandlerCheck
	DD	048H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptBufferXTSNonParallel
_TEXT	SEGMENT
ks2$GSCopy$1$ = 48
whiteningValue$ = 56
__$ArrayPad$ = 72
buffer$ = 128
length$ = 136
startDataUnitNo$ = 144
startCipherBlockNo$ = 152
ks$ = 160
ks2$ = 168
cipher$ = 176
EncryptBufferXTSNonParallel PROC			; COMDAT

; 310  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0002b	4c 8b b4 24 a8
	00 00 00	 mov	 r14, QWORD PTR ks2$[rsp]
  00033	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR ks$[rsp]

; 311  : 	unsigned __int8 finalCarry;
; 312  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 313  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 314  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 315  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 316  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 317  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 318  : 
; 319  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 320  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 321  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 322  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 323  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 324  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 325  : 
; 326  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 327  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 328  : 	dataUnitNo = startDataUnitNo->Value;

  0003b	49 8b 28	 mov	 rbp, QWORD PTR [r8]
  0003e	4c 89 74 24 30	 mov	 QWORD PTR ks2$GSCopy$1$[rsp], r14
  00043	48 8b da	 mov	 rbx, rdx
  00046	4c 8b e9	 mov	 r13, rcx

; 329  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 330  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 331  : 
; 332  : 	if (length % BYTES_PER_XTS_BLOCK)

  00049	f6 c2 0f	 test	 dl, 15
  0004c	74 1e		 je	 SHORT $LN16@EncryptBuf

; 333  : 		GST_THROW_FATAL_EXCEPTION;

  0004e	45 33 c9	 xor	 r9d, r9d
  00051	45 33 c0	 xor	 r8d, r8d
  00054	ba 4d 01 00 00	 mov	 edx, 333		; 0000014dH
  00059	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0005d	49 c7 43 a8 54
	53 47 00	 mov	 QWORD PTR [r11-88], 4674388 ; 00475354H
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0006b	cc		 int	 3
$LN16@EncryptBuf:

; 334  : 
; 335  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  0006c	48 c1 eb 04	 shr	 rbx, 4

; 336  : 
; 337  : 	// Process all blocks in the buffer
; 338  : 	while (blockCount > 0)

  00070	48 85 db	 test	 rbx, rbx
  00073	0f 84 bc 00 00
	00		 je	 $LN5@EncryptBuf
$LL15@EncryptBuf:

; 339  : 	{
; 340  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
; 341  : 			endBlock = startBlock + (unsigned int) blockCount;
; 342  : 		else
; 343  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
; 344  : 
; 345  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 346  : 
; 347  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 348  : 		// whitening value for this data unit)
; 349  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
; 350  : 		*(whiteningValuePtr64 + 1) = 0;
; 351  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00079	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00080	bf 20 00 00 00	 mov	 edi, 32			; 00000020H
  00085	48 8d 54 24 38	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  0008a	48 3b df	 cmp	 rbx, rdi
  0008d	4d 8b c6	 mov	 r8, r14
  00090	48 8d 74 24 38	 lea	 rsi, QWORD PTR whiteningValue$[rsp]
  00095	0f 42 fb	 cmovb	 edi, ebx
  00098	48 83 64 24 40
	00		 and	 QWORD PTR whiteningValue$[rsp+8], 0
  0009e	48 89 6c 24 38	 mov	 QWORD PTR whiteningValue$[rsp], rbp
  000a3	e8 00 00 00 00	 call	 EncipherBlock

; 352  : 
; 353  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 354  : 		// encrypt all relevant blocks in this data unit
; 355  : 		for (block = 0; block < endBlock; block++)

  000a8	45 33 e4	 xor	 r12d, r12d
  000ab	85 ff		 test	 edi, edi
  000ad	74 78		 je	 SHORT $LN9@EncryptBuf
  000af	49 be 00 00 00
	00 00 00 00 80	 mov	 r14, -9223372036854775808 ; 8000000000000000H
$LL11@EncryptBuf:

; 356  : 		{
; 357  : 			if (block >= startBlock)
; 358  : 			{
; 359  : 				// Pre-whitening
; 360  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000b9	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 361  : 				*bufPtr-- ^= *whiteningValuePtr64--;
; 362  : 
; 363  : 				// Actual encryption
; 364  : 				EncipherBlock (cipher, bufPtr, ks);

  000bc	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000c3	4d 8b c7	 mov	 r8, r15
  000c6	49 31 45 00	 xor	 QWORD PTR [r13], rax
  000ca	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000ce	49 8b d5	 mov	 rdx, r13
  000d1	49 31 45 08	 xor	 QWORD PTR [r13+8], rax
  000d5	e8 00 00 00 00	 call	 EncipherBlock

; 365  : 
; 366  : 				// Post-whitening
; 367  : 				*bufPtr++ ^= *whiteningValuePtr64++;
; 368  : 				*bufPtr++ ^= *whiteningValuePtr64;

  000da	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000de	4c 8b 1e	 mov	 r11, QWORD PTR [rsi]

; 369  : 			}
; 370  : 			else
; 371  : 				whiteningValuePtr64++;
; 372  : 
; 373  : 			// Derive the next whitening value
; 374  : 
; 375  : #if BYTE_ORDER == LITTLE_ENDIAN
; 376  : 
; 377  : 			// Little-endian platforms
; 378  : 
; 379  : 			finalCarry = 
; 380  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 381  : 				135 : 0;

  000e1	48 8b c8	 mov	 rcx, rax
  000e4	4d 31 5d 00	 xor	 QWORD PTR [r13], r11
  000e8	49 31 45 08	 xor	 QWORD PTR [r13+8], rax
  000ec	49 23 c6	 and	 rax, r14
  000ef	49 83 c5 10	 add	 r13, 16
  000f3	48 f7 d8	 neg	 rax

; 382  : 
; 383  : 			*whiteningValuePtr64-- <<= 1;

  000f6	48 8d 04 09	 lea	 rax, QWORD PTR [rcx+rcx]
  000fa	1a d2		 sbb	 dl, dl
  000fc	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 384  : 
; 385  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00100	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00103	80 e2 87	 and	 dl, 135			; 00000087H
  00106	49 85 c6	 test	 rax, r14
  00109	74 05		 je	 SHORT $LN6@EncryptBuf

; 386  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0010b	48 83 4e 08 01	 or	 QWORD PTR [rsi+8], 1
$LN6@EncryptBuf:

; 387  : 
; 388  : 			*whiteningValuePtr64 <<= 1;

  00110	48 03 c0	 add	 rax, rax
  00113	41 ff c4	 inc	 r12d
  00116	48 89 06	 mov	 QWORD PTR [rsi], rax

; 389  : #else
; 390  : 
; 391  : 			// Big-endian platforms
; 392  : 
; 393  : 			finalCarry = 
; 394  : 				(*whiteningValuePtr64 & 0x80) ?
; 395  : 				135 : 0;
; 396  : 
; 397  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 398  : 
; 399  : 			whiteningValuePtr64--;
; 400  : 
; 401  : 			if (*whiteningValuePtr64 & 0x80)
; 402  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 403  : 
; 404  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 405  : #endif
; 406  : 
; 407  : 			whiteningValue[0] ^= finalCarry;

  00119	30 54 24 38	 xor	 BYTE PTR whiteningValue$[rsp], dl
  0011d	44 3b e7	 cmp	 r12d, edi
  00120	72 97		 jb	 SHORT $LL11@EncryptBuf
  00122	4c 8b 74 24 30	 mov	 r14, QWORD PTR ks2$GSCopy$1$[rsp]
$LN9@EncryptBuf:

; 408  : 		}
; 409  : 
; 410  : 		blockCount -= endBlock - startBlock;

  00127	8b c7		 mov	 eax, edi

; 411  : 		startBlock = 0;
; 412  : 		dataUnitNo++;

  00129	48 ff c5	 inc	 rbp
  0012c	48 2b d8	 sub	 rbx, rax
  0012f	0f 85 44 ff ff
	ff		 jne	 $LL15@EncryptBuf
$LN5@EncryptBuf:

; 413  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 414  : 	}
; 415  : 
; 416  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00135	48 8d 44 24 38	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  0013a	b9 02 00 00 00	 mov	 ecx, 2
$LL2@EncryptBuf:
  0013f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00146	48 83 c0 08	 add	 rax, 8
  0014a	83 e9 01	 sub	 ecx, 1
  0014d	75 f0		 jne	 SHORT $LL2@EncryptBuf

; 417  : }

  0014f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00154	48 33 cc	 xor	 rcx, rsp
  00157	e8 00 00 00 00	 call	 __security_check_cookie
  0015c	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00161	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00165	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  00169	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0016d	49 8b e3	 mov	 rsp, r11
  00170	41 5f		 pop	 r15
  00172	41 5e		 pop	 r14
  00174	41 5d		 pop	 r13
  00176	41 5c		 pop	 r12
  00178	5f		 pop	 rdi
  00179	c3		 ret	 0
$LN26@EncryptBuf:
EncryptBufferXTSNonParallel ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	EncryptBufferXTS8Byte
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
pdata	SEGMENT
$pdata$EncryptBufferXTS8Byte DD imagerel $LN29
	DD	imagerel $LN29+418
	DD	imagerel $unwind$EncryptBufferXTS8Byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTS8Byte DD 0b2b19H
	DD	0585419H
	DD	0573419H
	DD	0500119H
	DD	0e010f012H
	DD	0700cc00eH
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	0270H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xts.c
xdata	ENDS
;	COMDAT EncryptBufferXTS8Byte
_TEXT	SEGMENT
ks2$GSCopy$1$ = 48
whiteningValue$ = 56
byteBufUnitNo$ = 64
xor_ks$ = 80
__$ArrayPad$ = 624
buffer$ = 688
length$ = 696
startDataUnitNo$ = 704
startCipherBlockNo$ = 712
ks$ = 720
ks2$ = 728
cipher$ = 736
EncryptBufferXTS8Byte PROC				; COMDAT

; 70   : {

$LN29:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 81 ec 80 02
	00 00		 sub	 rsp, 640		; 00000280H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0002b	4c 8b a4 24 d8
	02 00 00	 mov	 r12, QWORD PTR ks2$[rsp]

; 71   : 	unsigned __int8 finalCarry;
; 72   : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
; 73   : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
; 74   : 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *)whiteningValue;
; 75   : 	unsigned __int32 *bufPtr = (unsigned __int32 *)buffer;
; 76   : 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;
; 77   : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 78   : 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
; 79   : 
; 80   : 	dataUnitNo = startDataUnitNo->Value;

  00033	49 8b 38	 mov	 rdi, QWORD PTR [r8]
  00036	4c 8b b4 24 d0
	02 00 00	 mov	 r14, QWORD PTR ks$[rsp]
  0003e	4c 89 64 24 30	 mov	 QWORD PTR ks2$GSCopy$1$[rsp], r12

; 81   : 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64(dataUnitNo);

  00043	48 89 7c 24 40	 mov	 QWORD PTR byteBufUnitNo$[rsp], rdi
  00048	48 8b da	 mov	 rbx, rdx
  0004b	4c 8b f9	 mov	 r15, rcx

; 82   : 
; 83   : 	if (length % BYTES_PER_XTS_BLOCK_SMALL)

  0004e	f6 c2 07	 test	 dl, 7
  00051	74 1d		 je	 SHORT $LN16@EncryptBuf@2

; 84   : 		GST_THROW_FATAL_EXCEPTION;

  00053	45 33 c9	 xor	 r9d, r9d
  00056	45 33 c0	 xor	 r8d, r8d
  00059	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00062	41 8d 51 54	 lea	 edx, QWORD PTR [r9+84]
  00066	8d 4a d5	 lea	 ecx, QWORD PTR [rdx-43]
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0006f	cc		 int	 3
$LN16@EncryptBuf@2:

; 85   : 
; 86   : 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;
; 87   : 
; 88   : 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));

  00070	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00077	48 c1 eb 03	 shr	 rbx, 3
  0007b	e8 00 00 00 00	 call	 CipherGet
  00080	48 8d 4c 24 50	 lea	 rcx, QWORD PTR xor_ks$[rsp]
  00085	49 8b d6	 mov	 rdx, r14
  00088	4c 63 40 18	 movsxd	 r8, DWORD PTR [rax+24]
  0008c	e8 00 00 00 00	 call	 memcpy

; 89   : 
; 90   : 	while (blockCount > 0)

  00091	48 85 db	 test	 rbx, rbx
  00094	0f 84 d4 00 00
	00		 je	 $LN5@EncryptBuf@2
$LL15@EncryptBuf@2:

; 91   : 	{
; 92   : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)
; 93   : 			endBlock = startBlock + (unsigned __int32) blockCount;
; 94   : 		else
; 95   : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;
; 96   : 
; 97   : 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
; 98   : 
; 99   : 		//Generate first whitening value
; 100  : 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);
; 101  : 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);
; 102  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0009a	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000a1	bd 40 00 00 00	 mov	 ebp, 64			; 00000040H
  000a6	48 8b c7	 mov	 rax, rdi
  000a9	48 3b dd	 cmp	 rbx, rbp
  000ac	48 8d 54 24 38	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  000b1	4d 8b c4	 mov	 r8, r12
  000b4	0f 42 eb	 cmovb	 ebp, ebx
  000b7	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  000bb	48 8d 74 24 38	 lea	 rsi, QWORD PTR whiteningValue$[rsp]
  000c0	89 44 24 3c	 mov	 DWORD PTR whiteningValue$[rsp+4], eax
  000c4	89 7c 24 38	 mov	 DWORD PTR whiteningValue$[rsp], edi
  000c8	e8 00 00 00 00	 call	 EncipherBlock

; 103  : 
; 104  : 		//XOR ks with the current DataUnitNo
; 105  : 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);

  000cd	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000d4	4c 8d 4c 24 40	 lea	 r9, QWORD PTR byteBufUnitNo$[rsp]
  000d9	4c 8d 44 24 50	 lea	 r8, QWORD PTR xor_ks$[rsp]
  000de	49 8b d6	 mov	 rdx, r14
  000e1	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  000e9	e8 00 00 00 00	 call	 XorKeySchedule

; 106  : 
; 107  : 		//Generate subsequent whitening values for blocks
; 108  : 		for (block = 0; block < endBlock; block++)

  000ee	45 33 e4	 xor	 r12d, r12d
  000f1	85 ed		 test	 ebp, ebp
  000f3	74 61		 je	 SHORT $LN9@EncryptBuf@2
$LL11@EncryptBuf@2:

; 109  : 		{
; 110  : 			if (block >= startBlock)
; 111  : 			{
; 112  : 				//Pre-whitening
; 113  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  000f5	8b 06		 mov	 eax, DWORD PTR [rsi]

; 114  : 				*bufPtr-- ^= *whiteningValuePtr32--;
; 115  : 
; 116  : 				//Actual encryption
; 117  : 				EncipherBlock(cipher, bufPtr, xor_ks);

  000f7	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000fe	4c 8d 44 24 50	 lea	 r8, QWORD PTR xor_ks$[rsp]
  00103	41 31 07	 xor	 DWORD PTR [r15], eax
  00106	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  00109	49 8b d7	 mov	 rdx, r15
  0010c	41 31 47 04	 xor	 DWORD PTR [r15+4], eax
  00110	e8 00 00 00 00	 call	 EncipherBlock

; 118  : 
; 119  : 				//Post-whitening
; 120  : 				*bufPtr++ ^= *whiteningValuePtr32++;
; 121  : 				*bufPtr++ ^= *whiteningValuePtr32;

  00115	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  00118	44 8b 1e	 mov	 r11d, DWORD PTR [rsi]

; 122  : 			}
; 123  : 			else
; 124  : 				whiteningValuePtr32++;
; 125  : 
; 126  : 			//Derive the next whitening value
; 127  : #if BYTE_ORDER == LITTLE_ENDIAN
; 128  : 
; 129  : 			//Little-endian platforms
; 130  : 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;

  0011b	8b c8		 mov	 ecx, eax
  0011d	45 31 1f	 xor	 DWORD PTR [r15], r11d
  00120	41 31 47 04	 xor	 DWORD PTR [r15+4], eax
  00124	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00129	49 83 c7 08	 add	 r15, 8
  0012d	f7 d8		 neg	 eax

; 131  : 
; 132  : 			*whiteningValuePtr32-- <<= 1;

  0012f	8d 04 09	 lea	 eax, DWORD PTR [rcx+rcx]
  00132	1a d2		 sbb	 dl, dl
  00134	89 46 04	 mov	 DWORD PTR [rsi+4], eax

; 133  : 
; 134  : 			if (*whiteningValuePtr32 & 0x80000000)

  00137	8b 06		 mov	 eax, DWORD PTR [rsi]
  00139	80 e2 1b	 and	 dl, 27
  0013c	0f ba e0 1f	 bt	 eax, 31
  00140	73 04		 jae	 SHORT $LN6@EncryptBuf@2

; 135  : 				*(whiteningValuePtr32 + 1) |= 1;

  00142	83 4e 04 01	 or	 DWORD PTR [rsi+4], 1
$LN6@EncryptBuf@2:

; 136  : 
; 137  : 			*whiteningValuePtr32 <<= 1;

  00146	03 c0		 add	 eax, eax
  00148	41 ff c4	 inc	 r12d
  0014b	89 06		 mov	 DWORD PTR [rsi], eax

; 138  : #else
; 139  : 			//Big-endian platforms
; 140  : 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
; 141  : 
; 142  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 143  : 
; 144  : 			whiteningValuePtr32--;
; 145  : 
; 146  : 			if (*whiteningValuePtr32 & 0x80)
; 147  : 				*(whiteningValuePtr32 + 1) |= 0x01000000;
; 148  : 
; 149  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 150  : #endif
; 151  : 			whiteningValue[0] ^= finalCarry;

  0014d	30 54 24 38	 xor	 BYTE PTR whiteningValue$[rsp], dl
  00151	44 3b e5	 cmp	 r12d, ebp
  00154	72 9f		 jb	 SHORT $LL11@EncryptBuf@2
$LN9@EncryptBuf@2:

; 89   : 
; 90   : 	while (blockCount > 0)

  00156	4c 8b 64 24 30	 mov	 r12, QWORD PTR ks2$GSCopy$1$[rsp]

; 152  : 		}
; 153  : 		blockCount -= endBlock - startBlock;
; 154  : 		startBlock = 0;
; 155  : 		dataUnitNo++;

  0015b	48 ff c7	 inc	 rdi
  0015e	8b c5		 mov	 eax, ebp
  00160	48 2b d8	 sub	 rbx, rax

; 156  : 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  00163	48 89 7c 24 40	 mov	 QWORD PTR byteBufUnitNo$[rsp], rdi
  00168	0f 85 2c ff ff
	ff		 jne	 $LL15@EncryptBuf@2
$LN5@EncryptBuf@2:

; 157  : 	}
; 158  : 	FAST_ERASE32(whiteningValue, sizeof(whiteningValue));

  0016e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR whiteningValue$[rsp], 0

; 159  : }

  00176	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0017e	48 33 cc	 xor	 rcx, rsp
  00181	e8 00 00 00 00	 call	 __security_check_cookie
  00186	4c 8d 9c 24 80
	02 00 00	 lea	 r11, QWORD PTR [rsp+640]
  0018e	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00192	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  00196	49 8b e3	 mov	 rsp, r11
  00199	41 5f		 pop	 r15
  0019b	41 5e		 pop	 r14
  0019d	41 5c		 pop	 r12
  0019f	5f		 pop	 rdi
  001a0	5e		 pop	 rsi
  001a1	c3		 ret	 0
$LN28@EncryptBuf@2:
EncryptBufferXTS8Byte ENDP
PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
pdata	SEGMENT
$pdata$DecryptBufferXTSParallel DD imagerel DecryptBufferXTSParallel
	DD	imagerel DecryptBufferXTSParallel+561
	DD	imagerel $unwind$DecryptBufferXTSParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTSParallel DD 0d3119H
	DD	055641fH
	DD	054541fH
	DD	053341fH
	DD	04c011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0250H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xts.c
xdata	ENDS
;	COMDAT DecryptBufferXTSParallel
_TEXT	SEGMENT
ks2$GSCopy$1$ = 48
ks$GSCopy$1$ = 56
whiteningValue$ = 64
whiteningValues$ = 80
__$ArrayPad$ = 592
buffer$ = 656
length$ = 664
startDataUnitNo$ = 672
startCipherBlockNo$ = 680
ks$ = 688
ks2$ = 696
cipher$ = 704
DecryptBufferXTSParallel PROC				; COMDAT

; 545  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 81 ec 60 02
	00 00		 sub	 rsp, 608		; 00000260H
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c4	 xor	 rax, rsp
  00029	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00031	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR ks$[rsp]

; 546  : 	unsigned __int8 finalCarry;
; 547  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 548  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 549  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 550  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 551  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 552  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 553  : 	unsigned __int64 *dataUnitBufPtr;
; 554  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 555  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 556  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 557  : 
; 558  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 559  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 560  : 	dataUnitNo = startDataUnitNo->Value;

  00039	4d 8b 38	 mov	 r15, QWORD PTR [r8]
  0003c	48 8b fa	 mov	 rdi, rdx
  0003f	48 89 44 24 38	 mov	 QWORD PTR ks$GSCopy$1$[rsp], rax
  00044	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR ks2$[rsp]
  0004c	48 8b d9	 mov	 rbx, rcx
  0004f	48 89 44 24 30	 mov	 QWORD PTR ks2$GSCopy$1$[rsp], rax

; 561  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 562  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 563  : 
; 564  : 	if (length % BYTES_PER_XTS_BLOCK)

  00054	f6 c2 0f	 test	 dl, 15
  00057	74 1f		 je	 SHORT $LN27@DecryptBuf@3

; 565  : 		GST_THROW_FATAL_EXCEPTION;

  00059	45 33 c9	 xor	 r9d, r9d
  0005c	45 33 c0	 xor	 r8d, r8d
  0005f	ba 35 02 00 00	 mov	 edx, 565		; 00000235H
  00064	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00068	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00077	cc		 int	 3
$LN27@DecryptBuf@3:

; 566  : 
; 567  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00078	48 c1 ef 04	 shr	 rdi, 4

; 568  : 
; 569  : 	// Process all blocks in the buffer
; 570  : 	while (blockCount > 0)

  0007c	48 85 ff	 test	 rdi, rdi
  0007f	0f 84 47 01 00
	00		 je	 $LN10@DecryptBuf@3
  00085	49 bd 00 00 00
	00 00 00 00 80	 mov	 r13, -9223372036854775808 ; 8000000000000000H
$LL26@DecryptBuf@3:

; 571  : 	{
; 572  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
; 573  : 			endBlock = startBlock + (unsigned int) blockCount;
; 574  : 		else
; 575  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
; 576  : 
; 577  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 578  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 579  : 
; 580  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 581  : 		// whitening value for this data unit)
; 582  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
; 583  : 		*(whiteningValuePtr64 + 1) = 0;
; 584  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0008f	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00096	be 20 00 00 00	 mov	 esi, 32			; 00000020H
  0009b	48 8d 54 24 40	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  000a0	48 3b fe	 cmp	 rdi, rsi
  000a3	4c 8b c0	 mov	 r8, rax
  000a6	4c 8d a4 24 48
	02 00 00	 lea	 r12, QWORD PTR whiteningValues$[rsp+504]
  000ae	0f 42 f7	 cmovb	 esi, edi
  000b1	48 83 64 24 48
	00		 and	 QWORD PTR whiteningValue$[rsp+8], 0
  000b7	48 8d 6c 24 40	 lea	 rbp, QWORD PTR whiteningValue$[rsp]
  000bc	4c 89 7c 24 40	 mov	 QWORD PTR whiteningValue$[rsp], r15
  000c1	e8 00 00 00 00	 call	 EncipherBlock

; 585  : 
; 586  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 587  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 588  : 		for (block = 0; block < endBlock; block++)

  000c6	45 33 db	 xor	 r11d, r11d
  000c9	85 f6		 test	 esi, esi
  000cb	74 4c		 je	 SHORT $LN20@DecryptBuf@3
$LL22@DecryptBuf@3:

; 589  : 		{
; 590  : 			if (block >= startBlock)
; 591  : 			{
; 592  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  000cd	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  000d1	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 593  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  000d5	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  000d9	49 83 ec 10	 sub	 r12, 16
  000dd	49 89 44 24 08	 mov	 QWORD PTR [r12+8], rax

; 594  : 			}
; 595  : 			else
; 596  : 				whiteningValuePtr64++;
; 597  : 
; 598  : 			// Derive the next whitening value
; 599  : 
; 600  : #if BYTE_ORDER == LITTLE_ENDIAN
; 601  : 
; 602  : 			// Little-endian platforms
; 603  : 
; 604  : 			finalCarry = 
; 605  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 606  : 				135 : 0;

  000e2	48 8b c8	 mov	 rcx, rax
  000e5	49 23 c5	 and	 rax, r13
  000e8	48 f7 d8	 neg	 rax

; 607  : 
; 608  : 			*whiteningValuePtr64-- <<= 1;

  000eb	48 8d 04 09	 lea	 rax, QWORD PTR [rcx+rcx]
  000ef	1a d2		 sbb	 dl, dl
  000f1	48 89 45 08	 mov	 QWORD PTR [rbp+8], rax

; 609  : 
; 610  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  000f5	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  000f9	80 e2 87	 and	 dl, 135			; 00000087H
  000fc	49 85 c5	 test	 rax, r13
  000ff	74 05		 je	 SHORT $LN17@DecryptBuf@3

; 611  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00101	48 83 4d 08 01	 or	 QWORD PTR [rbp+8], 1
$LN17@DecryptBuf@3:

; 612  : 
; 613  : 			*whiteningValuePtr64 <<= 1;

  00106	48 03 c0	 add	 rax, rax
  00109	41 ff c3	 inc	 r11d
  0010c	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 614  : 
; 615  : #else
; 616  : 			// Big-endian platforms
; 617  : 
; 618  : 			finalCarry = 
; 619  : 				(*whiteningValuePtr64 & 0x80) ?
; 620  : 				135 : 0;
; 621  : 
; 622  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 623  : 
; 624  : 			whiteningValuePtr64--;
; 625  : 
; 626  : 			if (*whiteningValuePtr64 & 0x80)
; 627  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 628  : 
; 629  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 630  : #endif
; 631  : 
; 632  : 			whiteningValue[0] ^= finalCarry;

  00110	30 54 24 40	 xor	 BYTE PTR whiteningValue$[rsp], dl
  00114	44 3b de	 cmp	 r11d, esi
  00117	72 b4		 jb	 SHORT $LL22@DecryptBuf@3
$LN20@DecryptBuf@3:

; 633  : 		}
; 634  : 
; 635  : 		dataUnitBufPtr = bufPtr;

  00119	4c 8b eb	 mov	 r13, rbx

; 636  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0011c	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR whiteningValues$[rsp+504]

; 637  : 
; 638  : 		// Decrypt blocks in this data unit
; 639  : 
; 640  : 		for (block = startBlock; block < endBlock; block++)

  00124	85 f6		 test	 esi, esi
  00126	74 1e		 je	 SHORT $LN14@DecryptBuf@3

; 633  : 		}
; 634  : 
; 635  : 		dataUnitBufPtr = bufPtr;

  00128	8b d6		 mov	 edx, esi
$LL16@DecryptBuf@3:

; 641  : 		{
; 642  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0012a	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 643  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0012d	48 83 e9 10	 sub	 rcx, 16
  00131	48 31 03	 xor	 QWORD PTR [rbx], rax
  00134	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00138	48 83 c3 10	 add	 rbx, 16
  0013c	48 31 43 f8	 xor	 QWORD PTR [rbx-8], rax
  00140	48 83 ea 01	 sub	 rdx, 1
  00144	75 e4		 jne	 SHORT $LL16@DecryptBuf@3
$LN14@DecryptBuf@3:

; 644  : 		}
; 645  : 
; 646  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00146	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0014d	8b ee		 mov	 ebp, esi
  0014f	8b de		 mov	 ebx, esi
  00151	4d 8b e5	 mov	 r12, r13
  00154	e8 00 00 00 00	 call	 CipherGet
  00159	4c 63 70 10	 movsxd	 r14, DWORD PTR [rax+16]
  0015d	85 f6		 test	 esi, esi
  0015f	74 22		 je	 SHORT $LN45@DecryptBuf@3
  00161	48 8b 6c 24 38	 mov	 rbp, QWORD PTR ks$GSCopy$1$[rsp]
$LL31@DecryptBuf@3:
  00166	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0016d	4c 8b c5	 mov	 r8, rbp
  00170	49 8b d4	 mov	 rdx, r12
  00173	e8 00 00 00 00	 call	 DecipherBlock
  00178	4d 03 e6	 add	 r12, r14
  0017b	48 83 eb 01	 sub	 rbx, 1
  0017f	75 e5		 jne	 SHORT $LL31@DecryptBuf@3
  00181	8b ee		 mov	 ebp, esi
$LN45@DecryptBuf@3:

; 647  : 
; 648  : 		bufPtr = dataUnitBufPtr;

  00183	49 8b dd	 mov	 rbx, r13

; 649  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00186	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR whiteningValues$[rsp+504]

; 650  : 
; 651  : 		for (block = startBlock; block < endBlock; block++)

  0018e	85 f6		 test	 esi, esi
  00190	74 1f		 je	 SHORT $LN11@DecryptBuf@3

; 647  : 
; 648  : 		bufPtr = dataUnitBufPtr;

  00192	48 8b d5	 mov	 rdx, rbp
$LL13@DecryptBuf@3:

; 652  : 		{
; 653  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00195	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 654  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00198	48 83 e9 10	 sub	 rcx, 16
  0019c	48 31 03	 xor	 QWORD PTR [rbx], rax
  0019f	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  001a3	48 83 c3 10	 add	 rbx, 16
  001a7	48 31 43 f8	 xor	 QWORD PTR [rbx-8], rax
  001ab	48 83 ea 01	 sub	 rdx, 1
  001af	75 e4		 jne	 SHORT $LL13@DecryptBuf@3
$LN11@DecryptBuf@3:

; 568  : 
; 569  : 	// Process all blocks in the buffer
; 570  : 	while (blockCount > 0)

  001b1	48 8b 44 24 30	 mov	 rax, QWORD PTR ks2$GSCopy$1$[rsp]

; 655  : 		}
; 656  : 
; 657  : 		blockCount -= endBlock - startBlock;
; 658  : 		startBlock = 0;
; 659  : 		dataUnitNo++;

  001b6	49 ff c7	 inc	 r15
  001b9	48 2b fd	 sub	 rdi, rbp
  001bc	49 bd 00 00 00
	00 00 00 00 80	 mov	 r13, -9223372036854775808 ; 8000000000000000H
  001c6	0f 85 c3 fe ff
	ff		 jne	 $LL26@DecryptBuf@3
$LN10@DecryptBuf@3:

; 660  : 
; 661  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 662  : 	}
; 663  : 
; 664  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  001cc	48 8d 44 24 40	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  001d1	b9 02 00 00 00	 mov	 ecx, 2
$LL7@DecryptBuf@3:
  001d6	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  001dd	48 83 c0 08	 add	 rax, 8
  001e1	83 e9 01	 sub	 ecx, 1
  001e4	75 f0		 jne	 SHORT $LL7@DecryptBuf@3

; 665  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  001e6	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  001eb	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
$LL2@DecryptBuf@3:
  001f0	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  001f7	48 83 c0 08	 add	 rax, 8
  001fb	83 e9 01	 sub	 ecx, 1
  001fe	75 f0		 jne	 SHORT $LL2@DecryptBuf@3

; 666  : }

  00200	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00208	48 33 cc	 xor	 rcx, rsp
  0020b	e8 00 00 00 00	 call	 __security_check_cookie
  00210	4c 8d 9c 24 60
	02 00 00	 lea	 r11, QWORD PTR [rsp+608]
  00218	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  0021c	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  00220	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  00224	49 8b e3	 mov	 rsp, r11
  00227	41 5f		 pop	 r15
  00229	41 5e		 pop	 r14
  0022b	41 5d		 pop	 r13
  0022d	41 5c		 pop	 r12
  0022f	5f		 pop	 rdi
  00230	c3		 ret	 0
$LN53@DecryptBuf@3:
DecryptBufferXTSParallel ENDP
_TEXT	ENDS
PUBLIC	DecryptBufferXTS
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
pdata	SEGMENT
$pdata$DecryptBufferXTS DD imagerel $LN7
	DD	imagerel $LN7+48
	DD	imagerel $unwind$DecryptBufferXTS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTS DD 010401H
	DD	08204H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xts.c
xdata	ENDS
;	COMDAT DecryptBufferXTS
_TEXT	SEGMENT
buffer$ = 80
length$ = 88
startDataUnitNo$ = 96
startCipherBlockNo$ = 104
ks$ = 112
ks2$ = 120
cipher$ = 128
DecryptBufferXTS PROC					; COMDAT

; 428  : {

$LN7:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 429  : 	if (CipherSupportsIntraDataUnitParallelization (cipher))
; 430  : 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);
; 431  : 	else
; 432  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00004	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR cipher$[rsp]
  0000b	45 33 c9	 xor	 r9d, r9d
  0000e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00012	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00017	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0001c	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  00021	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00026	e8 00 00 00 00	 call	 DecryptBufferXTSNonParallel

; 433  : }

  0002b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0002f	c3		 ret	 0
DecryptBufferXTS ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
pdata	SEGMENT
$pdata$EncryptBufferXTSParallel DD imagerel EncryptBufferXTSParallel
	DD	imagerel EncryptBufferXTSParallel+561
	DD	imagerel $unwind$EncryptBufferXTSParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTSParallel DD 0d3119H
	DD	055641fH
	DD	054541fH
	DD	053341fH
	DD	04c011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0250H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xts.c
xdata	ENDS
;	COMDAT EncryptBufferXTSParallel
_TEXT	SEGMENT
ks2$GSCopy$1$ = 48
ks$GSCopy$1$ = 56
whiteningValue$ = 64
whiteningValues$ = 80
__$ArrayPad$ = 592
buffer$ = 656
length$ = 664
startDataUnitNo$ = 672
startCipherBlockNo$ = 680
ks$ = 688
ks2$ = 696
cipher$ = 704
EncryptBufferXTSParallel PROC				; COMDAT

; 169  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 81 ec 60 02
	00 00		 sub	 rsp, 608		; 00000260H
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c4	 xor	 rax, rsp
  00029	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00031	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR ks$[rsp]

; 170  : 	unsigned __int8 finalCarry;
; 171  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 172  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 173  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 174  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 175  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 176  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 177  : 	unsigned __int64 *dataUnitBufPtr;
; 178  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 179  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 180  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 181  : 
; 182  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 183  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 184  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 185  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 186  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 187  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 188  : 
; 189  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 190  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 191  : 	dataUnitNo = startDataUnitNo->Value;

  00039	4d 8b 38	 mov	 r15, QWORD PTR [r8]
  0003c	48 8b fa	 mov	 rdi, rdx
  0003f	48 89 44 24 38	 mov	 QWORD PTR ks$GSCopy$1$[rsp], rax
  00044	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR ks2$[rsp]
  0004c	48 8b d9	 mov	 rbx, rcx
  0004f	48 89 44 24 30	 mov	 QWORD PTR ks2$GSCopy$1$[rsp], rax

; 192  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 193  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 194  : 
; 195  : 	if (length % BYTES_PER_XTS_BLOCK)

  00054	f6 c2 0f	 test	 dl, 15
  00057	74 1f		 je	 SHORT $LN27@EncryptBuf@3

; 196  : 		GST_THROW_FATAL_EXCEPTION;

  00059	45 33 c9	 xor	 r9d, r9d
  0005c	45 33 c0	 xor	 r8d, r8d
  0005f	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  00064	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00068	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00077	cc		 int	 3
$LN27@EncryptBuf@3:

; 197  : 
; 198  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00078	48 c1 ef 04	 shr	 rdi, 4

; 199  : 
; 200  : 	// Process all blocks in the buffer
; 201  : 	while (blockCount > 0)

  0007c	48 85 ff	 test	 rdi, rdi
  0007f	0f 84 47 01 00
	00		 je	 $LN10@EncryptBuf@3
  00085	49 bd 00 00 00
	00 00 00 00 80	 mov	 r13, -9223372036854775808 ; 8000000000000000H
$LL26@EncryptBuf@3:

; 202  : 	{
; 203  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
; 204  : 			endBlock = startBlock + (unsigned int) blockCount;
; 205  : 		else
; 206  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
; 207  : 
; 208  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 209  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 210  : 
; 211  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 212  : 		// whitening value for this data unit)
; 213  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
; 214  : 		*(whiteningValuePtr64 + 1) = 0;
; 215  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0008f	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00096	be 20 00 00 00	 mov	 esi, 32			; 00000020H
  0009b	48 8d 54 24 40	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  000a0	48 3b fe	 cmp	 rdi, rsi
  000a3	4c 8b c0	 mov	 r8, rax
  000a6	4c 8d a4 24 48
	02 00 00	 lea	 r12, QWORD PTR whiteningValues$[rsp+504]
  000ae	0f 42 f7	 cmovb	 esi, edi
  000b1	48 83 64 24 48
	00		 and	 QWORD PTR whiteningValue$[rsp+8], 0
  000b7	48 8d 6c 24 40	 lea	 rbp, QWORD PTR whiteningValue$[rsp]
  000bc	4c 89 7c 24 40	 mov	 QWORD PTR whiteningValue$[rsp], r15
  000c1	e8 00 00 00 00	 call	 EncipherBlock

; 216  : 
; 217  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 218  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 219  : 		for (block = 0; block < endBlock; block++)

  000c6	45 33 db	 xor	 r11d, r11d
  000c9	85 f6		 test	 esi, esi
  000cb	74 4c		 je	 SHORT $LN20@EncryptBuf@3
$LL22@EncryptBuf@3:

; 220  : 		{
; 221  : 			if (block >= startBlock)
; 222  : 			{
; 223  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  000cd	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  000d1	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 224  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  000d5	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  000d9	49 83 ec 10	 sub	 r12, 16
  000dd	49 89 44 24 08	 mov	 QWORD PTR [r12+8], rax

; 225  : 			}
; 226  : 			else
; 227  : 				whiteningValuePtr64++;
; 228  : 
; 229  : 			// Derive the next whitening value
; 230  : 
; 231  : #if BYTE_ORDER == LITTLE_ENDIAN
; 232  : 
; 233  : 			// Little-endian platforms
; 234  : 
; 235  : 			finalCarry = 
; 236  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 237  : 				135 : 0;

  000e2	48 8b c8	 mov	 rcx, rax
  000e5	49 23 c5	 and	 rax, r13
  000e8	48 f7 d8	 neg	 rax

; 238  : 
; 239  : 			*whiteningValuePtr64-- <<= 1;

  000eb	48 8d 04 09	 lea	 rax, QWORD PTR [rcx+rcx]
  000ef	1a d2		 sbb	 dl, dl
  000f1	48 89 45 08	 mov	 QWORD PTR [rbp+8], rax

; 240  : 
; 241  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  000f5	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  000f9	80 e2 87	 and	 dl, 135			; 00000087H
  000fc	49 85 c5	 test	 rax, r13
  000ff	74 05		 je	 SHORT $LN17@EncryptBuf@3

; 242  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00101	48 83 4d 08 01	 or	 QWORD PTR [rbp+8], 1
$LN17@EncryptBuf@3:

; 243  : 
; 244  : 			*whiteningValuePtr64 <<= 1;

  00106	48 03 c0	 add	 rax, rax
  00109	41 ff c3	 inc	 r11d
  0010c	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 245  : #else
; 246  : 
; 247  : 			// Big-endian platforms
; 248  : 
; 249  : 			finalCarry = 
; 250  : 				(*whiteningValuePtr64 & 0x80) ?
; 251  : 				135 : 0;
; 252  : 
; 253  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 254  : 
; 255  : 			whiteningValuePtr64--;
; 256  : 
; 257  : 			if (*whiteningValuePtr64 & 0x80)
; 258  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 259  : 
; 260  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 261  : #endif
; 262  : 
; 263  : 			whiteningValue[0] ^= finalCarry;

  00110	30 54 24 40	 xor	 BYTE PTR whiteningValue$[rsp], dl
  00114	44 3b de	 cmp	 r11d, esi
  00117	72 b4		 jb	 SHORT $LL22@EncryptBuf@3
$LN20@EncryptBuf@3:

; 264  : 		}
; 265  : 
; 266  : 		dataUnitBufPtr = bufPtr;

  00119	4c 8b eb	 mov	 r13, rbx

; 267  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0011c	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR whiteningValues$[rsp+504]

; 268  : 
; 269  : 		// Encrypt all blocks in this data unit
; 270  : 
; 271  : 		for (block = startBlock; block < endBlock; block++)

  00124	85 f6		 test	 esi, esi
  00126	74 1e		 je	 SHORT $LN14@EncryptBuf@3

; 264  : 		}
; 265  : 
; 266  : 		dataUnitBufPtr = bufPtr;

  00128	8b d6		 mov	 edx, esi
$LL16@EncryptBuf@3:

; 272  : 		{
; 273  : 			// Pre-whitening
; 274  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0012a	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 275  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0012d	48 83 e9 10	 sub	 rcx, 16
  00131	48 31 03	 xor	 QWORD PTR [rbx], rax
  00134	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00138	48 83 c3 10	 add	 rbx, 16
  0013c	48 31 43 f8	 xor	 QWORD PTR [rbx-8], rax
  00140	48 83 ea 01	 sub	 rdx, 1
  00144	75 e4		 jne	 SHORT $LL16@EncryptBuf@3
$LN14@EncryptBuf@3:

; 276  : 		}
; 277  : 
; 278  : 		// Actual encryption
; 279  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00146	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0014d	8b ee		 mov	 ebp, esi
  0014f	8b de		 mov	 ebx, esi
  00151	4d 8b e5	 mov	 r12, r13
  00154	e8 00 00 00 00	 call	 CipherGet
  00159	4c 63 70 10	 movsxd	 r14, DWORD PTR [rax+16]
  0015d	85 f6		 test	 esi, esi
  0015f	74 22		 je	 SHORT $LN45@EncryptBuf@3
  00161	48 8b 6c 24 38	 mov	 rbp, QWORD PTR ks$GSCopy$1$[rsp]
$LL31@EncryptBuf@3:
  00166	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0016d	4c 8b c5	 mov	 r8, rbp
  00170	49 8b d4	 mov	 rdx, r12
  00173	e8 00 00 00 00	 call	 EncipherBlock
  00178	4d 03 e6	 add	 r12, r14
  0017b	48 83 eb 01	 sub	 rbx, 1
  0017f	75 e5		 jne	 SHORT $LL31@EncryptBuf@3
  00181	8b ee		 mov	 ebp, esi
$LN45@EncryptBuf@3:

; 280  : 		
; 281  : 		bufPtr = dataUnitBufPtr;

  00183	49 8b dd	 mov	 rbx, r13

; 282  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00186	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR whiteningValues$[rsp+504]

; 283  : 
; 284  : 		for (block = startBlock; block < endBlock; block++)

  0018e	85 f6		 test	 esi, esi
  00190	74 1f		 je	 SHORT $LN11@EncryptBuf@3

; 280  : 		
; 281  : 		bufPtr = dataUnitBufPtr;

  00192	48 8b d5	 mov	 rdx, rbp
$LL13@EncryptBuf@3:

; 285  : 		{
; 286  : 			// Post-whitening
; 287  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00195	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 288  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00198	48 83 e9 10	 sub	 rcx, 16
  0019c	48 31 03	 xor	 QWORD PTR [rbx], rax
  0019f	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  001a3	48 83 c3 10	 add	 rbx, 16
  001a7	48 31 43 f8	 xor	 QWORD PTR [rbx-8], rax
  001ab	48 83 ea 01	 sub	 rdx, 1
  001af	75 e4		 jne	 SHORT $LL13@EncryptBuf@3
$LN11@EncryptBuf@3:

; 199  : 
; 200  : 	// Process all blocks in the buffer
; 201  : 	while (blockCount > 0)

  001b1	48 8b 44 24 30	 mov	 rax, QWORD PTR ks2$GSCopy$1$[rsp]

; 289  : 		}
; 290  : 
; 291  : 		blockCount -= endBlock - startBlock;
; 292  : 		startBlock = 0;
; 293  : 		dataUnitNo++;

  001b6	49 ff c7	 inc	 r15
  001b9	48 2b fd	 sub	 rdi, rbp
  001bc	49 bd 00 00 00
	00 00 00 00 80	 mov	 r13, -9223372036854775808 ; 8000000000000000H
  001c6	0f 85 c3 fe ff
	ff		 jne	 $LL26@EncryptBuf@3
$LN10@EncryptBuf@3:

; 294  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 295  : 	}
; 296  : 
; 297  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  001cc	48 8d 44 24 40	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  001d1	b9 02 00 00 00	 mov	 ecx, 2
$LL7@EncryptBuf@3:
  001d6	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  001dd	48 83 c0 08	 add	 rax, 8
  001e1	83 e9 01	 sub	 ecx, 1
  001e4	75 f0		 jne	 SHORT $LL7@EncryptBuf@3

; 298  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  001e6	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  001eb	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
$LL2@EncryptBuf@3:
  001f0	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  001f7	48 83 c0 08	 add	 rax, 8
  001fb	83 e9 01	 sub	 ecx, 1
  001fe	75 f0		 jne	 SHORT $LL2@EncryptBuf@3

; 299  : }

  00200	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00208	48 33 cc	 xor	 rcx, rsp
  0020b	e8 00 00 00 00	 call	 __security_check_cookie
  00210	4c 8d 9c 24 60
	02 00 00	 lea	 r11, QWORD PTR [rsp+608]
  00218	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  0021c	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  00220	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  00224	49 8b e3	 mov	 rsp, r11
  00227	41 5f		 pop	 r15
  00229	41 5e		 pop	 r14
  0022b	41 5d		 pop	 r13
  0022d	41 5c		 pop	 r12
  0022f	5f		 pop	 rdi
  00230	c3		 ret	 0
$LN53@EncryptBuf@3:
EncryptBufferXTSParallel ENDP
_TEXT	ENDS
PUBLIC	EncryptBufferXTS
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
pdata	SEGMENT
$pdata$EncryptBufferXTS DD imagerel $LN7
	DD	imagerel $LN7+48
	DD	imagerel $unwind$EncryptBufferXTS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTS DD 010401H
	DD	08204H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xts.c
xdata	ENDS
;	COMDAT EncryptBufferXTS
_TEXT	SEGMENT
buffer$ = 80
length$ = 88
startDataUnitNo$ = 96
startCipherBlockNo$ = 104
ks$ = 112
ks2$ = 120
cipher$ = 128
EncryptBufferXTS PROC					; COMDAT

; 56   : {

$LN7:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 57   : 	if (CipherSupportsIntraDataUnitParallelization (cipher))
; 58   : 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);
; 59   : 	else
; 60   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00004	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR cipher$[rsp]
  0000b	45 33 c9	 xor	 r9d, r9d
  0000e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00012	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00017	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0001c	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  00021	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00026	e8 00 00 00 00	 call	 EncryptBufferXTSNonParallel

; 61   : }

  0002b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0002f	c3		 ret	 0
EncryptBufferXTS ENDP
END
