; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_09HLDHDDJL@Whirlpool?$AA@			; `string'
PUBLIC	??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@	; `string'
PUBLIC	??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@	; `string'
PUBLIC	??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@	; `string'
PUBLIC	??_C@_0O@POKHNLDL@GOST?528147?989?$AA@		; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
HwEncryptionDisabled DD 01H DUP (?)
;	COMDAT ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@ DB '[unknown]', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@ DB 'XTS 64-bit ver'
	DB	'sion', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@ DB 'XTS', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@ DB '-', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@ DB '?', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09HLDHDDJL@Whirlpool?$AA@
CONST	SEGMENT
??_C@_09HLDHDDJL@Whirlpool?$AA@ DB 'Whirlpool', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@
CONST	SEGMENT
??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@ DB 'GOST R 34.11-94', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@
CONST	SEGMENT
??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@ DB 'GOST R 34.11-2012', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@
CONST	SEGMENT
??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@ DB 'Gost Grasshopper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
CONST	SEGMENT
??_C@_0O@POKHNLDL@GOST?528147?989?$AA@ DB 'GOST 28147-89', 00H ; `string'
Ciphers	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
	DD	08H
	DD	020H
	DD	0220H
	ORG $+4
	DD	02H
	ORG $+4
	DQ	FLAT:??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@
	DD	010H
	DD	020H
	DD	0a0H
	ORG $+4
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
EncryptionAlgorithms DD 00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	ORG $+4
	DD	00H
	DD	01H
	DD	00H
	ORG $+8
	DD	02H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	00H
	ORG $+8
	DD	01H
	DD	00H
	ORG $+4
	DD	01H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	ORG $+4
	DD	00H
Hashes	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@
	DD	00H
	DD	01H
	DD	02H
	ORG $+4
	DQ	FLAT:??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@
	DD	00H
	DD	00H
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_09HLDHDDJL@Whirlpool?$AA@
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
PUBLIC	IsHwEncryptionEnabled
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT IsHwEncryptionEnabled
_TEXT	SEGMENT
IsHwEncryptionEnabled PROC				; COMDAT

; 1612 : 	return !HwEncryptionDisabled;

  00000	33 c0		 xor	 eax, eax
  00002	39 05 00 00 00
	00		 cmp	 DWORD PTR HwEncryptionDisabled, eax
  00008	0f 94 c0	 sete	 al

; 1613 : }

  0000b	c3		 ret	 0
IsHwEncryptionEnabled ENDP
_TEXT	ENDS
PUBLIC	EnableHwEncryption
; Function compile flags: /Ogspy
;	COMDAT EnableHwEncryption
_TEXT	SEGMENT
enable$ = 8
EnableHwEncryption PROC					; COMDAT

; 1600 : 	//Deprecated
; 1601 : }

  00000	c2 00 00	 ret	 0
EnableHwEncryption ENDP
_TEXT	ENDS
PUBLIC	crypto_open
;	COMDAT pdata
pdata	SEGMENT
$pdata$crypto_open DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$crypto_open
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$crypto_open DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT crypto_open
_TEXT	SEGMENT
crypto_open PROC					; COMDAT

; 894  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 895  : #ifndef GST_WINDOWS_BOOT
; 896  : 
; 897  : 	/* Do the crt allocation */
; 898  : 	PCRYPTO_INFO cryptoInfo = (PCRYPTO_INFO) GSTalloc (sizeof (CRYPTO_INFO));

  00006	ba 10 1f 00 00	 mov	 edx, 7952		; 00001f10H
  0000b	33 c9		 xor	 ecx, ecx
  0000d	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00019	48 8b d8	 mov	 rbx, rax

; 899  : 	if (cryptoInfo == NULL)

  0001c	48 85 c0	 test	 rax, rax
  0001f	74 16		 je	 SHORT $LN2@crypto_ope
$LN1@crypto_ope:

; 900  : 		return NULL;
; 901  : 
; 902  : 	memset (cryptoInfo, 0, sizeof (CRYPTO_INFO));

  00021	33 d2		 xor	 edx, edx
  00023	41 b8 10 1f 00
	00		 mov	 r8d, 7952		; 00001f10H
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 memset

; 903  : 
; 904  : #ifndef DEVICE_DRIVER
; 905  : 	VirtualLock (cryptoInfo, sizeof (CRYPTO_INFO));
; 906  : #endif
; 907  : 
; 908  : 	cryptoInfo->ea = -1;

  00031	83 0b ff	 or	 DWORD PTR [rbx], -1

; 909  : 	return cryptoInfo;

  00034	48 8b c3	 mov	 rax, rbx
$LN2@crypto_ope:

; 910  : 
; 911  : #else // GST_WINDOWS_BOOT
; 912  : 
; 913  : #if 0
; 914  : 	if (CryptoInfoBufferInUse)
; 915  : 		GST_THROW_FATAL_EXCEPTION;
; 916  : #endif
; 917  : 	CryptoInfoBufferInUse = 1;
; 918  : 	return &CryptoInfoBuffer;
; 919  : 
; 920  : #endif // GST_WINDOWS_BOOT
; 921  : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
crypto_open ENDP
_TEXT	ENDS
PUBLIC	EAGetPreviousCipher
; Function compile flags: /Ogspy
;	COMDAT EAGetPreviousCipher
_TEXT	SEGMENT
ea$ = 8
previousCipherId$ = 16
EAGetPreviousCipher PROC				; COMDAT

; 758  : 	int c, i = 0;
; 759  : 
; 760  : 	if (EncryptionAlgorithms[ea].Ciphers[i++] == previousCipherId)

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:EncryptionAlgorithms
  0000a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00010	4c 8b c8	 mov	 r9, rax
  00013	49 c1 e1 03	 shl	 r9, 3
  00017	43 39 14 8b	 cmp	 DWORD PTR [r11+r9*4], edx

; 761  : 		return 0;

  0001b	74 28		 je	 SHORT $LN9@EAGetPrevi

; 762  : 
; 763  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  0001d	43 8b 4c 8b 04	 mov	 ecx, DWORD PTR [r11+r9*4+4]
  00022	85 c9		 test	 ecx, ecx
  00024	74 1f		 je	 SHORT $LN9@EAGetPrevi
  00026	4c 8d 15 04 00
	00 00		 lea	 r10, OFFSET FLAT:EncryptionAlgorithms+4
  0002d	48 c1 e0 05	 shl	 rax, 5
  00031	49 03 c2	 add	 rax, r10
$LL3@EAGetPrevi:
  00034	41 ff c0	 inc	 r8d
  00037	48 83 c0 04	 add	 rax, 4

; 764  : 	{
; 765  : 		if (c == previousCipherId) 

  0003b	3b ca		 cmp	 ecx, edx
  0003d	74 09		 je	 SHORT $LN8@EAGetPrevi
  0003f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00041	85 c9		 test	 ecx, ecx
  00043	75 ef		 jne	 SHORT $LL3@EAGetPrevi
$LN9@EAGetPrevi:

; 767  : 	}
; 768  : 
; 769  : 	return 0;

  00045	33 c0		 xor	 eax, eax

; 770  : }

  00047	c3		 ret	 0
$LN8@EAGetPrevi:

; 766  : 			return EncryptionAlgorithms[ea].Ciphers[i - 2];

  00048	49 63 c0	 movsxd	 rax, r8d
  0004b	49 03 c1	 add	 rax, r9
  0004e	41 8b 44 83 f8	 mov	 eax, DWORD PTR [r11+rax*4-8]

; 770  : }

  00053	c3		 ret	 0
EAGetPreviousCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetNextCipher
; Function compile flags: /Ogspy
;	COMDAT EAGetNextCipher
_TEXT	SEGMENT
ea$ = 8
previousCipherId$ = 16
EAGetNextCipher PROC					; COMDAT

; 736  : 	int c, i = 0;
; 737  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:EncryptionAlgorithms
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	4c 8b c8	 mov	 r9, rax
  00010	49 c1 e1 03	 shl	 r9, 3
  00014	43 8b 0c 8a	 mov	 ecx, DWORD PTR [r10+r9*4]
  00018	85 c9		 test	 ecx, ecx
  0001a	74 18		 je	 SHORT $LN8@EAGetNextC
  0001c	48 c1 e0 05	 shl	 rax, 5
  00020	49 03 c2	 add	 rax, r10
$LL3@EAGetNextC:
  00023	41 ff c0	 inc	 r8d
  00026	48 83 c0 04	 add	 rax, 4

; 738  : 	{
; 739  : 		if (c == previousCipherId) 

  0002a	3b ca		 cmp	 ecx, edx
  0002c	74 09		 je	 SHORT $LN7@EAGetNextC
  0002e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00030	85 c9		 test	 ecx, ecx
  00032	75 ef		 jne	 SHORT $LL3@EAGetNextC
$LN8@EAGetNextC:

; 741  : 	}
; 742  : 
; 743  : 	return 0;

  00034	33 c0		 xor	 eax, eax

; 744  : }

  00036	c3		 ret	 0
$LN7@EAGetNextC:

; 740  : 			return EncryptionAlgorithms[ea].Ciphers[i];

  00037	49 63 c0	 movsxd	 rax, r8d
  0003a	49 03 c1	 add	 rax, r9
  0003d	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]

; 744  : }

  00041	c3		 ret	 0
EAGetNextCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetLastCipher
; Function compile flags: /Ogspy
;	COMDAT EAGetLastCipher
_TEXT	SEGMENT
ea$ = 8
EAGetLastCipher PROC					; COMDAT

; 718  : 	int c, i = 0;

  00000	4c 63 c1	 movsxd	 r8, ecx
  00003	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:EncryptionAlgorithms
  0000a	33 d2		 xor	 edx, edx
  0000c	49 8b c8	 mov	 rcx, r8
  0000f	48 c1 e1 05	 shl	 rcx, 5
  00013	49 03 c9	 add	 rcx, r9
$LL2@EAGetLastC:

; 719  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++]);

  00016	8b 01		 mov	 eax, DWORD PTR [rcx]
  00018	ff c2		 inc	 edx
  0001a	48 83 c1 04	 add	 rcx, 4
  0001e	85 c0		 test	 eax, eax
  00020	75 f4		 jne	 SHORT $LL2@EAGetLastC

; 720  : 
; 721  : 	return EncryptionAlgorithms[ea].Ciphers[i - 2];

  00022	48 63 c2	 movsxd	 rax, edx
  00025	4a 8d 0c c0	 lea	 rcx, QWORD PTR [rax+r8*8]
  00029	41 8b 44 89 f8	 mov	 eax, DWORD PTR [r9+rcx*4-8]

; 722  : }

  0002e	c3		 ret	 0
EAGetLastCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetFirstCipher
; Function compile flags: /Ogspy
;	COMDAT EAGetFirstCipher
_TEXT	SEGMENT
ea$ = 8
EAGetFirstCipher PROC					; COMDAT

; 704  : 	return EncryptionAlgorithms[ea].Ciphers[0];

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0000a	48 c1 e0 05	 shl	 rax, 5
  0000e	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]

; 705  : }

  00011	c3		 ret	 0
EAGetFirstCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetNextMode
; Function compile flags: /Ogspy
;	COMDAT EAGetNextMode
_TEXT	SEGMENT
ea$ = 8
previousModeId$ = 16
EAGetNextMode PROC					; COMDAT

; 567  : 	int c, i = 0;
; 568  : 	while (c = EncryptionAlgorithms[ea].Modes[i++])

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:EncryptionAlgorithms
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	4c 8b c8	 mov	 r9, rax
  00010	49 c1 e1 03	 shl	 r9, 3
  00014	43 8b 4c 8b 10	 mov	 ecx, DWORD PTR [r11+r9*4+16]
  00019	85 c9		 test	 ecx, ecx
  0001b	74 1f		 je	 SHORT $LN8@EAGetNextM
  0001d	4c 8d 15 10 00
	00 00		 lea	 r10, OFFSET FLAT:EncryptionAlgorithms+16
  00024	48 c1 e0 05	 shl	 rax, 5
  00028	49 03 c2	 add	 rax, r10
$LL3@EAGetNextM:
  0002b	41 ff c0	 inc	 r8d
  0002e	48 83 c0 04	 add	 rax, 4

; 569  : 	{
; 570  : 		if (c == previousModeId) 

  00032	3b ca		 cmp	 ecx, edx
  00034	74 09		 je	 SHORT $LN7@EAGetNextM
  00036	8b 08		 mov	 ecx, DWORD PTR [rax]
  00038	85 c9		 test	 ecx, ecx
  0003a	75 ef		 jne	 SHORT $LL3@EAGetNextM
$LN8@EAGetNextM:

; 572  : 	}
; 573  : 
; 574  : 	return 0;

  0003c	33 c0		 xor	 eax, eax

; 575  : }

  0003e	c3		 ret	 0
$LN7@EAGetNextM:

; 571  : 			return EncryptionAlgorithms[ea].Modes[i];

  0003f	49 63 c0	 movsxd	 rax, r8d
  00042	49 03 c1	 add	 rax, r9
  00045	41 8b 44 83 10	 mov	 eax, DWORD PTR [r11+rax*4+16]

; 575  : }

  0004a	c3		 ret	 0
EAGetNextMode ENDP
_TEXT	ENDS
PUBLIC	EAGetFirstMode
; Function compile flags: /Ogspy
;	COMDAT EAGetFirstMode
_TEXT	SEGMENT
ea$ = 8
EAGetFirstMode PROC					; COMDAT

; 552  : 	return (EncryptionAlgorithms[ea].Modes[0]);

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms+16
  0000a	48 c1 e0 05	 shl	 rax, 5
  0000e	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]

; 553  : }

  00011	c3		 ret	 0
EAGetFirstMode ENDP
_TEXT	ENDS
PUBLIC	EAGetNext
; Function compile flags: /Ogspy
;	COMDAT EAGetNext
_TEXT	SEGMENT
previousEA$ = 8
EAGetNext PROC						; COMDAT

; 386  : 	int id = previousEA + 1;

  00000	ff c1		 inc	 ecx

; 387  : 	if (EncryptionAlgorithms[id].Ciphers[0] != 0) return id;

  00002	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:EncryptionAlgorithms
  00009	48 63 c1	 movsxd	 rax, ecx
  0000c	48 c1 e0 05	 shl	 rax, 5
  00010	8b 04 10	 mov	 eax, DWORD PTR [rax+rdx]
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	23 c1		 and	 eax, ecx

; 388  : 	return 0;
; 389  : }

  00019	c3		 ret	 0
EAGetNext ENDP
_TEXT	ENDS
PUBLIC	EAGetFirst
; Function compile flags: /Ogspy
;	COMDAT EAGetFirst
_TEXT	SEGMENT
EAGetFirst PROC						; COMDAT

; 354  : 	return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 355  : }

  00005	c3		 ret	 0
EAGetFirst ENDP
_TEXT	ENDS
PUBLIC	XorKeySchedule
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\crypto\gostcipher.c
pdata	SEGMENT
$pdata$XorKeySchedule DD imagerel $LN17
	DD	imagerel $LN17+197
	DD	imagerel $unwind$XorKeySchedule
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$XorKeySchedule DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
xdata	ENDS
;	COMDAT XorKeySchedule
_TEXT	SEGMENT
cipher$ = 64
ks$ = 72
out_ks$ = 80
data$ = 88
len$ = 96
XorKeySchedule PROC					; COMDAT

; 329  : {

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 330  : 	switch (cipher)

  00006	83 e9 01	 sub	 ecx, 1
  00009	49 8b d9	 mov	 rbx, r9
  0000c	4d 8b d0	 mov	 r10, r8
  0000f	4c 8b da	 mov	 r11, rdx
  00012	74 3a		 je	 SHORT $LN3@XorKeySche
  00014	83 f9 01	 cmp	 ecx, 1
  00017	74 1f		 je	 SHORT $LN2@XorKeySche

; 338  : 	default:
; 339  : 		GST_THROW_FATAL_EXCEPTION;

  00019	45 33 c9	 xor	 r9d, r9d
  0001c	45 33 c0	 xor	 r8d, r8d
  0001f	ba 53 01 00 00	 mov	 edx, 339		; 00000153H
  00024	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00028	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00037	cc		 int	 3
$LN2@XorKeySche:

; 334  : 		break;
; 335  : 	case GRASSHOPPER:
; 336  : 		grasshopper_xor_ks(ks, out_ks, data, len / sizeof(__int32));

  00038	41 b9 02 00 00
	00		 mov	 r9d, 2
  0003e	4c 8b c3	 mov	 r8, rbx
  00041	49 8b d2	 mov	 rdx, r10
  00044	49 8b cb	 mov	 rcx, r11
  00047	e8 00 00 00 00	 call	 grasshopper_xor_ks

; 337  : 		break;

  0004c	eb 71		 jmp	 SHORT $LN8@XorKeySche
$LN3@XorKeySche:

; 331  : 	{
; 332  : 	case GOST:
; 333  : 		gost_xor_ks(ks, out_ks, data, len / sizeof(__int32));

  0004e	8b 02		 mov	 eax, DWORD PTR [rdx]
  00050	41 33 01	 xor	 eax, DWORD PTR [r9]
  00053	41 89 00	 mov	 DWORD PTR [r8], eax
  00056	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00059	41 33 01	 xor	 eax, DWORD PTR [r9]
  0005c	41 89 40 04	 mov	 DWORD PTR [r8+4], eax
  00060	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  00063	41 33 01	 xor	 eax, DWORD PTR [r9]
  00066	41 89 40 08	 mov	 DWORD PTR [r8+8], eax
  0006a	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]
  0006d	41 33 01	 xor	 eax, DWORD PTR [r9]
  00070	41 89 40 0c	 mov	 DWORD PTR [r8+12], eax
  00074	8b 42 10	 mov	 eax, DWORD PTR [rdx+16]
  00077	41 33 01	 xor	 eax, DWORD PTR [r9]
  0007a	41 89 40 10	 mov	 DWORD PTR [r8+16], eax
  0007e	8b 42 14	 mov	 eax, DWORD PTR [rdx+20]
  00081	41 33 01	 xor	 eax, DWORD PTR [r9]
  00084	41 89 40 14	 mov	 DWORD PTR [r8+20], eax
  00088	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  0008b	41 33 01	 xor	 eax, DWORD PTR [r9]
  0008e	41 89 40 18	 mov	 DWORD PTR [r8+24], eax
  00092	8b 42 1c	 mov	 eax, DWORD PTR [rdx+28]
  00095	41 33 01	 xor	 eax, DWORD PTR [r9]
  00098	41 89 40 1c	 mov	 DWORD PTR [r8+28], eax
  0009c	41 8b 41 04	 mov	 eax, DWORD PTR [r9+4]
  000a0	41 31 00	 xor	 DWORD PTR [r8], eax
  000a3	41 31 40 04	 xor	 DWORD PTR [r8+4], eax
  000a7	41 31 40 08	 xor	 DWORD PTR [r8+8], eax
  000ab	41 31 40 0c	 xor	 DWORD PTR [r8+12], eax
  000af	41 31 40 10	 xor	 DWORD PTR [r8+16], eax
  000b3	41 31 40 14	 xor	 DWORD PTR [r8+20], eax
  000b7	41 31 40 18	 xor	 DWORD PTR [r8+24], eax
  000bb	41 31 40 1c	 xor	 DWORD PTR [r8+28], eax
$LN8@XorKeySche:

; 340  : 	}
; 341  : }

  000bf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c3	5b		 pop	 rbx
  000c4	c3		 ret	 0
$LN16@XorKeySche:
XorKeySchedule ENDP
_TEXT	ENDS
PUBLIC	CipherSupportsIntraDataUnitParallelization
; Function compile flags: /Ogspy
;	COMDAT CipherSupportsIntraDataUnitParallelization
_TEXT	SEGMENT
cipher$ = 8
CipherSupportsIntraDataUnitParallelization PROC		; COMDAT

; 311  : 	return 0;

  00000	33 c0		 xor	 eax, eax

; 312  : }

  00002	c3		 ret	 0
CipherSupportsIntraDataUnitParallelization ENDP
_TEXT	ENDS
PUBLIC	CipherGet
; Function compile flags: /Ogspy
;	COMDAT CipherGet
_TEXT	SEGMENT
id$ = 8
CipherGet PROC						; COMDAT

; 239  : 	int i;
; 240  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Ciphers
  00006	33 d2		 xor	 edx, edx
  00008	45 33 c0	 xor	 r8d, r8d
  0000b	85 c0		 test	 eax, eax
  0000d	74 1f		 je	 SHORT $LN2@CipherGet
  0000f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:Ciphers
$LL4@CipherGet:

; 241  : 		if (Ciphers[i].Id == id)

  00016	3b c1		 cmp	 eax, ecx
  00018	74 17		 je	 SHORT $LN8@CipherGet
  0001a	49 ff c0	 inc	 r8
  0001d	ff c2		 inc	 edx
  0001f	49 8b c0	 mov	 rax, r8
  00022	48 c1 e0 05	 shl	 rax, 5
  00026	42 8b 04 08	 mov	 eax, DWORD PTR [rax+r9]
  0002a	85 c0		 test	 eax, eax
  0002c	75 e8		 jne	 SHORT $LL4@CipherGet
$LN2@CipherGet:

; 243  : 
; 244  : 	return NULL;

  0002e	33 c0		 xor	 eax, eax

; 245  : }

  00030	c3		 ret	 0
$LN8@CipherGet:

; 242  : 			return &Ciphers[i];

  00031	48 63 c2	 movsxd	 rax, edx
  00034	48 c1 e0 05	 shl	 rax, 5
  00038	49 03 c1	 add	 rax, r9

; 245  : }

  0003b	c3		 ret	 0
CipherGet ENDP
PUBLIC	crypto_close
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$crypto_close DD imagerel $LN15
	DD	imagerel $LN15+62
	DD	imagerel $unwind$crypto_close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$crypto_close DD 020a01H
	DD	07006320aH
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
xdata	ENDS
;	COMDAT crypto_close
_TEXT	SEGMENT
cryptoInfo$ = 48
crypto_close PROC					; COMDAT

; 949  : {

$LN15:

; 950  : #ifndef GST_WINDOWS_BOOT
; 951  : 
; 952  : 	if (cryptoInfo != NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 38		 je	 SHORT $LN14@crypto_clo
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 949  : {

  0000a	4c 8b c1	 mov	 r8, rcx

; 953  : 	{
; 954  : 		burn (cryptoInfo, sizeof (CRYPTO_INFO));

  0000d	4c 8b c9	 mov	 r9, rcx
  00010	48 8b f9	 mov	 rdi, rcx
  00013	ba 10 1f 00 00	 mov	 edx, 7952		; 00001f10H
  00018	33 c0		 xor	 eax, eax
  0001a	48 8b ca	 mov	 rcx, rdx
  0001d	f3 aa		 rep stosb
$LL2@crypto_clo:
  0001f	41 88 01	 mov	 BYTE PTR [r9], al
  00022	49 ff c1	 inc	 r9
  00025	83 ea 01	 sub	 edx, 1
  00028	75 f5		 jne	 SHORT $LL2@crypto_clo

; 955  : #ifndef DEVICE_DRIVER
; 956  : 		VirtualUnlock (cryptoInfo, sizeof (CRYPTO_INFO));
; 957  : #endif
; 958  : 		GSTfree (cryptoInfo);

  0002a	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0002f	49 8b c8	 mov	 rcx, r8
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 959  : 	}
; 960  : 
; 961  : #else // GST_WINDOWS_BOOT
; 962  : 
; 963  : 	burn (&CryptoInfoBuffer, sizeof (CryptoInfoBuffer));
; 964  : 	CryptoInfoBufferInUse = FALSE;
; 965  : 
; 966  : #endif // GST_WINDOWS_BOOT
; 967  : }

  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
$LN14@crypto_clo:
  0003d	c3		 ret	 0
crypto_close ENDP
_TEXT	ENDS
PUBLIC	crypto_loadkey
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$crypto_loadkey DD imagerel $LN13
	DD	imagerel $LN13+61
	DD	imagerel $unwind$crypto_loadkey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$crypto_loadkey DD 020601H
	DD	070023206H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
xdata	ENDS
;	COMDAT crypto_loadkey
_TEXT	SEGMENT
keyInfo$ = 48
lpszUserKey$ = 56
nUserKeyLen$ = 64
crypto_loadkey PROC					; COMDAT

; 934  : {

$LN13:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 935  : 	keyInfo->keyLength = nUserKeyLen;
; 936  : 	burn (keyInfo->userKey, sizeof (keyInfo->userKey));

  00006	4c 8d 59 08	 lea	 r11, QWORD PTR [rcx+8]
  0000a	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d
  0000e	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00014	49 8b fb	 mov	 rdi, r11
  00017	33 c0		 xor	 eax, eax
  00019	49 8b c9	 mov	 rcx, r9
  0001c	f3 aa		 rep stosb
  0001e	4d 8b d3	 mov	 r10, r11
$LL2@crypto_loa:
  00021	41 88 02	 mov	 BYTE PTR [r10], al
  00024	49 ff c2	 inc	 r10
  00027	41 83 e9 01	 sub	 r9d, 1
  0002b	75 f4		 jne	 SHORT $LL2@crypto_loa

; 937  : 	memcpy (keyInfo->userKey, lpszUserKey, nUserKeyLen);

  0002d	4d 63 c0	 movsxd	 r8, r8d
  00030	49 8b cb	 mov	 rcx, r11

; 938  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	e9 00 00 00 00	 jmp	 memcpy
crypto_loadkey ENDP
_TEXT	ENDS
PUBLIC	EAIsModeSupported
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAIsModeSupported DD imagerel $LN12
	DD	imagerel $LN12+73
	DD	imagerel $unwind$EAIsModeSupported
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAIsModeSupported DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAIsModeSupported
_TEXT	SEGMENT
ea$ = 48
testedMode$ = 56
EAIsModeSupported PROC					; COMDAT

; 798  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 f9	 movsxd	 rdi, ecx

; 799  : 	int mode;
; 800  : 
; 801  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  0000d	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms+16
  00014	8b da		 mov	 ebx, edx
  00016	48 8b c7	 mov	 rax, rdi
  00019	48 c1 e0 05	 shl	 rax, 5
  0001d	8b 14 08	 mov	 edx, DWORD PTR [rax+rcx]
  00020	85 d2		 test	 edx, edx
  00022	74 11		 je	 SHORT $LN2@EAIsModeSu
$LL4@EAIsModeSu:

; 802  : 	{
; 803  : 		if (mode == testedMode)

  00024	3b d3		 cmp	 edx, ebx
  00026	74 1a		 je	 SHORT $LN10@EAIsModeSu
  00028	8b cf		 mov	 ecx, edi
  0002a	e8 00 00 00 00	 call	 EAGetNextMode
  0002f	8b d0		 mov	 edx, eax
  00031	85 c0		 test	 eax, eax
  00033	75 ef		 jne	 SHORT $LL4@EAIsModeSu
$LN2@EAIsModeSu:

; 805  : 	}
; 806  : 	return FALSE;

  00035	33 c0		 xor	 eax, eax
$LN5@EAIsModeSu:

; 807  : }

  00037	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN10@EAIsModeSu:

; 804  : 			return TRUE;

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	eb ee		 jmp	 SHORT $LN5@EAIsModeSu
EAIsModeSupported ENDP
_TEXT	ENDS
PUBLIC	CipherGetKeyScheduleSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetKeyScheduleSize DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$CipherGetKeyScheduleSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetKeyScheduleSize DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CipherGetKeyScheduleSize
_TEXT	SEGMENT
cipherId$ = 48
CipherGetKeyScheduleSize PROC				; COMDAT

; 295  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 296  : 	return CipherGet (cipherId) -> KeyScheduleSize;

  00004	e8 00 00 00 00	 call	 CipherGet
  00009	8b 40 18	 mov	 eax, DWORD PTR [rax+24]

; 297  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
CipherGetKeyScheduleSize ENDP
_TEXT	ENDS
PUBLIC	CipherGetKeySize
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetKeySize DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$CipherGetKeySize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetKeySize DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CipherGetKeySize
_TEXT	SEGMENT
cipherId$ = 48
CipherGetKeySize PROC					; COMDAT

; 282  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 283  : 	return CipherGet (cipherId) -> KeySize;

  00004	e8 00 00 00 00	 call	 CipherGet
  00009	8b 40 14	 mov	 eax, DWORD PTR [rax+20]

; 284  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
CipherGetKeySize ENDP
_TEXT	ENDS
PUBLIC	CipherGetBlockSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetBlockSize DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$CipherGetBlockSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetBlockSize DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CipherGetBlockSize
_TEXT	SEGMENT
cipherId$ = 48
CipherGetBlockSize PROC					; COMDAT

; 269  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 270  : 	return CipherGet (cipherId) -> BlockSize;

  00004	e8 00 00 00 00	 call	 CipherGet
  00009	8b 40 10	 mov	 eax, DWORD PTR [rax+16]

; 271  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
CipherGetBlockSize ENDP
_TEXT	ENDS
PUBLIC	CipherGetName
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetName DD imagerel $LN3
	DD	imagerel $LN3+18
	DD	imagerel $unwind$CipherGetName
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetName DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CipherGetName
_TEXT	SEGMENT
cipherId$ = 48
CipherGetName PROC					; COMDAT

; 256  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 257  : 	return CipherGet (cipherId) -> Name;

  00004	e8 00 00 00 00	 call	 CipherGet
  00009	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 258  : }

  0000d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00011	c3		 ret	 0
CipherGetName ENDP
PUBLIC	EAGetKeyScheduleSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetKeyScheduleSize DD imagerel $LN15
	DD	imagerel $LN15+70
	DD	imagerel $unwind$EAGetKeyScheduleSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetKeyScheduleSize DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAGetKeyScheduleSize
_TEXT	SEGMENT
ea$ = 48
EAGetKeyScheduleSize PROC				; COMDAT

; 616  : {

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 63 d9	 movsxd	 rbx, ecx

; 617  : 	int i = EAGetFirstCipher(ea);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00010	48 8b c3	 mov	 rax, rbx
  00013	48 c1 e0 05	 shl	 rax, 5
  00017	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]

; 618  : 	int size = CipherGetKeyScheduleSize (i);

  0001a	e8 00 00 00 00	 call	 CipherGet
  0001f	44 8b 58 18	 mov	 r11d, DWORD PTR [rax+24]

; 619  : 
; 620  : 	while (i = EAGetNextCipher(ea, i))

  00023	eb 09		 jmp	 SHORT $LN14@EAGetKeySc
$LL2@EAGetKeySc:

; 621  : 	{
; 622  : 		size += CipherGetKeyScheduleSize (i);

  00025	e8 00 00 00 00	 call	 CipherGet
  0002a	44 03 58 18	 add	 r11d, DWORD PTR [rax+24]
$LN14@EAGetKeySc:
  0002e	8b d1		 mov	 edx, ecx
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 EAGetNextCipher
  00037	8b c8		 mov	 ecx, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 e8		 jne	 SHORT $LL2@EAGetKeySc

; 623  : 	}
; 624  : 
; 625  : 	return size;

  0003d	41 8b c3	 mov	 eax, r11d

; 626  : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
EAGetKeyScheduleSize ENDP
_TEXT	ENDS
PUBLIC	EAGetKeySize
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetKeySize DD imagerel $LN15
	DD	imagerel $LN15+70
	DD	imagerel $unwind$EAGetKeySize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetKeySize DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAGetKeySize
_TEXT	SEGMENT
ea$ = 48
EAGetKeySize PROC					; COMDAT

; 528  : {

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 63 d9	 movsxd	 rbx, ecx

; 529  : 	int i = EAGetFirstCipher (ea);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00010	48 8b c3	 mov	 rax, rbx
  00013	48 c1 e0 05	 shl	 rax, 5
  00017	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]

; 530  : 	int size = CipherGetKeySize (i);

  0001a	e8 00 00 00 00	 call	 CipherGet
  0001f	44 8b 58 14	 mov	 r11d, DWORD PTR [rax+20]

; 531  : 
; 532  : 	while (i = EAGetNextCipher (ea, i))

  00023	eb 09		 jmp	 SHORT $LN14@EAGetKeySi
$LL2@EAGetKeySi:

; 533  : 	{
; 534  : 		size += CipherGetKeySize (i);

  00025	e8 00 00 00 00	 call	 CipherGet
  0002a	44 03 58 14	 add	 r11d, DWORD PTR [rax+20]
$LN14@EAGetKeySi:
  0002e	8b d1		 mov	 edx, ecx
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 EAGetNextCipher
  00037	8b c8		 mov	 ecx, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 e8		 jne	 SHORT $LL2@EAGetKeySi

; 535  : 	}
; 536  : 
; 537  : 	return size;

  0003d	41 8b c3	 mov	 eax, r11d

; 538  : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
EAGetKeySize ENDP
_TEXT	ENDS
PUBLIC	EAGetName
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetName DD imagerel $LN19
	DD	imagerel $LN19+171
	DD	imagerel $unwind$EAGetName
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetName DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAGetName
_TEXT	SEGMENT
buf$ = 48
ea$ = 56
EAGetName PROC						; COMDAT

; 478  : {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 479  : 	int i = EAGetLastCipher(ea);

  00012	8b ca		 mov	 ecx, edx
  00014	8b da		 mov	 ebx, edx
  00016	e8 00 00 00 00	 call	 EAGetLastCipher
  0001b	8b f8		 mov	 edi, eax

; 480  : 	strcpy (buf, (i != 0) ? CipherGetName (i) : "?");

  0001d	85 c0		 test	 eax, eax
  0001f	74 0d		 je	 SHORT $LN5@EAGetName
  00021	8b c8		 mov	 ecx, eax
  00023	e8 00 00 00 00	 call	 CipherGet
  00028	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002c	eb 07		 jmp	 SHORT $LN6@EAGetName
$LN5@EAGetName:
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
$LN6@EAGetName:
  00035	48 8b d6	 mov	 rdx, rsi
$LL7@EAGetName:
  00038	8a 01		 mov	 al, BYTE PTR [rcx]
  0003a	48 ff c1	 inc	 rcx
  0003d	88 02		 mov	 BYTE PTR [rdx], al
  0003f	48 ff c2	 inc	 rdx
  00042	84 c0		 test	 al, al
  00044	75 f2		 jne	 SHORT $LL7@EAGetName

; 481  : 
; 482  : 	while (i = EAGetPreviousCipher(ea, i))

  00046	8b d7		 mov	 edx, edi
  00048	eb 40		 jmp	 SHORT $LN18@EAGetName
$LL2@EAGetName:

; 483  : 	{
; 484  : 		strcat (buf, "-");

  0004a	48 83 c9 ff	 or	 rcx, -1
  0004e	33 c0		 xor	 eax, eax
  00050	48 8b fe	 mov	 rdi, rsi
  00053	f2 ae		 repne scasb
  00055	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
  0005c	66 89 4f ff	 mov	 WORD PTR [rdi-1], cx

; 485  : 		strcat (buf, CipherGetName (i));

  00060	41 8b cb	 mov	 ecx, r11d
  00063	e8 00 00 00 00	 call	 CipherGet
  00068	48 83 c9 ff	 or	 rcx, -1
  0006c	48 8b fe	 mov	 rdi, rsi
  0006f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00073	33 c0		 xor	 eax, eax
  00075	f2 ae		 repne scasb
  00077	33 c9		 xor	 ecx, ecx
$LL16@EAGetName:
  00079	8a 04 0a	 mov	 al, BYTE PTR [rdx+rcx]
  0007c	48 ff c1	 inc	 rcx
  0007f	88 44 0f fe	 mov	 BYTE PTR [rdi+rcx-2], al
  00083	84 c0		 test	 al, al
  00085	75 f2		 jne	 SHORT $LL16@EAGetName

; 481  : 
; 482  : 	while (i = EAGetPreviousCipher(ea, i))

  00087	41 8b d3	 mov	 edx, r11d
$LN18@EAGetName:
  0008a	8b cb		 mov	 ecx, ebx
  0008c	e8 00 00 00 00	 call	 EAGetPreviousCipher
  00091	44 8b d8	 mov	 r11d, eax
  00094	85 c0		 test	 eax, eax
  00096	75 b2		 jne	 SHORT $LL2@EAGetName

; 486  : 	}
; 487  : 
; 488  : 	return buf;
; 489  : }

  00098	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009d	48 8b c6	 mov	 rax, rsi
  000a0	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
EAGetName ENDP
PUBLIC	EAGetLargestKeyForMode
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetLargestKeyForMode DD imagerel $LN15
	DD	imagerel $LN15+121
	DD	imagerel $unwind$EAGetLargestKeyForMode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetLargestKeyForMode DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAGetLargestKeyForMode
_TEXT	SEGMENT
mode$ = 48
EAGetLargestKeyForMode PROC				; COMDAT

; 639  : {

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 640  : 	int ea, key = 0;

  00014	33 ff		 xor	 edi, edi
  00016	8b e9		 mov	 ebp, ecx

; 641  : 
; 642  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00018	8d 5f 01	 lea	 ebx, QWORD PTR [rdi+1]
  0001b	48 8b f3	 mov	 rsi, rbx
$LL11@EAGetLarge:

; 643  : 	{
; 644  : 		if (!EAIsModeSupported (ea, mode))

  0001e	8b d5		 mov	 edx, ebp
  00020	8b cb		 mov	 ecx, ebx
  00022	e8 00 00 00 00	 call	 EAIsModeSupported
  00027	85 c0		 test	 eax, eax
  00029	74 14		 je	 SHORT $LN4@EAGetLarge

; 645  : 			continue;
; 646  : 
; 647  : 		if (EAGetKeySize (ea) >= key)

  0002b	8b cb		 mov	 ecx, ebx
  0002d	e8 00 00 00 00	 call	 EAGetKeySize
  00032	3b c7		 cmp	 eax, edi
  00034	7c 09		 jl	 SHORT $LN4@EAGetLarge

; 648  : 			key = EAGetKeySize (ea);

  00036	8b cb		 mov	 ecx, ebx
  00038	e8 00 00 00 00	 call	 EAGetKeySize
  0003d	8b f8		 mov	 edi, eax
$LN4@EAGetLarge:
  0003f	48 ff c6	 inc	 rsi
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:EncryptionAlgorithms
  00049	48 8b ce	 mov	 rcx, rsi
  0004c	48 c1 e1 05	 shl	 rcx, 5
  00050	83 3c 11 00	 cmp	 DWORD PTR [rcx+rdx], 0
  00054	74 04		 je	 SHORT $LN10@EAGetLarge

; 641  : 
; 642  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00056	ff c3		 inc	 ebx
  00058	eb 04		 jmp	 SHORT $LN14@EAGetLarge
$LN10@EAGetLarge:
  0005a	33 db		 xor	 ebx, ebx
  0005c	33 f6		 xor	 esi, esi
$LN14@EAGetLarge:
  0005e	85 db		 test	 ebx, ebx
  00060	75 bc		 jne	 SHORT $LL11@EAGetLarge

; 649  : 	}
; 650  : 	return key;
; 651  : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00071	8b c7		 mov	 eax, edi
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
EAGetLargestKeyForMode ENDP
_TEXT	ENDS
PUBLIC	DecipherBlock
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecipherBlock DD imagerel $LN9
	DD	imagerel $LN9+77
	DD	imagerel $unwind$DecipherBlock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecipherBlock DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecipherBlock
_TEXT	SEGMENT
cipher$ = 64
data$ = 72
ks$ = 80
DecipherBlock PROC					; COMDAT

; 187  : {

$LN9:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 188  : 	switch (cipher)

  00004	83 e9 01	 sub	 ecx, 1
  00007	4d 8b d0	 mov	 r10, r8
  0000a	4c 8b ca	 mov	 r9, rdx
  0000d	74 31		 je	 SHORT $LN3@DecipherBl
  0000f	83 f9 01	 cmp	 ecx, 1
  00012	74 1f		 je	 SHORT $LN2@DecipherBl

; 196  : 	default:		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00014	45 33 c9	 xor	 r9d, r9d
  00017	45 33 c0	 xor	 r8d, r8d
  0001a	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  0001f	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00023	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00032	cc		 int	 3
$LN2@DecipherBl:

; 192  : 		break;
; 193  : 	case GRASSHOPPER:
; 194  : 		grasshopper_decrypt(ks, (unsigned long*)data, (unsigned long*)data);

  00033	4c 8b c2	 mov	 r8, rdx
  00036	49 8b ca	 mov	 rcx, r10
  00039	e8 00 00 00 00	 call	 grasshopper_decrypt

; 195  : 		break;

  0003e	eb 08		 jmp	 SHORT $LN4@DecipherBl
$LN3@DecipherBl:

; 189  : 	{
; 190  : 	case GOST:
; 191  : 		gost_decrypt((byte *)data, (byte *)data, ks);

  00040	49 8b c9	 mov	 rcx, r9
  00043	e8 00 00 00 00	 call	 gost_decrypt
$LN4@DecipherBl:

; 197  : 	}
; 198  : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
$LN8@DecipherBl:
DecipherBlock ENDP
_TEXT	ENDS
PUBLIC	EncipherBlock
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncipherBlock DD imagerel $LN9
	DD	imagerel $LN9+76
	DD	imagerel $unwind$EncipherBlock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncipherBlock DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncipherBlock
_TEXT	SEGMENT
cipher$ = 64
data$ = 72
ks$ = 80
EncipherBlock PROC					; COMDAT

; 137  : {

$LN9:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 138  : 	switch (cipher)

  00004	83 e9 01	 sub	 ecx, 1
  00007	4d 8b d0	 mov	 r10, r8
  0000a	4c 8b ca	 mov	 r9, rdx
  0000d	74 30		 je	 SHORT $LN3@EncipherBl
  0000f	83 f9 01	 cmp	 ecx, 1
  00012	74 1e		 je	 SHORT $LN2@EncipherBl

; 146  : 	default:			GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00014	ba 92 00 00 00	 mov	 edx, 146		; 00000092H
  00019	45 33 c9	 xor	 r9d, r9d
  0001c	45 33 c0	 xor	 r8d, r8d
  0001f	8d 4a 97	 lea	 ecx, QWORD PTR [rdx-105]
  00022	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00031	cc		 int	 3
$LN2@EncipherBl:

; 142  : 		break;
; 143  : 	case GRASSHOPPER:
; 144  : 		grasshopper_encrypt(ks, (unsigned long *)data, (unsigned long *)data);

  00032	4c 8b c2	 mov	 r8, rdx
  00035	49 8b ca	 mov	 rcx, r10
  00038	e8 00 00 00 00	 call	 grasshopper_encrypt

; 145  : 		break;

  0003d	eb 08		 jmp	 SHORT $LN4@EncipherBl
$LN3@EncipherBl:

; 139  : 	{
; 140  : 	case GOST:
; 141  : 		gost_encrypt((byte *)data, (byte *)data, ks);

  0003f	49 8b c9	 mov	 rcx, r9
  00042	e8 00 00 00 00	 call	 gost_encrypt
$LN4@EncipherBl:

; 147  : 	}
; 148  : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
$LN8@EncipherBl:
EncipherBlock ENDP
PUBLIC	GetMaxPkcs5OutSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetMaxPkcs5OutSize DD imagerel $LN7
	DD	imagerel $LN7+75
	DD	imagerel $unwind$GetMaxPkcs5OutSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetMaxPkcs5OutSize DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetMaxPkcs5OutSize
_TEXT	SEGMENT
GetMaxPkcs5OutSize PROC					; COMDAT

; 1319 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1320 : 	int size = 32;

  00006	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H

; 1321 : 
; 1322 : 	size = max (size, EAGetLargestKeyForMode (XTS) * 2);	// Sizes of primary + secondary keys

  0000b	8d 4b e1	 lea	 ecx, QWORD PTR [rbx-31]
  0000e	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  00013	03 c0		 add	 eax, eax
  00015	3b c3		 cmp	 eax, ebx
  00017	7c 0c		 jl	 SHORT $LN4@GetMaxPkcs
  00019	8d 4b e1	 lea	 ecx, QWORD PTR [rbx-31]
  0001c	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  00021	8b d8		 mov	 ebx, eax
  00023	03 db		 add	 ebx, ebx
$LN4@GetMaxPkcs:

; 1323 : 	size = max (size, EAGetLargestKeyForMode (XTS8) * 2);

  00025	b9 02 00 00 00	 mov	 ecx, 2
  0002a	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  0002f	03 c0		 add	 eax, eax
  00031	3b d8		 cmp	 ebx, eax
  00033	7f 0e		 jg	 SHORT $LN6@GetMaxPkcs
  00035	b9 02 00 00 00	 mov	 ecx, 2
  0003a	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  0003f	8b d8		 mov	 ebx, eax
  00041	03 db		 add	 ebx, ebx
$LN6@GetMaxPkcs:

; 1324 : 
; 1325 : 	return size;

  00043	8b c3		 mov	 eax, ebx

; 1326 : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
GetMaxPkcs5OutSize ENDP
_TEXT	ENDS
PUBLIC	DecipherBlocks
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecipherBlocks DD imagerel $LN10
	DD	imagerel $LN10+99
	DD	imagerel $unwind$DecipherBlocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecipherBlocks DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0c0153219H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecipherBlocks
_TEXT	SEGMENT
cipher$ = 48
dataPtr$ = 56
ks$ = 64
blockCount$ = 72
DecipherBlocks PROC					; COMDAT

; 214  : {

$LN10:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	49 8b d9	 mov	 rbx, r9
  0001c	49 8b e8	 mov	 rbp, r8
  0001f	48 8b fa	 mov	 rdi, rdx
  00022	8b f1		 mov	 esi, ecx

; 215  : 	byte *data = dataPtr;
; 216  : 	size_t blockSize = CipherGetBlockSize (cipher);

  00024	e8 00 00 00 00	 call	 CipherGet
  00029	4c 63 60 10	 movsxd	 r12, DWORD PTR [rax+16]

; 217  : 	while (blockCount-- > 0)

  0002d	48 85 db	 test	 rbx, rbx
  00030	74 16		 je	 SHORT $LN8@DecipherBl@2
$LL2@DecipherBl@2:

; 218  : 	{
; 219  : 		DecipherBlock (cipher, data, ks);

  00032	4c 8b c5	 mov	 r8, rbp
  00035	48 8b d7	 mov	 rdx, rdi
  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 DecipherBlock

; 220  : 		data += blockSize;

  0003f	49 03 fc	 add	 rdi, r12
  00042	48 83 eb 01	 sub	 rbx, 1
  00046	75 ea		 jne	 SHORT $LL2@DecipherBl@2
$LN8@DecipherBl@2:

; 221  : 	}
; 222  : }

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00052	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00057	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	41 5c		 pop	 r12
  00062	c3		 ret	 0
DecipherBlocks ENDP
_TEXT	ENDS
PUBLIC	EncipherBlocks
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncipherBlocks DD imagerel $LN10
	DD	imagerel $LN10+99
	DD	imagerel $unwind$EncipherBlocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncipherBlocks DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0c0153219H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncipherBlocks
_TEXT	SEGMENT
cipher$ = 48
dataPtr$ = 56
ks$ = 64
blockCount$ = 72
EncipherBlocks PROC					; COMDAT

; 164  : {

$LN10:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	49 8b d9	 mov	 rbx, r9
  0001c	49 8b e8	 mov	 rbp, r8
  0001f	48 8b fa	 mov	 rdi, rdx
  00022	8b f1		 mov	 esi, ecx

; 165  : 	byte *data = dataPtr;
; 166  : 	size_t blockSize = CipherGetBlockSize (cipher);

  00024	e8 00 00 00 00	 call	 CipherGet
  00029	4c 63 60 10	 movsxd	 r12, DWORD PTR [rax+16]

; 167  : 	while (blockCount-- > 0)

  0002d	48 85 db	 test	 rbx, rbx
  00030	74 16		 je	 SHORT $LN8@EncipherBl@2
$LL2@EncipherBl@2:

; 168  : 	{
; 169  : 		EncipherBlock (cipher, data, ks);

  00032	4c 8b c5	 mov	 r8, rbp
  00035	48 8b d7	 mov	 rdx, rdi
  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 EncipherBlock

; 170  : 		data += blockSize;

  0003f	49 03 fc	 add	 rdi, r12
  00042	48 83 eb 01	 sub	 rbx, 1
  00046	75 ea		 jne	 SHORT $LL2@EncipherBl@2
$LN8@EncipherBl@2:

; 171  : 	}
; 172  : }

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00052	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00057	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	41 5c		 pop	 r12
  00062	c3		 ret	 0
EncipherBlocks ENDP
_TEXT	ENDS
PUBLIC	CipherInit
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherInit DD imagerel $LN8
	DD	imagerel $LN8+55
	DD	imagerel $unwind$CipherInit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherInit DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CipherInit
_TEXT	SEGMENT
cipher$ = 48
key$ = 56
ks$ = 64
CipherInit PROC						; COMDAT

; 107  : {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 108  : 	int retVal = ERR_SUCCESS;
; 109  : 
; 110  : 	switch (cipher)

  00004	83 e9 01	 sub	 ecx, 1
  00007	4c 8b ca	 mov	 r9, rdx
  0000a	74 19		 je	 SHORT $LN3@CipherInit
  0000c	83 f9 01	 cmp	 ecx, 1
  0000f	74 07		 je	 SHORT $LN2@CipherInit

; 118  : 	default:
; 119  : 		// Unknown/wrong cipher ID
; 120  : 		return ERR_CIPHER_INIT_FAILURE;

  00011	b8 11 00 00 00	 mov	 eax, 17
  00016	eb 1a		 jmp	 SHORT $LN6@CipherInit
$LN2@CipherInit:

; 114  : 		break;
; 115  : 	case GRASSHOPPER:
; 116  : 		grasshopper_set_key((unsigned long *)key, (grasshopper_kds*)ks);

  00018	49 8b d0	 mov	 rdx, r8
  0001b	49 8b c9	 mov	 rcx, r9
  0001e	e8 00 00 00 00	 call	 grasshopper_set_key

; 117  : 		break;

  00023	eb 0b		 jmp	 SHORT $LN4@CipherInit
$LN3@CipherInit:

; 111  : 	{
; 112  : 	case GOST:
; 113  : 		gost_set_key(key, (gost_kds *)ks);

  00025	49 8b d0	 mov	 rdx, r8
  00028	49 8b c9	 mov	 rcx, r9
  0002b	e8 00 00 00 00	 call	 gost_set_key
$LN4@CipherInit:

; 121  : 	}
; 122  : 
; 123  : 	return retVal;

  00030	33 c0		 xor	 eax, eax
$LN6@CipherInit:

; 124  : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
CipherInit ENDP
PUBLIC	DecryptDataUnitsCurrentThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptDataUnitsCurrentThread DD imagerel $LN33
	DD	imagerel $LN33+361
	DD	imagerel $unwind$DecryptDataUnitsCurrentThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptDataUnitsCurrentThread DD 0c1d01H
	DD	0f741dH
	DD	0e641dH
	DD	0d541dH
	DD	0c341dH
	DD	0e019721dH
	DD	0c015d017H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptDataUnitsCurrentThread
_TEXT	SEGMENT
buf$ = 96
structUnitNo$ = 104
nbrUnits$ = 112
ci$ = 120
DecryptDataUnitsCurrentThread PROC			; COMDAT

; 1259 : {

$LN33:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 55		 push	 r13
  00017	41 56		 push	 r14
  00019	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1260 : 	int ea = ci->ea;
; 1261 : 	unsigned __int8 *ks = ci->ks;
; 1262 : 	unsigned __int8 *ks2 = ci->ks2;
; 1263 : 	int cipher;
; 1264 : 
; 1265 : 	switch (ci->mode)

  0001d	45 8b 51 04	 mov	 r10d, DWORD PTR [r9+4]
  00021	41 8b 39	 mov	 edi, DWORD PTR [r9]
  00024	49 8b d8	 mov	 rbx, r8
  00027	41 83 ea 01	 sub	 r10d, 1
  0002b	4c 8b ea	 mov	 r13, rdx
  0002e	4c 8b f1	 mov	 r14, rcx
  00031	49 8d 71 08	 lea	 rsi, QWORD PTR [r9+8]
  00035	49 8d a9 28 02
	00 00		 lea	 rbp, QWORD PTR [r9+552]
  0003c	0f 84 99 00 00
	00		 je	 $LN9@DecryptDat
  00042	41 83 fa 01	 cmp	 r10d, 1
  00046	74 1e		 je	 SHORT $LN5@DecryptDat

; 1303 : 	default:		
; 1304 : 		// Unknown/wrong ID
; 1305 : 		GST_THROW_FATAL_EXCEPTION;

  00048	45 33 c9	 xor	 r9d, r9d
  0004b	45 33 c0	 xor	 r8d, r8d
  0004e	ba 19 05 00 00	 mov	 edx, 1305		; 00000519H
  00053	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00057	48 c7 40 c8 54
	53 47 00	 mov	 QWORD PTR [rax-56], 4674388 ; 00475354H
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00065	cc		 int	 3
$LN5@DecryptDat:

; 1283 : 		}
; 1284 : 		break;
; 1285 : 	case XTS8:
; 1286 : 		ks += EAGetKeyScheduleSize(ea);

  00066	8b cf		 mov	 ecx, edi
  00068	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  0006d	48 63 c8	 movsxd	 rcx, eax
  00070	48 03 f1	 add	 rsi, rcx

; 1287 : 		ks2 += EAGetKeyScheduleSize(ea);

  00073	8b cf		 mov	 ecx, edi
  00075	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  0007a	48 63 c8	 movsxd	 rcx, eax
  0007d	48 03 e9	 add	 rbp, rcx

; 1288 : 
; 1289 : 		for (cipher = EAGetLastCipher(ea); cipher != 0; cipher = EAGetPreviousCipher(ea, cipher))

  00080	8b cf		 mov	 ecx, edi
  00082	e8 00 00 00 00	 call	 EAGetLastCipher
  00087	44 8b e0	 mov	 r12d, eax
  0008a	85 c0		 test	 eax, eax
  0008c	0f 84 b8 00 00
	00		 je	 $LN6@DecryptDat
  00092	48 c1 e3 09	 shl	 rbx, 9
$LL4@DecryptDat:

; 1290 : 		{
; 1291 : 			ks -= CipherGetKeyScheduleSize(cipher);

  00096	41 8b cc	 mov	 ecx, r12d
  00099	e8 00 00 00 00	 call	 CipherGet

; 1292 : 			ks2 -= CipherGetKeyScheduleSize(cipher);
; 1293 : 
; 1294 : 			DecryptBufferXTS8Byte(buf,
; 1295 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1296 : 				structUnitNo,
; 1297 : 				0,
; 1298 : 				ks,
; 1299 : 				ks2,
; 1300 : 				cipher);

  0009e	44 89 64 24 30	 mov	 DWORD PTR [rsp+48], r12d
  000a3	45 33 c9	 xor	 r9d, r9d
  000a6	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  000aa	4d 8b c5	 mov	 r8, r13
  000ad	48 8b d3	 mov	 rdx, rbx
  000b0	48 2b e9	 sub	 rbp, rcx
  000b3	48 2b f1	 sub	 rsi, rcx
  000b6	49 8b ce	 mov	 rcx, r14
  000b9	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  000be	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000c3	e8 00 00 00 00	 call	 DecryptBufferXTS8Byte
  000c8	41 8b d4	 mov	 edx, r12d
  000cb	8b cf		 mov	 ecx, edi
  000cd	e8 00 00 00 00	 call	 EAGetPreviousCipher
  000d2	44 8b e0	 mov	 r12d, eax
  000d5	85 c0		 test	 eax, eax
  000d7	75 bd		 jne	 SHORT $LL4@DecryptDat

; 1301 : 		}
; 1302 : 		break;

  000d9	eb 6f		 jmp	 SHORT $LN6@DecryptDat
$LN9@DecryptDat:

; 1266 : 	{
; 1267 : 	case XTS:
; 1268 : 		ks += EAGetKeyScheduleSize (ea);

  000db	8b cf		 mov	 ecx, edi
  000dd	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  000e2	48 63 c8	 movsxd	 rcx, eax
  000e5	48 03 f1	 add	 rsi, rcx

; 1269 : 		ks2 += EAGetKeyScheduleSize (ea);

  000e8	8b cf		 mov	 ecx, edi
  000ea	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  000ef	48 63 c8	 movsxd	 rcx, eax
  000f2	48 03 e9	 add	 rbp, rcx

; 1270 : 
; 1271 : 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  000f5	8b cf		 mov	 ecx, edi
  000f7	e8 00 00 00 00	 call	 EAGetLastCipher
  000fc	44 8b e0	 mov	 r12d, eax
  000ff	85 c0		 test	 eax, eax
  00101	74 47		 je	 SHORT $LN6@DecryptDat
  00103	48 c1 e3 09	 shl	 rbx, 9
$LL8@DecryptDat:

; 1272 : 		{
; 1273 : 			ks -= CipherGetKeyScheduleSize (cipher);

  00107	41 8b cc	 mov	 ecx, r12d
  0010a	e8 00 00 00 00	 call	 CipherGet

; 1274 : 			ks2 -= CipherGetKeyScheduleSize (cipher);
; 1275 : 
; 1276 : 			DecryptBufferXTS (buf,
; 1277 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1278 : 				structUnitNo,
; 1279 : 				0,
; 1280 : 				ks,
; 1281 : 				ks2,
; 1282 : 				cipher);

  0010f	44 89 64 24 30	 mov	 DWORD PTR [rsp+48], r12d
  00114	45 33 c9	 xor	 r9d, r9d
  00117	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  0011b	4d 8b c5	 mov	 r8, r13
  0011e	48 8b d3	 mov	 rdx, rbx
  00121	48 2b e9	 sub	 rbp, rcx
  00124	48 2b f1	 sub	 rsi, rcx
  00127	49 8b ce	 mov	 rcx, r14
  0012a	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  0012f	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00134	e8 00 00 00 00	 call	 DecryptBufferXTSNonParallel
  00139	41 8b d4	 mov	 edx, r12d
  0013c	8b cf		 mov	 ecx, edi
  0013e	e8 00 00 00 00	 call	 EAGetPreviousCipher
  00143	44 8b e0	 mov	 r12d, eax
  00146	85 c0		 test	 eax, eax
  00148	75 bd		 jne	 SHORT $LL8@DecryptDat
$LN6@DecryptDat:

; 1306 : 	}
; 1307 : }

  0014a	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0014f	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00154	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00159	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  0015e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00162	41 5e		 pop	 r14
  00164	41 5d		 pop	 r13
  00166	41 5c		 pop	 r12
  00168	c3		 ret	 0
$LN32@DecryptDat:
DecryptDataUnitsCurrentThread ENDP
_TEXT	ENDS
PUBLIC	DecryptBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBuffer DD imagerel $LN35
	DD	imagerel $LN35+346
	DD	imagerel $unwind$DecryptBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBuffer DD 0a1801H
	DD	0f6418H
	DD	0d5418H
	DD	0c3418H
	DD	0d0147218H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptBuffer
_TEXT	SEGMENT
buf$ = 96
len$ = 104
dataUnitNo$27716 = 112
dataUnitNo$27708 = 112
cryptoInfo$ = 112
DecryptBuffer PROC					; COMDAT

; 1168 : {

$LN35:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1169 : 	switch (cryptoInfo->mode)

  00018	45 8b 48 04	 mov	 r9d, DWORD PTR [r8+4]
  0001c	49 8b d8	 mov	 rbx, r8
  0001f	48 8b fa	 mov	 rdi, rdx
  00022	41 83 e9 01	 sub	 r9d, 1
  00026	48 8b f1	 mov	 rsi, rcx
  00029	0f 84 9c 00 00
	00		 je	 $LN9@DecryptBuf@4
  0002f	41 83 f9 01	 cmp	 r9d, 1
  00033	74 1e		 je	 SHORT $LN5@DecryptBuf@4

; 1219 : 	default:		
; 1220 : 		// Unknown/wrong ID
; 1221 : 		GST_THROW_FATAL_EXCEPTION;

  00035	45 33 c9	 xor	 r9d, r9d
  00038	45 33 c0	 xor	 r8d, r8d
  0003b	ba c5 04 00 00	 mov	 edx, 1221		; 000004c5H
  00040	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00044	48 c7 40 c8 54
	53 47 00	 mov	 QWORD PTR [rax-56], 4674388 ; 00475354H
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00052	cc		 int	 3
$LN5@DecryptBuf@4:

; 1192 : 			}
; 1193 : 		}
; 1194 : 		break;
; 1195 : 	case XTS8:
; 1196 : 	{
; 1197 : 				 unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize(cryptoInfo->ea);

  00053	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00056	e8 00 00 00 00	 call	 EAGetKeyScheduleSize

; 1198 : 				 unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize(cryptoInfo->ea);

  0005b	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0005d	48 63 d0	 movsxd	 rdx, eax
  00060	4c 8d 64 1a 08	 lea	 r12, QWORD PTR [rdx+rbx+8]
  00065	e8 00 00 00 00	 call	 EAGetKeyScheduleSize

; 1199 : 				 UINT64_STRUCT dataUnitNo;
; 1200 : 				 int cipher;
; 1201 : 
; 1202 : 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1203 : 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1204 : 				 // always assumed to be aligned with the start of the data unit 0.
; 1205 : 				 dataUnitNo.LowPart = 0;
; 1206 : 				 dataUnitNo.HighPart = 0;
; 1207 : 
; 1208 : 				 for (cipher = EAGetLastCipher(cryptoInfo->ea);
; 1209 : 					 cipher != 0;
; 1210 : 					 cipher = EAGetPreviousCipher(cryptoInfo->ea, cipher))

  0006a	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0006c	83 64 24 70 00	 and	 DWORD PTR dataUnitNo$27716[rsp], 0
  00071	83 64 24 74 00	 and	 DWORD PTR dataUnitNo$27716[rsp+4], 0
  00076	48 63 d0	 movsxd	 rdx, eax
  00079	4c 8d ac 1a 28
	02 00 00	 lea	 r13, QWORD PTR [rdx+rbx+552]
  00081	e8 00 00 00 00	 call	 EAGetLastCipher
  00086	eb 3b		 jmp	 SHORT $LN33@DecryptBuf@4
$LL4@DecryptBuf@4:

; 1211 : 				 {
; 1212 : 					 ks -= CipherGetKeyScheduleSize(cipher);

  00088	8b cd		 mov	 ecx, ebp
  0008a	e8 00 00 00 00	 call	 CipherGet

; 1213 : 					 ks2 -= CipherGetKeyScheduleSize(cipher);
; 1214 : 
; 1215 : 					 DecryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  0008f	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  00093	4c 8d 44 24 70	 lea	 r8, QWORD PTR dataUnitNo$27716[rsp]
  00098	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  0009c	45 33 c9	 xor	 r9d, r9d
  0009f	48 8b d7	 mov	 rdx, rdi
  000a2	4c 2b e9	 sub	 r13, rcx
  000a5	4c 2b e1	 sub	 r12, rcx
  000a8	48 8b ce	 mov	 rcx, rsi
  000ab	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  000b0	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  000b5	e8 00 00 00 00	 call	 DecryptBufferXTS8Byte
  000ba	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  000bc	8b d5		 mov	 edx, ebp
  000be	e8 00 00 00 00	 call	 EAGetPreviousCipher
$LN33@DecryptBuf@4:
  000c3	8b e8		 mov	 ebp, eax
  000c5	85 c0		 test	 eax, eax
  000c7	75 bf		 jne	 SHORT $LL4@DecryptBuf@4

; 1216 : 				 }
; 1217 : 	}
; 1218 : 		break;

  000c9	eb 76		 jmp	 SHORT $LN6@DecryptBuf@4
$LN9@DecryptBuf@4:

; 1170 : 	{
; 1171 : 	case XTS:
; 1172 : 		{
; 1173 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  000cb	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  000ce	e8 00 00 00 00	 call	 EAGetKeyScheduleSize

; 1174 : 			unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize (cryptoInfo->ea);

  000d3	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  000d5	48 63 d0	 movsxd	 rdx, eax
  000d8	4c 8d 64 1a 08	 lea	 r12, QWORD PTR [rdx+rbx+8]
  000dd	e8 00 00 00 00	 call	 EAGetKeyScheduleSize

; 1175 : 			UINT64_STRUCT dataUnitNo;
; 1176 : 			int cipher;
; 1177 : 
; 1178 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1179 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1180 : 			// always assumed to be aligned with the start of the data unit 0.
; 1181 : 			dataUnitNo.LowPart = 0;
; 1182 : 			dataUnitNo.HighPart = 0;
; 1183 : 
; 1184 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 1185 : 				cipher != 0;
; 1186 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  000e2	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  000e4	83 64 24 70 00	 and	 DWORD PTR dataUnitNo$27708[rsp], 0
  000e9	83 64 24 74 00	 and	 DWORD PTR dataUnitNo$27708[rsp+4], 0
  000ee	48 63 d0	 movsxd	 rdx, eax
  000f1	4c 8d ac 1a 28
	02 00 00	 lea	 r13, QWORD PTR [rdx+rbx+552]
  000f9	e8 00 00 00 00	 call	 EAGetLastCipher
  000fe	eb 3b		 jmp	 SHORT $LN34@DecryptBuf@4
$LL8@DecryptBuf@4:

; 1187 : 			{
; 1188 : 				ks -= CipherGetKeyScheduleSize (cipher);

  00100	8b cd		 mov	 ecx, ebp
  00102	e8 00 00 00 00	 call	 CipherGet

; 1189 : 				ks2 -= CipherGetKeyScheduleSize (cipher);
; 1190 : 
; 1191 : 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00107	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0010b	4c 8d 44 24 70	 lea	 r8, QWORD PTR dataUnitNo$27708[rsp]
  00110	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  00114	45 33 c9	 xor	 r9d, r9d
  00117	48 8b d7	 mov	 rdx, rdi
  0011a	4c 2b e9	 sub	 r13, rcx
  0011d	4c 2b e1	 sub	 r12, rcx
  00120	48 8b ce	 mov	 rcx, rsi
  00123	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00128	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  0012d	e8 00 00 00 00	 call	 DecryptBufferXTSNonParallel
  00132	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00134	8b d5		 mov	 edx, ebp
  00136	e8 00 00 00 00	 call	 EAGetPreviousCipher
$LN34@DecryptBuf@4:
  0013b	8b e8		 mov	 ebp, eax
  0013d	85 c0		 test	 eax, eax
  0013f	75 bf		 jne	 SHORT $LL8@DecryptBuf@4
$LN6@DecryptBuf@4:

; 1222 : 	}
; 1223 : }

  00141	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00146	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0014b	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00150	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00154	41 5d		 pop	 r13
  00156	41 5c		 pop	 r12
  00158	5f		 pop	 rdi
  00159	c3		 ret	 0
$LN32@DecryptBuf@4:
DecryptBuffer ENDP
_TEXT	ENDS
PUBLIC	EncryptDataUnitsCurrentThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptDataUnitsCurrentThread DD imagerel $LN37
	DD	imagerel $LN37+315
	DD	imagerel $unwind$EncryptDataUnitsCurrentThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptDataUnitsCurrentThread DD 0c1d01H
	DD	0f741dH
	DD	0e641dH
	DD	0d541dH
	DD	0c341dH
	DD	0e019721dH
	DD	0c015d017H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptDataUnitsCurrentThread
_TEXT	SEGMENT
buf$ = 96
structUnitNo$ = 104
nbrUnits$ = 112
ci$ = 120
EncryptDataUnitsCurrentThread PROC			; COMDAT

; 1112 : {

$LN37:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 55		 push	 r13
  00017	41 56		 push	 r14
  00019	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1113 : 	int ea = ci->ea;
; 1114 : 	unsigned __int8 *ks = ci->ks;
; 1115 : 	unsigned __int8 *ks2 = ci->ks2;
; 1116 : 	int cipher;
; 1117 : 
; 1118 : 	switch (ci->mode)

  0001d	45 8b 51 04	 mov	 r10d, DWORD PTR [r9+4]
  00021	49 63 39	 movsxd	 rdi, DWORD PTR [r9]
  00024	49 8b d8	 mov	 rbx, r8
  00027	41 83 ea 01	 sub	 r10d, 1
  0002b	4c 8b ea	 mov	 r13, rdx
  0002e	4c 8b f1	 mov	 r14, rcx
  00031	49 8d 69 08	 lea	 rbp, QWORD PTR [r9+8]
  00035	4d 8d a1 28 02
	00 00		 lea	 r12, QWORD PTR [r9+552]
  0003c	0f 84 82 00 00
	00		 je	 $LN9@EncryptDat
  00042	41 83 fa 01	 cmp	 r10d, 1
  00046	74 1e		 je	 SHORT $LN5@EncryptDat

; 1150 : 	default:		
; 1151 : 		// Unknown/wrong ID
; 1152 : 		GST_THROW_FATAL_EXCEPTION;

  00048	45 33 c9	 xor	 r9d, r9d
  0004b	45 33 c0	 xor	 r8d, r8d
  0004e	ba 80 04 00 00	 mov	 edx, 1152		; 00000480H
  00053	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00057	48 c7 40 c8 54
	53 47 00	 mov	 QWORD PTR [rax-56], 4674388 ; 00475354H
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00065	cc		 int	 3
$LN5@EncryptDat:

; 1133 : 		}
; 1134 : 		break;
; 1135 : 	case XTS8:
; 1136 : 		for (cipher = EAGetFirstCipher(ea); cipher != 0; cipher = EAGetNextCipher(ea, cipher))

  00066	48 8b c7	 mov	 rax, rdi
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00070	48 c1 e0 05	 shl	 rax, 5
  00074	8b 34 08	 mov	 esi, DWORD PTR [rax+rcx]
  00077	85 f6		 test	 esi, esi
  00079	0f 84 9d 00 00
	00		 je	 $LN6@EncryptDat
  0007f	48 c1 e3 09	 shl	 rbx, 9
$LL4@EncryptDat:

; 1137 : 		{
; 1138 : 			EncryptBufferXTS8Byte(buf,
; 1139 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1140 : 				structUnitNo,
; 1141 : 				0,
; 1142 : 				ks,
; 1143 : 				ks2,
; 1144 : 				cipher);

  00083	89 74 24 30	 mov	 DWORD PTR [rsp+48], esi
  00087	45 33 c9	 xor	 r9d, r9d
  0008a	4d 8b c5	 mov	 r8, r13
  0008d	48 8b d3	 mov	 rdx, rbx
  00090	49 8b ce	 mov	 rcx, r14
  00093	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00098	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0009d	e8 00 00 00 00	 call	 EncryptBufferXTS8Byte

; 1145 : 
; 1146 : 			ks += CipherGetKeyScheduleSize(cipher);

  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 CipherGet
  000a9	8b d6		 mov	 edx, esi
  000ab	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  000af	48 03 e9	 add	 rbp, rcx

; 1147 : 			ks2 += CipherGetKeyScheduleSize(cipher);

  000b2	4c 03 e1	 add	 r12, rcx
  000b5	8b cf		 mov	 ecx, edi
  000b7	e8 00 00 00 00	 call	 EAGetNextCipher
  000bc	8b f0		 mov	 esi, eax
  000be	85 c0		 test	 eax, eax
  000c0	75 c1		 jne	 SHORT $LL4@EncryptDat

; 1148 : 		}
; 1149 : 		break;

  000c2	eb 58		 jmp	 SHORT $LN6@EncryptDat
$LN9@EncryptDat:

; 1119 : 	{
; 1120 : 	case XTS:
; 1121 : 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  000c4	48 8b c7	 mov	 rax, rdi
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  000ce	48 c1 e0 05	 shl	 rax, 5
  000d2	8b 34 08	 mov	 esi, DWORD PTR [rax+rcx]
  000d5	85 f6		 test	 esi, esi
  000d7	74 43		 je	 SHORT $LN6@EncryptDat
  000d9	48 c1 e3 09	 shl	 rbx, 9
$LL8@EncryptDat:

; 1122 : 		{
; 1123 : 			EncryptBufferXTS (buf,
; 1124 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1125 : 				structUnitNo,
; 1126 : 				0,
; 1127 : 				ks,
; 1128 : 				ks2,
; 1129 : 				cipher);

  000dd	89 74 24 30	 mov	 DWORD PTR [rsp+48], esi
  000e1	45 33 c9	 xor	 r9d, r9d
  000e4	4d 8b c5	 mov	 r8, r13
  000e7	48 8b d3	 mov	 rdx, rbx
  000ea	49 8b ce	 mov	 rcx, r14
  000ed	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  000f2	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  000f7	e8 00 00 00 00	 call	 EncryptBufferXTSNonParallel

; 1130 : 
; 1131 : 			ks += CipherGetKeyScheduleSize (cipher);

  000fc	8b ce		 mov	 ecx, esi
  000fe	e8 00 00 00 00	 call	 CipherGet
  00103	8b d6		 mov	 edx, esi
  00105	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  00109	48 03 e9	 add	 rbp, rcx

; 1132 : 			ks2 += CipherGetKeyScheduleSize (cipher);

  0010c	4c 03 e1	 add	 r12, rcx
  0010f	8b cf		 mov	 ecx, edi
  00111	e8 00 00 00 00	 call	 EAGetNextCipher
  00116	8b f0		 mov	 esi, eax
  00118	85 c0		 test	 eax, eax
  0011a	75 c1		 jne	 SHORT $LL8@EncryptDat
$LN6@EncryptDat:

; 1153 : 	}
; 1154 : }

  0011c	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00121	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00126	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  0012b	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  00130	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00134	41 5e		 pop	 r14
  00136	41 5d		 pop	 r13
  00138	41 5c		 pop	 r12
  0013a	c3		 ret	 0
$LN36@EncryptDat:
EncryptDataUnitsCurrentThread ENDP
_TEXT	ENDS
PUBLIC	EncryptBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBuffer DD imagerel $LN37
	DD	imagerel $LN37+328
	DD	imagerel $unwind$EncryptBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBuffer DD 0a1801H
	DD	0f6418H
	DD	0d5418H
	DD	0c3418H
	DD	0d0147218H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptBuffer
_TEXT	SEGMENT
buf$ = 96
len$ = 104
dataUnitNo$27651 = 112
dataUnitNo$27643 = 112
cryptoInfo$ = 112
EncryptBuffer PROC					; COMDAT

; 1023 : {

$LN37:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00018	49 8b d8	 mov	 rbx, r8

; 1024 : 	switch (cryptoInfo->mode)

  0001b	45 8b 40 04	 mov	 r8d, DWORD PTR [r8+4]
  0001f	4c 8b e2	 mov	 r12, rdx
  00022	41 83 e8 01	 sub	 r8d, 1
  00026	4c 8b e9	 mov	 r13, rcx
  00029	0f 84 95 00 00
	00		 je	 $LN9@EncryptBuf@4
  0002f	41 83 f8 01	 cmp	 r8d, 1
  00033	74 1e		 je	 SHORT $LN5@EncryptBuf@4

; 1074 : 
; 1075 : 	default:		
; 1076 : 		// Unknown/wrong ID
; 1077 : 		GST_THROW_FATAL_EXCEPTION;

  00035	45 33 c9	 xor	 r9d, r9d
  00038	45 33 c0	 xor	 r8d, r8d
  0003b	ba 35 04 00 00	 mov	 edx, 1077		; 00000435H
  00040	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00044	48 c7 40 c8 54
	53 47 00	 mov	 QWORD PTR [rax-56], 4674388 ; 00475354H
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00052	cc		 int	 3
$LN5@EncryptBuf@4:

; 1047 : 			}
; 1048 : 		}
; 1049 : 		break;
; 1050 : 	case XTS8:
; 1051 : 		{
; 1052 : 				 unsigned __int8 *ks = cryptoInfo->ks;
; 1053 : 				 unsigned __int8 *ks2 = cryptoInfo->ks2;
; 1054 : 				 UINT64_STRUCT dataUnitNo;
; 1055 : 				 int cipher;
; 1056 : 
; 1057 : 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1058 : 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1059 : 				 // always assumed to be aligned with the start of a data unit.
; 1060 : 				 dataUnitNo.LowPart = 0;
; 1061 : 				 dataUnitNo.HighPart = 0;
; 1062 : 
; 1063 : 				 for (cipher = EAGetFirstCipher(cryptoInfo->ea);
; 1064 : 					 cipher != 0;
; 1065 : 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))

  00053	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  00056	83 64 24 70 00	 and	 DWORD PTR dataUnitNo$27651[rsp], 0
  0005b	83 64 24 74 00	 and	 DWORD PTR dataUnitNo$27651[rsp+4], 0
  00060	48 c1 e0 05	 shl	 rax, 5
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0006b	48 8d 73 08	 lea	 rsi, QWORD PTR [rbx+8]
  0006f	8b 3c 08	 mov	 edi, DWORD PTR [rax+rcx]
  00072	48 8d ab 28 02
	00 00		 lea	 rbp, QWORD PTR [rbx+552]
  00079	85 ff		 test	 edi, edi
  0007b	0f 84 ae 00 00
	00		 je	 $LN6@EncryptBuf@4
$LL4@EncryptBuf@4:

; 1066 : 				 {
; 1067 : 					 EncryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00081	89 7c 24 30	 mov	 DWORD PTR [rsp+48], edi
  00085	4c 8d 44 24 70	 lea	 r8, QWORD PTR dataUnitNo$27651[rsp]
  0008a	45 33 c9	 xor	 r9d, r9d
  0008d	49 8b d4	 mov	 rdx, r12
  00090	49 8b cd	 mov	 rcx, r13
  00093	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  00098	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0009d	e8 00 00 00 00	 call	 EncryptBufferXTS8Byte

; 1068 : 
; 1069 : 					 ks += CipherGetKeyScheduleSize(cipher);

  000a2	8b cf		 mov	 ecx, edi
  000a4	e8 00 00 00 00	 call	 CipherGet
  000a9	8b d7		 mov	 edx, edi
  000ab	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  000af	48 03 f1	 add	 rsi, rcx

; 1070 : 					 ks2 += CipherGetKeyScheduleSize(cipher);

  000b2	48 03 e9	 add	 rbp, rcx
  000b5	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  000b7	e8 00 00 00 00	 call	 EAGetNextCipher
  000bc	8b f8		 mov	 edi, eax
  000be	85 c0		 test	 eax, eax
  000c0	75 bf		 jne	 SHORT $LL4@EncryptBuf@4

; 1071 : 				 }
; 1072 : 		}
; 1073 : 		break;

  000c2	eb 6b		 jmp	 SHORT $LN6@EncryptBuf@4
$LN9@EncryptBuf@4:

; 1025 : 	{
; 1026 : 	case XTS:
; 1027 : 		{
; 1028 : 			unsigned __int8 *ks = cryptoInfo->ks;
; 1029 : 			unsigned __int8 *ks2 = cryptoInfo->ks2;
; 1030 : 			UINT64_STRUCT dataUnitNo;
; 1031 : 			int cipher;
; 1032 : 
; 1033 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1034 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1035 : 			// always assumed to be aligned with the start of a data unit.
; 1036 : 			dataUnitNo.LowPart = 0;
; 1037 : 			dataUnitNo.HighPart = 0;
; 1038 : 
; 1039 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1040 : 				cipher != 0;
; 1041 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  000c4	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  000c7	83 64 24 70 00	 and	 DWORD PTR dataUnitNo$27643[rsp], 0
  000cc	83 64 24 74 00	 and	 DWORD PTR dataUnitNo$27643[rsp+4], 0
  000d1	48 c1 e0 05	 shl	 rax, 5
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  000dc	48 8d 73 08	 lea	 rsi, QWORD PTR [rbx+8]
  000e0	8b 3c 08	 mov	 edi, DWORD PTR [rax+rcx]
  000e3	48 8d ab 28 02
	00 00		 lea	 rbp, QWORD PTR [rbx+552]
  000ea	85 ff		 test	 edi, edi
  000ec	74 41		 je	 SHORT $LN6@EncryptBuf@4
$LL8@EncryptBuf@4:

; 1042 : 			{
; 1043 : 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  000ee	89 7c 24 30	 mov	 DWORD PTR [rsp+48], edi
  000f2	4c 8d 44 24 70	 lea	 r8, QWORD PTR dataUnitNo$27643[rsp]
  000f7	45 33 c9	 xor	 r9d, r9d
  000fa	49 8b d4	 mov	 rdx, r12
  000fd	49 8b cd	 mov	 rcx, r13
  00100	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  00105	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0010a	e8 00 00 00 00	 call	 EncryptBufferXTSNonParallel

; 1044 : 
; 1045 : 				ks += CipherGetKeyScheduleSize (cipher);

  0010f	8b cf		 mov	 ecx, edi
  00111	e8 00 00 00 00	 call	 CipherGet
  00116	8b d7		 mov	 edx, edi
  00118	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  0011c	48 03 f1	 add	 rsi, rcx

; 1046 : 				ks2 += CipherGetKeyScheduleSize (cipher);

  0011f	48 03 e9	 add	 rbp, rcx
  00122	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00124	e8 00 00 00 00	 call	 EAGetNextCipher
  00129	8b f8		 mov	 edi, eax
  0012b	85 c0		 test	 eax, eax
  0012d	75 bf		 jne	 SHORT $LL8@EncryptBuf@4
$LN6@EncryptBuf@4:

; 1078 : 	}
; 1079 : }

  0012f	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00134	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00139	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  0013e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00142	41 5d		 pop	 r13
  00144	41 5c		 pop	 r12
  00146	5f		 pop	 rdi
  00147	c3		 ret	 0
$LN36@EncryptBuf@4:
EncryptBuffer ENDP
_TEXT	ENDS
PUBLIC	EAInit
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAInit DD imagerel $LN29
	DD	imagerel $LN29+191
	DD	imagerel $unwind$EAInit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAInit DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0c0153219H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAInit
_TEXT	SEGMENT
ea$ = 48
key$ = 56
ks$ = 64
EAInit	PROC						; COMDAT

; 404  : {

$LN29:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	4c 63 e1	 movsxd	 r12, ecx

; 405  : 	int c, retVal = ERR_SUCCESS;
; 406  : 
; 407  : 	if (ea == 0)
; 408  : 		return ERR_CIPHER_INIT_FAILURE;
; 409  : 
; 410  : 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))

  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00023	33 ff		 xor	 edi, edi
  00025	49 8b c4	 mov	 rax, r12
  00028	49 8b f0	 mov	 rsi, r8
  0002b	48 8b ea	 mov	 rbp, rdx
  0002e	48 c1 e0 05	 shl	 rax, 5
  00032	8b 1c 08	 mov	 ebx, DWORD PTR [rax+rcx]
  00035	85 db		 test	 ebx, ebx
  00037	74 62		 je	 SHORT $LN5@EAInit
$LL7@EAInit:

; 411  : 	{
; 412  : 		switch (CipherInit (c, key, ks))

  00039	8b cb		 mov	 ecx, ebx
  0003b	83 e9 01	 sub	 ecx, 1
  0003e	74 19		 je	 SHORT $LN18@EAInit
  00040	83 f9 01	 cmp	 ecx, 1
  00043	74 07		 je	 SHORT $LN17@EAInit
  00045	b9 11 00 00 00	 mov	 ecx, 17
  0004a	eb 1a		 jmp	 SHORT $LN21@EAInit
$LN17@EAInit:
  0004c	48 8b d6	 mov	 rdx, rsi
  0004f	48 8b cd	 mov	 rcx, rbp
  00052	e8 00 00 00 00	 call	 grasshopper_set_key
  00057	eb 0b		 jmp	 SHORT $LN19@EAInit
$LN18@EAInit:
  00059	48 8b d6	 mov	 rdx, rsi
  0005c	48 8b cd	 mov	 rcx, rbp
  0005f	e8 00 00 00 00	 call	 gost_set_key
$LN19@EAInit:
  00064	33 c9		 xor	 ecx, ecx
$LN21@EAInit:
  00066	83 e9 11	 sub	 ecx, 17
  00069	74 4d		 je	 SHORT $LN2@EAInit
  0006b	83 f9 01	 cmp	 ecx, 1
  0006e	75 03		 jne	 SHORT $LN3@EAInit

; 416  : 
; 417  : 		case ERR_CIPHER_INIT_WEAK_KEY:
; 418  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  00070	8d 79 11	 lea	 edi, QWORD PTR [rcx+17]
$LN3@EAInit:

; 419  : 			break;
; 420  : 		}
; 421  : 
; 422  : 		key += CipherGetKeySize (c);

  00073	8b cb		 mov	 ecx, ebx
  00075	e8 00 00 00 00	 call	 CipherGet
  0007a	8b d3		 mov	 edx, ebx
  0007c	48 8b c8	 mov	 rcx, rax
  0007f	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  00083	48 03 e8	 add	 rbp, rax

; 423  : 		ks += CipherGetKeyScheduleSize (c);

  00086	48 63 41 18	 movsxd	 rax, DWORD PTR [rcx+24]
  0008a	41 8b cc	 mov	 ecx, r12d
  0008d	48 03 f0	 add	 rsi, rax
  00090	e8 00 00 00 00	 call	 EAGetNextCipher
  00095	8b d8		 mov	 ebx, eax
  00097	85 c0		 test	 eax, eax
  00099	75 9e		 jne	 SHORT $LL7@EAInit
$LN5@EAInit:

; 424  : 	}
; 425  : 	return retVal;

  0009b	8b c7		 mov	 eax, edi
$LN12@EAInit:

; 426  : }

  0009d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a2	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ac	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	41 5c		 pop	 r12
  000b7	c3		 ret	 0
$LN2@EAInit:

; 413  : 		{
; 414  : 		case ERR_CIPHER_INIT_FAILURE:
; 415  : 			return ERR_CIPHER_INIT_FAILURE;

  000b8	b8 11 00 00 00	 mov	 eax, 17
  000bd	eb de		 jmp	 SHORT $LN12@EAInit
EAInit	ENDP
PUBLIC	DecryptDataUnits
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptDataUnits DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$DecryptDataUnits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptDataUnits DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptDataUnits
_TEXT	SEGMENT
buf$ = 64
structUnitNo$ = 72
nbrUnits$ = 80
ci$ = 88
DecryptDataUnits PROC					; COMDAT

; 1240 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1241 : 	EncryptionThreadPoolDoWork (DecryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00004	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00009	45 8b c8	 mov	 r9d, r8d
  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d1	 mov	 rdx, rcx
  00012	b9 01 00 00 00	 mov	 ecx, 1
  00017	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 1242 : }

  0001c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00020	c3		 ret	 0
DecryptDataUnits ENDP
_TEXT	ENDS
PUBLIC	EncryptDataUnits
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptDataUnits DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$EncryptDataUnits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptDataUnits DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptDataUnits
_TEXT	SEGMENT
buf$ = 64
structUnitNo$ = 72
nbrUnits$ = 80
ci$ = 88
EncryptDataUnits PROC					; COMDAT

; 1096 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1097 : 	EncryptionThreadPoolDoWork (EncryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00004	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00009	45 8b c8	 mov	 r9d, r8d
  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d1	 mov	 rdx, rcx
  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 1098 : }

  00019	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001d	c3		 ret	 0
EncryptDataUnits ENDP
_TEXT	ENDS
PUBLIC	EAInitMode
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAInitMode DD imagerel $LN40
	DD	imagerel $LN40+92
	DD	imagerel $unwind$EAInitMode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAInitMode DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAInitMode
_TEXT	SEGMENT
ci$ = 64
EAInitMode PROC						; COMDAT

; 440  : {

$LN40:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 441  : 	switch (ci->mode)

  00004	8b 51 04	 mov	 edx, DWORD PTR [rcx+4]
  00007	83 ea 01	 sub	 edx, 1
  0000a	74 24		 je	 SHORT $LN3@EAInitMode
  0000c	83 fa 01	 cmp	 edx, 1
  0000f	74 1f		 je	 SHORT $LN3@EAInitMode

; 457  : 		break;
; 458  : 
; 459  : 	default:		
; 460  : 		// Unknown/wrong ID
; 461  : 		GST_THROW_FATAL_EXCEPTION;

  00011	45 33 c9	 xor	 r9d, r9d
  00014	45 33 c0	 xor	 r8d, r8d
  00017	ba cd 01 00 00	 mov	 edx, 461		; 000001cdH
  0001c	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00020	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0002f	cc		 int	 3
$LN3@EAInitMode:

; 447  : 
; 448  : 		/* Note: XTS mode could potentially be initialized with a weak key causing all blocks in one data unit
; 449  : 		on the volume to be tweaked with zero tweaks (i.e. 512 bytes of the volume would be encrypted in ECB
; 450  : 		mode). However, to create a GostCrypt volume with such a weak key, each human being on Earth would have
; 451  : 		to create approximately 11,378,125,361,078,862 (about eleven quadrillion) GostCrypt volumes (provided 
; 452  : 		that the size of each of the volumes is 1024 terabytes). */
; 453  : 		break;
; 454  : 	case XTS8:
; 455  : 		if (EAInit(ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)

  00030	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00033	74 20		 je	 SHORT $LN37@EAInitMode
  00035	4c 8d 81 28 02
	00 00		 lea	 r8, QWORD PTR [rcx+552]
  0003c	48 8d 91 50 1d
	00 00		 lea	 rdx, QWORD PTR [rcx+7504]
  00043	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00045	e8 00 00 00 00	 call	 EAInit
  0004a	85 c0		 test	 eax, eax

; 456  : 			return FALSE;

  0004c	75 07		 jne	 SHORT $LN37@EAInitMode

; 462  : 	}
; 463  : 	return TRUE;

  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	eb 02		 jmp	 SHORT $LN8@EAInitMode
$LN37@EAInitMode:

; 442  : 	{
; 443  : 	case XTS:
; 444  : 		// Secondary key schedule
; 445  : 		if (EAInit (ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)
; 446  : 			return FALSE;

  00055	33 c0		 xor	 eax, eax
$LN8@EAInitMode:

; 464  : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
$LN38@EAInitMode:
EAInitMode ENDP
END
