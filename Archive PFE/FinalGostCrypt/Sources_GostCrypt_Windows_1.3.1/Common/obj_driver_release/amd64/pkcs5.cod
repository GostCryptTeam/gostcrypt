; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@ DB '(Unknown)', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@ DB 'HMAC-GOST '
	DB	'R 34.11-94', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@ DB 'HMAC-GOS'
	DB	'T R 34.11-2012', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@ DB 'HMAC-Whirlpool', 00H ;  ?? ::FNODOBFM::`string'
PUBLIC	get_pkcs5_iteration_count
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
pdata	SEGMENT
$pdata$get_pkcs5_iteration_count DD imagerel $LN10
	DD	imagerel $LN10+60
	DD	imagerel $unwind$get_pkcs5_iteration_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_pkcs5_iteration_count DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT get_pkcs5_iteration_count
_TEXT	SEGMENT
pkcs5_prf_id$ = 64
bBoot$ = 72
get_pkcs5_iteration_count PROC				; COMDAT

; 562  : {

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 563  : 	switch (pkcs5_prf_id)

  00004	83 e9 01	 sub	 ecx, 1
  00007	74 29		 je	 SHORT $LN3@get_pkcs5_
  00009	83 e9 01	 sub	 ecx, 1
  0000c	74 24		 je	 SHORT $LN3@get_pkcs5_
  0000e	83 f9 01	 cmp	 ecx, 1
  00011	74 1f		 je	 SHORT $LN3@get_pkcs5_

; 569  : 	case GOSTHASH:
; 570  : 		return 1000;
; 571  : 	default:		
; 572  : 		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00013	45 33 c9	 xor	 r9d, r9d
  00016	45 33 c0	 xor	 r8d, r8d
  00019	ba 3c 02 00 00	 mov	 edx, 572		; 0000023cH
  0001e	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00022	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00031	cc		 int	 3
$LN3@get_pkcs5_:

; 564  : 	{
; 565  : 	case WHIRLPOOL:	
; 566  : 		return 1000;
; 567  : 	case STRIBOG:
; 568  : 		return 1000;

  00032	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H

; 573  : 	}
; 574  : 	return 0;
; 575  : }

  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
$LN9@get_pkcs5_:
get_pkcs5_iteration_count ENDP
_TEXT	ENDS
PUBLIC	hmac_truncate
; Function compile flags: /Ogspy
;	COMDAT hmac_truncate
_TEXT	SEGMENT
d1$ = 8
d2$ = 16
len$ = 24
hmac_truncate PROC					; COMDAT

; 39   : 	int i;
; 40   : 	for (i = 0; i < len; i++)

  00000	4d 63 c8	 movsxd	 r9, r8d
  00003	45 85 c0	 test	 r8d, r8d
  00006	7e 11		 jle	 SHORT $LN1@hmac_trunc
  00008	48 2b ca	 sub	 rcx, rdx
$LL3@hmac_trunc:

; 41   : 		d2[i] = d1[i];

  0000b	8a 04 11	 mov	 al, BYTE PTR [rcx+rdx]
  0000e	88 02		 mov	 BYTE PTR [rdx], al
  00010	48 ff c2	 inc	 rdx
  00013	49 83 e9 01	 sub	 r9, 1
  00017	75 f2		 jne	 SHORT $LL3@hmac_trunc
$LN1@hmac_trunc:

; 42   : }

  00019	f3 c3		 fatret	 0
hmac_truncate ENDP
PUBLIC	__$ArrayPad$
PUBLIC	hmac_whirlpool
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$hmac_whirlpool DD imagerel $LN122
	DD	imagerel $LN122+892
	DD	imagerel $unwind$hmac_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_whirlpool DD 0a2619H
	DD	0690114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	0330H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
xdata	ENDS
;	COMDAT hmac_whirlpool
_TEXT	SEGMENT
ictx$ = 32
octx$ = 208
tctx$27176 = 384
buf$ = 560
key$ = 624
owhi$ = 688
iwhi$ = 752
__$ArrayPad$ = 816
k$ = 912
lk$ = 920
d$ = 928
ld$ = 936
out$ = 944
t$ = 952
hmac_whirlpool PROC					; COMDAT

; 54   : {

$LN122:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec 48 03
	00 00		 sub	 rsp, 840		; 00000348H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00026	4c 8b bc 24 b0
	03 00 00	 mov	 r15, QWORD PTR out$[rsp]

; 55   : 	WHIRLPOOL_CTX ictx, octx;
; 56   : 	char iwhi[WHIRLPOOL_DIGESTSIZE], owhi[WHIRLPOOL_DIGESTSIZE];
; 57   : 	char key[WHIRLPOOL_DIGESTSIZE];
; 58   : 	char buf[WHIRLPOOL_BLOCKSIZE];
; 59   : 	int i;
; 60   : 
; 61   :     /* If the key is longer than the hash algorithm block size,
; 62   : 	   let key = whirlpool(key), as per HMAC specifications. */
; 63   : 	if (lk > WHIRLPOOL_BLOCKSIZE)

  0002e	33 ff		 xor	 edi, edi
  00030	45 8b f1	 mov	 r14d, r9d
  00033	8d 5f 40	 lea	 ebx, QWORD PTR [rdi+64]
  00036	4d 8b e8	 mov	 r13, r8
  00039	44 8b e2	 mov	 r12d, edx
  0003c	3b d3		 cmp	 edx, ebx
  0003e	48 8b e9	 mov	 rbp, rcx
  00041	be a8 00 00 00	 mov	 esi, 168		; 000000a8H
  00046	0f 8e 9b 00 00
	00		 jle	 $LN45@hmac_whirl

; 64   : 	{
; 65   : 		WHIRLPOOL_CTX tctx;
; 66   : 
; 67   : 		WHIRLPOOL_init (&tctx);

  0004c	44 8d 47 20	 lea	 r8d, QWORD PTR [rdi+32]
  00050	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR tctx$27176[rsp]
  00058	33 d2		 xor	 edx, edx
  0005a	e8 00 00 00 00	 call	 memset
  0005f	48 8d 8c 24 e8
	01 00 00	 lea	 rcx, QWORD PTR tctx$27176[rsp+104]
  00067	4c 8b c3	 mov	 r8, rbx
  0006a	33 d2		 xor	 edx, edx
  0006c	89 bc 24 e4 01
	00 00		 mov	 DWORD PTR tctx$27176[rsp+100], edi
  00073	89 bc 24 e0 01
	00 00		 mov	 DWORD PTR tctx$27176[rsp+96], edi
  0007a	40 88 bc 24 a0
	01 00 00	 mov	 BYTE PTR tctx$27176[rsp+32], dil
  00082	e8 00 00 00 00	 call	 memset

; 68   : 		WHIRLPOOL_add ((unsigned char *) k, lk * 8, &tctx);

  00087	41 8b d4	 mov	 edx, r12d
  0008a	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR tctx$27176[rsp]
  00092	c1 e2 03	 shl	 edx, 3
  00095	48 8b cd	 mov	 rcx, rbp
  00098	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 69   : 		WHIRLPOOL_finalize (&tctx, (unsigned char *) key);

  0009d	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR key$[rsp]
  000a5	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR tctx$27176[rsp]
  000ad	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 70   : 
; 71   : 		k = key;
; 72   : 		lk = WHIRLPOOL_DIGESTSIZE;
; 73   : 
; 74   : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  000b2	33 c0		 xor	 eax, eax
  000b4	48 8d bc 24 80
	01 00 00	 lea	 rdi, QWORD PTR tctx$27176[rsp]
  000bc	48 8b ce	 mov	 rcx, rsi
  000bf	48 8d ac 24 70
	02 00 00	 lea	 rbp, QWORD PTR key$[rsp]
  000c7	44 8b e3	 mov	 r12d, ebx
  000ca	f3 aa		 rep stosb
  000cc	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR tctx$27176[rsp]
  000d4	44 8b c6	 mov	 r8d, esi
  000d7	33 ff		 xor	 edi, edi
$LL44@hmac_whirl:
  000d9	41 ff c8	 dec	 r8d
  000dc	40 88 3a	 mov	 BYTE PTR [rdx], dil
  000df	48 ff c2	 inc	 rdx
  000e2	44 3b c7	 cmp	 r8d, edi
  000e5	75 f2		 jne	 SHORT $LL44@hmac_whirl
$LN45@hmac_whirl:

; 75   : 	}
; 76   : 
; 77   : 	/**** Inner Digest ****/
; 78   : 
; 79   : 	WHIRLPOOL_init (&ictx);

  000e7	33 d2		 xor	 edx, edx
  000e9	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ictx$[rsp]
  000ee	44 8d 42 20	 lea	 r8d, QWORD PTR [rdx+32]
  000f2	e8 00 00 00 00	 call	 memset
  000f7	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR ictx$[rsp+104]
  000ff	4c 8b c3	 mov	 r8, rbx
  00102	33 d2		 xor	 edx, edx
  00104	89 bc 24 84 00
	00 00		 mov	 DWORD PTR ictx$[rsp+100], edi
  0010b	89 bc 24 80 00
	00 00		 mov	 DWORD PTR ictx$[rsp+96], edi
  00112	40 88 7c 24 40	 mov	 BYTE PTR ictx$[rsp+32], dil
  00117	e8 00 00 00 00	 call	 memset

; 80   : 
; 81   : 	/* Pad the key for inner digest */
; 82   : 	for (i = 0; i < lk; ++i)

  0011c	4c 8b df	 mov	 r11, rdi
  0011f	49 63 fc	 movsxd	 rdi, r12d
  00122	45 33 e4	 xor	 r12d, r12d
  00125	b2 36		 mov	 dl, 54			; 00000036H
  00127	49 3b fc	 cmp	 rdi, r12
  0012a	7e 26		 jle	 SHORT $LN40@hmac_whirl
  0012c	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00134	4c 8b c5	 mov	 r8, rbp
  00137	4c 2b c0	 sub	 r8, rax
$LL42@hmac_whirl:

; 83   : 		buf[i] = (char) (k[i] ^ 0x36);

  0013a	4a 8d 8c 1c 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r11]
  00142	49 ff c3	 inc	 r11
  00145	41 8a 04 08	 mov	 al, BYTE PTR [r8+rcx]
  00149	32 c2		 xor	 al, dl
  0014b	4c 3b df	 cmp	 r11, rdi
  0014e	88 01		 mov	 BYTE PTR [rcx], al
  00150	7c e8		 jl	 SHORT $LL42@hmac_whirl
$LN40@hmac_whirl:

; 84   : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  00152	48 3b fb	 cmp	 rdi, rbx
  00155	7d 13		 jge	 SHORT $LN39@hmac_whirl
  00157	4c 8b c3	 mov	 r8, rbx
  0015a	48 8d 8c 3c 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  00162	4c 2b c7	 sub	 r8, rdi
  00165	e8 00 00 00 00	 call	 memset
$LN39@hmac_whirl:

; 85   : 		buf[i] = 0x36;
; 86   : 
; 87   : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &ictx);

  0016a	4c 8d 44 24 20	 lea	 r8, QWORD PTR ictx$[rsp]
  0016f	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00177	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0017c	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 88   : 	WHIRLPOOL_add ((unsigned char *) d, ld * 8, &ictx);

  00181	41 8b d6	 mov	 edx, r14d
  00184	4c 8d 44 24 20	 lea	 r8, QWORD PTR ictx$[rsp]
  00189	c1 e2 03	 shl	 edx, 3
  0018c	49 8b cd	 mov	 rcx, r13
  0018f	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 89   : 
; 90   : 	WHIRLPOOL_finalize (&ictx, (unsigned char *) iwhi);

  00194	48 8d 94 24 f0
	02 00 00	 lea	 rdx, QWORD PTR iwhi$[rsp]
  0019c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ictx$[rsp]
  001a1	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 91   : 
; 92   : 	/**** Outer Digest ****/
; 93   : 
; 94   : 	WHIRLPOOL_init (&octx);

  001a6	33 d2		 xor	 edx, edx
  001a8	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  001b0	44 8d 42 20	 lea	 r8d, QWORD PTR [rdx+32]
  001b4	e8 00 00 00 00	 call	 memset
  001b9	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp+104]
  001c1	4c 8b c3	 mov	 r8, rbx
  001c4	33 d2		 xor	 edx, edx
  001c6	44 89 a4 24 34
	01 00 00	 mov	 DWORD PTR octx$[rsp+100], r12d
  001ce	44 89 a4 24 30
	01 00 00	 mov	 DWORD PTR octx$[rsp+96], r12d
  001d6	44 88 a4 24 f0
	00 00 00	 mov	 BYTE PTR octx$[rsp+32], r12b
  001de	e8 00 00 00 00	 call	 memset

; 95   : 
; 96   : 	for (i = 0; i < lk; ++i)

  001e3	49 3b fc	 cmp	 rdi, r12
  001e6	4d 8b dc	 mov	 r11, r12
  001e9	b2 5c		 mov	 dl, 92			; 0000005cH
  001eb	7e 22		 jle	 SHORT $LN34@hmac_whirl
  001ed	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  001f5	48 2b e8	 sub	 rbp, rax
$LL36@hmac_whirl:

; 97   : 		buf[i] = (char) (k[i] ^ 0x5C);

  001f8	4a 8d 8c 1c 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r11]
  00200	49 ff c3	 inc	 r11
  00203	8a 04 29	 mov	 al, BYTE PTR [rcx+rbp]
  00206	32 c2		 xor	 al, dl
  00208	4c 3b df	 cmp	 r11, rdi
  0020b	88 01		 mov	 BYTE PTR [rcx], al
  0020d	7c e9		 jl	 SHORT $LL36@hmac_whirl
$LN34@hmac_whirl:

; 98   : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  0020f	48 3b fb	 cmp	 rdi, rbx
  00212	7d 13		 jge	 SHORT $LN33@hmac_whirl
  00214	4c 8b c3	 mov	 r8, rbx
  00217	48 8d 8c 3c 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  0021f	4c 2b c7	 sub	 r8, rdi
  00222	e8 00 00 00 00	 call	 memset
$LN33@hmac_whirl:

; 99   : 		buf[i] = 0x5C;
; 100  : 
; 101  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  00227	bf 00 02 00 00	 mov	 edi, 512		; 00000200H
  0022c	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  00234	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0023c	8b d7		 mov	 edx, edi
  0023e	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 102  : 	WHIRLPOOL_add ((unsigned char *) iwhi, WHIRLPOOL_DIGESTSIZE * 8, &octx);

  00243	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  0024b	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR iwhi$[rsp]
  00253	8b d7		 mov	 edx, edi
  00255	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 103  : 
; 104  : 	WHIRLPOOL_finalize (&octx, (unsigned char *) owhi);

  0025a	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR owhi$[rsp]
  00262	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  0026a	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 105  : 
; 106  : 	/* truncate and print the results */
; 107  : 	t = t > WHIRLPOOL_DIGESTSIZE ? WHIRLPOOL_DIGESTSIZE : t;
; 108  : 	hmac_truncate (owhi, out, t);

  0026f	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR owhi$[rsp]
  00277	4c 8b c3	 mov	 r8, rbx
  0027a	49 8b cf	 mov	 rcx, r15
  0027d	e8 00 00 00 00	 call	 memcpy

; 109  : 
; 110  : 	/* Prevent possible leaks. */
; 111  : 	burn (&ictx, sizeof(ictx));

  00282	48 8d 7c 24 20	 lea	 rdi, QWORD PTR ictx$[rsp]
  00287	33 c0		 xor	 eax, eax
  00289	48 8b ce	 mov	 rcx, rsi
  0028c	4c 8d 5c 24 20	 lea	 r11, QWORD PTR ictx$[rsp]
  00291	8b d6		 mov	 edx, esi
  00293	f3 aa		 rep stosb
$LL27@hmac_whirl:
  00295	ff ca		 dec	 edx
  00297	45 88 23	 mov	 BYTE PTR [r11], r12b
  0029a	49 ff c3	 inc	 r11
  0029d	41 3b d4	 cmp	 edx, r12d
  002a0	75 f3		 jne	 SHORT $LL27@hmac_whirl

; 112  : 	burn (&octx, sizeof(octx));

  002a2	48 8d bc 24 d0
	00 00 00	 lea	 rdi, QWORD PTR octx$[rsp]
  002aa	48 8b ce	 mov	 rcx, rsi
  002ad	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR octx$[rsp]
  002b5	f3 aa		 rep stosb
$LL22@hmac_whirl:
  002b7	ff ce		 dec	 esi
  002b9	44 88 22	 mov	 BYTE PTR [rdx], r12b
  002bc	48 ff c2	 inc	 rdx
  002bf	41 3b f4	 cmp	 esi, r12d
  002c2	75 f3		 jne	 SHORT $LL22@hmac_whirl

; 113  : 	burn (owhi, sizeof(owhi));

  002c4	48 8d bc 24 b0
	02 00 00	 lea	 rdi, QWORD PTR owhi$[rsp]
  002cc	48 8b cb	 mov	 rcx, rbx
  002cf	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR owhi$[rsp]
  002d7	f3 aa		 rep stosb
  002d9	44 8b c3	 mov	 r8d, ebx
$LL17@hmac_whirl:
  002dc	41 ff c8	 dec	 r8d
  002df	44 88 22	 mov	 BYTE PTR [rdx], r12b
  002e2	48 ff c2	 inc	 rdx
  002e5	45 3b c4	 cmp	 r8d, r12d
  002e8	75 f2		 jne	 SHORT $LL17@hmac_whirl

; 114  : 	burn (iwhi, sizeof(iwhi));

  002ea	48 8d bc 24 f0
	02 00 00	 lea	 rdi, QWORD PTR iwhi$[rsp]
  002f2	48 8b cb	 mov	 rcx, rbx
  002f5	48 8d 94 24 f0
	02 00 00	 lea	 rdx, QWORD PTR iwhi$[rsp]
  002fd	f3 aa		 rep stosb
  002ff	44 8b c3	 mov	 r8d, ebx
$LL12@hmac_whirl:
  00302	41 ff c8	 dec	 r8d
  00305	44 88 22	 mov	 BYTE PTR [rdx], r12b
  00308	48 ff c2	 inc	 rdx
  0030b	45 3b c4	 cmp	 r8d, r12d
  0030e	75 f2		 jne	 SHORT $LL12@hmac_whirl

; 115  : 	burn (buf, sizeof(buf));

  00310	48 8d bc 24 30
	02 00 00	 lea	 rdi, QWORD PTR buf$[rsp]
  00318	48 8b cb	 mov	 rcx, rbx
  0031b	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00323	f3 aa		 rep stosb
  00325	44 8b c3	 mov	 r8d, ebx
$LL7@hmac_whirl:
  00328	41 ff c8	 dec	 r8d
  0032b	44 88 22	 mov	 BYTE PTR [rdx], r12b
  0032e	48 ff c2	 inc	 rdx
  00331	45 3b c4	 cmp	 r8d, r12d
  00334	75 f2		 jne	 SHORT $LL7@hmac_whirl

; 116  : 	burn (key, sizeof(key));

  00336	48 8d bc 24 70
	02 00 00	 lea	 rdi, QWORD PTR key$[rsp]
  0033e	48 8b cb	 mov	 rcx, rbx
  00341	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR key$[rsp]
  00349	f3 aa		 rep stosb
$LL2@hmac_whirl:
  0034b	ff cb		 dec	 ebx
  0034d	44 88 22	 mov	 BYTE PTR [rdx], r12b
  00350	48 ff c2	 inc	 rdx
  00353	41 3b dc	 cmp	 ebx, r12d
  00356	75 f3		 jne	 SHORT $LL2@hmac_whirl

; 117  : }

  00358	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00360	48 33 cc	 xor	 rcx, rsp
  00363	e8 00 00 00 00	 call	 __security_check_cookie
  00368	48 81 c4 48 03
	00 00		 add	 rsp, 840		; 00000348H
  0036f	41 5f		 pop	 r15
  00371	41 5e		 pop	 r14
  00373	41 5d		 pop	 r13
  00375	41 5c		 pop	 r12
  00377	5f		 pop	 rdi
  00378	5e		 pop	 rsi
  00379	5d		 pop	 rbp
  0037a	5b		 pop	 rbx
  0037b	c3		 ret	 0
hmac_whirlpool ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_whirlpool
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_u_whirlpool DD imagerel $LN33
	DD	imagerel $LN33+344
	DD	imagerel $unwind$derive_u_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_whirlpool DD 072019H
	DD	02a010eH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0140H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_u_whirlpool
_TEXT	SEGMENT
counter$ = 48
j$ = 64
k$ = 128
init$ = 192
__$ArrayPad$ = 320
pwd$ = 384
pwd_len$ = 392
salt$ = 400
salt_len$ = 408
iterations$ = 416
u$ = 424
b$ = 432
derive_u_whirlpool PROC					; COMDAT

; 134  : {

$LN33:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00020	48 8b b4 24 a8
	01 00 00	 mov	 rsi, QWORD PTR u$[rsp]

; 135  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 136  : 	char init[128];
; 137  : 	char counter[4];
; 138  : 	int c, i;
; 139  : 
; 140  : 	/* iteration 1 */
; 141  : 	memset (counter, 0, 4);

  00028	33 c0		 xor	 eax, eax
  0002a	4d 8b d0	 mov	 r10, r8
  0002d	89 44 24 30	 mov	 DWORD PTR counter$[rsp], eax

; 142  : 	counter[3] = (char) b;

  00031	8a 84 24 b0 01
	00 00		 mov	 al, BYTE PTR b$[rsp]
  00038	49 63 d9	 movsxd	 rbx, r9d
  0003b	48 8b e9	 mov	 rbp, rcx
  0003e	44 8b e2	 mov	 r12d, edx

; 143  : 	memcpy (init, salt, salt_len);	/* salt */

  00041	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR init$[rsp]
  00049	4c 8b c3	 mov	 r8, rbx
  0004c	49 8b d2	 mov	 rdx, r10
  0004f	88 44 24 33	 mov	 BYTE PTR counter$[rsp+3], al
  00053	e8 00 00 00 00	 call	 memcpy

; 144  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00058	8b 54 24 30	 mov	 edx, DWORD PTR counter$[rsp]

; 145  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);

  0005c	44 8d 4b 04	 lea	 r9d, DWORD PTR [rbx+4]
  00060	89 94 1c c0 00
	00 00		 mov	 DWORD PTR init$[rsp+rbx], edx
  00067	48 8d 44 24 40	 lea	 rax, QWORD PTR j$[rsp]
  0006c	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR init$[rsp]
  00074	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00079	41 8b d4	 mov	 edx, r12d
  0007c	48 8b cd	 mov	 rcx, rbp
  0007f	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00088	e8 00 00 00 00	 call	 hmac_whirlpool

; 146  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);

  0008d	48 8d 54 24 40	 lea	 rdx, QWORD PTR j$[rsp]
  00092	48 8b ce	 mov	 rcx, rsi
  00095	4c 8b c3	 mov	 r8, rbx
  00098	e8 00 00 00 00	 call	 memcpy

; 147  : 
; 148  : 	/* remaining iterations */
; 149  : 	for (c = 1; c < iterations; c++)

  0009d	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000a4	83 f8 01	 cmp	 eax, 1
  000a7	7e 53		 jle	 SHORT $LN10@derive_u_w
  000a9	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  000b1	8d 78 ff	 lea	 edi, DWORD PTR [rax-1]
  000b4	48 2b f1	 sub	 rsi, rcx
$LL16@derive_u_w:

; 150  : 	{
; 151  : 		hmac_whirlpool (pwd, pwd_len, j, WHIRLPOOL_DIGESTSIZE, k, WHIRLPOOL_DIGESTSIZE);

  000b7	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  000bf	4c 8d 44 24 40	 lea	 r8, QWORD PTR j$[rsp]
  000c4	44 8b cb	 mov	 r9d, ebx
  000c7	41 8b d4	 mov	 edx, r12d
  000ca	48 8b cd	 mov	 rcx, rbp
  000cd	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	e8 00 00 00 00	 call	 hmac_whirlpool

; 152  : 		for (i = 0; i < WHIRLPOOL_DIGESTSIZE; i++)

  000db	33 d2		 xor	 edx, edx
$LL13@derive_u_w:

; 153  : 		{
; 154  : 			u[i] ^= k[i];

  000dd	48 8d 8c 14 80
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp+rdx]
  000e5	48 ff c2	 inc	 rdx
  000e8	8a 01		 mov	 al, BYTE PTR [rcx]
  000ea	30 04 0e	 xor	 BYTE PTR [rsi+rcx], al
  000ed	48 3b d3	 cmp	 rdx, rbx

; 155  : 			j[i] = k[i];

  000f0	88 44 14 3f	 mov	 BYTE PTR j$[rsp+rdx-1], al
  000f4	7c e7		 jl	 SHORT $LL13@derive_u_w

; 147  : 
; 148  : 	/* remaining iterations */
; 149  : 	for (c = 1; c < iterations; c++)

  000f6	48 83 ef 01	 sub	 rdi, 1
  000fa	75 bb		 jne	 SHORT $LL16@derive_u_w
$LN10@derive_u_w:

; 156  : 		}
; 157  : 	}
; 158  : 
; 159  : 	/* Prevent possible leaks. */
; 160  : 	burn (j, sizeof(j));

  000fc	48 8d 7c 24 40	 lea	 rdi, QWORD PTR j$[rsp]
  00101	33 c0		 xor	 eax, eax
  00103	48 8b cb	 mov	 rcx, rbx
  00106	48 8d 54 24 40	 lea	 rdx, QWORD PTR j$[rsp]
  0010b	44 8b c3	 mov	 r8d, ebx
  0010e	f3 aa		 rep stosb
$LL7@derive_u_w:
  00110	88 02		 mov	 BYTE PTR [rdx], al
  00112	48 ff c2	 inc	 rdx
  00115	41 83 e8 01	 sub	 r8d, 1
  00119	75 f5		 jne	 SHORT $LL7@derive_u_w

; 161  : 	burn (k, sizeof(k));

  0011b	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR k$[rsp]
  00123	48 8b cb	 mov	 rcx, rbx
  00126	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  0012e	f3 aa		 rep stosb
$LL2@derive_u_w:
  00130	88 02		 mov	 BYTE PTR [rdx], al
  00132	48 ff c2	 inc	 rdx
  00135	83 eb 01	 sub	 ebx, 1
  00138	75 f6		 jne	 SHORT $LL2@derive_u_w

; 162  : }

  0013a	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00142	48 33 cc	 xor	 rcx, rsp
  00145	e8 00 00 00 00	 call	 __security_check_cookie
  0014a	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  00151	41 5c		 pop	 r12
  00153	5f		 pop	 rdi
  00154	5e		 pop	 rsi
  00155	5d		 pop	 rbp
  00156	5b		 pop	 rbx
  00157	c3		 ret	 0
derive_u_whirlpool ENDP
PUBLIC	__$ArrayPad$
PUBLIC	hmac_gosthash
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$hmac_gosthash DD imagerel $LN111
	DD	imagerel $LN111+634
	DD	imagerel $unwind$hmac_gosthash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_gosthash DD 092419H
	DD	0240112H
	DD	0d009e00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0110H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
xdata	ENDS
;	COMDAT hmac_gosthash
_TEXT	SEGMENT
ctx$ = 32
buf$ = 144
key$ = 176
inner$ = 208
outer$ = 240
__$ArrayPad$ = 272
k$ = 352
lk$ = 360
d$ = 368
ld$ = 376
out$ = 384
hmac_gosthash PROC					; COMDAT

; 219  : {

$LN111:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 220  : 	gost_hash_ctx ctx;
; 221  : 	char inner[GOSTHASH_DIGESTSIZE], outer[GOSTHASH_DIGESTSIZE];
; 222  : 	char key[GOSTHASH_DIGESTSIZE];
; 223  : 	char buf[GOSTHASH_BLOCKSIZE];
; 224  : 	int32 i;
; 225  : 
; 226  :     /* If the key is longer than the hash algorithm block size,
; 227  : 	   let key = gosthash(key), as per HMAC specifications. */
; 228  : 	if (lk > GOSTHASH_BLOCKSIZE)

  00024	be 68 00 00 00	 mov	 esi, 104		; 00000068H
  00029	45 8b f1	 mov	 r14d, r9d
  0002c	4d 8b e8	 mov	 r13, r8
  0002f	8d 5e b8	 lea	 ebx, QWORD PTR [rsi-72]
  00032	44 8b e2	 mov	 r12d, edx
  00035	48 8b e9	 mov	 rbp, rcx
  00038	3b d3		 cmp	 edx, ebx
  0003a	7e 5b		 jle	 SHORT $LN40@hmac_gosth

; 229  : 	{
; 230  : 		GOSTHASH_init (&ctx);

  0003c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  00041	4c 8b c6	 mov	 r8, rsi
  00044	33 d2		 xor	 edx, edx
  00046	e8 00 00 00 00	 call	 memset

; 231  : 		GOSTHASH_add ((unsigned char *)k, lk, &ctx);

  0004b	4c 8d 44 24 20	 lea	 r8, QWORD PTR ctx$[rsp]
  00050	41 8b d4	 mov	 edx, r12d
  00053	48 8b cd	 mov	 rcx, rbp
  00056	e8 00 00 00 00	 call	 GOSTHASH_add

; 232  : 		GOSTHASH_finalize (&ctx, (unsigned char *) key);

  0005b	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR key$[rsp]
  00063	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  00068	e8 00 00 00 00	 call	 GOSTHASH_finalize

; 233  : 
; 234  : 		k = key;
; 235  : 		lk = GOSTHASH_DIGESTSIZE;
; 236  : 
; 237  : 		burn (&ctx, sizeof(ctx));		// Prevent leaks

  0006d	48 8d 7c 24 20	 lea	 rdi, QWORD PTR ctx$[rsp]
  00072	33 c0		 xor	 eax, eax
  00074	48 8b ce	 mov	 rcx, rsi
  00077	48 8d ac 24 b0
	00 00 00	 lea	 rbp, QWORD PTR key$[rsp]
  0007f	44 8b e3	 mov	 r12d, ebx
  00082	48 8d 54 24 20	 lea	 rdx, QWORD PTR ctx$[rsp]
  00087	44 8b c6	 mov	 r8d, esi
  0008a	f3 aa		 rep stosb
$LL39@hmac_gosth:
  0008c	88 02		 mov	 BYTE PTR [rdx], al
  0008e	48 ff c2	 inc	 rdx
  00091	41 83 e8 01	 sub	 r8d, 1
  00095	75 f5		 jne	 SHORT $LL39@hmac_gosth
$LN40@hmac_gosth:

; 238  : 	}
; 239  : 
; 240  : 	/**** Inner Digest ****/
; 241  : 
; 242  : 	GOSTHASH_init (&ctx);

  00097	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  0009c	4c 8b c6	 mov	 r8, rsi
  0009f	33 d2		 xor	 edx, edx
  000a1	e8 00 00 00 00	 call	 memset

; 243  : 
; 244  : 	/* Pad the key for inner digest */
; 245  : 	for (i = 0; i < lk; ++i)

  000a6	45 33 db	 xor	 r11d, r11d
  000a9	49 63 fc	 movsxd	 rdi, r12d
  000ac	b2 36		 mov	 dl, 54			; 00000036H
  000ae	45 85 e4	 test	 r12d, r12d
  000b1	7e 26		 jle	 SHORT $LN35@hmac_gosth
  000b3	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  000bb	4c 8b c5	 mov	 r8, rbp
  000be	4c 2b c0	 sub	 r8, rax
$LL37@hmac_gosth:

; 246  : 		buf[i] = (char) (k[i] ^ 0x36);

  000c1	4a 8d 8c 1c 90
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r11]
  000c9	49 ff c3	 inc	 r11
  000cc	41 8a 04 08	 mov	 al, BYTE PTR [r8+rcx]
  000d0	32 c2		 xor	 al, dl
  000d2	4c 3b df	 cmp	 r11, rdi
  000d5	88 01		 mov	 BYTE PTR [rcx], al
  000d7	7c e8		 jl	 SHORT $LL37@hmac_gosth
$LN35@hmac_gosth:

; 247  : 	for (i = lk; i < GOSTHASH_BLOCKSIZE; ++i)

  000d9	48 3b fb	 cmp	 rdi, rbx
  000dc	7d 13		 jge	 SHORT $LN34@hmac_gosth
  000de	4c 8b c3	 mov	 r8, rbx
  000e1	48 8d 8c 3c 90
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  000e9	4c 2b c7	 sub	 r8, rdi
  000ec	e8 00 00 00 00	 call	 memset
$LN34@hmac_gosth:

; 248  : 		buf[i] = 0x36;
; 249  : 
; 250  : 	GOSTHASH_add ((unsigned char *) buf, GOSTHASH_BLOCKSIZE, &ctx);

  000f1	4c 8d 44 24 20	 lea	 r8, QWORD PTR ctx$[rsp]
  000f6	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  000fe	8b d3		 mov	 edx, ebx
  00100	e8 00 00 00 00	 call	 GOSTHASH_add

; 251  : 	GOSTHASH_add ((unsigned char *) d, ld, &ctx);

  00105	4c 8d 44 24 20	 lea	 r8, QWORD PTR ctx$[rsp]
  0010a	41 8b d6	 mov	 edx, r14d
  0010d	49 8b cd	 mov	 rcx, r13
  00110	e8 00 00 00 00	 call	 GOSTHASH_add

; 252  : 
; 253  : 	GOSTHASH_finalize (&ctx, (unsigned char *) inner);

  00115	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR inner$[rsp]
  0011d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  00122	e8 00 00 00 00	 call	 GOSTHASH_finalize

; 254  : 
; 255  : 	/**** Outer Digest ****/
; 256  : 	
; 257  : 	GOSTHASH_init (&ctx);

  00127	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  0012c	4c 8b c6	 mov	 r8, rsi
  0012f	33 d2		 xor	 edx, edx
  00131	e8 00 00 00 00	 call	 memset

; 258  : 
; 259  : 	for (i = 0; i < lk; ++i)

  00136	45 33 db	 xor	 r11d, r11d
  00139	b2 5c		 mov	 dl, 92			; 0000005cH
  0013b	45 85 e4	 test	 r12d, r12d
  0013e	7e 22		 jle	 SHORT $LN29@hmac_gosth
  00140	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00148	48 2b e8	 sub	 rbp, rax
$LL31@hmac_gosth:

; 260  : 		buf[i] = (char) (k[i] ^ 0x5C);

  0014b	4a 8d 8c 1c 90
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r11]
  00153	49 ff c3	 inc	 r11
  00156	8a 04 29	 mov	 al, BYTE PTR [rcx+rbp]
  00159	32 c2		 xor	 al, dl
  0015b	4c 3b df	 cmp	 r11, rdi
  0015e	88 01		 mov	 BYTE PTR [rcx], al
  00160	7c e9		 jl	 SHORT $LL31@hmac_gosth
$LN29@hmac_gosth:

; 261  : 	for (i = lk; i < GOSTHASH_BLOCKSIZE; ++i)

  00162	48 3b fb	 cmp	 rdi, rbx
  00165	7d 13		 jge	 SHORT $LN28@hmac_gosth
  00167	4c 8b c3	 mov	 r8, rbx
  0016a	48 8d 8c 3c 90
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  00172	4c 2b c7	 sub	 r8, rdi
  00175	e8 00 00 00 00	 call	 memset
$LN28@hmac_gosth:

; 262  : 		buf[i] = 0x5C;
; 263  : 
; 264  : 	GOSTHASH_add ((unsigned char *) buf, GOSTHASH_BLOCKSIZE, &ctx);

  0017a	4c 8d 44 24 20	 lea	 r8, QWORD PTR ctx$[rsp]
  0017f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00187	8b d3		 mov	 edx, ebx
  00189	e8 00 00 00 00	 call	 GOSTHASH_add

; 265  : 	GOSTHASH_add ((unsigned char *) inner, GOSTHASH_DIGESTSIZE, &ctx);

  0018e	4c 8d 44 24 20	 lea	 r8, QWORD PTR ctx$[rsp]
  00193	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR inner$[rsp]
  0019b	8b d3		 mov	 edx, ebx
  0019d	e8 00 00 00 00	 call	 GOSTHASH_add

; 266  : 
; 267  : 	GOSTHASH_finalize (&ctx, (unsigned char *) out);

  001a2	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  001aa	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  001af	e8 00 00 00 00	 call	 GOSTHASH_finalize

; 268  : 
; 269  : 	/* Prevent possible leaks. */
; 270  : 	burn (&ctx, sizeof(ctx));

  001b4	48 8d 7c 24 20	 lea	 rdi, QWORD PTR ctx$[rsp]
  001b9	33 c0		 xor	 eax, eax
  001bb	48 8b ce	 mov	 rcx, rsi
  001be	4c 8d 5c 24 20	 lea	 r11, QWORD PTR ctx$[rsp]
  001c3	f3 aa		 rep stosb
$LL22@hmac_gosth:
  001c5	41 88 03	 mov	 BYTE PTR [r11], al
  001c8	49 ff c3	 inc	 r11
  001cb	83 ee 01	 sub	 esi, 1
  001ce	75 f5		 jne	 SHORT $LL22@hmac_gosth

; 271  : 	burn (outer, sizeof(outer));

  001d0	48 8d bc 24 f0
	00 00 00	 lea	 rdi, QWORD PTR outer$[rsp]
  001d8	48 8b cb	 mov	 rcx, rbx
  001db	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR outer$[rsp]
  001e3	f3 aa		 rep stosb
  001e5	44 8b c3	 mov	 r8d, ebx
$LL17@hmac_gosth:
  001e8	88 02		 mov	 BYTE PTR [rdx], al
  001ea	48 ff c2	 inc	 rdx
  001ed	41 83 e8 01	 sub	 r8d, 1
  001f1	75 f5		 jne	 SHORT $LL17@hmac_gosth

; 272  : 	burn (inner, sizeof(inner));

  001f3	48 8d bc 24 d0
	00 00 00	 lea	 rdi, QWORD PTR inner$[rsp]
  001fb	48 8b cb	 mov	 rcx, rbx
  001fe	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR inner$[rsp]
  00206	f3 aa		 rep stosb
  00208	44 8b c3	 mov	 r8d, ebx
$LL12@hmac_gosth:
  0020b	88 02		 mov	 BYTE PTR [rdx], al
  0020d	48 ff c2	 inc	 rdx
  00210	41 83 e8 01	 sub	 r8d, 1
  00214	75 f5		 jne	 SHORT $LL12@hmac_gosth

; 273  : 	burn (buf, sizeof(buf));

  00216	48 8d bc 24 90
	00 00 00	 lea	 rdi, QWORD PTR buf$[rsp]
  0021e	48 8b cb	 mov	 rcx, rbx
  00221	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00229	f3 aa		 rep stosb
  0022b	44 8b c3	 mov	 r8d, ebx
$LL7@hmac_gosth:
  0022e	88 02		 mov	 BYTE PTR [rdx], al
  00230	48 ff c2	 inc	 rdx
  00233	41 83 e8 01	 sub	 r8d, 1
  00237	75 f5		 jne	 SHORT $LL7@hmac_gosth

; 274  : 	burn (key, sizeof(key));

  00239	48 8d bc 24 b0
	00 00 00	 lea	 rdi, QWORD PTR key$[rsp]
  00241	48 8b cb	 mov	 rcx, rbx
  00244	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR key$[rsp]
  0024c	f3 aa		 rep stosb
$LL2@hmac_gosth:
  0024e	88 02		 mov	 BYTE PTR [rdx], al
  00250	48 ff c2	 inc	 rdx
  00253	83 eb 01	 sub	 ebx, 1
  00256	75 f6		 jne	 SHORT $LL2@hmac_gosth

; 275  : }

  00258	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00260	48 33 cc	 xor	 rcx, rsp
  00263	e8 00 00 00 00	 call	 __security_check_cookie
  00268	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  0026f	41 5e		 pop	 r14
  00271	41 5d		 pop	 r13
  00273	41 5c		 pop	 r12
  00275	5f		 pop	 rdi
  00276	5e		 pop	 rsi
  00277	5d		 pop	 rbp
  00278	5b		 pop	 rbx
  00279	c3		 ret	 0
hmac_gosthash ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_whirlpool
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_key_whirlpool DD imagerel $LN20
	DD	imagerel $LN20+315
	DD	imagerel $unwind$derive_key_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_whirlpool DD 0a2619H
	DD	0150114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	090H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_key_whirlpool
_TEXT	SEGMENT
salt_len$GSCopy$1$ = 64
salt$GSCopy$1$ = 72
u$ = 80
__$ArrayPad$ = 144
pwd$ = 240
pwd_len$ = 248
salt$ = 256
salt_len$ = 264
iterations$ = 272
dk$ = 280
dklen$ = 288
derive_key_whirlpool PROC				; COMDAT

; 179  : {

$LN20:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 180  : 	char u[WHIRLPOOL_DIGESTSIZE];
; 181  : 	int b, l, r;
; 182  : 
; 183  : 	if (dklen % WHIRLPOOL_DIGESTSIZE)

  00026	8b b4 24 20 01
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  0002d	4c 8b ac 24 18
	01 00 00	 mov	 r13, QWORD PTR dk$[rsp]
  00035	44 8b fa	 mov	 r15d, edx
  00038	8b c6		 mov	 eax, esi
  0003a	44 89 4c 24 40	 mov	 DWORD PTR salt_len$GSCopy$1$[rsp], r9d
  0003f	4c 89 44 24 48	 mov	 QWORD PTR salt$GSCopy$1$[rsp], r8
  00044	99		 cdq
  00045	4c 8b f1	 mov	 r14, rcx
  00048	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004b	03 c2		 add	 eax, edx
  0004d	8b f8		 mov	 edi, eax
  0004f	83 e0 3f	 and	 eax, 63			; 0000003fH
  00052	c1 ff 06	 sar	 edi, 6
  00055	3b c2		 cmp	 eax, edx
  00057	74 02		 je	 SHORT $LN9@derive_key

; 184  : 	{
; 185  : 		l = 1 + dklen / WHIRLPOOL_DIGESTSIZE;

  00059	ff c7		 inc	 edi
$LN9@derive_key:

; 186  : 	}
; 187  : 	else
; 188  : 	{
; 189  : 		l = dklen / WHIRLPOOL_DIGESTSIZE;
; 190  : 	}
; 191  : 
; 192  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;
; 193  : 
; 194  : 	/* first l - 1 blocks */
; 195  : 	for (b = 1; b < l; b++)

  0005b	44 8b a4 24 10
	01 00 00	 mov	 r12d, DWORD PTR iterations$[rsp]
  00063	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00068	8b c7		 mov	 eax, edi
  0006a	c1 e0 06	 shl	 eax, 6
  0006d	8d 6b c1	 lea	 ebp, QWORD PTR [rbx-63]
  00070	2b f0		 sub	 esi, eax
  00072	03 f3		 add	 esi, ebx
  00074	3b fd		 cmp	 edi, ebp
  00076	89 b4 24 20 01
	00 00		 mov	 DWORD PTR dklen$[rsp], esi
  0007d	7e 4e		 jle	 SHORT $LN6@derive_key
  0007f	49 8b f0	 mov	 rsi, r8
$LL8@derive_key:

; 196  : 	{
; 197  : 		derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00082	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00087	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0008b	4c 8b c6	 mov	 r8, rsi
  0008e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00093	41 8b d7	 mov	 edx, r15d
  00096	49 8b ce	 mov	 rcx, r14
  00099	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  0009e	e8 00 00 00 00	 call	 derive_u_whirlpool

; 198  : 		memcpy (dk, u, WHIRLPOOL_DIGESTSIZE);

  000a3	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  000a8	49 8b cd	 mov	 rcx, r13
  000ab	4c 8b c3	 mov	 r8, rbx
  000ae	e8 00 00 00 00	 call	 memcpy
  000b3	44 8b 4c 24 40	 mov	 r9d, DWORD PTR salt_len$GSCopy$1$[rsp]
  000b8	ff c5		 inc	 ebp

; 199  : 		dk += WHIRLPOOL_DIGESTSIZE;

  000ba	4c 03 eb	 add	 r13, rbx
  000bd	3b ef		 cmp	 ebp, edi
  000bf	7c c1		 jl	 SHORT $LL8@derive_key
  000c1	8b b4 24 20 01
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  000c8	4c 8b 44 24 48	 mov	 r8, QWORD PTR salt$GSCopy$1$[rsp]
$LN6@derive_key:

; 200  : 	}
; 201  : 
; 202  : 	/* last block */
; 203  : 	derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000cd	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000d2	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  000d6	41 8b d7	 mov	 edx, r15d
  000d9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000de	49 8b ce	 mov	 rcx, r14
  000e1	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  000e6	e8 00 00 00 00	 call	 derive_u_whirlpool

; 204  : 	memcpy (dk, u, r);

  000eb	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  000f0	4c 63 c6	 movsxd	 r8, esi
  000f3	49 8b cd	 mov	 rcx, r13
  000f6	e8 00 00 00 00	 call	 memcpy

; 205  : 
; 206  : 
; 207  : 	/* Prevent possible leaks. */
; 208  : 	burn (u, sizeof(u));

  000fb	48 8d 7c 24 50	 lea	 rdi, QWORD PTR u$[rsp]
  00100	33 c0		 xor	 eax, eax
  00102	48 8b cb	 mov	 rcx, rbx
  00105	4c 8d 5c 24 50	 lea	 r11, QWORD PTR u$[rsp]
  0010a	f3 aa		 rep stosb
$LL2@derive_key:
  0010c	41 88 03	 mov	 BYTE PTR [r11], al
  0010f	49 ff c3	 inc	 r11
  00112	83 eb 01	 sub	 ebx, 1
  00115	75 f5		 jne	 SHORT $LL2@derive_key

; 209  : }

  00117	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0011f	48 33 cc	 xor	 rcx, rsp
  00122	e8 00 00 00 00	 call	 __security_check_cookie
  00127	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0012e	41 5f		 pop	 r15
  00130	41 5e		 pop	 r14
  00132	41 5d		 pop	 r13
  00134	41 5c		 pop	 r12
  00136	5f		 pop	 rdi
  00137	5e		 pop	 rsi
  00138	5d		 pop	 rbp
  00139	5b		 pop	 rbx
  0013a	c3		 ret	 0
derive_key_whirlpool ENDP
PUBLIC	__$ArrayPad$
PUBLIC	hmac_stribog
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$hmac_stribog DD imagerel $LN111
	DD	imagerel $LN111+687
	DD	imagerel $unwind$hmac_stribog
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_stribog DD 0a2619H
	DD	0590114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
xdata	ENDS
;	COMDAT hmac_stribog
_TEXT	SEGMENT
ctx$ = 32
buf$ = 432
key$ = 496
inner$ = 560
outer$ = 624
__$ArrayPad$ = 688
k$ = 784
lk$ = 792
d$ = 800
ld$ = 808
out$ = 816
hmac_stribog PROC					; COMDAT

; 379  : {

$LN111:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00026	4c 8b bc 24 30
	03 00 00	 mov	 r15, QWORD PTR out$[rsp]

; 380  : 	STRIBOG_CTX ctx;
; 381  : 	char inner[STRIBOG_DIGESTSIZE], outer[STRIBOG_DIGESTSIZE];
; 382  : 	char key[STRIBOG_DIGESTSIZE];
; 383  : 	char buf[STRIBOG_BLOCKSIZE];
; 384  : 	int32 i;
; 385  : 
; 386  :     /* If the key is longer than the hash algorithm block size,
; 387  : 	   let key = stribog(key), as per HMAC specifications. */
; 388  : 	if (lk > STRIBOG_BLOCKSIZE)

  0002e	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00033	45 8b f1	 mov	 r14d, r9d
  00036	3b d3		 cmp	 edx, ebx
  00038	4d 8b e8	 mov	 r13, r8
  0003b	44 8b e2	 mov	 r12d, edx
  0003e	48 8b e9	 mov	 rbp, rcx
  00041	be 81 01 00 00	 mov	 esi, 385		; 00000181H
  00046	7e 63		 jle	 SHORT $LN40@hmac_strib

; 389  : 	{
; 390  : 		STRIBOG_init (&ctx);

  00048	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  0004d	4c 8b c6	 mov	 r8, rsi
  00050	33 d2		 xor	 edx, edx
  00052	e8 00 00 00 00	 call	 memset

; 391  : 		STRIBOG_add (&ctx, (unsigned char *)k, lk);

  00057	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  0005c	45 8b c4	 mov	 r8d, r12d
  0005f	48 8b d5	 mov	 rdx, rbp
  00062	c6 84 24 1f 01
	00 00 02	 mov	 BYTE PTR ctx$[rsp+255], 2
  0006a	e8 00 00 00 00	 call	 STRIBOG_add

; 392  : 		STRIBOG_finalize (&ctx, (unsigned char *) key);

  0006f	48 8d 94 24 f0
	01 00 00	 lea	 rdx, QWORD PTR key$[rsp]
  00077	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  0007c	e8 00 00 00 00	 call	 STRIBOG_finalize

; 393  : 
; 394  : 		k = key;
; 395  : 		lk = STRIBOG_DIGESTSIZE;
; 396  : 
; 397  : 		burn (&ctx, sizeof(ctx));		// Prevent leaks

  00081	48 8d 7c 24 20	 lea	 rdi, QWORD PTR ctx$[rsp]
  00086	33 c0		 xor	 eax, eax
  00088	48 8b ce	 mov	 rcx, rsi
  0008b	48 8d ac 24 f0
	01 00 00	 lea	 rbp, QWORD PTR key$[rsp]
  00093	44 8b e3	 mov	 r12d, ebx
  00096	48 8d 54 24 20	 lea	 rdx, QWORD PTR ctx$[rsp]
  0009b	44 8b c6	 mov	 r8d, esi
  0009e	f3 aa		 rep stosb
$LL39@hmac_strib:
  000a0	88 02		 mov	 BYTE PTR [rdx], al
  000a2	48 ff c2	 inc	 rdx
  000a5	41 83 e8 01	 sub	 r8d, 1
  000a9	75 f5		 jne	 SHORT $LL39@hmac_strib
$LN40@hmac_strib:

; 398  : 	}
; 399  : 
; 400  : 	/**** Inner Digest ****/
; 401  : 
; 402  : 	STRIBOG_init (&ctx);

  000ab	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  000b0	4c 8b c6	 mov	 r8, rsi
  000b3	33 d2		 xor	 edx, edx
  000b5	e8 00 00 00 00	 call	 memset

; 403  : 
; 404  : 	/* Pad the key for inner digest */
; 405  : 	for (i = 0; i < lk; ++i)

  000ba	49 63 fc	 movsxd	 rdi, r12d
  000bd	45 33 e4	 xor	 r12d, r12d
  000c0	45 33 c0	 xor	 r8d, r8d
  000c3	49 3b fc	 cmp	 rdi, r12
  000c6	c6 84 24 1f 01
	00 00 02	 mov	 BYTE PTR ctx$[rsp+255], 2
  000ce	b2 36		 mov	 dl, 54			; 00000036H
  000d0	7e 26		 jle	 SHORT $LN35@hmac_strib
  000d2	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  000da	4c 8b cd	 mov	 r9, rbp
  000dd	4c 2b c8	 sub	 r9, rax
$LL37@hmac_strib:

; 406  : 		buf[i] = (char) (k[i] ^ 0x36);

  000e0	4a 8d 8c 04 b0
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r8]
  000e8	49 ff c0	 inc	 r8
  000eb	41 8a 04 09	 mov	 al, BYTE PTR [r9+rcx]
  000ef	32 c2		 xor	 al, dl
  000f1	4c 3b c7	 cmp	 r8, rdi
  000f4	88 01		 mov	 BYTE PTR [rcx], al
  000f6	7c e8		 jl	 SHORT $LL37@hmac_strib
$LN35@hmac_strib:

; 407  : 	for (i = lk; i < STRIBOG_BLOCKSIZE; ++i)

  000f8	48 3b fb	 cmp	 rdi, rbx
  000fb	7d 13		 jge	 SHORT $LN34@hmac_strib
  000fd	4c 8b c3	 mov	 r8, rbx
  00100	48 8d 8c 3c b0
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  00108	4c 2b c7	 sub	 r8, rdi
  0010b	e8 00 00 00 00	 call	 memset
$LN34@hmac_strib:

; 408  : 		buf[i] = 0x36;
; 409  : 
; 410  : 	STRIBOG_add (&ctx, (unsigned char *) buf, STRIBOG_BLOCKSIZE);

  00110	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00118	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  0011d	44 8b c3	 mov	 r8d, ebx
  00120	e8 00 00 00 00	 call	 STRIBOG_add

; 411  : 	STRIBOG_add (&ctx, (unsigned char *) d, ld);

  00125	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  0012a	45 8b c6	 mov	 r8d, r14d
  0012d	49 8b d5	 mov	 rdx, r13
  00130	e8 00 00 00 00	 call	 STRIBOG_add

; 412  : 
; 413  : 	STRIBOG_finalize (&ctx, (unsigned char *) inner);

  00135	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR inner$[rsp]
  0013d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  00142	e8 00 00 00 00	 call	 STRIBOG_finalize

; 414  : 
; 415  : 	/**** Outer Digest ****/
; 416  : 	
; 417  : 	STRIBOG_init (&ctx);

  00147	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  0014c	4c 8b c6	 mov	 r8, rsi
  0014f	33 d2		 xor	 edx, edx
  00151	e8 00 00 00 00	 call	 memset

; 418  : 
; 419  : 	for (i = 0; i < lk; ++i)

  00156	49 3b fc	 cmp	 rdi, r12
  00159	c6 84 24 1f 01
	00 00 02	 mov	 BYTE PTR ctx$[rsp+255], 2
  00161	4d 8b c4	 mov	 r8, r12
  00164	b2 5c		 mov	 dl, 92			; 0000005cH
  00166	7e 22		 jle	 SHORT $LN29@hmac_strib
  00168	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00170	48 2b e8	 sub	 rbp, rax
$LL31@hmac_strib:

; 420  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00173	4a 8d 8c 04 b0
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r8]
  0017b	49 ff c0	 inc	 r8
  0017e	8a 04 29	 mov	 al, BYTE PTR [rcx+rbp]
  00181	32 c2		 xor	 al, dl
  00183	4c 3b c7	 cmp	 r8, rdi
  00186	88 01		 mov	 BYTE PTR [rcx], al
  00188	7c e9		 jl	 SHORT $LL31@hmac_strib
$LN29@hmac_strib:

; 421  : 	for (i = lk; i < STRIBOG_BLOCKSIZE; ++i)

  0018a	48 3b fb	 cmp	 rdi, rbx
  0018d	7d 13		 jge	 SHORT $LN28@hmac_strib
  0018f	4c 8b c3	 mov	 r8, rbx
  00192	48 8d 8c 3c b0
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  0019a	4c 2b c7	 sub	 r8, rdi
  0019d	e8 00 00 00 00	 call	 memset
$LN28@hmac_strib:

; 422  : 		buf[i] = 0x5C;
; 423  : 
; 424  : 	STRIBOG_add (&ctx, (unsigned char *) buf, STRIBOG_BLOCKSIZE);

  001a2	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  001aa	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  001af	44 8b c3	 mov	 r8d, ebx
  001b2	e8 00 00 00 00	 call	 STRIBOG_add

; 425  : 	STRIBOG_add (&ctx, (unsigned char *) inner, STRIBOG_DIGESTSIZE);

  001b7	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR inner$[rsp]
  001bf	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  001c4	44 8b c3	 mov	 r8d, ebx
  001c7	e8 00 00 00 00	 call	 STRIBOG_add

; 426  : 
; 427  : 	STRIBOG_finalize (&ctx, (unsigned char *) out);

  001cc	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  001d1	49 8b d7	 mov	 rdx, r15
  001d4	e8 00 00 00 00	 call	 STRIBOG_finalize

; 428  : 
; 429  : 	/* Prevent possible leaks. */
; 430  : 	burn (&ctx, sizeof(ctx));

  001d9	48 8d 7c 24 20	 lea	 rdi, QWORD PTR ctx$[rsp]
  001de	33 c0		 xor	 eax, eax
  001e0	48 8b ce	 mov	 rcx, rsi
  001e3	4c 8d 5c 24 20	 lea	 r11, QWORD PTR ctx$[rsp]
  001e8	f3 aa		 rep stosb
$LL22@hmac_strib:
  001ea	ff ce		 dec	 esi
  001ec	45 88 23	 mov	 BYTE PTR [r11], r12b
  001ef	49 ff c3	 inc	 r11
  001f2	41 3b f4	 cmp	 esi, r12d
  001f5	75 f3		 jne	 SHORT $LL22@hmac_strib

; 431  : 	burn (outer, sizeof(outer));

  001f7	48 8d bc 24 70
	02 00 00	 lea	 rdi, QWORD PTR outer$[rsp]
  001ff	48 8b cb	 mov	 rcx, rbx
  00202	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR outer$[rsp]
  0020a	f3 aa		 rep stosb
  0020c	44 8b c3	 mov	 r8d, ebx
$LL17@hmac_strib:
  0020f	41 ff c8	 dec	 r8d
  00212	44 88 22	 mov	 BYTE PTR [rdx], r12b
  00215	48 ff c2	 inc	 rdx
  00218	45 3b c4	 cmp	 r8d, r12d
  0021b	75 f2		 jne	 SHORT $LL17@hmac_strib

; 432  : 	burn (inner, sizeof(inner));

  0021d	48 8d bc 24 30
	02 00 00	 lea	 rdi, QWORD PTR inner$[rsp]
  00225	48 8b cb	 mov	 rcx, rbx
  00228	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR inner$[rsp]
  00230	f3 aa		 rep stosb
  00232	44 8b c3	 mov	 r8d, ebx
$LL12@hmac_strib:
  00235	41 ff c8	 dec	 r8d
  00238	44 88 22	 mov	 BYTE PTR [rdx], r12b
  0023b	48 ff c2	 inc	 rdx
  0023e	45 3b c4	 cmp	 r8d, r12d
  00241	75 f2		 jne	 SHORT $LL12@hmac_strib

; 433  : 	burn (buf, sizeof(buf));

  00243	48 8d bc 24 b0
	01 00 00	 lea	 rdi, QWORD PTR buf$[rsp]
  0024b	48 8b cb	 mov	 rcx, rbx
  0024e	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00256	f3 aa		 rep stosb
  00258	44 8b c3	 mov	 r8d, ebx
$LL7@hmac_strib:
  0025b	41 ff c8	 dec	 r8d
  0025e	44 88 22	 mov	 BYTE PTR [rdx], r12b
  00261	48 ff c2	 inc	 rdx
  00264	45 3b c4	 cmp	 r8d, r12d
  00267	75 f2		 jne	 SHORT $LL7@hmac_strib

; 434  : 	burn (key, sizeof(key));

  00269	48 8d bc 24 f0
	01 00 00	 lea	 rdi, QWORD PTR key$[rsp]
  00271	48 8b cb	 mov	 rcx, rbx
  00274	48 8d 94 24 f0
	01 00 00	 lea	 rdx, QWORD PTR key$[rsp]
  0027c	f3 aa		 rep stosb
$LL2@hmac_strib:
  0027e	ff cb		 dec	 ebx
  00280	44 88 22	 mov	 BYTE PTR [rdx], r12b
  00283	48 ff c2	 inc	 rdx
  00286	41 3b dc	 cmp	 ebx, r12d
  00289	75 f3		 jne	 SHORT $LL2@hmac_strib

; 435  : }

  0028b	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00293	48 33 cc	 xor	 rcx, rsp
  00296	e8 00 00 00 00	 call	 __security_check_cookie
  0029b	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  002a2	41 5f		 pop	 r15
  002a4	41 5e		 pop	 r14
  002a6	41 5d		 pop	 r13
  002a8	41 5c		 pop	 r12
  002aa	5f		 pop	 rdi
  002ab	5e		 pop	 rsi
  002ac	5d		 pop	 rbp
  002ad	5b		 pop	 rbx
  002ae	c3		 ret	 0
hmac_stribog ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_gosthash
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_u_gosthash DD imagerel $LN33
	DD	imagerel $LN33+321
	DD	imagerel $unwind$derive_u_gosthash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_gosthash DD 072019H
	DD	022010eH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0100H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_u_gosthash
_TEXT	SEGMENT
counter$ = 48
j$ = 56
k$ = 88
init$ = 128
__$ArrayPad$ = 256
pwd$ = 320
pwd_len$ = 328
salt$ = 336
salt_len$ = 344
iterations$ = 352
u$ = 360
b$ = 368
derive_u_gosthash PROC					; COMDAT

; 292  : {

$LN33:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00020	48 8b b4 24 68
	01 00 00	 mov	 rsi, QWORD PTR u$[rsp]

; 293  : 	char j[GOSTHASH_DIGESTSIZE], k[GOSTHASH_DIGESTSIZE];
; 294  : 	char init[128];
; 295  : 	char counter[4];
; 296  : 	int c, i;
; 297  : 
; 298  : 	/* iteration 1 */
; 299  : 	memset (counter, 0, 4);

  00028	33 c0		 xor	 eax, eax
  0002a	4d 8b d0	 mov	 r10, r8
  0002d	89 44 24 30	 mov	 DWORD PTR counter$[rsp], eax

; 300  : 	counter[3] = (char) b;

  00031	8a 84 24 70 01
	00 00		 mov	 al, BYTE PTR b$[rsp]
  00038	49 63 d9	 movsxd	 rbx, r9d
  0003b	48 8b e9	 mov	 rbp, rcx
  0003e	44 8b e2	 mov	 r12d, edx

; 301  : 	memcpy (init, salt, salt_len);	/* salt */

  00041	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR init$[rsp]
  00049	4c 8b c3	 mov	 r8, rbx
  0004c	49 8b d2	 mov	 rdx, r10
  0004f	88 44 24 33	 mov	 BYTE PTR counter$[rsp+3], al
  00053	e8 00 00 00 00	 call	 memcpy

; 302  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00058	8b 54 24 30	 mov	 edx, DWORD PTR counter$[rsp]

; 303  : 	hmac_gosthash (pwd, pwd_len, init, salt_len + 4, j);

  0005c	48 8d 44 24 38	 lea	 rax, QWORD PTR j$[rsp]
  00061	89 94 1c 80 00
	00 00		 mov	 DWORD PTR init$[rsp+rbx], edx
  00068	44 8d 4b 04	 lea	 r9d, DWORD PTR [rbx+4]
  0006c	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR init$[rsp]
  00074	41 8b d4	 mov	 edx, r12d
  00077	48 8b cd	 mov	 rcx, rbp
  0007a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007f	e8 00 00 00 00	 call	 hmac_gosthash

; 304  : 	memcpy (u, j, GOSTHASH_DIGESTSIZE);

  00084	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
  00089	48 8d 54 24 38	 lea	 rdx, QWORD PTR j$[rsp]
  0008e	4c 8b c3	 mov	 r8, rbx
  00091	48 8b ce	 mov	 rcx, rsi
  00094	e8 00 00 00 00	 call	 memcpy

; 305  : 
; 306  : 	/* remaining iterations */
; 307  : 	for (c = 1; c < iterations; c++)

  00099	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000a0	83 f8 01	 cmp	 eax, 1
  000a3	7e 46		 jle	 SHORT $LN10@derive_u_g
  000a5	48 8d 4c 24 58	 lea	 rcx, QWORD PTR k$[rsp]
  000aa	8d 78 ff	 lea	 edi, DWORD PTR [rax-1]
  000ad	48 2b f1	 sub	 rsi, rcx
$LL16@derive_u_g:

; 308  : 	{
; 309  : 		hmac_gosthash (pwd, pwd_len, j, GOSTHASH_DIGESTSIZE, k);

  000b0	48 8d 44 24 58	 lea	 rax, QWORD PTR k$[rsp]
  000b5	4c 8d 44 24 38	 lea	 r8, QWORD PTR j$[rsp]
  000ba	44 8b cb	 mov	 r9d, ebx
  000bd	41 8b d4	 mov	 edx, r12d
  000c0	48 8b cd	 mov	 rcx, rbp
  000c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c8	e8 00 00 00 00	 call	 hmac_gosthash

; 310  : 		for (i = 0; i < GOSTHASH_DIGESTSIZE; i++)

  000cd	33 d2		 xor	 edx, edx
$LL13@derive_u_g:

; 311  : 		{
; 312  : 			u[i] ^= k[i];

  000cf	48 8d 4c 14 58	 lea	 rcx, QWORD PTR k$[rsp+rdx]
  000d4	48 ff c2	 inc	 rdx
  000d7	8a 01		 mov	 al, BYTE PTR [rcx]
  000d9	30 04 0e	 xor	 BYTE PTR [rsi+rcx], al
  000dc	48 3b d3	 cmp	 rdx, rbx

; 313  : 			j[i] = k[i];

  000df	88 44 14 37	 mov	 BYTE PTR j$[rsp+rdx-1], al
  000e3	7c ea		 jl	 SHORT $LL13@derive_u_g

; 305  : 
; 306  : 	/* remaining iterations */
; 307  : 	for (c = 1; c < iterations; c++)

  000e5	48 83 ef 01	 sub	 rdi, 1
  000e9	75 c5		 jne	 SHORT $LL16@derive_u_g
$LN10@derive_u_g:

; 314  : 		}
; 315  : 	}
; 316  : 
; 317  : 	/* Prevent possible leaks. */
; 318  : 	burn (j, sizeof(j));

  000eb	48 8d 7c 24 38	 lea	 rdi, QWORD PTR j$[rsp]
  000f0	33 c0		 xor	 eax, eax
  000f2	48 8b cb	 mov	 rcx, rbx
  000f5	48 8d 54 24 38	 lea	 rdx, QWORD PTR j$[rsp]
  000fa	44 8b c3	 mov	 r8d, ebx
  000fd	f3 aa		 rep stosb
$LL7@derive_u_g:
  000ff	88 02		 mov	 BYTE PTR [rdx], al
  00101	48 ff c2	 inc	 rdx
  00104	41 83 e8 01	 sub	 r8d, 1
  00108	75 f5		 jne	 SHORT $LL7@derive_u_g

; 319  : 	burn (k, sizeof(k));

  0010a	48 8d 7c 24 58	 lea	 rdi, QWORD PTR k$[rsp]
  0010f	48 8b cb	 mov	 rcx, rbx
  00112	48 8d 54 24 58	 lea	 rdx, QWORD PTR k$[rsp]
  00117	f3 aa		 rep stosb
$LL2@derive_u_g:
  00119	88 02		 mov	 BYTE PTR [rdx], al
  0011b	48 ff c2	 inc	 rdx
  0011e	83 eb 01	 sub	 ebx, 1
  00121	75 f6		 jne	 SHORT $LL2@derive_u_g

; 320  : }

  00123	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012b	48 33 cc	 xor	 rcx, rsp
  0012e	e8 00 00 00 00	 call	 __security_check_cookie
  00133	48 81 c4 10 01
	00 00		 add	 rsp, 272		; 00000110H
  0013a	41 5c		 pop	 r12
  0013c	5f		 pop	 rdi
  0013d	5e		 pop	 rsi
  0013e	5d		 pop	 rbp
  0013f	5b		 pop	 rbx
  00140	c3		 ret	 0
derive_u_gosthash ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_stribog
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_u_stribog DD imagerel $LN33
	DD	imagerel $LN33+336
	DD	imagerel $unwind$derive_u_stribog
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_stribog DD 072019H
	DD	02a010eH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0140H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_u_stribog
_TEXT	SEGMENT
counter$ = 48
j$ = 64
k$ = 128
init$ = 192
__$ArrayPad$ = 320
pwd$ = 384
pwd_len$ = 392
salt$ = 400
salt_len$ = 408
iterations$ = 416
u$ = 424
b$ = 432
derive_u_stribog PROC					; COMDAT

; 452  : {

$LN33:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00020	48 8b b4 24 a8
	01 00 00	 mov	 rsi, QWORD PTR u$[rsp]

; 453  : 	char j[STRIBOG_DIGESTSIZE], k[STRIBOG_DIGESTSIZE];
; 454  : 	char init[128];
; 455  : 	char counter[4];
; 456  : 	int c, i;
; 457  : 
; 458  : 	/* iteration 1 */
; 459  : 	memset (counter, 0, 4);

  00028	33 c0		 xor	 eax, eax
  0002a	4d 8b d0	 mov	 r10, r8
  0002d	89 44 24 30	 mov	 DWORD PTR counter$[rsp], eax

; 460  : 	counter[3] = (char) b;

  00031	8a 84 24 b0 01
	00 00		 mov	 al, BYTE PTR b$[rsp]
  00038	49 63 d9	 movsxd	 rbx, r9d
  0003b	48 8b e9	 mov	 rbp, rcx
  0003e	44 8b e2	 mov	 r12d, edx

; 461  : 	memcpy (init, salt, salt_len);	/* salt */

  00041	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR init$[rsp]
  00049	4c 8b c3	 mov	 r8, rbx
  0004c	49 8b d2	 mov	 rdx, r10
  0004f	88 44 24 33	 mov	 BYTE PTR counter$[rsp+3], al
  00053	e8 00 00 00 00	 call	 memcpy

; 462  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00058	8b 54 24 30	 mov	 edx, DWORD PTR counter$[rsp]

; 463  : 	hmac_stribog (pwd, pwd_len, init, salt_len + 4, j);

  0005c	48 8d 44 24 40	 lea	 rax, QWORD PTR j$[rsp]
  00061	89 94 1c c0 00
	00 00		 mov	 DWORD PTR init$[rsp+rbx], edx
  00068	44 8d 4b 04	 lea	 r9d, DWORD PTR [rbx+4]
  0006c	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR init$[rsp]
  00074	41 8b d4	 mov	 edx, r12d
  00077	48 8b cd	 mov	 rcx, rbp
  0007a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007f	e8 00 00 00 00	 call	 hmac_stribog

; 464  : 	memcpy (u, j, STRIBOG_DIGESTSIZE);

  00084	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00089	48 8d 54 24 40	 lea	 rdx, QWORD PTR j$[rsp]
  0008e	4c 8b c3	 mov	 r8, rbx
  00091	48 8b ce	 mov	 rcx, rsi
  00094	e8 00 00 00 00	 call	 memcpy

; 465  : 
; 466  : 	/* remaining iterations */
; 467  : 	for (c = 1; c < iterations; c++)

  00099	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000a0	83 f8 01	 cmp	 eax, 1
  000a3	7e 4f		 jle	 SHORT $LN10@derive_u_s
  000a5	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  000ad	8d 78 ff	 lea	 edi, DWORD PTR [rax-1]
  000b0	48 2b f1	 sub	 rsi, rcx
$LL16@derive_u_s:

; 468  : 	{
; 469  : 		hmac_stribog (pwd, pwd_len, j, STRIBOG_DIGESTSIZE, k);

  000b3	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  000bb	4c 8d 44 24 40	 lea	 r8, QWORD PTR j$[rsp]
  000c0	44 8b cb	 mov	 r9d, ebx
  000c3	41 8b d4	 mov	 edx, r12d
  000c6	48 8b cd	 mov	 rcx, rbp
  000c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ce	e8 00 00 00 00	 call	 hmac_stribog

; 470  : 		for (i = 0; i < STRIBOG_DIGESTSIZE; i++)

  000d3	33 d2		 xor	 edx, edx
$LL13@derive_u_s:

; 471  : 		{
; 472  : 			u[i] ^= k[i];

  000d5	48 8d 8c 14 80
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp+rdx]
  000dd	48 ff c2	 inc	 rdx
  000e0	8a 01		 mov	 al, BYTE PTR [rcx]
  000e2	30 04 0e	 xor	 BYTE PTR [rsi+rcx], al
  000e5	48 3b d3	 cmp	 rdx, rbx

; 473  : 			j[i] = k[i];

  000e8	88 44 14 3f	 mov	 BYTE PTR j$[rsp+rdx-1], al
  000ec	7c e7		 jl	 SHORT $LL13@derive_u_s

; 465  : 
; 466  : 	/* remaining iterations */
; 467  : 	for (c = 1; c < iterations; c++)

  000ee	48 83 ef 01	 sub	 rdi, 1
  000f2	75 bf		 jne	 SHORT $LL16@derive_u_s
$LN10@derive_u_s:

; 474  : 		}
; 475  : 	}
; 476  : 
; 477  : 	/* Prevent possible leaks. */
; 478  : 	burn (j, sizeof(j));

  000f4	48 8d 7c 24 40	 lea	 rdi, QWORD PTR j$[rsp]
  000f9	33 c0		 xor	 eax, eax
  000fb	48 8b cb	 mov	 rcx, rbx
  000fe	48 8d 54 24 40	 lea	 rdx, QWORD PTR j$[rsp]
  00103	44 8b c3	 mov	 r8d, ebx
  00106	f3 aa		 rep stosb
$LL7@derive_u_s:
  00108	88 02		 mov	 BYTE PTR [rdx], al
  0010a	48 ff c2	 inc	 rdx
  0010d	41 83 e8 01	 sub	 r8d, 1
  00111	75 f5		 jne	 SHORT $LL7@derive_u_s

; 479  : 	burn (k, sizeof(k));

  00113	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR k$[rsp]
  0011b	48 8b cb	 mov	 rcx, rbx
  0011e	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00126	f3 aa		 rep stosb
$LL2@derive_u_s:
  00128	88 02		 mov	 BYTE PTR [rdx], al
  0012a	48 ff c2	 inc	 rdx
  0012d	83 eb 01	 sub	 ebx, 1
  00130	75 f6		 jne	 SHORT $LL2@derive_u_s

; 480  : }

  00132	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0013a	48 33 cc	 xor	 rcx, rsp
  0013d	e8 00 00 00 00	 call	 __security_check_cookie
  00142	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  00149	41 5c		 pop	 r12
  0014b	5f		 pop	 rdi
  0014c	5e		 pop	 rsi
  0014d	5d		 pop	 rbp
  0014e	5b		 pop	 rbx
  0014f	c3		 ret	 0
derive_u_stribog ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_gosthash
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_key_gosthash DD imagerel $LN20
	DD	imagerel $LN20+309
	DD	imagerel $unwind$derive_key_gosthash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_gosthash DD 0a2319H
	DD	0110114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	070H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_key_gosthash
_TEXT	SEGMENT
salt_len$GSCopy$1$ = 64
salt$GSCopy$1$ = 72
u$ = 80
__$ArrayPad$ = 112
pwd$ = 208
pwd_len$ = 216
salt$ = 224
salt_len$ = 232
iterations$ = 240
dk$ = 248
dklen$ = 256
derive_key_gosthash PROC				; COMDAT

; 337  : {

$LN20:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 338  : 	char u[GOSTHASH_DIGESTSIZE];
; 339  : 	int b, l, r;
; 340  : 
; 341  : 	if (dklen % GOSTHASH_DIGESTSIZE)

  00023	8b b4 24 00 01
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  0002a	4c 8b ac 24 f8
	00 00 00	 mov	 r13, QWORD PTR dk$[rsp]
  00032	44 8b fa	 mov	 r15d, edx
  00035	8b c6		 mov	 eax, esi
  00037	44 89 4c 24 40	 mov	 DWORD PTR salt_len$GSCopy$1$[rsp], r9d
  0003c	4c 89 44 24 48	 mov	 QWORD PTR salt$GSCopy$1$[rsp], r8
  00041	99		 cdq
  00042	4c 8b f1	 mov	 r14, rcx
  00045	83 e2 1f	 and	 edx, 31
  00048	03 c2		 add	 eax, edx
  0004a	8b f8		 mov	 edi, eax
  0004c	83 e0 1f	 and	 eax, 31
  0004f	c1 ff 05	 sar	 edi, 5
  00052	3b c2		 cmp	 eax, edx
  00054	74 02		 je	 SHORT $LN9@derive_key@2

; 342  : 	{
; 343  : 		l = 1 + dklen / GOSTHASH_DIGESTSIZE;

  00056	ff c7		 inc	 edi
$LN9@derive_key@2:

; 344  : 	}
; 345  : 	else
; 346  : 	{
; 347  : 		l = dklen / GOSTHASH_DIGESTSIZE;
; 348  : 	}
; 349  : 
; 350  : 	r = dklen - (l - 1) * GOSTHASH_DIGESTSIZE;
; 351  : 
; 352  : 	/* first l - 1 blocks */
; 353  : 	for (b = 1; b < l; b++)

  00058	44 8b a4 24 f0
	00 00 00	 mov	 r12d, DWORD PTR iterations$[rsp]
  00060	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
  00065	8b c7		 mov	 eax, edi
  00067	c1 e0 05	 shl	 eax, 5
  0006a	8d 6b e1	 lea	 ebp, QWORD PTR [rbx-31]
  0006d	2b f0		 sub	 esi, eax
  0006f	03 f3		 add	 esi, ebx
  00071	3b fd		 cmp	 edi, ebp
  00073	89 b4 24 00 01
	00 00		 mov	 DWORD PTR dklen$[rsp], esi
  0007a	7e 4e		 jle	 SHORT $LN6@derive_key@2
  0007c	49 8b f0	 mov	 rsi, r8
$LL8@derive_key@2:

; 354  : 	{
; 355  : 		derive_u_gosthash (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0007f	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00084	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  00088	4c 8b c6	 mov	 r8, rsi
  0008b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00090	41 8b d7	 mov	 edx, r15d
  00093	49 8b ce	 mov	 rcx, r14
  00096	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  0009b	e8 00 00 00 00	 call	 derive_u_gosthash

; 356  : 		memcpy (dk, u, GOSTHASH_DIGESTSIZE);

  000a0	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  000a5	49 8b cd	 mov	 rcx, r13
  000a8	4c 8b c3	 mov	 r8, rbx
  000ab	e8 00 00 00 00	 call	 memcpy
  000b0	44 8b 4c 24 40	 mov	 r9d, DWORD PTR salt_len$GSCopy$1$[rsp]
  000b5	ff c5		 inc	 ebp

; 357  : 		dk += GOSTHASH_DIGESTSIZE;

  000b7	4c 03 eb	 add	 r13, rbx
  000ba	3b ef		 cmp	 ebp, edi
  000bc	7c c1		 jl	 SHORT $LL8@derive_key@2
  000be	8b b4 24 00 01
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  000c5	4c 8b 44 24 48	 mov	 r8, QWORD PTR salt$GSCopy$1$[rsp]
$LN6@derive_key@2:

; 358  : 	}
; 359  : 
; 360  : 	/* last block */
; 361  : 	derive_u_gosthash (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000ca	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000cf	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  000d3	41 8b d7	 mov	 edx, r15d
  000d6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000db	49 8b ce	 mov	 rcx, r14
  000de	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  000e3	e8 00 00 00 00	 call	 derive_u_gosthash

; 362  : 	memcpy (dk, u, r);

  000e8	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  000ed	4c 63 c6	 movsxd	 r8, esi
  000f0	49 8b cd	 mov	 rcx, r13
  000f3	e8 00 00 00 00	 call	 memcpy

; 363  : 
; 364  : 
; 365  : 	/* Prevent possible leaks. */
; 366  : 	burn (u, sizeof(u));

  000f8	48 8d 7c 24 50	 lea	 rdi, QWORD PTR u$[rsp]
  000fd	33 c0		 xor	 eax, eax
  000ff	48 8b cb	 mov	 rcx, rbx
  00102	4c 8d 5c 24 50	 lea	 r11, QWORD PTR u$[rsp]
  00107	f3 aa		 rep stosb
$LL2@derive_key@2:
  00109	41 88 03	 mov	 BYTE PTR [r11], al
  0010c	49 ff c3	 inc	 r11
  0010f	83 eb 01	 sub	 ebx, 1
  00112	75 f5		 jne	 SHORT $LL2@derive_key@2

; 367  : }

  00114	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00128	41 5f		 pop	 r15
  0012a	41 5e		 pop	 r14
  0012c	41 5d		 pop	 r13
  0012e	41 5c		 pop	 r12
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	5d		 pop	 rbp
  00133	5b		 pop	 rbx
  00134	c3		 ret	 0
derive_key_gosthash ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_stribog
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_key_stribog DD imagerel $LN20
	DD	imagerel $LN20+315
	DD	imagerel $unwind$derive_key_stribog
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_stribog DD 0a2619H
	DD	0150114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	090H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_key_stribog
_TEXT	SEGMENT
salt_len$GSCopy$1$ = 64
salt$GSCopy$1$ = 72
u$ = 80
__$ArrayPad$ = 144
pwd$ = 240
pwd_len$ = 248
salt$ = 256
salt_len$ = 264
iterations$ = 272
dk$ = 280
dklen$ = 288
derive_key_stribog PROC					; COMDAT

; 497  : {

$LN20:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 498  : 	char u[STRIBOG_DIGESTSIZE];
; 499  : 	int b, l, r;
; 500  : 
; 501  : 	if (dklen % STRIBOG_DIGESTSIZE)

  00026	8b b4 24 20 01
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  0002d	4c 8b ac 24 18
	01 00 00	 mov	 r13, QWORD PTR dk$[rsp]
  00035	44 8b fa	 mov	 r15d, edx
  00038	8b c6		 mov	 eax, esi
  0003a	44 89 4c 24 40	 mov	 DWORD PTR salt_len$GSCopy$1$[rsp], r9d
  0003f	4c 89 44 24 48	 mov	 QWORD PTR salt$GSCopy$1$[rsp], r8
  00044	99		 cdq
  00045	4c 8b f1	 mov	 r14, rcx
  00048	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004b	03 c2		 add	 eax, edx
  0004d	8b f8		 mov	 edi, eax
  0004f	83 e0 3f	 and	 eax, 63			; 0000003fH
  00052	c1 ff 06	 sar	 edi, 6
  00055	3b c2		 cmp	 eax, edx
  00057	74 02		 je	 SHORT $LN9@derive_key@3

; 502  : 	{
; 503  : 		l = 1 + dklen / STRIBOG_DIGESTSIZE;

  00059	ff c7		 inc	 edi
$LN9@derive_key@3:

; 504  : 	}
; 505  : 	else
; 506  : 	{
; 507  : 		l = dklen / STRIBOG_DIGESTSIZE;
; 508  : 	}
; 509  : 
; 510  : 	r = dklen - (l - 1) * STRIBOG_DIGESTSIZE;
; 511  : 
; 512  : 	/* first l - 1 blocks */
; 513  : 	for (b = 1; b < l; b++)

  0005b	44 8b a4 24 10
	01 00 00	 mov	 r12d, DWORD PTR iterations$[rsp]
  00063	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00068	8b c7		 mov	 eax, edi
  0006a	c1 e0 06	 shl	 eax, 6
  0006d	8d 6b c1	 lea	 ebp, QWORD PTR [rbx-63]
  00070	2b f0		 sub	 esi, eax
  00072	03 f3		 add	 esi, ebx
  00074	3b fd		 cmp	 edi, ebp
  00076	89 b4 24 20 01
	00 00		 mov	 DWORD PTR dklen$[rsp], esi
  0007d	7e 4e		 jle	 SHORT $LN6@derive_key@3
  0007f	49 8b f0	 mov	 rsi, r8
$LL8@derive_key@3:

; 514  : 	{
; 515  : 		derive_u_stribog (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00082	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00087	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0008b	4c 8b c6	 mov	 r8, rsi
  0008e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00093	41 8b d7	 mov	 edx, r15d
  00096	49 8b ce	 mov	 rcx, r14
  00099	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  0009e	e8 00 00 00 00	 call	 derive_u_stribog

; 516  : 		memcpy (dk, u, STRIBOG_DIGESTSIZE);

  000a3	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  000a8	49 8b cd	 mov	 rcx, r13
  000ab	4c 8b c3	 mov	 r8, rbx
  000ae	e8 00 00 00 00	 call	 memcpy
  000b3	44 8b 4c 24 40	 mov	 r9d, DWORD PTR salt_len$GSCopy$1$[rsp]
  000b8	ff c5		 inc	 ebp

; 517  : 		dk += STRIBOG_DIGESTSIZE;

  000ba	4c 03 eb	 add	 r13, rbx
  000bd	3b ef		 cmp	 ebp, edi
  000bf	7c c1		 jl	 SHORT $LL8@derive_key@3
  000c1	8b b4 24 20 01
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  000c8	4c 8b 44 24 48	 mov	 r8, QWORD PTR salt$GSCopy$1$[rsp]
$LN6@derive_key@3:

; 518  : 	}
; 519  : 
; 520  : 	/* last block */
; 521  : 	derive_u_stribog (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000cd	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000d2	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  000d6	41 8b d7	 mov	 edx, r15d
  000d9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000de	49 8b ce	 mov	 rcx, r14
  000e1	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  000e6	e8 00 00 00 00	 call	 derive_u_stribog

; 522  : 	memcpy (dk, u, r);

  000eb	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  000f0	4c 63 c6	 movsxd	 r8, esi
  000f3	49 8b cd	 mov	 rcx, r13
  000f6	e8 00 00 00 00	 call	 memcpy

; 523  : 
; 524  : 
; 525  : 	/* Prevent possible leaks. */
; 526  : 	burn (u, sizeof(u));

  000fb	48 8d 7c 24 50	 lea	 rdi, QWORD PTR u$[rsp]
  00100	33 c0		 xor	 eax, eax
  00102	48 8b cb	 mov	 rcx, rbx
  00105	4c 8d 5c 24 50	 lea	 r11, QWORD PTR u$[rsp]
  0010a	f3 aa		 rep stosb
$LL2@derive_key@3:
  0010c	41 88 03	 mov	 BYTE PTR [r11], al
  0010f	49 ff c3	 inc	 r11
  00112	83 eb 01	 sub	 ebx, 1
  00115	75 f5		 jne	 SHORT $LL2@derive_key@3

; 527  : }

  00117	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0011f	48 33 cc	 xor	 rcx, rsp
  00122	e8 00 00 00 00	 call	 __security_check_cookie
  00127	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0012e	41 5f		 pop	 r15
  00130	41 5e		 pop	 r14
  00132	41 5d		 pop	 r13
  00134	41 5c		 pop	 r12
  00136	5f		 pop	 rdi
  00137	5e		 pop	 rsi
  00138	5d		 pop	 rbp
  00139	5b		 pop	 rbx
  0013a	c3		 ret	 0
derive_key_stribog ENDP
END
