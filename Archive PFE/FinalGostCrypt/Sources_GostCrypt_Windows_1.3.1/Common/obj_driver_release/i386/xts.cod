; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\xts.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ks$GSCopy$
PUBLIC	_ks2$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_EncryptBufferXTS8Byte@32
EXTRN	_XorKeySchedule@20:PROC
EXTRN	_EncipherBlock@12:PROC
EXTRN	_CipherGetKeyScheduleSize@4:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\xts.c
;	COMDAT _EncryptBufferXTS8Byte@32
_TEXT	SEGMENT
_ks$GSCopy$ = -596					; size = 4
_ks2$GSCopy$ = -592					; size = 4
_dataUnitNo$ = -588					; size = 8
_block$ = -580						; size = 4
_startBlock$ = -576					; size = 4
_blockCount$ = -572					; size = 8
_xor_ks$ = -564						; size = 544
_whiteningValue$ = -20					; size = 8
_byteBufUnitNo$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTS8Byte@32 PROC				; COMDAT

; 102  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 54 02 00
	00		 sub	 esp, 596		; 00000254H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00018	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]

; 103  : 	unsigned __int8 finalCarry;
; 104  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
; 105  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
; 106  : 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *)whiteningValue;
; 107  : 	unsigned __int32 *bufPtr = (unsigned __int32 *)buffer;
; 108  : 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;

  0001b	89 8d b0 fd ff
	ff		 mov	 DWORD PTR _ks2$GSCopy$[ebp], ecx
  00021	8b 4d 18	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  00024	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], ecx

; 109  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 110  : 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
; 111  : 
; 112  : 	dataUnitNo = startDataUnitNo->Value;

  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	53		 push	 ebx
  00030	8b 5d 08	 mov	 ebx, DWORD PTR _buffer$[ebp]
  00033	89 8d b4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  00039	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax

; 113  : 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64(dataUnitNo);

  0003f	89 4d f4	 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx

; 114  : 
; 115  : 	if (length % BYTES_PER_XTS_BLOCK_SMALL)

  00042	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00045	89 45 f8	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], eax
  00048	56		 push	 esi
  00049	8b c1		 mov	 eax, ecx
  0004b	57		 push	 edi
  0004c	8b 7d 1c	 mov	 edi, DWORD PTR _ks$[ebp]
  0004f	83 e0 07	 and	 eax, 7
  00052	33 d2		 xor	 edx, edx
  00054	0b c2		 or	 eax, edx
  00056	89 bd ac fd ff
	ff		 mov	 DWORD PTR _ks$GSCopy$[ebp], edi
  0005c	74 11		 je	 SHORT $LN16@EncryptBuf

; 116  : 		GST_THROW_FATAL_EXCEPTION;

  0005e	68 54 53 47 00	 push	 4674388			; 00475354H
  00063	52		 push	 edx
  00064	52		 push	 edx
  00065	6a 74		 push	 116			; 00000074H
  00067	6a 29		 push	 41			; 00000029H
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN39@EncryptBuf:
$LN16@EncryptBuf:

; 117  : 
; 118  : 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;

  0006f	8b 75 10	 mov	 esi, DWORD PTR _length$[ebp+4]

; 119  : 
; 120  : 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));

  00072	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00075	0f ac f1 03	 shrd	 ecx, esi, 3
  00079	c1 ee 03	 shr	 esi, 3
  0007c	89 b5 c8 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], esi
  00082	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], ecx
  00088	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0008d	50		 push	 eax
  0008e	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  00094	57		 push	 edi
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _memcpy
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 121  : 
; 122  : 	while (blockCount > 0)

  0009e	85 f6		 test	 esi, esi
  000a0	77 35		 ja	 SHORT $LN32@EncryptBuf
  000a2	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp], 0
  000a9	0f 86 49 01 00
	00		 jbe	 $LN5@EncryptBuf
  000af	eb 06		 jmp	 SHORT $LN15@EncryptBuf
$LL31@EncryptBuf:
  000b1	8b b5 c8 fd ff
	ff		 mov	 esi, DWORD PTR _blockCount$[ebp+4]
$LN15@EncryptBuf:

; 123  : 	{
; 124  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)

  000b7	85 f6		 test	 esi, esi
  000b9	77 1c		 ja	 SHORT $LN32@EncryptBuf
  000bb	72 09		 jb	 SHORT $LN36@EncryptBuf
  000bd	83 bd c4 fd ff
	ff 40		 cmp	 DWORD PTR _blockCount$[ebp], 64 ; 00000040H
  000c4	73 11		 jae	 SHORT $LN32@EncryptBuf
$LN36@EncryptBuf:

; 125  : 			endBlock = startBlock + (unsigned __int32) blockCount;

  000c6	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _startBlock$[ebp]
  000cc	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp]
  000d2	8d 3c 01	 lea	 edi, DWORD PTR [ecx+eax]

; 126  : 		else

  000d5	eb 03		 jmp	 SHORT $LN12@EncryptBuf
$LN32@EncryptBuf:

; 127  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;

  000d7	6a 40		 push	 64			; 00000040H
  000d9	5f		 pop	 edi
$LN12@EncryptBuf:

; 128  : 
; 129  : 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
; 130  : 
; 131  : 		//Generate first whitening value
; 132  : 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);

  000da	8b 45 f4	 mov	 eax, DWORD PTR _byteBufUnitNo$[ebp]

; 133  : 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);
; 134  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000dd	ff b5 b0 fd ff
	ff		 push	 DWORD PTR _ks2$GSCopy$[ebp]
  000e3	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000e6	8b 45 f8	 mov	 eax, DWORD PTR _byteBufUnitNo$[ebp+4]
  000e9	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000ec	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000ef	8b c6		 mov	 eax, esi
  000f1	50		 push	 eax
  000f2	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  000f5	e8 00 00 00 00	 call	 _EncipherBlock@12

; 135  : 
; 136  : 		//XOR ks with the current DataUnitNo
; 137  : 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);

  000fa	6a 08		 push	 8
  000fc	8d 45 f4	 lea	 eax, DWORD PTR _byteBufUnitNo$[ebp]
  000ff	50		 push	 eax
  00100	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  00106	50		 push	 eax
  00107	ff b5 ac fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$[ebp]
  0010d	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00110	e8 00 00 00 00	 call	 _XorKeySchedule@20

; 138  : 
; 139  : 		//Generate subsequent whitening values for blocks
; 140  : 		for (block = 0; block < endBlock; block++)

  00115	33 c0		 xor	 eax, eax
  00117	89 85 bc fd ff
	ff		 mov	 DWORD PTR _block$[ebp], eax
  0011d	3b f8		 cmp	 edi, eax
  0011f	0f 86 81 00 00
	00		 jbe	 $LN33@EncryptBuf
$LL11@EncryptBuf:

; 141  : 		{
; 142  : 			if (block >= startBlock)

  00125	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  0012b	3b 85 c0 fd ff
	ff		 cmp	 eax, DWORD PTR _startBlock$[ebp]
  00131	72 36		 jb	 SHORT $LN8@EncryptBuf

; 143  : 			{
; 144  : 				//Pre-whitening
; 145  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  00133	8b 06		 mov	 eax, DWORD PTR [esi]
  00135	31 03		 xor	 DWORD PTR [ebx], eax
  00137	6a 04		 push	 4
  00139	58		 pop	 eax
  0013a	03 f0		 add	 esi, eax

; 146  : 				*bufPtr-- ^= *whiteningValuePtr32--;

  0013c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0013e	03 d8		 add	 ebx, eax
  00140	31 0b		 xor	 DWORD PTR [ebx], ecx
  00142	2b d8		 sub	 ebx, eax
  00144	2b f0		 sub	 esi, eax

; 147  : 
; 148  : 				//Actual encryption
; 149  : 				EncipherBlock(cipher, bufPtr, xor_ks);

  00146	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  0014c	50		 push	 eax
  0014d	53		 push	 ebx
  0014e	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00151	e8 00 00 00 00	 call	 _EncipherBlock@12

; 150  : 
; 151  : 				//Post-whitening
; 152  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  00156	8b 06		 mov	 eax, DWORD PTR [esi]
  00158	31 03		 xor	 DWORD PTR [ebx], eax
  0015a	83 c6 04	 add	 esi, 4

; 153  : 				*bufPtr++ ^= *whiteningValuePtr32;

  0015d	8b 06		 mov	 eax, DWORD PTR [esi]
  0015f	83 c3 04	 add	 ebx, 4
  00162	31 03		 xor	 DWORD PTR [ebx], eax
  00164	83 c3 04	 add	 ebx, 4

; 154  : 			}
; 155  : 			else

  00167	eb 03		 jmp	 SHORT $LN7@EncryptBuf
$LN8@EncryptBuf:

; 156  : 				whiteningValuePtr32++;

  00169	83 c6 04	 add	 esi, 4
$LN7@EncryptBuf:

; 157  : 
; 158  : 			//Derive the next whitening value
; 159  : #if BYTE_ORDER == LITTLE_ENDIAN
; 160  : 
; 161  : 			//Little-endian platforms
; 162  : 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;

  0016c	8b 16		 mov	 edx, DWORD PTR [esi]
  0016e	8b c2		 mov	 eax, edx
  00170	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00175	23 c1		 and	 eax, ecx
  00177	f7 d8		 neg	 eax
  00179	1a c0		 sbb	 al, al

; 163  : 
; 164  : 			*whiteningValuePtr32-- <<= 1;

  0017b	03 d2		 add	 edx, edx
  0017d	89 16		 mov	 DWORD PTR [esi], edx
  0017f	83 ee 04	 sub	 esi, 4

; 165  : 
; 166  : 			if (*whiteningValuePtr32 & 0x80000000)

  00182	8b 16		 mov	 edx, DWORD PTR [esi]
  00184	24 1b		 and	 al, 27			; 0000001bH
  00186	85 d1		 test	 edx, ecx
  00188	74 04		 je	 SHORT $LN6@EncryptBuf

; 167  : 				*(whiteningValuePtr32 + 1) |= 1;

  0018a	83 4e 04 01	 or	 DWORD PTR [esi+4], 1
$LN6@EncryptBuf:

; 168  : 
; 169  : 			*whiteningValuePtr32 <<= 1;

  0018e	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  00191	89 0e		 mov	 DWORD PTR [esi], ecx

; 170  : #else
; 171  : 			//Big-endian platforms
; 172  : 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
; 173  : 
; 174  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 175  : 
; 176  : 			whiteningValuePtr32--;
; 177  : 
; 178  : 			if (*whiteningValuePtr32 & 0x80)
; 179  : 				*(whiteningValuePtr32 + 1) |= 0x01000000;
; 180  : 
; 181  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 182  : #endif
; 183  : 			whiteningValue[0] ^= finalCarry;

  00193	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  00196	ff 85 bc fd ff
	ff		 inc	 DWORD PTR _block$[ebp]
  0019c	39 bd bc fd ff
	ff		 cmp	 DWORD PTR _block$[ebp], edi
  001a2	72 81		 jb	 SHORT $LL11@EncryptBuf

; 138  : 
; 139  : 		//Generate subsequent whitening values for blocks
; 140  : 		for (block = 0; block < endBlock; block++)

  001a4	33 c0		 xor	 eax, eax
$LN33@EncryptBuf:

; 184  : 		}
; 185  : 		blockCount -= endBlock - startBlock;

  001a6	2b bd c0 fd ff
	ff		 sub	 edi, DWORD PTR _startBlock$[ebp]

; 186  : 		startBlock = 0;

  001ac	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], eax
  001b2	29 bd c4 fd ff
	ff		 sub	 DWORD PTR _blockCount$[ebp], edi
  001b8	19 85 c8 fd ff
	ff		 sbb	 DWORD PTR _blockCount$[ebp+4], eax

; 187  : 		dataUnitNo++;

  001be	83 85 b4 fd ff
	ff 01		 add	 DWORD PTR _dataUnitNo$[ebp], 1

; 188  : 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  001c5	8b 8d b4 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  001cb	89 4d f4	 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  001ce	11 85 b8 fd ff
	ff		 adc	 DWORD PTR _dataUnitNo$[ebp+4], eax
  001d4	8b 8d b8 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp+4]
  001da	89 4d f8	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx
  001dd	39 85 c8 fd ff
	ff		 cmp	 DWORD PTR _blockCount$[ebp+4], eax
  001e3	0f 87 c8 fe ff
	ff		 ja	 $LL31@EncryptBuf

; 121  : 
; 122  : 	while (blockCount > 0)

  001e9	72 0d		 jb	 SHORT $LN5@EncryptBuf
  001eb	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp], 0
  001f2	0f 87 b9 fe ff
	ff		 ja	 $LL31@EncryptBuf
$LN5@EncryptBuf:
  001f8	5f		 pop	 edi

; 189  : 	}
; 190  : 	FAST_ERASE32(whiteningValue, sizeof(whiteningValue));

  001f9	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _whiteningValue$[ebp], 0

; 191  : }

  00200	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00203	5e		 pop	 esi
  00204	33 cd		 xor	 ecx, ebp
  00206	5b		 pop	 ebx
  00207	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020c	c9		 leave
  0020d	c2 20 00	 ret	 32			; 00000020H
$LN37@EncryptBuf:
_EncryptBufferXTS8Byte@32 ENDP
_TEXT	ENDS
PUBLIC	_ks2$GSCopy$
PUBLIC	_ks$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_EncipherBlocks@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptBufferXTSParallel@32
_TEXT	SEGMENT
_ks$GSCopy$ = -576					; size = 4
_ks2$GSCopy$ = -572					; size = 4
_dataUnitNo$ = -568					; size = 8
_startBlock$ = -560					; size = 4
_block$ = -556						; size = 4
_blockCount$ = -552					; size = 8
_dataUnitBufPtr$ = -544					; size = 4
_whiteningValuesPtr64$ = -544				; size = 4
_endBlock$ = -540					; size = 4
_finalCarry$ = -533					; size = 1
_whiteningValues$ = -532				; size = 512
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_length$ = 8						; size = 8
_startDataUnitNo$ = 16					; size = 4
_startCipherBlockNo$ = 20				; size = 4
_ks2$ = 24						; size = 4
_cipher$ = 28						; size = 4
_EncryptBufferXTSParallel@32 PROC			; COMDAT
; _buffer$ = edx
; _ks$ = ecx

; 217  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 40 02 00
	00		 sub	 esp, 576		; 00000240H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 10	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00018	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _ks$GSCopy$[ebp], ecx

; 218  : 	unsigned __int8 finalCarry;
; 219  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 220  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 221  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 222  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 223  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 224  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 225  : 	unsigned __int64 *dataUnitBufPtr;
; 226  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0001e	8b 4d 18	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00021	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _ks2$GSCopy$[ebp], ecx
  00027	8b 4d 14	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  0002a	56		 push	 esi
  0002b	89 8d d0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], ecx

; 227  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 228  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 229  : 
; 230  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 231  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 232  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 233  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 234  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 235  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 236  : 
; 237  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 238  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 239  : 	dataUnitNo = startDataUnitNo->Value;

  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	57		 push	 edi
  00037	8b fa		 mov	 edi, edx

; 240  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 241  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 242  : 
; 243  : 	if (length % BYTES_PER_XTS_BLOCK)

  00039	8b 55 08	 mov	 edx, DWORD PTR _length$[ebp]
  0003c	89 85 cc fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00042	8b c2		 mov	 eax, edx
  00044	89 8d c8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0004a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0004d	33 c9		 xor	 ecx, ecx
  0004f	33 f6		 xor	 esi, esi
  00051	0b c1		 or	 eax, ecx
  00053	74 14		 je	 SHORT $LN27@EncryptBuf@2

; 244  : 		GST_THROW_FATAL_EXCEPTION;

  00055	68 54 53 47 00	 push	 4674388			; 00475354H
  0005a	56		 push	 esi
  0005b	56		 push	 esi
  0005c	68 f4 00 00 00	 push	 244			; 000000f4H
  00061	6a 29		 push	 41			; 00000029H
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN61@EncryptBuf@2:
$LN27@EncryptBuf@2:

; 245  : 
; 246  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00069	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp+4]
  0006c	0f ac c2 04	 shrd	 edx, eax, 4
  00070	c1 e8 04	 shr	 eax, 4
  00073	89 85 dc fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], eax
  00079	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], edx

; 247  : 
; 248  : 	// Process all blocks in the buffer
; 249  : 	while (blockCount > 0)

  0007f	3b c6		 cmp	 eax, esi
  00081	77 08		 ja	 SHORT $LN49@EncryptBuf@2
  00083	3b d6		 cmp	 edx, esi
  00085	0f 86 09 02 00
	00		 jbe	 $LN10@EncryptBuf@2
$LN49@EncryptBuf@2:
  0008b	53		 push	 ebx
  0008c	eb 08		 jmp	 SHORT $LN26@EncryptBuf@2
$LL55@EncryptBuf@2:
  0008e	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp+4]
  00094	33 f6		 xor	 esi, esi
$LN26@EncryptBuf@2:

; 250  : 	{
; 251  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00096	3b c6		 cmp	 eax, esi
  00098	77 21		 ja	 SHORT $LN56@EncryptBuf@2
  0009a	72 09		 jb	 SHORT $LN59@EncryptBuf@2
  0009c	83 bd d8 fd ff
	ff 20		 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  000a3	73 16		 jae	 SHORT $LN56@EncryptBuf@2
$LN59@EncryptBuf@2:

; 252  : 			endBlock = startBlock + (unsigned int) blockCount;

  000a5	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _startBlock$[ebp]
  000ab	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp]
  000b1	03 c8		 add	 ecx, eax
  000b3	89 8d e4 fd ff
	ff		 mov	 DWORD PTR _endBlock$[ebp], ecx

; 253  : 		else

  000b9	eb 0a		 jmp	 SHORT $LN23@EncryptBuf@2
$LN56@EncryptBuf@2:

; 254  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000bb	c7 85 e4 fd ff
	ff 20 00 00 00	 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN23@EncryptBuf@2:

; 255  : 
; 256  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 257  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 258  : 
; 259  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 260  : 		// whitening value for this data unit)
; 261  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  000c5	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp]

; 262  : 		*(whiteningValuePtr64 + 1) = 0;
; 263  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000cb	ff b5 c4 fd ff
	ff		 push	 DWORD PTR _ks2$GSCopy$[ebp]
  000d1	83 65 f4 00	 and	 DWORD PTR _whiteningValue$[ebp+8], 0
  000d5	83 65 f8 00	 and	 DWORD PTR _whiteningValue$[ebp+12], 0
  000d9	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000dc	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  000e2	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000e5	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000e8	8b c6		 mov	 eax, esi
  000ea	50		 push	 eax
  000eb	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000ee	8d 5d e4	 lea	 ebx, DWORD PTR _whiteningValues$[ebp+504]
  000f1	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ebx
  000f7	e8 00 00 00 00	 call	 _EncipherBlock@12

; 264  : 
; 265  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 266  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 267  : 		for (block = 0; block < endBlock; block++)

  000fc	83 a5 d4 fd ff
	ff 00		 and	 DWORD PTR _block$[ebp], 0
  00103	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _endBlock$[ebp], 0
  0010a	0f 86 b6 00 00
	00		 jbe	 $LN20@EncryptBuf@2
  00110	eb 06		 jmp	 SHORT $LN22@EncryptBuf@2
$LL57@EncryptBuf@2:
  00112	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _whiteningValuesPtr64$[ebp]
$LN22@EncryptBuf@2:

; 268  : 		{
; 269  : 			if (block >= startBlock)

  00118	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  0011e	3b 85 d0 fd ff
	ff		 cmp	 eax, DWORD PTR _startBlock$[ebp]
  00124	72 25		 jb	 SHORT $LN19@EncryptBuf@2

; 270  : 			{
; 271  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  00126	8b 06		 mov	 eax, DWORD PTR [esi]
  00128	89 03		 mov	 DWORD PTR [ebx], eax
  0012a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0012d	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00130	83 c6 08	 add	 esi, 8

; 272  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  00133	8b 06		 mov	 eax, DWORD PTR [esi]
  00135	83 eb 08	 sub	 ebx, 8
  00138	89 03		 mov	 DWORD PTR [ebx], eax
  0013a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0013d	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00140	83 eb 08	 sub	 ebx, 8
  00143	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ebx

; 273  : 			}
; 274  : 			else

  00149	eb 03		 jmp	 SHORT $LN18@EncryptBuf@2
$LN19@EncryptBuf@2:

; 275  : 				whiteningValuePtr64++;

  0014b	83 c6 08	 add	 esi, 8
$LN18@EncryptBuf@2:

; 276  : 
; 277  : 			// Derive the next whitening value
; 278  : 
; 279  : #if BYTE_ORDER == LITTLE_ENDIAN
; 280  : 
; 281  : 			// Little-endian platforms
; 282  : 
; 283  : 			finalCarry = 
; 284  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 285  : 				135 : 0;

  0014e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00151	8b 06		 mov	 eax, DWORD PTR [esi]
  00153	8b da		 mov	 ebx, edx
  00155	81 e3 00 00 00
	80		 and	 ebx, -2147483648	; 80000000H
  0015b	33 c9		 xor	 ecx, ecx
  0015d	0b cb		 or	 ecx, ebx
  0015f	c6 85 eb fd ff
	ff 87		 mov	 BYTE PTR _finalCarry$[ebp], 135 ; 00000087H
  00166	75 07		 jne	 SHORT $LN31@EncryptBuf@2
  00168	c6 85 eb fd ff
	ff 00		 mov	 BYTE PTR _finalCarry$[ebp], 0
$LN31@EncryptBuf@2:

; 286  : 
; 287  : 			*whiteningValuePtr64-- <<= 1;

  0016f	0f a4 c2 01	 shld	 edx, eax, 1
  00173	03 c0		 add	 eax, eax
  00175	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00178	89 06		 mov	 DWORD PTR [esi], eax

; 288  : 
; 289  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  0017a	8b 5e fc	 mov	 ebx, DWORD PTR [esi-4]
  0017d	83 ee 08	 sub	 esi, 8
  00180	8b 06		 mov	 eax, DWORD PTR [esi]
  00182	8b d3		 mov	 edx, ebx
  00184	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  0018a	33 c9		 xor	 ecx, ecx
  0018c	0b ca		 or	 ecx, edx
  0018e	74 0a		 je	 SHORT $LN17@EncryptBuf@2

; 290  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00190	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00193	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00197	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN17@EncryptBuf@2:

; 291  : 
; 292  : 			*whiteningValuePtr64 <<= 1;

  0019a	0f a4 c3 01	 shld	 ebx, eax, 1
  0019e	03 c0		 add	 eax, eax
  001a0	89 06		 mov	 DWORD PTR [esi], eax

; 293  : #else
; 294  : 
; 295  : 			// Big-endian platforms
; 296  : 
; 297  : 			finalCarry = 
; 298  : 				(*whiteningValuePtr64 & 0x80) ?
; 299  : 				135 : 0;
; 300  : 
; 301  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 302  : 
; 303  : 			whiteningValuePtr64--;
; 304  : 
; 305  : 			if (*whiteningValuePtr64 & 0x80)
; 306  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 307  : 
; 308  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 309  : #endif
; 310  : 
; 311  : 			whiteningValue[0] ^= finalCarry;

  001a2	8a 85 eb fd ff
	ff		 mov	 al, BYTE PTR _finalCarry$[ebp]
  001a8	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  001ab	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  001ae	ff 85 d4 fd ff
	ff		 inc	 DWORD PTR _block$[ebp]
  001b4	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  001ba	3b 85 e4 fd ff
	ff		 cmp	 eax, DWORD PTR _endBlock$[ebp]
  001c0	0f 82 4c ff ff
	ff		 jb	 $LL57@EncryptBuf@2
$LN20@EncryptBuf@2:

; 315  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 316  : 
; 317  : 		// Encrypt all blocks in this data unit
; 318  : 
; 319  : 		for (block = startBlock; block < endBlock; block++)

  001c6	8b 9d d0 fd ff
	ff		 mov	 ebx, DWORD PTR _startBlock$[ebp]
  001cc	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _endBlock$[ebp]
  001d2	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _dataUnitBufPtr$[ebp], edi
  001d8	8d 45 e4	 lea	 eax, DWORD PTR _whiteningValues$[ebp+504]
  001db	3b d9		 cmp	 ebx, ecx
  001dd	73 24		 jae	 SHORT $LN14@EncryptBuf@2

; 312  : 		}
; 313  : 
; 314  : 		dataUnitBufPtr = bufPtr;

  001df	2b cb		 sub	 ecx, ebx
$LL16@EncryptBuf@2:

; 320  : 		{
; 321  : 			// Pre-whitening
; 322  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001e1	8b 10		 mov	 edx, DWORD PTR [eax]
  001e3	31 17		 xor	 DWORD PTR [edi], edx
  001e5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001e8	31 57 04	 xor	 DWORD PTR [edi+4], edx
  001eb	6a 08		 push	 8
  001ed	5a		 pop	 edx
  001ee	2b c2		 sub	 eax, edx

; 323  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001f0	8b 30		 mov	 esi, DWORD PTR [eax]
  001f2	03 fa		 add	 edi, edx
  001f4	31 37		 xor	 DWORD PTR [edi], esi
  001f6	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001f9	31 77 04	 xor	 DWORD PTR [edi+4], esi
  001fc	2b c2		 sub	 eax, edx
  001fe	03 fa		 add	 edi, edx
  00200	49		 dec	 ecx
  00201	75 de		 jne	 SHORT $LL16@EncryptBuf@2
$LN14@EncryptBuf@2:

; 324  : 		}
; 325  : 
; 326  : 		// Actual encryption
; 327  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00203	8b b5 e4 fd ff
	ff		 mov	 esi, DWORD PTR _endBlock$[ebp]
  00209	2b f3		 sub	 esi, ebx
  0020b	56		 push	 esi
  0020c	ff b5 c0 fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$[ebp]
  00212	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _dataUnitBufPtr$[ebp]
  00218	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  0021b	e8 00 00 00 00	 call	 _EncipherBlocks@16

; 328  : 		
; 329  : 		bufPtr = dataUnitBufPtr;

  00220	8b bd e0 fd ff
	ff		 mov	 edi, DWORD PTR _dataUnitBufPtr$[ebp]

; 330  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00226	8d 45 e4	 lea	 eax, DWORD PTR _whiteningValues$[ebp+504]

; 331  : 
; 332  : 		for (block = startBlock; block < endBlock; block++)

  00229	3b 9d e4 fd ff
	ff		 cmp	 ebx, DWORD PTR _endBlock$[ebp]
  0022f	73 24		 jae	 SHORT $LN11@EncryptBuf@2

; 324  : 		}
; 325  : 
; 326  : 		// Actual encryption
; 327  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00231	8b d6		 mov	 edx, esi
$LL13@EncryptBuf@2:

; 333  : 		{
; 334  : 			// Post-whitening
; 335  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00233	8b 08		 mov	 ecx, DWORD PTR [eax]
  00235	31 0f		 xor	 DWORD PTR [edi], ecx
  00237	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0023a	31 4f 04	 xor	 DWORD PTR [edi+4], ecx
  0023d	6a 08		 push	 8
  0023f	59		 pop	 ecx
  00240	2b c1		 sub	 eax, ecx

; 336  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00242	8b 18		 mov	 ebx, DWORD PTR [eax]
  00244	03 f9		 add	 edi, ecx
  00246	31 1f		 xor	 DWORD PTR [edi], ebx
  00248	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0024b	31 5f 04	 xor	 DWORD PTR [edi+4], ebx
  0024e	2b c1		 sub	 eax, ecx
  00250	03 f9		 add	 edi, ecx
  00252	4a		 dec	 edx
  00253	75 de		 jne	 SHORT $LL13@EncryptBuf@2
$LN11@EncryptBuf@2:

; 337  : 		}
; 338  : 
; 339  : 		blockCount -= endBlock - startBlock;

  00255	29 b5 d8 fd ff
	ff		 sub	 DWORD PTR _blockCount$[ebp], esi
  0025b	6a 00		 push	 0
  0025d	58		 pop	 eax
  0025e	19 85 dc fd ff
	ff		 sbb	 DWORD PTR _blockCount$[ebp+4], eax

; 340  : 		startBlock = 0;
; 341  : 		dataUnitNo++;

  00264	83 85 c8 fd ff
	ff 01		 add	 DWORD PTR _dataUnitNo$[ebp], 1
  0026b	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], eax
  00271	11 85 cc fd ff
	ff		 adc	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00277	39 85 dc fd ff
	ff		 cmp	 DWORD PTR _blockCount$[ebp+4], eax
  0027d	0f 87 0b fe ff
	ff		 ja	 $LL55@EncryptBuf@2

; 247  : 
; 248  : 	// Process all blocks in the buffer
; 249  : 	while (blockCount > 0)

  00283	72 0c		 jb	 SHORT $LN58@EncryptBuf@2
  00285	39 85 d8 fd ff
	ff		 cmp	 DWORD PTR _blockCount$[ebp], eax
  0028b	0f 87 fd fd ff
	ff		 ja	 $LL55@EncryptBuf@2
$LN58@EncryptBuf@2:
  00291	33 f6		 xor	 esi, esi
  00293	5b		 pop	 ebx
$LN10@EncryptBuf@2:

; 342  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 343  : 	}
; 344  : 
; 345  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00294	6a 02		 push	 2
  00296	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00299	59		 pop	 ecx
$LL7@EncryptBuf@2:
  0029a	89 30		 mov	 DWORD PTR [eax], esi
  0029c	49		 dec	 ecx
  0029d	89 70 04	 mov	 DWORD PTR [eax+4], esi
  002a0	83 c0 08	 add	 eax, 8
  002a3	3b ce		 cmp	 ecx, esi
  002a5	75 f3		 jne	 SHORT $LL7@EncryptBuf@2

; 346  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  002a7	6a 40		 push	 64			; 00000040H
  002a9	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  002af	59		 pop	 ecx
$LL2@EncryptBuf@2:
  002b0	89 30		 mov	 DWORD PTR [eax], esi
  002b2	49		 dec	 ecx
  002b3	89 70 04	 mov	 DWORD PTR [eax+4], esi
  002b6	83 c0 08	 add	 eax, 8
  002b9	3b ce		 cmp	 ecx, esi
  002bb	75 f3		 jne	 SHORT $LL2@EncryptBuf@2

; 347  : }

  002bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c0	5f		 pop	 edi
  002c1	33 cd		 xor	 ecx, ebp
  002c3	5e		 pop	 esi
  002c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c9	c9		 leave
  002ca	c2 18 00	 ret	 24			; 00000018H
$LN60@EncryptBuf@2:
_EncryptBufferXTSParallel@32 ENDP
_TEXT	ENDS
PUBLIC	_ks2$GSCopy$
PUBLIC	_ks$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogsp
;	COMDAT _EncryptBufferXTSNonParallel@32
_TEXT	SEGMENT
_ks$GSCopy$ = -60					; size = 4
_ks2$GSCopy$ = -56					; size = 4
_dataUnitNo$ = -52					; size = 8
_endBlock$ = -44					; size = 4
_block$ = -40						; size = 4
_startBlock$ = -36					; size = 4
_blockCount$ = -32					; size = 8
_finalCarry$ = -21					; size = 1
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_length$ = 8						; size = 8
_startDataUnitNo$ = 16					; size = 4
_startCipherBlockNo$ = 20				; size = 4
_ks2$ = 24						; size = 4
_cipher$ = 28						; size = 4
_EncryptBufferXTSNonParallel@32 PROC			; COMDAT
; _buffer$ = edx
; _ks$ = ecx

; 373  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 45 10	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00015	89 4d c4	 mov	 DWORD PTR _ks$GSCopy$[ebp], ecx

; 374  : 	unsigned __int8 finalCarry;
; 375  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 376  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 377  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 378  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 379  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00018	8b 4d 18	 mov	 ecx, DWORD PTR _ks2$[ebp]
  0001b	89 4d c8	 mov	 DWORD PTR _ks2$GSCopy$[ebp], ecx
  0001e	8b 4d 14	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	89 4d dc	 mov	 DWORD PTR _startBlock$[ebp], ecx

; 380  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 381  : 
; 382  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 383  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 384  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 385  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 386  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 387  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 388  : 
; 389  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 390  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 391  : 	dataUnitNo = startDataUnitNo->Value;

  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	57		 push	 edi
  0002a	8b fa		 mov	 edi, edx

; 392  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 393  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 394  : 
; 395  : 	if (length % BYTES_PER_XTS_BLOCK)

  0002c	8b 55 08	 mov	 edx, DWORD PTR _length$[ebp]
  0002f	89 45 d0	 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00032	8b c2		 mov	 eax, edx
  00034	89 4d cc	 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  00037	83 e0 0f	 and	 eax, 15			; 0000000fH
  0003a	33 c9		 xor	 ecx, ecx
  0003c	0b c1		 or	 eax, ecx
  0003e	74 14		 je	 SHORT $LN16@EncryptBuf@3

; 396  : 		GST_THROW_FATAL_EXCEPTION;

  00040	68 54 53 47 00	 push	 4674388			; 00475354H
  00045	51		 push	 ecx
  00046	51		 push	 ecx
  00047	68 8c 01 00 00	 push	 396			; 0000018cH
  0004c	6a 29		 push	 41			; 00000029H
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN42@EncryptBuf@3:
$LN16@EncryptBuf@3:

; 397  : 
; 398  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp+4]
  00057	0f ac c2 04	 shrd	 edx, eax, 4
  0005b	c1 e8 04	 shr	 eax, 4
  0005e	89 45 e4	 mov	 DWORD PTR _blockCount$[ebp+4], eax
  00061	89 55 e0	 mov	 DWORD PTR _blockCount$[ebp], edx

; 399  : 
; 400  : 	// Process all blocks in the buffer
; 401  : 	while (blockCount > 0)

  00064	3b c1		 cmp	 eax, ecx
  00066	77 08		 ja	 SHORT $LN31@EncryptBuf@3
  00068	3b d1		 cmp	 edx, ecx
  0006a	0f 86 44 01 00
	00		 jbe	 $LN5@EncryptBuf@3
$LN31@EncryptBuf@3:
  00070	53		 push	 ebx
  00071	56		 push	 esi
  00072	eb 03		 jmp	 SHORT $LN15@EncryptBuf@3
$LL34@EncryptBuf@3:
  00074	8b 45 e4	 mov	 eax, DWORD PTR _blockCount$[ebp+4]
$LN15@EncryptBuf@3:

; 402  : 	{
; 403  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00077	85 c0		 test	 eax, eax
  00079	77 16		 ja	 SHORT $LN35@EncryptBuf@3
  0007b	72 06		 jb	 SHORT $LN38@EncryptBuf@3
  0007d	83 7d e0 20	 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  00081	73 0e		 jae	 SHORT $LN35@EncryptBuf@3
$LN38@EncryptBuf@3:

; 404  : 			endBlock = startBlock + (unsigned int) blockCount;

  00083	8b 45 dc	 mov	 eax, DWORD PTR _startBlock$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  00089	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]
  0008c	89 5d d4	 mov	 DWORD PTR _endBlock$[ebp], ebx

; 405  : 		else

  0008f	eb 0a		 jmp	 SHORT $LN12@EncryptBuf@3
$LN35@EncryptBuf@3:

; 406  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00091	c7 45 d4 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
  00098	8b 5d d4	 mov	 ebx, DWORD PTR _endBlock$[ebp]
$LN12@EncryptBuf@3:

; 407  : 
; 408  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 409  : 
; 410  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 411  : 		// whitening value for this data unit)
; 412  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0009b	8b 45 cc	 mov	 eax, DWORD PTR _dataUnitNo$[ebp]

; 413  : 		*(whiteningValuePtr64 + 1) = 0;
; 414  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0009e	ff 75 c8	 push	 DWORD PTR _ks2$GSCopy$[ebp]
  000a1	83 65 f4 00	 and	 DWORD PTR _whiteningValue$[ebp+8], 0
  000a5	83 65 f8 00	 and	 DWORD PTR _whiteningValue$[ebp+12], 0
  000a9	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000ac	8b 45 d0	 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  000af	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000b2	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000b5	8b c6		 mov	 eax, esi
  000b7	50		 push	 eax
  000b8	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000bb	e8 00 00 00 00	 call	 _EncipherBlock@12

; 415  : 
; 416  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 417  : 		// encrypt all relevant blocks in this data unit
; 418  : 		for (block = 0; block < endBlock; block++)

  000c0	33 c0		 xor	 eax, eax
  000c2	89 45 d8	 mov	 DWORD PTR _block$[ebp], eax
  000c5	3b d8		 cmp	 ebx, eax
  000c7	0f 86 bd 00 00
	00		 jbe	 $LN9@EncryptBuf@3
$LL36@EncryptBuf@3:

; 419  : 		{
; 420  : 			if (block >= startBlock)

  000cd	8b 45 d8	 mov	 eax, DWORD PTR _block$[ebp]
  000d0	3b 45 dc	 cmp	 eax, DWORD PTR _startBlock$[ebp]
  000d3	72 47		 jb	 SHORT $LN8@EncryptBuf@3

; 421  : 			{
; 422  : 				// Pre-whitening
; 423  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000d5	8b 06		 mov	 eax, DWORD PTR [esi]
  000d7	31 07		 xor	 DWORD PTR [edi], eax
  000d9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000dc	31 47 04	 xor	 DWORD PTR [edi+4], eax
  000df	6a 08		 push	 8
  000e1	5b		 pop	 ebx

; 424  : 				*bufPtr-- ^= *whiteningValuePtr64--;
; 425  : 
; 426  : 				// Actual encryption
; 427  : 				EncipherBlock (cipher, bufPtr, ks);

  000e2	ff 75 c4	 push	 DWORD PTR _ks$GSCopy$[ebp]
  000e5	03 f3		 add	 esi, ebx
  000e7	8b 06		 mov	 eax, DWORD PTR [esi]
  000e9	03 fb		 add	 edi, ebx
  000eb	31 07		 xor	 DWORD PTR [edi], eax
  000ed	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f0	31 47 04	 xor	 DWORD PTR [edi+4], eax
  000f3	2b fb		 sub	 edi, ebx
  000f5	57		 push	 edi
  000f6	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000f9	2b f3		 sub	 esi, ebx
  000fb	e8 00 00 00 00	 call	 _EncipherBlock@12

; 428  : 
; 429  : 				// Post-whitening
; 430  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00100	8b 06		 mov	 eax, DWORD PTR [esi]
  00102	31 07		 xor	 DWORD PTR [edi], eax
  00104	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00107	31 47 04	 xor	 DWORD PTR [edi+4], eax
  0010a	03 f3		 add	 esi, ebx

; 431  : 				*bufPtr++ ^= *whiteningValuePtr64;

  0010c	8b 06		 mov	 eax, DWORD PTR [esi]
  0010e	03 fb		 add	 edi, ebx
  00110	31 07		 xor	 DWORD PTR [edi], eax
  00112	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00115	31 47 04	 xor	 DWORD PTR [edi+4], eax
  00118	03 fb		 add	 edi, ebx

; 432  : 			}
; 433  : 			else

  0011a	eb 03		 jmp	 SHORT $LN7@EncryptBuf@3
$LN8@EncryptBuf@3:

; 434  : 				whiteningValuePtr64++;

  0011c	83 c6 08	 add	 esi, 8
$LN7@EncryptBuf@3:

; 435  : 
; 436  : 			// Derive the next whitening value
; 437  : 
; 438  : #if BYTE_ORDER == LITTLE_ENDIAN
; 439  : 
; 440  : 			// Little-endian platforms
; 441  : 
; 442  : 			finalCarry = 
; 443  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 444  : 				135 : 0;

  0011f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8b da		 mov	 ebx, edx
  00126	81 e3 00 00 00
	80		 and	 ebx, -2147483648	; 80000000H
  0012c	33 c9		 xor	 ecx, ecx
  0012e	0b cb		 or	 ecx, ebx
  00130	c6 45 eb 87	 mov	 BYTE PTR _finalCarry$[ebp], 135 ; 00000087H
  00134	75 04		 jne	 SHORT $LN20@EncryptBuf@3
  00136	c6 45 eb 00	 mov	 BYTE PTR _finalCarry$[ebp], 0
$LN20@EncryptBuf@3:

; 445  : 
; 446  : 			*whiteningValuePtr64-- <<= 1;

  0013a	0f a4 c2 01	 shld	 edx, eax, 1
  0013e	03 c0		 add	 eax, eax
  00140	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00143	89 06		 mov	 DWORD PTR [esi], eax

; 447  : 
; 448  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00145	8b 5e fc	 mov	 ebx, DWORD PTR [esi-4]
  00148	83 ee 08	 sub	 esi, 8
  0014b	8b 06		 mov	 eax, DWORD PTR [esi]
  0014d	8b d3		 mov	 edx, ebx
  0014f	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00155	33 c9		 xor	 ecx, ecx
  00157	0b ca		 or	 ecx, edx
  00159	74 0a		 je	 SHORT $LN6@EncryptBuf@3

; 449  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0015b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0015e	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00162	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN6@EncryptBuf@3:

; 450  : 
; 451  : 			*whiteningValuePtr64 <<= 1;

  00165	0f a4 c3 01	 shld	 ebx, eax, 1
  00169	03 c0		 add	 eax, eax
  0016b	89 06		 mov	 DWORD PTR [esi], eax

; 452  : #else
; 453  : 
; 454  : 			// Big-endian platforms
; 455  : 
; 456  : 			finalCarry = 
; 457  : 				(*whiteningValuePtr64 & 0x80) ?
; 458  : 				135 : 0;
; 459  : 
; 460  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 461  : 
; 462  : 			whiteningValuePtr64--;
; 463  : 
; 464  : 			if (*whiteningValuePtr64 & 0x80)
; 465  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 466  : 
; 467  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 468  : #endif
; 469  : 
; 470  : 			whiteningValue[0] ^= finalCarry;

  0016d	8a 45 eb	 mov	 al, BYTE PTR _finalCarry$[ebp]
  00170	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00173	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  00176	ff 45 d8	 inc	 DWORD PTR _block$[ebp]
  00179	8b 45 d8	 mov	 eax, DWORD PTR _block$[ebp]
  0017c	3b 45 d4	 cmp	 eax, DWORD PTR _endBlock$[ebp]
  0017f	0f 82 48 ff ff
	ff		 jb	 $LL36@EncryptBuf@3
  00185	8b 5d d4	 mov	 ebx, DWORD PTR _endBlock$[ebp]
  00188	33 c0		 xor	 eax, eax
$LN9@EncryptBuf@3:

; 471  : 		}
; 472  : 
; 473  : 		blockCount -= endBlock - startBlock;

  0018a	2b 5d dc	 sub	 ebx, DWORD PTR _startBlock$[ebp]

; 474  : 		startBlock = 0;

  0018d	89 45 dc	 mov	 DWORD PTR _startBlock$[ebp], eax
  00190	29 5d e0	 sub	 DWORD PTR _blockCount$[ebp], ebx
  00193	19 45 e4	 sbb	 DWORD PTR _blockCount$[ebp+4], eax

; 475  : 		dataUnitNo++;

  00196	83 45 cc 01	 add	 DWORD PTR _dataUnitNo$[ebp], 1
  0019a	11 45 d0	 adc	 DWORD PTR _dataUnitNo$[ebp+4], eax
  0019d	39 45 e4	 cmp	 DWORD PTR _blockCount$[ebp+4], eax
  001a0	0f 87 ce fe ff
	ff		 ja	 $LL34@EncryptBuf@3

; 399  : 
; 400  : 	// Process all blocks in the buffer
; 401  : 	while (blockCount > 0)

  001a6	72 0a		 jb	 SHORT $LN39@EncryptBuf@3
  001a8	83 7d e0 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  001ac	0f 87 c2 fe ff
	ff		 ja	 $LL34@EncryptBuf@3
$LN39@EncryptBuf@3:
  001b2	5e		 pop	 esi
  001b3	5b		 pop	 ebx
$LN5@EncryptBuf@3:

; 476  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 477  : 	}
; 478  : 
; 479  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  001b4	6a 02		 push	 2
  001b6	59		 pop	 ecx
  001b7	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  001ba	5f		 pop	 edi
$LL2@EncryptBuf@3:
  001bb	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001c1	49		 dec	 ecx
  001c2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  001c9	83 c0 08	 add	 eax, 8
  001cc	85 c9		 test	 ecx, ecx
  001ce	75 eb		 jne	 SHORT $LL2@EncryptBuf@3

; 480  : }

  001d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d3	33 cd		 xor	 ecx, ebp
  001d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001da	c9		 leave
  001db	c2 18 00	 ret	 24			; 00000018H
$LN41@EncryptBuf@3:
_EncryptBufferXTSNonParallel@32 ENDP
_TEXT	ENDS
PUBLIC	_ks$GSCopy$
PUBLIC	_ks2$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_DecryptBufferXTS8Byte@32
EXTRN	_DecipherBlock@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _DecryptBufferXTS8Byte@32
_TEXT	SEGMENT
_ks$GSCopy$ = -596					; size = 4
_ks2$GSCopy$ = -592					; size = 4
_dataUnitNo$ = -588					; size = 8
_block$ = -580						; size = 4
_startBlock$ = -576					; size = 4
_blockCount$ = -572					; size = 8
_xor_ks$ = -564						; size = 544
_whiteningValue$ = -20					; size = 8
_byteBufUnitNo$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTS8Byte@32 PROC				; COMDAT

; 518  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 54 02 00
	00		 sub	 esp, 596		; 00000254H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00018	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]

; 519  : 	unsigned __int8 finalCarry;
; 520  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
; 521  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
; 522  : 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
; 523  : 	unsigned __int32 *bufPtr = (unsigned __int32 *) buffer;
; 524  : 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;

  0001b	89 8d b0 fd ff
	ff		 mov	 DWORD PTR _ks2$GSCopy$[ebp], ecx
  00021	8b 4d 18	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  00024	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], ecx

; 525  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 526  : 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
; 527  : 
; 528  : 	dataUnitNo = startDataUnitNo->Value;

  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	53		 push	 ebx
  00030	8b 5d 08	 mov	 ebx, DWORD PTR _buffer$[ebp]
  00033	89 8d b4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  00039	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax

; 529  : 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  0003f	89 4d f4	 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx

; 530  : 
; 531  : 	if (length % BYTES_PER_XTS_BLOCK_SMALL)

  00042	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00045	89 45 f8	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], eax
  00048	56		 push	 esi
  00049	8b c1		 mov	 eax, ecx
  0004b	57		 push	 edi
  0004c	8b 7d 1c	 mov	 edi, DWORD PTR _ks$[ebp]
  0004f	83 e0 07	 and	 eax, 7
  00052	33 d2		 xor	 edx, edx
  00054	0b c2		 or	 eax, edx
  00056	89 bd ac fd ff
	ff		 mov	 DWORD PTR _ks$GSCopy$[ebp], edi
  0005c	74 14		 je	 SHORT $LN16@DecryptBuf

; 532  : 		GST_THROW_FATAL_EXCEPTION;

  0005e	68 54 53 47 00	 push	 4674388			; 00475354H
  00063	52		 push	 edx
  00064	52		 push	 edx
  00065	68 14 02 00 00	 push	 532			; 00000214H
  0006a	6a 29		 push	 41			; 00000029H
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN39@DecryptBuf:
$LN16@DecryptBuf:

; 533  : 
; 534  : 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;

  00072	8b 75 10	 mov	 esi, DWORD PTR _length$[ebp+4]

; 535  : 
; 536  : 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));

  00075	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00078	0f ac f1 03	 shrd	 ecx, esi, 3
  0007c	c1 ee 03	 shr	 esi, 3
  0007f	89 b5 c8 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], esi
  00085	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], ecx
  0008b	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00090	50		 push	 eax
  00091	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  00097	57		 push	 edi
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _memcpy
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 537  : 
; 538  : 	while (blockCount > 0)

  000a1	85 f6		 test	 esi, esi
  000a3	77 35		 ja	 SHORT $LN32@DecryptBuf
  000a5	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp], 0
  000ac	0f 86 49 01 00
	00		 jbe	 $LN5@DecryptBuf
  000b2	eb 06		 jmp	 SHORT $LN15@DecryptBuf
$LL31@DecryptBuf:
  000b4	8b b5 c8 fd ff
	ff		 mov	 esi, DWORD PTR _blockCount$[ebp+4]
$LN15@DecryptBuf:

; 539  : 	{
; 540  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)

  000ba	85 f6		 test	 esi, esi
  000bc	77 1c		 ja	 SHORT $LN32@DecryptBuf
  000be	72 09		 jb	 SHORT $LN36@DecryptBuf
  000c0	83 bd c4 fd ff
	ff 40		 cmp	 DWORD PTR _blockCount$[ebp], 64 ; 00000040H
  000c7	73 11		 jae	 SHORT $LN32@DecryptBuf
$LN36@DecryptBuf:

; 541  : 			endBlock = startBlock + (unsigned __int32) blockCount;

  000c9	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _startBlock$[ebp]
  000cf	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp]
  000d5	8d 3c 01	 lea	 edi, DWORD PTR [ecx+eax]

; 542  : 		else

  000d8	eb 03		 jmp	 SHORT $LN12@DecryptBuf
$LN32@DecryptBuf:

; 543  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;

  000da	6a 40		 push	 64			; 00000040H
  000dc	5f		 pop	 edi
$LN12@DecryptBuf:

; 544  : 
; 545  : 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
; 546  : 
; 547  : 		//Encrypt data unit using the second key to generate the first whitening value
; 548  : 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);

  000dd	8b 45 f4	 mov	 eax, DWORD PTR _byteBufUnitNo$[ebp]

; 549  : 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);
; 550  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000e0	ff b5 b0 fd ff
	ff		 push	 DWORD PTR _ks2$GSCopy$[ebp]
  000e6	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000e9	8b 45 f8	 mov	 eax, DWORD PTR _byteBufUnitNo$[ebp+4]
  000ec	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000ef	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000f2	8b c6		 mov	 eax, esi
  000f4	50		 push	 eax
  000f5	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  000f8	e8 00 00 00 00	 call	 _EncipherBlock@12

; 551  : 
; 552  : 		//XOR ks with the current DataUnitNo
; 553  : 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);

  000fd	6a 08		 push	 8
  000ff	8d 45 f4	 lea	 eax, DWORD PTR _byteBufUnitNo$[ebp]
  00102	50		 push	 eax
  00103	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  00109	50		 push	 eax
  0010a	ff b5 ac fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$[ebp]
  00110	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00113	e8 00 00 00 00	 call	 _XorKeySchedule@20

; 554  : 
; 555  : 		for (block = 0; block < endBlock; block++)

  00118	33 c0		 xor	 eax, eax
  0011a	89 85 bc fd ff
	ff		 mov	 DWORD PTR _block$[ebp], eax
  00120	3b f8		 cmp	 edi, eax
  00122	0f 86 81 00 00
	00		 jbe	 $LN33@DecryptBuf
$LL11@DecryptBuf:

; 556  : 		{
; 557  : 			if (block >= startBlock)

  00128	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  0012e	3b 85 c0 fd ff
	ff		 cmp	 eax, DWORD PTR _startBlock$[ebp]
  00134	72 36		 jb	 SHORT $LN8@DecryptBuf

; 558  : 			{
; 559  : 				//Post-whitening
; 560  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  00136	8b 06		 mov	 eax, DWORD PTR [esi]
  00138	31 03		 xor	 DWORD PTR [ebx], eax
  0013a	6a 04		 push	 4
  0013c	58		 pop	 eax
  0013d	03 f0		 add	 esi, eax

; 561  : 				*bufPtr-- ^= *whiteningValuePtr32--;

  0013f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00141	03 d8		 add	 ebx, eax
  00143	31 0b		 xor	 DWORD PTR [ebx], ecx
  00145	2b d8		 sub	 ebx, eax
  00147	2b f0		 sub	 esi, eax

; 562  : 
; 563  : 				//Actual decryption
; 564  : 				DecipherBlock (cipher, bufPtr, xor_ks);

  00149	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  0014f	50		 push	 eax
  00150	53		 push	 ebx
  00151	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00154	e8 00 00 00 00	 call	 _DecipherBlock@12

; 565  : 
; 566  : 				//Pre-whitening
; 567  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  00159	8b 06		 mov	 eax, DWORD PTR [esi]
  0015b	31 03		 xor	 DWORD PTR [ebx], eax
  0015d	83 c6 04	 add	 esi, 4

; 568  : 				*bufPtr++ ^= *whiteningValuePtr32;

  00160	8b 06		 mov	 eax, DWORD PTR [esi]
  00162	83 c3 04	 add	 ebx, 4
  00165	31 03		 xor	 DWORD PTR [ebx], eax
  00167	83 c3 04	 add	 ebx, 4

; 569  : 			}
; 570  : 			else

  0016a	eb 03		 jmp	 SHORT $LN7@DecryptBuf
$LN8@DecryptBuf:

; 571  : 				whiteningValuePtr32++;

  0016c	83 c6 04	 add	 esi, 4
$LN7@DecryptBuf:

; 572  : 
; 573  : 			//Derive the next whitening value
; 574  : 
; 575  : #if BYTE_ORDER == LITTLE_ENDIAN
; 576  : 
; 577  : 			//Little-endian platforms
; 578  : 
; 579  : 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;

  0016f	8b 16		 mov	 edx, DWORD PTR [esi]
  00171	8b c2		 mov	 eax, edx
  00173	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00178	23 c1		 and	 eax, ecx
  0017a	f7 d8		 neg	 eax
  0017c	1a c0		 sbb	 al, al

; 580  : 
; 581  : 			*whiteningValuePtr32-- <<= 1;

  0017e	03 d2		 add	 edx, edx
  00180	89 16		 mov	 DWORD PTR [esi], edx
  00182	83 ee 04	 sub	 esi, 4

; 582  : 
; 583  : 			if (*whiteningValuePtr32 & 0x80000000)

  00185	8b 16		 mov	 edx, DWORD PTR [esi]
  00187	24 1b		 and	 al, 27			; 0000001bH
  00189	85 d1		 test	 edx, ecx
  0018b	74 04		 je	 SHORT $LN6@DecryptBuf

; 584  : 				*(whiteningValuePtr32 + 1) |= 1;

  0018d	83 4e 04 01	 or	 DWORD PTR [esi+4], 1
$LN6@DecryptBuf:

; 585  : 
; 586  : 			*whiteningValuePtr32 <<= 1;

  00191	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  00194	89 0e		 mov	 DWORD PTR [esi], ecx

; 587  : #else
; 588  : 			//Big-endian platforms
; 589  : 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
; 590  : 
; 591  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 592  : 
; 593  : 			whiteningValuePtr32--;
; 594  : 
; 595  : 			if (*whiteningValuePtr32 & 0x80)
; 596  : 				*(whiteningValuePtr32 + 1) |= 0x1000000;
; 597  : 
; 598  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 599  : #endif
; 600  : 
; 601  : 			whiteningValue[0] ^= finalCarry;

  00196	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  00199	ff 85 bc fd ff
	ff		 inc	 DWORD PTR _block$[ebp]
  0019f	39 bd bc fd ff
	ff		 cmp	 DWORD PTR _block$[ebp], edi
  001a5	72 81		 jb	 SHORT $LL11@DecryptBuf

; 554  : 
; 555  : 		for (block = 0; block < endBlock; block++)

  001a7	33 c0		 xor	 eax, eax
$LN33@DecryptBuf:

; 602  : 		}
; 603  : 
; 604  : 		blockCount -= endBlock - startBlock;

  001a9	2b bd c0 fd ff
	ff		 sub	 edi, DWORD PTR _startBlock$[ebp]

; 605  : 		startBlock = 0;

  001af	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], eax
  001b5	29 bd c4 fd ff
	ff		 sub	 DWORD PTR _blockCount$[ebp], edi
  001bb	19 85 c8 fd ff
	ff		 sbb	 DWORD PTR _blockCount$[ebp+4], eax

; 606  : 		dataUnitNo++;

  001c1	83 85 b4 fd ff
	ff 01		 add	 DWORD PTR _dataUnitNo$[ebp], 1

; 607  : 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  001c8	8b 8d b4 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  001ce	89 4d f4	 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  001d1	11 85 b8 fd ff
	ff		 adc	 DWORD PTR _dataUnitNo$[ebp+4], eax
  001d7	8b 8d b8 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp+4]
  001dd	89 4d f8	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx
  001e0	39 85 c8 fd ff
	ff		 cmp	 DWORD PTR _blockCount$[ebp+4], eax
  001e6	0f 87 c8 fe ff
	ff		 ja	 $LL31@DecryptBuf

; 537  : 
; 538  : 	while (blockCount > 0)

  001ec	72 0d		 jb	 SHORT $LN5@DecryptBuf
  001ee	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp], 0
  001f5	0f 87 b9 fe ff
	ff		 ja	 $LL31@DecryptBuf
$LN5@DecryptBuf:
  001fb	5f		 pop	 edi

; 608  : 	}
; 609  : 
; 610  : 	FAST_ERASE32 (whiteningValue, sizeof (whiteningValue));

  001fc	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _whiteningValue$[ebp], 0

; 611  : }

  00203	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00206	5e		 pop	 esi
  00207	33 cd		 xor	 ecx, ebp
  00209	5b		 pop	 ebx
  0020a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020f	c9		 leave
  00210	c2 20 00	 ret	 32			; 00000020H
$LN37@DecryptBuf:
_DecryptBufferXTS8Byte@32 ENDP
_TEXT	ENDS
PUBLIC	_ks2$GSCopy$
PUBLIC	_ks$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_DecipherBlocks@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _DecryptBufferXTSParallel@32
_TEXT	SEGMENT
_ks$GSCopy$ = -576					; size = 4
_ks2$GSCopy$ = -572					; size = 4
_dataUnitNo$ = -568					; size = 8
_startBlock$ = -560					; size = 4
_block$ = -556						; size = 4
_blockCount$ = -552					; size = 8
_dataUnitBufPtr$ = -544					; size = 4
_whiteningValuesPtr64$ = -544				; size = 4
_endBlock$ = -540					; size = 4
_finalCarry$ = -533					; size = 1
_whiteningValues$ = -532				; size = 512
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_length$ = 8						; size = 8
_startDataUnitNo$ = 16					; size = 4
_startCipherBlockNo$ = 20				; size = 4
_ks2$ = 24						; size = 4
_cipher$ = 28						; size = 4
_DecryptBufferXTSParallel@32 PROC			; COMDAT
; _buffer$ = edx
; _ks$ = ecx

; 634  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 40 02 00
	00		 sub	 esp, 576		; 00000240H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 10	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00018	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _ks$GSCopy$[ebp], ecx

; 635  : 	unsigned __int8 finalCarry;
; 636  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 637  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 638  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 639  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 640  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 641  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 642  : 	unsigned __int64 *dataUnitBufPtr;
; 643  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0001e	8b 4d 18	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00021	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _ks2$GSCopy$[ebp], ecx
  00027	8b 4d 14	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  0002a	56		 push	 esi
  0002b	89 8d d0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], ecx

; 644  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 645  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 646  : 
; 647  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 648  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 649  : 	dataUnitNo = startDataUnitNo->Value;

  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	57		 push	 edi
  00037	8b fa		 mov	 edi, edx

; 650  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 651  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 652  : 
; 653  : 	if (length % BYTES_PER_XTS_BLOCK)

  00039	8b 55 08	 mov	 edx, DWORD PTR _length$[ebp]
  0003c	89 85 cc fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00042	8b c2		 mov	 eax, edx
  00044	89 8d c8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0004a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0004d	33 c9		 xor	 ecx, ecx
  0004f	33 f6		 xor	 esi, esi
  00051	0b c1		 or	 eax, ecx
  00053	74 14		 je	 SHORT $LN27@DecryptBuf@2

; 654  : 		GST_THROW_FATAL_EXCEPTION;

  00055	68 54 53 47 00	 push	 4674388			; 00475354H
  0005a	56		 push	 esi
  0005b	56		 push	 esi
  0005c	68 8e 02 00 00	 push	 654			; 0000028eH
  00061	6a 29		 push	 41			; 00000029H
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN61@DecryptBuf@2:
$LN27@DecryptBuf@2:

; 655  : 
; 656  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00069	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp+4]
  0006c	0f ac c2 04	 shrd	 edx, eax, 4
  00070	c1 e8 04	 shr	 eax, 4
  00073	89 85 dc fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], eax
  00079	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], edx

; 657  : 
; 658  : 	// Process all blocks in the buffer
; 659  : 	while (blockCount > 0)

  0007f	3b c6		 cmp	 eax, esi
  00081	77 08		 ja	 SHORT $LN49@DecryptBuf@2
  00083	3b d6		 cmp	 edx, esi
  00085	0f 86 09 02 00
	00		 jbe	 $LN10@DecryptBuf@2
$LN49@DecryptBuf@2:
  0008b	53		 push	 ebx
  0008c	eb 08		 jmp	 SHORT $LN26@DecryptBuf@2
$LL55@DecryptBuf@2:
  0008e	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp+4]
  00094	33 f6		 xor	 esi, esi
$LN26@DecryptBuf@2:

; 660  : 	{
; 661  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00096	3b c6		 cmp	 eax, esi
  00098	77 21		 ja	 SHORT $LN56@DecryptBuf@2
  0009a	72 09		 jb	 SHORT $LN59@DecryptBuf@2
  0009c	83 bd d8 fd ff
	ff 20		 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  000a3	73 16		 jae	 SHORT $LN56@DecryptBuf@2
$LN59@DecryptBuf@2:

; 662  : 			endBlock = startBlock + (unsigned int) blockCount;

  000a5	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _startBlock$[ebp]
  000ab	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp]
  000b1	03 c8		 add	 ecx, eax
  000b3	89 8d e4 fd ff
	ff		 mov	 DWORD PTR _endBlock$[ebp], ecx

; 663  : 		else

  000b9	eb 0a		 jmp	 SHORT $LN23@DecryptBuf@2
$LN56@DecryptBuf@2:

; 664  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000bb	c7 85 e4 fd ff
	ff 20 00 00 00	 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN23@DecryptBuf@2:

; 665  : 
; 666  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 667  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 668  : 
; 669  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 670  : 		// whitening value for this data unit)
; 671  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  000c5	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp]

; 672  : 		*(whiteningValuePtr64 + 1) = 0;
; 673  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000cb	ff b5 c4 fd ff
	ff		 push	 DWORD PTR _ks2$GSCopy$[ebp]
  000d1	83 65 f4 00	 and	 DWORD PTR _whiteningValue$[ebp+8], 0
  000d5	83 65 f8 00	 and	 DWORD PTR _whiteningValue$[ebp+12], 0
  000d9	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000dc	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  000e2	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000e5	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000e8	8b c6		 mov	 eax, esi
  000ea	50		 push	 eax
  000eb	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000ee	8d 5d e4	 lea	 ebx, DWORD PTR _whiteningValues$[ebp+504]
  000f1	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ebx
  000f7	e8 00 00 00 00	 call	 _EncipherBlock@12

; 674  : 
; 675  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 676  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 677  : 		for (block = 0; block < endBlock; block++)

  000fc	83 a5 d4 fd ff
	ff 00		 and	 DWORD PTR _block$[ebp], 0
  00103	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _endBlock$[ebp], 0
  0010a	0f 86 b6 00 00
	00		 jbe	 $LN20@DecryptBuf@2
  00110	eb 06		 jmp	 SHORT $LN22@DecryptBuf@2
$LL57@DecryptBuf@2:
  00112	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _whiteningValuesPtr64$[ebp]
$LN22@DecryptBuf@2:

; 678  : 		{
; 679  : 			if (block >= startBlock)

  00118	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  0011e	3b 85 d0 fd ff
	ff		 cmp	 eax, DWORD PTR _startBlock$[ebp]
  00124	72 25		 jb	 SHORT $LN19@DecryptBuf@2

; 680  : 			{
; 681  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  00126	8b 06		 mov	 eax, DWORD PTR [esi]
  00128	89 03		 mov	 DWORD PTR [ebx], eax
  0012a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0012d	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00130	83 c6 08	 add	 esi, 8

; 682  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  00133	8b 06		 mov	 eax, DWORD PTR [esi]
  00135	83 eb 08	 sub	 ebx, 8
  00138	89 03		 mov	 DWORD PTR [ebx], eax
  0013a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0013d	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00140	83 eb 08	 sub	 ebx, 8
  00143	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ebx

; 683  : 			}
; 684  : 			else

  00149	eb 03		 jmp	 SHORT $LN18@DecryptBuf@2
$LN19@DecryptBuf@2:

; 685  : 				whiteningValuePtr64++;

  0014b	83 c6 08	 add	 esi, 8
$LN18@DecryptBuf@2:

; 686  : 
; 687  : 			// Derive the next whitening value
; 688  : 
; 689  : #if BYTE_ORDER == LITTLE_ENDIAN
; 690  : 
; 691  : 			// Little-endian platforms
; 692  : 
; 693  : 			finalCarry = 
; 694  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 695  : 				135 : 0;

  0014e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00151	8b 06		 mov	 eax, DWORD PTR [esi]
  00153	8b da		 mov	 ebx, edx
  00155	81 e3 00 00 00
	80		 and	 ebx, -2147483648	; 80000000H
  0015b	33 c9		 xor	 ecx, ecx
  0015d	0b cb		 or	 ecx, ebx
  0015f	c6 85 eb fd ff
	ff 87		 mov	 BYTE PTR _finalCarry$[ebp], 135 ; 00000087H
  00166	75 07		 jne	 SHORT $LN31@DecryptBuf@2
  00168	c6 85 eb fd ff
	ff 00		 mov	 BYTE PTR _finalCarry$[ebp], 0
$LN31@DecryptBuf@2:

; 696  : 
; 697  : 			*whiteningValuePtr64-- <<= 1;

  0016f	0f a4 c2 01	 shld	 edx, eax, 1
  00173	03 c0		 add	 eax, eax
  00175	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00178	89 06		 mov	 DWORD PTR [esi], eax

; 698  : 
; 699  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  0017a	8b 5e fc	 mov	 ebx, DWORD PTR [esi-4]
  0017d	83 ee 08	 sub	 esi, 8
  00180	8b 06		 mov	 eax, DWORD PTR [esi]
  00182	8b d3		 mov	 edx, ebx
  00184	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  0018a	33 c9		 xor	 ecx, ecx
  0018c	0b ca		 or	 ecx, edx
  0018e	74 0a		 je	 SHORT $LN17@DecryptBuf@2

; 700  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00190	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00193	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00197	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN17@DecryptBuf@2:

; 701  : 
; 702  : 			*whiteningValuePtr64 <<= 1;

  0019a	0f a4 c3 01	 shld	 ebx, eax, 1
  0019e	03 c0		 add	 eax, eax
  001a0	89 06		 mov	 DWORD PTR [esi], eax

; 703  : 
; 704  : #else
; 705  : 			// Big-endian platforms
; 706  : 
; 707  : 			finalCarry = 
; 708  : 				(*whiteningValuePtr64 & 0x80) ?
; 709  : 				135 : 0;
; 710  : 
; 711  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 712  : 
; 713  : 			whiteningValuePtr64--;
; 714  : 
; 715  : 			if (*whiteningValuePtr64 & 0x80)
; 716  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 717  : 
; 718  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 719  : #endif
; 720  : 
; 721  : 			whiteningValue[0] ^= finalCarry;

  001a2	8a 85 eb fd ff
	ff		 mov	 al, BYTE PTR _finalCarry$[ebp]
  001a8	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  001ab	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  001ae	ff 85 d4 fd ff
	ff		 inc	 DWORD PTR _block$[ebp]
  001b4	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  001ba	3b 85 e4 fd ff
	ff		 cmp	 eax, DWORD PTR _endBlock$[ebp]
  001c0	0f 82 4c ff ff
	ff		 jb	 $LL57@DecryptBuf@2
$LN20@DecryptBuf@2:

; 725  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 726  : 
; 727  : 		// Decrypt blocks in this data unit
; 728  : 
; 729  : 		for (block = startBlock; block < endBlock; block++)

  001c6	8b 9d d0 fd ff
	ff		 mov	 ebx, DWORD PTR _startBlock$[ebp]
  001cc	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _endBlock$[ebp]
  001d2	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _dataUnitBufPtr$[ebp], edi
  001d8	8d 45 e4	 lea	 eax, DWORD PTR _whiteningValues$[ebp+504]
  001db	3b d9		 cmp	 ebx, ecx
  001dd	73 24		 jae	 SHORT $LN14@DecryptBuf@2

; 722  : 		}
; 723  : 
; 724  : 		dataUnitBufPtr = bufPtr;

  001df	2b cb		 sub	 ecx, ebx
$LL16@DecryptBuf@2:

; 730  : 		{
; 731  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001e1	8b 10		 mov	 edx, DWORD PTR [eax]
  001e3	31 17		 xor	 DWORD PTR [edi], edx
  001e5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001e8	31 57 04	 xor	 DWORD PTR [edi+4], edx
  001eb	6a 08		 push	 8
  001ed	5a		 pop	 edx
  001ee	2b c2		 sub	 eax, edx

; 732  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001f0	8b 30		 mov	 esi, DWORD PTR [eax]
  001f2	03 fa		 add	 edi, edx
  001f4	31 37		 xor	 DWORD PTR [edi], esi
  001f6	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001f9	31 77 04	 xor	 DWORD PTR [edi+4], esi
  001fc	2b c2		 sub	 eax, edx
  001fe	03 fa		 add	 edi, edx
  00200	49		 dec	 ecx
  00201	75 de		 jne	 SHORT $LL16@DecryptBuf@2
$LN14@DecryptBuf@2:

; 733  : 		}
; 734  : 
; 735  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00203	8b b5 e4 fd ff
	ff		 mov	 esi, DWORD PTR _endBlock$[ebp]
  00209	2b f3		 sub	 esi, ebx
  0020b	56		 push	 esi
  0020c	ff b5 c0 fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$[ebp]
  00212	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _dataUnitBufPtr$[ebp]
  00218	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  0021b	e8 00 00 00 00	 call	 _DecipherBlocks@16

; 736  : 
; 737  : 		bufPtr = dataUnitBufPtr;

  00220	8b bd e0 fd ff
	ff		 mov	 edi, DWORD PTR _dataUnitBufPtr$[ebp]

; 738  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00226	8d 45 e4	 lea	 eax, DWORD PTR _whiteningValues$[ebp+504]

; 739  : 
; 740  : 		for (block = startBlock; block < endBlock; block++)

  00229	3b 9d e4 fd ff
	ff		 cmp	 ebx, DWORD PTR _endBlock$[ebp]
  0022f	73 24		 jae	 SHORT $LN11@DecryptBuf@2

; 733  : 		}
; 734  : 
; 735  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00231	8b d6		 mov	 edx, esi
$LL13@DecryptBuf@2:

; 741  : 		{
; 742  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00233	8b 08		 mov	 ecx, DWORD PTR [eax]
  00235	31 0f		 xor	 DWORD PTR [edi], ecx
  00237	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0023a	31 4f 04	 xor	 DWORD PTR [edi+4], ecx
  0023d	6a 08		 push	 8
  0023f	59		 pop	 ecx
  00240	2b c1		 sub	 eax, ecx

; 743  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00242	8b 18		 mov	 ebx, DWORD PTR [eax]
  00244	03 f9		 add	 edi, ecx
  00246	31 1f		 xor	 DWORD PTR [edi], ebx
  00248	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0024b	31 5f 04	 xor	 DWORD PTR [edi+4], ebx
  0024e	2b c1		 sub	 eax, ecx
  00250	03 f9		 add	 edi, ecx
  00252	4a		 dec	 edx
  00253	75 de		 jne	 SHORT $LL13@DecryptBuf@2
$LN11@DecryptBuf@2:

; 744  : 		}
; 745  : 
; 746  : 		blockCount -= endBlock - startBlock;

  00255	29 b5 d8 fd ff
	ff		 sub	 DWORD PTR _blockCount$[ebp], esi
  0025b	6a 00		 push	 0
  0025d	58		 pop	 eax
  0025e	19 85 dc fd ff
	ff		 sbb	 DWORD PTR _blockCount$[ebp+4], eax

; 747  : 		startBlock = 0;
; 748  : 		dataUnitNo++;

  00264	83 85 c8 fd ff
	ff 01		 add	 DWORD PTR _dataUnitNo$[ebp], 1
  0026b	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], eax
  00271	11 85 cc fd ff
	ff		 adc	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00277	39 85 dc fd ff
	ff		 cmp	 DWORD PTR _blockCount$[ebp+4], eax
  0027d	0f 87 0b fe ff
	ff		 ja	 $LL55@DecryptBuf@2

; 657  : 
; 658  : 	// Process all blocks in the buffer
; 659  : 	while (blockCount > 0)

  00283	72 0c		 jb	 SHORT $LN58@DecryptBuf@2
  00285	39 85 d8 fd ff
	ff		 cmp	 DWORD PTR _blockCount$[ebp], eax
  0028b	0f 87 fd fd ff
	ff		 ja	 $LL55@DecryptBuf@2
$LN58@DecryptBuf@2:
  00291	33 f6		 xor	 esi, esi
  00293	5b		 pop	 ebx
$LN10@DecryptBuf@2:

; 749  : 
; 750  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 751  : 	}
; 752  : 
; 753  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00294	6a 02		 push	 2
  00296	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00299	59		 pop	 ecx
$LL7@DecryptBuf@2:
  0029a	89 30		 mov	 DWORD PTR [eax], esi
  0029c	49		 dec	 ecx
  0029d	89 70 04	 mov	 DWORD PTR [eax+4], esi
  002a0	83 c0 08	 add	 eax, 8
  002a3	3b ce		 cmp	 ecx, esi
  002a5	75 f3		 jne	 SHORT $LL7@DecryptBuf@2

; 754  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  002a7	6a 40		 push	 64			; 00000040H
  002a9	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  002af	59		 pop	 ecx
$LL2@DecryptBuf@2:
  002b0	89 30		 mov	 DWORD PTR [eax], esi
  002b2	49		 dec	 ecx
  002b3	89 70 04	 mov	 DWORD PTR [eax+4], esi
  002b6	83 c0 08	 add	 eax, 8
  002b9	3b ce		 cmp	 ecx, esi
  002bb	75 f3		 jne	 SHORT $LL2@DecryptBuf@2

; 755  : }

  002bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c0	5f		 pop	 edi
  002c1	33 cd		 xor	 ecx, ebp
  002c3	5e		 pop	 esi
  002c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c9	c9		 leave
  002ca	c2 18 00	 ret	 24			; 00000018H
$LN60@DecryptBuf@2:
_DecryptBufferXTSParallel@32 ENDP
_TEXT	ENDS
PUBLIC	_ks2$GSCopy$
PUBLIC	_ks$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogsp
;	COMDAT _DecryptBufferXTSNonParallel@32
_TEXT	SEGMENT
_ks$GSCopy$ = -60					; size = 4
_ks2$GSCopy$ = -56					; size = 4
_dataUnitNo$ = -52					; size = 8
_endBlock$ = -44					; size = 4
_block$ = -40						; size = 4
_startBlock$ = -36					; size = 4
_blockCount$ = -32					; size = 8
_finalCarry$ = -21					; size = 1
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_length$ = 8						; size = 8
_startDataUnitNo$ = 16					; size = 4
_startCipherBlockNo$ = 20				; size = 4
_ks2$ = 24						; size = 4
_cipher$ = 28						; size = 4
_DecryptBufferXTSNonParallel@32 PROC			; COMDAT
; _buffer$ = edx
; _ks$ = ecx

; 780  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 45 10	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00015	89 4d c4	 mov	 DWORD PTR _ks$GSCopy$[ebp], ecx

; 781  : 	unsigned __int8 finalCarry;
; 782  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 783  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 784  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 785  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 786  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00018	8b 4d 18	 mov	 ecx, DWORD PTR _ks2$[ebp]
  0001b	89 4d c8	 mov	 DWORD PTR _ks2$GSCopy$[ebp], ecx
  0001e	8b 4d 14	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	89 4d dc	 mov	 DWORD PTR _startBlock$[ebp], ecx

; 787  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 788  : 
; 789  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 790  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 791  : 	dataUnitNo = startDataUnitNo->Value;

  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	57		 push	 edi
  0002a	8b fa		 mov	 edi, edx

; 792  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 793  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 794  : 
; 795  : 	if (length % BYTES_PER_XTS_BLOCK)

  0002c	8b 55 08	 mov	 edx, DWORD PTR _length$[ebp]
  0002f	89 45 d0	 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00032	8b c2		 mov	 eax, edx
  00034	89 4d cc	 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  00037	83 e0 0f	 and	 eax, 15			; 0000000fH
  0003a	33 c9		 xor	 ecx, ecx
  0003c	0b c1		 or	 eax, ecx
  0003e	74 14		 je	 SHORT $LN16@DecryptBuf@3

; 796  : 		GST_THROW_FATAL_EXCEPTION;

  00040	68 54 53 47 00	 push	 4674388			; 00475354H
  00045	51		 push	 ecx
  00046	51		 push	 ecx
  00047	68 1c 03 00 00	 push	 796			; 0000031cH
  0004c	6a 29		 push	 41			; 00000029H
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN42@DecryptBuf@3:
$LN16@DecryptBuf@3:

; 797  : 
; 798  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp+4]
  00057	0f ac c2 04	 shrd	 edx, eax, 4
  0005b	c1 e8 04	 shr	 eax, 4
  0005e	89 45 e4	 mov	 DWORD PTR _blockCount$[ebp+4], eax
  00061	89 55 e0	 mov	 DWORD PTR _blockCount$[ebp], edx

; 799  : 
; 800  : 	// Process all blocks in the buffer
; 801  : 	while (blockCount > 0)

  00064	3b c1		 cmp	 eax, ecx
  00066	77 08		 ja	 SHORT $LN31@DecryptBuf@3
  00068	3b d1		 cmp	 edx, ecx
  0006a	0f 86 44 01 00
	00		 jbe	 $LN5@DecryptBuf@3
$LN31@DecryptBuf@3:
  00070	53		 push	 ebx
  00071	56		 push	 esi
  00072	eb 03		 jmp	 SHORT $LN15@DecryptBuf@3
$LL34@DecryptBuf@3:
  00074	8b 45 e4	 mov	 eax, DWORD PTR _blockCount$[ebp+4]
$LN15@DecryptBuf@3:

; 802  : 	{
; 803  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00077	85 c0		 test	 eax, eax
  00079	77 16		 ja	 SHORT $LN35@DecryptBuf@3
  0007b	72 06		 jb	 SHORT $LN38@DecryptBuf@3
  0007d	83 7d e0 20	 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  00081	73 0e		 jae	 SHORT $LN35@DecryptBuf@3
$LN38@DecryptBuf@3:

; 804  : 			endBlock = startBlock + (unsigned int) blockCount;

  00083	8b 45 dc	 mov	 eax, DWORD PTR _startBlock$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  00089	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]
  0008c	89 5d d4	 mov	 DWORD PTR _endBlock$[ebp], ebx

; 805  : 		else

  0008f	eb 0a		 jmp	 SHORT $LN12@DecryptBuf@3
$LN35@DecryptBuf@3:

; 806  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00091	c7 45 d4 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
  00098	8b 5d d4	 mov	 ebx, DWORD PTR _endBlock$[ebp]
$LN12@DecryptBuf@3:

; 807  : 
; 808  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 809  : 
; 810  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 811  : 		// whitening value for this data unit)
; 812  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0009b	8b 45 cc	 mov	 eax, DWORD PTR _dataUnitNo$[ebp]

; 813  : 		*(whiteningValuePtr64 + 1) = 0;
; 814  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0009e	ff 75 c8	 push	 DWORD PTR _ks2$GSCopy$[ebp]
  000a1	83 65 f4 00	 and	 DWORD PTR _whiteningValue$[ebp+8], 0
  000a5	83 65 f8 00	 and	 DWORD PTR _whiteningValue$[ebp+12], 0
  000a9	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000ac	8b 45 d0	 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  000af	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000b2	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000b5	8b c6		 mov	 eax, esi
  000b7	50		 push	 eax
  000b8	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000bb	e8 00 00 00 00	 call	 _EncipherBlock@12

; 815  : 
; 816  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 817  : 		// decrypt all relevant blocks in this data unit
; 818  : 		for (block = 0; block < endBlock; block++)

  000c0	33 c0		 xor	 eax, eax
  000c2	89 45 d8	 mov	 DWORD PTR _block$[ebp], eax
  000c5	3b d8		 cmp	 ebx, eax
  000c7	0f 86 bd 00 00
	00		 jbe	 $LN9@DecryptBuf@3
$LL36@DecryptBuf@3:

; 819  : 		{
; 820  : 			if (block >= startBlock)

  000cd	8b 45 d8	 mov	 eax, DWORD PTR _block$[ebp]
  000d0	3b 45 dc	 cmp	 eax, DWORD PTR _startBlock$[ebp]
  000d3	72 47		 jb	 SHORT $LN8@DecryptBuf@3

; 821  : 			{
; 822  : 				// Post-whitening
; 823  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000d5	8b 06		 mov	 eax, DWORD PTR [esi]
  000d7	31 07		 xor	 DWORD PTR [edi], eax
  000d9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000dc	31 47 04	 xor	 DWORD PTR [edi+4], eax
  000df	6a 08		 push	 8
  000e1	5b		 pop	 ebx

; 824  : 				*bufPtr-- ^= *whiteningValuePtr64--;
; 825  : 
; 826  : 				// Actual decryption
; 827  : 				DecipherBlock (cipher, bufPtr, ks);

  000e2	ff 75 c4	 push	 DWORD PTR _ks$GSCopy$[ebp]
  000e5	03 f3		 add	 esi, ebx
  000e7	8b 06		 mov	 eax, DWORD PTR [esi]
  000e9	03 fb		 add	 edi, ebx
  000eb	31 07		 xor	 DWORD PTR [edi], eax
  000ed	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f0	31 47 04	 xor	 DWORD PTR [edi+4], eax
  000f3	2b fb		 sub	 edi, ebx
  000f5	57		 push	 edi
  000f6	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000f9	2b f3		 sub	 esi, ebx
  000fb	e8 00 00 00 00	 call	 _DecipherBlock@12

; 828  : 
; 829  : 				// Pre-whitening
; 830  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00100	8b 06		 mov	 eax, DWORD PTR [esi]
  00102	31 07		 xor	 DWORD PTR [edi], eax
  00104	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00107	31 47 04	 xor	 DWORD PTR [edi+4], eax
  0010a	03 f3		 add	 esi, ebx

; 831  : 				*bufPtr++ ^= *whiteningValuePtr64;

  0010c	8b 06		 mov	 eax, DWORD PTR [esi]
  0010e	03 fb		 add	 edi, ebx
  00110	31 07		 xor	 DWORD PTR [edi], eax
  00112	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00115	31 47 04	 xor	 DWORD PTR [edi+4], eax
  00118	03 fb		 add	 edi, ebx

; 832  : 			}
; 833  : 			else

  0011a	eb 03		 jmp	 SHORT $LN7@DecryptBuf@3
$LN8@DecryptBuf@3:

; 834  : 				whiteningValuePtr64++;

  0011c	83 c6 08	 add	 esi, 8
$LN7@DecryptBuf@3:

; 835  : 
; 836  : 			// Derive the next whitening value
; 837  : 
; 838  : #if BYTE_ORDER == LITTLE_ENDIAN
; 839  : 
; 840  : 			// Little-endian platforms
; 841  : 
; 842  : 			finalCarry = 
; 843  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 844  : 				135 : 0;

  0011f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8b da		 mov	 ebx, edx
  00126	81 e3 00 00 00
	80		 and	 ebx, -2147483648	; 80000000H
  0012c	33 c9		 xor	 ecx, ecx
  0012e	0b cb		 or	 ecx, ebx
  00130	c6 45 eb 87	 mov	 BYTE PTR _finalCarry$[ebp], 135 ; 00000087H
  00134	75 04		 jne	 SHORT $LN20@DecryptBuf@3
  00136	c6 45 eb 00	 mov	 BYTE PTR _finalCarry$[ebp], 0
$LN20@DecryptBuf@3:

; 845  : 
; 846  : 			*whiteningValuePtr64-- <<= 1;

  0013a	0f a4 c2 01	 shld	 edx, eax, 1
  0013e	03 c0		 add	 eax, eax
  00140	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00143	89 06		 mov	 DWORD PTR [esi], eax

; 847  : 
; 848  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00145	8b 5e fc	 mov	 ebx, DWORD PTR [esi-4]
  00148	83 ee 08	 sub	 esi, 8
  0014b	8b 06		 mov	 eax, DWORD PTR [esi]
  0014d	8b d3		 mov	 edx, ebx
  0014f	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00155	33 c9		 xor	 ecx, ecx
  00157	0b ca		 or	 ecx, edx
  00159	74 0a		 je	 SHORT $LN6@DecryptBuf@3

; 849  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0015b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0015e	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00162	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN6@DecryptBuf@3:

; 850  : 
; 851  : 			*whiteningValuePtr64 <<= 1;

  00165	0f a4 c3 01	 shld	 ebx, eax, 1
  00169	03 c0		 add	 eax, eax
  0016b	89 06		 mov	 DWORD PTR [esi], eax

; 852  : 
; 853  : #else
; 854  : 			// Big-endian platforms
; 855  : 
; 856  : 			finalCarry = 
; 857  : 				(*whiteningValuePtr64 & 0x80) ?
; 858  : 				135 : 0;
; 859  : 
; 860  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 861  : 
; 862  : 			whiteningValuePtr64--;
; 863  : 
; 864  : 			if (*whiteningValuePtr64 & 0x80)
; 865  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 866  : 
; 867  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 868  : #endif
; 869  : 
; 870  : 			whiteningValue[0] ^= finalCarry;

  0016d	8a 45 eb	 mov	 al, BYTE PTR _finalCarry$[ebp]
  00170	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00173	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  00176	ff 45 d8	 inc	 DWORD PTR _block$[ebp]
  00179	8b 45 d8	 mov	 eax, DWORD PTR _block$[ebp]
  0017c	3b 45 d4	 cmp	 eax, DWORD PTR _endBlock$[ebp]
  0017f	0f 82 48 ff ff
	ff		 jb	 $LL36@DecryptBuf@3
  00185	8b 5d d4	 mov	 ebx, DWORD PTR _endBlock$[ebp]
  00188	33 c0		 xor	 eax, eax
$LN9@DecryptBuf@3:

; 871  : 		}
; 872  : 
; 873  : 		blockCount -= endBlock - startBlock;

  0018a	2b 5d dc	 sub	 ebx, DWORD PTR _startBlock$[ebp]

; 874  : 		startBlock = 0;

  0018d	89 45 dc	 mov	 DWORD PTR _startBlock$[ebp], eax
  00190	29 5d e0	 sub	 DWORD PTR _blockCount$[ebp], ebx
  00193	19 45 e4	 sbb	 DWORD PTR _blockCount$[ebp+4], eax

; 875  : 		dataUnitNo++;

  00196	83 45 cc 01	 add	 DWORD PTR _dataUnitNo$[ebp], 1
  0019a	11 45 d0	 adc	 DWORD PTR _dataUnitNo$[ebp+4], eax
  0019d	39 45 e4	 cmp	 DWORD PTR _blockCount$[ebp+4], eax
  001a0	0f 87 ce fe ff
	ff		 ja	 $LL34@DecryptBuf@3

; 799  : 
; 800  : 	// Process all blocks in the buffer
; 801  : 	while (blockCount > 0)

  001a6	72 0a		 jb	 SHORT $LN39@DecryptBuf@3
  001a8	83 7d e0 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  001ac	0f 87 c2 fe ff
	ff		 ja	 $LL34@DecryptBuf@3
$LN39@DecryptBuf@3:
  001b2	5e		 pop	 esi
  001b3	5b		 pop	 ebx
$LN5@DecryptBuf@3:

; 876  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 877  : 	}
; 878  : 
; 879  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  001b4	6a 02		 push	 2
  001b6	59		 pop	 ecx
  001b7	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  001ba	5f		 pop	 edi
$LL2@DecryptBuf@3:
  001bb	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001c1	49		 dec	 ecx
  001c2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  001c9	83 c0 08	 add	 eax, 8
  001cc	85 c9		 test	 ecx, ecx
  001ce	75 eb		 jne	 SHORT $LL2@DecryptBuf@3

; 880  : }

  001d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d3	33 cd		 xor	 ecx, ebp
  001d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001da	c9		 leave
  001db	c2 18 00	 ret	 24			; 00000018H
$LN41@DecryptBuf@3:
_DecryptBufferXTSNonParallel@32 ENDP
_TEXT	ENDS
PUBLIC	_EncryptBufferXTS@32
EXTRN	_CipherSupportsIntraDataUnitParallelization@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptBufferXTS@32
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTS@32 PROC				; COMDAT

; 72   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 73   : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00005	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization@4

; 74   : 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0000d	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00010	8b 4d 1c	 mov	 ecx, DWORD PTR _ks$[ebp]
  00013	ff 75 20	 push	 DWORD PTR _ks2$[ebp]
  00016	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00019	ff 75 18	 push	 DWORD PTR _startCipherBlockNo$[ebp]
  0001c	ff 75 14	 push	 DWORD PTR _startDataUnitNo$[ebp]
  0001f	ff 75 10	 push	 DWORD PTR _length$[ebp+4]
  00022	ff 75 0c	 push	 DWORD PTR _length$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	74 07		 je	 SHORT $LN2@EncryptBuf@4
  00029	e8 00 00 00 00	 call	 _EncryptBufferXTSParallel@32

; 75   : 	else

  0002e	eb 05		 jmp	 SHORT $LN1@EncryptBuf@4
$LN2@EncryptBuf@4:

; 76   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00030	e8 00 00 00 00	 call	 _EncryptBufferXTSNonParallel@32
$LN1@EncryptBuf@4:

; 77   : }

  00035	5d		 pop	 ebp
  00036	c2 20 00	 ret	 32			; 00000020H
_EncryptBufferXTS@32 ENDP
_TEXT	ENDS
PUBLIC	_DecryptBufferXTS@32
; Function compile flags: /Ogsp
;	COMDAT _DecryptBufferXTS@32
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTS@32 PROC				; COMDAT

; 504  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 505  : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00005	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization@4

; 506  : 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0000d	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00010	8b 4d 1c	 mov	 ecx, DWORD PTR _ks$[ebp]
  00013	ff 75 20	 push	 DWORD PTR _ks2$[ebp]
  00016	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00019	ff 75 18	 push	 DWORD PTR _startCipherBlockNo$[ebp]
  0001c	ff 75 14	 push	 DWORD PTR _startDataUnitNo$[ebp]
  0001f	ff 75 10	 push	 DWORD PTR _length$[ebp+4]
  00022	ff 75 0c	 push	 DWORD PTR _length$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	74 07		 je	 SHORT $LN2@DecryptBuf@4
  00029	e8 00 00 00 00	 call	 _DecryptBufferXTSParallel@32

; 507  : 	else

  0002e	eb 05		 jmp	 SHORT $LN1@DecryptBuf@4
$LN2@DecryptBuf@4:

; 508  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00030	e8 00 00 00 00	 call	 _DecryptBufferXTSNonParallel@32
$LN1@DecryptBuf@4:

; 509  : }

  00035	5d		 pop	 ebp
  00036	c2 20 00	 ret	 32			; 00000020H
_DecryptBufferXTS@32 ENDP
_TEXT	ENDS
END
