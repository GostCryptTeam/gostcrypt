; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_hmac_truncate@12
; Function compile flags: /Ogsp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _hmac_truncate@12
_TEXT	SEGMENT
_d1$ = 8						; size = 4
_d2$ = 12						; size = 4
_len$ = 16						; size = 4
_hmac_truncate@12 PROC					; COMDAT

; 52   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 53   : 	int i;
; 54   : 	for (i = 0; i < len; i++)

  00006	8b 75 10	 mov	 esi, DWORD PTR _len$[ebp]
  00009	85 f6		 test	 esi, esi
  0000b	7e 11		 jle	 SHORT $LN1@hmac_trunc
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _d2$[ebp]
  00010	8b 45 08	 mov	 eax, DWORD PTR _d1$[ebp]
  00013	2b c1		 sub	 eax, ecx
$LL3@hmac_trunc:

; 55   : 		d2[i] = d1[i];

  00015	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00018	88 11		 mov	 BYTE PTR [ecx], dl
  0001a	41		 inc	 ecx
  0001b	4e		 dec	 esi
  0001c	75 f7		 jne	 SHORT $LL3@hmac_trunc
$LN1@hmac_trunc:
  0001e	5e		 pop	 esi

; 56   : }

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
_hmac_truncate@12 ENDP
_TEXT	ENDS
PUBLIC	_out$GSCopy$
PUBLIC	_k$GSCopy$
PUBLIC	_d$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_whirlpool@24
EXTRN	_WHIRLPOOL_finalize@8:PROC
EXTRN	_WHIRLPOOL_add@12:PROC
EXTRN	_WHIRLPOOL_init@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _hmac_whirlpool@24
_TEXT	SEGMENT
_out$GSCopy$ = -776					; size = 4
_k$GSCopy$ = -772					; size = 4
tv493 = -768						; size = 4
_d$GSCopy$ = -768					; size = 4
_tctx$25541 = -764					; size = 168
_octx$ = -596						; size = 168
_ictx$ = -428						; size = 168
_key$ = -260						; size = 64
_iwhi$ = -196						; size = 64
_owhi$ = -132						; size = 64
_buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_whirlpool@24 PROC					; COMDAT

; 81   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 08 03 00
	00		 sub	 esp, 776		; 00000308H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 08	 mov	 ebx, DWORD PTR _k$[ebp]
  0001c	56		 push	 esi

; 82   : 	WHIRLPOOL_CTX ictx, octx;
; 83   : 	char iwhi[WHIRLPOOL_DIGESTSIZE], owhi[WHIRLPOOL_DIGESTSIZE];
; 84   : 	char key[WHIRLPOOL_DIGESTSIZE];
; 85   : 	char buf[WHIRLPOOL_BLOCKSIZE];
; 86   : 	int i;
; 87   : 
; 88   :     /* If the key is longer than the hash algorithm block size,
; 89   : 	   let key = whirlpool(key), as per HMAC specifications. */
; 90   : 	if (lk > WHIRLPOOL_BLOCKSIZE)

  0001d	8b 75 0c	 mov	 esi, DWORD PTR _lk$[ebp]
  00020	83 fe 40	 cmp	 esi, 64			; 00000040H

; 126  : 		buf[i] = 0x5C;
; 127  : 
; 128  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  00023	89 85 00 fd ff
	ff		 mov	 DWORD PTR _d$GSCopy$[ebp], eax
  00029	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  0002c	57		 push	 edi
  0002d	89 9d fc fc ff
	ff		 mov	 DWORD PTR _k$GSCopy$[ebp], ebx
  00033	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _out$GSCopy$[ebp], eax
  00039	bf a8 00 00 00	 mov	 edi, 168		; 000000a8H
  0003e	7e 5d		 jle	 SHORT $LN45@hmac_whirl
  00040	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$25541[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4
  0004c	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$25541[ebp]
  00052	50		 push	 eax
  00053	8b c6		 mov	 eax, esi
  00055	c1 e0 03	 shl	 eax, 3
  00058	50		 push	 eax
  00059	53		 push	 ebx
  0005a	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12
  0005f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  00065	50		 push	 eax
  00066	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$25541[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8
  00072	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  00078	6a 40		 push	 64			; 00000040H
  0007a	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR _tctx$25541[ebp]
  00080	89 85 fc fc ff
	ff		 mov	 DWORD PTR _k$GSCopy$[ebp], eax
  00086	5e		 pop	 esi
  00087	8b d7		 mov	 edx, edi
  00089	8b df		 mov	 ebx, edi
  0008b	8b c1		 mov	 eax, ecx
$LL54@hmac_whirl:
  0008d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00090	40		 inc	 eax
  00091	4b		 dec	 ebx
  00092	75 f9		 jne	 SHORT $LL54@hmac_whirl
$LL44@hmac_whirl:

; 91   : 	{
; 92   : 		WHIRLPOOL_CTX tctx;
; 93   : 
; 94   : 		WHIRLPOOL_init (&tctx);
; 95   : 		WHIRLPOOL_add ((unsigned char *) k, lk * 8, &tctx);
; 96   : 		WHIRLPOOL_finalize (&tctx, (unsigned char *) key);
; 97   : 
; 98   : 		k = key;
; 99   : 		lk = WHIRLPOOL_DIGESTSIZE;
; 100  : 
; 101  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  00094	4a		 dec	 edx
  00095	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00098	41		 inc	 ecx
  00099	85 d2		 test	 edx, edx
  0009b	75 f7		 jne	 SHORT $LL44@hmac_whirl
$LN45@hmac_whirl:

; 102  : 	}
; 103  : 
; 104  : 	/**** Inner Digest ****/
; 105  : 
; 106  : 	WHIRLPOOL_init (&ictx);

  0009d	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4

; 107  : 
; 108  : 	/* Pad the key for inner digest */
; 109  : 	for (i = 0; i < lk; ++i)

  000a9	33 c9		 xor	 ecx, ecx
  000ab	85 f6		 test	 esi, esi
  000ad	7e 1c		 jle	 SHORT $LN40@hmac_whirl
  000af	8b 95 fc fc ff
	ff		 mov	 edx, DWORD PTR _k$GSCopy$[ebp]
  000b5	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  000b8	2b d0		 sub	 edx, eax
$LL42@hmac_whirl:

; 110  : 		buf[i] = (char) (k[i] ^ 0x36);

  000ba	8d 44 0d bc	 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  000be	8a 1c 02	 mov	 bl, BYTE PTR [edx+eax]
  000c1	80 f3 36	 xor	 bl, 54			; 00000036H
  000c4	41		 inc	 ecx
  000c5	3b ce		 cmp	 ecx, esi
  000c7	88 18		 mov	 BYTE PTR [eax], bl
  000c9	7c ef		 jl	 SHORT $LL42@hmac_whirl
$LN40@hmac_whirl:

; 111  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  000cb	83 fe 40	 cmp	 esi, 64			; 00000040H
  000ce	7d 15		 jge	 SHORT $LN39@hmac_whirl
  000d0	6a 40		 push	 64			; 00000040H
  000d2	59		 pop	 ecx
  000d3	2b ce		 sub	 ecx, esi
  000d5	51		 push	 ecx
  000d6	8d 44 35 bc	 lea	 eax, DWORD PTR _buf$[ebp+esi]
  000da	6a 36		 push	 54			; 00000036H
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _memset
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@hmac_whirl:

; 112  : 		buf[i] = 0x36;
; 113  : 
; 114  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &ictx);

  000e5	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  000eb	50		 push	 eax
  000ec	bb 00 02 00 00	 mov	 ebx, 512		; 00000200H
  000f1	53		 push	 ebx
  000f2	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 115  : 	WHIRLPOOL_add ((unsigned char *) d, ld * 8, &ictx);

  000fb	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00101	50		 push	 eax
  00102	8b 45 14	 mov	 eax, DWORD PTR _ld$[ebp]
  00105	c1 e0 03	 shl	 eax, 3
  00108	50		 push	 eax
  00109	ff b5 00 fd ff
	ff		 push	 DWORD PTR _d$GSCopy$[ebp]
  0010f	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 116  : 
; 117  : 	WHIRLPOOL_finalize (&ictx, (unsigned char *) iwhi);

  00114	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  0011a	50		 push	 eax
  0011b	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8

; 118  : 
; 119  : 	/**** Outer Digest ****/
; 120  : 
; 121  : 	WHIRLPOOL_init (&octx);

  00127	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4

; 122  : 
; 123  : 	for (i = 0; i < lk; ++i)

  00133	33 c9		 xor	 ecx, ecx
  00135	85 f6		 test	 esi, esi
  00137	7e 2a		 jle	 SHORT $LN34@hmac_whirl
  00139	8b 95 fc fc ff
	ff		 mov	 edx, DWORD PTR _k$GSCopy$[ebp]
  0013f	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  00142	2b d0		 sub	 edx, eax
  00144	89 95 00 fd ff
	ff		 mov	 DWORD PTR tv493[ebp], edx
  0014a	eb 06		 jmp	 SHORT $LN36@hmac_whirl
$LL156@hmac_whirl:
  0014c	8b 95 00 fd ff
	ff		 mov	 edx, DWORD PTR tv493[ebp]
$LN36@hmac_whirl:

; 124  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00152	8d 44 0d bc	 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  00156	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  00159	80 f2 5c	 xor	 dl, 92			; 0000005cH
  0015c	41		 inc	 ecx
  0015d	3b ce		 cmp	 ecx, esi
  0015f	88 10		 mov	 BYTE PTR [eax], dl
  00161	7c e9		 jl	 SHORT $LL156@hmac_whirl
$LN34@hmac_whirl:

; 125  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  00163	83 fe 40	 cmp	 esi, 64			; 00000040H
  00166	7d 15		 jge	 SHORT $LN33@hmac_whirl
  00168	6a 40		 push	 64			; 00000040H
  0016a	59		 pop	 ecx
  0016b	2b ce		 sub	 ecx, esi
  0016d	51		 push	 ecx
  0016e	8d 44 35 bc	 lea	 eax, DWORD PTR _buf$[ebp+esi]
  00172	6a 5c		 push	 92			; 0000005cH
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _memset
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@hmac_whirl:

; 126  : 		buf[i] = 0x5C;
; 127  : 
; 128  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  0017d	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00183	50		 push	 eax
  00184	53		 push	 ebx
  00185	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 129  : 	WHIRLPOOL_add ((unsigned char *) iwhi, WHIRLPOOL_DIGESTSIZE * 8, &octx);

  0018e	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00194	50		 push	 eax
  00195	53		 push	 ebx
  00196	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 130  : 
; 131  : 	WHIRLPOOL_finalize (&octx, (unsigned char *) owhi);

  001a2	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _owhi$[ebp]
  001a8	50		 push	 eax
  001a9	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8

; 132  : 
; 133  : 	/* truncate and print the results */
; 134  : 	t = t > WHIRLPOOL_DIGESTSIZE ? WHIRLPOOL_DIGESTSIZE : t;

  001b5	6a 40		 push	 64			; 00000040H
  001b7	5e		 pop	 esi
  001b8	39 75 1c	 cmp	 DWORD PTR _t$[ebp], esi
  001bb	7e 03		 jle	 SHORT $LN51@hmac_whirl
  001bd	89 75 1c	 mov	 DWORD PTR _t$[ebp], esi
$LN51@hmac_whirl:

; 135  : 	hmac_truncate (owhi, out, t);

  001c0	ff 75 1c	 push	 DWORD PTR _t$[ebp]
  001c3	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _owhi$[ebp]
  001c9	ff b5 f8 fc ff
	ff		 push	 DWORD PTR _out$GSCopy$[ebp]
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 _hmac_truncate@12

; 136  : 
; 137  : 	/* Prevent possible leaks. */
; 138  : 	burn (&ictx, sizeof(ictx));

  001d5	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _ictx$[ebp]
  001db	8b d7		 mov	 edx, edi
  001dd	8b df		 mov	 ebx, edi
  001df	8b c1		 mov	 eax, ecx
$LL58@hmac_whirl:
  001e1	c6 00 00	 mov	 BYTE PTR [eax], 0
  001e4	40		 inc	 eax
  001e5	4b		 dec	 ebx
  001e6	75 f9		 jne	 SHORT $LL58@hmac_whirl
$LL27@hmac_whirl:
  001e8	4a		 dec	 edx
  001e9	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001ec	41		 inc	 ecx
  001ed	85 d2		 test	 edx, edx
  001ef	75 f7		 jne	 SHORT $LL27@hmac_whirl

; 139  : 	burn (&octx, sizeof(octx));

  001f1	8d 8d ac fd ff
	ff		 lea	 ecx, DWORD PTR _octx$[ebp]
  001f7	8b d7		 mov	 edx, edi
  001f9	8b c1		 mov	 eax, ecx
$LL62@hmac_whirl:
  001fb	c6 00 00	 mov	 BYTE PTR [eax], 0
  001fe	40		 inc	 eax
  001ff	4f		 dec	 edi
  00200	75 f9		 jne	 SHORT $LL62@hmac_whirl
$LL22@hmac_whirl:
  00202	4a		 dec	 edx
  00203	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00206	41		 inc	 ecx
  00207	85 d2		 test	 edx, edx
  00209	75 f7		 jne	 SHORT $LL22@hmac_whirl

; 140  : 	burn (owhi, sizeof(owhi));

  0020b	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _owhi$[ebp]
  00211	8b d6		 mov	 edx, esi
  00213	8b fe		 mov	 edi, esi
  00215	8b c1		 mov	 eax, ecx
$LL66@hmac_whirl:
  00217	c6 00 00	 mov	 BYTE PTR [eax], 0
  0021a	40		 inc	 eax
  0021b	4f		 dec	 edi
  0021c	75 f9		 jne	 SHORT $LL66@hmac_whirl
$LL17@hmac_whirl:
  0021e	4a		 dec	 edx
  0021f	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00222	41		 inc	 ecx
  00223	85 d2		 test	 edx, edx
  00225	75 f7		 jne	 SHORT $LL17@hmac_whirl

; 141  : 	burn (iwhi, sizeof(iwhi));

  00227	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _iwhi$[ebp]
  0022d	8b d6		 mov	 edx, esi
  0022f	8b fe		 mov	 edi, esi
  00231	8b c1		 mov	 eax, ecx
$LL70@hmac_whirl:
  00233	c6 00 00	 mov	 BYTE PTR [eax], 0
  00236	40		 inc	 eax
  00237	4f		 dec	 edi
  00238	75 f9		 jne	 SHORT $LL70@hmac_whirl
$LL12@hmac_whirl:
  0023a	4a		 dec	 edx
  0023b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0023e	41		 inc	 ecx
  0023f	85 d2		 test	 edx, edx
  00241	75 f7		 jne	 SHORT $LL12@hmac_whirl

; 142  : 	burn (buf, sizeof(buf));

  00243	8d 4d bc	 lea	 ecx, DWORD PTR _buf$[ebp]
  00246	8b d6		 mov	 edx, esi
  00248	8b fe		 mov	 edi, esi
  0024a	8b c1		 mov	 eax, ecx
$LL74@hmac_whirl:
  0024c	c6 00 00	 mov	 BYTE PTR [eax], 0
  0024f	40		 inc	 eax
  00250	4f		 dec	 edi
  00251	75 f9		 jne	 SHORT $LL74@hmac_whirl
$LL7@hmac_whirl:
  00253	4a		 dec	 edx
  00254	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00257	41		 inc	 ecx
  00258	85 d2		 test	 edx, edx
  0025a	75 f7		 jne	 SHORT $LL7@hmac_whirl

; 143  : 	burn (key, sizeof(key));

  0025c	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  00262	8b d6		 mov	 edx, esi
  00264	8b c1		 mov	 eax, ecx
$LL78@hmac_whirl:
  00266	c6 00 00	 mov	 BYTE PTR [eax], 0
  00269	40		 inc	 eax
  0026a	4e		 dec	 esi
  0026b	75 f9		 jne	 SHORT $LL78@hmac_whirl
  0026d	5f		 pop	 edi
  0026e	5e		 pop	 esi
  0026f	5b		 pop	 ebx
$LL2@hmac_whirl:
  00270	4a		 dec	 edx
  00271	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00274	41		 inc	 ecx
  00275	85 d2		 test	 edx, edx
  00277	75 f7		 jne	 SHORT $LL2@hmac_whirl

; 144  : }

  00279	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027c	33 cd		 xor	 ecx, ebp
  0027e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00283	c9		 leave
  00284	c2 18 00	 ret	 24			; 00000018H
_hmac_whirlpool@24 ENDP
_TEXT	ENDS
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_whirlpool@28
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT _derive_u_whirlpool@28
_TEXT	SEGMENT
_pwd$GSCopy$ = -268					; size = 4
_counter$ = -264					; size = 4
_init$ = -260						; size = 128
_k$ = -132						; size = 64
_j$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_whirlpool@28 PROC				; COMDAT

; 161  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  0001b	53		 push	 ebx
  0001c	8b 5d 1c	 mov	 ebx, DWORD PTR _u$[ebp]
  0001f	56		 push	 esi
  00020	8b 75 14	 mov	 esi, DWORD PTR _salt_len$[ebp]
  00023	57		 push	 edi

; 162  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 163  : 	char init[128];
; 164  : 	char counter[4];
; 165  : 	int c, i;
; 166  : 
; 167  : 	/* iteration 1 */
; 168  : 	memset (counter, 0, 4);
; 169  : 	counter[3] = (char) b;
; 170  : 	memcpy (init, salt, salt_len);	/* salt */
; 171  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 172  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);
; 173  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);
; 174  : 
; 175  : 	/* remaining iterations */
; 176  : 	for (c = 1; c < iterations; c++)

  00024	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0002a	33 c0		 xor	 eax, eax
  0002c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _counter$[ebp]
  00032	ab		 stosd
  00033	8a 45 20	 mov	 al, BYTE PTR _b$[ebp]
  00036	56		 push	 esi
  00037	88 85 fb fe ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], al
  0003d	51		 push	 ecx
  0003e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memcpy
  0004a	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	6a 40		 push	 64			; 00000040H
  00055	89 84 35 fc fe
	ff ff		 mov	 DWORD PTR _init$[ebp+esi], eax
  0005c	8d 45 bc	 lea	 eax, DWORD PTR _j$[ebp]
  0005f	50		 push	 eax
  00060	83 c6 04	 add	 esi, 4
  00063	56		 push	 esi
  00064	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  0006a	50		 push	 eax
  0006b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0006e	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00074	e8 00 00 00 00	 call	 _hmac_whirlpool@24
  00079	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0007c	83 f8 01	 cmp	 eax, 1
  0007f	6a 10		 push	 16			; 00000010H
  00081	59		 pop	 ecx
  00082	8d 75 bc	 lea	 esi, DWORD PTR _j$[ebp]
  00085	8b fb		 mov	 edi, ebx
  00087	f3 a5		 rep movsd
  00089	7e 47		 jle	 SHORT $LN47@derive_u_w
  0008b	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  00091	2b d9		 sub	 ebx, ecx
  00093	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
$LL16@derive_u_w:

; 177  : 	{
; 178  : 		hmac_whirlpool (pwd, pwd_len, j, WHIRLPOOL_DIGESTSIZE, k, WHIRLPOOL_DIGESTSIZE);

  00096	6a 40		 push	 64			; 00000040H
  00098	5e		 pop	 esi
  00099	56		 push	 esi
  0009a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  000a0	50		 push	 eax
  000a1	56		 push	 esi
  000a2	8d 45 bc	 lea	 eax, DWORD PTR _j$[ebp]
  000a5	50		 push	 eax
  000a6	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000a9	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000af	e8 00 00 00 00	 call	 _hmac_whirlpool@24

; 179  : 		for (i = 0; i < WHIRLPOOL_DIGESTSIZE; i++)

  000b4	33 d2		 xor	 edx, edx
$LL13@derive_u_w:

; 180  : 		{
; 181  : 			u[i] ^= k[i];

  000b6	8d 84 15 7c ff
	ff ff		 lea	 eax, DWORD PTR _k$[ebp+edx]
  000bd	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  000c0	8a 00		 mov	 al, BYTE PTR [eax]
  000c2	30 01		 xor	 BYTE PTR [ecx], al

; 182  : 			j[i] = k[i];

  000c4	88 44 15 bc	 mov	 BYTE PTR _j$[ebp+edx], al
  000c8	42		 inc	 edx
  000c9	3b d6		 cmp	 edx, esi
  000cb	7c e9		 jl	 SHORT $LL13@derive_u_w

; 162  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 163  : 	char init[128];
; 164  : 	char counter[4];
; 165  : 	int c, i;
; 166  : 
; 167  : 	/* iteration 1 */
; 168  : 	memset (counter, 0, 4);
; 169  : 	counter[3] = (char) b;
; 170  : 	memcpy (init, salt, salt_len);	/* salt */
; 171  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 172  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);
; 173  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);
; 174  : 
; 175  : 	/* remaining iterations */
; 176  : 	for (c = 1; c < iterations; c++)

  000cd	4f		 dec	 edi
  000ce	75 c6		 jne	 SHORT $LL16@derive_u_w
  000d0	eb 03		 jmp	 SHORT $LN10@derive_u_w
$LN47@derive_u_w:
  000d2	6a 40		 push	 64			; 00000040H
  000d4	5e		 pop	 esi
$LN10@derive_u_w:

; 183  : 		}
; 184  : 	}
; 185  : 
; 186  : 	/* Prevent possible leaks. */
; 187  : 	burn (j, sizeof(j));

  000d5	8d 4d bc	 lea	 ecx, DWORD PTR _j$[ebp]
  000d8	8b d6		 mov	 edx, esi
  000da	8b fe		 mov	 edi, esi
  000dc	8b c1		 mov	 eax, ecx
$LL20@derive_u_w:
  000de	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e1	40		 inc	 eax
  000e2	4f		 dec	 edi
  000e3	75 f9		 jne	 SHORT $LL20@derive_u_w
$LL7@derive_u_w:
  000e5	4a		 dec	 edx
  000e6	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000e9	41		 inc	 ecx
  000ea	85 d2		 test	 edx, edx
  000ec	75 f7		 jne	 SHORT $LL7@derive_u_w

; 188  : 	burn (k, sizeof(k));

  000ee	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  000f4	8b d6		 mov	 edx, esi
  000f6	8b c1		 mov	 eax, ecx
$LL24@derive_u_w:
  000f8	c6 00 00	 mov	 BYTE PTR [eax], 0
  000fb	40		 inc	 eax
  000fc	4e		 dec	 esi
  000fd	75 f9		 jne	 SHORT $LL24@derive_u_w
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx
$LL2@derive_u_w:
  00102	4a		 dec	 edx
  00103	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00106	41		 inc	 ecx
  00107	85 d2		 test	 edx, edx
  00109	75 f7		 jne	 SHORT $LL2@derive_u_w

; 189  : }

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	c9		 leave
  00116	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_whirlpool@28 ENDP
_TEXT	ENDS
PUBLIC	_dk$GSCopy$
PUBLIC	_salt$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_whirlpool@28
; Function compile flags: /Ogsp
;	COMDAT _derive_key_whirlpool@28
_TEXT	SEGMENT
_r$ = -88						; size = 4
_pwd$GSCopy$ = -84					; size = 4
_salt$GSCopy$ = -80					; size = 4
_dk$GSCopy$ = -76					; size = 4
_b$ = -72						; size = 4
_u$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_whirlpool@28 PROC				; COMDAT

; 206  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 58	 sub	 esp, 88			; 00000058H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 217  : 	}
; 218  : 
; 219  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;

  00012	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00015	8b 4d 20	 mov	 ecx, DWORD PTR _dklen$[ebp]
  00018	89 45 ac	 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0001b	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0001e	89 45 b0	 mov	 DWORD PTR _salt$GSCopy$[ebp], eax
  00021	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  00024	89 45 b4	 mov	 DWORD PTR _dk$GSCopy$[ebp], eax
  00027	8b c1		 mov	 eax, ecx
  00029	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0002e	53		 push	 ebx
  0002f	56		 push	 esi
  00030	79 05		 jns	 SHORT $LN28@derive_key
  00032	48		 dec	 eax
  00033	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00036	40		 inc	 eax
$LN28@derive_key:
  00037	8b c1		 mov	 eax, ecx
  00039	99		 cdq
  0003a	74 0d		 je	 SHORT $LN10@derive_key
  0003c	83 e2 3f	 and	 edx, 63			; 0000003fH
  0003f	03 c2		 add	 eax, edx
  00041	8b d8		 mov	 ebx, eax
  00043	c1 fb 06	 sar	 ebx, 6
  00046	43		 inc	 ebx
  00047	eb 0a		 jmp	 SHORT $LN9@derive_key
$LN10@derive_key:

; 207  : 	char u[WHIRLPOOL_DIGESTSIZE];
; 208  : 	int b, l, r;
; 209  : 
; 210  : 	if (dklen % WHIRLPOOL_DIGESTSIZE)
; 211  : 	{
; 212  : 		l = 1 + dklen / WHIRLPOOL_DIGESTSIZE;
; 213  : 	}
; 214  : 	else
; 215  : 	{
; 216  : 		l = dklen / WHIRLPOOL_DIGESTSIZE;

  00049	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004c	03 c2		 add	 eax, edx
  0004e	8b d8		 mov	 ebx, eax
  00050	c1 fb 06	 sar	 ebx, 6
$LN9@derive_key:

; 217  : 	}
; 218  : 
; 219  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;

  00053	8b c3		 mov	 eax, ebx
  00055	c1 e0 06	 shl	 eax, 6
  00058	2b c8		 sub	 ecx, eax

; 220  : 
; 221  : 	/* first l - 1 blocks */
; 222  : 	for (b = 1; b < l; b++)

  0005a	33 c0		 xor	 eax, eax
  0005c	40		 inc	 eax
  0005d	83 c1 40	 add	 ecx, 64			; 00000040H
  00060	3b d8		 cmp	 ebx, eax
  00062	89 4d a8	 mov	 DWORD PTR _r$[ebp], ecx
  00065	89 45 b8	 mov	 DWORD PTR _b$[ebp], eax
  00068	7e 34		 jle	 SHORT $LN6@derive_key
  0006a	57		 push	 edi
$LL26@derive_key:

; 223  : 	{
; 224  : 		derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0006b	ff 75 b8	 push	 DWORD PTR _b$[ebp]
  0006e	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  00071	50		 push	 eax
  00072	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  00075	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  00078	ff 75 b0	 push	 DWORD PTR _salt$GSCopy$[ebp]
  0007b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0007e	ff 75 ac	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00081	e8 00 00 00 00	 call	 _derive_u_whirlpool@28

; 225  : 		memcpy (dk, u, WHIRLPOOL_DIGESTSIZE);

  00086	8b 7d b4	 mov	 edi, DWORD PTR _dk$GSCopy$[ebp]

; 226  : 		dk += WHIRLPOOL_DIGESTSIZE;

  00089	83 45 b4 40	 add	 DWORD PTR _dk$GSCopy$[ebp], 64 ; 00000040H
  0008d	ff 45 b8	 inc	 DWORD PTR _b$[ebp]
  00090	39 5d b8	 cmp	 DWORD PTR _b$[ebp], ebx
  00093	6a 10		 push	 16			; 00000010H
  00095	59		 pop	 ecx
  00096	8d 75 bc	 lea	 esi, DWORD PTR _u$[ebp]
  00099	f3 a5		 rep movsd
  0009b	7c ce		 jl	 SHORT $LL26@derive_key
  0009d	5f		 pop	 edi
$LN6@derive_key:

; 227  : 	}
; 228  : 
; 229  : 	/* last block */
; 230  : 	derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0009e	ff 75 b8	 push	 DWORD PTR _b$[ebp]
  000a1	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  000a4	50		 push	 eax
  000a5	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  000a8	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  000ab	ff 75 b0	 push	 DWORD PTR _salt$GSCopy$[ebp]
  000ae	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000b1	ff 75 ac	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000b4	e8 00 00 00 00	 call	 _derive_u_whirlpool@28

; 231  : 	memcpy (dk, u, r);

  000b9	ff 75 a8	 push	 DWORD PTR _r$[ebp]
  000bc	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  000bf	50		 push	 eax
  000c0	ff 75 b4	 push	 DWORD PTR _dk$GSCopy$[ebp]
  000c3	e8 00 00 00 00	 call	 _memcpy
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  : 
; 233  : 
; 234  : 	/* Prevent possible leaks. */
; 235  : 	burn (u, sizeof(u));

  000cb	6a 40		 push	 64			; 00000040H
  000cd	8d 4d bc	 lea	 ecx, DWORD PTR _u$[ebp]
  000d0	5e		 pop	 esi
  000d1	8b d6		 mov	 edx, esi
  000d3	8b c1		 mov	 eax, ecx
$LL14@derive_key:
  000d5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d8	40		 inc	 eax
  000d9	4e		 dec	 esi
  000da	75 f9		 jne	 SHORT $LL14@derive_key
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
$LL2@derive_key:
  000de	4a		 dec	 edx
  000df	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000e2	41		 inc	 ecx
  000e3	85 d2		 test	 edx, edx
  000e5	75 f7		 jne	 SHORT $LL2@derive_key

; 236  : }

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	c9		 leave
  000f2	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_whirlpool@28 ENDP
_TEXT	ENDS
PUBLIC	_out$GSCopy$
PUBLIC	_d$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_gosthash@20
EXTRN	_GOSTHASH_finalize@8:PROC
EXTRN	_GOSTHASH_add@12:PROC
EXTRN	_GOSTHASH_init@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _hmac_gosthash@20
_TEXT	SEGMENT
_out$GSCopy$ = -248					; size = 4
_d$GSCopy$ = -244					; size = 4
tv466 = -240						; size = 4
_burnc$25731 = -240					; size = 4
_ctx$ = -236						; size = 104
_outer$ = -132						; size = 32
_key$ = -100						; size = 32
_inner$ = -68						; size = 32
_buf$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_hmac_gosthash@20 PROC					; COMDAT

; 258  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 08	 mov	 ebx, DWORD PTR _k$[ebp]
  0001c	56		 push	 esi

; 259  : 	gost_hash_ctx ctx;
; 260  : 	char inner[GOSTHASH_DIGESTSIZE], outer[GOSTHASH_DIGESTSIZE];
; 261  : 	char key[GOSTHASH_DIGESTSIZE];
; 262  : 	char buf[GOSTHASH_BLOCKSIZE];
; 263  : 	int32 i;
; 264  : 
; 265  :     /* If the key is longer than the hash algorithm block size,
; 266  : 	   let key = gosthash(key), as per HMAC specifications. */
; 267  : 	if (lk > GOSTHASH_BLOCKSIZE)

  0001d	8b 75 0c	 mov	 esi, DWORD PTR _lk$[ebp]
  00020	57		 push	 edi
  00021	6a 20		 push	 32			; 00000020H

; 297  : 
; 298  : 	for (i = 0; i < lk; ++i)

  00023	89 85 0c ff ff
	ff		 mov	 DWORD PTR _d$GSCopy$[ebp], eax
  00029	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  0002c	5f		 pop	 edi
  0002d	3b f7		 cmp	 esi, edi
  0002f	89 85 08 ff ff
	ff		 mov	 DWORD PTR _out$GSCopy$[ebp], eax
  00035	7e 5c		 jle	 SHORT $LN40@hmac_gosth
  00037	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _GOSTHASH_init@4
  00043	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00049	50		 push	 eax
  0004a	56		 push	 esi
  0004b	53		 push	 ebx
  0004c	e8 00 00 00 00	 call	 _GOSTHASH_add@12
  00051	8d 45 9c	 lea	 eax, DWORD PTR _key$[ebp]
  00054	50		 push	 eax
  00055	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _GOSTHASH_finalize@8
  00061	6a 68		 push	 104			; 00000068H
  00063	58		 pop	 eax
  00064	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  0006a	89 85 10 ff ff
	ff		 mov	 DWORD PTR _burnc$25731[ebp], eax
  00070	8b d0		 mov	 edx, eax
  00072	8d 5d 9c	 lea	 ebx, DWORD PTR _key$[ebp]
  00075	8b f7		 mov	 esi, edi
  00077	8b c1		 mov	 eax, ecx
$LL47@hmac_gosth:
  00079	c6 00 00	 mov	 BYTE PTR [eax], 0
  0007c	40		 inc	 eax
  0007d	4a		 dec	 edx
  0007e	75 f9		 jne	 SHORT $LL47@hmac_gosth
$LL39@hmac_gosth:

; 268  : 	{
; 269  : 		GOSTHASH_init (&ctx);
; 270  : 		GOSTHASH_add ((unsigned char *)k, lk, &ctx);
; 271  : 		GOSTHASH_finalize (&ctx, (unsigned char *) key);
; 272  : 
; 273  : 		k = key;
; 274  : 		lk = GOSTHASH_DIGESTSIZE;
; 275  : 
; 276  : 		burn (&ctx, sizeof(ctx));		// Prevent leaks

  00080	ff 8d 10 ff ff
	ff		 dec	 DWORD PTR _burnc$25731[ebp]
  00086	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00089	41		 inc	 ecx
  0008a	83 bd 10 ff ff
	ff 00		 cmp	 DWORD PTR _burnc$25731[ebp], 0
  00091	75 ed		 jne	 SHORT $LL39@hmac_gosth
$LN40@hmac_gosth:

; 277  : 	}
; 278  : 
; 279  : 	/**** Inner Digest ****/
; 280  : 
; 281  : 	GOSTHASH_init (&ctx);

  00093	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _GOSTHASH_init@4

; 282  : 
; 283  : 	/* Pad the key for inner digest */
; 284  : 	for (i = 0; i < lk; ++i)

  0009f	33 c9		 xor	 ecx, ecx
  000a1	85 f6		 test	 esi, esi
  000a3	7e 26		 jle	 SHORT $LN35@hmac_gosth
  000a5	89 9d 10 ff ff
	ff		 mov	 DWORD PTR tv466[ebp], ebx
  000ab	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  000ae	29 85 10 ff ff
	ff		 sub	 DWORD PTR tv466[ebp], eax
$LL136@hmac_gosth:

; 285  : 		buf[i] = (char) (k[i] ^ 0x36);

  000b4	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR tv466[ebp]
  000ba	8d 44 0d dc	 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  000be	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  000c1	80 f2 36	 xor	 dl, 54			; 00000036H
  000c4	41		 inc	 ecx
  000c5	3b ce		 cmp	 ecx, esi
  000c7	88 10		 mov	 BYTE PTR [eax], dl
  000c9	7c e9		 jl	 SHORT $LL136@hmac_gosth
$LN35@hmac_gosth:

; 286  : 	for (i = lk; i < GOSTHASH_BLOCKSIZE; ++i)

  000cb	3b f7		 cmp	 esi, edi
  000cd	7d 14		 jge	 SHORT $LN34@hmac_gosth
  000cf	8b cf		 mov	 ecx, edi
  000d1	2b ce		 sub	 ecx, esi
  000d3	51		 push	 ecx
  000d4	8d 44 35 dc	 lea	 eax, DWORD PTR _buf$[ebp+esi]
  000d8	6a 36		 push	 54			; 00000036H
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 _memset
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@hmac_gosth:

; 287  : 		buf[i] = 0x36;
; 288  : 
; 289  : 	GOSTHASH_add ((unsigned char *) buf, GOSTHASH_BLOCKSIZE, &ctx);

  000e3	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  000e9	50		 push	 eax
  000ea	57		 push	 edi
  000eb	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _GOSTHASH_add@12

; 290  : 	GOSTHASH_add ((unsigned char *) d, ld, &ctx);

  000f4	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  000fa	50		 push	 eax
  000fb	ff 75 14	 push	 DWORD PTR _ld$[ebp]
  000fe	ff b5 0c ff ff
	ff		 push	 DWORD PTR _d$GSCopy$[ebp]
  00104	e8 00 00 00 00	 call	 _GOSTHASH_add@12

; 291  : 
; 292  : 	GOSTHASH_finalize (&ctx, (unsigned char *) inner);

  00109	8d 45 bc	 lea	 eax, DWORD PTR _inner$[ebp]
  0010c	50		 push	 eax
  0010d	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _GOSTHASH_finalize@8

; 293  : 
; 294  : 	/**** Outer Digest ****/
; 295  : 	
; 296  : 	GOSTHASH_init (&ctx);

  00119	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 _GOSTHASH_init@4

; 297  : 
; 298  : 	for (i = 0; i < lk; ++i)

  00125	33 c9		 xor	 ecx, ecx
  00127	85 f6		 test	 esi, esi
  00129	7e 16		 jle	 SHORT $LN29@hmac_gosth
  0012b	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  0012e	2b d8		 sub	 ebx, eax
$LL31@hmac_gosth:

; 299  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00130	8d 44 0d dc	 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  00134	8a 14 03	 mov	 dl, BYTE PTR [ebx+eax]
  00137	80 f2 5c	 xor	 dl, 92			; 0000005cH
  0013a	41		 inc	 ecx
  0013b	3b ce		 cmp	 ecx, esi
  0013d	88 10		 mov	 BYTE PTR [eax], dl
  0013f	7c ef		 jl	 SHORT $LL31@hmac_gosth
$LN29@hmac_gosth:

; 300  : 	for (i = lk; i < GOSTHASH_BLOCKSIZE; ++i)

  00141	3b f7		 cmp	 esi, edi
  00143	7d 14		 jge	 SHORT $LN28@hmac_gosth
  00145	8b cf		 mov	 ecx, edi
  00147	2b ce		 sub	 ecx, esi
  00149	51		 push	 ecx
  0014a	8d 44 35 dc	 lea	 eax, DWORD PTR _buf$[ebp+esi]
  0014e	6a 5c		 push	 92			; 0000005cH
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _memset
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@hmac_gosth:

; 301  : 		buf[i] = 0x5C;
; 302  : 
; 303  : 	GOSTHASH_add ((unsigned char *) buf, GOSTHASH_BLOCKSIZE, &ctx);

  00159	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0015f	50		 push	 eax
  00160	57		 push	 edi
  00161	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _GOSTHASH_add@12

; 304  : 	GOSTHASH_add ((unsigned char *) inner, GOSTHASH_DIGESTSIZE, &ctx);

  0016a	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00170	50		 push	 eax
  00171	57		 push	 edi
  00172	8d 45 bc	 lea	 eax, DWORD PTR _inner$[ebp]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _GOSTHASH_add@12

; 305  : 
; 306  : 	GOSTHASH_finalize (&ctx, (unsigned char *) out);

  0017b	ff b5 08 ff ff
	ff		 push	 DWORD PTR _out$GSCopy$[ebp]
  00181	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 _GOSTHASH_finalize@8

; 307  : 
; 308  : 	/* Prevent possible leaks. */
; 309  : 	burn (&ctx, sizeof(ctx));

  0018d	6a 68		 push	 104			; 00000068H
  0018f	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  00195	5e		 pop	 esi
  00196	8b d6		 mov	 edx, esi
  00198	8b c1		 mov	 eax, ecx
$LL51@hmac_gosth:
  0019a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0019d	40		 inc	 eax
  0019e	4e		 dec	 esi
  0019f	75 f9		 jne	 SHORT $LL51@hmac_gosth
$LL22@hmac_gosth:
  001a1	4a		 dec	 edx
  001a2	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001a5	41		 inc	 ecx
  001a6	85 d2		 test	 edx, edx
  001a8	75 f7		 jne	 SHORT $LL22@hmac_gosth

; 310  : 	burn (outer, sizeof(outer));

  001aa	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _outer$[ebp]
  001b0	8b d7		 mov	 edx, edi
  001b2	8b f7		 mov	 esi, edi
  001b4	8b c1		 mov	 eax, ecx
$LL55@hmac_gosth:
  001b6	c6 00 00	 mov	 BYTE PTR [eax], 0
  001b9	40		 inc	 eax
  001ba	4e		 dec	 esi
  001bb	75 f9		 jne	 SHORT $LL55@hmac_gosth
$LL17@hmac_gosth:
  001bd	4a		 dec	 edx
  001be	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001c1	41		 inc	 ecx
  001c2	85 d2		 test	 edx, edx
  001c4	75 f7		 jne	 SHORT $LL17@hmac_gosth

; 311  : 	burn (inner, sizeof(inner));

  001c6	8d 4d bc	 lea	 ecx, DWORD PTR _inner$[ebp]
  001c9	8b d7		 mov	 edx, edi
  001cb	8b f7		 mov	 esi, edi
  001cd	8b c1		 mov	 eax, ecx
$LL59@hmac_gosth:
  001cf	c6 00 00	 mov	 BYTE PTR [eax], 0
  001d2	40		 inc	 eax
  001d3	4e		 dec	 esi
  001d4	75 f9		 jne	 SHORT $LL59@hmac_gosth
$LL12@hmac_gosth:
  001d6	4a		 dec	 edx
  001d7	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001da	41		 inc	 ecx
  001db	85 d2		 test	 edx, edx
  001dd	75 f7		 jne	 SHORT $LL12@hmac_gosth

; 312  : 	burn (buf, sizeof(buf));

  001df	8d 4d dc	 lea	 ecx, DWORD PTR _buf$[ebp]
  001e2	8b d7		 mov	 edx, edi
  001e4	8b f7		 mov	 esi, edi
  001e6	8b c1		 mov	 eax, ecx
$LL63@hmac_gosth:
  001e8	c6 00 00	 mov	 BYTE PTR [eax], 0
  001eb	40		 inc	 eax
  001ec	4e		 dec	 esi
  001ed	75 f9		 jne	 SHORT $LL63@hmac_gosth
$LL7@hmac_gosth:
  001ef	4a		 dec	 edx
  001f0	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001f3	41		 inc	 ecx
  001f4	85 d2		 test	 edx, edx
  001f6	75 f7		 jne	 SHORT $LL7@hmac_gosth

; 313  : 	burn (key, sizeof(key));

  001f8	8d 4d 9c	 lea	 ecx, DWORD PTR _key$[ebp]
  001fb	8b d7		 mov	 edx, edi
  001fd	8b c1		 mov	 eax, ecx
$LL67@hmac_gosth:
  001ff	c6 00 00	 mov	 BYTE PTR [eax], 0
  00202	40		 inc	 eax
  00203	4f		 dec	 edi
  00204	75 f9		 jne	 SHORT $LL67@hmac_gosth
  00206	5f		 pop	 edi
  00207	5e		 pop	 esi
  00208	5b		 pop	 ebx
$LL2@hmac_gosth:
  00209	4a		 dec	 edx
  0020a	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0020d	41		 inc	 ecx
  0020e	85 d2		 test	 edx, edx
  00210	75 f7		 jne	 SHORT $LL2@hmac_gosth

; 314  : }

  00212	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00215	33 cd		 xor	 ecx, ebp
  00217	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021c	c9		 leave
  0021d	c2 14 00	 ret	 20			; 00000014H
_hmac_gosthash@20 ENDP
_TEXT	ENDS
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_gosthash@28
; Function compile flags: /Ogsp
;	COMDAT _derive_u_gosthash@28
_TEXT	SEGMENT
_pwd$GSCopy$ = -204					; size = 4
_counter$ = -200					; size = 4
_init$ = -196						; size = 128
_k$ = -68						; size = 32
_j$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_gosthash@28 PROC				; COMDAT

; 331  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  0001b	53		 push	 ebx
  0001c	8b 5d 1c	 mov	 ebx, DWORD PTR _u$[ebp]
  0001f	56		 push	 esi
  00020	8b 75 14	 mov	 esi, DWORD PTR _salt_len$[ebp]
  00023	57		 push	 edi

; 332  : 	char j[GOSTHASH_DIGESTSIZE], k[GOSTHASH_DIGESTSIZE];
; 333  : 	char init[128];
; 334  : 	char counter[4];
; 335  : 	int c, i;
; 336  : 
; 337  : 	/* iteration 1 */
; 338  : 	memset (counter, 0, 4);
; 339  : 	counter[3] = (char) b;
; 340  : 	memcpy (init, salt, salt_len);	/* salt */
; 341  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 342  : 	hmac_gosthash (pwd, pwd_len, init, salt_len + 4, j);
; 343  : 	memcpy (u, j, GOSTHASH_DIGESTSIZE);
; 344  : 
; 345  : 	/* remaining iterations */
; 346  : 	for (c = 1; c < iterations; c++)

  00024	89 85 34 ff ff
	ff		 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0002a	33 c0		 xor	 eax, eax
  0002c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR _counter$[ebp]
  00032	ab		 stosd
  00033	8a 45 20	 mov	 al, BYTE PTR _b$[ebp]
  00036	56		 push	 esi
  00037	88 85 3b ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], al
  0003d	51		 push	 ecx
  0003e	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memcpy
  0004a	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	89 84 35 3c ff
	ff ff		 mov	 DWORD PTR _init$[ebp+esi], eax
  0005a	8d 45 dc	 lea	 eax, DWORD PTR _j$[ebp]
  0005d	50		 push	 eax
  0005e	83 c6 04	 add	 esi, 4
  00061	56		 push	 esi
  00062	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00068	50		 push	 eax
  00069	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0006c	ff b5 34 ff ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00072	e8 00 00 00 00	 call	 _hmac_gosthash@20
  00077	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0007a	83 f8 01	 cmp	 eax, 1
  0007d	6a 08		 push	 8
  0007f	59		 pop	 ecx
  00080	8d 75 dc	 lea	 esi, DWORD PTR _j$[ebp]
  00083	8b fb		 mov	 edi, ebx
  00085	6a 20		 push	 32			; 00000020H
  00087	f3 a5		 rep movsd
  00089	5e		 pop	 esi
  0008a	7e 38		 jle	 SHORT $LN10@derive_u_g
  0008c	8d 4d bc	 lea	 ecx, DWORD PTR _k$[ebp]
  0008f	2b d9		 sub	 ebx, ecx
  00091	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
$LL16@derive_u_g:

; 347  : 	{
; 348  : 		hmac_gosthash (pwd, pwd_len, j, GOSTHASH_DIGESTSIZE, k);

  00094	8d 45 bc	 lea	 eax, DWORD PTR _k$[ebp]
  00097	50		 push	 eax
  00098	56		 push	 esi
  00099	8d 45 dc	 lea	 eax, DWORD PTR _j$[ebp]
  0009c	50		 push	 eax
  0009d	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000a0	ff b5 34 ff ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000a6	e8 00 00 00 00	 call	 _hmac_gosthash@20

; 349  : 		for (i = 0; i < GOSTHASH_DIGESTSIZE; i++)

  000ab	33 d2		 xor	 edx, edx
$LL13@derive_u_g:

; 350  : 		{
; 351  : 			u[i] ^= k[i];

  000ad	8d 44 15 bc	 lea	 eax, DWORD PTR _k$[ebp+edx]
  000b1	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  000b4	8a 00		 mov	 al, BYTE PTR [eax]
  000b6	30 01		 xor	 BYTE PTR [ecx], al

; 352  : 			j[i] = k[i];

  000b8	88 44 15 dc	 mov	 BYTE PTR _j$[ebp+edx], al
  000bc	42		 inc	 edx
  000bd	3b d6		 cmp	 edx, esi
  000bf	7c ec		 jl	 SHORT $LL13@derive_u_g

; 332  : 	char j[GOSTHASH_DIGESTSIZE], k[GOSTHASH_DIGESTSIZE];
; 333  : 	char init[128];
; 334  : 	char counter[4];
; 335  : 	int c, i;
; 336  : 
; 337  : 	/* iteration 1 */
; 338  : 	memset (counter, 0, 4);
; 339  : 	counter[3] = (char) b;
; 340  : 	memcpy (init, salt, salt_len);	/* salt */
; 341  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 342  : 	hmac_gosthash (pwd, pwd_len, init, salt_len + 4, j);
; 343  : 	memcpy (u, j, GOSTHASH_DIGESTSIZE);
; 344  : 
; 345  : 	/* remaining iterations */
; 346  : 	for (c = 1; c < iterations; c++)

  000c1	4f		 dec	 edi
  000c2	75 d0		 jne	 SHORT $LL16@derive_u_g
$LN10@derive_u_g:

; 353  : 		}
; 354  : 	}
; 355  : 
; 356  : 	/* Prevent possible leaks. */
; 357  : 	burn (j, sizeof(j));

  000c4	8d 4d dc	 lea	 ecx, DWORD PTR _j$[ebp]
  000c7	8b d6		 mov	 edx, esi
  000c9	8b fe		 mov	 edi, esi
  000cb	8b c1		 mov	 eax, ecx
$LL20@derive_u_g:
  000cd	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d0	40		 inc	 eax
  000d1	4f		 dec	 edi
  000d2	75 f9		 jne	 SHORT $LL20@derive_u_g
$LL7@derive_u_g:
  000d4	4a		 dec	 edx
  000d5	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000d8	41		 inc	 ecx
  000d9	85 d2		 test	 edx, edx
  000db	75 f7		 jne	 SHORT $LL7@derive_u_g

; 358  : 	burn (k, sizeof(k));

  000dd	8d 4d bc	 lea	 ecx, DWORD PTR _k$[ebp]
  000e0	8b d6		 mov	 edx, esi
  000e2	8b c1		 mov	 eax, ecx
$LL24@derive_u_g:
  000e4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e7	40		 inc	 eax
  000e8	4e		 dec	 esi
  000e9	75 f9		 jne	 SHORT $LL24@derive_u_g
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx
$LL2@derive_u_g:
  000ee	4a		 dec	 edx
  000ef	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000f2	41		 inc	 ecx
  000f3	85 d2		 test	 edx, edx
  000f5	75 f7		 jne	 SHORT $LL2@derive_u_g

; 359  : }

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fa	33 cd		 xor	 ecx, ebp
  000fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00101	c9		 leave
  00102	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_gosthash@28 ENDP
_TEXT	ENDS
PUBLIC	_dk$GSCopy$
PUBLIC	_salt$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_gosthash@28
; Function compile flags: /Ogsp
;	COMDAT _derive_key_gosthash@28
_TEXT	SEGMENT
_r$ = -56						; size = 4
_pwd$GSCopy$ = -52					; size = 4
_salt$GSCopy$ = -48					; size = 4
_dk$GSCopy$ = -44					; size = 4
_b$ = -40						; size = 4
_u$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_gosthash@28 PROC				; COMDAT

; 376  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 38	 sub	 esp, 56			; 00000038H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 387  : 	}
; 388  : 
; 389  : 	r = dklen - (l - 1) * GOSTHASH_DIGESTSIZE;

  00012	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00015	8b 4d 20	 mov	 ecx, DWORD PTR _dklen$[ebp]
  00018	89 45 cc	 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0001b	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0001e	89 45 d0	 mov	 DWORD PTR _salt$GSCopy$[ebp], eax
  00021	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  00024	89 45 d4	 mov	 DWORD PTR _dk$GSCopy$[ebp], eax
  00027	8b c1		 mov	 eax, ecx
  00029	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0002e	53		 push	 ebx
  0002f	56		 push	 esi
  00030	79 05		 jns	 SHORT $LN28@derive_key@2
  00032	48		 dec	 eax
  00033	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00036	40		 inc	 eax
$LN28@derive_key@2:
  00037	8b c1		 mov	 eax, ecx
  00039	99		 cdq
  0003a	74 0d		 je	 SHORT $LN10@derive_key@2
  0003c	83 e2 1f	 and	 edx, 31			; 0000001fH
  0003f	03 c2		 add	 eax, edx
  00041	8b d8		 mov	 ebx, eax
  00043	c1 fb 05	 sar	 ebx, 5
  00046	43		 inc	 ebx
  00047	eb 0a		 jmp	 SHORT $LN9@derive_key@2
$LN10@derive_key@2:

; 377  : 	char u[GOSTHASH_DIGESTSIZE];
; 378  : 	int b, l, r;
; 379  : 
; 380  : 	if (dklen % GOSTHASH_DIGESTSIZE)
; 381  : 	{
; 382  : 		l = 1 + dklen / GOSTHASH_DIGESTSIZE;
; 383  : 	}
; 384  : 	else
; 385  : 	{
; 386  : 		l = dklen / GOSTHASH_DIGESTSIZE;

  00049	83 e2 1f	 and	 edx, 31			; 0000001fH
  0004c	03 c2		 add	 eax, edx
  0004e	8b d8		 mov	 ebx, eax
  00050	c1 fb 05	 sar	 ebx, 5
$LN9@derive_key@2:

; 387  : 	}
; 388  : 
; 389  : 	r = dklen - (l - 1) * GOSTHASH_DIGESTSIZE;

  00053	8b c3		 mov	 eax, ebx
  00055	c1 e0 05	 shl	 eax, 5
  00058	2b c8		 sub	 ecx, eax

; 390  : 
; 391  : 	/* first l - 1 blocks */
; 392  : 	for (b = 1; b < l; b++)

  0005a	33 c0		 xor	 eax, eax
  0005c	40		 inc	 eax
  0005d	83 c1 20	 add	 ecx, 32			; 00000020H
  00060	3b d8		 cmp	 ebx, eax
  00062	89 4d c8	 mov	 DWORD PTR _r$[ebp], ecx
  00065	89 45 d8	 mov	 DWORD PTR _b$[ebp], eax
  00068	7e 34		 jle	 SHORT $LN6@derive_key@2
  0006a	57		 push	 edi
$LL26@derive_key@2:

; 393  : 	{
; 394  : 		derive_u_gosthash (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0006b	ff 75 d8	 push	 DWORD PTR _b$[ebp]
  0006e	8d 45 dc	 lea	 eax, DWORD PTR _u$[ebp]
  00071	50		 push	 eax
  00072	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  00075	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  00078	ff 75 d0	 push	 DWORD PTR _salt$GSCopy$[ebp]
  0007b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0007e	ff 75 cc	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00081	e8 00 00 00 00	 call	 _derive_u_gosthash@28

; 395  : 		memcpy (dk, u, GOSTHASH_DIGESTSIZE);

  00086	8b 7d d4	 mov	 edi, DWORD PTR _dk$GSCopy$[ebp]

; 396  : 		dk += GOSTHASH_DIGESTSIZE;

  00089	83 45 d4 20	 add	 DWORD PTR _dk$GSCopy$[ebp], 32 ; 00000020H
  0008d	ff 45 d8	 inc	 DWORD PTR _b$[ebp]
  00090	39 5d d8	 cmp	 DWORD PTR _b$[ebp], ebx
  00093	6a 08		 push	 8
  00095	59		 pop	 ecx
  00096	8d 75 dc	 lea	 esi, DWORD PTR _u$[ebp]
  00099	f3 a5		 rep movsd
  0009b	7c ce		 jl	 SHORT $LL26@derive_key@2
  0009d	5f		 pop	 edi
$LN6@derive_key@2:

; 397  : 	}
; 398  : 
; 399  : 	/* last block */
; 400  : 	derive_u_gosthash (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0009e	ff 75 d8	 push	 DWORD PTR _b$[ebp]
  000a1	8d 45 dc	 lea	 eax, DWORD PTR _u$[ebp]
  000a4	50		 push	 eax
  000a5	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  000a8	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  000ab	ff 75 d0	 push	 DWORD PTR _salt$GSCopy$[ebp]
  000ae	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000b1	ff 75 cc	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000b4	e8 00 00 00 00	 call	 _derive_u_gosthash@28

; 401  : 	memcpy (dk, u, r);

  000b9	ff 75 c8	 push	 DWORD PTR _r$[ebp]
  000bc	8d 45 dc	 lea	 eax, DWORD PTR _u$[ebp]
  000bf	50		 push	 eax
  000c0	ff 75 d4	 push	 DWORD PTR _dk$GSCopy$[ebp]
  000c3	e8 00 00 00 00	 call	 _memcpy
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 402  : 
; 403  : 
; 404  : 	/* Prevent possible leaks. */
; 405  : 	burn (u, sizeof(u));

  000cb	6a 20		 push	 32			; 00000020H
  000cd	8d 4d dc	 lea	 ecx, DWORD PTR _u$[ebp]
  000d0	5e		 pop	 esi
  000d1	8b d6		 mov	 edx, esi
  000d3	8b c1		 mov	 eax, ecx
$LL14@derive_key@2:
  000d5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d8	40		 inc	 eax
  000d9	4e		 dec	 esi
  000da	75 f9		 jne	 SHORT $LL14@derive_key@2
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
$LL2@derive_key@2:
  000de	4a		 dec	 edx
  000df	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000e2	41		 inc	 ecx
  000e3	85 d2		 test	 edx, edx
  000e5	75 f7		 jne	 SHORT $LL2@derive_key@2

; 406  : }

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	c9		 leave
  000f2	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_gosthash@28 ENDP
_TEXT	ENDS
PUBLIC	_out$GSCopy$
PUBLIC	_d$GSCopy$
PUBLIC	_k$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_stribog@20
EXTRN	_STRIBOG_finalize@8:PROC
EXTRN	_STRIBOG_add@12:PROC
EXTRN	_STRIBOG_init@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _hmac_stribog@20
_TEXT	SEGMENT
_d$GSCopy$ = -664					; size = 4
_out$GSCopy$ = -660					; size = 4
_k$GSCopy$ = -656					; size = 4
tv466 = -652						; size = 4
_burnc$25904 = -652					; size = 4
_ctx$ = -648						; size = 385
_outer$ = -260						; size = 64
_key$ = -196						; size = 64
_inner$ = -132						; size = 64
_buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_hmac_stribog@20 PROC					; COMDAT

; 430  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 98 02 00
	00		 sub	 esp, 664		; 00000298H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  00018	53		 push	 ebx
  00019	56		 push	 esi

; 431  : 	STRIBOG_CTX ctx;
; 432  : 	char inner[STRIBOG_DIGESTSIZE], outer[STRIBOG_DIGESTSIZE];
; 433  : 	char key[STRIBOG_DIGESTSIZE];
; 434  : 	char buf[STRIBOG_BLOCKSIZE];
; 435  : 	int32 i;
; 436  : 
; 437  :     /* If the key is longer than the hash algorithm block size,
; 438  : 	   let key = stribog(key), as per HMAC specifications. */
; 439  : 	if (lk > STRIBOG_BLOCKSIZE)

  0001a	8b 75 0c	 mov	 esi, DWORD PTR _lk$[ebp]
  0001d	57		 push	 edi

; 485  : 	burn (key, sizeof(key));

  0001e	89 85 70 fd ff
	ff		 mov	 DWORD PTR _k$GSCopy$[ebp], eax
  00024	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00027	6a 40		 push	 64			; 00000040H
  00029	89 85 68 fd ff
	ff		 mov	 DWORD PTR _d$GSCopy$[ebp], eax
  0002f	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00032	5b		 pop	 ebx
  00033	3b f3		 cmp	 esi, ebx
  00035	89 85 6c fd ff
	ff		 mov	 DWORD PTR _out$GSCopy$[ebp], eax
  0003b	bf 81 01 00 00	 mov	 edi, 385		; 00000181H
  00040	7e 6a		 jle	 SHORT $LN40@hmac_strib
  00042	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _STRIBOG_init@4
  0004e	56		 push	 esi
  0004f	ff b5 70 fd ff
	ff		 push	 DWORD PTR _k$GSCopy$[ebp]
  00055	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _STRIBOG_add@12
  00061	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  00067	50		 push	 eax
  00068	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _STRIBOG_finalize@8
  00074	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  0007a	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  00080	89 85 70 fd ff
	ff		 mov	 DWORD PTR _k$GSCopy$[ebp], eax
  00086	8b f3		 mov	 esi, ebx
  00088	89 bd 74 fd ff
	ff		 mov	 DWORD PTR _burnc$25904[ebp], edi
  0008e	8b d7		 mov	 edx, edi
  00090	8b c1		 mov	 eax, ecx
$LL47@hmac_strib:
  00092	c6 00 00	 mov	 BYTE PTR [eax], 0
  00095	40		 inc	 eax
  00096	4a		 dec	 edx
  00097	75 f9		 jne	 SHORT $LL47@hmac_strib
$LL39@hmac_strib:

; 440  : 	{
; 441  : 		STRIBOG_init (&ctx);
; 442  : 		STRIBOG_add (&ctx, (unsigned char *)k, lk);
; 443  : 		STRIBOG_finalize (&ctx, (unsigned char *) key);
; 444  : 
; 445  : 		k = key;
; 446  : 		lk = STRIBOG_DIGESTSIZE;
; 447  : 
; 448  : 		burn (&ctx, sizeof(ctx));		// Prevent leaks

  00099	ff 8d 74 fd ff
	ff		 dec	 DWORD PTR _burnc$25904[ebp]
  0009f	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000a2	41		 inc	 ecx
  000a3	83 bd 74 fd ff
	ff 00		 cmp	 DWORD PTR _burnc$25904[ebp], 0
  000aa	75 ed		 jne	 SHORT $LL39@hmac_strib
$LN40@hmac_strib:

; 449  : 	}
; 450  : 
; 451  : 	/**** Inner Digest ****/
; 452  : 
; 453  : 	STRIBOG_init (&ctx);

  000ac	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _STRIBOG_init@4

; 454  : 
; 455  : 	/* Pad the key for inner digest */
; 456  : 	for (i = 0; i < lk; ++i)

  000b8	33 c9		 xor	 ecx, ecx
  000ba	85 f6		 test	 esi, esi
  000bc	7e 2a		 jle	 SHORT $LN35@hmac_strib
  000be	8b 95 70 fd ff
	ff		 mov	 edx, DWORD PTR _k$GSCopy$[ebp]
  000c4	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  000c7	2b d0		 sub	 edx, eax
  000c9	89 95 74 fd ff
	ff		 mov	 DWORD PTR tv466[ebp], edx
  000cf	eb 06		 jmp	 SHORT $LN37@hmac_strib
$LL137@hmac_strib:
  000d1	8b 95 74 fd ff
	ff		 mov	 edx, DWORD PTR tv466[ebp]
$LN37@hmac_strib:

; 457  : 		buf[i] = (char) (k[i] ^ 0x36);

  000d7	8d 44 0d bc	 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  000db	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  000de	80 f2 36	 xor	 dl, 54			; 00000036H
  000e1	41		 inc	 ecx
  000e2	3b ce		 cmp	 ecx, esi
  000e4	88 10		 mov	 BYTE PTR [eax], dl
  000e6	7c e9		 jl	 SHORT $LL137@hmac_strib
$LN35@hmac_strib:

; 458  : 	for (i = lk; i < STRIBOG_BLOCKSIZE; ++i)

  000e8	3b f3		 cmp	 esi, ebx
  000ea	7d 14		 jge	 SHORT $LN34@hmac_strib
  000ec	8b cb		 mov	 ecx, ebx
  000ee	2b ce		 sub	 ecx, esi
  000f0	51		 push	 ecx
  000f1	8d 44 35 bc	 lea	 eax, DWORD PTR _buf$[ebp+esi]
  000f5	6a 36		 push	 54			; 00000036H
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _memset
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@hmac_strib:

; 459  : 		buf[i] = 0x36;
; 460  : 
; 461  : 	STRIBOG_add (&ctx, (unsigned char *) buf, STRIBOG_BLOCKSIZE);

  00100	53		 push	 ebx
  00101	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  00104	50		 push	 eax
  00105	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _STRIBOG_add@12

; 462  : 	STRIBOG_add (&ctx, (unsigned char *) d, ld);

  00111	ff 75 14	 push	 DWORD PTR _ld$[ebp]
  00114	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0011a	ff b5 68 fd ff
	ff		 push	 DWORD PTR _d$GSCopy$[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 _STRIBOG_add@12

; 463  : 
; 464  : 	STRIBOG_finalize (&ctx, (unsigned char *) inner);

  00126	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _inner$[ebp]
  0012c	50		 push	 eax
  0012d	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _STRIBOG_finalize@8

; 465  : 
; 466  : 	/**** Outer Digest ****/
; 467  : 	
; 468  : 	STRIBOG_init (&ctx);

  00139	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _STRIBOG_init@4

; 469  : 
; 470  : 	for (i = 0; i < lk; ++i)

  00145	33 c9		 xor	 ecx, ecx
  00147	85 f6		 test	 esi, esi
  00149	7e 2a		 jle	 SHORT $LN29@hmac_strib
  0014b	8b 95 70 fd ff
	ff		 mov	 edx, DWORD PTR _k$GSCopy$[ebp]
  00151	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  00154	2b d0		 sub	 edx, eax
  00156	89 95 74 fd ff
	ff		 mov	 DWORD PTR tv466[ebp], edx
  0015c	eb 06		 jmp	 SHORT $LN31@hmac_strib
$LL136@hmac_strib:
  0015e	8b 95 74 fd ff
	ff		 mov	 edx, DWORD PTR tv466[ebp]
$LN31@hmac_strib:

; 471  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00164	8d 44 0d bc	 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  00168	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  0016b	80 f2 5c	 xor	 dl, 92			; 0000005cH
  0016e	41		 inc	 ecx
  0016f	3b ce		 cmp	 ecx, esi
  00171	88 10		 mov	 BYTE PTR [eax], dl
  00173	7c e9		 jl	 SHORT $LL136@hmac_strib
$LN29@hmac_strib:

; 472  : 	for (i = lk; i < STRIBOG_BLOCKSIZE; ++i)

  00175	3b f3		 cmp	 esi, ebx
  00177	7d 14		 jge	 SHORT $LN28@hmac_strib
  00179	8b cb		 mov	 ecx, ebx
  0017b	2b ce		 sub	 ecx, esi
  0017d	51		 push	 ecx
  0017e	8d 44 35 bc	 lea	 eax, DWORD PTR _buf$[ebp+esi]
  00182	6a 5c		 push	 92			; 0000005cH
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _memset
  0018a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@hmac_strib:

; 473  : 		buf[i] = 0x5C;
; 474  : 
; 475  : 	STRIBOG_add (&ctx, (unsigned char *) buf, STRIBOG_BLOCKSIZE);

  0018d	53		 push	 ebx
  0018e	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  00191	50		 push	 eax
  00192	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _STRIBOG_add@12

; 476  : 	STRIBOG_add (&ctx, (unsigned char *) inner, STRIBOG_DIGESTSIZE);

  0019e	53		 push	 ebx
  0019f	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _inner$[ebp]
  001a5	50		 push	 eax
  001a6	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  001ac	50		 push	 eax
  001ad	e8 00 00 00 00	 call	 _STRIBOG_add@12

; 477  : 
; 478  : 	STRIBOG_finalize (&ctx, (unsigned char *) out);

  001b2	ff b5 6c fd ff
	ff		 push	 DWORD PTR _out$GSCopy$[ebp]
  001b8	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 _STRIBOG_finalize@8

; 479  : 
; 480  : 	/* Prevent possible leaks. */
; 481  : 	burn (&ctx, sizeof(ctx));

  001c4	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  001ca	8b d7		 mov	 edx, edi
  001cc	8b c1		 mov	 eax, ecx
$LL51@hmac_strib:
  001ce	c6 00 00	 mov	 BYTE PTR [eax], 0
  001d1	40		 inc	 eax
  001d2	4f		 dec	 edi
  001d3	75 f9		 jne	 SHORT $LL51@hmac_strib
$LL22@hmac_strib:
  001d5	4a		 dec	 edx
  001d6	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001d9	41		 inc	 ecx
  001da	85 d2		 test	 edx, edx
  001dc	75 f7		 jne	 SHORT $LL22@hmac_strib

; 482  : 	burn (outer, sizeof(outer));

  001de	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _outer$[ebp]
  001e4	8b d3		 mov	 edx, ebx
  001e6	8b f3		 mov	 esi, ebx
  001e8	8b c1		 mov	 eax, ecx
$LL55@hmac_strib:
  001ea	c6 00 00	 mov	 BYTE PTR [eax], 0
  001ed	40		 inc	 eax
  001ee	4e		 dec	 esi
  001ef	75 f9		 jne	 SHORT $LL55@hmac_strib
$LL17@hmac_strib:
  001f1	4a		 dec	 edx
  001f2	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001f5	41		 inc	 ecx
  001f6	85 d2		 test	 edx, edx
  001f8	75 f7		 jne	 SHORT $LL17@hmac_strib

; 483  : 	burn (inner, sizeof(inner));

  001fa	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _inner$[ebp]
  00200	8b d3		 mov	 edx, ebx
  00202	8b f3		 mov	 esi, ebx
  00204	8b c1		 mov	 eax, ecx
$LL59@hmac_strib:
  00206	c6 00 00	 mov	 BYTE PTR [eax], 0
  00209	40		 inc	 eax
  0020a	4e		 dec	 esi
  0020b	75 f9		 jne	 SHORT $LL59@hmac_strib
$LL12@hmac_strib:
  0020d	4a		 dec	 edx
  0020e	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00211	41		 inc	 ecx
  00212	85 d2		 test	 edx, edx
  00214	75 f7		 jne	 SHORT $LL12@hmac_strib

; 484  : 	burn (buf, sizeof(buf));

  00216	8d 4d bc	 lea	 ecx, DWORD PTR _buf$[ebp]
  00219	8b d3		 mov	 edx, ebx
  0021b	8b f3		 mov	 esi, ebx
  0021d	8b c1		 mov	 eax, ecx
$LL63@hmac_strib:
  0021f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00222	40		 inc	 eax
  00223	4e		 dec	 esi
  00224	75 f9		 jne	 SHORT $LL63@hmac_strib
$LL7@hmac_strib:
  00226	4a		 dec	 edx
  00227	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0022a	41		 inc	 ecx
  0022b	85 d2		 test	 edx, edx
  0022d	75 f7		 jne	 SHORT $LL7@hmac_strib

; 485  : 	burn (key, sizeof(key));

  0022f	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  00235	8b d3		 mov	 edx, ebx
  00237	8b c1		 mov	 eax, ecx
$LL67@hmac_strib:
  00239	c6 00 00	 mov	 BYTE PTR [eax], 0
  0023c	40		 inc	 eax
  0023d	4b		 dec	 ebx
  0023e	75 f9		 jne	 SHORT $LL67@hmac_strib
  00240	5f		 pop	 edi
  00241	5e		 pop	 esi
  00242	5b		 pop	 ebx
$LL2@hmac_strib:
  00243	4a		 dec	 edx
  00244	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00247	41		 inc	 ecx
  00248	85 d2		 test	 edx, edx
  0024a	75 f7		 jne	 SHORT $LL2@hmac_strib

; 486  : }

  0024c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024f	33 cd		 xor	 ecx, ebp
  00251	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00256	c9		 leave
  00257	c2 14 00	 ret	 20			; 00000014H
_hmac_stribog@20 ENDP
_TEXT	ENDS
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_stribog@28
; Function compile flags: /Ogsp
;	COMDAT _derive_u_stribog@28
_TEXT	SEGMENT
_pwd$GSCopy$ = -268					; size = 4
_counter$ = -264					; size = 4
_init$ = -260						; size = 128
_k$ = -132						; size = 64
_j$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_stribog@28 PROC				; COMDAT

; 503  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  0001b	53		 push	 ebx
  0001c	8b 5d 1c	 mov	 ebx, DWORD PTR _u$[ebp]
  0001f	56		 push	 esi
  00020	8b 75 14	 mov	 esi, DWORD PTR _salt_len$[ebp]
  00023	57		 push	 edi

; 504  : 	char j[STRIBOG_DIGESTSIZE], k[STRIBOG_DIGESTSIZE];
; 505  : 	char init[128];
; 506  : 	char counter[4];
; 507  : 	int c, i;
; 508  : 
; 509  : 	/* iteration 1 */
; 510  : 	memset (counter, 0, 4);
; 511  : 	counter[3] = (char) b;
; 512  : 	memcpy (init, salt, salt_len);	/* salt */
; 513  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 514  : 	hmac_stribog (pwd, pwd_len, init, salt_len + 4, j);
; 515  : 	memcpy (u, j, STRIBOG_DIGESTSIZE);
; 516  : 
; 517  : 	/* remaining iterations */
; 518  : 	for (c = 1; c < iterations; c++)

  00024	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0002a	33 c0		 xor	 eax, eax
  0002c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _counter$[ebp]
  00032	ab		 stosd
  00033	8a 45 20	 mov	 al, BYTE PTR _b$[ebp]
  00036	56		 push	 esi
  00037	88 85 fb fe ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], al
  0003d	51		 push	 ecx
  0003e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memcpy
  0004a	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	89 84 35 fc fe
	ff ff		 mov	 DWORD PTR _init$[ebp+esi], eax
  0005a	8d 45 bc	 lea	 eax, DWORD PTR _j$[ebp]
  0005d	50		 push	 eax
  0005e	83 c6 04	 add	 esi, 4
  00061	56		 push	 esi
  00062	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00068	50		 push	 eax
  00069	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0006c	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00072	e8 00 00 00 00	 call	 _hmac_stribog@20
  00077	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0007a	83 f8 01	 cmp	 eax, 1
  0007d	6a 10		 push	 16			; 00000010H
  0007f	59		 pop	 ecx
  00080	8d 75 bc	 lea	 esi, DWORD PTR _j$[ebp]
  00083	8b fb		 mov	 edi, ebx
  00085	6a 40		 push	 64			; 00000040H
  00087	f3 a5		 rep movsd
  00089	5e		 pop	 esi
  0008a	7e 41		 jle	 SHORT $LN10@derive_u_s
  0008c	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  00092	2b d9		 sub	 ebx, ecx
  00094	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
$LL16@derive_u_s:

; 519  : 	{
; 520  : 		hmac_stribog (pwd, pwd_len, j, STRIBOG_DIGESTSIZE, k);

  00097	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  0009d	50		 push	 eax
  0009e	56		 push	 esi
  0009f	8d 45 bc	 lea	 eax, DWORD PTR _j$[ebp]
  000a2	50		 push	 eax
  000a3	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000a6	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000ac	e8 00 00 00 00	 call	 _hmac_stribog@20

; 521  : 		for (i = 0; i < STRIBOG_DIGESTSIZE; i++)

  000b1	33 d2		 xor	 edx, edx
$LL13@derive_u_s:

; 522  : 		{
; 523  : 			u[i] ^= k[i];

  000b3	8d 84 15 7c ff
	ff ff		 lea	 eax, DWORD PTR _k$[ebp+edx]
  000ba	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  000bd	8a 00		 mov	 al, BYTE PTR [eax]
  000bf	30 01		 xor	 BYTE PTR [ecx], al

; 524  : 			j[i] = k[i];

  000c1	88 44 15 bc	 mov	 BYTE PTR _j$[ebp+edx], al
  000c5	42		 inc	 edx
  000c6	3b d6		 cmp	 edx, esi
  000c8	7c e9		 jl	 SHORT $LL13@derive_u_s

; 504  : 	char j[STRIBOG_DIGESTSIZE], k[STRIBOG_DIGESTSIZE];
; 505  : 	char init[128];
; 506  : 	char counter[4];
; 507  : 	int c, i;
; 508  : 
; 509  : 	/* iteration 1 */
; 510  : 	memset (counter, 0, 4);
; 511  : 	counter[3] = (char) b;
; 512  : 	memcpy (init, salt, salt_len);	/* salt */
; 513  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 514  : 	hmac_stribog (pwd, pwd_len, init, salt_len + 4, j);
; 515  : 	memcpy (u, j, STRIBOG_DIGESTSIZE);
; 516  : 
; 517  : 	/* remaining iterations */
; 518  : 	for (c = 1; c < iterations; c++)

  000ca	4f		 dec	 edi
  000cb	75 ca		 jne	 SHORT $LL16@derive_u_s
$LN10@derive_u_s:

; 525  : 		}
; 526  : 	}
; 527  : 
; 528  : 	/* Prevent possible leaks. */
; 529  : 	burn (j, sizeof(j));

  000cd	8d 4d bc	 lea	 ecx, DWORD PTR _j$[ebp]
  000d0	8b d6		 mov	 edx, esi
  000d2	8b fe		 mov	 edi, esi
  000d4	8b c1		 mov	 eax, ecx
$LL20@derive_u_s:
  000d6	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d9	40		 inc	 eax
  000da	4f		 dec	 edi
  000db	75 f9		 jne	 SHORT $LL20@derive_u_s
$LL7@derive_u_s:
  000dd	4a		 dec	 edx
  000de	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000e1	41		 inc	 ecx
  000e2	85 d2		 test	 edx, edx
  000e4	75 f7		 jne	 SHORT $LL7@derive_u_s

; 530  : 	burn (k, sizeof(k));

  000e6	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  000ec	8b d6		 mov	 edx, esi
  000ee	8b c1		 mov	 eax, ecx
$LL24@derive_u_s:
  000f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  000f3	40		 inc	 eax
  000f4	4e		 dec	 esi
  000f5	75 f9		 jne	 SHORT $LL24@derive_u_s
  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
$LL2@derive_u_s:
  000fa	4a		 dec	 edx
  000fb	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000fe	41		 inc	 ecx
  000ff	85 d2		 test	 edx, edx
  00101	75 f7		 jne	 SHORT $LL2@derive_u_s

; 531  : }

  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	c9		 leave
  0010e	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_stribog@28 ENDP
_TEXT	ENDS
PUBLIC	_dk$GSCopy$
PUBLIC	_salt$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_stribog@28
; Function compile flags: /Ogsp
;	COMDAT _derive_key_stribog@28
_TEXT	SEGMENT
_r$ = -88						; size = 4
_pwd$GSCopy$ = -84					; size = 4
_salt$GSCopy$ = -80					; size = 4
_dk$GSCopy$ = -76					; size = 4
_b$ = -72						; size = 4
_u$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_stribog@28 PROC				; COMDAT

; 548  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 58	 sub	 esp, 88			; 00000058H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 559  : 	}
; 560  : 
; 561  : 	r = dklen - (l - 1) * STRIBOG_DIGESTSIZE;

  00012	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00015	8b 4d 20	 mov	 ecx, DWORD PTR _dklen$[ebp]
  00018	89 45 ac	 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0001b	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0001e	89 45 b0	 mov	 DWORD PTR _salt$GSCopy$[ebp], eax
  00021	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  00024	89 45 b4	 mov	 DWORD PTR _dk$GSCopy$[ebp], eax
  00027	8b c1		 mov	 eax, ecx
  00029	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0002e	53		 push	 ebx
  0002f	56		 push	 esi
  00030	79 05		 jns	 SHORT $LN28@derive_key@3
  00032	48		 dec	 eax
  00033	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00036	40		 inc	 eax
$LN28@derive_key@3:
  00037	8b c1		 mov	 eax, ecx
  00039	99		 cdq
  0003a	74 0d		 je	 SHORT $LN10@derive_key@3
  0003c	83 e2 3f	 and	 edx, 63			; 0000003fH
  0003f	03 c2		 add	 eax, edx
  00041	8b d8		 mov	 ebx, eax
  00043	c1 fb 06	 sar	 ebx, 6
  00046	43		 inc	 ebx
  00047	eb 0a		 jmp	 SHORT $LN9@derive_key@3
$LN10@derive_key@3:

; 549  : 	char u[STRIBOG_DIGESTSIZE];
; 550  : 	int b, l, r;
; 551  : 
; 552  : 	if (dklen % STRIBOG_DIGESTSIZE)
; 553  : 	{
; 554  : 		l = 1 + dklen / STRIBOG_DIGESTSIZE;
; 555  : 	}
; 556  : 	else
; 557  : 	{
; 558  : 		l = dklen / STRIBOG_DIGESTSIZE;

  00049	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004c	03 c2		 add	 eax, edx
  0004e	8b d8		 mov	 ebx, eax
  00050	c1 fb 06	 sar	 ebx, 6
$LN9@derive_key@3:

; 559  : 	}
; 560  : 
; 561  : 	r = dklen - (l - 1) * STRIBOG_DIGESTSIZE;

  00053	8b c3		 mov	 eax, ebx
  00055	c1 e0 06	 shl	 eax, 6
  00058	2b c8		 sub	 ecx, eax

; 562  : 
; 563  : 	/* first l - 1 blocks */
; 564  : 	for (b = 1; b < l; b++)

  0005a	33 c0		 xor	 eax, eax
  0005c	40		 inc	 eax
  0005d	83 c1 40	 add	 ecx, 64			; 00000040H
  00060	3b d8		 cmp	 ebx, eax
  00062	89 4d a8	 mov	 DWORD PTR _r$[ebp], ecx
  00065	89 45 b8	 mov	 DWORD PTR _b$[ebp], eax
  00068	7e 34		 jle	 SHORT $LN6@derive_key@3
  0006a	57		 push	 edi
$LL26@derive_key@3:

; 565  : 	{
; 566  : 		derive_u_stribog (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0006b	ff 75 b8	 push	 DWORD PTR _b$[ebp]
  0006e	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  00071	50		 push	 eax
  00072	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  00075	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  00078	ff 75 b0	 push	 DWORD PTR _salt$GSCopy$[ebp]
  0007b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0007e	ff 75 ac	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00081	e8 00 00 00 00	 call	 _derive_u_stribog@28

; 567  : 		memcpy (dk, u, STRIBOG_DIGESTSIZE);

  00086	8b 7d b4	 mov	 edi, DWORD PTR _dk$GSCopy$[ebp]

; 568  : 		dk += STRIBOG_DIGESTSIZE;

  00089	83 45 b4 40	 add	 DWORD PTR _dk$GSCopy$[ebp], 64 ; 00000040H
  0008d	ff 45 b8	 inc	 DWORD PTR _b$[ebp]
  00090	39 5d b8	 cmp	 DWORD PTR _b$[ebp], ebx
  00093	6a 10		 push	 16			; 00000010H
  00095	59		 pop	 ecx
  00096	8d 75 bc	 lea	 esi, DWORD PTR _u$[ebp]
  00099	f3 a5		 rep movsd
  0009b	7c ce		 jl	 SHORT $LL26@derive_key@3
  0009d	5f		 pop	 edi
$LN6@derive_key@3:

; 569  : 	}
; 570  : 
; 571  : 	/* last block */
; 572  : 	derive_u_stribog (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0009e	ff 75 b8	 push	 DWORD PTR _b$[ebp]
  000a1	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  000a4	50		 push	 eax
  000a5	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  000a8	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  000ab	ff 75 b0	 push	 DWORD PTR _salt$GSCopy$[ebp]
  000ae	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000b1	ff 75 ac	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000b4	e8 00 00 00 00	 call	 _derive_u_stribog@28

; 573  : 	memcpy (dk, u, r);

  000b9	ff 75 a8	 push	 DWORD PTR _r$[ebp]
  000bc	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  000bf	50		 push	 eax
  000c0	ff 75 b4	 push	 DWORD PTR _dk$GSCopy$[ebp]
  000c3	e8 00 00 00 00	 call	 _memcpy
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 574  : 
; 575  : 
; 576  : 	/* Prevent possible leaks. */
; 577  : 	burn (u, sizeof(u));

  000cb	6a 40		 push	 64			; 00000040H
  000cd	8d 4d bc	 lea	 ecx, DWORD PTR _u$[ebp]
  000d0	5e		 pop	 esi
  000d1	8b d6		 mov	 edx, esi
  000d3	8b c1		 mov	 eax, ecx
$LL14@derive_key@3:
  000d5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d8	40		 inc	 eax
  000d9	4e		 dec	 esi
  000da	75 f9		 jne	 SHORT $LL14@derive_key@3
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
$LL2@derive_key@3:
  000de	4a		 dec	 edx
  000df	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000e2	41		 inc	 ecx
  000e3	85 d2		 test	 edx, edx
  000e5	75 f7		 jne	 SHORT $LL2@derive_key@3

; 578  : }

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	c9		 leave
  000f2	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_stribog@28 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_get_pkcs5_prf_name@4
;	COMDAT ??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@ DB 'HMAC-GOS'
	DB	'T R 34.11-2012', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@ DB 'HMAC-GOST '
	DB	'R 34.11-94', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@ DB 'HMAC-Whirlpool', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@ DB '(Unknown)', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _get_pkcs5_prf_name@4
_TEXT	SEGMENT
_pkcs5_prf_id$ = 8					; size = 4
_get_pkcs5_prf_name@4 PROC				; COMDAT

; 592  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 593  : 	switch (pkcs5_prf_id)

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkcs5_prf_id$[ebp]
  00008	48		 dec	 eax
  00009	74 1b		 je	 SHORT $LN3@get_pkcs5_
  0000b	48		 dec	 eax
  0000c	74 11		 je	 SHORT $LN2@get_pkcs5_
  0000e	48		 dec	 eax
  0000f	74 07		 je	 SHORT $LN4@get_pkcs5_

; 601  : 	default:		
; 602  : 		return "(Unknown)";

  00011	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
  00016	eb 13		 jmp	 SHORT $LN5@get_pkcs5_
$LN4@get_pkcs5_:

; 594  : 	{
; 595  : 	case WHIRLPOOL:	
; 596  : 		return "HMAC-Whirlpool";

  00018	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
  0001d	eb 0c		 jmp	 SHORT $LN5@get_pkcs5_
$LN2@get_pkcs5_:

; 599  : 	case GOSTHASH:
; 600  : 		return "HMAC-GOST R 34.11-94";

  0001f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@
  00024	eb 05		 jmp	 SHORT $LN5@get_pkcs5_
$LN3@get_pkcs5_:

; 597  : 	case STRIBOG:
; 598  : 		return "HMAC-GOST R 34.11-2012";

  00026	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@
$LN5@get_pkcs5_:

; 603  : 	}
; 604  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
_get_pkcs5_prf_name@4 ENDP
_TEXT	ENDS
PUBLIC	_get_pkcs5_iteration_count@8
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _get_pkcs5_iteration_count@8
_TEXT	SEGMENT
_pkcs5_prf_id$ = 8					; size = 4
_bBoot$ = 12						; size = 4
_get_pkcs5_iteration_count@8 PROC			; COMDAT

; 617  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 618  : 	switch (pkcs5_prf_id)

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkcs5_prf_id$[ebp]
  00008	48		 dec	 eax
  00009	74 1c		 je	 SHORT $LN3@get_pkcs5_@2
  0000b	48		 dec	 eax
  0000c	74 19		 je	 SHORT $LN3@get_pkcs5_@2
  0000e	48		 dec	 eax
  0000f	74 16		 je	 SHORT $LN3@get_pkcs5_@2

; 624  : 	case GOSTHASH:
; 625  : 		return 1000;
; 626  : 	default:		
; 627  : 		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00011	68 54 53 47 00	 push	 4674388			; 00475354H
  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	68 73 02 00 00	 push	 627			; 00000273H
  0001f	6a 29		 push	 41			; 00000029H
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN10@get_pkcs5_@2:
$LN3@get_pkcs5_@2:

; 619  : 	{
; 620  : 	case WHIRLPOOL:	
; 621  : 		return 1000;
; 622  : 	case STRIBOG:
; 623  : 		return 1000;

  00027	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H

; 628  : 	}
; 629  : 	return 0;
; 630  : }

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
$LN9@get_pkcs5_@2:
_get_pkcs5_iteration_count@8 ENDP
_TEXT	ENDS
END
