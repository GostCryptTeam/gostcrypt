; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ReadVolumeHeaderRecoveryMode
_BSS	SEGMENT
_ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField16@8
EXTRN	_MirrorBytes16@4:PROC
; Function compile flags: /Ogsp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _GetHeaderField16@8
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField16@8 PROC				; COMDAT

; 148  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 149  : 	return BE16 (*(uint16 *) (header + offset));

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _header$[ebp]
  00008	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0000b	0f b7 04 01	 movzx	 eax, WORD PTR [ecx+eax]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _MirrorBytes16@4

; 150  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_GetHeaderField16@8 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField32@8
EXTRN	_MirrorBytes32@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetHeaderField32@8
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField32@8 PROC				; COMDAT

; 163  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 164  : 	return BE32 (*(uint32 *) (header + offset));

  00005	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _header$[ebp]
  0000b	ff 34 01	 push	 DWORD PTR [ecx+eax]
  0000e	e8 00 00 00 00	 call	 _MirrorBytes32@4

; 165  : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
_GetHeaderField32@8 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField64@8
EXTRN	_MirrorBytes64@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetHeaderField64@8
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField64@8 PROC				; COMDAT

; 178  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 179  : 	UINT64_STRUCT uint64Struct;
; 180  : 
; 181  : #ifndef GST_NO_COMPILER_INT64
; 182  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  00005	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  0000b	ff 74 08 04	 push	 DWORD PTR [eax+ecx+4]
  0000f	ff 34 08	 push	 DWORD PTR [eax+ecx]
  00012	e8 00 00 00 00	 call	 _MirrorBytes64@8

; 183  : #else
; 184  : 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; 185  : 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; 186  : #endif
; 187  : 	return uint64Struct;
; 188  : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
_GetHeaderField64@8 ENDP
_TEXT	ENDS
PUBLIC	_retHeaderCryptoInfo$GSCopy$
PUBLIC	_retInfo$GSCopy$
PUBLIC	_encryptedHeader$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ReadVolumeHeader@20
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	_crypto_close@4:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_EAGetNext@4:PROC
EXTRN	_GetCrc32@8:PROC
EXTRN	_DecryptBuffer@16:PROC
EXTRN	_EAInitMode@4:PROC
EXTRN	_EAGetKeySize@4:PROC
EXTRN	_EAInit@12:PROC
EXTRN	_CipherGetBlockSize@4:PROC
EXTRN	_EAGetFirstCipher@4:PROC
EXTRN	_EAIsModeSupported@8:PROC
EXTRN	_EAGetFirst@0:PROC
EXTRN	_derive_key_stribog@28:PROC
EXTRN	_derive_key_gosthash@28:PROC
EXTRN	_derive_key_whirlpool@28:PROC
EXTRN	_GetMaxPkcs5OutSize@0:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	_EncryptionThreadPoolBeginKeyDerivation@40:PROC
EXTRN	_get_pkcs5_iteration_count@8:PROC
EXTRN	_crypto_loadkey@12:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	_crypto_open@0:PROC
EXTRN	_GetEncryptionThreadCount@0:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT _ReadVolumeHeader@20
_TEXT	SEGMENT
_keyDerivationCompletedEvent$ = -1236			; size = 16
_noOutstandingWorkItemEvent$ = -1220			; size = 16
_outstandingWorkItemCount$ = -1204			; size = 4
_retInfo$GSCopy$ = -1200				; size = 4
_encryptedHeader$GSCopy$ = -1196			; size = 4
_retHeaderCryptoInfo$GSCopy$ = -1192			; size = 4
_encryptionThreadCount$ = -1188				; size = 4
_pkcs5_prf$ = -1184					; size = 4
_keyDerivationWorkItems$ = -1180			; size = 4
_queuedWorkItems$ = -1176				; size = 4
_enqPkcs5Prf$ = -1172					; size = 4
_item$ = -1168						; size = 4
_status$ = -1168					; size = 4
_keyInfo$ = -1164					; size = 392
_dk$ = -772						; size = 256
_header$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_encryptedHeader$ = 12					; size = 4
_password$ = 16						; size = 4
_retInfo$ = 20						; size = 4
_retHeaderCryptoInfo$ = 24				; size = 4
_ReadVolumeHeader@20 PROC				; COMDAT

; 227  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR _encryptedHeader$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 18	 mov	 ebx, DWORD PTR _retHeaderCryptoInfo$[ebp]
  0001c	56		 push	 esi
  0001d	8b 75 14	 mov	 esi, DWORD PTR _retInfo$[ebp]
  00020	57		 push	 edi
  00021	8b 7d 10	 mov	 edi, DWORD PTR _password$[ebp]

; 228  : 	char header[GST_VOLUME_HEADER_EFFECTIVE_SIZE];
; 229  : 	KEY_INFO keyInfo;
; 230  : 	PCRYPTO_INFO cryptoInfo;
; 231  : 	char dk[MASTER_KEYDATA_SIZE];
; 232  : 	int enqPkcs5Prf, pkcs5_prf;
; 233  : 	uint16 headerVersion;
; 234  : 	int status = ERR_PARAMETER_INCORRECT;
; 235  : 	int primaryKeyOffset;
; 236  : 
; 237  : 	GST_EVENT keyDerivationCompletedEvent;
; 238  : 	GST_EVENT noOutstandingWorkItemEvent;
; 239  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 240  : 	KeyDerivationWorkItem *item;
; 241  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;
; 242  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  00024	89 85 54 fb ff
	ff		 mov	 DWORD PTR _encryptedHeader$GSCopy$[ebp], eax
  0002a	89 b5 50 fb ff
	ff		 mov	 DWORD PTR _retInfo$GSCopy$[ebp], esi
  00030	89 9d 58 fb ff
	ff		 mov	 DWORD PTR _retHeaderCryptoInfo$GSCopy$[ebp], ebx
  00036	e8 00 00 00 00	 call	 _GetEncryptionThreadCount@0

; 243  : 	size_t queuedWorkItems = 0;

  0003b	83 a5 68 fb ff
	ff 00		 and	 DWORD PTR _queuedWorkItems$[ebp], 0

; 244  : 	LONG outstandingWorkItemCount = 0;

  00042	83 a5 4c fb ff
	ff 00		 and	 DWORD PTR _outstandingWorkItemCount$[ebp], 0
  00049	89 85 5c fb ff
	ff		 mov	 DWORD PTR _encryptionThreadCount$[ebp], eax

; 245  : 	int i;
; 246  : 
; 247  : 	if (retHeaderCryptoInfo != NULL)

  0004f	85 db		 test	 ebx, ebx

; 248  : 	{
; 249  : 		cryptoInfo = retHeaderCryptoInfo;
; 250  : 	}
; 251  : 	else

  00051	75 15		 jne	 SHORT $LN82@ReadVolume

; 252  : 	{
; 253  : 		cryptoInfo = *retInfo = crypto_open ();

  00053	e8 00 00 00 00	 call	 _crypto_open@0
  00058	8b d8		 mov	 ebx, eax
  0005a	89 06		 mov	 DWORD PTR [esi], eax

; 254  : 		if (cryptoInfo == NULL)

  0005c	85 db		 test	 ebx, ebx
  0005e	75 08		 jne	 SHORT $LN82@ReadVolume
$LN156@ReadVolume:

; 255  : 			return ERR_OUTOFMEMORY;

  00060	6a 02		 push	 2
  00062	58		 pop	 eax
  00063	e9 81 07 00 00	 jmp	 $LN85@ReadVolume
$LN82@ReadVolume:

; 256  : 	}
; 257  : 
; 258  : 	if (encryptionThreadCount > 1)

  00068	33 f6		 xor	 esi, esi
  0006a	46		 inc	 esi
  0006b	39 b5 5c fb ff
	ff		 cmp	 DWORD PTR _encryptionThreadCount$[ebp], esi
  00071	76 4d		 jbe	 SHORT $LN146@ReadVolume

; 259  : 	{
; 260  : 		keyDerivationWorkItems = GSTalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00073	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00078	68 24 03 00 00	 push	 804			; 00000324H
  0007d	6a 00		 push	 0
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00085	89 85 64 fb ff
	ff		 mov	 DWORD PTR _keyDerivationWorkItems$[ebp], eax

; 261  : 		if (!keyDerivationWorkItems)

  0008b	85 c0		 test	 eax, eax

; 262  : 			return ERR_OUTOFMEMORY;

  0008d	74 d1		 je	 SHORT $LN156@ReadVolume

; 263  : 
; 264  : 		for (i = 0; i < pkcs5PrfCount; ++i)

  0008f	6a 03		 push	 3
  00091	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00096	59		 pop	 ecx
$LL79@ReadVolume:

; 265  : 			keyDerivationWorkItems[i].Free = TRUE;

  00097	89 30		 mov	 DWORD PTR [eax], esi
  00099	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  0009e	49		 dec	 ecx
  0009f	75 f6		 jne	 SHORT $LL79@ReadVolume

; 266  : 
; 267  : #ifdef DEVICE_DRIVER
; 268  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);

  000a1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__KeInitializeEvent@12
  000a7	51		 push	 ecx
  000a8	6a 01		 push	 1
  000aa	8d 85 2c fb ff
	ff		 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  000b0	50		 push	 eax
  000b1	ff d6		 call	 esi

; 269  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);

  000b3	6a 01		 push	 1
  000b5	6a 01		 push	 1
  000b7	8d 85 3c fb ff
	ff		 lea	 eax, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  000bd	50		 push	 eax
  000be	ff d6		 call	 esi
$LN146@ReadVolume:

; 270  : #else
; 271  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 272  : 		if (!keyDerivationCompletedEvent)
; 273  : 		{
; 274  : 			GSTfree (keyDerivationWorkItems);
; 275  : 			return ERR_OUTOFMEMORY;
; 276  : 		}
; 277  : 
; 278  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);
; 279  : 		if (!noOutstandingWorkItemEvent)
; 280  : 		{
; 281  : 			CloseHandle (keyDerivationCompletedEvent);
; 282  : 			GSTfree (keyDerivationWorkItems);
; 283  : 			return ERR_OUTOFMEMORY;
; 284  : 		}
; 285  : #endif
; 286  : 	}
; 287  : 		
; 288  : #ifndef DEVICE_DRIVER
; 289  : 	VirtualLock (&keyInfo, sizeof (keyInfo));
; 290  : 	VirtualLock (&dk, sizeof (dk));
; 291  : #endif
; 292  : 
; 293  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  000c0	ff 37		 push	 DWORD PTR [edi]
  000c2	83 c7 04	 add	 edi, 4
  000c5	57		 push	 edi
  000c6	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _crypto_loadkey@12

; 294  : 
; 295  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 296  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  000d2	8b b5 54 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$[ebp]
  000d8	6a 10		 push	 16			; 00000010H
  000da	59		 pop	 ecx
  000db	8d bd bc fb ff
	ff		 lea	 edi, DWORD PTR _keyInfo$[ebp+72]
  000e1	f3 a5		 rep movsd

; 297  : 
; 298  : 	// Test all available PKCS5 PRFs
; 299  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  000e3	c7 85 6c fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _enqPkcs5Prf$[ebp], 1
  000ed	33 ff		 xor	 edi, edi
$LL76@ReadVolume:
  000ef	6a 03		 push	 3
  000f1	5a		 pop	 edx
  000f2	39 95 6c fb ff
	ff		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], edx
  000f8	7e 0c		 jle	 SHORT $LN150@ReadVolume
  000fa	39 bd 68 fb ff
	ff		 cmp	 DWORD PTR _queuedWorkItems$[ebp], edi
  00100	0f 86 cc 03 00
	00		 jbe	 $LN74@ReadVolume
$LN150@ReadVolume:

; 300  : 	{
; 301  : 
; 302  : 		if (encryptionThreadCount > 1)

  00106	8b 85 5c fb ff
	ff		 mov	 eax, DWORD PTR _encryptionThreadCount$[ebp]
  0010c	83 f8 01	 cmp	 eax, 1
  0010f	0f 86 4c 01 00
	00		 jbe	 $LN72@ReadVolume

; 303  : 		{
; 304  : 			// Enqueue key derivation on thread pool
; 305  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  00115	39 85 68 fb ff
	ff		 cmp	 DWORD PTR _queuedWorkItems$[ebp], eax
  0011b	0f 83 97 00 00
	00		 jae	 $LN71@ReadVolume
  00121	39 95 6c fb ff
	ff		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], edx
  00127	0f 8f 8b 00 00
	00		 jg	 $LN71@ReadVolume

; 306  : 			{
; 307  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  0012d	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$[ebp]
  00133	33 c9		 xor	 ecx, ecx
$LL70@ReadVolume:

; 308  : 				{
; 309  : 					item = &keyDerivationWorkItems[i];
; 310  : 					if (item->Free)

  00135	39 b8 00 01 00
	00		 cmp	 DWORD PTR [eax+256], edi
  0013b	75 0c		 jne	 SHORT $LN115@ReadVolume
  0013d	41		 inc	 ecx
  0013e	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  00143	3b ca		 cmp	 ecx, edx
  00145	7c ee		 jl	 SHORT $LL70@ReadVolume

; 435  : 				
; 436  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  00147	eb 60		 jmp	 SHORT $LN68@ReadVolume
$LN115@ReadVolume:

; 311  : 					{
; 312  : 						item->Free = FALSE;
; 313  : 						item->KeyReady = FALSE;
; 314  : 						item->Pkcs5Prf = enqPkcs5Prf;

  00149	8b 8d 6c fb ff
	ff		 mov	 ecx, DWORD PTR _enqPkcs5Prf$[ebp]

; 315  : 
; 316  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 317  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 318  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  0014f	50		 push	 eax
  00150	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  00153	8d b0 04 01 00
	00		 lea	 esi, DWORD PTR [eax+260]
  00159	51		 push	 ecx
  0015a	89 b8 00 01 00
	00		 mov	 DWORD PTR [eax+256], edi
  00160	89 3e		 mov	 DWORD PTR [esi], edi
  00162	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx
  00168	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8
  0016d	50		 push	 eax
  0016e	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  00174	50		 push	 eax
  00175	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  0017b	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00181	50		 push	 eax
  00182	ff b5 6c fb ff
	ff		 push	 DWORD PTR _enqPkcs5Prf$[ebp]
  00188	8d 85 4c fb ff
	ff		 lea	 eax, DWORD PTR _outstandingWorkItemCount$[ebp]
  0018e	50		 push	 eax
  0018f	56		 push	 esi
  00190	8d 85 3c fb ff
	ff		 lea	 eax, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  00196	50		 push	 eax
  00197	8d 85 2c fb ff
	ff		 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 _EncryptionThreadPoolBeginKeyDerivation@40

; 319  : 						
; 320  : 						++queuedWorkItems;

  001a3	ff 85 68 fb ff
	ff		 inc	 DWORD PTR _queuedWorkItems$[ebp]
$LN68@ReadVolume:

; 321  : 						break;
; 322  : 					}
; 323  : 				}
; 324  : 
; 325  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  001a9	83 bd 6c fb ff
	ff 03		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], 3
  001b0	0f 8c 11 03 00
	00		 jl	 $LN75@ReadVolume

; 326  : 					continue;
; 327  : 			}
; 328  : 			else

  001b6	eb 06		 jmp	 SHORT $LN105@ReadVolume
$LN71@ReadVolume:

; 329  : 				--enqPkcs5Prf;

  001b8	ff 8d 6c fb ff
	ff		 dec	 DWORD PTR _enqPkcs5Prf$[ebp]
$LN105@ReadVolume:

; 330  : 
; 331  : 			// Wait for completion of a key derivation
; 332  : 			while (queuedWorkItems > 0)

  001be	39 bd 68 fb ff
	ff		 cmp	 DWORD PTR _queuedWorkItems$[ebp], edi
  001c4	0f 86 fd 02 00
	00		 jbe	 $LN75@ReadVolume
  001ca	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _keyDerivationWorkItems$[ebp]
  001d0	81 c6 04 01 00
	00		 add	 esi, 260		; 00000104H
$LL64@ReadVolume:

; 333  : 			{
; 334  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  001d6	33 c9		 xor	 ecx, ecx
  001d8	8b c6		 mov	 eax, esi
$LL62@ReadVolume:

; 335  : 				{
; 336  : 					item = &keyDerivationWorkItems[i];

  001da	8d 90 fc fe ff
	ff		 lea	 edx, DWORD PTR [eax-260]
  001e0	89 95 70 fb ff
	ff		 mov	 DWORD PTR _item$[ebp], edx

; 337  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  001e6	39 78 fc	 cmp	 DWORD PTR [eax-4], edi
  001e9	75 0f		 jne	 SHORT $LN61@ReadVolume
  001eb	33 d2		 xor	 edx, edx
  001ed	8b f8		 mov	 edi, eax
  001ef	f0 0f c1 17	 lock	  xadd	 DWORD PTR [edi], edx
  001f3	83 fa 01	 cmp	 edx, 1
  001f6	74 20		 je	 SHORT $LN116@ReadVolume
  001f8	33 ff		 xor	 edi, edi
$LN61@ReadVolume:

; 333  : 			{
; 334  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  001fa	41		 inc	 ecx
  001fb	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  00200	83 f9 03	 cmp	 ecx, 3
  00203	7c d5		 jl	 SHORT $LL62@ReadVolume

; 345  : 						goto KeyReady;
; 346  : 					}
; 347  : 				}
; 348  : 
; 349  : 				if (queuedWorkItems > 0)
; 350  : 					GST_WAIT_EVENT (keyDerivationCompletedEvent);

  00205	57		 push	 edi
  00206	57		 push	 edi
  00207	57		 push	 edi
  00208	57		 push	 edi
  00209	8d 85 2c fb ff
	ff		 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  0020f	50		 push	 eax
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00216	eb be		 jmp	 SHORT $LL64@ReadVolume
$LN116@ReadVolume:

; 338  : 					{
; 339  : 						pkcs5_prf = item->Pkcs5Prf;

  00218	8b b5 70 fb ff
	ff		 mov	 esi, DWORD PTR _item$[ebp]
  0021e	8b 86 08 01 00
	00		 mov	 eax, DWORD PTR [esi+264]

; 340  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  00224	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  00227	89 85 60 fb ff
	ff		 mov	 DWORD PTR _pkcs5_prf$[ebp], eax
  0022d	50		 push	 eax
  0022e	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8

; 341  : 						memcpy (dk, item->DerivedKey, sizeof (dk));
; 342  : 
; 343  : 						item->Free = TRUE;
; 344  : 						--queuedWorkItems;

  00233	ff 8d 68 fb ff
	ff		 dec	 DWORD PTR _queuedWorkItems$[ebp]
  00239	89 85 74 fb ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax
  0023f	8b 85 70 fb ff
	ff		 mov	 eax, DWORD PTR _item$[ebp]
  00245	6a 40		 push	 64			; 00000040H
  00247	59		 pop	 ecx
  00248	8d bd fc fc ff
	ff		 lea	 edi, DWORD PTR _dk$[ebp]
  0024e	f3 a5		 rep movsd
  00250	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+256], 1
$KeyReady$26674:

; 351  : 			}
; 352  : 			continue;
; 353  : KeyReady:	;
; 354  : 		}
; 355  : 		else

  0025a	33 ff		 xor	 edi, edi
  0025c	e9 b8 00 00 00	 jmp	 $LN55@ReadVolume
$LN72@ReadVolume:

; 356  : 		{
; 357  : 			pkcs5_prf = enqPkcs5Prf;
; 358  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  00261	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  00264	8b b5 6c fb ff
	ff		 mov	 esi, DWORD PTR _enqPkcs5Prf$[ebp]
  0026a	56		 push	 esi
  0026b	89 b5 60 fb ff
	ff		 mov	 DWORD PTR _pkcs5_prf$[ebp], esi
  00271	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8
  00276	89 85 74 fb ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax

; 359  : 
; 360  : 			switch (pkcs5_prf)

  0027c	8b c6		 mov	 eax, esi
  0027e	48		 dec	 eax
  0027f	74 6a		 je	 SHORT $LN53@ReadVolume
  00281	48		 dec	 eax
  00282	74 37		 je	 SHORT $LN52@ReadVolume
  00284	48		 dec	 eax
  00285	0f 85 52 02 00
	00		 jne	 $LN51@ReadVolume

; 361  : 			{
; 362  : 			case WHIRLPOOL:
; 363  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 364  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  0028b	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  00290	50		 push	 eax
  00291	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  00297	50		 push	 eax
  00298	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  0029e	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  002a4	6a 40		 push	 64			; 00000040H
  002a6	50		 push	 eax
  002a7	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  002ad	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  002b3	50		 push	 eax
  002b4	e8 00 00 00 00	 call	 _derive_key_whirlpool@28

; 365  : 				break;

  002b9	eb 5e		 jmp	 SHORT $LN55@ReadVolume
$LN52@ReadVolume:

; 369  : 				break;
; 370  : 			case GOSTHASH:
; 371  : 				derive_key_gosthash (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 372  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  002bb	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  002c0	50		 push	 eax
  002c1	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  002c7	50		 push	 eax
  002c8	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  002ce	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  002d4	6a 40		 push	 64			; 00000040H
  002d6	50		 push	 eax
  002d7	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  002dd	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 _derive_key_gosthash@28

; 373  : 				break;

  002e9	eb 2e		 jmp	 SHORT $LN55@ReadVolume
$LN53@ReadVolume:

; 366  : 			case STRIBOG:
; 367  : 				derive_key_stribog (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 368  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  002eb	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  002f0	50		 push	 eax
  002f1	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  002f7	50		 push	 eax
  002f8	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  002fe	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  00304	6a 40		 push	 64			; 00000040H
  00306	50		 push	 eax
  00307	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  0030d	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00313	50		 push	 eax
  00314	e8 00 00 00 00	 call	 _derive_key_stribog@28
$LN55@ReadVolume:

; 377  : 			} 
; 378  : 		}
; 379  : 
; 380  : 		// Test all available modes of operation
; 381  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; 382  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 383  : 			cryptoInfo->mode++)

  00319	c7 43 04 01 00
	00 00		 mov	 DWORD PTR [ebx+4], 1
$LL50@ReadVolume:

; 384  : 		{
; 385  : 			switch (cryptoInfo->mode)
; 386  : 			{
; 387  : 			default:
; 388  : 				primaryKeyOffset = 0;
; 389  : 			}
; 390  : 
; 391  : 			// Test all available encryption algorithms
; 392  : 			for (cryptoInfo->ea = EAGetFirst ();
; 393  : 				cryptoInfo->ea != 0;
; 394  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  00320	e8 00 00 00 00	 call	 _EAGetFirst@0
  00325	e9 86 01 00 00	 jmp	 $LN155@ReadVolume
$LL147@ReadVolume:

; 395  : 			{
; 396  : 				int blockSize;
; 397  : 
; 398  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  0032a	ff 73 04	 push	 DWORD PTR [ebx+4]
  0032d	ff 33		 push	 DWORD PTR [ebx]
  0032f	e8 00 00 00 00	 call	 _EAIsModeSupported@8
  00334	85 c0		 test	 eax, eax
  00336	0f 84 6b 01 00
	00		 je	 $LN43@ReadVolume

; 399  : 					continue;	// This encryption algorithm has never been available with this mode of operation
; 400  : 
; 401  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));

  0033c	ff 33		 push	 DWORD PTR [ebx]
  0033e	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00343	50		 push	 eax
  00344	e8 00 00 00 00	 call	 _CipherGetBlockSize@4

; 402  : 
; 403  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  00349	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  0034c	50		 push	 eax
  0034d	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  00353	50		 push	 eax
  00354	ff 33		 push	 DWORD PTR [ebx]
  00356	e8 00 00 00 00	 call	 _EAInit@12
  0035b	89 85 70 fb ff
	ff		 mov	 DWORD PTR _status$[ebp], eax

; 404  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00361	83 f8 11	 cmp	 eax, 17			; 00000011H
  00364	0f 84 d8 03 00
	00		 je	 $err$26701

; 405  : 					goto err;
; 406  : 
; 407  : 				// Init objects related to the mode of operation
; 408  : 
; 409  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  0036a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0036d	83 f8 01	 cmp	 eax, 1
  00370	74 05		 je	 SHORT $LN38@ReadVolume
  00372	83 f8 02	 cmp	 eax, 2
  00375	75 34		 jne	 SHORT $LN37@ReadVolume
$LN38@ReadVolume:

; 410  : 				{
; 411  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 412  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00377	ff 33		 push	 DWORD PTR [ebx]
  00379	e8 00 00 00 00	 call	 _EAGetKeySize@4
  0037e	50		 push	 eax
  0037f	ff 33		 push	 DWORD PTR [ebx]
  00381	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00386	8d 84 05 fc fc
	ff ff		 lea	 eax, DWORD PTR _dk$[ebp+eax]
  0038d	50		 push	 eax
  0038e	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  00394	50		 push	 eax
  00395	e8 00 00 00 00	 call	 _memcpy
  0039a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 413  : 
; 414  : 					// Secondary key schedule
; 415  : 					if (!EAInitMode (cryptoInfo))

  0039d	53		 push	 ebx
  0039e	e8 00 00 00 00	 call	 _EAInitMode@4
  003a3	85 c0		 test	 eax, eax
  003a5	0f 84 46 01 00
	00		 je	 $LN118@ReadVolume
$LN37@ReadVolume:

; 419  : 					}
; 420  : 				}
; 421  : 
; 422  : 				// Copy the header for decryption
; 423  : 				memcpy (header, encryptedHeader, sizeof (header));

  003ab	8b b5 54 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$[ebp]
  003b1	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  003b6	8d bd fc fd ff
	ff		 lea	 edi, DWORD PTR _header$[ebp]
  003bc	f3 a5		 rep movsd

; 424  : 
; 425  : 				// Try to decrypt header 
; 426  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  003be	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  003c1	83 f8 01	 cmp	 eax, 1
  003c4	74 05		 je	 SHORT $LN35@ReadVolume
  003c6	83 f8 02	 cmp	 eax, 2
  003c9	75 14		 jne	 SHORT $LN36@ReadVolume
$LN35@ReadVolume:

; 427  : 					DecryptBuffer(header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  003cb	53		 push	 ebx
  003cc	6a 00		 push	 0
  003ce	68 c0 01 00 00	 push	 448			; 000001c0H
  003d3	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+64]
  003d9	50		 push	 eax
  003da	e8 00 00 00 00	 call	 _DecryptBuffer@16
$LN36@ReadVolume:

; 428  : 
; 429  : 				// Magic 'TRUE'
; 430  : 				if (GetHeaderField32 (header, GST_HEADER_OFFSET_MAGIC) != 0x54525545)

  003df	6a 40		 push	 64			; 00000040H
  003e1	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  003e7	50		 push	 eax
  003e8	e8 00 00 00 00	 call	 _GetHeaderField32@8
  003ed	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  003f2	0f 85 af 00 00
	00		 jne	 $LN43@ReadVolume

; 431  : 					continue;
; 432  : 
; 433  : 				// Header version
; 434  : 				headerVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_VERSION);

  003f8	6a 44		 push	 68			; 00000044H
  003fa	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00400	50		 push	 eax
  00401	e8 00 00 00 00	 call	 _GetHeaderField16@8
  00406	0f b7 f0	 movzx	 esi, ax

; 435  : 				
; 436  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  00409	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  0040e	66 3b f0	 cmp	 si, ax
  00411	0f 87 e9 00 00
	00		 ja	 $LN119@ReadVolume

; 440  : 				}
; 441  : 
; 442  : 				// Check CRC of the header fields
; 443  : 				if (!ReadVolumeHeaderRecoveryMode
; 444  : 					&& headerVersion >= 4
; 445  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC))

  00417	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  0041e	75 2e		 jne	 SHORT $LN32@ReadVolume
  00420	66 83 fe 04	 cmp	 si, 4
  00424	72 28		 jb	 SHORT $LN32@ReadVolume
  00426	68 bc 00 00 00	 push	 188			; 000000bcH
  0042b	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+64]
  00431	50		 push	 eax
  00432	e8 00 00 00 00	 call	 _GetCrc32@8
  00437	8b f8		 mov	 edi, eax
  00439	68 fc 00 00 00	 push	 252			; 000000fcH
  0043e	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00444	50		 push	 eax
  00445	e8 00 00 00 00	 call	 _GetHeaderField32@8
  0044a	3b c7		 cmp	 eax, edi
  0044c	75 59		 jne	 SHORT $LN43@ReadVolume
$LN32@ReadVolume:

; 446  : 					continue;
; 447  : 
; 448  : 				// Required program version
; 449  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_REQUIRED_VERSION);

  0044e	6a 46		 push	 70			; 00000046H
  00450	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00456	50		 push	 eax
  00457	e8 00 00 00 00	 call	 _GetHeaderField16@8

; 450  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  0045c	b9 00 06 00 00	 mov	 ecx, 1536		; 00000600H
  00461	66 3b c1	 cmp	 ax, cx
  00464	66 89 83 e0 1e
	00 00		 mov	 WORD PTR [ebx+7904], ax
  0046b	1b c0		 sbb	 eax, eax
  0046d	f7 d8		 neg	 eax
  0046f	89 83 e4 1e 00
	00		 mov	 DWORD PTR [ebx+7908], eax

; 451  : 
; 452  : 				// Check CRC of the key set
; 453  : 				if (!ReadVolumeHeaderRecoveryMode
; 454  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  00475	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  0047c	0f 85 8d 00 00
	00		 jne	 $LN148@ReadVolume
  00482	68 00 01 00 00	 push	 256			; 00000100H
  00487	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+256]
  0048d	50		 push	 eax
  0048e	e8 00 00 00 00	 call	 _GetCrc32@8
  00493	8b f8		 mov	 edi, eax
  00495	6a 48		 push	 72			; 00000048H
  00497	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0049d	50		 push	 eax
  0049e	e8 00 00 00 00	 call	 _GetHeaderField32@8
  004a3	3b c7		 cmp	 eax, edi
  004a5	74 68		 je	 SHORT $LN148@ReadVolume
$LN43@ReadVolume:

; 384  : 		{
; 385  : 			switch (cryptoInfo->mode)
; 386  : 			{
; 387  : 			default:
; 388  : 				primaryKeyOffset = 0;
; 389  : 			}
; 390  : 
; 391  : 			// Test all available encryption algorithms
; 392  : 			for (cryptoInfo->ea = EAGetFirst ();
; 393  : 				cryptoInfo->ea != 0;
; 394  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  004a7	ff 33		 push	 DWORD PTR [ebx]
  004a9	e8 00 00 00 00	 call	 _EAGetNext@4
  004ae	33 ff		 xor	 edi, edi
$LN155@ReadVolume:
  004b0	89 03		 mov	 DWORD PTR [ebx], eax
  004b2	3b c7		 cmp	 eax, edi
  004b4	0f 85 70 fe ff
	ff		 jne	 $LL147@ReadVolume
  004ba	ff 43 04	 inc	 DWORD PTR [ebx+4]
  004bd	83 7b 04 02	 cmp	 DWORD PTR [ebx+4], 2
  004c1	0f 8e 59 fe ff
	ff		 jle	 $LL50@ReadVolume
$LN75@ReadVolume:

; 297  : 
; 298  : 	// Test all available PKCS5 PRFs
; 299  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  004c7	ff 85 6c fb ff
	ff		 inc	 DWORD PTR _enqPkcs5Prf$[ebp]
  004cd	e9 1d fc ff ff	 jmp	 $LL76@ReadVolume
$LN74@ReadVolume:

; 555  : 			}
; 556  : 		}
; 557  : 	}
; 558  : 	status = ERR_PASSWORD_WRONG;

  004d2	89 95 70 fb ff
	ff		 mov	 DWORD PTR _status$[ebp], edx
  004d8	e9 65 02 00 00	 jmp	 $err$26701
$LN51@ReadVolume:

; 374  : 			default:		
; 375  : 				// Unknown/wrong ID
; 376  : 				GST_THROW_FATAL_EXCEPTION;

  004dd	68 54 53 47 00	 push	 4674388			; 00475354H
  004e2	57		 push	 edi
  004e3	57		 push	 edi
  004e4	68 78 01 00 00	 push	 376			; 00000178H
  004e9	6a 29		 push	 41			; 00000029H
  004eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN157@ReadVolume:
$LN118@ReadVolume:

; 416  : 					{
; 417  : 						status = ERR_MODE_INIT_FAILED;

  004f1	c7 85 70 fb ff
	ff 1b 00 00 00	 mov	 DWORD PTR _status$[ebp], 27 ; 0000001bH

; 418  : 						goto err;

  004fb	e9 42 02 00 00	 jmp	 $err$26701
$LN119@ReadVolume:

; 437  : 				{
; 438  : 					status = ERR_NEW_VERSION_REQUIRED;

  00500	c7 85 70 fb ff
	ff 10 00 00 00	 mov	 DWORD PTR _status$[ebp], 16 ; 00000010H

; 439  : 					goto err;

  0050a	e9 33 02 00 00	 jmp	 $err$26701
$LN148@ReadVolume:

; 455  : 					continue;
; 456  : 
; 457  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 458  : 
; 459  : 				// Check the version required to handle this volume
; 460  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  0050f	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  00514	66 39 83 e0 1e
	00 00		 cmp	 WORD PTR [ebx+7904], ax

; 461  : 				{
; 462  : 					status = ERR_NEW_VERSION_REQUIRED;
; 463  : 					goto err;

  0051b	77 e3		 ja	 SHORT $LN119@ReadVolume

; 464  : 				}
; 465  : 
; 466  : 				// Header version
; 467  : 				cryptoInfo->HeaderVersion = headerVersion;
; 468  : 
; 469  : 				// Volume creation time (legacy)
; 470  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  0051d	6a 4c		 push	 76			; 0000004cH
  0051f	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00525	50		 push	 eax
  00526	66 89 b3 4c 04
	00 00		 mov	 WORD PTR [ebx+1100], si
  0052d	e8 00 00 00 00	 call	 _GetHeaderField64@8
  00532	89 83 98 1e 00
	00		 mov	 DWORD PTR [ebx+7832], eax

; 471  : 
; 472  : 				// Header creation time (legacy)
; 473  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_MODIFICATION_TIME).Value;

  00538	6a 54		 push	 84			; 00000054H
  0053a	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00540	50		 push	 eax
  00541	89 93 9c 1e 00
	00		 mov	 DWORD PTR [ebx+7836], edx
  00547	e8 00 00 00 00	 call	 _GetHeaderField64@8
  0054c	89 83 a0 1e 00
	00		 mov	 DWORD PTR [ebx+7840], eax

; 474  : 
; 475  : 				// Hidden volume size (if any)
; 476  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  00552	6a 5c		 push	 92			; 0000005cH
  00554	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0055a	50		 push	 eax
  0055b	89 93 a4 1e 00
	00		 mov	 DWORD PTR [ebx+7844], edx
  00561	e8 00 00 00 00	 call	 _GetHeaderField64@8
  00566	89 83 b8 1e 00
	00		 mov	 DWORD PTR [ebx+7864], eax

; 477  : 
; 478  : 				// Hidden volume status
; 479  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  0056c	0b c2		 or	 eax, edx
  0056e	89 93 bc 1e 00
	00		 mov	 DWORD PTR [ebx+7868], edx
  00574	74 05		 je	 SHORT $LN87@ReadVolume
  00576	33 c0		 xor	 eax, eax
  00578	40		 inc	 eax
  00579	eb 02		 jmp	 SHORT $LN88@ReadVolume
$LN87@ReadVolume:
  0057b	33 c0		 xor	 eax, eax
$LN88@ReadVolume:
  0057d	89 83 48 04 00
	00		 mov	 DWORD PTR [ebx+1096], eax

; 480  : 
; 481  : 				// Volume size
; 482  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_SIZE);

  00583	6a 64		 push	 100			; 00000064H
  00585	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0058b	50		 push	 eax
  0058c	e8 00 00 00 00	 call	 _GetHeaderField64@8
  00591	89 83 f0 1e 00
	00		 mov	 DWORD PTR [ebx+7920], eax

; 483  : 				
; 484  : 				// Encrypted area size and length
; 485  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_START);

  00597	6a 6c		 push	 108			; 0000006cH
  00599	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0059f	50		 push	 eax
  005a0	89 93 f4 1e 00
	00		 mov	 DWORD PTR [ebx+7924], edx
  005a6	e8 00 00 00 00	 call	 _GetHeaderField64@8
  005ab	89 83 f8 1e 00
	00		 mov	 DWORD PTR [ebx+7928], eax

; 486  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  005b1	6a 74		 push	 116			; 00000074H
  005b3	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  005b9	50		 push	 eax
  005ba	89 93 fc 1e 00
	00		 mov	 DWORD PTR [ebx+7932], edx
  005c0	e8 00 00 00 00	 call	 _GetHeaderField64@8
  005c5	89 83 00 1f 00
	00		 mov	 DWORD PTR [ebx+7936], eax

; 487  : 
; 488  : 				// Flags
; 489  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, GST_HEADER_OFFSET_FLAGS);

  005cb	6a 7c		 push	 124			; 0000007cH
  005cd	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  005d3	50		 push	 eax
  005d4	89 93 04 1f 00
	00		 mov	 DWORD PTR [ebx+7940], edx
  005da	e8 00 00 00 00	 call	 _GetHeaderField32@8
  005df	89 83 08 1f 00
	00		 mov	 DWORD PTR [ebx+7944], eax

; 490  : 
; 491  : 				// Sector size
; 492  : 				if (headerVersion >= 5)

  005e5	bf 00 02 00 00	 mov	 edi, 512		; 00000200H
  005ea	66 83 fe 05	 cmp	 si, 5
  005ee	72 19		 jb	 SHORT $LN29@ReadVolume

; 493  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, GST_HEADER_OFFSET_SECTOR_SIZE);

  005f0	68 80 00 00 00	 push	 128			; 00000080H
  005f5	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  005fb	50		 push	 eax
  005fc	e8 00 00 00 00	 call	 _GetHeaderField32@8
  00601	89 83 e8 1e 00
	00		 mov	 DWORD PTR [ebx+7912], eax

; 494  : 				else

  00607	eb 06		 jmp	 SHORT $LN28@ReadVolume
$LN29@ReadVolume:

; 495  : 					cryptoInfo->SectorSize = GST_SECTOR_SIZE_LEGACY;

  00609	89 bb e8 1e 00
	00		 mov	 DWORD PTR [ebx+7912], edi
$LN28@ReadVolume:

; 496  : 
; 497  : 				if (cryptoInfo->SectorSize < GST_MIN_VOLUME_SECTOR_SIZE
; 498  : 					|| cryptoInfo->SectorSize > GST_MAX_VOLUME_SECTOR_SIZE
; 499  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  0060f	8b 83 e8 1e 00
	00		 mov	 eax, DWORD PTR [ebx+7912]
  00615	3b c7		 cmp	 eax, edi
  00617	0f 82 1b 01 00
	00		 jb	 $LN26@ReadVolume
  0061d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00622	0f 87 10 01 00
	00		 ja	 $LN26@ReadVolume
  00628	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  0062d	0f 85 05 01 00
	00		 jne	 $LN26@ReadVolume

; 502  : 					goto err;
; 503  : 				}
; 504  : 
; 505  : 				// Preserve scheduled header keys if requested			
; 506  : 				if (retHeaderCryptoInfo)

  00633	83 bd 58 fb ff
	ff 00		 cmp	 DWORD PTR _retHeaderCryptoInfo$GSCopy$[ebp], 0
  0063a	74 57		 je	 SHORT $LN25@ReadVolume

; 507  : 				{
; 508  : 					if (retInfo == NULL)

  0063c	8b b5 50 fb ff
	ff		 mov	 esi, DWORD PTR _retInfo$GSCopy$[ebp]
  00642	85 f6		 test	 esi, esi
  00644	75 1d		 jne	 SHORT $LN24@ReadVolume

; 509  : 					{
; 510  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  00646	8b 85 60 fb ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$[ebp]
  0064c	89 83 94 1e 00
	00		 mov	 DWORD PTR [ebx+7828], eax

; 511  : 						cryptoInfo->noIterations = keyInfo.noIterations;

  00652	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  00658	89 83 90 1e 00
	00		 mov	 DWORD PTR [ebx+7824], eax

; 512  : 						goto ret;

  0065e	e9 f6 00 00 00	 jmp	 $ret$26719
$LN24@ReadVolume:

; 513  : 					}
; 514  : 
; 515  : 					cryptoInfo = *retInfo = crypto_open ();

  00663	e8 00 00 00 00	 call	 _crypto_open@0
  00668	8b d8		 mov	 ebx, eax
  0066a	89 06		 mov	 DWORD PTR [esi], eax

; 516  : 					if (cryptoInfo == NULL)

  0066c	85 db		 test	 ebx, ebx
  0066e	75 0f		 jne	 SHORT $LN23@ReadVolume

; 517  : 					{
; 518  : 						status = ERR_OUTOFMEMORY;

  00670	c7 85 70 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR _status$[ebp], 2

; 519  : 						goto err;

  0067a	e9 c3 00 00 00	 jmp	 $err$26701
$LN23@ReadVolume:

; 520  : 					}
; 521  : 
; 522  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  0067f	68 10 1f 00 00	 push	 7952			; 00001f10H
  00684	ff b5 58 fb ff
	ff		 push	 DWORD PTR _retHeaderCryptoInfo$GSCopy$[ebp]
  0068a	53		 push	 ebx
  0068b	e8 00 00 00 00	 call	 _memcpy
  00690	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@ReadVolume:

; 523  : 				}
; 524  : 
; 525  : 				// Master key data
; 526  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);
; 527  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
; 528  : 
; 529  : 				// PKCS #5
; 530  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);
; 531  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  00693	8b 85 60 fb ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$[ebp]
  00699	6a 40		 push	 64			; 00000040H
  0069b	59		 pop	 ecx
  0069c	6a 40		 push	 64			; 00000040H
  0069e	8d b5 fc fe ff
	ff		 lea	 esi, DWORD PTR _header$[ebp+256]
  006a4	8d bd fc fb ff
	ff		 lea	 edi, DWORD PTR _keyInfo$[ebp+136]
  006aa	f3 a5		 rep movsd
  006ac	59		 pop	 ecx
  006ad	6a 10		 push	 16			; 00000010H
  006af	8d bb 50 1c 00
	00		 lea	 edi, DWORD PTR [ebx+7248]
  006b5	8d b5 fc fb ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+136]
  006bb	f3 a5		 rep movsd
  006bd	59		 pop	 ecx
  006be	8d bb 50 1e 00
	00		 lea	 edi, DWORD PTR [ebx+7760]
  006c4	8d b5 bc fb ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+72]
  006ca	f3 a5		 rep movsd
  006cc	89 83 94 1e 00
	00		 mov	 DWORD PTR [ebx+7828], eax

; 532  : 				cryptoInfo->noIterations = keyInfo.noIterations;

  006d2	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  006d8	89 83 90 1e 00
	00		 mov	 DWORD PTR [ebx+7824], eax

; 533  : 
; 534  : 				// Init the cipher with the decrypted master key
; 535  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  006de	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  006e1	50		 push	 eax
  006e2	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+136]
  006e8	50		 push	 eax
  006e9	ff 33		 push	 DWORD PTR [ebx]
  006eb	e8 00 00 00 00	 call	 _EAInit@12
  006f0	89 85 70 fb ff
	ff		 mov	 DWORD PTR _status$[ebp], eax

; 536  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  006f6	83 f8 11	 cmp	 eax, 17			; 00000011H
  006f9	74 47		 je	 SHORT $err$26701

; 537  : 					goto err;
; 538  : 
; 539  : 				switch (cryptoInfo->mode)
; 540  : 				{
; 541  : 				default:
; 542  : 					// The secondary master key (if cascade, multiple concatenated)
; 543  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  006fb	ff 33		 push	 DWORD PTR [ebx]
  006fd	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00702	50		 push	 eax
  00703	ff 33		 push	 DWORD PTR [ebx]
  00705	e8 00 00 00 00	 call	 _EAGetKeySize@4
  0070a	8d 84 05 fc fb
	ff ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+eax+136]
  00711	50		 push	 eax
  00712	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  00718	50		 push	 eax
  00719	e8 00 00 00 00	 call	 _memcpy
  0071e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 544  : 
; 545  : 				}
; 546  : 
; 547  : 				if (!EAInitMode (cryptoInfo))

  00721	53		 push	 ebx
  00722	e8 00 00 00 00	 call	 _EAInitMode@4
  00727	85 c0		 test	 eax, eax

; 548  : 				{
; 549  : 					status = ERR_MODE_INIT_FAILED;
; 550  : 					goto err;

  00729	0f 84 c2 fd ff
	ff		 je	 $LN118@ReadVolume

; 551  : 				}
; 552  : 
; 553  : 				status = ERR_SUCCESS;

  0072f	83 a5 70 fb ff
	ff 00		 and	 DWORD PTR _status$[ebp], 0

; 554  : 				goto ret;

  00736	eb 21		 jmp	 SHORT $ret$26719
$LN26@ReadVolume:

; 500  : 				{
; 501  : 					status = ERR_PARAMETER_INCORRECT;

  00738	c7 85 70 fb ff
	ff 1e 00 00 00	 mov	 DWORD PTR _status$[ebp], 30 ; 0000001eH
$err$26701:

; 559  : 
; 560  : err:
; 561  : 	if (cryptoInfo != retHeaderCryptoInfo)

  00742	3b 9d 58 fb ff
	ff		 cmp	 ebx, DWORD PTR _retHeaderCryptoInfo$GSCopy$[ebp]
  00748	74 0f		 je	 SHORT $ret$26719

; 562  : 	{
; 563  : 		crypto_close(cryptoInfo);

  0074a	53		 push	 ebx
  0074b	e8 00 00 00 00	 call	 _crypto_close@4

; 564  : 		*retInfo = NULL; 

  00750	8b 85 50 fb ff
	ff		 mov	 eax, DWORD PTR _retInfo$GSCopy$[ebp]
  00756	83 20 00	 and	 DWORD PTR [eax], 0
$ret$26719:

; 565  : 	}
; 566  : 
; 567  : ret:
; 568  : 	burn (&keyInfo, sizeof (keyInfo));

  00759	8d 95 74 fb ff
	ff		 lea	 edx, DWORD PTR _keyInfo$[ebp]
  0075f	b8 88 01 00 00	 mov	 eax, 392		; 00000188H
  00764	8b f8		 mov	 edi, eax
  00766	8b ca		 mov	 ecx, edx
$LL90@ReadVolume:
  00768	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0076b	41		 inc	 ecx
  0076c	48		 dec	 eax
  0076d	75 f9		 jne	 SHORT $LL90@ReadVolume
  0076f	33 f6		 xor	 esi, esi
$LL13@ReadVolume:
  00771	4f		 dec	 edi
  00772	c6 02 00	 mov	 BYTE PTR [edx], 0
  00775	42		 inc	 edx
  00776	3b fe		 cmp	 edi, esi
  00778	75 f7		 jne	 SHORT $LL13@ReadVolume

; 569  : 	burn (dk, sizeof(dk));

  0077a	8d 95 fc fc ff
	ff		 lea	 edx, DWORD PTR _dk$[ebp]
  00780	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00785	8b f8		 mov	 edi, eax
  00787	8b ca		 mov	 ecx, edx
$LL94@ReadVolume:
  00789	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0078c	41		 inc	 ecx
  0078d	48		 dec	 eax
  0078e	75 f9		 jne	 SHORT $LL94@ReadVolume
$LL8@ReadVolume:
  00790	4f		 dec	 edi
  00791	c6 02 00	 mov	 BYTE PTR [edx], 0
  00794	42		 inc	 edx
  00795	3b fe		 cmp	 edi, esi
  00797	75 f7		 jne	 SHORT $LL8@ReadVolume

; 570  : 
; 571  : #ifndef DEVICE_DRIVER
; 572  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));
; 573  : 	VirtualUnlock (&dk, sizeof (dk));
; 574  : #endif
; 575  : 
; 576  : 	if (encryptionThreadCount > 1)

  00799	83 bd 5c fb ff
	ff 01		 cmp	 DWORD PTR _encryptionThreadCount$[ebp], 1
  007a0	76 41		 jbe	 SHORT $LN6@ReadVolume

; 577  : 	{
; 578  : 		GST_WAIT_EVENT (noOutstandingWorkItemEvent);

  007a2	56		 push	 esi
  007a3	56		 push	 esi
  007a4	56		 push	 esi
  007a5	56		 push	 esi
  007a6	8d 85 3c fb ff
	ff		 lea	 eax, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  007ac	50		 push	 eax
  007ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 579  : 
; 580  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  007b3	8b 95 64 fb ff
	ff		 mov	 edx, DWORD PTR _keyDerivationWorkItems$[ebp]
  007b9	b8 24 03 00 00	 mov	 eax, 804		; 00000324H
  007be	8b f8		 mov	 edi, eax
  007c0	8b ca		 mov	 ecx, edx
$LL98@ReadVolume:
  007c2	c6 01 00	 mov	 BYTE PTR [ecx], 0
  007c5	41		 inc	 ecx
  007c6	48		 dec	 eax
  007c7	75 f9		 jne	 SHORT $LL98@ReadVolume
$LL2@ReadVolume:
  007c9	4f		 dec	 edi
  007ca	c6 02 00	 mov	 BYTE PTR [edx], 0
  007cd	42		 inc	 edx
  007ce	3b fe		 cmp	 edi, esi
  007d0	75 f7		 jne	 SHORT $LL2@ReadVolume

; 581  : 		GSTfree (keyDerivationWorkItems);

  007d2	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  007d7	ff b5 64 fb ff
	ff		 push	 DWORD PTR _keyDerivationWorkItems$[ebp]
  007dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN6@ReadVolume:

; 582  : 
; 583  : #ifndef DEVICE_DRIVER
; 584  : 		CloseHandle (keyDerivationCompletedEvent);
; 585  : 		CloseHandle (noOutstandingWorkItemEvent);
; 586  : #endif
; 587  : 	}
; 588  : 
; 589  : 	return status;

  007e3	8b 85 70 fb ff
	ff		 mov	 eax, DWORD PTR _status$[ebp]
$LN85@ReadVolume:

; 590  : }

  007e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ec	5f		 pop	 edi
  007ed	5e		 pop	 esi
  007ee	33 cd		 xor	 ecx, ebp
  007f0	5b		 pop	 ebx
  007f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007f6	c9		 leave
  007f7	c2 14 00	 ret	 20			; 00000014H
$LN154@ReadVolume:
_ReadVolumeHeader@20 ENDP
_TEXT	ENDS
END
