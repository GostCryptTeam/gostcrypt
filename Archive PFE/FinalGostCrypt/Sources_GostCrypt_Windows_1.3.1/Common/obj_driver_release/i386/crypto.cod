; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_09HLDHDDJL@Whirlpool?$AA@			; `string'
PUBLIC	??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@	; `string'
PUBLIC	??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@	; `string'
PUBLIC	??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@	; `string'
PUBLIC	??_C@_0O@POKHNLDL@GOST?528147?989?$AA@		; `string'
_BSS	SEGMENT
_HwEncryptionDisabled DD 01H DUP (?)
?state@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::state
?stateValid@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::stateValid
_BSS	ENDS
;	COMDAT ??_C@_09HLDHDDJL@Whirlpool?$AA@
CONST	SEGMENT
??_C@_09HLDHDDJL@Whirlpool?$AA@ DB 'Whirlpool', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@
CONST	SEGMENT
??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@ DB 'GOST R 34.11-94', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@
CONST	SEGMENT
??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@ DB 'GOST R 34.11-2012', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_Ciphers DD	01H
	DD	FLAT:??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
	DD	08H
	DD	020H
	DD	0220H
	DD	02H
	DD	FLAT:??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@
	DD	010H
	DD	020H
	DD	0a0H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_EncryptionAlgorithms DD 00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	ORG $+4
	DD	00H
	DD	01H
	DD	00H
	ORG $+8
	DD	02H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	00H
	ORG $+8
	DD	01H
	DD	00H
	ORG $+4
	DD	01H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	ORG $+4
	DD	00H
_Hashes	DD	01H
	DD	FLAT:??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_09HLDHDDJL@Whirlpool?$AA@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
;	COMDAT ??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@
CONST	SEGMENT
??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@ DB 'Gost Grasshopper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
CONST	SEGMENT
??_C@_0O@POKHNLDL@GOST?528147?989?$AA@ DB 'GOST 28147-89', 00H ; `string'
CONST	ENDS
PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_CipherInit@12
EXTRN	_gost_set_key@8:PROC
EXTRN	_grasshopper_set_key@8:PROC
; Function compile flags: /Ogsp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _CipherInit@12
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_key$ = 12						; size = 4
_ks$ = 16						; size = 4
_CipherInit@12 PROC					; COMDAT

; 110  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 111  : 	int retVal = ERR_SUCCESS;
; 112  : 
; 113  : 	switch (cipher)

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00008	48		 dec	 eax
  00009	74 15		 je	 SHORT $LN3@CipherInit
  0000b	48		 dec	 eax
  0000c	74 05		 je	 SHORT $LN2@CipherInit

; 121  : 	default:
; 122  : 		// Unknown/wrong cipher ID
; 123  : 		return ERR_CIPHER_INIT_FAILURE;

  0000e	6a 11		 push	 17			; 00000011H
  00010	58		 pop	 eax
  00011	eb 1a		 jmp	 SHORT $LN6@CipherInit
$LN2@CipherInit:

; 117  : 		break;
; 118  : 	case GRASSHOPPER:
; 119  : 		grasshopper_set_key((unsigned long *)key, (grasshopper_kds*)ks);

  00013	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00016	ff 75 0c	 push	 DWORD PTR _key$[ebp]
  00019	e8 00 00 00 00	 call	 _grasshopper_set_key@8

; 120  : 		break;

  0001e	eb 0b		 jmp	 SHORT $LN4@CipherInit
$LN3@CipherInit:

; 114  : 	{
; 115  : 	case GOST:
; 116  : 		gost_set_key(key, (gost_kds *)ks);

  00020	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00023	ff 75 0c	 push	 DWORD PTR _key$[ebp]
  00026	e8 00 00 00 00	 call	 _gost_set_key@8
$LN4@CipherInit:

; 124  : 	}
; 125  : 
; 126  : 	return retVal;

  0002b	33 c0		 xor	 eax, eax
$LN6@CipherInit:

; 127  : }

  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
_CipherInit@12 ENDP
_TEXT	ENDS
PUBLIC	_EncipherBlock@12
EXTRN	_gost_encrypt@12:PROC
EXTRN	_grasshopper_encrypt@12:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncipherBlock@12
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_data$ = 12						; size = 4
_ks$ = 16						; size = 4
_EncipherBlock@12 PROC					; COMDAT

; 140  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 141  : 	switch (cipher)

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00008	48		 dec	 eax
  00009	74 29		 je	 SHORT $LN3@EncipherBl
  0000b	48		 dec	 eax
  0000c	74 16		 je	 SHORT $LN2@EncipherBl

; 149  : 	default:			GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  0000e	68 54 53 47 00	 push	 4674388			; 00475354H
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	68 95 00 00 00	 push	 149			; 00000095H
  0001c	6a 29		 push	 41			; 00000029H
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN9@EncipherBl:
$LN2@EncipherBl:

; 145  : 		break;
; 146  : 	case GRASSHOPPER:
; 147  : 		grasshopper_encrypt(ks, (unsigned long *)data, (unsigned long *)data);

  00024	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00027	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0002a	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  0002d	e8 00 00 00 00	 call	 _grasshopper_encrypt@12

; 148  : 		break;

  00032	eb 0e		 jmp	 SHORT $LN4@EncipherBl
$LN3@EncipherBl:

; 142  : 	{
; 143  : 	case GOST:
; 144  : 		gost_encrypt((byte *)data, (byte *)data, ks);

  00034	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00037	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0003a	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0003d	e8 00 00 00 00	 call	 _gost_encrypt@12
$LN4@EncipherBl:

; 150  : 	}
; 151  : }

  00042	5d		 pop	 ebp
  00043	c2 0c 00	 ret	 12			; 0000000cH
$LN8@EncipherBl:
_EncipherBlock@12 ENDP
_TEXT	ENDS
PUBLIC	_DecipherBlock@12
EXTRN	_gost_decrypt@12:PROC
EXTRN	_grasshopper_decrypt@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _DecipherBlock@12
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_data$ = 12						; size = 4
_ks$ = 16						; size = 4
_DecipherBlock@12 PROC					; COMDAT

; 190  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 191  : 	switch (cipher)

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00008	48		 dec	 eax
  00009	74 29		 je	 SHORT $LN3@DecipherBl
  0000b	48		 dec	 eax
  0000c	74 16		 je	 SHORT $LN2@DecipherBl

; 199  : 	default:		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  0000e	68 54 53 47 00	 push	 4674388			; 00475354H
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	68 c7 00 00 00	 push	 199			; 000000c7H
  0001c	6a 29		 push	 41			; 00000029H
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN9@DecipherBl:
$LN2@DecipherBl:

; 195  : 		break;
; 196  : 	case GRASSHOPPER:
; 197  : 		grasshopper_decrypt(ks, (unsigned long*)data, (unsigned long*)data);

  00024	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00027	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0002a	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  0002d	e8 00 00 00 00	 call	 _grasshopper_decrypt@12

; 198  : 		break;

  00032	eb 0e		 jmp	 SHORT $LN4@DecipherBl
$LN3@DecipherBl:

; 192  : 	{
; 193  : 	case GOST:
; 194  : 		gost_decrypt((byte *)data, (byte *)data, ks);

  00034	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00037	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0003a	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0003d	e8 00 00 00 00	 call	 _gost_decrypt@12
$LN4@DecipherBl:

; 200  : 	}
; 201  : }

  00042	5d		 pop	 ebp
  00043	c2 0c 00	 ret	 12			; 0000000cH
$LN8@DecipherBl:
_DecipherBlock@12 ENDP
_TEXT	ENDS
PUBLIC	_CipherGet@4
; Function compile flags: /Ogsp
;	COMDAT _CipherGet@4
_TEXT	SEGMENT
_id$ = 8						; size = 4
_CipherGet@4 PROC					; COMDAT

; 242  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 243  : 	int i;
; 244  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00005	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Ciphers
  0000b	33 c0		 xor	 eax, eax
  0000d	eb 11		 jmp	 SHORT $LN10@CipherGet
$LL4@CipherGet:

; 245  : 		if (Ciphers[i].Id == id)

  0000f	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  00012	74 16		 je	 SHORT $LN8@CipherGet
  00014	40		 inc	 eax
  00015	8b c8		 mov	 ecx, eax
  00017	6b c9 14	 imul	 ecx, 20			; 00000014H
  0001a	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _Ciphers[ecx]
$LN10@CipherGet:

; 243  : 	int i;
; 244  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00020	85 c9		 test	 ecx, ecx
  00022	75 eb		 jne	 SHORT $LL4@CipherGet

; 247  : 
; 248  : 	return NULL;

  00024	33 c0		 xor	 eax, eax
$LN5@CipherGet:

; 249  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN8@CipherGet:

; 246  : 			return &Ciphers[i];

  0002a	6b c0 14	 imul	 eax, 20			; 00000014H
  0002d	05 00 00 00 00	 add	 eax, OFFSET _Ciphers
  00032	eb f2		 jmp	 SHORT $LN5@CipherGet
_CipherGet@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetName@4
; Function compile flags: /Ogsp
;	COMDAT _CipherGetName@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetName@4 PROC					; COMDAT

; 261  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 262  : 	return CipherGet (cipherId) -> Name;

  00005	ff 75 08	 push	 DWORD PTR _cipherId$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherGet@4
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 263  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_CipherGetName@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetBlockSize@4
; Function compile flags: /Ogsp
;	COMDAT _CipherGetBlockSize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetBlockSize@4 PROC				; COMDAT

; 275  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 276  : 	return CipherGet (cipherId) -> BlockSize;

  00005	ff 75 08	 push	 DWORD PTR _cipherId$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherGet@4
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 277  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_CipherGetBlockSize@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetKeySize@4
; Function compile flags: /Ogsp
;	COMDAT _CipherGetKeySize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetKeySize@4 PROC				; COMDAT

; 289  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 290  : 	return CipherGet (cipherId) -> KeySize;

  00005	ff 75 08	 push	 DWORD PTR _cipherId$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherGet@4
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 291  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_CipherGetKeySize@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetKeyScheduleSize@4
; Function compile flags: /Ogsp
;	COMDAT _CipherGetKeyScheduleSize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetKeyScheduleSize@4 PROC			; COMDAT

; 303  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 304  : 	return CipherGet (cipherId) -> KeyScheduleSize;

  00005	ff 75 08	 push	 DWORD PTR _cipherId$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherGet@4
  0000d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 305  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_CipherGetKeyScheduleSize@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherSupportsIntraDataUnitParallelization@4
; Function compile flags: /Ogsp
;	COMDAT _CipherSupportsIntraDataUnitParallelization@4
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_CipherSupportsIntraDataUnitParallelization@4 PROC	; COMDAT

; 319  : 	return 0;

  00000	33 c0		 xor	 eax, eax

; 320  : }

  00002	c2 04 00	 ret	 4
_CipherSupportsIntraDataUnitParallelization@4 ENDP
_TEXT	ENDS
PUBLIC	_XorKeySchedule@20
EXTRN	_gost_xor_ks@16:PROC
EXTRN	_grasshopper_xor_ks@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _XorKeySchedule@20
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_ks$ = 12						; size = 4
_out_ks$ = 16						; size = 4
_data$ = 20						; size = 4
_len$ = 24						; size = 4
_XorKeySchedule@20 PROC					; COMDAT

; 337  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 338  : 	switch (cipher)

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00008	48		 dec	 eax
  00009	74 30		 je	 SHORT $LN3@XorKeySche
  0000b	48		 dec	 eax
  0000c	74 16		 je	 SHORT $LN2@XorKeySche

; 346  : 	default:
; 347  : 		GST_THROW_FATAL_EXCEPTION;

  0000e	68 54 53 47 00	 push	 4674388			; 00475354H
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	68 5b 01 00 00	 push	 347			; 0000015bH
  0001c	6a 29		 push	 41			; 00000029H
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN9@XorKeySche:
$LN2@XorKeySche:

; 342  : 		break;
; 343  : 	case GRASSHOPPER:
; 344  : 		grasshopper_xor_ks(ks, out_ks, data, len / sizeof(__int32));

  00024	8b 45 18	 mov	 eax, DWORD PTR _len$[ebp]
  00027	c1 e8 02	 shr	 eax, 2
  0002a	50		 push	 eax
  0002b	ff 75 14	 push	 DWORD PTR _data$[ebp]
  0002e	ff 75 10	 push	 DWORD PTR _out_ks$[ebp]
  00031	ff 75 0c	 push	 DWORD PTR _ks$[ebp]
  00034	e8 00 00 00 00	 call	 _grasshopper_xor_ks@16

; 345  : 		break;

  00039	eb 15		 jmp	 SHORT $LN4@XorKeySche
$LN3@XorKeySche:

; 339  : 	{
; 340  : 	case GOST:
; 341  : 		gost_xor_ks(ks, out_ks, data, len / sizeof(__int32));

  0003b	8b 45 18	 mov	 eax, DWORD PTR _len$[ebp]
  0003e	c1 e8 02	 shr	 eax, 2
  00041	50		 push	 eax
  00042	ff 75 14	 push	 DWORD PTR _data$[ebp]
  00045	ff 75 10	 push	 DWORD PTR _out_ks$[ebp]
  00048	ff 75 0c	 push	 DWORD PTR _ks$[ebp]
  0004b	e8 00 00 00 00	 call	 _gost_xor_ks@16
$LN4@XorKeySche:

; 348  : 	}
; 349  : }

  00050	5d		 pop	 ebp
  00051	c2 14 00	 ret	 20			; 00000014H
$LN8@XorKeySche:
_XorKeySchedule@20 ENDP
_TEXT	ENDS
PUBLIC	_EAGetFirst@0
; Function compile flags: /Ogsp
;	COMDAT _EAGetFirst@0
_TEXT	SEGMENT
_EAGetFirst@0 PROC					; COMDAT

; 362  : 	return 1;

  00000	33 c0		 xor	 eax, eax
  00002	40		 inc	 eax

; 363  : }

  00003	c3		 ret	 0
_EAGetFirst@0 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNext@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetNext@4
_TEXT	SEGMENT
_previousEA$ = 8					; size = 4
_EAGetNext@4 PROC					; COMDAT

; 394  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 395  : 	int id = previousEA + 1;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _previousEA$[ebp]
  00008	41		 inc	 ecx

; 396  : 	if (EncryptionAlgorithms[id].Ciphers[0] != 0) return id;

  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e0 05	 shl	 eax, 5
  0000e	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  00014	f7 d8		 neg	 eax
  00016	1b c0		 sbb	 eax, eax
  00018	23 c1		 and	 eax, ecx

; 397  : 	return 0;
; 398  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
_EAGetNext@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetFirstMode@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetFirstMode@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetFirstMode@4 PROC					; COMDAT

; 562  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 563  : 	return (EncryptionAlgorithms[ea].Modes[0]);

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	c1 e0 05	 shl	 eax, 5
  0000b	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+16]

; 564  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAGetFirstMode@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNextMode@8
; Function compile flags: /Ogsp
;	COMDAT _EAGetNextMode@8
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_previousModeId$ = 12					; size = 4
_EAGetNextMode@8 PROC					; COMDAT

; 578  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 579  : 	int c, i = 0;
; 580  : 	while (c = EncryptionAlgorithms[ea].Modes[i++])

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _ea$[ebp]
  00008	8b d1		 mov	 edx, ecx
  0000a	c1 e2 03	 shl	 edx, 3
  0000d	8b 04 95 10 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edx*4+16]
  00014	56		 push	 esi
  00015	33 f6		 xor	 esi, esi
  00017	85 c0		 test	 eax, eax
  00019	74 18		 je	 SHORT $LN8@EAGetNextM
  0001b	c1 e1 05	 shl	 ecx, 5
  0001e	81 c1 10 00 00
	00		 add	 ecx, OFFSET _EncryptionAlgorithms+16
$LL3@EAGetNextM:
  00024	46		 inc	 esi
  00025	83 c1 04	 add	 ecx, 4

; 581  : 	{
; 582  : 		if (c == previousModeId) 

  00028	3b 45 0c	 cmp	 eax, DWORD PTR _previousModeId$[ebp]
  0002b	74 0d		 je	 SHORT $LN7@EAGetNextM
  0002d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002f	85 c0		 test	 eax, eax
  00031	75 f1		 jne	 SHORT $LL3@EAGetNextM
$LN8@EAGetNextM:

; 584  : 	}
; 585  : 
; 586  : 	return 0;

  00033	33 c0		 xor	 eax, eax
$LN4@EAGetNextM:
  00035	5e		 pop	 esi

; 587  : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
$LN7@EAGetNextM:

; 583  : 			return EncryptionAlgorithms[ea].Modes[i];

  0003a	03 d6		 add	 edx, esi
  0003c	8b 04 95 10 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edx*4+16]
  00043	eb f0		 jmp	 SHORT $LN4@EAGetNextM
_EAGetNextMode@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_EAGetModeName@12
;	COMDAT ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@ DB 'XTS', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@ DB 'XTS 64-bit ver'
	DB	'sion', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@ DB '[unknown]', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _EAGetModeName@12
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_mode$ = 12						; size = 4
_capitalLetters$ = 16					; size = 4
_EAGetModeName@12 PROC					; COMDAT

; 605  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 606  : 	switch (mode)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00008	48		 dec	 eax
  00009	74 11		 je	 SHORT $LN2@EAGetModeN
  0000b	48		 dec	 eax
  0000c	74 07		 je	 SHORT $LN1@EAGetModeN

; 612  : 	}
; 613  : 	return "[unknown]";

  0000e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
  00013	eb 0c		 jmp	 SHORT $LN5@EAGetModeN
$LN1@EAGetModeN:

; 610  : 	case XTS8:
; 611  : 		return "XTS 64-bit version";

  00015	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@FNODOBFM@
  0001a	eb 05		 jmp	 SHORT $LN5@EAGetModeN
$LN2@EAGetModeN:

; 607  : 	{
; 608  : 	case XTS:
; 609  : 		return "XTS";

  0001c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
$LN5@EAGetModeN:

; 614  : }

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
_EAGetModeName@12 ENDP
_TEXT	ENDS
PUBLIC	_EAGetCipherCount@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetCipherCount@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetCipherCount@4 PROC				; COMDAT

; 691  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 692  : 	int i = 0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	c1 e0 05	 shl	 eax, 5
  0000b	33 c9		 xor	 ecx, ecx
  0000d	05 00 00 00 00	 add	 eax, OFFSET _EncryptionAlgorithms
$LL2@EAGetCiphe:

; 693  : 	while (EncryptionAlgorithms[ea].Ciphers[i++]);

  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	41		 inc	 ecx
  00015	83 c0 04	 add	 eax, 4
  00018	85 d2		 test	 edx, edx
  0001a	75 f6		 jne	 SHORT $LL2@EAGetCiphe

; 694  : 
; 695  : 	return i - 1;

  0001c	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]

; 696  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
_EAGetCipherCount@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetFirstCipher@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetFirstCipher@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetFirstCipher@4 PROC				; COMDAT

; 708  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 709  : 	return EncryptionAlgorithms[ea].Ciphers[0];

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	c1 e0 05	 shl	 eax, 5
  0000b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]

; 710  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAGetFirstCipher@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetLastCipher@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetLastCipher@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetLastCipher@4 PROC					; COMDAT

; 722  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 723  : 	int c, i = 0;

  00005	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00008	8b c2		 mov	 eax, edx
  0000a	c1 e0 05	 shl	 eax, 5
  0000d	33 c9		 xor	 ecx, ecx
  0000f	05 00 00 00 00	 add	 eax, OFFSET _EncryptionAlgorithms
  00014	56		 push	 esi
$LL2@EAGetLastC:

; 724  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++]);

  00015	8b 30		 mov	 esi, DWORD PTR [eax]
  00017	41		 inc	 ecx
  00018	83 c0 04	 add	 eax, 4
  0001b	85 f6		 test	 esi, esi
  0001d	75 f6		 jne	 SHORT $LL2@EAGetLastC

; 725  : 
; 726  : 	return EncryptionAlgorithms[ea].Ciphers[i - 2];

  0001f	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00022	8b 04 85 f8 ff
	ff ff		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  00029	5e		 pop	 esi

; 727  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
_EAGetLastCipher@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNextCipher@8
; Function compile flags: /Ogsp
;	COMDAT _EAGetNextCipher@8
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_previousCipherId$ = 12					; size = 4
_EAGetNextCipher@8 PROC					; COMDAT

; 741  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 742  : 	int c, i = 0;
; 743  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _ea$[ebp]
  00008	8b d1		 mov	 edx, ecx
  0000a	c1 e2 03	 shl	 edx, 3
  0000d	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edx*4]
  00014	56		 push	 esi
  00015	33 f6		 xor	 esi, esi
  00017	85 c0		 test	 eax, eax
  00019	74 18		 je	 SHORT $LN8@EAGetNextC
  0001b	c1 e1 05	 shl	 ecx, 5
  0001e	81 c1 00 00 00
	00		 add	 ecx, OFFSET _EncryptionAlgorithms
$LL3@EAGetNextC:
  00024	46		 inc	 esi
  00025	83 c1 04	 add	 ecx, 4

; 744  : 	{
; 745  : 		if (c == previousCipherId) 

  00028	3b 45 0c	 cmp	 eax, DWORD PTR _previousCipherId$[ebp]
  0002b	74 0d		 je	 SHORT $LN7@EAGetNextC
  0002d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002f	85 c0		 test	 eax, eax
  00031	75 f1		 jne	 SHORT $LL3@EAGetNextC
$LN8@EAGetNextC:

; 747  : 	}
; 748  : 
; 749  : 	return 0;

  00033	33 c0		 xor	 eax, eax
$LN4@EAGetNextC:
  00035	5e		 pop	 esi

; 750  : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
$LN7@EAGetNextC:

; 746  : 			return EncryptionAlgorithms[ea].Ciphers[i];

  0003a	03 d6		 add	 edx, esi
  0003c	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edx*4]
  00043	eb f0		 jmp	 SHORT $LN4@EAGetNextC
_EAGetNextCipher@8 ENDP
_TEXT	ENDS
PUBLIC	_EAGetPreviousCipher@8
; Function compile flags: /Ogsp
;	COMDAT _EAGetPreviousCipher@8
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_previousCipherId$ = 12					; size = 4
_EAGetPreviousCipher@8 PROC				; COMDAT

; 764  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 765  : 	int c, i = 0;
; 766  : 
; 767  : 	if (EncryptionAlgorithms[ea].Ciphers[i++] == previousCipherId)

  00005	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00008	56		 push	 esi
  00009	8b 75 0c	 mov	 esi, DWORD PTR _previousCipherId$[ebp]
  0000c	57		 push	 edi
  0000d	8b c2		 mov	 eax, edx
  0000f	33 ff		 xor	 edi, edi
  00011	c1 e0 03	 shl	 eax, 3
  00014	47		 inc	 edi
  00015	39 34 85 00 00
	00 00		 cmp	 DWORD PTR _EncryptionAlgorithms[eax*4], esi

; 768  : 		return 0;

  0001c	74 22		 je	 SHORT $LN9@EAGetPrevi

; 769  : 
; 770  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  0001e	8b 0c 85 04 00
	00 00		 mov	 ecx, DWORD PTR _EncryptionAlgorithms[eax*4+4]
  00025	85 c9		 test	 ecx, ecx
  00027	74 17		 je	 SHORT $LN9@EAGetPrevi
  00029	c1 e2 05	 shl	 edx, 5
  0002c	81 c2 04 00 00
	00		 add	 edx, OFFSET _EncryptionAlgorithms+4
$LL3@EAGetPrevi:
  00032	47		 inc	 edi
  00033	83 c2 04	 add	 edx, 4

; 771  : 	{
; 772  : 		if (c == previousCipherId) 

  00036	3b ce		 cmp	 ecx, esi
  00038	74 0e		 je	 SHORT $LN8@EAGetPrevi
  0003a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003c	85 c9		 test	 ecx, ecx
  0003e	75 f2		 jne	 SHORT $LL3@EAGetPrevi
$LN9@EAGetPrevi:

; 774  : 	}
; 775  : 
; 776  : 	return 0;

  00040	33 c0		 xor	 eax, eax
$LN5@EAGetPrevi:
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 777  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN8@EAGetPrevi:

; 773  : 			return EncryptionAlgorithms[ea].Ciphers[i - 2];

  00048	03 c7		 add	 eax, edi
  0004a	8b 04 85 f8 ff
	ff ff		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  00051	eb ef		 jmp	 SHORT $LN5@EAGetPrevi
_EAGetPreviousCipher@8 ENDP
_TEXT	ENDS
PUBLIC	_EAIsFormatEnabled@4
; Function compile flags: /Ogsp
;	COMDAT _EAIsFormatEnabled@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAIsFormatEnabled@4 PROC				; COMDAT

; 789  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 790  : 	return EncryptionAlgorithms[ea].FormatEnabled;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	c1 e0 05	 shl	 eax, 5
  0000b	8b 80 1c 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+28]

; 791  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAIsFormatEnabled@4 ENDP
_TEXT	ENDS
PUBLIC	_EAIsModeSupported@8
; Function compile flags: /Ogsp
;	COMDAT _EAIsModeSupported@8
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_testedMode$ = 12					; size = 4
_EAIsModeSupported@8 PROC				; COMDAT

; 804  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 805  : 	int mode;
; 806  : 
; 807  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	c1 e0 05	 shl	 eax, 5
  0000b	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+16]
  00011	eb 0e		 jmp	 SHORT $LN12@EAIsModeSu
$LL4@EAIsModeSu:

; 808  : 	{
; 809  : 		if (mode == testedMode)

  00013	3b 45 0c	 cmp	 eax, DWORD PTR _testedMode$[ebp]
  00016	74 11		 je	 SHORT $LN10@EAIsModeSu
  00018	50		 push	 eax
  00019	ff 75 08	 push	 DWORD PTR _ea$[ebp]
  0001c	e8 00 00 00 00	 call	 _EAGetNextMode@8
$LN12@EAIsModeSu:

; 805  : 	int mode;
; 806  : 
; 807  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  00021	85 c0		 test	 eax, eax
  00023	75 ee		 jne	 SHORT $LL4@EAIsModeSu
$LN5@EAIsModeSu:

; 811  : 	}
; 812  : 	return FALSE;
; 813  : }

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN10@EAIsModeSu:

; 810  : 			return TRUE;

  00029	33 c0		 xor	 eax, eax
  0002b	40		 inc	 eax
  0002c	eb f7		 jmp	 SHORT $LN5@EAIsModeSu
_EAIsModeSupported@8 ENDP
_TEXT	ENDS
PUBLIC	_HashGet@4
; Function compile flags: /Ogsp
;	COMDAT _HashGet@4
_TEXT	SEGMENT
_id$ = 8						; size = 4
_HashGet@4 PROC						; COMDAT

; 826  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 827  : 	int i;
; 828  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00005	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Hashes
  0000b	33 c0		 xor	 eax, eax
  0000d	eb 11		 jmp	 SHORT $LN10@HashGet
$LL4@HashGet:

; 829  : 		if (Hashes[i].Id == id)

  0000f	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  00012	74 16		 je	 SHORT $LN8@HashGet
  00014	40		 inc	 eax
  00015	8b c8		 mov	 ecx, eax
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _Hashes[ecx]
$LN10@HashGet:

; 827  : 	int i;
; 828  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00020	85 c9		 test	 ecx, ecx
  00022	75 eb		 jne	 SHORT $LL4@HashGet

; 831  : 
; 832  : 	return 0;

  00024	33 c0		 xor	 eax, eax
$LN5@HashGet:

; 833  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN8@HashGet:

; 830  : 			return &Hashes[i];

  0002a	c1 e0 04	 shl	 eax, 4
  0002d	05 00 00 00 00	 add	 eax, OFFSET _Hashes
  00032	eb f2		 jmp	 SHORT $LN5@HashGet
_HashGet@4 ENDP
_TEXT	ENDS
PUBLIC	_HashGetIdByName@4
; Function compile flags: /Ogsp
;	COMDAT _HashGetIdByName@4
_TEXT	SEGMENT
_name$ = 8						; size = 4
_HashGetIdByName@4 PROC					; COMDAT

; 846  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 847  : 	int i;
; 848  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00006	33 f6		 xor	 esi, esi
  00008	39 35 00 00 00
	00		 cmp	 DWORD PTR _Hashes, esi
  0000e	74 41		 je	 SHORT $LN2@HashGetIdB
  00010	33 c0		 xor	 eax, eax
$LL4@HashGetIdB:

; 849  : 		if (strcmp (Hashes[i].Name, name) == 0)

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  00015	8b 80 04 00 00
	00		 mov	 eax, DWORD PTR _Hashes[eax+4]
$LL10@HashGetIdB:
  0001b	8a 10		 mov	 dl, BYTE PTR [eax]
  0001d	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0001f	75 18		 jne	 SHORT $LN11@HashGetIdB
  00021	84 d2		 test	 dl, dl
  00023	74 10		 je	 SHORT $LN12@HashGetIdB
  00025	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00028	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  0002b	75 0c		 jne	 SHORT $LN11@HashGetIdB
  0002d	40		 inc	 eax
  0002e	40		 inc	 eax
  0002f	41		 inc	 ecx
  00030	41		 inc	 ecx
  00031	84 d2		 test	 dl, dl
  00033	75 e6		 jne	 SHORT $LL10@HashGetIdB
$LN12@HashGetIdB:
  00035	33 c0		 xor	 eax, eax
  00037	eb 05		 jmp	 SHORT $LN13@HashGetIdB
$LN11@HashGetIdB:
  00039	1b c0		 sbb	 eax, eax
  0003b	83 d8 ff	 sbb	 eax, -1
$LN13@HashGetIdB:
  0003e	85 c0		 test	 eax, eax
  00040	74 16		 je	 SHORT $LN8@HashGetIdB
  00042	46		 inc	 esi
  00043	8b c6		 mov	 eax, esi
  00045	c1 e0 04	 shl	 eax, 4
  00048	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _Hashes[eax], 0
  0004f	75 c1		 jne	 SHORT $LL4@HashGetIdB
$LN2@HashGetIdB:

; 851  : 
; 852  : 	return 0;

  00051	33 c0		 xor	 eax, eax
$LN5@HashGetIdB:
  00053	5e		 pop	 esi

; 853  : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN8@HashGetIdB:

; 850  : 			return Hashes[i].Id;

  00058	c1 e6 04	 shl	 esi, 4
  0005b	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR _Hashes[esi]
  00061	eb f0		 jmp	 SHORT $LN5@HashGetIdB
_HashGetIdByName@4 ENDP
_TEXT	ENDS
PUBLIC	_HashGetName@4
; Function compile flags: /Ogsp
;	COMDAT _HashGetName@4
_TEXT	SEGMENT
_hashId$ = 8						; size = 4
_HashGetName@4 PROC					; COMDAT

; 865  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 866  : 	return HashGet (hashId) -> Name;

  00005	ff 75 08	 push	 DWORD PTR _hashId$[ebp]
  00008	e8 00 00 00 00	 call	 _HashGet@4
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 867  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_HashGetName@4 ENDP
_TEXT	ENDS
PUBLIC	_HashIsDeprecated@4
; Function compile flags: /Ogsp
;	COMDAT _HashIsDeprecated@4
_TEXT	SEGMENT
_hashId$ = 8						; size = 4
_HashIsDeprecated@4 PROC				; COMDAT

; 879  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 880  : 	return HashGet (hashId) -> Deprecated;

  00005	ff 75 08	 push	 DWORD PTR _hashId$[ebp]
  00008	e8 00 00 00 00	 call	 _HashGet@4
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 881  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_HashIsDeprecated@4 ENDP
_TEXT	ENDS
PUBLIC	_crypto_open@0
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _crypto_open@0
_TEXT	SEGMENT
_crypto_open@0 PROC					; COMDAT

; 905  : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	57		 push	 edi

; 906  : #ifndef GST_WINDOWS_BOOT
; 907  : 
; 908  : 	/* Do the crt allocation */
; 909  : 	PCRYPTO_INFO cryptoInfo = (PCRYPTO_INFO) GSTalloc (sizeof (CRYPTO_INFO));

  00004	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00009	be 10 1f 00 00	 mov	 esi, 7952		; 00001f10H
  0000e	56		 push	 esi
  0000f	6a 00		 push	 0
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00017	8b f8		 mov	 edi, eax

; 910  : 	if (cryptoInfo == NULL)

  00019	85 ff		 test	 edi, edi
  0001b	74 11		 je	 SHORT $LN2@crypto_ope
$LN1@crypto_ope:

; 911  : 		return NULL;
; 912  : 
; 913  : 	memset (cryptoInfo, 0, sizeof (CRYPTO_INFO));

  0001d	56		 push	 esi
  0001e	6a 00		 push	 0
  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 _memset
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 914  : 
; 915  : #ifndef DEVICE_DRIVER
; 916  : 	VirtualLock (cryptoInfo, sizeof (CRYPTO_INFO));
; 917  : #endif
; 918  : 
; 919  : 	cryptoInfo->ea = -1;

  00029	83 0f ff	 or	 DWORD PTR [edi], -1

; 920  : 	return cryptoInfo;

  0002c	8b c7		 mov	 eax, edi
$LN2@crypto_ope:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 921  : 
; 922  : #else // GST_WINDOWS_BOOT
; 923  : 
; 924  : #if 0
; 925  : 	if (CryptoInfoBufferInUse)
; 926  : 		GST_THROW_FATAL_EXCEPTION;
; 927  : #endif
; 928  : 	CryptoInfoBufferInUse = 1;
; 929  : 	return &CryptoInfoBuffer;
; 930  : 
; 931  : #endif // GST_WINDOWS_BOOT
; 932  : }

  00030	c3		 ret	 0
_crypto_open@0 ENDP
_TEXT	ENDS
PUBLIC	_crypto_loadkey@12
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT _crypto_loadkey@12
_TEXT	SEGMENT
_keyInfo$ = 8						; size = 4
_lpszUserKey$ = 12					; size = 4
_nUserKeyLen$ = 16					; size = 4
_crypto_loadkey@12 PROC					; COMDAT

; 945  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 946  : 	keyInfo->keyLength = nUserKeyLen;

  00005	8b 45 08	 mov	 eax, DWORD PTR _keyInfo$[ebp]
  00008	8b 55 10	 mov	 edx, DWORD PTR _nUserKeyLen$[ebp]
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 947  : 	burn (keyInfo->userKey, sizeof (keyInfo->userKey));

  0000e	6a 40		 push	 64			; 00000040H
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	83 c0 08	 add	 eax, 8
  00016	5b		 pop	 ebx
  00017	8b f0		 mov	 esi, eax
  00019	8b fb		 mov	 edi, ebx
  0001b	8b c8		 mov	 ecx, eax
$LL9@crypto_loa:
  0001d	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00020	41		 inc	 ecx
  00021	4b		 dec	 ebx
  00022	75 f9		 jne	 SHORT $LL9@crypto_loa
$LL2@crypto_loa:
  00024	4f		 dec	 edi
  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	46		 inc	 esi
  00029	85 ff		 test	 edi, edi
  0002b	75 f7		 jne	 SHORT $LL2@crypto_loa

; 948  : 	memcpy (keyInfo->userKey, lpszUserKey, nUserKeyLen);

  0002d	52		 push	 edx
  0002e	ff 75 0c	 push	 DWORD PTR _lpszUserKey$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx

; 949  : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
_crypto_loadkey@12 ENDP
_TEXT	ENDS
PUBLIC	_crypto_close@4
EXTRN	__imp__ExFreePoolWithTag@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _crypto_close@4
_TEXT	SEGMENT
_cryptoInfo$ = 8					; size = 4
_crypto_close@4 PROC					; COMDAT

; 960  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	57		 push	 edi

; 961  : #ifndef GST_WINDOWS_BOOT
; 962  : 
; 963  : 	if (cryptoInfo != NULL)

  00006	8b 7d 08	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]
  00009	85 ff		 test	 edi, edi
  0000b	74 29		 je	 SHORT $LN6@crypto_clo

; 964  : 	{
; 965  : 		burn (cryptoInfo, sizeof (CRYPTO_INFO));

  0000d	b8 10 1f 00 00	 mov	 eax, 7952		; 00001f10H
  00012	56		 push	 esi
  00013	8b d7		 mov	 edx, edi
  00015	8b f0		 mov	 esi, eax
  00017	8b cf		 mov	 ecx, edi
$LL10@crypto_clo:
  00019	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0001c	41		 inc	 ecx
  0001d	48		 dec	 eax
  0001e	75 f9		 jne	 SHORT $LL10@crypto_clo
$LL2@crypto_clo:
  00020	4e		 dec	 esi
  00021	c6 02 00	 mov	 BYTE PTR [edx], 0
  00024	42		 inc	 edx
  00025	85 f6		 test	 esi, esi
  00027	75 f7		 jne	 SHORT $LL2@crypto_clo

; 966  : #ifndef DEVICE_DRIVER
; 967  : 		VirtualUnlock (cryptoInfo, sizeof (CRYPTO_INFO));
; 968  : #endif
; 969  : 		GSTfree (cryptoInfo);

  00029	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0002e	57		 push	 edi
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
  00035	5e		 pop	 esi
$LN6@crypto_clo:
  00036	5f		 pop	 edi

; 970  : 	}
; 971  : 
; 972  : #else // GST_WINDOWS_BOOT
; 973  : 
; 974  : 	burn (&CryptoInfoBuffer, sizeof (CryptoInfoBuffer));
; 975  : 	CryptoInfoBufferInUse = FALSE;
; 976  : 
; 977  : #endif // GST_WINDOWS_BOOT
; 978  : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
_crypto_close@4 ENDP
_TEXT	ENDS
PUBLIC	_Xor128@8
; Function compile flags: /Ogsp
;	COMDAT _Xor128@8
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_Xor128@8 PROC						; COMDAT

; 996  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 997  : 	*a++ ^= *b++;

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000d	31 10		 xor	 DWORD PTR [eax], edx
  0000f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00012	31 50 04	 xor	 DWORD PTR [eax+4], edx

; 998  : 	*a ^= *b;

  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	83 c0 08	 add	 eax, 8
  0001b	31 10		 xor	 DWORD PTR [eax], edx
  0001d	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00020	31 48 04	 xor	 DWORD PTR [eax+4], ecx

; 999  : }

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
_Xor128@8 ENDP
_TEXT	ENDS
PUBLIC	_Xor64@8
; Function compile flags: /Ogsp
;	COMDAT _Xor64@8
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_Xor64@8 PROC						; COMDAT

; 1011 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1012 : 	*a ^= *b;

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000d	31 10		 xor	 DWORD PTR [eax], edx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00012	31 48 04	 xor	 DWORD PTR [eax+4], ecx

; 1013 : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_Xor64@8 ENDP
_TEXT	ENDS
PUBLIC	_EncryptBuffer@16
EXTRN	_EncryptBufferXTS@32:PROC
EXTRN	_EncryptBufferXTS8Byte@32:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptBuffer@16
_TEXT	SEGMENT
_dataUnitNo$26016 = -12					; size = 8
_dataUnitNo$26008 = -12					; size = 8
_ks2$26015 = -4						; size = 4
_ks2$26007 = -4						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 8
_ks$26014 = 20						; size = 4
_ks$26006 = 20						; size = 4
_cryptoInfo$ = 20					; size = 4
_EncryptBuffer@16 PROC					; COMDAT

; 1028 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	56		 push	 esi

; 1029 : 	switch (cryptoInfo->mode)

  00009	8b 75 14	 mov	 esi, DWORD PTR _cryptoInfo$[ebp]
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	48		 dec	 eax
  00010	57		 push	 edi
  00011	74 77		 je	 SHORT $LN9@EncryptBuf
  00013	48		 dec	 eax
  00014	74 16		 je	 SHORT $LN5@EncryptBuf

; 1079 : 
; 1080 : 	default:		
; 1081 : 		// Unknown/wrong ID
; 1082 : 		GST_THROW_FATAL_EXCEPTION;

  00016	68 54 53 47 00	 push	 4674388			; 00475354H
  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	68 3a 04 00 00	 push	 1082			; 0000043aH
  00024	6a 29		 push	 41			; 00000029H
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN35@EncryptBuf:
$LN5@EncryptBuf:

; 1052 : 			}
; 1053 : 		}
; 1054 : 		break;
; 1055 : 	case XTS8:
; 1056 : 		{
; 1057 : 				 unsigned __int8 *ks = cryptoInfo->ks;
; 1058 : 				 unsigned __int8 *ks2 = cryptoInfo->ks2;
; 1059 : 				 UINT64_STRUCT dataUnitNo;
; 1060 : 				 int cipher;
; 1061 : 
; 1062 : 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1063 : 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1064 : 				 // always assumed to be aligned with the start of a data unit.
; 1065 : 				 dataUnitNo.LowPart = 0;

  0002c	83 65 f4 00	 and	 DWORD PTR _dataUnitNo$26016[ebp], 0

; 1066 : 				 dataUnitNo.HighPart = 0;

  00030	83 65 f8 00	 and	 DWORD PTR _dataUnitNo$26016[ebp+4], 0
  00034	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00037	89 45 14	 mov	 DWORD PTR _ks$26014[ebp], eax
  0003a	8d 86 28 02 00
	00		 lea	 eax, DWORD PTR [esi+552]
  00040	89 45 fc	 mov	 DWORD PTR _ks2$26015[ebp], eax

; 1067 : 
; 1068 : 				 for (cipher = EAGetFirstCipher(cryptoInfo->ea);
; 1069 : 					 cipher != 0;
; 1070 : 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))

  00043	8b 06		 mov	 eax, DWORD PTR [esi]
  00045	c1 e0 05	 shl	 eax, 5
  00048	8b b8 00 00 00
	00		 mov	 edi, DWORD PTR _EncryptionAlgorithms[eax]
  0004e	eb 34		 jmp	 SHORT $LN33@EncryptBuf
$LL30@EncryptBuf:

; 1071 : 				 {
; 1072 : 					 EncryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00050	57		 push	 edi
  00051	ff 75 fc	 push	 DWORD PTR _ks2$26015[ebp]
  00054	8d 45 f4	 lea	 eax, DWORD PTR _dataUnitNo$26016[ebp]
  00057	ff 75 14	 push	 DWORD PTR _ks$26014[ebp]
  0005a	6a 00		 push	 0
  0005c	50		 push	 eax
  0005d	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  00060	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00063	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00066	e8 00 00 00 00	 call	 _EncryptBufferXTS8Byte@32

; 1073 : 
; 1074 : 					 ks += CipherGetKeyScheduleSize(cipher);

  0006b	57		 push	 edi
  0006c	e8 00 00 00 00	 call	 _CipherGet@4
  00071	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00074	01 45 14	 add	 DWORD PTR _ks$26014[ebp], eax

; 1075 : 					 ks2 += CipherGetKeyScheduleSize(cipher);

  00077	01 45 fc	 add	 DWORD PTR _ks2$26015[ebp], eax
  0007a	57		 push	 edi
  0007b	ff 36		 push	 DWORD PTR [esi]
  0007d	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  00082	8b f8		 mov	 edi, eax
$LN33@EncryptBuf:

; 1067 : 
; 1068 : 				 for (cipher = EAGetFirstCipher(cryptoInfo->ea);
; 1069 : 					 cipher != 0;
; 1070 : 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))

  00084	85 ff		 test	 edi, edi
  00086	75 c8		 jne	 SHORT $LL30@EncryptBuf

; 1076 : 				 }
; 1077 : 		}
; 1078 : 		break;

  00088	eb 5c		 jmp	 SHORT $LN6@EncryptBuf
$LN9@EncryptBuf:

; 1030 : 	{
; 1031 : 	case XTS:
; 1032 : 		{
; 1033 : 			unsigned __int8 *ks = cryptoInfo->ks;
; 1034 : 			unsigned __int8 *ks2 = cryptoInfo->ks2;
; 1035 : 			UINT64_STRUCT dataUnitNo;
; 1036 : 			int cipher;
; 1037 : 
; 1038 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1039 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1040 : 			// always assumed to be aligned with the start of a data unit.
; 1041 : 			dataUnitNo.LowPart = 0;

  0008a	83 65 f4 00	 and	 DWORD PTR _dataUnitNo$26008[ebp], 0

; 1042 : 			dataUnitNo.HighPart = 0;

  0008e	83 65 f8 00	 and	 DWORD PTR _dataUnitNo$26008[ebp+4], 0
  00092	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00095	89 45 14	 mov	 DWORD PTR _ks$26006[ebp], eax
  00098	8d 86 28 02 00
	00		 lea	 eax, DWORD PTR [esi+552]
  0009e	89 45 fc	 mov	 DWORD PTR _ks2$26007[ebp], eax

; 1043 : 
; 1044 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1045 : 				cipher != 0;
; 1046 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  000a1	8b 06		 mov	 eax, DWORD PTR [esi]
  000a3	c1 e0 05	 shl	 eax, 5
  000a6	8b b8 00 00 00
	00		 mov	 edi, DWORD PTR _EncryptionAlgorithms[eax]
  000ac	eb 34		 jmp	 SHORT $LN34@EncryptBuf
$LL31@EncryptBuf:

; 1047 : 			{
; 1048 : 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  000ae	57		 push	 edi
  000af	ff 75 fc	 push	 DWORD PTR _ks2$26007[ebp]
  000b2	8d 45 f4	 lea	 eax, DWORD PTR _dataUnitNo$26008[ebp]
  000b5	ff 75 14	 push	 DWORD PTR _ks$26006[ebp]
  000b8	6a 00		 push	 0
  000ba	50		 push	 eax
  000bb	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  000be	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  000c1	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  000c4	e8 00 00 00 00	 call	 _EncryptBufferXTS@32

; 1049 : 
; 1050 : 				ks += CipherGetKeyScheduleSize (cipher);

  000c9	57		 push	 edi
  000ca	e8 00 00 00 00	 call	 _CipherGet@4
  000cf	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000d2	01 45 14	 add	 DWORD PTR _ks$26006[ebp], eax

; 1051 : 				ks2 += CipherGetKeyScheduleSize (cipher);

  000d5	01 45 fc	 add	 DWORD PTR _ks2$26007[ebp], eax
  000d8	57		 push	 edi
  000d9	ff 36		 push	 DWORD PTR [esi]
  000db	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  000e0	8b f8		 mov	 edi, eax
$LN34@EncryptBuf:

; 1043 : 
; 1044 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1045 : 				cipher != 0;
; 1046 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  000e2	85 ff		 test	 edi, edi
  000e4	75 c8		 jne	 SHORT $LL31@EncryptBuf
$LN6@EncryptBuf:
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi

; 1083 : 	}
; 1084 : }

  000e8	c9		 leave
  000e9	c2 10 00	 ret	 16			; 00000010H
$LN32@EncryptBuf:
_EncryptBuffer@16 ENDP
_TEXT	ENDS
PUBLIC	_EncryptDataUnits@16
EXTRN	_EncryptionThreadPoolDoWork@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptDataUnits@16
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 4
_ci$ = 20						; size = 4
_EncryptDataUnits@16 PROC				; COMDAT

; 1101 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1102 : 	EncryptionThreadPoolDoWork (EncryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00005	ff 75 14	 push	 DWORD PTR _ci$[ebp]
  00008	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00011	6a 00		 push	 0
  00013	e8 00 00 00 00	 call	 _EncryptionThreadPoolDoWork@20

; 1103 : }

  00018	5d		 pop	 ebp
  00019	c2 10 00	 ret	 16			; 00000010H
_EncryptDataUnits@16 ENDP
_TEXT	ENDS
PUBLIC	_EncryptDataUnitsCurrentThread@20
EXTRN	__allmul:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptDataUnitsCurrentThread@20
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
tv204 = 16						; size = 8
_nbrUnits$ = 16						; size = 8
_ea$ = 24						; size = 4
_ci$ = 24						; size = 4
_EncryptDataUnitsCurrentThread@20 PROC			; COMDAT

; 1118 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1119 : 	int ea = ci->ea;

  00005	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 1120 : 	unsigned __int8 *ks = ci->ks;

  0000d	8d 78 08	 lea	 edi, DWORD PTR [eax+8]

; 1121 : 	unsigned __int8 *ks2 = ci->ks2;

  00010	8d 98 28 02 00
	00		 lea	 ebx, DWORD PTR [eax+552]

; 1122 : 	int cipher;
; 1123 : 
; 1124 : 	switch (ci->mode)

  00016	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00019	48		 dec	 eax
  0001a	89 4d 18	 mov	 DWORD PTR _ea$[ebp], ecx
  0001d	74 76		 je	 SHORT $LN9@EncryptDat
  0001f	48		 dec	 eax
  00020	74 16		 je	 SHORT $LN5@EncryptDat

; 1156 : 	default:		
; 1157 : 		// Unknown/wrong ID
; 1158 : 		GST_THROW_FATAL_EXCEPTION;

  00022	68 54 53 47 00	 push	 4674388			; 00475354H
  00027	6a 00		 push	 0
  00029	6a 00		 push	 0
  0002b	68 86 04 00 00	 push	 1158			; 00000486H
  00030	6a 29		 push	 41			; 00000029H
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN33@EncryptDat:
$LN5@EncryptDat:

; 1139 : 		}
; 1140 : 		break;
; 1141 : 	case XTS8:
; 1142 : 		for (cipher = EAGetFirstCipher(ea); cipher != 0; cipher = EAGetNextCipher(ea, cipher))

  00038	c1 e1 05	 shl	 ecx, 5
  0003b	8b b1 00 00 00
	00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[ecx]
  00041	85 f6		 test	 esi, esi
  00043	0f 84 a3 00 00
	00		 je	 $LN6@EncryptDat
  00049	6a 00		 push	 0
  0004b	68 00 02 00 00	 push	 512			; 00000200H
  00050	ff 75 14	 push	 DWORD PTR _nbrUnits$[ebp+4]
  00053	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  00056	e8 00 00 00 00	 call	 __allmul
  0005b	89 45 10	 mov	 DWORD PTR tv204[ebp], eax
  0005e	89 55 14	 mov	 DWORD PTR tv204[ebp+4], edx
$LL30@EncryptDat:

; 1143 : 		{
; 1144 : 			EncryptBufferXTS8Byte(buf,
; 1145 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1146 : 				structUnitNo,
; 1147 : 				0,
; 1148 : 				ks,
; 1149 : 				ks2,
; 1150 : 				cipher);

  00061	56		 push	 esi
  00062	53		 push	 ebx
  00063	57		 push	 edi
  00064	6a 00		 push	 0
  00066	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  00069	ff 75 14	 push	 DWORD PTR tv204[ebp+4]
  0006c	ff 75 10	 push	 DWORD PTR tv204[ebp]
  0006f	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00072	e8 00 00 00 00	 call	 _EncryptBufferXTS8Byte@32

; 1151 : 
; 1152 : 			ks += CipherGetKeyScheduleSize(cipher);

  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 _CipherGet@4
  0007d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00080	56		 push	 esi
  00081	ff 75 18	 push	 DWORD PTR _ea$[ebp]
  00084	03 f8		 add	 edi, eax

; 1153 : 			ks2 += CipherGetKeyScheduleSize(cipher);

  00086	03 d8		 add	 ebx, eax
  00088	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0008d	8b f0		 mov	 esi, eax
  0008f	85 f6		 test	 esi, esi
  00091	75 ce		 jne	 SHORT $LL30@EncryptDat

; 1154 : 		}
; 1155 : 		break;

  00093	eb 57		 jmp	 SHORT $LN6@EncryptDat
$LN9@EncryptDat:

; 1125 : 	{
; 1126 : 	case XTS:
; 1127 : 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  00095	c1 e1 05	 shl	 ecx, 5
  00098	8b b1 00 00 00
	00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[ecx]
  0009e	85 f6		 test	 esi, esi
  000a0	74 4a		 je	 SHORT $LN6@EncryptDat
  000a2	6a 00		 push	 0
  000a4	68 00 02 00 00	 push	 512			; 00000200H
  000a9	ff 75 14	 push	 DWORD PTR _nbrUnits$[ebp+4]
  000ac	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  000af	e8 00 00 00 00	 call	 __allmul
  000b4	89 45 10	 mov	 DWORD PTR tv204[ebp], eax
  000b7	89 55 14	 mov	 DWORD PTR tv204[ebp+4], edx
$LL31@EncryptDat:

; 1128 : 		{
; 1129 : 			EncryptBufferXTS (buf,
; 1130 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1131 : 				structUnitNo,
; 1132 : 				0,
; 1133 : 				ks,
; 1134 : 				ks2,
; 1135 : 				cipher);

  000ba	56		 push	 esi
  000bb	53		 push	 ebx
  000bc	57		 push	 edi
  000bd	6a 00		 push	 0
  000bf	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  000c2	ff 75 14	 push	 DWORD PTR tv204[ebp+4]
  000c5	ff 75 10	 push	 DWORD PTR tv204[ebp]
  000c8	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  000cb	e8 00 00 00 00	 call	 _EncryptBufferXTS@32

; 1136 : 
; 1137 : 			ks += CipherGetKeyScheduleSize (cipher);

  000d0	56		 push	 esi
  000d1	e8 00 00 00 00	 call	 _CipherGet@4
  000d6	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000d9	56		 push	 esi
  000da	ff 75 18	 push	 DWORD PTR _ea$[ebp]
  000dd	03 f8		 add	 edi, eax

; 1138 : 			ks2 += CipherGetKeyScheduleSize (cipher);

  000df	03 d8		 add	 ebx, eax
  000e1	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  000e6	8b f0		 mov	 esi, eax
  000e8	85 f6		 test	 esi, esi
  000ea	75 ce		 jne	 SHORT $LL31@EncryptDat
$LN6@EncryptDat:
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx

; 1159 : 	}
; 1160 : }

  000ef	5d		 pop	 ebp
  000f0	c2 14 00	 ret	 20			; 00000014H
$LN32@EncryptDat:
_EncryptDataUnitsCurrentThread@20 ENDP
_TEXT	ENDS
PUBLIC	_DecryptDataUnits@16
; Function compile flags: /Ogsp
;	COMDAT _DecryptDataUnits@16
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 4
_ci$ = 20						; size = 4
_DecryptDataUnits@16 PROC				; COMDAT

; 1246 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1247 : 	EncryptionThreadPoolDoWork (DecryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00005	ff 75 14	 push	 DWORD PTR _ci$[ebp]
  00008	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00011	6a 01		 push	 1
  00013	e8 00 00 00 00	 call	 _EncryptionThreadPoolDoWork@20

; 1248 : }

  00018	5d		 pop	 ebp
  00019	c2 10 00	 ret	 16			; 00000010H
_DecryptDataUnits@16 ENDP
_TEXT	ENDS
PUBLIC	_IsAesHwCpuSupported@0
; Function compile flags: /Ogsp
;	COMDAT _IsAesHwCpuSupported@0
_TEXT	SEGMENT
_IsAesHwCpuSupported@0 PROC				; COMDAT

; 1584 : 	static BOOL state = FALSE;
; 1585 : 	static BOOL stateValid = FALSE;
; 1586 : 
; 1587 : 	if (!stateValid)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, 0
  00007	75 11		 jne	 SHORT $LN1@IsAesHwCpu

; 1588 : 	{
; 1589 : 		state = FALSE;//state = is_aes_hw_cpu_supported() ? TRUE : FALSE;

  00009	83 25 00 00 00
	00 00		 and	 DWORD PTR ?state@?1??IsAesHwCpuSupported@@9@9, 0

; 1590 : 		stateValid = TRUE;

  00010	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, 1
$LN1@IsAesHwCpu:

; 1591 : 	}
; 1592 : 
; 1593 : 	return FALSE;//state && !HwEncryptionDisabled;

  0001a	33 c0		 xor	 eax, eax

; 1594 : }

  0001c	c3		 ret	 0
_IsAesHwCpuSupported@0 ENDP
_TEXT	ENDS
PUBLIC	_EnableHwEncryption@4
; Function compile flags: /Ogsp
;	COMDAT _EnableHwEncryption@4
_TEXT	SEGMENT
_enable$ = 8						; size = 4
_EnableHwEncryption@4 PROC				; COMDAT

; 1606 : 	//Deprecated
; 1607 : }

  00000	c2 04 00	 ret	 4
_EnableHwEncryption@4 ENDP
_TEXT	ENDS
PUBLIC	_IsHwEncryptionEnabled@0
; Function compile flags: /Ogsp
;	COMDAT _IsHwEncryptionEnabled@0
_TEXT	SEGMENT
_IsHwEncryptionEnabled@0 PROC				; COMDAT

; 1618 : 	return !HwEncryptionDisabled;

  00000	33 c0		 xor	 eax, eax
  00002	39 05 00 00 00
	00		 cmp	 DWORD PTR _HwEncryptionDisabled, eax
  00008	0f 94 c0	 sete	 al

; 1619 : }

  0000b	c3		 ret	 0
_IsHwEncryptionEnabled@0 ENDP
_TEXT	ENDS
PUBLIC	_EncipherBlocks@16
; Function compile flags: /Ogsp
;	COMDAT _EncipherBlocks@16
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_ks$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_EncipherBlocks@16 PROC					; COMDAT

; 167  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 168  : 	byte *data = dataPtr;

  00006	8b 75 0c	 mov	 esi, DWORD PTR _dataPtr$[ebp]
  00009	57		 push	 edi

; 169  : 	size_t blockSize = CipherGetBlockSize (cipher);

  0000a	ff 75 08	 push	 DWORD PTR _cipher$[ebp]
  0000d	e8 00 00 00 00	 call	 _CipherGet@4
  00012	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00015	eb 11		 jmp	 SHORT $LN10@EncipherBl@2
$LL2@EncipherBl@2:

; 171  : 	{
; 172  : 		EncipherBlock (cipher, data, ks);

  00017	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  0001a	ff 4d 14	 dec	 DWORD PTR _blockCount$[ebp]
  0001d	56		 push	 esi
  0001e	ff 75 08	 push	 DWORD PTR _cipher$[ebp]
  00021	e8 00 00 00 00	 call	 _EncipherBlock@12

; 173  : 		data += blockSize;

  00026	03 f7		 add	 esi, edi
$LN10@EncipherBl@2:

; 170  : 	while (blockCount-- > 0)

  00028	83 7d 14 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  0002c	77 e9		 ja	 SHORT $LL2@EncipherBl@2
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 174  : 	}
; 175  : }

  00030	5d		 pop	 ebp
  00031	c2 10 00	 ret	 16			; 00000010H
_EncipherBlocks@16 ENDP
_TEXT	ENDS
PUBLIC	_DecipherBlocks@16
; Function compile flags: /Ogsp
;	COMDAT _DecipherBlocks@16
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_ks$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_DecipherBlocks@16 PROC					; COMDAT

; 217  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 218  : 	byte *data = dataPtr;

  00006	8b 75 0c	 mov	 esi, DWORD PTR _dataPtr$[ebp]
  00009	57		 push	 edi

; 219  : 	size_t blockSize = CipherGetBlockSize (cipher);

  0000a	ff 75 08	 push	 DWORD PTR _cipher$[ebp]
  0000d	e8 00 00 00 00	 call	 _CipherGet@4
  00012	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00015	eb 11		 jmp	 SHORT $LN10@DecipherBl@2
$LL2@DecipherBl@2:

; 221  : 	{
; 222  : 		DecipherBlock (cipher, data, ks);

  00017	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  0001a	ff 4d 14	 dec	 DWORD PTR _blockCount$[ebp]
  0001d	56		 push	 esi
  0001e	ff 75 08	 push	 DWORD PTR _cipher$[ebp]
  00021	e8 00 00 00 00	 call	 _DecipherBlock@12

; 223  : 		data += blockSize;

  00026	03 f7		 add	 esi, edi
$LN10@DecipherBl@2:

; 220  : 	while (blockCount-- > 0)

  00028	83 7d 14 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  0002c	77 e9		 ja	 SHORT $LL2@DecipherBl@2
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 224  : 	}
; 225  : }

  00030	5d		 pop	 ebp
  00031	c2 10 00	 ret	 16			; 00000010H
_DecipherBlocks@16 ENDP
_TEXT	ENDS
PUBLIC	_EAGetCount@0
; Function compile flags: /Ogsp
;	COMDAT _EAGetCount@0
_TEXT	SEGMENT
_EAGetCount@0 PROC					; COMDAT

; 375  : 	int ea, count = 0;
; 376  : 
; 377  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00000	33 c0		 xor	 eax, eax
  00002	33 d2		 xor	 edx, edx
  00004	40		 inc	 eax
$LL3@EAGetCount:
  00005	50		 push	 eax

; 378  : 	{
; 379  : 		count++;

  00006	42		 inc	 edx
  00007	e8 00 00 00 00	 call	 _EAGetNext@4
  0000c	85 c0		 test	 eax, eax
  0000e	75 f5		 jne	 SHORT $LL3@EAGetCount

; 380  : 	}
; 381  : 	return count;

  00010	8b c2		 mov	 eax, edx

; 382  : }

  00012	c3		 ret	 0
_EAGetCount@0 ENDP
_TEXT	ENDS
PUBLIC	_EAInit@12
; Function compile flags: /Ogsp
;	COMDAT _EAInit@12
_TEXT	SEGMENT
_retVal$ = -4						; size = 4
_ea$ = 8						; size = 4
_key$ = 12						; size = 4
_ks$ = 16						; size = 4
_EAInit@12 PROC						; COMDAT

; 414  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 415  : 	int c, retVal = ERR_SUCCESS;

  00006	83 65 fc 00	 and	 DWORD PTR _retVal$[ebp], 0

; 416  : 
; 417  : 	if (ea == 0)

  0000a	83 7d 08 00	 cmp	 DWORD PTR _ea$[ebp], 0
  0000e	75 05		 jne	 SHORT $LN8@EAInit

; 418  : 		return ERR_CIPHER_INIT_FAILURE;

  00010	6a 11		 push	 17			; 00000011H
  00012	58		 pop	 eax
  00013	eb 51		 jmp	 SHORT $LN9@EAInit
$LN8@EAInit:

; 419  : 
; 420  : 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))

  00015	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00018	53		 push	 ebx
  00019	c1 e0 05	 shl	 eax, 5
  0001c	8b 98 00 00 00
	00		 mov	 ebx, DWORD PTR _EncryptionAlgorithms[eax]
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	85 db		 test	 ebx, ebx
  00026	74 38		 je	 SHORT $LN5@EAInit
  00028	8b 7d 10	 mov	 edi, DWORD PTR _ks$[ebp]
  0002b	8b 75 0c	 mov	 esi, DWORD PTR _key$[ebp]
$LL7@EAInit:

; 421  : 	{
; 422  : 		switch (CipherInit (c, key, ks))

  0002e	57		 push	 edi
  0002f	56		 push	 esi
  00030	53		 push	 ebx
  00031	e8 00 00 00 00	 call	 _CipherInit@12
  00036	83 e8 11	 sub	 eax, 17			; 00000011H
  00039	74 2f		 je	 SHORT $LN2@EAInit
  0003b	48		 dec	 eax
  0003c	75 07		 jne	 SHORT $LN3@EAInit

; 426  : 
; 427  : 		case ERR_CIPHER_INIT_WEAK_KEY:
; 428  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  0003e	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 18 ; 00000012H
$LN3@EAInit:

; 429  : 			break;
; 430  : 		}
; 431  : 
; 432  : 		key += CipherGetKeySize (c);

  00045	53		 push	 ebx
  00046	e8 00 00 00 00	 call	 _CipherGet@4
  0004b	03 70 0c	 add	 esi, DWORD PTR [eax+12]

; 433  : 		ks += CipherGetKeyScheduleSize (c);

  0004e	03 78 10	 add	 edi, DWORD PTR [eax+16]
  00051	53		 push	 ebx
  00052	ff 75 08	 push	 DWORD PTR _ea$[ebp]
  00055	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0005a	8b d8		 mov	 ebx, eax
  0005c	85 db		 test	 ebx, ebx
  0005e	75 ce		 jne	 SHORT $LL7@EAInit
$LN5@EAInit:

; 434  : 	}
; 435  : 	return retVal;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _retVal$[ebp]
$LN19@EAInit:
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
$LN9@EAInit:

; 436  : }

  00066	c9		 leave
  00067	c2 0c 00	 ret	 12			; 0000000cH
$LN2@EAInit:

; 423  : 		{
; 424  : 		case ERR_CIPHER_INIT_FAILURE:
; 425  : 			return ERR_CIPHER_INIT_FAILURE;

  0006a	6a 11		 push	 17			; 00000011H
  0006c	58		 pop	 eax
  0006d	eb f4		 jmp	 SHORT $LN19@EAInit
_EAInit@12 ENDP
_TEXT	ENDS
PUBLIC	_EAInitMode@4
; Function compile flags: /Ogsp
;	COMDAT _EAInitMode@4
_TEXT	SEGMENT
_ci$ = 8						; size = 4
_EAInitMode@4 PROC					; COMDAT

; 452  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 453  : 	switch (ci->mode)

  00005	8b 45 08	 mov	 eax, DWORD PTR _ci$[ebp]
  00008	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000b	49		 dec	 ecx
  0000c	74 19		 je	 SHORT $LN5@EAInitMode
  0000e	49		 dec	 ecx
  0000f	74 16		 je	 SHORT $LN5@EAInitMode

; 459  : 
; 460  : 		/* Note: XTS mode could potentially be initialized with a weak key causing all blocks in one data unit
; 461  : 		on the volume to be tweaked with zero tweaks (i.e. 512 bytes of the volume would be encrypted in ECB
; 462  : 		mode). However, to create a GostCrypt volume with such a weak key, each human being on Earth would have
; 463  : 		to create approximately 11,378,125,361,078,862 (about eleven quadrillion) GostCrypt volumes (provided 
; 464  : 		that the size of each of the volumes is 1024 terabytes). */
; 465  : 		break;
; 466  : 	case XTS8:
; 467  : 		if (EAInit(ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)
; 468  : 			return FALSE;
; 469  : 		break;
; 470  : 
; 471  : 	default:		
; 472  : 		// Unknown/wrong ID
; 473  : 		GST_THROW_FATAL_EXCEPTION;

  00011	68 54 53 47 00	 push	 4674388			; 00475354H
  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	68 d9 01 00 00	 push	 473			; 000001d9H
  0001f	6a 29		 push	 41			; 00000029H
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN11@EAInitMode:
$LN5@EAInitMode:

; 454  : 	{
; 455  : 	case XTS:
; 456  : 		// Secondary key schedule
; 457  : 		if (EAInit (ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)

  00027	8d 88 28 02 00
	00		 lea	 ecx, DWORD PTR [eax+552]
  0002d	51		 push	 ecx
  0002e	8d 88 50 1d 00
	00		 lea	 ecx, DWORD PTR [eax+7504]
  00034	51		 push	 ecx
  00035	ff 30		 push	 DWORD PTR [eax]
  00037	e8 00 00 00 00	 call	 _EAInit@12
  0003c	85 c0		 test	 eax, eax
  0003e	74 04		 je	 SHORT $LN4@EAInitMode

; 458  : 			return FALSE;

  00040	33 c0		 xor	 eax, eax
  00042	eb 03		 jmp	 SHORT $LN8@EAInitMode
$LN4@EAInitMode:

; 474  : 	}
; 475  : 	return TRUE;

  00044	33 c0		 xor	 eax, eax
  00046	40		 inc	 eax
$LN8@EAInitMode:

; 476  : }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN10@EAInitMode:
_EAInitMode@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	_EAGetName@8
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@ DB '-', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@ DB '?', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _EAGetName@8
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_ea$ = 12						; size = 4
_EAGetName@8 PROC					; COMDAT

; 489  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx
  00006	56		 push	 esi

; 490  : 	int i = EAGetLastCipher(ea);

  00007	ff 75 0c	 push	 DWORD PTR _ea$[ebp]
  0000a	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  0000f	8b f0		 mov	 esi, eax

; 491  : 	strcpy (buf, (i != 0) ? CipherGetName (i) : "?");

  00011	85 f6		 test	 esi, esi
  00013	74 0b		 je	 SHORT $LN5@EAGetName
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _CipherGet@4
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	eb 05		 jmp	 SHORT $LN6@EAGetName
$LN5@EAGetName:
  00020	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
$LN6@EAGetName:
  00025	8b 5d 08	 mov	 ebx, DWORD PTR _buf$[ebp]
  00028	8b c8		 mov	 ecx, eax
  0002a	8b d3		 mov	 edx, ebx
$LL7@EAGetName:
  0002c	8a 01		 mov	 al, BYTE PTR [ecx]
  0002e	41		 inc	 ecx
  0002f	88 02		 mov	 BYTE PTR [edx], al
  00031	42		 inc	 edx
  00032	84 c0		 test	 al, al
  00034	75 f6		 jne	 SHORT $LL7@EAGetName

; 492  : 
; 493  : 	while (i = EAGetPreviousCipher(ea, i))

  00036	56		 push	 esi
  00037	ff 75 0c	 push	 DWORD PTR _ea$[ebp]
  0003a	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  0003f	8b d0		 mov	 edx, eax
  00041	85 d2		 test	 edx, edx
  00043	74 50		 je	 SHORT $LN1@EAGetName
  00045	57		 push	 edi
$LL2@EAGetName:

; 494  : 	{
; 495  : 		strcat (buf, "-");

  00046	8b fb		 mov	 edi, ebx
  00048	4f		 dec	 edi
$LL16@EAGetName:
  00049	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0004c	47		 inc	 edi
  0004d	84 c0		 test	 al, al
  0004f	75 f8		 jne	 SHORT $LL16@EAGetName
  00051	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@

; 496  : 		strcat (buf, CipherGetName (i));

  00056	52		 push	 edx
  00057	66 a5		 movsw
  00059	e8 00 00 00 00	 call	 _CipherGet@4
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b f0		 mov	 esi, eax
$LL17@EAGetName:
  00063	8a 08		 mov	 cl, BYTE PTR [eax]
  00065	40		 inc	 eax
  00066	84 c9		 test	 cl, cl
  00068	75 f9		 jne	 SHORT $LL17@EAGetName
  0006a	8b fb		 mov	 edi, ebx
  0006c	2b c6		 sub	 eax, esi
  0006e	4f		 dec	 edi
$LL18@EAGetName:
  0006f	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00072	47		 inc	 edi
  00073	84 c9		 test	 cl, cl
  00075	75 f8		 jne	 SHORT $LL18@EAGetName
  00077	8b c8		 mov	 ecx, eax
  00079	c1 e9 02	 shr	 ecx, 2
  0007c	f3 a5		 rep movsd
  0007e	8b c8		 mov	 ecx, eax
  00080	52		 push	 edx
  00081	ff 75 0c	 push	 DWORD PTR _ea$[ebp]
  00084	83 e1 03	 and	 ecx, 3
  00087	f3 a4		 rep movsb
  00089	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  0008e	8b d0		 mov	 edx, eax
  00090	85 d2		 test	 edx, edx
  00092	75 b2		 jne	 SHORT $LL2@EAGetName
  00094	5f		 pop	 edi
$LN1@EAGetName:
  00095	5e		 pop	 esi

; 497  : 	}
; 498  : 
; 499  : 	return buf;

  00096	8b c3		 mov	 eax, ebx
  00098	5b		 pop	 ebx

; 500  : }

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
_EAGetName@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_EAGetByName@4
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _EAGetByName@4
_TEXT	SEGMENT
_n$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_EAGetByName@4 PROC					; COMDAT

; 513  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi

; 514  : 	int ea = EAGetFirst ();

  00016	33 f6		 xor	 esi, esi
  00018	46		 inc	 esi
$LL4@EAGetByNam:

; 515  : 	char n[128];
; 516  : 
; 517  : 	do
; 518  : 	{
; 519  : 		EAGetName (n, ea);

  00019	56		 push	 esi
  0001a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _EAGetName@8

; 520  : 		if (strcmp (n, name) == 0)

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  00029	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
$LL12@EAGetByNam:
  0002f	8a 10		 mov	 dl, BYTE PTR [eax]
  00031	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00033	75 18		 jne	 SHORT $LN13@EAGetByNam
  00035	84 d2		 test	 dl, dl
  00037	74 10		 je	 SHORT $LN14@EAGetByNam
  00039	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003c	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  0003f	75 0c		 jne	 SHORT $LN13@EAGetByNam
  00041	40		 inc	 eax
  00042	40		 inc	 eax
  00043	41		 inc	 ecx
  00044	41		 inc	 ecx
  00045	84 d2		 test	 dl, dl
  00047	75 e6		 jne	 SHORT $LL12@EAGetByNam
$LN14@EAGetByNam:
  00049	33 c0		 xor	 eax, eax
  0004b	eb 05		 jmp	 SHORT $LN15@EAGetByNam
$LN13@EAGetByNam:
  0004d	1b c0		 sbb	 eax, eax
  0004f	83 d8 ff	 sbb	 eax, -1
$LN15@EAGetByNam:
  00052	85 c0		 test	 eax, eax
  00054	74 1b		 je	 SHORT $LN10@EAGetByNam

; 522  : 	}
; 523  : 	while (ea = EAGetNext (ea));

  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 _EAGetNext@4
  0005c	8b f0		 mov	 esi, eax
  0005e	85 f6		 test	 esi, esi
  00060	75 b7		 jne	 SHORT $LL4@EAGetByNam
$LN5@EAGetByNam:

; 524  : 
; 525  : 	return 0;
; 526  : }

  00062	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00065	33 cd		 xor	 ecx, ebp
  00067	5e		 pop	 esi
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	c9		 leave
  0006e	c2 04 00	 ret	 4
$LN10@EAGetByNam:

; 521  : 			return ea;

  00071	8b c6		 mov	 eax, esi
  00073	eb ed		 jmp	 SHORT $LN5@EAGetByNam
_EAGetByName@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetKeySize@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetKeySize@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetKeySize@4 PROC					; COMDAT

; 540  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 541  : 	int i = EAGetFirstCipher (ea);

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	c1 e0 05	 shl	 eax, 5
  0000b	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax]
  00011	56		 push	 esi

; 542  : 	int size = CipherGetKeySize (i);

  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 _CipherGet@4
  00018	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 543  : 
; 544  : 	while (i = EAGetNextCipher (ea, i))

  0001b	eb 09		 jmp	 SHORT $LN14@EAGetKeySi
$LL2@EAGetKeySi:

; 545  : 	{
; 546  : 		size += CipherGetKeySize (i);

  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _CipherGet@4
  00023	03 70 0c	 add	 esi, DWORD PTR [eax+12]
$LN14@EAGetKeySi:
  00026	52		 push	 edx
  00027	ff 75 08	 push	 DWORD PTR _ea$[ebp]
  0002a	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0002f	8b d0		 mov	 edx, eax
  00031	85 d2		 test	 edx, edx
  00033	75 e8		 jne	 SHORT $LL2@EAGetKeySi

; 547  : 	}
; 548  : 
; 549  : 	return size;

  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 550  : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
_EAGetKeySize@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetKeyScheduleSize@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetKeyScheduleSize@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetKeyScheduleSize@4 PROC				; COMDAT

; 627  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 628  : 	int i = EAGetFirstCipher(ea);

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	c1 e0 05	 shl	 eax, 5
  0000b	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax]
  00011	56		 push	 esi

; 629  : 	int size = CipherGetKeyScheduleSize (i);

  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 _CipherGet@4
  00018	8b 70 10	 mov	 esi, DWORD PTR [eax+16]

; 630  : 
; 631  : 	while (i = EAGetNextCipher(ea, i))

  0001b	eb 09		 jmp	 SHORT $LN14@EAGetKeySc
$LL2@EAGetKeySc:

; 632  : 	{
; 633  : 		size += CipherGetKeyScheduleSize (i);

  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _CipherGet@4
  00023	03 70 10	 add	 esi, DWORD PTR [eax+16]
$LN14@EAGetKeySc:
  00026	52		 push	 edx
  00027	ff 75 08	 push	 DWORD PTR _ea$[ebp]
  0002a	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0002f	8b d0		 mov	 edx, eax
  00031	85 d2		 test	 edx, edx
  00033	75 e8		 jne	 SHORT $LL2@EAGetKeySc

; 634  : 	}
; 635  : 
; 636  : 	return size;

  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 637  : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
_EAGetKeyScheduleSize@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetLargestKeyForMode@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetLargestKeyForMode@4
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_EAGetLargestKeyForMode@4 PROC				; COMDAT

; 648  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 649  : 	int ea, key = 0;
; 650  : 
; 651  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00007	33 f6		 xor	 esi, esi
  00009	33 ff		 xor	 edi, edi
  0000b	46		 inc	 esi
$LL5@EAGetLarge:

; 652  : 	{
; 653  : 		if (!EAIsModeSupported (ea, mode))

  0000c	ff 75 08	 push	 DWORD PTR _mode$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _EAIsModeSupported@8
  00015	85 c0		 test	 eax, eax
  00017	74 12		 je	 SHORT $LN4@EAGetLarge

; 654  : 			continue;
; 655  : 
; 656  : 		if (EAGetKeySize (ea) >= key)

  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 _EAGetKeySize@4
  0001f	3b c7		 cmp	 eax, edi
  00021	7c 08		 jl	 SHORT $LN4@EAGetLarge

; 657  : 			key = EAGetKeySize (ea);

  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00029	8b f8		 mov	 edi, eax
$LN4@EAGetLarge:
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 _EAGetNext@4
  00031	8b f0		 mov	 esi, eax
  00033	85 f6		 test	 esi, esi
  00035	75 d5		 jne	 SHORT $LL5@EAGetLarge

; 658  : 	}
; 659  : 	return key;

  00037	8b c7		 mov	 eax, edi
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi

; 660  : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
_EAGetLargestKeyForMode@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetLargestKey@0
; Function compile flags: /Ogsp
;	COMDAT _EAGetLargestKey@0
_TEXT	SEGMENT
_EAGetLargestKey@0 PROC					; COMDAT

; 670  : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	57		 push	 edi

; 671  : 	int ea, key = 0;
; 672  : 
; 673  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00004	33 f6		 xor	 esi, esi
  00006	33 ff		 xor	 edi, edi
  00008	46		 inc	 esi
$LL4@EAGetLarge@2:

; 674  : 	{
; 675  : 		if (EAGetKeySize (ea) >= key)

  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 _EAGetKeySize@4
  0000f	3b c7		 cmp	 eax, edi
  00011	7c 08		 jl	 SHORT $LN3@EAGetLarge@2

; 676  : 			key = EAGetKeySize (ea);

  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00019	8b f8		 mov	 edi, eax
$LN3@EAGetLarge@2:
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 _EAGetNext@4
  00021	8b f0		 mov	 esi, eax
  00023	85 f6		 test	 esi, esi
  00025	75 e2		 jne	 SHORT $LL4@EAGetLarge@2

; 677  : 	}
; 678  : 
; 679  : 	return key;

  00027	8b c7		 mov	 eax, edi
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 680  : }

  0002b	c3		 ret	 0
_EAGetLargestKey@0 ENDP
_TEXT	ENDS
PUBLIC	_DecryptBuffer@16
EXTRN	_DecryptBufferXTS@32:PROC
EXTRN	_DecryptBufferXTS8Byte@32:PROC
; Function compile flags: /Ogsp
;	COMDAT _DecryptBuffer@16
_TEXT	SEGMENT
_dataUnitNo$26081 = -12					; size = 8
_dataUnitNo$26073 = -12					; size = 8
_ks$26079 = -4						; size = 4
_ks$26071 = -4						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 8
_ks2$26080 = 20						; size = 4
_ks2$26072 = 20						; size = 4
_cryptoInfo$ = 20					; size = 4
_DecryptBuffer@16 PROC					; COMDAT

; 1174 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	56		 push	 esi

; 1175 : 	switch (cryptoInfo->mode)

  00009	8b 75 14	 mov	 esi, DWORD PTR _cryptoInfo$[ebp]
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	48		 dec	 eax
  00010	57		 push	 edi
  00011	0f 84 82 00 00
	00		 je	 $LN9@DecryptBuf
  00017	48		 dec	 eax
  00018	74 16		 je	 SHORT $LN5@DecryptBuf

; 1225 : 	default:		
; 1226 : 		// Unknown/wrong ID
; 1227 : 		GST_THROW_FATAL_EXCEPTION;

  0001a	68 54 53 47 00	 push	 4674388			; 00475354H
  0001f	6a 00		 push	 0
  00021	6a 00		 push	 0
  00023	68 cb 04 00 00	 push	 1227			; 000004cbH
  00028	6a 29		 push	 41			; 00000029H
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN31@DecryptBuf:
$LN5@DecryptBuf:

; 1198 : 			}
; 1199 : 		}
; 1200 : 		break;
; 1201 : 	case XTS8:
; 1202 : 	{
; 1203 : 				 unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize(cryptoInfo->ea);

  00030	8b 3e		 mov	 edi, DWORD PTR [esi]
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  00038	8d 44 30 08	 lea	 eax, DWORD PTR [eax+esi+8]

; 1204 : 				 unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize(cryptoInfo->ea);

  0003c	57		 push	 edi
  0003d	89 45 fc	 mov	 DWORD PTR _ks$26079[ebp], eax
  00040	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1205 : 				 UINT64_STRUCT dataUnitNo;
; 1206 : 				 int cipher;
; 1207 : 
; 1208 : 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1209 : 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1210 : 				 // always assumed to be aligned with the start of the data unit 0.
; 1211 : 				 dataUnitNo.LowPart = 0;

  00045	83 65 f4 00	 and	 DWORD PTR _dataUnitNo$26081[ebp], 0

; 1212 : 				 dataUnitNo.HighPart = 0;

  00049	83 65 f8 00	 and	 DWORD PTR _dataUnitNo$26081[ebp+4], 0
  0004d	8d 84 30 28 02
	00 00		 lea	 eax, DWORD PTR [eax+esi+552]

; 1213 : 
; 1214 : 				 for (cipher = EAGetLastCipher(cryptoInfo->ea);
; 1215 : 					 cipher != 0;
; 1216 : 					 cipher = EAGetPreviousCipher(cryptoInfo->ea, cipher))

  00054	57		 push	 edi
  00055	89 45 14	 mov	 DWORD PTR _ks2$26080[ebp], eax
  00058	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  0005d	eb 32		 jmp	 SHORT $LN28@DecryptBuf
$LL4@DecryptBuf:

; 1217 : 				 {
; 1218 : 					 ks -= CipherGetKeyScheduleSize(cipher);

  0005f	57		 push	 edi
  00060	e8 00 00 00 00	 call	 _CipherGet@4
  00065	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1219 : 					 ks2 -= CipherGetKeyScheduleSize(cipher);

  00068	29 45 14	 sub	 DWORD PTR _ks2$26080[ebp], eax
  0006b	29 45 fc	 sub	 DWORD PTR _ks$26079[ebp], eax

; 1220 : 
; 1221 : 					 DecryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  0006e	57		 push	 edi
  0006f	ff 75 14	 push	 DWORD PTR _ks2$26080[ebp]
  00072	8d 45 f4	 lea	 eax, DWORD PTR _dataUnitNo$26081[ebp]
  00075	ff 75 fc	 push	 DWORD PTR _ks$26079[ebp]
  00078	6a 00		 push	 0
  0007a	50		 push	 eax
  0007b	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  0007e	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00081	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00084	e8 00 00 00 00	 call	 _DecryptBufferXTS8Byte@32
  00089	57		 push	 edi
  0008a	ff 36		 push	 DWORD PTR [esi]
  0008c	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
$LN28@DecryptBuf:
  00091	8b f8		 mov	 edi, eax
  00093	85 ff		 test	 edi, edi
  00095	75 c8		 jne	 SHORT $LL4@DecryptBuf

; 1222 : 				 }
; 1223 : 	}
; 1224 : 		break;

  00097	eb 67		 jmp	 SHORT $LN6@DecryptBuf
$LN9@DecryptBuf:

; 1176 : 	{
; 1177 : 	case XTS:
; 1178 : 		{
; 1179 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  00099	8b 3e		 mov	 edi, DWORD PTR [esi]
  0009b	57		 push	 edi
  0009c	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  000a1	8d 44 30 08	 lea	 eax, DWORD PTR [eax+esi+8]

; 1180 : 			unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize (cryptoInfo->ea);

  000a5	57		 push	 edi
  000a6	89 45 fc	 mov	 DWORD PTR _ks$26071[ebp], eax
  000a9	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1181 : 			UINT64_STRUCT dataUnitNo;
; 1182 : 			int cipher;
; 1183 : 
; 1184 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1185 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1186 : 			// always assumed to be aligned with the start of the data unit 0.
; 1187 : 			dataUnitNo.LowPart = 0;

  000ae	83 65 f4 00	 and	 DWORD PTR _dataUnitNo$26073[ebp], 0

; 1188 : 			dataUnitNo.HighPart = 0;

  000b2	83 65 f8 00	 and	 DWORD PTR _dataUnitNo$26073[ebp+4], 0
  000b6	8d 84 30 28 02
	00 00		 lea	 eax, DWORD PTR [eax+esi+552]

; 1189 : 
; 1190 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 1191 : 				cipher != 0;
; 1192 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  000bd	57		 push	 edi
  000be	89 45 14	 mov	 DWORD PTR _ks2$26072[ebp], eax
  000c1	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  000c6	eb 32		 jmp	 SHORT $LN30@DecryptBuf
$LL8@DecryptBuf:

; 1193 : 			{
; 1194 : 				ks -= CipherGetKeyScheduleSize (cipher);

  000c8	57		 push	 edi
  000c9	e8 00 00 00 00	 call	 _CipherGet@4
  000ce	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1195 : 				ks2 -= CipherGetKeyScheduleSize (cipher);

  000d1	29 45 14	 sub	 DWORD PTR _ks2$26072[ebp], eax
  000d4	29 45 fc	 sub	 DWORD PTR _ks$26071[ebp], eax

; 1196 : 
; 1197 : 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  000d7	57		 push	 edi
  000d8	ff 75 14	 push	 DWORD PTR _ks2$26072[ebp]
  000db	8d 45 f4	 lea	 eax, DWORD PTR _dataUnitNo$26073[ebp]
  000de	ff 75 fc	 push	 DWORD PTR _ks$26071[ebp]
  000e1	6a 00		 push	 0
  000e3	50		 push	 eax
  000e4	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  000e7	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  000ea	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  000ed	e8 00 00 00 00	 call	 _DecryptBufferXTS@32
  000f2	57		 push	 edi
  000f3	ff 36		 push	 DWORD PTR [esi]
  000f5	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
$LN30@DecryptBuf:
  000fa	8b f8		 mov	 edi, eax
  000fc	85 ff		 test	 edi, edi
  000fe	75 c8		 jne	 SHORT $LL8@DecryptBuf
$LN6@DecryptBuf:
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi

; 1228 : 	}
; 1229 : }

  00102	c9		 leave
  00103	c2 10 00	 ret	 16			; 00000010H
$LN26@DecryptBuf:
_DecryptBuffer@16 ENDP
_TEXT	ENDS
PUBLIC	_DecryptDataUnitsCurrentThread@20
; Function compile flags: /Ogsp
;	COMDAT _DecryptDataUnitsCurrentThread@20
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
tv209 = 16						; size = 8
_nbrUnits$ = 16						; size = 8
_ea$ = 24						; size = 4
_ci$ = 24						; size = 4
_DecryptDataUnitsCurrentThread@20 PROC			; COMDAT

; 1265 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1266 : 	int ea = ci->ea;

  00005	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	57		 push	 edi

; 1267 : 	unsigned __int8 *ks = ci->ks;

  0000d	8d 78 08	 lea	 edi, DWORD PTR [eax+8]

; 1268 : 	unsigned __int8 *ks2 = ci->ks2;

  00010	8d 98 28 02 00
	00		 lea	 ebx, DWORD PTR [eax+552]

; 1269 : 	int cipher;
; 1270 : 
; 1271 : 	switch (ci->mode)

  00016	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00019	48		 dec	 eax
  0001a	89 75 18	 mov	 DWORD PTR _ea$[ebp], esi
  0001d	0f 84 85 00 00
	00		 je	 $LN9@DecryptDat
  00023	48		 dec	 eax
  00024	74 16		 je	 SHORT $LN5@DecryptDat

; 1309 : 	default:		
; 1310 : 		// Unknown/wrong ID
; 1311 : 		GST_THROW_FATAL_EXCEPTION;

  00026	68 54 53 47 00	 push	 4674388			; 00475354H
  0002b	6a 00		 push	 0
  0002d	6a 00		 push	 0
  0002f	68 1f 05 00 00	 push	 1311			; 0000051fH
  00034	6a 29		 push	 41			; 00000029H
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN29@DecryptDat:
$LN5@DecryptDat:

; 1289 : 		}
; 1290 : 		break;
; 1291 : 	case XTS8:
; 1292 : 		ks += EAGetKeyScheduleSize(ea);

  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1293 : 		ks2 += EAGetKeyScheduleSize(ea);

  00042	56		 push	 esi
  00043	03 f8		 add	 edi, eax
  00045	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1294 : 
; 1295 : 		for (cipher = EAGetLastCipher(ea); cipher != 0; cipher = EAGetPreviousCipher(ea, cipher))

  0004a	56		 push	 esi
  0004b	03 d8		 add	 ebx, eax
  0004d	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00052	8b f0		 mov	 esi, eax
  00054	85 f6		 test	 esi, esi
  00056	0f 84 b2 00 00
	00		 je	 $LN6@DecryptDat
  0005c	6a 00		 push	 0
  0005e	68 00 02 00 00	 push	 512			; 00000200H
  00063	ff 75 14	 push	 DWORD PTR _nbrUnits$[ebp+4]
  00066	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  00069	e8 00 00 00 00	 call	 __allmul
  0006e	89 45 10	 mov	 DWORD PTR tv209[ebp], eax
  00071	89 55 14	 mov	 DWORD PTR tv209[ebp+4], edx
$LL26@DecryptDat:

; 1296 : 		{
; 1297 : 			ks -= CipherGetKeyScheduleSize(cipher);

  00074	56		 push	 esi
  00075	e8 00 00 00 00	 call	 _CipherGet@4
  0007a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1298 : 			ks2 -= CipherGetKeyScheduleSize(cipher);
; 1299 : 
; 1300 : 			DecryptBufferXTS8Byte(buf,
; 1301 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1302 : 				structUnitNo,
; 1303 : 				0,
; 1304 : 				ks,
; 1305 : 				ks2,
; 1306 : 				cipher);

  0007d	56		 push	 esi
  0007e	2b d8		 sub	 ebx, eax
  00080	53		 push	 ebx
  00081	2b f8		 sub	 edi, eax
  00083	57		 push	 edi
  00084	6a 00		 push	 0
  00086	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  00089	ff 75 14	 push	 DWORD PTR tv209[ebp+4]
  0008c	ff 75 10	 push	 DWORD PTR tv209[ebp]
  0008f	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00092	e8 00 00 00 00	 call	 _DecryptBufferXTS8Byte@32
  00097	56		 push	 esi
  00098	ff 75 18	 push	 DWORD PTR _ea$[ebp]
  0009b	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  000a0	8b f0		 mov	 esi, eax
  000a2	85 f6		 test	 esi, esi
  000a4	75 ce		 jne	 SHORT $LL26@DecryptDat

; 1307 : 		}
; 1308 : 		break;

  000a6	eb 66		 jmp	 SHORT $LN6@DecryptDat
$LN9@DecryptDat:

; 1272 : 	{
; 1273 : 	case XTS:
; 1274 : 		ks += EAGetKeyScheduleSize (ea);

  000a8	56		 push	 esi
  000a9	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1275 : 		ks2 += EAGetKeyScheduleSize (ea);

  000ae	56		 push	 esi
  000af	03 f8		 add	 edi, eax
  000b1	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1276 : 
; 1277 : 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  000b6	56		 push	 esi
  000b7	03 d8		 add	 ebx, eax
  000b9	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  000be	8b f0		 mov	 esi, eax
  000c0	85 f6		 test	 esi, esi
  000c2	74 4a		 je	 SHORT $LN6@DecryptDat
  000c4	6a 00		 push	 0
  000c6	68 00 02 00 00	 push	 512			; 00000200H
  000cb	ff 75 14	 push	 DWORD PTR _nbrUnits$[ebp+4]
  000ce	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  000d1	e8 00 00 00 00	 call	 __allmul
  000d6	89 45 10	 mov	 DWORD PTR tv209[ebp], eax
  000d9	89 55 14	 mov	 DWORD PTR tv209[ebp+4], edx
$LL27@DecryptDat:

; 1278 : 		{
; 1279 : 			ks -= CipherGetKeyScheduleSize (cipher);

  000dc	56		 push	 esi
  000dd	e8 00 00 00 00	 call	 _CipherGet@4
  000e2	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1280 : 			ks2 -= CipherGetKeyScheduleSize (cipher);
; 1281 : 
; 1282 : 			DecryptBufferXTS (buf,
; 1283 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1284 : 				structUnitNo,
; 1285 : 				0,
; 1286 : 				ks,
; 1287 : 				ks2,
; 1288 : 				cipher);

  000e5	56		 push	 esi
  000e6	2b d8		 sub	 ebx, eax
  000e8	53		 push	 ebx
  000e9	2b f8		 sub	 edi, eax
  000eb	57		 push	 edi
  000ec	6a 00		 push	 0
  000ee	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  000f1	ff 75 14	 push	 DWORD PTR tv209[ebp+4]
  000f4	ff 75 10	 push	 DWORD PTR tv209[ebp]
  000f7	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  000fa	e8 00 00 00 00	 call	 _DecryptBufferXTS@32
  000ff	56		 push	 esi
  00100	ff 75 18	 push	 DWORD PTR _ea$[ebp]
  00103	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  00108	8b f0		 mov	 esi, eax
  0010a	85 f6		 test	 esi, esi
  0010c	75 ce		 jne	 SHORT $LL27@DecryptDat
$LN6@DecryptDat:
  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5b		 pop	 ebx

; 1312 : 	}
; 1313 : }

  00111	5d		 pop	 ebp
  00112	c2 14 00	 ret	 20			; 00000014H
$LN28@DecryptDat:
_DecryptDataUnitsCurrentThread@20 ENDP
_TEXT	ENDS
PUBLIC	_GetMaxPkcs5OutSize@0
; Function compile flags: /Ogsp
;	COMDAT _GetMaxPkcs5OutSize@0
_TEXT	SEGMENT
_GetMaxPkcs5OutSize@0 PROC				; COMDAT

; 1323 : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 1324 : 	int size = 32;

  00003	6a 20		 push	 32			; 00000020H
  00005	5e		 pop	 esi

; 1325 : 
; 1326 : 	size = max (size, EAGetLargestKeyForMode (XTS) * 2);	// Sizes of primary + secondary keys

  00006	6a 01		 push	 1
  00008	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  0000d	03 c0		 add	 eax, eax
  0000f	3b c6		 cmp	 eax, esi
  00011	7c 0b		 jl	 SHORT $LN4@GetMaxPkcs
  00013	6a 01		 push	 1
  00015	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  0001a	8b f0		 mov	 esi, eax
  0001c	03 f6		 add	 esi, esi
$LN4@GetMaxPkcs:

; 1327 : 	size = max (size, EAGetLargestKeyForMode (XTS8) * 2);

  0001e	6a 02		 push	 2
  00020	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00025	03 c0		 add	 eax, eax
  00027	3b f0		 cmp	 esi, eax
  00029	7f 0b		 jg	 SHORT $LN6@GetMaxPkcs
  0002b	6a 02		 push	 2
  0002d	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00032	8b f0		 mov	 esi, eax
  00034	03 f6		 add	 esi, esi
$LN6@GetMaxPkcs:

; 1328 : 
; 1329 : 	return size;

  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi

; 1330 : }

  00039	c3		 ret	 0
_GetMaxPkcs5OutSize@0 ENDP
_TEXT	ENDS
END
