; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\wipe.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

; Function compile flags: /Ogsp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\wipe.c
;	COMDAT _Wipe1PseudoRandom@12
_TEXT	SEGMENT
_Wipe1PseudoRandom@12 PROC				; COMDAT

; 36   : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 37   : }

  00002	c3		 ret	 0
_Wipe1PseudoRandom@12 ENDP
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _Wipe3Dod5220@12
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_Wipe3Dod5220@12 PROC					; COMDAT
; _pass$ = eax

; 56   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 57   : 	byte wipeChar;
; 58   : 
; 59   : 	switch (pass)

  00005	48		 dec	 eax
  00006	74 0b		 je	 SHORT $LN3@Wipe3Dod52
  00008	48		 dec	 eax
  00009	74 04		 je	 SHORT $LN2@Wipe3Dod52

; 68   : 
; 69   : 	default:
; 70   : 		return FALSE;

  0000b	33 c0		 xor	 eax, eax
  0000d	eb 1b		 jmp	 SHORT $LN6@Wipe3Dod52
$LN2@Wipe3Dod52:

; 63   : 		break;
; 64   : 
; 65   : 	case 2:
; 66   : 		wipeChar = 0xff;

  0000f	0c ff		 or	 al, 255			; 000000ffH

; 67   : 		break;

  00011	eb 02		 jmp	 SHORT $LN4@Wipe3Dod52
$LN3@Wipe3Dod52:

; 60   : 	{
; 61   : 	case 1:
; 62   : 		wipeChar = 0;

  00013	32 c0		 xor	 al, al
$LN4@Wipe3Dod52:

; 71   : 	}
; 72   : 
; 73   : 	memset (buffer, wipeChar, size);

  00015	ff 75 0c	 push	 DWORD PTR _size$[ebp]
  00018	0f b6 c0	 movzx	 eax, al
  0001b	50		 push	 eax
  0001c	ff 75 08	 push	 DWORD PTR _buffer$[ebp]
  0001f	e8 00 00 00 00	 call	 _memset

; 74   : 	return TRUE;

  00024	33 c0		 xor	 eax, eax
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	40		 inc	 eax
$LN6@Wipe3Dod52:

; 75   : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
_Wipe3Dod5220@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _Wipe7Dod5220@16
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_Wipe7Dod5220@16 PROC					; COMDAT
; _pass$ = ecx
; _randChars$ = eax

; 92   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 93   : 	byte wipeChar;
; 94   : 
; 95   : 	switch (pass)

  00005	49		 dec	 ecx
  00006	74 26		 je	 SHORT $LN6@Wipe7Dod52
  00008	49		 dec	 ecx
  00009	74 1d		 je	 SHORT $LN5@Wipe7Dod52
  0000b	49		 dec	 ecx
  0000c	49		 dec	 ecx
  0000d	74 14		 je	 SHORT $LN4@Wipe7Dod52
  0000f	49		 dec	 ecx
  00010	74 0c		 je	 SHORT $LN3@Wipe7Dod52
  00012	49		 dec	 ecx
  00013	74 04		 je	 SHORT $LN2@Wipe7Dod52

; 116  : 
; 117  : 	default:
; 118  : 		return FALSE;

  00015	33 c0		 xor	 eax, eax
  00017	eb 2c		 jmp	 SHORT $LN9@Wipe7Dod52
$LN2@Wipe7Dod52:

; 112  : 
; 113  : 	case 6:
; 114  : 		wipeChar = ~randChars[2];

  00019	8a 40 02	 mov	 al, BYTE PTR [eax+2]

; 115  : 		break;

  0001c	eb 0c		 jmp	 SHORT $LN11@Wipe7Dod52
$LN3@Wipe7Dod52:

; 108  : 
; 109  : 	case 5:
; 110  : 		wipeChar = randChars[2];

  0001e	8a 40 02	 mov	 al, BYTE PTR [eax+2]

; 111  : 		break;

  00021	eb 0d		 jmp	 SHORT $LN7@Wipe7Dod52
$LN4@Wipe7Dod52:

; 104  : 
; 105  : 	case 4:
; 106  : 		wipeChar = randChars[1];

  00023	8a 40 01	 mov	 al, BYTE PTR [eax+1]

; 107  : 		break;

  00026	eb 08		 jmp	 SHORT $LN7@Wipe7Dod52
$LN5@Wipe7Dod52:

; 99   : 		break;
; 100  : 
; 101  : 	case 2:
; 102  : 		wipeChar = ~randChars[0];

  00028	8a 00		 mov	 al, BYTE PTR [eax]
$LN11@Wipe7Dod52:
  0002a	f6 d0		 not	 al

; 103  : 		break;

  0002c	eb 02		 jmp	 SHORT $LN7@Wipe7Dod52
$LN6@Wipe7Dod52:

; 96   : 	{
; 97   : 	case 1:
; 98   : 		wipeChar = randChars[0];

  0002e	8a 00		 mov	 al, BYTE PTR [eax]
$LN7@Wipe7Dod52:

; 119  : 	}
; 120  : 
; 121  : 	memset (buffer, wipeChar, size);

  00030	ff 75 0c	 push	 DWORD PTR _size$[ebp]
  00033	0f b6 c0	 movzx	 eax, al
  00036	50		 push	 eax
  00037	ff 75 08	 push	 DWORD PTR _buffer$[ebp]
  0003a	e8 00 00 00 00	 call	 _memset

; 122  : 	return TRUE;

  0003f	33 c0		 xor	 eax, eax
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	40		 inc	 eax
$LN9@Wipe7Dod52:

; 123  : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
_Wipe7Dod5220@16 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _Wipe35Gutmann@12
_TEXT	SEGMENT
_wipePat3$ = -4						; size = 3
_size$ = 8						; size = 4
_Wipe35Gutmann@12 PROC					; COMDAT
; _pass$ = ecx
; _buffer$ = edi

; 139  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 140  : 	byte wipePat3[] = { 0x92, 0x49, 0x24 };
; 141  : 	int wipePat3Pos;
; 142  : 	size_t i;
; 143  : 
; 144  : 	switch (pass)

  00006	83 f9 1a	 cmp	 ecx, 26			; 0000001aH
  00009	8b 55 08	 mov	 edx, DWORD PTR _size$[ebp]
  0000c	56		 push	 esi
  0000d	c6 45 fc 92	 mov	 BYTE PTR _wipePat3$[ebp], 146 ; 00000092H
  00011	c6 45 fd 49	 mov	 BYTE PTR _wipePat3$[ebp+1], 73 ; 00000049H
  00015	c6 45 fe 24	 mov	 BYTE PTR _wipePat3$[ebp+2], 36 ; 00000024H
  00019	7f 19		 jg	 SHORT $LN17@Wipe35Gutm
  0001b	74 46		 je	 SHORT $LN10@Wipe35Gutm
  0001d	8b c1		 mov	 eax, ecx
  0001f	83 e8 05	 sub	 eax, 5
  00022	74 0b		 je	 SHORT $LN12@Wipe35Gutm
  00024	48		 dec	 eax
  00025	75 17		 jne	 SHORT $LN20@Wipe35Gutm

; 149  : 
; 150  : 	case 6:
; 151  : 		memset (buffer, 0xaa, size);

  00027	52		 push	 edx
  00028	68 aa 00 00 00	 push	 170			; 000000aaH

; 152  : 		break;

  0002d	eb 25		 jmp	 SHORT $LN21@Wipe35Gutm
$LN12@Wipe35Gutm:

; 145  : 	{
; 146  : 	case 5:
; 147  : 		memset (buffer, 0x55, size);

  0002f	52		 push	 edx
  00030	6a 55		 push	 85			; 00000055H

; 148  : 		break;

  00032	eb 20		 jmp	 SHORT $LN21@Wipe35Gutm
$LN17@Wipe35Gutm:

; 140  : 	byte wipePat3[] = { 0x92, 0x49, 0x24 };
; 141  : 	int wipePat3Pos;
; 142  : 	size_t i;
; 143  : 
; 144  : 	switch (pass)

  00034	8b c1		 mov	 eax, ecx
  00036	83 e8 1b	 sub	 eax, 27			; 0000001bH
  00039	74 31		 je	 SHORT $LN9@Wipe35Gutm
  0003b	48		 dec	 eax
  0003c	74 29		 je	 SHORT $LN8@Wipe35Gutm
$LN20@Wipe35Gutm:
  0003e	48		 dec	 eax
  0003f	74 22		 je	 SHORT $LN10@Wipe35Gutm
  00041	48		 dec	 eax
  00042	74 28		 je	 SHORT $LN9@Wipe35Gutm
  00044	48		 dec	 eax
  00045	74 20		 je	 SHORT $LN8@Wipe35Gutm

; 183  : 		}
; 184  : 		break;
; 185  : 
; 186  : 	default:
; 187  : 		if (pass >= 10 && pass <= 25)

  00047	8d 41 f6	 lea	 eax, DWORD PTR [ecx-10]
  0004a	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0004d	77 10		 ja	 SHORT $LN2@Wipe35Gutm

; 188  : 			memset (buffer, (pass - 10) * 0x11, size);

  0004f	6b c0 11	 imul	 eax, 17			; 00000011H
  00052	52		 push	 edx
  00053	50		 push	 eax
$LN21@Wipe35Gutm:
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 _memset
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 189  : 		else

  0005d	eb 3f		 jmp	 SHORT $LN4@Wipe35Gutm
$LN2@Wipe35Gutm:

; 190  : 			return FALSE;

  0005f	33 c0		 xor	 eax, eax
  00061	eb 3e		 jmp	 SHORT $LN15@Wipe35Gutm
$LN10@Wipe35Gutm:

; 153  : 
; 154  : 	case 7:
; 155  : 	case 26:
; 156  : 	case 29:
; 157  : 		wipePat3Pos = 0;

  00063	33 f6		 xor	 esi, esi

; 158  : 		goto wipe3;

  00065	eb 08		 jmp	 SHORT $wipe3$24819
$LN8@Wipe35Gutm:

; 164  : 		goto wipe3;
; 165  : 
; 166  : 	case 9:
; 167  : 	case 28:
; 168  : 	case 31:
; 169  : 		wipePat3Pos = 2;

  00067	6a 02		 push	 2
  00069	5e		 pop	 esi
  0006a	eb 03		 jmp	 SHORT $wipe3$24819
$LN9@Wipe35Gutm:

; 159  : 
; 160  : 	case 8:
; 161  : 	case 27:
; 162  : 	case 30:
; 163  : 		wipePat3Pos = 1;

  0006c	33 f6		 xor	 esi, esi
  0006e	46		 inc	 esi
$wipe3$24819:

; 170  : 		goto wipe3;
; 171  : 
; 172  : wipe3:
; 173  : 		if (pass >= 29)

  0006f	83 f9 1d	 cmp	 ecx, 29			; 0000001dH
  00072	7c 0c		 jl	 SHORT $LN7@Wipe35Gutm

; 174  : 		{
; 175  : 			wipePat3[0] = ~wipePat3[0];

  00074	c6 45 fc 6d	 mov	 BYTE PTR _wipePat3$[ebp], 109 ; 0000006dH

; 176  : 			wipePat3[1] = ~wipePat3[1];

  00078	c6 45 fd b6	 mov	 BYTE PTR _wipePat3$[ebp+1], 182 ; 000000b6H

; 177  : 			wipePat3[2] = ~wipePat3[2];

  0007c	c6 45 fe db	 mov	 BYTE PTR _wipePat3$[ebp+2], 219 ; 000000dbH
$LN7@Wipe35Gutm:

; 178  : 		}
; 179  : 
; 180  : 		for (i = 0; i < size; ++i)

  00080	33 c9		 xor	 ecx, ecx
  00082	85 d2		 test	 edx, edx
  00084	76 18		 jbe	 SHORT $LN4@Wipe35Gutm
  00086	53		 push	 ebx
$LL6@Wipe35Gutm:

; 181  : 		{
; 182  : 			buffer[i] = wipePat3[wipePat3Pos++ % 3];

  00087	8b c6		 mov	 eax, esi
  00089	99		 cdq
  0008a	6a 03		 push	 3
  0008c	5b		 pop	 ebx
  0008d	f7 fb		 idiv	 ebx
  0008f	46		 inc	 esi
  00090	8a 44 15 fc	 mov	 al, BYTE PTR _wipePat3$[ebp+edx]
  00094	88 04 39	 mov	 BYTE PTR [ecx+edi], al
  00097	41		 inc	 ecx
  00098	3b 4d 08	 cmp	 ecx, DWORD PTR _size$[ebp]
  0009b	72 ea		 jb	 SHORT $LL6@Wipe35Gutm
  0009d	5b		 pop	 ebx
$LN4@Wipe35Gutm:

; 191  : 	}
; 192  : 
; 193  : 	return TRUE;

  0009e	33 c0		 xor	 eax, eax
  000a0	40		 inc	 eax
$LN15@Wipe35Gutm:
  000a1	5e		 pop	 esi

; 194  : }

  000a2	c9		 leave
  000a3	c2 04 00	 ret	 4
_Wipe35Gutmann@12 ENDP
_TEXT	ENDS
PUBLIC	_GetWipePassCount@4
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetWipePassCount@4
_TEXT	SEGMENT
_algorithm$ = 8						; size = 4
_GetWipePassCount@4 PROC				; COMDAT

; 211  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 212  : 	switch (algorithm)

  00005	8b 45 08	 mov	 eax, DWORD PTR _algorithm$[ebp]
  00008	83 f8 64	 cmp	 eax, 100		; 00000064H
  0000b	74 38		 je	 SHORT $LN5@GetWipePas
  0000d	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  00012	74 2c		 je	 SHORT $LN4@GetWipePas
  00014	3d bc 02 00 00	 cmp	 eax, 700		; 000002bcH
  00019	74 21		 je	 SHORT $LN3@GetWipePas
  0001b	3d ac 0d 00 00	 cmp	 eax, 3500		; 00000dacH
  00020	74 16		 je	 SHORT $LN2@GetWipePas

; 225  : 
; 226  : 	default:
; 227  : 		GST_THROW_FATAL_EXCEPTION;

  00022	68 54 53 47 00	 push	 4674388			; 00475354H
  00027	6a 00		 push	 0
  00029	6a 00		 push	 0
  0002b	68 e3 00 00 00	 push	 227			; 000000e3H
  00030	6a 29		 push	 41			; 00000029H
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN12@GetWipePas:
$LN2@GetWipePas:

; 222  : 
; 223  : 	case GST_WIPE_35_GUTMANN:
; 224  : 		return 35;

  00038	6a 23		 push	 35			; 00000023H
  0003a	eb 06		 jmp	 SHORT $LN11@GetWipePas
$LN3@GetWipePas:

; 219  : 
; 220  : 	case GST_WIPE_7_DOD_5220:
; 221  : 		return 7;

  0003c	6a 07		 push	 7
  0003e	eb 02		 jmp	 SHORT $LN11@GetWipePas
$LN4@GetWipePas:

; 216  : 
; 217  : 	case GST_WIPE_3_DOD_5220:
; 218  : 		return 3;

  00040	6a 03		 push	 3
$LN11@GetWipePas:
  00042	58		 pop	 eax
  00043	eb 03		 jmp	 SHORT $LN8@GetWipePas
$LN5@GetWipePas:

; 213  : 	{
; 214  : 	case GST_WIPE_1_RAND:
; 215  : 		return 1;

  00045	33 c0		 xor	 eax, eax
  00047	40		 inc	 eax
$LN8@GetWipePas:

; 228  : 	}
; 229  : 
; 230  : 	return 0;	// Prevent compiler warnings
; 231  : }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN10@GetWipePas:
_GetWipePassCount@4 ENDP
_TEXT	ENDS
PUBLIC	_WipeBuffer@20
; Function compile flags: /Ogsp
;	COMDAT _WipeBuffer@20
_TEXT	SEGMENT
_algorithm$ = 8						; size = 4
_randChars$ = 12					; size = 4
_pass$ = 16						; size = 4
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_WipeBuffer@20 PROC					; COMDAT

; 252  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 253  : 	switch (algorithm)

  00005	8b 45 08	 mov	 eax, DWORD PTR _algorithm$[ebp]
  00008	83 f8 64	 cmp	 eax, 100		; 00000064H
  0000b	74 76		 je	 SHORT $LN5@WipeBuffer
  0000d	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  00012	74 49		 je	 SHORT $LN4@WipeBuffer
  00014	3d bc 02 00 00	 cmp	 eax, 700		; 000002bcH
  00019	74 2f		 je	 SHORT $LN3@WipeBuffer
  0001b	3d ac 0d 00 00	 cmp	 eax, 3500		; 00000dacH
  00020	74 16		 je	 SHORT $LN2@WipeBuffer

; 266  : 
; 267  : 	default:
; 268  : 		GST_THROW_FATAL_EXCEPTION;

  00022	68 54 53 47 00	 push	 4674388			; 00475354H
  00027	6a 00		 push	 0
  00029	6a 00		 push	 0
  0002b	68 0c 01 00 00	 push	 268			; 0000010cH
  00030	6a 29		 push	 41			; 00000029H
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN20@WipeBuffer:
$LN2@WipeBuffer:

; 263  : 
; 264  : 	case GST_WIPE_35_GUTMANN:
; 265  : 		return Wipe35Gutmann (pass, buffer, size);

  00038	8b 4d 10	 mov	 ecx, DWORD PTR _pass$[ebp]
  0003b	57		 push	 edi
  0003c	ff 75 18	 push	 DWORD PTR _size$[ebp]
  0003f	8b 7d 14	 mov	 edi, DWORD PTR _buffer$[ebp]
  00042	e8 00 00 00 00	 call	 _Wipe35Gutmann@12
  00047	5f		 pop	 edi
  00048	eb 3b		 jmp	 SHORT $LN8@WipeBuffer
$LN3@WipeBuffer:

; 260  : 
; 261  : 	case GST_WIPE_7_DOD_5220:
; 262  : 		return Wipe7Dod5220 (pass, randChars, buffer, size);

  0004a	ff 75 18	 push	 DWORD PTR _size$[ebp]
  0004d	8b 45 0c	 mov	 eax, DWORD PTR _randChars$[ebp]
  00050	ff 75 14	 push	 DWORD PTR _buffer$[ebp]
  00053	8b 4d 10	 mov	 ecx, DWORD PTR _pass$[ebp]
  00056	e8 00 00 00 00	 call	 _Wipe7Dod5220@16
  0005b	eb 28		 jmp	 SHORT $LN8@WipeBuffer
$LN4@WipeBuffer:

; 257  : 
; 258  : 	case GST_WIPE_3_DOD_5220:
; 259  : 		return Wipe3Dod5220 (pass, buffer, size);

  0005d	8b 45 10	 mov	 eax, DWORD PTR _pass$[ebp]
  00060	48		 dec	 eax
  00061	74 07		 je	 SHORT $LN14@WipeBuffer
  00063	48		 dec	 eax
  00064	75 1d		 jne	 SHORT $LN5@WipeBuffer
  00066	0c ff		 or	 al, 255			; 000000ffH
  00068	eb 02		 jmp	 SHORT $LN15@WipeBuffer
$LN14@WipeBuffer:
  0006a	32 c0		 xor	 al, al
$LN15@WipeBuffer:
  0006c	ff 75 18	 push	 DWORD PTR _size$[ebp]
  0006f	0f b6 c0	 movzx	 eax, al
  00072	50		 push	 eax
  00073	ff 75 14	 push	 DWORD PTR _buffer$[ebp]
  00076	e8 00 00 00 00	 call	 _memset
  0007b	33 c0		 xor	 eax, eax
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	40		 inc	 eax
  00081	eb 02		 jmp	 SHORT $LN8@WipeBuffer
$LN5@WipeBuffer:

; 254  : 	{
; 255  : 	case GST_WIPE_1_RAND:
; 256  : 		return Wipe1PseudoRandom (pass, buffer, size);

  00083	33 c0		 xor	 eax, eax
$LN8@WipeBuffer:

; 269  : 	}
; 270  : 
; 271  : 	return FALSE;	// Prevent compiler warnings
; 272  : }

  00085	5d		 pop	 ebp
  00086	c2 14 00	 ret	 20			; 00000014H
$LN19@WipeBuffer:
_WipeBuffer@20 ENDP
_TEXT	ENDS
END
