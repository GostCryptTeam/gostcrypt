; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\Volumes.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ReadVolumeHeaderRecoveryMode
_BSS	SEGMENT
_ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	_GetHeaderField16
PUBLIC	_GetHeaderField32
PUBLIC	_GetHeaderField64
PUBLIC	_ReadVolumeHeader
PUBLIC	_CreateVolumeHeaderInMemory
PUBLIC	_ReadEffectiveVolumeHeader
PUBLIC	_WriteEffectiveVolumeHeader
PUBLIC	_WriteRandomDataToReservedHeaderAreas
PUBLIC	??_C@_04JFFKLGJF@?$CF02X?$AA@			; `string'
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	__imp__VirtualUnlock@8:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_crypto_open:PROC
EXTRN	_crypto_loadkey:PROC
EXTRN	_crypto_close:PROC
EXTRN	_CipherGetBlockSize:PROC
EXTRN	_EAInit:PROC
EXTRN	_EAInitMode:PROC
EXTRN	_EAGetFirst:PROC
EXTRN	_EAGetNext:PROC
EXTRN	_EAGetKeySize:PROC
EXTRN	_EAGetFirstCipher:PROC
EXTRN	_EAIsModeSupported:PROC
EXTRN	_GetMaxPkcs5OutSize:PROC
EXTRN	_EncryptBuffer:PROC
EXTRN	_DecryptBuffer:PROC
EXTRN	_EncryptionThreadPoolBeginKeyDerivation:PROC
EXTRN	_GetEncryptionThreadCount:PROC
EXTRN	_RandgetBytes:PROC
EXTRN	_GetCrc32:PROC
EXTRN	_MirrorBytes16:PROC
EXTRN	_MirrorBytes32:PROC
EXTRN	_MirrorBytes64:PROC
EXTRN	_derive_key_whirlpool:PROC
EXTRN	_derive_key_gosthash:PROC
EXTRN	_derive_key_stribog:PROC
EXTRN	_get_pkcs5_iteration_count:PROC
EXTRN	_DisplayPortionsOfKeys:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_showKeys:DWORD
EXTRN	_hMasterKey:DWORD
EXTRN	_hHeaderKey:DWORD
EXTRN	_bInPlaceEncNonSys:DWORD
EXTRN	_HeaderKeyGUIView:BYTE
EXTRN	_MasterKeyGUIView:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9 DB 0188H DUP (?) ; `CreateVolumeHeaderInMemory'::`2'::keyInfo
?dk@?1??CreateVolumeHeaderInMemory@@9@9 DB 0100H DUP (?) ; `CreateVolumeHeaderInMemory'::`2'::dk
_BSS	ENDS
;	COMDAT ??_C@_04JFFKLGJF@?$CF02X?$AA@
CONST	SEGMENT
??_C@_04JFFKLGJF@?$CF02X?$AA@ DB '%02X', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _WriteRandomDataToReservedHeaderAreas
_TEXT	SEGMENT
_offset$ = -131604					; size = 8
_bytesDone$ = -131596					; size = 4
_dev$GSCopy$1$ = -131592				; size = 4
_buf$ = -131588						; size = 131072
_originalK2$ = -516					; size = 256
_temporaryKey$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_dev$ = 8						; size = 4
_cryptoInfo$ = 12					; size = 4
_dataAreaSize$ = 16					; size = 8
_bPrimaryOnly$ = 24					; size = 4
_bBackupOnly$ = 28					; size = 4
_WriteRandomDataToReservedHeaderAreas PROC		; COMDAT

; 1159 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 14 02 02 00	 mov	 eax, 131604		; 00020214H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1160 : 	char temporaryKey[MASTER_KEYDATA_SIZE];
; 1161 : 	char originalK2[MASTER_KEYDATA_SIZE];
; 1162 : 
; 1163 : 	byte buf[GST_VOLUME_HEADER_GROUP_SIZE];
; 1164 : 
; 1165 : 	LARGE_INTEGER offset;
; 1166 : 	int nStatus = ERR_SUCCESS;
; 1167 : 	DWORD dwError;
; 1168 : 	DWORD bytesDone;
; 1169 : 	BOOL backupHeaders = bBackupOnly;
; 1170 : 
; 1171 : 	if (bPrimaryOnly && bBackupOnly)

  00017	83 7d 18 00	 cmp	 DWORD PTR _bPrimaryOnly$[ebp], 0
  0001b	8b 45 08	 mov	 eax, DWORD PTR _dev$[ebp]
  0001e	53		 push	 ebx
  0001f	8b 5d 0c	 mov	 ebx, DWORD PTR _cryptoInfo$[ebp]
  00022	56		 push	 esi
  00023	89 85 f8 fd fd
	ff		 mov	 DWORD PTR _dev$GSCopy$1$[ebp], eax
  00029	74 0d		 je	 SHORT $LN14@WriteRando
  0002b	83 7d 1c 00	 cmp	 DWORD PTR _bBackupOnly$[ebp], 0
  0002f	74 07		 je	 SHORT $LN14@WriteRando

; 1172 : 		GST_THROW_FATAL_EXCEPTION;

  00031	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN14@WriteRando:
  00038	57		 push	 edi

; 1173 : 
; 1174 : 	memcpy (originalK2, cryptoInfo->k2, sizeof (cryptoInfo->k2));
; 1175 : 
; 1176 : 	while (TRUE)
; 1177 : 	{
; 1178 : 		// Temporary keys
; 1179 : 		if (!RandgetBytes (temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE)
; 1180 : 			|| !RandgetBytes (cryptoInfo->k2, sizeof (cryptoInfo->k2), FALSE))

  00039	6a 00		 push	 0
  0003b	ff 33		 push	 DWORD PTR [ebx]
  0003d	8d b3 50 1d 00
	00		 lea	 esi, DWORD PTR [ebx+7504]
  00043	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00048	8d bd fc fd ff
	ff		 lea	 edi, DWORD PTR _originalK2$[ebp]
  0004e	f3 a5		 rep movsd
  00050	e8 00 00 00 00	 call	 _EAGetKeySize
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _RandgetBytes
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	85 c0		 test	 eax, eax
  0006a	0f 84 6f 01 00
	00		 je	 $LN16@WriteRando
$LL2@WriteRando:
  00070	6a 00		 push	 0
  00072	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  00078	68 00 01 00 00	 push	 256			; 00000100H
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _RandgetBytes
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
  00086	85 c0		 test	 eax, eax
  00088	0f 84 51 01 00
	00		 je	 $LN16@WriteRando

; 1183 : 			goto final_seq;
; 1184 : 		}
; 1185 : 
; 1186 : 		nStatus = EAInit (cryptoInfo->ea, temporaryKey, cryptoInfo->ks);

  0008e	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00091	50		 push	 eax
  00092	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  00098	50		 push	 eax
  00099	ff 33		 push	 DWORD PTR [ebx]
  0009b	e8 00 00 00 00	 call	 _EAInit
  000a0	8b f0		 mov	 esi, eax
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1187 : 		if (nStatus != ERR_SUCCESS)

  000a5	85 f6		 test	 esi, esi
  000a7	0f 85 37 01 00
	00		 jne	 $final_seq$93

; 1188 : 			goto final_seq;
; 1189 : 
; 1190 : 		if (!EAInitMode (cryptoInfo))

  000ad	53		 push	 ebx
  000ae	e8 00 00 00 00	 call	 _EAInitMode
  000b3	83 c4 04	 add	 esp, 4
  000b6	85 c0		 test	 eax, eax
  000b8	0f 84 ed 01 00
	00		 je	 $LN48@WriteRando

; 1194 : 		}
; 1195 : 
; 1196 : 		offset.QuadPart = backupHeaders ? dataAreaSize + GST_VOLUME_HEADER_GROUP_SIZE : GST_VOLUME_HEADER_OFFSET;

  000be	39 75 1c	 cmp	 DWORD PTR _bBackupOnly$[ebp], esi
  000c1	74 11		 je	 SHORT $LN31@WriteRando
  000c3	8b 75 10	 mov	 esi, DWORD PTR _dataAreaSize$[ebp]
  000c6	8b 7d 14	 mov	 edi, DWORD PTR _dataAreaSize$[ebp+4]
  000c9	81 c6 00 00 02
	00		 add	 esi, 131072		; 00020000H
  000cf	83 d7 00	 adc	 edi, 0
  000d2	eb 17		 jmp	 SHORT $LN32@WriteRando
$LN31@WriteRando:
  000d4	0f 57 c0	 xorps	 xmm0, xmm0
  000d7	66 0f 13 85 ec
	fd fd ff	 movlpd	 QWORD PTR _offset$[ebp], xmm0
  000df	8b bd f0 fd fd
	ff		 mov	 edi, DWORD PTR _offset$[ebp+4]
  000e5	8b b5 ec fd fd
	ff		 mov	 esi, DWORD PTR _offset$[ebp]
$LN32@WriteRando:

; 1197 : 
; 1198 : 		if (!SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  000eb	6a 00		 push	 0
  000ed	6a 00		 push	 0
  000ef	57		 push	 edi
  000f0	56		 push	 esi
  000f1	ff b5 f8 fd fd
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000fd	85 c0		 test	 eax, eax
  000ff	0f 84 b8 01 00
	00		 je	 $LN49@WriteRando

; 1199 : 		{
; 1200 : 			nStatus = ERR_OS_ERROR;
; 1201 : 			goto final_seq;
; 1202 : 		}
; 1203 : 
; 1204 : 		if (!ReadFile (dev, buf, sizeof (buf), &bytesDone, NULL))

  00105	6a 00		 push	 0
  00107	8d 85 f4 fd fd
	ff		 lea	 eax, DWORD PTR _bytesDone$[ebp]
  0010d	50		 push	 eax
  0010e	68 00 00 02 00	 push	 131072			; 00020000H
  00113	8d 85 fc fd fd
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00119	50		 push	 eax
  0011a	ff b5 f8 fd fd
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00126	85 c0		 test	 eax, eax
  00128	0f 84 8f 01 00
	00		 je	 $LN49@WriteRando

; 1205 : 		{
; 1206 : 			nStatus = ERR_OS_ERROR;
; 1207 : 			goto final_seq;
; 1208 : 		}
; 1209 : 
; 1210 : 		if (bytesDone < GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  0012e	81 bd f4 fd fd
	ff 00 02 00 00	 cmp	 DWORD PTR _bytesDone$[ebp], 512 ; 00000200H
  00138	0f 82 77 01 00
	00		 jb	 $LN51@WriteRando

; 1215 : 		}
; 1216 : 
; 1217 : 		EncryptBuffer (buf + GST_VOLUME_HEADER_EFFECTIVE_SIZE, sizeof (buf) - GST_VOLUME_HEADER_EFFECTIVE_SIZE, cryptoInfo);

  0013e	53		 push	 ebx
  0013f	6a 00		 push	 0
  00141	8d 85 fc ff fd
	ff		 lea	 eax, DWORD PTR _buf$[ebp+512]
  00147	68 00 fe 01 00	 push	 130560			; 0001fe00H
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _EncryptBuffer
  00152	83 c4 10	 add	 esp, 16			; 00000010H

; 1218 : 
; 1219 : 		if (!SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  00155	6a 00		 push	 0
  00157	6a 00		 push	 0
  00159	57		 push	 edi
  0015a	56		 push	 esi
  0015b	8b b5 f8 fd fd
	ff		 mov	 esi, DWORD PTR _dev$GSCopy$1$[ebp]
  00161	56		 push	 esi
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00168	85 c0		 test	 eax, eax
  0016a	0f 84 4d 01 00
	00		 je	 $LN49@WriteRando

; 1220 : 		{
; 1221 : 			nStatus = ERR_OS_ERROR;
; 1222 : 			goto final_seq;
; 1223 : 		}
; 1224 : 
; 1225 : 		if (!WriteFile (dev, buf, sizeof (buf), &bytesDone, NULL))

  00170	6a 00		 push	 0
  00172	8d 85 f4 fd fd
	ff		 lea	 eax, DWORD PTR _bytesDone$[ebp]
  00178	50		 push	 eax
  00179	68 00 00 02 00	 push	 131072			; 00020000H
  0017e	8d 85 fc fd fd
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00184	50		 push	 eax
  00185	56		 push	 esi
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0018c	85 c0		 test	 eax, eax
  0018e	0f 84 29 01 00
	00		 je	 $LN49@WriteRando

; 1226 : 		{
; 1227 : 			nStatus = ERR_OS_ERROR;
; 1228 : 			goto final_seq;
; 1229 : 		}
; 1230 : 
; 1231 : 		if (bytesDone != sizeof (buf))

  00194	81 bd f4 fd fd
	ff 00 00 02 00	 cmp	 DWORD PTR _bytesDone$[ebp], 131072 ; 00020000H
  0019e	75 3f		 jne	 SHORT $LN16@WriteRando

; 1232 : 		{
; 1233 : 			nStatus = ERR_PARAMETER_INCORRECT;
; 1234 : 			goto final_seq;
; 1235 : 		}
; 1236 : 
; 1237 : 		if (backupHeaders || bPrimaryOnly)

  001a0	83 7d 1c 00	 cmp	 DWORD PTR _bBackupOnly$[ebp], 0
  001a4	0f 85 be 00 00
	00		 jne	 $LN55@WriteRando
  001aa	83 7d 18 00	 cmp	 DWORD PTR _bPrimaryOnly$[ebp], 0
  001ae	0f 85 b4 00 00
	00		 jne	 $LN55@WriteRando

; 1173 : 
; 1174 : 	memcpy (originalK2, cryptoInfo->k2, sizeof (cryptoInfo->k2));
; 1175 : 
; 1176 : 	while (TRUE)
; 1177 : 	{
; 1178 : 		// Temporary keys
; 1179 : 		if (!RandgetBytes (temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE)
; 1180 : 			|| !RandgetBytes (cryptoInfo->k2, sizeof (cryptoInfo->k2), FALSE))

  001b4	6a 00		 push	 0
  001b6	ff 33		 push	 DWORD PTR [ebx]

; 1238 : 			break;
; 1239 : 
; 1240 : 		backupHeaders = TRUE;

  001b8	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR _bBackupOnly$[ebp], 1
  001bf	e8 00 00 00 00	 call	 _EAGetKeySize
  001c4	83 c4 04	 add	 esp, 4
  001c7	50		 push	 eax
  001c8	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _RandgetBytes
  001d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d7	85 c0		 test	 eax, eax
  001d9	0f 85 91 fe ff
	ff		 jne	 $LL2@WriteRando
$LN16@WriteRando:

; 1181 : 		{
; 1182 : 			nStatus = ERR_PARAMETER_INCORRECT; 

  001df	be 1e 00 00 00	 mov	 esi, 30			; 0000001eH
$final_seq$93:

; 1250 : 	{
; 1251 : 		nStatus = ERR_MODE_INIT_FAILED;
; 1252 : 		goto final_seq;
; 1253 : 	}
; 1254 : 
; 1255 : final_seq:
; 1256 : 
; 1257 : 	dwError = GetLastError();

  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1258 : 
; 1259 : 	burn (temporaryKey, sizeof (temporaryKey));

  001ea	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _temporaryKey$[ebp]
  001f0	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  001f5	8b d8		 mov	 ebx, eax
  001f7	8b f9		 mov	 edi, ecx
  001f9	8b c2		 mov	 eax, edx
  001fb	0f 1f 44 00 00	 npad	 5
$LL34@WriteRando:
  00200	c6 07 00	 mov	 BYTE PTR [edi], 0
  00203	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00206	83 e8 01	 sub	 eax, 1
  00209	75 f5		 jne	 SHORT $LL34@WriteRando
  0020b	0f 1f 44 00 00	 npad	 5
$LL7@WriteRando:
  00210	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00213	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00216	83 ea 01	 sub	 edx, 1
  00219	75 f5		 jne	 SHORT $LL7@WriteRando

; 1260 : 	burn (originalK2, sizeof (originalK2));

  0021b	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _originalK2$[ebp]
  00221	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00226	8b f9		 mov	 edi, ecx
  00228	8b d0		 mov	 edx, eax
  0022a	66 0f 1f 44 00
	00		 npad	 6
$LL38@WriteRando:
  00230	c6 02 00	 mov	 BYTE PTR [edx], 0
  00233	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00236	83 ef 01	 sub	 edi, 1
  00239	75 f5		 jne	 SHORT $LL38@WriteRando
  0023b	5f		 pop	 edi
  0023c	0f 1f 40 00	 npad	 4
$LL12@WriteRando:
  00240	c6 00 00	 mov	 BYTE PTR [eax], 0
  00243	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00246	83 e9 01	 sub	 ecx, 1
  00249	75 f5		 jne	 SHORT $LL12@WriteRando

; 1261 : 
; 1262 : 	if (nStatus != ERR_SUCCESS)

  0024b	85 f6		 test	 esi, esi
  0024d	74 07		 je	 SHORT $LN85@WriteRando

; 1263 : 		SetLastError (dwError);

  0024f	53		 push	 ebx
  00250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN85@WriteRando:

; 1264 : 
; 1265 : 	return nStatus;
; 1266 : }

  00256	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00259	8b c6		 mov	 eax, esi
  0025b	5e		 pop	 esi
  0025c	33 cd		 xor	 ecx, ebp
  0025e	5b		 pop	 ebx
  0025f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00264	8b e5		 mov	 esp, ebp
  00266	5d		 pop	 ebp
  00267	c3		 ret	 0
$LN55@WriteRando:

; 1241 : 	}
; 1242 : 
; 1243 : 	memcpy (cryptoInfo->k2, originalK2, sizeof (cryptoInfo->k2));
; 1244 : 
; 1245 : 	nStatus = EAInit (cryptoInfo->ea, cryptoInfo->master_keydata, cryptoInfo->ks);

  00268	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  0026b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00270	50		 push	 eax
  00271	8d 83 50 1c 00
	00		 lea	 eax, DWORD PTR [ebx+7248]
  00277	50		 push	 eax
  00278	ff 33		 push	 DWORD PTR [ebx]
  0027a	8d b5 fc fd ff
	ff		 lea	 esi, DWORD PTR _originalK2$[ebp]
  00280	8d bb 50 1d 00
	00		 lea	 edi, DWORD PTR [ebx+7504]
  00286	f3 a5		 rep movsd
  00288	e8 00 00 00 00	 call	 _EAInit
  0028d	8b f0		 mov	 esi, eax
  0028f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1246 : 	if (nStatus != ERR_SUCCESS)

  00292	85 f6		 test	 esi, esi
  00294	0f 85 4a ff ff
	ff		 jne	 $final_seq$93

; 1247 : 		goto final_seq;
; 1248 : 
; 1249 : 	if (!EAInitMode (cryptoInfo))

  0029a	53		 push	 ebx
  0029b	e8 00 00 00 00	 call	 _EAInitMode
  002a0	83 c4 04	 add	 esp, 4
  002a3	85 c0		 test	 eax, eax
  002a5	0f 85 39 ff ff
	ff		 jne	 $final_seq$93
$LN48@WriteRando:

; 1191 : 		{
; 1192 : 			nStatus = ERR_MODE_INIT_FAILED;

  002ab	be 1b 00 00 00	 mov	 esi, 27			; 0000001bH

; 1193 : 			goto final_seq;

  002b0	e9 2f ff ff ff	 jmp	 $final_seq$93
$LN51@WriteRando:

; 1211 : 		{
; 1212 : 			SetLastError (ERROR_INVALID_PARAMETER);

  002b5	6a 57		 push	 87			; 00000057H
  002b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN49@WriteRando:

; 1213 : 			nStatus = ERR_OS_ERROR;

  002bd	be 01 00 00 00	 mov	 esi, 1

; 1214 : 			goto final_seq;

  002c2	e9 1d ff ff ff	 jmp	 $final_seq$93
_WriteRandomDataToReservedHeaderAreas ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _WriteEffectiveVolumeHeader
_TEXT	SEGMENT
_bytesDone$ = -4128					; size = 4
_geometry$ = -4124					; size = 24
_sectorBuffer$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_device$ = 8						; size = 4
_fileHandle$ = 12					; size = 4
_header$ = 16						; size = 4
_WriteEffectiveVolumeHeader PROC			; COMDAT

; 1070 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 20 10 00 00	 mov	 eax, 4128		; 00001020H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1071 : #if GST_VOLUME_HEADER_EFFECTIVE_SIZE > GST_MAX_VOLUME_SECTOR_SIZE
; 1072 : #error GST_VOLUME_HEADER_EFFECTIVE_SIZE > GST_MAX_VOLUME_SECTOR_SIZE
; 1073 : #endif
; 1074 : 
; 1075 : 	byte sectorBuffer[GST_MAX_VOLUME_SECTOR_SIZE];
; 1076 : 	DWORD bytesDone;
; 1077 : 	DISK_GEOMETRY geometry;
; 1078 : 
; 1079 : 	if (!device)

  00017	83 7d 08 00	 cmp	 DWORD PTR _device$[ebp], 0

; 1080 : 	{
; 1081 : 		if (!WriteFile (fileHandle, header, GST_VOLUME_HEADER_EFFECTIVE_SIZE, &bytesDone, NULL))

  0001b	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _bytesDone$[ebp]
  00021	53		 push	 ebx
  00022	8b 5d 0c	 mov	 ebx, DWORD PTR _fileHandle$[ebp]
  00025	56		 push	 esi
  00026	8b 75 10	 mov	 esi, DWORD PTR _header$[ebp]
  00029	6a 00		 push	 0
  0002b	50		 push	 eax
  0002c	75 3a		 jne	 SHORT $LN2@WriteEffec
  0002e	68 00 02 00 00	 push	 512			; 00000200H
  00033	56		 push	 esi
  00034	53		 push	 ebx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 ff 00 00
	00		 je	 $LN16@WriteEffec

; 1082 : 			return FALSE;
; 1083 : 
; 1084 : 		if (bytesDone != GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  00043	81 bd e0 ef ff
	ff 00 02 00 00	 cmp	 DWORD PTR _bytesDone$[ebp], 512 ; 00000200H
  0004d	0f 85 e7 00 00
	00		 jne	 $LN7@WriteEffec

; 1085 : 		{
; 1086 : 			SetLastError (ERROR_INVALID_PARAMETER);
; 1087 : 			return FALSE;
; 1088 : 		}
; 1089 : 
; 1090 : 		return TRUE;

  00053	5e		 pop	 esi
  00054	b8 01 00 00 00	 mov	 eax, 1
  00059	5b		 pop	 ebx

; 1132 : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
$LN2@WriteEffec:

; 1091 : 	}
; 1092 : 
; 1093 : 	if (!DeviceIoControl (fileHandle, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry), &bytesDone, NULL))

  00068	6a 18		 push	 24			; 00000018H
  0006a	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _geometry$[ebp]
  00070	50		 push	 eax
  00071	6a 00		 push	 0
  00073	6a 00		 push	 0
  00075	68 00 00 07 00	 push	 458752			; 00070000H
  0007a	53		 push	 ebx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00081	85 c0		 test	 eax, eax
  00083	0f 84 b9 00 00
	00		 je	 $LN16@WriteEffec

; 1094 : 		return FALSE;
; 1095 : 
; 1096 : 	if (geometry.BytesPerSector > sizeof (sectorBuffer) || geometry.BytesPerSector < GST_MIN_VOLUME_SECTOR_SIZE)

  00089	8b 95 f8 ef ff
	ff		 mov	 edx, DWORD PTR _geometry$[ebp+20]
  0008f	8d 82 00 fe ff
	ff		 lea	 eax, DWORD PTR [edx-512]
  00095	3d 00 0e 00 00	 cmp	 eax, 3584		; 00000e00H
  0009a	0f 87 9a 00 00
	00		 ja	 $LN7@WriteEffec

; 1099 : 		return FALSE;
; 1100 : 	}
; 1101 : 
; 1102 : 	if (geometry.BytesPerSector != GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  000a0	81 fa 00 02 00
	00		 cmp	 edx, 512		; 00000200H
  000a6	74 44		 je	 SHORT $LN11@WriteEffec

; 1103 : 	{
; 1104 : 		LARGE_INTEGER seekOffset;
; 1105 : 
; 1106 : 		if (!ReadFile (fileHandle, sectorBuffer, geometry.BytesPerSector, &bytesDone, NULL))

  000a8	6a 00		 push	 0
  000aa	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _bytesDone$[ebp]
  000b0	50		 push	 eax
  000b1	52		 push	 edx
  000b2	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _sectorBuffer$[ebp]
  000b8	50		 push	 eax
  000b9	53		 push	 ebx
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  000c0	85 c0		 test	 eax, eax
  000c2	74 7e		 je	 SHORT $LN16@WriteEffec

; 1107 : 			return FALSE;
; 1108 : 
; 1109 : 		if (bytesDone != geometry.BytesPerSector)

  000c4	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _bytesDone$[ebp]
  000ca	3b 85 f8 ef ff
	ff		 cmp	 eax, DWORD PTR _geometry$[ebp+20]
  000d0	75 68		 jne	 SHORT $LN7@WriteEffec

; 1110 : 		{
; 1111 : 			SetLastError (ERROR_INVALID_PARAMETER);
; 1112 : 			return FALSE;
; 1113 : 		}
; 1114 : 
; 1115 : 		seekOffset.QuadPart = -(int) bytesDone;
; 1116 : 		if (!SetFilePointerEx (fileHandle, seekOffset, NULL, FILE_CURRENT))

  000d2	6a 01		 push	 1
  000d4	f7 d8		 neg	 eax
  000d6	6a 00		 push	 0
  000d8	99		 cdq
  000d9	52		 push	 edx
  000da	50		 push	 eax
  000db	53		 push	 ebx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000e2	85 c0		 test	 eax, eax
  000e4	74 5c		 je	 SHORT $LN16@WriteEffec

; 1117 : 			return FALSE;

  000e6	8b 95 f8 ef ff
	ff		 mov	 edx, DWORD PTR _geometry$[ebp+20]
$LN11@WriteEffec:
  000ec	57		 push	 edi

; 1118 : 	}
; 1119 : 
; 1120 : 	memcpy (sectorBuffer, header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);
; 1121 : 
; 1122 : 	if (!WriteFile (fileHandle, sectorBuffer, geometry.BytesPerSector, &bytesDone, NULL))

  000ed	6a 00		 push	 0
  000ef	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _bytesDone$[ebp]
  000f5	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000fa	50		 push	 eax
  000fb	52		 push	 edx
  000fc	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _sectorBuffer$[ebp]
  00102	50		 push	 eax
  00103	8d bd fc ef ff
	ff		 lea	 edi, DWORD PTR _sectorBuffer$[ebp]
  00109	f3 a5		 rep movsd
  0010b	53		 push	 ebx
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00112	5f		 pop	 edi
  00113	85 c0		 test	 eax, eax
  00115	74 2b		 je	 SHORT $LN16@WriteEffec

; 1123 : 		return FALSE;
; 1124 : 
; 1125 : 	if (bytesDone != geometry.BytesPerSector)

  00117	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _bytesDone$[ebp]
  0011d	3b 85 f8 ef ff
	ff		 cmp	 eax, DWORD PTR _geometry$[ebp+20]
  00123	75 15		 jne	 SHORT $LN7@WriteEffec

; 1126 : 	{
; 1127 : 		SetLastError (ERROR_INVALID_PARAMETER);
; 1128 : 		return FALSE;
; 1129 : 	}
; 1130 : 
; 1131 : 	return TRUE;

  00125	5e		 pop	 esi
  00126	b8 01 00 00 00	 mov	 eax, 1
  0012b	5b		 pop	 ebx

; 1132 : }

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012f	33 cd		 xor	 ecx, ebp
  00131	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
$LN7@WriteEffec:

; 1097 : 	{
; 1098 : 		SetLastError (ERROR_INVALID_PARAMETER);

  0013a	6a 57		 push	 87			; 00000057H
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN16@WriteEffec:

; 1132 : }

  00142	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00145	33 c0		 xor	 eax, eax
  00147	5e		 pop	 esi
  00148	33 cd		 xor	 ecx, ebp
  0014a	5b		 pop	 ebx
  0014b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
_WriteEffectiveVolumeHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _ReadEffectiveVolumeHeader
_TEXT	SEGMENT
_header$GSCopy$1$ = -4128				; size = 4
_geometry$ = -4124					; size = 24
_sectorBuffer$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_device$ = 8						; size = 4
_fileHandle$ = 12					; size = 4
_header$ = 16						; size = 4
_bytesRead$ = 20					; size = 4
_ReadEffectiveVolumeHeader PROC				; COMDAT

; 1017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 20 10 00 00	 mov	 eax, 4128		; 00001020H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1018 : #if GST_VOLUME_HEADER_EFFECTIVE_SIZE > GST_MAX_VOLUME_SECTOR_SIZE
; 1019 : #error GST_VOLUME_HEADER_EFFECTIVE_SIZE > GST_MAX_VOLUME_SECTOR_SIZE
; 1020 : #endif
; 1021 : 
; 1022 : 	byte sectorBuffer[GST_MAX_VOLUME_SECTOR_SIZE];
; 1023 : 	DISK_GEOMETRY geometry;
; 1024 : 
; 1025 : 	if (!device)

  00017	83 7d 08 00	 cmp	 DWORD PTR _device$[ebp], 0
  0001b	8b 45 10	 mov	 eax, DWORD PTR _header$[ebp]
  0001e	56		 push	 esi
  0001f	8b 75 14	 mov	 esi, DWORD PTR _bytesRead$[ebp]
  00022	57		 push	 edi
  00023	8b 7d 0c	 mov	 edi, DWORD PTR _fileHandle$[ebp]

; 1026 : 		return ReadFile (fileHandle, header, GST_VOLUME_HEADER_EFFECTIVE_SIZE, bytesRead, NULL);

  00026	6a 00		 push	 0
  00028	89 85 e0 ef ff
	ff		 mov	 DWORD PTR _header$GSCopy$1$[ebp], eax
  0002e	56		 push	 esi
  0002f	75 1d		 jne	 SHORT $LN2@ReadEffect
  00031	68 00 02 00 00	 push	 512			; 00000200H
  00036	50		 push	 eax
  00037	57		 push	 edi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 1046 : }

  00040	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00043	33 cd		 xor	 ecx, ebp
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN2@ReadEffect:

; 1027 : 
; 1028 : 	if (!DeviceIoControl (fileHandle, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry), bytesRead, NULL))

  0004e	6a 18		 push	 24			; 00000018H
  00050	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _geometry$[ebp]
  00056	50		 push	 eax
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	68 00 00 07 00	 push	 458752			; 00070000H
  00060	57		 push	 edi
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00067	85 c0		 test	 eax, eax
  00069	0f 84 8c 00 00
	00		 je	 $LN12@ReadEffect

; 1029 : 		return FALSE;
; 1030 : 
; 1031 : 	if (geometry.BytesPerSector > sizeof (sectorBuffer) || geometry.BytesPerSector < GST_MIN_VOLUME_SECTOR_SIZE)

  0006f	8b 8d f8 ef ff
	ff		 mov	 ecx, DWORD PTR _geometry$[ebp+20]
  00075	8d 81 00 fe ff
	ff		 lea	 eax, DWORD PTR [ecx-512]
  0007b	3d 00 0e 00 00	 cmp	 eax, 3584		; 00000e00H
  00080	77 71		 ja	 SHORT $LN5@ReadEffect

; 1034 : 		return FALSE;
; 1035 : 	}
; 1036 : 
; 1037 : 	if (!ReadFile (fileHandle, sectorBuffer, max (GST_VOLUME_HEADER_EFFECTIVE_SIZE, geometry.BytesPerSector), bytesRead, NULL))

  00082	53		 push	 ebx
  00083	6a 00		 push	 0
  00085	bb 00 02 00 00	 mov	 ebx, 512		; 00000200H
  0008a	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _sectorBuffer$[ebp]
  00090	3b cb		 cmp	 ecx, ebx
  00092	56		 push	 esi
  00093	0f 42 cb	 cmovb	 ecx, ebx
  00096	51		 push	 ecx
  00097	50		 push	 eax
  00098	57		 push	 edi
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  0009f	85 c0		 test	 eax, eax
  000a1	75 11		 jne	 SHORT $LN6@ReadEffect
  000a3	5b		 pop	 ebx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi

; 1046 : }

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a9	33 cd		 xor	 ecx, ebp
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
$LN6@ReadEffect:

; 1038 : 		return FALSE;
; 1039 : 
; 1040 : 	memcpy (header, sectorBuffer, min (*bytesRead, GST_VOLUME_HEADER_EFFECTIVE_SIZE));

  000b4	39 1e		 cmp	 DWORD PTR [esi], ebx
  000b6	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _sectorBuffer$[ebp]
  000bc	0f 42 1e	 cmovb	 ebx, DWORD PTR [esi]
  000bf	53		 push	 ebx
  000c0	50		 push	 eax
  000c1	ff b5 e0 ef ff
	ff		 push	 DWORD PTR _header$GSCopy$1$[ebp]
  000c7	e8 00 00 00 00	 call	 _memcpy
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1041 : 	
; 1042 : 	if (*bytesRead > GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  000cf	81 3e 00 02 00
	00		 cmp	 DWORD PTR [esi], 512	; 00000200H
  000d5	76 06		 jbe	 SHORT $LN7@ReadEffect

; 1043 : 		*bytesRead = GST_VOLUME_HEADER_EFFECTIVE_SIZE;

  000d7	c7 06 00 02 00
	00		 mov	 DWORD PTR [esi], 512	; 00000200H
$LN7@ReadEffect:
  000dd	5b		 pop	 ebx
  000de	5f		 pop	 edi

; 1044 : 
; 1045 : 	return TRUE;

  000df	b8 01 00 00 00	 mov	 eax, 1
  000e4	5e		 pop	 esi

; 1046 : }

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e8	33 cd		 xor	 ecx, ebp
  000ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
$LN5@ReadEffect:

; 1032 : 	{
; 1033 : 		SetLastError (ERROR_INVALID_PARAMETER);

  000f3	6a 57		 push	 87			; 00000057H
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN12@ReadEffect:

; 1046 : }

  000fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	33 c0		 xor	 eax, eax
  00100	5f		 pop	 edi
  00101	33 cd		 xor	 ecx, ebp
  00103	5e		 pop	 esi
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
_ReadEffectiveVolumeHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _CreateVolumeHeaderInMemory
_TEXT	SEGMENT
_retInfo$GSCopy$1$ = -36				; size = 4
_cryptoInfo$1$ = -32					; size = 4
_masterKeydata$GSCopy$1$ = -28				; size = 4
_dots3$1$ = -28						; size = 4
_j$1$ = -24						; size = 4
_nUserKeyLen$1$ = -24					; size = 4
tv760 = -24						; size = 4
_tmp2$1 = -20						; size = 8
_password$GSCopy$1$ = -16				; size = 4
_tmp2$2 = -12						; size = 8
_header$GSCopy$1$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_header$ = 12						; size = 4
_ea$ = 16						; size = 4
_mode$ = 20						; size = 4
_password$ = 24						; size = 4
_pkcs5_prf$ = 28					; size = 4
_masterKeydata$ = 32					; size = 4
_retInfo$ = 36						; size = 4
_volumeSize$ = 40					; size = 8
_hiddenVolumeSize$ = 48					; size = 8
_encryptedAreaStart$ = 56				; size = 8
_encryptedAreaLength$ = 64				; size = 8
_requiredProgramVersion$ = 72				; size = 2
_headerFlags$ = 76					; size = 4
_sectorSize$ = 80					; size = 4
_bWipeMode$ = 84					; size = 4
_CreateVolumeHeaderInMemory PROC			; COMDAT

; 761  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 18	 mov	 ecx, DWORD PTR _password$[ebp]
  00013	8b 45 20	 mov	 eax, DWORD PTR _masterKeydata$[ebp]
  00016	89 45 e4	 mov	 DWORD PTR _masterKeydata$GSCopy$1$[ebp], eax
  00019	8b 45 24	 mov	 eax, DWORD PTR _retInfo$[ebp]
  0001c	53		 push	 ebx
  0001d	8b 5d 0c	 mov	 ebx, DWORD PTR _header$[ebp]
  00020	89 45 dc	 mov	 DWORD PTR _retInfo$GSCopy$1$[ebp], eax

; 762  : 	unsigned char *p = (unsigned char *) header;
; 763  : 	static KEY_INFO keyInfo;
; 764  : 
; 765  : 	int nUserKeyLen = password->Length;

  00023	8b 01		 mov	 eax, DWORD PTR [ecx]
  00025	57		 push	 edi
  00026	89 5d f8	 mov	 DWORD PTR _header$GSCopy$1$[ebp], ebx
  00029	89 4d f0	 mov	 DWORD PTR _password$GSCopy$1$[ebp], ecx
  0002c	89 45 e8	 mov	 DWORD PTR _nUserKeyLen$1$[ebp], eax

; 766  : 	PCRYPTO_INFO cryptoInfo = crypto_open ();

  0002f	e8 00 00 00 00	 call	 _crypto_open
  00034	8b f8		 mov	 edi, eax
  00036	89 7d e0	 mov	 DWORD PTR _cryptoInfo$1$[ebp], edi

; 767  : 	static char dk[MASTER_KEYDATA_SIZE];
; 768  : 	int x;
; 769  : 	int retVal = 0;
; 770  : 	int primaryKeyOffset;
; 771  : 
; 772  : 	if (cryptoInfo == NULL)

  00039	85 ff		 test	 edi, edi
  0003b	75 13		 jne	 SHORT $LN28@CreateVolu

; 773  : 		return ERR_OUTOFMEMORY;

  0003d	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00040	5f		 pop	 edi
  00041	5b		 pop	 ebx

; 999  : }

  00042	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00045	33 cd		 xor	 ecx, ebp
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN28@CreateVolu:
  00050	56		 push	 esi

; 774  : 
; 775  : 	memset (header, 0, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00051	68 00 02 00 00	 push	 512			; 00000200H
  00056	6a 00		 push	 0
  00058	53		 push	 ebx
  00059	e8 00 00 00 00	 call	 _memset

; 776  : 
; 777  : 	VirtualLock (&keyInfo, sizeof (keyInfo));

  0005e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualLock@8
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	68 88 01 00 00	 push	 392			; 00000188H
  0006c	68 00 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  00071	ff d6		 call	 esi

; 778  : 	VirtualLock (&dk, sizeof (dk));

  00073	68 00 01 00 00	 push	 256			; 00000100H
  00078	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  0007d	ff d6		 call	 esi

; 779  : 
; 780  : 	/* Encryption setup */
; 781  : 
; 782  : 	if (masterKeydata == NULL)

  0007f	8b 45 e4	 mov	 eax, DWORD PTR _masterKeydata$GSCopy$1$[ebp]
  00082	85 c0		 test	 eax, eax
  00084	75 34		 jne	 SHORT $LN29@CreateVolu

; 783  : 	{
; 784  : 		// We have no master key data (creating a new volume) so we'll use the GostCrypt RNG to generate them
; 785  : 
; 786  : 		int bytesNeeded;
; 787  : 
; 788  : 		switch (mode)
; 789  : 		{
; 790  : 		default:
; 791  : 			bytesNeeded = EAGetKeySize (ea) * 2;	// Size of primary + secondary key(s)

  00086	ff 75 10	 push	 DWORD PTR _ea$[ebp]
  00089	e8 00 00 00 00	 call	 _EAGetKeySize
  0008e	03 c0		 add	 eax, eax

; 792  : 		}
; 793  : 
; 794  : 		if (!RandgetBytes (keyInfo.master_keydata, bytesNeeded, TRUE))

  00090	6a 01		 push	 1
  00092	50		 push	 eax
  00093	68 88 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  00098	e8 00 00 00 00	 call	 _RandgetBytes
  0009d	83 c4 10	 add	 esp, 16			; 00000010H
  000a0	85 c0		 test	 eax, eax
  000a2	75 27		 jne	 SHORT $LN30@CreateVolu
$LN121@CreateVolu:
  000a4	5e		 pop	 esi
  000a5	5f		 pop	 edi

; 795  : 			return ERR_CIPHER_INIT_WEAK_KEY;

  000a6	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  000ab	5b		 pop	 ebx

; 999  : }

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000af	33 cd		 xor	 ecx, ebp
  000b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN29@CreateVolu:

; 796  : 	}
; 797  : 	else
; 798  : 	{
; 799  : 		// We already have existing master key data (the header is being re-encrypted)
; 800  : 		memcpy (keyInfo.master_keydata, masterKeydata, MASTER_KEYDATA_SIZE);

  000ba	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000bf	8b f0		 mov	 esi, eax
  000c1	bf 88 00 00 00	 mov	 edi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  000c6	f3 a5		 rep movsd
  000c8	8b 7d e0	 mov	 edi, DWORD PTR _cryptoInfo$1$[ebp]
$LN30@CreateVolu:

; 801  : 	}
; 802  : 
; 803  : 	// User key 
; 804  : 	memcpy (keyInfo.userKey, password->Text, nUserKeyLen);

  000cb	8b 45 f0	 mov	 eax, DWORD PTR _password$GSCopy$1$[ebp]
  000ce	8b 75 e8	 mov	 esi, DWORD PTR _nUserKeyLen$1$[ebp]
  000d1	83 c0 04	 add	 eax, 4
  000d4	56		 push	 esi
  000d5	50		 push	 eax
  000d6	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  000db	e8 00 00 00 00	 call	 _memcpy

; 805  : 	keyInfo.keyLength = nUserKeyLen;
; 806  : 	keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  000e0	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  000e3	89 35 04 00 00
	00		 mov	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4, esi
  000e9	8b 75 1c	 mov	 esi, DWORD PTR _pkcs5_prf$[ebp]
  000ec	56		 push	 esi
  000ed	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count
  000f2	a3 00 00 00 00	 mov	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9, eax

; 807  : 
; 808  : 	// User selected encryption algorithm
; 809  : 	cryptoInfo->ea = ea;

  000f7	8b 45 10	 mov	 eax, DWORD PTR _ea$[ebp]
  000fa	89 07		 mov	 DWORD PTR [edi], eax

; 810  : 
; 811  : 	// Mode of operation
; 812  : 	cryptoInfo->mode = mode;

  000fc	8b 45 14	 mov	 eax, DWORD PTR _mode$[ebp]
  000ff	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 813  : 
; 814  : 	// Salt for header key derivation
; 815  : 	if (!RandgetBytes (keyInfo.salt, PKCS5_SALT_SIZE, !bWipeMode))

  00102	33 c0		 xor	 eax, eax
  00104	39 45 54	 cmp	 DWORD PTR _bWipeMode$[ebp], eax
  00107	0f 94 c0	 sete	 al
  0010a	50		 push	 eax
  0010b	6a 40		 push	 64			; 00000040H
  0010d	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  00112	e8 00 00 00 00	 call	 _RandgetBytes
  00117	83 c4 20	 add	 esp, 32			; 00000020H
  0011a	85 c0		 test	 eax, eax
  0011c	74 86		 je	 SHORT $LN121@CreateVolu

; 816  : 		return ERR_CIPHER_INIT_WEAK_KEY; 
; 817  : 
; 818  : 	// PBKDF2 (PKCS5) is used to derive primary header key(s) and secondary header key(s) (XTS) from the password/keyfiles
; 819  : 	switch (pkcs5_prf)

  0011e	83 ee 01	 sub	 esi, 1
  00121	74 67		 je	 SHORT $LN35@CreateVolu
  00123	83 ee 01	 sub	 esi, 1
  00126	74 38		 je	 SHORT $LN36@CreateVolu
  00128	83 ee 01	 sub	 esi, 1
  0012b	74 09		 je	 SHORT $LN34@CreateVolu

; 833  : 	default:		
; 834  : 		// Unknown/wrong ID
; 835  : 		GST_THROW_FATAL_EXCEPTION;

  0012d	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00134	eb 7f		 jmp	 SHORT $LN4@CreateVolu
$LN34@CreateVolu:

; 820  : 	{
; 821  : 	case WHIRLPOOL:
; 822  : 		derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  00136	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  0013b	50		 push	 eax
  0013c	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  00141	ff 35 00 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  00147	6a 40		 push	 64			; 00000040H
  00149	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  0014e	ff 35 04 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4
  00154	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  00159	e8 00 00 00 00	 call	 _derive_key_whirlpool

; 823  : 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 824  : 		break;

  0015e	eb 52		 jmp	 SHORT $LN119@CreateVolu
$LN36@CreateVolu:

; 827  : 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 828  : 		break;
; 829  : 	case GOSTHASH:
; 830  : 		derive_key_gosthash (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  00160	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00165	50		 push	 eax
  00166	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  0016b	ff 35 00 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  00171	6a 40		 push	 64			; 00000040H
  00173	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  00178	ff 35 04 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4
  0017e	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  00183	e8 00 00 00 00	 call	 _derive_key_gosthash

; 831  : 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 832  : 		break;

  00188	eb 28		 jmp	 SHORT $LN119@CreateVolu
$LN35@CreateVolu:

; 825  : 	case STRIBOG:
; 826  : 		derive_key_stribog (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  0018a	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  0018f	50		 push	 eax
  00190	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  00195	ff 35 00 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  0019b	6a 40		 push	 64			; 00000040H
  0019d	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  001a2	ff 35 04 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4
  001a8	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  001ad	e8 00 00 00 00	 call	 _derive_key_stribog
$LN119@CreateVolu:
  001b2	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN4@CreateVolu:

; 836  : 	} 
; 837  : 
; 838  : 	/* Header setup */
; 839  : 
; 840  : 	// Salt
; 841  : 	mputBytes (p, keyInfo.salt, PKCS5_SALT_SIZE);	

  001b5	0f 10 05 48 00
	00 00		 movups	 xmm0, XMMWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72

; 842  : 
; 843  : 	// Magic
; 844  : 	mputLong (p, 0x54525545);
; 845  : 
; 846  : 	// Header version
; 847  : 	mputWord (p, VOLUME_HEADER_VERSION);
; 848  : 	cryptoInfo->HeaderVersion = VOLUME_HEADER_VERSION;
; 849  : 
; 850  : 	// Required program version to handle this volume
; 851  : 	switch (mode)
; 852  : 	{
; 853  : 	default:
; 854  : 		mputWord (p, requiredProgramVersion != 0 ? requiredProgramVersion : GST_VOLUME_MIN_REQUIRED_PROGRAM_VERSION);

  001bc	66 8b 4d 48	 mov	 cx, WORD PTR _requiredProgramVersion$[ebp]
  001c0	8d 43 40	 lea	 eax, DWORD PTR [ebx+64]
  001c3	89 45 e8	 mov	 DWORD PTR tv760[ebp], eax
  001c6	8b f0		 mov	 esi, eax
  001c8	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  001cd	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  001d0	0f 10 05 58 00
	00 00		 movups	 xmm0, XMMWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+88
  001d7	0f 11 43 10	 movups	 XMMWORD PTR [ebx+16], xmm0
  001db	0f 10 05 68 00
	00 00		 movups	 xmm0, XMMWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+104
  001e2	0f 11 43 20	 movups	 XMMWORD PTR [ebx+32], xmm0
  001e6	0f 10 05 78 00
	00 00		 movups	 xmm0, XMMWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+120
  001ed	0f 11 43 30	 movups	 XMMWORD PTR [ebx+48], xmm0
  001f1	c7 06 54 52 55
	45		 mov	 DWORD PTR [esi], 1163219540 ; 45555254H
  001f7	66 c7 46 04 13
	00		 mov	 WORD PTR [esi+4], 19	; 00000013H
  001fd	66 89 87 4c 04
	00 00		 mov	 WORD PTR [edi+1100], ax
  00204	66 85 c9	 test	 cx, cx
  00207	74 03		 je	 SHORT $LN53@CreateVolu
  00209	0f b7 c1	 movzx	 eax, cx
$LN53@CreateVolu:
  0020c	c1 e8 08	 shr	 eax, 8
  0020f	88 46 06	 mov	 BYTE PTR [esi+6], al
  00212	0f b7 c1	 movzx	 eax, cx
  00215	66 85 c9	 test	 cx, cx
  00218	75 05		 jne	 SHORT $LN55@CreateVolu
  0021a	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
$LN55@CreateVolu:

; 855  : 	}
; 856  : 
; 857  : 	// CRC of the master key data
; 858  : 	x = GetCrc32(keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  0021f	68 00 01 00 00	 push	 256			; 00000100H
  00224	68 88 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  00229	88 46 07	 mov	 BYTE PTR [esi+7], al
  0022c	e8 00 00 00 00	 call	 _GetCrc32

; 859  : 	mputLong (p, x);

  00231	8b c8		 mov	 ecx, eax
  00233	83 c4 08	 add	 esp, 8
  00236	c1 f9 18	 sar	 ecx, 24			; 00000018H
  00239	88 4e 08	 mov	 BYTE PTR [esi+8], cl
  0023c	8b c8		 mov	 ecx, eax
  0023e	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00241	88 4e 09	 mov	 BYTE PTR [esi+9], cl
  00244	8b c8		 mov	 ecx, eax
  00246	c1 f9 08	 sar	 ecx, 8
  00249	88 4e 0a	 mov	 BYTE PTR [esi+10], cl
  0024c	88 46 0b	 mov	 BYTE PTR [esi+11], al

; 860  : 
; 861  : 	// Reserved fields
; 862  : 	p += 2 * 8;
; 863  : 
; 864  : 	// Size of hidden volume (if any)
; 865  : 	cryptoInfo->hiddenVolumeSize = hiddenVolumeSize;

  0024f	8b 45 30	 mov	 eax, DWORD PTR _hiddenVolumeSize$[ebp]
  00252	89 87 b8 1e 00
	00		 mov	 DWORD PTR [edi+7864], eax
  00258	8b 45 34	 mov	 eax, DWORD PTR _hiddenVolumeSize$[ebp+4]
  0025b	89 87 bc 1e 00
	00		 mov	 DWORD PTR [edi+7868], eax

; 866  : 	mputInt64 (p, cryptoInfo->hiddenVolumeSize);

  00261	0f b6 87 bf 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7871]
  00268	88 46 1c	 mov	 BYTE PTR [esi+28], al
  0026b	0f b6 87 be 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7870]
  00272	88 46 1d	 mov	 BYTE PTR [esi+29], al
  00275	0f b6 87 bd 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7869]
  0027c	88 46 1e	 mov	 BYTE PTR [esi+30], al
  0027f	0f b6 87 bc 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7868]
  00286	88 46 1f	 mov	 BYTE PTR [esi+31], al
  00289	0f b6 87 bb 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7867]
  00290	88 46 20	 mov	 BYTE PTR [esi+32], al
  00293	0f b6 87 ba 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7866]
  0029a	88 46 21	 mov	 BYTE PTR [esi+33], al
  0029d	0f b6 87 b9 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7865]
  002a4	88 46 22	 mov	 BYTE PTR [esi+34], al
  002a7	0f b6 87 b8 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7864]
  002ae	88 46 23	 mov	 BYTE PTR [esi+35], al

; 867  : 
; 868  : 	cryptoInfo->hiddenVolume = cryptoInfo->hiddenVolumeSize != 0;

  002b1	8b 87 b8 1e 00
	00		 mov	 eax, DWORD PTR [edi+7864]
  002b7	0b 87 bc 1e 00
	00		 or	 eax, DWORD PTR [edi+7868]
  002bd	74 07		 je	 SHORT $LN56@CreateVolu
  002bf	b8 01 00 00 00	 mov	 eax, 1
  002c4	eb 02		 jmp	 SHORT $LN57@CreateVolu
$LN56@CreateVolu:
  002c6	33 c0		 xor	 eax, eax
$LN57@CreateVolu:
  002c8	89 87 48 04 00
	00		 mov	 DWORD PTR [edi+1096], eax

; 869  : 
; 870  : 	// Volume size
; 871  : 	cryptoInfo->VolumeSize.Value = volumeSize;

  002ce	8b 55 2c	 mov	 edx, DWORD PTR _volumeSize$[ebp+4]

; 872  : 	mputInt64 (p, volumeSize);

  002d1	8b c2		 mov	 eax, edx
  002d3	8b 5d 28	 mov	 ebx, DWORD PTR _volumeSize$[ebp]
  002d6	8b cb		 mov	 ecx, ebx
  002d8	c1 e8 18	 shr	 eax, 24			; 00000018H
  002db	89 97 f4 1e 00
	00		 mov	 DWORD PTR [edi+7924], edx
  002e1	89 9f f0 1e 00
	00		 mov	 DWORD PTR [edi+7920], ebx
  002e7	88 46 24	 mov	 BYTE PTR [esi+36], al
  002ea	8b c2		 mov	 eax, edx
  002ec	c1 e8 10	 shr	 eax, 16			; 00000010H
  002ef	88 46 25	 mov	 BYTE PTR [esi+37], al
  002f2	8b c2		 mov	 eax, edx
  002f4	c1 e8 08	 shr	 eax, 8
  002f7	88 46 26	 mov	 BYTE PTR [esi+38], al
  002fa	8b c2		 mov	 eax, edx
  002fc	0f ac c1 18	 shrd	 ecx, eax, 24
  00300	88 56 27	 mov	 BYTE PTR [esi+39], dl
  00303	c1 e8 18	 shr	 eax, 24			; 00000018H
  00306	88 4e 28	 mov	 BYTE PTR [esi+40], cl
  00309	8b c2		 mov	 eax, edx
  0030b	8b cb		 mov	 ecx, ebx
  0030d	0f ac c1 10	 shrd	 ecx, eax, 16
  00311	c1 e8 10	 shr	 eax, 16			; 00000010H
  00314	88 4e 29	 mov	 BYTE PTR [esi+41], cl
  00317	8b c3		 mov	 eax, ebx
  00319	0f ac d0 08	 shrd	 eax, edx, 8
  0031d	88 46 2a	 mov	 BYTE PTR [esi+42], al
  00320	88 5e 2b	 mov	 BYTE PTR [esi+43], bl

; 873  : 
; 874  : 	// Encrypted area start
; 875  : 	cryptoInfo->EncryptedAreaStart.Value = encryptedAreaStart;

  00323	8b 5d 38	 mov	 ebx, DWORD PTR _encryptedAreaStart$[ebp]

; 876  : 	mputInt64 (p, encryptedAreaStart);

  00326	8b cb		 mov	 ecx, ebx
  00328	89 9f f8 1e 00
	00		 mov	 DWORD PTR [edi+7928], ebx
  0032e	c1 ea 08	 shr	 edx, 8
  00331	8b 55 3c	 mov	 edx, DWORD PTR _encryptedAreaStart$[ebp+4]
  00334	8b c2		 mov	 eax, edx
  00336	c1 e8 18	 shr	 eax, 24			; 00000018H
  00339	89 97 fc 1e 00
	00		 mov	 DWORD PTR [edi+7932], edx
  0033f	88 46 2c	 mov	 BYTE PTR [esi+44], al
  00342	8b c2		 mov	 eax, edx
  00344	c1 e8 10	 shr	 eax, 16			; 00000010H
  00347	88 46 2d	 mov	 BYTE PTR [esi+45], al
  0034a	8b c2		 mov	 eax, edx
  0034c	c1 e8 08	 shr	 eax, 8
  0034f	88 46 2e	 mov	 BYTE PTR [esi+46], al
  00352	8b c2		 mov	 eax, edx
  00354	0f ac c1 18	 shrd	 ecx, eax, 24
  00358	88 56 2f	 mov	 BYTE PTR [esi+47], dl
  0035b	c1 e8 18	 shr	 eax, 24			; 00000018H
  0035e	88 4e 30	 mov	 BYTE PTR [esi+48], cl
  00361	8b c2		 mov	 eax, edx
  00363	8b cb		 mov	 ecx, ebx
  00365	0f ac c1 10	 shrd	 ecx, eax, 16
  00369	c1 e8 10	 shr	 eax, 16			; 00000010H
  0036c	88 4e 31	 mov	 BYTE PTR [esi+49], cl
  0036f	8b c3		 mov	 eax, ebx
  00371	0f ac d0 08	 shrd	 eax, edx, 8
  00375	88 46 32	 mov	 BYTE PTR [esi+50], al
  00378	88 5e 33	 mov	 BYTE PTR [esi+51], bl

; 877  : 
; 878  : 	// Encrypted area size
; 879  : 	cryptoInfo->EncryptedAreaLength.Value = encryptedAreaLength;

  0037b	8b 5d 40	 mov	 ebx, DWORD PTR _encryptedAreaLength$[ebp]

; 880  : 	mputInt64 (p, encryptedAreaLength);

  0037e	8b cb		 mov	 ecx, ebx
  00380	c1 ea 08	 shr	 edx, 8
  00383	8b 55 44	 mov	 edx, DWORD PTR _encryptedAreaLength$[ebp+4]
  00386	8b c2		 mov	 eax, edx
  00388	c1 e8 18	 shr	 eax, 24			; 00000018H
  0038b	89 9f 00 1f 00
	00		 mov	 DWORD PTR [edi+7936], ebx
  00391	89 97 04 1f 00
	00		 mov	 DWORD PTR [edi+7940], edx
  00397	88 46 34	 mov	 BYTE PTR [esi+52], al
  0039a	8b c2		 mov	 eax, edx
  0039c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0039f	88 46 35	 mov	 BYTE PTR [esi+53], al
  003a2	8b c2		 mov	 eax, edx
  003a4	c1 e8 08	 shr	 eax, 8
  003a7	88 46 36	 mov	 BYTE PTR [esi+54], al
  003aa	8b c2		 mov	 eax, edx
  003ac	0f ac c1 18	 shrd	 ecx, eax, 24
  003b0	88 56 37	 mov	 BYTE PTR [esi+55], dl
  003b3	c1 e8 18	 shr	 eax, 24			; 00000018H
  003b6	88 4e 38	 mov	 BYTE PTR [esi+56], cl
  003b9	8b c2		 mov	 eax, edx
  003bb	8b cb		 mov	 ecx, ebx
  003bd	0f ac c1 10	 shrd	 ecx, eax, 16
  003c1	c1 e8 10	 shr	 eax, 16			; 00000010H
  003c4	88 4e 39	 mov	 BYTE PTR [esi+57], cl
  003c7	8b c3		 mov	 eax, ebx

; 881  : 
; 882  : 	// Flags
; 883  : 	cryptoInfo->HeaderFlags = headerFlags;

  003c9	8b 4d 4c	 mov	 ecx, DWORD PTR _headerFlags$[ebp]
  003cc	0f ac d0 08	 shrd	 eax, edx, 8
  003d0	88 46 3a	 mov	 BYTE PTR [esi+58], al

; 884  : 	mputLong (p, headerFlags);

  003d3	8b c1		 mov	 eax, ecx
  003d5	c1 e8 18	 shr	 eax, 24			; 00000018H
  003d8	88 5e 3b	 mov	 BYTE PTR [esi+59], bl
  003db	89 8f 08 1f 00
	00		 mov	 DWORD PTR [edi+7944], ecx
  003e1	88 46 3c	 mov	 BYTE PTR [esi+60], al
  003e4	8b c1		 mov	 eax, ecx
  003e6	c1 e8 10	 shr	 eax, 16			; 00000010H
  003e9	88 46 3d	 mov	 BYTE PTR [esi+61], al
  003ec	8b c1		 mov	 eax, ecx
  003ee	c1 e8 08	 shr	 eax, 8
  003f1	88 46 3e	 mov	 BYTE PTR [esi+62], al
  003f4	88 4e 3f	 mov	 BYTE PTR [esi+63], cl

; 885  : 
; 886  : 	// Sector size
; 887  : 	if (sectorSize < GST_MIN_VOLUME_SECTOR_SIZE
; 888  : 		|| sectorSize > GST_MAX_VOLUME_SECTOR_SIZE
; 889  : 		|| sectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  003f7	8b 4d 50	 mov	 ecx, DWORD PTR _sectorSize$[ebp]
  003fa	c1 ea 08	 shr	 edx, 8
  003fd	8d 81 00 fe ff
	ff		 lea	 eax, DWORD PTR [ecx-512]
  00403	3d 00 0e 00 00	 cmp	 eax, 3584		; 00000e00H
  00408	77 08		 ja	 SHORT $LN40@CreateVolu
  0040a	f7 c1 ff 01 00
	00		 test	 ecx, 511		; 000001ffH
  00410	74 07		 je	 SHORT $LN39@CreateVolu
$LN40@CreateVolu:

; 890  : 	{
; 891  : 		GST_THROW_FATAL_EXCEPTION;

  00412	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN39@CreateVolu:

; 892  : 	}
; 893  : 
; 894  : 	cryptoInfo->SectorSize = sectorSize;

  00419	89 8f e8 1e 00
	00		 mov	 DWORD PTR [edi+7912], ecx

; 895  : 	mputLong (p, sectorSize);

  0041f	8b c1		 mov	 eax, ecx
  00421	c1 e8 18	 shr	 eax, 24			; 00000018H
  00424	88 46 40	 mov	 BYTE PTR [esi+64], al
  00427	8b c1		 mov	 eax, ecx
  00429	c1 e8 10	 shr	 eax, 16			; 00000010H
  0042c	88 46 41	 mov	 BYTE PTR [esi+65], al
  0042f	8b c1		 mov	 eax, ecx
  00431	c1 e8 08	 shr	 eax, 8

; 896  : 
; 897  : 	// CRC of the header fields
; 898  : 	x = GetCrc32 (header + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC);

  00434	68 bc 00 00 00	 push	 188			; 000000bcH
  00439	88 46 42	 mov	 BYTE PTR [esi+66], al
  0043c	56		 push	 esi
  0043d	88 4e 43	 mov	 BYTE PTR [esi+67], cl
  00440	e8 00 00 00 00	 call	 _GetCrc32

; 899  : 	p = header + GST_HEADER_OFFSET_HEADER_CRC;

  00445	8b 7d f8	 mov	 edi, DWORD PTR _header$GSCopy$1$[ebp]
  00448	8b d8		 mov	 ebx, eax

; 900  : 	mputLong (p, x);

  0044a	8b cb		 mov	 ecx, ebx
  0044c	c1 f8 08	 sar	 eax, 8
  0044f	c1 f9 18	 sar	 ecx, 24			; 00000018H

; 901  : 
; 902  : 	// The master key data
; 903  : 	memcpy (header + HEADER_MASTER_KEYDATA_OFFSET, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  00452	be 88 00 00 00	 mov	 esi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  00457	88 8f fc 00 00
	00		 mov	 BYTE PTR [edi+252], cl
  0045d	8b cb		 mov	 ecx, ebx
  0045f	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00462	88 8f fd 00 00
	00		 mov	 BYTE PTR [edi+253], cl
  00468	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0046d	88 87 fe 00 00
	00		 mov	 BYTE PTR [edi+254], al
  00473	88 9f ff 00 00
	00		 mov	 BYTE PTR [edi+255], bl
  00479	81 c7 00 01 00
	00		 add	 edi, 256		; 00000100H

; 904  : 
; 905  : 
; 906  : 	/* Header encryption */
; 907  : 
; 908  : 	switch (mode)
; 909  : 	{
; 910  : 	default:
; 911  : 		// The secondary key (if cascade, multiple concatenated)
; 912  : 		memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  0047f	8b 5d e0	 mov	 ebx, DWORD PTR _cryptoInfo$1$[ebp]
  00482	f3 a5		 rep movsd
  00484	ff 33		 push	 DWORD PTR [ebx]
  00486	8d b3 50 1d 00
	00		 lea	 esi, DWORD PTR [ebx+7504]
  0048c	e8 00 00 00 00	 call	 _EAGetKeySize
  00491	83 c4 0c	 add	 esp, 12			; 0000000cH
  00494	50		 push	 eax
  00495	ff 33		 push	 DWORD PTR [ebx]
  00497	e8 00 00 00 00	 call	 _EAGetKeySize
  0049c	83 c4 04	 add	 esp, 4
  0049f	05 00 00 00 00	 add	 eax, OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  004a4	50		 push	 eax
  004a5	56		 push	 esi
  004a6	e8 00 00 00 00	 call	 _memcpy

; 913  : 		primaryKeyOffset = 0;
; 914  : 	}
; 915  : 
; 916  : 	retVal = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  004ab	8d 73 08	 lea	 esi, DWORD PTR [ebx+8]
  004ae	56		 push	 esi
  004af	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  004b4	ff 33		 push	 DWORD PTR [ebx]
  004b6	e8 00 00 00 00	 call	 _EAInit
  004bb	83 c4 18	 add	 esp, 24			; 00000018H

; 917  : 	if (retVal != ERR_SUCCESS)

  004be	85 c0		 test	 eax, eax
  004c0	0f 85 4c 02 00
	00		 jne	 $LN118@CreateVolu

; 918  : 		return retVal;
; 919  : 
; 920  : 	// Mode of operation
; 921  : 	if (!EAInitMode (cryptoInfo))

  004c6	53		 push	 ebx
  004c7	e8 00 00 00 00	 call	 _EAInitMode
  004cc	83 c4 04	 add	 esp, 4
  004cf	85 c0		 test	 eax, eax
  004d1	74 6e		 je	 SHORT $LN120@CreateVolu

; 922  : 		return ERR_OUTOFMEMORY;
; 923  : 
; 924  : 
; 925  : 	// Encrypt the entire header (except the salt)
; 926  : 	EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET,

  004d3	53		 push	 ebx
  004d4	6a 00		 push	 0
  004d6	68 c0 01 00 00	 push	 448			; 000001c0H
  004db	ff 75 e8	 push	 DWORD PTR tv760[ebp]
  004de	e8 00 00 00 00	 call	 _EncryptBuffer

; 927  : 		HEADER_ENCRYPTED_DATA_SIZE,
; 928  : 		cryptoInfo);
; 929  : 
; 930  : 
; 931  : 	/* cryptoInfo setup for further use (disk format) */
; 932  : 
; 933  : 	// Init with the master key(s) 
; 934  : 	retVal = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  004e3	56		 push	 esi
  004e4	68 88 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  004e9	ff 33		 push	 DWORD PTR [ebx]
  004eb	e8 00 00 00 00	 call	 _EAInit
  004f0	83 c4 1c	 add	 esp, 28			; 0000001cH

; 935  : 	if (retVal != ERR_SUCCESS)

  004f3	85 c0		 test	 eax, eax
  004f5	0f 85 17 02 00
	00		 jne	 $LN118@CreateVolu

; 936  : 		return retVal;
; 937  : 
; 938  : 	memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
; 939  : 
; 940  : 	switch (cryptoInfo->mode)
; 941  : 	{
; 942  : 	default:
; 943  : 		// The secondary master key (if cascade, multiple concatenated)
; 944  : 		memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  004fb	ff 33		 push	 DWORD PTR [ebx]
  004fd	8d bb 50 1c 00
	00		 lea	 edi, DWORD PTR [ebx+7248]
  00503	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00508	be 88 00 00 00	 mov	 esi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  0050d	f3 a5		 rep movsd
  0050f	e8 00 00 00 00	 call	 _EAGetKeySize
  00514	83 c4 04	 add	 esp, 4
  00517	50		 push	 eax
  00518	ff 33		 push	 DWORD PTR [ebx]
  0051a	e8 00 00 00 00	 call	 _EAGetKeySize
  0051f	83 c4 04	 add	 esp, 4
  00522	05 88 00 00 00	 add	 eax, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  00527	50		 push	 eax
  00528	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  0052e	50		 push	 eax
  0052f	e8 00 00 00 00	 call	 _memcpy

; 945  : 	}
; 946  : 
; 947  : 	// Mode of operation
; 948  : 	if (!EAInitMode (cryptoInfo))

  00534	53		 push	 ebx
  00535	e8 00 00 00 00	 call	 _EAInitMode
  0053a	83 c4 10	 add	 esp, 16			; 00000010H
  0053d	85 c0		 test	 eax, eax
  0053f	75 16		 jne	 SHORT $LN46@CreateVolu
$LN120@CreateVolu:
  00541	5e		 pop	 esi
  00542	5f		 pop	 edi

; 949  : 		return ERR_OUTOFMEMORY;

  00543	b8 02 00 00 00	 mov	 eax, 2
  00548	5b		 pop	 ebx

; 999  : }

  00549	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0054c	33 cd		 xor	 ecx, ebp
  0054e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00553	8b e5		 mov	 esp, ebp
  00555	5d		 pop	 ebp
  00556	c3		 ret	 0
$LN46@CreateVolu:

; 950  : 
; 951  : 
; 952  : #ifdef VOLFORMAT
; 953  : 	if (showKeys && !bInPlaceEncNonSys)

  00557	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _showKeys, 0
  0055e	0f 84 55 01 00
	00		 je	 $LN20@CreateVolu
  00564	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  0056b	0f 85 48 01 00
	00		 jne	 $LN20@CreateVolu

; 954  : 	{
; 955  : 		BOOL dots3 = FALSE;
; 956  : 		int i, j;
; 957  : 
; 958  : 		j = EAGetKeySize (ea);

  00571	ff 75 10	 push	 DWORD PTR _ea$[ebp]
  00574	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dots3$1$[ebp], 0
  0057b	e8 00 00 00 00	 call	 _EAGetKeySize
  00580	83 c4 04	 add	 esp, 4
  00583	89 45 e8	 mov	 DWORD PTR _j$1$[ebp], eax

; 959  : 
; 960  : 		if (j > NBR_KEY_BYTES_TO_DISPLAY)

  00586	83 f8 10	 cmp	 eax, 16			; 00000010H
  00589	7e 0f		 jle	 SHORT $LN48@CreateVolu

; 961  : 		{
; 962  : 			dots3 = TRUE;
; 963  : 			j = NBR_KEY_BYTES_TO_DISPLAY;

  0058b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00590	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _dots3$1$[ebp], 1
  00597	89 45 e8	 mov	 DWORD PTR _j$1$[ebp], eax
$LN48@CreateVolu:

; 964  : 		}
; 965  : 
; 966  : 		MasterKeyGUIView[0] = 0;

  0059a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _MasterKeyGUIView, 0

; 967  : 		for (i = 0; i < j; i++)

  005a1	85 c0		 test	 eax, eax
  005a3	7e 5b		 jle	 SHORT $LN13@CreateVolu
  005a5	33 db		 xor	 ebx, ebx
$LL14@CreateVolu:

; 968  : 		{
; 969  : 			char tmp2[8] = {0};

  005a7	33 c0		 xor	 eax, eax
  005a9	c6 45 f4 00	 mov	 BYTE PTR _tmp2$2[ebp], 0
  005ad	89 45 f5	 mov	 DWORD PTR _tmp2$2[ebp+1], eax
  005b0	66 89 45 f9	 mov	 WORD PTR _tmp2$2[ebp+5], ax
  005b4	88 45 fb	 mov	 BYTE PTR _tmp2$2[ebp+7], al

; 970  : 			sprintf (tmp2, "%02X", (int) (unsigned char) keyInfo.master_keydata[i + primaryKeyOffset]);

  005b7	0f b6 83 88 00
	00 00		 movzx	 eax, BYTE PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9[ebx+136]
  005be	50		 push	 eax
  005bf	8d 45 f4	 lea	 eax, DWORD PTR _tmp2$2[ebp]
  005c2	68 00 00 00 00	 push	 OFFSET ??_C@_04JFFKLGJF@?$CF02X?$AA@
  005c7	50		 push	 eax
  005c8	e8 00 00 00 00	 call	 _sprintf

; 971  : 			strcat (MasterKeyGUIView, tmp2);

  005cd	8d 55 f4	 lea	 edx, DWORD PTR _tmp2$2[ebp]
  005d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  005d3	8b f2		 mov	 esi, edx
$LL102@CreateVolu:
  005d5	8a 02		 mov	 al, BYTE PTR [edx]
  005d7	42		 inc	 edx
  005d8	84 c0		 test	 al, al
  005da	75 f9		 jne	 SHORT $LL102@CreateVolu
  005dc	bf 00 00 00 00	 mov	 edi, OFFSET _MasterKeyGUIView
  005e1	2b d6		 sub	 edx, esi
  005e3	4f		 dec	 edi
$LL103@CreateVolu:
  005e4	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  005e7	47		 inc	 edi
  005e8	84 c0		 test	 al, al
  005ea	75 f8		 jne	 SHORT $LL103@CreateVolu
  005ec	8b ca		 mov	 ecx, edx
  005ee	43		 inc	 ebx
  005ef	c1 e9 02	 shr	 ecx, 2
  005f2	f3 a5		 rep movsd
  005f4	8b ca		 mov	 ecx, edx
  005f6	83 e1 03	 and	 ecx, 3
  005f9	f3 a4		 rep movsb
  005fb	3b 5d e8	 cmp	 ebx, DWORD PTR _j$1$[ebp]
  005fe	7c a7		 jl	 SHORT $LL14@CreateVolu
$LN13@CreateVolu:

; 972  : 		}
; 973  : 
; 974  : 		HeaderKeyGUIView[0] = 0;

  00600	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _HeaderKeyGUIView, 0

; 975  : 		for (i = 0; i < NBR_KEY_BYTES_TO_DISPLAY; i++)

  00607	33 db		 xor	 ebx, ebx
  00609	0f 1f 80 00 00
	00 00		 npad	 7
$LL17@CreateVolu:

; 976  : 		{
; 977  : 			char tmp2[8];
; 978  : 			sprintf (tmp2, "%02X", (int) (unsigned char) dk[primaryKeyOffset + i]);

  00610	0f b6 83 00 00
	00 00		 movzx	 eax, BYTE PTR ?dk@?1??CreateVolumeHeaderInMemory@@9@9[ebx]
  00617	50		 push	 eax
  00618	8d 45 ec	 lea	 eax, DWORD PTR _tmp2$1[ebp]
  0061b	68 00 00 00 00	 push	 OFFSET ??_C@_04JFFKLGJF@?$CF02X?$AA@
  00620	50		 push	 eax
  00621	e8 00 00 00 00	 call	 _sprintf

; 979  : 			strcat (HeaderKeyGUIView, tmp2);

  00626	8d 45 ec	 lea	 eax, DWORD PTR _tmp2$1[ebp]
  00629	83 c4 0c	 add	 esp, 12			; 0000000cH
  0062c	8b f0		 mov	 esi, eax
  0062e	66 90		 npad	 2
$LL104@CreateVolu:
  00630	8a 08		 mov	 cl, BYTE PTR [eax]
  00632	40		 inc	 eax
  00633	84 c9		 test	 cl, cl
  00635	75 f9		 jne	 SHORT $LL104@CreateVolu
  00637	bf 00 00 00 00	 mov	 edi, OFFSET _HeaderKeyGUIView
  0063c	2b c6		 sub	 eax, esi
  0063e	4f		 dec	 edi
  0063f	90		 npad	 1
$LL105@CreateVolu:
  00640	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00643	47		 inc	 edi
  00644	84 c9		 test	 cl, cl
  00646	75 f8		 jne	 SHORT $LL105@CreateVolu
  00648	8b c8		 mov	 ecx, eax
  0064a	43		 inc	 ebx
  0064b	c1 e9 02	 shr	 ecx, 2
  0064e	f3 a5		 rep movsd
  00650	8b c8		 mov	 ecx, eax
  00652	83 e1 03	 and	 ecx, 3
  00655	f3 a4		 rep movsb
  00657	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0065a	7c b4		 jl	 SHORT $LL17@CreateVolu

; 980  : 		}
; 981  : 
; 982  : 		if (dots3)

  0065c	83 7d e4 00	 cmp	 DWORD PTR _dots3$1$[ebp], 0
  00660	8b 5d e0	 mov	 ebx, DWORD PTR _cryptoInfo$1$[ebp]
  00663	74 2c		 je	 SHORT $LN49@CreateVolu

; 983  : 		{
; 984  : 			DisplayPortionsOfKeys (hHeaderKey, hMasterKey, HeaderKeyGUIView, MasterKeyGUIView, !showKeys);

  00665	33 c0		 xor	 eax, eax
  00667	39 05 00 00 00
	00		 cmp	 DWORD PTR _showKeys, eax
  0066d	0f 94 c0	 sete	 al
  00670	50		 push	 eax
  00671	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMasterKey
  00676	68 00 00 00 00	 push	 OFFSET _MasterKeyGUIView
  0067b	68 00 00 00 00	 push	 OFFSET _HeaderKeyGUIView
  00680	50		 push	 eax
  00681	a1 00 00 00 00	 mov	 eax, DWORD PTR _hHeaderKey
  00686	50		 push	 eax
  00687	e8 00 00 00 00	 call	 _DisplayPortionsOfKeys
  0068c	83 c4 14	 add	 esp, 20			; 00000014H

; 985  : 		}

  0068f	eb 28		 jmp	 SHORT $LN20@CreateVolu
$LN49@CreateVolu:

; 986  : 		else
; 987  : 		{
; 988  : 			SendMessage (hMasterKey, WM_SETTEXT, 0, (LPARAM) MasterKeyGUIView);

  00691	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMasterKey
  00696	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  0069c	68 00 00 00 00	 push	 OFFSET _MasterKeyGUIView
  006a1	6a 00		 push	 0
  006a3	6a 0c		 push	 12			; 0000000cH
  006a5	50		 push	 eax
  006a6	ff d6		 call	 esi

; 989  : 			SendMessage (hHeaderKey, WM_SETTEXT, 0, (LPARAM) HeaderKeyGUIView);

  006a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _hHeaderKey
  006ad	68 00 00 00 00	 push	 OFFSET _HeaderKeyGUIView
  006b2	6a 00		 push	 0
  006b4	6a 0c		 push	 12			; 0000000cH
  006b6	50		 push	 eax
  006b7	ff d6		 call	 esi
$LN20@CreateVolu:

; 990  : 		}
; 991  : 	}
; 992  : #endif	// #ifdef VOLFORMAT
; 993  : 
; 994  : 	burn (dk, sizeof(dk));

  006b9	b8 00 00 00 00	 mov	 eax, OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  006be	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  006c3	8b f1		 mov	 esi, ecx
  006c5	8b d0		 mov	 edx, eax
$LL63@CreateVolu:
  006c7	c6 02 00	 mov	 BYTE PTR [edx], 0
  006ca	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  006cd	83 ee 01	 sub	 esi, 1
  006d0	75 f5		 jne	 SHORT $LL63@CreateVolu
$LL21@CreateVolu:
  006d2	c6 00 00	 mov	 BYTE PTR [eax], 0
  006d5	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  006d8	83 e9 01	 sub	 ecx, 1
  006db	75 f5		 jne	 SHORT $LL21@CreateVolu

; 995  : 	burn (&keyInfo, sizeof (keyInfo));

  006dd	b8 00 00 00 00	 mov	 eax, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  006e2	b9 88 01 00 00	 mov	 ecx, 392		; 00000188H
  006e7	8b f1		 mov	 esi, ecx
  006e9	8b d0		 mov	 edx, eax
  006eb	0f 1f 44 00 00	 npad	 5
$LL67@CreateVolu:
  006f0	c6 02 00	 mov	 BYTE PTR [edx], 0
  006f3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  006f6	83 ee 01	 sub	 esi, 1
  006f9	75 f5		 jne	 SHORT $LL67@CreateVolu
  006fb	0f 1f 44 00 00	 npad	 5
$LL26@CreateVolu:
  00700	c6 00 00	 mov	 BYTE PTR [eax], 0
  00703	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00706	83 e9 01	 sub	 ecx, 1
  00709	75 f5		 jne	 SHORT $LL26@CreateVolu

; 996  : 
; 997  : 	*retInfo = cryptoInfo;

  0070b	8b 45 dc	 mov	 eax, DWORD PTR _retInfo$GSCopy$1$[ebp]
  0070e	89 18		 mov	 DWORD PTR [eax], ebx

; 998  : 	return 0;

  00710	33 c0		 xor	 eax, eax
$LN118@CreateVolu:

; 999  : }

  00712	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00715	5e		 pop	 esi
  00716	5f		 pop	 edi
  00717	33 cd		 xor	 ecx, ebp
  00719	5b		 pop	 ebx
  0071a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0071f	8b e5		 mov	 esp, ebp
  00721	5d		 pop	 ebp
  00722	c3		 ret	 0
_CreateVolumeHeaderInMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _ReadVolumeHeader
_TEXT	SEGMENT
_keyDerivationWorkItems$ = -1212			; size = 4
_outstandingWorkItemCount$ = -1212			; size = 4
_encryptionThreadCount$1$ = -1208			; size = 4
_retHeaderCryptoInfo$GSCopy$1$ = -1204			; size = 4
_noOutstandingWorkItemEvent$ = -1200			; size = 4
_pkcs5_prf$1$ = -1196					; size = 4
_enqPkcs5Prf$1$ = -1192					; size = 4
_item$1$ = -1188					; size = 4
_status$1$ = -1188					; size = 4
_keyDerivationCompletedEvent$ = -1184			; size = 4
_encryptedHeader$GSCopy$1$ = -1180			; size = 4
_keyDerivationWorkItems$1$ = -1176			; size = 4
_queuedWorkItems$1$ = -1172				; size = 4
_retInfo$GSCopy$1$ = -1168				; size = 4
_keyInfo$ = -1164					; size = 392
_dk$ = -772						; size = 256
_header$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_encryptedHeader$ = 12					; size = 4
_password$ = 16						; size = 4
_retInfo$ = 20						; size = 4
_retHeaderCryptoInfo$ = 24				; size = 4
_ReadVolumeHeader PROC					; COMDAT

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 04 00
	00		 sub	 esp, 1212		; 000004bcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _encryptedHeader$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 18	 mov	 ebx, DWORD PTR _retHeaderCryptoInfo$[ebp]
  0001a	56		 push	 esi
  0001b	89 85 64 fb ff
	ff		 mov	 DWORD PTR _encryptedHeader$GSCopy$1$[ebp], eax
  00021	8b 45 14	 mov	 eax, DWORD PTR _retInfo$[ebp]
  00024	57		 push	 edi
  00025	8b 7d 10	 mov	 edi, DWORD PTR _password$[ebp]
  00028	89 85 70 fb ff
	ff		 mov	 DWORD PTR _retInfo$GSCopy$1$[ebp], eax
  0002e	89 9d 4c fb ff
	ff		 mov	 DWORD PTR _retHeaderCryptoInfo$GSCopy$1$[ebp], ebx

; 228  : 	char header[GST_VOLUME_HEADER_EFFECTIVE_SIZE];
; 229  : 	KEY_INFO keyInfo;
; 230  : 	PCRYPTO_INFO cryptoInfo;
; 231  : 	char dk[MASTER_KEYDATA_SIZE];
; 232  : 	int enqPkcs5Prf, pkcs5_prf;
; 233  : 	uint16 headerVersion;
; 234  : 	int status = ERR_PARAMETER_INCORRECT;
; 235  : 	int primaryKeyOffset;
; 236  : 
; 237  : 	GST_EVENT keyDerivationCompletedEvent;
; 238  : 	GST_EVENT noOutstandingWorkItemEvent;
; 239  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 240  : 	KeyDerivationWorkItem *item;
; 241  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;
; 242  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  00034	e8 00 00 00 00	 call	 _GetEncryptionThreadCount

; 243  : 	size_t queuedWorkItems = 0;

  00039	33 c9		 xor	 ecx, ecx
  0003b	8b f0		 mov	 esi, eax
  0003d	89 b5 48 fb ff
	ff		 mov	 DWORD PTR _encryptionThreadCount$1$[ebp], esi
  00043	89 8d 6c fb ff
	ff		 mov	 DWORD PTR _queuedWorkItems$1$[ebp], ecx

; 244  : 	LONG outstandingWorkItemCount = 0;

  00049	89 8d 44 fb ff
	ff		 mov	 DWORD PTR _outstandingWorkItemCount$[ebp], ecx

; 245  : 	int i;
; 246  : 
; 247  : 	if (retHeaderCryptoInfo != NULL)

  0004f	85 db		 test	 ebx, ebx
  00051	75 17		 jne	 SHORT $LN45@ReadVolume

; 248  : 	{
; 249  : 		cryptoInfo = retHeaderCryptoInfo;
; 250  : 	}
; 251  : 	else
; 252  : 	{
; 253  : 		cryptoInfo = *retInfo = crypto_open ();

  00053	e8 00 00 00 00	 call	 _crypto_open
  00058	8b d8		 mov	 ebx, eax
  0005a	8b 85 70 fb ff
	ff		 mov	 eax, DWORD PTR _retInfo$GSCopy$1$[ebp]
  00060	89 18		 mov	 DWORD PTR [eax], ebx

; 254  : 		if (cryptoInfo == NULL)

  00062	85 db		 test	 ebx, ebx
  00064	0f 84 86 00 00
	00		 je	 $LN233@ReadVolume
$LN45@ReadVolume:

; 255  : 			return ERR_OUTOFMEMORY;
; 256  : 	}
; 257  : 
; 258  : 	if (encryptionThreadCount > 1)

  0006a	83 fe 01	 cmp	 esi, 1
  0006d	0f 86 93 00 00
	00		 jbe	 $LN216@ReadVolume

; 259  : 	{
; 260  : 		keyDerivationWorkItems = GSTalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00073	68 24 03 00 00	 push	 804			; 00000324H
  00078	e8 00 00 00 00	 call	 _malloc
  0007d	83 c4 04	 add	 esp, 4
  00080	89 85 68 fb ff
	ff		 mov	 DWORD PTR _keyDerivationWorkItems$1$[ebp], eax

; 261  : 		if (!keyDerivationWorkItems)

  00086	85 c0		 test	 eax, eax
  00088	74 66		 je	 SHORT $LN233@ReadVolume

; 262  : 			return ERR_OUTOFMEMORY;
; 263  : 
; 264  : 		for (i = 0; i < pkcs5PrfCount; ++i)
; 265  : 			keyDerivationWorkItems[i].Free = TRUE;
; 266  : 
; 267  : #ifdef DEVICE_DRIVER
; 268  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);
; 269  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);
; 270  : #else
; 271  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  0008a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateEventA@16
  00090	6a 00		 push	 0
  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	6a 00		 push	 0
  00098	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+256], 1
  000a2	c7 80 0c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+524], 1
  000ac	c7 80 18 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+792], 1
  000b6	ff d6		 call	 esi
  000b8	89 85 60 fb ff
	ff		 mov	 DWORD PTR _keyDerivationCompletedEvent$[ebp], eax

; 272  : 		if (!keyDerivationCompletedEvent)

  000be	85 c0		 test	 eax, eax
  000c0	74 20		 je	 SHORT $LN234@ReadVolume

; 273  : 		{
; 274  : 			GSTfree (keyDerivationWorkItems);
; 275  : 			return ERR_OUTOFMEMORY;
; 276  : 		}
; 277  : 
; 278  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);

  000c2	6a 00		 push	 0
  000c4	6a 01		 push	 1
  000c6	6a 00		 push	 0
  000c8	6a 00		 push	 0
  000ca	ff d6		 call	 esi
  000cc	89 85 50 fb ff
	ff		 mov	 DWORD PTR _noOutstandingWorkItemEvent$[ebp], eax

; 279  : 		if (!noOutstandingWorkItemEvent)

  000d2	85 c0		 test	 eax, eax
  000d4	75 3c		 jne	 SHORT $LN49@ReadVolume

; 280  : 		{
; 281  : 			CloseHandle (keyDerivationCompletedEvent);

  000d6	ff b5 60 fb ff
	ff		 push	 DWORD PTR _keyDerivationCompletedEvent$[ebp]
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN234@ReadVolume:

; 282  : 			GSTfree (keyDerivationWorkItems);

  000e2	ff b5 68 fb ff
	ff		 push	 DWORD PTR _keyDerivationWorkItems$1$[ebp]
  000e8	e8 00 00 00 00	 call	 _free
  000ed	83 c4 04	 add	 esp, 4
$LN233@ReadVolume:

; 283  : 			return ERR_OUTOFMEMORY;

  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	b8 02 00 00 00	 mov	 eax, 2
  000f7	5b		 pop	 ebx

; 586  : #endif
; 587  : 	}
; 588  : 
; 589  : 	return status;
; 590  : }

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	33 cd		 xor	 ecx, ebp
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
$LN216@ReadVolume:

; 283  : 			return ERR_OUTOFMEMORY;

  00106	8b 85 44 fb ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$[ebp]
  0010c	89 85 68 fb ff
	ff		 mov	 DWORD PTR _keyDerivationWorkItems$1$[ebp], eax
$LN49@ReadVolume:

; 284  : 		}
; 285  : #endif
; 286  : 	}
; 287  : 		
; 288  : #ifndef DEVICE_DRIVER
; 289  : 	VirtualLock (&keyInfo, sizeof (keyInfo));

  00112	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualLock@8
  00118	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  0011e	68 88 01 00 00	 push	 392			; 00000188H
  00123	50		 push	 eax
  00124	ff d6		 call	 esi

; 290  : 	VirtualLock (&dk, sizeof (dk));

  00126	68 00 01 00 00	 push	 256			; 00000100H
  0012b	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  00131	50		 push	 eax
  00132	ff d6		 call	 esi

; 291  : #endif
; 292  : 
; 293  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  00134	ff 37		 push	 DWORD PTR [edi]
  00136	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00139	50		 push	 eax
  0013a	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _crypto_loadkey

; 294  : 
; 295  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 296  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  00146	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$1$[ebp]
  0014c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  : 
; 298  : 	// Test all available PKCS5 PRFs
; 299  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  0014f	bf 01 00 00 00	 mov	 edi, 1
  00154	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00157	0f 11 85 bc fb
	ff ff		 movups	 XMMWORD PTR _keyInfo$[ebp+72], xmm0
  0015e	0f 10 46 10	 movups	 xmm0, XMMWORD PTR [esi+16]
  00162	0f 11 85 cc fb
	ff ff		 movups	 XMMWORD PTR _keyInfo$[ebp+88], xmm0
  00169	0f 10 46 20	 movups	 xmm0, XMMWORD PTR [esi+32]
  0016d	0f 11 85 dc fb
	ff ff		 movups	 XMMWORD PTR _keyInfo$[ebp+104], xmm0
  00174	0f 10 46 30	 movups	 xmm0, XMMWORD PTR [esi+48]
  00178	0f 11 85 ec fb
	ff ff		 movups	 XMMWORD PTR _keyInfo$[ebp+120], xmm0
$LN232@ReadVolume:
  0017f	8b 95 6c fb ff
	ff		 mov	 edx, DWORD PTR _queuedWorkItems$1$[ebp]
  00185	89 bd 58 fb ff
	ff		 mov	 DWORD PTR _enqPkcs5Prf$1$[ebp], edi
  0018b	83 ff 03	 cmp	 edi, 3
  0018e	7e 08		 jle	 SHORT $LN50@ReadVolume
  00190	85 d2		 test	 edx, edx
  00192	0f 84 fb 03 00
	00		 je	 $LN6@ReadVolume
$LN50@ReadVolume:

; 300  : 	{
; 301  : 
; 302  : 		if (encryptionThreadCount > 1)

  00198	8b 85 48 fb ff
	ff		 mov	 eax, DWORD PTR _encryptionThreadCount$1$[ebp]
  0019e	83 f8 01	 cmp	 eax, 1
  001a1	0f 86 4e 01 00
	00		 jbe	 $LN51@ReadVolume

; 303  : 		{
; 304  : 			// Enqueue key derivation on thread pool
; 305  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  001a7	3b d0		 cmp	 edx, eax
  001a9	0f 83 9c 00 00
	00		 jae	 $LN53@ReadVolume
  001af	83 ff 03	 cmp	 edi, 3
  001b2	0f 8f 93 00 00
	00		 jg	 $LN53@ReadVolume

; 306  : 			{
; 307  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  001b8	8b 85 68 fb ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$1$[ebp]
  001be	33 c9		 xor	 ecx, ecx
$LL10@ReadVolume:

; 308  : 				{
; 309  : 					item = &keyDerivationWorkItems[i];
; 310  : 					if (item->Free)

  001c0	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR [eax+256], 0
  001c7	75 0d		 jne	 SHORT $LN143@ReadVolume

; 306  : 			{
; 307  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  001c9	41		 inc	 ecx
  001ca	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  001cf	83 f9 03	 cmp	 ecx, 3
  001d2	7c ec		 jl	 SHORT $LL10@ReadVolume

; 435  : 				
; 436  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  001d4	eb 6a		 jmp	 SHORT $LN9@ReadVolume
$LN143@ReadVolume:

; 311  : 					{
; 312  : 						item->Free = FALSE;
; 313  : 						item->KeyReady = FALSE;
; 314  : 						item->Pkcs5Prf = enqPkcs5Prf;
; 315  : 
; 316  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,

  001d6	50		 push	 eax
  001d7	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  001da	8d b0 04 01 00
	00		 lea	 esi, DWORD PTR [eax+260]
  001e0	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0
  001ea	57		 push	 edi
  001eb	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  001f1	89 b8 08 01 00
	00		 mov	 DWORD PTR [eax+264], edi
  001f7	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count
  001fc	83 c4 08	 add	 esp, 8
  001ff	50		 push	 eax
  00200	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  00206	50		 push	 eax
  00207	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  0020d	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00213	50		 push	 eax
  00214	57		 push	 edi
  00215	8d 85 44 fb ff
	ff		 lea	 eax, DWORD PTR _outstandingWorkItemCount$[ebp]
  0021b	50		 push	 eax
  0021c	56		 push	 esi
  0021d	8d 85 50 fb ff
	ff		 lea	 eax, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  00223	50		 push	 eax
  00224	8d 85 60 fb ff
	ff		 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  0022a	50		 push	 eax
  0022b	e8 00 00 00 00	 call	 _EncryptionThreadPoolBeginKeyDerivation

; 317  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 318  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);
; 319  : 						
; 320  : 						++queuedWorkItems;

  00230	8b 95 6c fb ff
	ff		 mov	 edx, DWORD PTR _queuedWorkItems$1$[ebp]
  00236	83 c4 28	 add	 esp, 40			; 00000028H
  00239	42		 inc	 edx
  0023a	89 95 6c fb ff
	ff		 mov	 DWORD PTR _queuedWorkItems$1$[ebp], edx
$LN9@ReadVolume:

; 321  : 						break;
; 322  : 					}
; 323  : 				}
; 324  : 
; 325  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  00240	83 ff 03	 cmp	 edi, 3
  00243	0f 8c 3e 03 00
	00		 jl	 $LN5@ReadVolume

; 326  : 					continue;
; 327  : 			}

  00249	eb 07		 jmp	 SHORT $LN133@ReadVolume
$LN53@ReadVolume:

; 328  : 			else
; 329  : 				--enqPkcs5Prf;

  0024b	4f		 dec	 edi
  0024c	89 bd 58 fb ff
	ff		 mov	 DWORD PTR _enqPkcs5Prf$1$[ebp], edi
$LN133@ReadVolume:

; 330  : 
; 331  : 			// Wait for completion of a key derivation
; 332  : 			while (queuedWorkItems > 0)

  00252	85 d2		 test	 edx, edx
  00254	0f 84 2d 03 00
	00		 je	 $LN5@ReadVolume
  0025a	8b bd 68 fb ff
	ff		 mov	 edi, DWORD PTR _keyDerivationWorkItems$1$[ebp]
$LL11@ReadVolume:

; 333  : 			{
; 334  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00260	33 d2		 xor	 edx, edx
  00262	8d 8f 04 01 00
	00		 lea	 ecx, DWORD PTR [edi+260]
  00268	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL15@ReadVolume:

; 335  : 				{
; 336  : 					item = &keyDerivationWorkItems[i];
; 337  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  00270	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  00274	8d b1 fc fe ff
	ff		 lea	 esi, DWORD PTR [ecx-260]
  0027a	89 b5 5c fb ff
	ff		 mov	 DWORD PTR _item$1$[ebp], esi
  00280	75 0b		 jne	 SHORT $LN13@ReadVolume
  00282	33 c0		 xor	 eax, eax
  00284	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00288	83 f8 01	 cmp	 eax, 1
  0028b	74 1c		 je	 SHORT $LN144@ReadVolume
$LN13@ReadVolume:

; 333  : 			{
; 334  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  0028d	42		 inc	 edx
  0028e	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00294	83 fa 03	 cmp	 edx, 3
  00297	7c d7		 jl	 SHORT $LL15@ReadVolume

; 345  : 						goto KeyReady;
; 346  : 					}
; 347  : 				}
; 348  : 
; 349  : 				if (queuedWorkItems > 0)
; 350  : 					GST_WAIT_EVENT (keyDerivationCompletedEvent);

  00299	6a ff		 push	 -1
  0029b	ff b5 60 fb ff
	ff		 push	 DWORD PTR _keyDerivationCompletedEvent$[ebp]
  002a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  002a7	eb b7		 jmp	 SHORT $LL11@ReadVolume
$LN144@ReadVolume:

; 338  : 					{
; 339  : 						pkcs5_prf = item->Pkcs5Prf;

  002a9	8b 86 08 01 00
	00		 mov	 eax, DWORD PTR [esi+264]

; 340  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  002af	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  002b2	89 85 54 fb ff
	ff		 mov	 DWORD PTR _pkcs5_prf$1$[ebp], eax
  002b8	50		 push	 eax
  002b9	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count
  002be	89 85 74 fb ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax

; 341  : 						memcpy (dk, item->DerivedKey, sizeof (dk));

  002c4	8d bd fc fc ff
	ff		 lea	 edi, DWORD PTR _dk$[ebp]

; 342  : 
; 343  : 						item->Free = TRUE;

  002ca	8b 85 5c fb ff
	ff		 mov	 eax, DWORD PTR _item$1$[ebp]
  002d0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002d5	83 c4 08	 add	 esp, 8

; 344  : 						--queuedWorkItems;

  002d8	ff 8d 6c fb ff
	ff		 dec	 DWORD PTR _queuedWorkItems$1$[ebp]
  002de	f3 a5		 rep movsd
  002e0	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+256], 1
$KeyReady$236:

; 351  : 			}
; 352  : 			continue;
; 353  : KeyReady:	;
; 354  : 		}

  002ea	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$1$[ebp]
  002f0	e9 ca 00 00 00	 jmp	 $LN16@ReadVolume
$LN51@ReadVolume:

; 355  : 		else
; 356  : 		{
; 357  : 			pkcs5_prf = enqPkcs5Prf;
; 358  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  002f5	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  002f8	89 bd 54 fb ff
	ff		 mov	 DWORD PTR _pkcs5_prf$1$[ebp], edi
  002fe	57		 push	 edi
  002ff	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count
  00304	89 85 74 fb ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax
  0030a	83 c4 08	 add	 esp, 8

; 359  : 
; 360  : 			switch (pkcs5_prf)

  0030d	8b c7		 mov	 eax, edi
  0030f	83 e8 01	 sub	 eax, 1
  00312	0f 84 76 00 00
	00		 je	 $LN60@ReadVolume
  00318	83 e8 01	 sub	 eax, 1
  0031b	74 41		 je	 SHORT $LN61@ReadVolume
  0031d	83 e8 01	 sub	 eax, 1
  00320	74 0c		 je	 SHORT $LN59@ReadVolume

; 374  : 			default:		
; 375  : 				// Unknown/wrong ID
; 376  : 				GST_THROW_FATAL_EXCEPTION;

  00322	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00329	e9 91 00 00 00	 jmp	 $LN16@ReadVolume
$LN59@ReadVolume:

; 361  : 			{
; 362  : 			case WHIRLPOOL:
; 363  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  0032e	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00333	50		 push	 eax
  00334	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  0033a	50		 push	 eax
  0033b	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  00341	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  00347	6a 40		 push	 64			; 00000040H
  00349	50		 push	 eax
  0034a	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  00350	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00356	50		 push	 eax
  00357	e8 00 00 00 00	 call	 _derive_key_whirlpool

; 364  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 365  : 				break;

  0035c	eb 5e		 jmp	 SHORT $LN231@ReadVolume
$LN61@ReadVolume:

; 368  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 369  : 				break;
; 370  : 			case GOSTHASH:
; 371  : 				derive_key_gosthash (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  0035e	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00363	50		 push	 eax
  00364	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  0036a	50		 push	 eax
  0036b	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  00371	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  00377	6a 40		 push	 64			; 00000040H
  00379	50		 push	 eax
  0037a	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  00380	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00386	50		 push	 eax
  00387	e8 00 00 00 00	 call	 _derive_key_gosthash

; 372  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 373  : 				break;

  0038c	eb 2e		 jmp	 SHORT $LN231@ReadVolume
$LN60@ReadVolume:

; 366  : 			case STRIBOG:
; 367  : 				derive_key_stribog (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  0038e	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00393	50		 push	 eax
  00394	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  0039a	50		 push	 eax
  0039b	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  003a1	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  003a7	6a 40		 push	 64			; 00000040H
  003a9	50		 push	 eax
  003aa	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  003b0	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 _derive_key_stribog
$LN231@ReadVolume:
  003bc	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN16@ReadVolume:

; 377  : 			} 
; 378  : 		}
; 379  : 
; 380  : 		// Test all available modes of operation
; 381  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;

  003bf	c7 43 04 01 00
	00 00		 mov	 DWORD PTR [ebx+4], 1
$LL20@ReadVolume:

; 384  : 		{
; 385  : 			switch (cryptoInfo->mode)
; 386  : 			{
; 387  : 			default:
; 388  : 				primaryKeyOffset = 0;
; 389  : 			}
; 390  : 
; 391  : 			// Test all available encryption algorithms
; 392  : 			for (cryptoInfo->ea = EAGetFirst ();

  003c6	e8 00 00 00 00	 call	 _EAGetFirst
  003cb	89 03		 mov	 DWORD PTR [ebx], eax

; 393  : 				cryptoInfo->ea != 0;

  003cd	85 c0		 test	 eax, eax
  003cf	0f 84 99 01 00
	00		 je	 $LN18@ReadVolume
$LL25@ReadVolume:

; 395  : 			{
; 396  : 				int blockSize;
; 397  : 
; 398  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  003d5	ff 73 04	 push	 DWORD PTR [ebx+4]
  003d8	ff 33		 push	 DWORD PTR [ebx]
  003da	e8 00 00 00 00	 call	 _EAIsModeSupported
  003df	83 c4 08	 add	 esp, 8
  003e2	85 c0		 test	 eax, eax
  003e4	0f 84 6a 01 00
	00		 je	 $LN23@ReadVolume

; 399  : 					continue;	// This encryption algorithm has never been available with this mode of operation
; 400  : 
; 401  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));

  003ea	ff 33		 push	 DWORD PTR [ebx]
  003ec	e8 00 00 00 00	 call	 _EAGetFirstCipher
  003f1	50		 push	 eax
  003f2	e8 00 00 00 00	 call	 _CipherGetBlockSize

; 402  : 
; 403  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  003f7	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  003fa	50		 push	 eax
  003fb	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  00401	50		 push	 eax
  00402	ff 33		 push	 DWORD PTR [ebx]
  00404	e8 00 00 00 00	 call	 _EAInit
  00409	83 c4 14	 add	 esp, 20			; 00000014H
  0040c	89 85 5c fb ff
	ff		 mov	 DWORD PTR _status$1$[ebp], eax

; 404  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00412	83 f8 11	 cmp	 eax, 17			; 00000011H
  00415	0f 84 fb 03 00
	00		 je	 $LN223@ReadVolume

; 405  : 					goto err;
; 406  : 
; 407  : 				// Init objects related to the mode of operation
; 408  : 
; 409  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  0041b	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0041e	83 f9 01	 cmp	 ecx, 1
  00421	74 05		 je	 SHORT $LN67@ReadVolume
  00423	83 f9 02	 cmp	 ecx, 2
  00426	75 3b		 jne	 SHORT $LN68@ReadVolume
$LN67@ReadVolume:

; 410  : 				{
; 411  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 412  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00428	ff 33		 push	 DWORD PTR [ebx]
  0042a	e8 00 00 00 00	 call	 _EAGetKeySize
  0042f	83 c4 04	 add	 esp, 4
  00432	50		 push	 eax
  00433	ff 33		 push	 DWORD PTR [ebx]
  00435	e8 00 00 00 00	 call	 _EAGetKeySize
  0043a	83 c4 04	 add	 esp, 4
  0043d	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR _dk$[ebp]
  00443	03 c1		 add	 eax, ecx
  00445	50		 push	 eax
  00446	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  0044c	50		 push	 eax
  0044d	e8 00 00 00 00	 call	 _memcpy

; 413  : 
; 414  : 					// Secondary key schedule
; 415  : 					if (!EAInitMode (cryptoInfo))

  00452	53		 push	 ebx
  00453	e8 00 00 00 00	 call	 _EAInitMode
  00458	83 c4 10	 add	 esp, 16			; 00000010H
  0045b	85 c0		 test	 eax, eax
  0045d	0f 84 a1 03 00
	00		 je	 $LN146@ReadVolume
$LN68@ReadVolume:

; 416  : 					{
; 417  : 						status = ERR_MODE_INIT_FAILED;
; 418  : 						goto err;
; 419  : 					}
; 420  : 				}
; 421  : 
; 422  : 				// Copy the header for decryption
; 423  : 				memcpy (header, encryptedHeader, sizeof (header));

  00463	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00468	8d bd fc fd ff
	ff		 lea	 edi, DWORD PTR _header$[ebp]
  0046e	f3 a5		 rep movsd

; 424  : 
; 425  : 				// Try to decrypt header 
; 426  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  00470	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00473	83 f8 01	 cmp	 eax, 1
  00476	74 05		 je	 SHORT $LN70@ReadVolume
  00478	83 f8 02	 cmp	 eax, 2
  0047b	75 17		 jne	 SHORT $LN69@ReadVolume
$LN70@ReadVolume:

; 427  : 					DecryptBuffer(header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  0047d	53		 push	 ebx
  0047e	6a 00		 push	 0
  00480	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+64]
  00486	68 c0 01 00 00	 push	 448			; 000001c0H
  0048b	50		 push	 eax
  0048c	e8 00 00 00 00	 call	 _DecryptBuffer
  00491	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@ReadVolume:

; 428  : 
; 429  : 				// Magic 'TRUE'
; 430  : 				if (GetHeaderField32 (header, GST_HEADER_OFFSET_MAGIC) != 0x54525545)

  00494	ff b5 3c fe ff
	ff		 push	 DWORD PTR _header$[ebp+64]
  0049a	e8 00 00 00 00	 call	 _MirrorBytes32
  0049f	83 c4 04	 add	 esp, 4
  004a2	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  004a7	0f 85 a7 00 00
	00		 jne	 $LN23@ReadVolume

; 431  : 					continue;
; 432  : 
; 433  : 				// Header version
; 434  : 				headerVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_VERSION);

  004ad	ff b5 40 fe ff
	ff		 push	 DWORD PTR _header$[ebp+68]
  004b3	e8 00 00 00 00	 call	 _MirrorBytes16
  004b8	0f b7 f8	 movzx	 edi, ax
  004bb	83 c4 04	 add	 esp, 4

; 435  : 				
; 436  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  004be	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  004c3	66 3b f8	 cmp	 di, ax
  004c6	0f 87 df 00 00
	00		 ja	 $LN147@ReadVolume

; 437  : 				{
; 438  : 					status = ERR_NEW_VERSION_REQUIRED;
; 439  : 					goto err;
; 440  : 				}
; 441  : 
; 442  : 				// Check CRC of the header fields
; 443  : 				if (!ReadVolumeHeaderRecoveryMode
; 444  : 					&& headerVersion >= 4
; 445  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC))

  004cc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  004d3	75 2a		 jne	 SHORT $LN73@ReadVolume
  004d5	83 ff 04	 cmp	 edi, 4
  004d8	72 25		 jb	 SHORT $LN73@ReadVolume
  004da	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _header$[ebp+252]
  004e0	e8 00 00 00 00	 call	 _MirrorBytes32
  004e5	8b f0		 mov	 esi, eax
  004e7	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+64]
  004ed	68 bc 00 00 00	 push	 188			; 000000bcH
  004f2	50		 push	 eax
  004f3	e8 00 00 00 00	 call	 _GetCrc32
  004f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  004fb	3b f0		 cmp	 esi, eax
  004fd	75 55		 jne	 SHORT $LN23@ReadVolume
$LN73@ReadVolume:

; 446  : 					continue;
; 447  : 
; 448  : 				// Required program version
; 449  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_REQUIRED_VERSION);

  004ff	ff b5 42 fe ff
	ff		 push	 DWORD PTR _header$[ebp+70]
  00505	e8 00 00 00 00	 call	 _MirrorBytes16
  0050a	83 c4 04	 add	 esp, 4
  0050d	66 89 83 e0 1e
	00 00		 mov	 WORD PTR [ebx+7904], ax

; 450  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  00514	b9 00 06 00 00	 mov	 ecx, 1536		; 00000600H
  00519	66 3b c1	 cmp	 ax, cx
  0051c	1b c0		 sbb	 eax, eax
  0051e	f7 d8		 neg	 eax
  00520	89 83 e4 1e 00
	00		 mov	 DWORD PTR [ebx+7908], eax

; 451  : 
; 452  : 				// Check CRC of the key set
; 453  : 				if (!ReadVolumeHeaderRecoveryMode
; 454  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  00526	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  0052d	75 6e		 jne	 SHORT $LN74@ReadVolume
  0052f	ff b5 44 fe ff
	ff		 push	 DWORD PTR _header$[ebp+72]
  00535	e8 00 00 00 00	 call	 _MirrorBytes32
  0053a	8b f0		 mov	 esi, eax
  0053c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+256]
  00542	68 00 01 00 00	 push	 256			; 00000100H
  00547	50		 push	 eax
  00548	e8 00 00 00 00	 call	 _GetCrc32
  0054d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00550	3b f0		 cmp	 esi, eax
  00552	74 49		 je	 SHORT $LN74@ReadVolume
$LN23@ReadVolume:

; 394  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  00554	ff 33		 push	 DWORD PTR [ebx]
  00556	e8 00 00 00 00	 call	 _EAGetNext
  0055b	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$1$[ebp]
  00561	83 c4 04	 add	 esp, 4
  00564	89 03		 mov	 DWORD PTR [ebx], eax
  00566	85 c0		 test	 eax, eax
  00568	0f 85 67 fe ff
	ff		 jne	 $LL25@ReadVolume
$LN18@ReadVolume:

; 382  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 383  : 			cryptoInfo->mode++)

  0056e	ff 43 04	 inc	 DWORD PTR [ebx+4]
  00571	83 7b 04 02	 cmp	 DWORD PTR [ebx+4], 2
  00575	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$1$[ebp]
  0057b	0f 8e 45 fe ff
	ff		 jle	 $LL20@ReadVolume
  00581	8b bd 58 fb ff
	ff		 mov	 edi, DWORD PTR _enqPkcs5Prf$1$[ebp]
$LN5@ReadVolume:

; 297  : 
; 298  : 	// Test all available PKCS5 PRFs
; 299  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  00587	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$1$[ebp]
  0058d	47		 inc	 edi
  0058e	e9 ec fb ff ff	 jmp	 $LN232@ReadVolume
$LN6@ReadVolume:

; 555  : 			}
; 556  : 		}
; 557  : 	}
; 558  : 	status = ERR_PASSWORD_WRONG;

  00593	bf 03 00 00 00	 mov	 edi, 3
  00598	e9 7f 02 00 00	 jmp	 $LN225@ReadVolume
$LN74@ReadVolume:

; 455  : 					continue;
; 456  : 
; 457  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 458  : 
; 459  : 				// Check the version required to handle this volume
; 460  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  0059d	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  005a2	66 39 83 e0 1e
	00 00		 cmp	 WORD PTR [ebx+7904], ax
  005a9	76 0a		 jbe	 SHORT $LN75@ReadVolume
$LN147@ReadVolume:

; 461  : 				{
; 462  : 					status = ERR_NEW_VERSION_REQUIRED;

  005ab	bf 10 00 00 00	 mov	 edi, 16			; 00000010H

; 463  : 					goto err;

  005b0	e9 67 02 00 00	 jmp	 $LN225@ReadVolume
$LN75@ReadVolume:

; 464  : 				}
; 465  : 
; 466  : 				// Header version
; 467  : 				cryptoInfo->HeaderVersion = headerVersion;

  005b5	66 89 bb 4c 04
	00 00		 mov	 WORD PTR [ebx+1100], di

; 468  : 
; 469  : 				// Volume creation time (legacy)
; 470  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  005bc	ff b5 4c fe ff
	ff		 push	 DWORD PTR _header$[ebp+80]
  005c2	ff b5 48 fe ff
	ff		 push	 DWORD PTR _header$[ebp+76]
  005c8	e8 00 00 00 00	 call	 _MirrorBytes64
  005cd	89 83 98 1e 00
	00		 mov	 DWORD PTR [ebx+7832], eax
  005d3	89 93 9c 1e 00
	00		 mov	 DWORD PTR [ebx+7836], edx

; 471  : 
; 472  : 				// Header creation time (legacy)
; 473  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_MODIFICATION_TIME).Value;

  005d9	ff b5 54 fe ff
	ff		 push	 DWORD PTR _header$[ebp+88]
  005df	ff b5 50 fe ff
	ff		 push	 DWORD PTR _header$[ebp+84]
  005e5	e8 00 00 00 00	 call	 _MirrorBytes64
  005ea	89 83 a0 1e 00
	00		 mov	 DWORD PTR [ebx+7840], eax
  005f0	89 93 a4 1e 00
	00		 mov	 DWORD PTR [ebx+7844], edx

; 474  : 
; 475  : 				// Hidden volume size (if any)
; 476  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  005f6	ff b5 5c fe ff
	ff		 push	 DWORD PTR _header$[ebp+96]
  005fc	ff b5 58 fe ff
	ff		 push	 DWORD PTR _header$[ebp+92]
  00602	e8 00 00 00 00	 call	 _MirrorBytes64
  00607	83 c4 18	 add	 esp, 24			; 00000018H
  0060a	89 83 b8 1e 00
	00		 mov	 DWORD PTR [ebx+7864], eax

; 477  : 
; 478  : 				// Hidden volume status
; 479  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  00610	0b c2		 or	 eax, edx
  00612	89 93 bc 1e 00
	00		 mov	 DWORD PTR [ebx+7868], edx
  00618	74 07		 je	 SHORT $LN89@ReadVolume
  0061a	b8 01 00 00 00	 mov	 eax, 1
  0061f	eb 02		 jmp	 SHORT $LN90@ReadVolume
$LN89@ReadVolume:
  00621	33 c0		 xor	 eax, eax
$LN90@ReadVolume:
  00623	89 83 48 04 00
	00		 mov	 DWORD PTR [ebx+1096], eax

; 480  : 
; 481  : 				// Volume size
; 482  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_SIZE);

  00629	ff b5 64 fe ff
	ff		 push	 DWORD PTR _header$[ebp+104]
  0062f	ff b5 60 fe ff
	ff		 push	 DWORD PTR _header$[ebp+100]
  00635	e8 00 00 00 00	 call	 _MirrorBytes64
  0063a	89 83 f0 1e 00
	00		 mov	 DWORD PTR [ebx+7920], eax
  00640	89 93 f4 1e 00
	00		 mov	 DWORD PTR [ebx+7924], edx

; 483  : 				
; 484  : 				// Encrypted area size and length
; 485  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_START);

  00646	ff b5 6c fe ff
	ff		 push	 DWORD PTR _header$[ebp+112]
  0064c	ff b5 68 fe ff
	ff		 push	 DWORD PTR _header$[ebp+108]
  00652	e8 00 00 00 00	 call	 _MirrorBytes64
  00657	89 83 f8 1e 00
	00		 mov	 DWORD PTR [ebx+7928], eax
  0065d	89 93 fc 1e 00
	00		 mov	 DWORD PTR [ebx+7932], edx

; 486  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  00663	ff b5 74 fe ff
	ff		 push	 DWORD PTR _header$[ebp+120]
  00669	ff b5 70 fe ff
	ff		 push	 DWORD PTR _header$[ebp+116]
  0066f	e8 00 00 00 00	 call	 _MirrorBytes64
  00674	89 83 00 1f 00
	00		 mov	 DWORD PTR [ebx+7936], eax
  0067a	89 93 04 1f 00
	00		 mov	 DWORD PTR [ebx+7940], edx

; 487  : 
; 488  : 				// Flags
; 489  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, GST_HEADER_OFFSET_FLAGS);

  00680	ff b5 78 fe ff
	ff		 push	 DWORD PTR _header$[ebp+124]
  00686	e8 00 00 00 00	 call	 _MirrorBytes32
  0068b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0068e	89 83 08 1f 00
	00		 mov	 DWORD PTR [ebx+7944], eax

; 490  : 
; 491  : 				// Sector size
; 492  : 				if (headerVersion >= 5)

  00694	83 ff 05	 cmp	 edi, 5
  00697	72 16		 jb	 SHORT $LN76@ReadVolume

; 493  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, GST_HEADER_OFFSET_SECTOR_SIZE);

  00699	ff b5 7c fe ff
	ff		 push	 DWORD PTR _header$[ebp+128]
  0069f	e8 00 00 00 00	 call	 _MirrorBytes32
  006a4	83 c4 04	 add	 esp, 4
  006a7	89 83 e8 1e 00
	00		 mov	 DWORD PTR [ebx+7912], eax
  006ad	eb 0a		 jmp	 SHORT $LN77@ReadVolume
$LN76@ReadVolume:

; 494  : 				else
; 495  : 					cryptoInfo->SectorSize = GST_SECTOR_SIZE_LEGACY;

  006af	c7 83 e8 1e 00
	00 00 02 00 00	 mov	 DWORD PTR [ebx+7912], 512 ; 00000200H
$LN77@ReadVolume:

; 496  : 
; 497  : 				if (cryptoInfo->SectorSize < GST_MIN_VOLUME_SECTOR_SIZE
; 498  : 					|| cryptoInfo->SectorSize > GST_MAX_VOLUME_SECTOR_SIZE
; 499  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  006b9	8b 83 e8 1e 00
	00		 mov	 eax, DWORD PTR [ebx+7912]
  006bf	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  006c4	0f 82 45 01 00
	00		 jb	 $LN79@ReadVolume
  006ca	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  006cf	0f 87 3a 01 00
	00		 ja	 $LN79@ReadVolume
  006d5	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  006da	0f 85 2f 01 00
	00		 jne	 $LN79@ReadVolume

; 502  : 					goto err;
; 503  : 				}
; 504  : 
; 505  : 				// Preserve scheduled header keys if requested			
; 506  : 				if (retHeaderCryptoInfo)

  006e0	8b bd 4c fb ff
	ff		 mov	 edi, DWORD PTR _retHeaderCryptoInfo$GSCopy$1$[ebp]
  006e6	85 ff		 test	 edi, edi
  006e8	74 51		 je	 SHORT $LN80@ReadVolume

; 507  : 				{
; 508  : 					if (retInfo == NULL)

  006ea	8b b5 70 fb ff
	ff		 mov	 esi, DWORD PTR _retInfo$GSCopy$1$[ebp]
  006f0	85 f6		 test	 esi, esi
  006f2	75 23		 jne	 SHORT $LN81@ReadVolume

; 509  : 					{
; 510  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  006f4	8b 85 54 fb ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$1$[ebp]

; 511  : 						cryptoInfo->noIterations = keyInfo.noIterations;
; 512  : 						goto ret;

  006fa	8b bd 5c fb ff
	ff		 mov	 edi, DWORD PTR _status$1$[ebp]
  00700	89 83 94 1e 00
	00		 mov	 DWORD PTR [ebx+7828], eax
  00706	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  0070c	89 83 90 1e 00
	00		 mov	 DWORD PTR [ebx+7824], eax
  00712	e9 22 01 00 00	 jmp	 $ret$237
$LN81@ReadVolume:

; 513  : 					}
; 514  : 
; 515  : 					cryptoInfo = *retInfo = crypto_open ();

  00717	e8 00 00 00 00	 call	 _crypto_open
  0071c	8b d8		 mov	 ebx, eax
  0071e	89 1e		 mov	 DWORD PTR [esi], ebx

; 516  : 					if (cryptoInfo == NULL)

  00720	85 db		 test	 ebx, ebx
  00722	75 08		 jne	 SHORT $LN82@ReadVolume

; 517  : 					{
; 518  : 						status = ERR_OUTOFMEMORY;

  00724	8d 78 02	 lea	 edi, DWORD PTR [eax+2]

; 519  : 						goto err;

  00727	e9 f6 00 00 00	 jmp	 $err$238
$LN82@ReadVolume:

; 520  : 					}
; 521  : 
; 522  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  0072c	68 10 1f 00 00	 push	 7952			; 00001f10H
  00731	57		 push	 edi
  00732	53		 push	 ebx
  00733	e8 00 00 00 00	 call	 _memcpy
  00738	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN80@ReadVolume:

; 523  : 				}
; 524  : 
; 525  : 				// Master key data
; 526  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);
; 527  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
; 528  : 
; 529  : 				// PKCS #5
; 530  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);
; 531  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  0073b	8b 85 54 fb ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$1$[ebp]
  00741	8d b5 fc fe ff
	ff		 lea	 esi, DWORD PTR _header$[ebp+256]
  00747	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0074c	8d bd fc fb ff
	ff		 lea	 edi, DWORD PTR _keyInfo$[ebp+136]
  00752	f3 a5		 rep movsd
  00754	8d bb 50 1c 00
	00		 lea	 edi, DWORD PTR [ebx+7248]
  0075a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0075f	8d b5 fc fb ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+136]
  00765	f3 a5		 rep movsd
  00767	0f 10 85 bc fb
	ff ff		 movups	 xmm0, XMMWORD PTR _keyInfo$[ebp+72]
  0076e	0f 11 83 50 1e
	00 00		 movups	 XMMWORD PTR [ebx+7760], xmm0
  00775	0f 10 85 cc fb
	ff ff		 movups	 xmm0, XMMWORD PTR _keyInfo$[ebp+88]
  0077c	0f 11 83 60 1e
	00 00		 movups	 XMMWORD PTR [ebx+7776], xmm0
  00783	0f 10 85 dc fb
	ff ff		 movups	 xmm0, XMMWORD PTR _keyInfo$[ebp+104]
  0078a	0f 11 83 70 1e
	00 00		 movups	 XMMWORD PTR [ebx+7792], xmm0
  00791	0f 10 85 ec fb
	ff ff		 movups	 xmm0, XMMWORD PTR _keyInfo$[ebp+120]
  00798	89 83 94 1e 00
	00		 mov	 DWORD PTR [ebx+7828], eax
  0079e	0f 11 83 80 1e
	00 00		 movups	 XMMWORD PTR [ebx+7808], xmm0

; 532  : 				cryptoInfo->noIterations = keyInfo.noIterations;

  007a5	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  007ab	89 83 90 1e 00
	00		 mov	 DWORD PTR [ebx+7824], eax

; 533  : 
; 534  : 				// Init the cipher with the decrypted master key
; 535  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  007b1	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  007b4	50		 push	 eax
  007b5	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+136]
  007bb	50		 push	 eax
  007bc	ff 33		 push	 DWORD PTR [ebx]
  007be	e8 00 00 00 00	 call	 _EAInit
  007c3	8b f8		 mov	 edi, eax
  007c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 536  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  007c8	83 ff 11	 cmp	 edi, 17			; 00000011H
  007cb	74 4f		 je	 SHORT $LN225@ReadVolume

; 537  : 					goto err;
; 538  : 
; 539  : 				switch (cryptoInfo->mode)
; 540  : 				{
; 541  : 				default:
; 542  : 					// The secondary master key (if cascade, multiple concatenated)
; 543  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  007cd	ff 33		 push	 DWORD PTR [ebx]
  007cf	e8 00 00 00 00	 call	 _EAGetKeySize
  007d4	83 c4 04	 add	 esp, 4
  007d7	50		 push	 eax
  007d8	ff 33		 push	 DWORD PTR [ebx]
  007da	e8 00 00 00 00	 call	 _EAGetKeySize
  007df	83 c4 04	 add	 esp, 4
  007e2	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp+136]
  007e8	03 c1		 add	 eax, ecx
  007ea	50		 push	 eax
  007eb	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  007f1	50		 push	 eax
  007f2	e8 00 00 00 00	 call	 _memcpy

; 544  : 
; 545  : 				}
; 546  : 
; 547  : 				if (!EAInitMode (cryptoInfo))

  007f7	53		 push	 ebx
  007f8	e8 00 00 00 00	 call	 _EAInitMode
  007fd	83 c4 10	 add	 esp, 16			; 00000010H
  00800	85 c0		 test	 eax, eax
  00802	75 07		 jne	 SHORT $LN85@ReadVolume
$LN146@ReadVolume:

; 548  : 				{
; 549  : 					status = ERR_MODE_INIT_FAILED;

  00804	bf 1b 00 00 00	 mov	 edi, 27			; 0000001bH

; 550  : 					goto err;

  00809	eb 11		 jmp	 SHORT $LN225@ReadVolume
$LN85@ReadVolume:

; 551  : 				}
; 552  : 
; 553  : 				status = ERR_SUCCESS;

  0080b	33 ff		 xor	 edi, edi

; 554  : 				goto ret;

  0080d	eb 2a		 jmp	 SHORT $ret$237
$LN79@ReadVolume:

; 500  : 				{
; 501  : 					status = ERR_PARAMETER_INCORRECT;

  0080f	bf 1e 00 00 00	 mov	 edi, 30			; 0000001eH
  00814	eb 06		 jmp	 SHORT $LN225@ReadVolume
$LN223@ReadVolume:
  00816	8b bd 5c fb ff
	ff		 mov	 edi, DWORD PTR _status$1$[ebp]
$LN225@ReadVolume:
  0081c	8b b5 70 fb ff
	ff		 mov	 esi, DWORD PTR _retInfo$GSCopy$1$[ebp]
$err$238:

; 559  : 
; 560  : err:
; 561  : 	if (cryptoInfo != retHeaderCryptoInfo)

  00822	3b 9d 4c fb ff
	ff		 cmp	 ebx, DWORD PTR _retHeaderCryptoInfo$GSCopy$1$[ebp]
  00828	74 0f		 je	 SHORT $ret$237

; 562  : 	{
; 563  : 		crypto_close(cryptoInfo);

  0082a	53		 push	 ebx
  0082b	e8 00 00 00 00	 call	 _crypto_close
  00830	83 c4 04	 add	 esp, 4

; 564  : 		*retInfo = NULL; 

  00833	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$ret$237:

; 565  : 	}
; 566  : 
; 567  : ret:
; 568  : 	burn (&keyInfo, sizeof (keyInfo));

  00839	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  0083f	b9 88 01 00 00	 mov	 ecx, 392		; 00000188H
  00844	8b f1		 mov	 esi, ecx
  00846	8b d0		 mov	 edx, eax
  00848	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL118@ReadVolume:
  00850	c6 02 00	 mov	 BYTE PTR [edx], 0
  00853	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00856	83 ee 01	 sub	 esi, 1
  00859	75 f5		 jne	 SHORT $LL118@ReadVolume
  0085b	0f 1f 44 00 00	 npad	 5
$LL31@ReadVolume:
  00860	c6 00 00	 mov	 BYTE PTR [eax], 0
  00863	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00866	83 e9 01	 sub	 ecx, 1
  00869	75 f5		 jne	 SHORT $LL31@ReadVolume

; 569  : 	burn (dk, sizeof(dk));

  0086b	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  00871	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00876	8b f1		 mov	 esi, ecx
  00878	8b d0		 mov	 edx, eax
  0087a	66 0f 1f 44 00
	00		 npad	 6
$LL122@ReadVolume:
  00880	c6 02 00	 mov	 BYTE PTR [edx], 0
  00883	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00886	83 ee 01	 sub	 esi, 1
  00889	75 f5		 jne	 SHORT $LL122@ReadVolume
  0088b	0f 1f 44 00 00	 npad	 5
$LL36@ReadVolume:
  00890	c6 00 00	 mov	 BYTE PTR [eax], 0
  00893	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00896	83 e9 01	 sub	 ecx, 1
  00899	75 f5		 jne	 SHORT $LL36@ReadVolume

; 570  : 
; 571  : #ifndef DEVICE_DRIVER
; 572  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));

  0089b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualUnlock@8
  008a1	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  008a7	68 88 01 00 00	 push	 392			; 00000188H
  008ac	50		 push	 eax
  008ad	ff d6		 call	 esi

; 573  : 	VirtualUnlock (&dk, sizeof (dk));

  008af	68 00 01 00 00	 push	 256			; 00000100H
  008b4	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  008ba	50		 push	 eax
  008bb	ff d6		 call	 esi

; 574  : #endif
; 575  : 
; 576  : 	if (encryptionThreadCount > 1)

  008bd	83 bd 48 fb ff
	ff 01		 cmp	 DWORD PTR _encryptionThreadCount$1$[ebp], 1
  008c4	76 54		 jbe	 SHORT $LN87@ReadVolume

; 577  : 	{
; 578  : 		GST_WAIT_EVENT (noOutstandingWorkItemEvent);

  008c6	6a ff		 push	 -1
  008c8	ff b5 50 fb ff
	ff		 push	 DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  008ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 579  : 
; 580  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  008d4	8b 9d 68 fb ff
	ff		 mov	 ebx, DWORD PTR _keyDerivationWorkItems$1$[ebp]
  008da	b9 24 03 00 00	 mov	 ecx, 804		; 00000324H
  008df	8b c3		 mov	 eax, ebx
  008e1	8b f1		 mov	 esi, ecx
  008e3	8b d3		 mov	 edx, ebx
$LL126@ReadVolume:
  008e5	c6 02 00	 mov	 BYTE PTR [edx], 0
  008e8	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  008eb	83 ee 01	 sub	 esi, 1
  008ee	75 f5		 jne	 SHORT $LL126@ReadVolume
$LL41@ReadVolume:
  008f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  008f3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  008f6	83 e9 01	 sub	 ecx, 1
  008f9	75 f5		 jne	 SHORT $LL41@ReadVolume

; 581  : 		GSTfree (keyDerivationWorkItems);

  008fb	53		 push	 ebx
  008fc	e8 00 00 00 00	 call	 _free

; 582  : 
; 583  : #ifndef DEVICE_DRIVER
; 584  : 		CloseHandle (keyDerivationCompletedEvent);

  00901	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00907	83 c4 04	 add	 esp, 4
  0090a	ff b5 60 fb ff
	ff		 push	 DWORD PTR _keyDerivationCompletedEvent$[ebp]
  00910	ff d6		 call	 esi

; 585  : 		CloseHandle (noOutstandingWorkItemEvent);

  00912	ff b5 50 fb ff
	ff		 push	 DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  00918	ff d6		 call	 esi
$LN87@ReadVolume:

; 586  : #endif
; 587  : 	}
; 588  : 
; 589  : 	return status;
; 590  : }

  0091a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0091d	8b c7		 mov	 eax, edi
  0091f	5f		 pop	 edi
  00920	5e		 pop	 esi
  00921	33 cd		 xor	 ecx, ebp
  00923	5b		 pop	 ebx
  00924	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00929	8b e5		 mov	 esp, ebp
  0092b	5d		 pop	 ebp
  0092c	c3		 ret	 0
_ReadVolumeHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _GetHeaderField64
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField64 PROC					; COMDAT

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 179  : 	UINT64_STRUCT uint64Struct;
; 180  : 
; 181  : #ifndef GST_NO_COMPILER_INT64
; 182  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _header$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00009	ff 74 01 04	 push	 DWORD PTR [ecx+eax+4]
  0000d	ff 34 01	 push	 DWORD PTR [ecx+eax]
  00010	e8 00 00 00 00	 call	 _MirrorBytes64
  00015	83 c4 08	 add	 esp, 8

; 183  : #else
; 184  : 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; 185  : 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; 186  : #endif
; 187  : 	return uint64Struct;
; 188  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_GetHeaderField64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _GetHeaderField32
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField32 PROC					; COMDAT

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 164  : 	return BE32 (*(uint32 *) (header + offset));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  00009	ff 34 08	 push	 DWORD PTR [eax+ecx]
  0000c	e8 00 00 00 00	 call	 _MirrorBytes32
  00011	83 c4 04	 add	 esp, 4

; 165  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_GetHeaderField32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _GetHeaderField16
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField16 PROC					; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 149  : 	return BE16 (*(uint16 *) (header + offset));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  00009	0f b7 04 08	 movzx	 eax, WORD PTR [eax+ecx]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _MirrorBytes16
  00013	83 c4 04	 add	 esp, 4

; 150  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_GetHeaderField16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
