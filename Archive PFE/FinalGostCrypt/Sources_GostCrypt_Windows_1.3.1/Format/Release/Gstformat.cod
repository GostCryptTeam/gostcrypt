; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Format\Gstformat.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BootEncObj@@3PAVBootEncryption@GostCrypt@@A	; BootEncObj
PUBLIC	?BootEncStatus@@3UBootEncryptionStatus@@A	; BootEncStatus
PUBLIC	?nCurPageNo@@3HA				; nCurPageNo
PUBLIC	?nLastPageNo@@3HA				; nLastPageNo
PUBLIC	?bHiddenOS@@3HC					; bHiddenOS
PUBLIC	?bDirectSysEncMode@@3HA				; bDirectSysEncMode
PUBLIC	?bDirectSysEncModeCommand@@3HA			; bDirectSysEncModeCommand
PUBLIC	?DirectDeviceEncMode@@3HA			; DirectDeviceEncMode
PUBLIC	?DirectNonSysInplaceEncResumeMode@@3HA		; DirectNonSysInplaceEncResumeMode
PUBLIC	?DirectPromptNonSysInplaceEncResumeMode@@3HA	; DirectPromptNonSysInplaceEncResumeMode
PUBLIC	?bDeviceTransformModeChoiceMade@@3HA		; bDeviceTransformModeChoiceMade
PUBLIC	?nNeedToStoreFilesOver4GB@@3HA			; nNeedToStoreFilesOver4GB
PUBLIC	?nVolumeEA@@3HA					; nVolumeEA
PUBLIC	?bSystemEncryptionInProgress@@3HA		; bSystemEncryptionInProgress
PUBLIC	?bWholeSysDrive@@3HA				; bWholeSysDrive
PUBLIC	?bSysEncDriveAnalysisInProgress@@3HC		; bSysEncDriveAnalysisInProgress
PUBLIC	?bSysEncDriveAnalysisTimeOutOccurred@@3HC	; bSysEncDriveAnalysisTimeOutOccurred
PUBLIC	?SysEncDetectHiddenSectors@@3HA			; SysEncDetectHiddenSectors
PUBLIC	?SysEncDriveAnalysisStart@@3HA			; SysEncDriveAnalysisStart
PUBLIC	?bDontVerifyRescueDisk@@3HA			; bDontVerifyRescueDisk
PUBLIC	?bFirstSysEncResumeDone@@3HA			; bFirstSysEncResumeDone
PUBLIC	?nMultiBoot@@3HA				; nMultiBoot
PUBLIC	?bHiddenVol@@3HC				; bHiddenVol
PUBLIC	?bHiddenVolFinished@@3HC			; bHiddenVolFinished
PUBLIC	?hiddenVolHostDriveNo@@3HA			; hiddenVolHostDriveNo
PUBLIC	?realClusterSize@@3HA				; realClusterSize
PUBLIC	?hash_algo@@3HA					; hash_algo
PUBLIC	?nUIVolumeSize@@3_KA				; nUIVolumeSize
PUBLIC	?nVolumeSize@@3_KA				; nVolumeSize
PUBLIC	?nHiddenVolHostSize@@3_KA			; nHiddenVolHostSize
PUBLIC	?nMaximumHiddenVolSize@@3_JA			; nMaximumHiddenVolSize
PUBLIC	?nbrFreeClusters@@3_JA				; nbrFreeClusters
PUBLIC	?nMultiplier@@3HA				; nMultiplier
PUBLIC	?szFileName@@3PADA				; szFileName
PUBLIC	?szDiskFile@@3PADA				; szDiskFile
PUBLIC	?szRescueDiskISO@@3PADA				; szRescueDiskISO
PUBLIC	?bDeviceWipeInProgress@@3HA			; bDeviceWipeInProgress
PUBLIC	?bTryToCorrectReadErrors@@3HC			; bTryToCorrectReadErrors
PUBLIC	?DiscardUnreadableEncryptedSectors@@3HC		; DiscardUnreadableEncryptedSectors
PUBLIC	?bVolTransformThreadRunning@@3HC		; bVolTransformThreadRunning
PUBLIC	?bVolTransformThreadToRun@@3HC			; bVolTransformThreadToRun
PUBLIC	?bConfirmQuit@@3HC				; bConfirmQuit
PUBLIC	?bConfirmQuitSysEncPretest@@3HC			; bConfirmQuitSysEncPretest
PUBLIC	?bDevice@@3HA					; bDevice
PUBLIC	?hRandPool@@3RAUHWND__@@A			; hRandPool
PUBLIC	?hRandPoolSys@@3RAUHWND__@@A			; hRandPoolSys
PUBLIC	?hPasswordInputField@@3RAUHWND__@@A		; hPasswordInputField
PUBLIC	?hVerifyPasswordInputField@@3RAUHWND__@@A	; hVerifyPasswordInputField
PUBLIC	?hbmWizardBitmapRescaled@@3PAUHBITMAP__@@A	; hbmWizardBitmapRescaled
PUBLIC	?OrigKeyboardLayout@@3PADA			; OrigKeyboardLayout
PUBLIC	?bKeyboardLayoutChanged@@3HA			; bKeyboardLayoutChanged
PUBLIC	?bKeybLayoutAltKeyWarningShown@@3HA		; bKeybLayoutAltKeyWarningShown
PUBLIC	?bWarnOuterVolSuitableFileSys@@3HA		; bWarnOuterVolSuitableFileSys
PUBLIC	?volumePassword@@3UPassword@@A			; volumePassword
PUBLIC	?szVerify@@3PADA				; szVerify
PUBLIC	?szRawPassword@@3PADA				; szRawPassword
PUBLIC	?bHistoryCmdLine@@3HA				; bHistoryCmdLine
PUBLIC	?ComServerMode@@3HA				; ComServerMode
PUBLIC	?randPool@@3PAEA				; randPool
PUBLIC	?lastRandPool@@3PAEA				; lastRandPool
PUBLIC	?outRandPoolDispBuffer@@3PAEA			; outRandPoolDispBuffer
PUBLIC	?bDisplayPoolContents@@3HA			; bDisplayPoolContents
PUBLIC	?bSparseFileSwitch@@3HC				; bSparseFileSwitch
PUBLIC	?quickFormat@@3HC				; quickFormat
PUBLIC	?fileSystem@@3HC				; fileSystem
PUBLIC	?clusterSize@@3HC				; clusterSize
PUBLIC	?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A	; SysEncMultiBootCfg
PUBLIC	?SysEncMultiBootCfgOutcome@@3PA_WA		; SysEncMultiBootCfgOutcome
PUBLIC	_showKeys
PUBLIC	_hMasterKey
PUBLIC	_hHeaderKey
PUBLIC	_bHiddenVolHost
PUBLIC	_bHiddenVolDirect
PUBLIC	_bRemovableHostDevice
PUBLIC	_bWarnDeviceFormatAdvanced
PUBLIC	_hCurPage
PUBLIC	_bVolTransformThreadCancel
PUBLIC	_bInPlaceEncNonSysResumed
PUBLIC	_bFirstNonSysInPlaceEncResumeDone
PUBLIC	_bInPlaceEncNonSys
PUBLIC	_NonSysInplaceEncBytesDone
PUBLIC	_NonSysInplaceEncTotalSize
PUBLIC	_nPbar
PUBLIC	_WizardMode
PUBLIC	_HeaderKeyGUIView
PUBLIC	_MasterKeyGUIView
PUBLIC	_NonSysInplaceEncStatus
_BSS	SEGMENT
?BootEncObj@@3PAVBootEncryption@GostCrypt@@A DD 01H DUP (?) ; BootEncObj
?BootEncStatus@@3UBootEncryptionStatus@@A DB 05eH DUP (?) ; BootEncStatus
	ALIGN	4

?bHiddenOS@@3HC DD 01H DUP (?)				; bHiddenOS
?bDirectSysEncMode@@3HA DD 01H DUP (?)			; bDirectSysEncMode
?bDirectSysEncModeCommand@@3HA DD 01H DUP (?)		; bDirectSysEncModeCommand
?DirectDeviceEncMode@@3HA DD 01H DUP (?)		; DirectDeviceEncMode
?DirectNonSysInplaceEncResumeMode@@3HA DD 01H DUP (?)	; DirectNonSysInplaceEncResumeMode
?DirectPromptNonSysInplaceEncResumeMode@@3HA DD 01H DUP (?) ; DirectPromptNonSysInplaceEncResumeMode
?bDeviceTransformModeChoiceMade@@3HA DD 01H DUP (?)	; bDeviceTransformModeChoiceMade
?nNeedToStoreFilesOver4GB@@3HA DD 01H DUP (?)		; nNeedToStoreFilesOver4GB
?bSystemEncryptionInProgress@@3HA DD 01H DUP (?)	; bSystemEncryptionInProgress
?bWholeSysDrive@@3HA DD 01H DUP (?)			; bWholeSysDrive
?bSysEncDriveAnalysisInProgress@@3HC DD 01H DUP (?)	; bSysEncDriveAnalysisInProgress
?bSysEncDriveAnalysisTimeOutOccurred@@3HC DD 01H DUP (?) ; bSysEncDriveAnalysisTimeOutOccurred
?SysEncDriveAnalysisStart@@3HA DD 01H DUP (?)		; SysEncDriveAnalysisStart
?bDontVerifyRescueDisk@@3HA DD 01H DUP (?)		; bDontVerifyRescueDisk
?bFirstSysEncResumeDone@@3HA DD 01H DUP (?)		; bFirstSysEncResumeDone
?nMultiBoot@@3HA DD 01H DUP (?)				; nMultiBoot
?bHiddenVol@@3HC DD 01H DUP (?)				; bHiddenVol
?bHiddenVolFinished@@3HC DD 01H DUP (?)			; bHiddenVolFinished
?realClusterSize@@3HA DD 01H DUP (?)			; realClusterSize
?nUIVolumeSize@@3_KA DQ 01H DUP (?)			; nUIVolumeSize
?nVolumeSize@@3_KA DQ 01H DUP (?)			; nVolumeSize
?nHiddenVolHostSize@@3_KA DQ 01H DUP (?)		; nHiddenVolHostSize
?nMaximumHiddenVolSize@@3_JA DQ 01H DUP (?)		; nMaximumHiddenVolSize
?nbrFreeClusters@@3_JA DQ 01H DUP (?)			; nbrFreeClusters
?szFileName@@3PADA DB 0105H DUP (?)			; szFileName
	ALIGN	4

?szDiskFile@@3PADA DB 0105H DUP (?)			; szDiskFile
	ALIGN	4

?szRescueDiskISO@@3PADA DB 0105H DUP (?)		; szRescueDiskISO
	ALIGN	4

?bDeviceWipeInProgress@@3HA DD 01H DUP (?)		; bDeviceWipeInProgress
?bTryToCorrectReadErrors@@3HC DD 01H DUP (?)		; bTryToCorrectReadErrors
?DiscardUnreadableEncryptedSectors@@3HC DD 01H DUP (?)	; DiscardUnreadableEncryptedSectors
?bVolTransformThreadRunning@@3HC DD 01H DUP (?)		; bVolTransformThreadRunning
?bVolTransformThreadToRun@@3HC DD 01H DUP (?)		; bVolTransformThreadToRun
?bConfirmQuit@@3HC DD 01H DUP (?)			; bConfirmQuit
?bConfirmQuitSysEncPretest@@3HC DD 01H DUP (?)		; bConfirmQuitSysEncPretest
?bDevice@@3HA DD 01H DUP (?)				; bDevice
?hRandPool@@3RAUHWND__@@A DD 01H DUP (?)		; hRandPool
?hRandPoolSys@@3RAUHWND__@@A DD 01H DUP (?)		; hRandPoolSys
?hPasswordInputField@@3RAUHWND__@@A DD 01H DUP (?)	; hPasswordInputField
?hVerifyPasswordInputField@@3RAUHWND__@@A DD 01H DUP (?) ; hVerifyPasswordInputField
?hbmWizardBitmapRescaled@@3PAUHBITMAP__@@A DD 01H DUP (?) ; hbmWizardBitmapRescaled
?bKeyboardLayoutChanged@@3HA DD 01H DUP (?)		; bKeyboardLayoutChanged
?bKeybLayoutAltKeyWarningShown@@3HA DD 01H DUP (?)	; bKeybLayoutAltKeyWarningShown
?volumePassword@@3UPassword@@A DB 048H DUP (?)		; volumePassword
?szVerify@@3PADA DB 041H DUP (?)			; szVerify
	ALIGN	4

?szRawPassword@@3PADA DB 041H DUP (?)			; szRawPassword
	ALIGN	4

?bHistoryCmdLine@@3HA DD 01H DUP (?)			; bHistoryCmdLine
?ComServerMode@@3HA DD 01H DUP (?)			; ComServerMode
?randPool@@3PAEA DB 078H DUP (?)			; randPool
?lastRandPool@@3PAEA DB 078H DUP (?)			; lastRandPool
?outRandPoolDispBuffer@@3PAEA DB 0172H DUP (?)		; outRandPoolDispBuffer
	ALIGN	4

?bSparseFileSwitch@@3HC DD 01H DUP (?)			; bSparseFileSwitch
?quickFormat@@3HC DD 01H DUP (?)			; quickFormat
?fileSystem@@3HC DD 01H DUP (?)				; fileSystem
?clusterSize@@3HC DD 01H DUP (?)			; clusterSize
?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A DB 014H DUP (?) ; SysEncMultiBootCfg
_hMasterKey DD	01H DUP (?)
_hHeaderKey DD	01H DUP (?)
_bHiddenVolHost DD 01H DUP (?)
_bHiddenVolDirect DD 01H DUP (?)
_bRemovableHostDevice DD 01H DUP (?)
_hCurPage DD	01H DUP (?)
_bVolTransformThreadCancel DD 01H DUP (?)
_bInPlaceEncNonSysResumed DD 01H DUP (?)
_bFirstNonSysInPlaceEncResumeDone DD 01H DUP (?)
_bInPlaceEncNonSys DD 01H DUP (?)
	ALIGN	8

_NonSysInplaceEncBytesDone DQ 01H DUP (?)
_NonSysInplaceEncTotalSize DQ 01H DUP (?)
_nPbar	DD	01H DUP (?)
_WizardMode DD	01H DUP (?)
_HeaderKeyGUIView DB 040H DUP (?)
_MasterKeyGUIView DB 040H DUP (?)
_NonSysInplaceEncStatus DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?nCurPageNo@@3HA DD 0ffffffffH				; nCurPageNo
?nLastPageNo@@3HA DD 0ffffffffH				; nLastPageNo
?nVolumeEA@@3HA DD 01H					; nVolumeEA
?SysEncDetectHiddenSectors@@3HA DD 0ffffffffH		; SysEncDetectHiddenSectors
?hiddenVolHostDriveNo@@3HA DD 0ffffffffH		; hiddenVolHostDriveNo
?hash_algo@@3HA DD 01H					; hash_algo
?nMultiplier@@3HA DD 0100000H				; nMultiplier
?OrigKeyboardLayout@@3PADA DB '00000409', 00H		; OrigKeyboardLayout
	ORG $+3
?bWarnOuterVolSuitableFileSys@@3HA DD 01H		; bWarnOuterVolSuitableFileSys
?bDisplayPoolContents@@3HA DD 01H			; bDisplayPoolContents
?SysEncMultiBootCfgOutcome@@3PA_WA DW 04eH		; SysEncMultiBootCfgOutcome
	DW	02fH
	DW	041H
	DW	00H
	ORG $+8184
_showKeys DD	01H
_bWarnDeviceFormatAdvanced DD 01H
_DATA	ENDS
PUBLIC	_WinMain@16
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
PUBLIC	__snwprintf
PUBLIC	_swprintf_s
PUBLIC	??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ ; __vcrt_va_start_verify_argument_type<wchar_t const *>
PUBLIC	?swprintf@@YAHQA_WQB_WZZ			; swprintf
PUBLIC	_fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	_sprintf_s
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z	; std::ctype<wchar_t>::ctype<wchar_t>
PUBLIC	?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<wchar_t>::_Getcat
PUBLIC	??1?$ctype@_W@std@@MAE@XZ			; std::ctype<wchar_t>::~ctype<wchar_t>
PUBLIC	?do_is@?$ctype@_W@std@@MBE_NF_W@Z		; std::ctype<wchar_t>::do_is
PUBLIC	?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z	; std::ctype<wchar_t>::do_is
PUBLIC	?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z	; std::ctype<wchar_t>::do_scan_is
PUBLIC	?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z	; std::ctype<wchar_t>::do_scan_not
PUBLIC	?do_tolower@?$ctype@_W@std@@MBE_W_W@Z		; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z	; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_toupper@?$ctype@_W@std@@MBE_W_W@Z		; std::ctype<wchar_t>::do_toupper
PUBLIC	?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z	; std::ctype<wchar_t>::do_toupper
PUBLIC	?do_widen@?$ctype@_W@std@@MBE_WD@Z		; std::ctype<wchar_t>::do_widen
PUBLIC	?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z	; std::ctype<wchar_t>::do_widen
PUBLIC	?do_narrow@?$ctype@_W@std@@MBED_WD@Z		; std::ctype<wchar_t>::do_narrow
PUBLIC	?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z	; std::ctype<wchar_t>::do_narrow
PUBLIC	??_G?$ctype@_W@std@@MAEPAXI@Z			; std::ctype<wchar_t>::`scalar deleting destructor'
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH@Z			; std::ios_base::clear
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	??1ios_base@std@@UAE@XZ				; std::ios_base::~ios_base
PUBLIC	?_Init@ios_base@std@@IAEXXZ			; std::ios_base::_Init
PUBLIC	??_Gios_base@std@@UAEPAXI@Z			; std::ios_base::`scalar deleting destructor'
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	??1HostDevice@@QAE@XZ				; HostDevice::~HostDevice
PUBLIC	?allocate@?$allocator@UHostDevice@@@std@@QAEPAUHostDevice@@I@Z ; std::allocator<HostDevice>::allocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<HostDevice> >::_Wrap_alloc<std::allocator<HostDevice> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@I@Z ; std::_Wrap_alloc<std::allocator<HostDevice> >::deallocate
PUBLIC	??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::vector<HostDevice,std::allocator<HostDevice> >
PUBLIC	??1?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ ; std::vector<HostDevice,std::allocator<HostDevice> >::~vector<HostDevice,std::allocator<HostDevice> >
PUBLIC	?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::push_back
PUBLIC	?clear@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::clear
PUBLIC	?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::_Reserve
PUBLIC	?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy
PUBLIC	??0HostDevice@@QAE@ABU0@@Z			; HostDevice::HostDevice
PUBLIC	??1Partition@GostCrypt@@QAE@XZ			; GostCrypt::Partition::~Partition
PUBLIC	?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
PUBLIC	??1SystemDriveConfiguration@GostCrypt@@QAE@XZ	; GostCrypt::SystemDriveConfiguration::~SystemDriveConfiguration
PUBLIC	??1Container@ForEach@GostCrypt@@UAE@XZ		; GostCrypt::ForEach::Container::~Container
PUBLIC	??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z	; GostCrypt::ForEach::Container::`scalar deleting destructor'
PUBLIC	_ComboSelChangeEA
PUBLIC	_PrintFreeSpace
PUBLIC	_DisplaySizingErrorText
PUBLIC	_EnableDisableFileNext
PUBLIC	_QueryFreeSpace
PUBLIC	_HandleOldAssignedDriveLetter
PUBLIC	_PageDialogProc@16
PUBLIC	_MainDialogProc@16
PUBLIC	_ExtractCommandLine
PUBLIC	_DisplayRandPool
PUBLIC	_DisplayPortionsOfKeys
PUBLIC	_DetermineMaxHiddenVolSize
PUBLIC	_IsSparseFile
PUBLIC	_GetFileVolSize
PUBLIC	_SwitchWizardToSysEncMode
PUBLIC	_SwitchWizardToFileContainerMode
PUBLIC	_ShowNonSysInPlaceEncUIStatus
PUBLIC	_UpdateNonSysInPlaceEncControls
PUBLIC	_MountHiddenVolHost
PUBLIC	_AnalyzeHiddenVolumeHost
PUBLIC	_ScanVolClusterBitmap
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?SwitchWizardToNonSysDeviceMode@@YAXXZ		; SwitchWizardToNonSysDeviceMode
PUBLIC	?SwitchWizardToHiddenOSMode@@YAHXZ		; SwitchWizardToHiddenOSMode
PUBLIC	?SwitchWizardToNonSysInplaceEncResumeMode@@YAXXZ ; SwitchWizardToNonSysInplaceEncResumeMode
PUBLIC	?GetSystemPartitionSize@@YA_JXZ			; GetSystemPartitionSize
PUBLIC	??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >
PUBLIC	?IsNotEnd@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::IsNotEnd
PUBLIC	?Next@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::Next
PUBLIC	??1?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::~ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >
PUBLIC	??_G?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`scalar deleting destructor'
PUBLIC	??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
PUBLIC	??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::~basic_ostream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
PUBLIC	??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
PUBLIC	?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
PUBLIC	??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
PUBLIC	??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
PUBLIC	??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
PUBLIC	?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail
PUBLIC	?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
PUBLIC	?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
PUBLIC	?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
PUBLIC	?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow
PUBLIC	?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
PUBLIC	?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf
PUBLIC	?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync
PUBLIC	?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue
PUBLIC	??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
PUBLIC	?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos
PUBLIC	?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
PUBLIC	??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor'
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
PUBLIC	?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getcat
PUBLIC	??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput
PUBLIC	?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput
PUBLIC	?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
PUBLIC	?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
PUBLIC	??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
PUBLIC	?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<wchar_t>::grouping
PUBLIC	?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::falsename
PUBLIC	?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::truename
PUBLIC	?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<wchar_t>::_Getcat
PUBLIC	??1?$numpunct@_W@std@@MAE@XZ			; std::numpunct<wchar_t>::~numpunct<wchar_t>
PUBLIC	?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<wchar_t>::_Init
PUBLIC	?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ	; std::numpunct<wchar_t>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ	; std::numpunct<wchar_t>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<wchar_t>::do_grouping
PUBLIC	?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::do_falsename
PUBLIC	?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::do_truename
PUBLIC	?_Tidy@?$numpunct@_W@std@@AAEXXZ		; std::numpunct<wchar_t>::_Tidy
PUBLIC	??_G?$numpunct@_W@std@@MAEPAXI@Z		; std::numpunct<wchar_t>::`scalar deleting destructor'
PUBLIC	??$_Destroy_range@V?$allocator@UHostDevice@@@std@@PAUHostDevice@@@std@@YAXPAUHostDevice@@0AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<HostDevice>,HostDevice *>
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static''
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<HostDevice *,HostDevice *,std::allocator<HostDevice> >
PUBLIC	??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<HostDevice const *,HostDevice *,std::allocator<HostDevice> >
PUBLIC	??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@_W@std@@6B@				; std::ctype<wchar_t>::`vftable'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_C@_09NKHKFHLH@GostCrypt?$AA@			; `string'
PUBLIC	??_7Container@ForEach@GostCrypt@@6B@		; GostCrypt::ForEach::Container::`vftable'
PUBLIC	?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A ; DeferredNonSysInPlaceEncDevices
PUBLIC	??_C@_07MDDLOGBN@?1q?5UAC?5?$AA@		; `string'
PUBLIC	??_C@_05KPBLJGDL@runas?$AA@			; `string'
PUBLIC	??_C@_0P@NDJDHMAP@UAC_INIT_ERROR?$AA@		; `string'
PUBLIC	??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@	; `string'
PUBLIC	??_C@_0CE@LPCKNJKP@CANNOT_SAVE_SYS_ENCRYPTION_SETTI@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BC@IEDCODCO@?6?7?$DMsysencryption?$DO?$AA@ ; `string'
PUBLIC	??_C@_0DE@HMBPOGIN@?6?7?7?$DMconfig?5key?$DN?$CCSystemEncryption@ ; `string'
PUBLIC	??_C@_0CG@BNNHBPIN@?6?7?7?$DMconfig?5key?$DN?$CCWipeMode?$CC?$DO?$CFd?$DM?1co@ ; `string'
PUBLIC	??_C@_0BD@KMABOOHN@?6?7?$DM?1sysencryption?$DO?$AA@ ; `string'
PUBLIC	??_R0?AUException@GostCrypt@@@8			; GostCrypt::Exception `RTTI Type Descriptor'
PUBLIC	??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@ ; `string'
PUBLIC	??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@ ; `string'
PUBLIC	??_C@_02CLCFLINC@?1e?$AA@			; `string'
PUBLIC	??_C@_0N@PLOGBODB@StartOnLogon?$AA@		; `string'
PUBLIC	??_C@_0BM@GHIJBHNC@HiddenSectorDetectionStatus?$AA@ ; `string'
PUBLIC	??_C@_0BC@CGLEBHPJ@SaveVolumeHistory?$AA@	; `string'
PUBLIC	??_C@_0BF@MIMCAHPI@SecurityTokenLibrary?$AA@	; `string'
PUBLIC	??_C@_08BENDAOKD@Language?$AA@			; `string'
PUBLIC	??_C@_0CA@HDGOHFPD@SYSTEM_ENCRYPTION_RESUME_PROMPT?$AA@ ; `string'
PUBLIC	??_C@_0CJ@GFEACENL@SYS_ENCRYPTION_OR_DECRYPTION_IN_@ ; `string'
PUBLIC	??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@ ; `string'
PUBLIC	??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@ ; `string'
PUBLIC	??_C@_0CH@KNBCDPOB@ASK_ENCRYPT_PARTITION_INSTEAD_OF@ ; `string'
PUBLIC	??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@		; `string'
PUBLIC	??_C@_0CB@CKHHFLEI@SYSDRIVE_NON_STANDARD_PARTITIONS@ ; `string'
PUBLIC	??_C@_0CI@HLDNCEMH@WDE_UNSUPPORTED_FOR_EXTENDED_PAR@ ; `string'
PUBLIC	??_C@_0CA@DBKKOPEJ@WDE_EXTENDED_PARTITIONS_WARNING?$AA@ ; `string'
PUBLIC	??_C@_0BH@HHEGHILA@WHOLE_SYC_DEVICE_RECOM?$AA@	; `string'
PUBLIC	??_C@_0CD@NPEEBJKE@HIDDEN_OS_PRECLUDES_SINGLE_KEY_W@ ; `string'
PUBLIC	??_C@_09FFOCOHMH@?1zinplace?$AA@		; `string'
PUBLIC	??_C@_0DA@NNBJDAHG@CHOOSE_ENCRYPT_OR_DECRYPT_FINALI@ ; `string'
PUBLIC	??_C@_0BK@CFANEEFJ@CHOOSE_ENCRYPT_OR_DECRYPT?$AA@ ; `string'
PUBLIC	??_C@_07CAOFPAJK@ENCRYPT?$AA@			; `string'
PUBLIC	??_C@_07OOEIKEPO@DECRYPT?$AA@			; `string'
PUBLIC	??_C@_08DDAIHKOO@IDCANCEL?$AA@			; `string'
PUBLIC	??_C@_0O@POKHNLDL@GOST?528147?989?$AA@		; `string'
PUBLIC	??_C@_0BA@LGBFJNHH@MORE_INFO_ABOUT?$AA@		; `string'
PUBLIC	??_C@_09JHKBFGFC@GOST_HELP?$AA@			; `string'
PUBLIC	??_C@_0BH@PJGBOAEF@TWO_LAYER_CASCADE_HELP?$AA@	; `string'
PUBLIC	??_C@_0BJ@CFADADFJ@THREE_LAYER_CASCADE_HELP?$AA@ ; `string'
PUBLIC	??_C@_0CA@EHDIKOJL@IDC_LINK_MORE_INFO_ABOUT_CIPHER?$AA@ ; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_09JHINKGCK@UISTR_YES?$AA@			; `string'
PUBLIC	??_C@_08EOJLPPDK@UISTR_NO?$AA@			; `string'
PUBLIC	??_C@_04MOKMKBJN@NEXT?$AA@			; `string'
PUBLIC	??_C@_04PKHKLFPJ@PREV?$AA@			; `string'
PUBLIC	??_C@_06JHILMIHF@CANCEL?$AA@			; `string'
PUBLIC	??_C@_0BI@FJOOBAJA@PROGRESS_STATUS_WAITING?$AA@	; `string'
PUBLIC	??_C@_0BL@MHLPJIOG@PROGRESS_STATUS_DECRYPTING?$AA@ ; `string'
PUBLIC	??_C@_0BL@PONBLMNB@PROGRESS_STATUS_ENCRYPTING?$AA@ ; `string'
PUBLIC	??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@		; `string'
PUBLIC	??_C@_09PJBBBIIP@IDC_PAUSE?$AA@			; `string'
PUBLIC	??_C@_06PPGAKMJI@RESUME?$AA@			; `string'
PUBLIC	??_C@_0BJ@HKENJBII@PROGRESS_STATUS_FINISHED?$AA@ ; `string'
PUBLIC	??_C@_0BH@LLAADOBF@PROGRESS_STATUS_PAUSED?$AA@	; `string'
PUBLIC	??_C@_0BO@DMHMPBKC@PROCESSED_PORTION_100_PERCENT?$AA@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_0CG@OIGJDCBH@FAILED_TO_INTERRUPT_SYSTEM_ENCRY@ ; `string'
PUBLIC	??_C@_0CD@HEMAICHN@FAILED_TO_RESUME_SYSTEM_ENCRYPTI@ ; `string'
PUBLIC	??_C@_0BP@CJOANMAM@NONSYS_INPLACE_ENC_IN_PROGRESS?$AA@ ; `string'
PUBLIC	??_C@_0BK@NECHGBNE@PROGRESS_STATUS_PREPARING?$AA@ ; `string'
PUBLIC	??_C@_0BJ@EIBDNDIC@PROGRESS_STATUS_RESIZING?$AA@ ; `string'
PUBLIC	??_C@_0BL@CIJLEOGN@PROGRESS_STATUS_FINALIZING?$AA@ ; `string'
PUBLIC	??_C@_0BG@IDPLALHN@PROGRESS_STATUS_ERROR?$AA@	; `string'
PUBLIC	??_C@_05KEELGAD@DEFER?$AA@			; `string'
PUBLIC	??_C@_04LAOFCJDB@?5?$CFc?5?$AA@			; `string'
PUBLIC	??_C@_03NJNOMAJF@?5?4?5?$AA@			; `string'
PUBLIC	??_C@_05BFHEBJNP@?$CF02X?5?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_1JO@BPJIPIJP@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK@ ; `string'
PUBLIC	??_C@_0BK@JMBFHJFE@TRIPLE_DOT_GLYPH_ELLIPSIS?$AA@ ; `string'
PUBLIC	??_C@_0BL@PHPLOOOK@FAILED_TO_INTERRUPT_WIPING?$AA@ ; `string'
PUBLIC	??_C@_0BH@PKDMJBLN@FAILED_TO_START_WIPING?$AA@	; `string'
PUBLIC	??_R0?AUTimeOut@GostCrypt@@@8			; GostCrypt::TimeOut `RTTI Type Descriptor'
PUBLIC	??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@		; `string'
PUBLIC	??_C@_0BL@MHDAJDPI@ADMIN_PRIVILEGES_WARN_NTFS?$AA@ ; `string'
PUBLIC	??_C@_0P@EMHOIPJB@READONLYPROMPT?$AA@		; `string'
PUBLIC	??_C@_0BA@JEAHJACA@OVERWRITEPROMPT?$AA@		; `string'
PUBLIC	??_C@_0P@JKCBOPBP@ACCESSMODEFAIL?$AA@		; `string'
PUBLIC	??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@		; `string'
PUBLIC	??_C@_0BM@DNIPKEFC@NO_FREE_DRIVE_FOR_OUTER_VOL?$AA@ ; `string'
PUBLIC	??_C@_0BF@IAAAEIAJ@CANT_MOUNT_OUTER_VOL?$AA@	; `string'
PUBLIC	??_C@_0BP@CBCIBGL@INPLACE_ENC_GENERIC_ERR_RESUME?$AA@ ; `string'
PUBLIC	??_C@_0CC@GOJAHDJH@INPLACE_ENC_GENERIC_ERR_ALT_STEP@ ; `string'
PUBLIC	??_C@_0O@OIAKNAOK@CREATE_FAILED?$AA@		; `string'
PUBLIC	??_C@_0BM@NHKMKNFC@HIDVOL_FORMAT_FINISHED_HELP?$AA@ ; `string'
PUBLIC	??_C@_0CB@KOCBDKDK@NONSYS_INPLACE_ENC_FINISHED_INFO@ ; `string'
PUBLIC	??_C@_0BF@ELGDKJEM@FORMAT_FINISHED_INFO?$AA@	; `string'
PUBLIC	??_C@_0BG@PHMPDKJN@SPARSE_FILE_SIZE_NOTE?$AA@	; `string'
PUBLIC	??_C@_0BA@IDMMBDGF@FORMAT_FINISHED?$AA@		; `string'
PUBLIC	??_C@_0BM@JKEOLKCL@NONSYS_INPLACE_ENC_CANCELED?$AA@ ; `string'
PUBLIC	??_C@_0BA@NLOHJLIM@FORMAT_CANCELED?$AA@		; `string'
PUBLIC	??_C@_0BI@DFBMOJJF@PASSWORD_HIDDEN_OS_NOTE?$AA@	; `string'
PUBLIC	??_C@_0BN@GMGGDPEP@HIDDEN_OS_PRE_CIPHER_WARNING?$AA@ ; `string'
PUBLIC	??_C@_0BG@OMPICDCM@MAX_HIDVOL_SIZE_BYTES?$AA@	; `string'
PUBLIC	??_C@_0BC@DDPKPAD@DEVICE_FREE_BYTES?$AA@	; `string'
PUBLIC	??_C@_0BA@GNIBCOCE@DISK_FREE_BYTES?$AA@		; `string'
PUBLIC	??_C@_0BD@NCFPMHAA@MAX_HIDVOL_SIZE_KB?$AA@	; `string'
PUBLIC	??_C@_0P@IKBGAMLK@DEVICE_FREE_KB?$AA@		; `string'
PUBLIC	??_C@_0N@LDEICJLE@DISK_FREE_KB?$AA@		; `string'
PUBLIC	??_C@_0BD@NGNCLLLC@MAX_HIDVOL_SIZE_MB?$AA@	; `string'
PUBLIC	??_C@_0P@IOJLHAAI@DEVICE_FREE_MB?$AA@		; `string'
PUBLIC	??_C@_0N@LHMFFFAG@DISK_FREE_MB?$AA@		; `string'
PUBLIC	??_C@_0BD@NLEFDOGE@MAX_HIDVOL_SIZE_GB?$AA@	; `string'
PUBLIC	??_C@_0P@IDAMPFNO@DEVICE_FREE_GB?$AA@		; `string'
PUBLIC	??_C@_0N@LKFCNANA@DISK_FREE_GB?$AA@		; `string'
PUBLIC	??_C@_0BC@LBACDGOD@CANNOT_CALC_SPACE?$AA@	; `string'
PUBLIC	??_C@_1M@KGONCMNM@?$AA?$CF?$AAs?$AA?6?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@		; `string'
PUBLIC	??_C@_0BB@FNOFFGJI@CANT_GET_VOLSIZE?$AA@	; `string'
PUBLIC	??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@	; `string'
PUBLIC	??_C@_0O@MKGMJGFE@EXT_PARTITION?$AA@		; `string'
PUBLIC	??_C@_1BK@GHMHFLJL@?$AA?5?$AA?$CI?$AA?$CF?$AAh?$AAc?$AA?3?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@LDCEEKNB@?$AA?5?$AA?$CI?$AA?$CF?$AAh?$AAc?$AA?3?$AA?$CF?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CL@KCMNHFDO@OVERWRITEPROMPT_DEVICE_HIDDEN_OS@ ; `string'
PUBLIC	??_C@_0BL@IMNAFHOP@NONSYS_INPLACE_ENC_CONFIRM?$AA@ ; `string'
PUBLIC	??_C@_0BH@JPJDALOG@OVERWRITEPROMPT_DEVICE?$AA@	; `string'
PUBLIC	??_C@_0DD@GFFEJLFD@OVERWRITEPROMPT_DEVICE_SECOND_WA@ ; `string'
PUBLIC	??_C@_0BP@IMKLJEFC@ERASE_FILES_BY_CREATING_VOLUME?$AA@ ; `string'
PUBLIC	??_C@_0BC@ELOGDKJ@DRIVE_LETTER_ITEM?$AA@	; `string'
PUBLIC	??_C@_19KHPJIBCC@?$AA?$CF?$AAh?$AAc?$AA?3?$AA?$AA@ ; `string'
PUBLIC	??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@		; `string'
PUBLIC	??_C@_0L@PEDCDHCM@LABEL_ITEM?$AA@		; `string'
PUBLIC	??_C@_0CA@KEHLKHJA@NOT_APPLICABLE_OR_NOT_AVAILABLE?$AA@ ; `string'
PUBLIC	??_C@_09DBGAMMMC@SIZE_ITEM?$AA@			; `string'
PUBLIC	??_C@_09BFNCKGCL@PATH_ITEM?$AA@			; `string'
PUBLIC	??_C@_0BP@DGIMBADH@AFTER_FORMAT_DRIVE_LETTER_WARN?$AA@ ; `string'
PUBLIC	??_7?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`vftable'
PUBLIC	??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
PUBLIC	??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
PUBLIC	??_C@_0BM@IHMEHMBJ@IDD_VOL_CREATION_WIZARD_DLG?$AA@ ; `string'
PUBLIC	??_C@_0P@IDKFBPLE@FORMAT_PAGE_?$CFd?$AA@	; `string'
PUBLIC	??_C@_0M@BGLIKHAN@INTRO_TITLE?$AA@		; `string'
PUBLIC	??_C@_0BH@LFFPJFCG@SYSENC_TYPE_PAGE_TITLE?$AA@	; `string'
PUBLIC	??_C@_0BI@FECPKDFP@SYSENC_HIDDEN_TYPE_HELP?$AA@	; `string'
PUBLIC	??_C@_0BI@EEMGDNEH@SYSENC_NORMAL_TYPE_HELP?$AA@	; `string'
PUBLIC	??_C@_0CG@CLMIJGGF@SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_@ ; `string'
PUBLIC	??_C@_0CF@GBPOCIAL@SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_@ ; `string'
PUBLIC	??_C@_0BK@FBGFJBLB@SYS_ENCRYPTION_SPAN_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0CJ@CMOPFEFD@SYS_ENCRYPTION_SPAN_WHOLE_SYS_DR@ ; `string'
PUBLIC	??_C@_0CA@IIEHPPGP@SYSENC_PRE_DRIVE_ANALYSIS_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BP@FCJHFGGJ@SYSENC_PRE_DRIVE_ANALYSIS_HELP?$AA@ ; `string'
PUBLIC	??_C@_0BM@EGLOODHA@SYSENC_DRIVE_ANALYSIS_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BL@OAMDPDOH@SYSENC_DRIVE_ANALYSIS_INFO?$AA@ ; `string'
PUBLIC	??_C@_0CK@KEHMFNIA@HIDDEN_SECTOR_DETECTION_FAILED_P@ ; `string'
PUBLIC	??_C@_0BN@GHOENGPC@SKIP_HIDDEN_SECTOR_DETECTION?$AA@ ; `string'
PUBLIC	??_C@_0BO@OEFOGNPK@RETRY_HIDDEN_SECTOR_DETECTION?$AA@ ; `string'
PUBLIC	??_C@_08HBBNJJLH@IDC_EXIT?$AA@			; `string'
PUBLIC	??_C@_0BK@NAIABFPC@SYS_MULTI_BOOT_MODE_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0CE@HOKCHJKA@SYSENC_MULTI_BOOT_SYS_EQ_BOOT_TI@ ; `string'
PUBLIC	??_C@_0CD@ODHMCLM@SYSENC_MULTI_BOOT_SYS_EQ_BOOT_HE@ ; `string'
PUBLIC	??_C@_09BCPPDPEL@DIGIT_ONE?$AA@			; `string'
PUBLIC	??_C@_0M@BAIFEFDO@TWO_OR_MORE?$AA@		; `string'
PUBLIC	??_C@_0CH@IMKPMBEM@SYSENC_MULTI_BOOT_NBR_SYS_DRIVES@ ; `string'
PUBLIC	??_C@_0CG@GBIPGAOP@SYSENC_MULTI_BOOT_NBR_SYS_DRIVES@ ; `string'
PUBLIC	??_C@_0CF@MINJEEM@SYSENC_MULTI_BOOT_ADJACENT_SYS_T@ ; `string'
PUBLIC	??_C@_0CE@CGLNKLHK@SYSENC_MULTI_BOOT_ADJACENT_SYS_H@ ; `string'
PUBLIC	??_C@_0CL@PKMEBLJM@SYSENC_MULTI_BOOT_NONWIN_BOOT_LO@ ; `string'
PUBLIC	??_C@_0CK@NGBECAKP@SYSENC_MULTI_BOOT_NONWIN_BOOT_LO@ ; `string'
PUBLIC	??_C@_0CA@FOODICMO@SYSENC_MULTI_BOOT_OUTCOME_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BC@IMPHNJMH@VOLUME_TYPE_TITLE?$AA@	; `string'
PUBLIC	??_C@_0BI@OMMJFNJB@HIDDEN_VOLUME_TYPE_HELP?$AA@	; `string'
PUBLIC	??_C@_0BI@OKEJAKDK@NORMAL_VOLUME_TYPE_HELP?$AA@	; `string'
PUBLIC	??_C@_0BN@CFKNBCJG@HIDDEN_VOL_WIZARD_MODE_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0CD@LJCMOGBH@HIDDEN_VOL_WIZARD_MODE_NORMAL_HE@ ; `string'
PUBLIC	??_C@_0CD@BGGCLDPJ@HIDDEN_VOL_WIZARD_MODE_DIRECT_HE@ ; `string'
PUBLIC	??_C@_0BC@NHEENOIC@IDC_SELECT_DEVICE?$AA@	; `string'
PUBLIC	??_C@_0BA@HOMDJPL@IDC_SELECT_FILE?$AA@		; `string'
PUBLIC	??_C@_0CB@LOIOBDOO@FILE_HELP_HIDDEN_HOST_VOL_DIRECT@ ; `string'
PUBLIC	??_C@_0BM@DMHDGBOJ@DEVICE_HELP_HIDDEN_HOST_VOL?$AA@ ; `string'
PUBLIC	??_C@_0M@JNOAPEGE@DEVICE_HELP?$AA@		; `string'
PUBLIC	??_C@_0BK@JMGOJAKG@FILE_HELP_HIDDEN_HOST_VOL?$AA@ ; `string'
PUBLIC	??_C@_09GPELPABL@FILE_HELP?$AA@			; `string'
PUBLIC	??_C@_0L@DGHBDDNJ@FILE_TITLE?$AA@		; `string'
PUBLIC	??_C@_0CB@IJHCDAO@DEVICE_TRANSFORM_MODE_PAGE_TITLE@ ; `string'
PUBLIC	??_C@_0CH@CJGGIKCO@DEVICE_TRANSFORM_MODE_PAGE_FORMA@ ; `string'
PUBLIC	??_C@_0CI@FGJIGFAK@DEVICE_TRANSFORM_MODE_PAGE_INPLA@ ; `string'
PUBLIC	??_C@_0BN@PMMGMENG@HIDVOL_HOST_PRE_CIPHER_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0CD@OMGBOOGK@HIDVOL_HOST_PRE_CIPHER_HELP_SYSE@ ; `string'
PUBLIC	??_C@_0BM@GCHOHFOK@HIDVOL_HOST_PRE_CIPHER_HELP?$AA@ ; `string'
PUBLIC	??_C@_0N@PJPEEMEG@INVALID_PATH?$AA@		; `string'
PUBLIC	??_C@_0BI@JOBKEAGA@HIDVOL_PRE_CIPHER_TITLE?$AA@	; `string'
PUBLIC	??_C@_0CF@OIPNIHCG@HIDDEN_VOLUME_TOO_SMALL_FOR_OS_C@ ; `string'
PUBLIC	??_C@_04GOLNGIJ@EXIT?$AA@			; `string'
PUBLIC	??_C@_0BK@FGHOHKMP@HIDDEN_OS_PRE_CIPHER_HELP?$AA@ ; `string'
PUBLIC	??_C@_0BH@GDOHBMLG@HIDVOL_PRE_CIPHER_HELP?$AA@	; `string'
PUBLIC	??_C@_0BJ@GGKKJCIG@CIPHER_HIDVOL_HOST_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BE@JFKJAJEK@CIPHER_HIDVOL_TITLE?$AA@	; `string'
PUBLIC	??_C@_0N@IMFDFPGM@CIPHER_TITLE?$AA@		; `string'
PUBLIC	??_C@_0BK@DEODNGPK@SIZE_HELP_HIDDEN_HOST_VOL?$AA@ ; `string'
PUBLIC	??_C@_0BF@LOOCDJPI@SIZE_HELP_HIDDEN_VOL?$AA@	; `string'
PUBLIC	??_C@_09BEBIICBL@SIZE_HELP?$AA@			; `string'
PUBLIC	??_C@_0BP@JPPBFIHO@SIZE_PARTITION_HIDDEN_VOL_HELP?$AA@ ; `string'
PUBLIC	??_C@_0CC@MIIACKDF@SIZE_PARTITION_HIDDEN_SYSENC_HEL@ ; `string'
PUBLIC	??_C@_0BE@FGKMPGH@SIZE_PARTITION_HELP?$AA@	; `string'
PUBLIC	??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_07NFANNNEC@UNKNOWN?$AA@			; `string'
PUBLIC	??_C@_05OINFJHGD@?$CFI64u?$AA@			; `string'
PUBLIC	??_C@_0BH@GBEPPLEC@SIZE_HIDVOL_HOST_TITLE?$AA@	; `string'
PUBLIC	??_C@_0BC@COPDBOHD@SIZE_HIDVOL_TITLE?$AA@	; `string'
PUBLIC	??_C@_0L@DGAKGAKL@SIZE_TITLE?$AA@		; `string'
PUBLIC	??_C@_0CN@CCCDIOBF@NONSYS_INPLACE_ENC_RESUME_PASSWO@ ; `string'
PUBLIC	??_C@_0CE@MPBBLHJC@PASSWORD_HIDDENVOL_HOST_DIRECT_H@ ; `string'
PUBLIC	??_C@_08KENNMKEI@PASSWORD?$AA@			; `string'
PUBLIC	??_C@_0BL@DDMDKDAG@PASSWORD_HIDVOL_HOST_TITLE?$AA@ ; `string'
PUBLIC	??_C@_04JIMNDDED@?$CF08X?$AA@			; `string'
PUBLIC	??_C@_08OKJEGFFL@00000409?$AA@			; `string'
PUBLIC	??_C@_0CL@KAEHBIEI@CANT_CHANGE_KEYB_LAYOUT_FOR_SYS_@ ; `string'
PUBLIC	??_C@_0BB@MMDPAFIK@CANNOT_SET_TIMER?$AA@	; `string'
PUBLIC	??_C@_0BO@EJBBHKGE@PASSWORD_SYSENC_OUTERVOL_HELP?$AA@ ; `string'
PUBLIC	??_C@_0BN@OJJOHFMM@PASSWORD_HIDDENVOL_HOST_HELP?$AA@ ; `string'
PUBLIC	??_C@_0O@MEODOKDB@PASSWORD_HELP?$AA@		; `string'
PUBLIC	??_C@_0BI@PAGBOIIN@PASSWORD_HIDDEN_OS_HELP?$AA@	; `string'
PUBLIC	??_C@_0BI@MNFELCPB@PASSWORD_HIDDENVOL_HELP?$AA@	; `string'
PUBLIC	??_C@_0BJ@CPICCPLA@PASSWORD_HIDDEN_OS_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BG@ILMPEOM@PASSWORD_HIDVOL_TITLE?$AA@	; `string'
PUBLIC	??_C@_0P@ONGBFCBF@PASSWORD_TITLE?$AA@		; `string'
PUBLIC	??_C@_0BD@LCAKBGFA@FILESYS_PAGE_TITLE?$AA@	; `string'
PUBLIC	??_C@_0BL@IEILEGP@FILESYS_PAGE_HELP_QUESTION?$AA@ ; `string'
PUBLIC	??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@	; `string'
PUBLIC	??_C@_0P@JPAMOBPC@NOTE_BEGINNING?$AA@		; `string'
PUBLIC	??_C@_0BO@NPNHCCNA@FILESYS_PAGE_HELP_EXPLANATION?$AA@ ; `string'
PUBLIC	??_C@_0CF@BDOPEICN@FILESYS_PAGE_HELP_EXPLANATION_HI@ ; `string'
PUBLIC	??_C@_0BN@DAHBFIJD@COLLECTING_RANDOM_DATA_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0P@KEHBBAFI@KEYS_GEN_TITLE?$AA@		; `string'
PUBLIC	??_C@_0M@IGHMLIGA@RESCUE_DISK?$AA@		; `string'
PUBLIC	??_C@_0BB@KBMALCGN@RESCUE_DISK_INFO?$AA@	; `string'
PUBLIC	??_C@_0BK@NAGNMEFO@RESCUE_DISK_CREATED_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BM@GPDOJGLC@RESCUE_DISK_RECORDING_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0CI@IHEJGKND@RESCUE_DISK_BURN_INFO_NONWIN_ISO@ ; `string'
PUBLIC	??_C@_0BP@JAENMDIB@RESCUE_DISK_BURN_INFO_NO_CHECK?$AA@ ; `string'
PUBLIC	??_C@_0BG@KIJPDAJH@RESCUE_DISK_BURN_INFO?$AA@	; `string'
PUBLIC	??_C@_0BD@CHINNFGJ@LAUNCH_WIN_ISOBURN?$AA@	; `string'
PUBLIC	??_C@_0CA@OFKHEBFP@RESCUE_DISK_DISK_VERIFIED_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BK@PHEMJDOE@RESCUE_DISK_VERIFIED_INFO?$AA@ ; `string'
PUBLIC	??_C@_0BA@GEMFOMCA@WIPE_MODE_TITLE?$AA@		; `string'
PUBLIC	??_C@_0BL@KPLPAAMG@INPLACE_ENC_WIPE_MODE_INFO?$AA@ ; `string'
PUBLIC	??_C@_0CB@PAHHLDJJ@HIDDEN_OS_CREATION_PREINFO_TITLE@ ; `string'
PUBLIC	??_C@_0CA@GFBCACCB@HIDDEN_OS_CREATION_PREINFO_HELP?$AA@ ; `string'
PUBLIC	??_C@_05JLPDBANI@START?$AA@			; `string'
PUBLIC	??_C@_0BN@OJLMLLFE@SYS_ENCRYPTION_PRETEST_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BM@OIIAJLEO@SYS_ENCRYPTION_PRETEST_INFO?$AA@ ; `string'
PUBLIC	??_C@_04OIKJMBFP@TEST?$AA@			; `string'
PUBLIC	??_C@_0CE@FEPHBNLJ@SYS_ENCRYPTION_PRETEST_RESULT_TI@ ; `string'
PUBLIC	??_C@_0CD@BONEGKLO@SYS_ENCRYPTION_PRETEST_RESULT_IN@ ; `string'
PUBLIC	??_C@_0L@MHHIHFIN@ENCRYPTION?$AA@		; `string'
PUBLIC	??_C@_0L@POBGFBLK@DECRYPTION?$AA@		; `string'
PUBLIC	??_C@_0BM@LFGBLAAC@SYSENC_ENCRYPTION_PAGE_INFO?$AA@ ; `string'
PUBLIC	??_C@_0CK@KEEMKNMD@NONSYS_INPLACE_ENC_RESUME_VOL_SE@ ; `string'
PUBLIC	??_C@_0CI@MDGBIFPN@NONSYS_INPLACE_ENC_ENCRYPTION_PA@ ; `string'
PUBLIC	??_C@_0CC@LOJCKPNA@NONSYS_INPLACE_ENC_FINISHED_TITL@ ; `string'
PUBLIC	??_C@_08MFKGCNCO@FINALIZE?$AA@			; `string'
PUBLIC	??_C@_0BI@MEDALEIG@FORMAT_HIDVOL_HOST_HELP?$AA@	; `string'
PUBLIC	??_C@_0M@EEPPFDAO@FORMAT_HELP?$AA@		; `string'
PUBLIC	??_C@_0BJ@LIGEKHGE@FORMAT_HIDVOL_HOST_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BE@CEEOMNDM@FORMAT_HIDVOL_TITLE?$AA@	; `string'
PUBLIC	??_C@_0N@FLIHGDJB@FORMAT_TITLE?$AA@		; `string'
PUBLIC	??_C@_0BA@LBGDFDPO@IDC_QUICKFORMAT?$AA@		; `string'
PUBLIC	??_C@_0M@GPMOAIEF@SPARSE_FILE?$AA@		; `string'
PUBLIC	??_C@_0EP@NPBFJCJA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ ; `string'
PUBLIC	??_C@_07MGCPDNLD@DEFAULT?$AA@			; `string'
PUBLIC	??_C@_17OFEDBPDO@?$AA0?$AA?4?$AA5?$AA?$AA@	; `string'
PUBLIC	??_C@_02LODOGJEL@KB?$AA@			; `string'
PUBLIC	??_C@_04HPPAIJNK@NTFS?$AA@			; `string'
PUBLIC	??_C@_03MPELFIKF@FAT?$AA@			; `string'
PUBLIC	??_C@_04OKGDLNCL@NONE?$AA@			; `string'
PUBLIC	??_C@_03JMFMNIFM@?9?9?9?$AA@			; `string'
PUBLIC	??_C@_06DPGELLJH@FORMAT?$AA@			; `string'
PUBLIC	??_C@_02LKLDBFPJ@MB?$AA@			; `string'
PUBLIC	??_C@_1BC@JJPHEOJD@?$AA?$CF?$AAI?$AA6?$AA4?$AAd?$AA?5?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CA@NGPBKLAB@HIDVOL_HOST_FILLING_HELP_SYSENC?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NMHGGMKI@HIDVOL_HOST_FILLING_HELP?$AA@ ; `string'
PUBLIC	??_C@_0BK@GEKKOMHD@HIDVOL_HOST_FILLING_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0CH@DILBCENC@SYSENC_HIDDEN_VOL_FORMAT_FINISHE@ ; `string'
PUBLIC	??_C@_0BF@GBMPIMLF@FORMAT_FINISHED_HELP?$AA@	; `string'
PUBLIC	??_C@_0BN@DJMJCNLA@HIDVOL_FORMAT_FINISHED_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BG@HBBDJEK@FORMAT_FINISHED_TITLE?$AA@	; `string'
PUBLIC	??_C@_0BE@KFFNPDGB@PageDialogProc?35088?$AA@	; `string'
PUBLIC	??_C@_0CE@LLANPMHF@SYSENC_HIDDEN_OS_INITIAL_INFO_TI@ ; `string'
PUBLIC	??_C@_0BK@FHELJNGN@FIRST_HIDDEN_OS_BOOT_INFO?$AA@ ; `string'
PUBLIC	??_C@_0CB@MMHOKPDB@SYSENC_HIDDEN_OS_WIPE_INFO_TITLE@ ; `string'
PUBLIC	??_C@_0BL@KAEKPGLE@SYSENC_HIDDEN_OS_WIPE_INFO?$AA@ ; `string'
PUBLIC	??_C@_0P@JJNKBKFB@WIPE_MODE_INFO?$AA@		; `string'
PUBLIC	??_C@_0CA@NHNKCAEG@DEVICE_WIPE_PAGE_INFO_HIDDEN_OS?$AA@ ; `string'
PUBLIC	??_C@_0BG@OABGGIFL@DEVICE_WIPE_PAGE_INFO?$AA@	; `string'
PUBLIC	??_C@_0BH@IEGJMJEM@DEVICE_WIPE_PAGE_TITLE?$AA@	; `string'
PUBLIC	??_C@_04LEEAJJHO@WIPE?$AA@			; `string'
PUBLIC	??_C@_15OJKDPEFE@?$AA?5?$AA?5?$AA?$AA@		; `string'
PUBLIC	??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@ ; `string'
PUBLIC	??_C@_0CN@EDGNFMHB@FILESYS_PAGE_HELP_EXPLANATION_HI@ ; `string'
PUBLIC	??_C@_0N@LNDFLMFM@FORMAT_ABORT?$AA@		; `string'
PUBLIC	??_C@_0CE@BFLBCKJG@http?3?1?1www?4ietf?4org?1rfc?1rfc5830?4@ ; `string'
PUBLIC	??_C@_0CK@PHDAOPJF@KEYFILES_NOT_SUPPORTED_FOR_SYS_E@ ; `string'
PUBLIC	??_C@_0L@GHEOANHD@OPEN_TITLE?$AA@		; `string'
PUBLIC	??_C@_06OACPEFAM@Floppy?$AA@			; `string'
PUBLIC	??_C@_0CG@FCGANOF@ALGO_NOT_SUPPORTED_FOR_SYS_ENCRY@ ; `string'
PUBLIC	??_C@_0BE@NLHJLKOB@CONFIRM_SPARSE_FILE?$AA@	; `string'
PUBLIC	??_C@_0BC@LJAPGPK@WARN_QUICK_FORMAT?$AA@	; `string'
PUBLIC	??_C@_0EP@HCFFCIHD@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0BD@EJEDNFIG@CONFIRM_WIPE_ABORT?$AA@	; `string'
PUBLIC	??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@ ; `string'
PUBLIC	??_C@_0BL@JMGGGIDG@?2GostCrypt?5Rescue?5Disk?4iso?$AA@ ; `string'
PUBLIC	??_C@_04JFFKLGJF@?$CF02X?$AA@			; `string'
PUBLIC	??_R0?AUSystemException@GostCrypt@@@8		; GostCrypt::SystemException `RTTI Type Descriptor'
PUBLIC	??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@ ; `string'
PUBLIC	??_C@_0CF@BKMHLPHL@DISCARD_UNREADABLE_ENCRYPTED_SEC@ ; `string'
PUBLIC	??_C@_0BL@LJPGNBNM@SYSTEM_ENCRYPTION_FINISHED?$AA@ ; `string'
PUBLIC	??_C@_0BL@HGGGHBLG@SYSTEM_DECRYPTION_FINISHED?$AA@ ; `string'
PUBLIC	??_C@_0BA@ICICKJJH@CONFIRM_RESTART?$AA@		; `string'
PUBLIC	??_C@_0BN@MNCKOJDH@KEYB_LAYOUT_CHANGE_PREVENTED?$AA@ ; `string'
PUBLIC	??_C@_0CA@HGCGAMEK@KEYB_LAYOUT_SYS_ENC_EXPLANATION?$AA@ ; `string'
PUBLIC	??_C@_0CF@OEJEFNLJ@ALT_KEY_CHARS_NOT_FOR_SYS_ENCRYP@ ; `string'
PUBLIC	??_C@_0BN@KCOCCGGE@SYS_DRIVE_SIZE_PROBE_TIMEOUT?$AA@ ; `string'
PUBLIC	??_C@_0CF@JGIFKPLM@WIPE_FINISHED_DECOY_SYSTEM_PARTI@ ; `string'
PUBLIC	??_C@_0BJ@EAMLJMAO@DECOY_OS_VERSION_WARNING?$AA@ ; `string'
PUBLIC	??_C@_0CB@MEPMKNNG@NONSYS_INPLACE_ENC_DEFER_CONFIRM@ ; `string'
PUBLIC	??_C@_0CA@MDOAMJOP@SYSTEM_DECRYPTION_DEFER_CONFIRM?$AA@ ; `string'
PUBLIC	??_C@_0CA@OMHIMMHH@SYSTEM_ENCRYPTION_DEFER_CONFIRM?$AA@ ; `string'
PUBLIC	??_C@_0CC@KDAJHHMG@CONFIRM_CANCEL_HIDDEN_OS_CREATIO@ ; `string'
PUBLIC	??_C@_0BP@IFOLEKLB@CONFIRM_CANCEL_SYS_ENC_PRETEST?$AA@ ; `string'
PUBLIC	??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@	; `string'
PUBLIC	??_C@_0BI@BGKLALIE@CONTAINER_ADMIN_WARNING?$AA@	; `string'
PUBLIC	??_C@_0CI@HFDNHKMM@GAP_BETWEEN_SYS_AND_HIDDEN_OS_PA@ ; `string'
PUBLIC	??_C@_0BL@IDNPDOGL@DECOY_OS_REINSTALL_WARNING?$AA@ ; `string'
PUBLIC	??_C@_0CH@OILEALFF@HIDDEN_OS_WRITE_PROTECTION_EXPLA@ ; `string'
PUBLIC	??_C@_0CG@LFCLDECM@HIDDEN_OS_WRITE_PROTECTION_BRIEF@ ; `string'
PUBLIC	??_C@_02COKGDMEE@?1r?$AA@			; `string'
PUBLIC	??_C@_0BN@EDCHAEND@MULTI_BOOT_FOR_ADVANCED_ONLY?$AA@ ; `string'
PUBLIC	??_C@_0BF@OEFLIJFC@HIDDEN_OS_MULTI_BOOT?$AA@	; `string'
PUBLIC	??_C@_0CF@PJBIBHBE@UNSUPPORTED_HIDDEN_OS_MULTI_BOOT@ ; `string'
PUBLIC	??_C@_0CH@PDMBGJBN@CONFIRM_HIDDEN_OS_EXTRA_BOOT_PAR@ ; `string'
PUBLIC	??_C@_0BG@HEENEHGK@DECOY_OS_REQUIREMENTS?$AA@	; `string'
PUBLIC	??_C@_0CE@BLBEBHP@SYS_PARTITION_MUST_BE_ON_BOOT_DR@ ; `string'
PUBLIC	??_C@_0DC@EAFFGLI@WDE_UNSUPPORTED_FOR_MULTIPLE_SYS@ ; `string'
PUBLIC	??_C@_0CI@KANLNDNO@CUSTOM_BOOT_MANAGERS_IN_MBR_UNSU@ ; `string'
PUBLIC	??_C@_0BK@EHEECKKC@WINDOWS_BOOT_LOADER_HINTS?$AA@ ; `string'
PUBLIC	??_C@_0BN@DOPCDKC@ADMIN_PRIVILEGES_WARN_HIDVOL?$AA@ ; `string'
PUBLIC	??_C@_0CK@NNPIGIED@HIDDEN_VOL_CREATION_UNDER_HIDDEN@ ; `string'
PUBLIC	??_C@_0CD@DKKKPMLO@DEVICE_SELECTED_IN_NON_DEVICE_MO@ ; `string'
PUBLIC	??_C@_0BA@ECFGGOBI@ALREADY_MOUNTED?$AA@		; `string'
PUBLIC	??_C@_0BP@NCOMIFAB@CONFIRM_SYSTEM_ENCRYPTION_MODE?$AA@ ; `string'
PUBLIC	??_C@_0BL@LHDMMKJO@EXE_FILE_EXTENSION_CONFIRM?$AA@ ; `string'
PUBLIC	??_C@_0BH@BGCKDFKI@HIDDEN_VOL_HOST_SPARSE?$AA@	; `string'
PUBLIC	??_C@_0CC@NCAFIIDC@NONSYS_INPLACE_ENC_CONFIRM_BACKU@ ; `string'
PUBLIC	??_C@_0CD@HEIAMGDN@CONFIRM_CASCADE_FOR_SYS_ENCRYPTI@ ; `string'
PUBLIC	??_C@_0CA@HENDJLLF@NOTE_CASCADE_FOR_SYS_ENCRYPTION?$AA@ ; `string'
PUBLIC	??_C@_05HNJNFBJJ@FAT32?$AA@			; `string'
PUBLIC	??_C@_0BL@FEGMEEPN@VOLUME_TOO_LARGE_FOR_FAT32?$AA@ ; `string'
PUBLIC	??_C@_0BL@IAHLEEBN@VOLUME_TOO_LARGE_FOR_WINXP?$AA@ ; `string'
PUBLIC	??_C@_0CH@NJLIGNCF@FREE_SPACE_FOR_WRITING_TO_OUTER_@ ; `string'
PUBLIC	??_C@_0BJ@CPHEENHA@UNSUPPORTED_CHARS_IN_PWD?$AA@ ; `string'
PUBLIC	??_C@_0BP@BGCHIACG@CANNOT_RESTORE_KEYBOARD_LAYOUT?$AA@ ; `string'
PUBLIC	??_C@_0BI@GNHKCMLM@CANT_DISMOUNT_OUTER_VOL?$AA@	; `string'
PUBLIC	??_C@_0CK@DBNLNPHP@FOUND_NO_PARTITION_W_DEFERRED_IN@ ; `string'
PUBLIC	??_C@_0DG@KNHACFHE@CANNOT_CREATE_NON_HIDDEN_NTFS_VO@ ; `string'
PUBLIC	??_C@_0CF@HFPIFBIF@CANNOT_SATISFY_OVER_4G_FILE_SIZE@ ; `string'
PUBLIC	??_C@_0BG@GLKAIFEA@CD_BURNER_NOT_PRESENT?$AA@	; `string'
PUBLIC	??_C@_0CF@OBJIPJKN@CD_BURNER_NOT_PRESENT_WILL_STORE@ ; `string'
PUBLIC	??_C@_0CJ@FCOKHALJ@CD_BURNER_NOT_PRESENT_WILL_CONNE@ ; `string'
PUBLIC	??_C@_0CE@FEAJEJEJ@CD_BURNER_NOT_PRESENT_CONNECTED_@ ; `string'
PUBLIC	??_C@_0CK@BHLKCEED@CD_BURNER_NOT_PRESENT_WILL_STORE@ ; `string'
PUBLIC	??_C@_0BP@EJPBDEFG@RESCUE_DISK_BURN_NO_CHECK_WARN?$AA@ ; `string'
PUBLIC	??_C@_0CH@GAGHEKIC@RESCUE_DISK_WIN_ISOBURN_PRELAUNC@ ; `string'
PUBLIC	??_C@_0CL@LCMPFPDG@RESCUE_DISK_CHECK_FAILED_SENTENC@ ; `string'
PUBLIC	??_C@_0BJ@KDGMPLJF@RESCUE_DISK_CHECK_FAILED?$AA@ ; `string'
PUBLIC	??_C@_0P@BMFNBJAJ@WIPE_MODE_WARN?$AA@		; `string'
PUBLIC	??_C@_0BG@DGIFCGMK@PREBOOT_NOT_LOCALIZED?$AA@	; `string'
PUBLIC	??_C@_0CD@DFDNFFMK@CANNOT_INITIATE_HIDDEN_OS_CREATI@ ; `string'
PUBLIC	??_C@_0CH@MGEMKCIE@CANNOT_INITIATE_SYS_ENCRYPTION_P@ ; `string'
PUBLIC	??_C@_09PIOBCILE@?1acsysenc?$AA@		; `string'
PUBLIC	??_C@_0BN@EFIGHBDJ@OFFER_FAT_FORMAT_ALTERNATIVE?$AA@ ; `string'
PUBLIC	??_C@_0CG@HAPBHPDC@FAT_NOT_AVAILABLE_FOR_SO_LARGE_V@ ; `string'
PUBLIC	??_C@_0CK@PNCJJOHK@OUTER_VOLUME_TOO_SMALL_FOR_HIDDE@ ; `string'
PUBLIC	??_C@_0CM@PCAIDDLK@HIDDEN_VOL_HOST_UNSUPPORTED_FILE@ ; `string'
PUBLIC	??_C@_0BJ@NALGNOGO@HIDDEN_VOL_HOST_NTFS_ASK?$AA@ ; `string'
PUBLIC	??_C@_0BP@NLBJKNFD@CONFIRM_FAT_FOR_FILES_OVER_4GB?$AA@ ; `string'
PUBLIC	??_C@_0BC@DADPIOMM@CLUSTER_TOO_SMALL?$AA@	; `string'
PUBLIC	??_C@_0BD@NGECJJAH@FORMAT_IN_PROGRESS?$AA@	; `string'
PUBLIC	??_C@_0CH@LLDBJBEP@CONFIRM_WIPE_START_DECOY_SYS_PAR@ ; `string'
PUBLIC	??_C@_0BD@ICCGDAH@CONFIRM_WIPE_START?$AA@	; `string'
PUBLIC	??_C@_0L@JGIDNNFC@?9Embedding?$AA@		; `string'
PUBLIC	??_C@_08BCLHLEKP@?1history?$AA@			; `string'
PUBLIC	??_C@_02JOILMGJP@?1h?$AA@			; `string'
PUBLIC	??_C@_0M@IEGCIDAG@?1noisocheck?$AA@		; `string'
PUBLIC	??_C@_02MINBGBBJ@?1n?$AA@			; `string'
PUBLIC	??_C@_05CMMBDMDD@?1quit?$AA@			; `string'
PUBLIC	??_C@_02FILGPIH@?1q?$AA@			; `string'
PUBLIC	??_C@_09JABABBPB@?1tokenlib?$AA@		; `string'
PUBLIC	??_C@_02EPEJHNNG@?1a?$AA@			; `string'
PUBLIC	??_C@_08FFGENEKE@?1csysenc?$AA@			; `string'
PUBLIC	??_C@_02HNHPBPFE@?1c?$AA@			; `string'
PUBLIC	??_C@_08FPKBNNLN@?1dsysenc?$AA@			; `string'
PUBLIC	??_C@_02DCDOIJJD@?1d?$AA@			; `string'
PUBLIC	??_C@_07MFEOHHG@?1encdev?$AA@			; `string'
PUBLIC	??_C@_08MEKEMIGM@?1isysenc?$AA@			; `string'
PUBLIC	??_C@_02IHJAPHNO@?1i?$AA@			; `string'
PUBLIC	??_C@_0L@DLEMDKJB@?1prinplace?$AA@		; `string'
PUBLIC	??_C@_02BMJAFOMG@?1p?$AA@			; `string'
PUBLIC	??_C@_09PMGMEKMI@?1risysenc?$AA@		; `string'
PUBLIC	??_C@_07PFDFIFLD@?1sysenc?$AA@			; `string'
PUBLIC	??_C@_02DHLNANAF@?1s?$AA@			; `string'
PUBLIC	??_C@_02OGHPLGEM@?1z?$AA@			; `string'
PUBLIC	??_C@_01EANLCPLP@y?$AA@				; `string'
PUBLIC	??_C@_03ICICOMAL@yes?$AA@			; `string'
PUBLIC	??_C@_01EFFIKLCJ@n?$AA@				; `string'
PUBLIC	??_C@_02KAJCLHKP@no?$AA@			; `string'
PUBLIC	??_C@_0BD@LGCKNJIO@COMMAND_LINE_ERROR?$AA@	; `string'
PUBLIC	??_C@_0BI@EIHCDBCC@NO_SPACE_FOR_HIDDEN_VOL?$AA@	; `string'
PUBLIC	??_C@_0BG@EDMDLNEK@CANT_ACCESS_OUTER_VOL?$AA@	; `string'
PUBLIC	??_C@_0BD@GJIBONDI@ERR_VOL_FORMAT_BAD?$AA@	; `string'
PUBLIC	??_C@_0BN@PEDIFLNF@ERR_HIDDEN_NOT_NORMAL_VOLUME?$AA@ ; `string'
PUBLIC	??_C@_0CG@DBCOIOLF@ERR_HIDDEN_VOL_HOST_ENCRYPTED_IN@ ; `string'
PUBLIC	??_C@_0BF@GKHHEFAE@HIDDEN_VOL_HOST_NTFS?$AA@	; `string'
PUBLIC	??_C@_0BI@JLECLIC@CANT_GET_OUTER_VOL_INFO?$AA@	; `string'
PUBLIC	??_C@_0CE@PMECNFFM@HIDDEN_VOL_HOST_UNSUPPORTED_FILE@ ; `string'
PUBLIC	??_C@_0BG@BIDCCDPC@MountVolumesRemovable?$AA@	; `string'
PUBLIC	??_C@_0BI@IEBIBFIL@CANT_GET_CLUSTER_BITMAP?$AA@	; `string'
PUBLIC	??_C@_0CE@GLPLHHCP@AfterSysEncProgressWMInitTasks?39@ ; `string'
PUBLIC	??_C@_0BJ@KGJBOMKO@CANNOT_DECRYPT_HIDDEN_OS?$AA@ ; `string'
PUBLIC	??_C@_0BG@JNPKODLF@AfterWMInitTasks?39116?$AA@	; `string'
PUBLIC	??_C@_0CL@LHNBFDMB@SYSTEM_ENCRYPTION_SCHEDULED_BUT_@ ; `string'
PUBLIC	??_C@_0BC@BOICFCMD@NOTHING_TO_RESUME?$AA@	; `string'
PUBLIC	??_C@_0CP@MHIMBFBH@SYS_PARTITION_OR_DRIVE_APPEARS_F@ ; `string'
PUBLIC	??_C@_0BG@BOBNFKFK@AfterWMInitTasks?39288?$AA@	; `string'
PUBLIC	??_C@_0BG@BEIDFAO@AfterWMInitTasks?39374?$AA@	; `string'
PUBLIC	??_C@_0BK@DFBAAIPH@BOOT_PRETEST_FAILED_RETRY?$AA@ ; `string'
PUBLIC	??_C@_0BL@BAAJMEPI@OS_WIPING_NOT_FINISHED_ASK?$AA@ ; `string'
PUBLIC	??_C@_0CE@BLKNBIFF@HIDDEN_OS_CREATION_NOT_FINISHED_@ ; `string'
PUBLIC	??_C@_0CN@NFNCFNOG@HIDDEN_OS_CREATION_NOT_FINISHED_@ ; `string'
PUBLIC	??_C@_0DB@KJCGFBOB@HIDDEN_OS_CREATION_NOT_FINISHED_@ ; `string'
PUBLIC	??_C@_0DB@IJPDGLEP@HIDDEN_OS_CREATION_NOT_FINISHED_@ ; `string'
PUBLIC	??_C@_0BG@JEMCACBK@AfterWMInitTasks?39509?$AA@	; `string'
PUBLIC	??_C@_0N@PDPHKHCO@INIT_SYS_ENC?$AA@		; `string'
PUBLIC	??_C@_09PLHAEEAO@INIT_RAND?$AA@			; `string'
PUBLIC	??_C@_08ELEAABKI@NODRIVER?$AA@			; `string'
PUBLIC	??_C@_0BG@DKEEGIEL@ERR_SELF_TESTS_FAILED?$AA@	; `string'
PUBLIC	?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
PUBLIC	??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`vftable'
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu?$AA@			; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld?$AA@			; `string'
PUBLIC	??_C@_02BDDLJJBK@lu?$AA@			; `string'
PUBLIC	??_C@_02EAOCLKAK@ld?$AA@			; `string'
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_7?$numpunct@_W@std@@6B@			; std::numpunct<wchar_t>::`vftable'
PUBLIC	??_C@_02MDKMJEGG@eE?$AA@			; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Static
PUBLIC	?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ios_base@std@@6B@				; std::ios_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@_W@std@@6B@			; std::ctype<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@_W@std@@@8			; std::ctype<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@_W@std@@8			; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Container@ForEach@GostCrypt@@6B@		; GostCrypt::ForEach::Container::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUContainer@ForEach@GostCrypt@@@8		; GostCrypt::ForEach::Container `RTTI Type Descriptor'
PUBLIC	??_R3Container@ForEach@GostCrypt@@8		; GostCrypt::ForEach::Container::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Container@ForEach@GostCrypt@@8		; GostCrypt::ForEach::Container::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8	; GostCrypt::ForEach::Container::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@_W@std@@6B@			; std::numpunct<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@_W@std@@@8			; std::numpunct<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@_W@std@@8			; std::numpunct<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@_W@std@@8			; std::numpunct<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@_W@std@@8		; std::numpunct<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3feb333333333333
PUBLIC	__real@4000cccccccccccd
PUBLIC	__real@4058ff5c28f5c28f
PUBLIC	__real@4202a05f20000000
PUBLIC	__real@42b00000
PUBLIC	__xmm@000000000000000000000019000000a2
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@ffffffffffffffffffffffffffffffff
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__errno:PROC
EXTRN	_memmove:PROC
EXTRN	_strstr:PROC
EXTRN	_wcscpy_s:PROC
EXTRN	_wcsncpy:PROC
EXTRN	_strcspn:PROC
EXTRN	__stricmp:PROC
EXTRN	_strncmp:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__GetDiskFreeSpaceA@20:PROC
EXTRN	__imp__GetDiskFreeSpaceExA@16:PROC
EXTRN	__imp__GetFileInformationByHandle@8:PROC
EXTRN	__imp__GetFileSizeEx@8:PROC
EXTRN	__imp__GetFileTime@16:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__SetFileTime@16:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	__imp__VirtualUnlock@8:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__SetThreadExecutionState@4:PROC
EXTRN	__imp__GetVolumeInformationA@32:PROC
EXTRN	__imp__GetVolumePathNameA@12:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__wsprintfW:PROC
EXTRN	__imp__LoadKeyboardLayoutA@8:PROC
EXTRN	__imp__GetKeyboardLayout@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__IsWindow@4:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__MoveWindow@24:PROC
EXTRN	__imp__CreateDialogParamW@20:PROC
EXTRN	__imp__DialogBoxParamW@20:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__SetDlgItemTextA@12:PROC
EXTRN	__imp__GetDlgItemTextA@16:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__GetAsyncKeyState@4:PROC
EXTRN	__imp__SetTimer@16:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__SetWindowTextW@8:PROC
EXTRN	__imp__GetWindowTextA@12:PROC
EXTRN	__imp__GetWindowTextLengthA@4:PROC
EXTRN	__imp__GetWindowRect@8:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__imp__MessageBeep@4:PROC
EXTRN	__imp__GetWindowLongA@8:PROC
EXTRN	__imp__GetParent@4:PROC
EXTRN	__imp__EnumWindows@8:PROC
EXTRN	__imp__MapDialogRect@8:PROC
EXTRN	__imp__ShellExecuteA@24:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_exit:PROC
EXTRN	__atoi64:PROC
EXTRN	__imp__InitCommonControls@0:PROC
EXTRN	_frexp:PROC
EXTRN	__beginthread:PROC
EXTRN	__endthread:PROC
EXTRN	___stdio_common_vswprintf:PROC
EXTRN	___stdio_common_vswprintf_s:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fputs:PROC
EXTRN	_remove:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	__access:PROC
EXTRN	__chmod:PROC
EXTRN	__imp__SHGetFolderPathA@20:PROC
EXTRN	_VerifyPasswordAndUpdate:PROC
EXTRN	_CheckPasswordLength:PROC
EXTRN	_CheckPasswordCharEncoding:PROC
EXTRN	_CipherGetKeySize:PROC
EXTRN	_CipherGetName:PROC
EXTRN	_EAGetFirst:PROC
EXTRN	_EAGetNext:PROC
EXTRN	_EAGetName:PROC
EXTRN	_EAGetCipherCount:PROC
EXTRN	_EAGetLastCipher:PROC
EXTRN	_EAGetPreviousCipher:PROC
EXTRN	_EAIsFormatEnabled:PROC
EXTRN	_HashGetName:PROC
EXTRN	_HashIsDeprecated:PROC
EXTRN	_EnableHwEncryption:PROC
EXTRN	_KeyFileRemoveAll:PROC
EXTRN	_KeyFilesApply:PROC
EXTRN	_KeyFilesDlgProc@16:PROC
EXTRN	_cleanup:PROC
EXTRN	_CreateFullVolumePath:PROC
EXTRN	_AbortProcess:PROC
EXTRN	_AbortProcessSilent:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	_IsDiskReadError:PROC
EXTRN	_translateWin32Error:PROC
EXTRN	_AboutDlgProc@16:PROC
EXTRN	_IsButtonChecked:PROC
EXTRN	_CheckButton:PROC
EXTRN	_ToUNICODE:PROC
EXTRN	_InitDialog:PROC
EXTRN	_RenderBitmap:PROC
EXTRN	_RegisterRedTick:PROC
EXTRN	_UnregisterRedTick:PROC
EXTRN	_WaitCursor:PROC
EXTRN	_NormalCursor:PROC
EXTRN	_ArrowWaitCursor:PROC
EXTRN	_AddComboPair:PROC
EXTRN	_AddComboPairW:PROC
EXTRN	_SelectAlgo:PROC
EXTRN	_PopulateWipeModeCombo:PROC
EXTRN	_GetWipeModeName:PROC
EXTRN	_GetPathType:PROC
EXTRN	_CreateSysEncMutex:PROC
EXTRN	_InstanceHasSysEncMutex:PROC
EXTRN	_CloseSysEncMutex:PROC
EXTRN	_CreateNonSysInplaceEncMutex:PROC
EXTRN	_CloseNonSysInplaceEncMutex:PROC
EXTRN	_NonSysInplaceEncInProgressElsewhere:PROC
EXTRN	_IsGostCryptInstallerRunning:PROC
EXTRN	_ReadDriverConfigurationFlags:PROC
EXTRN	_LoadSysEncSettings:PROC
EXTRN	_LoadNonSysInPlaceEncSettings:PROC
EXTRN	_InitApp:PROC
EXTRN	_IsSystemDevicePath:PROC
EXTRN	_RawDevicesDlgProc@16:PROC
EXTRN	_TextInfoDialogBox:PROC
EXTRN	_BenchmarkDlgProc@16:PROC
EXTRN	_DriverAttach:PROC
EXTRN	_CipherTestDialogProc@16:PROC
EXTRN	_BrowseFiles:PROC
EXTRN	_handleError:PROC
EXTRN	_LocalizeDialog:PROC
EXTRN	_OpenVolumeExplorerWindow:PROC
EXTRN	_CloseVolumeExplorerWindows:PROC
EXTRN	_CheckCapsLock:PROC
EXTRN	_CheckFileExtension:PROC
EXTRN	_GetLastAvailableDrive:PROC
EXTRN	_MountVolume:PROC
EXTRN	_UnmountVolume:PROC
EXTRN	_IsMountedVolume:PROC
EXTRN	_IsAdmin:PROC
EXTRN	_IsBuiltInAdmin:PROC
EXTRN	_IsUacSupported:PROC
EXTRN	_GetDiskDeviceDriveLetter:PROC
EXTRN	_FileSystemAppearsEmpty:PROC
EXTRN	_GetStatsFreeSpaceOnPartition:PROC
EXTRN	_GetDeviceSize:PROC
EXTRN	_GSTFlushFile:PROC
EXTRN	_IsNonInstallMode:PROC
EXTRN	_SetCheckBox:PROC
EXTRN	_GetCheckBox:PROC
EXTRN	_ManageStartupSeq:PROC
EXTRN	_ManageStartupSeqWiz:PROC
EXTRN	_CleanLastVisitedMRU:PROC
EXTRN	_ClearHistory:PROC
EXTRN	_GetSizeString:PROC
EXTRN	_GetConfigPath:PROC
EXTRN	_OpenPageHelp:PROC
EXTRN	_Info:PROC
EXTRN	_Warning:PROC
EXTRN	_WarningDirect:PROC
EXTRN	_Error:PROC
EXTRN	_ErrorDirect:PROC
EXTRN	_AskYesNo:PROC
EXTRN	_AskNoYes:PROC
EXTRN	_AskWarnYesNo:PROC
EXTRN	_AskWarnYesNoString:PROC
EXTRN	_AskWarnNoYes:PROC
EXTRN	_AskWarnOkCancel:PROC
EXTRN	_AskMultiChoice:PROC
EXTRN	_ConfigWriteBegin:PROC
EXTRN	_ConfigWriteEnd:PROC
EXTRN	_ConfigWriteString:PROC
EXTRN	_ConfigWriteInt:PROC
EXTRN	_ConfigReadInt:PROC
EXTRN	_ConfigReadString:PROC
EXTRN	_RestoreDefaultKeyFilesParam:PROC
EXTRN	_LoadDefaultKeyFilesParam:PROC
EXTRN	_IsOSAtLeast:PROC
EXTRN	_IsHiddenOSRunning:PROC
EXTRN	_Extlink:PROC
EXTRN	_RelativePath2Absolute:PROC
EXTRN	_InconsistencyResolved:PROC
EXTRN	_ReportUnexpectedState:PROC
EXTRN	_GetPartitionInfo:PROC
EXTRN	_GetDriveGeometry:PROC
EXTRN	_ToHyperlink:PROC
EXTRN	_ToBootPwdField:PROC
EXTRN	_AccommodateTextField:PROC
EXTRN	_GetDriveLabel:PROC
EXTRN	_OpenVolume:PROC
EXTRN	_CloseVolume:PROC
EXTRN	_InitSecurityTokenLibrary:PROC
EXTRN	_AskNonSysInPlaceEncryptionResume:PROC
EXTRN	_IsWindowsIsoBurnerAvailable:PROC
EXTRN	_LaunchWindowsIsoBurner:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Mbrtowc:PROC
EXTRN	__Wcrtomb:PROC
EXTRN	__Getwctype:PROC
EXTRN	__Getwctypes:PROC
EXTRN	__Towlower:PROC
EXTRN	__Towupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC	; std::locale::_Init
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@_W@std@@MAEPAXI@Z:PROC		; std::ctype<wchar_t>::`vector deleting destructor'
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	?_Addstd@ios_base@std@@SAXPAV12@@Z:PROC		; std::ios_base::_Addstd
EXTRN	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z:PROC	; std::ios_base::_Ios_base_dtor
EXTRN	??_Eios_base@std@@UAEPAXI@Z:PROC		; std::ios_base::`vector deleting destructor'
EXTRN	?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:PROC ; SingleStringToWide
EXTRN	?GetAvailableHostDevices@@YA?AV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@_N000@Z:PROC ; GetAvailableHostDevices
EXTRN	_GetString:PROC
EXTRN	_GetPreferredLangId:PROC
EXTRN	_AddComboItem:PROC
EXTRN	_MoveEditToCombo:PROC
EXTRN	_UpdateComboOrder:PROC
EXTRN	_LoadCombo:PROC
EXTRN	_DumpCombo:PROC
EXTRN	??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z:PROC ; GostCrypt::BootEncryption::BootEncryption
EXTRN	??1BootEncryption@GostCrypt@@QAE@XZ:PROC	; GostCrypt::BootEncryption::~BootEncryption
EXTRN	?AbortDecoyOSWipe@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::AbortDecoyOSWipe
EXTRN	?AbortSetup@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::AbortSetup
EXTRN	?AbortSetupWait@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::AbortSetupWait
EXTRN	?CheckDecoyOSWipeResult@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::CheckDecoyOSWipeResult
EXTRN	?CheckEncryptionSetupResult@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::CheckEncryptionSetupResult
EXTRN	?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::CheckRequirements
EXTRN	?CheckRequirementsHiddenOS@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::CheckRequirementsHiddenOS
EXTRN	?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GostCrypt::BootEncryption::CreateRescueIsoImage
EXTRN	?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z:PROC ; GostCrypt::BootEncryption::Deinstall
EXTRN	?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ:PROC ; GostCrypt::BootEncryption::GetDecoyOSWipeStatus
EXTRN	?GetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEIXZ:PROC ; GostCrypt::BootEncryption::GetHiddenOSCreationPhase
EXTRN	?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ:PROC ; GostCrypt::BootEncryption::GetPartitionForHiddenOS
EXTRN	?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ:PROC ; GostCrypt::BootEncryption::GetStatus
EXTRN	?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ:PROC ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
EXTRN	?Install@BootEncryption@GostCrypt@@QAEX_N@Z:PROC ; GostCrypt::BootEncryption::Install
EXTRN	?InvalidateCachedSysDriveProperties@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::InvalidateCachedSysDriveProperties
EXTRN	?IsCDDrivePresent@BootEncryption@GostCrypt@@QAE_NXZ:PROC ; GostCrypt::BootEncryption::IsCDDrivePresent
EXTRN	?PrepareHiddenOSCreation@BootEncryption@GostCrypt@@QAEXHHH@Z:PROC ; GostCrypt::BootEncryption::PrepareHiddenOSCreation
EXTRN	?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GostCrypt::BootEncryption::PrepareInstallation
EXTRN	?ProbeRealSystemDriveSize@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::ProbeRealSystemDriveSize
EXTRN	?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z:PROC ; GostCrypt::BootEncryption::RegisterBootDriver
EXTRN	?RestartComputer@BootEncryption@GostCrypt@@QAE_NXZ:PROC ; GostCrypt::BootEncryption::RestartComputer
EXTRN	?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::InitialSecurityChecksForHiddenOS
EXTRN	?SetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEXI@Z:PROC ; GostCrypt::BootEncryption::SetHiddenOSCreationPhase
EXTRN	?StartDecryption@BootEncryption@GostCrypt@@QAEXH@Z:PROC ; GostCrypt::BootEncryption::StartDecryption
EXTRN	?StartDecoyOSWipe@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@@Z:PROC ; GostCrypt::BootEncryption::StartDecoyOSWipe
EXTRN	?StartEncryption@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@_N@Z:PROC ; GostCrypt::BootEncryption::StartEncryption
EXTRN	?SystemDriveContainsExtendedPartition@BootEncryption@GostCrypt@@QAE_NXZ:PROC ; GostCrypt::BootEncryption::SystemDriveContainsExtendedPartition
EXTRN	?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ:PROC ; GostCrypt::BootEncryption::SystemDriveContainsNonStandardPartitions
EXTRN	?SystemPartitionCoversWholeDrive@BootEncryption@GostCrypt@@QAE_NXZ:PROC ; GostCrypt::BootEncryption::SystemPartitionCoversWholeDrive
EXTRN	?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ:PROC ; GostCrypt::BootEncryption::VerifyRescueDisk
EXTRN	?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::WipeHiddenOSCreationConfig
EXTRN	??_EContainer@ForEach@GostCrypt@@UAEPAXI@Z:PROC	; GostCrypt::ForEach::Container::`vector deleting destructor'
EXTRN	_Randinit:PROC
EXTRN	_RandStop:PROC
EXTRN	_RandSetHashFunction:PROC
EXTRN	_RandGetHashFunction:PROC
EXTRN	_RandpeekBytes:PROC
EXTRN	_GSTFormatVolume:PROC
EXTRN	_GetVolumeDataAreaSize:PROC
EXTRN	_CheckRequirementsForNonSysInPlaceEnc:PROC
EXTRN	_EncryptPartitionInPlaceBegin:PROC
EXTRN	_EncryptPartitionInPlaceResume:PROC
EXTRN	_ShowInPlaceEncErrMsgWAltSteps:PROC
EXTRN	_SetNonSysInplaceEncUIStatus:PROC
EXTRN	_ComServerFormat:PROC
EXTRN	_UacAnalyzeHiddenVolumeHost:PROC
EXTRN	_InitProgressBar:PROC
EXTRN	_UpdateProgressBarProc:PROC
EXTRN	_AutoTestAlgorithms:PROC
EXTRN	_CommandHelpDlgProc@16:PROC
EXTRN	_Win32CommandLine:PROC
EXTRN	_GetArgumentID:PROC
EXTRN	_GetArgumentValue:PROC
EXTRN	_XmlWriteHeader:PROC
EXTRN	_XmlWriteFooter:PROC
EXTRN	??_E?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z:PROC ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`vector deleting destructor'
EXTRN	??_E?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@_W@std@@MAEPAXI@Z:PROC		; std::numpunct<wchar_t>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__allrem:PROC
EXTRN	__aulldiv:PROC
EXTRN	__chkstk:PROC
EXTRN	__ltod3:PROC
EXTRN	__ultod3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	_LastDialogId:DWORD
EXTRN	_SecurityTokenLibraryPath:BYTE
EXTRN	_hFixedDigitFont:DWORD
EXTRN	_hBoldFont:DWORD
EXTRN	_hTitleFont:DWORD
EXTRN	_hUserUnderlineFont:DWORD
EXTRN	_hUserBoldFont:DWORD
EXTRN	_ScreenDPI:DWORD
EXTRN	_MainDlg:DWORD
EXTRN	_bHistory:DWORD
EXTRN	_bPreserveTimestamp:DWORD
EXTRN	_bStartOnLogon:DWORD
EXTRN	_HiddenSectorDetectionStatus:DWORD
EXTRN	_lpszTitle:DWORD
EXTRN	_nCurrentOS:DWORD
EXTRN	_CurrentOSMajor:DWORD
EXTRN	_hDriver:DWORD
EXTRN	_hInst:DWORD
EXTRN	_SystemEncryptionStatus:DWORD
EXTRN	_nWipeMode:DWORD
EXTRN	_bSysPartitionSelected:DWORD
EXTRN	_bSysDriveSelected:DWORD
EXTRN	_bHyperLinkBeingTracked:DWORD
EXTRN	_bInPlaceEncNonSysPending:DWORD
EXTRN	_KeyFilesEnable:DWORD
EXTRN	_FirstKeyFile:DWORD
EXTRN	_defaultKeyFilesParam:QWORD
EXTRN	?_BADOFF@std@@3_JB:QWORD			; std::_BADOFF
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@_W@std@@2V0locale@2@A:DWORD		; std::ctype<wchar_t>::id
EXTRN	_LocalizationActive:DWORD
EXTRN	_bFastPollEnabled:DWORD
EXTRN	_bRandmixEnabled:DWORD
EXTRN	_FormatWriteBufferSize:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?bSystemEncryptionStatusChanged@@3HA DD 01H DUP (?)	; bSystemEncryptionStatusChanged
?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A DB 0cH DUP (?) ; DeferredNonSysInPlaceEncDevices
_BSS	ENDS
;	COMDAT ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A
_BSS	SEGMENT
?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A DB 05eH DUP (?) ; `SysEncryptionOrDecryptionRequired'::`2'::locBootEncStatus
_BSS	ENDS
;	COMDAT ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A
_BSS	SEGMENT
?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A DB 05eH DUP (?) ; `SysDriveOrPartitionFullyEncrypted'::`2'::locBootEncStatus
_BSS	ENDS
;	COMDAT ?nLastVolumeSize@?1??VerifySizeAndUpdate@@9@4_KA
_BSS	SEGMENT
?nLastVolumeSize@?1??VerifySizeAndUpdate@@9@4_KA DQ 01H DUP (?) ; `VerifySizeAndUpdate'::`2'::nLastVolumeSize
_BSS	ENDS
;	COMDAT ?lastNonSysInplaceEncStatus@?1??UpdateNonSysInplaceEncProgressBar@@9@4HA
_BSS	SEGMENT
?lastNonSysInplaceEncStatus@?1??UpdateNonSysInplaceEncProgressBar@@9@4HA DD 01H DUP (?) ; `UpdateNonSysInplaceEncProgressBar'::`2'::lastNonSysInplaceEncStatus
_BSS	ENDS
;	COMDAT ?bRandPoolDispAscii@?1??DisplayRandPool@@9@4HA
_BSS	SEGMENT
?bRandPoolDispAscii@?1??DisplayRandPool@@9@4HA DD 01H DUP (?) ; `DisplayRandPool'::`2'::bRandPoolDispAscii
_BSS	ENDS
;	COMDAT ?PageDebugId@?1??PageDialogProc@@9@16@4PADA
_BSS	SEGMENT
?PageDebugId@?1??PageDialogProc@@9@16@4PADA DB 080H DUP (?) ; `PageDialogProc'::`2'::PageDebugId
_BSS	ENDS
;	COMDAT ?warningConfirmed@?NM@??MainDialogProc@@9@16@4_NA
_BSS	SEGMENT
?warningConfirmed@?NM@??MainDialogProc@@9@16@4_NA DB 01H DUP (?) ; `MainDialogProc'::`220'::warningConfirmed
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
;	COMDAT ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A
_BSS	SEGMENT
?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A DQ 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Static
_BSS	ENDS
;	COMDAT ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
CRT$XCU	SEGMENT
?DeferredNonSysInPlaceEncDevices$initializer$@@3P6AXXZA DD FLAT:??__EDeferredNonSysInPlaceEncDevices@@YAXXZ ; DeferredNonSysInPlaceEncDevices$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@ffffffffffffffffffffffffffffffff
CONST	SEGMENT
__xmm@ffffffffffffffffffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@000000000000000000000019000000a2
CONST	SEGMENT
__xmm@000000000000000000000019000000a2 DB 0a2H, 00H, 00H, 00H, 019H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@42b00000
CONST	SEGMENT
__real@42b00000 DD 042b00000r			; 88
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT __real@4058ff5c28f5c28f
CONST	SEGMENT
__real@4058ff5c28f5c28f DQ 04058ff5c28f5c28fr	; 99.99
CONST	ENDS
;	COMDAT __real@4000cccccccccccd
CONST	SEGMENT
__real@4000cccccccccccd DQ 04000cccccccccccdr	; 2.1
CONST	ENDS
;	COMDAT __real@3feb333333333333
CONST	SEGMENT
__real@3feb333333333333 DQ 03feb333333333333r	; 0.85
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@_W@std@@8 DD FLAT:??_R0?AV?$numpunct@_W@std@@@8 ; std::numpunct<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@_W@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@_W@std@@8 ; std::numpunct<wchar_t>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@_W@std@@8 DD 00H			; std::numpunct<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
data$r	SEGMENT
??_R0?AV?$numpunct@_W@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::numpunct<wchar_t> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@_W@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@_W@std@@6B@ DD 00H			; std::numpunct<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@_W@std@@@8
	DD	FLAT:??_R3?$numpunct@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 DD 00H ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@'
	DB	'_W@std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ DD 00H ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R0?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8 DD 00H ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocat'
	DB	'or@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@6B@ DD 00H ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8 DD FLAT:??_R0?AUContainer@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::Container::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2Container@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::Container::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3Container@ForEach@GostCrypt@@8 DD 00H		; GostCrypt::ForEach::Container::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUContainer@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUContainer@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::Container `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUContainer@ForEach@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4Container@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4Container@ForEach@GostCrypt@@6B@ DD 00H		; GostCrypt::ForEach::Container::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUContainer@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@_W@std@@8 DD FLAT:??_R0?AV?$ctype@_W@std@@@8 ; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R2?$ctype@_W@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@_W@std@@8 ; std::ctype<wchar_t>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R3?$ctype@_W@std@@8 DD 00H				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
data$r	SEGMENT
??_R0?AV?$ctype@_W@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<wchar_t> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@_W@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@_W@std@@6B@ DD 00H				; std::ctype<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@_W@std@@@8
	DD	FLAT:??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$r	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$r	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$r	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$r	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$r	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$all'
	DB	'ocator@_W@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD 00H ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$alloca'
	DB	'tor@_W@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD 00H ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	020H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	08H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	018H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT
??_R4ios_base@std@@6B@ DD 00H				; std::ios_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVios_base@std@@@8
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP?$AA@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP?$AA@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE?$AA@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE?$AA@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@_W@std@@6B@
CONST	SEGMENT
??_7?$numpunct@_W@std@@6B@ DD FLAT:??_R4?$numpunct@_W@std@@6B@ ; std::numpunct<wchar_t>::`vftable'
	DD	FLAT:??_E?$numpunct@_W@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ
	DD	FLAT:?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld?$AA@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu?$AA@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld?$AA@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu?$AA@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`vftable'
	DD	FLAT:??_E?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@DKEEGIEL@ERR_SELF_TESTS_FAILED?$AA@
CONST	SEGMENT
??_C@_0BG@DKEEGIEL@ERR_SELF_TESTS_FAILED?$AA@ DB 'ERR_SELF_TESTS_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08ELEAABKI@NODRIVER?$AA@
CONST	SEGMENT
??_C@_08ELEAABKI@NODRIVER?$AA@ DB 'NODRIVER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PLHAEEAO@INIT_RAND?$AA@
CONST	SEGMENT
??_C@_09PLHAEEAO@INIT_RAND?$AA@ DB 'INIT_RAND', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDPHKHCO@INIT_SYS_ENC?$AA@
CONST	SEGMENT
??_C@_0N@PDPHKHCO@INIT_SYS_ENC?$AA@ DB 'INIT_SYS_ENC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JEMCACBK@AfterWMInitTasks?39509?$AA@
CONST	SEGMENT
??_C@_0BG@JEMCACBK@AfterWMInitTasks?39509?$AA@ DB 'AfterWMInitTasks:9509', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IJPDGLEP@HIDDEN_OS_CREATION_NOT_FINISHED_@
CONST	SEGMENT
??_C@_0DB@IJPDGLEP@HIDDEN_OS_CREATION_NOT_FINISHED_@ DB 'HIDDEN_OS_CREATI'
	DB	'ON_NOT_FINISHED_CHOICE_ASK_LATER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KJCGFBOB@HIDDEN_OS_CREATION_NOT_FINISHED_@
CONST	SEGMENT
??_C@_0DB@KJCGFBOB@HIDDEN_OS_CREATION_NOT_FINISHED_@ DB 'HIDDEN_OS_CREATI'
	DB	'ON_NOT_FINISHED_CHOICE_TERMINATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NFNCFNOG@HIDDEN_OS_CREATION_NOT_FINISHED_@
CONST	SEGMENT
??_C@_0CN@NFNCFNOG@HIDDEN_OS_CREATION_NOT_FINISHED_@ DB 'HIDDEN_OS_CREATI'
	DB	'ON_NOT_FINISHED_CHOICE_RETRY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BLKNBIFF@HIDDEN_OS_CREATION_NOT_FINISHED_@
CONST	SEGMENT
??_C@_0CE@BLKNBIFF@HIDDEN_OS_CREATION_NOT_FINISHED_@ DB 'HIDDEN_OS_CREATI'
	DB	'ON_NOT_FINISHED_ASK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BAAJMEPI@OS_WIPING_NOT_FINISHED_ASK?$AA@
CONST	SEGMENT
??_C@_0BL@BAAJMEPI@OS_WIPING_NOT_FINISHED_ASK?$AA@ DB 'OS_WIPING_NOT_FINI'
	DB	'SHED_ASK', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DFBAAIPH@BOOT_PRETEST_FAILED_RETRY?$AA@
CONST	SEGMENT
??_C@_0BK@DFBAAIPH@BOOT_PRETEST_FAILED_RETRY?$AA@ DB 'BOOT_PRETEST_FAILED'
	DB	'_RETRY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BEIDFAO@AfterWMInitTasks?39374?$AA@
CONST	SEGMENT
??_C@_0BG@BEIDFAO@AfterWMInitTasks?39374?$AA@ DB 'AfterWMInitTasks:9374', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BOBNFKFK@AfterWMInitTasks?39288?$AA@
CONST	SEGMENT
??_C@_0BG@BOBNFKFK@AfterWMInitTasks?39288?$AA@ DB 'AfterWMInitTasks:9288', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MHIMBFBH@SYS_PARTITION_OR_DRIVE_APPEARS_F@
CONST	SEGMENT
??_C@_0CP@MHIMBFBH@SYS_PARTITION_OR_DRIVE_APPEARS_F@ DB 'SYS_PARTITION_OR'
	DB	'_DRIVE_APPEARS_FULLY_ENCRYPTED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BOICFCMD@NOTHING_TO_RESUME?$AA@
CONST	SEGMENT
??_C@_0BC@BOICFCMD@NOTHING_TO_RESUME?$AA@ DB 'NOTHING_TO_RESUME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LHNBFDMB@SYSTEM_ENCRYPTION_SCHEDULED_BUT_@
CONST	SEGMENT
??_C@_0CL@LHNBFDMB@SYSTEM_ENCRYPTION_SCHEDULED_BUT_@ DB 'SYSTEM_ENCRYPTIO'
	DB	'N_SCHEDULED_BUT_PBA_FAILED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JNPKODLF@AfterWMInitTasks?39116?$AA@
CONST	SEGMENT
??_C@_0BG@JNPKODLF@AfterWMInitTasks?39116?$AA@ DB 'AfterWMInitTasks:9116', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KGJBOMKO@CANNOT_DECRYPT_HIDDEN_OS?$AA@
CONST	SEGMENT
??_C@_0BJ@KGJBOMKO@CANNOT_DECRYPT_HIDDEN_OS?$AA@ DB 'CANNOT_DECRYPT_HIDDE'
	DB	'N_OS', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GLPLHHCP@AfterSysEncProgressWMInitTasks?39@
CONST	SEGMENT
??_C@_0CE@GLPLHHCP@AfterSysEncProgressWMInitTasks?39@ DB 'AfterSysEncProg'
	DB	'ressWMInitTasks:9045', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IEBIBFIL@CANT_GET_CLUSTER_BITMAP?$AA@
CONST	SEGMENT
??_C@_0BI@IEBIBFIL@CANT_GET_CLUSTER_BITMAP?$AA@ DB 'CANT_GET_CLUSTER_BITM'
	DB	'AP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BIDCCDPC@MountVolumesRemovable?$AA@
CONST	SEGMENT
??_C@_0BG@BIDCCDPC@MountVolumesRemovable?$AA@ DB 'MountVolumesRemovable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PMECNFFM@HIDDEN_VOL_HOST_UNSUPPORTED_FILE@
CONST	SEGMENT
??_C@_0CE@PMECNFFM@HIDDEN_VOL_HOST_UNSUPPORTED_FILE@ DB 'HIDDEN_VOL_HOST_'
	DB	'UNSUPPORTED_FILESYS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLECLIC@CANT_GET_OUTER_VOL_INFO?$AA@
CONST	SEGMENT
??_C@_0BI@JLECLIC@CANT_GET_OUTER_VOL_INFO?$AA@ DB 'CANT_GET_OUTER_VOL_INF'
	DB	'O', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GKHHEFAE@HIDDEN_VOL_HOST_NTFS?$AA@
CONST	SEGMENT
??_C@_0BF@GKHHEFAE@HIDDEN_VOL_HOST_NTFS?$AA@ DB 'HIDDEN_VOL_HOST_NTFS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DBCOIOLF@ERR_HIDDEN_VOL_HOST_ENCRYPTED_IN@
CONST	SEGMENT
??_C@_0CG@DBCOIOLF@ERR_HIDDEN_VOL_HOST_ENCRYPTED_IN@ DB 'ERR_HIDDEN_VOL_H'
	DB	'OST_ENCRYPTED_INPLACE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PEDIFLNF@ERR_HIDDEN_NOT_NORMAL_VOLUME?$AA@
CONST	SEGMENT
??_C@_0BN@PEDIFLNF@ERR_HIDDEN_NOT_NORMAL_VOLUME?$AA@ DB 'ERR_HIDDEN_NOT_N'
	DB	'ORMAL_VOLUME', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GJIBONDI@ERR_VOL_FORMAT_BAD?$AA@
CONST	SEGMENT
??_C@_0BD@GJIBONDI@ERR_VOL_FORMAT_BAD?$AA@ DB 'ERR_VOL_FORMAT_BAD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EDMDLNEK@CANT_ACCESS_OUTER_VOL?$AA@
CONST	SEGMENT
??_C@_0BG@EDMDLNEK@CANT_ACCESS_OUTER_VOL?$AA@ DB 'CANT_ACCESS_OUTER_VOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EIHCDBCC@NO_SPACE_FOR_HIDDEN_VOL?$AA@
CONST	SEGMENT
??_C@_0BI@EIHCDBCC@NO_SPACE_FOR_HIDDEN_VOL?$AA@ DB 'NO_SPACE_FOR_HIDDEN_V'
	DB	'OL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LGCKNJIO@COMMAND_LINE_ERROR?$AA@
CONST	SEGMENT
??_C@_0BD@LGCKNJIO@COMMAND_LINE_ERROR?$AA@ DB 'COMMAND_LINE_ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAJCLHKP@no?$AA@
CONST	SEGMENT
??_C@_02KAJCLHKP@no?$AA@ DB 'no', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n?$AA@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n?$AA@ DB 'n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICICOMAL@yes?$AA@
CONST	SEGMENT
??_C@_03ICICOMAL@yes?$AA@ DB 'yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EANLCPLP@y?$AA@
CONST	SEGMENT
??_C@_01EANLCPLP@y?$AA@ DB 'y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OGHPLGEM@?1z?$AA@
CONST	SEGMENT
??_C@_02OGHPLGEM@?1z?$AA@ DB '/z', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHLNANAF@?1s?$AA@
CONST	SEGMENT
??_C@_02DHLNANAF@?1s?$AA@ DB '/s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFDFIFLD@?1sysenc?$AA@
CONST	SEGMENT
??_C@_07PFDFIFLD@?1sysenc?$AA@ DB '/sysenc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PMGMEKMI@?1risysenc?$AA@
CONST	SEGMENT
??_C@_09PMGMEKMI@?1risysenc?$AA@ DB '/risysenc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02BMJAFOMG@?1p?$AA@
CONST	SEGMENT
??_C@_02BMJAFOMG@?1p?$AA@ DB '/p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DLEMDKJB@?1prinplace?$AA@
CONST	SEGMENT
??_C@_0L@DLEMDKJB@?1prinplace?$AA@ DB '/prinplace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02IHJAPHNO@?1i?$AA@
CONST	SEGMENT
??_C@_02IHJAPHNO@?1i?$AA@ DB '/i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MEKEMIGM@?1isysenc?$AA@
CONST	SEGMENT
??_C@_08MEKEMIGM@?1isysenc?$AA@ DB '/isysenc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFEOHHG@?1encdev?$AA@
CONST	SEGMENT
??_C@_07MFEOHHG@?1encdev?$AA@ DB '/encdev', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCDOIJJD@?1d?$AA@
CONST	SEGMENT
??_C@_02DCDOIJJD@?1d?$AA@ DB '/d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FPKBNNLN@?1dsysenc?$AA@
CONST	SEGMENT
??_C@_08FPKBNNLN@?1dsysenc?$AA@ DB '/dsysenc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HNHPBPFE@?1c?$AA@
CONST	SEGMENT
??_C@_02HNHPBPFE@?1c?$AA@ DB '/c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FFGENEKE@?1csysenc?$AA@
CONST	SEGMENT
??_C@_08FFGENEKE@?1csysenc?$AA@ DB '/csysenc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02EPEJHNNG@?1a?$AA@
CONST	SEGMENT
??_C@_02EPEJHNNG@?1a?$AA@ DB '/a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09JABABBPB@?1tokenlib?$AA@
CONST	SEGMENT
??_C@_09JABABBPB@?1tokenlib?$AA@ DB '/tokenlib', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02FILGPIH@?1q?$AA@
CONST	SEGMENT
??_C@_02FILGPIH@?1q?$AA@ DB '/q', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMMBDMDD@?1quit?$AA@
CONST	SEGMENT
??_C@_05CMMBDMDD@?1quit?$AA@ DB '/quit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MINBGBBJ@?1n?$AA@
CONST	SEGMENT
??_C@_02MINBGBBJ@?1n?$AA@ DB '/n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IEGCIDAG@?1noisocheck?$AA@
CONST	SEGMENT
??_C@_0M@IEGCIDAG@?1noisocheck?$AA@ DB '/noisocheck', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JOILMGJP@?1h?$AA@
CONST	SEGMENT
??_C@_02JOILMGJP@?1h?$AA@ DB '/h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BCLHLEKP@?1history?$AA@
CONST	SEGMENT
??_C@_08BCLHLEKP@?1history?$AA@ DB '/history', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JGIDNNFC@?9Embedding?$AA@
CONST	SEGMENT
??_C@_0L@JGIDNNFC@?9Embedding?$AA@ DB '-Embedding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ICCGDAH@CONFIRM_WIPE_START?$AA@
CONST	SEGMENT
??_C@_0BD@ICCGDAH@CONFIRM_WIPE_START?$AA@ DB 'CONFIRM_WIPE_START', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LLDBJBEP@CONFIRM_WIPE_START_DECOY_SYS_PAR@
CONST	SEGMENT
??_C@_0CH@LLDBJBEP@CONFIRM_WIPE_START_DECOY_SYS_PAR@ DB 'CONFIRM_WIPE_STA'
	DB	'RT_DECOY_SYS_PARTITION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NGECJJAH@FORMAT_IN_PROGRESS?$AA@
CONST	SEGMENT
??_C@_0BD@NGECJJAH@FORMAT_IN_PROGRESS?$AA@ DB 'FORMAT_IN_PROGRESS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DADPIOMM@CLUSTER_TOO_SMALL?$AA@
CONST	SEGMENT
??_C@_0BC@DADPIOMM@CLUSTER_TOO_SMALL?$AA@ DB 'CLUSTER_TOO_SMALL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NLBJKNFD@CONFIRM_FAT_FOR_FILES_OVER_4GB?$AA@
CONST	SEGMENT
??_C@_0BP@NLBJKNFD@CONFIRM_FAT_FOR_FILES_OVER_4GB?$AA@ DB 'CONFIRM_FAT_FO'
	DB	'R_FILES_OVER_4GB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NALGNOGO@HIDDEN_VOL_HOST_NTFS_ASK?$AA@
CONST	SEGMENT
??_C@_0BJ@NALGNOGO@HIDDEN_VOL_HOST_NTFS_ASK?$AA@ DB 'HIDDEN_VOL_HOST_NTFS'
	DB	'_ASK', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PCAIDDLK@HIDDEN_VOL_HOST_UNSUPPORTED_FILE@
CONST	SEGMENT
??_C@_0CM@PCAIDDLK@HIDDEN_VOL_HOST_UNSUPPORTED_FILE@ DB 'HIDDEN_VOL_HOST_'
	DB	'UNSUPPORTED_FILESYS_WIN2000', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PNCJJOHK@OUTER_VOLUME_TOO_SMALL_FOR_HIDDE@
CONST	SEGMENT
??_C@_0CK@PNCJJOHK@OUTER_VOLUME_TOO_SMALL_FOR_HIDDE@ DB 'OUTER_VOLUME_TOO'
	DB	'_SMALL_FOR_HIDDEN_OS_NTFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HAPBHPDC@FAT_NOT_AVAILABLE_FOR_SO_LARGE_V@
CONST	SEGMENT
??_C@_0CG@HAPBHPDC@FAT_NOT_AVAILABLE_FOR_SO_LARGE_V@ DB 'FAT_NOT_AVAILABL'
	DB	'E_FOR_SO_LARGE_VOLUME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EFIGHBDJ@OFFER_FAT_FORMAT_ALTERNATIVE?$AA@
CONST	SEGMENT
??_C@_0BN@EFIGHBDJ@OFFER_FAT_FORMAT_ALTERNATIVE?$AA@ DB 'OFFER_FAT_FORMAT'
	DB	'_ALTERNATIVE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09PIOBCILE@?1acsysenc?$AA@
CONST	SEGMENT
??_C@_09PIOBCILE@?1acsysenc?$AA@ DB '/acsysenc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MGEMKCIE@CANNOT_INITIATE_SYS_ENCRYPTION_P@
CONST	SEGMENT
??_C@_0CH@MGEMKCIE@CANNOT_INITIATE_SYS_ENCRYPTION_P@ DB 'CANNOT_INITIATE_'
	DB	'SYS_ENCRYPTION_PRETEST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DFDNFFMK@CANNOT_INITIATE_HIDDEN_OS_CREATI@
CONST	SEGMENT
??_C@_0CD@DFDNFFMK@CANNOT_INITIATE_HIDDEN_OS_CREATI@ DB 'CANNOT_INITIATE_'
	DB	'HIDDEN_OS_CREATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DGIFCGMK@PREBOOT_NOT_LOCALIZED?$AA@
CONST	SEGMENT
??_C@_0BG@DGIFCGMK@PREBOOT_NOT_LOCALIZED?$AA@ DB 'PREBOOT_NOT_LOCALIZED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BMFNBJAJ@WIPE_MODE_WARN?$AA@
CONST	SEGMENT
??_C@_0P@BMFNBJAJ@WIPE_MODE_WARN?$AA@ DB 'WIPE_MODE_WARN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KDGMPLJF@RESCUE_DISK_CHECK_FAILED?$AA@
CONST	SEGMENT
??_C@_0BJ@KDGMPLJF@RESCUE_DISK_CHECK_FAILED?$AA@ DB 'RESCUE_DISK_CHECK_FA'
	DB	'ILED', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LCMPFPDG@RESCUE_DISK_CHECK_FAILED_SENTENC@
CONST	SEGMENT
??_C@_0CL@LCMPFPDG@RESCUE_DISK_CHECK_FAILED_SENTENC@ DB 'RESCUE_DISK_CHEC'
	DB	'K_FAILED_SENTENCE_APPENDIX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GAGHEKIC@RESCUE_DISK_WIN_ISOBURN_PRELAUNC@
CONST	SEGMENT
??_C@_0CH@GAGHEKIC@RESCUE_DISK_WIN_ISOBURN_PRELAUNC@ DB 'RESCUE_DISK_WIN_'
	DB	'ISOBURN_PRELAUNCH_NOTE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EJPBDEFG@RESCUE_DISK_BURN_NO_CHECK_WARN?$AA@
CONST	SEGMENT
??_C@_0BP@EJPBDEFG@RESCUE_DISK_BURN_NO_CHECK_WARN?$AA@ DB 'RESCUE_DISK_BU'
	DB	'RN_NO_CHECK_WARN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BHLKCEED@CD_BURNER_NOT_PRESENT_WILL_STORE@
CONST	SEGMENT
??_C@_0CK@BHLKCEED@CD_BURNER_NOT_PRESENT_WILL_STORE@ DB 'CD_BURNER_NOT_PR'
	DB	'ESENT_WILL_STORE_ISO_INFO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FEAJEJEJ@CD_BURNER_NOT_PRESENT_CONNECTED_@
CONST	SEGMENT
??_C@_0CE@FEAJEJEJ@CD_BURNER_NOT_PRESENT_CONNECTED_@ DB 'CD_BURNER_NOT_PR'
	DB	'ESENT_CONNECTED_NOW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FCOKHALJ@CD_BURNER_NOT_PRESENT_WILL_CONNE@
CONST	SEGMENT
??_C@_0CJ@FCOKHALJ@CD_BURNER_NOT_PRESENT_WILL_CONNE@ DB 'CD_BURNER_NOT_PR'
	DB	'ESENT_WILL_CONNECT_LATER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OBJIPJKN@CD_BURNER_NOT_PRESENT_WILL_STORE@
CONST	SEGMENT
??_C@_0CF@OBJIPJKN@CD_BURNER_NOT_PRESENT_WILL_STORE@ DB 'CD_BURNER_NOT_PR'
	DB	'ESENT_WILL_STORE_ISO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GLKAIFEA@CD_BURNER_NOT_PRESENT?$AA@
CONST	SEGMENT
??_C@_0BG@GLKAIFEA@CD_BURNER_NOT_PRESENT?$AA@ DB 'CD_BURNER_NOT_PRESENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HFPIFBIF@CANNOT_SATISFY_OVER_4G_FILE_SIZE@
CONST	SEGMENT
??_C@_0CF@HFPIFBIF@CANNOT_SATISFY_OVER_4G_FILE_SIZE@ DB 'CANNOT_SATISFY_O'
	DB	'VER_4G_FILE_SIZE_REQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KNHACFHE@CANNOT_CREATE_NON_HIDDEN_NTFS_VO@
CONST	SEGMENT
??_C@_0DG@KNHACFHE@CANNOT_CREATE_NON_HIDDEN_NTFS_VO@ DB 'CANNOT_CREATE_NO'
	DB	'N_HIDDEN_NTFS_VOLUMES_UNDER_HIDDEN_OS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DBNLNPHP@FOUND_NO_PARTITION_W_DEFERRED_IN@
CONST	SEGMENT
??_C@_0CK@DBNLNPHP@FOUND_NO_PARTITION_W_DEFERRED_IN@ DB 'FOUND_NO_PARTITI'
	DB	'ON_W_DEFERRED_INPLACE_ENC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GNHKCMLM@CANT_DISMOUNT_OUTER_VOL?$AA@
CONST	SEGMENT
??_C@_0BI@GNHKCMLM@CANT_DISMOUNT_OUTER_VOL?$AA@ DB 'CANT_DISMOUNT_OUTER_V'
	DB	'OL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BGCHIACG@CANNOT_RESTORE_KEYBOARD_LAYOUT?$AA@
CONST	SEGMENT
??_C@_0BP@BGCHIACG@CANNOT_RESTORE_KEYBOARD_LAYOUT?$AA@ DB 'CANNOT_RESTORE'
	DB	'_KEYBOARD_LAYOUT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CPHEENHA@UNSUPPORTED_CHARS_IN_PWD?$AA@
CONST	SEGMENT
??_C@_0BJ@CPHEENHA@UNSUPPORTED_CHARS_IN_PWD?$AA@ DB 'UNSUPPORTED_CHARS_IN'
	DB	'_PWD', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NJLIGNCF@FREE_SPACE_FOR_WRITING_TO_OUTER_@
CONST	SEGMENT
??_C@_0CH@NJLIGNCF@FREE_SPACE_FOR_WRITING_TO_OUTER_@ DB 'FREE_SPACE_FOR_W'
	DB	'RITING_TO_OUTER_VOLUME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IAHLEEBN@VOLUME_TOO_LARGE_FOR_WINXP?$AA@
CONST	SEGMENT
??_C@_0BL@IAHLEEBN@VOLUME_TOO_LARGE_FOR_WINXP?$AA@ DB 'VOLUME_TOO_LARGE_F'
	DB	'OR_WINXP', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FEGMEEPN@VOLUME_TOO_LARGE_FOR_FAT32?$AA@
CONST	SEGMENT
??_C@_0BL@FEGMEEPN@VOLUME_TOO_LARGE_FOR_FAT32?$AA@ DB 'VOLUME_TOO_LARGE_F'
	DB	'OR_FAT32', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNJNFBJJ@FAT32?$AA@
CONST	SEGMENT
??_C@_05HNJNFBJJ@FAT32?$AA@ DB 'FAT32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HENDJLLF@NOTE_CASCADE_FOR_SYS_ENCRYPTION?$AA@
CONST	SEGMENT
??_C@_0CA@HENDJLLF@NOTE_CASCADE_FOR_SYS_ENCRYPTION?$AA@ DB 'NOTE_CASCADE_'
	DB	'FOR_SYS_ENCRYPTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HEIAMGDN@CONFIRM_CASCADE_FOR_SYS_ENCRYPTI@
CONST	SEGMENT
??_C@_0CD@HEIAMGDN@CONFIRM_CASCADE_FOR_SYS_ENCRYPTI@ DB 'CONFIRM_CASCADE_'
	DB	'FOR_SYS_ENCRYPTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NCAFIIDC@NONSYS_INPLACE_ENC_CONFIRM_BACKU@
CONST	SEGMENT
??_C@_0CC@NCAFIIDC@NONSYS_INPLACE_ENC_CONFIRM_BACKU@ DB 'NONSYS_INPLACE_E'
	DB	'NC_CONFIRM_BACKUP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BGCKDFKI@HIDDEN_VOL_HOST_SPARSE?$AA@
CONST	SEGMENT
??_C@_0BH@BGCKDFKI@HIDDEN_VOL_HOST_SPARSE?$AA@ DB 'HIDDEN_VOL_HOST_SPARSE'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LHDMMKJO@EXE_FILE_EXTENSION_CONFIRM?$AA@
CONST	SEGMENT
??_C@_0BL@LHDMMKJO@EXE_FILE_EXTENSION_CONFIRM?$AA@ DB 'EXE_FILE_EXTENSION'
	DB	'_CONFIRM', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NCOMIFAB@CONFIRM_SYSTEM_ENCRYPTION_MODE?$AA@
CONST	SEGMENT
??_C@_0BP@NCOMIFAB@CONFIRM_SYSTEM_ENCRYPTION_MODE?$AA@ DB 'CONFIRM_SYSTEM'
	DB	'_ENCRYPTION_MODE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ECFGGOBI@ALREADY_MOUNTED?$AA@
CONST	SEGMENT
??_C@_0BA@ECFGGOBI@ALREADY_MOUNTED?$AA@ DB 'ALREADY_MOUNTED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DKKKPMLO@DEVICE_SELECTED_IN_NON_DEVICE_MO@
CONST	SEGMENT
??_C@_0CD@DKKKPMLO@DEVICE_SELECTED_IN_NON_DEVICE_MO@ DB 'DEVICE_SELECTED_'
	DB	'IN_NON_DEVICE_MODE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NNPIGIED@HIDDEN_VOL_CREATION_UNDER_HIDDEN@
CONST	SEGMENT
??_C@_0CK@NNPIGIED@HIDDEN_VOL_CREATION_UNDER_HIDDEN@ DB 'HIDDEN_VOL_CREAT'
	DB	'ION_UNDER_HIDDEN_OS_HOWTO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DOPCDKC@ADMIN_PRIVILEGES_WARN_HIDVOL?$AA@
CONST	SEGMENT
??_C@_0BN@DOPCDKC@ADMIN_PRIVILEGES_WARN_HIDVOL?$AA@ DB 'ADMIN_PRIVILEGES_'
	DB	'WARN_HIDVOL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EHEECKKC@WINDOWS_BOOT_LOADER_HINTS?$AA@
CONST	SEGMENT
??_C@_0BK@EHEECKKC@WINDOWS_BOOT_LOADER_HINTS?$AA@ DB 'WINDOWS_BOOT_LOADER'
	DB	'_HINTS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KANLNDNO@CUSTOM_BOOT_MANAGERS_IN_MBR_UNSU@
CONST	SEGMENT
??_C@_0CI@KANLNDNO@CUSTOM_BOOT_MANAGERS_IN_MBR_UNSU@ DB 'CUSTOM_BOOT_MANA'
	DB	'GERS_IN_MBR_UNSUPPORTED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EAFFGLI@WDE_UNSUPPORTED_FOR_MULTIPLE_SYS@
CONST	SEGMENT
??_C@_0DC@EAFFGLI@WDE_UNSUPPORTED_FOR_MULTIPLE_SYS@ DB 'WDE_UNSUPPORTED_F'
	DB	'OR_MULTIPLE_SYSTEMS_ON_ONE_DRIVE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BLBEBHP@SYS_PARTITION_MUST_BE_ON_BOOT_DR@
CONST	SEGMENT
??_C@_0CE@BLBEBHP@SYS_PARTITION_MUST_BE_ON_BOOT_DR@ DB 'SYS_PARTITION_MUS'
	DB	'T_BE_ON_BOOT_DRIVE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HEENEHGK@DECOY_OS_REQUIREMENTS?$AA@
CONST	SEGMENT
??_C@_0BG@HEENEHGK@DECOY_OS_REQUIREMENTS?$AA@ DB 'DECOY_OS_REQUIREMENTS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PDMBGJBN@CONFIRM_HIDDEN_OS_EXTRA_BOOT_PAR@
CONST	SEGMENT
??_C@_0CH@PDMBGJBN@CONFIRM_HIDDEN_OS_EXTRA_BOOT_PAR@ DB 'CONFIRM_HIDDEN_O'
	DB	'S_EXTRA_BOOT_PARTITION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PJBIBHBE@UNSUPPORTED_HIDDEN_OS_MULTI_BOOT@
CONST	SEGMENT
??_C@_0CF@PJBIBHBE@UNSUPPORTED_HIDDEN_OS_MULTI_BOOT@ DB 'UNSUPPORTED_HIDD'
	DB	'EN_OS_MULTI_BOOT_CFG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OEFLIJFC@HIDDEN_OS_MULTI_BOOT?$AA@
CONST	SEGMENT
??_C@_0BF@OEFLIJFC@HIDDEN_OS_MULTI_BOOT?$AA@ DB 'HIDDEN_OS_MULTI_BOOT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EDCHAEND@MULTI_BOOT_FOR_ADVANCED_ONLY?$AA@
CONST	SEGMENT
??_C@_0BN@EDCHAEND@MULTI_BOOT_FOR_ADVANCED_ONLY?$AA@ DB 'MULTI_BOOT_FOR_A'
	DB	'DVANCED_ONLY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02COKGDMEE@?1r?$AA@
CONST	SEGMENT
??_C@_02COKGDMEE@?1r?$AA@ DB '/r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LFCLDECM@HIDDEN_OS_WRITE_PROTECTION_BRIEF@
CONST	SEGMENT
??_C@_0CG@LFCLDECM@HIDDEN_OS_WRITE_PROTECTION_BRIEF@ DB 'HIDDEN_OS_WRITE_'
	DB	'PROTECTION_BRIEF_INFO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OILEALFF@HIDDEN_OS_WRITE_PROTECTION_EXPLA@
CONST	SEGMENT
??_C@_0CH@OILEALFF@HIDDEN_OS_WRITE_PROTECTION_EXPLA@ DB 'HIDDEN_OS_WRITE_'
	DB	'PROTECTION_EXPLANATION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IDNPDOGL@DECOY_OS_REINSTALL_WARNING?$AA@
CONST	SEGMENT
??_C@_0BL@IDNPDOGL@DECOY_OS_REINSTALL_WARNING?$AA@ DB 'DECOY_OS_REINSTALL'
	DB	'_WARNING', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HFDNHKMM@GAP_BETWEEN_SYS_AND_HIDDEN_OS_PA@
CONST	SEGMENT
??_C@_0CI@HFDNHKMM@GAP_BETWEEN_SYS_AND_HIDDEN_OS_PA@ DB 'GAP_BETWEEN_SYS_'
	DB	'AND_HIDDEN_OS_PARTITION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BGKLALIE@CONTAINER_ADMIN_WARNING?$AA@
CONST	SEGMENT
??_C@_0BI@BGKLALIE@CONTAINER_ADMIN_WARNING?$AA@ DB 'CONTAINER_ADMIN_WARNI'
	DB	'NG', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@
CONST	SEGMENT
??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@ DB 'CONFIRM_EXIT_UNIVERSAL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IFOLEKLB@CONFIRM_CANCEL_SYS_ENC_PRETEST?$AA@
CONST	SEGMENT
??_C@_0BP@IFOLEKLB@CONFIRM_CANCEL_SYS_ENC_PRETEST?$AA@ DB 'CONFIRM_CANCEL'
	DB	'_SYS_ENC_PRETEST', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KDAJHHMG@CONFIRM_CANCEL_HIDDEN_OS_CREATIO@
CONST	SEGMENT
??_C@_0CC@KDAJHHMG@CONFIRM_CANCEL_HIDDEN_OS_CREATIO@ DB 'CONFIRM_CANCEL_H'
	DB	'IDDEN_OS_CREATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OMHIMMHH@SYSTEM_ENCRYPTION_DEFER_CONFIRM?$AA@
CONST	SEGMENT
??_C@_0CA@OMHIMMHH@SYSTEM_ENCRYPTION_DEFER_CONFIRM?$AA@ DB 'SYSTEM_ENCRYP'
	DB	'TION_DEFER_CONFIRM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MDOAMJOP@SYSTEM_DECRYPTION_DEFER_CONFIRM?$AA@
CONST	SEGMENT
??_C@_0CA@MDOAMJOP@SYSTEM_DECRYPTION_DEFER_CONFIRM?$AA@ DB 'SYSTEM_DECRYP'
	DB	'TION_DEFER_CONFIRM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MEPMKNNG@NONSYS_INPLACE_ENC_DEFER_CONFIRM@
CONST	SEGMENT
??_C@_0CB@MEPMKNNG@NONSYS_INPLACE_ENC_DEFER_CONFIRM@ DB 'NONSYS_INPLACE_E'
	DB	'NC_DEFER_CONFIRM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EAMLJMAO@DECOY_OS_VERSION_WARNING?$AA@
CONST	SEGMENT
??_C@_0BJ@EAMLJMAO@DECOY_OS_VERSION_WARNING?$AA@ DB 'DECOY_OS_VERSION_WAR'
	DB	'NING', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JGIFKPLM@WIPE_FINISHED_DECOY_SYSTEM_PARTI@
CONST	SEGMENT
??_C@_0CF@JGIFKPLM@WIPE_FINISHED_DECOY_SYSTEM_PARTI@ DB 'WIPE_FINISHED_DE'
	DB	'COY_SYSTEM_PARTITION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KCOCCGGE@SYS_DRIVE_SIZE_PROBE_TIMEOUT?$AA@
CONST	SEGMENT
??_C@_0BN@KCOCCGGE@SYS_DRIVE_SIZE_PROBE_TIMEOUT?$AA@ DB 'SYS_DRIVE_SIZE_P'
	DB	'ROBE_TIMEOUT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OEJEFNLJ@ALT_KEY_CHARS_NOT_FOR_SYS_ENCRYP@
CONST	SEGMENT
??_C@_0CF@OEJEFNLJ@ALT_KEY_CHARS_NOT_FOR_SYS_ENCRYP@ DB 'ALT_KEY_CHARS_NO'
	DB	'T_FOR_SYS_ENCRYPTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HGCGAMEK@KEYB_LAYOUT_SYS_ENC_EXPLANATION?$AA@
CONST	SEGMENT
??_C@_0CA@HGCGAMEK@KEYB_LAYOUT_SYS_ENC_EXPLANATION?$AA@ DB 'KEYB_LAYOUT_S'
	DB	'YS_ENC_EXPLANATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MNCKOJDH@KEYB_LAYOUT_CHANGE_PREVENTED?$AA@
CONST	SEGMENT
??_C@_0BN@MNCKOJDH@KEYB_LAYOUT_CHANGE_PREVENTED?$AA@ DB 'KEYB_LAYOUT_CHAN'
	DB	'GE_PREVENTED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ICICKJJH@CONFIRM_RESTART?$AA@
CONST	SEGMENT
??_C@_0BA@ICICKJJH@CONFIRM_RESTART?$AA@ DB 'CONFIRM_RESTART', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HGGGHBLG@SYSTEM_DECRYPTION_FINISHED?$AA@
CONST	SEGMENT
??_C@_0BL@HGGGHBLG@SYSTEM_DECRYPTION_FINISHED?$AA@ DB 'SYSTEM_DECRYPTION_'
	DB	'FINISHED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LJPGNBNM@SYSTEM_ENCRYPTION_FINISHED?$AA@
CONST	SEGMENT
??_C@_0BL@LJPGNBNM@SYSTEM_ENCRYPTION_FINISHED?$AA@ DB 'SYSTEM_ENCRYPTION_'
	DB	'FINISHED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BKMHLPHL@DISCARD_UNREADABLE_ENCRYPTED_SEC@
CONST	SEGMENT
??_C@_0CF@BKMHLPHL@DISCARD_UNREADABLE_ENCRYPTED_SEC@ DB 'DISCARD_UNREADAB'
	DB	'LE_ENCRYPTED_SECTORS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@
CONST	SEGMENT
??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@ DB 'ENABLE_BAD_SECTOR_Z'
	DB	'EROING', 00H				; `string'
CONST	ENDS
;	COMDAT ??_R0?AUSystemException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUSystemException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::SystemException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSystemException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_C@_04JFFKLGJF@?$CF02X?$AA@
CONST	SEGMENT
??_C@_04JFFKLGJF@?$CF02X?$AA@ DB '%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JMGGGIDG@?2GostCrypt?5Rescue?5Disk?4iso?$AA@
CONST	SEGMENT
??_C@_0BL@JMGGGIDG@?2GostCrypt?5Rescue?5Disk?4iso?$AA@ DB '\GostCrypt Res'
	DB	'cue Disk.iso', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@
CONST	SEGMENT
??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@ DB 'GST_INSTALLER_IS_RUN'
	DB	'NING', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EJEDNFIG@CONFIRM_WIPE_ABORT?$AA@
CONST	SEGMENT
??_C@_0BD@EJEDNFIG@CONFIRM_WIPE_ABORT?$AA@ DB 'CONFIRM_WIPE_ABORT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@HCFFCIHD@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0EP@HCFFCIHD@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB ' '
	DB	'                                                             '
	DB	'                ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJAPGPK@WARN_QUICK_FORMAT?$AA@
CONST	SEGMENT
??_C@_0BC@LJAPGPK@WARN_QUICK_FORMAT?$AA@ DB 'WARN_QUICK_FORMAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLHJLKOB@CONFIRM_SPARSE_FILE?$AA@
CONST	SEGMENT
??_C@_0BE@NLHJLKOB@CONFIRM_SPARSE_FILE?$AA@ DB 'CONFIRM_SPARSE_FILE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FCGANOF@ALGO_NOT_SUPPORTED_FOR_SYS_ENCRY@
CONST	SEGMENT
??_C@_0CG@FCGANOF@ALGO_NOT_SUPPORTED_FOR_SYS_ENCRY@ DB 'ALGO_NOT_SUPPORTE'
	DB	'D_FOR_SYS_ENCRYPTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OACPEFAM@Floppy?$AA@
CONST	SEGMENT
??_C@_06OACPEFAM@Floppy?$AA@ DB 'Floppy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GHEOANHD@OPEN_TITLE?$AA@
CONST	SEGMENT
??_C@_0L@GHEOANHD@OPEN_TITLE?$AA@ DB 'OPEN_TITLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PHDAOPJF@KEYFILES_NOT_SUPPORTED_FOR_SYS_E@
CONST	SEGMENT
??_C@_0CK@PHDAOPJF@KEYFILES_NOT_SUPPORTED_FOR_SYS_E@ DB 'KEYFILES_NOT_SUP'
	DB	'PORTED_FOR_SYS_ENCRYPTION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BFLBCKJG@http?3?1?1www?4ietf?4org?1rfc?1rfc5830?4@
CONST	SEGMENT
??_C@_0CE@BFLBCKJG@http?3?1?1www?4ietf?4org?1rfc?1rfc5830?4@ DB 'http://w'
	DB	'ww.ietf.org/rfc/rfc5830.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LNDFLMFM@FORMAT_ABORT?$AA@
CONST	SEGMENT
??_C@_0N@LNDFLMFM@FORMAT_ABORT?$AA@ DB 'FORMAT_ABORT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EDGNFMHB@FILESYS_PAGE_HELP_EXPLANATION_HI@
CONST	SEGMENT
??_C@_0CN@EDGNFMHB@FILESYS_PAGE_HELP_EXPLANATION_HI@ DB 'FILESYS_PAGE_HEL'
	DB	'P_EXPLANATION_HIDVOL_CONFIRM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@
CONST	SEGMENT
??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@ DB 'http://www'
	DB	'.gostcrypt.org/redirect.php?a=2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_15OJKDPEFE@?$AA?5?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_15OJKDPEFE@?$AA?5?$AA?5?$AA?$AA@ DB ' ', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LEEAJJHO@WIPE?$AA@
CONST	SEGMENT
??_C@_04LEEAJJHO@WIPE?$AA@ DB 'WIPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IEGJMJEM@DEVICE_WIPE_PAGE_TITLE?$AA@
CONST	SEGMENT
??_C@_0BH@IEGJMJEM@DEVICE_WIPE_PAGE_TITLE?$AA@ DB 'DEVICE_WIPE_PAGE_TITLE'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OABGGIFL@DEVICE_WIPE_PAGE_INFO?$AA@
CONST	SEGMENT
??_C@_0BG@OABGGIFL@DEVICE_WIPE_PAGE_INFO?$AA@ DB 'DEVICE_WIPE_PAGE_INFO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NHNKCAEG@DEVICE_WIPE_PAGE_INFO_HIDDEN_OS?$AA@
CONST	SEGMENT
??_C@_0CA@NHNKCAEG@DEVICE_WIPE_PAGE_INFO_HIDDEN_OS?$AA@ DB 'DEVICE_WIPE_P'
	DB	'AGE_INFO_HIDDEN_OS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JJNKBKFB@WIPE_MODE_INFO?$AA@
CONST	SEGMENT
??_C@_0P@JJNKBKFB@WIPE_MODE_INFO?$AA@ DB 'WIPE_MODE_INFO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KAEKPGLE@SYSENC_HIDDEN_OS_WIPE_INFO?$AA@
CONST	SEGMENT
??_C@_0BL@KAEKPGLE@SYSENC_HIDDEN_OS_WIPE_INFO?$AA@ DB 'SYSENC_HIDDEN_OS_W'
	DB	'IPE_INFO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MMHOKPDB@SYSENC_HIDDEN_OS_WIPE_INFO_TITLE@
CONST	SEGMENT
??_C@_0CB@MMHOKPDB@SYSENC_HIDDEN_OS_WIPE_INFO_TITLE@ DB 'SYSENC_HIDDEN_OS'
	DB	'_WIPE_INFO_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FHELJNGN@FIRST_HIDDEN_OS_BOOT_INFO?$AA@
CONST	SEGMENT
??_C@_0BK@FHELJNGN@FIRST_HIDDEN_OS_BOOT_INFO?$AA@ DB 'FIRST_HIDDEN_OS_BOO'
	DB	'T_INFO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LLANPMHF@SYSENC_HIDDEN_OS_INITIAL_INFO_TI@
CONST	SEGMENT
??_C@_0CE@LLANPMHF@SYSENC_HIDDEN_OS_INITIAL_INFO_TI@ DB 'SYSENC_HIDDEN_OS'
	DB	'_INITIAL_INFO_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KFFNPDGB@PageDialogProc?35088?$AA@
CONST	SEGMENT
??_C@_0BE@KFFNPDGB@PageDialogProc?35088?$AA@ DB 'PageDialogProc:5088', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HBBDJEK@FORMAT_FINISHED_TITLE?$AA@
CONST	SEGMENT
??_C@_0BG@HBBDJEK@FORMAT_FINISHED_TITLE?$AA@ DB 'FORMAT_FINISHED_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DJMJCNLA@HIDVOL_FORMAT_FINISHED_TITLE?$AA@
CONST	SEGMENT
??_C@_0BN@DJMJCNLA@HIDVOL_FORMAT_FINISHED_TITLE?$AA@ DB 'HIDVOL_FORMAT_FI'
	DB	'NISHED_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GBMPIMLF@FORMAT_FINISHED_HELP?$AA@
CONST	SEGMENT
??_C@_0BF@GBMPIMLF@FORMAT_FINISHED_HELP?$AA@ DB 'FORMAT_FINISHED_HELP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DILBCENC@SYSENC_HIDDEN_VOL_FORMAT_FINISHE@
CONST	SEGMENT
??_C@_0CH@DILBCENC@SYSENC_HIDDEN_VOL_FORMAT_FINISHE@ DB 'SYSENC_HIDDEN_VO'
	DB	'L_FORMAT_FINISHED_HELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GEKKOMHD@HIDVOL_HOST_FILLING_TITLE?$AA@
CONST	SEGMENT
??_C@_0BK@GEKKOMHD@HIDVOL_HOST_FILLING_TITLE?$AA@ DB 'HIDVOL_HOST_FILLING'
	DB	'_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NMHGGMKI@HIDVOL_HOST_FILLING_HELP?$AA@
CONST	SEGMENT
??_C@_0BJ@NMHGGMKI@HIDVOL_HOST_FILLING_HELP?$AA@ DB 'HIDVOL_HOST_FILLING_'
	DB	'HELP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NGPBKLAB@HIDVOL_HOST_FILLING_HELP_SYSENC?$AA@
CONST	SEGMENT
??_C@_0CA@NGPBKLAB@HIDVOL_HOST_FILLING_HELP_SYSENC?$AA@ DB 'HIDVOL_HOST_F'
	DB	'ILLING_HELP_SYSENC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@JJPHEOJD@?$AA?$CF?$AAI?$AA6?$AA4?$AAd?$AA?5?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@JJPHEOJD@?$AA?$CF?$AAI?$AA6?$AA4?$AAd?$AA?5?$AA?$CF?$AAs?$AA?$AA@ DB '%'
	DB	00H, 'I', 00H, '6', 00H, '4', 00H, 'd', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02LKLDBFPJ@MB?$AA@
CONST	SEGMENT
??_C@_02LKLDBFPJ@MB?$AA@ DB 'MB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DPGELLJH@FORMAT?$AA@
CONST	SEGMENT
??_C@_06DPGELLJH@FORMAT?$AA@ DB 'FORMAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JMFMNIFM@?9?9?9?$AA@
CONST	SEGMENT
??_C@_03JMFMNIFM@?9?9?9?$AA@ DB '---', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OKGDLNCL@NONE?$AA@
CONST	SEGMENT
??_C@_04OKGDLNCL@NONE?$AA@ DB 'NONE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MPELFIKF@FAT?$AA@
CONST	SEGMENT
??_C@_03MPELFIKF@FAT?$AA@ DB 'FAT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPPAIJNK@NTFS?$AA@
CONST	SEGMENT
??_C@_04HPPAIJNK@NTFS?$AA@ DB 'NTFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LODOGJEL@KB?$AA@
CONST	SEGMENT
??_C@_02LODOGJEL@KB?$AA@ DB 'KB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_17OFEDBPDO@?$AA0?$AA?4?$AA5?$AA?$AA@
CONST	SEGMENT
??_C@_17OFEDBPDO@?$AA0?$AA?4?$AA5?$AA?$AA@ DB '0', 00H, '.', 00H, '5', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07MGCPDNLD@DEFAULT?$AA@
CONST	SEGMENT
??_C@_07MGCPDNLD@DEFAULT?$AA@ DB 'DEFAULT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@NPBFJCJA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
CONST	SEGMENT
??_C@_0EP@NPBFJCJA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ DB '*'
	DB	'*******************************                              '
	DB	'                ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPMOAIEF@SPARSE_FILE?$AA@
CONST	SEGMENT
??_C@_0M@GPMOAIEF@SPARSE_FILE?$AA@ DB 'SPARSE_FILE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LBGDFDPO@IDC_QUICKFORMAT?$AA@
CONST	SEGMENT
??_C@_0BA@LBGDFDPO@IDC_QUICKFORMAT?$AA@ DB 'IDC_QUICKFORMAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FLIHGDJB@FORMAT_TITLE?$AA@
CONST	SEGMENT
??_C@_0N@FLIHGDJB@FORMAT_TITLE?$AA@ DB 'FORMAT_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CEEOMNDM@FORMAT_HIDVOL_TITLE?$AA@
CONST	SEGMENT
??_C@_0BE@CEEOMNDM@FORMAT_HIDVOL_TITLE?$AA@ DB 'FORMAT_HIDVOL_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LIGEKHGE@FORMAT_HIDVOL_HOST_TITLE?$AA@
CONST	SEGMENT
??_C@_0BJ@LIGEKHGE@FORMAT_HIDVOL_HOST_TITLE?$AA@ DB 'FORMAT_HIDVOL_HOST_T'
	DB	'ITLE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEPPFDAO@FORMAT_HELP?$AA@
CONST	SEGMENT
??_C@_0M@EEPPFDAO@FORMAT_HELP?$AA@ DB 'FORMAT_HELP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MEDALEIG@FORMAT_HIDVOL_HOST_HELP?$AA@
CONST	SEGMENT
??_C@_0BI@MEDALEIG@FORMAT_HIDVOL_HOST_HELP?$AA@ DB 'FORMAT_HIDVOL_HOST_HE'
	DB	'LP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08MFKGCNCO@FINALIZE?$AA@
CONST	SEGMENT
??_C@_08MFKGCNCO@FINALIZE?$AA@ DB 'FINALIZE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LOJCKPNA@NONSYS_INPLACE_ENC_FINISHED_TITL@
CONST	SEGMENT
??_C@_0CC@LOJCKPNA@NONSYS_INPLACE_ENC_FINISHED_TITL@ DB 'NONSYS_INPLACE_E'
	DB	'NC_FINISHED_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MDGBIFPN@NONSYS_INPLACE_ENC_ENCRYPTION_PA@
CONST	SEGMENT
??_C@_0CI@MDGBIFPN@NONSYS_INPLACE_ENC_ENCRYPTION_PA@ DB 'NONSYS_INPLACE_E'
	DB	'NC_ENCRYPTION_PAGE_INFO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KEEMKNMD@NONSYS_INPLACE_ENC_RESUME_VOL_SE@
CONST	SEGMENT
??_C@_0CK@KEEMKNMD@NONSYS_INPLACE_ENC_RESUME_VOL_SE@ DB 'NONSYS_INPLACE_E'
	DB	'NC_RESUME_VOL_SELECT_HELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LFGBLAAC@SYSENC_ENCRYPTION_PAGE_INFO?$AA@
CONST	SEGMENT
??_C@_0BM@LFGBLAAC@SYSENC_ENCRYPTION_PAGE_INFO?$AA@ DB 'SYSENC_ENCRYPTION'
	DB	'_PAGE_INFO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@POBGFBLK@DECRYPTION?$AA@
CONST	SEGMENT
??_C@_0L@POBGFBLK@DECRYPTION?$AA@ DB 'DECRYPTION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MHHIHFIN@ENCRYPTION?$AA@
CONST	SEGMENT
??_C@_0L@MHHIHFIN@ENCRYPTION?$AA@ DB 'ENCRYPTION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BONEGKLO@SYS_ENCRYPTION_PRETEST_RESULT_IN@
CONST	SEGMENT
??_C@_0CD@BONEGKLO@SYS_ENCRYPTION_PRETEST_RESULT_IN@ DB 'SYS_ENCRYPTION_P'
	DB	'RETEST_RESULT_INFO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FEPHBNLJ@SYS_ENCRYPTION_PRETEST_RESULT_TI@
CONST	SEGMENT
??_C@_0CE@FEPHBNLJ@SYS_ENCRYPTION_PRETEST_RESULT_TI@ DB 'SYS_ENCRYPTION_P'
	DB	'RETEST_RESULT_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OIKJMBFP@TEST?$AA@
CONST	SEGMENT
??_C@_04OIKJMBFP@TEST?$AA@ DB 'TEST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OIIAJLEO@SYS_ENCRYPTION_PRETEST_INFO?$AA@
CONST	SEGMENT
??_C@_0BM@OIIAJLEO@SYS_ENCRYPTION_PRETEST_INFO?$AA@ DB 'SYS_ENCRYPTION_PR'
	DB	'ETEST_INFO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OJLMLLFE@SYS_ENCRYPTION_PRETEST_TITLE?$AA@
CONST	SEGMENT
??_C@_0BN@OJLMLLFE@SYS_ENCRYPTION_PRETEST_TITLE?$AA@ DB 'SYS_ENCRYPTION_P'
	DB	'RETEST_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05JLPDBANI@START?$AA@
CONST	SEGMENT
??_C@_05JLPDBANI@START?$AA@ DB 'START', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GFBCACCB@HIDDEN_OS_CREATION_PREINFO_HELP?$AA@
CONST	SEGMENT
??_C@_0CA@GFBCACCB@HIDDEN_OS_CREATION_PREINFO_HELP?$AA@ DB 'HIDDEN_OS_CRE'
	DB	'ATION_PREINFO_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PAHHLDJJ@HIDDEN_OS_CREATION_PREINFO_TITLE@
CONST	SEGMENT
??_C@_0CB@PAHHLDJJ@HIDDEN_OS_CREATION_PREINFO_TITLE@ DB 'HIDDEN_OS_CREATI'
	DB	'ON_PREINFO_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KPLPAAMG@INPLACE_ENC_WIPE_MODE_INFO?$AA@
CONST	SEGMENT
??_C@_0BL@KPLPAAMG@INPLACE_ENC_WIPE_MODE_INFO?$AA@ DB 'INPLACE_ENC_WIPE_M'
	DB	'ODE_INFO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GEMFOMCA@WIPE_MODE_TITLE?$AA@
CONST	SEGMENT
??_C@_0BA@GEMFOMCA@WIPE_MODE_TITLE?$AA@ DB 'WIPE_MODE_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PHEMJDOE@RESCUE_DISK_VERIFIED_INFO?$AA@
CONST	SEGMENT
??_C@_0BK@PHEMJDOE@RESCUE_DISK_VERIFIED_INFO?$AA@ DB 'RESCUE_DISK_VERIFIE'
	DB	'D_INFO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OFKHEBFP@RESCUE_DISK_DISK_VERIFIED_TITLE?$AA@
CONST	SEGMENT
??_C@_0CA@OFKHEBFP@RESCUE_DISK_DISK_VERIFIED_TITLE?$AA@ DB 'RESCUE_DISK_D'
	DB	'ISK_VERIFIED_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CHINNFGJ@LAUNCH_WIN_ISOBURN?$AA@
CONST	SEGMENT
??_C@_0BD@CHINNFGJ@LAUNCH_WIN_ISOBURN?$AA@ DB 'LAUNCH_WIN_ISOBURN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KIJPDAJH@RESCUE_DISK_BURN_INFO?$AA@
CONST	SEGMENT
??_C@_0BG@KIJPDAJH@RESCUE_DISK_BURN_INFO?$AA@ DB 'RESCUE_DISK_BURN_INFO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JAENMDIB@RESCUE_DISK_BURN_INFO_NO_CHECK?$AA@
CONST	SEGMENT
??_C@_0BP@JAENMDIB@RESCUE_DISK_BURN_INFO_NO_CHECK?$AA@ DB 'RESCUE_DISK_BU'
	DB	'RN_INFO_NO_CHECK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IHEJGKND@RESCUE_DISK_BURN_INFO_NONWIN_ISO@
CONST	SEGMENT
??_C@_0CI@IHEJGKND@RESCUE_DISK_BURN_INFO_NONWIN_ISO@ DB 'RESCUE_DISK_BURN'
	DB	'_INFO_NONWIN_ISO_BURNER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GPDOJGLC@RESCUE_DISK_RECORDING_TITLE?$AA@
CONST	SEGMENT
??_C@_0BM@GPDOJGLC@RESCUE_DISK_RECORDING_TITLE?$AA@ DB 'RESCUE_DISK_RECOR'
	DB	'DING_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NAGNMEFO@RESCUE_DISK_CREATED_TITLE?$AA@
CONST	SEGMENT
??_C@_0BK@NAGNMEFO@RESCUE_DISK_CREATED_TITLE?$AA@ DB 'RESCUE_DISK_CREATED'
	DB	'_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KBMALCGN@RESCUE_DISK_INFO?$AA@
CONST	SEGMENT
??_C@_0BB@KBMALCGN@RESCUE_DISK_INFO?$AA@ DB 'RESCUE_DISK_INFO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IGHMLIGA@RESCUE_DISK?$AA@
CONST	SEGMENT
??_C@_0M@IGHMLIGA@RESCUE_DISK?$AA@ DB 'RESCUE_DISK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KEHBBAFI@KEYS_GEN_TITLE?$AA@
CONST	SEGMENT
??_C@_0P@KEHBBAFI@KEYS_GEN_TITLE?$AA@ DB 'KEYS_GEN_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DAHBFIJD@COLLECTING_RANDOM_DATA_TITLE?$AA@
CONST	SEGMENT
??_C@_0BN@DAHBFIJD@COLLECTING_RANDOM_DATA_TITLE?$AA@ DB 'COLLECTING_RANDO'
	DB	'M_DATA_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BDOPEICN@FILESYS_PAGE_HELP_EXPLANATION_HI@
CONST	SEGMENT
??_C@_0CF@BDOPEICN@FILESYS_PAGE_HELP_EXPLANATION_HI@ DB 'FILESYS_PAGE_HEL'
	DB	'P_EXPLANATION_HIDVOL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NPNHCCNA@FILESYS_PAGE_HELP_EXPLANATION?$AA@
CONST	SEGMENT
??_C@_0BO@NPNHCCNA@FILESYS_PAGE_HELP_EXPLANATION?$AA@ DB 'FILESYS_PAGE_HE'
	DB	'LP_EXPLANATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JPAMOBPC@NOTE_BEGINNING?$AA@
CONST	SEGMENT
??_C@_0P@JPAMOBPC@NOTE_BEGINNING?$AA@ DB 'NOTE_BEGINNING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@ DB 0aH, 00H, 0aH, 00H, 0aH, 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IEILEGP@FILESYS_PAGE_HELP_QUESTION?$AA@
CONST	SEGMENT
??_C@_0BL@IEILEGP@FILESYS_PAGE_HELP_QUESTION?$AA@ DB 'FILESYS_PAGE_HELP_Q'
	DB	'UESTION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LCAKBGFA@FILESYS_PAGE_TITLE?$AA@
CONST	SEGMENT
??_C@_0BD@LCAKBGFA@FILESYS_PAGE_TITLE?$AA@ DB 'FILESYS_PAGE_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ONGBFCBF@PASSWORD_TITLE?$AA@
CONST	SEGMENT
??_C@_0P@ONGBFCBF@PASSWORD_TITLE?$AA@ DB 'PASSWORD_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ILMPEOM@PASSWORD_HIDVOL_TITLE?$AA@
CONST	SEGMENT
??_C@_0BG@ILMPEOM@PASSWORD_HIDVOL_TITLE?$AA@ DB 'PASSWORD_HIDVOL_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CPICCPLA@PASSWORD_HIDDEN_OS_TITLE?$AA@
CONST	SEGMENT
??_C@_0BJ@CPICCPLA@PASSWORD_HIDDEN_OS_TITLE?$AA@ DB 'PASSWORD_HIDDEN_OS_T'
	DB	'ITLE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MNFELCPB@PASSWORD_HIDDENVOL_HELP?$AA@
CONST	SEGMENT
??_C@_0BI@MNFELCPB@PASSWORD_HIDDENVOL_HELP?$AA@ DB 'PASSWORD_HIDDENVOL_HE'
	DB	'LP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PAGBOIIN@PASSWORD_HIDDEN_OS_HELP?$AA@
CONST	SEGMENT
??_C@_0BI@PAGBOIIN@PASSWORD_HIDDEN_OS_HELP?$AA@ DB 'PASSWORD_HIDDEN_OS_HE'
	DB	'LP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEODOKDB@PASSWORD_HELP?$AA@
CONST	SEGMENT
??_C@_0O@MEODOKDB@PASSWORD_HELP?$AA@ DB 'PASSWORD_HELP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OJJOHFMM@PASSWORD_HIDDENVOL_HOST_HELP?$AA@
CONST	SEGMENT
??_C@_0BN@OJJOHFMM@PASSWORD_HIDDENVOL_HOST_HELP?$AA@ DB 'PASSWORD_HIDDENV'
	DB	'OL_HOST_HELP', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EJBBHKGE@PASSWORD_SYSENC_OUTERVOL_HELP?$AA@
CONST	SEGMENT
??_C@_0BO@EJBBHKGE@PASSWORD_SYSENC_OUTERVOL_HELP?$AA@ DB 'PASSWORD_SYSENC'
	DB	'_OUTERVOL_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MMDPAFIK@CANNOT_SET_TIMER?$AA@
CONST	SEGMENT
??_C@_0BB@MMDPAFIK@CANNOT_SET_TIMER?$AA@ DB 'CANNOT_SET_TIMER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KAEHBIEI@CANT_CHANGE_KEYB_LAYOUT_FOR_SYS_@
CONST	SEGMENT
??_C@_0CL@KAEHBIEI@CANT_CHANGE_KEYB_LAYOUT_FOR_SYS_@ DB 'CANT_CHANGE_KEYB'
	DB	'_LAYOUT_FOR_SYS_ENCRYPTION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OKJEGFFL@00000409?$AA@
CONST	SEGMENT
??_C@_08OKJEGFFL@00000409?$AA@ DB '00000409', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JIMNDDED@?$CF08X?$AA@
CONST	SEGMENT
??_C@_04JIMNDDED@?$CF08X?$AA@ DB '%08X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DDMDKDAG@PASSWORD_HIDVOL_HOST_TITLE?$AA@
CONST	SEGMENT
??_C@_0BL@DDMDKDAG@PASSWORD_HIDVOL_HOST_TITLE?$AA@ DB 'PASSWORD_HIDVOL_HO'
	DB	'ST_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08KENNMKEI@PASSWORD?$AA@
CONST	SEGMENT
??_C@_08KENNMKEI@PASSWORD?$AA@ DB 'PASSWORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MPBBLHJC@PASSWORD_HIDDENVOL_HOST_DIRECT_H@
CONST	SEGMENT
??_C@_0CE@MPBBLHJC@PASSWORD_HIDDENVOL_HOST_DIRECT_H@ DB 'PASSWORD_HIDDENV'
	DB	'OL_HOST_DIRECT_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CCCDIOBF@NONSYS_INPLACE_ENC_RESUME_PASSWO@
CONST	SEGMENT
??_C@_0CN@CCCDIOBF@NONSYS_INPLACE_ENC_RESUME_PASSWO@ DB 'NONSYS_INPLACE_E'
	DB	'NC_RESUME_PASSWORD_PAGE_HELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DGAKGAKL@SIZE_TITLE?$AA@
CONST	SEGMENT
??_C@_0L@DGAKGAKL@SIZE_TITLE?$AA@ DB 'SIZE_TITLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@COPDBOHD@SIZE_HIDVOL_TITLE?$AA@
CONST	SEGMENT
??_C@_0BC@COPDBOHD@SIZE_HIDVOL_TITLE?$AA@ DB 'SIZE_HIDVOL_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GBEPPLEC@SIZE_HIDVOL_HOST_TITLE?$AA@
CONST	SEGMENT
??_C@_0BH@GBEPPLEC@SIZE_HIDVOL_HOST_TITLE?$AA@ DB 'SIZE_HIDVOL_HOST_TITLE'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05OINFJHGD@?$CFI64u?$AA@
CONST	SEGMENT
??_C@_05OINFJHGD@?$CFI64u?$AA@ DB '%I64u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NFANNNEC@UNKNOWN?$AA@
CONST	SEGMENT
??_C@_07NFANNNEC@UNKNOWN?$AA@ DB 'UNKNOWN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H
	DB	'%', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FGKMPGH@SIZE_PARTITION_HELP?$AA@
CONST	SEGMENT
??_C@_0BE@FGKMPGH@SIZE_PARTITION_HELP?$AA@ DB 'SIZE_PARTITION_HELP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MIIACKDF@SIZE_PARTITION_HIDDEN_SYSENC_HEL@
CONST	SEGMENT
??_C@_0CC@MIIACKDF@SIZE_PARTITION_HIDDEN_SYSENC_HEL@ DB 'SIZE_PARTITION_H'
	DB	'IDDEN_SYSENC_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JPPBFIHO@SIZE_PARTITION_HIDDEN_VOL_HELP?$AA@
CONST	SEGMENT
??_C@_0BP@JPPBFIHO@SIZE_PARTITION_HIDDEN_VOL_HELP?$AA@ DB 'SIZE_PARTITION'
	DB	'_HIDDEN_VOL_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BEBIICBL@SIZE_HELP?$AA@
CONST	SEGMENT
??_C@_09BEBIICBL@SIZE_HELP?$AA@ DB 'SIZE_HELP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LOOCDJPI@SIZE_HELP_HIDDEN_VOL?$AA@
CONST	SEGMENT
??_C@_0BF@LOOCDJPI@SIZE_HELP_HIDDEN_VOL?$AA@ DB 'SIZE_HELP_HIDDEN_VOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DEODNGPK@SIZE_HELP_HIDDEN_HOST_VOL?$AA@
CONST	SEGMENT
??_C@_0BK@DEODNGPK@SIZE_HELP_HIDDEN_HOST_VOL?$AA@ DB 'SIZE_HELP_HIDDEN_HO'
	DB	'ST_VOL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IMFDFPGM@CIPHER_TITLE?$AA@
CONST	SEGMENT
??_C@_0N@IMFDFPGM@CIPHER_TITLE?$AA@ DB 'CIPHER_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JFKJAJEK@CIPHER_HIDVOL_TITLE?$AA@
CONST	SEGMENT
??_C@_0BE@JFKJAJEK@CIPHER_HIDVOL_TITLE?$AA@ DB 'CIPHER_HIDVOL_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GGKKJCIG@CIPHER_HIDVOL_HOST_TITLE?$AA@
CONST	SEGMENT
??_C@_0BJ@GGKKJCIG@CIPHER_HIDVOL_HOST_TITLE?$AA@ DB 'CIPHER_HIDVOL_HOST_T'
	DB	'ITLE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GDOHBMLG@HIDVOL_PRE_CIPHER_HELP?$AA@
CONST	SEGMENT
??_C@_0BH@GDOHBMLG@HIDVOL_PRE_CIPHER_HELP?$AA@ DB 'HIDVOL_PRE_CIPHER_HELP'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FGHOHKMP@HIDDEN_OS_PRE_CIPHER_HELP?$AA@
CONST	SEGMENT
??_C@_0BK@FGHOHKMP@HIDDEN_OS_PRE_CIPHER_HELP?$AA@ DB 'HIDDEN_OS_PRE_CIPHE'
	DB	'R_HELP', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOLNGIJ@EXIT?$AA@
CONST	SEGMENT
??_C@_04GOLNGIJ@EXIT?$AA@ DB 'EXIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OIPNIHCG@HIDDEN_VOLUME_TOO_SMALL_FOR_OS_C@
CONST	SEGMENT
??_C@_0CF@OIPNIHCG@HIDDEN_VOLUME_TOO_SMALL_FOR_OS_C@ DB 'HIDDEN_VOLUME_TO'
	DB	'O_SMALL_FOR_OS_CLONE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JOBKEAGA@HIDVOL_PRE_CIPHER_TITLE?$AA@
CONST	SEGMENT
??_C@_0BI@JOBKEAGA@HIDVOL_PRE_CIPHER_TITLE?$AA@ DB 'HIDVOL_PRE_CIPHER_TIT'
	DB	'LE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PJPEEMEG@INVALID_PATH?$AA@
CONST	SEGMENT
??_C@_0N@PJPEEMEG@INVALID_PATH?$AA@ DB 'INVALID_PATH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GCHOHFOK@HIDVOL_HOST_PRE_CIPHER_HELP?$AA@
CONST	SEGMENT
??_C@_0BM@GCHOHFOK@HIDVOL_HOST_PRE_CIPHER_HELP?$AA@ DB 'HIDVOL_HOST_PRE_C'
	DB	'IPHER_HELP', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OMGBOOGK@HIDVOL_HOST_PRE_CIPHER_HELP_SYSE@
CONST	SEGMENT
??_C@_0CD@OMGBOOGK@HIDVOL_HOST_PRE_CIPHER_HELP_SYSE@ DB 'HIDVOL_HOST_PRE_'
	DB	'CIPHER_HELP_SYSENC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PMMGMENG@HIDVOL_HOST_PRE_CIPHER_TITLE?$AA@
CONST	SEGMENT
??_C@_0BN@PMMGMENG@HIDVOL_HOST_PRE_CIPHER_TITLE?$AA@ DB 'HIDVOL_HOST_PRE_'
	DB	'CIPHER_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FGJIGFAK@DEVICE_TRANSFORM_MODE_PAGE_INPLA@
CONST	SEGMENT
??_C@_0CI@FGJIGFAK@DEVICE_TRANSFORM_MODE_PAGE_INPLA@ DB 'DEVICE_TRANSFORM'
	DB	'_MODE_PAGE_INPLACE_HELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CJGGIKCO@DEVICE_TRANSFORM_MODE_PAGE_FORMA@
CONST	SEGMENT
??_C@_0CH@CJGGIKCO@DEVICE_TRANSFORM_MODE_PAGE_FORMA@ DB 'DEVICE_TRANSFORM'
	DB	'_MODE_PAGE_FORMAT_HELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IJHCDAO@DEVICE_TRANSFORM_MODE_PAGE_TITLE@
CONST	SEGMENT
??_C@_0CB@IJHCDAO@DEVICE_TRANSFORM_MODE_PAGE_TITLE@ DB 'DEVICE_TRANSFORM_'
	DB	'MODE_PAGE_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DGHBDDNJ@FILE_TITLE?$AA@
CONST	SEGMENT
??_C@_0L@DGHBDDNJ@FILE_TITLE?$AA@ DB 'FILE_TITLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPELPABL@FILE_HELP?$AA@
CONST	SEGMENT
??_C@_09GPELPABL@FILE_HELP?$AA@ DB 'FILE_HELP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JMGOJAKG@FILE_HELP_HIDDEN_HOST_VOL?$AA@
CONST	SEGMENT
??_C@_0BK@JMGOJAKG@FILE_HELP_HIDDEN_HOST_VOL?$AA@ DB 'FILE_HELP_HIDDEN_HO'
	DB	'ST_VOL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JNOAPEGE@DEVICE_HELP?$AA@
CONST	SEGMENT
??_C@_0M@JNOAPEGE@DEVICE_HELP?$AA@ DB 'DEVICE_HELP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DMHDGBOJ@DEVICE_HELP_HIDDEN_HOST_VOL?$AA@
CONST	SEGMENT
??_C@_0BM@DMHDGBOJ@DEVICE_HELP_HIDDEN_HOST_VOL?$AA@ DB 'DEVICE_HELP_HIDDE'
	DB	'N_HOST_VOL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LOIOBDOO@FILE_HELP_HIDDEN_HOST_VOL_DIRECT@
CONST	SEGMENT
??_C@_0CB@LOIOBDOO@FILE_HELP_HIDDEN_HOST_VOL_DIRECT@ DB 'FILE_HELP_HIDDEN'
	DB	'_HOST_VOL_DIRECT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HOMDJPL@IDC_SELECT_FILE?$AA@
CONST	SEGMENT
??_C@_0BA@HOMDJPL@IDC_SELECT_FILE?$AA@ DB 'IDC_SELECT_FILE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHEENOIC@IDC_SELECT_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BC@NHEENOIC@IDC_SELECT_DEVICE?$AA@ DB 'IDC_SELECT_DEVICE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BGGCLDPJ@HIDDEN_VOL_WIZARD_MODE_DIRECT_HE@
CONST	SEGMENT
??_C@_0CD@BGGCLDPJ@HIDDEN_VOL_WIZARD_MODE_DIRECT_HE@ DB 'HIDDEN_VOL_WIZAR'
	DB	'D_MODE_DIRECT_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LJCMOGBH@HIDDEN_VOL_WIZARD_MODE_NORMAL_HE@
CONST	SEGMENT
??_C@_0CD@LJCMOGBH@HIDDEN_VOL_WIZARD_MODE_NORMAL_HE@ DB 'HIDDEN_VOL_WIZAR'
	DB	'D_MODE_NORMAL_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CFKNBCJG@HIDDEN_VOL_WIZARD_MODE_TITLE?$AA@
CONST	SEGMENT
??_C@_0BN@CFKNBCJG@HIDDEN_VOL_WIZARD_MODE_TITLE?$AA@ DB 'HIDDEN_VOL_WIZAR'
	DB	'D_MODE_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OKEJAKDK@NORMAL_VOLUME_TYPE_HELP?$AA@
CONST	SEGMENT
??_C@_0BI@OKEJAKDK@NORMAL_VOLUME_TYPE_HELP?$AA@ DB 'NORMAL_VOLUME_TYPE_HE'
	DB	'LP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OMMJFNJB@HIDDEN_VOLUME_TYPE_HELP?$AA@
CONST	SEGMENT
??_C@_0BI@OMMJFNJB@HIDDEN_VOLUME_TYPE_HELP?$AA@ DB 'HIDDEN_VOLUME_TYPE_HE'
	DB	'LP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IMPHNJMH@VOLUME_TYPE_TITLE?$AA@
CONST	SEGMENT
??_C@_0BC@IMPHNJMH@VOLUME_TYPE_TITLE?$AA@ DB 'VOLUME_TYPE_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FOODICMO@SYSENC_MULTI_BOOT_OUTCOME_TITLE?$AA@
CONST	SEGMENT
??_C@_0CA@FOODICMO@SYSENC_MULTI_BOOT_OUTCOME_TITLE?$AA@ DB 'SYSENC_MULTI_'
	DB	'BOOT_OUTCOME_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NGBECAKP@SYSENC_MULTI_BOOT_NONWIN_BOOT_LO@
CONST	SEGMENT
??_C@_0CK@NGBECAKP@SYSENC_MULTI_BOOT_NONWIN_BOOT_LO@ DB 'SYSENC_MULTI_BOO'
	DB	'T_NONWIN_BOOT_LOADER_HELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PKMEBLJM@SYSENC_MULTI_BOOT_NONWIN_BOOT_LO@
CONST	SEGMENT
??_C@_0CL@PKMEBLJM@SYSENC_MULTI_BOOT_NONWIN_BOOT_LO@ DB 'SYSENC_MULTI_BOO'
	DB	'T_NONWIN_BOOT_LOADER_TITLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CGLNKLHK@SYSENC_MULTI_BOOT_ADJACENT_SYS_H@
CONST	SEGMENT
??_C@_0CE@CGLNKLHK@SYSENC_MULTI_BOOT_ADJACENT_SYS_H@ DB 'SYSENC_MULTI_BOO'
	DB	'T_ADJACENT_SYS_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MINJEEM@SYSENC_MULTI_BOOT_ADJACENT_SYS_T@
CONST	SEGMENT
??_C@_0CF@MINJEEM@SYSENC_MULTI_BOOT_ADJACENT_SYS_T@ DB 'SYSENC_MULTI_BOOT'
	DB	'_ADJACENT_SYS_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GBIPGAOP@SYSENC_MULTI_BOOT_NBR_SYS_DRIVES@
CONST	SEGMENT
??_C@_0CG@GBIPGAOP@SYSENC_MULTI_BOOT_NBR_SYS_DRIVES@ DB 'SYSENC_MULTI_BOO'
	DB	'T_NBR_SYS_DRIVES_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IMKPMBEM@SYSENC_MULTI_BOOT_NBR_SYS_DRIVES@
CONST	SEGMENT
??_C@_0CH@IMKPMBEM@SYSENC_MULTI_BOOT_NBR_SYS_DRIVES@ DB 'SYSENC_MULTI_BOO'
	DB	'T_NBR_SYS_DRIVES_TITLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BAIFEFDO@TWO_OR_MORE?$AA@
CONST	SEGMENT
??_C@_0M@BAIFEFDO@TWO_OR_MORE?$AA@ DB 'TWO_OR_MORE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BCPPDPEL@DIGIT_ONE?$AA@
CONST	SEGMENT
??_C@_09BCPPDPEL@DIGIT_ONE?$AA@ DB 'DIGIT_ONE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ODHMCLM@SYSENC_MULTI_BOOT_SYS_EQ_BOOT_HE@
CONST	SEGMENT
??_C@_0CD@ODHMCLM@SYSENC_MULTI_BOOT_SYS_EQ_BOOT_HE@ DB 'SYSENC_MULTI_BOOT'
	DB	'_SYS_EQ_BOOT_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HOKCHJKA@SYSENC_MULTI_BOOT_SYS_EQ_BOOT_TI@
CONST	SEGMENT
??_C@_0CE@HOKCHJKA@SYSENC_MULTI_BOOT_SYS_EQ_BOOT_TI@ DB 'SYSENC_MULTI_BOO'
	DB	'T_SYS_EQ_BOOT_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NAIABFPC@SYS_MULTI_BOOT_MODE_TITLE?$AA@
CONST	SEGMENT
??_C@_0BK@NAIABFPC@SYS_MULTI_BOOT_MODE_TITLE?$AA@ DB 'SYS_MULTI_BOOT_MODE'
	DB	'_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08HBBNJJLH@IDC_EXIT?$AA@
CONST	SEGMENT
??_C@_08HBBNJJLH@IDC_EXIT?$AA@ DB 'IDC_EXIT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OEFOGNPK@RETRY_HIDDEN_SECTOR_DETECTION?$AA@
CONST	SEGMENT
??_C@_0BO@OEFOGNPK@RETRY_HIDDEN_SECTOR_DETECTION?$AA@ DB 'RETRY_HIDDEN_SE'
	DB	'CTOR_DETECTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GHOENGPC@SKIP_HIDDEN_SECTOR_DETECTION?$AA@
CONST	SEGMENT
??_C@_0BN@GHOENGPC@SKIP_HIDDEN_SECTOR_DETECTION?$AA@ DB 'SKIP_HIDDEN_SECT'
	DB	'OR_DETECTION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KEHMFNIA@HIDDEN_SECTOR_DETECTION_FAILED_P@
CONST	SEGMENT
??_C@_0CK@KEHMFNIA@HIDDEN_SECTOR_DETECTION_FAILED_P@ DB 'HIDDEN_SECTOR_DE'
	DB	'TECTION_FAILED_PREVIOUSLY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OAMDPDOH@SYSENC_DRIVE_ANALYSIS_INFO?$AA@
CONST	SEGMENT
??_C@_0BL@OAMDPDOH@SYSENC_DRIVE_ANALYSIS_INFO?$AA@ DB 'SYSENC_DRIVE_ANALY'
	DB	'SIS_INFO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EGLOODHA@SYSENC_DRIVE_ANALYSIS_TITLE?$AA@
CONST	SEGMENT
??_C@_0BM@EGLOODHA@SYSENC_DRIVE_ANALYSIS_TITLE?$AA@ DB 'SYSENC_DRIVE_ANAL'
	DB	'YSIS_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FCJHFGGJ@SYSENC_PRE_DRIVE_ANALYSIS_HELP?$AA@
CONST	SEGMENT
??_C@_0BP@FCJHFGGJ@SYSENC_PRE_DRIVE_ANALYSIS_HELP?$AA@ DB 'SYSENC_PRE_DRI'
	DB	'VE_ANALYSIS_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IIEHPPGP@SYSENC_PRE_DRIVE_ANALYSIS_TITLE?$AA@
CONST	SEGMENT
??_C@_0CA@IIEHPPGP@SYSENC_PRE_DRIVE_ANALYSIS_TITLE?$AA@ DB 'SYSENC_PRE_DR'
	DB	'IVE_ANALYSIS_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CMOPFEFD@SYS_ENCRYPTION_SPAN_WHOLE_SYS_DR@
CONST	SEGMENT
??_C@_0CJ@CMOPFEFD@SYS_ENCRYPTION_SPAN_WHOLE_SYS_DR@ DB 'SYS_ENCRYPTION_S'
	DB	'PAN_WHOLE_SYS_DRIVE_HELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FBGFJBLB@SYS_ENCRYPTION_SPAN_TITLE?$AA@
CONST	SEGMENT
??_C@_0BK@FBGFJBLB@SYS_ENCRYPTION_SPAN_TITLE?$AA@ DB 'SYS_ENCRYPTION_SPAN'
	DB	'_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GBPOCIAL@SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_@
CONST	SEGMENT
??_C@_0CF@GBPOCIAL@SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_@ DB 'SYSENC_HIDDEN_OS'
	DB	'_REQ_CHECK_PAGE_HELP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CLMIJGGF@SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_@
CONST	SEGMENT
??_C@_0CG@CLMIJGGF@SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_@ DB 'SYSENC_HIDDEN_OS'
	DB	'_REQ_CHECK_PAGE_TITLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EEMGDNEH@SYSENC_NORMAL_TYPE_HELP?$AA@
CONST	SEGMENT
??_C@_0BI@EEMGDNEH@SYSENC_NORMAL_TYPE_HELP?$AA@ DB 'SYSENC_NORMAL_TYPE_HE'
	DB	'LP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FECPKDFP@SYSENC_HIDDEN_TYPE_HELP?$AA@
CONST	SEGMENT
??_C@_0BI@FECPKDFP@SYSENC_HIDDEN_TYPE_HELP?$AA@ DB 'SYSENC_HIDDEN_TYPE_HE'
	DB	'LP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LFFPJFCG@SYSENC_TYPE_PAGE_TITLE?$AA@
CONST	SEGMENT
??_C@_0BH@LFFPJFCG@SYSENC_TYPE_PAGE_TITLE?$AA@ DB 'SYSENC_TYPE_PAGE_TITLE'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BGLIKHAN@INTRO_TITLE?$AA@
CONST	SEGMENT
??_C@_0M@BGLIKHAN@INTRO_TITLE?$AA@ DB 'INTRO_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDKFBPLE@FORMAT_PAGE_?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@IDKFBPLE@FORMAT_PAGE_?$CFd?$AA@ DB 'FORMAT_PAGE_%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IHMEHMBJ@IDD_VOL_CREATION_WIZARD_DLG?$AA@
CONST	SEGMENT
??_C@_0BM@IHMEHMBJ@IDD_VOL_CREATION_WIZARD_DLG?$AA@ DB 'IDD_VOL_CREATION_'
	DB	'WIZARD_DLG', 00H				; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
	DD	058H
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD FLAT:??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ
	DD	FLAT:?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
	DD	FLAT:?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
	DD	FLAT:?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
	DD	FLAT:?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	010H
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	020H
CONST	ENDS
;	COMDAT ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@ DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@ DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@6B@ DD FLAT:??_R4?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`vftable'
	DD	FLAT:??_E?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:?IsNotEnd@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
	DD	FLAT:?Next@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
CONST	ENDS
;	COMDAT ??_C@_0BP@DGIMBADH@AFTER_FORMAT_DRIVE_LETTER_WARN?$AA@
CONST	SEGMENT
??_C@_0BP@DGIMBADH@AFTER_FORMAT_DRIVE_LETTER_WARN?$AA@ DB 'AFTER_FORMAT_D'
	DB	'RIVE_LETTER_WARN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BFNCKGCL@PATH_ITEM?$AA@
CONST	SEGMENT
??_C@_09BFNCKGCL@PATH_ITEM?$AA@ DB 'PATH_ITEM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DBGAMMMC@SIZE_ITEM?$AA@
CONST	SEGMENT
??_C@_09DBGAMMMC@SIZE_ITEM?$AA@ DB 'SIZE_ITEM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KEHLKHJA@NOT_APPLICABLE_OR_NOT_AVAILABLE?$AA@
CONST	SEGMENT
??_C@_0CA@KEHLKHJA@NOT_APPLICABLE_OR_NOT_AVAILABLE?$AA@ DB 'NOT_APPLICABL'
	DB	'E_OR_NOT_AVAILABLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PEDCDHCM@LABEL_ITEM?$AA@
CONST	SEGMENT
??_C@_0L@PEDCDHCM@LABEL_ITEM?$AA@ DB 'LABEL_ITEM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@ DB 0aH, 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19KHPJIBCC@?$AA?$CF?$AAh?$AAc?$AA?3?$AA?$AA@
CONST	SEGMENT
??_C@_19KHPJIBCC@?$AA?$CF?$AAh?$AAc?$AA?3?$AA?$AA@ DB '%', 00H, 'h', 00H, 'c'
	DB	00H, ':', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ELOGDKJ@DRIVE_LETTER_ITEM?$AA@
CONST	SEGMENT
??_C@_0BC@ELOGDKJ@DRIVE_LETTER_ITEM?$AA@ DB 'DRIVE_LETTER_ITEM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IMKLJEFC@ERASE_FILES_BY_CREATING_VOLUME?$AA@
CONST	SEGMENT
??_C@_0BP@IMKLJEFC@ERASE_FILES_BY_CREATING_VOLUME?$AA@ DB 'ERASE_FILES_BY'
	DB	'_CREATING_VOLUME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GFFEJLFD@OVERWRITEPROMPT_DEVICE_SECOND_WA@
CONST	SEGMENT
??_C@_0DD@GFFEJLFD@OVERWRITEPROMPT_DEVICE_SECOND_WA@ DB 'OVERWRITEPROMPT_'
	DB	'DEVICE_SECOND_WARNING_LOTS_OF_DATA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JPJDALOG@OVERWRITEPROMPT_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BH@JPJDALOG@OVERWRITEPROMPT_DEVICE?$AA@ DB 'OVERWRITEPROMPT_DEVICE'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IMNAFHOP@NONSYS_INPLACE_ENC_CONFIRM?$AA@
CONST	SEGMENT
??_C@_0BL@IMNAFHOP@NONSYS_INPLACE_ENC_CONFIRM?$AA@ DB 'NONSYS_INPLACE_ENC'
	DB	'_CONFIRM', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KCMNHFDO@OVERWRITEPROMPT_DEVICE_HIDDEN_OS@
CONST	SEGMENT
??_C@_0CL@KCMNHFDO@OVERWRITEPROMPT_DEVICE_HIDDEN_OS@ DB 'OVERWRITEPROMPT_'
	DB	'DEVICE_HIDDEN_OS_PARTITION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@LDCEEKNB@?$AA?5?$AA?$CI?$AA?$CF?$AAh?$AAc?$AA?3?$AA?$CF?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@LDCEEKNB@?$AA?5?$AA?$CI?$AA?$CF?$AAh?$AAc?$AA?3?$AA?$CF?$AAs?$AA?$CJ?$AA?$AA@ DB ' '
	DB	00H, '(', 00H, '%', 00H, 'h', 00H, 'c', 00H, ':', 00H, '%', 00H
	DB	's', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@GHMHFLJL@?$AA?5?$AA?$CI?$AA?$CF?$AAh?$AAc?$AA?3?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@GHMHFLJL@?$AA?5?$AA?$CI?$AA?$CF?$AAh?$AAc?$AA?3?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?$CJ?$AA?$AA@ DB ' '
	DB	00H, '(', 00H, '%', 00H, 'h', 00H, 'c', 00H, ':', 00H, ' ', 00H
	DB	'''', 00H, '%', 00H, 's', 00H, '''', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MKGMJGFE@EXT_PARTITION?$AA@
CONST	SEGMENT
??_C@_0O@MKGMJGFE@EXT_PARTITION?$AA@ DB 'EXT_PARTITION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
CONST	SEGMENT
??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@ DB 'SECTOR_SIZE_UNSUPPORT'
	DB	'ED', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FNOFFGJI@CANT_GET_VOLSIZE?$AA@
CONST	SEGMENT
??_C@_0BB@FNOFFGJI@CANT_GET_VOLSIZE?$AA@ DB 'CANT_GET_VOLSIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@
CONST	SEGMENT
??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@ DB 'CANT_ACCESS_VOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KGONCMNM@?$AA?$CF?$AAs?$AA?6?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KGONCMNM@?$AA?$CF?$AAs?$AA?6?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's'
	DB	00H, 0aH, 00H, '%', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LBACDGOD@CANNOT_CALC_SPACE?$AA@
CONST	SEGMENT
??_C@_0BC@LBACDGOD@CANNOT_CALC_SPACE?$AA@ DB 'CANNOT_CALC_SPACE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LKFCNANA@DISK_FREE_GB?$AA@
CONST	SEGMENT
??_C@_0N@LKFCNANA@DISK_FREE_GB?$AA@ DB 'DISK_FREE_GB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDAMPFNO@DEVICE_FREE_GB?$AA@
CONST	SEGMENT
??_C@_0P@IDAMPFNO@DEVICE_FREE_GB?$AA@ DB 'DEVICE_FREE_GB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NLEFDOGE@MAX_HIDVOL_SIZE_GB?$AA@
CONST	SEGMENT
??_C@_0BD@NLEFDOGE@MAX_HIDVOL_SIZE_GB?$AA@ DB 'MAX_HIDVOL_SIZE_GB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LHMFFFAG@DISK_FREE_MB?$AA@
CONST	SEGMENT
??_C@_0N@LHMFFFAG@DISK_FREE_MB?$AA@ DB 'DISK_FREE_MB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IOJLHAAI@DEVICE_FREE_MB?$AA@
CONST	SEGMENT
??_C@_0P@IOJLHAAI@DEVICE_FREE_MB?$AA@ DB 'DEVICE_FREE_MB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NGNCLLLC@MAX_HIDVOL_SIZE_MB?$AA@
CONST	SEGMENT
??_C@_0BD@NGNCLLLC@MAX_HIDVOL_SIZE_MB?$AA@ DB 'MAX_HIDVOL_SIZE_MB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LDEICJLE@DISK_FREE_KB?$AA@
CONST	SEGMENT
??_C@_0N@LDEICJLE@DISK_FREE_KB?$AA@ DB 'DISK_FREE_KB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IKBGAMLK@DEVICE_FREE_KB?$AA@
CONST	SEGMENT
??_C@_0P@IKBGAMLK@DEVICE_FREE_KB?$AA@ DB 'DEVICE_FREE_KB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NCFPMHAA@MAX_HIDVOL_SIZE_KB?$AA@
CONST	SEGMENT
??_C@_0BD@NCFPMHAA@MAX_HIDVOL_SIZE_KB?$AA@ DB 'MAX_HIDVOL_SIZE_KB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNIBCOCE@DISK_FREE_BYTES?$AA@
CONST	SEGMENT
??_C@_0BA@GNIBCOCE@DISK_FREE_BYTES?$AA@ DB 'DISK_FREE_BYTES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DDPKPAD@DEVICE_FREE_BYTES?$AA@
CONST	SEGMENT
??_C@_0BC@DDPKPAD@DEVICE_FREE_BYTES?$AA@ DB 'DEVICE_FREE_BYTES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OMPICDCM@MAX_HIDVOL_SIZE_BYTES?$AA@
CONST	SEGMENT
??_C@_0BG@OMPICDCM@MAX_HIDVOL_SIZE_BYTES?$AA@ DB 'MAX_HIDVOL_SIZE_BYTES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GMGGDPEP@HIDDEN_OS_PRE_CIPHER_WARNING?$AA@
CONST	SEGMENT
??_C@_0BN@GMGGDPEP@HIDDEN_OS_PRE_CIPHER_WARNING?$AA@ DB 'HIDDEN_OS_PRE_CI'
	DB	'PHER_WARNING', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DFBMOJJF@PASSWORD_HIDDEN_OS_NOTE?$AA@
CONST	SEGMENT
??_C@_0BI@DFBMOJJF@PASSWORD_HIDDEN_OS_NOTE?$AA@ DB 'PASSWORD_HIDDEN_OS_NO'
	DB	'TE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NLOHJLIM@FORMAT_CANCELED?$AA@
CONST	SEGMENT
??_C@_0BA@NLOHJLIM@FORMAT_CANCELED?$AA@ DB 'FORMAT_CANCELED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JKEOLKCL@NONSYS_INPLACE_ENC_CANCELED?$AA@
CONST	SEGMENT
??_C@_0BM@JKEOLKCL@NONSYS_INPLACE_ENC_CANCELED?$AA@ DB 'NONSYS_INPLACE_EN'
	DB	'C_CANCELED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDMMBDGF@FORMAT_FINISHED?$AA@
CONST	SEGMENT
??_C@_0BA@IDMMBDGF@FORMAT_FINISHED?$AA@ DB 'FORMAT_FINISHED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PHMPDKJN@SPARSE_FILE_SIZE_NOTE?$AA@
CONST	SEGMENT
??_C@_0BG@PHMPDKJN@SPARSE_FILE_SIZE_NOTE?$AA@ DB 'SPARSE_FILE_SIZE_NOTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ELGDKJEM@FORMAT_FINISHED_INFO?$AA@
CONST	SEGMENT
??_C@_0BF@ELGDKJEM@FORMAT_FINISHED_INFO?$AA@ DB 'FORMAT_FINISHED_INFO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KOCBDKDK@NONSYS_INPLACE_ENC_FINISHED_INFO@
CONST	SEGMENT
??_C@_0CB@KOCBDKDK@NONSYS_INPLACE_ENC_FINISHED_INFO@ DB 'NONSYS_INPLACE_E'
	DB	'NC_FINISHED_INFO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NHKMKNFC@HIDVOL_FORMAT_FINISHED_HELP?$AA@
CONST	SEGMENT
??_C@_0BM@NHKMKNFC@HIDVOL_FORMAT_FINISHED_HELP?$AA@ DB 'HIDVOL_FORMAT_FIN'
	DB	'ISHED_HELP', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OIAKNAOK@CREATE_FAILED?$AA@
CONST	SEGMENT
??_C@_0O@OIAKNAOK@CREATE_FAILED?$AA@ DB 'CREATE_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GOJAHDJH@INPLACE_ENC_GENERIC_ERR_ALT_STEP@
CONST	SEGMENT
??_C@_0CC@GOJAHDJH@INPLACE_ENC_GENERIC_ERR_ALT_STEP@ DB 'INPLACE_ENC_GENE'
	DB	'RIC_ERR_ALT_STEPS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CBCIBGL@INPLACE_ENC_GENERIC_ERR_RESUME?$AA@
CONST	SEGMENT
??_C@_0BP@CBCIBGL@INPLACE_ENC_GENERIC_ERR_RESUME?$AA@ DB 'INPLACE_ENC_GEN'
	DB	'ERIC_ERR_RESUME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAAEIAJ@CANT_MOUNT_OUTER_VOL?$AA@
CONST	SEGMENT
??_C@_0BF@IAAAEIAJ@CANT_MOUNT_OUTER_VOL?$AA@ DB 'CANT_MOUNT_OUTER_VOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DNIPKEFC@NO_FREE_DRIVE_FOR_OUTER_VOL?$AA@
CONST	SEGMENT
??_C@_0BM@DNIPKEFC@NO_FREE_DRIVE_FOR_OUTER_VOL?$AA@ DB 'NO_FREE_DRIVE_FOR'
	DB	'_OUTER_VOL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@
CONST	SEGMENT
??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@ DB 'OUTOFMEMORY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JKCBOPBP@ACCESSMODEFAIL?$AA@
CONST	SEGMENT
??_C@_0P@JKCBOPBP@ACCESSMODEFAIL?$AA@ DB 'ACCESSMODEFAIL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JEAHJACA@OVERWRITEPROMPT?$AA@
CONST	SEGMENT
??_C@_0BA@JEAHJACA@OVERWRITEPROMPT?$AA@ DB 'OVERWRITEPROMPT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMHOIPJB@READONLYPROMPT?$AA@
CONST	SEGMENT
??_C@_0P@EMHOIPJB@READONLYPROMPT?$AA@ DB 'READONLYPROMPT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MHDAJDPI@ADMIN_PRIVILEGES_WARN_NTFS?$AA@
CONST	SEGMENT
??_C@_0BL@MHDAJDPI@ADMIN_PRIVILEGES_WARN_NTFS?$AA@ DB 'ADMIN_PRIVILEGES_W'
	DB	'ARN_NTFS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@
CONST	SEGMENT
??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@ DB 'ERR_MEM_ALLOC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0?AUTimeOut@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUTimeOut@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::TimeOut `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUTimeOut@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BH@PKDMJBLN@FAILED_TO_START_WIPING?$AA@
CONST	SEGMENT
??_C@_0BH@PKDMJBLN@FAILED_TO_START_WIPING?$AA@ DB 'FAILED_TO_START_WIPING'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PHPLOOOK@FAILED_TO_INTERRUPT_WIPING?$AA@
CONST	SEGMENT
??_C@_0BL@PHPLOOOK@FAILED_TO_INTERRUPT_WIPING?$AA@ DB 'FAILED_TO_INTERRUP'
	DB	'T_WIPING', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JMBFHJFE@TRIPLE_DOT_GLYPH_ELLIPSIS?$AA@
CONST	SEGMENT
??_C@_0BK@JMBFHJFE@TRIPLE_DOT_GLYPH_ELLIPSIS?$AA@ DB 'TRIPLE_DOT_GLYPH_EL'
	DB	'LIPSIS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@BPJIPIJP@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK@
CONST	SEGMENT
??_C@_1JO@BPJIPIJP@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK@ DB '*'
	DB	00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H
	DB	'*', 00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H, '*'
	DB	00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H
	DB	'*', 00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H, '*'
	DB	00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H, '*', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFHEBJNP@?$CF02X?5?$AA@
CONST	SEGMENT
??_C@_05BFHEBJNP@?$CF02X?5?$AA@ DB '%02X ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJNOMAJF@?5?4?5?$AA@
CONST	SEGMENT
??_C@_03NJNOMAJF@?5?4?5?$AA@ DB ' . ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LAOFCJDB@?5?$CFc?5?$AA@
CONST	SEGMENT
??_C@_04LAOFCJDB@?5?$CFc?5?$AA@ DB ' %c ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KEELGAD@DEFER?$AA@
CONST	SEGMENT
??_C@_05KEELGAD@DEFER?$AA@ DB 'DEFER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IDPLALHN@PROGRESS_STATUS_ERROR?$AA@
CONST	SEGMENT
??_C@_0BG@IDPLALHN@PROGRESS_STATUS_ERROR?$AA@ DB 'PROGRESS_STATUS_ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CIJLEOGN@PROGRESS_STATUS_FINALIZING?$AA@
CONST	SEGMENT
??_C@_0BL@CIJLEOGN@PROGRESS_STATUS_FINALIZING?$AA@ DB 'PROGRESS_STATUS_FI'
	DB	'NALIZING', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EIBDNDIC@PROGRESS_STATUS_RESIZING?$AA@
CONST	SEGMENT
??_C@_0BJ@EIBDNDIC@PROGRESS_STATUS_RESIZING?$AA@ DB 'PROGRESS_STATUS_RESI'
	DB	'ZING', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NECHGBNE@PROGRESS_STATUS_PREPARING?$AA@
CONST	SEGMENT
??_C@_0BK@NECHGBNE@PROGRESS_STATUS_PREPARING?$AA@ DB 'PROGRESS_STATUS_PRE'
	DB	'PARING', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CJOANMAM@NONSYS_INPLACE_ENC_IN_PROGRESS?$AA@
CONST	SEGMENT
??_C@_0BP@CJOANMAM@NONSYS_INPLACE_ENC_IN_PROGRESS?$AA@ DB 'NONSYS_INPLACE'
	DB	'_ENC_IN_PROGRESS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HEMAICHN@FAILED_TO_RESUME_SYSTEM_ENCRYPTI@
CONST	SEGMENT
??_C@_0CD@HEMAICHN@FAILED_TO_RESUME_SYSTEM_ENCRYPTI@ DB 'FAILED_TO_RESUME'
	DB	'_SYSTEM_ENCRYPTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OIGJDCBH@FAILED_TO_INTERRUPT_SYSTEM_ENCRY@
CONST	SEGMENT
??_C@_0CG@OIGJDCBH@FAILED_TO_INTERRUPT_SYSTEM_ENCRY@ DB 'FAILED_TO_INTERR'
	DB	'UPT_SYSTEM_ENCRYPTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DMHMPBKC@PROCESSED_PORTION_100_PERCENT?$AA@
CONST	SEGMENT
??_C@_0BO@DMHMPBKC@PROCESSED_PORTION_100_PERCENT?$AA@ DB 'PROCESSED_PORTI'
	DB	'ON_100_PERCENT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LLAADOBF@PROGRESS_STATUS_PAUSED?$AA@
CONST	SEGMENT
??_C@_0BH@LLAADOBF@PROGRESS_STATUS_PAUSED?$AA@ DB 'PROGRESS_STATUS_PAUSED'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HKENJBII@PROGRESS_STATUS_FINISHED?$AA@
CONST	SEGMENT
??_C@_0BJ@HKENJBII@PROGRESS_STATUS_FINISHED?$AA@ DB 'PROGRESS_STATUS_FINI'
	DB	'SHED', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06PPGAKMJI@RESUME?$AA@
CONST	SEGMENT
??_C@_06PPGAKMJI@RESUME?$AA@ DB 'RESUME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJBBBIIP@IDC_PAUSE?$AA@
CONST	SEGMENT
??_C@_09PJBBBIIP@IDC_PAUSE?$AA@ DB 'IDC_PAUSE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@ DB ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PONBLMNB@PROGRESS_STATUS_ENCRYPTING?$AA@
CONST	SEGMENT
??_C@_0BL@PONBLMNB@PROGRESS_STATUS_ENCRYPTING?$AA@ DB 'PROGRESS_STATUS_EN'
	DB	'CRYPTING', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MHLPJIOG@PROGRESS_STATUS_DECRYPTING?$AA@
CONST	SEGMENT
??_C@_0BL@MHLPJIOG@PROGRESS_STATUS_DECRYPTING?$AA@ DB 'PROGRESS_STATUS_DE'
	DB	'CRYPTING', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FJOOBAJA@PROGRESS_STATUS_WAITING?$AA@
CONST	SEGMENT
??_C@_0BI@FJOOBAJA@PROGRESS_STATUS_WAITING?$AA@ DB 'PROGRESS_STATUS_WAITI'
	DB	'NG', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHILMIHF@CANCEL?$AA@
CONST	SEGMENT
??_C@_06JHILMIHF@CANCEL?$AA@ DB 'CANCEL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKHKLFPJ@PREV?$AA@
CONST	SEGMENT
??_C@_04PKHKLFPJ@PREV?$AA@ DB 'PREV', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MOKMKBJN@NEXT?$AA@
CONST	SEGMENT
??_C@_04MOKMKBJN@NEXT?$AA@ DB 'NEXT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EOJLPPDK@UISTR_NO?$AA@
CONST	SEGMENT
??_C@_08EOJLPPDK@UISTR_NO?$AA@ DB 'UISTR_NO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHINKGCK@UISTR_YES?$AA@
CONST	SEGMENT
??_C@_09JHINKGCK@UISTR_YES?$AA@ DB 'UISTR_YES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EHDIKOJL@IDC_LINK_MORE_INFO_ABOUT_CIPHER?$AA@
CONST	SEGMENT
??_C@_0CA@EHDIKOJL@IDC_LINK_MORE_INFO_ABOUT_CIPHER?$AA@ DB 'IDC_LINK_MORE'
	DB	'_INFO_ABOUT_CIPHER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CFADADFJ@THREE_LAYER_CASCADE_HELP?$AA@
CONST	SEGMENT
??_C@_0BJ@CFADADFJ@THREE_LAYER_CASCADE_HELP?$AA@ DB 'THREE_LAYER_CASCADE_'
	DB	'HELP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PJGBOAEF@TWO_LAYER_CASCADE_HELP?$AA@
CONST	SEGMENT
??_C@_0BH@PJGBOAEF@TWO_LAYER_CASCADE_HELP?$AA@ DB 'TWO_LAYER_CASCADE_HELP'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHKBFGFC@GOST_HELP?$AA@
CONST	SEGMENT
??_C@_09JHKBFGFC@GOST_HELP?$AA@ DB 'GOST_HELP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LGBFJNHH@MORE_INFO_ABOUT?$AA@
CONST	SEGMENT
??_C@_0BA@LGBFJNHH@MORE_INFO_ABOUT?$AA@ DB 'MORE_INFO_ABOUT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
CONST	SEGMENT
??_C@_0O@POKHNLDL@GOST?528147?989?$AA@ DB 'GOST 28147-89', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DDAIHKOO@IDCANCEL?$AA@
CONST	SEGMENT
??_C@_08DDAIHKOO@IDCANCEL?$AA@ DB 'IDCANCEL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OOEIKEPO@DECRYPT?$AA@
CONST	SEGMENT
??_C@_07OOEIKEPO@DECRYPT?$AA@ DB 'DECRYPT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CAOFPAJK@ENCRYPT?$AA@
CONST	SEGMENT
??_C@_07CAOFPAJK@ENCRYPT?$AA@ DB 'ENCRYPT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CFANEEFJ@CHOOSE_ENCRYPT_OR_DECRYPT?$AA@
CONST	SEGMENT
??_C@_0BK@CFANEEFJ@CHOOSE_ENCRYPT_OR_DECRYPT?$AA@ DB 'CHOOSE_ENCRYPT_OR_D'
	DB	'ECRYPT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NNBJDAHG@CHOOSE_ENCRYPT_OR_DECRYPT_FINALI@
CONST	SEGMENT
??_C@_0DA@NNBJDAHG@CHOOSE_ENCRYPT_OR_DECRYPT_FINALI@ DB 'CHOOSE_ENCRYPT_O'
	DB	'R_DECRYPT_FINALIZE_DECRYPT_NOTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FFOCOHMH@?1zinplace?$AA@
CONST	SEGMENT
??_C@_09FFOCOHMH@?1zinplace?$AA@ DB '/zinplace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NPEEBJKE@HIDDEN_OS_PRECLUDES_SINGLE_KEY_W@
CONST	SEGMENT
??_C@_0CD@NPEEBJKE@HIDDEN_OS_PRECLUDES_SINGLE_KEY_W@ DB 'HIDDEN_OS_PRECLU'
	DB	'DES_SINGLE_KEY_WDE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HHEGHILA@WHOLE_SYC_DEVICE_RECOM?$AA@
CONST	SEGMENT
??_C@_0BH@HHEGHILA@WHOLE_SYC_DEVICE_RECOM?$AA@ DB 'WHOLE_SYC_DEVICE_RECOM'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DBKKOPEJ@WDE_EXTENDED_PARTITIONS_WARNING?$AA@
CONST	SEGMENT
??_C@_0CA@DBKKOPEJ@WDE_EXTENDED_PARTITIONS_WARNING?$AA@ DB 'WDE_EXTENDED_'
	DB	'PARTITIONS_WARNING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HLDNCEMH@WDE_UNSUPPORTED_FOR_EXTENDED_PAR@
CONST	SEGMENT
??_C@_0CI@HLDNCEMH@WDE_UNSUPPORTED_FOR_EXTENDED_PAR@ DB 'WDE_UNSUPPORTED_'
	DB	'FOR_EXTENDED_PARTITIONS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CKHHFLEI@SYSDRIVE_NON_STANDARD_PARTITIONS@
CONST	SEGMENT
??_C@_0CB@CKHHFLEI@SYSDRIVE_NON_STANDARD_PARTITIONS@ DB 'SYSDRIVE_NON_STA'
	DB	'NDARD_PARTITIONS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@ DB 0aH, 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KNBCDPOB@ASK_ENCRYPT_PARTITION_INSTEAD_OF@
CONST	SEGMENT
??_C@_0CH@KNBCDPOB@ASK_ENCRYPT_PARTITION_INSTEAD_OF@ DB 'ASK_ENCRYPT_PART'
	DB	'ITION_INSTEAD_OF_DRIVE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@
CONST	SEGMENT
??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@ DB 'ADMIN_PRIVILEGE'
	DB	'S_WARN_DEVICES', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@
CONST	SEGMENT
??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@ DB 'SETUP_FAILED_BOO'
	DB	'T_DRIVE_ENCRYPTED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GFEACENL@SYS_ENCRYPTION_OR_DECRYPTION_IN_@
CONST	SEGMENT
??_C@_0CJ@GFEACENL@SYS_ENCRYPTION_OR_DECRYPTION_IN_@ DB 'SYS_ENCRYPTION_O'
	DB	'R_DECRYPTION_IN_PROGRESS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HDGOHFPD@SYSTEM_ENCRYPTION_RESUME_PROMPT?$AA@
CONST	SEGMENT
??_C@_0CA@HDGOHFPD@SYSTEM_ENCRYPTION_RESUME_PROMPT?$AA@ DB 'SYSTEM_ENCRYP'
	DB	'TION_RESUME_PROMPT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BENDAOKD@Language?$AA@
CONST	SEGMENT
??_C@_08BENDAOKD@Language?$AA@ DB 'Language', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MIMCAHPI@SecurityTokenLibrary?$AA@
CONST	SEGMENT
??_C@_0BF@MIMCAHPI@SecurityTokenLibrary?$AA@ DB 'SecurityTokenLibrary', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CGLEBHPJ@SaveVolumeHistory?$AA@
CONST	SEGMENT
??_C@_0BC@CGLEBHPJ@SaveVolumeHistory?$AA@ DB 'SaveVolumeHistory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GHIJBHNC@HiddenSectorDetectionStatus?$AA@
CONST	SEGMENT
??_C@_0BM@GHIJBHNC@HiddenSectorDetectionStatus?$AA@ DB 'HiddenSectorDetec'
	DB	'tionStatus', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PLOGBODB@StartOnLogon?$AA@
CONST	SEGMENT
??_C@_0N@PLOGBODB@StartOnLogon?$AA@ DB 'StartOnLogon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLCFLINC@?1e?$AA@
CONST	SEGMENT
??_C@_02CLCFLINC@?1e?$AA@ DB '/e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
CONST	SEGMENT
??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@ DB 'SYSTEM_ENCRYPTIO'
	DB	'N_IN_PROGRESS_ELSEWHERE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@
CONST	SEGMENT
??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@ DB 'ERR_GETTING_SYST'
	DB	'EM_ENCRYPTION_STATUS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_R0?AUException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::Exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BD@KMABOOHN@?6?7?$DM?1sysencryption?$DO?$AA@
CONST	SEGMENT
??_C@_0BD@KMABOOHN@?6?7?$DM?1sysencryption?$DO?$AA@ DB 0aH, 09H, '</sysen'
	DB	'cryption>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BNNHBPIN@?6?7?7?$DMconfig?5key?$DN?$CCWipeMode?$CC?$DO?$CFd?$DM?1co@
CONST	SEGMENT
??_C@_0CG@BNNHBPIN@?6?7?7?$DMconfig?5key?$DN?$CCWipeMode?$CC?$DO?$CFd?$DM?1co@ DB 0aH
	DB	09H, 09H, '<config key="WipeMode">%d</config>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HMBPOGIN@?6?7?7?$DMconfig?5key?$DN?$CCSystemEncryption@
CONST	SEGMENT
??_C@_0DE@HMBPOGIN@?6?7?7?$DMconfig?5key?$DN?$CCSystemEncryption@ DB 0aH, 09H
	DB	09H, '<config key="SystemEncryptionStatus">%d</config>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEDCODCO@?6?7?$DMsysencryption?$DO?$AA@
CONST	SEGMENT
??_C@_0BC@IEDCODCO@?6?7?$DMsysencryption?$DO?$AA@ DB 0aH, 09H, '<sysencry'
	DB	'ption>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LPCKNJKP@CANNOT_SAVE_SYS_ENCRYPTION_SETTI@
CONST	SEGMENT
??_C@_0CE@LPCKNJKP@CANNOT_SAVE_SYS_ENCRYPTION_SETTI@ DB 'CANNOT_SAVE_SYS_'
	DB	'ENCRYPTION_SETTINGS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@
CONST	SEGMENT
??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@ DB 'System Encryption.xml'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NDJDHMAP@UAC_INIT_ERROR?$AA@
CONST	SEGMENT
??_C@_0P@NDJDHMAP@UAC_INIT_ERROR?$AA@ DB 'UAC_INIT_ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KPBLJGDL@runas?$AA@
CONST	SEGMENT
??_C@_05KPBLJGDL@runas?$AA@ DB 'runas', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MDDLOGBN@?1q?5UAC?5?$AA@
CONST	SEGMENT
??_C@_07MDDLOGBN@?1q?5UAC?5?$AA@ DB '/q UAC ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7Container@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7Container@ForEach@GostCrypt@@6B@ DD FLAT:??_R4Container@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::Container::`vftable'
	DD	FLAT:??_EContainer@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_09NKHKFHLH@GostCrypt?$AA@
CONST	SEGMENT
??_C@_09NKHKFHLH@GostCrypt?$AA@ DB 'GostCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT
??_7ios_base@std@@6B@ DD FLAT:??_R4ios_base@std@@6B@	; std::ios_base::`vftable'
	DD	FLAT:??_Eios_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7?$ctype@_W@std@@6B@
CONST	SEGMENT
??_7?$ctype@_W@std@@6B@ DD FLAT:??_R4?$ctype@_W@std@@6B@ ; std::ctype<wchar_t>::`vftable'
	DD	FLAT:??_E?$ctype@_W@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
	DD	FLAT:?do_is@?$ctype@_W@std@@MBE_NF_W@Z
	DD	FLAT:?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
	DD	FLAT:?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
	DD	FLAT:?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
	DD	FLAT:?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
	DD	FLAT:?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
	DD	FLAT:?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
	DD	FLAT:?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
	DD	FLAT:?do_widen@?$ctype@_W@std@@MBE_WD@Z
	DD	FLAT:?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@_W@std@@MBED_WD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z$0
__ehfuncinfo$??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z$1
__ehfuncinfo$??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$28 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$28
__unwindtable$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$4
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z$2
__ehfuncinfo$??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
__tryblocktable$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$7
__unwindtable$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$5
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z$0
__ehfuncinfo$??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z$0
__ehfuncinfo$??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z$1
__ehfuncinfo$??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z$1
__ehfuncinfo$??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z$0
__unwindtable$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z$2
__ehfuncinfo$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z$0
__ehfuncinfo$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$33
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$33
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z$0
__ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z$0
__ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$32
	DD	02H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$134
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z$2
__ehfuncinfo$??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z$2
__ehfuncinfo$??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$38 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$38
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$36
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$37
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ$1
__ehfuncinfo$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$2
__ehfuncinfo$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$2
__ehfuncinfo$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0
__ehfuncinfo$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$2
__ehfuncinfo$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ$1
__ehfuncinfo$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ$0
__ehfuncinfo$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$3
__ehfuncinfo$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$3
__ehfuncinfo$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$4
__ehfuncinfo$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$0
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$1
	DD	02H
	DD	00H
__ehfuncinfo$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2
__ehfuncinfo$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$14
	DD	01H
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$15
__ehfuncinfo$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$34 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$0
__tryblocktable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$34
__ehfuncinfo$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$5
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$32
	DD	06H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$33
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$14
__ehfuncinfo$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0
__ehfuncinfo$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2
__ehfuncinfo$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z$0
__ehfuncinfo$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$1
__ehfuncinfo$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$1
__ehfuncinfo$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$1
__ehfuncinfo$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z$0
__ehfuncinfo$??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z$1
__ehfuncinfo$??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?CheckGapBetweenSysAndHiddenOS@@YAHXZ$4 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffe38H
	DD	FLAT:__catch$?CheckGapBetweenSysAndHiddenOS@@YAHXZ$0
__tryblocktable$?CheckGapBetweenSysAndHiddenOS@@YAHXZ DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?CheckGapBetweenSysAndHiddenOS@@YAHXZ$4
__unwindtable$?CheckGapBetweenSysAndHiddenOS@@YAHXZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?CheckGapBetweenSysAndHiddenOS@@YAHXZ$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?CheckGapBetweenSysAndHiddenOS@@YAHXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?CheckGapBetweenSysAndHiddenOS@@YAHXZ
	DD	01H
	DD	FLAT:__tryblocktable$?CheckGapBetweenSysAndHiddenOS@@YAHXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?GetDevicePathForHiddenOS@@YAHXZ$6 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffff74H
	DD	FLAT:__catch$?GetDevicePathForHiddenOS@@YAHXZ$0
__unwindtable$?GetDevicePathForHiddenOS@@YAHXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?GetDevicePathForHiddenOS@@YAHXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?GetDevicePathForHiddenOS@@YAHXZ$6
__ehfuncinfo$?GetDevicePathForHiddenOS@@YAHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetDevicePathForHiddenOS@@YAHXZ
	DD	01H
	DD	FLAT:__tryblocktable$?GetDevicePathForHiddenOS@@YAHXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?SysEncResume@@YAXXZ$5 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffff88H
	DD	FLAT:__catch$?SysEncResume@@YAXXZ$2
__catchsym$?SysEncResume@@YAXXZ$4 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffff84H
	DD	FLAT:__catch$?SysEncResume@@YAXXZ$0
__unwindtable$?SysEncResume@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?SysEncResume@@YAXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SysEncResume@@YAXXZ
	DD	02H
	DD	FLAT:__tryblocktable$?SysEncResume@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?SysEncResume@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?SysEncResume@@YAXXZ$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?SysEncResume@@YAXXZ$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?SysEncPause@@YAXXZ$5 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffff88H
	DD	FLAT:__catch$?SysEncPause@@YAXXZ$2
__catchsym$?SysEncPause@@YAXXZ$4 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffff84H
	DD	FLAT:__catch$?SysEncPause@@YAXXZ$0
__unwindtable$?SysEncPause@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?SysEncPause@@YAXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SysEncPause@@YAXXZ
	DD	02H
	DD	FLAT:__tryblocktable$?SysEncPause@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?SysEncPause@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?SysEncPause@@YAXXZ$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?SysEncPause@@YAXXZ$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?UpdateSysEncControls@@YAXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?UpdateSysEncControls@@YAXXZ$0
__unwindtable$?UpdateSysEncControls@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?UpdateSysEncControls@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?UpdateSysEncControls@@YAXXZ$2
__ehfuncinfo$?UpdateSysEncControls@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateSysEncControls@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?UpdateSysEncControls@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?UpdateSysEncProgressBar@@YAXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?UpdateSysEncProgressBar@@YAXXZ$0
__unwindtable$?UpdateSysEncProgressBar@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?UpdateSysEncProgressBar@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?UpdateSysEncProgressBar@@YAXXZ$2
__ehfuncinfo$?UpdateSysEncProgressBar@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateSysEncProgressBar@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?UpdateSysEncProgressBar@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?GetSystemPartitionSize@@YA_JXZ$3 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffea8H
	DD	FLAT:__catch$?GetSystemPartitionSize@@YA_JXZ$0
__unwindtable$?GetSystemPartitionSize@@YA_JXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?GetSystemPartitionSize@@YA_JXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?GetSystemPartitionSize@@YA_JXZ$3
__ehfuncinfo$?GetSystemPartitionSize@@YA_JXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetSystemPartitionSize@@YA_JXZ
	DD	01H
	DD	FLAT:__tryblocktable$?GetSystemPartitionSize@@YA_JXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ForceRemoveSysEnc@@YAHXZ$5 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffe08H
	DD	FLAT:__catch$?ForceRemoveSysEnc@@YAHXZ$2
__catchsym$?ForceRemoveSysEnc@@YAHXZ$4 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffe04H
	DD	FLAT:__catch$?ForceRemoveSysEnc@@YAHXZ$0
__unwindtable$?ForceRemoveSysEnc@@YAHXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?ForceRemoveSysEnc@@YAHXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ForceRemoveSysEnc@@YAHXZ
	DD	02H
	DD	FLAT:__tryblocktable$?ForceRemoveSysEnc@@YAHXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?ForceRemoveSysEnc@@YAHXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?ForceRemoveSysEnc@@YAHXZ$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?ForceRemoveSysEnc@@YAHXZ$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?SwitchWizardToHiddenOSMode@@YAHXZ$2 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffff20H
	DD	FLAT:__catch$?SwitchWizardToHiddenOSMode@@YAHXZ$0
__unwindtable$?SwitchWizardToHiddenOSMode@@YAHXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?SwitchWizardToHiddenOSMode@@YAHXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?SwitchWizardToHiddenOSMode@@YAHXZ$2
__ehfuncinfo$?SwitchWizardToHiddenOSMode@@YAHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SwitchWizardToHiddenOSMode@@YAHXZ
	DD	01H
	DD	FLAT:__tryblocktable$?SwitchWizardToHiddenOSMode@@YAHXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z$2 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffff88H
	DD	FLAT:__catch$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z$0
__unwindtable$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z$2
__ehfuncinfo$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?SysEncryptionOrDecryptionRequired@@YAHXZ$2 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffff88H
	DD	FLAT:__catch$?SysEncryptionOrDecryptionRequired@@YAHXZ$0
__unwindtable$?SysEncryptionOrDecryptionRequired@@YAHXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?SysEncryptionOrDecryptionRequired@@YAHXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?SysEncryptionOrDecryptionRequired@@YAHXZ$2
__ehfuncinfo$?SysEncryptionOrDecryptionRequired@@YAHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SysEncryptionOrDecryptionRequired@@YAHXZ
	DD	01H
	DD	FLAT:__tryblocktable$?SysEncryptionOrDecryptionRequired@@YAHXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ChangeHiddenOSCreationPhase@@YAHH@Z$2 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffffecH
	DD	FLAT:__catch$?ChangeHiddenOSCreationPhase@@YAHH@Z$0
__unwindtable$?ChangeHiddenOSCreationPhase@@YAHH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?ChangeHiddenOSCreationPhase@@YAHH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?ChangeHiddenOSCreationPhase@@YAHH@Z$2
__ehfuncinfo$?ChangeHiddenOSCreationPhase@@YAHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ChangeHiddenOSCreationPhase@@YAHH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?ChangeHiddenOSCreationPhase@@YAHH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?DetermineHiddenOSCreationPhase@@YAIXZ$2 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffffe8H
	DD	FLAT:__catch$?DetermineHiddenOSCreationPhase@@YAIXZ$0
__unwindtable$?DetermineHiddenOSCreationPhase@@YAIXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DetermineHiddenOSCreationPhase@@YAIXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?DetermineHiddenOSCreationPhase@@YAIXZ$2
__ehfuncinfo$?DetermineHiddenOSCreationPhase@@YAIXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DetermineHiddenOSCreationPhase@@YAIXZ
	DD	01H
	DD	FLAT:__tryblocktable$?DetermineHiddenOSCreationPhase@@YAIXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
__ehfuncinfo$?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_UpdateWipeControls$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_UpdateWipeControls$0
__unwindtable$_UpdateWipeControls DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_UpdateWipeControls DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_UpdateWipeControls$2
__ehfuncinfo$_UpdateWipeControls DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_UpdateWipeControls
	DD	01H
	DD	FLAT:__tryblocktable$_UpdateWipeControls
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_InitWipeProgressBar$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_InitWipeProgressBar$0
__unwindtable$_InitWipeProgressBar DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_InitWipeProgressBar DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_InitWipeProgressBar$2
__ehfuncinfo$_InitWipeProgressBar DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_InitWipeProgressBar
	DD	01H
	DD	FLAT:__tryblocktable$_InitWipeProgressBar
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_UpdateWipeProgressBar$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_UpdateWipeProgressBar$0
__unwindtable$_UpdateWipeProgressBar DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_UpdateWipeProgressBar DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_UpdateWipeProgressBar$2
__ehfuncinfo$_UpdateWipeProgressBar DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_UpdateWipeProgressBar
	DD	01H
	DD	FLAT:__tryblocktable$_UpdateWipeProgressBar
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_WipeAbort$5 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffffb8H
	DD	FLAT:__catch$_WipeAbort$2
__catchsym$_WipeAbort$4 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffffb4H
	DD	FLAT:__catch$_WipeAbort$0
__unwindtable$_WipeAbort DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$_WipeAbort DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$_WipeAbort
	DD	02H
	DD	FLAT:__tryblocktable$_WipeAbort
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$_WipeAbort DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_WipeAbort$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$_WipeAbort$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_WipeStart$2 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffffecH
	DD	FLAT:__catch$_WipeStart$0
__unwindtable$_WipeStart DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_WipeStart DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_WipeStart$2
__ehfuncinfo$_WipeStart DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_WipeStart
	DD	01H
	DD	FLAT:__tryblocktable$_WipeStart
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_InitSysEncProgressBar$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_InitSysEncProgressBar$0
__unwindtable$_InitSysEncProgressBar DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_InitSysEncProgressBar DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_InitSysEncProgressBar$2
__ehfuncinfo$_InitSysEncProgressBar DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_InitSysEncProgressBar
	DD	01H
	DD	FLAT:__tryblocktable$_InitSysEncProgressBar
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_AfterSysEncProgressWMInitTasks$2 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffffecH
	DD	FLAT:__catch$_AfterSysEncProgressWMInitTasks$0
__unwindtable$_AfterSysEncProgressWMInitTasks DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_AfterSysEncProgressWMInitTasks DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_AfterSysEncProgressWMInitTasks$2
__ehfuncinfo$_AfterSysEncProgressWMInitTasks DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_AfterSysEncProgressWMInitTasks
	DD	01H
	DD	FLAT:__tryblocktable$_AfterSysEncProgressWMInitTasks
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_AfterWMInitTasks$16 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffcb0H
	DD	FLAT:__catch$_AfterWMInitTasks$8
__catchsym$_AfterWMInitTasks$15 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffca8H
	DD	FLAT:__catch$_AfterWMInitTasks$6
__catchsym$_AfterWMInitTasks$14 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffcacH
	DD	FLAT:__catch$_AfterWMInitTasks$4
__catchsym$_AfterWMInitTasks$13 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffca4H
	DD	FLAT:__catch$_AfterWMInitTasks$2
__catchsym$_AfterWMInitTasks$12 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffcb4H
	DD	FLAT:__catch$_AfterWMInitTasks$0
__ehfuncinfo$_AfterWMInitTasks DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$_AfterWMInitTasks
	DD	05H
	DD	FLAT:__tryblocktable$_AfterWMInitTasks
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_AfterWMInitTasks DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_AfterWMInitTasks DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_AfterWMInitTasks$12
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$_AfterWMInitTasks$13
	DD	04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$_AfterWMInitTasks$14
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$_AfterWMInitTasks$15
	DD	08H
	DD	08H
	DD	09H
	DD	01H
	DD	FLAT:__catchsym$_AfterWMInitTasks$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_WipeHiddenOSCreationConfig$3 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffffe8H
	DD	FLAT:__catch$_WipeHiddenOSCreationConfig$0
__tryblocktable$_WipeHiddenOSCreationConfig DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$_WipeHiddenOSCreationConfig$3
__unwindtable$_WipeHiddenOSCreationConfig DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_WipeHiddenOSCreationConfig$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$_WipeHiddenOSCreationConfig DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$_WipeHiddenOSCreationConfig
	DD	01H
	DD	FLAT:__tryblocktable$_WipeHiddenOSCreationConfig
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_ResolveUnknownSysEncDirection$2 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffff70H
	DD	FLAT:__catch$_ResolveUnknownSysEncDirection$0
__unwindtable$_ResolveUnknownSysEncDirection DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_ResolveUnknownSysEncDirection DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_ResolveUnknownSysEncDirection$2
__ehfuncinfo$_ResolveUnknownSysEncDirection DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_ResolveUnknownSysEncDirection
	DD	01H
	DD	FLAT:__tryblocktable$_ResolveUnknownSysEncDirection
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_SwitchWizardToSysEncMode$17 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffdb0H
	DD	FLAT:__catch$_SwitchWizardToSysEncMode$4
__catchsym$_SwitchWizardToSysEncMode$16 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffdacH
	DD	FLAT:__catch$_SwitchWizardToSysEncMode$2
__catchsym$_SwitchWizardToSysEncMode$15 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffda8H
	DD	FLAT:__catch$_SwitchWizardToSysEncMode$0
__ehfuncinfo$_SwitchWizardToSysEncMode DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$_SwitchWizardToSysEncMode
	DD	03H
	DD	FLAT:__tryblocktable$_SwitchWizardToSysEncMode
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$_SwitchWizardToSysEncMode DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_SwitchWizardToSysEncMode$15
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$_SwitchWizardToSysEncMode$16
	DD	04H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$_SwitchWizardToSysEncMode$17
__unwindtable$_SwitchWizardToSysEncMode DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	04H
	DD	FLAT:__unwindfunclet$_SwitchWizardToSysEncMode$6
	DD	05H
	DD	FLAT:__unwindfunclet$_SwitchWizardToSysEncMode$7
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_MainDialogProc@16$159 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d10H
	DD	FLAT:__catch$_MainDialogProc@16$41
__catchsym$_MainDialogProc@16$158 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d04H
	DD	FLAT:__catch$_MainDialogProc@16$39
__catchsym$_MainDialogProc@16$157 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2cf4H
	DD	FLAT:__catch$_MainDialogProc@16$37
__catchsym$_MainDialogProc@16$156 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2cecH
	DD	FLAT:__catch$_MainDialogProc@16$35
__catchsym$_MainDialogProc@16$155 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2cf0H
	DD	FLAT:__catch$_MainDialogProc@16$33
__catchsym$_MainDialogProc@16$154 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2cd8H
	DD	FLAT:__catch$_MainDialogProc@16$31
__catchsym$_MainDialogProc@16$153 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d14H
	DD	FLAT:__catch$_MainDialogProc@16$29
__catchsym$_MainDialogProc@16$152 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2ce8H
	DD	FLAT:__catch$_MainDialogProc@16$27
__catchsym$_MainDialogProc@16$151 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2ce4H
	DD	FLAT:__catch$_MainDialogProc@16$25
__catchsym$_MainDialogProc@16$150 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2cdcH
	DD	FLAT:__catch$_MainDialogProc@16$23
__catchsym$_MainDialogProc@16$149 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2ce0H
	DD	FLAT:__catch$_MainDialogProc@16$21
__catchsym$_MainDialogProc@16$148 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d0cH
	DD	FLAT:__catch$_MainDialogProc@16$19
__catchsym$_MainDialogProc@16$147 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2cf8H
	DD	FLAT:__catch$_MainDialogProc@16$17
__catchsym$_MainDialogProc@16$146 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d00H
	DD	FLAT:__catch$_MainDialogProc@16$13
__catchsym$_MainDialogProc@16$145 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2cfcH
	DD	FLAT:__catch$_MainDialogProc@16$14
__catchsym$_MainDialogProc@16$144 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d20H
	DD	FLAT:__catch$_MainDialogProc@16$11
__catchsym$_MainDialogProc@16$143 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d24H
	DD	FLAT:__catch$_MainDialogProc@16$9
__catchsym$_MainDialogProc@16$141 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d1cH
	DD	FLAT:__catch$_MainDialogProc@16$2
__catchsym$_MainDialogProc@16$140 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d08H
	DD	FLAT:__catch$_MainDialogProc@16$3
__catchsym$_MainDialogProc@16$139 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d2cH
	DD	FLAT:__catch$_MainDialogProc@16$0
__catchsym$_MainDialogProc@16$142 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	0ffff2d50H
	DD	FLAT:__catch$_MainDialogProc@16$6
	DD	08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffff2d28H
	DD	FLAT:__catch$_MainDialogProc@16$7
__ehfuncinfo$_MainDialogProc@16 DD 019930522H
	DD	047H
	DD	FLAT:__unwindtable$_MainDialogProc@16
	DD	015H
	DD	FLAT:__tryblocktable$_MainDialogProc@16
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$_MainDialogProc@16 DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$139
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$140
	DD	04H
	DD	04H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$141
	DD	08H
	DD	08H
	DD	09H
	DD	02H
	DD	FLAT:__catchsym$_MainDialogProc@16$142
	DD	0aH
	DD	0aH
	DD	0bH
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$143
	DD	0cH
	DD	0cH
	DD	0dH
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$144
	DD	010H
	DD	010H
	DD	011H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$145
	DD	0eH
	DD	0eH
	DD	011H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$146
	DD	012H
	DD	012H
	DD	013H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$147
	DD	014H
	DD	014H
	DD	015H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$148
	DD	016H
	DD	016H
	DD	017H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$149
	DD	01aH
	DD	01aH
	DD	01bH
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$150
	DD	01cH
	DD	01eH
	DD	01fH
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$151
	DD	020H
	DD	020H
	DD	021H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$152
	DD	031H
	DD	032H
	DD	033H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$153
	DD	034H
	DD	035H
	DD	036H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$154
	DD	038H
	DD	038H
	DD	039H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$155
	DD	03aH
	DD	03aH
	DD	03bH
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$156
	DD	03cH
	DD	03cH
	DD	03dH
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$157
	DD	03eH
	DD	03eH
	DD	03fH
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$158
	DD	045H
	DD	045H
	DD	046H
	DD	01H
	DD	FLAT:__catchsym$_MainDialogProc@16$159
__unwindtable$_MainDialogProc@16 DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$45
	DD	02H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$46
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	00H
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0fH
	DD	00H
	DD	0fH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$49
	DD	018H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$50
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01cH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$53
	DD	01dH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$54
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$57
	DD	022H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$58
	DD	023H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$59
	DD	024H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$60
	DD	025H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$61
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$63
	DD	027H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$64
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$64
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$66
	DD	02aH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$67
	DD	02bH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$68
	DD	02cH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$69
	DD	02dH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$70
	DD	02eH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$71
	DD	02fH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$72
	DD	0ffffffffH
	DD	00H
	DD	031H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$74
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	034H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$75
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$76
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$78
	DD	040H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$79
	DD	041H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$80
	DD	042H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$81
	DD	043H
	DD	FLAT:__unwindfunclet$_MainDialogProc@16$82
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_PageDialogProc@16$42 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffeeb30H
	DD	FLAT:__catch$_PageDialogProc@16$4
__catchsym$_PageDialogProc@16$41 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffeeb2cH
	DD	FLAT:__catch$_PageDialogProc@16$2
__catchsym$_PageDialogProc@16$40 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffeeb34H
	DD	FLAT:__catch$_PageDialogProc@16$0
__ehfuncinfo$_PageDialogProc@16 DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$_PageDialogProc@16
	DD	03H
	DD	FLAT:__tryblocktable$_PageDialogProc@16
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$_PageDialogProc@16 DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_PageDialogProc@16$40
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$_PageDialogProc@16$41
	DD	0eH
	DD	0eH
	DD	0fH
	DD	01H
	DD	FLAT:__catchsym$_PageDialogProc@16$42
__unwindtable$_PageDialogProc@16 DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_PageDialogProc@16$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_PageDialogProc@16$18
	DD	05H
	DD	00H
	DD	06H
	DD	00H
	DD	06H
	DD	FLAT:__unwindfunclet$_PageDialogProc@16$22
	DD	08H
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$_PageDialogProc@16$19
	DD	0aH
	DD	FLAT:__unwindfunclet$_PageDialogProc@16$26
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_PageDialogProc@16$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_PageDialogProc@16$10
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$_sysEncDriveAnalysisThread DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_sysEncDriveAnalysisThread DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$_sysEncDriveAnalysisThread$3
__catchsym$_sysEncDriveAnalysisThread$3 DD 08H
	DD	FLAT:??_R0?AUTimeOut@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$_sysEncDriveAnalysisThread$0
	DD	08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffffe4H
	DD	FLAT:__catch$_sysEncDriveAnalysisThread$1
__ehfuncinfo$_sysEncDriveAnalysisThread DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_sysEncDriveAnalysisThread
	DD	01H
	DD	FLAT:__tryblocktable$_sysEncDriveAnalysisThread
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_localcleanup$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_localcleanup$0
__unwindtable$_localcleanup DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_localcleanup DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$_localcleanup$3
__ehfuncinfo$_localcleanup DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_localcleanup
	DD	01H
	DD	FLAT:__tryblocktable$_localcleanup
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HostDevice@@QAE@ABU0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HostDevice@@QAE@ABU0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0HostDevice@@QAE@ABU0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0HostDevice@@QAE@ABU0@@Z$2
__ehfuncinfo$??0HostDevice@@QAE@ABU0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0HostDevice@@QAE@ABU0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z$54 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z$54
__ehfuncinfo$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z$57
__ehfuncinfo$?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z$67 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z$67
__ehfuncinfo$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1HostDevice@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1HostDevice@@QAE@XZ$0
__ehfuncinfo$??1HostDevice@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1HostDevice@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gios_base@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gios_base@std@@UAEPAXI@Z$0
__ehfuncinfo$??_Gios_base@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gios_base@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Init@ios_base@std@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Init@ios_base@std@@IAEXXZ$0
__ehfuncinfo$?_Init@ios_base@std@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Init@ios_base@std@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ios_base@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$1
__ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
__ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Glocale@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Glocale@std@@QAEPAXI@Z$0
__ehfuncinfo$??_Glocale@std@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Glocale@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_WinMain@16$3 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffffe8H
	DD	FLAT:__catch$_WinMain@16$0
__tryblocktable$_WinMain@16 DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$_WinMain@16$3
__unwindtable$_WinMain@16 DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_WinMain@16$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$_WinMain@16 DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$_WinMain@16
	DD	01H
	DD	FLAT:__tryblocktable$_WinMain@16
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z PROC ; std::allocator<HostDevice>::construct<HostDevice,HostDevice>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN3@construct:

; 738  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UHostDevice@@U1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z ENDP ; std::allocator<HostDevice>::construct<HostDevice,HostDevice>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<HostDevice> >::construct<HostDevice,HostDevice>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN8@construct:

; 858  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UHostDevice@@U1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<HostDevice> >::construct<HostDevice,HostDevice>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UHostDevice@@@std@@YA$$QAUHostDevice@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UHostDevice@@@std@@YA$$QAUHostDevice@@AAU1@@Z PROC ; std::forward<HostDevice>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UHostDevice@@@std@@YA$$QAUHostDevice@@AAU1@@Z ENDP ; std::forward<HostDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
$T2 = 12						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<HostDevice const *,HostDevice *,std::allocator<HostDevice> >, COMDAT

; 220  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 221  : 	_FwdIt _Next = _Dest;

  0002b	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 222  : 
; 223  : 	_TRY_BEGIN

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00031	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00034	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003e	66 90		 npad	 2
$LL4@Uninitiali:

; 224  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00040	3b fb		 cmp	 edi, ebx
  00042	74 3c		 je	 SHORT $LN3@Uninitiali

; 225  : 		_Al.construct(_Unfancy(_Dest), *_First);

  00044	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004b	85 f6		 test	 esi, esi
  0004d	74 08		 je	 SHORT $LN25@Uninitiali
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN25@Uninitiali:
  00057	83 c6 70	 add	 esi, 112		; 00000070H
  0005a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0005e	89 75 10	 mov	 DWORD PTR __Dest$[ebp], esi
  00061	83 c7 70	 add	 edi, 112		; 00000070H
  00064	eb da		 jmp	 SHORT $LL4@Uninitiali
__catch$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:

; 226  : 	_CATCH_ALL
; 227  : 	_Destroy_range(_Next, _Dest, _Al);

  00066	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00069	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0006c	ff 75 ec	 push	 DWORD PTR __Next$[ebp]
  0006f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UHostDevice@@@std@@PAUHostDevice@@@std@@YAXPAUHostDevice@@0AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<HostDevice>,HostDevice *>
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 228  : 	_RERAISE;

  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN106@Uninitiali:
$LN3@Uninitiali:

; 229  : 	_CATCH_END
; 230  : 
; 231  : 	return (_Dest);

  00080	8b c6		 mov	 eax, esi

; 232  : 	}

  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN105@Uninitiali:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$4:
  00000	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00003	50		 push	 eax
  00004	8b 45 0c	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<HostDevice const *,HostDevice *,std::allocator<HostDevice> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@$$CBUHostDevice@@U1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBUHostDevice@@ABQAU2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_copy_cat@$$CBUHostDevice@@U1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBUHostDevice@@ABQAU2@@Z PROC ; std::_Ptr_copy_cat<HostDevice const ,HostDevice>, COMDAT

; 793  : 	return {};

  00000	32 c0		 xor	 al, al

; 794  : 	}

  00002	c3		 ret	 0
??$_Ptr_copy_cat@$$CBUHostDevice@@U1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBUHostDevice@@ABQAU2@@Z ENDP ; std::_Ptr_copy_cat<HostDevice const ,HostDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::construct<HostDevice,HostDevice>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UHostDevice@@U1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::construct<HostDevice,HostDevice>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UHostDevice@@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UHostDevice@@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@@Z PROC ; std::allocator<HostDevice>::destroy<HostDevice>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  : 		_Ptr->~_Uty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1HostDevice@@QAE@XZ	; HostDevice::~HostDevice

; 745  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UHostDevice@@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@@Z ENDP ; std::allocator<HostDevice>::destroy<HostDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<HostDevice> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<HostDevice> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy_al_unchecked@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<HostDevice const *,HostDevice *,std::allocator<HostDevice> >, COMDAT

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<HostDevice const *,HostDevice *,std::allocator<HostDevice> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 250  : 		_Ptr_copy_cat(_First, _Dest),
; 251  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), decltype(*_First)>()));
; 252  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_copy_al_unchecked@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<HostDevice const *,HostDevice *,std::allocator<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@YAPBUHostDevice@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@YAPBUHostDevice@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<HostDevice> > >, COMDAT

; 271  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 272  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 273  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@YAPBUHostDevice@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<HostDevice> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 554  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
$T2 = 12						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<HostDevice *,HostDevice *,std::allocator<HostDevice> >, COMDAT

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 274  : 	_FwdIt _Next = _Dest;

  0002b	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 275  : 
; 276  : 	_TRY_BEGIN

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00031	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00034	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003e	66 90		 npad	 2
$LL4@Uninitiali:

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00040	3b fb		 cmp	 edi, ebx
  00042	74 3c		 je	 SHORT $LN3@Uninitiali

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));

  00044	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004b	85 f6		 test	 esi, esi
  0004d	74 08		 je	 SHORT $LN28@Uninitiali
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN28@Uninitiali:
  00057	83 c6 70	 add	 esi, 112		; 00000070H
  0005a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0005e	89 75 10	 mov	 DWORD PTR __Dest$[ebp], esi
  00061	83 c7 70	 add	 edi, 112		; 00000070H
  00064	eb da		 jmp	 SHORT $LL4@Uninitiali
__catch$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:

; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);

  00066	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00069	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0006c	ff 75 ec	 push	 DWORD PTR __Next$[ebp]
  0006f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UHostDevice@@@std@@PAUHostDevice@@@std@@YAXPAUHostDevice@@0AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<HostDevice>,HostDevice *>
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : 	_RERAISE;

  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN41@Uninitiali:
$LN3@Uninitiali:

; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

  00080	8b c6		 mov	 eax, esi

; 285  : 	}

  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN40@Uninitiali:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$5:
  00000	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00003	50		 push	 eax
  00004	8b 45 0c	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<HostDevice *,HostDevice *,std::allocator<HostDevice> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@UHostDevice@@U1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUHostDevice@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_move_cat@UHostDevice@@U1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUHostDevice@@0@Z PROC ; std::_Ptr_move_cat<HostDevice,HostDevice>, COMDAT

; 810  : 	return {};

  00000	32 c0		 xor	 al, al

; 811  : 	}

  00002	c3		 ret	 0
??$_Ptr_move_cat@UHostDevice@@U1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUHostDevice@@0@Z ENDP ; std::_Ptr_move_cat<HostDevice,HostDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAUHostDevice@@@std@@YA$$QAUHostDevice@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUHostDevice@@@std@@YA$$QAUHostDevice@@AAU1@@Z PROC ; std::move<HostDevice &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUHostDevice@@@std@@YA$$QAUHostDevice@@AAU1@@Z ENDP ; std::move<HostDevice &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UHostDevice@@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UHostDevice@@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@@Z PROC ; std::allocator_traits<std::allocator<HostDevice> >::destroy<HostDevice>, COMDAT

; 863  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 864  : 		_Al.destroy(_Ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 865  : 		}

  00006	5d		 pop	 ebp

; 864  : 		_Al.destroy(_Ptr);

  00007	e9 00 00 00 00	 jmp	 ??1HostDevice@@QAE@XZ	; HostDevice::~HostDevice
??$destroy@UHostDevice@@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@@Z ENDP ; std::allocator_traits<std::allocator<HostDevice> >::destroy<HostDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@UHostDevice@@@std@@@std@@YA$$QAV?$allocator@UHostDevice@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@UHostDevice@@@std@@@std@@YA$$QAV?$allocator@UHostDevice@@@0@AAV10@@Z PROC ; std::forward<std::allocator<HostDevice> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@UHostDevice@@@std@@@std@@YA$$QAV?$allocator@UHostDevice@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@PAUHostDevice@@V?$allocator@UHostDevice@@@2@@std@@YAPAUHostDevice@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@PAUHostDevice@@V?$allocator@UHostDevice@@@2@@std@@YAPAUHostDevice@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >,HostDevice *,std::allocator<HostDevice> >, COMDAT

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 260  : 		// note: only called internally from elsewhere in the STL, debug checks
; 261  : 		// and deprecation warnings omitted
; 262  : 	return (_Rechecked(_Dest,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<HostDevice const *,HostDevice *,std::allocator<HostDevice> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 263  : 		_Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 264  : 			_Unchecked(_Dest), _Al)));
; 265  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@PAUHostDevice@@V?$allocator@UHostDevice@@@2@@std@@YAPAUHostDevice@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >,HostDevice *,std::allocator<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1><std::_Wrap_alloc<std::allocator<HostDevice> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1><std::_Wrap_alloc<std::allocator<HostDevice> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<HostDevice> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<HostDevice> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartition@GostCrypt@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UPartition@GostCrypt@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::destroy<GostCrypt::Partition>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  : 		_Ptr->~_Uty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ

; 745  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UPartition@GostCrypt@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::destroy<GostCrypt::Partition>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUHostDevice@@PAU1@@std@@YAAAPAUHostDevice@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUHostDevice@@PAU1@@std@@YAAAPAUHostDevice@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<HostDevice *,HostDevice *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 459  : 	return (_Dest);
; 460  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUHostDevice@@PAU1@@std@@YAAAPAUHostDevice@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<HostDevice *,HostDevice *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<HostDevice *,HostDevice *,std::allocator<HostDevice> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 302  : 	typedef decltype(_STD move(*_First)) _Src_type; // TRANSITION MODULES VSO#222794
; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<HostDevice *,HostDevice *,std::allocator<HostDevice> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<HostDevice *,HostDevice *,std::allocator<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUHostDevice@@@std@@YAPAUHostDevice@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUHostDevice@@@std@@YAPAUHostDevice@@PAU1@@Z PROC ; std::_Unchecked<HostDevice *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 429  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUHostDevice@@@std@@YAPAUHostDevice@@PAU1@@Z ENDP ; std::_Unchecked<HostDevice *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::destroy<std::_List_node<GostCrypt::Partition,void *> *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::destroy<std::_List_node<GostCrypt::Partition,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UHostDevice@@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UHostDevice@@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@@Z PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::destroy<HostDevice>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1HostDevice@@QAE@XZ	; HostDevice::~HostDevice

; 1004 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UHostDevice@@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@@Z ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::destroy<HostDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z PROC ; std::allocator<HostDevice>::construct<HostDevice,HostDevice const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN3@construct:

; 738  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UHostDevice@@ABU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@ABU2@@Z ENDP ; std::allocator<HostDevice>::construct<HostDevice,HostDevice const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z PROC ; std::allocator<HostDevice>::construct<HostDevice,HostDevice &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN3@construct:

; 738  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UHostDevice@@AAU1@@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@AAU2@@Z ENDP ; std::allocator<HostDevice>::construct<HostDevice,HostDevice &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@UHostDevice@@@std@@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@$$QAV?$allocator@UHostDevice@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@UHostDevice@@@std@@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@$$QAV?$allocator@UHostDevice@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::_Wrap_alloc<std::allocator<HostDevice> ><std::allocator<HostDevice> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@UHostDevice@@@std@@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@$$QAV?$allocator@UHostDevice@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::_Wrap_alloc<std::allocator<HostDevice> ><std::allocator<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 719  : 	{	// convert C string to _Elem sequence using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 720  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	57		 push	 edi
  00008	8b fe		 mov	 edi, esi
  0000a	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000d	0f 1f 00	 npad	 3
$LL11@Maklocstr:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL11@Maklocstr
  00017	2b f9		 sub	 edi, ecx
  00019	47		 inc	 edi

; 721  : 
; 722  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

  0001a	6a 01		 push	 1
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 _calloc
  00022	8b d0		 mov	 edx, eax
  00024	83 c4 08	 add	 esp, 8

; 723  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 724  : 
; 725  : 	if (!_Ptrdest)

  00027	85 d2		 test	 edx, edx
  00029	74 1c		 je	 SHORT $LN13@Maklocstr

; 727  : 
; 728  :  #pragma warning(push)
; 729  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 730  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

  0002b	85 ff		 test	 edi, edi
  0002d	74 12		 je	 SHORT $LN3@Maklocstr
  0002f	8b ca		 mov	 ecx, edx
  00031	2b ce		 sub	 ecx, esi
$LL4@Maklocstr:

; 731  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

  00033	8a 06		 mov	 al, BYTE PTR [esi]
  00035	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00038	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  0003c	83 ef 01	 sub	 edi, 1
  0003f	75 f2		 jne	 SHORT $LL4@Maklocstr
$LN3@Maklocstr:
  00041	5f		 pop	 edi

; 732  :  #pragma warning(pop)
; 733  : 
; 734  : 	return (_Ptrdest);

  00042	8b c2		 mov	 eax, edx
  00044	5e		 pop	 esi

; 735  : 	}

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN13@Maklocstr:

; 726  : 		_Xbad_alloc();

  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN15@Maklocstr:
$LN12@Maklocstr:
  0004c	cc		 int	 3
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEPAUHostDevice@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@1@0PAU2@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEPAUHostDevice@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@1@0PAU2@@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > > >, COMDAT
; _this$ = ecx

; 1651 : 		{	// copy initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1652 : 		return (_Uninitialized_copy(_First, _Last,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	51		 push	 ecx
  0000f	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<HostDevice const *,HostDevice *,std::allocator<HostDevice> >
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 1653 : 			_Ptr, this->_Getal()));
; 1654 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEPAUHostDevice@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@1@0PAU2@@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > ><std::_Wrap_alloc<std::allocator<HostDevice> >,void>, COMDAT
; _this$ = ecx

; 526  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 529  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > ><std::_Wrap_alloc<std::allocator<HostDevice> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1039 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z PROC		; std::operator==<wchar_t,wchar_t>, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ENDP		; std::operator==<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartition@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UPartition@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<GostCrypt::Partition>, COMDAT

; 863  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 864  : 		_Al.destroy(_Ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 865  : 		}

  00006	5d		 pop	 ebp

; 864  : 		_Al.destroy(_Ptr);

  00007	e9 00 00 00 00	 jmp	 ??1Partition@GostCrypt@@QAE@XZ
??$destroy@UPartition@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<GostCrypt::Partition>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z PROC ; std::_Uninitialized_move<HostDevice *,HostDevice *,std::allocator<HostDevice> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<HostDevice *,HostDevice *,std::allocator<HostDevice> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<HostDevice *,HostDevice *,std::allocator<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<std::_List_node<GostCrypt::Partition,void *> *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<std::_List_node<GostCrypt::Partition,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@UHostDevice@@@std@@PAUHostDevice@@@std@@YAXPAUHostDevice@@0AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@UHostDevice@@@std@@PAUHostDevice@@@std@@YAXPAUHostDevice@@0AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<HostDevice>,HostDevice *>, COMDAT

; 1099 : 	{	// destroy [_First, _Last), no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1100 : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN3@Destroy_ra
  0000f	90		 npad	 1
$LL4@Destroy_ra:

; 1101 : 		_Al.destroy(_Unfancy(_First));

  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1HostDevice@@QAE@XZ	; HostDevice::~HostDevice
  00017	83 c6 70	 add	 esi, 112		; 00000070H
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL4@Destroy_ra
$LN3@Destroy_ra:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1102 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Destroy_range1@V?$allocator@UHostDevice@@@std@@PAUHostDevice@@@std@@YAXPAUHostDevice@@0AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<HostDevice>,HostDevice *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<HostDevice> >::construct<HostDevice,HostDevice const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN8@construct:

; 858  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UHostDevice@@ABU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<HostDevice> >::construct<HostDevice,HostDevice const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUHostDevice@@@std@@YAABUHostDevice@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUHostDevice@@@std@@YAABUHostDevice@@ABU1@@Z PROC ; std::forward<HostDevice const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUHostDevice@@@std@@YAABUHostDevice@@ABU1@@Z ENDP ; std::forward<HostDevice const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<HostDevice> >::construct<HostDevice,HostDevice &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN8@construct:

; 858  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UHostDevice@@AAU1@@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAXAAV?$allocator@UHostDevice@@@1@PAUHostDevice@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<HostDevice> >::construct<HostDevice,HostDevice &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUHostDevice@@@std@@YAAAUHostDevice@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUHostDevice@@@std@@YAAAUHostDevice@@AAU1@@Z PROC ; std::forward<HostDevice &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUHostDevice@@@std@@YAAAUHostDevice@@AAU1@@Z ENDP ; std::forward<HostDevice &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ
text$yd	SEGMENT
??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ PROC ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static'', COMDAT
  00000	c3		 ret	 0
??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ ENDP ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??1?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ PROC ; std::_Immortalizer<std::_Iostream_error_category>::~_Immortalizer<std::_Iostream_error_category>, COMDAT
; _this$ = ecx

; 687  : 		}

  00000	c3		 ret	 0
??1?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ ENDP ; std::_Immortalizer<std::_Iostream_error_category>::~_Immortalizer<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ PROC ; std::_Immortalizer<std::_Iostream_error_category>::_Immortalizer<std::_Iostream_error_category>, COMDAT
; _this$ = ecx

; 683  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	85 c9		 test	 ecx, ecx
  00004	74 0d		 je	 SHORT $LN3@Immortaliz

; 681  : 		{	// construct _Ty inside _Storage
; 682  : 		::new (static_cast<void *>(&_Storage)) _Ty();

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@
  0000c	c7 41 04 05 00
	00 00		 mov	 DWORD PTR [ecx+4], 5
$LN3@Immortaliz:

; 683  : 		}

  00013	c3		 ret	 0
??0?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ ENDP ; std::_Immortalizer<std::_Iostream_error_category>::_Immortalizer<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartition@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UPartition@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<GostCrypt::Partition>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ

; 1004 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UPartition@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<GostCrypt::Partition>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UPartition@GostCrypt@@@std@@YAPAUPartition@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UPartition@GostCrypt@@@std@@YAPAUPartition@GostCrypt@@AAU12@@Z PROC ; std::addressof<GostCrypt::Partition>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UPartition@GostCrypt@@@std@@YAPAUPartition@GostCrypt@@AAU12@@Z ENDP ; std::addressof<GostCrypt::Partition>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9_W_W@std@@YA_NABV?$allocator@_W@0@0@Z PROC		; std::operator!=<wchar_t,wchar_t>, COMDAT

; 804  : 	return (false);

  00000	32 c0		 xor	 al, al

; 805  : 	}

  00002	c3		 ret	 0
??$?9_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ENDP		; std::operator!=<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUHostDevice@@@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEPAUHostDevice@@PAU2@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUHostDevice@@@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEPAUHostDevice@@PAU2@00@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Umove<HostDevice *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1659 : 		return (_Uninitialized_move(_First, _Last,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	51		 push	 ecx
  0000f	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<HostDevice *,HostDevice *,std::allocator<HostDevice> >
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 1660 : 			_Ptr, this->_Getal()));
; 1661 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUHostDevice@@@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEPAUHostDevice@@PAU2@00@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Umove<HostDevice *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<std::_List_node<GostCrypt::Partition,void *> *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<std::_List_node<GostCrypt::Partition,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<GostCrypt::Partition,void *> *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<GostCrypt::Partition,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A ; std::ctype<wchar_t>::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A, edi ; std::ctype<wchar_t>::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A, eax ; std::ctype<wchar_t>::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A ; std::ctype<wchar_t>::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<wchar_t>::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@UHostDevice@@@std@@PAUHostDevice@@@std@@YAXPAUHostDevice@@0AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UHostDevice@@@std@@PAUHostDevice@@@std@@YAXPAUHostDevice@@0AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<HostDevice>,HostDevice *>, COMDAT

; 1114 : 	{	// destroy [_First, _Last), choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN5@Destroy_ra
  0000f	90		 npad	 1
$LL6@Destroy_ra:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1HostDevice@@QAE@XZ	; HostDevice::~HostDevice
  00017	83 c6 70	 add	 esi, 112		; 00000070H
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL6@Destroy_ra
$LN5@Destroy_ra:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Destroy_range@V?$allocator@UHostDevice@@@std@@PAUHostDevice@@@std@@YAXPAUHostDevice@@0AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<HostDevice>,HostDevice *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 281  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@_W@std@@MAEPAXI@Z PROC			; std::numpunct<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 76 08	 push	 DWORD PTR [esi+8]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@
  0000f	e8 00 00 00 00	 call	 _free
  00014	ff 76 10	 push	 DWORD PTR [esi+16]
  00017	e8 00 00 00 00	 call	 _free
  0001c	ff 76 14	 push	 DWORD PTR [esi+20]
  0001f	e8 00 00 00 00	 call	 _free
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00031	74 0b		 je	 SHORT $LN15@scalar
  00033	6a 18		 push	 24			; 00000018H
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN15@scalar:
  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??_G?$numpunct@_W@std@@MAEPAXI@Z ENDP			; std::numpunct<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@_W@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@_W@std@@AAEXXZ PROC			; std::numpunct<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 257  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 258  : 		_CSTD free((void *)_Grouping);

  00003	ff 76 08	 push	 DWORD PTR [esi+8]
  00006	e8 00 00 00 00	 call	 _free

; 259  : 		_CSTD free((void *)_Falsename);

  0000b	ff 76 10	 push	 DWORD PTR [esi+16]
  0000e	e8 00 00 00 00	 call	 _free

; 260  : 		_CSTD free((void *)_Truename);

  00013	ff 76 14	 push	 DWORD PTR [esi+20]
  00016	e8 00 00 00 00	 call	 _free
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	5e		 pop	 esi

; 261  : 		}

  0001f	c3		 ret	 0
?_Tidy@?$numpunct@_W@std@@AAEXXZ ENDP			; std::numpunct<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::numpunct<wchar_t>::do_truename, COMDAT
; _this$ = ecx

; 251  : 		{	// return name for true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 252  : 		return (string_type(_Truename));

  00004	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00007	33 c0		 xor	 eax, eax
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00022	66 89 06	 mov	 WORD PTR [esi], ax
  00025	66 39 02	 cmp	 WORD PTR [edx], ax
  00028	75 14		 jne	 SHORT $LN117@do_truenam
  0002a	33 c9		 xor	 ecx, ecx
  0002c	51		 push	 ecx
  0002d	52		 push	 edx
  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 253  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4

; 252  : 		return (string_type(_Truename));

$LN117@do_truenam:
  0003e	8b ca		 mov	 ecx, edx
  00040	57		 push	 edi
  00041	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
$LL119@do_truenam:
  00044	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00047	83 c1 02	 add	 ecx, 2
  0004a	66 85 c0	 test	 ax, ax
  0004d	75 f5		 jne	 SHORT $LL119@do_truenam
  0004f	2b cf		 sub	 ecx, edi
  00051	d1 f9		 sar	 ecx, 1
  00053	5f		 pop	 edi
  00054	51		 push	 ecx
  00055	52		 push	 edx
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0005d	8b c6		 mov	 eax, esi
  0005f	5e		 pop	 esi

; 253  : 		}

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::numpunct<wchar_t>::do_truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::numpunct<wchar_t>::do_falsename, COMDAT
; _this$ = ecx

; 246  : 		{	// return name for false

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 247  : 		return (string_type(_Falsename));

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00007	33 c0		 xor	 eax, eax
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00022	66 89 06	 mov	 WORD PTR [esi], ax
  00025	66 39 02	 cmp	 WORD PTR [edx], ax
  00028	75 14		 jne	 SHORT $LN117@do_falsena
  0002a	33 c9		 xor	 ecx, ecx
  0002c	51		 push	 ecx
  0002d	52		 push	 edx
  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 248  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4

; 247  : 		return (string_type(_Falsename));

$LN117@do_falsena:
  0003e	8b ca		 mov	 ecx, edx
  00040	57		 push	 edi
  00041	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
$LL119@do_falsena:
  00044	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00047	83 c1 02	 add	 ecx, 2
  0004a	66 85 c0	 test	 ax, ax
  0004d	75 f5		 jne	 SHORT $LL119@do_falsena
  0004f	2b cf		 sub	 ecx, edi
  00051	d1 f9		 sar	 ecx, 1
  00053	5f		 pop	 edi
  00054	51		 push	 ecx
  00055	52		 push	 edx
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0005d	8b c6		 mov	 eax, esi
  0005f	5e		 pop	 esi

; 248  : 		}

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::numpunct<wchar_t>::do_falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<wchar_t>::do_grouping, COMDAT
; _this$ = ecx

; 241  : 		{	// return grouping string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 242  : 		return (string(_Grouping));

  00004	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00020	c6 06 00	 mov	 BYTE PTR [esi], 0
  00023	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00026	75 14		 jne	 SHORT $LN115@do_groupin
  00028	33 c9		 xor	 ecx, ecx
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi

; 243  : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4

; 242  : 		return (string(_Grouping));

$LN115@do_groupin:
  0003c	8b ca		 mov	 ecx, edx
  0003e	57		 push	 edi
  0003f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL117@do_groupin:
  00042	8a 01		 mov	 al, BYTE PTR [ecx]
  00044	41		 inc	 ecx
  00045	84 c0		 test	 al, al
  00047	75 f9		 jne	 SHORT $LL117@do_groupin
  00049	2b cf		 sub	 ecx, edi
  0004b	5f		 pop	 edi
  0004c	51		 push	 ecx
  0004d	52		 push	 edx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 243  : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<wchar_t>::do_grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ PROC	; std::numpunct<wchar_t>::do_thousands_sep, COMDAT
; _this$ = ecx

; 237  : 		return (_Kseparator);

  00000	66 8b 41 0e	 mov	 ax, WORD PTR [ecx+14]

; 238  : 		}

  00004	c3		 ret	 0
?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ ENDP	; std::numpunct<wchar_t>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ PROC	; std::numpunct<wchar_t>::do_decimal_point, COMDAT
; _this$ = ecx

; 232  : 		return (_Dp);

  00000	66 8b 41 0c	 mov	 ax, WORD PTR [ecx+12]

; 233  : 		}

  00004	c3		 ret	 0
?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ ENDP	; std::numpunct<wchar_t>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
$T2 = -124						; size = 44
$T3 = -124						; size = 44
__Mbst1$4 = -80						; size = 8
__Mbst1$5 = -80						; size = 8
_this$GSCopy$ = -76					; size = 4
__Ptr$1$ = -72						; size = 4
__Wc$6 = -72						; size = 2
__Wc$7 = -72						; size = 2
__Byte$ = -68						; size = 1
__Byte$ = -68						; size = 1
__Cvt$ = -64						; size = 44
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<wchar_t>::_Init, COMDAT
; _this$ = ecx

; 202  : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 70	 sub	 esp, 112		; 00000070H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	8b d9		 mov	 ebx, ecx
  00030	89 5d b4	 mov	 DWORD PTR _this$GSCopy$[ebp], ebx

; 203  : 		const lconv *_Ptr = _Lobj._Getlconv();

  00033	e8 00 00 00 00	 call	 _localeconv
  00038	8b f0		 mov	 esi, eax

; 204  : 		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	// conversion information

  0003a	8d 45 84	 lea	 eax, DWORD PTR $T3[ebp]
  0003d	50		 push	 eax
  0003e	89 75 b8	 mov	 DWORD PTR __Ptr$1$[ebp], esi
  00041	e8 00 00 00 00	 call	 __Getcvt
  00046	83 c4 04	 add	 esp, 4

; 205  : 
; 206  : 		_Grouping = 0;
; 207  : 		_Falsename = 0;
; 208  : 		_Truename = 0;
; 209  : 
; 210  : 		_TRY_BEGIN

  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,

  00050	80 7d 0c 00	 cmp	 BYTE PTR __Isdef$[ebp], 0
  00054	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00057	0f 11 45 c0	 movups	 XMMWORD PTR __Cvt$[ebp], xmm0
  0005b	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0005f	0f 11 45 d0	 movups	 XMMWORD PTR __Cvt$[ebp+16], xmm0
  00063	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  00068	66 0f d6 45 e0	 movq	 QWORD PTR __Cvt$[ebp+32], xmm0
  0006d	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00070	89 45 e8	 mov	 DWORD PTR __Cvt$[ebp+40], eax
  00073	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  0007a	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00081	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0
  00088	74 07		 je	 SHORT $LN6@Init
  0008a	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0008f	eb 03		 jmp	 SHORT $LN7@Init
$LN6@Init:
  00091	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
$LN7@Init:
  00094	8d 45 84	 lea	 eax, DWORD PTR $T2[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 __Getcvt
  0009d	8b fe		 mov	 edi, esi
  0009f	83 c4 04	 add	 esp, 4
  000a2	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL39@Init:
  000a5	8a 07		 mov	 al, BYTE PTR [edi]
  000a7	47		 inc	 edi
  000a8	84 c0		 test	 al, al
  000aa	75 f9		 jne	 SHORT $LL39@Init
  000ac	2b f9		 sub	 edi, ecx
  000ae	47		 inc	 edi
  000af	6a 01		 push	 1
  000b1	57		 push	 edi
  000b2	e8 00 00 00 00	 call	 _calloc
  000b7	8b d0		 mov	 edx, eax
  000b9	83 c4 08	 add	 esp, 8
  000bc	85 d2		 test	 edx, edx
  000be	75 05		 jne	 SHORT $LN22@Init
  000c0	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN43@Init:
$LN22@Init:
  000c5	85 ff		 test	 edi, edi
  000c7	74 15		 je	 SHORT $LN20@Init
  000c9	8b ca		 mov	 ecx, edx
  000cb	2b ce		 sub	 ecx, esi
  000cd	0f 1f 00	 npad	 3
$LL21@Init:
  000d0	8a 06		 mov	 al, BYTE PTR [esi]
  000d2	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000d5	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  000d9	83 ef 01	 sub	 edi, 1
  000dc	75 f2		 jne	 SHORT $LL21@Init
$LN20@Init:

; 212  : 			_Lobj._Getcvt());
; 213  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);

  000de	8d 45 c0	 lea	 eax, DWORD PTR __Cvt$[ebp]
  000e1	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_05LAPONLG@false?$AA@
  000ec	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 214  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);

  000f7	8d 45 c0	 lea	 eax, DWORD PTR __Cvt$[ebp]
  000fa	50		 push	 eax
  000fb	6a 00		 push	 0
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_04LOAJBDKD@true?$AA@
  00102	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 218  : 		_CATCH_END
; 219  : 
; 220  : 		if (_Isdef)

  0010d	80 7d 0c 00	 cmp	 BYTE PTR __Isdef$[ebp], 0
  00111	0f 84 85 00 00
	00		 je	 $LN3@Init

; 221  : 			{	// apply defaults for required facets
; 222  : //			_Grouping = _MAKLOCSTR(char, "", _Cvt);
; 223  : 			_Dp = _MAKLOCCHR(_Elem, '.', _Cvt);

  00117	8d 45 c0	 lea	 eax, DWORD PTR __Cvt$[ebp]
  0011a	c6 45 bc 2e	 mov	 BYTE PTR __Byte$[ebp], 46 ; 0000002eH
  0011e	50		 push	 eax
  0011f	8d 45 b0	 lea	 eax, DWORD PTR __Mbst1$5[ebp]
  00122	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __Wc$6[ebp], 0
  00129	50		 push	 eax
  0012a	6a 01		 push	 1
  0012c	8d 45 bc	 lea	 eax, DWORD PTR __Byte$[ebp]
  0012f	0f 57 c0	 xorps	 xmm0, xmm0
  00132	50		 push	 eax
  00133	8d 45 b8	 lea	 eax, DWORD PTR __Wc$6[ebp]
  00136	66 0f d6 45 b0	 movq	 QWORD PTR __Mbst1$5[ebp], xmm0
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 __Mbrtowc
  00141	0f b7 45 b8	 movzx	 eax, WORD PTR __Wc$6[ebp]
  00145	0f 57 c0	 xorps	 xmm0, xmm0
  00148	66 89 43 0c	 mov	 WORD PTR [ebx+12], ax

; 224  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);

  0014c	8d 45 c0	 lea	 eax, DWORD PTR __Cvt$[ebp]
  0014f	50		 push	 eax
  00150	8d 45 b0	 lea	 eax, DWORD PTR __Mbst1$4[ebp]
  00153	c6 45 bc 2c	 mov	 BYTE PTR __Byte$[ebp], 44 ; 0000002cH
  00157	50		 push	 eax
  00158	6a 01		 push	 1
  0015a	8d 45 bc	 lea	 eax, DWORD PTR __Byte$[ebp]
  0015d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __Wc$7[ebp], 0
  00164	50		 push	 eax
  00165	8d 45 b8	 lea	 eax, DWORD PTR __Wc$7[ebp]
  00168	66 0f d6 45 b0	 movq	 QWORD PTR __Mbst1$4[ebp], xmm0
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 __Mbrtowc
  00173	0f b7 45 b8	 movzx	 eax, WORD PTR __Wc$7[ebp]
  00177	83 c4 28	 add	 esp, 40			; 00000028H
$LN42@Init:

; 225  : 			}
; 226  : 		else
; 227  : 			_Getvals((_Elem)0, _Ptr, _Cvt);

  0017a	66 89 43 0e	 mov	 WORD PTR [ebx+14], ax

; 228  : 		}

  0017e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00181	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00188	59		 pop	 ecx
  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5b		 pop	 ebx
  0018c	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018f	33 cd		 xor	 ecx, ebp
  00191	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c2 08 00	 ret	 8
$LN3@Init:

; 225  : 			}
; 226  : 		else
; 227  : 			_Getvals((_Elem)0, _Ptr, _Cvt);

  0019c	8b 4d b8	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  0019f	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  001a2	0f b7 00	 movzx	 eax, WORD PTR [eax]
  001a5	66 89 43 0c	 mov	 WORD PTR [ebx+12], ax
  001a9	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  001ac	0f b7 00	 movzx	 eax, WORD PTR [eax]
  001af	eb c9		 jmp	 SHORT $LN42@Init
__catch$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z$0:

; 215  : 		_CATCH_ALL
; 216  : 		_Tidy();

  001b1	8b 4d b4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001b4	e8 00 00 00 00	 call	 ?_Tidy@?$numpunct@_W@std@@AAEXXZ ; std::numpunct<wchar_t>::_Tidy

; 217  : 		_RERAISE;

  001b9	6a 00		 push	 0
  001bb	6a 00		 push	 0
  001bd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN44@Init:
$LN41@Init:
  001c2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 80	 mov	 ecx, DWORD PTR [edx-128]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<wchar_t>::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??$_Getvals@_W@?$numpunct@_W@std@@IAEX_WPBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 2
__Ptr$ = 12						; size = 4
___formal$ = 16						; size = 44
??$_Getvals@_W@?$numpunct@_W@std@@IAEX_WPBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<wchar_t>::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 196  : 		{	// get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Dp = (_Elem)_Ptr->_W_decimal_point[0];

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00009	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0000c	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 198  : 		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];

  00010	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00013	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00016	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 199  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 34 00	 ret	 52			; 00000034H
??$_Getvals@_W@?$numpunct@_W@std@@IAEX_WPBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<wchar_t>::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??1?$numpunct@_W@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@_W@std@@MAE@XZ PROC			; std::numpunct<wchar_t>::~numpunct<wchar_t>, COMDAT
; _this$ = ecx

; 175  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 176  : 		_Tidy();

  00003	ff 76 08	 push	 DWORD PTR [esi+8]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@
  0000c	e8 00 00 00 00	 call	 _free
  00011	ff 76 10	 push	 DWORD PTR [esi+16]
  00014	e8 00 00 00 00	 call	 _free
  00019	ff 76 14	 push	 DWORD PTR [esi+20]
  0001c	e8 00 00 00 00	 call	 _free
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  : 		}

  00024	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002a	5e		 pop	 esi
  0002b	c3		 ret	 0
??1?$numpunct@_W@std@@MAE@XZ ENDP			; std::numpunct<wchar_t>::~numpunct<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<wchar_t>::_Getcat, COMDAT

; 166  : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	33 db		 xor	 ebx, ebx
  0002a	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx

; 167  : 		if (_Ppf != 0 && *_Ppf == 0)

  0002d	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  00030	85 ff		 test	 edi, edi
  00032	74 76		 je	 SHORT $LN29@Getcat
  00034	39 1f		 cmp	 DWORD PTR [edi], ebx
  00036	75 72		 jne	 SHORT $LN29@Getcat

; 168  : 			*_Ppf = new numpunct<_Elem>(

  00038	6a 18		 push	 24			; 00000018H
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 75 08	 mov	 DWORD PTR $T4[ebp], esi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 f6		 test	 esi, esi
  0004c	74 4b		 je	 SHORT $LN4@Getcat
  0004e	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	bb 01 00 00 00	 mov	 ebx, 1
  00077	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0007e	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00081	53		 push	 ebx
  00082	50		 push	 eax
  00083	8b ce		 mov	 ecx, esi
  00085	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0008c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@
  00092	e8 00 00 00 00	 call	 ?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<wchar_t>::_Init
  00097	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00099	33 f6		 xor	 esi, esi
$LN5@Getcat:
  0009b	89 37		 mov	 DWORD PTR [edi], esi
  0009d	f6 c3 01	 test	 bl, 1
  000a0	74 08		 je	 SHORT $LN29@Getcat
  000a2	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  000a5	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@Getcat:

; 169  : 				_Locinfo(_Ploc->c_str()), 0, true);
; 170  : 		return (_X_NUMERIC);

  000aa	b8 04 00 00 00	 mov	 eax, 4

; 171  : 		}

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	0f 84 0c 00 00
	00		 je	 $LN8@Getcat
  0001b	83 65 f0 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  0001f	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00022	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN8@Getcat:
  00027	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2:
  00028	8b 4d 08	 mov	 ecx, DWORD PTR $T4[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__ehhandler$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<wchar_t>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<wchar_t>::numpunct<wchar_t>, COMDAT
; _this$ = ecx

; 160  : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 159  : 		: locale::facet(_Refs)

  00029	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 161  : 		_Init(_Lobj, _Isdef);

  0002f	ff 75 10	 push	 DWORD PTR __Isdef$[ebp]
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	ff 75 08	 push	 DWORD PTR __Lobj$[ebp]
  0003c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@
  00042	e8 00 00 00 00	 call	 ?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<wchar_t>::_Init

; 162  : 		}

  00047	8b c6		 mov	 eax, esi
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5e		 pop	 esi
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__ehhandler$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<wchar_t>::numpunct<wchar_t>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::numpunct<wchar_t>::truename, COMDAT
; _this$ = ecx

; 143  : 		{	// return name for true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 144  : 		return (do_truename());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 1c	 call	 DWORD PTR [edx+28]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 145  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::numpunct<wchar_t>::truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::numpunct<wchar_t>::falsename, COMDAT
; _this$ = ecx

; 138  : 		{	// return name for false

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 139  : 		return (do_falsename());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 18	 call	 DWORD PTR [edx+24]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 140  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::numpunct<wchar_t>::falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<wchar_t>::grouping, COMDAT
; _this$ = ecx

; 133  : 		{	// return grouping string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 134  : 		return (do_grouping());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 14	 call	 DWORD PTR [edx+20]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 135  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<wchar_t>::grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@_W@std@@QBE_WXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@_W@std@@QBE_WXZ PROC		; std::numpunct<wchar_t>::thousands_sep, COMDAT
; _this$ = ecx

; 129  : 		return (do_thousands_sep());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 10	 jmp	 DWORD PTR [eax+16]
?thousands_sep@?$numpunct@_W@std@@QBE_WXZ ENDP		; std::numpunct<wchar_t>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@_W@std@@QBE_WXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@_W@std@@QBE_WXZ PROC		; std::numpunct<wchar_t>::decimal_point, COMDAT
; _this$ = ecx

; 124  : 		return (do_decimal_point());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 0c	 jmp	 DWORD PTR [eax+12]
?decimal_point@?$numpunct@_W@std@@QBE_WXZ ENDP		; std::numpunct<wchar_t>::decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<wchar_t> >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A, edi ; std::numpunct<wchar_t>::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A, eax ; std::numpunct<wchar_t>::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<wchar_t>::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?failed@?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::failed, COMDAT
; _this$ = ecx

; 662  : 		return (_Failed);

  00000	8a 01		 mov	 al, BYTE PTR [ecx]

; 663  : 		}

  00002	c3		 ret	 0
?failed@?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::failed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator++, COMDAT
; _this$ = ecx

; 652  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 653  : 		}

  00002	c3		 ret	 0
??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator*, COMDAT
; _this$ = ecx

; 647  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 2
??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z PROC ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 637  : 		{	// store element and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 638  : 		if (_Strbuf == 0
; 639  : 			|| traits_type::eq_int_type(_Traits::eof(),

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 3b		 je	 SHORT $LN3@operator
  0000d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00010	83 38 00	 cmp	 DWORD PTR [eax], 0
  00013	74 1e		 je	 SHORT $LN7@operator
  00015	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	85 c0		 test	 eax, eax
  0001c	7e 15		 jle	 SHORT $LN7@operator
  0001e	48		 dec	 eax
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00029	89 01		 mov	 DWORD PTR [ecx], eax
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0002e	66 89 02	 mov	 WORD PTR [edx], ax
  00031	eb 08		 jmp	 SHORT $LN28@operator
$LN7@operator:
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00038	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN28@operator:
  0003b	0f b7 c0	 movzx	 eax, ax
  0003e	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00043	66 3b c8	 cmp	 cx, ax
  00046	75 03		 jne	 SHORT $LN29@operator
$LN3@operator:

; 640  : 				_Strbuf->sputc(_Right)))
; 641  : 			_Failed = true;

  00048	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN29@operator:

; 642  : 		return (*this);

  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi

; 643  : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z ENDP ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??0?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z PROC ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 628  : 		{	// construct from stream buffer _Sb

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		: _Failed(false), _Strbuf(_Sb)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Sb$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 629  : 		}

  00009	8b c1		 mov	 eax, ecx
  0000b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??0?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z ENDP ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN13@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 2
__Count$ = 28						; size = 4
?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep, COMDAT

; 1583 : 		{	// put _Count * _Ch to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1584 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

  00003	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00006	56		 push	 esi
  00007	8b 75 1c	 mov	 esi, DWORD PTR __Count$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	74 52		 je	 SHORT $LN3@Rep
  0000e	53		 push	 ebx
  0000f	57		 push	 edi
  00010	8b 7d 18	 mov	 edi, DWORD PTR __Ch$[ebp]
  00013	bb ff ff 00 00	 mov	 ebx, 65535		; 0000ffffH
$LL4@Rep:

; 1585 : 			*_Dest = _Ch;

  00018	85 d2		 test	 edx, edx
  0001a	74 39		 je	 SHORT $LN12@Rep
  0001c	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00022	74 1e		 je	 SHORT $LN16@Rep
  00024	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  00027	8b 01		 mov	 eax, DWORD PTR [ecx]
  00029	85 c0		 test	 eax, eax
  0002b	7e 15		 jle	 SHORT $LN16@Rep
  0002d	48		 dec	 eax
  0002e	89 01		 mov	 DWORD PTR [ecx], eax
  00030	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	66 89 3a	 mov	 WORD PTR [edx], di
  0003d	0f b7 c7	 movzx	 eax, di
  00040	eb 0b		 jmp	 SHORT $LN17@Rep
$LN16@Rep:
  00042	8b 02		 mov	 eax, DWORD PTR [edx]
  00044	8b ca		 mov	 ecx, edx
  00046	57		 push	 edi
  00047	ff 50 0c	 call	 DWORD PTR [eax+12]
  0004a	0f b7 c0	 movzx	 eax, ax
$LN17@Rep:
  0004d	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00050	66 3b d8	 cmp	 bx, ax
  00053	75 04		 jne	 SHORT $LN2@Rep
$LN12@Rep:
  00055	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Rep:

; 1584 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

  00059	83 ee 01	 sub	 esi, 1
  0005c	75 ba		 jne	 SHORT $LL4@Rep
  0005e	5f		 pop	 edi
  0005f	5b		 pop	 ebx
$LN3@Rep:

; 1586 : 		return (_Dest);

  00060	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00063	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00066	5e		 pop	 esi
  00067	89 08		 mov	 DWORD PTR [eax], ecx
  00069	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1587 : 		}

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put, COMDAT

; 1575 : 		{	// put [_Ptr, _Ptr + _Count) to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1576 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

  00003	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00006	56		 push	 esi
  00007	8b 75 1c	 mov	 esi, DWORD PTR __Count$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	74 57		 je	 SHORT $LN3@Put
  0000e	53		 push	 ebx
  0000f	57		 push	 edi
  00010	8b 7d 18	 mov	 edi, DWORD PTR __Ptr$[ebp]
$LL4@Put:

; 1577 : 			*_Dest = *_Ptr;

  00013	85 d2		 test	 edx, edx
  00015	74 40		 je	 SHORT $LN12@Put
  00017	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001a	0f b7 1f	 movzx	 ebx, WORD PTR [edi]
  0001d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00020	74 1d		 je	 SHORT $LN16@Put
  00022	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	85 c0		 test	 eax, eax
  00029	7e 14		 jle	 SHORT $LN16@Put
  0002b	48		 dec	 eax
  0002c	89 01		 mov	 DWORD PTR [ecx], eax
  0002e	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00036	89 01		 mov	 DWORD PTR [ecx], eax
  00038	8b c3		 mov	 eax, ebx
  0003a	66 89 1a	 mov	 WORD PTR [edx], bx
  0003d	eb 0b		 jmp	 SHORT $LN17@Put
$LN16@Put:
  0003f	8b 02		 mov	 eax, DWORD PTR [edx]
  00041	8b ca		 mov	 ecx, edx
  00043	53		 push	 ebx
  00044	ff 50 0c	 call	 DWORD PTR [eax+12]
  00047	0f b7 c0	 movzx	 eax, ax
$LN17@Put:
  0004a	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  0004d	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00052	66 3b c8	 cmp	 cx, ax
  00055	75 04		 jne	 SHORT $LN2@Put
$LN12@Put:
  00057	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Put:

; 1576 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

  0005b	83 c7 02	 add	 edi, 2
  0005e	83 ee 01	 sub	 esi, 1
  00061	75 b0		 jne	 SHORT $LL4@Put
  00063	5f		 pop	 edi
  00064	5b		 pop	 ebx
$LN3@Put:

; 1578 : 		return (_Dest);

  00065	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00068	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0006b	5e		 pop	 esi
  0006c	89 08		 mov	 DWORD PTR [eax], ecx
  0006e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1579 : 		}

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
_TEXT	SEGMENT
$T2 = -92						; size = 8
__Iosbase$GSCopy$1$ = -88				; size = 4
___$ReturnUdt$GSCopy$1$ = -84				; size = 4
$T3 = -80						; size = 8
$T4 = -80						; size = 8
$T5 = -80						; size = 8
$T6 = -80						; size = 8
$T7 = -80						; size = 8
$T8 = -80						; size = 8
$T9 = -80						; size = 8
__Dest$3$ = -72						; size = 4
__Ctype_fac$1$ = -72					; size = 4
__Kseparator$1$ = -68					; size = 4
__Count$GSCopy$2$ = -68					; size = 4
__Buf$GSCopy$1$ = -68					; size = 4
__Punct_fac$1$ = -68					; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 2
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput, COMDAT

; 1515 : 		{	// put formatted integer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 7d 24	 mov	 edi, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 75 18	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00034	8b 4d 20	 mov	 ecx, DWORD PTR __Buf$[ebp]
  00037	89 45 ac	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 75 a8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], esi
  0003d	89 4d bc	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], ecx

; 1516 : 		_DEBUG_POINTER(_Dest);
; 1517 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')

  00040	85 ff		 test	 edi, edi
  00042	74 11		 je	 SHORT $LN14@Iput
  00044	8a 01		 mov	 al, BYTE PTR [ecx]
  00046	3c 2b		 cmp	 al, 43			; 0000002bH
  00048	74 04		 je	 SHORT $LN13@Iput
  0004a	3c 2d		 cmp	 al, 45			; 0000002dH
  0004c	75 07		 jne	 SHORT $LN14@Iput
$LN13@Iput:
  0004e	bb 01 00 00 00	 mov	 ebx, 1
  00053	eb 02		 jmp	 SHORT $LN15@Iput
$LN14@Iput:
  00055	33 db		 xor	 ebx, ebx
$LN15@Iput:

; 1518 : 			? 1 : 0;
; 1519 : 		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
; 1520 : 			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1521 : 			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

  00057	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005a	25 00 0e 00 00	 and	 eax, 3584		; 00000e00H
  0005f	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00064	75 1d		 jne	 SHORT $LN4@Iput
  00066	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00069	3b c7		 cmp	 eax, edi
  0006b	77 16		 ja	 SHORT $LN4@Iput
  0006d	80 3c 19 30	 cmp	 BYTE PTR [ecx+ebx], 48	; 00000030H
  00071	75 10		 jne	 SHORT $LN4@Iput
  00073	8a 4c 19 01	 mov	 cl, BYTE PTR [ecx+ebx+1]
  00077	80 f9 78	 cmp	 cl, 120			; 00000078H
  0007a	74 05		 je	 SHORT $LN5@Iput
  0007c	80 f9 58	 cmp	 cl, 88			; 00000058H
  0007f	75 02		 jne	 SHORT $LN4@Iput
$LN5@Iput:

; 1522 : 			_Prefix += 2;

  00081	8b d8		 mov	 ebx, eax
$LN4@Iput:

; 1523 : 
; 1524 : 		const ctype<_Elem>& _Ctype_fac =

  00083	8d 45 b0	 lea	 eax, DWORD PTR $T9[ebp]
  00086	8b ce		 mov	 ecx, esi
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0008e	50		 push	 eax
  0008f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00096	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000a1	8b 4d b4	 mov	 ecx, DWORD PTR $T9[ebp+4]
  000a4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000ab	85 c9		 test	 ecx, ecx
  000ad	74 11		 je	 SHORT $LN27@Iput
  000af	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b1	ff 50 08	 call	 DWORD PTR [eax+8]
  000b4	85 c0		 test	 eax, eax
  000b6	74 08		 je	 SHORT $LN27@Iput
  000b8	8b 10		 mov	 edx, DWORD PTR [eax]
  000ba	8b c8		 mov	 ecx, eax
  000bc	6a 01		 push	 1
  000be	ff 12		 call	 DWORD PTR [edx]
$LN27@Iput:

; 1525 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);
; 1526 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

  000c0	33 c0		 xor	 eax, eax
  000c2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c9	50		 push	 eax
  000ca	57		 push	 edi
  000cb	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  000ce	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+20], 7
  000d5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+16], 0
  000dc	66 89 45 d8	 mov	 WORD PTR __Groupstring$[ebp], ax
  000e0	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1527 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  000e5	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  000e9	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  000ec	8b 4d bc	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
  000ef	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  000f3	8b 55 b8	 mov	 edx, DWORD PTR __Ctype_fac$1$[ebp]
  000f6	50		 push	 eax
  000f7	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  000fa	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00101	50		 push	 eax
  00102	8b 12		 mov	 edx, DWORD PTR [edx]
  00104	51		 push	 ecx
  00105	8b 4d b8	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00108	ff 52 2c	 call	 DWORD PTR [edx+44]

; 1528 : 
; 1529 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0010b	8d 45 b0	 lea	 eax, DWORD PTR $T8[ebp]
  0010e	8b ce		 mov	 ecx, esi
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00116	50		 push	 eax
  00117	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0011b	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
  00120	8b f0		 mov	 esi, eax
  00122	83 c4 04	 add	 esp, 4
  00125	89 75 bc	 mov	 DWORD PTR __Punct_fac$1$[ebp], esi
  00128	8b 4d b4	 mov	 ecx, DWORD PTR $T8[ebp+4]
  0012b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0012f	85 c9		 test	 ecx, ecx
  00131	74 11		 je	 SHORT $LN159@Iput
  00133	8b 01		 mov	 eax, DWORD PTR [ecx]
  00135	ff 50 08	 call	 DWORD PTR [eax+8]
  00138	85 c0		 test	 eax, eax
  0013a	74 08		 je	 SHORT $LN159@Iput
  0013c	8b 10		 mov	 edx, DWORD PTR [eax]
  0013e	8b c8		 mov	 ecx, eax
  00140	6a 01		 push	 1
  00142	ff 12		 call	 DWORD PTR [edx]
$LN159@Iput:

; 1530 : 		const string _Grouping = _Punct_fac.grouping();

  00144	8d 45 c0	 lea	 eax, DWORD PTR __Grouping$[ebp]
  00147	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0014b	50		 push	 eax
  0014c	8b ce		 mov	 ecx, esi
  0014e	e8 00 00 00 00	 call	 ?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<wchar_t>::grouping

; 1531 : 		const char *_Pg = &_Grouping[0];

  00153	83 7d d4 10	 cmp	 DWORD PTR __Grouping$[ebp+20], 16 ; 00000010H
  00157	8d 75 c0	 lea	 esi, DWORD PTR __Grouping$[ebp]
  0015a	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0015e	0f 43 75 c0	 cmovae	 esi, DWORD PTR __Grouping$[ebp]

; 1532 : 		if (*_Pg != CHAR_MAX && '\0' < *_Pg)

  00162	8a 06		 mov	 al, BYTE PTR [esi]
  00164	3c 7f		 cmp	 al, 127			; 0000007fH
  00166	74 4b		 je	 SHORT $LN3@Iput
  00168	84 c0		 test	 al, al
  0016a	7e 47		 jle	 SHORT $LN3@Iput

; 1533 : 			{	// grouping specified, add thousands separators
; 1534 : 			const _Elem _Kseparator = _Punct_fac.thousands_sep();

  0016c	8b 4d bc	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  0016f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00171	ff 50 10	 call	 DWORD PTR [eax+16]

; 1535 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1536 : 				&& (size_t)*_Pg < _Count - _Prefix)

  00174	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  00177	0f b7 d0	 movzx	 edx, ax
  0017a	89 55 bc	 mov	 DWORD PTR __Kseparator$1$[ebp], edx
  0017d	74 34		 je	 SHORT $LN3@Iput
  0017f	90		 npad	 1
$LL2@Iput:
  00180	8a 06		 mov	 al, BYTE PTR [esi]
  00182	84 c0		 test	 al, al
  00184	7e 2d		 jle	 SHORT $LN3@Iput
  00186	0f be c8	 movsx	 ecx, al
  00189	8b c7		 mov	 eax, edi
  0018b	2b c3		 sub	 eax, ebx
  0018d	3b c8		 cmp	 ecx, eax
  0018f	73 22		 jae	 SHORT $LN3@Iput

; 1537 : 				{	// insert thousands separator
; 1538 : 				_Count -= *_Pg;
; 1539 : 				_Groupstring.insert(_Count, 1, _Kseparator);

  00191	52		 push	 edx
  00192	2b f9		 sub	 edi, ecx
  00194	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00197	6a 01		 push	 1
  00199	57		 push	 edi
  0019a	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  0019f	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0

; 1540 : 				if ('\0' < _Pg[1])

  001a3	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  001a6	8b 55 bc	 mov	 edx, DWORD PTR __Kseparator$1$[ebp]
  001a9	0f 4e c6	 cmovle	 eax, esi
  001ac	8b f0		 mov	 esi, eax
  001ae	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  001b1	75 cd		 jne	 SHORT $LL2@Iput
$LN3@Iput:

; 1541 : 					++_Pg;	// not last group, advance
; 1542 : 				}
; 1543 : 			}
; 1544 : 
; 1545 : 		_Count = _Groupstring.size();
; 1546 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1547 : 			|| (size_t)_Iosbase.width() <= _Count

  001b3	8b 75 a8	 mov	 esi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  001b6	8b 45 e8	 mov	 eax, DWORD PTR __Groupstring$[ebp+16]
  001b9	89 45 bc	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], eax
  001bc	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  001c0	7c 13		 jl	 SHORT $LN16@Iput
  001c2	7f 06		 jg	 SHORT $LN474@Iput
  001c4	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  001c8	76 0b		 jbe	 SHORT $LN16@Iput
$LN474@Iput:
  001ca	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  001cd	3b f8		 cmp	 edi, eax
  001cf	76 04		 jbe	 SHORT $LN16@Iput
  001d1	2b f8		 sub	 edi, eax
  001d3	eb 02		 jmp	 SHORT $LN17@Iput
$LN16@Iput:
  001d5	33 ff		 xor	 edi, edi
$LN17@Iput:

; 1548 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1549 : 
; 1550 : 		ios_base::fmtflags _Adjustfield =
; 1551 : 			_Iosbase.flags() & ios_base::adjustfield;

  001d7	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001da	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  001df	83 f8 40	 cmp	 eax, 64			; 00000040H

; 1552 : 		if (_Adjustfield != ios_base::left
; 1553 : 			&& _Adjustfield != ios_base::internal)

  001e2	0f 84 97 00 00
	00		 je	 $LN10@Iput
  001e8	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  001ed	74 48		 je	 SHORT $LN473@Iput

; 1554 : 			{	// put leading fill
; 1555 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  001ef	57		 push	 edi
  001f0	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  001f3	8d 45 b0	 lea	 eax, DWORD PTR $T7[ebp]
  001f6	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  001f9	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  001fc	50		 push	 eax
  001fd	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00200	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  00205	8b d0		 mov	 edx, eax

; 1556 : 			_Fillcount = 0;
; 1557 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00207	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0020a	33 ff		 xor	 edi, edi
  0020c	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  00210	53		 push	 ebx
  00211	0f 43 4d d8	 cmovae	 ecx, DWORD PTR __Groupstring$[ebp]
  00215	8b 02		 mov	 eax, DWORD PTR [edx]
  00217	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  0021a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0021d	51		 push	 ecx
  0021e	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00221	8d 45 b0	 lea	 eax, DWORD PTR $T6[ebp]
  00224	ff 72 04	 push	 DWORD PTR [edx+4]
  00227	ff 32		 push	 DWORD PTR [edx]
  00229	50		 push	 eax
  0022a	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0022d	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  00232	83 c4 30	 add	 esp, 48			; 00000030H
  00235	eb 6a		 jmp	 SHORT $LN478@Iput
$LN473@Iput:

; 1558 : 			}
; 1559 : 		else if (_Adjustfield == ios_base::internal)
; 1560 : 			{	// put internal fill
; 1561 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00237	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  0023b	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0023e	53		 push	 ebx
  0023f	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  00243	50		 push	 eax
  00244	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00247	8d 45 b0	 lea	 eax, DWORD PTR $T5[ebp]
  0024a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0024d	50		 push	 eax
  0024e	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00251	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  00256	8b c8		 mov	 ecx, eax

; 1562 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  00258	57		 push	 edi
  00259	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  0025c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0025e	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00261	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00264	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00267	8d 45 b0	 lea	 eax, DWORD PTR $T4[ebp]
  0026a	ff 71 04	 push	 DWORD PTR [ecx+4]
  0026d	ff 31		 push	 DWORD PTR [ecx]
  0026f	50		 push	 eax
  00270	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00273	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  00278	83 c4 30	 add	 esp, 48			; 00000030H

; 1563 : 			_Fillcount = 0;

  0027b	33 ff		 xor	 edi, edi

; 1564 : 			}
; 1565 : 		else

  0027d	eb 22		 jmp	 SHORT $LN478@Iput
$LN10@Iput:

; 1566 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  0027f	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  00283	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  00286	53		 push	 ebx
  00287	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  0028b	50		 push	 eax
  0028c	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  0028f	8d 45 b0	 lea	 eax, DWORD PTR $T3[ebp]
  00292	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00295	50		 push	 eax
  00296	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00299	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  0029e	83 c4 18	 add	 esp, 24			; 00000018H
$LN478@Iput:
  002a1	8b 10		 mov	 edx, DWORD PTR [eax]

; 1567 : 
; 1568 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  002a3	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  002a7	8b 4d bc	 mov	 ecx, DWORD PTR __Count$GSCopy$2$[ebp]
  002aa	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  002ad	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002b0	89 45 b8	 mov	 DWORD PTR __Dest$3$[ebp], eax
  002b3	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002b6	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  002b9	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002bd	2b cb		 sub	 ecx, ebx
  002bf	51		 push	 ecx
  002c0	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  002c3	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  002c6	50		 push	 eax
  002c7	ff 75 b8	 push	 DWORD PTR __Dest$3$[ebp]
  002ca	8d 45 a4	 lea	 eax, DWORD PTR $T2[ebp]
  002cd	52		 push	 edx
  002ce	50		 push	 eax
  002cf	53		 push	 ebx
  002d0	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put

; 1569 : 		_Iosbase.width(0);
; 1570 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  002d5	57		 push	 edi
  002d6	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  002d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  002db	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  002de	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002e1	50		 push	 eax
  002e2	51		 push	 ecx
  002e3	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  002ea	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  002f1	8b 75 ac	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  002f4	56		 push	 esi
  002f5	53		 push	 ebx
  002f6	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002f9	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  002fe	8b 45 d4	 mov	 eax, DWORD PTR __Grouping$[ebp+20]
  00301	83 c4 30	 add	 esp, 48			; 00000030H
  00304	83 f8 10	 cmp	 eax, 16			; 00000010H
  00307	72 0d		 jb	 SHORT $LN272@Iput
  00309	40		 inc	 eax
  0030a	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0030d	50		 push	 eax
  0030e	ff 75 c0	 push	 DWORD PTR __Grouping$[ebp]
  00311	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN272@Iput:
  00316	8b 4d ec	 mov	 ecx, DWORD PTR __Groupstring$[ebp+20]
  00319	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH
  00320	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+16], 0
  00327	c6 45 c0 00	 mov	 BYTE PTR __Grouping$[ebp], 0
  0032b	83 f9 08	 cmp	 ecx, 8
  0032e	72 0d		 jb	 SHORT $LN475@Iput
  00330	41		 inc	 ecx
  00331	51		 push	 ecx
  00332	ff 75 d8	 push	 DWORD PTR __Groupstring$[ebp]
  00335	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00338	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN475@Iput:
  0033d	8b c6		 mov	 eax, esi

; 1571 : 		}

  0033f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00342	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00349	59		 pop	 ecx
  0034a	5f		 pop	 edi
  0034b	5e		 pop	 esi
  0034c	5b		 pop	 ebx
  0034d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00350	33 cd		 xor	 ecx, ebp
  00352	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00357	8b e5		 mov	 esp, ebp
  00359	5d		 pop	 ebp
  0035a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$2:
  00016	8d 4d b0	 lea	 ecx, DWORD PTR $T8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$33:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$3:
  00024	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt, COMDAT

; 1487 : 		{	// generate sprintf format for integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1488 : 		char *_Ptr = _Fmt;
; 1489 : 		*_Ptr++ = '%';
; 1490 : 
; 1491 : 		if (_Flags & ios_base::showpos)

  00003	8b 4d 14	 mov	 ecx, DWORD PTR __Flags$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Fmt$[ebp]
  0000a	57		 push	 edi
  0000b	c6 06 25	 mov	 BYTE PTR [esi], 37	; 00000025H
  0000e	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00011	f6 c1 20	 test	 cl, 32			; 00000020H
  00014	74 04		 je	 SHORT $LN2@Ifmt

; 1492 : 			*_Ptr++ = '+';

  00016	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  00019	40		 inc	 eax
$LN2@Ifmt:

; 1493 : 		if (_Flags & ios_base::showbase)

  0001a	f6 c1 08	 test	 cl, 8
  0001d	74 04		 je	 SHORT $LN3@Ifmt

; 1494 : 			*_Ptr++ = '#';

  0001f	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00022	40		 inc	 eax
$LN3@Ifmt:

; 1495 : 		if (_Spec[0] != 'L')

  00023	8b 7d 10	 mov	 edi, DWORD PTR __Spec$[ebp]
  00026	8a 17		 mov	 dl, BYTE PTR [edi]
  00028	80 fa 4c	 cmp	 dl, 76			; 0000004cH
  0002b	74 04		 je	 SHORT $LN4@Ifmt

; 1496 : 			*_Ptr++ = _Spec[0];	// qualifier

  0002d	88 10		 mov	 BYTE PTR [eax], dl

; 1497 : 		else

  0002f	eb 0b		 jmp	 SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1498 : 
; 1499 : 			{	/* change L to I64 */
; 1500 : 			*_Ptr++ = 'I';

  00031	66 c7 00 49 36	 mov	 WORD PTR [eax], 13897	; 00003649H

; 1501 : 			*_Ptr++ = '6';

  00036	83 c0 02	 add	 eax, 2

; 1502 : 			*_Ptr++ = '4';

  00039	c6 00 34	 mov	 BYTE PTR [eax], 52	; 00000034H
$LN5@Ifmt:

; 1503 : 			}
; 1504 : 
; 1505 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  0003c	8b d1		 mov	 edx, ecx
  0003e	81 e2 00 0e 00
	00		 and	 edx, 3584		; 00000e00H
  00044	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  0004a	75 0f		 jne	 SHORT $LN9@Ifmt
  0004c	b1 6f		 mov	 cl, 111			; 0000006fH
  0004e	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00051	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  00055	8b c6		 mov	 eax, esi
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 1511 : 		}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN9@Ifmt:
  0005b	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  00061	74 10		 je	 SHORT $LN7@Ifmt
  00063	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00066	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00069	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  0006d	8b c6		 mov	 eax, esi
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 1511 : 		}

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$LN7@Ifmt:

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  00073	c0 e1 03	 shl	 cl, 3
  00076	f6 d1		 not	 cl
  00078	80 e1 20	 and	 cl, 32			; 00000020H
  0007b	80 c9 58	 or	 cl, 88			; 00000058H
  0007e	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00081	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 1511 : 		}

  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z
_TEXT	SEGMENT
$T2 = -104						; size = 8
__Iosbase$GSCopy$1$ = -100				; size = 4
___$ReturnUdt$GSCopy$1$ = -96				; size = 4
__Count$GSCopy$2$ = -92					; size = 4
__Eoff$1$ = -92						; size = 4
__Buf$GSCopy$1$ = -88					; size = 4
__Punct_fac$1$ = -88					; size = 4
$T3 = -84						; size = 8
$T4 = -84						; size = 8
$T5 = -84						; size = 8
$T6 = -84						; size = 8
$T7 = -84						; size = 8
$T8 = -84						; size = 8
$T9 = -84						; size = 8
__Kseparator$1$ = -76					; size = 4
__Ctype_fac$1$ = -76					; size = 4
__Dp$ = -72						; size = 2
__Dest$3$ = -68						; size = 4
__Count$GSCopy$1$ = -68					; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 2
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput, COMDAT

; 1413 : 		{	// put formatted floating-point to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 4d 24	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 75 18	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00034	8b 7d 20	 mov	 edi, DWORD PTR __Buf$[ebp]
  00037	89 45 a0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 75 9c	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], esi
  0003d	89 7d a8	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], edi
  00040	89 4d bc	 mov	 DWORD PTR __Count$GSCopy$1$[ebp], ecx

; 1414 : 		_DEBUG_POINTER(_Dest);
; 1415 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')

  00043	85 c9		 test	 ecx, ecx
  00045	74 11		 je	 SHORT $LN16@Fput
  00047	8a 07		 mov	 al, BYTE PTR [edi]
  00049	3c 2b		 cmp	 al, 43			; 0000002bH
  0004b	74 04		 je	 SHORT $LN15@Fput
  0004d	3c 2d		 cmp	 al, 45			; 0000002dH
  0004f	75 07		 jne	 SHORT $LN16@Fput
$LN15@Fput:
  00051	bb 01 00 00 00	 mov	 ebx, 1
  00056	eb 02		 jmp	 SHORT $LN17@Fput
$LN16@Fput:
  00058	33 db		 xor	 ebx, ebx
$LN17@Fput:

; 1416 : 			? 1 : 0;
; 1417 : 
; 1418 : 		const char *_Exps;
; 1419 : 		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)

  0005a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005d	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00062	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  00067	74 07		 je	 SHORT $LN4@Fput

; 1420 : 			_Exps = "eE";

  00069	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MDKMJEGG@eE?$AA@

; 1421 : 		else

  0006e	eb 22		 jmp	 SHORT $LN6@Fput
$LN4@Fput:

; 1422 : 			{	// correct for hexadecimal floating-point
; 1423 : 			_Exps = "pP";
; 1424 : 			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1425 : 				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

  00070	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00073	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02OOPEBDOJ@pP?$AA@
  00078	3b c1		 cmp	 eax, ecx
  0007a	77 16		 ja	 SHORT $LN6@Fput
  0007c	80 3c 1f 30	 cmp	 BYTE PTR [edi+ebx], 48	; 00000030H
  00080	75 10		 jne	 SHORT $LN6@Fput
  00082	8a 4c 1f 01	 mov	 cl, BYTE PTR [edi+ebx+1]
  00086	80 f9 78	 cmp	 cl, 120			; 00000078H
  00089	74 05		 je	 SHORT $LN7@Fput
  0008b	80 f9 58	 cmp	 cl, 88			; 00000058H
  0008e	75 02		 jne	 SHORT $LN6@Fput
$LN7@Fput:

; 1426 : 				_Prefix += 2;

  00090	8b d8		 mov	 ebx, eax
$LN6@Fput:

; 1427 : 			}
; 1428 : 		const size_t _Eoff =
; 1429 : 			_CSTD strcspn(&_Buf[0], _Exps);	// find exponent

  00092	52		 push	 edx
  00093	57		 push	 edi
  00094	e8 00 00 00 00	 call	 _strcspn
  00099	89 45 a4	 mov	 DWORD PTR __Eoff$1$[ebp], eax

; 1430 : 		char _Dp[2] = {"."};

  0009c	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  000a1	66 89 45 b8	 mov	 WORD PTR __Dp$[ebp], ax

; 1431 : 		_Dp[0] = _CSTD localeconv()->decimal_point[0];

  000a5	e8 00 00 00 00	 call	 _localeconv
  000aa	8b 00		 mov	 eax, DWORD PTR [eax]
  000ac	8a 00		 mov	 al, BYTE PTR [eax]
  000ae	88 45 b8	 mov	 BYTE PTR __Dp$[ebp], al

; 1432 : 		const size_t _Poff =
; 1433 : 			_CSTD strcspn(&_Buf[0], &_Dp[0]);	// find decimal point

  000b1	8d 45 b8	 lea	 eax, DWORD PTR __Dp$[ebp]
  000b4	50		 push	 eax
  000b5	57		 push	 edi
  000b6	e8 00 00 00 00	 call	 _strcspn
  000bb	83 c4 10	 add	 esp, 16			; 00000010H
  000be	8b f8		 mov	 edi, eax

; 1434 : 
; 1435 : 		const ctype<_Elem>& _Ctype_fac =

  000c0	8d 45 ac	 lea	 eax, DWORD PTR $T9[ebp]
  000c3	8b ce		 mov	 ecx, esi
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  000cb	50		 push	 eax
  000cc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d3	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  000d8	83 c4 04	 add	 esp, 4
  000db	89 45 b4	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000de	8b 4d b0	 mov	 ecx, DWORD PTR $T9[ebp+4]
  000e1	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000e8	85 c9		 test	 ecx, ecx
  000ea	74 11		 je	 SHORT $LN29@Fput
  000ec	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ee	ff 50 08	 call	 DWORD PTR [eax+8]
  000f1	8b c8		 mov	 ecx, eax
  000f3	85 c9		 test	 ecx, ecx
  000f5	74 06		 je	 SHORT $LN29@Fput
  000f7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f9	6a 01		 push	 1
  000fb	ff 10		 call	 DWORD PTR [eax]
$LN29@Fput:

; 1436 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);
; 1437 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

  000fd	33 c0		 xor	 eax, eax
  000ff	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00106	50		 push	 eax
  00107	ff 75 bc	 push	 DWORD PTR __Count$GSCopy$1$[ebp]
  0010a	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0010d	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+20], 7
  00114	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+16], 0
  0011b	66 89 45 d8	 mov	 WORD PTR __Groupstring$[ebp], ax
  0011f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1438 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  00124	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  00128	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0012b	8b 55 b4	 mov	 edx, DWORD PTR __Ctype_fac$1$[ebp]
  0012e	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  00132	8b 4d a8	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
  00135	50		 push	 eax
  00136	8b 45 bc	 mov	 eax, DWORD PTR __Count$GSCopy$1$[ebp]
  00139	8b 12		 mov	 edx, DWORD PTR [edx]
  0013b	03 c1		 add	 eax, ecx
  0013d	50		 push	 eax
  0013e	51		 push	 ecx
  0013f	8b 4d b4	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00142	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00149	ff 52 2c	 call	 DWORD PTR [edx+44]

; 1439 : 
; 1440 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0014c	8d 45 ac	 lea	 eax, DWORD PTR $T8[ebp]
  0014f	8b ce		 mov	 ecx, esi
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00157	50		 push	 eax
  00158	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0015c	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
  00161	8b f0		 mov	 esi, eax
  00163	83 c4 04	 add	 esp, 4
  00166	89 75 a8	 mov	 DWORD PTR __Punct_fac$1$[ebp], esi
  00169	8b 4d b0	 mov	 ecx, DWORD PTR $T8[ebp+4]
  0016c	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00170	85 c9		 test	 ecx, ecx
  00172	74 11		 je	 SHORT $LN161@Fput
  00174	8b 01		 mov	 eax, DWORD PTR [ecx]
  00176	ff 50 08	 call	 DWORD PTR [eax+8]
  00179	8b c8		 mov	 ecx, eax
  0017b	85 c9		 test	 ecx, ecx
  0017d	74 06		 je	 SHORT $LN161@Fput
  0017f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00181	6a 01		 push	 1
  00183	ff 10		 call	 DWORD PTR [eax]
$LN161@Fput:

; 1441 : 		const string _Grouping = _Punct_fac.grouping();

  00185	8d 45 c0	 lea	 eax, DWORD PTR __Grouping$[ebp]
  00188	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0018c	50		 push	 eax
  0018d	8b ce		 mov	 ecx, esi
  0018f	e8 00 00 00 00	 call	 ?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<wchar_t>::grouping

; 1442 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

  00194	8b 06		 mov	 eax, DWORD PTR [esi]
  00196	8b ce		 mov	 ecx, esi
  00198	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0019c	ff 50 10	 call	 DWORD PTR [eax+16]

; 1443 : 
; 1444 : 		if (_Poff != _Count)

  0019f	8b 75 bc	 mov	 esi, DWORD PTR __Count$GSCopy$1$[ebp]
  001a2	0f b7 d0	 movzx	 edx, ax
  001a5	89 55 b4	 mov	 DWORD PTR __Kseparator$1$[ebp], edx
  001a8	3b fe		 cmp	 edi, esi
  001aa	74 1f		 je	 SHORT $LN498@Fput

; 1445 : 			_Groupstring[_Poff] = _Punct_fac.decimal_point();

  001ac	8b 4d a8	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  001af	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b1	ff 50 0c	 call	 DWORD PTR [eax+12]
  001b4	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  001b8	8b 55 b4	 mov	 edx, DWORD PTR __Kseparator$1$[ebp]
  001bb	0f b7 c8	 movzx	 ecx, ax
  001be	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  001c1	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]

; 1446 : 
; 1447 : 		size_t _Off = _Poff == _Count ? _Eoff : _Poff;

  001c5	3b fe		 cmp	 edi, esi
  001c7	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN498@Fput:
  001cb	0f 44 7d a4	 cmove	 edi, DWORD PTR __Eoff$1$[ebp]

; 1448 : 		const char *_Pg = &_Grouping[0];

  001cf	8d 75 c0	 lea	 esi, DWORD PTR __Grouping$[ebp]
  001d2	83 7d d4 10	 cmp	 DWORD PTR __Grouping$[ebp+20], 16 ; 00000010H
  001d6	0f 43 75 c0	 cmovae	 esi, DWORD PTR __Grouping$[ebp]

; 1449 : 		while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1450 : 			&& (size_t)*_Pg < _Off - _Prefix)

  001da	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  001dd	74 34		 je	 SHORT $LN3@Fput
  001df	90		 npad	 1
$LL2@Fput:
  001e0	8a 06		 mov	 al, BYTE PTR [esi]
  001e2	84 c0		 test	 al, al
  001e4	7e 2d		 jle	 SHORT $LN3@Fput
  001e6	0f be c8	 movsx	 ecx, al
  001e9	8b c7		 mov	 eax, edi
  001eb	2b c3		 sub	 eax, ebx
  001ed	3b c8		 cmp	 ecx, eax
  001ef	73 22		 jae	 SHORT $LN3@Fput

; 1451 : 			{	// add thousands separator
; 1452 : 			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);

  001f1	52		 push	 edx
  001f2	2b f9		 sub	 edi, ecx
  001f4	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  001f7	6a 01		 push	 1
  001f9	57		 push	 edi
  001fa	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  001ff	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0

; 1453 : 			if ('\0' < _Pg[1])

  00203	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00206	8b 55 b4	 mov	 edx, DWORD PTR __Kseparator$1$[ebp]
  00209	0f 4e c6	 cmovle	 eax, esi
  0020c	8b f0		 mov	 esi, eax
  0020e	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  00211	75 cd		 jne	 SHORT $LL2@Fput
$LN3@Fput:

; 1454 : 				++_Pg;	// not last group, advance
; 1455 : 			}
; 1456 : 
; 1457 : 		_Count = _Groupstring.size();
; 1458 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1459 : 			|| (size_t)_Iosbase.width() <= _Count

  00213	8b 7d 9c	 mov	 edi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00216	8b 45 e8	 mov	 eax, DWORD PTR __Groupstring$[ebp+16]
  00219	89 45 a4	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], eax
  0021c	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  00220	7c 13		 jl	 SHORT $LN18@Fput
  00222	7f 06		 jg	 SHORT $LN494@Fput
  00224	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00228	76 0b		 jbe	 SHORT $LN18@Fput
$LN494@Fput:
  0022a	8b 77 20	 mov	 esi, DWORD PTR [edi+32]
  0022d	3b f0		 cmp	 esi, eax
  0022f	76 04		 jbe	 SHORT $LN18@Fput
  00231	2b f0		 sub	 esi, eax
  00233	eb 02		 jmp	 SHORT $LN19@Fput
$LN18@Fput:
  00235	33 f6		 xor	 esi, esi
$LN19@Fput:

; 1460 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1461 : 
; 1462 : 		ios_base::fmtflags _Adjustfield =
; 1463 : 			_Iosbase.flags() & ios_base::adjustfield;

  00237	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0023a	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  0023f	83 f8 40	 cmp	 eax, 64			; 00000040H

; 1464 : 		if (_Adjustfield != ios_base::left
; 1465 : 			&& _Adjustfield != ios_base::internal)

  00242	0f 84 97 00 00
	00		 je	 $LN12@Fput
  00248	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0024d	74 48		 je	 SHORT $LN493@Fput

; 1466 : 			{	// put leading fill
; 1467 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  0024f	56		 push	 esi
  00250	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00253	8d 45 ac	 lea	 eax, DWORD PTR $T7[ebp]
  00256	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00259	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0025c	50		 push	 eax
  0025d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00260	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  00265	8b c8		 mov	 ecx, eax

; 1468 : 			_Fillcount = 0;

  00267	33 f6		 xor	 esi, esi

; 1469 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00269	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  0026d	53		 push	 ebx
  0026e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00270	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00273	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00276	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00279	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0027c	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  00280	50		 push	 eax
  00281	ff 71 04	 push	 DWORD PTR [ecx+4]
  00284	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  00287	ff 31		 push	 DWORD PTR [ecx]
  00289	50		 push	 eax
  0028a	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0028d	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  00292	83 c4 30	 add	 esp, 48			; 00000030H
  00295	eb 6a		 jmp	 SHORT $LN499@Fput
$LN493@Fput:

; 1470 : 			}
; 1471 : 		else if (_Adjustfield == ios_base::internal)
; 1472 : 			{	// put internal fill
; 1473 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00297	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  0029b	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0029e	53		 push	 ebx
  0029f	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002a3	50		 push	 eax
  002a4	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  002a7	8d 45 ac	 lea	 eax, DWORD PTR $T5[ebp]
  002aa	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  002ad	50		 push	 eax
  002ae	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  002b6	8b c8		 mov	 ecx, eax

; 1474 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  002b8	56		 push	 esi
  002b9	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  002bc	8b 01		 mov	 eax, DWORD PTR [ecx]
  002be	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  002c1	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  002c4	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002c7	8d 45 ac	 lea	 eax, DWORD PTR $T4[ebp]
  002ca	ff 71 04	 push	 DWORD PTR [ecx+4]
  002cd	ff 31		 push	 DWORD PTR [ecx]
  002cf	50		 push	 eax
  002d0	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002d3	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  002d8	83 c4 30	 add	 esp, 48			; 00000030H

; 1475 : 			_Fillcount = 0;

  002db	33 f6		 xor	 esi, esi

; 1476 : 			}
; 1477 : 		else

  002dd	eb 22		 jmp	 SHORT $LN499@Fput
$LN12@Fput:

; 1478 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  002df	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  002e3	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  002e6	53		 push	 ebx
  002e7	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002eb	50		 push	 eax
  002ec	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  002ef	8d 45 ac	 lea	 eax, DWORD PTR $T3[ebp]
  002f2	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  002f5	50		 push	 eax
  002f6	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002f9	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  002fe	83 c4 18	 add	 esp, 24			; 00000018H
$LN499@Fput:
  00301	8b 10		 mov	 edx, DWORD PTR [eax]

; 1479 : 
; 1480 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00303	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  00307	8b 4d a4	 mov	 ecx, DWORD PTR __Count$GSCopy$2$[ebp]
  0030a	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0030d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00310	89 45 bc	 mov	 DWORD PTR __Dest$3$[ebp], eax
  00313	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00316	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  00319	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  0031d	2b cb		 sub	 ecx, ebx
  0031f	51		 push	 ecx
  00320	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  00323	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00326	50		 push	 eax
  00327	ff 75 bc	 push	 DWORD PTR __Dest$3$[ebp]
  0032a	8d 45 98	 lea	 eax, DWORD PTR $T2[ebp]
  0032d	52		 push	 edx
  0032e	50		 push	 eax
  0032f	53		 push	 ebx
  00330	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put

; 1481 : 		_Iosbase.width(0);
; 1482 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  00335	56		 push	 esi
  00336	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00339	8b 75 a0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0033c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033e	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00341	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00344	50		 push	 eax
  00345	51		 push	 ecx
  00346	56		 push	 esi
  00347	53		 push	 ebx
  00348	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  0034b	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  00352	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
  00359	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  0035e	8b 45 d4	 mov	 eax, DWORD PTR __Grouping$[ebp+20]
  00361	83 c4 30	 add	 esp, 48			; 00000030H
  00364	83 f8 10	 cmp	 eax, 16			; 00000010H
  00367	72 0d		 jb	 SHORT $LN292@Fput
  00369	40		 inc	 eax
  0036a	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0036d	50		 push	 eax
  0036e	ff 75 c0	 push	 DWORD PTR __Grouping$[ebp]
  00371	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN292@Fput:
  00376	8b 4d ec	 mov	 ecx, DWORD PTR __Groupstring$[ebp+20]
  00379	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH
  00380	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+16], 0
  00387	c6 45 c0 00	 mov	 BYTE PTR __Grouping$[ebp], 0
  0038b	83 f9 08	 cmp	 ecx, 8
  0038e	72 0d		 jb	 SHORT $LN495@Fput
  00390	41		 inc	 ecx
  00391	51		 push	 ecx
  00392	ff 75 d8	 push	 DWORD PTR __Groupstring$[ebp]
  00395	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00398	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN495@Fput:
  0039d	8b c6		 mov	 eax, esi

; 1483 : 		}

  0039f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003a9	59		 pop	 ecx
  003aa	5f		 pop	 edi
  003ab	5e		 pop	 esi
  003ac	5b		 pop	 ebx
  003ad	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b0	33 cd		 xor	 ecx, ebp
  003b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b7	8b e5		 mov	 esp, ebp
  003b9	5d		 pop	 ebp
  003ba	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR $T9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$2:
  00016	8d 4d ac	 lea	 ecx, DWORD PTR $T8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$33:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$3:
  00024	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt, COMDAT

; 1383 : 		{	// generate sprintf format for floating-point

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1384 : 		char *_Ptr = _Fmt;
; 1385 : 		*_Ptr++ = '%';
; 1386 : 
; 1387 : 		if (_Flags & ios_base::showpos)

  00003	8b 55 14	 mov	 edx, DWORD PTR __Flags$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Fmt$[ebp]
  0000a	c6 06 25	 mov	 BYTE PTR [esi], 37	; 00000025H
  0000d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00010	f6 c2 20	 test	 dl, 32			; 00000020H
  00013	74 04		 je	 SHORT $LN2@Ffmt

; 1388 : 			*_Ptr++ = '+';

  00015	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  00018	40		 inc	 eax
$LN2@Ffmt:

; 1389 : 		if (_Flags & ios_base::showpoint)

  00019	f6 c2 10	 test	 dl, 16			; 00000010H
  0001c	74 04		 je	 SHORT $LN3@Ffmt

; 1390 : 			*_Ptr++ = '#';

  0001e	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00021	40		 inc	 eax
$LN3@Ffmt:

; 1391 : 		*_Ptr++ = '.';
; 1392 : 		*_Ptr++ = '*';	// for precision argument
; 1393 : 		if (_Spec != '\0')

  00022	8a 4d 10	 mov	 cl, BYTE PTR __Spec$[ebp]
  00025	66 c7 00 2e 2a	 mov	 WORD PTR [eax], 10798	; 00002a2eH
  0002a	83 c0 02	 add	 eax, 2
  0002d	84 c9		 test	 cl, cl
  0002f	74 03		 je	 SHORT $LN4@Ffmt

; 1394 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

  00031	88 08		 mov	 BYTE PTR [eax], cl
  00033	40		 inc	 eax
$LN4@Ffmt:

; 1395 : 
; 1396 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

  00034	8b ca		 mov	 ecx, edx
  00036	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H

; 1397 : 		if (_Flags & ios_base::uppercase)

  0003c	f6 c2 04	 test	 dl, 4
  0003f	74 38		 je	 SHORT $LN5@Ffmt
  00041	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H

; 1398 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00047	74 38		 je	 SHORT $LN16@Ffmt
  00049	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H
  0004f	75 0d		 jne	 SHORT $LN8@Ffmt
  00051	b1 41		 mov	 cl, 65			; 00000041H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00053	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00055	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi

; 1408 : 		}

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN8@Ffmt:
  0005e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H

; 1398 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00064	0f 95 c1	 setne	 cl
  00067	8d 0c 4d 45 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+69]

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  0006e	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00070	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00074	8b c6		 mov	 eax, esi
  00076	5e		 pop	 esi

; 1408 : 		}

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN5@Ffmt:
  00079	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  0007f	75 0d		 jne	 SHORT $LN14@Ffmt
$LN16@Ffmt:
  00081	b1 66		 mov	 cl, 102			; 00000066H
  00083	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00085	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00089	8b c6		 mov	 eax, esi
  0008b	5e		 pop	 esi

; 1408 : 		}

  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN14@Ffmt:
  0008e	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00094	75 0d		 jne	 SHORT $LN12@Ffmt
  00096	b1 61		 mov	 cl, 97			; 00000061H
  00098	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  0009a	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi

; 1408 : 		}

  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
$LN12@Ffmt:
  000a3	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  000a9	0f 95 c1	 setne	 cl
  000ac	8d 0c 4d 65 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+101]
  000b3	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  000b5	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  000b9	8b c6		 mov	 eax, esi
  000bb	5e		 pop	 esi

; 1408 : 		}

  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1373 : 		{	// put formatted void pointer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 1c	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi

; 1374 : 		char _Buf[2 * _MAX_INT_DIG];
; 1375 : 
; 1376 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp?$AA@
  00022	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00025	8b f9		 mov	 edi, ecx
  00027	6a 40		 push	 64			; 00000040H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _sprintf_s
  0002f	50		 push	 eax
  00030	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00033	50		 push	 eax
  00034	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00037	56		 push	 esi
  00038	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0003b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0003e	53		 push	 ebx
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1377 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
; 1378 : 		}

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	83 c4 30	 add	 esp, 48			; 00000030H
  0004b	8b c3		 mov	 eax, ebx
  0004d	33 cd		 xor	 ecx, ebp
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
_TEXT	SEGMENT
__Precision$ = -72					; size = 8
__Ptwo$2 = -68						; size = 4
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
_this$GSCopy$1$ = -60					; size = 4
__Iosbase$GSCopy$1$ = -56				; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1349 : 		{	// put formatted long double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d c4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1350 : 		string _Buf;

  00030	33 d2		 xor	 edx, edx
  00032	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00035	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  0003a	89 45 c0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003d	89 4d c8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
  00040	89 7d e4	 mov	 DWORD PTR __Buf$[ebp+20], edi
  00043	89 55 e0	 mov	 DWORD PTR __Buf$[ebp+16], edx
  00046	88 55 d0	 mov	 BYTE PTR __Buf$[ebp], dl

; 1351 : 		char _Fmt[8];
; 1352 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1353 : 			== ios_base::fixed;

  00049	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1354 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

  0004c	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0004f	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00054	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00057	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  0005a	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
  0005d	85 c9		 test	 ecx, ecx
  0005f	7f 17		 jg	 SHORT $LN4@do_put
  00061	7c 04		 jl	 SHORT $LN314@do_put
  00063	85 f6		 test	 esi, esi
  00065	75 11		 jne	 SHORT $LN4@do_put
$LN314@do_put:
  00067	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0006c	74 0a		 je	 SHORT $LN4@do_put
  0006e	be 06 00 00 00	 mov	 esi, 6
  00073	33 c9		 xor	 ecx, ecx
  00075	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
$LN4@do_put:
  00078	89 4d bc	 mov	 DWORD PTR __Precision$[ebp+4], ecx

; 1355 : 			? 6 : _Iosbase.precision();	// desired precision
; 1356 : 		size_t _Bufsize = (size_t)_Precision;

  0007b	8b ce		 mov	 ecx, esi
  0007d	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H

; 1357 : 		if (_Isfixed && 1e10 < _CSTD fabsl(_Val))

  00082	75 56		 jne	 SHORT $LN2@do_put
  00084	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  00089	0f 28 c1	 movaps	 xmm0, xmm1
  0008c	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00093	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  0009b	76 3d		 jbe	 SHORT $LN2@do_put

; 1358 : 			{	// f or F format
; 1359 : 			int _Ptwo;
; 1360 : 			(void)_CSTD frexpl(_Val, &_Ptwo);

  0009d	8d 45 bc	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000a0	50		 push	 eax
  000a1	83 ec 08	 sub	 esp, 8
  000a4	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000a9	e8 00 00 00 00	 call	 _frexp

; 1361 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000ae	8b 45 bc	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	8b 7d e4	 mov	 edi, DWORD PTR __Buf$[ebp+20]
  000b7	dd d8		 fstp	 ST(0)
  000b9	99		 cdq
  000ba	33 c2		 xor	 eax, edx
  000bc	2b c2		 sub	 eax, edx
  000be	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000c4	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  000c9	f7 e9		 imul	 ecx
  000cb	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ce	8b ca		 mov	 ecx, edx
  000d0	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d3	03 ca		 add	 ecx, edx
  000d5	8b 55 e0	 mov	 edx, DWORD PTR __Buf$[ebp+16]
  000d8	03 ce		 add	 ecx, esi
$LN2@do_put:

; 1362 : 			}
; 1363 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

  000da	83 c1 32	 add	 ecx, 50			; 00000032H
  000dd	3b ca		 cmp	 ecx, edx
  000df	77 13		 ja	 SHORT $LN127@do_put
  000e1	83 ff 10	 cmp	 edi, 16			; 00000010H
  000e4	89 4d e0	 mov	 DWORD PTR __Buf$[ebp+16], ecx
  000e7	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]
  000ea	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Buf$[ebp]
  000ee	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f2	eb 0d		 jmp	 SHORT $LN128@do_put
$LN127@do_put:
  000f4	2b ca		 sub	 ecx, edx
  000f6	6a 00		 push	 0
  000f8	51		 push	 ecx
  000f9	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  000fc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN128@do_put:

; 1364 : 
; 1365 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

  00101	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00105	8d 7d d0	 lea	 edi, DWORD PTR __Buf$[ebp]
  00108	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0010d	0f 43 7d d0	 cmovae	 edi, DWORD PTR __Buf$[ebp]
  00111	83 ec 08	 sub	 esp, 8
  00114	8b 45 c8	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00117	8b 75 e0	 mov	 esi, DWORD PTR __Buf$[ebp+16]
  0011a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011f	ff 75 cc	 push	 DWORD PTR __Precision$1$[ebp]
  00122	ff 70 14	 push	 DWORD PTR [eax+20]
  00125	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00128	6a 4c		 push	 76			; 0000004cH
  0012a	50		 push	 eax
  0012b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
  00133	83 c4 10	 add	 esp, 16			; 00000010H
  00136	50		 push	 eax
  00137	56		 push	 esi
  00138	57		 push	 edi
  00139	e8 00 00 00 00	 call	 _sprintf_s

; 1366 : 			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);
; 1367 : 
; 1368 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

  0013e	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00142	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00145	8b 75 c0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00148	0f 43 4d d0	 cmovae	 ecx, DWORD PTR __Buf$[ebp]
  0014c	50		 push	 eax
  0014d	51		 push	 ecx
  0014e	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00151	ff 75 c8	 push	 DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00154	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00157	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0015a	56		 push	 esi
  0015b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput
  00163	8b 4d e4	 mov	 ecx, DWORD PTR __Buf$[ebp+20]
  00166	83 c4 38	 add	 esp, 56			; 00000038H
  00169	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0016c	72 0d		 jb	 SHORT $LN315@do_put
  0016e	41		 inc	 ecx
  0016f	51		 push	 ecx
  00170	ff 75 d0	 push	 DWORD PTR __Buf$[ebp]
  00173	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00176	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN315@do_put:
  0017b	8b c6		 mov	 eax, esi

; 1369 : 		}

  0017d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00180	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00187	59		 pop	 ecx
  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
_TEXT	SEGMENT
__Precision$ = -72					; size = 8
__Ptwo$2 = -68						; size = 4
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
_this$GSCopy$1$ = -60					; size = 4
__Iosbase$GSCopy$1$ = -56				; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1325 : 		{	// put formatted double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d c4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1326 : 		string _Buf;

  00030	33 d2		 xor	 edx, edx
  00032	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00035	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  0003a	89 45 c0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003d	89 4d c8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
  00040	89 7d e4	 mov	 DWORD PTR __Buf$[ebp+20], edi
  00043	89 55 e0	 mov	 DWORD PTR __Buf$[ebp+16], edx
  00046	88 55 d0	 mov	 BYTE PTR __Buf$[ebp], dl

; 1327 : 		char _Fmt[8];
; 1328 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1329 : 			== ios_base::fixed;

  00049	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1330 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

  0004c	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0004f	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00054	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00057	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  0005a	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
  0005d	85 c9		 test	 ecx, ecx
  0005f	7f 17		 jg	 SHORT $LN4@do_put
  00061	7c 04		 jl	 SHORT $LN310@do_put
  00063	85 f6		 test	 esi, esi
  00065	75 11		 jne	 SHORT $LN4@do_put
$LN310@do_put:
  00067	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0006c	74 0a		 je	 SHORT $LN4@do_put
  0006e	be 06 00 00 00	 mov	 esi, 6
  00073	33 c9		 xor	 ecx, ecx
  00075	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
$LN4@do_put:
  00078	89 4d bc	 mov	 DWORD PTR __Precision$[ebp+4], ecx

; 1331 : 			? 6 : _Iosbase.precision();	// desired precision
; 1332 : 		size_t _Bufsize = (size_t)_Precision;

  0007b	8b ce		 mov	 ecx, esi
  0007d	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H

; 1333 : 		if (_Isfixed && 1e10 < _CSTD fabs(_Val))

  00082	75 56		 jne	 SHORT $LN2@do_put
  00084	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  00089	0f 28 c1	 movaps	 xmm0, xmm1
  0008c	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00093	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  0009b	76 3d		 jbe	 SHORT $LN2@do_put

; 1334 : 			{	// f or F format
; 1335 : 			int _Ptwo;
; 1336 : 			(void)_CSTD frexp(_Val, &_Ptwo);

  0009d	8d 45 bc	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000a0	50		 push	 eax
  000a1	83 ec 08	 sub	 esp, 8
  000a4	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000a9	e8 00 00 00 00	 call	 _frexp

; 1337 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000ae	8b 45 bc	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	8b 7d e4	 mov	 edi, DWORD PTR __Buf$[ebp+20]
  000b7	dd d8		 fstp	 ST(0)
  000b9	99		 cdq
  000ba	33 c2		 xor	 eax, edx
  000bc	2b c2		 sub	 eax, edx
  000be	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000c4	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  000c9	f7 e9		 imul	 ecx
  000cb	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ce	8b ca		 mov	 ecx, edx
  000d0	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d3	03 ca		 add	 ecx, edx
  000d5	8b 55 e0	 mov	 edx, DWORD PTR __Buf$[ebp+16]
  000d8	03 ce		 add	 ecx, esi
$LN2@do_put:

; 1338 : 			}
; 1339 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

  000da	83 c1 32	 add	 ecx, 50			; 00000032H
  000dd	3b ca		 cmp	 ecx, edx
  000df	77 13		 ja	 SHORT $LN123@do_put
  000e1	83 ff 10	 cmp	 edi, 16			; 00000010H
  000e4	89 4d e0	 mov	 DWORD PTR __Buf$[ebp+16], ecx
  000e7	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]
  000ea	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Buf$[ebp]
  000ee	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f2	eb 0d		 jmp	 SHORT $LN124@do_put
$LN123@do_put:
  000f4	2b ca		 sub	 ecx, edx
  000f6	6a 00		 push	 0
  000f8	51		 push	 ecx
  000f9	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  000fc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN124@do_put:

; 1340 : 
; 1341 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

  00101	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00105	8d 7d d0	 lea	 edi, DWORD PTR __Buf$[ebp]
  00108	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0010d	0f 43 7d d0	 cmovae	 edi, DWORD PTR __Buf$[ebp]
  00111	83 ec 08	 sub	 esp, 8
  00114	8b 45 c8	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00117	8b 75 e0	 mov	 esi, DWORD PTR __Buf$[ebp+16]
  0011a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011f	ff 75 cc	 push	 DWORD PTR __Precision$1$[ebp]
  00122	ff 70 14	 push	 DWORD PTR [eax+20]
  00125	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00128	6a 00		 push	 0
  0012a	50		 push	 eax
  0012b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
  00133	83 c4 10	 add	 esp, 16			; 00000010H
  00136	50		 push	 eax
  00137	56		 push	 esi
  00138	57		 push	 edi
  00139	e8 00 00 00 00	 call	 _sprintf_s

; 1342 : 			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val);
; 1343 : 
; 1344 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

  0013e	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00142	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00145	8b 75 c0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00148	0f 43 4d d0	 cmovae	 ecx, DWORD PTR __Buf$[ebp]
  0014c	50		 push	 eax
  0014d	51		 push	 ecx
  0014e	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00151	ff 75 c8	 push	 DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00154	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00157	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0015a	56		 push	 esi
  0015b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput
  00163	8b 4d e4	 mov	 ecx, DWORD PTR __Buf$[ebp+20]
  00166	83 c4 38	 add	 esp, 56			; 00000038H
  00169	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0016c	72 0d		 jb	 SHORT $LN311@do_put
  0016e	41		 inc	 ecx
  0016f	51		 push	 ecx
  00170	ff 75 d0	 push	 DWORD PTR __Buf$[ebp]
  00173	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00176	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN311@do_put:
  0017b	8b c6		 mov	 eax, esi

; 1345 : 		}

  0017d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00180	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00187	59		 pop	 ecx
  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1315 : 		{	// put formatted unsigned long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1316 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1317 : 
; 1318 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00024	ff 76 14	 push	 DWORD PTR [esi+20]
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_02CLHGNPPK@Lu?$AA@
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003a	6a 40		 push	 64			; 00000040H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _sprintf_s
  00042	50		 push	 eax
  00043	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00046	50		 push	 eax
  00047	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0004a	56		 push	 esi
  0004b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004e	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00051	53		 push	 ebx
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1319 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
; 1320 : 				_Iosbase.flags()), _Val)));
; 1321 : 		}

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	83 c4 34	 add	 esp, 52			; 00000034H
  0005e	8b c3		 mov	 eax, ebx
  00060	33 cd		 xor	 ecx, ebp
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1305 : 		{	// put formatted long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1306 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1307 : 
; 1308 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00024	ff 76 14	 push	 DWORD PTR [esi+20]
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_02HIKPPMOK@Ld?$AA@
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003a	6a 40		 push	 64			; 00000040H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _sprintf_s
  00042	50		 push	 eax
  00043	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00046	50		 push	 eax
  00047	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0004a	56		 push	 esi
  0004b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004e	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00051	53		 push	 ebx
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1309 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
; 1310 : 				_Iosbase.flags()), _Val)));
; 1311 : 		}

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	83 c4 34	 add	 esp, 52			; 00000034H
  0005e	8b c3		 mov	 eax, ebx
  00060	33 cd		 xor	 ecx, ebp
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1295 : 		{	// put formatted unsigned long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1296 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1297 : 
; 1298 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 76 14	 push	 DWORD PTR [esi+20]
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02BDDLJJBK@lu?$AA@
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	50		 push	 eax
  00034	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00037	6a 40		 push	 64			; 00000040H
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _sprintf_s
  0003f	50		 push	 eax
  00040	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00043	50		 push	 eax
  00044	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00047	56		 push	 esi
  00048	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0004e	53		 push	 ebx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1299 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
; 1300 : 				_Iosbase.flags()), _Val)));
; 1301 : 		}

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	83 c4 30	 add	 esp, 48			; 00000030H
  0005b	8b c3		 mov	 eax, ebx
  0005d	33 cd		 xor	 ecx, ebp
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1285 : 		{	// put formatted long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1286 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1287 : 
; 1288 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 76 14	 push	 DWORD PTR [esi+20]
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02EAOCLKAK@ld?$AA@
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	50		 push	 eax
  00034	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00037	6a 40		 push	 64			; 00000040H
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _sprintf_s
  0003f	50		 push	 eax
  00040	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00043	50		 push	 eax
  00044	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00047	56		 push	 esi
  00048	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0004e	53		 push	 ebx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1289 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
; 1290 : 				_Iosbase.flags()), _Val)));
; 1291 : 		}

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	83 c4 30	 add	 esp, 48			; 00000030H
  0005b	8b c3		 mov	 eax, ebx
  0005d	33 cd		 xor	 ecx, ebp
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
_TEXT	SEGMENT
$T2 = -88						; size = 8
__Fill$GSCopy$1$ = -80					; size = 4
$T3 = -76						; size = 8
$T4 = -76						; size = 8
__Dest$3$ = -72						; size = 4
_this$GSCopy$1$ = -68					; size = 4
$T5 = -64						; size = 24
$T6 = -64						; size = 24
__Str$7 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 1
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1255 : 		{	// put formatted bool to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d bc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002e	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00031	0f b7 7d 18	 movzx	 edi, WORD PTR __Fill$[ebp]
  00035	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00038	89 7d b0	 mov	 DWORD PTR __Fill$GSCopy$1$[ebp], edi

; 1256 : 		_DEBUG_POINTER(_Dest);
; 1257 : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

  0003b	f7 46 14 00 40
	00 00		 test	 DWORD PTR [esi+20], 16384 ; 00004000H
  00042	75 18		 jne	 SHORT $LN2@do_put

; 1258 : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));

  00044	0f b6 45 1c	 movzx	 eax, BYTE PTR __Val$[ebp]
  00048	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004a	50		 push	 eax
  0004b	57		 push	 edi
  0004c	56		 push	 esi
  0004d	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00050	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00053	53		 push	 ebx
  00054	ff 52 24	 call	 DWORD PTR [edx+36]
  00057	e9 7d 01 00 00	 jmp	 $LN964@do_put
$LN2@do_put:

; 1259 : 		else
; 1260 : 			{	// put "false" or "true"
; 1261 : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0005c	8d 45 b4	 lea	 eax, DWORD PTR $T4[ebp]
  0005f	8b ce		 mov	 ecx, esi
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00067	50		 push	 eax
  00068	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006f	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
  00074	83 c4 04	 add	 esp, 4
  00077	8b f8		 mov	 edi, eax
  00079	8b 4d b8	 mov	 ecx, DWORD PTR $T4[ebp+4]
  0007c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00083	85 c9		 test	 ecx, ecx
  00085	74 11		 je	 SHORT $LN19@do_put
  00087	8b 11		 mov	 edx, DWORD PTR [ecx]
  00089	ff 52 08	 call	 DWORD PTR [edx+8]
  0008c	85 c0		 test	 eax, eax
  0008e	74 08		 je	 SHORT $LN19@do_put
  00090	8b 10		 mov	 edx, DWORD PTR [eax]
  00092	8b c8		 mov	 ecx, eax
  00094	6a 01		 push	 1
  00096	ff 12		 call	 DWORD PTR [edx]
$LN19@do_put:

; 1262 : 			_Mystr _Str;

  00098	33 c0		 xor	 eax, eax
  0009a	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+20], 7
  000a1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+16], 0
  000a8	66 89 45 d8	 mov	 WORD PTR __Str$7[ebp], ax

; 1263 : 			if (_Val)

  000ac	80 7d 1c 00	 cmp	 BYTE PTR __Val$[ebp], 0

; 1264 : 				_Str.assign(_Punct_fac.truename());

  000b0	8d 45 c0	 lea	 eax, DWORD PTR $T6[ebp]
  000b3	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000ba	8b cf		 mov	 ecx, edi
  000bc	50		 push	 eax
  000bd	74 09		 je	 SHORT $LN4@do_put
  000bf	e8 00 00 00 00	 call	 ?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::truename
  000c4	8b f8		 mov	 edi, eax

; 1265 : 			else

  000c6	eb 07		 jmp	 SHORT $LN1068@do_put
$LN4@do_put:

; 1266 : 				_Str.assign(_Punct_fac.falsename());

  000c8	e8 00 00 00 00	 call	 ?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::falsename
  000cd	8b f8		 mov	 edi, eax
$LN1068@do_put:
  000cf	8d 45 d8	 lea	 eax, DWORD PTR __Str$7[ebp]
  000d2	3b c7		 cmp	 eax, edi
  000d4	74 2e		 je	 SHORT $LN517@do_put
  000d6	8b 45 ec	 mov	 eax, DWORD PTR __Str$7[ebp+20]
  000d9	83 f8 08	 cmp	 eax, 8
  000dc	72 0d		 jb	 SHORT $LN692@do_put
  000de	40		 inc	 eax
  000df	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  000e2	50		 push	 eax
  000e3	ff 75 d8	 push	 DWORD PTR __Str$7[ebp]
  000e6	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN692@do_put:
  000eb	33 c0		 xor	 eax, eax
  000ed	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+20], 7
  000f4	57		 push	 edi
  000f5	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  000f8	89 45 e8	 mov	 DWORD PTR __Str$7[ebp+16], eax
  000fb	66 89 45 d8	 mov	 WORD PTR __Str$7[ebp], ax
  000ff	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN517@do_put:
  00104	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp+20]
  00107	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0010b	83 f8 08	 cmp	 eax, 8
  0010e	72 0d		 jb	 SHORT $LN798@do_put
  00110	40		 inc	 eax
  00111	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  00114	50		 push	 eax
  00115	ff 75 c0	 push	 DWORD PTR $T5[ebp]
  00118	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN798@do_put:

; 1267 : 
; 1268 : 			size_t _Fillcount = _Iosbase.width() <= 0
; 1269 : 				|| (size_t)_Iosbase.width() <= _Str.size()

  0011d	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00121	8b 4d e8	 mov	 ecx, DWORD PTR __Str$7[ebp+16]
  00124	7c 13		 jl	 SHORT $LN8@do_put
  00126	7f 06		 jg	 SHORT $LN1061@do_put
  00128	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0012c	76 0b		 jbe	 SHORT $LN8@do_put
$LN1061@do_put:
  0012e	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00131	3b f9		 cmp	 edi, ecx
  00133	76 04		 jbe	 SHORT $LN8@do_put
  00135	2b f9		 sub	 edi, ecx
  00137	eb 02		 jmp	 SHORT $LN9@do_put
$LN8@do_put:
  00139	33 ff		 xor	 edi, edi
$LN9@do_put:

; 1270 : 					? 0 : (size_t)_Iosbase.width() - _Str.size();
; 1271 : 
; 1272 : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

  0013b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0013e	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00143	83 f8 40	 cmp	 eax, 64			; 00000040H
  00146	74 2b		 je	 SHORT $LN1062@do_put

; 1273 : 				{	// put leading fill
; 1274 : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

  00148	57		 push	 edi
  00149	ff 75 b0	 push	 DWORD PTR __Fill$GSCopy$1$[ebp]
  0014c	8d 45 b4	 lea	 eax, DWORD PTR $T3[ebp]
  0014f	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00152	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00155	50		 push	 eax
  00156	ff 75 bc	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  00159	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep

; 1275 : 				_Fillcount = 0;

  0015e	8b 4d e8	 mov	 ecx, DWORD PTR __Str$7[ebp+16]
  00161	83 c4 18	 add	 esp, 24			; 00000018H
  00164	33 ff		 xor	 edi, edi
  00166	8b 10		 mov	 edx, DWORD PTR [eax]
  00168	89 55 0c	 mov	 DWORD PTR __Dest$[ebp], edx
  0016b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016e	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00171	eb 06		 jmp	 SHORT $LN1069@do_put
$LN1062@do_put:
  00173	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00176	8b 55 0c	 mov	 edx, DWORD PTR __Dest$[ebp]
$LN1069@do_put:

; 1276 : 				}
; 1277 : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

  00179	83 7d ec 08	 cmp	 DWORD PTR __Str$7[ebp+20], 8
  0017d	89 45 b8	 mov	 DWORD PTR __Dest$3$[ebp], eax
  00180	8d 45 d8	 lea	 eax, DWORD PTR __Str$7[ebp]
  00183	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Str$7[ebp]
  00187	51		 push	 ecx
  00188	50		 push	 eax
  00189	ff 75 b8	 push	 DWORD PTR __Dest$3$[ebp]
  0018c	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  0018f	52		 push	 edx
  00190	50		 push	 eax
  00191	ff 75 bc	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  00194	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put

; 1278 : 			_Iosbase.width(0);
; 1279 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  00199	57		 push	 edi
  0019a	ff 75 b0	 push	 DWORD PTR __Fill$GSCopy$1$[ebp]
  0019d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019f	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  001a2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a5	50		 push	 eax
  001a6	51		 push	 ecx
  001a7	53		 push	 ebx
  001a8	ff 75 bc	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  001ab	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
  001ae	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  001b5	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  001bc	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  001c1	8b 45 ec	 mov	 eax, DWORD PTR __Str$7[ebp+20]
  001c4	83 c4 30	 add	 esp, 48			; 00000030H
  001c7	83 f8 08	 cmp	 eax, 8
  001ca	72 0d		 jb	 SHORT $LN964@do_put
  001cc	40		 inc	 eax
  001cd	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  001d0	50		 push	 eax
  001d1	ff 75 d8	 push	 DWORD PTR __Str$7[ebp]
  001d4	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN964@do_put:
  001d9	8b c3		 mov	 eax, ebx

; 1280 : 			}
; 1281 : 		}

  001db	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e5	59		 pop	 ecx
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	33 cd		 xor	 ecx, ebp
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$32:
  00016	e8 00 00 00 00	 call	 ___std_terminate
  0001b	c3		 ret	 0
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$134:
  0001c	e8 00 00 00 00	 call	 ___std_terminate
  00021	c3		 ret	 0
__ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::put, COMDAT
; _this$ = ecx

; 1224 : 		{	// put formatted long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1225 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

  00003	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  0000b	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Iosbase$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00014	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	ff 50 1c	 call	 DWORD PTR [eax+28]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1226 : 		}

  00020	5d		 pop	 ebp
  00021	c2 1c 00	 ret	 28			; 0000001cH
?put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??0?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >, COMDAT
; _this$ = ecx

; 1197 : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1196 : 		: locale::facet(_Refs)

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1198 : 		_Init(_Lobj);
; 1199 : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??0?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Init@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Init, COMDAT
; _this$ = ecx

; 1184 : 		}

  00000	c2 04 00	 ret	 4
?_Init@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >, COMDAT
; _this$ = ecx

; 1180 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getcat, COMDAT

; 1168 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1169 : 		if (_Ppf != 0 && *_Ppf == 0)

  00028	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00030	85 ff		 test	 edi, edi
  00032	74 63		 je	 SHORT $LN30@Getcat
  00034	39 1f		 cmp	 DWORD PTR [edi], ebx
  00036	75 5f		 jne	 SHORT $LN30@Getcat

; 1170 : 			*_Ppf = new num_put<_Elem, _OutIt>(

  00038	6a 08		 push	 8
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 75 08	 mov	 DWORD PTR $T4[ebp], esi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 f6		 test	 esi, esi
  0004c	74 38		 je	 SHORT $LN4@Getcat
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00051	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	bb 01 00 00 00	 mov	 ebx, 1
  00077	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0007e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@
  00084	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00086	33 f6		 xor	 esi, esi
$LN5@Getcat:
  00088	89 37		 mov	 DWORD PTR [edi], esi
  0008a	f6 c3 01	 test	 bl, 1
  0008d	74 08		 je	 SHORT $LN30@Getcat
  0008f	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00092	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN30@Getcat:

; 1171 : 				_Locinfo(_Ploc->c_str()));
; 1172 : 		return (_X_NUMERIC);

  00097	b8 04 00 00 00	 mov	 eax, 4

; 1173 : 		}

  0009c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a6	59		 pop	 ecx
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 08		 push	 8
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 142  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 143  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

  00025	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0002a	84 c0		 test	 al, al
  0002c	75 07		 jne	 SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN2@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00047	85 c9		 test	 ecx, ecx
  00049	74 05		 je	 SHORT $LN5@sentry
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 122  : 			: _Sentry_base(_Ostr)

  0002a	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  0002d	89 37		 mov	 DWORD PTR [edi], esi
  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00038	85 c9		 test	 ecx, ecx
  0003a	74 05		 je	 SHORT $LN6@sentry
  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN6@sentry:

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004d	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00052	75 11		 jne	 SHORT $LN2@sentry
  00054	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00058	85 c9		 test	 ecx, ecx
  0005a	74 09		 je	 SHORT $LN2@sentry
  0005c	3b ce		 cmp	 ecx, esi
  0005e	74 05		 je	 SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

  00060	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
$LN2@sentry:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006a	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0006f	0f 94 c0	 sete	 al
  00072	88 47 04	 mov	 BYTE PTR [edi+4], al

; 127  : 			}

  00075	8b c7		 mov	 eax, edi
  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 107  : 			if (_Myostr.rdbuf() != 0)

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 109  : 			}

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   : 			: _Myostr(_Ostr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00006	56		 push	 esi

; 100  : 			{	// lock the stream buffer, if there

  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 101  : 			if (_Myostr.rdbuf() != 0)

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 103  : 			}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 01		 add	 eax, DWORD PTR [ecx]
  00005	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00008	13 51 04	 adc	 edx, DWORD PTR [ecx+4]

; 69   : 		}

  0000b	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with stream offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	89 01		 mov	 DWORD PTR [ecx], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp+4]
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 44   : 		}

  00011	8b c1		 mov	 eax, ecx
  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00021	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEAAUHostDevice@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEAAUHostDevice@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::operator*, COMDAT
; _this$ = ecx

; 331  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 332  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEAAUHostDevice@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QAE@PAUHostDevice@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QAE@PAUHostDevice@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 312  : 		: _Mybase(_Parg, _Pvector)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QAE@PAUHostDevice@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::construct<HostDevice,HostDevice const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UHostDevice@@ABU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::construct<HostDevice,HostDevice const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::construct<HostDevice,HostDevice &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UHostDevice@@AAU1@@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::construct<HostDevice,HostDevice &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@UHostDevice@@@std@@YAPAUHostDevice@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@UHostDevice@@@std@@YAPAUHostDevice@@PAU1@@Z PROC ; std::_Unfancy<HostDevice>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@UHostDevice@@@std@@YAPAUHostDevice@@PAU1@@Z ENDP ; std::_Unfancy<HostDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUHostDevice@@@std@@YAPBUHostDevice@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUHostDevice@@@std@@YAPBUHostDevice@@ABU1@@Z PROC ; std::addressof<HostDevice const >, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUHostDevice@@@std@@YAPBUHostDevice@@ABU1@@Z ENDP ; std::addressof<HostDevice const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ??1Finally8982@?5??WipeHiddenOSCreationConfig@@YAHXZ@QAE@XZ
_TEXT	SEGMENT
??1Finally8982@?5??WipeHiddenOSCreationConfig@@YAHXZ@QAE@XZ PROC ; `WipeHiddenOSCreationConfig'::`6'::Finally8982::~Finally8982, COMDAT
; _this$ = ecx

; 8982 : 			finally_do ({ NormalCursor(); });

  00000	e9 00 00 00 00	 jmp	 _NormalCursor
??1Finally8982@?5??WipeHiddenOSCreationConfig@@YAHXZ@QAE@XZ ENDP ; `WipeHiddenOSCreationConfig'::`6'::Finally8982::~Finally8982
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
_TEXT	SEGMENT
$T2 = -96						; size = 20
$T3 = -76						; size = 20
$T4 = -56						; size = 20
__Ok$ = -36						; size = 8
__Pad$ = -36						; size = 8
__State$ = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -24						; size = 4
tv1240 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
tv1233 = 12						; size = 4
__Val$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 866  : 	{	// insert NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 867  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 868  : 
; 869  : 	ios_base::iostate _State = ios_base::goodbit;
; 870  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0002e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
  00035	66 83 38 00	 cmp	 WORD PTR [eax], 0
  00039	75 04		 jne	 SHORT $LN26@operator
  0003b	33 db		 xor	 ebx, ebx
  0003d	eb 14		 jmp	 SHORT $LN27@operator
$LN26@operator:
  0003f	8b d8		 mov	 ebx, eax
  00041	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
$LL257@operator:
  00044	66 8b 03	 mov	 ax, WORD PTR [ebx]
  00047	83 c3 02	 add	 ebx, 2
  0004a	66 85 c0	 test	 ax, ax
  0004d	75 f5		 jne	 SHORT $LL257@operator
  0004f	2b d9		 sub	 ebx, ecx
  00051	d1 fb		 sar	 ebx, 1
$LN27@operator:

; 871  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  00053	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005b	8b 7c 08 24	 mov	 edi, DWORD PTR [eax+ecx+36]
  0005f	8b 74 08 20	 mov	 esi, DWORD PTR [eax+ecx+32]
  00063	85 ff		 test	 edi, edi
  00065	7c 17		 jl	 SHORT $LN17@operator
  00067	7f 0e		 jg	 SHORT $LN259@operator
  00069	85 f6		 test	 esi, esi
  0006b	74 11		 je	 SHORT $LN17@operator
  0006d	85 ff		 test	 edi, edi
  0006f	7c 0d		 jl	 SHORT $LN17@operator
  00071	7f 04		 jg	 SHORT $LN259@operator
  00073	3b f3		 cmp	 esi, ebx
  00075	76 07		 jbe	 SHORT $LN17@operator
$LN259@operator:
  00077	2b f3		 sub	 esi, ebx
  00079	83 df 00	 sbb	 edi, 0
  0007c	eb 0e		 jmp	 SHORT $LN18@operator
$LN17@operator:
  0007e	0f 57 c0	 xorps	 xmm0, xmm0
  00081	66 0f 13 45 dc	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00086	8b 7d e0	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  00089	8b 75 dc	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN18@operator:

; 872  : 		? 0 : _Ostr.width() - _Count;
; 873  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 54 08 38	 mov	 edx, DWORD PTR [eax+ecx+56]
  00090	89 4d dc	 mov	 DWORD PTR __Ok$[ebp], ecx
  00093	85 d2		 test	 edx, edx
  00095	74 0a		 je	 SHORT $LN39@operator
  00097	8b 02		 mov	 eax, DWORD PTR [edx]
  00099	8b ca		 mov	 ecx, edx
  0009b	ff 50 04	 call	 DWORD PTR [eax+4]
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
$LN39@operator:
  000a1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ad	83 7c 08 0c 00	 cmp	 DWORD PTR [eax+ecx+12], 0
  000b2	75 16		 jne	 SHORT $LN35@operator
  000b4	8b 44 08 3c	 mov	 eax, DWORD PTR [eax+ecx+60]
  000b8	85 c0		 test	 eax, eax
  000ba	74 0e		 je	 SHORT $LN35@operator
  000bc	3b c1		 cmp	 eax, ecx
  000be	74 0a		 je	 SHORT $LN35@operator
  000c0	8b c8		 mov	 ecx, eax
  000c2	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
$LN35@operator:
  000ca	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cc	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000cf	83 7c 0a 0c 00	 cmp	 DWORD PTR [edx+ecx+12], 0
  000d4	0f 94 c0	 sete	 al
  000d7	88 45 e0	 mov	 BYTE PTR __Ok$[ebp+4], al
  000da	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 874  : 
; 875  : 	if (!_Ok)

  000e1	84 c0		 test	 al, al
  000e3	75 0a		 jne	 SHORT $LN8@operator

; 876  : 		_State |= ios_base::badbit;

  000e5	b9 04 00 00 00	 mov	 ecx, 4

; 877  : 	else

  000ea	e9 7d 01 00 00	 jmp	 $LN274@operator
$LN8@operator:

; 878  : 		{	// state okay, insert
; 879  : 		_TRY_IO_BEGIN
; 880  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000ef	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  000f3	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000f8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000fc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000ff	0f 84 9d 00 00
	00		 je	 $LN254@operator
$LL4@operator:

; 881  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00105	85 ff		 test	 edi, edi
  00107	0f 8c 8e 00 00
	00		 jl	 $LN3@operator
  0010d	7f 08		 jg	 SHORT $LN260@operator
  0010f	85 f6		 test	 esi, esi
  00111	0f 84 84 00 00
	00		 je	 $LN3@operator
$LN260@operator:

; 882  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00117	8b 01		 mov	 eax, DWORD PTR [ecx]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	0f b7 54 08 40	 movzx	 edx, WORD PTR [eax+ecx+64]
  00121	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00125	89 55 e8	 mov	 DWORD PTR $T6[ebp], edx
  00128	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0012b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0012e	74 21		 je	 SHORT $LN69@operator
  00130	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00133	8b 00		 mov	 eax, DWORD PTR [eax]
  00135	85 c0		 test	 eax, eax
  00137	7e 18		 jle	 SHORT $LN69@operator
  00139	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0013c	48		 dec	 eax
  0013d	89 02		 mov	 DWORD PTR [edx], eax
  0013f	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00142	8b 11		 mov	 edx, DWORD PTR [ecx]
  00144	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00147	89 01		 mov	 DWORD PTR [ecx], eax
  00149	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  0014c	66 89 02	 mov	 WORD PTR [edx], ax
  0014f	eb 06		 jmp	 SHORT $LN275@operator
$LN69@operator:
  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	52		 push	 edx
  00154	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN275@operator:
  00157	0f b7 c0	 movzx	 eax, ax
  0015a	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0015f	66 3b c8	 cmp	 cx, ax
  00162	75 29		 jne	 SHORT $LN2@operator
$LN261@operator:

; 883  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 884  : 					{	// insertion failed, quit
; 885  : 					_State |= ios_base::badbit;

  00164	b9 04 00 00 00	 mov	 ecx, 4
$LN268@operator:
  00169	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
$LN6@operator:

; 900  : 					}
; 901  : 		_Ostr.width(0);

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00175	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00178	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  00180	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
  00188	e9 e2 00 00 00	 jmp	 $LN22@operator
$LN2@operator:

; 881  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  0018d	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00190	83 c6 ff	 add	 esi, -1
  00193	83 d7 ff	 adc	 edi, -1
  00196	e9 6a ff ff ff	 jmp	 $LL4@operator
$LN3@operator:
  0019b	33 c9		 xor	 ecx, ecx

; 886  : 					break;
; 887  : 					}
; 888  : 
; 889  : 		if (_State == ios_base::goodbit
; 890  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  0019d	75 ca		 jne	 SHORT $LN268@operator
  0019f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
$LN254@operator:
  001a2	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a4	6a 00		 push	 0
  001a6	53		 push	 ebx
  001a7	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  001aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001ad	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  001b1	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b3	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  001b6	ff d0		 call	 eax
  001b8	3b c3		 cmp	 eax, ebx
  001ba	75 a8		 jne	 SHORT $LN261@operator
  001bc	85 d2		 test	 edx, edx
  001be	75 a4		 jne	 SHORT $LN261@operator
  001c0	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
$LL263@operator:

; 891  : 			_State |= ios_base::badbit;
; 892  : 
; 893  : 		if (_State == ios_base::goodbit)
; 894  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  001c3	85 ff		 test	 edi, edi
  001c5	7c 65		 jl	 SHORT $LN266@operator
  001c7	7f 04		 jg	 SHORT $LN262@operator
  001c9	85 f6		 test	 esi, esi
  001cb	74 5f		 je	 SHORT $LN266@operator
$LN262@operator:

; 895  : 				if (_Traits::eq_int_type(_Traits::eof(),

  001cd	8b 03		 mov	 eax, DWORD PTR [ebx]
  001cf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d2	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  001d6	0f b7 54 18 40	 movzx	 edx, WORD PTR [eax+ebx+64]
  001db	89 55 e8	 mov	 DWORD PTR $T5[ebp], edx
  001de	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  001e1	83 38 00	 cmp	 DWORD PTR [eax], 0
  001e4	74 21		 je	 SHORT $LN99@operator
  001e6	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  001e9	8b 00		 mov	 eax, DWORD PTR [eax]
  001eb	85 c0		 test	 eax, eax
  001ed	7e 18		 jle	 SHORT $LN99@operator
  001ef	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001f2	48		 dec	 eax
  001f3	89 02		 mov	 DWORD PTR [edx], eax
  001f5	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  001f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fa	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  001fd	89 01		 mov	 DWORD PTR [ecx], eax
  001ff	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00202	66 89 02	 mov	 WORD PTR [edx], ax
  00205	eb 06		 jmp	 SHORT $LN276@operator
$LN99@operator:
  00207	8b 01		 mov	 eax, DWORD PTR [ecx]
  00209	52		 push	 edx
  0020a	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN276@operator:
  0020d	0f b7 c0	 movzx	 eax, ax
  00210	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00215	66 3b c8	 cmp	 cx, ax
  00218	75 0a		 jne	 SHORT $LN5@operator

; 896  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 897  : 					{	// insertion failed, quit
; 898  : 					_State |= ios_base::badbit;

  0021a	33 c9		 xor	 ecx, ecx
  0021c	83 c9 04	 or	 ecx, 4

; 899  : 					break;

  0021f	e9 48 ff ff ff	 jmp	 $LN6@operator
$LN5@operator:

; 891  : 			_State |= ios_base::badbit;
; 892  : 
; 893  : 		if (_State == ios_base::goodbit)
; 894  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00224	83 c6 ff	 add	 esi, -1
  00227	83 d7 ff	 adc	 edi, -1
  0022a	eb 97		 jmp	 SHORT $LL263@operator
$LN266@operator:
  0022c	33 c9		 xor	 ecx, ecx
  0022e	e9 39 ff ff ff	 jmp	 $LN6@operator
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$0:

; 902  : 		_CATCH_IO_(_Ostr)

  00233	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00236	8b 01		 mov	 eax, DWORD PTR [ecx]
  00238	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0023b	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  0023f	03 d1		 add	 edx, ecx
  00241	83 c8 04	 or	 eax, 4
  00244	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00248	75 03		 jne	 SHORT $LN128@operator
  0024a	83 c8 04	 or	 eax, 4
$LN128@operator:
  0024d	83 e0 17	 and	 eax, 23			; 00000017H
  00250	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00253	85 42 10	 test	 DWORD PTR [edx+16], eax
  00256	0f 85 0e 01 00
	00		 jne	 $LN131@operator
  0025c	b8 00 00 00 00	 mov	 eax, $LN23@operator
  00261	c3		 ret	 0
$LN23@operator:
  00262	8b 4d e4	 mov	 ecx, DWORD PTR __State$[ebp]
  00265	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN274@operator:
  0026c	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
$LN22@operator:

; 903  : 		}
; 904  : 
; 905  : 	_Ostr.setstate(_State);

  0026f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00271	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00274	03 d3		 add	 edx, ebx
  00276	85 c9		 test	 ecx, ecx
  00278	0f 84 a8 00 00
	00		 je	 $LN196@operator
  0027e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00281	0b c1		 or	 eax, ecx
  00283	8b c8		 mov	 ecx, eax
  00285	83 c9 04	 or	 ecx, 4
  00288	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0028c	0f 45 c8	 cmovne	 ecx, eax
  0028f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00292	83 e1 17	 and	 ecx, 23			; 00000017H
  00295	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00298	23 c1		 and	 eax, ecx
  0029a	0f 84 86 00 00
	00		 je	 $LN196@operator
  002a0	a8 04		 test	 al, 4
  002a2	74 2a		 je	 SHORT $LN193@operator
  002a4	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  002a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  002ae	50		 push	 eax
  002af	6a 01		 push	 1
  002b1	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  002b4	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  002b9	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  002be	8d 45 c8	 lea	 eax, DWORD PTR $T4[ebp]
  002c1	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  002c8	50		 push	 eax
  002c9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN277@operator:
$LN193@operator:
  002ce	a8 02		 test	 al, 2
  002d0	74 2a		 je	 SHORT $LN195@operator
  002d2	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  002dc	50		 push	 eax
  002dd	6a 01		 push	 1
  002df	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  002e2	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  002e7	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  002ec	8d 45 b4	 lea	 eax, DWORD PTR $T3[ebp]
  002ef	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  002f6	50		 push	 eax
  002f7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN278@operator:
$LN195@operator:
  002fc	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00301	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  00306	50		 push	 eax
  00307	6a 01		 push	 1
  00309	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  0030c	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00311	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00316	8d 45 a0	 lea	 eax, DWORD PTR $T2[ebp]
  00319	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN279@operator:
$LN196@operator:

; 906  : 	return (_Ostr);

  00326	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  0032d	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  00332	8b 75 dc	 mov	 esi, DWORD PTR __Ok$[ebp]
  00335	84 c0		 test	 al, al
  00337	75 07		 jne	 SHORT $LN237@operator
  00339	8b ce		 mov	 ecx, esi
  0033b	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN237@operator:
  00340	8b 06		 mov	 eax, DWORD PTR [esi]
  00342	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  00346	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00349	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0034d	85 c9		 test	 ecx, ecx
  0034f	74 05		 je	 SHORT $LN241@operator
  00351	8b 11		 mov	 edx, DWORD PTR [ecx]
  00353	ff 52 08	 call	 DWORD PTR [edx+8]
$LN241@operator:
  00356	8b c3		 mov	 eax, ebx

; 907  : 	}

  00358	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0035b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00362	59		 pop	 ecx
  00363	5f		 pop	 edi
  00364	5e		 pop	 esi
  00365	5b		 pop	 ebx
  00366	8b e5		 mov	 esp, ebp
  00368	5d		 pop	 ebp
  00369	c3		 ret	 0

; 902  : 		_CATCH_IO_(_Ostr)

$LN131@operator:
  0036a	6a 00		 push	 0
  0036c	6a 00		 push	 0
  0036e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN280@operator:
$LN271@operator:
  00373	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$3:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$2:
  00008	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$36:
  00010	e8 00 00 00 00	 call	 ___std_terminate
  00015	c3		 ret	 0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$37:
  00016	e8 00 00 00 00	 call	 ___std_terminate
  0001b	c3		 ret	 0
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8d 71 68	 lea	 esi, DWORD PTR [ecx+104]
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0002d	56		 push	 esi
  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  0003b	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00040	83 c4 04	 add	 esp, 4
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	5e		 pop	 esi
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8d 71 98	 lea	 esi, DWORD PTR [ecx-104]
  00026	e8 00 00 00 00	 call	 ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0002b	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  0002e	50		 push	 eax
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0003c	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00041	83 c4 04	 add	 esp, 4
  00044	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00048	74 0e		 je	 SHORT $LN13@scalar
  0004a	68 b0 00 00 00	 push	 176			; 000000b0H
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00055	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00058	8b c6		 mov	 eax, esi
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0002c	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00031	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0003a	85 ff		 test	 edi, edi
  0003c	74 2a		 je	 SHORT $LN13@scalar
  0003e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	85 c9		 test	 ecx, ecx
  0004a	74 11		 je	 SHORT $LN19@scalar
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	ff 50 08	 call	 DWORD PTR [eax+8]
  00051	85 c0		 test	 eax, eax
  00053	74 08		 je	 SHORT $LN19@scalar
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b c8		 mov	 ecx, eax
  00059	6a 01		 push	 1
  0005b	ff 12		 call	 DWORD PTR [edx]
$LN19@scalar:
  0005d	6a 08		 push	 8
  0005f	57		 push	 edi
  00060	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00065	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00068	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0006c	74 0b		 je	 SHORT $LN22@scalar
  0006e	6a 44		 push	 68			; 00000044H
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00076	83 c4 08	 add	 esp, 8
$LN22@scalar:
  00079	8b c6		 mov	 eax, esi
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEHH@Z
_TEXT	SEGMENT
__Mode$ = 8						; size = 4
?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEHH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getstate, COMDAT
; _this$ = ecx

; 354  : 		{	// convert open mode to stream state bits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]

; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))

  00007	8b c3		 mov	 eax, ebx
  00009	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  00010	f7 d1		 not	 ecx
  00012	83 e1 04	 and	 ecx, 4
  00015	8b d1		 mov	 edx, ecx
  00017	83 ca 02	 or	 edx, 2
  0001a	24 02		 and	 al, 2

; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)

  0001c	8b c3		 mov	 eax, ebx
  0001e	0f 45 d1	 cmovne	 edx, ecx
  00021	8b ca		 mov	 ecx, edx
  00023	83 c9 08	 or	 ecx, 8
  00026	24 08		 and	 al, 8
  00028	0f 44 ca	 cmove	 ecx, edx
  0002b	8b c1		 mov	 eax, ecx
  0002d	83 c8 10	 or	 eax, 16			; 00000010H

; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)

  00030	80 e3 04	 and	 bl, 4
  00033	5b		 pop	 ebx
  00034	0f 44 c1	 cmove	 eax, ecx

; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEHH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 337  : 		{	// discard any allocated buffer and clear pointers

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 338  : 		if (_Mystate & _Allocated)

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  00007	74 33		 je	 SHORT $LN2@Tidy

; 339  : 			_Al.deallocate(_Mysb::eback(),

  00009	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 0a		 je	 SHORT $LN4@Tidy
  00012	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  0001a	eb 0d		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
  0001c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
$LN5@Tidy:
  00029	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	2b c8		 sub	 ecx, eax
  00030	d1 f9		 sar	 ecx, 1
  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00037	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate
$LN2@Tidy:

; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);

  0003c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 343  : 		_Mysb::setp(0, 0);

  00057	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00060	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00063	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00069	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0006c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;

  00072	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  00076	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  0007d	5e		 pop	 esi

; 346  : 		}

  0007e	c3		 ret	 0
?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXPB_WIH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
tv270 = 16						; size = 4
__State$ = 16						; size = 4
?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXPB_WIH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init, COMDAT
; _this$ = ecx

; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;

  00003	8b 45 10	 mov	 eax, DWORD PTR __State$[ebp]
  00006	53		 push	 ebx

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00014	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00017	85 db		 test	 ebx, ebx
  00019	0f 84 8e 00 00
	00		 je	 $LN2@Init
  0001f	83 e0 06	 and	 eax, 6
  00022	3c 06		 cmp	 al, 6
  00024	0f 84 83 00 00
	00		 je	 $LN2@Init

; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);

  0002a	57		 push	 edi
  0002b	53		 push	 ebx
  0002c	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  0002f	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  00034	8b f8		 mov	 edi, eax

; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);

  00036	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  00039	50		 push	 eax
  0003a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0003d	57		 push	 edi
  0003e	e8 00 00 00 00	 call	 _memcpy

; 319  : 			_Seekhigh = _Pnew + _Count;

  00043	8d 14 1b	 lea	 edx, DWORD PTR [ebx+ebx]
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 320  : 
; 321  : 			if (!(_Mystate & _Noread))

  00049	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0004d	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00050	89 45 10	 mov	 DWORD PTR tv270[ebp], eax
  00053	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00056	75 0f		 jne	 SHORT $LN3@Init

; 322  : 				_Mysb::setg(_Pnew, _Pnew,

  00058	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0005b	89 38		 mov	 DWORD PTR [eax], edi
  0005d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00060	89 38		 mov	 DWORD PTR [eax], edi
  00062	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00065	89 18		 mov	 DWORD PTR [eax], ebx
$LN3@Init:

; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))

  00067	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0006a	a8 02		 test	 al, 2
  0006c	75 3a		 jne	 SHORT $LN5@Init

; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,

  0006e	a8 18		 test	 al, 24			; 00000018H
  00070	8b cf		 mov	 ecx, edi
  00072	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00075	0f 45 4d 10	 cmovne	 ecx, DWORD PTR tv270[ebp]
  00079	2b d1		 sub	 edx, ecx
  0007b	03 d7		 add	 edx, edi
  0007d	89 38		 mov	 DWORD PTR [eax], edi
  0007f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00082	d1 fa		 sar	 edx, 1
  00084	89 08		 mov	 DWORD PTR [eax], ecx
  00086	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00089	89 10		 mov	 DWORD PTR [eax], edx

; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)

  0008b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0008e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00091	75 15		 jne	 SHORT $LN5@Init

; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);

  00093	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00096	89 38		 mov	 DWORD PTR [eax], edi
  00098	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0009b	d1 ff		 sar	 edi, 1
  0009d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a3	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a6	89 38		 mov	 DWORD PTR [eax], edi
$LN5@Init:

; 331  : 				}
; 332  : 			_Mystate |= _Allocated;

  000a8	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  000ac	5f		 pop	 edi
$LN2@Init:
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx

; 333  : 			}
; 334  : 		}

  000af	5d		 pop	 ebp
  000b0	c2 0c 00	 ret	 12			; 0000000cH
?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXPB_WIH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Off$1$ = -4						; size = 4
tv286 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
__Off$1$ = 36						; size = 4
tv324 = 36						; size = 4
tv297 = 36						; size = 4
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos, COMDAT
; _this$ = ecx

; 276  : 		{	// change position to _Pos, according to _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 277  : 		streamoff _Off = (streamoff)_Ptr;

  00005	8b 5d 18	 mov	 ebx, DWORD PTR __Ptr$[ebp+12]
  00008	56		 push	 esi
  00009	8b 75 14	 mov	 esi, DWORD PTR __Ptr$[ebp+8]
  0000c	03 75 0c	 add	 esi, DWORD PTR __Ptr$[ebp]
  0000f	57		 push	 edi
  00010	13 5d 10	 adc	 ebx, DWORD PTR __Ptr$[ebp+4]
  00013	8b f9		 mov	 edi, ecx

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00015	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	85 c0		 test	 eax, eax
  0001c	74 08		 je	 SHORT $LN2@seekpos
  0001e	39 47 38	 cmp	 DWORD PTR [edi+56], eax
  00021	73 03		 jae	 SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00023	89 47 38	 mov	 DWORD PTR [edi+56], eax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

  00026	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB+4
  0002b	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  00031	75 08		 jne	 SHORT $LN55@seekpos
  00033	3b d8		 cmp	 ebx, eax
  00035	0f 84 e1 00 00
	00		 je	 $LN11@seekpos
$LN55@seekpos:

; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  0003b	8b 4d 24	 mov	 ecx, DWORD PTR __Mode$[ebp]
  0003e	f6 c1 01	 test	 cl, 1
  00041	0f 84 83 00 00
	00		 je	 $LN5@seekpos
  00047	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	89 45 fc	 mov	 DWORD PTR tv286[ebp], eax
  0004f	85 c0		 test	 eax, eax
  00051	74 72		 je	 SHORT $LN60@seekpos

; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00053	85 db		 test	 ebx, ebx
  00055	7c 66		 jl	 SHORT $LN7@seekpos
  00057	7f 04		 jg	 SHORT $LN56@seekpos
  00059	85 f6		 test	 esi, esi
  0005b	72 60		 jb	 SHORT $LN7@seekpos
$LN56@seekpos:
  0005d	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00065	2b c1		 sub	 eax, ecx
  00067	d1 f8		 sar	 eax, 1
  00069	99		 cdq
  0006a	3b da		 cmp	 ebx, edx
  0006c	7f 4f		 jg	 SHORT $LN7@seekpos
  0006e	7c 04		 jl	 SHORT $LN57@seekpos
  00070	3b f0		 cmp	 esi, eax
  00072	77 49		 ja	 SHORT $LN7@seekpos
$LN57@seekpos:

; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  00074	2b 4d fc	 sub	 ecx, DWORD PTR tv286[ebp]
  00077	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0007a	d1 f9		 sar	 ecx, 1
  0007c	03 ce		 add	 ecx, esi
  0007e	89 4d fc	 mov	 DWORD PTR __Off$1$[ebp], ecx
  00081	29 08		 sub	 DWORD PTR [eax], ecx
  00083	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00086	8b 45 fc	 mov	 eax, DWORD PTR __Off$1$[ebp]
  00089	03 c0		 add	 eax, eax
  0008b	01 01		 add	 DWORD PTR [ecx], eax

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  0008d	f6 45 24 02	 test	 BYTE PTR __Mode$[ebp], 2
  00091	0f 84 85 00 00
	00		 je	 $LN11@seekpos
  00097	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	85 c9		 test	 ecx, ecx
  0009e	74 7c		 je	 SHORT $LN11@seekpos

; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),

  000a0	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  000a3	8b 10		 mov	 edx, DWORD PTR [eax]
  000a5	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000a8	8b 00		 mov	 eax, DWORD PTR [eax]
  000aa	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  000ad	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000b0	2b ca		 sub	 ecx, edx
  000b2	d1 f9		 sar	 ecx, 1
  000b4	89 10		 mov	 DWORD PTR [eax], edx
  000b6	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000b9	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else

  000bb	eb 5f		 jmp	 SHORT $LN11@seekpos
$LN7@seekpos:

; 293  : 				_Off = _BADOFF;

  000bd	8b 1d 04 00 00
	00		 mov	 ebx, DWORD PTR ?_BADOFF@std@@3_JB+4
  000c3	eb 51		 jmp	 SHORT $LN61@seekpos
$LN60@seekpos:
  000c5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB+4
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  000ca	f6 c1 02	 test	 cl, 2
  000cd	74 45		 je	 SHORT $LN10@seekpos
  000cf	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000d1	89 4d 24	 mov	 DWORD PTR tv297[ebp], ecx
  000d4	85 c9		 test	 ecx, ecx
  000d6	74 3c		 je	 SHORT $LN10@seekpos

; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000d8	85 db		 test	 ebx, ebx
  000da	7c e1		 jl	 SHORT $LN7@seekpos
  000dc	7f 04		 jg	 SHORT $LN58@seekpos
  000de	85 f6		 test	 esi, esi
  000e0	72 db		 jb	 SHORT $LN7@seekpos
$LN58@seekpos:
  000e2	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  000ea	2b c1		 sub	 eax, ecx
  000ec	d1 f8		 sar	 eax, 1
  000ee	99		 cdq
  000ef	3b da		 cmp	 ebx, edx
  000f1	7f ca		 jg	 SHORT $LN7@seekpos
  000f3	7c 04		 jl	 SHORT $LN59@seekpos
  000f5	3b f0		 cmp	 esi, eax
  000f7	77 c4		 ja	 SHORT $LN7@seekpos
$LN59@seekpos:

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000f9	2b 4d 24	 sub	 ecx, DWORD PTR tv297[ebp]
  000fc	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000ff	d1 f9		 sar	 ecx, 1
  00101	03 ce		 add	 ecx, esi
  00103	89 4d 24	 mov	 DWORD PTR __Off$1$[ebp], ecx
  00106	29 08		 sub	 DWORD PTR [eax], ecx
  00108	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  0010b	8b 45 24	 mov	 eax, DWORD PTR __Off$1$[ebp]
  0010e	03 c0		 add	 eax, eax
  00110	01 01		 add	 DWORD PTR [ecx], eax

; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else

  00112	eb 08		 jmp	 SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  00114	8b d8		 mov	 ebx, eax
$LN61@seekpos:
  00116	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
$LN11@seekpos:

; 305  : 		return (streampos(_Off));

  0011c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0011f	0f 57 c0	 xorps	 xmm0, xmm0
  00122	5f		 pop	 edi
  00123	89 30		 mov	 DWORD PTR [eax], esi
  00125	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00128	5e		 pop	 esi
  00129	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00130	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00137	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  0013c	5b		 pop	 ebx

; 306  : 		}

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv281 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Off$1$ = 20						; size = 4
__Way$ = 20						; size = 4
__Off$1$ = 24						; size = 4
tv292 = 24						; size = 4
tv287 = 24						; size = 4
__Which$ = 24						; size = 4
?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff, COMDAT
; _this$ = ecx

; 227  : 		{	// change position by _Off, according to _Way, _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00009	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	85 c0		 test	 eax, eax
  00010	74 08		 je	 SHORT $LN2@seekoff
  00012	39 43 38	 cmp	 DWORD PTR [ebx+56], eax
  00015	73 03		 jae	 SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00017	89 43 38	 mov	 DWORD PTR [ebx+56], eax
$LN2@seekoff:

; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  0001a	8b 4d 18	 mov	 ecx, DWORD PTR __Which$[ebp]
  0001d	f6 c1 01	 test	 cl, 1
  00020	0f 84 e8 00 00
	00		 je	 $LN3@seekoff
  00026	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00029	8b 30		 mov	 esi, DWORD PTR [eax]
  0002b	89 75 fc	 mov	 DWORD PTR tv281[ebp], esi
  0002e	85 f6		 test	 esi, esi
  00030	0f 84 d8 00 00
	00		 je	 $LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

  00036	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00039	83 f8 02	 cmp	 eax, 2
  0003c	75 17		 jne	 SHORT $LN5@seekoff

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  0003e	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00041	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00044	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00047	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0004a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004c	d1 f8		 sar	 eax, 1
  0004e	99		 cdq
  0004f	03 f0		 add	 esi, eax
  00051	13 fa		 adc	 edi, edx

; 235  : 			else if (_Way == ios_base::cur

  00053	eb 38		 jmp	 SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

  00055	83 f8 01	 cmp	 eax, 1
  00058	75 1b		 jne	 SHORT $LN7@seekoff
  0005a	f6 c1 02	 test	 cl, 2
  0005d	75 1a		 jne	 SHORT $LN74@seekoff

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

  0005f	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00062	8b c6		 mov	 eax, esi
  00064	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00067	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0006a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006c	d1 f8		 sar	 eax, 1
  0006e	99		 cdq
  0006f	03 f0		 add	 esi, eax
  00071	13 fa		 adc	 edi, edx
  00073	eb 18		 jmp	 SHORT $LN9@seekoff
$LN7@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00075	85 c0		 test	 eax, eax
  00077	74 0e		 je	 SHORT $LN79@seekoff
$LN74@seekoff:

; 239  : 				_Off = _BADOFF;

  00079	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  0007f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
  00085	eb 06		 jmp	 SHORT $LN9@seekoff
$LN79@seekoff:
  00087	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0008a	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN9@seekoff:

; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0008d	85 ff		 test	 edi, edi
  0008f	0f 8c 29 01 00
	00		 jl	 $LN10@seekoff
  00095	7f 08		 jg	 SHORT $LN75@seekoff
  00097	85 f6		 test	 esi, esi
  00099	0f 82 1f 01 00
	00		 jb	 $LN10@seekoff
$LN75@seekoff:
  0009f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  000a7	2b c1		 sub	 eax, ecx
  000a9	d1 f8		 sar	 eax, 1
  000ab	99		 cdq
  000ac	3b fa		 cmp	 edi, edx
  000ae	0f 8f 0a 01 00
	00		 jg	 $LN10@seekoff
  000b4	7c 08		 jl	 SHORT $LN76@seekoff
  000b6	3b f0		 cmp	 esi, eax
  000b8	0f 87 00 01 00
	00		 ja	 $LN10@seekoff
$LN76@seekoff:

; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  000be	2b 4d fc	 sub	 ecx, DWORD PTR tv281[ebp]
  000c1	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  000c4	d1 f9		 sar	 ecx, 1
  000c6	03 ce		 add	 ecx, esi
  000c8	89 4d 14	 mov	 DWORD PTR __Off$1$[ebp], ecx
  000cb	29 08		 sub	 DWORD PTR [eax], ecx
  000cd	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  000d0	8b 45 14	 mov	 eax, DWORD PTR __Off$1$[ebp]
  000d3	03 c0		 add	 eax, eax
  000d5	01 01		 add	 DWORD PTR [ecx], eax

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000d7	f6 45 18 02	 test	 BYTE PTR __Which$[ebp], 2
  000db	0f 84 e9 00 00
	00		 je	 $LN22@seekoff
  000e1	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	85 c9		 test	 ecx, ecx
  000e8	0f 84 dc 00 00
	00		 je	 $LN22@seekoff

; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),

  000ee	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000f1	8b 10		 mov	 edx, DWORD PTR [eax]
  000f3	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000f6	8b 00		 mov	 eax, DWORD PTR [eax]
  000f8	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  000fb	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000fe	2b ca		 sub	 ecx, edx
  00100	d1 f9		 sar	 ecx, 1
  00102	89 10		 mov	 DWORD PTR [eax], edx
  00104	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00107	89 08		 mov	 DWORD PTR [eax], ecx

; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else

  00109	e9 bc 00 00 00	 jmp	 $LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

  0010e	f6 c1 02	 test	 cl, 2
  00111	0f 84 9b 00 00
	00		 je	 $LN13@seekoff
  00117	8b 12		 mov	 edx, DWORD PTR [edx]
  00119	89 55 18	 mov	 DWORD PTR tv287[ebp], edx
  0011c	85 d2		 test	 edx, edx
  0011e	0f 84 8e 00 00
	00		 je	 $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

  00124	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00127	83 f8 02	 cmp	 eax, 2
  0012a	75 17		 jne	 SHORT $LN15@seekoff

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  0012c	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0012f	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00132	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00135	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00138	2b 01		 sub	 eax, DWORD PTR [ecx]
  0013a	d1 f8		 sar	 eax, 1
  0013c	99		 cdq
  0013d	03 f0		 add	 esi, eax
  0013f	13 fa		 adc	 edi, edx
  00141	eb 33		 jmp	 SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

  00143	83 f8 01	 cmp	 eax, 1
  00146	75 16		 jne	 SHORT $LN17@seekoff

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

  00148	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0014b	8b c2		 mov	 eax, edx
  0014d	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00150	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00153	2b 01		 sub	 eax, DWORD PTR [ecx]
  00155	d1 f8		 sar	 eax, 1
  00157	99		 cdq
  00158	03 f0		 add	 esi, eax
  0015a	13 fa		 adc	 edi, edx
  0015c	eb 18		 jmp	 SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  0015e	85 c0		 test	 eax, eax
  00160	74 0e		 je	 SHORT $LN80@seekoff

; 258  : 				_Off = _BADOFF;

  00162	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  00168	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
  0016e	eb 06		 jmp	 SHORT $LN19@seekoff
$LN80@seekoff:
  00170	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00173	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN19@seekoff:

; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00176	85 ff		 test	 edi, edi
  00178	7c 44		 jl	 SHORT $LN10@seekoff
  0017a	7f 04		 jg	 SHORT $LN77@seekoff
  0017c	85 f6		 test	 esi, esi
  0017e	72 3e		 jb	 SHORT $LN10@seekoff
$LN77@seekoff:
  00180	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00183	8b 08		 mov	 ecx, DWORD PTR [eax]
  00185	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00188	2b c1		 sub	 eax, ecx
  0018a	d1 f8		 sar	 eax, 1
  0018c	99		 cdq
  0018d	3b fa		 cmp	 edi, edx
  0018f	7f 2d		 jg	 SHORT $LN10@seekoff
  00191	7c 04		 jl	 SHORT $LN78@seekoff
  00193	3b f0		 cmp	 esi, eax
  00195	77 27		 ja	 SHORT $LN10@seekoff
$LN78@seekoff:

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

  00197	2b 4d 18	 sub	 ecx, DWORD PTR tv287[ebp]
  0019a	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  0019d	d1 f9		 sar	 ecx, 1
  0019f	03 ce		 add	 ecx, esi
  001a1	89 4d 18	 mov	 DWORD PTR __Off$1$[ebp], ecx
  001a4	29 08		 sub	 DWORD PTR [eax], ecx
  001a6	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  001a9	8b 45 18	 mov	 eax, DWORD PTR __Off$1$[ebp]
  001ac	03 c0		 add	 eax, eax
  001ae	01 01		 add	 DWORD PTR [ecx], eax

; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else

  001b0	eb 18		 jmp	 SHORT $LN22@seekoff
$LN13@seekoff:

; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

  001b2	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  001b5	8b c6		 mov	 eax, esi
  001b7	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  001ba	0b c7		 or	 eax, edi
  001bc	74 0c		 je	 SHORT $LN22@seekoff
$LN10@seekoff:

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  001be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  001c4	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
$LN22@seekoff:

; 271  : 		return (pos_type(_Off));

  001ca	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001cd	0f 57 c0	 xorps	 xmm0, xmm0
  001d0	89 78 04	 mov	 DWORD PTR [eax+4], edi
  001d3	5f		 pop	 edi
  001d4	89 30		 mov	 DWORD PTR [eax], esi
  001d6	5e		 pop	 esi
  001d7	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  001de	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  001e5	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  001ea	5b		 pop	 ebx

; 272  : 		}

  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow, COMDAT
; _this$ = ecx

; 207  : 		{	// get an element from stream, but don't point past it

  00000	8b d1		 mov	 edx, ecx
  00002	56		 push	 esi
  00003	57		 push	 edi

; 208  : 		if (_Mysb::gptr() == 0)

  00004	8b 7a 1c	 mov	 edi, DWORD PTR [edx+28]
  00007	8b 37		 mov	 esi, DWORD PTR [edi]
  00009	85 f6		 test	 esi, esi
  0000b	75 08		 jne	 SHORT $LN2@underflow

; 209  : 			return (_Traits::eof());	// no character buffer, fail

  0000d	5f		 pop	 edi
  0000e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00013	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00014	c3		 ret	 0
$LN2@underflow:
  00015	53		 push	 ebx

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

  00016	8b 5a 2c	 mov	 ebx, DWORD PTR [edx+44]
  00019	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0001b	8d 0c 4e	 lea	 ecx, DWORD PTR [esi+ecx*2]
  0001e	3b f1		 cmp	 esi, ecx
  00020	73 07		 jae	 SHORT $LN4@underflow

; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

  00022	66 8b 06	 mov	 ax, WORD PTR [esi]
  00025	5b		 pop	 ebx
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00028	c3		 ret	 0
$LN4@underflow:

; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  00029	f6 42 3c 04	 test	 BYTE PTR [edx+60], 4
  0002d	75 2f		 jne	 SHORT $LN8@underflow
  0002f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	85 c0		 test	 eax, eax
  00036	74 26		 je	 SHORT $LN8@underflow
  00038	3b c6		 cmp	 eax, esi
  0003a	77 05		 ja	 SHORT $LN6@underflow
  0003c	39 72 38	 cmp	 DWORD PTR [edx+56], esi
  0003f	76 1d		 jbe	 SHORT $LN8@underflow
$LN6@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

  00041	39 42 38	 cmp	 DWORD PTR [edx+56], eax
  00044	73 03		 jae	 SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

  00046	89 42 38	 mov	 DWORD PTR [edx+56], eax
$LN9@underflow:

; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

  00049	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0004c	2b 07		 sub	 eax, DWORD PTR [edi]
  0004e	d1 f8		 sar	 eax, 1
  00050	89 03		 mov	 DWORD PTR [ebx], eax

; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));

  00052	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00055	5b		 pop	 ebx
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 221  : 			}
; 222  : 		}

  0005d	c3		 ret	 0
$LN8@underflow:
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi

; 214  : 			return (_Traits::eof());	// can't read, fail

  00060	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00065	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00066	c3		 ret	 0
?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 2
?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail, COMDAT
; _this$ = ecx

; 190  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00003	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
  0000d	8b 30		 mov	 esi, DWORD PTR [eax]
  0000f	85 f6		 test	 esi, esi
  00011	74 45		 je	 SHORT $LN4@pbackfail
  00013	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00016	3b 30		 cmp	 esi, DWORD PTR [eax]
  00018	76 3e		 jbe	 SHORT $LN4@pbackfail
  0001a	66 8b 55 08	 mov	 dx, WORD PTR __Meta$[ebp]
  0001e	66 3b fa	 cmp	 di, dx
  00021	74 0c		 je	 SHORT $LN2@pbackfail
  00023	66 3b 56 fe	 cmp	 dx, WORD PTR [esi-2]
  00027	74 06		 je	 SHORT $LN2@pbackfail
  00029	f6 41 3c 02	 test	 BYTE PTR [ecx+60], 2
  0002d	75 29		 jne	 SHORT $LN4@pbackfail
$LN2@pbackfail:

; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);

  0002f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00032	ff 00		 inc	 DWORD PTR [eax]
  00034	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00037	83 00 fe	 add	 DWORD PTR [eax], -2	; fffffffeH

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

  0003a	66 3b fa	 cmp	 di, dx
  0003d	74 08		 je	 SHORT $LN45@pbackfail

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

  0003f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	66 89 10	 mov	 WORD PTR [eax], dx

; 202  : 			return (_Traits::not_eof(_Meta));

$LN45@pbackfail:
  00047	33 c9		 xor	 ecx, ecx
  00049	0f b7 c2	 movzx	 eax, dx
  0004c	66 3b d7	 cmp	 dx, di
  0004f	5f		 pop	 edi
  00050	0f 44 c1	 cmove	 eax, ecx
  00053	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

  00058	66 8b c7	 mov	 ax, di
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
__Oldptr$1$ = -4					; size = 4
__Meta$ = 8						; size = 2
?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow, COMDAT
; _this$ = ecx

; 120  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 121  : 		if (_Mystate & _Constant)

  00009	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0000c	a8 02		 test	 al, 2
  0000e	74 0c		 je	 SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

  00010	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00015	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN4@overflow:
  0001c	53		 push	 ebx

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0001d	66 8b 5d 08	 mov	 bx, WORD PTR __Meta$[ebp]
  00021	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00026	66 3b cb	 cmp	 cx, bx
  00029	75 0a		 jne	 SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  0002b	5b		 pop	 ebx
  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN6@overflow:
  00035	57		 push	 edi

; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  00036	a8 08		 test	 al, 8
  00038	74 23		 je	 SHORT $LN7@overflow
  0003a	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  0003d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 1a		 je	 SHORT $LN7@overflow
  00043	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00046	3b ca		 cmp	 ecx, edx
  00048	73 13		 jae	 SHORT $LN7@overflow

; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());

  0004a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
  0004f	89 17		 mov	 DWORD PTR [edi], edx
  00051	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  00054	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00057	2b ca		 sub	 ecx, edx
  00059	d1 f9		 sar	 ecx, 1
  0005b	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@overflow:

; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  0005d	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	85 c9		 test	 ecx, ecx
  00064	74 2e		 je	 SHORT $LN121@overflow
  00066	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00069	8b 3a		 mov	 edi, DWORD PTR [edx]
  0006b	8d 04 79	 lea	 eax, DWORD PTR [ecx+edi*2]
  0006e	3b c8		 cmp	 ecx, eax
  00070	73 1e		 jae	 SHORT $LN8@overflow

; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00072	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]

; 134  : 			return (_Meta);

  00075	66 8b c3	 mov	 ax, bx
  00078	89 0a		 mov	 DWORD PTR [edx], ecx
  0007a	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0007d	5f		 pop	 edi
  0007e	8b 32		 mov	 esi, DWORD PTR [edx]
  00080	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
  00083	89 0a		 mov	 DWORD PTR [edx], ecx
  00085	66 89 1e	 mov	 WORD PTR [esi], bx
  00088	5b		 pop	 ebx
  00089	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN8@overflow:

; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  00090	85 c9		 test	 ecx, ecx
  00092	75 04		 jne	 SHORT $LN20@overflow
$LN121@overflow:
  00094	33 ff		 xor	 edi, edi
  00096	eb 10		 jmp	 SHORT $LN21@overflow
$LN20@overflow:
  00098	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0009b	8b 38		 mov	 edi, DWORD PTR [eax]
  0009d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000a0	03 ff		 add	 edi, edi
  000a2	2b 38		 sub	 edi, DWORD PTR [eax]
  000a4	03 f9		 add	 edi, ecx
  000a6	d1 ff		 sar	 edi, 1
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

  000a8	8b cf		 mov	 ecx, edi
  000aa	d1 e9		 shr	 ecx, 1
  000ac	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000af	73 07		 jae	 SHORT $LN22@overflow
  000b1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000b6	eb 08		 jmp	 SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000b8	85 c9		 test	 ecx, ecx
  000ba	74 17		 je	 SHORT $LN123@overflow
  000bc	0f 1f 40 00	 npad	 4
$LL2@overflow:
  000c0	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000c5	2b c1		 sub	 eax, ecx
  000c7	3b c7		 cmp	 eax, edi
  000c9	73 04		 jae	 SHORT $LN116@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

  000cb	d1 e9		 shr	 ecx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000cd	75 f1		 jne	 SHORT $LL2@overflow
$LN116@overflow:

; 146  : 			if (_Inc == 0)

  000cf	85 c9		 test	 ecx, ecx
  000d1	75 0e		 jne	 SHORT $LN10@overflow
$LN123@overflow:
  000d3	5f		 pop	 edi
  000d4	5b		 pop	 ebx

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

  000d5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000da	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 04 00	 ret	 4
$LN10@overflow:

; 148  : 
; 149  : 			_Newsize += _Inc;

  000e1	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

  000e4	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  000e7	89 45 f8	 mov	 DWORD PTR __Newsize$1$[ebp], eax
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate

; 152  : 			_Elem *_Oldptr = _Mysb::eback();

  000f0	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000f3	8b d8		 mov	 ebx, eax
  000f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f7	89 55 fc	 mov	 DWORD PTR __Oldptr$1$[ebp], edx

; 153  : 
; 154  : 			if (0 < _Oldsize)

  000fa	85 ff		 test	 edi, edi
  000fc	74 15		 je	 SHORT $LN125@overflow

; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);

  000fe	8d 0c 3f	 lea	 ecx, DWORD PTR [edi+edi]
  00101	51		 push	 ecx
  00102	52		 push	 edx
  00103	53		 push	 ebx
  00104	e8 00 00 00 00	 call	 _memcpy
  00109	8b 55 fc	 mov	 edx, DWORD PTR __Oldptr$1$[ebp]
  0010c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 
; 157  : 			if (_Oldsize == 0)

  0010f	85 ff		 test	 edi, edi
  00111	75 45		 jne	 SHORT $LN12@overflow
$LN125@overflow:

; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);

  00113	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00116	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00119	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  0011c	89 18		 mov	 DWORD PTR [eax], ebx
  0011e	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00121	89 18		 mov	 DWORD PTR [eax], ebx
  00123	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00126	89 08		 mov	 DWORD PTR [eax], ecx

; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);

  00128	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0012b	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0012f	89 18		 mov	 DWORD PTR [eax], ebx
  00131	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00134	74 12		 je	 SHORT $LN14@overflow
  00136	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0013c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0013f	d1 fb		 sar	 ebx, 1
  00141	89 18		 mov	 DWORD PTR [eax], ebx

; 163  : 				else

  00143	e9 92 00 00 00	 jmp	 $LN17@overflow
$LN14@overflow:

; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);

  00148	89 18		 mov	 DWORD PTR [eax], ebx
  0014a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0014d	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 165  : 				}
; 166  : 			else

  00153	e9 82 00 00 00	 jmp	 $LN17@overflow
$LN12@overflow:

; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

  00158	8b 46 38	 mov	 eax, DWORD PTR [esi+56]

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  0015b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0015e	2b c2		 sub	 eax, edx
  00160	d1 f8		 sar	 eax, 1
  00162	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  00165	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00168	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0016b	8b 00		 mov	 eax, DWORD PTR [eax]
  0016d	2b c2		 sub	 eax, edx
  0016f	d1 f8		 sar	 eax, 1
  00171	8d 14 43	 lea	 edx, DWORD PTR [ebx+eax*2]
  00174	8b 01		 mov	 eax, DWORD PTR [ecx]
  00176	2b 45 fc	 sub	 eax, DWORD PTR __Oldptr$1$[ebp]
  00179	d1 f8		 sar	 eax, 1
  0017b	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  0017e	89 01		 mov	 DWORD PTR [ecx], eax
  00180	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00183	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00186	03 c9		 add	 ecx, ecx
  00188	2b ca		 sub	 ecx, edx
  0018a	89 10		 mov	 DWORD PTR [eax], edx
  0018c	03 cb		 add	 ecx, ebx
  0018e	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00191	d1 f9		 sar	 ecx, 1
  00193	89 08		 mov	 DWORD PTR [eax], ecx

; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)

  00195	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  00199	74 17		 je	 SHORT $LN16@overflow

; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);

  0019b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0019e	89 18		 mov	 DWORD PTR [eax], ebx
  001a0	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001a3	d1 fb		 sar	 ebx, 1
  001a5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001ab	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001ae	89 18		 mov	 DWORD PTR [eax], ebx

; 174  : 				else

  001b0	eb 28		 jmp	 SHORT $LN17@overflow
$LN16@overflow:

; 175  : 					_Mysb::setg(_Newptr,

  001b2	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  001b5	8b 10		 mov	 edx, DWORD PTR [eax]
  001b7	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001ba	8b 00		 mov	 eax, DWORD PTR [eax]
  001bc	2b 45 fc	 sub	 eax, DWORD PTR __Oldptr$1$[ebp]
  001bf	d1 f8		 sar	 eax, 1
  001c1	8d 0c 43	 lea	 ecx, DWORD PTR [ebx+eax*2]
  001c4	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001c7	2b d1		 sub	 edx, ecx
  001c9	83 c2 02	 add	 edx, 2
  001cc	d1 fa		 sar	 edx, 1
  001ce	89 18		 mov	 DWORD PTR [eax], ebx
  001d0	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001d3	89 08		 mov	 DWORD PTR [eax], ecx
  001d5	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001d8	89 10		 mov	 DWORD PTR [eax], edx
$LN17@overflow:

; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)

  001da	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  001de	74 0c		 je	 SHORT $LN18@overflow

; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);

  001e0	57		 push	 edi
  001e1	ff 75 fc	 push	 DWORD PTR __Oldptr$1$[ebp]
  001e4	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  001e7	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate
$LN18@overflow:

; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  001ec	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001ef	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  001f3	5f		 pop	 edi
  001f4	5b		 pop	 ebx
  001f5	ff 08		 dec	 DWORD PTR [eax]
  001f7	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  001fa	5e		 pop	 esi
  001fb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fd	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00200	89 01		 mov	 DWORD PTR [ecx], eax
  00202	66 8b 45 08	 mov	 ax, WORD PTR __Meta$[ebp]
  00206	66 89 02	 mov	 WORD PTR [edx], ax

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c2 04 00	 ret	 4
?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
__Nul$2 = -28						; size = 24
__Str$3 = -28						; size = 24
__Str$4 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str, COMDAT
; _this$ = ecx

; 93   : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b d1		 mov	 edx, ecx
  00012	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0001d	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  00020	f6 c1 02	 test	 cl, 2
  00023	75 66		 jne	 SHORT $LN2@str
  00025	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	85 c0		 test	 eax, eax
  0002c	74 5d		 je	 SHORT $LN2@str

; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  0002e	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00031	3b c8		 cmp	 ecx, eax
  00033	0f 42 c8	 cmovb	 ecx, eax
  00036	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00039	33 d2		 xor	 edx, edx
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	2b c8		 sub	 ecx, eax
  0003f	d1 f9		 sar	 ecx, 1
  00041	51		 push	 ecx
  00042	50		 push	 eax
  00043	8d 4d e4	 lea	 ecx, DWORD PTR __Str$4[ebp]
  00046	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR __Str$4[ebp+20], 7
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Str$4[ebp+16], 0
  00054	66 89 55 e4	 mov	 WORD PTR __Str$4[ebp], dx
  00058	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);

  0005d	33 c0		 xor	 eax, eax
  0005f	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00066	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0006d	8b ce		 mov	 ecx, esi
  0006f	66 89 06	 mov	 WORD PTR [esi], ax
  00072	8d 45 e4	 lea	 eax, DWORD PTR __Str$4[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  0007b	8b 4d f8	 mov	 ecx, DWORD PTR __Str$4[ebp+20]
  0007e	83 f9 08	 cmp	 ecx, 8
  00081	0f 82 8d 00 00
	00		 jb	 $LN950@str
  00087	41		 inc	 ecx
  00088	51		 push	 ecx
  00089	eb 7e		 jmp	 SHORT $LN1047@str
$LN2@str:

; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  0008b	f6 c1 04	 test	 cl, 4
  0008e	75 41		 jne	 SHORT $LN4@str
  00090	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00093	8b 08		 mov	 ecx, DWORD PTR [eax]
  00095	85 c9		 test	 ecx, ecx
  00097	74 38		 je	 SHORT $LN4@str

; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

  00099	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0009c	8b 00		 mov	 eax, DWORD PTR [eax]
  0009e	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  000a1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a4	33 d2		 xor	 edx, edx
  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	2b c8		 sub	 ecx, eax
  000aa	d1 f9		 sar	 ecx, 1
  000ac	51		 push	 ecx
  000ad	50		 push	 eax
  000ae	8d 4d e4	 lea	 ecx, DWORD PTR __Str$3[ebp]
  000b1	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR __Str$3[ebp+20], 7
  000b8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Str$3[ebp+16], 0
  000bf	66 89 55 e4	 mov	 WORD PTR __Str$3[ebp], dx
  000c3	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 103  : 			return (_Str);

  000c8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000cf	eb 17		 jmp	 SHORT $LN1050@str
$LN4@str:

; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;

  000d1	33 c0		 xor	 eax, eax
  000d3	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR __Nul$2[ebp+20], 7
  000da	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Nul$2[ebp+16], 0
  000e1	66 89 45 e4	 mov	 WORD PTR __Nul$2[ebp], ax

; 108  : 			return (_Nul);

  000e5	89 46 10	 mov	 DWORD PTR [esi+16], eax
$LN1050@str:
  000e8	33 c0		 xor	 eax, eax
  000ea	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  000f1	66 89 06	 mov	 WORD PTR [esi], ax
  000f4	8b ce		 mov	 ecx, esi
  000f6	8d 45 e4	 lea	 eax, DWORD PTR __Nul$2[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  000ff	8b 45 f8	 mov	 eax, DWORD PTR __Nul$2[ebp+20]
  00102	83 f8 08	 cmp	 eax, 8
  00105	72 0d		 jb	 SHORT $LN950@str
  00107	40		 inc	 eax
  00108	50		 push	 eax
$LN1047@str:
  00109	ff 75 e4	 push	 DWORD PTR __Nul$2[ebp]
  0010c	8d 4d e4	 lea	 ecx, DWORD PTR __Nul$2[ebp]
  0010f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN950@str:

; 109  : 			}
; 110  : 		}

  00114	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	8b c6		 mov	 eax, esi
  00119	33 cd		 xor	 ecx, ebp
  0011b	5e		 pop	 esi
  0011c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@

; 76   : 		_Tidy();

  0002b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 77   : 		}

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  00036	8b 76 34	 mov	 esi, DWORD PTR [esi+52]
  00039	85 f6		 test	 esi, esi
  0003b	74 2a		 je	 SHORT $LN9@basic_stri
  0003d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	85 c9		 test	 ecx, ecx
  00049	74 11		 je	 SHORT $LN15@basic_stri
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
  00050	85 c0		 test	 eax, eax
  00052	74 08		 je	 SHORT $LN15@basic_stri
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b c8		 mov	 ecx, eax
  00058	6a 01		 push	 1
  0005a	ff 12		 call	 DWORD PTR [edx]
$LN15@basic_stri:
  0005c	6a 08		 push	 8
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00064	83 c4 08	 add	 esp, 8
$LN9@basic_stri:
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	5e		 pop	 esi
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

  0002a	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  0002f	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]

; 31   : 		_Init(0, 0, _Getstate(_Mode));

  00032	8b c3		 mov	 eax, ebx
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0003a	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00041	8d 14 9d 00 00
	00 00		 lea	 edx, DWORD PTR [ebx*4]
  00048	f7 d2		 not	 edx
  0004a	83 e2 04	 and	 edx, 4
  0004d	8b ca		 mov	 ecx, edx
  0004f	83 c9 02	 or	 ecx, 2
  00052	24 02		 and	 al, 2
  00054	8b c3		 mov	 eax, ebx
  00056	0f 45 ca	 cmovne	 ecx, edx
  00059	8b d1		 mov	 edx, ecx
  0005b	83 ca 08	 or	 edx, 8
  0005e	24 08		 and	 al, 8
  00060	0f 44 d1	 cmove	 edx, ecx
  00063	8b c2		 mov	 eax, edx
  00065	83 c8 10	 or	 eax, 16			; 00000010H
  00068	80 e3 04	 and	 bl, 4
  0006b	0f 44 c2	 cmove	 eax, edx
  0006e	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 32   : 		}

  00071	8b c6		 mov	 eax, esi
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__ehhandler$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0002f	85 ff		 test	 edi, edi
  00031	74 2a		 je	 SHORT $LN10@scalar
  00033	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	85 c9		 test	 ecx, ecx
  0003f	74 11		 je	 SHORT $LN16@scalar
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	ff 50 08	 call	 DWORD PTR [eax+8]
  00046	85 c0		 test	 eax, eax
  00048	74 08		 je	 SHORT $LN16@scalar
  0004a	8b 10		 mov	 edx, DWORD PTR [eax]
  0004c	8b c8		 mov	 ecx, eax
  0004e	6a 01		 push	 1
  00050	ff 12		 call	 DWORD PTR [edx]
$LN16@scalar:
  00052	6a 08		 push	 8
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0005d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00061	74 0b		 je	 SHORT $LN19@scalar
  00063	6a 38		 push	 56			; 00000038H
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006b	83 c4 08	 add	 esp, 8
$LN19@scalar:
  0006e	8b c6		 mov	 eax, esi
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue, COMDAT
; _this$ = ecx

; 449  : 		}

  00000	c2 04 00	 ret	 4
?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync, COMDAT
; _this$ = ecx

; 444  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 445  : 		}

  00002	c3		 ret	 0
?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf, COMDAT
; _this$ = ecx

; 439  : 		return (this);

  00000	8b c1		 mov	 eax, ecx

; 440  : 		}

  00002	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos, COMDAT
; _this$ = ecx

; 433  : 		{	// change to specified position, according to mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 434  : 		return (streampos(_BADOFF));

  00003	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	8b c2		 mov	 eax, edx
  00012	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00022	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00029	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 435  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff, COMDAT
; _this$ = ecx

; 427  : 		{	// change position by offset, according to way and mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 		return (streampos(_BADOFF));

  00003	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	8b c2		 mov	 eax, edx
  00012	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00022	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00029	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 429  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
_TEXT	SEGMENT
__Copied$ = -16						; size = 8
__Size$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Copied$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Copied$2$ = 16					; size = 4
?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn, COMDAT
; _this$ = ecx

; 397  : 		{	// put _Count characters to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	66 0f 13 45 f0	 movlpd	 QWORD PTR __Copied$[ebp], xmm0
  00015	57		 push	 edi
  00016	85 db		 test	 ebx, ebx
  00018	0f 8c cd 00 00
	00		 jl	 $LN40@xsputn
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00021	7f 08		 jg	 SHORT $LN39@xsputn
  00023	85 ff		 test	 edi, edi
  00025	0f 84 c0 00 00
	00		 je	 $LN40@xsputn
$LN39@xsputn:
  0002b	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  00031	89 55 10	 mov	 DWORD PTR __Copied$2$[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR __Copied$1$[ebp], eax
  00037	56		 push	 esi
$LL2@xsputn:

; 401  : 			if (0 < (_Size = _Pnavail()))

  00038	e8 00 00 00 00	 call	 ?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
  0003d	8b f0		 mov	 esi, eax
  0003f	8b c2		 mov	 eax, edx
  00041	89 45 f4	 mov	 DWORD PTR __Size$2$[ebp], eax
  00044	85 c0		 test	 eax, eax
  00046	7c 50		 jl	 SHORT $LN5@xsputn
  00048	7f 04		 jg	 SHORT $LN35@xsputn
  0004a	85 f6		 test	 esi, esi
  0004c	74 4a		 je	 SHORT $LN5@xsputn
$LN35@xsputn:

; 402  : 				{	// copy to write buffer
; 403  : 				if (_Count < _Size)

  0004e	3b d8		 cmp	 ebx, eax
  00050	7f 0b		 jg	 SHORT $LN7@xsputn
  00052	7c 04		 jl	 SHORT $LN36@xsputn
  00054	3b fe		 cmp	 edi, esi
  00056	73 05		 jae	 SHORT $LN7@xsputn
$LN36@xsputn:

; 404  : 					_Size = _Count;

  00058	8b f7		 mov	 esi, edi
  0005a	89 5d f4	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN7@xsputn:

; 405  : 				_Traits::copy(pptr(), _Ptr, (size_t)_Size);

  0005d	85 f6		 test	 esi, esi
  0005f	74 18		 je	 SHORT $LN16@xsputn
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00064	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00067	50		 push	 eax
  00068	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	50		 push	 eax
  0006c	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0006f	ff 30		 push	 DWORD PTR [eax]
  00071	e8 00 00 00 00	 call	 _memcpy
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@xsputn:

; 406  : 				_Ptr += _Size;
; 407  : 				_Copied += _Size;

  00079	01 75 fc	 add	 DWORD PTR __Copied$1$[ebp], esi
  0007c	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  0007f	8b 45 f4	 mov	 eax, DWORD PTR __Size$2$[ebp]
  00082	11 45 10	 adc	 DWORD PTR __Copied$2$[ebp], eax

; 408  : 				_Count -= _Size;

  00085	2b fe		 sub	 edi, esi

; 409  : 				pbump((int)_Size);

  00087	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0008a	1b d8		 sbb	 ebx, eax
  0008c	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0008f	29 30		 sub	 DWORD PTR [eax], esi
  00091	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00094	01 10		 add	 DWORD PTR [eax], edx
  00096	eb 2f		 jmp	 SHORT $LN9@xsputn
$LN5@xsputn:

; 410  : 				}
; 411  : 			else if (_Traits::eq_int_type(_Traits::eof(),

  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0009b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	0f b7 00	 movzx	 eax, WORD PTR [eax]
  000a3	50		 push	 eax
  000a4	ff 52 0c	 call	 DWORD PTR [edx+12]
  000a7	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  000ac	66 3b c8	 cmp	 cx, ax
  000af	74 2b		 je	 SHORT $LN42@xsputn

; 412  : 				overflow(_Traits::to_int_type(*_Ptr))))
; 413  : 				break;	// single character put failed, quit
; 414  : 			else
; 415  : 				{	// count character successfully put
; 416  : 				++_Ptr;
; 417  : 				++_Copied;

  000b1	83 45 fc 01	 add	 DWORD PTR __Copied$1$[ebp], 1

; 418  : 				--_Count;

  000b5	ba 02 00 00 00	 mov	 edx, 2
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000bd	83 55 10 00	 adc	 DWORD PTR __Copied$2$[ebp], 0
  000c1	83 c7 ff	 add	 edi, -1
  000c4	83 d3 ff	 adc	 ebx, -1
$LN9@xsputn:

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  000c7	01 55 08	 add	 DWORD PTR __Ptr$[ebp], edx
  000ca	85 db		 test	 ebx, ebx
  000cc	0f 8f 66 ff ff
	ff		 jg	 $LL2@xsputn
  000d2	7c 08		 jl	 SHORT $LN42@xsputn
  000d4	85 ff		 test	 edi, edi
  000d6	0f 85 5c ff ff
	ff		 jne	 $LL2@xsputn
$LN42@xsputn:
  000dc	8b 55 10	 mov	 edx, DWORD PTR __Copied$2$[ebp]
  000df	8b 45 fc	 mov	 eax, DWORD PTR __Copied$1$[ebp]
  000e2	5e		 pop	 esi
  000e3	5f		 pop	 edi
  000e4	5b		 pop	 ebx

; 419  : 				}
; 420  : 
; 421  : 		return (_Copied);
; 422  : 		}

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH
$LN40@xsputn:

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  000eb	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000ee	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  000f1	5f		 pop	 edi
  000f2	5b		 pop	 ebx

; 419  : 				}
; 420  : 
; 421  : 		return (_Copied);
; 422  : 		}

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
_TEXT	SEGMENT
__Copied$ = -16						; size = 8
__Size$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Copied$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Copied$2$ = 16					; size = 4
?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn, COMDAT
; _this$ = ecx

; 368  : 		{	// get _Count characters from stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	66 0f 13 45 f0	 movlpd	 QWORD PTR __Copied$[ebp], xmm0
  00015	57		 push	 edi
  00016	85 db		 test	 ebx, ebx
  00018	0f 8c d3 00 00
	00		 jl	 $LN40@xsgetn
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00021	7f 08		 jg	 SHORT $LN39@xsgetn
  00023	85 ff		 test	 edi, edi
  00025	0f 84 c6 00 00
	00		 je	 $LN40@xsgetn
$LN39@xsgetn:
  0002b	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  00031	89 55 10	 mov	 DWORD PTR __Copied$2$[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR __Copied$1$[ebp], eax
  00037	56		 push	 esi
$LL2@xsgetn:

; 373  : 			if (0 < (_Size = _Gnavail()))

  00038	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail
  0003d	8b f0		 mov	 esi, eax
  0003f	8b c2		 mov	 eax, edx
  00041	89 45 f4	 mov	 DWORD PTR __Size$2$[ebp], eax
  00044	85 c0		 test	 eax, eax
  00046	7c 52		 jl	 SHORT $LN5@xsgetn
  00048	7f 04		 jg	 SHORT $LN35@xsgetn
  0004a	85 f6		 test	 esi, esi
  0004c	74 4c		 je	 SHORT $LN5@xsgetn
$LN35@xsgetn:

; 374  : 				{	// copy from read buffer
; 375  : 				if (_Count < _Size)

  0004e	3b d8		 cmp	 ebx, eax
  00050	7f 0b		 jg	 SHORT $LN7@xsgetn
  00052	7c 04		 jl	 SHORT $LN36@xsgetn
  00054	3b fe		 cmp	 edi, esi
  00056	73 05		 jae	 SHORT $LN7@xsgetn
$LN36@xsgetn:

; 376  : 					_Size = _Count;

  00058	8b f7		 mov	 esi, edi
  0005a	89 5d f4	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN7@xsgetn:

; 377  : 				_Traits::copy(_Ptr, gptr(), (size_t)_Size);

  0005d	85 f6		 test	 esi, esi
  0005f	74 17		 je	 SHORT $LN16@xsgetn
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00064	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00067	50		 push	 eax
  00068	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0006b	ff 30		 push	 DWORD PTR [eax]
  0006d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00070	e8 00 00 00 00	 call	 _memcpy
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@xsgetn:

; 378  : 				_Ptr += _Size;
; 379  : 				_Copied += _Size;

  00078	01 75 fc	 add	 DWORD PTR __Copied$1$[ebp], esi
  0007b	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  0007e	8b 45 f4	 mov	 eax, DWORD PTR __Size$2$[ebp]
  00081	11 45 10	 adc	 DWORD PTR __Copied$2$[ebp], eax

; 380  : 				_Count -= _Size;

  00084	2b fe		 sub	 edi, esi

; 381  : 				gbump((int)_Size);

  00086	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00089	1b d8		 sbb	 ebx, eax
  0008b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0008e	29 30		 sub	 DWORD PTR [eax], esi
  00090	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00093	01 10		 add	 DWORD PTR [eax], edx
  00095	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00098	eb 31		 jmp	 SHORT $LN9@xsgetn
$LN5@xsgetn:

; 382  : 				}
; 383  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	ff 50 1c	 call	 DWORD PTR [eax+28]
  000a2	0f b7 c8	 movzx	 ecx, ax
  000a5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000aa	66 3b c1	 cmp	 ax, cx
  000ad	74 33		 je	 SHORT $LN42@xsgetn

; 384  : 				break;	// end of file, quit
; 385  : 			else
; 386  : 				{	// get a single character
; 387  : 				*_Ptr++ = _Traits::to_char_type(_Meta);
; 388  : 				++_Copied;

  000af	83 45 fc 01	 add	 DWORD PTR __Copied$1$[ebp], 1

; 389  : 				--_Count;

  000b3	ba 02 00 00 00	 mov	 edx, 2
  000b8	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000bb	83 55 10 00	 adc	 DWORD PTR __Copied$2$[ebp], 0
  000bf	83 c7 ff	 add	 edi, -1
  000c2	83 d3 ff	 adc	 ebx, -1
  000c5	66 89 08	 mov	 WORD PTR [eax], cx
  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN9@xsgetn:

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  000cb	03 c2		 add	 eax, edx
  000cd	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  000d0	85 db		 test	 ebx, ebx
  000d2	0f 8f 60 ff ff
	ff		 jg	 $LL2@xsgetn
  000d8	7c 08		 jl	 SHORT $LN42@xsgetn
  000da	85 ff		 test	 edi, edi
  000dc	0f 85 56 ff ff
	ff		 jne	 $LL2@xsgetn
$LN42@xsgetn:
  000e2	8b 55 10	 mov	 edx, DWORD PTR __Copied$2$[ebp]
  000e5	8b 45 fc	 mov	 eax, DWORD PTR __Copied$1$[ebp]
  000e8	5e		 pop	 esi
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 390  : 				}
; 391  : 
; 392  : 		return (_Copied);
; 393  : 		}

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c2 0c 00	 ret	 12			; 0000000cH
$LN40@xsgetn:

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  000f1	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000f4	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  000f7	5f		 pop	 edi
  000f8	5b		 pop	 ebx

; 390  : 				}
; 391  : 
; 392  : 		return (_Copied);
; 393  : 		}

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow, COMDAT
; _this$ = ecx

; 361  : 		{	// get a character from stream, point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 362  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 50 18	 call	 DWORD PTR [eax+24]
  00008	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0000d	66 3b c8	 cmp	 cx, ax
  00010	75 04		 jne	 SHORT $LN3@uflow
  00012	8b c1		 mov	 eax, ecx
  00014	5e		 pop	 esi

; 363  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
; 364  : 		}

  00015	c3		 ret	 0
$LN3@uflow:

; 362  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())

  00016	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00019	ff 08		 dec	 DWORD PTR [eax]
  0001b	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0001e	5e		 pop	 esi
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00024	89 01		 mov	 DWORD PTR [ecx], eax
  00026	0f b7 02	 movzx	 eax, WORD PTR [edx]

; 363  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
; 364  : 		}

  00029	c3		 ret	 0
?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow, COMDAT
; _this$ = ecx

; 357  : 		return (_Traits::eof());

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 358  : 		}

  00005	c3		 ret	 0
?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc, COMDAT
; _this$ = ecx

; 352  : 		return (0);

  00000	33 c0		 xor	 eax, eax
  00002	33 d2		 xor	 edx, edx

; 353  : 		}

  00004	c3		 ret	 0
?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 2
?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail, COMDAT
; _this$ = ecx

; 347  : 		return (_Traits::eof());

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 348  : 		}

  00005	c2 04 00	 ret	 4
?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 2
?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow, COMDAT
; _this$ = ecx

; 342  : 		return (_Traits::eof());

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 343  : 		}

  00005	c2 04 00	 ret	 4
?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init, COMDAT
; _this$ = ecx

; 319  : 		_IGfirst = &_Gfirst;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 320  : 		_IPfirst = &_Pfirst;

  00006	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]

; 321  : 		_IGnext = &_Gnext;

  00009	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  0000c	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000f	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 322  : 		_IPnext = &_Pnext;

  00012	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00015	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 323  : 		_IGcount = &_Gcount;

  00018	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  0001b	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 324  : 		_IPcount = &_Pcount;

  0001e	8d 41 28	 lea	 eax, DWORD PTR [ecx+40]
  00021	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 325  : 		setp(0, 0);

  00024	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0002a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00033	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 326  : 		setg(0, 0, 0);

  0003c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 327  : 		}

  00057	c3		 ret	 0
?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail, COMDAT
; _this$ = ecx

; 314  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Pnavail
  00008	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	99		 cdq

; 315  : 		}

  0000e	c3		 ret	 0
$LN3@Pnavail:

; 314  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 315  : 		}

  00012	c3		 ret	 0
?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc, COMDAT
; _this$ = ecx

; 308  : 		--*_IPcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 309  : 		return ((*_IPnext)++);

  00005	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx

; 310  : 		}

  0000f	c3		 ret	 0
?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp, COMDAT
; _this$ = ecx

; 300  : 		{	// set pointers for write buffer, extended version

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 301  : 		*_IPfirst = _First;

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi

; 302  : 		*_IPnext = _Next;
; 303  : 		*_IPcount = (int)(_Last - _Next);

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00012	8b 55 0c	 mov	 edx, DWORD PTR __Next$[ebp]
  00015	2b f2		 sub	 esi, edx
  00017	d1 fe		 sar	 esi, 1
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi

; 304  : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W0@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp, COMDAT
; _this$ = ecx

; 293  : 		{	// set pointers for write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  : 		*_IPfirst = _First;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 295  : 		*_IPnext = _First;
; 296  : 		*_IPcount = (int)(_Last - _First);

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b d6		 sub	 edx, esi
  0000f	89 30		 mov	 DWORD PTR [eax], esi
  00011	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00014	d1 fa		 sar	 edx, 1
  00016	89 30		 mov	 DWORD PTR [eax], esi
  00018	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001b	5e		 pop	 esi
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 297  : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W0@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?pbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbump, COMDAT
; _this$ = ecx

; 287  : 		{	// alter current position in write buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  : 		*_IPcount -= _Off;

  00003	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 289  : 		*_IPnext += _Off;

  0000b	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0000e	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00011	01 01		 add	 DWORD PTR [ecx], eax

; 290  : 		}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?pbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail, COMDAT
; _this$ = ecx

; 283  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Gnavail
  00008	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	99		 cdq

; 284  : 		}

  0000e	c3		 ret	 0
$LN3@Gnavail:

; 283  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 284  : 		}

  00012	c3		 ret	 0
?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gninc, COMDAT
; _this$ = ecx

; 271  : 		--*_IGcount;

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 272  : 		return ((*_IGnext)++);

  00005	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx

; 273  : 		}

  0000f	c3		 ret	 0
?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?epptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?epptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::epptr, COMDAT
; _this$ = ecx

; 260  : 		return (*_IPnext + *_IPcount);

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 261  : 		}

  0000d	c3		 ret	 0
?epptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::epptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setg@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setg@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setg, COMDAT
; _this$ = ecx

; 252  : 		{	// set pointers for read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 253  : 		*_IGfirst = _First;

  00003	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi

; 254  : 		*_IGnext = _Next;
; 255  : 		*_IGcount = (int)(_Last - _Next);

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00012	8b 55 0c	 mov	 edx, DWORD PTR __Next$[ebp]
  00015	2b f2		 sub	 esi, edx
  00017	d1 fe		 sar	 esi, 1
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi

; 256  : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
?setg@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?gbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?gbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gbump, COMDAT
; _this$ = ecx

; 246  : 		{	// alter current position in read buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 247  : 		*_IGcount -= _Off;

  00003	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 248  : 		*_IGnext += _Off;

  0000b	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000e	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00011	01 01		 add	 DWORD PTR [ecx], eax

; 249  : 		}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?gbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gbump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?egptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::egptr, COMDAT
; _this$ = ecx

; 242  : 		return (*_IGnext + *_IGcount);

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 243  : 		}

  0000d	c3		 ret	 0
?egptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::egptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?pptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pptr, COMDAT
; _this$ = ecx

; 237  : 		return (*_IPnext);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 238  : 		}

  00005	c3		 ret	 0
?pptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbase@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?pbase@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbase, COMDAT
; _this$ = ecx

; 232  : 		return (*_IPfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 233  : 		}

  00005	c3		 ret	 0
?pbase@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gptr, COMDAT
; _this$ = ecx

; 227  : 		return (*_IGnext);

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 228  : 		}

  00005	c3		 ret	 0
?gptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?eback@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?eback@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::eback, COMDAT
; _this$ = ecx

; 222  : 		return (*_IGfirst);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 223  : 		}

  00005	c3		 ret	 0
?eback@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::eback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock, COMDAT
; _this$ = ecx

; 217  : 		}

  00000	c3		 ret	 0
?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock, COMDAT
; _this$ = ecx

; 213  : 		}

  00000	c3		 ret	 0
?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAE_JPB_W_J@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAE_JPB_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputn, COMDAT
; _this$ = ecx

; 207  : 		{	// put _Count characters from array beginning at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (xsputn(_Ptr, _Count));

  00003	ff 75 10	 push	 DWORD PTR __Count$[ebp+4]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000e	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00011	ff d0		 call	 eax

; 209  : 		}

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAE_JPB_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc, COMDAT
; _this$ = ecx

; 199  : 		{	// put a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  : 		return (0 < _Pnavail()

  00003	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 23		 je	 SHORT $LN3@sputc
  0000b	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000e	8b 02		 mov	 eax, DWORD PTR [edx]
  00010	85 c0		 test	 eax, eax
  00012	7e 1a		 jle	 SHORT $LN3@sputc
  00014	48		 dec	 eax
  00015	89 02		 mov	 DWORD PTR [edx], eax
  00017	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  0001f	89 01		 mov	 DWORD PTR [ecx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00024	66 89 02	 mov	 WORD PTR [edx], ax
  00027	0f b7 c0	 movzx	 eax, ax

; 201  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 202  : 			: overflow(_Traits::to_int_type(_Ch)));
; 203  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN3@sputc:

; 200  : 		return (0 < _Pnavail()

  0002e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00030	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00033	ff 50 0c	 call	 DWORD PTR [eax+12]
  00036	0f b7 c0	 movzx	 eax, ax

; 201  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 202  : 			: overflow(_Traits::to_int_type(_Ch)));
; 203  : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync, COMDAT
; _this$ = ecx

; 145  : 		return (sync());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 34	 jmp	 DWORD PTR [eax+52]
?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 80   : 		delete _Plocale;

  00023	8b 71 34	 mov	 esi, DWORD PTR [ecx+52]
  00026	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0002c	85 f6		 test	 esi, esi
  0002e	74 2a		 je	 SHORT $LN6@basic_stre
  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 11		 je	 SHORT $LN12@basic_stre
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	ff 50 08	 call	 DWORD PTR [eax+8]
  00043	85 c0		 test	 eax, eax
  00045	74 08		 je	 SHORT $LN12@basic_stre
  00047	8b 10		 mov	 edx, DWORD PTR [eax]
  00049	8b c8		 mov	 ecx, eax
  0004b	6a 01		 push	 1
  0004d	ff 12		 call	 DWORD PTR [edx]
$LN12@basic_stre:
  0004f	6a 08		 push	 8
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00057	83 c4 08	 add	 esp, 8
$LN6@basic_stre:

; 81   : 		}

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 26   : 		{	// construct with no buffers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 25   : 		: _Plocale(new locale)

  00026	6a 08		 push	 8

; 26   : 		{	// construct with no buffers

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	8b f8		 mov	 edi, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 ff		 test	 edi, edi
  0003a	74 16		 je	 SHORT $LN3@basic_stre

; 25   : 		: _Plocale(new locale)

  0003c	6a 01		 push	 1
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00050	eb 02		 jmp	 SHORT $LN4@basic_stre
$LN3@basic_stre:
  00052	33 ff		 xor	 edi, edi
$LN4@basic_stre:

; 27   : 		_Init();

  00054	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00057	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  0005a	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0005d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00060	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00063	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00066	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00069	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0006c	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0006f	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00072	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00075	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00078	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0007b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00081	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00084	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0008a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0008d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00093	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00096	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0009c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0009f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a5	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 28   : 		}

  000ae	8b c6		 mov	 eax, esi
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str, COMDAT
; _this$ = ecx

; 644  : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 645  : 		return (_Stringbuffer.str());

  00004	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00007	83 c1 18	 add	 ecx, 24			; 00000018H
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00011	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 646  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 635  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	8b 47 98	 mov	 eax, DWORD PTR [edi-104]

; 636  : 		}

  00029	8d 4f b0	 lea	 ecx, DWORD PTR [edi-80]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  00037	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0003a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003d	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  00040	89 44 3a 94	 mov	 DWORD PTR [edx+edi-108], eax
  00044	c7 47 b0 00 00
	00 00		 mov	 DWORD PTR [edi-80], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0004b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00050	8b 77 e4	 mov	 esi, DWORD PTR [edi-28]
  00053	c7 47 b0 00 00
	00 00		 mov	 DWORD PTR [edi-80], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0005a	85 f6		 test	 esi, esi
  0005c	74 2a		 je	 SHORT $LN12@basic_stri
  0005e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	85 c9		 test	 ecx, ecx
  0006a	74 11		 je	 SHORT $LN18@basic_stri
  0006c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006e	ff 50 08	 call	 DWORD PTR [eax+8]
  00071	85 c0		 test	 eax, eax
  00073	74 08		 je	 SHORT $LN18@basic_stri
  00075	8b 10		 mov	 edx, DWORD PTR [eax]
  00077	8b c8		 mov	 ecx, eax
  00079	6a 01		 push	 1
  0007b	ff 12		 call	 DWORD PTR [edx]
$LN18@basic_stri:
  0007d	6a 08		 push	 8
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00085	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
  00088	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0008b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008e	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  00096	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  00099	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009c	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0009f	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
  000a3	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  000a6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a9	c7 44 38 a8 00
	00 00 00	 mov	 DWORD PTR [eax+edi-88], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  000b1	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ba	89 44 39 a4	 mov	 DWORD PTR [ecx+edi-92], eax
  000be	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  000c1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c4	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  000cc	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  000cf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d2	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  000d5	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 591  : 		{	// construct empty character buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00034	83 7d 0c 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00038	74 22		 je	 SHORT $LN2@basic_stri
  0003a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
  00040	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
  00047	c7 47 68 00 00
	00 00		 mov	 DWORD PTR [edi+104], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_stri:

; 589  : 		: _Mybase(&_Stringbuffer),

  0005c	6a 00		 push	 0
  0005e	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00061	8b cf		 mov	 ecx, edi
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >

; 591  : 		{	// construct empty character buffer

  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0007c	8b 07		 mov	 eax, DWORD PTR [edi]
  0007e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00081	89 75 0c	 mov	 DWORD PTR _this$[ebp], esi
  00084	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00087	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  00092	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]
  00095	8b c3		 mov	 eax, ebx
  00097	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0009d	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  000a4	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  000ab	f7 d1		 not	 ecx
  000ad	83 e1 04	 and	 ecx, 4
  000b0	8b d1		 mov	 edx, ecx
  000b2	83 ca 02	 or	 edx, 2
  000b5	24 02		 and	 al, 2
  000b7	8b c3		 mov	 eax, ebx
  000b9	0f 45 d1	 cmovne	 edx, ecx
  000bc	8b ca		 mov	 ecx, edx
  000be	83 c9 08	 or	 ecx, 8
  000c1	24 08		 and	 al, 8
  000c3	0f 44 ca	 cmove	 ecx, edx
  000c6	8b c1		 mov	 eax, ecx
  000c8	83 c8 10	 or	 eax, 16			; 00000010H
  000cb	80 e3 04	 and	 bl, 4
  000ce	0f 44 c1	 cmove	 eax, ecx
  000d1	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 592  : 		}

  000d4	8b c7		 mov	 eax, edi
  000d6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e0	59		 pop	 ecx
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_stri
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN5@basic_stri:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 20	 add	 ecx, 32			; 00000020H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$3:
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__ehhandler$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z:
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 20	 lea	 edx, DWORD PTR [ecx+32]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 e0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-32], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  00032	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0003b	89 44 11 dc	 mov	 DWORD PTR [ecx+edx-36], eax
  0003f	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	c7 44 10 f0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-16], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  0004d	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00050	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00053	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00056	89 44 11 ec	 mov	 DWORD PTR [ecx+edx-20], eax
  0005a	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	c7 44 10 e0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-32], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00068	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0006b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006e	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00071	89 44 11 dc	 mov	 DWORD PTR [ecx+edx-36], eax
  00075	52		 push	 edx
  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00083	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00088	83 c4 04	 add	 esp, 4
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$4:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 e0	 lea	 esi, DWORD PTR [ecx-32]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	74 0b		 je	 SHORT $LN4@scalar
  00014	6a 68		 push	 104			; 00000068H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 983  : 		{	// destroy the object

  00000	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e0 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-32], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  0000e	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  00017	89 44 0a dc	 mov	 DWORD PTR [edx+ecx-36], eax

; 984  : 		}

  0001b	8d 51 f8	 lea	 edx, DWORD PTR [ecx-8]
  0001e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  0002c	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00035	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  00039	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0003c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003f	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00047	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00050	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  00054	c3		 ret	 0
??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 954  : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00032	83 7d 0c 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00036	74 22		 je	 SHORT $LN2@basic_iost
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
  0003e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], OFFSET ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
  00045	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_iost:

; 952  : 		: _Myis(_Strbuf, false),

  0005a	8b 06		 mov	 eax, DWORD PTR [esi]
  0005c	6a 00		 push	 0
  0005e	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  00061	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00064	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  0006b	8b 06		 mov	 eax, DWORD PTR [esi]
  0006d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00070	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00073	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  00077	8b 06		 mov	 eax, DWORD PTR [esi]
  00079	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00080	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00087	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008a	03 ce		 add	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init

; 953  : 			_Myos(_Noinit, false)

  00091	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  00094	89 55 0c	 mov	 DWORD PTR _this$[ebp], edx
  00097	8b 02		 mov	 eax, DWORD PTR [edx]
  00099	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009c	c7 04 02 00 00
	00 00		 mov	 DWORD PTR [edx+eax], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  000a3	8b 02		 mov	 eax, DWORD PTR [edx]
  000a5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a8	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ab	89 44 11 fc	 mov	 DWORD PTR [ecx+edx-4], eax

; 954  : 		{	// construct from stream buffer pointer

  000af	8b 06		 mov	 eax, DWORD PTR [esi]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b4	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c0	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  000c3	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax

; 955  : 		}

  000c7	8b c6		 mov	 eax, esi
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5e		 pop	 esi
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_iost
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 20	 add	 ecx, 32			; 00000020H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN5@basic_iost:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 18	 add	 ecx, 24			; 00000018H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
__ehhandler$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z:
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  00032	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003b	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  0003f	52		 push	 edx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  0004d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00052	83 c4 04	 add	 esp, 4
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
  00025	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00028	8d 72 f8	 lea	 esi, DWORD PTR [edx-8]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003e	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN16@scalar
  0005e	6a 50		 push	 80			; 00000050H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN16@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
$T2 = -40						; size = 20
__Ok$3 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush, COMDAT
; _this$ = ecx

; 574  : 		{	// flush output stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx

; 575  : 		if (_Myios::rdbuf() != 0)

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 7c 30 38 00	 cmp	 DWORD PTR [eax+esi+56], 0
  00032	0f 84 ce 00 00
	00		 je	 $LN102@flush

; 576  : 			{	// buffer exists, flush it
; 577  : 			const sentry _Ok(*this);

  00038	56		 push	 esi
  00039	8d 4d ec	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  0003c	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 578  : 
; 579  : 			if (_Ok && _Myios::rdbuf()->pubsync() == -1)

  00041	80 7d f0 00	 cmp	 BYTE PTR __Ok$3[ebp+4], 0
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	0f 84 83 00 00
	00		 je	 $LN56@flush
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00057	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0005b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005d	ff 50 34	 call	 DWORD PTR [eax+52]
  00060	83 f8 ff	 cmp	 eax, -1
  00063	75 70		 jne	 SHORT $LN56@flush

; 580  : 				_Myios::setstate(ios_base::badbit);	// sync failed

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006a	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0006e	03 d6		 add	 edx, esi
  00070	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00073	83 c9 04	 or	 ecx, 4
  00076	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0007a	0f 45 4a 0c	 cmovne	 ecx, DWORD PTR [edx+12]
  0007e	83 e1 13	 and	 ecx, 19			; 00000013H
  00081	83 c9 04	 or	 ecx, 4
  00084	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00087	23 c1		 and	 eax, ecx
  00089	74 4a		 je	 SHORT $LN56@flush
  0008b	a8 04		 test	 al, 4
  0008d	74 2a		 je	 SHORT $LN53@flush
  0008f	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN111@flush:
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0009f	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000a4	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000a9	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  000ac	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@flush:
$LN53@flush:
  000b9	a8 02		 test	 al, 2
  000bb	74 0c		 je	 SHORT $LN55@flush
  000bd	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000c7	eb d0		 jmp	 SHORT $LN111@flush
$LN55@flush:
  000c9	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000d3	eb c4		 jmp	 SHORT $LN111@flush
$LN56@flush:

; 581  : 			}

  000d5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000dc	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  000e1	84 c0		 test	 al, al
  000e3	75 08		 jne	 SHORT $LN98@flush
  000e5	8b 4d ec	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000e8	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN98@flush:
  000ed	8b 4d ec	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f9	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  000fd	85 c9		 test	 ecx, ecx
  000ff	74 05		 je	 SHORT $LN102@flush
  00101	8b 01		 mov	 eax, DWORD PTR [ecx]
  00103	ff 50 08	 call	 DWORD PTR [eax+8]
$LN102@flush:

; 582  : 		return (*this);

  00106	8b c6		 mov	 eax, esi

; 583  : 		}

  00108	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00112	59		 pop	 ecx
  00113	5e		 pop	 esi
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
$LN110@flush:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$14:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$15:
  0000e	e8 00 00 00 00	 call	 ___std_terminate
  00013	c3		 ret	 0
__ehhandler$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z
_TEXT	SEGMENT
$T2 = -108						; size = 20
$T3 = -88						; size = 20
$T4 = -68						; size = 20
$T5 = -48						; size = 8
$T6 = -40						; size = 8
__Ok$ = -32						; size = 8
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T7 = 8							; size = 8
__Val$ = 8						; size = 8
??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<, COMDAT
; _this$ = ecx

; 376  : 		{	// insert a long long

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 377  : 		ios_base::iostate _State = ios_base::goodbit;
; 378  : 		const sentry _Ok(*this);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	33 ff		 xor	 edi, edi
  00034	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi
  00037	89 75 e0	 mov	 DWORD PTR __Ok$[ebp], esi
  0003a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003d	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN19@operator
  00045	8b 01		 mov	 eax, DWORD PTR [ecx]
  00047	ff 50 04	 call	 DWORD PTR [eax+4]
$LN19@operator:
  0004a	8b 06		 mov	 eax, DWORD PTR [esi]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00053	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00056	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0005b	75 11		 jne	 SHORT $LN15@operator
  0005d	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00061	85 c9		 test	 ecx, ecx
  00063	74 09		 je	 SHORT $LN15@operator
  00065	3b ce		 cmp	 ecx, esi
  00067	74 05		 je	 SHORT $LN15@operator
  00069	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
$LN15@operator:
  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00073	03 ce		 add	 ecx, esi
  00075	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00079	0f 94 c0	 sete	 al
  0007c	88 45 e4	 mov	 BYTE PTR __Ok$[ebp+4], al
  0007f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 379  : 
; 380  : 		if (_Ok)

  00086	84 c0		 test	 al, al
  00088	74 74		 je	 SHORT $LN12@operator

; 381  : 			{	// state okay, use facet to insert
; 382  : 			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

  0008a	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00093	50		 push	 eax
  00094	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00098	e8 00 00 00 00	 call	 ??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
  0009d	83 c4 04	 add	 esp, 4
  000a0	8b d8		 mov	 ebx, eax
  000a2	8b 4d dc	 mov	 ecx, DWORD PTR $T6[ebp+4]
  000a5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  000a9	85 c9		 test	 ecx, ecx
  000ab	74 11		 je	 SHORT $LN44@operator
  000ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  000af	ff 52 08	 call	 DWORD PTR [edx+8]
  000b2	85 c0		 test	 eax, eax
  000b4	74 08		 je	 SHORT $LN44@operator
  000b6	8b 10		 mov	 edx, DWORD PTR [eax]
  000b8	8b c8		 mov	 ecx, eax
  000ba	6a 01		 push	 1
  000bc	ff 12		 call	 DWORD PTR [edx]
$LN44@operator:

; 383  : 
; 384  : 			_TRY_IO_BEGIN
; 385  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 386  : 				_Myios::fill(), _Val).failed())

  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	ff 75 0c	 push	 DWORD PTR __Val$[ebp+4]
  000c3	8b 13		 mov	 edx, DWORD PTR [ebx]
  000c5	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  000c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cb	0f b7 44 31 40	 movzx	 eax, WORD PTR [ecx+esi+64]
  000d0	03 ce		 add	 ecx, esi
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	c6 45 d0 00	 mov	 BYTE PTR $T5[ebp], 0
  000d8	8d 45 08	 lea	 eax, DWORD PTR $T7[ebp]
  000db	ff 71 38	 push	 DWORD PTR [ecx+56]
  000de	8b cb		 mov	 ecx, ebx
  000e0	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  000e4	ff 75 d0	 push	 DWORD PTR $T5[ebp]
  000e7	50		 push	 eax
  000e8	ff 52 1c	 call	 DWORD PTR [edx+28]
  000eb	80 7d 08 00	 cmp	 BYTE PTR $T7[ebp], 0
  000ef	b8 04 00 00 00	 mov	 eax, 4
  000f4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000fb	0f 45 f8	 cmovne	 edi, eax
$LN12@operator:

; 389  : 			}
; 390  : 
; 391  : 		_Myios::setstate(_State);

  000fe	8b 06		 mov	 eax, DWORD PTR [esi]
  00100	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00103	03 d6		 add	 edx, esi
  00105	85 ff		 test	 edi, edi
  00107	0f 84 ee 00 00
	00		 je	 $LN134@operator
  0010d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00110	0b c7		 or	 eax, edi
  00112	8b c8		 mov	 ecx, eax
  00114	83 c9 04	 or	 ecx, 4
  00117	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0011b	0f 45 c8	 cmovne	 ecx, eax
  0011e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00121	83 e1 17	 and	 ecx, 23			; 00000017H
  00124	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00127	23 c1		 and	 eax, ecx
  00129	0f 84 cc 00 00
	00		 je	 $LN134@operator
  0012f	a8 04		 test	 al, 4
  00131	74 70		 je	 SHORT $LN131@operator
  00133	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00138	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  0013d	50		 push	 eax
  0013e	6a 01		 push	 1
  00140	8d 4d bc	 lea	 ecx, DWORD PTR $T4[ebp]
  00143	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00148	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0014d	8d 45 bc	 lea	 eax, DWORD PTR $T4[ebp]
  00150	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN188@operator:
__catch$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$0:

; 387  : 				_State |= ios_base::badbit;
; 388  : 			_CATCH_IO_END

  0015d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00160	8b 01		 mov	 eax, DWORD PTR [ecx]
  00162	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00165	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00169	03 d1		 add	 edx, ecx
  0016b	83 c8 04	 or	 eax, 4
  0016e	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00172	75 03		 jne	 SHORT $LN66@operator
  00174	83 c8 04	 or	 eax, 4
$LN66@operator:
  00177	83 e0 17	 and	 eax, 23			; 00000017H
  0017a	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0017d	85 42 10	 test	 DWORD PTR [edx+16], eax
  00180	75 18		 jne	 SHORT $LN69@operator
  00182	b8 00 00 00 00	 mov	 eax, $LN13@operator
  00187	c3		 ret	 0
$LN13@operator:
  00188	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0018b	8b 7d e8	 mov	 edi, DWORD PTR __State$[ebp]
  0018e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00195	e9 64 ff ff ff	 jmp	 $LN12@operator
$LN69@operator:
  0019a	6a 00		 push	 0
  0019c	6a 00		 push	 0
  0019e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN189@operator:

; 389  : 			}
; 390  : 
; 391  : 		_Myios::setstate(_State);

$LN131@operator:
  001a3	a8 02		 test	 al, 2
  001a5	74 2a		 je	 SHORT $LN133@operator
  001a7	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  001b1	50		 push	 eax
  001b2	6a 01		 push	 1
  001b4	8d 4d a8	 lea	 ecx, DWORD PTR $T3[ebp]
  001b7	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  001bc	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001c1	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  001c4	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN190@operator:
$LN133@operator:
  001d1	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  001db	50		 push	 eax
  001dc	6a 01		 push	 1
  001de	8d 4d 94	 lea	 ecx, DWORD PTR $T2[ebp]
  001e1	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  001e6	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001eb	8d 45 94	 lea	 eax, DWORD PTR $T2[ebp]
  001ee	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN191@operator:
$LN134@operator:

; 392  : 		return (*this);

  001fb	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  00202	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  00207	84 c0		 test	 al, al
  00209	75 07		 jne	 SHORT $LN175@operator
  0020b	8b ce		 mov	 ecx, esi
  0020d	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN175@operator:
  00212	8b 06		 mov	 eax, DWORD PTR [esi]
  00214	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  00218	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021b	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0021f	85 c9		 test	 ecx, ecx
  00221	74 05		 je	 SHORT $LN179@operator
  00223	8b 01		 mov	 eax, DWORD PTR [ecx]
  00225	ff 50 08	 call	 DWORD PTR [eax+8]
$LN179@operator:
  00228	8b c6		 mov	 eax, esi

; 393  : 		}

  0022a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0022d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00234	59		 pop	 ecx
  00235	5f		 pop	 edi
  00236	5e		 pop	 esi
  00237	5b		 pop	 ebx
  00238	8b e5		 mov	 esp, ebp
  0023a	5d		 pop	 ebp
  0023b	c2 08 00	 ret	 8
$LN187@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$4:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$2:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$3:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$5:
  00018	e8 00 00 00 00	 call	 ___std_terminate
  0001d	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$32:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z$33:
  00024	e8 00 00 00 00	 call	 ___std_terminate
  00029	c3		 ret	 0
__ehhandler$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z:
  0002a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00031	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -76						; size = 20
$T3 = -56						; size = 20
$T4 = -36						; size = 20
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx, COMDAT
; _this$ = ecx

; 165  : 		{	// perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 166  : 		_TRY_BEGIN
; 167  : 		if (this->good() && this->flags() & ios_base::unitbuf)

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00036	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00039	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0003e	0f 85 d3 00 00
	00		 jne	 $LN9@Osfx
  00044	f6 44 30 14 02	 test	 BYTE PTR [eax+esi+20], 2
  00049	0f 84 c8 00 00
	00		 je	 $LN9@Osfx

; 168  : 			if (_Myios::rdbuf()->pubsync() == -1)	// flush stream as needed

  0004f	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	ff 50 34	 call	 DWORD PTR [eax+52]
  00058	83 f8 ff	 cmp	 eax, -1
  0005b	0f 85 b6 00 00
	00		 jne	 $LN9@Osfx

; 169  : 				_Myios::setstate(ios_base::badbit);

  00061	8b 06		 mov	 eax, DWORD PTR [esi]
  00063	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00066	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0006a	03 d6		 add	 edx, esi
  0006c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0006f	83 c9 04	 or	 ecx, 4
  00072	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00076	0f 45 4a 0c	 cmovne	 ecx, DWORD PTR [edx+12]
  0007a	83 e1 13	 and	 ecx, 19			; 00000013H
  0007d	83 c9 04	 or	 ecx, 4
  00080	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00083	23 c1		 and	 eax, ecx
  00085	0f 84 8c 00 00
	00		 je	 $LN9@Osfx
  0008b	a8 04		 test	 al, 4
  0008d	74 2a		 je	 SHORT $LN34@Osfx
  0008f	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8d 4d dc	 lea	 ecx, DWORD PTR $T4[ebp]
  0009f	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000a4	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000a9	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  000ac	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN80@Osfx:
$LN34@Osfx:
  000b9	a8 02		 test	 al, 2
  000bb	74 2a		 je	 SHORT $LN36@Osfx
  000bd	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000c7	50		 push	 eax
  000c8	6a 01		 push	 1
  000ca	8d 4d c8	 lea	 ecx, DWORD PTR $T3[ebp]
  000cd	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000d2	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000d7	8d 45 c8	 lea	 eax, DWORD PTR $T3[ebp]
  000da	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN81@Osfx:
$LN36@Osfx:
  000e7	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000f1	50		 push	 eax
  000f2	6a 01		 push	 1
  000f4	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  000f7	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000fc	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00101	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  00104	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN82@Osfx:
__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$0:

; 170  : 		_CATCH_ALL
; 171  : 		_CATCH_END

  00111	b8 00 00 00 00	 mov	 eax, $LN9@Osfx
  00116	c3		 ret	 0
$LN9@Osfx:

; 172  : 		}

  00117	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0011a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00121	59		 pop	 ecx
  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
$LN79@Osfx:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::~basic_ostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 88   : 		{	// destroy the object

  00000	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 f8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  0000e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00017	89 44 0a f4	 mov	 DWORD PTR [edx+ecx-12], eax

; 89   : 		}

  0001b	c3		 ret	 0
??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::~basic_ostream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
__Addit$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::basic_ostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 58   : 	__CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 59   : 		{	// construct uninitialized

  0002b	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00036	74 1b		 je	 SHORT $LN2@basic_ostr
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@
  0003e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_ostr:

; 60   : 		if (_Addit)

  00053	80 7d 0c 00	 cmp	 BYTE PTR __Addit$[ebp], 0
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  00063	8b 06		 mov	 eax, DWORD PTR [esi]
  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00068	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0006b	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  0006f	74 10		 je	 SHORT $LN13@basic_ostr

; 61   : 			this->_Addstd(this);	// suppress for basic_iostream

  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00076	03 c6		 add	 eax, esi
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  0007e	83 c4 04	 add	 esp, 4
$LN13@basic_ostr:

; 62   : 		}

  00081	8b c6		 mov	 eax, esi
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN8@basic_ostr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN8@basic_ostr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::basic_ostream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00032	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003b	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  0003f	52		 push	 edx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  0004d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00052	83 c4 04	 add	 esp, 4
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
  00025	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00028	8d 72 e8	 lea	 esi, DWORD PTR [edx-24]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003e	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN16@scalar
  0005e	6a 60		 push	 96			; 00000060H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN16@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 81   : 		{	// destroy the object

  00000	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  0000e	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e8	 lea	 eax, DWORD PTR [edx-24]
  00017	89 44 0a e4	 mov	 DWORD PTR [edx+ecx-28], eax

; 82   : 		}

  0001b	c3		 ret	 0
??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::basic_istream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 46   : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00036	74 1b		 je	 SHORT $LN2@basic_istr
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@
  0003e	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_istr:
  00053	8b 06		 mov	 eax, DWORD PTR [esi]

; 47   : 		_Myios::init(_Strbuf, _Isstd);

  00055	ff 75 0c	 push	 DWORD PTR __Isstd$[ebp]
  00058	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  0005b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005e	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006a	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0006d	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0007a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00081	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00084	03 ce		 add	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init

; 48   : 		}

  0008b	8b c6		 mov	 eax, esi
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5e		 pop	 esi
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_istr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 18	 add	 ecx, 24			; 00000018H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN5@basic_istr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::basic_istream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	56		 push	 esi
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00033	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00038	83 c4 04	 add	 esp, 4
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN10@scalar
  00041	6a 48		 push	 72			; 00000048H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::basic_ios<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 183  : 	__CLR_OR_THIS_CALL basic_ios()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 		{	// default constructor, do nothing
; 185  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::basic_ios<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
_TEXT	SEGMENT
$T2 = -60						; size = 20
$T3 = -40						; size = 20
$T4 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init, COMDAT
; _this$ = ecx

; 170  : 		{	// initialize with stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 171  : 		_Init();	// initialize ios_base

  00029	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init

; 172  : 		_Mystrbuf = _Strbuf;

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]

; 173  : 		_Tiestr = 0;
; 174  : 		_Fillch = widen(' ');

  00031	8b ce		 mov	 ecx, esi
  00033	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  00039	50		 push	 eax
  0003a	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  00041	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00046	50		 push	 eax
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004e	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00053	83 c4 04	 add	 esp, 4
  00056	8b f8		 mov	 edi, eax
  00058	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp+4]
  0005b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00062	85 c9		 test	 ecx, ecx
  00064	74 11		 je	 SHORT $LN11@init
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	ff 52 08	 call	 DWORD PTR [edx+8]
  0006b	85 c0		 test	 eax, eax
  0006d	74 08		 je	 SHORT $LN11@init
  0006f	8b 10		 mov	 edx, DWORD PTR [eax]
  00071	8b c8		 mov	 ecx, eax
  00073	6a 01		 push	 1
  00075	ff 12		 call	 DWORD PTR [edx]
$LN11@init:
  00077	8b 07		 mov	 eax, DWORD PTR [edi]
  00079	8b cf		 mov	 ecx, edi
  0007b	6a 20		 push	 32			; 00000020H
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00084	ff 50 30	 call	 DWORD PTR [eax+48]

; 175  : 
; 176  : 		if (_Mystrbuf == 0)

  00087	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  0008b	66 89 46 40	 mov	 WORD PTR [esi+64], ax
  0008f	75 79		 jne	 SHORT $LN33@init

; 177  : 			setstate(badbit);

  00091	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00094	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00097	83 e0 13	 and	 eax, 19			; 00000013H
  0009a	83 c8 04	 or	 eax, 4
  0009d	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000a0	23 c8		 and	 ecx, eax
  000a2	74 66		 je	 SHORT $LN33@init
  000a4	f6 c1 04	 test	 cl, 4
  000a7	74 2a		 je	 SHORT $LN30@init
  000a9	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN76@init:
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  000b9	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000be	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000c5	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  000c8	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
$LN77@init:
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN78@init:
$LN30@init:
  000d3	f6 c1 02	 test	 cl, 2
  000d6	74 0c		 je	 SHORT $LN32@init
  000d8	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000e2	eb cf		 jmp	 SHORT $LN76@init
$LN32@init:
  000e4	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000ee	50		 push	 eax
  000ef	6a 01		 push	 1
  000f1	8d 4d c4	 lea	 ecx, DWORD PTR $T2[ebp]
  000f4	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000f9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00100	8d 45 c4	 lea	 eax, DWORD PTR $T2[ebp]
  00103	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00108	eb c3		 jmp	 SHORT $LN77@init
$LN33@init:

; 178  : 
; 179  : 		if (_Isstd)

  0010a	80 7d 0c 00	 cmp	 BYTE PTR __Isstd$[ebp], 0
  0010e	74 09		 je	 SHORT $LN3@init

; 180  : 			_Addstd(this);	// special handling for standard streams

  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  00116	83 c4 04	 add	 esp, 4
$LN3@init:

; 181  : 		}

  00119	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00123	59		 pop	 ecx
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN75@init:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$1:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__ehhandler$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
_TEXT	SEGMENT
$T2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::widen, COMDAT
; _this$ = ecx

; 130  : 		{	// convert _Byte to character using imbued locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 131  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

  00026	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0002f	50		 push	 eax
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b f0		 mov	 esi, eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp+4]
  00044	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0004b	85 c9		 test	 ecx, ecx
  0004d	74 11		 je	 SHORT $LN7@widen
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	ff 52 08	 call	 DWORD PTR [edx+8]
  00054	85 c0		 test	 eax, eax
  00056	74 08		 je	 SHORT $LN7@widen
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b c8		 mov	 ecx, eax
  0005c	6a 01		 push	 1
  0005e	ff 12		 call	 DWORD PTR [edx]
$LN7@widen:

; 132  : 		return (_Ctype_fac.widen(_Byte));

  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	8b ce		 mov	 ecx, esi
  00064	ff 75 08	 push	 DWORD PTR __Byte$[ebp]
  00067	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006e	ff 50 30	 call	 DWORD PTR [eax+48]

; 133  : 		}

  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007b	59		 pop	 ecx
  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$1:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__ehhandler$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::widen
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT
?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill, COMDAT
; _this$ = ecx

; 113  : 		return (_Fillch);

  00000	66 8b 41 40	 mov	 ax, WORD PTR [ecx+64]

; 114  : 		}

  00004	c3		 ret	 0
?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf, COMDAT
; _this$ = ecx

; 92   : 		return (_Mystrbuf);

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]

; 93   : 		}

  00003	c3		 ret	 0
?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::tie, COMDAT
; _this$ = ecx

; 80   : 		return (_Tiestr);

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]

; 81   : 		}

  00003	c3		 ret	 0
?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::tie
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate, COMDAT
; _this$ = ecx

; 58   : 		{	// merge _State into state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 		if (_State != goodbit)

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1a		 je	 SHORT $LN2@setstate

; 60   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

  0000a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0000d	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00010	0b d0		 or	 edx, eax
  00012	8b c2		 mov	 eax, edx
  00014	83 c8 04	 or	 eax, 4
  00017	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0001b	0f 45 c2	 cmovne	 eax, edx
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN2@setstate:

; 61   : 		}

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::clear, COMDAT
; _this$ = ecx

; 44   : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]

; 45   : 		ios_base::clear((iostate)(_Mystrbuf == 0

  00006	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00009	83 ca 04	 or	 edx, 4
  0000c	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00010	0f 45 55 08	 cmovne	 edx, DWORD PTR __State$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);
; 47   : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 39   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 40   : 		}

  00022	51		 push	 ecx
  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00030	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@@Z
_TEXT	SEGMENT
_forEachContainer$ = 8					; size = 4
___formal$ = 12						; size = 4
??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >, COMDAT

; 95   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 			return static_cast <const ContainerForward <T> &> (forEachContainer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _forEachContainer$[ebp]

; 97   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$?BV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@12@XZ PROC ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::vector<HostDevice,std::allocator<HostDevice> > > GostCrypt::ForEach::TypeWrapper<std::vector<HostDevice,std::allocator<HostDevice> > >, COMDAT
; _this$ = ecx

; 90   : 			operator TypeWrapper <T> () const { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
??$?BV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@12@XZ ENDP ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::vector<HostDevice,std::allocator<HostDevice> > > GostCrypt::ForEach::TypeWrapper<std::vector<HostDevice,std::allocator<HostDevice> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$ToTypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
_x$ = 8							; size = 4
??$ToTypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::ToTypeWrapper<std::vector<HostDevice,std::allocator<HostDevice> > >, COMDAT

; 85   : 		static TypeWrapper <T> ToTypeWrapper (const T &x) { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8a 45 ff	 mov	 al, BYTE PTR $T1[ebp]
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$ToTypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ToTypeWrapper<std::vector<HostDevice,std::allocator<HostDevice> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z PROC ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00009	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00018	74 0b		 je	 SHORT $LN13@scalar
  0001a	6a 1c		 push	 28			; 0000001cH
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::~ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00006	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy
  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00011	5e		 pop	 esi
  00012	c3		 ret	 0
??1?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::~ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::_Compat, COMDAT
; _this$ = ecx

; 262  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 95 c0	 setne	 al

; 219  : 		return (!(*this == _Right));
; 220  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 213  : 		_Compat(_Right);
; 214  : 		return (_Ptr == _Right._Ptr);
; 215  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)
; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 103  : 			_SCL_SECURE_OUT_OF_RANGE;
; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

  00000	83 01 70	 add	 DWORD PTR [ecx], 112	; 00000070H

; 114  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 115  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEABUHostDevice@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEABUHostDevice@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)
; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 74   : 			_SCL_SECURE_OUT_OF_RANGE;
; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEABUHostDevice@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEPBUHostDevice@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEPBUHostDevice@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::_Unchecked, COMDAT
; _this$ = ecx

; 61   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 62   : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QBEPBUHostDevice@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QAE@PAUHostDevice@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QAE@PAUHostDevice@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@std@@QAE@PAUHostDevice@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HostDevice> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Next@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
_TEXT	SEGMENT
?Next@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::Next, COMDAT
; _this$ = ecx

; 39   : 			virtual void Next () const { ++Iterator; }

  00000	83 41 18 70	 add	 DWORD PTR [ecx+24], 112	; 00000070H
  00004	c3		 ret	 0
?Next@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::Next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?IsNotEnd@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
_TEXT	SEGMENT
?IsNotEnd@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::IsNotEnd, COMDAT
; _this$ = ecx

; 38   : 			virtual bool IsNotEnd () const { bool r = InnerContinue && Iterator != EndIterator; InnerContinue = false; return r; }

  00000	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00004	74 0f		 je	 SHORT $LN3@IsNotEnd
  00006	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00009	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0000c	74 07		 je	 SHORT $LN3@IsNotEnd
  0000e	b0 01		 mov	 al, 1
  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00014	c3		 ret	 0
$LN3@IsNotEnd:
  00015	32 c0		 xor	 al, al
  00017	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0001a	c3		 ret	 0
?IsNotEnd@?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::IsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_container$ = 8						; size = 4
??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >, COMDAT
; _this$ = ecx

; 36   : 				: ContainerCopy (container), EndIterator (ContainerCopy.end()), Iterator (ContainerCopy.begin()) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002a	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00030	ff 75 08	 push	 DWORD PTR _container$[ebp]
  00033	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@6B@
  00043	e8 00 00 00 00	 call	 ??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::vector<HostDevice,std::allocator<HostDevice> >
  00048	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0004b	89 47 14	 mov	 DWORD PTR [edi+20], eax
  0004e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00051	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00054	8b c7		 mov	 eax, edi
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >::ContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_container$ = 12					; size = 4
??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >, COMDAT

; 69   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 70   : 			return ContainerForward <T> (container);

  00025	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002f	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00035	ff 75 0c	 push	 DWORD PTR _container$[ebp]
  00038	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@6B@
  00048	e8 00 00 00 00	 call	 ??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::vector<HostDevice,std::allocator<HostDevice> >
  0004d	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00050	8b c7		 mov	 eax, edi
  00052	89 4f 14	 mov	 DWORD PTR [edi+20], ecx
  00055	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00058	89 4f 18	 mov	 DWORD PTR [edi+24], ecx

; 71   : 		}

  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z$1:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?FileSize4GBLimitQuestionNeeded@@YAHXZ
_TEXT	SEGMENT
_geometry$1 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
?FileSize4GBLimitQuestionNeeded@@YAHXZ PROC		; FileSize4GBLimitQuestionNeeded, COMDAT

; 3819 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3820 : 	uint64 dataAreaSize = GetVolumeDataAreaSize (bHiddenVol && !bHiddenVolHost, nVolumeSize);

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00017	74 10		 je	 SHORT $LN3@FileSize4G
  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00020	75 07		 jne	 SHORT $LN3@FileSize4G
  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	eb 02		 jmp	 SHORT $LN4@FileSize4G
$LN3@FileSize4G:
  00029	33 c0		 xor	 eax, eax
$LN4@FileSize4G:
  0002b	56		 push	 esi
  0002c	57		 push	 edi
  0002d	ff 35 04 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA+4
  00033	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  0003f	8b fa		 mov	 edi, edx
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	8b f0		 mov	 esi, eax

; 3821 : 
; 3822 : 	return (dataAreaSize > 4 * BYTES_PER_GB + GST_MIN_FAT_FS_SIZE

  00046	83 ff 01	 cmp	 edi, 1
  00049	72 65		 jb	 SHORT $LN5@FileSize4G
  0004b	77 08		 ja	 SHORT $LN11@FileSize4G
  0004d	81 fe 00 90 00
	00		 cmp	 esi, 36864		; 00009000H
  00053	76 5b		 jbe	 SHORT $LN5@FileSize4G
$LN11@FileSize4G:
  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  0005c	75 07		 jne	 SHORT $LN8@FileSize4G
  0005e	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00063	eb 2b		 jmp	 SHORT $LN7@FileSize4G
$LN8@FileSize4G:
  00065	8d 45 e4	 lea	 eax, DWORD PTR _geometry$1[ebp]
  00068	50		 push	 eax
  00069	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0006e	e8 00 00 00 00	 call	 _GetDriveGeometry
  00073	83 c4 08	 add	 esp, 8
  00076	85 c0		 test	 eax, eax
  00078	75 13		 jne	 SHORT $LN9@FileSize4G
  0007a	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00080	e8 00 00 00 00	 call	 _handleWin32Error
  00085	83 c4 04	 add	 esp, 4
  00088	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN9@FileSize4G:
  0008d	8b 45 f8	 mov	 eax, DWORD PTR _geometry$1[ebp+20]
$LN7@FileSize4G:
  00090	99		 cdq
  00091	3b f8		 cmp	 edi, eax
  00093	77 1b		 ja	 SHORT $LN5@FileSize4G
  00095	72 04		 jb	 SHORT $LN12@FileSize4G
  00097	85 f6		 test	 esi, esi
  00099	75 15		 jne	 SHORT $LN5@FileSize4G
$LN12@FileSize4G:
  0009b	5f		 pop	 edi
  0009c	b8 01 00 00 00	 mov	 eax, 1
  000a1	5e		 pop	 esi

; 3823 : 		&& dataAreaSize <= GST_MAX_FAT_SECTOR_COUNT * GetFormatSectorSize());
; 3824 : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
$LN5@FileSize4G:
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b3	33 c0		 xor	 eax, eax
  000b5	5f		 pop	 edi
  000b6	33 cd		 xor	 ecx, ebp
  000b8	5e		 pop	 esi
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?FileSize4GBLimitQuestionNeeded@@YAHXZ ENDP		; FileSize4GBLimitQuestionNeeded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?CheckGapBetweenSysAndHiddenOS@@YAHXZ
_TEXT	SEGMENT
_e$2 = -456						; size = 4
$T3 = -452						; size = 112
_sysDriveCfg$4 = -340					; size = 320
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?CheckGapBetweenSysAndHiddenOS@@YAHXZ PROC		; CheckGapBetweenSysAndHiddenOS, COMDAT

; 2047 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CheckGapBetweenSysAndHiddenOS@@YAHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec bc 01 00
	00		 sub	 esp, 444		; 000001bcH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2048 : 	try
; 2049 : 	{
; 2050 : 		SystemDriveConfiguration sysDriveCfg = BootEncObj->GetSystemDriveConfiguration();

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00037	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _sysDriveCfg$4[ebp]
  0003d	50		 push	 eax
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00045	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration

; 2051 : 
; 2052 : 		return (sysDriveCfg.SystemPartition.Info.StartingOffset.QuadPart 

  0004a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00050	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00056	50		 push	 eax
  00057	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0005b	e8 00 00 00 00	 call	 ?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ ; GostCrypt::BootEncryption::GetPartitionForHiddenOS
  00060	8b 55 8c	 mov	 edx, DWORD PTR _sysDriveCfg$4[ebp+224]
  00063	03 55 84	 add	 edx, DWORD PTR _sysDriveCfg$4[ebp+216]
  00066	8b 4d 90	 mov	 ecx, DWORD PTR _sysDriveCfg$4[ebp+228]
  00069	13 4d 88	 adc	 ecx, DWORD PTR _sysDriveCfg$4[ebp+220]
  0006c	81 c2 00 00 02
	04		 add	 edx, 67239936		; 04020000H
  00072	83 d1 00	 adc	 ecx, 0
  00075	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  00078	7f 0e		 jg	 SHORT $LN4@CheckGapBe
  0007a	7c 05		 jl	 SHORT $LN12@CheckGapBe
  0007c	3b 50 18	 cmp	 edx, DWORD PTR [eax+24]
  0007f	77 07		 ja	 SHORT $LN4@CheckGapBe
$LN12@CheckGapBe:
  00081	be 01 00 00 00	 mov	 esi, 1
  00086	eb 02		 jmp	 SHORT $LN5@CheckGapBe
$LN4@CheckGapBe:
  00088	33 f6		 xor	 esi, esi
$LN5@CheckGapBe:
  0008a	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00090	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  00095	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _sysDriveCfg$4[ebp]
  0009b	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  000a0	8b c6		 mov	 eax, esi
  000a2	eb 18		 jmp	 SHORT $LN1@CheckGapBe
__catch$?CheckGapBetweenSysAndHiddenOS@@YAHXZ$0:

; 2053 : 			+ sysDriveCfg.SystemPartition.Info.PartitionLength.QuadPart
; 2054 : 			+ 64 * BYTES_PER_MB
; 2055 : 			+ 128 * BYTES_PER_KB
; 2056 : 			<= BootEncObj->GetPartitionForHiddenOS().Info.StartingOffset.QuadPart);
; 2057 : 	}
; 2058 : 	catch (Exception &e)
; 2059 : 	{
; 2060 : 		e.Show (MainDlg);

  000a4	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  000aa	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000b0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b2	ff 10		 call	 DWORD PTR [eax]

; 2061 : 	}

  000b4	b8 00 00 00 00	 mov	 eax, $LN11@CheckGapBe
  000b9	c3		 ret	 0
$LN11@CheckGapBe:

; 2062 : 
; 2063 : 	return FALSE;

  000ba	33 c0		 xor	 eax, eax
$LN1@CheckGapBe:

; 2064 : }

  000bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c6	59		 pop	 ecx
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cd	33 cd		 xor	 ecx, ebp
  000cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckGapBetweenSysAndHiddenOS@@YAHXZ$2:
  00000	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _sysDriveCfg$4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__ehhandler$?CheckGapBetweenSysAndHiddenOS@@YAHXZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 34 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-460]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckGapBetweenSysAndHiddenOS@@YAHXZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckGapBetweenSysAndHiddenOS@@YAHXZ ENDP		; CheckGapBetweenSysAndHiddenOS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?GetDevicePathForHiddenOS@@YAHXZ
_TEXT	SEGMENT
_e$2 = -140						; size = 4
_tmpbDevice$ = -136					; size = 4
$T3 = -132						; size = 112
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?GetDevicePathForHiddenOS@@YAHXZ PROC			; GetDevicePathForHiddenOS, COMDAT

; 2016 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetDevicePathForHiddenOS@@YAHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2017 : 	BOOL tmpbDevice = FALSE;
; 2018 : 
; 2019 : 	try
; 2020 : 	{
; 2021 : 		strncpy (szFileName, BootEncObj->GetPartitionForHiddenOS().DevicePath.c_str(), sizeof(szFileName));

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00037	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0003d	50		 push	 eax
  0003e	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpbDevice$[ebp], 0
  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0004f	e8 00 00 00 00	 call	 ?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ ; GostCrypt::BootEncryption::GetPartitionForHiddenOS
  00054	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00058	72 02		 jb	 SHORT $LN25@GetDeviceP
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN25@GetDeviceP:
  0005c	68 05 01 00 00	 push	 261			; 00000105H
  00061	50		 push	 eax
  00062	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  00067	e8 00 00 00 00	 call	 _strncpy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00075	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ

; 2022 : 
; 2023 : 		CreateFullVolumePath (szDiskFile, szFileName, &tmpbDevice);

  0007a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _tmpbDevice$[ebp]
  00080	50		 push	 eax
  00081	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  00086	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0008b	e8 00 00 00 00	 call	 _CreateFullVolumePath
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2029 : 	}
; 2030 : 
; 2031 : 	return (szFileName[0] != 0 

  00093	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?szFileName@@3PADA, 0
  0009a	74 2f		 je	 SHORT $LN10@GetDeviceP
  0009c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?szDiskFile@@3PADA, 0
  000a3	74 26		 je	 SHORT $LN10@GetDeviceP
  000a5	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR _tmpbDevice$[ebp], 0
  000ac	74 1d		 je	 SHORT $LN10@GetDeviceP
  000ae	b8 01 00 00 00	 mov	 eax, 1
  000b3	eb 18		 jmp	 SHORT $LN1@GetDeviceP
__catch$?GetDevicePathForHiddenOS@@YAHXZ$0:

; 2024 : 	}
; 2025 : 	catch (Exception &e)
; 2026 : 	{
; 2027 : 		e.Show (MainDlg);

  000b5	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  000bb	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000c1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c3	ff 10		 call	 DWORD PTR [eax]

; 2028 : 		return FALSE;

  000c5	b8 00 00 00 00	 mov	 eax, $LN10@GetDeviceP
  000ca	c3		 ret	 0
$LN10@GetDeviceP:
  000cb	33 c0		 xor	 eax, eax
$LN1@GetDeviceP:

; 2032 : 		&& szDiskFile[0] != 0 
; 2033 : 		&& tmpbDevice);
; 2034 : }

  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d7	59		 pop	 ecx
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000de	33 cd		 xor	 ecx, ebp
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?GetDevicePathForHiddenOS@@YAHXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetDevicePathForHiddenOS@@YAHXZ
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetDevicePathForHiddenOS@@YAHXZ ENDP			; GetDevicePathForHiddenOS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?SysEncResume@@YAXXZ
_TEXT	SEGMENT
_locBootEncStatus$ = -220				; size = 94
_e$2 = -124						; size = 4
_e$3 = -120						; size = 4
$T4 = -116						; size = 94
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?SysEncResume@@YAXXZ PROC				; SysEncResume, COMDAT

; 1922 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SysEncResume@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1923 : 	BootEncryptionStatus locBootEncStatus;
; 1924 : 
; 1925 : 	if (CreateSysEncMutex ())

  00031	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00036	85 c0		 test	 eax, eax
  00038	0f 84 fd 01 00
	00		 je	 $LN4@SysEncResu

; 1926 : 	{
; 1927 : 		EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), FALSE);

  0003e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  00044	6a 00		 push	 0
  00046	68 41 04 00 00	 push	 1089			; 00000441H
  0004b	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00051	ff d3		 call	 ebx
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1928 : 
; 1929 : 		try
; 1930 : 		{
; 1931 : 			locBootEncStatus = BootEncObj->GetStatus();

  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00060	8d 45 8c	 lea	 eax, DWORD PTR $T4[ebp]
  00063	50		 push	 eax
  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0006b	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00070	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00075	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0007c	8b f0		 mov	 esi, eax
  0007e	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$[ebp]
  00084	f3 a5		 rep movsd
  00086	66 a5		 movsw
  00088	83 bd 62 ff ff
	ff 00		 cmp	 DWORD PTR _locBootEncStatus$[ebp+62], 0
  0008f	74 4a		 je	 SHORT $LN7@SysEncResu

; 1939 : 		}
; 1940 : 
; 1941 : 		if (locBootEncStatus.SetupInProgress)
; 1942 : 		{
; 1943 : 			// Prevent the OS from entering Sleep mode when idle
; 1944 : 			SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);

  00091	68 01 00 00 80	 push	 -2147483647		; 80000001H
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadExecutionState@4

; 1945 : 
; 1946 : 			bSystemEncryptionInProgress = TRUE;

  0009c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, 1 ; bSystemEncryptionInProgress

; 1947 : 			UpdateSysEncControls ();

  000a6	e8 00 00 00 00	 call	 ?UpdateSysEncControls@@YAXXZ ; UpdateSysEncControls

; 1948 : 			SetTimer (MainDlg, TIMER_ID_SYSENC_PROGRESS, TIMER_INTERVAL_SYSENC_PROGRESS, NULL);

  000ab	6a 00		 push	 0
  000ad	6a 1e		 push	 30			; 0000001eH
  000af	68 00 01 00 00	 push	 256			; 00000100H
  000b4	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 1949 : 			EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), TRUE);

  000c0	6a 01		 push	 1
  000c2	68 41 04 00 00	 push	 1089			; 00000441H
  000c7	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  000cd	ff d3		 call	 ebx
  000cf	50		 push	 eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1950 : 			return;

  000d6	e9 6d 01 00 00	 jmp	 $LN5@SysEncResu
$LN7@SysEncResu:

; 1951 : 		}
; 1952 : 
; 1953 : 		bSystemEncryptionInProgress = FALSE;

  000db	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, 0 ; bSystemEncryptionInProgress

; 1954 : 		WaitCursor ();

  000e5	e8 00 00 00 00	 call	 _WaitCursor

; 1955 : 
; 1956 : 		try
; 1957 : 		{
; 1958 : 			switch (SystemEncryptionStatus)

  000ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionStatus
  000ef	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  000f6	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  000fb	74 2d		 je	 SHORT $LN9@SysEncResu
  000fd	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  00102	75 45		 jne	 SHORT $LN11@SysEncResu

; 1963 : 				break;
; 1964 : 
; 1965 : 			case SYSENC_STATUS_DECRYPTING:
; 1966 : 
; 1967 : 				if (locBootEncStatus.DriveMounted)	// If the drive is not encrypted we will just deinstall

  00104	83 bd 2a ff ff
	ff 00		 cmp	 DWORD PTR _locBootEncStatus$[ebp+6], 0
  0010b	74 3c		 je	 SHORT $LN11@SysEncResu

; 1968 : 					BootEncObj->StartDecryption (DiscardUnreadableEncryptedSectors);	

  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DiscardUnreadableEncryptedSectors@@3HC ; DiscardUnreadableEncryptedSectors
  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?StartDecryption@BootEncryption@GostCrypt@@QAEXH@Z ; GostCrypt::BootEncryption::StartDecryption

; 1969 : 
; 1970 : 				break;
; 1971 : 			}
; 1972 : 
; 1973 : 			bSystemEncryptionInProgress = TRUE;

  0011e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, 1 ; bSystemEncryptionInProgress
  00128	eb 44		 jmp	 SHORT $LN23@SysEncResu
$LN9@SysEncResu:

; 1959 : 			{
; 1960 : 			case SYSENC_STATUS_ENCRYPTING:
; 1961 : 
; 1962 : 				BootEncObj->StartEncryption (nWipeMode, bTryToCorrectReadErrors ? true : false);	

  0012a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bTryToCorrectReadErrors@@3HC, 0 ; bTryToCorrectReadErrors
  00131	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00137	0f 95 c0	 setne	 al
  0013a	0f b6 c0	 movzx	 eax, al
  0013d	50		 push	 eax
  0013e	ff 35 00 00 00
	00		 push	 DWORD PTR _nWipeMode
  00144	e8 00 00 00 00	 call	 ?StartEncryption@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@_N@Z ; GostCrypt::BootEncryption::StartEncryption
$LN11@SysEncResu:

; 1969 : 
; 1970 : 				break;
; 1971 : 			}
; 1972 : 
; 1973 : 			bSystemEncryptionInProgress = TRUE;

  00149	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, 1 ; bSystemEncryptionInProgress
  00153	eb 19		 jmp	 SHORT $LN23@SysEncResu
__catch$?SysEncResume@@YAXXZ$2:

; 1974 : 		}
; 1975 : 		catch (Exception &e)
; 1976 : 		{
; 1977 : 			e.Show (MainDlg);

  00155	8b 4d 88	 mov	 ecx, DWORD PTR _e$3[ebp]
  00158	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0015e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00160	ff 10		 call	 DWORD PTR [eax]

; 1978 : 		}

  00162	b8 00 00 00 00	 mov	 eax, $LN21@SysEncResu
  00167	c3		 ret	 0
$LN21@SysEncResu:
  00168	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
$LN23@SysEncResu:
  0016e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1979 : 
; 1980 : 		NormalCursor ();
; 1981 : 
; 1982 : 		if (!bSystemEncryptionInProgress)

  00175	e8 00 00 00 00	 call	 _NormalCursor
  0017a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, 0 ; bSystemEncryptionInProgress
  00181	75 2b		 jne	 SHORT $LN12@SysEncResu

; 1983 : 		{
; 1984 : 			// Allow the OS to enter Sleep mode when idle
; 1985 : 			SetThreadExecutionState (ES_CONTINUOUS);

  00183	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadExecutionState@4

; 1986 : 
; 1987 : 			EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), TRUE);

  0018e	6a 01		 push	 1
  00190	68 41 04 00 00	 push	 1089			; 00000441H
  00195	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0019b	ff d3		 call	 ebx
  0019d	50		 push	 eax
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1988 : 			Error ("FAILED_TO_RESUME_SYSTEM_ENCRYPTION");

  001a4	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@HEMAICHN@FAILED_TO_RESUME_SYSTEM_ENCRYPTI@

; 1989 : 			return;

  001a9	e9 92 00 00 00	 jmp	 $LN24@SysEncResu
$LN12@SysEncResu:

; 1990 : 		}
; 1991 : 
; 1992 : 		// Prevent the OS from entering Sleep mode when idle
; 1993 : 		SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);

  001ae	68 01 00 00 80	 push	 -2147483647		; 80000001H
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadExecutionState@4

; 1994 : 
; 1995 : 		bFirstSysEncResumeDone = TRUE;

  001b9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bFirstSysEncResumeDone@@3HA, 1 ; bFirstSysEncResumeDone

; 1996 : 		InitSysEncProgressBar ();

  001c3	e8 00 00 00 00	 call	 _InitSysEncProgressBar

; 1997 : 		UpdateSysEncProgressBar ();

  001c8	e8 00 00 00 00	 call	 ?UpdateSysEncProgressBar@@YAXXZ ; UpdateSysEncProgressBar

; 1998 : 		UpdateSysEncControls ();

  001cd	e8 00 00 00 00	 call	 ?UpdateSysEncControls@@YAXXZ ; UpdateSysEncControls

; 1999 : 		EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), TRUE);

  001d2	6a 01		 push	 1
  001d4	68 41 04 00 00	 push	 1089			; 00000441H
  001d9	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  001df	ff d3		 call	 ebx
  001e1	50		 push	 eax
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 2000 : 		SetTimer (MainDlg, TIMER_ID_SYSENC_PROGRESS, TIMER_INTERVAL_SYSENC_PROGRESS, NULL);

  001e8	6a 00		 push	 0
  001ea	6a 1e		 push	 30			; 0000001eH
  001ec	68 00 01 00 00	 push	 256			; 00000100H
  001f1	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 2001 : 	}
; 2002 : 	else

  001fd	eb 49		 jmp	 SHORT $LN5@SysEncResu
__catch$?SysEncResume@@YAXXZ$0:

; 1932 : 		}
; 1933 : 		catch (Exception &e)
; 1934 : 		{
; 1935 : 			e.Show (MainDlg);

  001ff	8b 4d 84	 mov	 ecx, DWORD PTR _e$2[ebp]
  00202	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00208	8b 01		 mov	 eax, DWORD PTR [ecx]
  0020a	ff 10		 call	 DWORD PTR [eax]

; 1936 : 			Error ("ERR_GETTING_SYSTEM_ENCRYPTION_STATUS");

  0020c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@
  00211	e8 00 00 00 00	 call	 _Error
  00216	83 c4 04	 add	 esp, 4

; 1937 : 			EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), TRUE);

  00219	6a 01		 push	 1
  0021b	68 41 04 00 00	 push	 1089			; 00000441H
  00220	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00226	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0022c	50		 push	 eax
  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1938 : 			return;

  00233	b8 00 00 00 00	 mov	 eax, $LN19@SysEncResu
  00238	c3		 ret	 0
$LN19@SysEncResu:
  00239	eb 0d		 jmp	 SHORT $LN5@SysEncResu
$LN4@SysEncResu:

; 2003 : 		Error ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");

  0023b	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
$LN24@SysEncResu:
  00240	e8 00 00 00 00	 call	 _Error
  00245	83 c4 04	 add	 esp, 4
$LN5@SysEncResu:

; 2004 : }

  00248	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0024b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00252	59		 pop	 ecx
  00253	5f		 pop	 edi
  00254	5e		 pop	 esi
  00255	5b		 pop	 ebx
  00256	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00259	33 cd		 xor	 ecx, ebp
  0025b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?SysEncResume@@YAXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 20 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-224]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SysEncResume@@YAXXZ
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SysEncResume@@YAXXZ ENDP				; SysEncResume
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?SysEncPause@@YAXXZ
_TEXT	SEGMENT
_locBootEncStatus$ = -220				; size = 94
_e$2 = -124						; size = 4
_e$3 = -120						; size = 4
$T4 = -116						; size = 94
$T5 = -116						; size = 94
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?SysEncPause@@YAXXZ PROC				; SysEncPause, COMDAT

; 1845 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SysEncPause@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1846 : 	BootEncryptionStatus locBootEncStatus;
; 1847 : 
; 1848 : 	if (CreateSysEncMutex ())

  00031	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00036	85 c0		 test	 eax, eax
  00038	0f 84 8c 01 00
	00		 je	 $LN4@SysEncPaus

; 1849 : 	{
; 1850 : 		EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), FALSE);

  0003e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  00044	6a 00		 push	 0
  00046	68 41 04 00 00	 push	 1089			; 00000441H
  0004b	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00051	ff d3		 call	 ebx
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1851 : 
; 1852 : 		try
; 1853 : 		{
; 1854 : 			locBootEncStatus = BootEncObj->GetStatus();

  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00060	8d 45 8c	 lea	 eax, DWORD PTR $T5[ebp]
  00063	50		 push	 eax
  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0006b	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00070	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00075	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0007c	8b f0		 mov	 esi, eax
  0007e	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$[ebp]
  00084	f3 a5		 rep movsd
  00086	66 a5		 movsw
  00088	83 bd 62 ff ff
	ff 00		 cmp	 DWORD PTR _locBootEncStatus$[ebp+62], 0
  0008f	75 1b		 jne	 SHORT $LN7@SysEncPaus

; 1862 : 		}
; 1863 : 
; 1864 : 		if (!locBootEncStatus.SetupInProgress)
; 1865 : 		{
; 1866 : 			EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), TRUE);

  00091	6a 01		 push	 1
  00093	68 41 04 00 00	 push	 1089			; 00000441H
  00098	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0009e	ff d3		 call	 ebx
  000a0	50		 push	 eax
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1867 : 			return;

  000a7	e9 2b 01 00 00	 jmp	 $LN5@SysEncPaus
$LN7@SysEncPaus:

; 1868 : 		}
; 1869 : 
; 1870 : 		WaitCursor ();

  000ac	e8 00 00 00 00	 call	 _WaitCursor

; 1871 : 
; 1872 : 		try
; 1873 : 		{
; 1874 : 			int attempts = SYSENC_PAUSE_RETRIES;
; 1875 : 
; 1876 : 			BootEncObj->AbortSetup ();

  000b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  000b7	bb c8 00 00 00	 mov	 ebx, 200		; 000000c8H
  000bc	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  000c3	e8 00 00 00 00	 call	 ?AbortSetup@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::AbortSetup
$LN25@SysEncPaus:

; 1877 : 
; 1878 : 			locBootEncStatus = BootEncObj->GetStatus();

  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  000ce	8d 45 8c	 lea	 eax, DWORD PTR $T4[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  000d7	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  000dc	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$[ebp]
  000e2	8b f0		 mov	 esi, eax
  000e4	f3 a5		 rep movsd
  000e6	66 a5		 movsw

; 1879 : 
; 1880 : 			while (locBootEncStatus.SetupInProgress && attempts > 0)

  000e8	8b b5 62 ff ff
	ff		 mov	 esi, DWORD PTR _locBootEncStatus$[ebp+62]
  000ee	85 f6		 test	 esi, esi
  000f0	74 0f		 je	 SHORT $LN23@SysEncPaus
  000f2	85 db		 test	 ebx, ebx
  000f4	7e 31		 jle	 SHORT $LN9@SysEncPaus

; 1881 : 			{
; 1882 : 				Sleep (SYSENC_PAUSE_RETRY_INTERVAL);

  000f6	6a 64		 push	 100			; 00000064H
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 1883 : 				attempts--;

  000fe	4b		 dec	 ebx

; 1884 : 				locBootEncStatus = BootEncObj->GetStatus();
; 1885 : 			}

  000ff	eb c7		 jmp	 SHORT $LN25@SysEncPaus
$LN23@SysEncPaus:

; 1886 : 
; 1887 : 			if (!locBootEncStatus.SetupInProgress)
; 1888 : 				BootEncObj->CheckEncryptionSetupResult ();

  00101	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00107	e8 00 00 00 00	 call	 ?CheckEncryptionSetupResult@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckEncryptionSetupResult
  0010c	eb 19		 jmp	 SHORT $LN9@SysEncPaus
__catch$?SysEncPause@@YAXXZ$2:

; 1889 : 
; 1890 : 		}
; 1891 : 		catch (Exception &e)
; 1892 : 		{
; 1893 : 			e.Show (MainDlg);

  0010e	8b 4d 88	 mov	 ecx, DWORD PTR _e$3[ebp]
  00111	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00117	8b 01		 mov	 eax, DWORD PTR [ecx]
  00119	ff 10		 call	 DWORD PTR [eax]

; 1894 : 		}

  0011b	b8 00 00 00 00	 mov	 eax, $LN19@SysEncPaus
  00120	c3		 ret	 0
$LN19@SysEncPaus:
  00121	8b b5 62 ff ff
	ff		 mov	 esi, DWORD PTR _locBootEncStatus$[ebp+62]
$LN9@SysEncPaus:
  00127	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1895 : 
; 1896 : 		NormalCursor ();
; 1897 : 
; 1898 : 		if (locBootEncStatus.SetupInProgress)

  0012e	e8 00 00 00 00	 call	 _NormalCursor
  00133	85 f6		 test	 esi, esi
  00135	74 36		 je	 SHORT $LN10@SysEncPaus

; 1899 : 		{
; 1900 : 			SetTimer (MainDlg, TIMER_ID_SYSENC_PROGRESS, TIMER_INTERVAL_SYSENC_PROGRESS, NULL);

  00137	6a 00		 push	 0
  00139	6a 1e		 push	 30			; 0000001eH
  0013b	68 00 01 00 00	 push	 256			; 00000100H
  00140	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 1901 : 			EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), TRUE);

  0014c	6a 01		 push	 1
  0014e	68 41 04 00 00	 push	 1089			; 00000441H
  00153	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0015f	50		 push	 eax
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1902 : 			Error ("FAILED_TO_INTERRUPT_SYSTEM_ENCRYPTION");

  00166	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OIGJDCBH@FAILED_TO_INTERRUPT_SYSTEM_ENCRY@

; 1903 : 			return;

  0016b	eb 62		 jmp	 SHORT $LN26@SysEncPaus
$LN10@SysEncPaus:

; 1904 : 		}
; 1905 : 		
; 1906 : 		UpdateSysEncControls ();

  0016d	e8 00 00 00 00	 call	 ?UpdateSysEncControls@@YAXXZ ; UpdateSysEncControls

; 1907 : 		EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), TRUE);

  00172	6a 01		 push	 1
  00174	68 41 04 00 00	 push	 1089			; 00000441H
  00179	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00185	50		 push	 eax
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1908 : 	}
; 1909 : 	else

  0018c	eb 49		 jmp	 SHORT $LN5@SysEncPaus
__catch$?SysEncPause@@YAXXZ$0:

; 1855 : 		}
; 1856 : 		catch (Exception &e)
; 1857 : 		{
; 1858 : 			e.Show (MainDlg);

  0018e	8b 4d 84	 mov	 ecx, DWORD PTR _e$2[ebp]
  00191	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00197	8b 01		 mov	 eax, DWORD PTR [ecx]
  00199	ff 10		 call	 DWORD PTR [eax]

; 1859 : 			Error ("ERR_GETTING_SYSTEM_ENCRYPTION_STATUS");

  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@
  001a0	e8 00 00 00 00	 call	 _Error
  001a5	83 c4 04	 add	 esp, 4

; 1860 : 			EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), TRUE);

  001a8	6a 01		 push	 1
  001aa	68 41 04 00 00	 push	 1089			; 00000441H
  001af	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001bb	50		 push	 eax
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1861 : 			return;

  001c2	b8 00 00 00 00	 mov	 eax, $LN17@SysEncPaus
  001c7	c3		 ret	 0
$LN17@SysEncPaus:
  001c8	eb 0d		 jmp	 SHORT $LN5@SysEncPaus
$LN4@SysEncPaus:

; 1910 : 		Error ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");

  001ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
$LN26@SysEncPaus:
  001cf	e8 00 00 00 00	 call	 _Error
  001d4	83 c4 04	 add	 esp, 4
$LN5@SysEncPaus:

; 1911 : }

  001d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e1	59		 pop	 ecx
  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx
  001e5	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e8	33 cd		 xor	 ecx, ebp
  001ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?SysEncPause@@YAXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 20 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-224]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SysEncPause@@YAXXZ
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SysEncPause@@YAXXZ ENDP				; SysEncPause
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?UpdateSysEncControls@@YAXXZ
_TEXT	SEGMENT
_locBootEncStatus$ = -412				; size = 94
$T2 = -316						; size = 94
_tmpStr$3 = -220					; size = 200
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?UpdateSysEncControls@@YAXXZ PROC			; UpdateSysEncControls, COMDAT

; 1793 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?UpdateSysEncControls@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 90 01 00
	00		 sub	 esp, 400		; 00000190H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1794 : 	BootEncryptionStatus locBootEncStatus;
; 1795 : 
; 1796 : 	try
; 1797 : 	{
; 1798 : 		locBootEncStatus = BootEncObj->GetStatus();

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00037	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0003d	50		 push	 eax
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00045	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  0004a	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  0004f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00056	8b f0		 mov	 esi, eax
  00058	8d bd 64 fe ff
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$[ebp]
  0005e	f3 a5		 rep movsd
  00060	66 a5		 movsw
  00062	8b b5 a2 fe ff
	ff		 mov	 esi, DWORD PTR _locBootEncStatus$[ebp+62]
  00068	85 f6		 test	 esi, esi
  0006a	75 11		 jne	 SHORT $LN7@UpdateSysE

; 1803 : 	}
; 1804 : 
; 1805 : 	EnableWindow (GetDlgItem (hCurPage, IDC_WIPE_MODE), 

  0006c	81 3d 00 00 00
	00 90 01 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 400 ; 00000190H
  00076	75 05		 jne	 SHORT $LN7@UpdateSysE
  00078	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0007b	eb 02		 jmp	 SHORT $LN8@UpdateSysE
$LN7@UpdateSysE:
  0007d	33 c0		 xor	 eax, eax
$LN8@UpdateSysE:
  0007f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  00085	50		 push	 eax
  00086	68 3d 04 00 00	 push	 1085			; 0000043dH
  0008b	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00091	ff d3		 call	 ebx
  00093	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  00099	50		 push	 eax
  0009a	ff d7		 call	 edi

; 1806 : 		!locBootEncStatus.SetupInProgress 
; 1807 : 		&& SystemEncryptionStatus == SYSENC_STATUS_ENCRYPTING);
; 1808 : 
; 1809 : 	SetWindowTextW (GetDlgItem (hCurPage, IDC_PAUSE),

  0009c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_06PPGAKMJI@RESUME?$AA@
  000a1	85 f6		 test	 esi, esi
  000a3	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09PJBBBIIP@IDC_PAUSE?$AA@
  000a8	0f 44 c1	 cmove	 eax, ecx
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _GetString
  000b1	83 c4 04	 add	 esp, 4
  000b4	50		 push	 eax
  000b5	68 41 04 00 00	 push	 1089			; 00000441H
  000ba	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  000c0	ff d3		 call	 ebx
  000c2	50		 push	 eax
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 1810 : 		GetString (locBootEncStatus.SetupInProgress ? "IDC_PAUSE" : "RESUME"));
; 1811 : 
; 1812 : 	EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), !locBootEncStatus.SetupInProgress && !bFirstSysEncResumeDone);

  000c9	85 f6		 test	 esi, esi
  000cb	75 0d		 jne	 SHORT $LN9@UpdateSysE
  000cd	39 35 00 00 00
	00		 cmp	 DWORD PTR ?bFirstSysEncResumeDone@@3HA, esi ; bFirstSysEncResumeDone
  000d3	75 05		 jne	 SHORT $LN9@UpdateSysE
  000d5	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000d8	eb 02		 jmp	 SHORT $LN10@UpdateSysE
$LN9@UpdateSysE:
  000da	33 c0		 xor	 eax, eax
$LN10@UpdateSysE:
  000dc	50		 push	 eax
  000dd	68 10 04 00 00	 push	 1040			; 00000410H
  000e2	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000e8	ff d3		 call	 ebx
  000ea	50		 push	 eax
  000eb	ff d7		 call	 edi

; 1813 : 
; 1814 : 	if (!locBootEncStatus.SetupInProgress)

  000ed	85 f6		 test	 esi, esi
  000ef	0f 85 1e 01 00
	00		 jne	 $LN18@UpdateSysE

; 1815 : 	{
; 1816 : 		wchar_t tmpStr[100];
; 1817 : 
; 1818 : 		wcscpy (tmpStr, GetString ((SysDriveOrPartitionFullyEncrypted (TRUE) || !locBootEncStatus.DriveMounted) ?

  000f5	6a 01		 push	 1
  000f7	e8 00 00 00 00	 call	 ?SysDriveOrPartitionFullyEncrypted@@YAHH@Z ; SysDriveOrPartitionFullyEncrypted
  000fc	83 c4 04	 add	 esp, 4
  000ff	85 c0		 test	 eax, eax
  00101	75 0d		 jne	 SHORT $LN11@UpdateSysE
  00103	39 85 6a fe ff
	ff		 cmp	 DWORD PTR _locBootEncStatus$[ebp+6], eax
  00109	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BH@LLAADOBF@PROGRESS_STATUS_PAUSED?$AA@
  0010e	75 05		 jne	 SHORT $LN12@UpdateSysE
$LN11@UpdateSysE:
  00110	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BJ@HKENJBII@PROGRESS_STATUS_FINISHED?$AA@
$LN12@UpdateSysE:
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _GetString
  0011b	8d 95 24 ff ff
	ff		 lea	 edx, DWORD PTR _tmpStr$3[ebp]
  00121	83 c4 04	 add	 esp, 4
  00124	2b d0		 sub	 edx, eax
  00126	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL13@UpdateSysE:
  00130	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00133	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00136	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0013b	66 85 c9	 test	 cx, cx
  0013e	75 f0		 jne	 SHORT $LL13@UpdateSysE

; 1819 : 			"PROGRESS_STATUS_FINISHED" : "PROGRESS_STATUS_PAUSED"));
; 1820 : 		wcscat (tmpStr, L" ");

  00140	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR _tmpStr$3[ebp]
  00146	83 c7 fe	 add	 edi, -2			; fffffffeH
  00149	0f 1f 80 00 00
	00 00		 npad	 7
$LL25@UpdateSysE:
  00150	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00154	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]
  00157	66 85 c0	 test	 ax, ax
  0015a	75 f4		 jne	 SHORT $LL25@UpdateSysE
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  00161	89 07		 mov	 DWORD PTR [edi], eax

; 1821 : 
; 1822 : 		// Status
; 1823 : 		SetWindowTextW (GetDlgItem (hCurPage, IDC_WRITESPEED), tmpStr);

  00163	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _tmpStr$3[ebp]
  00169	50		 push	 eax
  0016a	68 01 04 00 00	 push	 1025			; 00000401H
  0016f	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00175	ff d3		 call	 ebx
  00177	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  0017d	50		 push	 eax
  0017e	ff d6		 call	 esi

; 1824 : 
; 1825 : 		if (SysDriveOrPartitionFullyEncrypted (TRUE) || SystemEncryptionStatus == SYSENC_STATUS_NONE)

  00180	6a 01		 push	 1
  00182	e8 00 00 00 00	 call	 ?SysDriveOrPartitionFullyEncrypted@@YAHH@Z ; SysDriveOrPartitionFullyEncrypted
  00187	83 c4 04	 add	 esp, 4
  0018a	85 c0		 test	 eax, eax
  0018c	75 08		 jne	 SHORT $LN5@UpdateSysE
  0018e	39 05 00 00 00
	00		 cmp	 DWORD PTR _SystemEncryptionStatus, eax
  00194	75 64		 jne	 SHORT $LN4@UpdateSysE
$LN5@UpdateSysE:

; 1826 : 		{
; 1827 : 			wcscpy (tmpStr, GetString ("PROCESSED_PORTION_100_PERCENT"));

  00196	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DMHMPBKC@PROCESSED_PORTION_100_PERCENT?$AA@
  0019b	e8 00 00 00 00	 call	 _GetString
  001a0	8d 95 24 ff ff
	ff		 lea	 edx, DWORD PTR _tmpStr$3[ebp]
  001a6	83 c4 04	 add	 esp, 4
  001a9	2b d0		 sub	 edx, eax
  001ab	0f 1f 44 00 00	 npad	 5
$LL14@UpdateSysE:
  001b0	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001b3	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  001b6	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  001bb	66 85 c9	 test	 cx, cx
  001be	75 f0		 jne	 SHORT $LL14@UpdateSysE

; 1828 : 			wcscat (tmpStr, L" ");

  001c0	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR _tmpStr$3[ebp]
  001c6	83 c7 fe	 add	 edi, -2			; fffffffeH
  001c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL26@UpdateSysE:
  001d0	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  001d4	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]
  001d7	66 85 c0	 test	 ax, ax
  001da	75 f4		 jne	 SHORT $LL26@UpdateSysE
  001dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  001e1	89 07		 mov	 DWORD PTR [edi], eax

; 1829 : 
; 1830 : 			SetWindowTextW (GetDlgItem (hCurPage, IDC_BYTESWRITTEN), tmpStr);

  001e3	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _tmpStr$3[ebp]
  001e9	50		 push	 eax
  001ea	68 00 04 00 00	 push	 1024			; 00000400H
  001ef	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  001f5	ff d3		 call	 ebx
  001f7	50		 push	 eax
  001f8	ff d6		 call	 esi
$LN4@UpdateSysE:

; 1831 : 		}
; 1832 : 
; 1833 : 		SetWindowText (GetDlgItem (hCurPage, IDC_TIMEREMAIN), " ");

  001fa	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  001ff	68 03 04 00 00	 push	 1027			; 00000403H
  00204	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0020a	ff d3		 call	 ebx
  0020c	50		 push	 eax
  0020d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN18@UpdateSysE:

; 1834 : 	}
; 1835 : }

  00213	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00216	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0021d	59		 pop	 ecx
  0021e	5f		 pop	 edi
  0021f	5e		 pop	 esi
  00220	5b		 pop	 ebx
  00221	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00224	33 cd		 xor	 ecx, ebp
  00226	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022b	8b e5		 mov	 esp, ebp
  0022d	5d		 pop	 ebp
  0022e	c3		 ret	 0
__catch$?UpdateSysEncControls@@YAXXZ$0:

; 1799 : 	}
; 1800 : 	catch (...)
; 1801 : 	{
; 1802 : 		return;

  0022f	b8 00 00 00 00	 mov	 eax, $LN18@UpdateSysE
  00234	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?UpdateSysEncControls@@YAXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 60 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-416]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?UpdateSysEncControls@@YAXXZ
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?UpdateSysEncControls@@YAXXZ ENDP			; UpdateSysEncControls
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?UpdateSysEncProgressBar@@YAXXZ
_TEXT	SEGMENT
_locBootEncStatus$ = -412				; size = 94
$T2 = -316						; size = 94
_tmpStr$3 = -220					; size = 200
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?UpdateSysEncProgressBar@@YAXXZ PROC			; UpdateSysEncProgressBar, COMDAT

; 1712 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?UpdateSysEncProgressBar@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 90 01 00
	00		 sub	 esp, 400		; 00000190H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1713 : 	BootEncryptionStatus locBootEncStatus;
; 1714 : 
; 1715 : 	try
; 1716 : 	{
; 1717 : 		locBootEncStatus = BootEncObj->GetStatus();

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00037	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0003d	50		 push	 eax
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00045	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  0004a	8b f0		 mov	 esi, eax
  0004c	8d bd 64 fe ff
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$[ebp]
  00052	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00057	f3 a5		 rep movsd
  00059	66 a5		 movsw

; 1722 : 	}
; 1723 : 
; 1724 : 	if (locBootEncStatus.EncryptedAreaEnd == -1 
; 1725 : 		|| locBootEncStatus.EncryptedAreaStart == -1)

  0005b	8b 8d 96 fe ff
	ff		 mov	 ecx, DWORD PTR _locBootEncStatus$[ebp+50]
  00061	8b c1		 mov	 eax, ecx
  00063	8b 95 9a fe ff
	ff		 mov	 edx, DWORD PTR _locBootEncStatus$[ebp+54]
  00069	23 c2		 and	 eax, edx
  0006b	83 f8 ff	 cmp	 eax, -1
  0006e	0f 84 0a 01 00
	00		 je	 $LN5@UpdateSysE
  00074	8b b5 8e fe ff
	ff		 mov	 esi, DWORD PTR _locBootEncStatus$[ebp+42]
  0007a	8b c6		 mov	 eax, esi
  0007c	8b bd 92 fe ff
	ff		 mov	 edi, DWORD PTR _locBootEncStatus$[ebp+46]
  00082	23 c7		 and	 eax, edi
  00084	83 f8 ff	 cmp	 eax, -1
  00087	0f 84 f1 00 00
	00		 je	 $LN5@UpdateSysE

; 1730 : 	{
; 1731 : 		UpdateProgressBarProc (locBootEncStatus.EncryptedAreaEnd - locBootEncStatus.EncryptedAreaStart + 1);

  0008d	2b ce		 sub	 ecx, esi
  0008f	1b d7		 sbb	 edx, edi
  00091	83 c1 01	 add	 ecx, 1
  00094	83 d2 00	 adc	 edx, 0
  00097	52		 push	 edx
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  0009e	83 c4 08	 add	 esp, 8

; 1732 : 
; 1733 : 		if (locBootEncStatus.SetupInProgress)

  000a1	83 bd a2 fe ff
	ff 00		 cmp	 DWORD PTR _locBootEncStatus$[ebp+62], 0
  000a8	0f 84 b4 00 00
	00		 je	 $LN15@UpdateSysE

; 1734 : 		{
; 1735 : 			wchar_t tmpStr[100];
; 1736 : 
; 1737 : 			// Status
; 1738 : 
; 1739 : 			if (locBootEncStatus.TransformWaitingForIdle)

  000ae	83 bd aa fe ff
	ff 00		 cmp	 DWORD PTR _locBootEncStatus$[ebp+70], 0
  000b5	74 2b		 je	 SHORT $LN7@UpdateSysE

; 1740 : 				wcscpy (tmpStr, GetString ("PROGRESS_STATUS_WAITING"));

  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FJOOBAJA@PROGRESS_STATUS_WAITING?$AA@
  000bc	e8 00 00 00 00	 call	 _GetString
  000c1	8d 95 24 ff ff
	ff		 lea	 edx, DWORD PTR _tmpStr$3[ebp]
  000c7	83 c4 04	 add	 esp, 4
  000ca	2b d0		 sub	 edx, eax
  000cc	0f 1f 40 00	 npad	 4
$LL10@UpdateSysE:
  000d0	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000d3	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  000d6	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  000db	66 85 c9	 test	 cx, cx
  000de	75 f0		 jne	 SHORT $LL10@UpdateSysE

; 1741 : 			else

  000e0	eb 3e		 jmp	 SHORT $LN8@UpdateSysE
$LN7@UpdateSysE:

; 1742 : 				wcscpy (tmpStr, GetString (SystemEncryptionStatus == SYSENC_STATUS_DECRYPTING ? "PROGRESS_STATUS_DECRYPTING" : "PROGRESS_STATUS_ENCRYPTING"));

  000e2	81 3d 00 00 00
	00 58 02 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 600 ; 00000258H
  000ec	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BL@PONBLMNB@PROGRESS_STATUS_ENCRYPTING?$AA@
  000f1	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BL@MHLPJIOG@PROGRESS_STATUS_DECRYPTING?$AA@
  000f6	0f 45 c1	 cmovne	 eax, ecx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _GetString
  000ff	8d 95 24 ff ff
	ff		 lea	 edx, DWORD PTR _tmpStr$3[ebp]
  00105	83 c4 04	 add	 esp, 4
  00108	2b d0		 sub	 edx, eax
  0010a	66 0f 1f 44 00
	00		 npad	 6
$LL11@UpdateSysE:
  00110	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00113	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00116	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0011b	66 85 c9	 test	 cx, cx
  0011e	75 f0		 jne	 SHORT $LL11@UpdateSysE
$LN8@UpdateSysE:

; 1743 : 
; 1744 : 			wcscat (tmpStr, L" ");

  00120	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR _tmpStr$3[ebp]
  00126	83 c7 fe	 add	 edi, -2			; fffffffeH
  00129	0f 1f 80 00 00
	00 00		 npad	 7
$LL22@UpdateSysE:
  00130	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00134	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]
  00137	66 85 c0	 test	 ax, ax
  0013a	75 f4		 jne	 SHORT $LL22@UpdateSysE
  0013c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  00141	89 07		 mov	 DWORD PTR [edi], eax

; 1745 : 
; 1746 : 			SetWindowTextW (GetDlgItem (hCurPage, IDC_WRITESPEED), tmpStr);

  00143	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _tmpStr$3[ebp]
  00149	50		 push	 eax
  0014a	68 01 04 00 00	 push	 1025			; 00000401H
  0014f	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0015b	50		 push	 eax
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
$LN15@UpdateSysE:

; 1747 : 		}
; 1748 : 	}
; 1749 : }

  00162	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00165	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016c	59		 pop	 ecx
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi
  0016f	5b		 pop	 ebx
  00170	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	33 cd		 xor	 ecx, ebp
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
$LN5@UpdateSysE:

; 1726 : 	{
; 1727 : 		UpdateProgressBarProc (0);

  0017e	6a 00		 push	 0
  00180	6a 00		 push	 0
  00182	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00187	83 c4 08	 add	 esp, 8

; 1728 : 	}
; 1729 : 	else

  0018a	eb d6		 jmp	 SHORT $LN15@UpdateSysE
__catch$?UpdateSysEncProgressBar@@YAXXZ$0:

; 1718 : 	}
; 1719 : 	catch (...)
; 1720 : 	{
; 1721 : 		return;

  0018c	b8 00 00 00 00	 mov	 eax, $LN15@UpdateSysE
  00191	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?UpdateSysEncProgressBar@@YAXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 60 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-416]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?UpdateSysEncProgressBar@@YAXXZ
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?UpdateSysEncProgressBar@@YAXXZ ENDP			; UpdateSysEncProgressBar
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?Init2RadButtonPageYesNo@@YAXH@Z
_TEXT	SEGMENT
_answer$ = 8						; size = 4
?Init2RadButtonPageYesNo@@YAXH@Z PROC			; Init2RadButtonPageYesNo, COMDAT

; 1690 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1691 : 	SetWindowTextW (GetDlgItem (hCurPage, IDC_CHOICE1), GetString ("UISTR_YES"));

  00006	68 00 00 00 00	 push	 OFFSET ??_C@_09JHINKGCK@UISTR_YES?$AA@
  0000b	e8 00 00 00 00	 call	 _GetString
  00010	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  00016	83 c4 04	 add	 esp, 4
  00019	50		 push	 eax
  0001a	68 dd 13 00 00	 push	 5085			; 000013ddH
  0001f	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00025	ff d3		 call	 ebx
  00027	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  0002d	50		 push	 eax
  0002e	ff d6		 call	 esi

; 1692 : 	SetWindowTextW (GetDlgItem (hCurPage, IDC_CHOICE2), GetString ("UISTR_NO"));

  00030	68 00 00 00 00	 push	 OFFSET ??_C@_08EOJLPPDK@UISTR_NO?$AA@
  00035	e8 00 00 00 00	 call	 _GetString
  0003a	83 c4 04	 add	 esp, 4
  0003d	50		 push	 eax
  0003e	68 df 13 00 00	 push	 5087			; 000013dfH
  00043	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00049	ff d3		 call	 ebx
  0004b	50		 push	 eax
  0004c	ff d6		 call	 esi

; 1693 : 
; 1694 : 	SetWindowTextW (GetDlgItem (MainDlg, IDC_NEXT), GetString ("NEXT"));

  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00053	e8 00 00 00 00	 call	 _GetString
  00058	83 c4 04	 add	 esp, 4
  0005b	50		 push	 eax
  0005c	68 10 04 00 00	 push	 1040			; 00000410H
  00061	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00067	ff d3		 call	 ebx
  00069	50		 push	 eax
  0006a	ff d6		 call	 esi

; 1695 : 	SetWindowTextW (GetDlgItem (MainDlg, IDC_PREV), GetString ("PREV"));

  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  00071	e8 00 00 00 00	 call	 _GetString
  00076	83 c4 04	 add	 esp, 4
  00079	50		 push	 eax
  0007a	68 11 04 00 00	 push	 1041			; 00000411H
  0007f	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00085	ff d3		 call	 ebx
  00087	50		 push	 eax
  00088	ff d6		 call	 esi

; 1696 : 	SetWindowTextW (GetDlgItem (MainDlg, IDCANCEL), GetString ("CANCEL"));

  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  0008f	e8 00 00 00 00	 call	 _GetString
  00094	83 c4 04	 add	 esp, 4
  00097	50		 push	 eax
  00098	6a 02		 push	 2
  0009a	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000a0	ff d3		 call	 ebx
  000a2	50		 push	 eax
  000a3	ff d6		 call	 esi

; 1697 : 
; 1698 : 	EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), answer >= 0);

  000a5	8b 7d 08	 mov	 edi, DWORD PTR _answer$[ebp]
  000a8	8b c7		 mov	 eax, edi
  000aa	f7 d0		 not	 eax
  000ac	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000af	50		 push	 eax
  000b0	68 10 04 00 00	 push	 1040			; 00000410H
  000b5	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000bb	ff d3		 call	 ebx
  000bd	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  000c3	50		 push	 eax
  000c4	ff d6		 call	 esi

; 1699 : 	EnableWindow (GetDlgItem (MainDlg, IDC_PREV), TRUE);

  000c6	6a 01		 push	 1
  000c8	68 11 04 00 00	 push	 1041			; 00000411H
  000cd	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000d3	ff d3		 call	 ebx
  000d5	50		 push	 eax
  000d6	ff d6		 call	 esi

; 1700 : 
; 1701 : 	Update2RadButtonPage (answer);

  000d8	33 c0		 xor	 eax, eax
  000da	83 ff 01	 cmp	 edi, 1
  000dd	6a 00		 push	 0
  000df	0f 94 c0	 sete	 al
  000e2	50		 push	 eax
  000e3	68 f1 00 00 00	 push	 241			; 000000f1H
  000e8	68 dd 13 00 00	 push	 5085			; 000013ddH
  000ed	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  000f3	ff d3		 call	 ebx
  000f5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  000fb	50		 push	 eax
  000fc	ff d6		 call	 esi
  000fe	6a 00		 push	 0
  00100	33 c0		 xor	 eax, eax
  00102	85 ff		 test	 edi, edi
  00104	0f 94 c0	 sete	 al
  00107	50		 push	 eax
  00108	68 f1 00 00 00	 push	 241			; 000000f1H
  0010d	68 df 13 00 00	 push	 5087			; 000013dfH
  00112	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00118	ff d3		 call	 ebx
  0011a	50		 push	 eax
  0011b	ff d6		 call	 esi
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx

; 1702 : }

  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
?Init2RadButtonPageYesNo@@YAXH@Z ENDP			; Init2RadButtonPageYesNo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?Update2RadButtonPage@@YAXH@Z
_TEXT	SEGMENT
_answer$ = 8						; size = 4
?Update2RadButtonPage@@YAXH@Z PROC			; Update2RadButtonPage, COMDAT

; 1669 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1670 : 	SendMessage (GetDlgItem (hCurPage, IDC_CHOICE1),

  00003	33 c0		 xor	 eax, eax
  00005	83 7d 08 01	 cmp	 DWORD PTR _answer$[ebp], 1
  00009	6a 00		 push	 0
  0000b	0f 94 c0	 sete	 al
  0000e	50		 push	 eax
  0000f	68 f1 00 00 00	 push	 241			; 000000f1H
  00014	68 dd 13 00 00	 push	 5085			; 000013ddH
  00019	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 1671 : 		BM_SETCHECK,
; 1672 : 		answer == 1 ? BST_CHECKED : BST_UNCHECKED,
; 1673 : 		0);
; 1674 : 
; 1675 : 	SendMessage (GetDlgItem (hCurPage, IDC_CHOICE2),

  0002c	33 c0		 xor	 eax, eax
  0002e	39 45 08	 cmp	 DWORD PTR _answer$[ebp], eax
  00031	6a 00		 push	 0
  00033	0f 94 c0	 sete	 al
  00036	50		 push	 eax
  00037	68 f1 00 00 00	 push	 241			; 000000f1H
  0003c	68 df 13 00 00	 push	 5087			; 000013dfH
  00041	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 1676 : 		BM_SETCHECK,
; 1677 : 		answer == 0 ? BST_CHECKED : BST_UNCHECKED,
; 1678 : 		0);
; 1679 : }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?Update2RadButtonPage@@YAXH@Z ENDP			; Update2RadButtonPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?Get2RadButtonPageAnswer@@YAHXZ
_TEXT	SEGMENT
?Get2RadButtonPageAnswer@@YAHXZ PROC			; Get2RadButtonPageAnswer, COMDAT

; 1650 : 	if (IsButtonChecked (GetDlgItem (hCurPage, IDC_CHOICE1)))

  00000	68 dd 13 00 00	 push	 5085			; 000013ddH
  00005	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _IsButtonChecked
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 06		 je	 SHORT $LN2@Get2RadBut

; 1651 : 		return 1;

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 1654 : 		return 0;
; 1655 : 
; 1656 : 	return -1;
; 1657 : }

  00023	c3		 ret	 0
$LN2@Get2RadBut:

; 1652 : 
; 1653 : 	if (IsButtonChecked (GetDlgItem (hCurPage, IDC_CHOICE2)))

  00024	68 df 13 00 00	 push	 5087			; 000013dfH
  00029	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _IsButtonChecked
  0003b	83 c4 04	 add	 esp, 4
  0003e	f7 d8		 neg	 eax
  00040	1b c0		 sbb	 eax, eax
  00042	f7 d8		 neg	 eax
  00044	48		 dec	 eax

; 1654 : 		return 0;
; 1655 : 
; 1656 : 	return -1;
; 1657 : }

  00045	c3		 ret	 0
?Get2RadButtonPageAnswer@@YAHXZ ENDP			; Get2RadButtonPageAnswer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?RefreshMultiBootControls@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
?RefreshMultiBootControls@@YAXPAUHWND__@@@Z PROC	; RefreshMultiBootControls, COMDAT

; 1622 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1623 : #ifdef DEBUG
; 1624 : 	if (nMultiBoot == 0)
; 1625 : 		nMultiBoot = 1;
; 1626 : #endif
; 1627 : 
; 1628 : 	SendMessage (GetDlgItem (hwndDlg, IDC_SINGLE_BOOT),

  00003	33 c0		 xor	 eax, eax
  00005	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?nMultiBoot@@3HA, 1 ; nMultiBoot
  0000c	6a 00		 push	 0
  0000e	0f 94 c0	 sete	 al
  00011	50		 push	 eax
  00012	68 f1 00 00 00	 push	 241			; 000000f1H
  00017	68 34 04 00 00	 push	 1076			; 00000434H
  0001c	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 1629 : 		BM_SETCHECK,
; 1630 : 		nMultiBoot == 1 ? BST_CHECKED : BST_UNCHECKED,
; 1631 : 		0);
; 1632 : 
; 1633 : 	SendMessage (GetDlgItem (hwndDlg, IDC_MULTI_BOOT),

  0002c	33 c0		 xor	 eax, eax
  0002e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?nMultiBoot@@3HA, 1 ; nMultiBoot
  00035	6a 00		 push	 0
  00037	0f 9f c0	 setg	 al
  0003a	50		 push	 eax
  0003b	68 f1 00 00 00	 push	 241			; 000000f1H
  00040	68 35 04 00 00	 push	 1077			; 00000435H
  00045	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0004e	50		 push	 eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 1634 : 		BM_SETCHECK,
; 1635 : 		nMultiBoot > 1 ? BST_CHECKED : BST_UNCHECKED,
; 1636 : 		0);
; 1637 : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?RefreshMultiBootControls@@YAXPAUHWND__@@@Z ENDP	; RefreshMultiBootControls
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?GetSelectedWizardMode@@YAHPAUHWND__@@@Z
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
?GetSelectedWizardMode@@YAHPAUHWND__@@@Z PROC		; GetSelectedWizardMode, COMDAT

; 1600 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1601 : 	if (IsButtonChecked (GetDlgItem (hwndDlg, IDC_FILE_CONTAINER)))

  00004	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]
  00007	57		 push	 edi
  00008	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0000e	68 25 04 00 00	 push	 1061			; 00000425H
  00013	56		 push	 esi
  00014	ff d7		 call	 edi
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _IsButtonChecked
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	74 06		 je	 SHORT $LN2@GetSelecte

; 1602 : 		return WIZARD_MODE_FILE_CONTAINER;

  00023	5f		 pop	 edi
  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi

; 1608 : 		return WIZARD_MODE_SYS_DEVICE;
; 1609 : 
; 1610 : 	return DEFAULT_VOL_CREATION_WIZARD_MODE;
; 1611 : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@GetSelecte:

; 1603 : 
; 1604 : 	if (IsButtonChecked (GetDlgItem (hwndDlg, IDC_NONSYS_DEVICE)))

  00029	68 26 04 00 00	 push	 1062			; 00000426H
  0002e	56		 push	 esi
  0002f	ff d7		 call	 edi
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _IsButtonChecked
  00037	83 c4 04	 add	 esp, 4
  0003a	85 c0		 test	 eax, eax
  0003c	74 09		 je	 SHORT $LN3@GetSelecte

; 1605 : 		return WIZARD_MODE_NONSYS_DEVICE;

  0003e	5f		 pop	 edi
  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	5e		 pop	 esi

; 1608 : 		return WIZARD_MODE_SYS_DEVICE;
; 1609 : 
; 1610 : 	return DEFAULT_VOL_CREATION_WIZARD_MODE;
; 1611 : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN3@GetSelecte:

; 1606 : 
; 1607 : 	if (IsButtonChecked (GetDlgItem (hwndDlg, IDC_SYS_DEVICE)))

  00047	68 27 04 00 00	 push	 1063			; 00000427H
  0004c	56		 push	 esi
  0004d	ff d7		 call	 edi
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _IsButtonChecked
  00055	83 c4 04	 add	 esp, 4
  00058	f7 d8		 neg	 eax
  0005a	1b c0		 sbb	 eax, eax
  0005c	83 e0 02	 and	 eax, 2
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1608 : 		return WIZARD_MODE_SYS_DEVICE;
; 1609 : 
; 1610 : 	return DEFAULT_VOL_CREATION_WIZARD_MODE;
; 1611 : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?GetSelectedWizardMode@@YAHPAUHWND__@@@Z ENDP		; GetSelectedWizardMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?UpdateWizardModeControls@@YAXPAUHWND__@@H@Z
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_setWizardMode$ = 12					; size = 4
?UpdateWizardModeControls@@YAXPAUHWND__@@H@Z PROC	; UpdateWizardModeControls, COMDAT

; 1570 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1571 : 	SendMessage (GetDlgItem (hwndDlg, IDC_FILE_CONTAINER),

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  00007	33 c0		 xor	 eax, eax
  00009	39 45 0c	 cmp	 DWORD PTR _setWizardMode$[ebp], eax
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00014	0f 94 c0	 sete	 al
  00017	6a 00		 push	 0
  00019	50		 push	 eax
  0001a	68 f1 00 00 00	 push	 241			; 000000f1H
  0001f	68 25 04 00 00	 push	 1061			; 00000425H
  00024	53		 push	 ebx
  00025	ff d7		 call	 edi
  00027	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  0002d	50		 push	 eax
  0002e	ff d6		 call	 esi

; 1572 : 		BM_SETCHECK,
; 1573 : 		setWizardMode == WIZARD_MODE_FILE_CONTAINER ? BST_CHECKED : BST_UNCHECKED,
; 1574 : 		0);
; 1575 : 
; 1576 : 	SendMessage (GetDlgItem (hwndDlg, IDC_NONSYS_DEVICE),

  00030	33 c0		 xor	 eax, eax
  00032	83 7d 0c 01	 cmp	 DWORD PTR _setWizardMode$[ebp], 1
  00036	6a 00		 push	 0
  00038	0f 94 c0	 sete	 al
  0003b	50		 push	 eax
  0003c	68 f1 00 00 00	 push	 241			; 000000f1H
  00041	68 26 04 00 00	 push	 1062			; 00000426H
  00046	53		 push	 ebx
  00047	ff d7		 call	 edi
  00049	50		 push	 eax
  0004a	ff d6		 call	 esi

; 1577 : 		BM_SETCHECK,
; 1578 : 		setWizardMode == WIZARD_MODE_NONSYS_DEVICE ? BST_CHECKED : BST_UNCHECKED,
; 1579 : 		0);
; 1580 : 
; 1581 : 	SendMessage (GetDlgItem (hwndDlg, IDC_SYS_DEVICE),

  0004c	33 c0		 xor	 eax, eax
  0004e	83 7d 0c 02	 cmp	 DWORD PTR _setWizardMode$[ebp], 2
  00052	6a 00		 push	 0
  00054	0f 94 c0	 sete	 al
  00057	50		 push	 eax
  00058	68 f1 00 00 00	 push	 241			; 000000f1H
  0005d	68 27 04 00 00	 push	 1063			; 00000427H
  00062	53		 push	 ebx
  00063	ff d7		 call	 edi
  00065	50		 push	 eax
  00066	ff d6		 call	 esi
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx

; 1582 : 		BM_SETCHECK,
; 1583 : 		setWizardMode == WIZARD_MODE_SYS_DEVICE ? BST_CHECKED : BST_UNCHECKED,
; 1584 : 		0);
; 1585 : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?UpdateWizardModeControls@@YAXPAUHWND__@@H@Z ENDP	; UpdateWizardModeControls
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?GetSystemPartitionSize@@YA_JXZ
_TEXT	SEGMENT
_e$2 = -344						; size = 4
$T3 = -340						; size = 320
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?GetSystemPartitionSize@@YA_JXZ PROC			; GetSystemPartitionSize, COMDAT

; 1377 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSystemPartitionSize@@YA_JXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1378 : 	try
; 1379 : 	{
; 1380 : 		return BootEncObj->GetSystemDriveConfiguration().SystemPartition.Info.PartitionLength.QuadPart;

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00037	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0003d	50		 push	 eax
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00045	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  0004a	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00050	8b b8 e0 00 00
	00		 mov	 edi, DWORD PTR [eax+224]
  00056	8b b0 e4 00 00
	00		 mov	 esi, DWORD PTR [eax+228]
  0005c	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  00061	8b c7		 mov	 eax, edi
  00063	8b d6		 mov	 edx, esi
  00065	eb 1a		 jmp	 SHORT $LN7@GetSystemP
__catch$?GetSystemPartitionSize@@YA_JXZ$0:

; 1381 : 	}
; 1382 : 	catch (Exception &e)
; 1383 : 	{
; 1384 : 		e.Show (MainDlg);

  00067	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  0006d	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00073	8b 01		 mov	 eax, DWORD PTR [ecx]
  00075	ff 10		 call	 DWORD PTR [eax]

; 1385 : 		return 0;

  00077	b8 00 00 00 00	 mov	 eax, $LN8@GetSystemP
  0007c	c3		 ret	 0
$LN8@GetSystemP:
  0007d	33 c0		 xor	 eax, eax
  0007f	33 d2		 xor	 edx, edx
$LN7@GetSystemP:

; 1386 : 	}
; 1387 : }

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00092	33 cd		 xor	 ecx, ebp
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?GetSystemPartitionSize@@YA_JXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a a4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-348]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSystemPartitionSize@@YA_JXZ
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSystemPartitionSize@@YA_JXZ ENDP			; GetSystemPartitionSize
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?ForceRemoveSysEnc@@YAHXZ
_TEXT	SEGMENT
_locBootEncStatus$2 = -604				; size = 94
_e$3 = -508						; size = 4
_e$4 = -504						; size = 4
$T5 = -500						; size = 94
$T6 = -404						; size = 94
$T7 = -308						; size = 94
$T8 = -212						; size = 94
$T9 = -116						; size = 94
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?ForceRemoveSysEnc@@YAHXZ PROC				; ForceRemoveSysEnc, COMDAT

; 1312 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ForceRemoveSysEnc@@YAHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1313 : 	if (CreateSysEncMutex ())	// If no other instance is currently taking care of system encryption

  00031	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00036	85 c0		 test	 eax, eax
  00038	0f 84 4c 01 00
	00		 je	 $LN4@ForceRemov

; 1314 : 	{
; 1315 : 		BootEncryptionStatus locBootEncStatus;
; 1316 : 
; 1317 : 		try
; 1318 : 		{
; 1319 : 			locBootEncStatus = BootEncObj->GetStatus();

  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00044	8d 45 8c	 lea	 eax, DWORD PTR $T9[ebp]
  00047	50		 push	 eax
  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0004f	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00054	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00059	8d bd a4 fd ff
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$2[ebp]
  0005f	8b f0		 mov	 esi, eax
  00061	f3 a5		 rep movsd
  00063	66 a5		 movsw

; 1320 : 
; 1321 : 			if (locBootEncStatus.SetupInProgress)

  00065	83 bd e2 fd ff
	ff 00		 cmp	 DWORD PTR _locBootEncStatus$2[ebp+62], 0
  0006c	74 0b		 je	 SHORT $LN7@ForceRemov

; 1322 : 				BootEncObj->AbortSetupWait ();

  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00074	e8 00 00 00 00	 call	 ?AbortSetupWait@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::AbortSetupWait
$LN7@ForceRemov:

; 1323 : 
; 1324 : 			locBootEncStatus = BootEncObj->GetStatus();

  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0007f	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  0008b	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00090	8d bd a4 fd ff
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$2[ebp]
  00096	8b f0		 mov	 esi, eax
  00098	f3 a5		 rep movsd
  0009a	66 a5		 movsw

; 1325 : 
; 1326 : 			if (locBootEncStatus.DriveMounted)

  0009c	83 bd aa fd ff
	ff 00		 cmp	 DWORD PTR _locBootEncStatus$2[ebp+6], 0
  000a3	74 68		 je	 SHORT $LN23@ForceRemov

; 1327 : 			{
; 1328 : 				// Remove the header
; 1329 : 				BootEncObj->StartDecryption (DiscardUnreadableEncryptedSectors);			

  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DiscardUnreadableEncryptedSectors@@3HC ; DiscardUnreadableEncryptedSectors
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?StartDecryption@BootEncryption@GostCrypt@@QAEXH@Z ; GostCrypt::BootEncryption::StartDecryption

; 1330 : 				locBootEncStatus = BootEncObj->GetStatus();

  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  000bc	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  000c8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__Sleep@4
$LN25@ForceRemov:
  000ce	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  000d3	8d bd a4 fd ff
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$2[ebp]
  000d9	8b f0		 mov	 esi, eax
  000db	f3 a5		 rep movsd
  000dd	66 a5		 movsw

; 1331 : 
; 1332 : 				while (locBootEncStatus.SetupInProgress)

  000df	83 bd e2 fd ff
	ff 00		 cmp	 DWORD PTR _locBootEncStatus$2[ebp+62], 0
  000e6	74 18		 je	 SHORT $LN3@ForceRemov

; 1333 : 				{
; 1334 : 					Sleep (100);

  000e8	6a 64		 push	 100			; 00000064H
  000ea	ff d3		 call	 ebx

; 1335 : 					locBootEncStatus = BootEncObj->GetStatus();

  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  000f2	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus

; 1336 : 				}

  000fe	eb ce		 jmp	 SHORT $LN25@ForceRemov
$LN3@ForceRemov:

; 1337 : 
; 1338 : 				BootEncObj->CheckEncryptionSetupResult ();

  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00106	e8 00 00 00 00	 call	 ?CheckEncryptionSetupResult@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckEncryptionSetupResult
  0010b	eb 06		 jmp	 SHORT $LN8@ForceRemov
$LN23@ForceRemov:
  0010d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__Sleep@4
$LN8@ForceRemov:

; 1339 : 			}
; 1340 : 
; 1341 : 			Sleep (50);

  00113	6a 32		 push	 50			; 00000032H
  00115	ff d3		 call	 ebx

; 1347 : 		}
; 1348 : 
; 1349 : 		try
; 1350 : 		{
; 1351 : 			locBootEncStatus = BootEncObj->GetStatus();

  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0011d	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00123	50		 push	 eax
  00124	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0012b	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00130	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00135	8d bd a4 fd ff
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$2[ebp]
  0013b	8b f0		 mov	 esi, eax
  0013d	f3 a5		 rep movsd
  0013f	66 a5		 movsw

; 1352 : 
; 1353 : 			if (!locBootEncStatus.DriveMounted)

  00141	83 bd aa fd ff
	ff 00		 cmp	 DWORD PTR _locBootEncStatus$2[ebp+6], 0
  00148	75 0d		 jne	 SHORT $LN10@ForceRemov

; 1354 : 				BootEncObj->Deinstall (true);

  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00150	6a 01		 push	 1
  00152	e8 00 00 00 00	 call	 ?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z ; GostCrypt::BootEncryption::Deinstall
$LN10@ForceRemov:

; 1360 : 		}
; 1361 : 
; 1362 : 		return TRUE;

  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	eb 2e		 jmp	 SHORT $LN5@ForceRemov
__catch$?ForceRemoveSysEnc@@YAHXZ$2:

; 1355 : 		}
; 1356 : 		catch (Exception &e)
; 1357 : 		{
; 1358 : 			e.Show (MainDlg);

  0015e	8b 8d 08 fe ff
	ff		 mov	 ecx, DWORD PTR _e$4[ebp]
  00164	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0016a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016c	ff 10		 call	 DWORD PTR [eax]

; 1359 : 			return FALSE;

  0016e	b8 00 00 00 00	 mov	 eax, $LN4@ForceRemov
  00173	c3		 ret	 0
__catch$?ForceRemoveSysEnc@@YAHXZ$0:

; 1342 : 		}
; 1343 : 		catch (Exception &e)
; 1344 : 		{
; 1345 : 			e.Show (MainDlg);

  00174	8b 8d 04 fe ff
	ff		 mov	 ecx, DWORD PTR _e$3[ebp]
  0017a	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00180	8b 01		 mov	 eax, DWORD PTR [ecx]
  00182	ff 10		 call	 DWORD PTR [eax]

; 1346 : 			return FALSE;

  00184	b8 00 00 00 00	 mov	 eax, $LN4@ForceRemov
  00189	c3		 ret	 0
$LN4@ForceRemov:

; 1363 : 	}
; 1364 : 	else
; 1365 : 		return FALSE;

  0018a	33 c0		 xor	 eax, eax
$LN5@ForceRemov:

; 1366 : }

  0018c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0018f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00196	59		 pop	 ecx
  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	5b		 pop	 ebx
  0019a	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019d	33 cd		 xor	 ecx, ebp
  0019f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?ForceRemoveSysEnc@@YAHXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a a0 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-608]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ForceRemoveSysEnc@@YAHXZ
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ForceRemoveSysEnc@@YAHXZ ENDP				; ForceRemoveSysEnc
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?SwitchWizardToNonSysInplaceEncResumeMode@@YAXXZ
_TEXT	SEGMENT
_rD$1 = -104						; size = 16
_rW$2 = -88						; size = 16
_tmp$3 = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
?SwitchWizardToNonSysInplaceEncResumeMode@@YAXXZ PROC	; SwitchWizardToNonSysInplaceEncResumeMode, COMDAT

; 1211 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi

; 1212 : 	if (!IsAdmin() && IsUacSupported())

  00011	e8 00 00 00 00	 call	 _IsAdmin
  00016	85 c0		 test	 eax, eax
  00018	75 29		 jne	 SHORT $LN3@SwitchWiza
  0001a	e8 00 00 00 00	 call	 _IsUacSupported
  0001f	85 c0		 test	 eax, eax
  00021	74 20		 je	 SHORT $LN3@SwitchWiza

; 1213 : 	{
; 1214 : 		if (!ElevateWholeWizardProcess ("/zinplace"))

  00023	83 ec 18	 sub	 esp, 24			; 00000018H
  00026	8b cc		 mov	 ecx, esp
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_09FFOCOHMH@?1zinplace?$AA@
  0002d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00032	e8 00 00 00 00	 call	 ?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ElevateWholeWizardProcess
  00037	83 c4 18	 add	 esp, 24			; 00000018H
  0003a	85 c0		 test	 eax, eax
  0003c	75 05		 jne	 SHORT $LN3@SwitchWiza

; 1215 : 			AbortProcessSilent ();

  0003e	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN3@SwitchWiza:

; 1216 : 	}
; 1217 : 
; 1218 : 	if (!IsAdmin())

  00043	e8 00 00 00 00	 call	 _IsAdmin
  00048	85 c0		 test	 eax, eax
  0004a	75 0d		 jne	 SHORT $LN4@SwitchWiza

; 1219 : 		AbortProcess("ADMIN_PRIVILEGES_WARN_DEVICES");

  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@
  00051	e8 00 00 00 00	 call	 _AbortProcess
  00056	83 c4 04	 add	 esp, 4
$LN4@SwitchWiza:

; 1220 : 
; 1221 : 	CreateNonSysInplaceEncMutex ();

  00059	e8 00 00 00 00	 call	 _CreateNonSysInplaceEncMutex

; 1222 : 
; 1223 : 	bInPlaceEncNonSys = TRUE;

  0005e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 1

; 1224 : 	bInPlaceEncNonSysResumed = TRUE;

  00068	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSysResumed, 1

; 1225 : 
; 1226 : 	ChangeWizardMode (WIZARD_MODE_NONSYS_DEVICE);

  00072	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _WizardMode, 1
  00079	74 66		 je	 SHORT $LN8@SwitchWiza
  0007b	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  00082	75 05		 jne	 SHORT $LN9@SwitchWiza
  00084	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
$LN9@SwitchWiza:
  00089	e8 00 00 00 00	 call	 _IsAdmin
  0008e	85 c0		 test	 eax, eax
  00090	75 24		 jne	 SHORT $LN15@SwitchWiza
  00092	e8 00 00 00 00	 call	 _IsUacSupported
  00097	85 c0		 test	 eax, eax
  00099	74 1b		 je	 SHORT $LN15@SwitchWiza
  0009b	83 ec 18	 sub	 esp, 24			; 00000018H
  0009e	8b cc		 mov	 ecx, esp
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_02CLCFLINC@?1e?$AA@
  000a5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000aa	e8 00 00 00 00	 call	 ?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ElevateWholeWizardProcess
  000af	83 c4 18	 add	 esp, 24			; 00000018H
  000b2	85 c0		 test	 eax, eax
  000b4	74 49		 je	 SHORT $LN16@SwitchWiza
$LN15@SwitchWiza:
  000b6	0f 57 c0	 xorps	 xmm0, xmm0
  000b9	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  000c0	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  000c7	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  000cf	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  000d7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _WizardMode, 1
$LN8@SwitchWiza:
  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  000e6	f7 d8		 neg	 eax
  000e8	1b c0		 sbb	 eax, eax
  000ea	f7 d8		 neg	 eax
  000ec	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  000f3	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice
  000f8	75 05		 jne	 SHORT $LN16@SwitchWiza
  000fa	e8 00 00 00 00	 call	 _CloseSysEncMutex
$LN16@SwitchWiza:

; 1227 : 
; 1228 : 	LoadPage (MainDlg, NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE);

  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  00104	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  0010a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _MainDlg
  00110	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  00116	85 c0		 test	 eax, eax
  00118	74 59		 je	 SHORT $LN31@SwitchWiza
  0011a	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  00124	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00127	75 39		 jne	 SHORT $LN25@SwitchWiza
  00129	6a 40		 push	 64			; 00000040H
  0012b	8d 45 b8	 lea	 eax, DWORD PTR _tmp$3[ebp]
  0012e	6a 58		 push	 88			; 00000058H
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _memset
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH
  00139	c6 45 f8 00	 mov	 BYTE PTR _tmp$3[ebp+64], 0
  0013d	8d 45 b8	 lea	 eax, DWORD PTR _tmp$3[ebp]
  00140	50		 push	 eax
  00141	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  00146	50		 push	 eax
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
  0014d	8d 45 b8	 lea	 eax, DWORD PTR _tmp$3[ebp]
  00150	50		 push	 eax
  00151	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  00156	50		 push	 eax
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
  0015d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN25@SwitchWiza:
  00162	50		 push	 eax
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00169	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN31@SwitchWiza:
  00173	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  0017d	e8 00 00 00 00	 call	 _NormalCursor
  00182	8d 45 a8	 lea	 eax, DWORD PTR _rW$2[ebp]
  00185	50		 push	 eax
  00186	68 23 04 00 00	 push	 1059			; 00000423H
  0018b	57		 push	 edi
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00192	50		 push	 eax
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00199	6a 00		 push	 0
  0019b	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  001a0	57		 push	 edi
  001a1	6a 6f		 push	 111			; 0000006fH
  001a3	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  001a9	c7 05 00 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 32 ; nCurPageNo, 00000020H
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  001b9	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  001c0	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  001c5	8d 45 98	 lea	 eax, DWORD PTR _rD$1[ebp]
  001c8	50		 push	 eax
  001c9	57		 push	 edi
  001ca	0f 11 45 98	 movups	 XMMWORD PTR _rD$1[ebp], xmm0
  001ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  001d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  001da	85 c9		 test	 ecx, ecx
  001dc	74 2b		 je	 SHORT $LN76@SwitchWiza
  001de	8b 45 b4	 mov	 eax, DWORD PTR _rW$2[ebp+12]
  001e1	2b 45 ac	 sub	 eax, DWORD PTR _rW$2[ebp+4]
  001e4	6a 01		 push	 1
  001e6	50		 push	 eax
  001e7	8b 45 b0	 mov	 eax, DWORD PTR _rW$2[ebp+8]
  001ea	2b 45 a8	 sub	 eax, DWORD PTR _rW$2[ebp]
  001ed	50		 push	 eax
  001ee	ff 75 9c	 push	 DWORD PTR _rD$1[ebp+4]
  001f1	ff 75 98	 push	 DWORD PTR _rD$1[ebp]
  001f4	51		 push	 ecx
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  001fb	6a 01		 push	 1
  001fd	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN76@SwitchWiza:

; 1229 : }

  00209	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020c	33 cd		 xor	 ecx, ebp
  0020e	5f		 pop	 edi
  0020f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c3		 ret	 0
?SwitchWizardToNonSysInplaceEncResumeMode@@YAXXZ ENDP	; SwitchWizardToNonSysInplaceEncResumeMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?SwitchWizardToHiddenOSMode@@YAHXZ
_TEXT	SEGMENT
_e$2 = -224						; size = 4
_rD$3 = -220						; size = 16
_rD$4 = -204						; size = 16
_rW$5 = -188						; size = 16
_rW$6 = -172						; size = 16
_tmp$7 = -156						; size = 65
_tmp$8 = -88						; size = 65
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?SwitchWizardToHiddenOSMode@@YAHXZ PROC			; SwitchWizardToHiddenOSMode, COMDAT

; 1157 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SwitchWizardToHiddenOSMode@@YAHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1158 : 	if (SwitchWizardToSysEncMode())

  00031	e8 00 00 00 00	 call	 _SwitchWizardToSysEncMode
  00036	85 c0		 test	 eax, eax
  00038	0f 84 d4 02 00
	00		 je	 $LN2@SwitchWiza

; 1159 : 	{
; 1160 : 		if (nCurPageNo != SYSENC_ENCRYPTION_PAGE)	// If the user did not manually choose to resume encryption or decryption of the system partition/drive

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  00043	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00046	0f 84 bf 02 00
	00		 je	 $LN4@SwitchWiza

; 1161 : 		{
; 1162 : 			bHiddenOS = TRUE;
; 1163 : 			bHiddenVol = TRUE;
; 1164 : 			bHiddenVolHost = TRUE;
; 1165 : 			bHiddenVolDirect = FALSE;
; 1166 : 			bWholeSysDrive = FALSE;
; 1167 : 			bInPlaceEncNonSys = FALSE;
; 1168 : 
; 1169 : 			if (bDirectSysEncModeCommand == SYSENC_COMMAND_CREATE_HIDDEN_OS_ELEV)

  0004c	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR ?bDirectSysEncModeCommand@@3HA, 6 ; bDirectSysEncModeCommand
  00053	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bHiddenOS@@3HC, 1 ; bHiddenOS
  0005d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bHiddenVol@@3HC, 1 ; bHiddenVol
  00067	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bHiddenVolHost, 1
  00071	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHiddenVolDirect, 0
  0007b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
  00085	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  0008f	0f 85 4a 01 00
	00		 jne	 $LN6@SwitchWiza

; 1170 : 			{
; 1171 : 				// Some of the requirements for hidden OS should have already been checked by the wizard process
; 1172 : 				// that launched us (in order to elevate), but we must recheck them. Otherwise, an advanced user 
; 1173 : 				// could bypass the checks by using the undocumented CLI switch. Moreover, some requirements
; 1174 : 				// can be checked only at this point (when we are elevated).
; 1175 : 				try
; 1176 : 				{
; 1177 : 					BootEncObj->CheckRequirementsHiddenOS ();

  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0009b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000a2	e8 00 00 00 00	 call	 ?CheckRequirementsHiddenOS@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckRequirementsHiddenOS

; 1178 : 
; 1179 : 					BootEncObj->InitialSecurityChecksForHiddenOS ();

  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  000ad	e8 00 00 00 00	 call	 ?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::InitialSecurityChecksForHiddenOS

; 1185 : 				}
; 1186 : 
; 1187 : 				LoadPage (MainDlg, SYSENC_MULTI_BOOT_MODE_PAGE);

  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  000b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  000bd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _MainDlg
  000c3	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  000c9	85 c0		 test	 eax, eax
  000cb	74 57		 je	 SHORT $LN21@SwitchWiza
  000cd	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  000d7	83 f9 15	 cmp	 ecx, 21			; 00000015H
  000da	75 37		 jne	 SHORT $LN15@SwitchWiza
  000dc	6a 40		 push	 64			; 00000040H
  000de	8d 45 a8	 lea	 eax, DWORD PTR _tmp$8[ebp]
  000e1	6a 58		 push	 88			; 00000058H
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _memset
  000e9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  000ef	8d 45 a8	 lea	 eax, DWORD PTR _tmp$8[ebp]
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f5	c6 45 e8 00	 mov	 BYTE PTR _tmp$8[ebp+64], 0
  000f9	50		 push	 eax
  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  000ff	50		 push	 eax
  00100	ff d6		 call	 esi
  00102	8d 45 a8	 lea	 eax, DWORD PTR _tmp$8[ebp]
  00105	50		 push	 eax
  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  0010b	50		 push	 eax
  0010c	ff d6		 call	 esi
  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN15@SwitchWiza:
  00113	50		 push	 eax
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  0011a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN21@SwitchWiza:
  00124	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  0012e	e8 00 00 00 00	 call	 _NormalCursor
  00133	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _rW$6[ebp]
  00139	50		 push	 eax
  0013a	68 23 04 00 00	 push	 1059			; 00000423H
  0013f	57		 push	 edi
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00146	50		 push	 eax
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  0014d	6a 00		 push	 0
  0014f	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00154	57		 push	 edi
  00155	6a 77		 push	 119			; 00000077H
  00157	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  0015d	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 6 ; nCurPageNo
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  0016d	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  00174	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  00179	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _rD$4[ebp]
  0017f	50		 push	 eax
  00180	57		 push	 edi
  00181	0f 11 85 34 ff
	ff ff		 movups	 XMMWORD PTR _rD$4[ebp], xmm0
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  0018e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  00194	85 c9		 test	 ecx, ecx
  00196	0f 84 6a 01 00
	00		 je	 $LN133@SwitchWiza
  0019c	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _rW$6[ebp+12]
  001a2	2b 85 58 ff ff
	ff		 sub	 eax, DWORD PTR _rW$6[ebp+4]
  001a8	6a 01		 push	 1
  001aa	50		 push	 eax
  001ab	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _rW$6[ebp+8]
  001b1	2b 85 54 ff ff
	ff		 sub	 eax, DWORD PTR _rW$6[ebp]
  001b7	50		 push	 eax
  001b8	ff b5 38 ff ff
	ff		 push	 DWORD PTR _rD$4[ebp+4]
  001be	ff b5 34 ff ff
	ff		 push	 DWORD PTR _rD$4[ebp]

; 1188 : 			}
; 1189 : 			else

  001c4	e9 28 01 00 00	 jmp	 $LN148@SwitchWiza
__catch$?SwitchWizardToHiddenOSMode@@YAHXZ$0:

; 1180 : 				}
; 1181 : 				catch (Exception &e)
; 1182 : 				{
; 1183 : 					e.Show (MainDlg);

  001c9	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  001cf	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  001d5	8b 01		 mov	 eax, DWORD PTR [ecx]
  001d7	ff 10		 call	 DWORD PTR [eax]

; 1184 : 					return FALSE;

  001d9	b8 00 00 00 00	 mov	 eax, $LN2@SwitchWiza
  001de	c3		 ret	 0
$LN6@SwitchWiza:

; 1190 : 				LoadPage (MainDlg, SYSENC_HIDDEN_OS_REQ_CHECK_PAGE);

  001df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  001e5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _MainDlg
  001eb	a3 00 00 00 00	 mov	 DWORD PTR ?nLastPageNo@@3HA, eax ; nLastPageNo
  001f0	85 c9		 test	 ecx, ecx
  001f2	74 61		 je	 SHORT $LN88@SwitchWiza
  001f4	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  001fe	83 f8 15	 cmp	 eax, 21			; 00000015H
  00201	75 41		 jne	 SHORT $LN82@SwitchWiza
  00203	6a 40		 push	 64			; 00000040H
  00205	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$7[ebp]
  0020b	6a 58		 push	 88			; 00000058H
  0020d	50		 push	 eax
  0020e	e8 00 00 00 00	 call	 _memset
  00213	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  00219	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$7[ebp]
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00222	c6 45 a4 00	 mov	 BYTE PTR _tmp$7[ebp+64], 0
  00226	50		 push	 eax
  00227	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  0022c	50		 push	 eax
  0022d	ff d6		 call	 esi
  0022f	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$7[ebp]
  00235	50		 push	 eax
  00236	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  0023b	50		 push	 eax
  0023c	ff d6		 call	 esi
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
$LN82@SwitchWiza:
  00244	51		 push	 ecx
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  0024b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN88@SwitchWiza:
  00255	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  0025f	e8 00 00 00 00	 call	 _NormalCursor
  00264	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _rW$5[ebp]
  0026a	50		 push	 eax
  0026b	68 23 04 00 00	 push	 1059			; 00000423H
  00270	57		 push	 edi
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00277	50		 push	 eax
  00278	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  0027e	6a 00		 push	 0
  00280	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00285	57		 push	 edi
  00286	6a 7f		 push	 127			; 0000007fH
  00288	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  0028e	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 2 ; nCurPageNo
  00298	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  0029e	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  002a5	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  002aa	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _rD$3[ebp]
  002b0	50		 push	 eax
  002b1	57		 push	 edi
  002b2	0f 11 85 24 ff
	ff ff		 movups	 XMMWORD PTR _rD$3[ebp], xmm0
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  002bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  002c5	85 c9		 test	 ecx, ecx
  002c7	74 3d		 je	 SHORT $LN133@SwitchWiza
  002c9	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _rW$5[ebp+12]
  002cf	2b 85 48 ff ff
	ff		 sub	 eax, DWORD PTR _rW$5[ebp+4]
  002d5	6a 01		 push	 1
  002d7	50		 push	 eax
  002d8	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _rW$5[ebp+8]
  002de	2b 85 44 ff ff
	ff		 sub	 eax, DWORD PTR _rW$5[ebp]
  002e4	50		 push	 eax
  002e5	ff b5 28 ff ff
	ff		 push	 DWORD PTR _rD$3[ebp+4]
  002eb	ff b5 24 ff ff
	ff		 push	 DWORD PTR _rD$3[ebp]
$LN148@SwitchWiza:
  002f1	51		 push	 ecx
  002f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  002f8	6a 01		 push	 1
  002fa	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00300	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN133@SwitchWiza:

; 1191 : 
; 1192 : 			NormalCursor ();

  00306	e8 00 00 00 00	 call	 _NormalCursor
$LN4@SwitchWiza:

; 1199 : 
; 1200 : 	return TRUE;

  0030b	b8 01 00 00 00	 mov	 eax, 1
  00310	eb 02		 jmp	 SHORT $LN1@SwitchWiza
$LN2@SwitchWiza:

; 1193 : 		}
; 1194 : 		else
; 1195 : 			return TRUE;
; 1196 : 	}
; 1197 : 	else
; 1198 : 		return FALSE;

  00312	33 c0		 xor	 eax, eax
$LN1@SwitchWiza:

; 1201 : }

  00314	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00317	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0031e	59		 pop	 ecx
  0031f	5f		 pop	 edi
  00320	5e		 pop	 esi
  00321	5b		 pop	 ebx
  00322	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00325	33 cd		 xor	 ecx, ebp
  00327	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032c	8b e5		 mov	 esp, ebp
  0032e	5d		 pop	 ebp
  0032f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?SwitchWizardToHiddenOSMode@@YAHXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 1c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-228]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SwitchWizardToHiddenOSMode@@YAHXZ
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SwitchWizardToHiddenOSMode@@YAHXZ ENDP			; SwitchWizardToHiddenOSMode
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?SwitchWizardToNonSysDeviceMode@@YAXXZ
_TEXT	SEGMENT
_rD$1 = -104						; size = 16
_rW$2 = -88						; size = 16
_tmp$3 = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
?SwitchWizardToNonSysDeviceMode@@YAXXZ PROC		; SwitchWizardToNonSysDeviceMode, COMDAT

; 1138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1139 : 	ChangeWizardMode (WIZARD_MODE_NONSYS_DEVICE);

  00010	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _WizardMode, 1
  00017	57		 push	 edi
  00018	74 66		 je	 SHORT $LN4@SwitchWiza
  0001a	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  00021	75 05		 jne	 SHORT $LN5@SwitchWiza
  00023	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
$LN5@SwitchWiza:
  00028	e8 00 00 00 00	 call	 _IsAdmin
  0002d	85 c0		 test	 eax, eax
  0002f	75 24		 jne	 SHORT $LN11@SwitchWiza
  00031	e8 00 00 00 00	 call	 _IsUacSupported
  00036	85 c0		 test	 eax, eax
  00038	74 1b		 je	 SHORT $LN11@SwitchWiza
  0003a	83 ec 18	 sub	 esp, 24			; 00000018H
  0003d	8b cc		 mov	 ecx, esp
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_02CLCFLINC@?1e?$AA@
  00044	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00049	e8 00 00 00 00	 call	 ?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ElevateWholeWizardProcess
  0004e	83 c4 18	 add	 esp, 24			; 00000018H
  00051	85 c0		 test	 eax, eax
  00053	74 49		 je	 SHORT $LN12@SwitchWiza
$LN11@SwitchWiza:
  00055	0f 57 c0	 xorps	 xmm0, xmm0
  00058	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  0005f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  00066	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  0006e	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  00076	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _WizardMode, 1
$LN4@SwitchWiza:
  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  00085	f7 d8		 neg	 eax
  00087	1b c0		 sbb	 eax, eax
  00089	f7 d8		 neg	 eax
  0008b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00092	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice
  00097	75 05		 jne	 SHORT $LN12@SwitchWiza
  00099	e8 00 00 00 00	 call	 _CloseSysEncMutex
$LN12@SwitchWiza:

; 1140 : 
; 1141 : 	LoadPage (MainDlg, VOLUME_TYPE_PAGE);

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  000a9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _MainDlg
  000af	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  000b5	85 c0		 test	 eax, eax
  000b7	74 59		 je	 SHORT $LN27@SwitchWiza
  000b9	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  000c3	83 f9 15	 cmp	 ecx, 21			; 00000015H
  000c6	75 39		 jne	 SHORT $LN21@SwitchWiza
  000c8	6a 40		 push	 64			; 00000040H
  000ca	8d 45 b8	 lea	 eax, DWORD PTR _tmp$3[ebp]
  000cd	6a 58		 push	 88			; 00000058H
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _memset
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d8	c6 45 f8 00	 mov	 BYTE PTR _tmp$3[ebp+64], 0
  000dc	8d 45 b8	 lea	 eax, DWORD PTR _tmp$3[ebp]
  000df	50		 push	 eax
  000e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  000e5	50		 push	 eax
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
  000ec	8d 45 b8	 lea	 eax, DWORD PTR _tmp$3[ebp]
  000ef	50		 push	 eax
  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  000f5	50		 push	 eax
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
  000fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN21@SwitchWiza:
  00101	50		 push	 eax
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00108	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN27@SwitchWiza:
  00112	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  0011c	e8 00 00 00 00	 call	 _NormalCursor
  00121	8d 45 a8	 lea	 eax, DWORD PTR _rW$2[ebp]
  00124	50		 push	 eax
  00125	68 23 04 00 00	 push	 1059			; 00000423H
  0012a	57		 push	 edi
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00131	50		 push	 eax
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00138	6a 00		 push	 0
  0013a	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  0013f	57		 push	 edi
  00140	6a 71		 push	 113			; 00000071H
  00142	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00148	c7 05 00 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 12 ; nCurPageNo, 0000000cH
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  00158	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  0015f	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  00164	8d 45 98	 lea	 eax, DWORD PTR _rD$1[ebp]
  00167	50		 push	 eax
  00168	57		 push	 edi
  00169	0f 11 45 98	 movups	 XMMWORD PTR _rD$1[ebp], xmm0
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00173	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  00179	85 c9		 test	 ecx, ecx
  0017b	74 2b		 je	 SHORT $LN72@SwitchWiza
  0017d	8b 45 b4	 mov	 eax, DWORD PTR _rW$2[ebp+12]
  00180	2b 45 ac	 sub	 eax, DWORD PTR _rW$2[ebp+4]
  00183	6a 01		 push	 1
  00185	50		 push	 eax
  00186	8b 45 b0	 mov	 eax, DWORD PTR _rW$2[ebp+8]
  00189	2b 45 a8	 sub	 eax, DWORD PTR _rW$2[ebp]
  0018c	50		 push	 eax
  0018d	ff 75 9c	 push	 DWORD PTR _rD$1[ebp+4]
  00190	ff 75 98	 push	 DWORD PTR _rD$1[ebp]
  00193	51		 push	 ecx
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  0019a	6a 01		 push	 1
  0019c	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN72@SwitchWiza:

; 1142 : 
; 1143 : 	NormalCursor ();

  001a8	e8 00 00 00 00	 call	 _NormalCursor

; 1144 : }

  001ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b0	33 cd		 xor	 ecx, ebp
  001b2	5f		 pop	 edi
  001b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
?SwitchWizardToNonSysDeviceMode@@YAXXZ ENDP		; SwitchWizardToNonSysDeviceMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2439 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2440 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  00013	75 04		 jne	 SHORT $LN9@operator
  00015	33 c0		 xor	 eax, eax
  00017	eb 16		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00019	8b c2		 mov	 eax, edx
  0001b	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0001e	66 90		 npad	 2
$LL141@operator:
  00020	66 8b 08	 mov	 cx, WORD PTR [eax]
  00023	83 c0 02	 add	 eax, 2
  00026	66 85 c9	 test	 cx, cx
  00029	75 f5		 jne	 SHORT $LL141@operator
  0002b	2b c6		 sub	 eax, esi
  0002d	d1 f8		 sar	 eax, 1
$LN10@operator:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00032	50		 push	 eax
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00039	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	33 c9		 xor	 ecx, ecx
  0003e	50		 push	 eax
  0003f	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	66 89 0e	 mov	 WORD PTR [esi], cx
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi

; 2441 : 	}

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?SysDriveOrPartitionFullyEncrypted@@YAHH@Z
_TEXT	SEGMENT
_e$2 = -120						; size = 4
$T3 = -116						; size = 94
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_bSilent$ = 8						; size = 4
?SysDriveOrPartitionFullyEncrypted@@YAHH@Z PROC		; SysDriveOrPartitionFullyEncrypted, COMDAT

; 877  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 878  : 	/* If you update this function, revise SysDriveOrPartitionFullyEncrypted() in Mount.c as well. */
; 879  : 
; 880  : 	static BootEncryptionStatus locBootEncStatus;
; 881  : 
; 882  : 	try
; 883  : 	{
; 884  : 		locBootEncStatus = BootEncObj->GetStatus();

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00034	8d 45 8c	 lea	 eax, DWORD PTR $T3[ebp]
  00037	50		 push	 eax
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003f	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00044	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00049	8b f0		 mov	 esi, eax
  0004b	bf 00 00 00 00	 mov	 edi, OFFSET ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A
  00050	f3 a5		 rep movsd
  00052	66 a5		 movsw
$LN10@SysDriveOr:

; 891  : 
; 892  : 	return (!locBootEncStatus.SetupInProgress

  00054	83 3d 3e 00 00
	00 00		 cmp	 DWORD PTR ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A+62, 0
  0005b	75 65		 jne	 SHORT $LN5@SysDriveOr
  0005d	8b 15 22 00 00
	00		 mov	 edx, DWORD PTR ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A+34
  00063	8b c2		 mov	 eax, edx
  00065	8b 0d 26 00 00
	00		 mov	 ecx, DWORD PTR ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A+38
  0006b	0b c1		 or	 eax, ecx
  0006d	74 53		 je	 SHORT $LN5@SysDriveOr
  0006f	8b c2		 mov	 eax, edx
  00071	23 c1		 and	 eax, ecx
  00073	83 f8 ff	 cmp	 eax, -1
  00076	74 4a		 je	 SHORT $LN5@SysDriveOr
  00078	a1 1a 00 00 00	 mov	 eax, DWORD PTR ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A+26
  0007d	3b 05 2a 00 00
	00		 cmp	 eax, DWORD PTR ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A+42
  00083	75 3d		 jne	 SHORT $LN5@SysDriveOr
  00085	a1 1e 00 00 00	 mov	 eax, DWORD PTR ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A+30
  0008a	3b 05 2e 00 00
	00		 cmp	 eax, DWORD PTR ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A+46
  00090	75 30		 jne	 SHORT $LN5@SysDriveOr
  00092	3b 15 32 00 00
	00		 cmp	 edx, DWORD PTR ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A+50
  00098	75 28		 jne	 SHORT $LN5@SysDriveOr
  0009a	3b 0d 36 00 00
	00		 cmp	 ecx, DWORD PTR ?locBootEncStatus@?1??SysDriveOrPartitionFullyEncrypted@@YAHH@Z@4UBootEncryptionStatus@@A+54
  000a0	75 20		 jne	 SHORT $LN5@SysDriveOr
  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	eb 1b		 jmp	 SHORT $LN6@SysDriveOr
__catch$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z$0:

; 885  : 	}
; 886  : 	catch (Exception &e)
; 887  : 	{
; 888  : 		if (!bSilent)

  000a9	83 7d 08 00	 cmp	 DWORD PTR _bSilent$[ebp], 0
  000ad	75 0d		 jne	 SHORT $LN3@SysDriveOr

; 889  : 			e.Show (MainDlg);

  000af	8b 4d 88	 mov	 ecx, DWORD PTR _e$2[ebp]
  000b2	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000b8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ba	ff 10		 call	 DWORD PTR [eax]
$LN3@SysDriveOr:

; 890  : 	}

  000bc	b8 00 00 00 00	 mov	 eax, $LN10@SysDriveOr
  000c1	c3		 ret	 0
$LN5@SysDriveOr:

; 891  : 
; 892  : 	return (!locBootEncStatus.SetupInProgress

  000c2	33 c0		 xor	 eax, eax
$LN6@SysDriveOr:

; 893  : 		&& locBootEncStatus.ConfiguredEncryptedAreaEnd != 0
; 894  : 		&& locBootEncStatus.ConfiguredEncryptedAreaEnd != -1
; 895  : 		&& locBootEncStatus.ConfiguredEncryptedAreaStart == locBootEncStatus.EncryptedAreaStart
; 896  : 		&& locBootEncStatus.ConfiguredEncryptedAreaEnd == locBootEncStatus.EncryptedAreaEnd);
; 897  : }

  000c4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ce	59		 pop	 ecx
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d5	33 cd		 xor	 ecx, ebp
  000d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SysDriveOrPartitionFullyEncrypted@@YAHH@Z
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SysDriveOrPartitionFullyEncrypted@@YAHH@Z ENDP		; SysDriveOrPartitionFullyEncrypted
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?SysEncryptionOrDecryptionRequired@@YAHXZ
_TEXT	SEGMENT
_e$2 = -120						; size = 4
$T3 = -116						; size = 94
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?SysEncryptionOrDecryptionRequired@@YAHXZ PROC		; SysEncryptionOrDecryptionRequired, COMDAT

; 840  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SysEncryptionOrDecryptionRequired@@YAHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 841  : 	/* If you update this function, revise SysEncryptionOrDecryptionRequired() in Mount.c as well. */
; 842  : 
; 843  : 	static BootEncryptionStatus locBootEncStatus;
; 844  : 
; 845  : 	try
; 846  : 	{
; 847  : 		locBootEncStatus = BootEncObj->GetStatus();

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00034	8d 45 8c	 lea	 eax, DWORD PTR $T3[ebp]
  00037	50		 push	 eax
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003f	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00044	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00049	8b f0		 mov	 esi, eax
  0004b	bf 00 00 00 00	 mov	 edi, OFFSET ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A
  00050	f3 a5		 rep movsd
  00052	66 a5		 movsw
$LN11@SysEncrypt:

; 853  : 
; 854  : 	return (SystemEncryptionStatus == SYSENC_STATUS_ENCRYPTING

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionStatus
  00059	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  0005e	74 5b		 je	 SHORT $LN4@SysEncrypt
  00060	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  00065	74 54		 je	 SHORT $LN4@SysEncrypt
  00067	83 3d 06 00 00
	00 00		 cmp	 DWORD PTR ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A+6, 0
  0006e	74 34		 je	 SHORT $LN6@SysEncrypt
  00070	a1 1a 00 00 00	 mov	 eax, DWORD PTR ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A+26
  00075	3b 05 2a 00 00
	00		 cmp	 eax, DWORD PTR ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A+42
  0007b	75 3e		 jne	 SHORT $LN4@SysEncrypt
  0007d	a1 1e 00 00 00	 mov	 eax, DWORD PTR ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A+30
  00082	3b 05 2e 00 00
	00		 cmp	 eax, DWORD PTR ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A+46
  00088	75 31		 jne	 SHORT $LN4@SysEncrypt
  0008a	a1 22 00 00 00	 mov	 eax, DWORD PTR ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A+34
  0008f	3b 05 32 00 00
	00		 cmp	 eax, DWORD PTR ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A+50
  00095	75 24		 jne	 SHORT $LN4@SysEncrypt
  00097	a1 26 00 00 00	 mov	 eax, DWORD PTR ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A+38
  0009c	3b 05 36 00 00
	00		 cmp	 eax, DWORD PTR ?locBootEncStatus@?1??SysEncryptionOrDecryptionRequired@@YAHXZ@4UBootEncryptionStatus@@A+54
  000a2	75 17		 jne	 SHORT $LN4@SysEncrypt
$LN6@SysEncrypt:
  000a4	33 c0		 xor	 eax, eax
  000a6	eb 18		 jmp	 SHORT $LN7@SysEncrypt
__catch$?SysEncryptionOrDecryptionRequired@@YAHXZ$0:

; 848  : 	}
; 849  : 	catch (Exception &e)
; 850  : 	{
; 851  : 		e.Show (MainDlg);

  000a8	8b 4d 88	 mov	 ecx, DWORD PTR _e$2[ebp]
  000ab	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000b1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b3	ff 10		 call	 DWORD PTR [eax]

; 852  : 	}

  000b5	b8 00 00 00 00	 mov	 eax, $LN11@SysEncrypt
  000ba	c3		 ret	 0
$LN4@SysEncrypt:

; 853  : 
; 854  : 	return (SystemEncryptionStatus == SYSENC_STATUS_ENCRYPTING

  000bb	b8 01 00 00 00	 mov	 eax, 1
$LN7@SysEncrypt:

; 855  : 		|| SystemEncryptionStatus == SYSENC_STATUS_DECRYPTING
; 856  : 		|| 
; 857  : 		(
; 858  : 			locBootEncStatus.DriveMounted 
; 859  : 			&& 
; 860  : 			(
; 861  : 				locBootEncStatus.ConfiguredEncryptedAreaStart != locBootEncStatus.EncryptedAreaStart
; 862  : 				|| locBootEncStatus.ConfiguredEncryptedAreaEnd != locBootEncStatus.EncryptedAreaEnd
; 863  : 			)
; 864  : 		)
; 865  : 	);
; 866  : }

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d1	33 cd		 xor	 ecx, ebp
  000d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?SysEncryptionOrDecryptionRequired@@YAHXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SysEncryptionOrDecryptionRequired@@YAHXZ
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SysEncryptionOrDecryptionRequired@@YAHXZ ENDP		; SysEncryptionOrDecryptionRequired
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?ChangeWizardMode@@YAHH@Z
_TEXT	SEGMENT
_newWizardMode$ = 8					; size = 4
?ChangeWizardMode@@YAHH@Z PROC				; ChangeWizardMode, COMDAT

; 649  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 650  : 	if (WizardMode != newWizardMode)	

  00004	8b 75 08	 mov	 esi, DWORD PTR _newWizardMode$[ebp]
  00007	39 35 00 00 00
	00		 cmp	 DWORD PTR _WizardMode, esi
  0000d	0f 84 9a 00 00
	00		 je	 $LN2@ChangeWiza

; 651  : 	{
; 652  : 		if (WizardMode == WIZARD_MODE_SYS_DEVICE || newWizardMode == WIZARD_MODE_SYS_DEVICE)

  00013	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  0001a	74 07		 je	 SHORT $LN4@ChangeWiza
  0001c	83 fe 02	 cmp	 esi, 2
  0001f	75 27		 jne	 SHORT $LN3@ChangeWiza

; 653  : 		{
; 654  : 			if (newWizardMode == WIZARD_MODE_SYS_DEVICE)

  00021	eb 05		 jmp	 SHORT $LN18@ChangeWiza
$LN4@ChangeWiza:
  00023	83 fe 02	 cmp	 esi, 2
  00026	75 1b		 jne	 SHORT $LN6@ChangeWiza
$LN18@ChangeWiza:

; 655  : 			{
; 656  : 				if (!CreateSysEncMutex ())

  00028	e8 00 00 00 00	 call	 _CreateSysEncMutex
  0002d	85 c0		 test	 eax, eax
  0002f	75 12		 jne	 SHORT $LN6@ChangeWiza

; 657  : 				{
; 658  : 					Error ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00036	e8 00 00 00 00	 call	 _Error
  0003b	83 c4 04	 add	 esp, 4
$LN19@ChangeWiza:

; 659  : 					return FALSE;

  0003e	33 c0		 xor	 eax, eax

; 696  : }

  00040	5e		 pop	 esi
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN6@ChangeWiza:

; 660  : 				}
; 661  : 			}
; 662  : 
; 663  : 			// If the previous mode was different, the password may have been typed using a different
; 664  : 			// keyboard layout (which might confuse the user and cause other problems if system encryption
; 665  : 			// was or will be involved).
; 666  : 			WipePasswordsAndKeyfiles();	

  00043	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
$LN3@ChangeWiza:

; 667  : 		}
; 668  : 
; 669  : 		if (newWizardMode != WIZARD_MODE_NONSYS_DEVICE)

  00048	83 fe 01	 cmp	 esi, 1
  0004b	74 0c		 je	 SHORT $LN17@ChangeWiza

; 670  : 			bInPlaceEncNonSys = FALSE;

  0004d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0

; 671  : 
; 672  : 		if (newWizardMode == WIZARD_MODE_NONSYS_DEVICE && !IsAdmin() && IsUacSupported())

  00057	eb 2d		 jmp	 SHORT $LN9@ChangeWiza
$LN17@ChangeWiza:
  00059	e8 00 00 00 00	 call	 _IsAdmin
  0005e	85 c0		 test	 eax, eax
  00060	75 24		 jne	 SHORT $LN9@ChangeWiza
  00062	e8 00 00 00 00	 call	 _IsUacSupported
  00067	85 c0		 test	 eax, eax
  00069	74 1b		 je	 SHORT $LN9@ChangeWiza

; 673  : 		{
; 674  : 			if (!ElevateWholeWizardProcess ("/e"))

  0006b	83 ec 18	 sub	 esp, 24			; 00000018H
  0006e	8b cc		 mov	 ecx, esp
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_02CLCFLINC@?1e?$AA@
  00075	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0007a	e8 00 00 00 00	 call	 ?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ElevateWholeWizardProcess
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	85 c0		 test	 eax, eax
  00084	74 b8		 je	 SHORT $LN19@ChangeWiza
$LN9@ChangeWiza:
  00086	0f 57 c0	 xorps	 xmm0, xmm0

; 675  : 				return FALSE;
; 676  : 		}
; 677  : 
; 678  : 		// The contents of the following items may be inappropriate after a change of mode
; 679  : 		szFileName[0] = 0;

  00089	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0

; 680  : 		szDiskFile[0] = 0;

  00090	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0

; 681  : 		nUIVolumeSize = 0;

  00097	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0

; 682  : 		nVolumeSize = 0;

  0009f	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0

; 683  : 
; 684  : 		WizardMode = newWizardMode;

  000a7	89 35 00 00 00
	00		 mov	 DWORD PTR _WizardMode, esi
$LN2@ChangeWiza:

; 685  : 	}
; 686  : 
; 687  : 	bDevice = (WizardMode != WIZARD_MODE_FILE_CONTAINER);

  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  000b2	f7 d8		 neg	 eax
  000b4	1b c0		 sbb	 eax, eax
  000b6	f7 d8		 neg	 eax
  000b8	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice

; 688  : 
; 689  : 	if (newWizardMode != WIZARD_MODE_SYS_DEVICE 
; 690  : 		&& !bHiddenOS)

  000bd	83 fe 02	 cmp	 esi, 2
  000c0	74 0e		 je	 SHORT $LN10@ChangeWiza
  000c2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  000c9	75 05		 jne	 SHORT $LN10@ChangeWiza

; 691  : 	{
; 692  : 		CloseSysEncMutex ();	

  000cb	e8 00 00 00 00	 call	 _CloseSysEncMutex
$LN10@ChangeWiza:

; 693  : 	}
; 694  : 
; 695  : 	return TRUE;

  000d0	b8 01 00 00 00	 mov	 eax, 1

; 696  : }

  000d5	5e		 pop	 esi
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
?ChangeWizardMode@@YAHH@Z ENDP				; ChangeWizardMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?ChangeSystemEncryptionStatus@@YAHH@Z
_TEXT	SEGMENT
_newStatus$ = 8						; size = 4
?ChangeSystemEncryptionStatus@@YAHH@Z PROC		; ChangeSystemEncryptionStatus, COMDAT

; 602  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 603  : 	if (!CreateSysEncMutex ())

  00003	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00008	85 c0		 test	 eax, eax
  0000a	75 11		 jne	 SHORT $LN2@ChangeSyst

; 604  : 	{
; 605  : 		Error ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00011	e8 00 00 00 00	 call	 _Error
  00016	83 c4 04	 add	 esp, 4
$LN8@ChangeSyst:

; 606  : 		return FALSE;		// Only one instance that has the mutex can modify the system encryption settings

  00019	33 c0		 xor	 eax, eax

; 629  : 	{
; 630  : 		return FALSE;
; 631  : 	}
; 632  : 
; 633  : 	return TRUE;
; 634  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN2@ChangeSyst:

; 607  : 	}
; 608  : 
; 609  : 	SystemEncryptionStatus = newStatus;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _newStatus$[ebp]
  00020	a3 00 00 00 00	 mov	 DWORD PTR _SystemEncryptionStatus, eax

; 610  : 	bSystemEncryptionStatusChanged = TRUE;

  00025	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 1

; 611  : 
; 612  : 	if (newStatus == SYSENC_STATUS_ENCRYPTING)

  0002f	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  00034	74 24		 je	 SHORT $LN5@ChangeSyst

; 613  : 	{
; 614  : 		// If the user has created a hidden OS and now is creating a decoy OS, we must wipe the hidden OS
; 615  : 		// config area in the MBR.
; 616  : 		WipeHiddenOSCreationConfig();
; 617  : 	}
; 618  : 
; 619  : 	if (newStatus == SYSENC_STATUS_NONE && !IsHiddenOSRunning())

  00036	85 c0		 test	 eax, eax
  00038	75 25		 jne	 SHORT $LN4@ChangeSyst
  0003a	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  0003f	85 c0		 test	 eax, eax
  00041	75 1c		 jne	 SHORT $LN4@ChangeSyst

; 620  : 	{
; 621  : 		if (DetermineHiddenOSCreationPhase() != GST_HIDDEN_OS_CREATION_PHASE_NONE
; 622  : 			&& !ChangeHiddenOSCreationPhase (GST_HIDDEN_OS_CREATION_PHASE_NONE))

  00043	e8 00 00 00 00	 call	 ?DetermineHiddenOSCreationPhase@@YAIXZ ; DetermineHiddenOSCreationPhase
  00048	85 c0		 test	 eax, eax
  0004a	74 0e		 je	 SHORT $LN5@ChangeSyst
  0004c	6a 00		 push	 0
  0004e	e8 00 00 00 00	 call	 ?ChangeHiddenOSCreationPhase@@YAHH@Z ; ChangeHiddenOSCreationPhase
  00053	83 c4 04	 add	 esp, 4
  00056	85 c0		 test	 eax, eax
  00058	74 bf		 je	 SHORT $LN8@ChangeSyst
$LN5@ChangeSyst:

; 623  : 			return FALSE;
; 624  : 
; 625  : 		WipeHiddenOSCreationConfig();

  0005a	e8 00 00 00 00	 call	 _WipeHiddenOSCreationConfig
$LN4@ChangeSyst:

; 626  : 	}
; 627  : 
; 628  : 	if (!SaveSysEncSettings (MainDlg))

  0005f	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00065	e8 00 00 00 00	 call	 ?SaveSysEncSettings@@YAHPAUHWND__@@@Z ; SaveSysEncSettings
  0006a	83 c4 04	 add	 esp, 4
  0006d	f7 d8		 neg	 eax
  0006f	1b c0		 sbb	 eax, eax
  00071	f7 d8		 neg	 eax

; 629  : 	{
; 630  : 		return FALSE;
; 631  : 	}
; 632  : 
; 633  : 	return TRUE;
; 634  : }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?ChangeSystemEncryptionStatus@@YAHH@Z ENDP		; ChangeSystemEncryptionStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?ChangeHiddenOSCreationPhase@@YAHH@Z
_TEXT	SEGMENT
_e$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_newPhase$ = 8						; size = 4
?ChangeHiddenOSCreationPhase@@YAHH@Z PROC		; ChangeHiddenOSCreationPhase, COMDAT

; 560  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ChangeHiddenOSCreationPhase@@YAHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 561  : 	if (!CreateSysEncMutex ())

  0002b	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00030	85 c0		 test	 eax, eax
  00032	75 21		 jne	 SHORT $LN2@ChangeHidd

; 562  : 	{
; 563  : 		Error ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00039	e8 00 00 00 00	 call	 _Error
  0003e	83 c4 04	 add	 esp, 4
$LN8@ChangeHidd:

; 574  : 		return FALSE;

  00041	33 c0		 xor	 eax, eax

; 584  : }

  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN2@ChangeHidd:

; 564  : 		return FALSE;
; 565  : 	}
; 566  : 
; 567  : 	try
; 568  : 	{
; 569  : 		BootEncObj->SetHiddenOSCreationPhase (newPhase);

  00055	ff 75 08	 push	 DWORD PTR _newPhase$[ebp]
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00065	e8 00 00 00 00	 call	 ?SetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEXI@Z ; GostCrypt::BootEncryption::SetHiddenOSCreationPhase

; 575  : 	}
; 576  : 
; 577  : 	//// The contents of the following items might be inappropriate after a change of the phase
; 578  : 	//szFileName[0] = 0;
; 579  : 	//szDiskFile[0] = 0;
; 580  : 	//nUIVolumeSize = 0;
; 581  : 	//nVolumeSize = 0;
; 582  : 
; 583  : 	return TRUE;

  0006a	b8 01 00 00 00	 mov	 eax, 1

; 584  : }

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
__catch$?ChangeHiddenOSCreationPhase@@YAHH@Z$0:

; 570  : 	}
; 571  : 	catch (Exception &e)
; 572  : 	{
; 573  : 		e.Show (MainDlg);

  00081	8b 4d ec	 mov	 ecx, DWORD PTR _e$2[ebp]
  00084	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0008a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008c	ff 10		 call	 DWORD PTR [eax]

; 574  : 		return FALSE;

  0008e	b8 00 00 00 00	 mov	 eax, $LN8@ChangeHidd
  00093	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?ChangeHiddenOSCreationPhase@@YAHH@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ChangeHiddenOSCreationPhase@@YAHH@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ChangeHiddenOSCreationPhase@@YAHH@Z ENDP		; ChangeHiddenOSCreationPhase
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?DetermineHiddenOSCreationPhase@@YAIXZ
_TEXT	SEGMENT
_e$2 = -24						; size = 4
_phase$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?DetermineHiddenOSCreationPhase@@YAIXZ PROC		; DetermineHiddenOSCreationPhase, COMDAT

; 533  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DetermineHiddenOSCreationPhase@@YAIXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 534  : 	unsigned int phase = GST_HIDDEN_OS_CREATION_PHASE_NONE;
; 535  : 
; 536  : 	try
; 537  : 	{
; 538  : 		phase = BootEncObj->GetHiddenOSCreationPhase();

  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _phase$[ebp], 0
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003f	e8 00 00 00 00	 call	 ?GetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEIXZ ; GostCrypt::BootEncryption::GetHiddenOSCreationPhase

; 545  : 
; 546  : 	return phase;
; 547  : }

  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	59		 pop	 ecx
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__catch$?DetermineHiddenOSCreationPhase@@YAIXZ$0:

; 539  : 	}
; 540  : 	catch (Exception &e)
; 541  : 	{
; 542  : 		e.Show (MainDlg);

  00056	8b 4d e8	 mov	 ecx, DWORD PTR _e$2[ebp]
  00059	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0005f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00061	ff 10		 call	 DWORD PTR [eax]

; 543  : 		AbortProcess("ERR_GETTING_SYSTEM_ENCRYPTION_STATUS");

  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@
  00068	e8 00 00 00 00	 call	 _AbortProcess
  0006d	83 c4 04	 add	 esp, 4

; 544  : 	}

  00070	b8 00 00 00 00	 mov	 eax, $LN8@DetermineH
  00075	c3		 ret	 0
$LN8@DetermineH:
  00076	8b 45 ec	 mov	 eax, DWORD PTR _phase$[ebp]

; 545  : 
; 546  : 	return phase;
; 547  : }

  00079	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0007c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00083	59		 pop	 ecx
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DetermineHiddenOSCreationPhase@@YAIXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DetermineHiddenOSCreationPhase@@YAIXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DetermineHiddenOSCreationPhase@@YAIXZ ENDP		; DetermineHiddenOSCreationPhase
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?SaveSysEncSettings@@YAHPAUHWND__@@@Z
_TEXT	SEGMENT
_bSuccess$1 = -4					; size = 4
_hwndDlg$ = 8						; size = 4
?SaveSysEncSettings@@YAHPAUHWND__@@@Z PROC		; SaveSysEncSettings, COMDAT

; 463  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 464  : 	FILE *f;
; 465  : 
; 466  : 	if (!bSystemEncryptionStatusChanged)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 0
  0000b	75 09		 jne	 SHORT $LN2@SaveSysEnc

; 467  : 		return TRUE;

  0000d	b8 01 00 00 00	 mov	 eax, 1

; 522  : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN2@SaveSysEnc:
  00016	57		 push	 edi

; 468  : 
; 469  : 	if (hwndDlg == NULL && MainDlg != NULL)

  00017	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  0001a	85 ff		 test	 edi, edi
  0001c	75 0a		 jne	 SHORT $LN3@SaveSysEnc
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  00023	85 c0		 test	 eax, eax
  00025	0f 45 f8	 cmovne	 edi, eax
$LN3@SaveSysEnc:

; 470  : 		hwndDlg = MainDlg;
; 471  : 
; 472  : 	if (!CreateSysEncMutex ())

  00028	e8 00 00 00 00	 call	 _CreateSysEncMutex
  0002d	85 c0		 test	 eax, eax
  0002f	74 2d		 je	 SHORT $LN16@SaveSysEnc

; 473  : 		return FALSE;		// Only one instance that has the mutex can modify the system encryption settings
; 474  : 
; 475  : 	if (SystemEncryptionStatus == SYSENC_STATUS_NONE)

  00031	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionStatus, 0
  00038	75 55		 jne	 SHORT $LN5@SaveSysEnc

; 476  : 	{
; 477  : 		if (remove (GetConfigPath (GST_APPD_FILENAME_SYSTEM_ENCRYPTION)) != 0)

  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@
  0003f	e8 00 00 00 00	 call	 _GetConfigPath
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _remove
  0004a	83 c4 08	 add	 esp, 8
  0004d	85 c0		 test	 eax, eax
  0004f	74 14		 je	 SHORT $LN6@SaveSysEnc

; 478  : 		{
; 479  : 			Error ("CANNOT_SAVE_SYS_ENCRYPTION_SETTINGS");

  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LPCKNJKP@CANNOT_SAVE_SYS_ENCRYPTION_SETTI@
  00056	e8 00 00 00 00	 call	 _Error
  0005b	83 c4 04	 add	 esp, 4
$LN16@SaveSysEnc:

; 480  : 			return FALSE;

  0005e	33 c0		 xor	 eax, eax
  00060	5f		 pop	 edi

; 522  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN6@SaveSysEnc:

; 481  : 		}
; 482  : 
; 483  : 		bSystemEncryptionStatusChanged = FALSE;
; 484  : 		BroadcastSysEncCfgUpdate ();

  00065	8d 45 fc	 lea	 eax, DWORD PTR _bSuccess$1[ebp]
  00068	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 0
  00072	50		 push	 eax
  00073	68 00 00 00 00	 push	 OFFSET ?BroadcastSysEncCfgUpdateCallb@@YGHPAUHWND__@@J@Z ; BroadcastSysEncCfgUpdateCallb
  00078	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bSuccess$1[ebp], 0
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnumWindows@8

; 485  : 		return TRUE;

  00085	b8 01 00 00 00	 mov	 eax, 1
  0008a	5f		 pop	 edi

; 522  : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
$LN5@SaveSysEnc:
  0008f	56		 push	 esi

; 486  : 	}
; 487  : 
; 488  : 	f = fopen (GetConfigPath (GST_APPD_FILENAME_SYSTEM_ENCRYPTION), "w");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@
  0009a	e8 00 00 00 00	 call	 _GetConfigPath
  0009f	83 c4 04	 add	 esp, 4
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 _fopen
  000a8	8b f0		 mov	 esi, eax
  000aa	83 c4 08	 add	 esp, 8

; 489  : 	if (f == NULL)

  000ad	85 f6		 test	 esi, esi
  000af	75 1b		 jne	 SHORT $LN7@SaveSysEnc

; 490  : 	{
; 491  : 		Error ("CANNOT_SAVE_SYS_ENCRYPTION_SETTINGS");

  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LPCKNJKP@CANNOT_SAVE_SYS_ENCRYPTION_SETTI@
  000b6	e8 00 00 00 00	 call	 _Error

; 492  : 		handleWin32Error (hwndDlg);

  000bb	57		 push	 edi
  000bc	e8 00 00 00 00	 call	 _handleWin32Error
  000c1	83 c4 08	 add	 esp, 8

; 511  : 		return FALSE;

  000c4	33 c0		 xor	 eax, eax
  000c6	5e		 pop	 esi
  000c7	5f		 pop	 edi

; 522  : }

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN7@SaveSysEnc:

; 493  : 		return FALSE;
; 494  : 	}
; 495  : 
; 496  : 	if (XmlWriteHeader (f) < 0
; 497  : 
; 498  : 	|| fputs ("\n\t<sysencryption>", f) < 0
; 499  : 
; 500  : 	|| fprintf (f, "\n\t\t<config key=\"SystemEncryptionStatus\">%d</config>", SystemEncryptionStatus) < 0
; 501  : 
; 502  : 	|| fprintf (f, "\n\t\t<config key=\"WipeMode\">%d</config>", (int) nWipeMode) < 0
; 503  : 
; 504  : 	|| fputs ("\n\t</sysencryption>", f) < 0
; 505  : 
; 506  : 	|| XmlWriteFooter (f) < 0)

  000cc	56		 push	 esi
  000cd	e8 00 00 00 00	 call	 _XmlWriteHeader
  000d2	83 c4 04	 add	 esp, 4
  000d5	85 c0		 test	 eax, eax
  000d7	0f 88 8a 00 00
	00		 js	 $LN9@SaveSysEnc
  000dd	56		 push	 esi
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@IEDCODCO@?6?7?$DMsysencryption?$DO?$AA@
  000e3	e8 00 00 00 00	 call	 _fputs
  000e8	83 c4 08	 add	 esp, 8
  000eb	85 c0		 test	 eax, eax
  000ed	78 78		 js	 SHORT $LN9@SaveSysEnc
  000ef	ff 35 00 00 00
	00		 push	 DWORD PTR _SystemEncryptionStatus
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@HMBPOGIN@?6?7?7?$DMconfig?5key?$DN?$CCSystemEncryption@
  000fa	56		 push	 esi
  000fb	e8 00 00 00 00	 call	 _fprintf
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
  00103	85 c0		 test	 eax, eax
  00105	78 60		 js	 SHORT $LN9@SaveSysEnc
  00107	ff 35 00 00 00
	00		 push	 DWORD PTR _nWipeMode
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BNNHBPIN@?6?7?7?$DMconfig?5key?$DN?$CCWipeMode?$CC?$DO?$CFd?$DM?1co@
  00112	56		 push	 esi
  00113	e8 00 00 00 00	 call	 _fprintf
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011b	85 c0		 test	 eax, eax
  0011d	78 48		 js	 SHORT $LN9@SaveSysEnc
  0011f	56		 push	 esi
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KMABOOHN@?6?7?$DM?1sysencryption?$DO?$AA@
  00125	e8 00 00 00 00	 call	 _fputs
  0012a	83 c4 08	 add	 esp, 8
  0012d	85 c0		 test	 eax, eax
  0012f	78 36		 js	 SHORT $LN9@SaveSysEnc
  00131	56		 push	 esi
  00132	e8 00 00 00 00	 call	 _XmlWriteFooter
  00137	83 c4 04	 add	 esp, 4
  0013a	85 c0		 test	 eax, eax
  0013c	78 29		 js	 SHORT $LN9@SaveSysEnc

; 512  : 	}
; 513  : 
; 514  : 	GSTFlushFile (f);

  0013e	56		 push	 esi
  0013f	e8 00 00 00 00	 call	 _GSTFlushFile

; 515  : 
; 516  : 	fclose (f);

  00144	56		 push	 esi
  00145	e8 00 00 00 00	 call	 _fclose
  0014a	83 c4 08	 add	 esp, 8

; 517  : 
; 518  : 	bSystemEncryptionStatusChanged = FALSE;

  0014d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 0

; 519  : 	BroadcastSysEncCfgUpdate ();

  00157	e8 00 00 00 00	 call	 ?BroadcastSysEncCfgUpdate@@YAHXZ ; BroadcastSysEncCfgUpdate
  0015c	5e		 pop	 esi

; 520  : 
; 521  : 	return TRUE;

  0015d	b8 01 00 00 00	 mov	 eax, 1
  00162	5f		 pop	 edi

; 522  : }

  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
$LN9@SaveSysEnc:

; 507  : 	{
; 508  : 		handleWin32Error (hwndDlg);

  00167	57		 push	 edi
  00168	e8 00 00 00 00	 call	 _handleWin32Error

; 509  : 		fclose (f);

  0016d	56		 push	 esi
  0016e	e8 00 00 00 00	 call	 _fclose

; 510  : 		Error ("CANNOT_SAVE_SYS_ENCRYPTION_SETTINGS");

  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LPCKNJKP@CANNOT_SAVE_SYS_ENCRYPTION_SETTI@
  00178	e8 00 00 00 00	 call	 _Error
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 511  : 		return FALSE;

  00180	33 c0		 xor	 eax, eax
  00182	5e		 pop	 esi
  00183	5f		 pop	 edi

; 522  : }

  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c3		 ret	 0
?SaveSysEncSettings@@YAHPAUHWND__@@@Z ENDP		; SaveSysEncSettings
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?BroadcastSysEncCfgUpdate@@YAHXZ
_TEXT	SEGMENT
_bSuccess$ = -4						; size = 4
?BroadcastSysEncCfgUpdate@@YAHXZ PROC			; BroadcastSysEncCfgUpdate, COMDAT

; 441  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 442  : 	BOOL bSuccess = FALSE;
; 443  : 	EnumWindows (BroadcastSysEncCfgUpdateCallb, (LPARAM) &bSuccess);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _bSuccess$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bSuccess$[ebp], 0
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ?BroadcastSysEncCfgUpdateCallb@@YGHPAUHWND__@@J@Z ; BroadcastSysEncCfgUpdateCallb
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnumWindows@8

; 444  : 	return bSuccess;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _bSuccess$[ebp]

; 445  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?BroadcastSysEncCfgUpdate@@YAHXZ ENDP			; BroadcastSysEncCfgUpdate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?BroadcastSysEncCfgUpdateCallb@@YGHPAUHWND__@@J@Z
_TEXT	SEGMENT
_name$1 = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_hwnd$ = 8						; size = 4
_lParam$ = 12						; size = 4
?BroadcastSysEncCfgUpdateCallb@@YGHPAUHWND__@@J@Z PROC	; BroadcastSysEncCfgUpdateCallb, COMDAT

; 420  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _hwnd$[ebp]

; 421  : 	if (GetWindowLongPtr (hwnd, GWLP_USERDATA) == (LONG_PTR) 'TRUE')

  00017	6a eb		 push	 -21			; ffffffebH
  00019	56		 push	 esi
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  00020	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  00025	75 59		 jne	 SHORT $LN9@BroadcastS

; 422  : 	{
; 423  : 		char name[1024] = { 0 };
; 424  : 		GetWindowText (hwnd, name, sizeof (name) - 1);

  00027	68 00 04 00 00	 push	 1024			; 00000400H
  0002c	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _name$1[ebp]
  00032	6a 00		 push	 0
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _name$1[ebp]
  00043	68 ff 03 00 00	 push	 1023			; 000003ffH
  00048	50		 push	 eax
  00049	56		 push	 esi
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 425  : 		if (hwnd != MainDlg && strstr (name, "GostCrypt"))

  00050	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _MainDlg
  00056	74 28		 je	 SHORT $LN9@BroadcastS
  00058	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _name$1[ebp]
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _strstr
  00069	83 c4 08	 add	 esp, 8
  0006c	85 c0		 test	 eax, eax
  0006e	74 10		 je	 SHORT $LN9@BroadcastS

; 426  : 		{
; 427  : 			PostMessage (hwnd, GST_APPMSG_SYSENC_CONFIG_UPDATE, 0, 0);

  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	68 65 80 00 00	 push	 32869			; 00008065H
  00079	56		 push	 esi
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
$LN9@BroadcastS:

; 428  : 		}
; 429  : 	}
; 430  : 	return TRUE;
; 431  : }

  00080	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	33 cd		 xor	 ecx, ebp
  0008a	5e		 pop	 esi
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 08 00	 ret	 8
?BroadcastSysEncCfgUpdateCallb@@YGHPAUHWND__@@J@Z ENDP	; BroadcastSysEncCfgUpdateCallb
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?WipePasswordsAndKeyfiles@@YAXXZ
_TEXT	SEGMENT
_tmp$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
?WipePasswordsAndKeyfiles@@YAXXZ PROC			; WipePasswordsAndKeyfiles, COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 305  : 	char tmp[MAX_PASSWORD+1];
; 306  : 
; 307  : 	// Attempt to wipe passwords stored in the input field buffers
; 308  : 	memset (tmp, 'X', MAX_PASSWORD);

  00012	6a 40		 push	 64			; 00000040H
  00014	8d 45 b8	 lea	 eax, DWORD PTR _tmp$[ebp]
  00017	6a 58		 push	 88			; 00000058H
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _memset

; 309  : 	tmp [MAX_PASSWORD] = 0;
; 310  : 	SetWindowText (hPasswordInputField, tmp);

  0001f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetWindowTextA@8
  00025	8d 45 b8	 lea	 eax, DWORD PTR _tmp$[ebp]
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	c6 45 f8 00	 mov	 BYTE PTR _tmp$[ebp+64], 0
  0002f	50		 push	 eax
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  00035	50		 push	 eax
  00036	ff d7		 call	 edi

; 311  : 	SetWindowText (hVerifyPasswordInputField, tmp);

  00038	8d 45 b8	 lea	 eax, DWORD PTR _tmp$[ebp]
  0003b	50		 push	 eax
  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  00041	50		 push	 eax
  00042	ff d7		 call	 edi

; 312  : 
; 313  : 	burn (&szVerify[0], sizeof (szVerify));

  00044	b8 00 00 00 00	 mov	 eax, OFFSET ?szVerify@@3PADA ; szVerify
  00049	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  0004e	8b f1		 mov	 esi, ecx
  00050	8b d0		 mov	 edx, eax
$LL21@WipePasswo:
  00052	c6 02 00	 mov	 BYTE PTR [edx], 0
  00055	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00058	83 ee 01	 sub	 esi, 1
  0005b	75 f5		 jne	 SHORT $LL21@WipePasswo
  0005d	0f 1f 00	 npad	 3
$LL5@WipePasswo:
  00060	c6 00 00	 mov	 BYTE PTR [eax], 0
  00063	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00066	83 e9 01	 sub	 ecx, 1
  00069	75 f5		 jne	 SHORT $LL5@WipePasswo

; 314  : 	burn (&volumePassword, sizeof (volumePassword));

  0006b	b8 00 00 00 00	 mov	 eax, OFFSET ?volumePassword@@3UPassword@@A ; volumePassword
  00070	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00075	8b f1		 mov	 esi, ecx
  00077	8b d0		 mov	 edx, eax
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL25@WipePasswo:
  00080	c6 02 00	 mov	 BYTE PTR [edx], 0
  00083	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00086	83 ee 01	 sub	 esi, 1
  00089	75 f5		 jne	 SHORT $LL25@WipePasswo
  0008b	0f 1f 44 00 00	 npad	 5
$LL10@WipePasswo:
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0
  00093	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00096	83 e9 01	 sub	 ecx, 1
  00099	75 f5		 jne	 SHORT $LL10@WipePasswo

; 315  : 	burn (&szRawPassword[0], sizeof (szRawPassword));

  0009b	b8 00 00 00 00	 mov	 eax, OFFSET ?szRawPassword@@3PADA ; szRawPassword
  000a0	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  000a5	8b f1		 mov	 esi, ecx
  000a7	8b d0		 mov	 edx, eax
  000a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL29@WipePasswo:
  000b0	c6 02 00	 mov	 BYTE PTR [edx], 0
  000b3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000b6	83 ee 01	 sub	 esi, 1
  000b9	75 f5		 jne	 SHORT $LL29@WipePasswo
  000bb	0f 1f 44 00 00	 npad	 5
$LL15@WipePasswo:
  000c0	c6 00 00	 mov	 BYTE PTR [eax], 0
  000c3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000c6	83 e9 01	 sub	 ecx, 1
  000c9	75 f5		 jne	 SHORT $LL15@WipePasswo

; 316  : 
; 317  : 	SetWindowText (hPasswordInputField, "");

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000d5	50		 push	 eax
  000d6	ff d7		 call	 edi

; 318  : 	SetWindowText (hVerifyPasswordInputField, "");

  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000e2	50		 push	 eax
  000e3	ff d7		 call	 edi

; 319  : 
; 320  : 	KeyFileRemoveAll (&FirstKeyFile);

  000e5	68 00 00 00 00	 push	 OFFSET _FirstKeyFile
  000ea	e8 00 00 00 00	 call	 _KeyFileRemoveAll

; 321  : 	KeyFileRemoveAll (&defaultKeyFilesParam.FirstKeyFile);

  000ef	68 04 00 00 00	 push	 OFFSET _defaultKeyFilesParam+4
  000f4	e8 00 00 00 00	 call	 _KeyFileRemoveAll

; 322  : }

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fc	83 c4 08	 add	 esp, 8
  000ff	33 cd		 xor	 ecx, ebp
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
?WipePasswordsAndKeyfiles@@YAXXZ ENDP			; WipePasswordsAndKeyfiles
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2393 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2394 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00007	56		 push	 esi
  00008	6a ff		 push	 -1
  0000a	6a 00		 push	 0
  0000c	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00016	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0001b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	8b ce		 mov	 ecx, esi
  00020	50		 push	 eax
  00021	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00028	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi

; 2395 : 	}

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T2 = -324						; size = 24
$T3 = -300						; size = 24
_modPath$ = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_arguments$ = 8						; size = 24
?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ElevateWholeWizardProcess, COMDAT

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 275  : 	char modPath[MAX_PATH];
; 276  : 
; 277  : 	if (IsAdmin())

  00034	e8 00 00 00 00	 call	 _IsAdmin
  00039	85 c0		 test	 eax, eax
  0003b	74 1f		 je	 SHORT $LN2@ElevateWho

; 278  : 		return TRUE;

  0003d	8b 45 1c	 mov	 eax, DWORD PTR _arguments$[ebp+20]
  00040	83 f8 10	 cmp	 eax, 16			; 00000010H
  00043	72 0d		 jb	 SHORT $LN16@ElevateWho
  00045	40		 inc	 eax
  00046	8d 4d 08	 lea	 ecx, DWORD PTR _arguments$[ebp]
  00049	50		 push	 eax
  0004a	ff 75 08	 push	 DWORD PTR _arguments$[ebp]
  0004d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN16@ElevateWho:
  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	e9 0c 01 00 00	 jmp	 $LN1@ElevateWho
$LN2@ElevateWho:

; 279  : 
; 280  : 	if (!IsUacSupported())

  0005c	e8 00 00 00 00	 call	 _IsUacSupported
  00061	85 c0		 test	 eax, eax
  00063	75 23		 jne	 SHORT $LN3@ElevateWho

; 281  : 		return IsAdmin();

  00065	e8 00 00 00 00	 call	 _IsAdmin
  0006a	8b 4d 1c	 mov	 ecx, DWORD PTR _arguments$[ebp+20]
  0006d	8b f0		 mov	 esi, eax
  0006f	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00072	72 0d		 jb	 SHORT $LN117@ElevateWho
  00074	41		 inc	 ecx
  00075	51		 push	 ecx
  00076	ff 75 08	 push	 DWORD PTR _arguments$[ebp]
  00079	8d 4d 08	 lea	 ecx, DWORD PTR _arguments$[ebp]
  0007c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN117@ElevateWho:
  00081	8b c6		 mov	 eax, esi
  00083	e9 e0 00 00 00	 jmp	 $LN1@ElevateWho
$LN3@ElevateWho:

; 282  : 
; 283  : 	GetModuleFileName (NULL, modPath, sizeof (modPath));

  00088	68 04 01 00 00	 push	 260			; 00000104H
  0008d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _modPath$[ebp]
  00093	50		 push	 eax
  00094	6a 00		 push	 0
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 284  : 
; 285  : 	if ((int)ShellExecute (MainDlg, "runas", modPath, (string("/q UAC ") + arguments).c_str(), NULL, SW_SHOWNORMAL) > 32)

  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_07MDDLOGBN@?1q?5UAC?5?$AA@
  000a1	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000a7	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ac	8d 4d 08	 lea	 ecx, DWORD PTR _arguments$[ebp]
  000af	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000b3	51		 push	 ecx
  000b4	50		 push	 eax
  000b5	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c4	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  000c8	72 02		 jb	 SHORT $LN226@ElevateWho
  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
$LN226@ElevateWho:
  000cc	6a 01		 push	 1
  000ce	6a 00		 push	 0
  000d0	50		 push	 eax
  000d1	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _modPath$[ebp]
  000d7	50		 push	 eax
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_05KPBLJGDL@runas?$AA@
  000dd	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShellExecuteA@24
  000e9	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ec	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp+20]
  000f2	0f 9f c3	 setg	 bl
  000f5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f8	72 13		 jb	 SHORT $LN235@ElevateWho
  000fa	40		 inc	 eax
  000fb	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00101	50		 push	 eax
  00102	ff b5 d4 fe ff
	ff		 push	 DWORD PTR $T3[ebp]
  00108	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN235@ElevateWho:
  0010d	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+20]
  00113	c7 85 e8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
  0011d	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp+16], 0
  00127	c6 85 d4 fe ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
  0012e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00131	72 13		 jb	 SHORT $LN336@ElevateWho
  00133	40		 inc	 eax
  00134	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0013a	50		 push	 eax
  0013b	ff b5 bc fe ff
	ff		 push	 DWORD PTR $T2[ebp]
  00141	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN336@ElevateWho:
  00146	84 db		 test	 bl, bl
  00148	74 07		 je	 SHORT $LN4@ElevateWho

; 286  : 	{				
; 287  : 		exit (0);

  0014a	6a 00		 push	 0
  0014c	e8 00 00 00 00	 call	 _exit
$LN433@ElevateWho:
$LN4@ElevateWho:

; 288  : 	}
; 289  : 	else
; 290  : 	{
; 291  : 		Error ("UAC_INIT_ERROR");

  00151	68 00 00 00 00	 push	 OFFSET ??_C@_0P@NDJDHMAP@UAC_INIT_ERROR?$AA@
  00156	e8 00 00 00 00	 call	 _Error
  0015b	83 c4 04	 add	 esp, 4

; 292  : 		return FALSE;

  0015e	8d 4d 08	 lea	 ecx, DWORD PTR _arguments$[ebp]
  00161	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00166	33 c0		 xor	 eax, eax
$LN1@ElevateWho:

; 293  : 	}
; 294  : }

  00168	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00172	59		 pop	 ecx
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00178	33 cd		 xor	 ecx, ebp
  0017a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
$LN432@ElevateWho:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _arguments$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  00008	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 8a bc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-324]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ElevateWholeWizardProcess
; Function compile flags: /Ogtp
;	COMDAT ??__FDeferredNonSysInPlaceEncDevices@@YAXXZ
text$yd	SEGMENT
??__FDeferredNonSysInPlaceEncDevices@@YAXXZ PROC	; `dynamic atexit destructor for 'DeferredNonSysInPlaceEncDevices'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A ; DeferredNonSysInPlaceEncDevices
  00005	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy
??__FDeferredNonSysInPlaceEncDevices@@YAXXZ ENDP	; `dynamic atexit destructor for 'DeferredNonSysInPlaceEncDevices''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT ??__EDeferredNonSysInPlaceEncDevices@@YAXXZ
text$di	SEGMENT
??__EDeferredNonSysInPlaceEncDevices@@YAXXZ PROC	; `dynamic initializer for 'DeferredNonSysInPlaceEncDevices'', COMDAT

; 262  : vector <HostDevice> DeferredNonSysInPlaceEncDevices;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A ; DeferredNonSysInPlaceEncDevices
  00005	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<HostDevice> >::_Wrap_alloc<std::allocator<HostDevice> >
  0000a	68 00 00 00 00	 push	 OFFSET ??__FDeferredNonSysInPlaceEncDevices@@YAXXZ ; `dynamic atexit destructor for 'DeferredNonSysInPlaceEncDevices''
  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A, 0
  00019	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A+4, 0
  00023	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A+8, 0
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	59		 pop	 ecx
  00033	c3		 ret	 0
??__EDeferredNonSysInPlaceEncDevices@@YAXXZ ENDP	; `dynamic initializer for 'DeferredNonSysInPlaceEncDevices''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _GetFormatSectorSize
_TEXT	SEGMENT
_geometry$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_GetFormatSectorSize PROC				; COMDAT

; 9674 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 9675 : 	if (!bDevice)

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  00017	75 13		 jne	 SHORT $LN2@GetFormatS

; 9676 : 		return GST_SECTOR_SIZE_FILE_HOSTED_VOLUME;

  00019	b8 00 02 00 00	 mov	 eax, 512		; 00000200H

; 9684 : 	}
; 9685 : 
; 9686 : 	return geometry.BytesPerSector;
; 9687 : }

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00021	33 cd		 xor	 ecx, ebp
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN2@GetFormatS:

; 9677 : 
; 9678 : 	DISK_GEOMETRY geometry;
; 9679 : 
; 9680 : 	if (!GetDriveGeometry (szDiskFile, &geometry))

  0002c	8d 45 e4	 lea	 eax, DWORD PTR _geometry$[ebp]
  0002f	50		 push	 eax
  00030	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  00035	e8 00 00 00 00	 call	 _GetDriveGeometry
  0003a	83 c4 08	 add	 esp, 8
  0003d	85 c0		 test	 eax, eax
  0003f	75 13		 jne	 SHORT $LN3@GetFormatS

; 9681 : 	{
; 9682 : 		handleWin32Error (MainDlg);

  00041	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00047	e8 00 00 00 00	 call	 _handleWin32Error
  0004c	83 c4 04	 add	 esp, 4

; 9683 : 		AbortProcessSilent();

  0004f	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN3@GetFormatS:

; 9684 : 	}
; 9685 : 
; 9686 : 	return geometry.BytesPerSector;
; 9687 : }

  00054	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00057	8b 45 f8	 mov	 eax, DWORD PTR _geometry$[ebp+20]
  0005a	33 cd		 xor	 ecx, ebp
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_GetFormatSectorSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _UpdateWipeControls
_TEXT	SEGMENT
_decoySysPartitionWipeStatus$2 = -148			; size = 16
$T3 = -132						; size = 94
$T4 = -36						; size = 16
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_UpdateWipeControls PROC				; COMDAT

; 2607 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_UpdateWipeControls
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2608 : 	if (bHiddenOS && IsHiddenOSRunning())

  00031	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00038	0f 84 80 00 00
	00		 je	 $LN2@UpdateWipe
  0003e	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  00043	85 c0		 test	 eax, eax
  00045	74 77		 je	 SHORT $LN2@UpdateWipe

; 2609 : 	{
; 2610 : 		/* Decoy system partition wipe */
; 2611 : 
; 2612 : 		DecoySystemWipeStatus decoySysPartitionWipeStatus;
; 2613 : 
; 2614 : 		try
; 2615 : 		{
; 2616 : 			decoySysPartitionWipeStatus = BootEncObj->GetDecoyOSWipeStatus();

  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0004d	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  00050	50		 push	 eax
  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00058	e8 00 00 00 00	 call	 ?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ ; GostCrypt::BootEncryption::GetDecoyOSWipeStatus

; 2617 : 			BootEncStatus = BootEncObj->GetStatus();

  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00063	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00066	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0006c	50		 push	 eax
  0006d	0f 11 85 6c ff
	ff ff		 movups	 XMMWORD PTR _decoySysPartitionWipeStatus$2[ebp], xmm0
  00074	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00079	8b f0		 mov	 esi, eax
  0007b	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00080	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus

; 2622 : 		}
; 2623 : 
; 2624 : 		EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), !decoySysPartitionWipeStatus.WipeInProgress);

  00085	33 c0		 xor	 eax, eax
  00087	39 85 6c ff ff
	ff		 cmp	 DWORD PTR _decoySysPartitionWipeStatus$2[ebp], eax
  0008d	f3 a5		 rep movsd
  0008f	0f 94 c0	 sete	 al
  00092	50		 push	 eax
  00093	68 10 04 00 00	 push	 1040			; 00000410H
  00098	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0009e	66 a5		 movsw
  000a0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  000a6	ff d6		 call	 esi
  000a8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  000ae	50		 push	 eax
  000af	ff d7		 call	 edi

; 2625 : 	}
; 2626 : 	else

  000b1	eb 4f		 jmp	 SHORT $LN5@UpdateWipe
__catch$_UpdateWipeControls$0:

; 2618 : 		}
; 2619 : 		catch (...)
; 2620 : 		{
; 2621 : 			return;

  000b3	b8 00 00 00 00	 mov	 eax, $LN10@UpdateWipe
  000b8	c3		 ret	 0
$LN10@UpdateWipe:
  000b9	e9 80 00 00 00	 jmp	 $LN1@UpdateWipe
$LN2@UpdateWipe:

; 2627 : 	{
; 2628 : 		/* Regular device wipe (not decoy system partition wipe) */
; 2629 : 
; 2630 : 		EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), bDeviceWipeInProgress);

  000be	ff 35 00 00 00
	00		 push	 DWORD PTR ?bDeviceWipeInProgress@@3HA ; bDeviceWipeInProgress
  000c4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  000ca	68 10 04 00 00	 push	 1040			; 00000410H
  000cf	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000d5	ff d6		 call	 esi
  000d7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  000dd	50		 push	 eax
  000de	ff d7		 call	 edi

; 2631 : 
; 2632 : 		if (!bDeviceWipeInProgress)

  000e0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDeviceWipeInProgress@@3HA, 0 ; bDeviceWipeInProgress
  000e7	75 19		 jne	 SHORT $LN5@UpdateWipe

; 2633 : 		{
; 2634 : 			SetWindowText (GetDlgItem (hCurPage, IDC_TIMEREMAIN), " ");

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  000ee	68 03 04 00 00	 push	 1027			; 00000403H
  000f3	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  000f9	ff d6		 call	 esi
  000fb	50		 push	 eax
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN5@UpdateWipe:

; 2635 : 		}
; 2636 : 	}
; 2637 : 
; 2638 : 	EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), bDeviceWipeInProgress);

  00102	ff 35 00 00 00
	00		 push	 DWORD PTR ?bDeviceWipeInProgress@@3HA ; bDeviceWipeInProgress
  00108	68 f8 03 00 00	 push	 1016			; 000003f8H
  0010d	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00113	ff d6		 call	 esi
  00115	50		 push	 eax
  00116	ff d7		 call	 edi

; 2639 : 	EnableWindow (GetDlgItem (MainDlg, IDC_PREV), !bDeviceWipeInProgress);

  00118	33 c0		 xor	 eax, eax
  0011a	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bDeviceWipeInProgress@@3HA, eax ; bDeviceWipeInProgress
  00120	0f 94 c0	 sete	 al
  00123	50		 push	 eax
  00124	68 11 04 00 00	 push	 1041			; 00000411H
  00129	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0012f	ff d6		 call	 esi
  00131	50		 push	 eax
  00132	ff d7		 call	 edi

; 2640 : 
; 2641 : 	bConfirmQuit = bDeviceWipeInProgress;

  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bDeviceWipeInProgress@@3HA ; bDeviceWipeInProgress
  00139	a3 00 00 00 00	 mov	 DWORD PTR ?bConfirmQuit@@3HC, eax ; bConfirmQuit
$LN1@UpdateWipe:

; 2642 : }

  0013e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00141	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00148	59		 pop	 ecx
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx
  0014c	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014f	33 cd		 xor	 ecx, ebp
  00151	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_UpdateWipeControls:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_UpdateWipeControls
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_UpdateWipeControls ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _InitWipeProgressBar
_TEXT	SEGMENT
$T2 = -132						; size = 94
$T3 = -36						; size = 16
_decoySysPartitionWipeStatus$4 = -36			; size = 16
tv86 = -28						; size = 8
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_InitWipeProgressBar PROC				; COMDAT

; 2563 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_InitWipeProgressBar
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2564 : 	if (bHiddenOS && IsHiddenOSRunning())

  0002e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00035	0f 84 c8 00 00
	00		 je	 $LN13@InitWipePr
  0003b	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  00040	85 c0		 test	 eax, eax
  00042	0f 84 bb 00 00
	00		 je	 $LN13@InitWipePr

; 2565 : 	{
; 2566 : 		/* Decoy system partition wipe */
; 2567 : 
; 2568 : 		DecoySystemWipeStatus decoySysPartitionWipeStatus;
; 2569 : 
; 2570 : 		try
; 2571 : 		{
; 2572 : 			decoySysPartitionWipeStatus = BootEncObj->GetDecoyOSWipeStatus();

  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0004e	8d 45 dc	 lea	 eax, DWORD PTR $T3[ebp]
  00051	50		 push	 eax
  00052	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00059	e8 00 00 00 00	 call	 ?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ ; GostCrypt::BootEncryption::GetDecoyOSWipeStatus

; 2573 : 			BootEncStatus = BootEncObj->GetStatus();

  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00064	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00067	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0006d	50		 push	 eax
  0006e	0f 11 45 dc	 movups	 XMMWORD PTR _decoySysPartitionWipeStatus$4[ebp], xmm0
  00072	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00077	8b f0		 mov	 esi, eax
  00079	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  0007e	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  00083	f3 a5		 rep movsd
  00085	66 a5		 movsw

; 2578 : 		}
; 2579 : 
; 2580 : 		if (BootEncStatus.ConfiguredEncryptedAreaEnd == -1 
; 2581 : 			|| BootEncStatus.ConfiguredEncryptedAreaStart == -1)

  00087	8b 1d 22 00 00
	00		 mov	 ebx, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+34
  0008d	8b c3		 mov	 eax, ebx
  0008f	23 05 26 00 00
	00		 and	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+38
  00095	83 f8 ff	 cmp	 eax, -1
  00098	74 69		 je	 SHORT $LN13@InitWipePr
  0009a	8b 35 1a 00 00
	00		 mov	 esi, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+26
  000a0	8b c6		 mov	 eax, esi
  000a2	8b 3d 1e 00 00
	00		 mov	 edi, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+30
  000a8	23 c7		 and	 eax, edi
  000aa	83 f8 ff	 cmp	 eax, -1
  000ad	74 54		 je	 SHORT $LN13@InitWipePr

; 2582 : 			return;
; 2583 : 
; 2584 : 		InitProgressBar (BootEncStatus.ConfiguredEncryptedAreaEnd - BootEncStatus.ConfiguredEncryptedAreaStart + 1,

  000af	8b 55 e4	 mov	 edx, DWORD PTR _decoySysPartitionWipeStatus$4[ebp+8]
  000b2	8b 4d e8	 mov	 ecx, DWORD PTR _decoySysPartitionWipeStatus$4[ebp+12]
  000b5	3b d6		 cmp	 edx, esi
  000b7	75 04		 jne	 SHORT $LN14@InitWipePr
  000b9	3b cf		 cmp	 ecx, edi
  000bb	74 15		 je	 SHORT $LN8@InitWipePr
$LN14@InitWipePr:
  000bd	8b c2		 mov	 eax, edx
  000bf	23 c1		 and	 eax, ecx
  000c1	83 f8 ff	 cmp	 eax, -1
  000c4	74 0c		 je	 SHORT $LN8@InitWipePr
  000c6	2b d6		 sub	 edx, esi
  000c8	1b cf		 sbb	 ecx, edi
  000ca	83 c2 01	 add	 edx, 1
  000cd	83 d1 00	 adc	 ecx, 0
  000d0	eb 0e		 jmp	 SHORT $LN9@InitWipePr
$LN8@InitWipePr:
  000d2	0f 57 c0	 xorps	 xmm0, xmm0
  000d5	66 0f 13 45 e4	 movlpd	 QWORD PTR tv86[ebp], xmm0
  000da	8b 4d e8	 mov	 ecx, DWORD PTR tv86[ebp+4]
  000dd	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
$LN9@InitWipePr:
  000e0	a1 26 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+38
  000e5	2b de		 sub	 ebx, esi
  000e7	6a 01		 push	 1
  000e9	6a 00		 push	 0
  000eb	6a 01		 push	 1
  000ed	6a 00		 push	 0
  000ef	1b c7		 sbb	 eax, edi
  000f1	83 c3 01	 add	 ebx, 1
  000f4	51		 push	 ecx
  000f5	52		 push	 edx
  000f6	83 d0 00	 adc	 eax, 0
  000f9	50		 push	 eax
  000fa	53		 push	 ebx
  000fb	e8 00 00 00 00	 call	 _InitProgressBar
  00100	83 c4 20	 add	 esp, 32			; 00000020H
$LN13@InitWipePr:

; 2585 : 			(decoySysPartitionWipeStatus.WipedAreaEnd == BootEncStatus.ConfiguredEncryptedAreaStart || decoySysPartitionWipeStatus.WipedAreaEnd == -1) ?
; 2586 : 			0 :	decoySysPartitionWipeStatus.WipedAreaEnd - BootEncStatus.ConfiguredEncryptedAreaStart + 1,
; 2587 : 			FALSE,
; 2588 : 			TRUE,
; 2589 : 			FALSE,
; 2590 : 			TRUE);
; 2591 : 	}
; 2592 : 	else
; 2593 : 	{
; 2594 : 		/* Regular device wipe (not decoy system partition wipe) */
; 2595 : 	}
; 2596 : }

  00103	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00106	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010d	59		 pop	 ecx
  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5b		 pop	 ebx
  00111	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00114	33 cd		 xor	 ecx, ebp
  00116	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
__catch$_InitWipeProgressBar$0:

; 2574 : 		}
; 2575 : 		catch (...)
; 2576 : 		{
; 2577 : 			return;

  0011f	b8 00 00 00 00	 mov	 eax, $LN13@InitWipePr
  00124	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_InitWipeProgressBar:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_InitWipeProgressBar
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_InitWipeProgressBar ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _UpdateWipeProgressBar
_TEXT	SEGMENT
$T2 = -132						; size = 94
$T3 = -36						; size = 16
_decoySysPartitionWipeStatus$4 = -36			; size = 16
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_UpdateWipeProgressBar PROC				; COMDAT

; 2526 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_UpdateWipeProgressBar
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2527 : 	if (bHiddenOS && IsHiddenOSRunning())

  0002e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00035	74 63		 je	 SHORT $LN11@UpdateWipe
  00037	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  0003c	85 c0		 test	 eax, eax
  0003e	74 5a		 je	 SHORT $LN11@UpdateWipe

; 2528 : 	{
; 2529 : 		/* Decoy system partition wipe */
; 2530 : 
; 2531 : 		DecoySystemWipeStatus decoySysPartitionWipeStatus;
; 2532 : 
; 2533 : 		try
; 2534 : 		{
; 2535 : 			decoySysPartitionWipeStatus = BootEncObj->GetDecoyOSWipeStatus();

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00046	8d 45 dc	 lea	 eax, DWORD PTR $T3[ebp]
  00049	50		 push	 eax
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00051	e8 00 00 00 00	 call	 ?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ ; GostCrypt::BootEncryption::GetDecoyOSWipeStatus

; 2536 : 			BootEncStatus = BootEncObj->GetStatus();

  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0005c	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0005f	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00065	50		 push	 eax
  00066	0f 11 45 dc	 movups	 XMMWORD PTR _decoySysPartitionWipeStatus$4[ebp], xmm0
  0006a	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus

; 2541 : 		}
; 2542 : 
; 2543 : 		if (decoySysPartitionWipeStatus.WipedAreaEnd == -1)

  0006f	8b 55 e8	 mov	 edx, DWORD PTR _decoySysPartitionWipeStatus$4[ebp+12]
  00072	8b f0		 mov	 esi, eax
  00074	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00079	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  0007e	f3 a5		 rep movsd
  00080	8b 4d e4	 mov	 ecx, DWORD PTR _decoySysPartitionWipeStatus$4[ebp+8]
  00083	8b c1		 mov	 eax, ecx
  00085	23 c2		 and	 eax, edx
  00087	66 a5		 movsw
  00089	83 f8 ff	 cmp	 eax, -1
  0008c	75 28		 jne	 SHORT $LN5@UpdateWipe

; 2544 : 			UpdateProgressBarProc (0);

  0008e	6a 00		 push	 0
  00090	6a 00		 push	 0
$LN13@UpdateWipe:
  00092	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00097	83 c4 08	 add	 esp, 8
$LN11@UpdateWipe:

; 2549 : 	{
; 2550 : 		/* Regular device wipe (not decoy system partition wipe) */
; 2551 : 	}
; 2552 : }

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a4	59		 pop	 ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ab	33 cd		 xor	 ecx, ebp
  000ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
$LN5@UpdateWipe:

; 2545 : 		else
; 2546 : 			UpdateProgressBarProc (decoySysPartitionWipeStatus.WipedAreaEnd - BootEncStatus.ConfiguredEncryptedAreaStart + 1);

  000b6	2b 0d 1a 00 00
	00		 sub	 ecx, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+26
  000bc	1b 15 1e 00 00
	00		 sbb	 edx, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+30
  000c2	83 c1 01	 add	 ecx, 1
  000c5	83 d2 00	 adc	 edx, 0
  000c8	52		 push	 edx
  000c9	51		 push	 ecx

; 2547 : 	}
; 2548 : 	else

  000ca	eb c6		 jmp	 SHORT $LN13@UpdateWipe
__catch$_UpdateWipeProgressBar$0:

; 2537 : 		}
; 2538 : 		catch (...)
; 2539 : 		{
; 2540 : 			return;

  000cc	b8 00 00 00 00	 mov	 eax, $LN11@UpdateWipe
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_UpdateWipeProgressBar:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_UpdateWipeProgressBar
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_UpdateWipeProgressBar ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _WipeAbort
_TEXT	SEGMENT
_e$2 = -76						; size = 4
_e$3 = -72						; size = 4
$T4 = -68						; size = 16
$T5 = -52						; size = 16
$T6 = -36						; size = 16
_decoySysPartitionWipeStatus$7 = -36			; size = 16
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_WipeAbort PROC						; COMDAT

; 2395 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_WipeAbort
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2396 : 	EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), FALSE);

  0002e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  00034	6a 00		 push	 0
  00036	68 f8 03 00 00	 push	 1016			; 000003f8H
  0003b	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00041	ff d3		 call	 ebx
  00043	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00049	50		 push	 eax
  0004a	ff d6		 call	 esi

; 2397 : 
; 2398 : 	if (bHiddenOS && IsHiddenOSRunning())

  0004c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00053	0f 84 29 01 00
	00		 je	 $LN4@WipeAbort
  00059	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  0005e	85 c0		 test	 eax, eax
  00060	0f 84 1c 01 00
	00		 je	 $LN4@WipeAbort

; 2399 : 	{
; 2400 : 		/* Decoy system partition wipe */	
; 2401 : 		
; 2402 : 		DecoySystemWipeStatus decoySysPartitionWipeStatus;
; 2403 : 
; 2404 : 		try
; 2405 : 		{
; 2406 : 			decoySysPartitionWipeStatus = BootEncObj->GetDecoyOSWipeStatus();

  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0006c	8d 45 dc	 lea	 eax, DWORD PTR $T6[ebp]
  0006f	50		 push	 eax
  00070	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00077	e8 00 00 00 00	 call	 ?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ ; GostCrypt::BootEncryption::GetDecoyOSWipeStatus
  0007c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00083	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00086	66 0f 7e c0	 movd	 eax, xmm0
  0008a	0f 11 45 dc	 movups	 XMMWORD PTR _decoySysPartitionWipeStatus$7[ebp], xmm0
  0008e	85 c0		 test	 eax, eax
  00090	0f 84 f1 00 00
	00		 je	 $LN27@WipeAbort

; 2413 : 		}
; 2414 : 
; 2415 : 		if (!decoySysPartitionWipeStatus.WipeInProgress)
; 2416 : 		{
; 2417 : 			EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), TRUE);
; 2418 : 			return;
; 2419 : 		}
; 2420 : 
; 2421 : 		WaitCursor ();
; 2422 : 
; 2423 : 		try
; 2424 : 		{
; 2425 : 			int attempts = SYSENC_PAUSE_RETRIES;
; 2426 : 
; 2427 : 			BootEncObj->AbortDecoyOSWipe ();

  00096	e8 00 00 00 00	 call	 _WaitCursor
  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  000a1	bf c8 00 00 00	 mov	 edi, 200		; 000000c8H
  000a6	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  000ad	e8 00 00 00 00	 call	 ?AbortDecoyOSWipe@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::AbortDecoyOSWipe

; 2428 : 
; 2429 : 			decoySysPartitionWipeStatus = BootEncObj->GetDecoyOSWipeStatus();

  000b2	8d 45 cc	 lea	 eax, DWORD PTR $T5[ebp]
$LN28@WipeAbort:
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ ; GostCrypt::BootEncryption::GetDecoyOSWipeStatus
  000c1	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000c4	0f 11 45 dc	 movups	 XMMWORD PTR _decoySysPartitionWipeStatus$7[ebp], xmm0

; 2430 : 
; 2431 : 			while (decoySysPartitionWipeStatus.WipeInProgress && attempts > 0)

  000c8	8b 75 dc	 mov	 esi, DWORD PTR _decoySysPartitionWipeStatus$7[ebp]
  000cb	85 f6		 test	 esi, esi
  000cd	74 12		 je	 SHORT $LN23@WipeAbort
  000cf	85 ff		 test	 edi, edi
  000d1	7e 37		 jle	 SHORT $LN19@WipeAbort

; 2432 : 			{
; 2433 : 				Sleep (SYSENC_PAUSE_RETRY_INTERVAL);

  000d3	6a 64		 push	 100			; 00000064H
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 2434 : 				attempts--;

  000db	4f		 dec	 edi

; 2435 : 				decoySysPartitionWipeStatus = BootEncObj->GetDecoyOSWipeStatus();

  000dc	8d 45 bc	 lea	 eax, DWORD PTR $T4[ebp]

; 2436 : 			}

  000df	eb d4		 jmp	 SHORT $LN28@WipeAbort
$LN23@WipeAbort:

; 2437 : 
; 2438 : 			if (!decoySysPartitionWipeStatus.WipeInProgress)
; 2439 : 				BootEncObj->CheckDecoyOSWipeResult ();

  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  000e7	e8 00 00 00 00	 call	 ?CheckDecoyOSWipeResult@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckDecoyOSWipeResult
  000ec	eb 1c		 jmp	 SHORT $LN19@WipeAbort
__catch$_WipeAbort$2:

; 2440 : 
; 2441 : 		}
; 2442 : 		catch (Exception &e)
; 2443 : 		{
; 2444 : 			e.Show (MainDlg);

  000ee	8b 4d b8	 mov	 ecx, DWORD PTR _e$3[ebp]
  000f1	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000f7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f9	ff 10		 call	 DWORD PTR [eax]

; 2445 : 		}

  000fb	b8 00 00 00 00	 mov	 eax, $LN24@WipeAbort
  00100	c3		 ret	 0
$LN24@WipeAbort:
  00101	8b 75 dc	 mov	 esi, DWORD PTR _decoySysPartitionWipeStatus$7[ebp]
  00104	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
$LN19@WipeAbort:

; 2446 : 
; 2447 : 		NormalCursor ();

  0010a	e8 00 00 00 00	 call	 _NormalCursor

; 2448 : 
; 2449 : 		if (decoySysPartitionWipeStatus.WipeInProgress)

  0010f	85 f6		 test	 esi, esi
  00111	74 69		 je	 SHORT $LN25@WipeAbort

; 2450 : 		{
; 2451 : 			SetTimer (MainDlg, TIMER_ID_WIPE_PROGRESS, TIMER_INTERVAL_WIPE_PROGRESS, NULL);

  00113	6a 00		 push	 0
  00115	6a 1e		 push	 30			; 0000001eH
  00117	68 02 01 00 00	 push	 258			; 00000102H
  0011c	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 2452 : 			EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), TRUE);

  00128	6a 01		 push	 1
  0012a	68 f8 03 00 00	 push	 1016			; 000003f8H
  0012f	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00135	ff d3		 call	 ebx
  00137	50		 push	 eax
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 2453 : 			Error ("FAILED_TO_INTERRUPT_WIPING");

  0013e	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PHPLOOOK@FAILED_TO_INTERRUPT_WIPING?$AA@
  00143	e8 00 00 00 00	 call	 _Error
  00148	83 c4 04	 add	 esp, 4

; 2454 : 			return;

  0014b	eb 4c		 jmp	 SHORT $LN1@WipeAbort
__catch$_WipeAbort$0:

; 2407 : 		}
; 2408 : 		catch (Exception &e)
; 2409 : 		{
; 2410 : 			e.Show (MainDlg);

  0014d	8b 4d b4	 mov	 ecx, DWORD PTR _e$2[ebp]
  00150	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00156	8b 01		 mov	 eax, DWORD PTR [ecx]
  00158	ff 10		 call	 DWORD PTR [eax]

; 2411 : 			EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), TRUE);

  0015a	6a 01		 push	 1
  0015c	68 f8 03 00 00	 push	 1016			; 000003f8H
  00161	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0016d	50		 push	 eax
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 2412 : 			return;

  00174	b8 00 00 00 00	 mov	 eax, $LN17@WipeAbort
  00179	c3		 ret	 0
$LN17@WipeAbort:
  0017a	eb 1d		 jmp	 SHORT $LN1@WipeAbort
$LN25@WipeAbort:
  0017c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
$LN4@WipeAbort:

; 2455 : 		}
; 2456 : 	}
; 2457 : 	else
; 2458 : 	{
; 2459 : 		/* Regular device wipe (not decoy system partition wipe) */
; 2460 : 	}
; 2461 : 
; 2462 : 	UpdateWipeControls ();

  00182	e8 00 00 00 00	 call	 _UpdateWipeControls
$LN27@WipeAbort:

; 2463 : 	EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), TRUE);

  00187	6a 01		 push	 1
  00189	68 f8 03 00 00	 push	 1016			; 000003f8H
  0018e	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00194	ff d3		 call	 ebx
  00196	50		 push	 eax
  00197	ff d6		 call	 esi
$LN1@WipeAbort:

; 2464 : }

  00199	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0019c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a3	59		 pop	 ecx
  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	5b		 pop	 ebx
  001a7	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001aa	33 cd		 xor	 ecx, ebp
  001ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_WipeAbort:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_WipeAbort
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_WipeAbort ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _WipeStart
_TEXT	SEGMENT
_e$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_WipeStart PROC						; COMDAT

; 2475 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_WipeStart
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2476 : 	if (bHiddenOS && IsHiddenOSRunning())

  0002b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00032	0f 84 bc 00 00
	00		 je	 $LN12@WipeStart
  00038	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  0003d	85 c0		 test	 eax, eax
  0003f	0f 84 af 00 00
	00		 je	 $LN12@WipeStart

; 2477 : 	{
; 2478 : 		/* Decoy system partition wipe */
; 2479 : 
; 2480 : 		EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), FALSE);

  00045	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  0004b	6a 00		 push	 0
  0004d	68 f8 03 00 00	 push	 1016			; 000003f8H
  00052	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00058	ff d6		 call	 esi
  0005a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  00060	50		 push	 eax
  00061	ff d7		 call	 edi

; 2481 : 
; 2482 : 		bDeviceWipeInProgress = FALSE;

  00063	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bDeviceWipeInProgress@@3HA, 0 ; bDeviceWipeInProgress

; 2483 : 		WaitCursor ();

  0006d	e8 00 00 00 00	 call	 _WaitCursor

; 2484 : 
; 2485 : 		try
; 2486 : 		{
; 2487 : 			BootEncObj->StartDecoyOSWipe (nWipeMode);	

  00072	ff 35 00 00 00
	00		 push	 DWORD PTR _nWipeMode
  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0007e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00085	e8 00 00 00 00	 call	 ?StartDecoyOSWipe@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@@Z ; GostCrypt::BootEncryption::StartDecoyOSWipe

; 2488 : 
; 2489 : 			bDeviceWipeInProgress = TRUE;

  0008a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDeviceWipeInProgress@@3HA, 1 ; bDeviceWipeInProgress
  00094	eb 1f		 jmp	 SHORT $LN10@WipeStart
__catch$_WipeStart$0:

; 2490 : 		}
; 2491 : 		catch (Exception &e)
; 2492 : 		{
; 2493 : 			e.Show (MainDlg);

  00096	8b 4d ec	 mov	 ecx, DWORD PTR _e$2[ebp]
  00099	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0009f	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a1	ff 10		 call	 DWORD PTR [eax]

; 2494 : 		}

  000a3	b8 00 00 00 00	 mov	 eax, $LN11@WipeStart
  000a8	c3		 ret	 0
$LN11@WipeStart:
  000a9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  000af	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
$LN10@WipeStart:

; 2495 : 
; 2496 : 		NormalCursor ();

  000b5	e8 00 00 00 00	 call	 _NormalCursor

; 2497 : 
; 2498 : 		if (!bDeviceWipeInProgress)

  000ba	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDeviceWipeInProgress@@3HA, 0 ; bDeviceWipeInProgress
  000c1	75 3d		 jne	 SHORT $LN5@WipeStart

; 2499 : 		{
; 2500 : 			EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), TRUE);

  000c3	6a 01		 push	 1
  000c5	68 f8 03 00 00	 push	 1016			; 000003f8H
  000ca	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  000d0	ff d6		 call	 esi
  000d2	50		 push	 eax
  000d3	ff d7		 call	 edi

; 2501 : 			Error ("FAILED_TO_START_WIPING");

  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PKDMJBLN@FAILED_TO_START_WIPING?$AA@
  000da	e8 00 00 00 00	 call	 _Error
  000df	83 c4 04	 add	 esp, 4

; 2515 : }

  000e2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ec	59		 pop	 ecx
  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
$LN12@WipeStart:

; 2502 : 			return;

  000f4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  000fa	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
$LN5@WipeStart:

; 2503 : 		}
; 2504 : 	}
; 2505 : 	else
; 2506 : 	{
; 2507 : 		/* Regular device wipe (not decoy system partition wipe) */
; 2508 : 	}
; 2509 : 
; 2510 : 	InitWipeProgressBar ();

  00100	e8 00 00 00 00	 call	 _InitWipeProgressBar

; 2511 : 	UpdateWipeProgressBar ();

  00105	e8 00 00 00 00	 call	 _UpdateWipeProgressBar

; 2512 : 	UpdateWipeControls ();

  0010a	e8 00 00 00 00	 call	 _UpdateWipeControls

; 2513 : 	EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), TRUE);

  0010f	6a 01		 push	 1
  00111	68 f8 03 00 00	 push	 1016			; 000003f8H
  00116	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0011c	ff d6		 call	 esi
  0011e	50		 push	 eax
  0011f	ff d7		 call	 edi

; 2514 : 	SetTimer (MainDlg, TIMER_ID_WIPE_PROGRESS, TIMER_INTERVAL_WIPE_PROGRESS, NULL);

  00121	6a 00		 push	 0
  00123	6a 1e		 push	 30			; 0000001eH
  00125	68 02 01 00 00	 push	 258			; 00000102H
  0012a	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 2515 : }

  00136	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00139	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00140	59		 pop	 ecx
  00141	5f		 pop	 edi
  00142	5e		 pop	 esi
  00143	5b		 pop	 ebx
  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_WipeStart:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_WipeStart
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_WipeStart ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _ScanVolClusterBitmap
_TEXT	SEGMENT
_lpInBuffer$ = -36					; size = 8
_lBytesReturned$ = -28					; size = 4
_hDevice$1$ = -24					; size = 4
tv370 = -20						; size = 4
tv356 = -20						; size = 4
_bufLen$2$ = -20					; size = 4
_rmnd$1$ = -13						; size = 1
_tmpPath$ = -12						; size = 7
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_driveNo$ = 12						; size = 4
_nbrClusters$ = 16					; size = 8
_nbrFreeClusters$ = 24					; size = 4
_ScanVolClusterBitmap PROC				; COMDAT

; 8881 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _driveNo$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 18	 mov	 ebx, DWORD PTR _nbrFreeClusters$[ebp]
  00017	56		 push	 esi

; 8882 : 	PVOLUME_BITMAP_BUFFER lpOutBuffer;
; 8883 : 	STARTING_LCN_INPUT_BUFFER lpInBuffer;
; 8884 : 
; 8885 : 	HANDLE hDevice;
; 8886 : 	DWORD lBytesReturned;
; 8887 : 	BYTE rmnd;
; 8888 : 	char tmpPath[7] = {'\\','\\','.','\\', (char) *driveNo + 'A', ':', 0};

  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  0001e	04 41		 add	 al, 65			; 00000041H

; 8889 : 
; 8890 : 	DWORD bufLen;
; 8891 : 	__int64 bitmapCnt;
; 8892 : 
; 8893 : 	hDevice = CreateFile (tmpPath, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	6a 03		 push	 3
  00026	6a 00		 push	 0
  00028	6a 03		 push	 3
  0002a	88 45 f8	 mov	 BYTE PTR _tmpPath$[ebp+4], al
  0002d	8d 45 f4	 lea	 eax, DWORD PTR _tmpPath$[ebp]
  00030	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00035	50		 push	 eax
  00036	c7 45 f4 5c 5c
	2e 5c		 mov	 DWORD PTR _tmpPath$[ebp], 1546542172 ; 5c2e5c5cH
  0003d	66 c7 45 f9 3a
	00		 mov	 WORD PTR _tmpPath$[ebp+5], 58 ; 0000003aH
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00049	89 45 e8	 mov	 DWORD PTR _hDevice$1$[ebp], eax

; 8894 : 
; 8895 : 	if (hDevice == INVALID_HANDLE_VALUE)

  0004c	83 f8 ff	 cmp	 eax, -1
  0004f	75 31		 jne	 SHORT $LN4@ScanVolClu

; 8896 : 	{
; 8897 : 		MessageBoxW (hwndDlg, GetString ("CANT_ACCESS_OUTER_VOL"), lpszTitle, ICON_HAND);

  00051	6a 10		 push	 16			; 00000010H
  00053	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EDMDLNEK@CANT_ACCESS_OUTER_VOL?$AA@
$LN21@ScanVolClu:
  0005e	e8 00 00 00 00	 call	 _GetString
  00063	83 c4 04	 add	 esp, 4
  00066	50		 push	 eax
  00067	57		 push	 edi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi

; 8961 : 
; 8962 : vcmf_error:
; 8963 : 	return -1;

  00070	83 c8 ff	 or	 eax, -1
  00073	5b		 pop	 ebx

; 8964 : }

  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	33 cd		 xor	 ecx, ebp
  00079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
$LN4@ScanVolClu:

; 8898 : 		goto vcmf_error;
; 8899 : 	}
; 8900 : 
; 8901 :  	bufLen = (DWORD) (nbrClusters / 8 + 2 * sizeof(LARGE_INTEGER));

  00082	6a 00		 push	 0
  00084	6a 08		 push	 8
  00086	ff 75 14	 push	 DWORD PTR _nbrClusters$[ebp+4]
  00089	ff 75 10	 push	 DWORD PTR _nbrClusters$[ebp]
  0008c	e8 00 00 00 00	 call	 __alldiv
  00091	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]

; 8902 : 	bufLen += 100000 + bufLen/10;	// Add reserve

  00094	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00099	f7 e1		 mul	 ecx
  0009b	c1 ea 03	 shr	 edx, 3
  0009e	8d 82 a0 86 01
	00		 lea	 eax, DWORD PTR [edx+100000]
  000a4	03 c1		 add	 eax, ecx

; 8903 : 
; 8904 : 	lpOutBuffer = (PVOLUME_BITMAP_BUFFER) malloc (bufLen);

  000a6	50		 push	 eax
  000a7	89 45 ec	 mov	 DWORD PTR _bufLen$2$[ebp], eax
  000aa	e8 00 00 00 00	 call	 _malloc
  000af	8b f0		 mov	 esi, eax
  000b1	83 c4 04	 add	 esp, 4

; 8905 : 
; 8906 : 	if (lpOutBuffer == NULL)

  000b4	85 f6		 test	 esi, esi
  000b6	75 0f		 jne	 SHORT $LN6@ScanVolClu

; 8907 : 	{
; 8908 : 		MessageBoxW (hwndDlg, GetString ("ERR_MEM_ALLOC"), lpszTitle, ICON_HAND);

  000b8	6a 10		 push	 16			; 00000010H
  000ba	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@

; 8909 : 		goto vcmf_error;

  000c5	eb 97		 jmp	 SHORT $LN21@ScanVolClu
$LN6@ScanVolClu:

; 8910 : 	}
; 8911 : 
; 8912 : 	lpInBuffer.StartingLcn.QuadPart = 0;
; 8913 : 
; 8914 : 	if ( !DeviceIoControl (hDevice,

  000c7	6a 00		 push	 0
  000c9	8d 45 e4	 lea	 eax, DWORD PTR _lBytesReturned$[ebp]
  000cc	0f 57 c0	 xorps	 xmm0, xmm0
  000cf	50		 push	 eax
  000d0	ff 75 ec	 push	 DWORD PTR _bufLen$2$[ebp]
  000d3	8d 45 dc	 lea	 eax, DWORD PTR _lpInBuffer$[ebp]
  000d6	66 0f 13 45 dc	 movlpd	 QWORD PTR _lpInBuffer$[ebp], xmm0
  000db	56		 push	 esi
  000dc	6a 08		 push	 8
  000de	50		 push	 eax
  000df	68 6f 00 09 00	 push	 589935			; 0009006fH
  000e4	ff 75 e8	 push	 DWORD PTR _hDevice$1$[ebp]
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  000ed	85 c0		 test	 eax, eax
  000ef	75 4c		 jne	 SHORT $LN8@ScanVolClu

; 8915 : 		FSCTL_GET_VOLUME_BITMAP,
; 8916 : 		&lpInBuffer,
; 8917 : 		sizeof(lpInBuffer),
; 8918 : 		lpOutBuffer,
; 8919 : 		bufLen,  
; 8920 : 		&lBytesReturned,
; 8921 : 		NULL))
; 8922 : 	{
; 8923 : 		handleWin32Error (hwndDlg);

  000f1	57		 push	 edi
  000f2	e8 00 00 00 00	 call	 _handleWin32Error
  000f7	83 c4 04	 add	 esp, 4

; 8924 : 		MessageBoxW (hwndDlg, GetString ("CANT_GET_CLUSTER_BITMAP"), lpszTitle, ICON_HAND);

  000fa	6a 10		 push	 16			; 00000010H
  000fc	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@IEBIBFIL@CANT_GET_CLUSTER_BITMAP?$AA@
  00107	e8 00 00 00 00	 call	 _GetString
  0010c	83 c4 04	 add	 esp, 4
  0010f	50		 push	 eax
  00110	57		 push	 edi
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$vcm_error$23:

; 8956 : 	return 1;
; 8957 : 
; 8958 : vcm_error:
; 8959 : 	CloseHandle (hDevice);

  00117	ff 75 e8	 push	 DWORD PTR _hDevice$1$[ebp]
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 8960 : 	free(lpOutBuffer);

  00120	56		 push	 esi
  00121	e8 00 00 00 00	 call	 _free
  00126	83 c4 04	 add	 esp, 4
$vcmf_error$24:

; 8961 : 
; 8962 : vcmf_error:
; 8963 : 	return -1;

  00129	5f		 pop	 edi
  0012a	5e		 pop	 esi
  0012b	83 c8 ff	 or	 eax, -1
  0012e	5b		 pop	 ebx

; 8964 : }

  0012f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00132	33 cd		 xor	 ecx, ebp
  00134	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
$LN8@ScanVolClu:

; 8925 : 
; 8926 : 		goto vcm_error;
; 8927 : 	}
; 8928 : 
; 8929 : 	rmnd = (BYTE) (lpOutBuffer->BitmapSize.QuadPart % 8);

  0013d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00140	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00143	6a 00		 push	 0
  00145	6a 08		 push	 8
  00147	50		 push	 eax
  00148	57		 push	 edi
  00149	89 45 ec	 mov	 DWORD PTR tv370[ebp], eax
  0014c	e8 00 00 00 00	 call	 __allrem
  00151	88 45 f3	 mov	 BYTE PTR _rmnd$1$[ebp], al

; 8930 : 
; 8931 : 	if ((rmnd != 0) 
; 8932 : 	&& ((lpOutBuffer->Buffer[lpOutBuffer->BitmapSize.QuadPart / 8] & ((1 << rmnd)-1) ) != 0))

  00154	84 c0		 test	 al, al
  00156	74 2d		 je	 SHORT $LN10@ScanVolClu
  00158	6a 00		 push	 0
  0015a	6a 08		 push	 8
  0015c	ff 75 ec	 push	 DWORD PTR tv370[ebp]
  0015f	57		 push	 edi
  00160	e8 00 00 00 00	 call	 __alldiv
  00165	8a 4d f3	 mov	 cl, BYTE PTR _rmnd$1$[ebp]
  00168	ba 01 00 00 00	 mov	 edx, 1
  0016d	d3 e2		 shl	 edx, cl
  0016f	4a		 dec	 edx
  00170	84 54 30 10	 test	 BYTE PTR [eax+esi+16], dl
  00174	74 0f		 je	 SHORT $LN10@ScanVolClu

; 8933 : 	{
; 8934 : 		*nbrFreeClusters = 0;

  00176	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  0017c	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 8935 : 	}
; 8936 : 	else

  00183	eb 5d		 jmp	 SHORT $LN3@ScanVolClu
$LN10@ScanVolClu:

; 8937 : 	{
; 8938 : 		*nbrFreeClusters = lpOutBuffer->BitmapSize.QuadPart;

  00185	8b 45 ec	 mov	 eax, DWORD PTR tv370[ebp]

; 8939 : 		bitmapCnt = lpOutBuffer->BitmapSize.QuadPart / 8;

  00188	6a 00		 push	 0
  0018a	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0018d	6a 08		 push	 8
  0018f	89 3b		 mov	 DWORD PTR [ebx], edi
  00191	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00194	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00197	50		 push	 eax
  00198	57		 push	 edi
  00199	e8 00 00 00 00	 call	 __alldiv

; 8940 : 
; 8941 : 		// Scan the bitmap from the end
; 8942 : 		while (--bitmapCnt >= 0)

  0019e	83 e8 01	 sub	 eax, 1
  001a1	83 da 00	 sbb	 edx, 0
  001a4	78 3c		 js	 SHORT $LN3@ScanVolClu
  001a6	7f 08		 jg	 SHORT $LL2@ScanVolClu
  001a8	85 c0		 test	 eax, eax
  001aa	72 36		 jb	 SHORT $LN3@ScanVolClu
  001ac	0f 1f 40 00	 npad	 4
$LL2@ScanVolClu:

; 8943 : 		{
; 8944 : 			if (lpOutBuffer->Buffer[bitmapCnt] != 0)

  001b0	80 7c 06 10 00	 cmp	 BYTE PTR [esi+eax+16], 0
  001b5	75 12		 jne	 SHORT $LN15@ScanVolClu

; 8940 : 
; 8941 : 		// Scan the bitmap from the end
; 8942 : 		while (--bitmapCnt >= 0)

  001b7	83 c0 ff	 add	 eax, -1
  001ba	83 d2 ff	 adc	 edx, -1
  001bd	85 d2		 test	 edx, edx
  001bf	7f ef		 jg	 SHORT $LL2@ScanVolClu
  001c1	7c 1f		 jl	 SHORT $LN3@ScanVolClu
  001c3	85 c0		 test	 eax, eax
  001c5	73 e9		 jae	 SHORT $LL2@ScanVolClu

; 8943 : 		{
; 8944 : 			if (lpOutBuffer->Buffer[bitmapCnt] != 0)

  001c7	eb 19		 jmp	 SHORT $LN3@ScanVolClu
$LN15@ScanVolClu:

; 8945 : 			{
; 8946 : 				// There might be up to 7 extra free clusters in this byte of the bitmap. 
; 8947 : 				// These are ignored because there is always a cluster reserve added anyway.
; 8948 : 				*nbrFreeClusters = lpOutBuffer->BitmapSize.QuadPart - ((bitmapCnt + 1) * 8);	

  001c9	83 c0 01	 add	 eax, 1
  001cc	83 d2 00	 adc	 edx, 0
  001cf	0f a4 c2 03	 shld	 edx, eax, 3
  001d3	c1 e0 03	 shl	 eax, 3
  001d6	2b f8		 sub	 edi, eax
  001d8	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001db	89 3b		 mov	 DWORD PTR [ebx], edi
  001dd	1b c2		 sbb	 eax, edx
  001df	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN3@ScanVolClu:

; 8949 : 				break;
; 8950 : 			}
; 8951 : 		}
; 8952 : 	}
; 8953 : 
; 8954 : 	CloseHandle (hDevice);

  001e2	ff 75 e8	 push	 DWORD PTR _hDevice$1$[ebp]
  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 8955 : 	free(lpOutBuffer);

  001eb	56		 push	 esi
  001ec	e8 00 00 00 00	 call	 _free

; 8964 : }

  001f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f4	83 c4 04	 add	 esp, 4
  001f7	33 cd		 xor	 ecx, ebp
  001f9	b8 01 00 00 00	 mov	 eax, 1
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
  00200	5b		 pop	 ebx
  00201	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
_ScanVolClusterBitmap ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _AnalyzeHiddenVolumeHost
_TEXT	SEGMENT
_offsetNew$ = -9108					; size = 8
_dwNumberOfFreeClusters$ = -9100			; size = 4
_dwTotalNumberOfClusters$ = -9096			; size = 4
_bytesReturned$ = -9092					; size = 4
_dwBytesPerSector$ = -9088				; size = 4
_dwSectorsPerCluster$ = -9084				; size = 4
_dwResult$ = -9080					; size = 4
_offset$ = -9076					; size = 8
tv486 = -9072						; size = 4
_pnbrFreeClusters$GSCopy$1$ = -9068			; size = 4
_realClusterSize$GSCopy$1$ = -9064			; size = 4
_szRootPathName$ = -9060				; size = 4
_volProp$ = -9056					; size = 596
_readBuffer$ = -8460					; size = 8192
_szFileSystemNameBuffer$ = -268				; size = 256
_tmpPath$ = -12						; size = 7
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_driveNo$ = 12						; size = 4
_hiddenVolHostSize$ = 16				; size = 8
_realClusterSize$ = 24					; size = 4
_pnbrFreeClusters$ = 28					; size = 4
_AnalyzeHiddenVolumeHost PROC				; COMDAT

; 8672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 94 23 00 00	 mov	 eax, 9108		; 00002394H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 18	 mov	 eax, DWORD PTR _realClusterSize$[ebp]
  0001a	53		 push	 ebx
  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR _driveNo$[ebp]
  0001e	89 85 98 dc ff
	ff		 mov	 DWORD PTR _realClusterSize$GSCopy$1$[ebp], eax
  00024	8b 45 1c	 mov	 eax, DWORD PTR _pnbrFreeClusters$[ebp]
  00027	56		 push	 esi
  00028	89 85 94 dc ff
	ff		 mov	 DWORD PTR _pnbrFreeClusters$GSCopy$1$[ebp], eax

; 8673 : 	HANDLE hDevice;
; 8674 : 	DWORD bytesReturned;
; 8675 : 	DWORD dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters, dwTotalNumberOfClusters;
; 8676 : 	DWORD dwResult;
; 8677 : 	int result;
; 8678 : 	char szFileSystemNameBuffer[256];
; 8679 : 	char tmpPath[7] = {'\\','\\','.','\\',(char) *driveNo + 'A',':',0};

  0002e	8a 03		 mov	 al, BYTE PTR [ebx]
  00030	57		 push	 edi
  00031	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  00034	04 41		 add	 al, 65			; 00000041H

; 8680 : 	char szRootPathName[4] = {(char) *driveNo + 'A', ':', '\\', 0};
; 8681 : 	BYTE readBuffer[GST_MAX_VOLUME_SECTOR_SIZE * 2];
; 8682 : 	LARGE_INTEGER offset, offsetNew;
; 8683 : 	VOLUME_PROPERTIES_STRUCT volProp;
; 8684 : 
; 8685 : 	memset (&volProp, 0, sizeof(volProp));

  00036	68 54 02 00 00	 push	 596			; 00000254H
  0003b	88 45 f8	 mov	 BYTE PTR _tmpPath$[ebp+4], al
  0003e	88 85 9c dc ff
	ff		 mov	 BYTE PTR _szRootPathName$[ebp], al
  00044	8d 85 a0 dc ff
	ff		 lea	 eax, DWORD PTR _volProp$[ebp]
  0004a	6a 00		 push	 0
  0004c	50		 push	 eax
  0004d	c7 45 f4 5c 5c
	2e 5c		 mov	 DWORD PTR _tmpPath$[ebp], 1546542172 ; 5c2e5c5cH
  00054	66 c7 45 f9 3a
	00		 mov	 WORD PTR _tmpPath$[ebp+5], 58 ; 0000003aH
  0005a	66 c7 85 9d dc
	ff ff 3a 5c	 mov	 WORD PTR _szRootPathName$[ebp+1], 23610 ; 00005c3aH
  00063	c6 85 9f dc ff
	ff 00		 mov	 BYTE PTR _szRootPathName$[ebp+3], 0
  0006a	e8 00 00 00 00	 call	 _memset

; 8686 : 	volProp.driveNo = *driveNo;

  0006f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	89 85 a0 dc ff
	ff		 mov	 DWORD PTR _volProp$[ebp], eax

; 8687 : 	if (!DeviceIoControl (hDriver, GST_IOCTL_GET_VOLUME_PROPERTIES, &volProp, sizeof (volProp), &volProp, sizeof (volProp), &dwResult, NULL) || dwResult == 0)

  0007a	8d 85 88 dc ff
	ff		 lea	 eax, DWORD PTR _dwResult$[ebp]
  00080	6a 00		 push	 0
  00082	50		 push	 eax
  00083	68 54 02 00 00	 push	 596			; 00000254H
  00088	8d 85 a0 dc ff
	ff		 lea	 eax, DWORD PTR _volProp$[ebp]
  0008e	50		 push	 eax
  0008f	68 54 02 00 00	 push	 596			; 00000254H
  00094	50		 push	 eax
  00095	68 1c 20 22 00	 push	 2236444			; 0022201cH
  0009a	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  000a6	85 c0		 test	 eax, eax
  000a8	0f 84 80 03 00
	00		 je	 $LN3@AnalyzeHid
  000ae	83 bd 88 dc ff
	ff 00		 cmp	 DWORD PTR _dwResult$[ebp], 0
  000b5	0f 84 73 03 00
	00		 je	 $LN3@AnalyzeHid

; 8691 : 		goto efsf_error;
; 8692 : 	}
; 8693 : 
; 8694 : 	if (volProp.volFormatVersion < GST_VOLUME_FORMAT_VERSION)

  000bb	83 bd f0 de ff
	ff 0d		 cmp	 DWORD PTR _volProp$[ebp+592], 13 ; 0000000dH
  000c2	7d 20		 jge	 SHORT $LN5@AnalyzeHid

; 8695 : 	{
; 8696 : 		// We do not support creating hidden volumes within volumes created by GostCrypt 5.1a or earlier.
; 8697 : 		Error ("ERR_VOL_FORMAT_BAD");

  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GJIBONDI@ERR_VOL_FORMAT_BAD?$AA@
  000c9	e8 00 00 00 00	 call	 _Error
  000ce	83 c4 04	 add	 esp, 4

; 8698 : 		return 0;

  000d1	33 c0		 xor	 eax, eax
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx

; 8816 : 
; 8817 : 	return -1;
; 8818 : }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN5@AnalyzeHid:

; 8699 : 	}
; 8700 : 
; 8701 : 	if (volProp.hiddenVolume)

  000e4	83 bd c8 de ff
	ff 00		 cmp	 DWORD PTR _volProp$[ebp+552], 0
  000eb	74 20		 je	 SHORT $LN6@AnalyzeHid

; 8702 : 	{
; 8703 : 		// The user entered a password for a hidden volume
; 8704 : 		Error ("ERR_HIDDEN_NOT_NORMAL_VOLUME");

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PEDIFLNF@ERR_HIDDEN_NOT_NORMAL_VOLUME?$AA@
  000f2	e8 00 00 00 00	 call	 _Error
  000f7	83 c4 04	 add	 esp, 4

; 8705 : 		return 0;

  000fa	33 c0		 xor	 eax, eax
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx

; 8816 : 
; 8817 : 	return -1;
; 8818 : }

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
$LN6@AnalyzeHid:

; 8706 : 	}
; 8707 : 
; 8708 : 	if (volProp.volumeHeaderFlags & GST_HEADER_FLAG_NONSYS_INPLACE_ENC
; 8709 : 		|| volProp.volumeHeaderFlags & GST_HEADER_FLAG_ENCRYPTED_SYSTEM)

  0010d	f6 85 d8 de ff
	ff 03		 test	 BYTE PTR _volProp$[ebp+568], 3
  00114	0f 85 f4 02 00
	00		 jne	 $LN8@AnalyzeHid

; 8713 : 	}
; 8714 : 
; 8715 : 	hDevice = CreateFile (tmpPath, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

  0011a	6a 00		 push	 0
  0011c	6a 00		 push	 0
  0011e	6a 03		 push	 3
  00120	6a 00		 push	 0
  00122	6a 03		 push	 3
  00124	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00129	8d 45 f4	 lea	 eax, DWORD PTR _tmpPath$[ebp]
  0012c	50		 push	 eax
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00133	8b f0		 mov	 esi, eax

; 8716 : 
; 8717 : 	if (hDevice == INVALID_HANDLE_VALUE)

  00135	83 fe ff	 cmp	 esi, -1
  00138	75 22		 jne	 SHORT $LN9@AnalyzeHid

; 8718 : 	{
; 8719 : 		MessageBoxW (hwndDlg, GetString ("CANT_ACCESS_OUTER_VOL"), lpszTitle, ICON_HAND);

  0013a	6a 10		 push	 16			; 00000010H
  0013c	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EDMDLNEK@CANT_ACCESS_OUTER_VOL?$AA@
  00147	e8 00 00 00 00	 call	 _GetString
  0014c	83 c4 04	 add	 esp, 4
  0014f	50		 push	 eax
  00150	57		 push	 edi
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 8720 : 		goto efsf_error;

  00157	e9 e5 02 00 00	 jmp	 $efsf_error$30
$LN9@AnalyzeHid:

; 8721 : 	}
; 8722 : 
; 8723 : 	offset.QuadPart = 0;
; 8724 : 
; 8725 : 	if (SetFilePointerEx (hDevice, offset, &offsetNew, FILE_BEGIN) == 0)

  0015c	6a 00		 push	 0
  0015e	8d 85 6c dc ff
	ff		 lea	 eax, DWORD PTR _offsetNew$[ebp]
  00164	0f 57 c0	 xorps	 xmm0, xmm0
  00167	50		 push	 eax
  00168	66 0f 13 85 8c
	dc ff ff	 movlpd	 QWORD PTR _offset$[ebp], xmm0
  00170	ff b5 90 dc ff
	ff		 push	 DWORD PTR _offset$[ebp+4]
  00176	ff b5 8c dc ff
	ff		 push	 DWORD PTR _offset$[ebp]
  0017c	56		 push	 esi
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00183	85 c0		 test	 eax, eax
  00185	75 15		 jne	 SHORT $LN11@AnalyzeHid

; 8726 : 	{
; 8727 : 		handleWin32Error (hwndDlg);

  00187	57		 push	 edi
  00188	e8 00 00 00 00	 call	 _handleWin32Error
  0018d	83 c4 04	 add	 esp, 4

; 8809 : 	}
; 8810 : 
; 8811 : efs_error:
; 8812 : 	CloseHandle (hDevice);

  00190	56		 push	 esi
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 8813 : 
; 8814 : efsf_error:

  00197	e9 a5 02 00 00	 jmp	 $efsf_error$30
$LN11@AnalyzeHid:

; 8728 : 		goto efs_error;
; 8729 : 	}
; 8730 : 
; 8731 : 	result = ReadFile (hDevice, &readBuffer, GST_MAX_VOLUME_SECTOR_SIZE, &bytesReturned, NULL);

  0019c	6a 00		 push	 0
  0019e	8d 85 7c dc ff
	ff		 lea	 eax, DWORD PTR _bytesReturned$[ebp]
  001a4	50		 push	 eax
  001a5	68 00 10 00 00	 push	 4096			; 00001000H
  001aa	8d 85 f4 de ff
	ff		 lea	 eax, DWORD PTR _readBuffer$[ebp]
  001b0	50		 push	 eax
  001b1	56		 push	 esi
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20

; 8732 : 
; 8733 : 	if (result == 0)

  001b8	85 c0		 test	 eax, eax
  001ba	75 32		 jne	 SHORT $LN13@AnalyzeHid

; 8734 : 	{
; 8735 : 		handleWin32Error (hwndDlg);

  001bc	57		 push	 edi
  001bd	e8 00 00 00 00	 call	 _handleWin32Error
  001c2	83 c4 04	 add	 esp, 4

; 8736 : 		MessageBoxW (hwndDlg, GetString ("CANT_ACCESS_OUTER_VOL"), lpszTitle, ICON_HAND);

  001c5	6a 10		 push	 16			; 00000010H
  001c7	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EDMDLNEK@CANT_ACCESS_OUTER_VOL?$AA@
  001d2	e8 00 00 00 00	 call	 _GetString
  001d7	83 c4 04	 add	 esp, 4
  001da	50		 push	 eax
  001db	57		 push	 edi
  001dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$efs_error$31:

; 8809 : 	}
; 8810 : 
; 8811 : efs_error:
; 8812 : 	CloseHandle (hDevice);

  001e2	56		 push	 esi
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 8813 : 
; 8814 : efsf_error:

  001e9	e9 53 02 00 00	 jmp	 $efsf_error$30
$LN13@AnalyzeHid:

; 8737 : 		goto efs_error;
; 8738 : 	}
; 8739 : 
; 8740 : 	CloseHandle (hDevice);

  001ee	56		 push	 esi
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 8741 : 	hDevice = INVALID_HANDLE_VALUE;
; 8742 : 
; 8743 : 	// Determine file system type
; 8744 : 
; 8745 : 	GetVolumeInformation(szRootPathName, NULL, 0, NULL, NULL, NULL, szFileSystemNameBuffer, sizeof(szFileSystemNameBuffer));

  001f5	68 00 01 00 00	 push	 256			; 00000100H
  001fa	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szFileSystemNameBuffer$[ebp]
  00200	50		 push	 eax
  00201	6a 00		 push	 0
  00203	6a 00		 push	 0
  00205	6a 00		 push	 0
  00207	6a 00		 push	 0
  00209	6a 00		 push	 0
  0020b	8d 85 9c dc ff
	ff		 lea	 eax, DWORD PTR _szRootPathName$[ebp]
  00211	50		 push	 eax
  00212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeInformationA@32

; 8746 : 
; 8747 : 	// The Windows API sometimes fails to indentify the file system correctly so we're using "raw" analysis too.
; 8748 : 	if (!strncmp (szFileSystemNameBuffer, "FAT", 3)
; 8749 : 		|| (readBuffer[0x36] == 'F' && readBuffer[0x37] == 'A' && readBuffer[0x38] == 'T')
; 8750 : 		|| (readBuffer[0x52] == 'F' && readBuffer[0x53] == 'A' && readBuffer[0x54] == 'T'))

  00218	6a 03		 push	 3
  0021a	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szFileSystemNameBuffer$[ebp]
  00220	68 00 00 00 00	 push	 OFFSET ??_C@_03MPELFIKF@FAT?$AA@
  00225	50		 push	 eax
  00226	e8 00 00 00 00	 call	 _strncmp
  0022b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022e	85 c0		 test	 eax, eax
  00230	0f 84 82 01 00
	00		 je	 $LN17@AnalyzeHid
  00236	80 bd 2a df ff
	ff 46		 cmp	 BYTE PTR _readBuffer$[ebp+54], 70 ; 00000046H
  0023d	75 16		 jne	 SHORT $LN18@AnalyzeHid
  0023f	80 bd 2b df ff
	ff 41		 cmp	 BYTE PTR _readBuffer$[ebp+55], 65 ; 00000041H
  00246	75 0d		 jne	 SHORT $LN18@AnalyzeHid
  00248	80 bd 2c df ff
	ff 54		 cmp	 BYTE PTR _readBuffer$[ebp+56], 84 ; 00000054H
  0024f	0f 84 63 01 00
	00		 je	 $LN17@AnalyzeHid
$LN18@AnalyzeHid:
  00255	80 bd 46 df ff
	ff 46		 cmp	 BYTE PTR _readBuffer$[ebp+82], 70 ; 00000046H
  0025c	75 16		 jne	 SHORT $LN15@AnalyzeHid
  0025e	80 bd 47 df ff
	ff 41		 cmp	 BYTE PTR _readBuffer$[ebp+83], 65 ; 00000041H
  00265	75 0d		 jne	 SHORT $LN15@AnalyzeHid
  00267	80 bd 48 df ff
	ff 54		 cmp	 BYTE PTR _readBuffer$[ebp+84], 84 ; 00000054H
  0026e	0f 84 44 01 00
	00		 je	 $LN17@AnalyzeHid
$LN15@AnalyzeHid:

; 8763 : 			driveNo,
; 8764 : 			hiddenVolHostSize / *realClusterSize,
; 8765 : 			pnbrFreeClusters);
; 8766 : 	}
; 8767 : 	else if (!strncmp (szFileSystemNameBuffer, "NTFS", 4))

  00274	6a 04		 push	 4
  00276	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szFileSystemNameBuffer$[ebp]
  0027c	68 00 00 00 00	 push	 OFFSET ??_C@_04HPPAIJNK@NTFS?$AA@
  00281	50		 push	 eax
  00282	e8 00 00 00 00	 call	 _strncmp
  00287	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028a	85 c0		 test	 eax, eax
  0028c	0f 85 f6 00 00
	00		 jne	 $LN19@AnalyzeHid

; 8768 : 	{
; 8769 : 		// NTFS
; 8770 : 
; 8771 : 		if (nCurrentOS == WIN_2000)

  00292	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _nCurrentOS, 7
  00299	75 20		 jne	 SHORT $LN21@AnalyzeHid

; 8772 : 		{
; 8773 : 			Error("HIDDEN_VOL_HOST_UNSUPPORTED_FILESYS_WIN2000");

  0029b	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PCAIDDLK@HIDDEN_VOL_HOST_UNSUPPORTED_FILE@
  002a0	e8 00 00 00 00	 call	 _Error
  002a5	83 c4 04	 add	 esp, 4

; 8774 : 			return 0;

  002a8	33 c0		 xor	 eax, eax
  002aa	5f		 pop	 edi
  002ab	5e		 pop	 esi
  002ac	5b		 pop	 ebx

; 8816 : 
; 8817 : 	return -1;
; 8818 : }

  002ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b0	33 cd		 xor	 ecx, ebp
  002b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b7	8b e5		 mov	 esp, ebp
  002b9	5d		 pop	 ebp
  002ba	c3		 ret	 0
$LN21@AnalyzeHid:

; 8775 : 		}
; 8776 : 
; 8777 : 		if (bHiddenVolDirect && GetVolumeDataAreaSize (FALSE, hiddenVolHostSize) <= GST_MAX_FAT_SECTOR_COUNT * GetFormatSectorSize())

  002bb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolDirect, 0
  002c2	8b 75 14	 mov	 esi, DWORD PTR _hiddenVolHostSize$[ebp+4]
  002c5	74 3b		 je	 SHORT $LN22@AnalyzeHid
  002c7	56		 push	 esi
  002c8	ff 75 10	 push	 DWORD PTR _hiddenVolHostSize$[ebp]
  002cb	6a 00		 push	 0
  002cd	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  002d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d5	89 85 90 dc ff
	ff		 mov	 DWORD PTR tv486[ebp], eax
  002db	8b f2		 mov	 esi, edx
  002dd	e8 00 00 00 00	 call	 _GetFormatSectorSize
  002e2	99		 cdq
  002e3	3b f0		 cmp	 esi, eax
  002e5	77 18		 ja	 SHORT $LN27@AnalyzeHid
  002e7	72 09		 jb	 SHORT $LN25@AnalyzeHid
  002e9	83 bd 90 dc ff
	ff 00		 cmp	 DWORD PTR tv486[ebp], 0
  002f0	77 0d		 ja	 SHORT $LN27@AnalyzeHid
$LN25@AnalyzeHid:

; 8778 : 			Info ("HIDDEN_VOL_HOST_NTFS");

  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GKHHEFAE@HIDDEN_VOL_HOST_NTFS?$AA@
  002f7	e8 00 00 00 00	 call	 _Info
  002fc	83 c4 04	 add	 esp, 4
$LN27@AnalyzeHid:
  002ff	8b 75 14	 mov	 esi, DWORD PTR _hiddenVolHostSize$[ebp+4]
$LN22@AnalyzeHid:

; 8779 : 
; 8780 : 		if (!GetDiskFreeSpace(szRootPathName, 

  00302	8d 85 78 dc ff
	ff		 lea	 eax, DWORD PTR _dwTotalNumberOfClusters$[ebp]
  00308	50		 push	 eax
  00309	8d 85 74 dc ff
	ff		 lea	 eax, DWORD PTR _dwNumberOfFreeClusters$[ebp]
  0030f	50		 push	 eax
  00310	8d 85 80 dc ff
	ff		 lea	 eax, DWORD PTR _dwBytesPerSector$[ebp]
  00316	50		 push	 eax
  00317	8d 85 84 dc ff
	ff		 lea	 eax, DWORD PTR _dwSectorsPerCluster$[ebp]
  0031d	50		 push	 eax
  0031e	8d 85 9c dc ff
	ff		 lea	 eax, DWORD PTR _szRootPathName$[ebp]
  00324	50		 push	 eax
  00325	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDiskFreeSpaceA@20
  0032b	85 c0		 test	 eax, eax
  0032d	75 15		 jne	 SHORT $LN23@AnalyzeHid

; 8781 : 			&dwSectorsPerCluster, 
; 8782 : 			&dwBytesPerSector, 
; 8783 : 			&dwNumberOfFreeClusters, 
; 8784 : 			&dwTotalNumberOfClusters))
; 8785 : 		{
; 8786 : 			handleWin32Error (hwndDlg);

  0032f	57		 push	 edi
  00330	e8 00 00 00 00	 call	 _handleWin32Error

; 8787 : 			Error ("CANT_GET_OUTER_VOL_INFO");

  00335	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@JLECLIC@CANT_GET_OUTER_VOL_INFO?$AA@
  0033a	e8 00 00 00 00	 call	 _Error

; 8788 : 			return -1;

  0033f	e9 05 01 00 00	 jmp	 $LN28@AnalyzeHid
$LN23@AnalyzeHid:

; 8789 : 		};
; 8790 : 
; 8791 : 		*realClusterSize = dwBytesPerSector * dwSectorsPerCluster;

  00344	8b 85 84 dc ff
	ff		 mov	 eax, DWORD PTR _dwSectorsPerCluster$[ebp]
  0034a	0f af 85 80 dc
	ff ff		 imul	 eax, DWORD PTR _dwBytesPerSector$[ebp]
  00351	8b 95 98 dc ff
	ff		 mov	 edx, DWORD PTR _realClusterSize$GSCopy$1$[ebp]

; 8792 : 
; 8793 : 		// Get the map of the clusters that are free and in use on the outer volume.
; 8794 : 		// The map will be scanned to determine the size of the uninterrupted block of free
; 8795 : 		// space (provided there is any) whose end is aligned with the end of the volume.
; 8796 : 		// The value will then be used to determine the maximum possible size of the hidden volume.
; 8797 : 
; 8798 : 		return ScanVolClusterBitmap (hwndDlg,

  00357	ff b5 94 dc ff
	ff		 push	 DWORD PTR _pnbrFreeClusters$GSCopy$1$[ebp]
  0035d	89 02		 mov	 DWORD PTR [edx], eax
  0035f	99		 cdq
  00360	52		 push	 edx
  00361	50		 push	 eax
  00362	56		 push	 esi
  00363	ff 75 10	 push	 DWORD PTR _hiddenVolHostSize$[ebp]
  00366	e8 00 00 00 00	 call	 __alldiv
  0036b	52		 push	 edx
  0036c	50		 push	 eax
  0036d	53		 push	 ebx
  0036e	57		 push	 edi
  0036f	e8 00 00 00 00	 call	 _ScanVolClusterBitmap
  00374	83 c4 14	 add	 esp, 20			; 00000014H
  00377	5f		 pop	 edi
  00378	5e		 pop	 esi
  00379	5b		 pop	 ebx

; 8816 : 
; 8817 : 	return -1;
; 8818 : }

  0037a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0037d	33 cd		 xor	 ecx, ebp
  0037f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00384	8b e5		 mov	 esp, ebp
  00386	5d		 pop	 ebp
  00387	c3		 ret	 0
$LN19@AnalyzeHid:

; 8799 : 			driveNo,
; 8800 : 			hiddenVolHostSize / *realClusterSize,
; 8801 : 			pnbrFreeClusters);
; 8802 : 	}
; 8803 : 	else
; 8804 : 	{
; 8805 : 		// Unsupported file system
; 8806 : 
; 8807 : 		Error ((nCurrentOS == WIN_2000) ? "HIDDEN_VOL_HOST_UNSUPPORTED_FILESYS_WIN2000" : "HIDDEN_VOL_HOST_UNSUPPORTED_FILESYS");

  00388	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _nCurrentOS, 7
  0038f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CE@PMECNFFM@HIDDEN_VOL_HOST_UNSUPPORTED_FILE@
  00394	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CM@PCAIDDLK@HIDDEN_VOL_HOST_UNSUPPORTED_FILE@
  00399	0f 45 c1	 cmovne	 eax, ecx
  0039c	50		 push	 eax
  0039d	e8 00 00 00 00	 call	 _Error
  003a2	83 c4 04	 add	 esp, 4

; 8808 : 		return 0;

  003a5	33 c0		 xor	 eax, eax
  003a7	5f		 pop	 edi
  003a8	5e		 pop	 esi
  003a9	5b		 pop	 ebx

; 8816 : 
; 8817 : 	return -1;
; 8818 : }

  003aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ad	33 cd		 xor	 ecx, ebp
  003af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b4	8b e5		 mov	 esp, ebp
  003b6	5d		 pop	 ebp
  003b7	c3		 ret	 0
$LN17@AnalyzeHid:

; 8751 : 	{
; 8752 : 		// FAT12/FAT16/FAT32
; 8753 : 
; 8754 : 		// Retrieve the cluster size
; 8755 : 		*realClusterSize = ((int) readBuffer[0xb] + ((int) readBuffer[0xc] << 8)) * (int) readBuffer[0xd];	

  003b8	0f b6 8d 00 df
	ff ff		 movzx	 ecx, BYTE PTR _readBuffer$[ebp+12]
  003bf	0f b6 85 ff de
	ff ff		 movzx	 eax, BYTE PTR _readBuffer$[ebp+11]

; 8756 : 
; 8757 : 		// Get the map of the clusters that are free and in use on the outer volume.
; 8758 : 		// The map will be scanned to determine the size of the uninterrupted block of free
; 8759 : 		// space (provided there is any) whose end is aligned with the end of the volume.
; 8760 : 		// The value will then be used to determine the maximum possible size of the hidden volume.
; 8761 : 
; 8762 : 		return ScanVolClusterBitmap (hwndDlg,

  003c6	ff b5 94 dc ff
	ff		 push	 DWORD PTR _pnbrFreeClusters$GSCopy$1$[ebp]
  003cc	8b 95 98 dc ff
	ff		 mov	 edx, DWORD PTR _realClusterSize$GSCopy$1$[ebp]
  003d2	c1 e1 08	 shl	 ecx, 8
  003d5	03 c8		 add	 ecx, eax
  003d7	0f b6 85 01 df
	ff ff		 movzx	 eax, BYTE PTR _readBuffer$[ebp+13]
  003de	0f af c8	 imul	 ecx, eax
  003e1	6a 00		 push	 0
  003e3	51		 push	 ecx
  003e4	ff 75 14	 push	 DWORD PTR _hiddenVolHostSize$[ebp+4]
  003e7	89 0a		 mov	 DWORD PTR [edx], ecx
  003e9	ff 75 10	 push	 DWORD PTR _hiddenVolHostSize$[ebp]
  003ec	e8 00 00 00 00	 call	 __alldiv
  003f1	52		 push	 edx
  003f2	50		 push	 eax
  003f3	53		 push	 ebx
  003f4	57		 push	 edi
  003f5	e8 00 00 00 00	 call	 _ScanVolClusterBitmap
  003fa	83 c4 14	 add	 esp, 20			; 00000014H
  003fd	5f		 pop	 edi
  003fe	5e		 pop	 esi
  003ff	5b		 pop	 ebx

; 8816 : 
; 8817 : 	return -1;
; 8818 : }

  00400	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00403	33 cd		 xor	 ecx, ebp
  00405	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040a	8b e5		 mov	 esp, ebp
  0040c	5d		 pop	 ebp
  0040d	c3		 ret	 0
$LN8@AnalyzeHid:

; 8710 : 	{
; 8711 : 		Warning ("ERR_HIDDEN_VOL_HOST_ENCRYPTED_INPLACE");

  0040e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@DBCOIOLF@ERR_HIDDEN_VOL_HOST_ENCRYPTED_IN@
  00413	e8 00 00 00 00	 call	 _Warning
  00418	83 c4 04	 add	 esp, 4

; 8712 : 		return 0;

  0041b	33 c0		 xor	 eax, eax
  0041d	5f		 pop	 edi
  0041e	5e		 pop	 esi
  0041f	5b		 pop	 ebx

; 8816 : 
; 8817 : 	return -1;
; 8818 : }

  00420	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00423	33 cd		 xor	 ecx, ebp
  00425	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0042a	8b e5		 mov	 esp, ebp
  0042c	5d		 pop	 ebp
  0042d	c3		 ret	 0
$LN3@AnalyzeHid:

; 8688 : 	{
; 8689 : 		handleWin32Error (hwndDlg);

  0042e	57		 push	 edi
  0042f	e8 00 00 00 00	 call	 _handleWin32Error

; 8690 : 		Error ("CANT_ACCESS_OUTER_VOL");

  00434	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EDMDLNEK@CANT_ACCESS_OUTER_VOL?$AA@
  00439	e8 00 00 00 00	 call	 _Error
  0043e	83 c4 08	 add	 esp, 8
$efsf_error$30:

; 8815 : 	CloseVolumeExplorerWindows (hwndDlg, *driveNo);

  00441	ff 33		 push	 DWORD PTR [ebx]
  00443	57		 push	 edi
  00444	e8 00 00 00 00	 call	 _CloseVolumeExplorerWindows
$LN28@AnalyzeHid:

; 8816 : 
; 8817 : 	return -1;
; 8818 : }

  00449	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044c	83 c4 08	 add	 esp, 8
  0044f	33 cd		 xor	 ecx, ebp
  00451	83 c8 ff	 or	 eax, -1
  00454	5f		 pop	 edi
  00455	5e		 pop	 esi
  00456	5b		 pop	 ebx
  00457	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045c	8b e5		 mov	 esp, ebp
  0045e	5d		 pop	 ebp
  0045f	c3		 ret	 0
_AnalyzeHiddenVolumeHost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _MountHiddenVolHost
_TEXT	SEGMENT
_password$GSCopy$1$ = -108				; size = 4
_mountOptions$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_volumePath$ = 12					; size = 4
_driveNo$ = 16						; size = 4
_password$ = 20						; size = 4
_bReadOnly$ = 24					; size = 4
_MountHiddenVolHost PROC				; COMDAT

; 8836 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 14	 mov	 eax, DWORD PTR _password$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _volumePath$[ebp]
  00017	56		 push	 esi
  00018	8b 75 10	 mov	 esi, DWORD PTR _driveNo$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]

; 8837 : 	MountOptions mountOptions;
; 8838 : 	ZeroMemory (&mountOptions, sizeof (mountOptions));

  0001f	6a 64		 push	 100			; 00000064H
  00021	89 45 94	 mov	 DWORD PTR _password$GSCopy$1$[ebp], eax
  00024	8d 45 98	 lea	 eax, DWORD PTR _mountOptions$[ebp]
  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _memset
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8839 : 
; 8840 : 	*driveNo = GetLastAvailableDrive ();

  00032	e8 00 00 00 00	 call	 _GetLastAvailableDrive
  00037	89 06		 mov	 DWORD PTR [esi], eax

; 8841 : 
; 8842 : 	if (*driveNo == -1)

  00039	83 f8 ff	 cmp	 eax, -1
  0003c	75 1c		 jne	 SHORT $LN2@MountHidde

; 8843 : 	{
; 8844 : 		*driveNo = -2;

  0003e	5f		 pop	 edi
  0003f	c7 06 fe ff ff
	ff		 mov	 DWORD PTR [esi], -2	; fffffffeH

; 8845 : 		return ERR_NO_FREE_DRIVES;

  00045	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 8859 : 	}
; 8860 : 	return 0;
; 8861 : }

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004f	33 cd		 xor	 ecx, ebp
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
$LN2@MountHidde:

; 8846 : 	}
; 8847 : 
; 8848 : 	mountOptions.ReadOnly = bReadOnly;

  0005a	8b 45 18	 mov	 eax, DWORD PTR _bReadOnly$[ebp]

; 8849 : 	mountOptions.Removable = ConfigReadInt ("MountVolumesRemovable", FALSE);

  0005d	6a 00		 push	 0
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BIDCCDPC@MountVolumesRemovable?$AA@
  00064	89 45 98	 mov	 DWORD PTR _mountOptions$[ebp], eax
  00067	e8 00 00 00 00	 call	 _ConfigReadInt

; 8850 : 	mountOptions.ProtectHiddenVolume = FALSE;
; 8851 : 	mountOptions.PreserveTimestamp = bPreserveTimestamp;
; 8852 : 	mountOptions.PartitionInInactiveSysEncScope = FALSE;
; 8853 : 	mountOptions.UseBackupHeader = FALSE;
; 8854 : 
; 8855 : 	if (MountVolume (hwndDlg, *driveNo, volumePath, password, FALSE, TRUE, &mountOptions, FALSE, TRUE) < 1)

  0006c	6a 01		 push	 1
  0006e	6a 00		 push	 0
  00070	89 45 9c	 mov	 DWORD PTR _mountOptions$[ebp+4], eax
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _bPreserveTimestamp
  00078	89 45 a4	 mov	 DWORD PTR _mountOptions$[ebp+12], eax
  0007b	8d 45 98	 lea	 eax, DWORD PTR _mountOptions$[ebp]
  0007e	50		 push	 eax
  0007f	6a 01		 push	 1
  00081	6a 00		 push	 0
  00083	ff 75 94	 push	 DWORD PTR _password$GSCopy$1$[ebp]
  00086	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _mountOptions$[ebp+8], 0
  0008d	53		 push	 ebx
  0008e	ff 36		 push	 DWORD PTR [esi]
  00090	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _mountOptions$[ebp+16], 0
  00097	57		 push	 edi
  00098	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mountOptions$[ebp+92], 0
  0009f	e8 00 00 00 00	 call	 _MountVolume
  000a4	83 c4 2c	 add	 esp, 44			; 0000002cH
  000a7	83 f8 01	 cmp	 eax, 1
  000aa	7d 1c		 jge	 SHORT $LN3@MountHidde

; 8856 : 	{
; 8857 : 		*driveNo = -3;

  000ac	5f		 pop	 edi
  000ad	c7 06 fd ff ff
	ff		 mov	 DWORD PTR [esi], -3	; fffffffdH

; 8858 : 		return ERR_VOL_MOUNT_FAILED;

  000b3	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx

; 8859 : 	}
; 8860 : 	return 0;
; 8861 : }

  000ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bd	33 cd		 xor	 ecx, ebp
  000bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN3@MountHidde:
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cb	33 c0		 xor	 eax, eax
  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	33 cd		 xor	 ecx, ebp
  000d1	5b		 pop	 ebx
  000d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
_MountHiddenVolHost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _UpdateNonSysInPlaceEncControls
_TEXT	SEGMENT
_UpdateNonSysInPlaceEncControls PROC			; COMDAT

; 2191 : 	EnableWindow (GetDlgItem (hCurPage, IDC_WIPE_MODE), !(bVolTransformThreadRunning || bVolTransformThreadToRun));

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  00007	75 10		 jne	 SHORT $LN14@UpdateNonS
  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  00010	75 07		 jne	 SHORT $LN14@UpdateNonS
  00012	b8 01 00 00 00	 mov	 eax, 1
  00017	eb 02		 jmp	 SHORT $LN15@UpdateNonS
$LN14@UpdateNonS:
  00019	33 c0		 xor	 eax, eax
$LN15@UpdateNonS:
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00024	50		 push	 eax
  00025	68 3d 04 00 00	 push	 1085			; 0000043dH
  0002a	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00030	ff d7		 call	 edi
  00032	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__EnableWindow@8
  00038	50		 push	 eax
  00039	ff d3		 call	 ebx

; 2192 : 
; 2193 : 	SetWindowTextW (GetDlgItem (hCurPage, IDC_PAUSE),

  0003b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  00042	75 0e		 jne	 SHORT $LN16@UpdateNonS
  00044	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06PPGAKMJI@RESUME?$AA@
  00050	74 05		 je	 SHORT $LN17@UpdateNonS
$LN16@UpdateNonS:
  00052	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09PJBBBIIP@IDC_PAUSE?$AA@
$LN17@UpdateNonS:
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _GetString
  0005d	83 c4 04	 add	 esp, 4
  00060	50		 push	 eax
  00061	68 41 04 00 00	 push	 1089			; 00000441H
  00066	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0006c	ff d7		 call	 edi
  0006e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00074	50		 push	 eax
  00075	ff d6		 call	 esi

; 2194 : 		GetString ((bVolTransformThreadRunning || bVolTransformThreadToRun) ? "IDC_PAUSE" : "RESUME"));
; 2195 : 
; 2196 : 	SetWindowTextW (GetDlgItem (MainDlg, IDCANCEL), GetString (bInPlaceEncNonSysResumed ? "DEFER" : "CANCEL"));

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSysResumed
  0007c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  00081	85 c0		 test	 eax, eax
  00083	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05KEELGAD@DEFER?$AA@
  00088	0f 44 ca	 cmove	 ecx, edx
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 _GetString
  00091	83 c4 04	 add	 esp, 4
  00094	50		 push	 eax
  00095	6a 02		 push	 2
  00097	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0009d	ff d7		 call	 edi
  0009f	50		 push	 eax
  000a0	ff d6		 call	 esi

; 2197 : 
; 2198 : 	EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), bFirstNonSysInPlaceEncResumeDone 

  000a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bFirstNonSysInPlaceEncResumeDone, 0
  000a9	74 19		 je	 SHORT $LN18@UpdateNonS
  000ab	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _NonSysInplaceEncStatus, 4
  000b2	74 10		 je	 SHORT $LN18@UpdateNonS
  000b4	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _NonSysInplaceEncStatus, 6
  000bb	74 07		 je	 SHORT $LN18@UpdateNonS
  000bd	b8 01 00 00 00	 mov	 eax, 1
  000c2	eb 02		 jmp	 SHORT $LN19@UpdateNonS
$LN18@UpdateNonS:
  000c4	33 c0		 xor	 eax, eax
$LN19@UpdateNonS:
  000c6	50		 push	 eax
  000c7	68 41 04 00 00	 push	 1089			; 00000441H
  000cc	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  000d2	ff d7		 call	 edi
  000d4	50		 push	 eax
  000d5	ff d3		 call	 ebx

; 2199 : 		&& NonSysInplaceEncStatus != NONSYS_INPLACE_ENC_STATUS_FINALIZING
; 2200 : 		&& NonSysInplaceEncStatus != NONSYS_INPLACE_ENC_STATUS_FINISHED);
; 2201 : 
; 2202 : 	EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), !(bVolTransformThreadRunning || bVolTransformThreadToRun) && !bFirstNonSysInPlaceEncResumeDone);

  000d7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  000de	75 19		 jne	 SHORT $LN20@UpdateNonS
  000e0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  000e7	75 10		 jne	 SHORT $LN20@UpdateNonS
  000e9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bFirstNonSysInPlaceEncResumeDone, 0
  000f0	75 07		 jne	 SHORT $LN20@UpdateNonS
  000f2	b8 01 00 00 00	 mov	 eax, 1
  000f7	eb 02		 jmp	 SHORT $LN21@UpdateNonS
$LN20@UpdateNonS:
  000f9	33 c0		 xor	 eax, eax
$LN21@UpdateNonS:
  000fb	50		 push	 eax
  000fc	68 10 04 00 00	 push	 1040			; 00000410H
  00101	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00107	ff d7		 call	 edi
  00109	50		 push	 eax
  0010a	ff d3		 call	 ebx

; 2203 : 	EnableWindow (GetDlgItem (MainDlg, IDC_PREV), !(bVolTransformThreadRunning || bVolTransformThreadToRun) && !bInPlaceEncNonSysResumed);

  0010c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  00113	75 19		 jne	 SHORT $LN22@UpdateNonS
  00115	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  0011c	75 10		 jne	 SHORT $LN22@UpdateNonS
  0011e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSysResumed, 0
  00125	75 07		 jne	 SHORT $LN22@UpdateNonS
  00127	b8 01 00 00 00	 mov	 eax, 1
  0012c	eb 02		 jmp	 SHORT $LN23@UpdateNonS
$LN22@UpdateNonS:
  0012e	33 c0		 xor	 eax, eax
$LN23@UpdateNonS:
  00130	50		 push	 eax
  00131	68 11 04 00 00	 push	 1041			; 00000411H
  00136	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0013c	ff d7		 call	 edi
  0013e	50		 push	 eax
  0013f	ff d3		 call	 ebx

; 2204 : 	EnableWindow (GetDlgItem (MainDlg, IDCANCEL), 

  00141	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  00148	75 2b		 jne	 SHORT $LN24@UpdateNonS
  0014a	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _NonSysInplaceEncStatus, 1
  00151	74 22		 je	 SHORT $LN24@UpdateNonS
  00153	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _NonSysInplaceEncStatus, 2
  0015a	74 19		 je	 SHORT $LN24@UpdateNonS
  0015c	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _NonSysInplaceEncStatus, 4
  00163	74 10		 je	 SHORT $LN24@UpdateNonS
  00165	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _NonSysInplaceEncStatus, 6
  0016c	74 07		 je	 SHORT $LN24@UpdateNonS
  0016e	b8 01 00 00 00	 mov	 eax, 1
  00173	eb 02		 jmp	 SHORT $LN25@UpdateNonS
$LN24@UpdateNonS:
  00175	33 c0		 xor	 eax, eax
$LN25@UpdateNonS:
  00177	50		 push	 eax
  00178	6a 02		 push	 2
  0017a	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00180	ff d7		 call	 edi
  00182	50		 push	 eax
  00183	ff d3		 call	 ebx

; 2205 : 		!(bVolTransformThreadToRun 
; 2206 : 		|| NonSysInplaceEncStatus == NONSYS_INPLACE_ENC_STATUS_PREPARING 
; 2207 : 		|| NonSysInplaceEncStatus == NONSYS_INPLACE_ENC_STATUS_RESIZING
; 2208 : 		|| NonSysInplaceEncStatus == NONSYS_INPLACE_ENC_STATUS_FINALIZING
; 2209 : 		|| NonSysInplaceEncStatus == NONSYS_INPLACE_ENC_STATUS_FINISHED));
; 2210 : 
; 2211 : 	if (bVolTransformThreadRunning || bVolTransformThreadToRun)

  00185	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  0018c	75 60		 jne	 SHORT $LN6@UpdateNonS
  0018e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  00195	75 57		 jne	 SHORT $LN6@UpdateNonS

; 2232 : 	}
; 2233 : 	else
; 2234 : 	{
; 2235 : 		NormalCursor ();

  00197	e8 00 00 00 00	 call	 _NormalCursor

; 2236 : 
; 2237 : 		if (bInPlaceEncNonSysResumed)

  0019c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSysResumed, 0
  001a3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  001a9	74 0c		 je	 SHORT $LN11@UpdateNonS

; 2238 : 		{
; 2239 : 			SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PAUSED);

  001ab	6a 05		 push	 5
  001ad	e8 00 00 00 00	 call	 _SetNonSysInplaceEncUIStatus
  001b2	83 c4 04	 add	 esp, 4

; 2240 : 		}
; 2241 : 		else

  001b5	eb 15		 jmp	 SHORT $LN12@UpdateNonS
$LN11@UpdateNonS:

; 2242 : 			SetWindowText (GetDlgItem (hCurPage, IDC_WRITESPEED), " ");

  001b7	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  001bc	68 01 04 00 00	 push	 1025			; 00000401H
  001c1	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  001c7	ff d7		 call	 edi
  001c9	50		 push	 eax
  001ca	ff d6		 call	 esi
$LN12@UpdateNonS:

; 2243 : 
; 2244 : 		SetWindowText (GetDlgItem (hCurPage, IDC_TIMEREMAIN), " ");

  001cc	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  001d1	68 03 04 00 00	 push	 1027			; 00000403H
  001d6	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  001dc	ff d7		 call	 edi
  001de	50		 push	 eax
  001df	ff d6		 call	 esi

; 2245 : 	}
; 2246 : 
; 2247 : 	ShowNonSysInPlaceEncUIStatus ();

  001e1	e8 00 00 00 00	 call	 _ShowNonSysInPlaceEncUIStatus
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx

; 2248 : 
; 2249 : 	UpdateNonSysInplaceEncProgressBar ();

  001e9	e9 00 00 00 00	 jmp	 _UpdateNonSysInplaceEncProgressBar
$LN6@UpdateNonS:

; 2212 : 	{
; 2213 : 		switch (NonSysInplaceEncStatus)

  001ee	a1 00 00 00 00	 mov	 eax, DWORD PTR _NonSysInplaceEncStatus
  001f3	48		 dec	 eax
  001f4	83 f8 03	 cmp	 eax, 3
  001f7	77 0e		 ja	 SHORT $LN9@UpdateNonS
  001f9	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN29@UpdateNonS[eax*4]
$LN7@UpdateNonS:

; 2214 : 		{
; 2215 : 		case NONSYS_INPLACE_ENC_STATUS_PREPARING:
; 2216 : 		case NONSYS_INPLACE_ENC_STATUS_RESIZING:
; 2217 : 		case NONSYS_INPLACE_ENC_STATUS_FINALIZING:
; 2218 : 			ArrowWaitCursor ();

  00200	e8 00 00 00 00	 call	 _ArrowWaitCursor

; 2219 : 			break;

  00205	eb 05		 jmp	 SHORT $LN2@UpdateNonS
$LN9@UpdateNonS:

; 2220 : 
; 2221 : 		case NONSYS_INPLACE_ENC_STATUS_ENCRYPTING:
; 2222 : 			NormalCursor ();
; 2223 : 			break;
; 2224 : 
; 2225 : 		default:
; 2226 : 			NormalCursor ();

  00207	e8 00 00 00 00	 call	 _NormalCursor
$LN2@UpdateNonS:

; 2227 : 			break;
; 2228 : 		}
; 2229 : 
; 2230 : 		if (bVolTransformThreadCancel)

  0020c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bVolTransformThreadCancel, 0
  00213	74 05		 je	 SHORT $LN10@UpdateNonS

; 2231 : 			WaitCursor ();

  00215	e8 00 00 00 00	 call	 _WaitCursor
$LN10@UpdateNonS:

; 2245 : 	}
; 2246 : 
; 2247 : 	ShowNonSysInPlaceEncUIStatus ();

  0021a	e8 00 00 00 00	 call	 _ShowNonSysInPlaceEncUIStatus
  0021f	5f		 pop	 edi
  00220	5e		 pop	 esi
  00221	5b		 pop	 ebx

; 2248 : 
; 2249 : 	UpdateNonSysInplaceEncProgressBar ();

  00222	e9 00 00 00 00	 jmp	 _UpdateNonSysInplaceEncProgressBar
  00227	90		 npad	 1
$LN29@UpdateNonS:

; 2250 : }

  00228	00 00 00 00	 DD	 $LN7@UpdateNonS
  0022c	00 00 00 00	 DD	 $LN7@UpdateNonS
  00230	00 00 00 00	 DD	 $LN9@UpdateNonS
  00234	00 00 00 00	 DD	 $LN7@UpdateNonS
_UpdateNonSysInPlaceEncControls ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _ShowNonSysInPlaceEncUIStatus
_TEXT	SEGMENT
_nonSysInplaceEncUIStatus$ = -604			; size = 600
__$ArrayPad$ = -4					; size = 4
_ShowNonSysInPlaceEncUIStatus PROC			; COMDAT

; 2148 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 02 00
	00		 sub	 esp, 604		; 0000025cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	68 58 02 00 00	 push	 600			; 00000258H
  00018	8d 85 a4 fd ff
	ff		 lea	 eax, DWORD PTR _nonSysInplaceEncUIStatus$[ebp]
  0001e	6a 00		 push	 0
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _memset

; 2149 : 	wchar_t nonSysInplaceEncUIStatus [300] = {0};
; 2150 : 
; 2151 : 	switch (NonSysInplaceEncStatus)

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR _NonSysInplaceEncStatus
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	48		 dec	 eax
  0002f	83 f8 06	 cmp	 eax, 6
  00032	0f 87 48 01 00
	00		 ja	 $LN2@ShowNonSys
  00038	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN42@ShowNonSys[eax*4]
$LN4@ShowNonSys:

; 2152 : 	{
; 2153 : 	case NONSYS_INPLACE_ENC_STATUS_PAUSED:
; 2154 : 		wcscpy (nonSysInplaceEncUIStatus, GetString ("PROGRESS_STATUS_PAUSED"));

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LLAADOBF@PROGRESS_STATUS_PAUSED?$AA@
  00044	e8 00 00 00 00	 call	 _GetString
  00049	8d 95 a4 fd ff
	ff		 lea	 edx, DWORD PTR _nonSysInplaceEncUIStatus$[ebp]
  0004f	83 c4 04	 add	 esp, 4
  00052	2b d0		 sub	 edx, eax
$LL12@ShowNonSys:
  00054	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00057	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  0005a	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0005f	66 85 c9	 test	 cx, cx
  00062	75 f0		 jne	 SHORT $LL12@ShowNonSys

; 2155 : 		break;

  00064	e9 17 01 00 00	 jmp	 $LN2@ShowNonSys
$LN5@ShowNonSys:

; 2156 : 	case NONSYS_INPLACE_ENC_STATUS_PREPARING:
; 2157 : 		wcscpy (nonSysInplaceEncUIStatus, GetString ("PROGRESS_STATUS_PREPARING"));

  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@NECHGBNE@PROGRESS_STATUS_PREPARING?$AA@
  0006e	e8 00 00 00 00	 call	 _GetString
  00073	8d 95 a4 fd ff
	ff		 lea	 edx, DWORD PTR _nonSysInplaceEncUIStatus$[ebp]
  00079	83 c4 04	 add	 esp, 4
  0007c	2b d0		 sub	 edx, eax
  0007e	66 90		 npad	 2
$LL13@ShowNonSys:
  00080	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00083	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00086	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0008b	66 85 c9	 test	 cx, cx
  0008e	75 f0		 jne	 SHORT $LL13@ShowNonSys

; 2158 : 		break;

  00090	e9 eb 00 00 00	 jmp	 $LN2@ShowNonSys
$LN6@ShowNonSys:

; 2159 : 	case NONSYS_INPLACE_ENC_STATUS_RESIZING:
; 2160 : 		wcscpy (nonSysInplaceEncUIStatus, GetString ("PROGRESS_STATUS_RESIZING"));

  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EIBDNDIC@PROGRESS_STATUS_RESIZING?$AA@
  0009a	e8 00 00 00 00	 call	 _GetString
  0009f	8d 95 a4 fd ff
	ff		 lea	 edx, DWORD PTR _nonSysInplaceEncUIStatus$[ebp]
  000a5	83 c4 04	 add	 esp, 4
  000a8	2b d0		 sub	 edx, eax
  000aa	66 0f 1f 44 00
	00		 npad	 6
$LL14@ShowNonSys:
  000b0	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000b3	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  000b6	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  000bb	66 85 c9	 test	 cx, cx
  000be	75 f0		 jne	 SHORT $LL14@ShowNonSys

; 2161 : 		break;

  000c0	e9 bb 00 00 00	 jmp	 $LN2@ShowNonSys
$LN7@ShowNonSys:

; 2162 : 	case NONSYS_INPLACE_ENC_STATUS_ENCRYPTING:
; 2163 : 		wcscpy (nonSysInplaceEncUIStatus, GetString ("PROGRESS_STATUS_ENCRYPTING"));

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PONBLMNB@PROGRESS_STATUS_ENCRYPTING?$AA@
  000ca	e8 00 00 00 00	 call	 _GetString
  000cf	8d 95 a4 fd ff
	ff		 lea	 edx, DWORD PTR _nonSysInplaceEncUIStatus$[ebp]
  000d5	83 c4 04	 add	 esp, 4
  000d8	2b d0		 sub	 edx, eax
  000da	66 0f 1f 44 00
	00		 npad	 6
$LL15@ShowNonSys:
  000e0	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000e3	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  000e6	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  000eb	66 85 c9	 test	 cx, cx
  000ee	75 f0		 jne	 SHORT $LL15@ShowNonSys

; 2164 : 		break;

  000f0	e9 8b 00 00 00	 jmp	 $LN2@ShowNonSys
$LN8@ShowNonSys:

; 2165 : 	case NONSYS_INPLACE_ENC_STATUS_FINALIZING:
; 2166 : 		wcscpy (nonSysInplaceEncUIStatus, GetString ("PROGRESS_STATUS_FINALIZING"));

  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CIJLEOGN@PROGRESS_STATUS_FINALIZING?$AA@
  000fa	e8 00 00 00 00	 call	 _GetString
  000ff	8d 95 a4 fd ff
	ff		 lea	 edx, DWORD PTR _nonSysInplaceEncUIStatus$[ebp]
  00105	83 c4 04	 add	 esp, 4
  00108	2b d0		 sub	 edx, eax
  0010a	66 0f 1f 44 00
	00		 npad	 6
$LL16@ShowNonSys:
  00110	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00113	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00116	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0011b	66 85 c9	 test	 cx, cx
  0011e	75 f0		 jne	 SHORT $LL16@ShowNonSys

; 2167 : 		break;

  00120	eb 5e		 jmp	 SHORT $LN2@ShowNonSys
$LN9@ShowNonSys:

; 2168 : 	case NONSYS_INPLACE_ENC_STATUS_FINISHED:
; 2169 : 		wcscpy (nonSysInplaceEncUIStatus, GetString ("PROGRESS_STATUS_FINISHED"));

  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HKENJBII@PROGRESS_STATUS_FINISHED?$AA@
  00127	e8 00 00 00 00	 call	 _GetString
  0012c	8d 95 a4 fd ff
	ff		 lea	 edx, DWORD PTR _nonSysInplaceEncUIStatus$[ebp]
  00132	83 c4 04	 add	 esp, 4
  00135	2b d0		 sub	 edx, eax
  00137	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL17@ShowNonSys:
  00140	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00143	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00146	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0014b	66 85 c9	 test	 cx, cx
  0014e	75 f0		 jne	 SHORT $LL17@ShowNonSys

; 2170 : 		break;

  00150	eb 2e		 jmp	 SHORT $LN2@ShowNonSys
$LN10@ShowNonSys:

; 2171 : 	case NONSYS_INPLACE_ENC_STATUS_ERROR:
; 2172 : 		wcscpy (nonSysInplaceEncUIStatus, GetString ("PROGRESS_STATUS_ERROR"));

  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IDPLALHN@PROGRESS_STATUS_ERROR?$AA@
  00157	e8 00 00 00 00	 call	 _GetString
  0015c	8d 95 a4 fd ff
	ff		 lea	 edx, DWORD PTR _nonSysInplaceEncUIStatus$[ebp]
  00162	83 c4 04	 add	 esp, 4
  00165	2b d0		 sub	 edx, eax
  00167	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@ShowNonSys:
  00170	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00173	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00176	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0017b	66 85 c9	 test	 cx, cx
  0017e	75 f0		 jne	 SHORT $LL18@ShowNonSys
$LN2@ShowNonSys:
  00180	57		 push	 edi

; 2173 : 		break;
; 2174 : 	}
; 2175 : 
; 2176 : 	wcscat (nonSysInplaceEncUIStatus, L" ");

  00181	8d bd a4 fd ff
	ff		 lea	 edi, DWORD PTR _nonSysInplaceEncUIStatus$[ebp]
  00187	83 c7 fe	 add	 edi, -2			; fffffffeH
  0018a	66 0f 1f 44 00
	00		 npad	 6
$LL40@ShowNonSys:
  00190	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00194	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]
  00197	66 85 c0	 test	 ax, ax
  0019a	75 f4		 jne	 SHORT $LL40@ShowNonSys
  0019c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  001a1	89 07		 mov	 DWORD PTR [edi], eax

; 2177 : 
; 2178 : 	SetWindowTextW (GetDlgItem (hCurPage, IDC_WRITESPEED), nonSysInplaceEncUIStatus);

  001a3	8d 85 a4 fd ff
	ff		 lea	 eax, DWORD PTR _nonSysInplaceEncUIStatus$[ebp]
  001a9	50		 push	 eax
  001aa	68 01 04 00 00	 push	 1025			; 00000401H
  001af	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001bb	50		 push	 eax
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 2179 : }

  001c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c5	33 cd		 xor	 ecx, ebp
  001c7	5f		 pop	 edi
  001c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cd	8b e5		 mov	 esp, ebp
  001cf	5d		 pop	 ebp
  001d0	c3		 ret	 0
  001d1	0f 1f 00	 npad	 3
$LN42@ShowNonSys:
  001d4	00 00 00 00	 DD	 $LN5@ShowNonSys
  001d8	00 00 00 00	 DD	 $LN6@ShowNonSys
  001dc	00 00 00 00	 DD	 $LN7@ShowNonSys
  001e0	00 00 00 00	 DD	 $LN8@ShowNonSys
  001e4	00 00 00 00	 DD	 $LN4@ShowNonSys
  001e8	00 00 00 00	 DD	 $LN9@ShowNonSys
  001ec	00 00 00 00	 DD	 $LN10@ShowNonSys
_ShowNonSysInPlaceEncUIStatus ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _NonSysInplaceEncResume
_TEXT	SEGMENT
_NonSysInplaceEncResume PROC				; COMDAT

; 2112 : 	if (bVolTransformThreadRunning || bVolTransformThreadToRun || bVolTransformThreadCancel)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  00007	0f 85 80 00 00
	00		 jne	 $LN3@NonSysInpl
  0000d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  00014	75 77		 jne	 SHORT $LN3@NonSysInpl
  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bVolTransformThreadCancel, 0
  0001d	75 6e		 jne	 SHORT $LN3@NonSysInpl

; 2113 : 		return;
; 2114 : 
; 2115 : 	if (!bInPlaceEncNonSysResumed
; 2116 : 		&& !FinalPreTransformPrompts ())

  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSysResumed, 0
  00026	75 09		 jne	 SHORT $LN4@NonSysInpl
  00028	e8 00 00 00 00	 call	 _FinalPreTransformPrompts
  0002d	85 c0		 test	 eax, eax
  0002f	74 5c		 je	 SHORT $LN3@NonSysInpl
$LN4@NonSysInpl:

; 2117 : 	{
; 2118 : 		return;
; 2119 : 	}
; 2120 : 
; 2121 : 	CreateNonSysInplaceEncMutex ();

  00031	e8 00 00 00 00	 call	 _CreateNonSysInplaceEncMutex

; 2122 : 
; 2123 : 	bFirstNonSysInPlaceEncResumeDone = TRUE;
; 2124 : 
; 2125 : 	SetTimer (MainDlg, TIMER_ID_NONSYS_INPLACE_ENC_PROGRESS, TIMER_INTERVAL_NONSYS_INPLACE_ENC_PROGRESS, NULL);

  00036	6a 00		 push	 0
  00038	6a 1e		 push	 30			; 0000001eH
  0003a	68 01 01 00 00	 push	 257			; 00000101H
  0003f	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00045	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bFirstNonSysInPlaceEncResumeDone, 1
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 2126 : 
; 2127 : 	bVolTransformThreadCancel = FALSE;

  00055	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bVolTransformThreadCancel, 0

; 2128 : 	bVolTransformThreadToRun = TRUE;

  0005f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 1 ; bVolTransformThreadToRun

; 2129 : 
; 2130 : 	UpdateNonSysInPlaceEncControls ();

  00069	e8 00 00 00 00	 call	 _UpdateNonSysInPlaceEncControls

; 2131 : 
; 2132 : 	LastDialogId = "NONSYS_INPLACE_ENC_IN_PROGRESS";
; 2133 : 
; 2134 : 	_beginthread (volTransformThreadFunction, 0, MainDlg);

  0006e	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00074	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LastDialogId, OFFSET ??_C@_0BP@CJOANMAM@NONSYS_INPLACE_ENC_IN_PROGRESS?$AA@
  0007e	6a 00		 push	 0
  00080	68 00 00 00 00	 push	 OFFSET _volTransformThreadFunction
  00085	e8 00 00 00 00	 call	 __beginthread
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@NonSysInpl:

; 2135 : 
; 2136 : 	return;
; 2137 : }

  0008d	c3		 ret	 0
_NonSysInplaceEncResume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _NonSysInplaceEncPause
_TEXT	SEGMENT
_guiMsg$1 = -28						; size = 28
_NonSysInplaceEncPause PROC				; COMDAT

; 2075 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2076 : 	bVolTransformThreadCancel = TRUE;

  00006	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bVolTransformThreadCancel, 1
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2077 : 
; 2078 : 	WaitCursor ();

  00013	e8 00 00 00 00	 call	 _WaitCursor

; 2079 : 
; 2080 : 	int waitThreshold = 100;	// Do not block GUI events for more than 10 seconds. IMPORTANT: This prevents deadlocks when the thread calls us back e.g. to update GUI!

  00018	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__PeekMessageA@20
  0001e	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
  00023	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DispatchMessageA@4
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@NonSysInpl:

; 2081 : 	
; 2082 : 	while (bVolTransformThreadRunning || bVolTransformThreadToRun)

  00030	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  00037	75 09		 jne	 SHORT $LN6@NonSysInpl
  00039	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  00040	74 4d		 je	 SHORT $LN3@NonSysInpl
$LN6@NonSysInpl:

; 2083 : 	{
; 2084 : 		MSG guiMsg;
; 2085 : 
; 2086 : 		bVolTransformThreadCancel = TRUE;

  00042	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bVolTransformThreadCancel, 1

; 2087 : 
; 2088 : 		if (waitThreshold <= 0)

  0004c	85 ff		 test	 edi, edi
  0004e	7f 34		 jg	 SHORT $LN7@NonSysInpl

; 2089 : 		{
; 2090 : 			while (PeekMessage (&guiMsg, NULL, 0, 0, PM_REMOVE) != 0)

  00050	6a 01		 push	 1
  00052	6a 00		 push	 0
  00054	6a 00		 push	 0
  00056	6a 00		 push	 0
  00058	8d 45 e4	 lea	 eax, DWORD PTR _guiMsg$1[ebp]
  0005b	50		 push	 eax
  0005c	ff d6		 call	 esi
  0005e	85 c0		 test	 eax, eax
  00060	74 23		 je	 SHORT $LN8@NonSysInpl
$LL4@NonSysInpl:

; 2091 : 			{
; 2092 : 				DispatchMessage (&guiMsg);

  00062	8d 45 e4	 lea	 eax, DWORD PTR _guiMsg$1[ebp]
  00065	50		 push	 eax
  00066	ff d3		 call	 ebx
  00068	6a 01		 push	 1
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	8d 45 e4	 lea	 eax, DWORD PTR _guiMsg$1[ebp]
  00073	50		 push	 eax
  00074	ff d6		 call	 esi
  00076	85 c0		 test	 eax, eax
  00078	75 e8		 jne	 SHORT $LL4@NonSysInpl

; 2097 : 
; 2098 : 		Sleep (100);

  0007a	6a 64		 push	 100			; 00000064H
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 2099 : 	}

  00082	eb ac		 jmp	 SHORT $LL2@NonSysInpl
$LN7@NonSysInpl:

; 2093 : 			}
; 2094 : 		}
; 2095 : 		else
; 2096 : 			waitThreshold--;

  00084	4f		 dec	 edi
$LN8@NonSysInpl:

; 2097 : 
; 2098 : 		Sleep (100);

  00085	6a 64		 push	 100			; 00000064H
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 2099 : 	}

  0008d	eb a1		 jmp	 SHORT $LL2@NonSysInpl
$LN3@NonSysInpl:
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx

; 2100 : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_NonSysInplaceEncPause ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _CreatingHiddenSysVol
_TEXT	SEGMENT
_CreatingHiddenSysVol PROC				; COMDAT

; 724  : 	return (bHiddenOS 

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00007	74 18		 je	 SHORT $LN3@CreatingHi
  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00010	74 0f		 je	 SHORT $LN3@CreatingHi
  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00019	75 06		 jne	 SHORT $LN3@CreatingHi
  0001b	b8 01 00 00 00	 mov	 eax, 1

; 725  : 		&& bHiddenVol && !bHiddenVolHost);
; 726  : }

  00020	c3		 ret	 0
$LN3@CreatingHi:

; 724  : 	return (bHiddenOS 

  00021	33 c0		 xor	 eax, eax

; 725  : 		&& bHiddenVol && !bHiddenVolHost);
; 726  : }

  00023	c3		 ret	 0
_CreatingHiddenSysVol ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _SysEncInEffect
_TEXT	SEGMENT
_SysEncInEffect PROC					; COMDAT

; 711  : 	return (WizardMode == WIZARD_MODE_SYS_DEVICE

  00000	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  00007	74 1e		 je	 SHORT $LN3@SysEncInEf
  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00010	74 12		 je	 SHORT $LN7@SysEncInEf
  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00019	74 09		 je	 SHORT $LN7@SysEncInEf
  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00022	74 03		 je	 SHORT $LN3@SysEncInEf
$LN7@SysEncInEf:
  00024	33 c0		 xor	 eax, eax

; 712  : 		|| CreatingHiddenSysVol());
; 713  : }

  00026	c3		 ret	 0
$LN3@SysEncInEf:

; 711  : 	return (WizardMode == WIZARD_MODE_SYS_DEVICE

  00027	b8 01 00 00 00	 mov	 eax, 1

; 712  : 		|| CreatingHiddenSysVol());
; 713  : }

  0002c	c3		 ret	 0
_SysEncInEffect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _UpdateNonSysInplaceEncProgressBar
_TEXT	SEGMENT
_UpdateNonSysInplaceEncProgressBar PROC			; COMDAT

; 2261 : {

  00000	56		 push	 esi

; 2262 : 	static int lastNonSysInplaceEncStatus = NONSYS_INPLACE_ENC_STATUS_NONE;
; 2263 : 	int nonSysInplaceEncStatus = NonSysInplaceEncStatus;

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _NonSysInplaceEncStatus

; 2264 : 	__int64 totalSize = NonSysInplaceEncTotalSize;
; 2265 : 
; 2266 : 	if (bVolTransformThreadRunning 
; 2267 : 		&& (nonSysInplaceEncStatus == NONSYS_INPLACE_ENC_STATUS_ENCRYPTING

  00007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR _NonSysInplaceEncTotalSize
  00013	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _NonSysInplaceEncTotalSize+4
  00019	74 71		 je	 SHORT $LN7@UpdateNonS
  0001b	83 fe 03	 cmp	 esi, 3
  0001e	74 0a		 je	 SHORT $LN3@UpdateNonS
  00020	83 fe 04	 cmp	 esi, 4
  00023	74 05		 je	 SHORT $LN3@UpdateNonS
  00025	83 fe 06	 cmp	 esi, 6
  00028	75 62		 jne	 SHORT $LN7@UpdateNonS
$LN3@UpdateNonS:

; 2268 : 		|| nonSysInplaceEncStatus == NONSYS_INPLACE_ENC_STATUS_FINALIZING
; 2269 : 		|| nonSysInplaceEncStatus == NONSYS_INPLACE_ENC_STATUS_FINISHED))
; 2270 : 	{
; 2271 : 		if (lastNonSysInplaceEncStatus != nonSysInplaceEncStatus
; 2272 : 			&& nonSysInplaceEncStatus == NONSYS_INPLACE_ENC_STATUS_ENCRYPTING)

  0002a	39 35 00 00 00
	00		 cmp	 DWORD PTR ?lastNonSysInplaceEncStatus@?1??UpdateNonSysInplaceEncProgressBar@@9@4HA, esi
  00030	74 17		 je	 SHORT $LN4@UpdateNonS
  00032	83 fe 03	 cmp	 esi, 3
  00035	75 12		 jne	 SHORT $LN4@UpdateNonS

; 2273 : 		{
; 2274 : 			InitNonSysInplaceEncProgressBar ();

  00037	e8 00 00 00 00	 call	 _InitNonSysInplaceEncProgressBar

; 2283 : 		}
; 2284 : 	}
; 2285 : 
; 2286 : 	ShowNonSysInPlaceEncUIStatus ();

  0003c	e8 00 00 00 00	 call	 _ShowNonSysInPlaceEncUIStatus

; 2287 : 
; 2288 : 	lastNonSysInplaceEncStatus = nonSysInplaceEncStatus;

  00041	89 35 00 00 00
	00		 mov	 DWORD PTR ?lastNonSysInplaceEncStatus@?1??UpdateNonSysInplaceEncProgressBar@@9@4HA, esi
  00047	5e		 pop	 esi

; 2289 : }

  00048	c3		 ret	 0
$LN4@UpdateNonS:

; 2275 : 		}
; 2276 : 		else
; 2277 : 		{
; 2278 : 			if (totalSize <= 0 && nVolumeSize > 0)

  00049	85 c9		 test	 ecx, ecx
  0004b	7f 2b		 jg	 SHORT $LN12@UpdateNonS
  0004d	7c 04		 jl	 SHORT $LN10@UpdateNonS
  0004f	85 c0		 test	 eax, eax
  00051	75 25		 jne	 SHORT $LN12@UpdateNonS
$LN10@UpdateNonS:
  00053	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?nVolumeSize@@3_KA+4, 0
  0005a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?nVolumeSize@@3_KA
  00060	77 04		 ja	 SHORT $LN11@UpdateNonS
  00062	85 d2		 test	 edx, edx
  00064	74 08		 je	 SHORT $LN6@UpdateNonS
$LN11@UpdateNonS:

; 2279 : 				totalSize = nVolumeSize;

  00066	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?nVolumeSize@@3_KA+4
  0006c	8b c2		 mov	 eax, edx
$LN6@UpdateNonS:

; 2280 : 
; 2281 : 			if (totalSize > 0)

  0006e	85 c9		 test	 ecx, ecx
  00070	7c 1a		 jl	 SHORT $LN7@UpdateNonS
  00072	7f 04		 jg	 SHORT $LN12@UpdateNonS
  00074	85 c0		 test	 eax, eax
  00076	74 14		 je	 SHORT $LN7@UpdateNonS
$LN12@UpdateNonS:

; 2282 : 				UpdateProgressBarProc (NonSysInplaceEncBytesDone);

  00078	ff 35 04 00 00
	00		 push	 DWORD PTR _NonSysInplaceEncBytesDone+4
  0007e	ff 35 00 00 00
	00		 push	 DWORD PTR _NonSysInplaceEncBytesDone
  00084	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00089	83 c4 08	 add	 esp, 8
$LN7@UpdateNonS:

; 2283 : 		}
; 2284 : 	}
; 2285 : 
; 2286 : 	ShowNonSysInPlaceEncUIStatus ();

  0008c	e8 00 00 00 00	 call	 _ShowNonSysInPlaceEncUIStatus

; 2287 : 
; 2288 : 	lastNonSysInplaceEncStatus = nonSysInplaceEncStatus;

  00091	89 35 00 00 00
	00		 mov	 DWORD PTR ?lastNonSysInplaceEncStatus@?1??UpdateNonSysInplaceEncProgressBar@@9@4HA, esi
  00097	5e		 pop	 esi

; 2289 : }

  00098	c3		 ret	 0
_UpdateNonSysInplaceEncProgressBar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _InitNonSysInplaceEncProgressBar
_TEXT	SEGMENT
_InitNonSysInplaceEncProgressBar PROC			; COMDAT

; 2301 : 	__int64 totalSize = NonSysInplaceEncTotalSize;

  00000	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _NonSysInplaceEncTotalSize+4
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _NonSysInplaceEncTotalSize

; 2302 : 
; 2303 : 	if (totalSize <= 0)

  0000b	85 c9		 test	 ecx, ecx
  0000d	7f 19		 jg	 SHORT $LN2@InitNonSys
  0000f	7c 04		 jl	 SHORT $LN5@InitNonSys
  00011	85 c0		 test	 eax, eax
  00013	75 13		 jne	 SHORT $LN2@InitNonSys
$LN5@InitNonSys:

; 2304 : 	{
; 2305 : 		if (nVolumeSize <= 0)

  00015	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?nVolumeSize@@3_KA+4
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nVolumeSize@@3_KA
  00020	85 c9		 test	 ecx, ecx
  00022	75 04		 jne	 SHORT $LN2@InitNonSys
  00024	85 c0		 test	 eax, eax
  00026	74 1e		 je	 SHORT $LN1@InitNonSys
$LN2@InitNonSys:

; 2306 : 			return;
; 2307 : 
; 2308 : 		totalSize = nVolumeSize;
; 2309 : 	}
; 2310 : 
; 2311 : 	InitProgressBar (totalSize,

  00028	6a 01		 push	 1
  0002a	6a 01		 push	 1
  0002c	6a 01		 push	 1
  0002e	6a 00		 push	 0
  00030	ff 35 04 00 00
	00		 push	 DWORD PTR _NonSysInplaceEncBytesDone+4
  00036	ff 35 00 00 00
	00		 push	 DWORD PTR _NonSysInplaceEncBytesDone
  0003c	51		 push	 ecx
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _InitProgressBar
  00043	83 c4 20	 add	 esp, 32			; 00000020H
$LN1@InitNonSys:

; 2312 : 		NonSysInplaceEncBytesDone,
; 2313 : 		FALSE,
; 2314 : 		TRUE,
; 2315 : 		TRUE,
; 2316 : 		TRUE);
; 2317 : }

  00046	c3		 ret	 0
_InitNonSysInplaceEncProgressBar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _InitSysEncProgressBar
_TEXT	SEGMENT
_locBootEncStatus$ = -220				; size = 94
tv80 = -124						; size = 8
$T2 = -116						; size = 94
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_InitSysEncProgressBar PROC				; COMDAT

; 1759 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_InitSysEncProgressBar
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1760 : 	BootEncryptionStatus locBootEncStatus;
; 1761 : 
; 1762 : 	try
; 1763 : 	{
; 1764 : 		locBootEncStatus = BootEncObj->GetStatus();

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00037	8d 45 8c	 lea	 eax, DWORD PTR $T2[ebp]
  0003a	50		 push	 eax
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00042	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00047	8b f0		 mov	 esi, eax
  00049	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$[ebp]
  0004f	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00054	f3 a5		 rep movsd
  00056	66 a5		 movsw

; 1769 : 	}
; 1770 : 
; 1771 : 	if (locBootEncStatus.ConfiguredEncryptedAreaEnd == -1 
; 1772 : 		|| locBootEncStatus.ConfiguredEncryptedAreaStart == -1)

  00058	8b b5 46 ff ff
	ff		 mov	 esi, DWORD PTR _locBootEncStatus$[ebp+34]
  0005e	8b c6		 mov	 eax, esi
  00060	8b bd 4a ff ff
	ff		 mov	 edi, DWORD PTR _locBootEncStatus$[ebp+38]
  00066	23 c7		 and	 eax, edi
  00068	83 f8 ff	 cmp	 eax, -1
  0006b	0f 84 8a 00 00
	00		 je	 $LN11@InitSysEnc
  00071	8b 85 3e ff ff
	ff		 mov	 eax, DWORD PTR _locBootEncStatus$[ebp+26]
  00077	23 85 42 ff ff
	ff		 and	 eax, DWORD PTR _locBootEncStatus$[ebp+30]
  0007d	83 f8 ff	 cmp	 eax, -1
  00080	74 79		 je	 SHORT $LN11@InitSysEnc

; 1773 : 		return;
; 1774 : 
; 1775 : 	InitProgressBar (locBootEncStatus.ConfiguredEncryptedAreaEnd 

  00082	8b 95 56 ff ff
	ff		 mov	 edx, DWORD PTR _locBootEncStatus$[ebp+50]
  00088	8b 8d 5a ff ff
	ff		 mov	 ecx, DWORD PTR _locBootEncStatus$[ebp+54]
  0008e	8b 9d 52 ff ff
	ff		 mov	 ebx, DWORD PTR _locBootEncStatus$[ebp+46]
  00094	3b 95 4e ff ff
	ff		 cmp	 edx, DWORD PTR _locBootEncStatus$[ebp+42]
  0009a	75 04		 jne	 SHORT $LN12@InitSysEnc
  0009c	3b cb		 cmp	 ecx, ebx
  0009e	74 19		 je	 SHORT $LN6@InitSysEnc
$LN12@InitSysEnc:
  000a0	8b c2		 mov	 eax, edx
  000a2	23 c1		 and	 eax, ecx
  000a4	83 f8 ff	 cmp	 eax, -1
  000a7	74 10		 je	 SHORT $LN6@InitSysEnc
  000a9	2b 95 4e ff ff
	ff		 sub	 edx, DWORD PTR _locBootEncStatus$[ebp+42]
  000af	1b cb		 sbb	 ecx, ebx
  000b1	83 c2 01	 add	 edx, 1
  000b4	83 d1 00	 adc	 ecx, 0
  000b7	eb 0e		 jmp	 SHORT $LN7@InitSysEnc
$LN6@InitSysEnc:
  000b9	0f 57 c0	 xorps	 xmm0, xmm0
  000bc	66 0f 13 45 84	 movlpd	 QWORD PTR tv80[ebp], xmm0
  000c1	8b 4d 88	 mov	 ecx, DWORD PTR tv80[ebp+4]
  000c4	8b 55 84	 mov	 edx, DWORD PTR tv80[ebp]
$LN7@InitSysEnc:
  000c7	33 c0		 xor	 eax, eax
  000c9	81 3d 00 00 00
	00 58 02 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 600 ; 00000258H
  000d3	6a 01		 push	 1
  000d5	6a 01		 push	 1
  000d7	0f 94 c0	 sete	 al
  000da	2b b5 3e ff ff
	ff		 sub	 esi, DWORD PTR _locBootEncStatus$[ebp+26]
  000e0	6a 01		 push	 1
  000e2	1b bd 42 ff ff
	ff		 sbb	 edi, DWORD PTR _locBootEncStatus$[ebp+30]
  000e8	83 c6 01	 add	 esi, 1
  000eb	50		 push	 eax
  000ec	51		 push	 ecx
  000ed	52		 push	 edx
  000ee	83 d7 00	 adc	 edi, 0
  000f1	57		 push	 edi
  000f2	56		 push	 esi
  000f3	e8 00 00 00 00	 call	 _InitProgressBar
  000f8	83 c4 20	 add	 esp, 32			; 00000020H
$LN11@InitSysEnc:

; 1776 : 		- locBootEncStatus.ConfiguredEncryptedAreaStart + 1,
; 1777 : 		(locBootEncStatus.EncryptedAreaEnd == locBootEncStatus.EncryptedAreaStart || locBootEncStatus.EncryptedAreaEnd == -1) ?
; 1778 : 		0 :	locBootEncStatus.EncryptedAreaEnd - locBootEncStatus.EncryptedAreaStart + 1,
; 1779 : 		SystemEncryptionStatus == SYSENC_STATUS_DECRYPTING,
; 1780 : 		TRUE,
; 1781 : 		TRUE,
; 1782 : 		TRUE);
; 1783 : }

  000fb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00105	59		 pop	 ecx
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010c	33 cd		 xor	 ecx, ebp
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
__catch$_InitSysEncProgressBar$0:

; 1765 : 	}
; 1766 : 	catch (...)
; 1767 : 	{
; 1768 : 		return;

  00117	b8 00 00 00 00	 mov	 eax, $LN11@InitSysEnc
  0011c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_InitSysEncProgressBar:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 20 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-224]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_InitSysEncProgressBar
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_InitSysEncProgressBar ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _AfterSysEncProgressWMInitTasks
_TEXT	SEGMENT
_e$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_hwndDlg$ = 8						; size = 4
_AfterSysEncProgressWMInitTasks PROC			; COMDAT

; 9007 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_AfterSysEncProgressWMInitTasks
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 9008 : 	try
; 9009 : 	{
; 9010 : 		switch (SystemEncryptionStatus)

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionStatus
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00037	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  0003c	0f 84 90 00 00
	00		 je	 $LN5@AfterSysEn
  00042	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  00047	0f 84 63 01 00
	00		 je	 $LN6@AfterSysEn

; 9030 : 			}
; 9031 : 
; 9032 : 			break;
; 9033 : 
; 9034 : 		case SYSENC_STATUS_DECRYPTING:
; 9035 : 			SysEncResume ();
; 9036 : 			break;
; 9037 : 
; 9038 : 		default:
; 9039 : 
; 9040 : 			// Unexpected mode here -- fix the inconsistency
; 9041 : 
; 9042 : 			ManageStartupSeqWiz (TRUE, "");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00052	6a 01		 push	 1
  00054	e8 00 00 00 00	 call	 _ManageStartupSeqWiz
  00059	83 c4 08	 add	 esp, 8

; 9043 : 			ChangeSystemEncryptionStatus (SYSENC_STATUS_NONE);

  0005c	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00061	85 c0		 test	 eax, eax
  00063	75 0c		 jne	 SHORT $LN23@AfterSysEn
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  0006a	e8 00 00 00 00	 call	 _Error
  0006f	eb 44		 jmp	 SHORT $LN30@AfterSysEn
$LN23@AfterSysEn:
  00071	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SystemEncryptionStatus, 0
  0007b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 1
  00085	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  0008a	85 c0		 test	 eax, eax
  0008c	75 1c		 jne	 SHORT $LN25@AfterSysEn
  0008e	e8 00 00 00 00	 call	 ?DetermineHiddenOSCreationPhase@@YAIXZ ; DetermineHiddenOSCreationPhase
  00093	85 c0		 test	 eax, eax
  00095	74 0e		 je	 SHORT $LN26@AfterSysEn
  00097	6a 00		 push	 0
  00099	e8 00 00 00 00	 call	 ?ChangeHiddenOSCreationPhase@@YAHH@Z ; ChangeHiddenOSCreationPhase
  0009e	83 c4 04	 add	 esp, 4
  000a1	85 c0		 test	 eax, eax
  000a3	74 13		 je	 SHORT $LN27@AfterSysEn
$LN26@AfterSysEn:
  000a5	e8 00 00 00 00	 call	 _WipeHiddenOSCreationConfig
$LN25@AfterSysEn:
  000aa	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000b0	e8 00 00 00 00	 call	 ?SaveSysEncSettings@@YAHPAUHWND__@@@Z ; SaveSysEncSettings
$LN30@AfterSysEn:
  000b5	83 c4 04	 add	 esp, 4
$LN27@AfterSysEn:

; 9044 : 			EndMainDlg (MainDlg);

  000b8	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000be	e8 00 00 00 00	 call	 _EndMainDlg

; 9045 : 			InconsistencyResolved (SRC_POS);

  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@GLPLHHCP@AfterSysEncProgressWMInitTasks?39@
  000c8	e8 00 00 00 00	 call	 _InconsistencyResolved
  000cd	e9 c9 00 00 00	 jmp	 $LN31@AfterSysEn
$LN5@AfterSysEn:

; 9011 : 		{
; 9012 : 		case SYSENC_STATUS_ENCRYPTING:
; 9013 : 
; 9014 : 			if (BootEncStatus.ConfiguredEncryptedAreaStart == BootEncStatus.EncryptedAreaStart
; 9015 : 				&& BootEncStatus.ConfiguredEncryptedAreaEnd == BootEncStatus.EncryptedAreaEnd)

  000d2	a1 1a 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+26
  000d7	3b 05 2a 00 00
	00		 cmp	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+42
  000dd	0f 85 cd 00 00
	00		 jne	 $LN6@AfterSysEn
  000e3	a1 1e 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+30
  000e8	3b 05 2e 00 00
	00		 cmp	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+46
  000ee	0f 85 bc 00 00
	00		 jne	 $LN6@AfterSysEn
  000f4	a1 22 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+34
  000f9	3b 05 32 00 00
	00		 cmp	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+50
  000ff	0f 85 ab 00 00
	00		 jne	 $LN6@AfterSysEn
  00105	a1 26 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+38
  0010a	3b 05 36 00 00
	00		 cmp	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+54
  00110	0f 85 9a 00 00
	00		 jne	 $LN6@AfterSysEn

; 9016 : 			{
; 9017 : 				// The partition/drive had been fully encrypted
; 9018 : 
; 9019 : 				ManageStartupSeqWiz (TRUE, "");

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0011b	6a 01		 push	 1
  0011d	e8 00 00 00 00	 call	 _ManageStartupSeqWiz
  00122	83 c4 08	 add	 esp, 8

; 9020 : 				WipeHiddenOSCreationConfig();	// For extra conservative security

  00125	e8 00 00 00 00	 call	 _WipeHiddenOSCreationConfig

; 9021 : 				ChangeSystemEncryptionStatus (SYSENC_STATUS_NONE);

  0012a	e8 00 00 00 00	 call	 _CreateSysEncMutex
  0012f	85 c0		 test	 eax, eax
  00131	75 0c		 jne	 SHORT $LN16@AfterSysEn
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00138	e8 00 00 00 00	 call	 _Error
  0013d	eb 44		 jmp	 SHORT $LN32@AfterSysEn
$LN16@AfterSysEn:
  0013f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SystemEncryptionStatus, 0
  00149	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 1
  00153	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  00158	85 c0		 test	 eax, eax
  0015a	75 1c		 jne	 SHORT $LN18@AfterSysEn
  0015c	e8 00 00 00 00	 call	 ?DetermineHiddenOSCreationPhase@@YAIXZ ; DetermineHiddenOSCreationPhase
  00161	85 c0		 test	 eax, eax
  00163	74 0e		 je	 SHORT $LN19@AfterSysEn
  00165	6a 00		 push	 0
  00167	e8 00 00 00 00	 call	 ?ChangeHiddenOSCreationPhase@@YAHH@Z ; ChangeHiddenOSCreationPhase
  0016c	83 c4 04	 add	 esp, 4
  0016f	85 c0		 test	 eax, eax
  00171	74 13		 je	 SHORT $LN20@AfterSysEn
$LN19@AfterSysEn:
  00173	e8 00 00 00 00	 call	 _WipeHiddenOSCreationConfig
$LN18@AfterSysEn:
  00178	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0017e	e8 00 00 00 00	 call	 ?SaveSysEncSettings@@YAHPAUHWND__@@@Z ; SaveSysEncSettings
$LN32@AfterSysEn:
  00183	83 c4 04	 add	 esp, 4
$LN20@AfterSysEn:

; 9022 : 
; 9023 : 				Info ("SYSTEM_ENCRYPTION_FINISHED");

  00186	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LJPGNBNM@SYSTEM_ENCRYPTION_FINISHED?$AA@
  0018b	e8 00 00 00 00	 call	 _Info

; 9024 : 				EndMainDlg (MainDlg);

  00190	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00196	e8 00 00 00 00	 call	 _EndMainDlg
$LN31@AfterSysEn:
  0019b	83 c4 08	 add	 esp, 8
$LN14@AfterSysEn:

; 9054 : 	}
; 9055 : 
; 9056 : 	InitSysEncProgressBar ();
; 9057 : 
; 9058 : 	UpdateSysEncProgressBar ();
; 9059 : 
; 9060 : 	UpdateSysEncControls ();
; 9061 : }

  0019e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a8	59		 pop	 ecx
  001a9	5f		 pop	 edi
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx
  001ac	8b e5		 mov	 esp, ebp
  001ae	5d		 pop	 ebp
  001af	c3		 ret	 0
$LN6@AfterSysEn:

; 9025 : 				return;
; 9026 : 			}
; 9027 : 			else
; 9028 : 			{
; 9029 : 				SysEncResume ();

  001b0	e8 00 00 00 00	 call	 ?SysEncResume@@YAXXZ	; SysEncResume
  001b5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001bc	e8 00 00 00 00	 call	 _InitSysEncProgressBar
  001c1	e8 00 00 00 00	 call	 ?UpdateSysEncProgressBar@@YAXXZ ; UpdateSysEncProgressBar
  001c6	e8 00 00 00 00	 call	 ?UpdateSysEncControls@@YAXXZ ; UpdateSysEncControls

; 9054 : 	}
; 9055 : 
; 9056 : 	InitSysEncProgressBar ();
; 9057 : 
; 9058 : 	UpdateSysEncProgressBar ();
; 9059 : 
; 9060 : 	UpdateSysEncControls ();
; 9061 : }

  001cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d5	59		 pop	 ecx
  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	5b		 pop	 ebx
  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c3		 ret	 0
__catch$_AfterSysEncProgressWMInitTasks$0:

; 9046 : 			return;
; 9047 : 		}
; 9048 : 	}
; 9049 : 	catch (Exception &e)
; 9050 : 	{
; 9051 : 		e.Show (hwndDlg);

  001dd	8b 4d ec	 mov	 ecx, DWORD PTR _e$2[ebp]
  001e0	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  001e3	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e5	ff 10		 call	 DWORD PTR [eax]

; 9052 : 		EndMainDlg (MainDlg);

  001e7	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  001ed	e8 00 00 00 00	 call	 _EndMainDlg
  001f2	83 c4 04	 add	 esp, 4

; 9053 : 		return;

  001f5	b8 00 00 00 00	 mov	 eax, $LN14@AfterSysEn
  001fa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_AfterSysEncProgressWMInitTasks:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_AfterSysEncProgressWMInitTasks
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_AfterSysEncProgressWMInitTasks ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _AfterWMInitTasks
_TEXT	SEGMENT
_e$2 = -860						; size = 4
_e$3 = -856						; size = 4
_e$4 = -852						; size = 4
_e$5 = -848						; size = 4
_e$6 = -844						; size = 4
_hwndDlg$GSCopy$ = -840					; size = 4
$T7 = -836						; size = 94
$T8 = -740						; size = 94
_rD$9 = -644						; size = 16
_rD$10 = -628						; size = 16
_rD$11 = -612						; size = 16
_rD$12 = -596						; size = 16
_rD$13 = -580						; size = 16
_rD$14 = -564						; size = 16
_rW$15 = -548						; size = 16
_rW$16 = -532						; size = 16
_rW$17 = -516						; size = 16
_rW$18 = -500						; size = 16
_rW$19 = -484						; size = 16
_rW$20 = -468						; size = 16
_tmpStr$21 = -452					; size = 24
_tmp$22 = -428						; size = 65
_tmp$23 = -360						; size = 65
_tmp$24 = -292						; size = 65
_tmp$25 = -224						; size = 65
_tmp$26 = -156						; size = 65
_tmp$27 = -88						; size = 65
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_hwndDlg$ = 8						; size = 4
_AfterWMInitTasks PROC					; COMDAT

; 9074 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_AfterWMInitTasks
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 50 03 00
	00		 sub	 esp, 848		; 00000350H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 9075 : 	// Note that if bDirectSysEncModeCommand is not SYSENC_COMMAND_NONE, we already have the mutex.
; 9076 : 
; 9077 : 	// SYSENC_COMMAND_DECRYPT has the highest priority because it also performs uninstallation (restores the
; 9078 : 	// original contents of the first drive cylinder, etc.) so it must be attempted regardless of the phase
; 9079 : 	// or content of configuration files.
; 9080 : 	if (bDirectSysEncModeCommand == SYSENC_COMMAND_DECRYPT)

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bDirectSysEncModeCommand@@3HA ; bDirectSysEncModeCommand
  00037	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  0003a	89 9d b8 fc ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$[ebp], ebx
  00040	83 f9 04	 cmp	 ecx, 4
  00043	0f 85 87 01 00
	00		 jne	 $LN10@AfterWMIni

; 9081 : 	{
; 9082 : 		if (IsHiddenOSRunning())

  00049	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  0004e	85 c0		 test	 eax, eax
  00050	74 12		 je	 SHORT $LN11@AfterWMIni

; 9083 : 		{
; 9084 : 			Warning ("CANNOT_DECRYPT_HIDDEN_OS");

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KGJBOMKO@CANNOT_DECRYPT_HIDDEN_OS?$AA@
  00057	e8 00 00 00 00	 call	 _Warning
  0005c	83 c4 04	 add	 esp, 4

; 9085 : 			AbortProcessSilent();

  0005f	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN11@AfterWMIni:

; 9086 : 		}
; 9087 : 
; 9088 : 		// Add the wizard to the system startup sequence
; 9089 : 		ManageStartupSeqWiz (FALSE, "/acsysenc");

  00064	68 00 00 00 00	 push	 OFFSET ??_C@_09PIOBCILE@?1acsysenc?$AA@
  00069	6a 00		 push	 0
  0006b	e8 00 00 00 00	 call	 _ManageStartupSeqWiz
  00070	83 c4 08	 add	 esp, 8

; 9090 : 
; 9091 : 		ChangeSystemEncryptionStatus (SYSENC_STATUS_DECRYPTING);

  00073	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00078	85 c0		 test	 eax, eax
  0007a	75 0c		 jne	 SHORT $LN107@AfterWMIni
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00081	e8 00 00 00 00	 call	 _Error
  00086	eb 1f		 jmp	 SHORT $LN559@AfterWMIni
$LN107@AfterWMIni:
  00088	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0008e	c7 05 00 00 00
	00 58 02 00 00	 mov	 DWORD PTR _SystemEncryptionStatus, 600 ; 00000258H
  00098	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 1
  000a2	e8 00 00 00 00	 call	 ?SaveSysEncSettings@@YAHPAUHWND__@@@Z ; SaveSysEncSettings
$LN559@AfterWMIni:

; 9092 : 		LoadPage (hwndDlg, SYSENC_ENCRYPTION_PAGE);

  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  000ac	83 c4 04	 add	 esp, 4
  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  000b5	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  000bb	85 c0		 test	 eax, eax
  000bd	74 57		 je	 SHORT $LN120@AfterWMIni
  000bf	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  000c9	83 f9 15	 cmp	 ecx, 21			; 00000015H
  000cc	75 37		 jne	 SHORT $LN114@AfterWMIni
  000ce	6a 40		 push	 64			; 00000040H
  000d0	8d 45 a8	 lea	 eax, DWORD PTR _tmp$27[ebp]
  000d3	6a 58		 push	 88			; 00000058H
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _memset
  000db	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  000e1	8d 45 a8	 lea	 eax, DWORD PTR _tmp$27[ebp]
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e7	c6 45 e8 00	 mov	 BYTE PTR _tmp$27[ebp+64], 0
  000eb	50		 push	 eax
  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  000f1	50		 push	 eax
  000f2	ff d6		 call	 esi
  000f4	8d 45 a8	 lea	 eax, DWORD PTR _tmp$27[ebp]
  000f7	50		 push	 eax
  000f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  000fd	50		 push	 eax
  000fe	ff d6		 call	 esi
  00100	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN114@AfterWMIni:
  00105	50		 push	 eax
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  0010c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN120@AfterWMIni:
  00116	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  00120	e8 00 00 00 00	 call	 _NormalCursor
  00125	8d 85 2c fe ff
	ff		 lea	 eax, DWORD PTR _rW$20[ebp]
  0012b	50		 push	 eax
  0012c	68 23 04 00 00	 push	 1059			; 00000423H
  00131	53		 push	 ebx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00138	50		 push	 eax
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  0013f	6a 00		 push	 0
  00141	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00146	53		 push	 ebx
  00147	6a 7a		 push	 122			; 0000007aH
  00149	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  0014f	c7 05 00 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 31 ; nCurPageNo, 0000001fH
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  0015f	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  00166	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  0016b	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _rD$14[ebp]
  00171	50		 push	 eax
  00172	53		 push	 ebx
  00173	0f 11 85 cc fd
	ff ff		 movups	 XMMWORD PTR _rD$14[ebp], xmm0
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00180	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  00186	85 c9		 test	 ecx, ecx
  00188	0f 84 eb 0c 00
	00		 je	 $LN48@AfterWMIni
  0018e	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _rW$20[ebp+12]
  00194	2b 85 30 fe ff
	ff		 sub	 eax, DWORD PTR _rW$20[ebp+4]
  0019a	6a 01		 push	 1
  0019c	50		 push	 eax
  0019d	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR _rW$20[ebp+8]
  001a3	2b 85 2c fe ff
	ff		 sub	 eax, DWORD PTR _rW$20[ebp]
  001a9	50		 push	 eax
  001aa	ff b5 d0 fd ff
	ff		 push	 DWORD PTR _rD$14[ebp+4]
  001b0	ff b5 cc fd ff
	ff		 push	 DWORD PTR _rD$14[ebp]
$LN565@AfterWMIni:
  001b6	51		 push	 ecx
  001b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  001bd	6a 01		 push	 1
  001bf	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  001c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 9093 : 		return;

  001cb	e9 a9 0c 00 00	 jmp	 $LN48@AfterWMIni
$LN10@AfterWMIni:

; 9094 : 	}
; 9095 : 
; 9096 : 
; 9097 : 	if (SystemEncryptionStatus == SYSENC_STATUS_ENCRYPTING
; 9098 : 		|| SystemEncryptionStatus == SYSENC_STATUS_DECRYPTING)

  001d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionStatus
  001d5	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  001da	74 0b		 je	 SHORT $LN13@AfterWMIni
  001dc	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  001e1	0f 85 19 01 00
	00		 jne	 $LN96@AfterWMIni
$LN13@AfterWMIni:

; 9099 : 	{
; 9100 : 		try
; 9101 : 		{
; 9102 : 			BootEncStatus = BootEncObj->GetStatus();

  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  001ed	8d 85 1c fd ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  001f3	50		 push	 eax
  001f4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  001fb	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00200	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00205	8b f0		 mov	 esi, eax
  00207	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  0020c	f3 a5		 rep movsd
  0020e	66 a5		 movsw

; 9103 : 
; 9104 : 			if (!BootEncStatus.DriveMounted)

  00210	83 3d 06 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+6, 0
  00217	0f 85 d1 00 00
	00		 jne	 $LN553@AfterWMIni

; 9105 : 			{
; 9106 : 				if (!BootEncStatus.DeviceFilterActive)

  0021d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A, 0
  00224	0f 85 85 00 00
	00		 jne	 $LN16@AfterWMIni

; 9107 : 				{
; 9108 : 					// This is an inconsistent state. SystemEncryptionStatus should never be SYSENC_STATUS_ENCRYPTING
; 9109 : 					// or SYSENC_STATUS_DECRYPTING when the drive filter is not active. Possible causes: 1) corrupted
; 9110 : 					// or stale config file, 2) corrupted system
; 9111 : 
; 9112 : 					// Fix the inconsistency
; 9113 : 					ManageStartupSeqWiz (TRUE, "");

  0022a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0022f	6a 01		 push	 1
  00231	e8 00 00 00 00	 call	 _ManageStartupSeqWiz
  00236	83 c4 08	 add	 esp, 8

; 9114 : 					ChangeSystemEncryptionStatus (SYSENC_STATUS_NONE);

  00239	e8 00 00 00 00	 call	 _CreateSysEncMutex
  0023e	85 c0		 test	 eax, eax
  00240	75 0c		 jne	 SHORT $LN181@AfterWMIni
  00242	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00247	e8 00 00 00 00	 call	 _Error
  0024c	eb 44		 jmp	 SHORT $LN560@AfterWMIni
$LN181@AfterWMIni:
  0024e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SystemEncryptionStatus, 0
  00258	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 1
  00262	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  00267	85 c0		 test	 eax, eax
  00269	75 1c		 jne	 SHORT $LN183@AfterWMIni
  0026b	e8 00 00 00 00	 call	 ?DetermineHiddenOSCreationPhase@@YAIXZ ; DetermineHiddenOSCreationPhase
  00270	85 c0		 test	 eax, eax
  00272	74 0e		 je	 SHORT $LN184@AfterWMIni
  00274	6a 00		 push	 0
  00276	e8 00 00 00 00	 call	 ?ChangeHiddenOSCreationPhase@@YAHH@Z ; ChangeHiddenOSCreationPhase
  0027b	83 c4 04	 add	 esp, 4
  0027e	85 c0		 test	 eax, eax
  00280	74 13		 je	 SHORT $LN185@AfterWMIni
$LN184@AfterWMIni:
  00282	e8 00 00 00 00	 call	 _WipeHiddenOSCreationConfig
$LN183@AfterWMIni:
  00287	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0028d	e8 00 00 00 00	 call	 ?SaveSysEncSettings@@YAHPAUHWND__@@@Z ; SaveSysEncSettings
$LN560@AfterWMIni:
  00292	83 c4 04	 add	 esp, 4
$LN185@AfterWMIni:

; 9115 : 					EndMainDlg (MainDlg);

  00295	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0029b	e8 00 00 00 00	 call	 _EndMainDlg

; 9116 : 					InconsistencyResolved (SRC_POS);

  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JNPKODLF@AfterWMInitTasks?39116?$AA@
  002a5	e8 00 00 00 00	 call	 _InconsistencyResolved

; 9117 : 					return;

  002aa	e9 c7 0b 00 00	 jmp	 $LN561@AfterWMIni
$LN16@AfterWMIni:

; 9118 : 				}
; 9119 : 				else if (bDirectSysEncMode)

  002af	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDirectSysEncMode@@3HA, 0 ; bDirectSysEncMode
  002b6	74 36		 je	 SHORT $LN553@AfterWMIni

; 9120 : 				{
; 9121 : 					// This is an inconsistent state. We have a direct system encryption command, 
; 9122 : 					// SystemEncryptionStatus is SYSENC_STATUS_ENCRYPTING or SYSENC_STATUS_DECRYPTING, the
; 9123 : 					// system drive is not 'mounted' and drive filter is active.  Possible causes: 1) The drive had
; 9124 : 					// been decrypted in the pre-boot environment. 2) The OS is not located on the lowest partition,
; 9125 : 					// the drive is to be fully encrypted, but the user rebooted before encryption reached the 
; 9126 : 					// system partition and then pressed Esc in the boot loader screen. 3) Corrupted or stale config
; 9127 : 					// file. 4) Damaged system.
; 9128 : 					
; 9129 : 					Warning ("SYSTEM_ENCRYPTION_SCHEDULED_BUT_PBA_FAILED");

  002b8	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LHNBFDMB@SYSTEM_ENCRYPTION_SCHEDULED_BUT_@
$LN563@AfterWMIni:
  002bd	e8 00 00 00 00	 call	 _Warning

; 9130 : 					EndMainDlg (MainDlg);

  002c2	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  002c8	e8 00 00 00 00	 call	 _EndMainDlg

; 9131 : 					return;

  002cd	e9 a4 0b 00 00	 jmp	 $LN561@AfterWMIni
__catch$_AfterWMInitTasks$0:

; 9132 : 				}
; 9133 : 			}
; 9134 : 		}
; 9135 : 		catch (Exception &e)
; 9136 : 		{
; 9137 : 			e.Show (MainDlg);

  002d2	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _e$6[ebp]
  002d8	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  002de	8b 01		 mov	 eax, DWORD PTR [ecx]
  002e0	ff 10		 call	 DWORD PTR [eax]

; 9138 : 		}

  002e2	b8 00 00 00 00	 mov	 eax, $LN97@AfterWMIni
  002e7	c3		 ret	 0
$LN97@AfterWMIni:
  002e8	8b 9d b8 fc ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN553@AfterWMIni:
  002ee	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionStatus
  002f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bDirectSysEncModeCommand@@3HA ; bDirectSysEncModeCommand
  002f9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN96@AfterWMIni:

; 9139 : 	}
; 9140 : 
; 9141 : 
; 9142 : 	if (SystemEncryptionStatus != SYSENC_STATUS_PRETEST)

  00300	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  00305	0f 84 0a 03 00
	00		 je	 $LN2@AfterWMIni

; 9143 : 	{
; 9144 : 		// Handle system encryption command line arguments (if we're not in the Pretest phase).
; 9145 : 		// Note that if bDirectSysEncModeCommand is not SYSENC_COMMAND_NONE, we already have the mutex.
; 9146 : 		// Also note that SYSENC_COMMAND_DECRYPT is handled above.
; 9147 : 
; 9148 : 		switch (bDirectSysEncModeCommand)

  0030b	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  0030e	83 fa 05	 cmp	 edx, 5
  00311	0f 87 fe 02 00
	00		 ja	 $LN2@AfterWMIni
  00317	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN570@AfterWMIni[edx*4]
$LN20@AfterWMIni:

; 9149 : 		{
; 9150 : 		case SYSENC_COMMAND_RESUME:
; 9151 : 		case SYSENC_COMMAND_STARTUP_SEQ_RESUME:
; 9152 : 
; 9153 : 			if (bDirectSysEncModeCommand == SYSENC_COMMAND_STARTUP_SEQ_RESUME
; 9154 : 				&& AskWarnYesNo ("SYSTEM_ENCRYPTION_RESUME_PROMPT") == IDNO)

  0031e	83 f9 02	 cmp	 ecx, 2
  00321	75 16		 jne	 SHORT $LN21@AfterWMIni
  00323	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HDGOHFPD@SYSTEM_ENCRYPTION_RESUME_PROMPT?$AA@
  00328	e8 00 00 00 00	 call	 _AskWarnYesNo
  0032d	83 c4 04	 add	 esp, 4
  00330	83 f8 07	 cmp	 eax, 7
  00333	0f 84 c2 02 00
	00		 je	 $LN566@AfterWMIni
$LN21@AfterWMIni:

; 9155 : 			{
; 9156 : 				EndMainDlg (MainDlg);
; 9157 : 				return;
; 9158 : 			}
; 9159 : 
; 9160 : 			if (SysEncryptionOrDecryptionRequired ())

  00339	e8 00 00 00 00	 call	 ?SysEncryptionOrDecryptionRequired@@YAHXZ ; SysEncryptionOrDecryptionRequired
  0033e	85 c0		 test	 eax, eax
  00340	0f 84 3a 01 00
	00		 je	 $LN22@AfterWMIni

; 9161 : 			{
; 9162 : 				if (SystemEncryptionStatus != SYSENC_STATUS_ENCRYPTING
; 9163 : 					&& SystemEncryptionStatus != SYSENC_STATUS_DECRYPTING)

  00346	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionStatus
  0034b	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  00350	74 14		 je	 SHORT $LN25@AfterWMIni
  00352	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  00357	74 0d		 je	 SHORT $LN25@AfterWMIni

; 9164 : 				{
; 9165 : 					// If the config file with status was lost or not written correctly, we
; 9166 : 					// don't know whether to encrypt or decrypt (but we know that encryption or
; 9167 : 					// decryption is required). Ask the user to select encryption, decryption, 
; 9168 : 					// or cancel
; 9169 : 					if (!ResolveUnknownSysEncDirection ())

  00359	e8 00 00 00 00	 call	 _ResolveUnknownSysEncDirection
  0035e	85 c0		 test	 eax, eax
  00360	0f 84 95 02 00
	00		 je	 $LN566@AfterWMIni
$LN25@AfterWMIni:

; 9170 : 					{
; 9171 : 						EndMainDlg (MainDlg);
; 9172 : 						return;
; 9173 : 					}
; 9174 : 				}
; 9175 : 
; 9176 : 				LoadPage (hwndDlg, SYSENC_ENCRYPTION_PAGE);

  00366	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  0036b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  00371	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  00377	85 c0		 test	 eax, eax
  00379	74 60		 je	 SHORT $LN194@AfterWMIni
  0037b	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  00385	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00388	75 40		 jne	 SHORT $LN188@AfterWMIni
  0038a	6a 40		 push	 64			; 00000040H
  0038c	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$26[ebp]
  00392	6a 58		 push	 88			; 00000058H
  00394	50		 push	 eax
  00395	e8 00 00 00 00	 call	 _memset
  0039a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  003a0	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$26[ebp]
  003a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a9	c6 45 a4 00	 mov	 BYTE PTR _tmp$26[ebp+64], 0
  003ad	50		 push	 eax
  003ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  003b3	50		 push	 eax
  003b4	ff d6		 call	 esi
  003b6	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$26[ebp]
  003bc	50		 push	 eax
  003bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  003c2	50		 push	 eax
  003c3	ff d6		 call	 esi
  003c5	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN188@AfterWMIni:
  003ca	50		 push	 eax
  003cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  003d1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN194@AfterWMIni:
  003db	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  003e5	e8 00 00 00 00	 call	 _NormalCursor
  003ea	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _rW$19[ebp]
  003f0	50		 push	 eax
  003f1	68 23 04 00 00	 push	 1059			; 00000423H
  003f6	53		 push	 ebx
  003f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  003fd	50		 push	 eax
  003fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00404	6a 00		 push	 0
  00406	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  0040b	53		 push	 ebx
  0040c	6a 7a		 push	 122			; 0000007aH
  0040e	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00414	c7 05 00 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 31 ; nCurPageNo, 0000001fH
  0041e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  00424	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  0042b	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  00430	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _rD$13[ebp]
  00436	50		 push	 eax
  00437	53		 push	 ebx
  00438	0f 11 85 bc fd
	ff ff		 movups	 XMMWORD PTR _rD$13[ebp], xmm0
  0043f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00445	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  0044b	85 c9		 test	 ecx, ecx
  0044d	0f 84 26 0a 00
	00		 je	 $LN48@AfterWMIni
  00453	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR _rW$19[ebp+12]
  00459	2b 85 20 fe ff
	ff		 sub	 eax, DWORD PTR _rW$19[ebp+4]
  0045f	6a 01		 push	 1
  00461	50		 push	 eax
  00462	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR _rW$19[ebp+8]
  00468	2b 85 1c fe ff
	ff		 sub	 eax, DWORD PTR _rW$19[ebp]
  0046e	50		 push	 eax
  0046f	ff b5 c0 fd ff
	ff		 push	 DWORD PTR _rD$13[ebp+4]
  00475	ff b5 bc fd ff
	ff		 push	 DWORD PTR _rD$13[ebp]

; 9177 : 				return;

  0047b	e9 36 fd ff ff	 jmp	 $LN565@AfterWMIni
$LN22@AfterWMIni:

; 9178 : 			}
; 9179 : 			else
; 9180 : 			{
; 9181 : 				// Nothing to resume
; 9182 : 				Warning ("NOTHING_TO_RESUME");

  00480	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BOICFCMD@NOTHING_TO_RESUME?$AA@

; 9183 : 				EndMainDlg (MainDlg);
; 9184 : 
; 9185 : 				return;

  00485	e9 33 fe ff ff	 jmp	 $LN563@AfterWMIni
$LN26@AfterWMIni:

; 9186 : 			}
; 9187 : 			break;
; 9188 : 
; 9189 : 		case SYSENC_COMMAND_ENCRYPT:
; 9190 : 
; 9191 : 			if (SysDriveOrPartitionFullyEncrypted (FALSE))

  0048a	6a 00		 push	 0
  0048c	e8 00 00 00 00	 call	 ?SysDriveOrPartitionFullyEncrypted@@YAHH@Z ; SysDriveOrPartitionFullyEncrypted
  00491	83 c4 04	 add	 esp, 4
  00494	85 c0		 test	 eax, eax
  00496	74 1a		 je	 SHORT $LN27@AfterWMIni

; 9192 : 			{
; 9193 : 				Info ("SYS_PARTITION_OR_DRIVE_APPEARS_FULLY_ENCRYPTED");

  00498	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@MHIMBFBH@SYS_PARTITION_OR_DRIVE_APPEARS_F@
  0049d	e8 00 00 00 00	 call	 _Info
  004a2	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  004a8	e8 00 00 00 00	 call	 _EndMainDlg
  004ad	e9 c4 09 00 00	 jmp	 $LN561@AfterWMIni
$LN27@AfterWMIni:

; 9194 : 				EndMainDlg (MainDlg);
; 9195 : 				return;
; 9196 : 			}
; 9197 : 
; 9198 : 			if (SysEncryptionOrDecryptionRequired ())

  004b2	e8 00 00 00 00	 call	 ?SysEncryptionOrDecryptionRequired@@YAHXZ ; SysEncryptionOrDecryptionRequired
  004b7	85 c0		 test	 eax, eax
  004b9	0f 84 2a 01 00
	00		 je	 $LN28@AfterWMIni

; 9199 : 			{
; 9200 : 				// System partition/drive encryption process already initiated but is incomplete.
; 9201 : 				// If we were encrypting, resume the process directly. If we were decrypting, reverse 
; 9202 : 				// the process and start encrypting.
; 9203 : 
; 9204 : 				ChangeSystemEncryptionStatus (SYSENC_STATUS_ENCRYPTING);

  004bf	68 90 01 00 00	 push	 400			; 00000190H
  004c4	e8 00 00 00 00	 call	 ?ChangeSystemEncryptionStatus@@YAHH@Z ; ChangeSystemEncryptionStatus

; 9205 : 				LoadPage (hwndDlg, SYSENC_ENCRYPTION_PAGE);

  004c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  004ce	83 c4 04	 add	 esp, 4
  004d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  004d7	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  004dd	85 c0		 test	 eax, eax
  004df	74 63		 je	 SHORT $LN260@AfterWMIni
  004e1	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  004eb	83 f9 15	 cmp	 ecx, 21			; 00000015H
  004ee	75 43		 jne	 SHORT $LN254@AfterWMIni
  004f0	6a 40		 push	 64			; 00000040H
  004f2	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$25[ebp]
  004f8	6a 58		 push	 88			; 00000058H
  004fa	50		 push	 eax
  004fb	e8 00 00 00 00	 call	 _memset
  00500	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  00506	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$25[ebp]
  0050c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0050f	c6 85 60 ff ff
	ff 00		 mov	 BYTE PTR _tmp$25[ebp+64], 0
  00516	50		 push	 eax
  00517	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  0051c	50		 push	 eax
  0051d	ff d6		 call	 esi
  0051f	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$25[ebp]
  00525	50		 push	 eax
  00526	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  0052b	50		 push	 eax
  0052c	ff d6		 call	 esi
  0052e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN254@AfterWMIni:
  00533	50		 push	 eax
  00534	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  0053a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN260@AfterWMIni:
  00544	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  0054e	e8 00 00 00 00	 call	 _NormalCursor
  00553	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR _rW$18[ebp]
  00559	50		 push	 eax
  0055a	68 23 04 00 00	 push	 1059			; 00000423H
  0055f	53		 push	 ebx
  00560	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00566	50		 push	 eax
  00567	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  0056d	6a 00		 push	 0
  0056f	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00574	53		 push	 ebx
  00575	6a 7a		 push	 122			; 0000007aH
  00577	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  0057d	c7 05 00 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 31 ; nCurPageNo, 0000001fH
  00587	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  0058d	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  00594	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  00599	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _rD$12[ebp]
  0059f	50		 push	 eax
  005a0	53		 push	 ebx
  005a1	0f 11 85 ac fd
	ff ff		 movups	 XMMWORD PTR _rD$12[ebp], xmm0
  005a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  005ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  005b4	85 c9		 test	 ecx, ecx
  005b6	0f 84 bd 08 00
	00		 je	 $LN48@AfterWMIni
  005bc	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR _rW$18[ebp+12]
  005c2	2b 85 10 fe ff
	ff		 sub	 eax, DWORD PTR _rW$18[ebp+4]
  005c8	6a 01		 push	 1
  005ca	50		 push	 eax
  005cb	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _rW$18[ebp+8]
  005d1	2b 85 0c fe ff
	ff		 sub	 eax, DWORD PTR _rW$18[ebp]
  005d7	50		 push	 eax
  005d8	ff b5 b0 fd ff
	ff		 push	 DWORD PTR _rD$12[ebp+4]
  005de	ff b5 ac fd ff
	ff		 push	 DWORD PTR _rD$12[ebp]

; 9206 : 				return;

  005e4	e9 cd fb ff ff	 jmp	 $LN565@AfterWMIni
$LN28@AfterWMIni:

; 9207 : 			}
; 9208 : 			else
; 9209 : 			{
; 9210 : 				// Initiate the Pretest preparation phase
; 9211 : 				if (!SwitchWizardToSysEncMode ())

  005e9	e8 00 00 00 00	 call	 _SwitchWizardToSysEncMode
$LN567@AfterWMIni:
  005ee	85 c0		 test	 eax, eax
  005f0	0f 85 83 08 00
	00		 jne	 $LN48@AfterWMIni

; 9212 : 				{
; 9213 : 					bDirectSysEncMode = FALSE;

  005f6	a3 00 00 00 00	 mov	 DWORD PTR ?bDirectSysEncMode@@3HA, eax ; bDirectSysEncMode
$LN566@AfterWMIni:

; 9214 : 					EndMainDlg (MainDlg);

  005fb	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
$LN68@AfterWMIni:
  00601	e8 00 00 00 00	 call	 _EndMainDlg
  00606	83 c4 04	 add	 esp, 4

; 9215 : 				}
; 9216 : 				return;

  00609	e9 6b 08 00 00	 jmp	 $LN48@AfterWMIni
$LN31@AfterWMIni:

; 9217 : 			}
; 9218 : 
; 9219 : 			break;
; 9220 : 
; 9221 : 		case SYSENC_COMMAND_CREATE_HIDDEN_OS_ELEV:
; 9222 : 		case SYSENC_COMMAND_CREATE_HIDDEN_OS:
; 9223 : 
; 9224 : 			if (!SwitchWizardToHiddenOSMode ())

  0060e	e8 00 00 00 00	 call	 ?SwitchWizardToHiddenOSMode@@YAHXZ ; SwitchWizardToHiddenOSMode

; 9225 : 			{
; 9226 : 				bDirectSysEncMode = FALSE;
; 9227 : 				EndMainDlg (MainDlg);
; 9228 : 			}
; 9229 : 			return;

  00613	eb d9		 jmp	 SHORT $LN567@AfterWMIni
$LN2@AfterWMIni:

; 9230 : 		}
; 9231 : 	}
; 9232 : 
; 9233 : 
; 9234 : 	if (!bDirectSysEncMode
; 9235 : 		|| bDirectSysEncMode && SystemEncryptionStatus == SYSENC_STATUS_NONE)

  00615	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDirectSysEncMode@@3HA, 0 ; bDirectSysEncMode
  0061c	74 07		 je	 SHORT $LN34@AfterWMIni
  0061e	85 c0		 test	 eax, eax

; 9236 : 	{
; 9237 : 		// Handle system encryption cases where the wizard did not start even though it
; 9238 : 		// was added to the startup sequence, as well as other weird cases and "leftovers"
; 9239 : 
; 9240 : 		if (SystemEncryptionStatus != SYSENC_STATUS_NONE
; 9241 : 			&& SystemEncryptionStatus != SYSENC_STATUS_PRETEST
; 9242 : 			&& SysEncryptionOrDecryptionRequired ())

  00620	e9 7f 02 00 00	 jmp	 $LN562@AfterWMIni
$LN34@AfterWMIni:
  00625	85 c0		 test	 eax, eax
  00627	0f 84 d7 01 00
	00		 je	 $LN35@AfterWMIni
  0062d	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  00632	0f 84 d7 01 00
	00		 je	 $LN549@AfterWMIni
  00638	e8 00 00 00 00	 call	 ?SysEncryptionOrDecryptionRequired@@YAHXZ ; SysEncryptionOrDecryptionRequired
  0063d	85 c0		 test	 eax, eax
  0063f	0f 84 ba 01 00
	00		 je	 $LN555@AfterWMIni

; 9243 : 		{
; 9244 : 			// System encryption/decryption had been in progress and did not finish
; 9245 : 
; 9246 : 			if (CreateSysEncMutex ())	// If no other instance is currently taking care of system encryption

  00645	e8 00 00 00 00	 call	 _CreateSysEncMutex
  0064a	85 c0		 test	 eax, eax
  0064c	0f 84 99 02 00
	00		 je	 $LN556@AfterWMIni

; 9247 : 			{
; 9248 : 				if (AskWarnYesNo ("SYSTEM_ENCRYPTION_RESUME_PROMPT") == IDYES)

  00652	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HDGOHFPD@SYSTEM_ENCRYPTION_RESUME_PROMPT?$AA@
  00657	e8 00 00 00 00	 call	 _AskWarnYesNo
  0065c	83 c4 04	 add	 esp, 4
  0065f	83 f8 06	 cmp	 eax, 6
  00662	0f 85 7e 02 00
	00		 jne	 $LN38@AfterWMIni

; 9249 : 				{
; 9250 : 					bDirectSysEncMode = TRUE;
; 9251 : 					ChangeWizardMode (WIZARD_MODE_SYS_DEVICE);

  00668	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  0066f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDirectSysEncMode@@3HA, 1 ; bDirectSysEncMode
  00679	74 57		 je	 SHORT $LN320@AfterWMIni
  0067b	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  00680	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00685	85 c0		 test	 eax, eax
  00687	75 0f		 jne	 SHORT $LN324@AfterWMIni
  00689	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  0068e	e8 00 00 00 00	 call	 _Error
  00693	83 c4 04	 add	 esp, 4
  00696	eb 4a		 jmp	 SHORT $LN328@AfterWMIni
$LN324@AfterWMIni:
  00698	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
  0069d	0f 57 c0	 xorps	 xmm0, xmm0
  006a0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  006aa	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  006b1	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  006b8	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  006c0	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  006c8	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _WizardMode, 2
$LN320@AfterWMIni:
  006d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  006d7	f7 d8		 neg	 eax
  006d9	1b c0		 sbb	 eax, eax
  006db	f7 d8		 neg	 eax
  006dd	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice
$LN328@AfterWMIni:

; 9252 : 					LoadPage (hwndDlg, SYSENC_ENCRYPTION_PAGE);

  006e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  006e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  006ed	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  006f3	85 c0		 test	 eax, eax
  006f5	74 63		 je	 SHORT $LN342@AfterWMIni
  006f7	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  00701	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00704	75 43		 jne	 SHORT $LN336@AfterWMIni
  00706	6a 40		 push	 64			; 00000040H
  00708	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _tmp$24[ebp]
  0070e	6a 58		 push	 88			; 00000058H
  00710	50		 push	 eax
  00711	e8 00 00 00 00	 call	 _memset
  00716	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  0071c	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _tmp$24[ebp]
  00722	83 c4 0c	 add	 esp, 12			; 0000000cH
  00725	c6 85 1c ff ff
	ff 00		 mov	 BYTE PTR _tmp$24[ebp+64], 0
  0072c	50		 push	 eax
  0072d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  00732	50		 push	 eax
  00733	ff d6		 call	 esi
  00735	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _tmp$24[ebp]
  0073b	50		 push	 eax
  0073c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  00741	50		 push	 eax
  00742	ff d6		 call	 esi
  00744	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN336@AfterWMIni:
  00749	50		 push	 eax
  0074a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00750	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN342@AfterWMIni:
  0075a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  00764	e8 00 00 00 00	 call	 _NormalCursor
  00769	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _rW$17[ebp]
  0076f	50		 push	 eax
  00770	68 23 04 00 00	 push	 1059			; 00000423H
  00775	53		 push	 ebx
  00776	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0077c	50		 push	 eax
  0077d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00783	6a 00		 push	 0
  00785	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  0078a	53		 push	 ebx
  0078b	6a 7a		 push	 122			; 0000007aH
  0078d	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00793	c7 05 00 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 31 ; nCurPageNo, 0000001fH
  0079d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  007a3	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  007aa	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  007af	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _rD$11[ebp]
  007b5	50		 push	 eax
  007b6	53		 push	 ebx
  007b7	0f 11 85 9c fd
	ff ff		 movups	 XMMWORD PTR _rD$11[ebp], xmm0
  007be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  007c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  007ca	85 c9		 test	 ecx, ecx
  007cc	0f 84 a7 06 00
	00		 je	 $LN48@AfterWMIni
  007d2	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR _rW$17[ebp+12]
  007d8	2b 85 00 fe ff
	ff		 sub	 eax, DWORD PTR _rW$17[ebp+4]
  007de	6a 01		 push	 1
  007e0	50		 push	 eax
  007e1	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR _rW$17[ebp+8]
  007e7	2b 85 fc fd ff
	ff		 sub	 eax, DWORD PTR _rW$17[ebp]
  007ed	50		 push	 eax
  007ee	ff b5 a0 fd ff
	ff		 push	 DWORD PTR _rD$11[ebp+4]
  007f4	ff b5 9c fd ff
	ff		 push	 DWORD PTR _rD$11[ebp]

; 9253 : 					return;

  007fa	e9 b7 f9 ff ff	 jmp	 $LN565@AfterWMIni
$LN555@AfterWMIni:

; 9254 : 				}
; 9255 : 				else
; 9256 : 					CloseSysEncMutex ();
; 9257 : 			}
; 9258 : 		}

  007ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionStatus
$LN35@AfterWMIni:

; 9259 : 		else if (SystemEncryptionStatus == SYSENC_STATUS_PRETEST)

  00804	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  00809	0f 85 8c 00 00
	00		 jne	 $LN40@AfterWMIni
$LN549@AfterWMIni:

; 9260 : 		{
; 9261 : 			// System pretest had been in progress but we were not launched during the startup seq
; 9262 : 
; 9263 : 			if (CreateSysEncMutex ())	// If no other instance is currently taking care of system encryption

  0080f	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00814	85 c0		 test	 eax, eax
  00816	0f 84 cf 00 00
	00		 je	 $LN556@AfterWMIni

; 9264 : 			{
; 9265 : 				// The pretest has "priority handling"
; 9266 : 				bDirectSysEncMode = TRUE;
; 9267 : 				ChangeWizardMode (WIZARD_MODE_SYS_DEVICE);

  0081c	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  00823	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDirectSysEncMode@@3HA, 1 ; bDirectSysEncMode
  0082d	74 5a		 je	 SHORT $LN402@AfterWMIni
  0082f	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  00834	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00839	85 c0		 test	 eax, eax
  0083b	75 12		 jne	 SHORT $LN406@AfterWMIni
  0083d	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00842	e8 00 00 00 00	 call	 _Error
  00847	83 c4 04	 add	 esp, 4
  0084a	e9 9c 00 00 00	 jmp	 $LN556@AfterWMIni
$LN406@AfterWMIni:
  0084f	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
  00854	0f 57 c0	 xorps	 xmm0, xmm0
  00857	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  00861	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  00868	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  0086f	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  00877	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  0087f	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _WizardMode, 2
$LN402@AfterWMIni:
  00889	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  0088e	f7 d8		 neg	 eax
  00890	1b c0		 sbb	 eax, eax
  00892	f7 d8		 neg	 eax
  00894	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice

; 9268 : 
; 9269 : 				/* Do not return yet -- the principal pretest handler is below. */
; 9270 : 			}
; 9271 : 		}
; 9272 : 
; 9273 : 		else if ((SystemEncryptionStatus == SYSENC_STATUS_NONE || SystemEncryptionStatus == SYSENC_STATUS_DECRYPTING)

  00899	eb 50		 jmp	 SHORT $LN556@AfterWMIni
$LN40@AfterWMIni:

; 9274 : 			&& !BootEncStatus.DriveEncrypted 
; 9275 : 			&& (BootEncStatus.DriveMounted || BootEncStatus.VolumeHeaderPresent))

  0089b	85 c0		 test	 eax, eax
  0089d	74 07		 je	 SHORT $LN44@AfterWMIni
  0089f	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
$LN562@AfterWMIni:
  008a4	75 45		 jne	 SHORT $LN556@AfterWMIni
$LN44@AfterWMIni:
  008a6	83 3d 0e 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+14, 0
  008ad	75 3c		 jne	 SHORT $LN556@AfterWMIni
  008af	83 3d 06 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+6, 0
  008b6	75 09		 jne	 SHORT $LN45@AfterWMIni
  008b8	83 3d 0a 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+10, 0
  008bf	74 2a		 je	 SHORT $LN556@AfterWMIni
$LN45@AfterWMIni:

; 9276 : 		{
; 9277 : 			// The pretest may have been in progress but we can't be sure (it is not in the config file).
; 9278 : 			// Another possibility is that the user had finished decrypting the drive, but the config file
; 9279 : 			// was not correctly updated. In both cases the best thing we can do is remove the header and 
; 9280 : 			// deinstall. Otherwise, the result might be some kind of deadlock.
; 9281 : 
; 9282 : 			if (CreateSysEncMutex ())	// If no other instance is currently taking care of system encryption

  008c1	e8 00 00 00 00	 call	 _CreateSysEncMutex
  008c6	85 c0		 test	 eax, eax
  008c8	74 21		 je	 SHORT $LN556@AfterWMIni

; 9283 : 			{
; 9284 : 				WaitCursor ();

  008ca	e8 00 00 00 00	 call	 _WaitCursor

; 9285 : 
; 9286 : 				ForceRemoveSysEnc();

  008cf	e8 00 00 00 00	 call	 ?ForceRemoveSysEnc@@YAHXZ ; ForceRemoveSysEnc

; 9287 : 
; 9288 : 				InconsistencyResolved (SRC_POS);

  008d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BOBNFKFK@AfterWMInitTasks?39288?$AA@
  008d9	e8 00 00 00 00	 call	 _InconsistencyResolved
  008de	83 c4 04	 add	 esp, 4

; 9289 : 
; 9290 : 				NormalCursor();

  008e1	e8 00 00 00 00	 call	 _NormalCursor
$LN38@AfterWMIni:

; 9291 : 				CloseSysEncMutex ();

  008e6	e8 00 00 00 00	 call	 _CloseSysEncMutex
$LN556@AfterWMIni:

; 9292 : 			}
; 9293 : 		}
; 9294 : 	}
; 9295 : 
; 9296 : 	if (bDirectSysEncMode && CreateSysEncMutex ())

  008eb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDirectSysEncMode@@3HA, 0 ; bDirectSysEncMode
  008f2	0f 84 db 04 00
	00		 je	 $LN47@AfterWMIni
  008f8	e8 00 00 00 00	 call	 _CreateSysEncMutex
  008fd	85 c0		 test	 eax, eax
  008ff	0f 84 ce 04 00
	00		 je	 $LN47@AfterWMIni

; 9297 : 	{
; 9298 : 		// We were launched either by Mount or by the system (startup sequence). Most of such cases should have 
; 9299 : 		// been handled above already. Here we handle only the pretest phase (which can also be a hidden OS 
; 9300 : 		// creation phase actually) and possible inconsistencies.
; 9301 : 
; 9302 : 		switch (SystemEncryptionStatus)

  00905	81 3d 00 00 00
	00 c8 00 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 200 ; 000000c8H
  0090f	74 30		 je	 SHORT $LN49@AfterWMIni

; 9497 : 					}
; 9498 : 				}
; 9499 : 			}
; 9500 : 			break;
; 9501 : 
; 9502 : 		default:
; 9503 : 
; 9504 : 			// Unexpected progress status -- fix the inconsistency
; 9505 : 
; 9506 : 			ManageStartupSeqWiz (TRUE, "");

  00911	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00916	6a 01		 push	 1
  00918	e8 00 00 00 00	 call	 _ManageStartupSeqWiz

; 9507 : 			ChangeSystemEncryptionStatus (SYSENC_STATUS_NONE);

  0091d	6a 00		 push	 0
  0091f	e8 00 00 00 00	 call	 ?ChangeSystemEncryptionStatus@@YAHH@Z ; ChangeSystemEncryptionStatus

; 9508 : 			EndMainDlg (MainDlg);

  00924	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0092a	e8 00 00 00 00	 call	 _EndMainDlg

; 9509 : 			InconsistencyResolved (SRC_POS);

  0092f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JEMCACBK@AfterWMInitTasks?39509?$AA@
  00934	e8 00 00 00 00	 call	 _InconsistencyResolved
  00939	83 c4 14	 add	 esp, 20			; 00000014H

; 9510 : 			return;

  0093c	e9 38 05 00 00	 jmp	 $LN48@AfterWMIni
$LN49@AfterWMIni:

; 9303 : 		{
; 9304 : 		case SYSENC_STATUS_PRETEST:
; 9305 : 			{
; 9306 : 				unsigned int hiddenOSCreationPhase = DetermineHiddenOSCreationPhase();

  00941	e8 00 00 00 00	 call	 ?DetermineHiddenOSCreationPhase@@YAIXZ ; DetermineHiddenOSCreationPhase

; 9307 : 
; 9308 : 				bHiddenOS = (hiddenOSCreationPhase != GST_HIDDEN_OS_CREATION_PHASE_NONE);

  00946	33 c9		 xor	 ecx, ecx

; 9309 : 
; 9310 : 				// Evaluate the results of the system encryption pretest (or of the hidden OS creation process)
; 9311 : 
; 9312 : 				try

  00948	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0094f	8b d8		 mov	 ebx, eax

; 9313 : 				{
; 9314 : 					BootEncStatus = BootEncObj->GetStatus();

  00951	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00957	85 db		 test	 ebx, ebx
  00959	50		 push	 eax
  0095a	0f 95 c1	 setne	 cl
  0095d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?bHiddenOS@@3HC, ecx ; bHiddenOS
  00963	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00969	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  0096e	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00973	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0097a	8b f0		 mov	 esi, eax
  0097c	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  00981	f3 a5		 rep movsd
  00983	66 a5		 movsw
  00985	83 3d 06 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+6, 0
  0098c	0f 84 9a 02 00
	00		 je	 $LN51@AfterWMIni

; 9322 : 				}
; 9323 : 
; 9324 : 				if (BootEncStatus.DriveMounted)
; 9325 : 				{
; 9326 : 					/* Pretest successful or hidden OS has been booted during the process of hidden OS creation. */
; 9327 : 
; 9328 : 					switch (hiddenOSCreationPhase)

  00992	83 eb 00	 sub	 ebx, 0
  00995	0f 84 61 01 00
	00		 je	 $LN53@AfterWMIni
  0099b	81 eb 80 00 00
	00		 sub	 ebx, 128		; 00000080H
  009a1	74 36		 je	 SHORT $LN55@AfterWMIni
  009a3	83 eb 40	 sub	 ebx, 64			; 00000040H
  009a6	74 1a		 je	 SHORT $LN56@AfterWMIni

; 9367 : 
; 9368 : 						EndMainDlg (MainDlg);
; 9369 : 						return;
; 9370 : 
; 9371 : 					default:
; 9372 : 
; 9373 : 						// Unexpected/unknown status
; 9374 : 						ReportUnexpectedState (SRC_POS);

  009a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BEIDFAO@AfterWMInitTasks?39374?$AA@
  009ad	e8 00 00 00 00	 call	 _ReportUnexpectedState
  009b2	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  009b8	e8 00 00 00 00	 call	 _EndMainDlg
  009bd	e9 b4 04 00 00	 jmp	 $LN561@AfterWMIni
$LN56@AfterWMIni:

; 9361 : 
; 9362 : 					case GST_HIDDEN_OS_CREATION_PHASE_WIPED:
; 9363 : 
; 9364 : 						// Hidden OS has been booted and the original OS wiped. Now the user is required to install a new, decoy, OS.
; 9365 : 
; 9366 : 						TextInfoDialogBox (GST_TBXID_DECOY_OS_INSTRUCTIONS);

  009c2	6a 03		 push	 3
  009c4	e8 00 00 00 00	 call	 _TextInfoDialogBox
  009c9	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  009cf	e8 00 00 00 00	 call	 _EndMainDlg
  009d4	e9 9d 04 00 00	 jmp	 $LN561@AfterWMIni
$LN55@AfterWMIni:

; 9354 : 
; 9355 : 					case GST_HIDDEN_OS_CREATION_PHASE_WIPING:
; 9356 : 
; 9357 : 						// Hidden OS has been booted when we are supposed to wipe the original OS
; 9358 : 
; 9359 : 						LoadPage (hwndDlg, SYSENC_HIDDEN_OS_INITIAL_INFO_PAGE);

  009d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  009de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  009e4	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  009ea	85 c0		 test	 eax, eax
  009ec	74 63		 je	 SHORT $LN490@AfterWMIni
  009ee	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  009f8	83 f9 15	 cmp	 ecx, 21			; 00000015H
  009fb	75 43		 jne	 SHORT $LN484@AfterWMIni
  009fd	6a 40		 push	 64			; 00000040H
  009ff	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$23[ebp]
  00a05	6a 58		 push	 88			; 00000058H
  00a07	50		 push	 eax
  00a08	e8 00 00 00 00	 call	 _memset
  00a0d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  00a13	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$23[ebp]
  00a19	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a1c	c6 85 d8 fe ff
	ff 00		 mov	 BYTE PTR _tmp$23[ebp+64], 0
  00a23	50		 push	 eax
  00a24	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  00a29	50		 push	 eax
  00a2a	ff d6		 call	 esi
  00a2c	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$23[ebp]
  00a32	50		 push	 eax
  00a33	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  00a38	50		 push	 eax
  00a39	ff d6		 call	 esi
  00a3b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN484@AfterWMIni:
  00a40	50		 push	 eax
  00a41	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00a47	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN490@AfterWMIni:
  00a51	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  00a5b	e8 00 00 00 00	 call	 _NormalCursor
  00a60	8b b5 b8 fc ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[ebp]
  00a66	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _rW$16[ebp]
  00a6c	50		 push	 eax
  00a6d	68 23 04 00 00	 push	 1059			; 00000423H
  00a72	56		 push	 esi
  00a73	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00a79	50		 push	 eax
  00a7a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00a80	6a 00		 push	 0
  00a82	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00a87	56		 push	 esi
  00a88	6a 6c		 push	 108			; 0000006cH
  00a8a	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00a90	c7 05 00 00 00
	00 28 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 40 ; nCurPageNo, 00000028H
  00a9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  00aa0	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  00aa7	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  00aac	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR _rD$10[ebp]
  00ab2	50		 push	 eax
  00ab3	56		 push	 esi
  00ab4	0f 11 85 8c fd
	ff ff		 movups	 XMMWORD PTR _rD$10[ebp], xmm0
  00abb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00ac1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  00ac7	85 c9		 test	 ecx, ecx
  00ac9	0f 84 aa 03 00
	00		 je	 $LN48@AfterWMIni
  00acf	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _rW$16[ebp+12]
  00ad5	2b 85 f0 fd ff
	ff		 sub	 eax, DWORD PTR _rW$16[ebp+4]
  00adb	6a 01		 push	 1
  00add	50		 push	 eax
  00ade	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _rW$16[ebp+8]
  00ae4	2b 85 ec fd ff
	ff		 sub	 eax, DWORD PTR _rW$16[ebp]
  00aea	50		 push	 eax
  00aeb	ff b5 90 fd ff
	ff		 push	 DWORD PTR _rD$10[ebp+4]
  00af1	ff b5 8c fd ff
	ff		 push	 DWORD PTR _rD$10[ebp]

; 9360 : 						return;

  00af7	e9 ba f6 ff ff	 jmp	 $LN565@AfterWMIni
$LN53@AfterWMIni:

; 9329 : 					{
; 9330 : 					case GST_HIDDEN_OS_CREATION_PHASE_NONE:
; 9331 : 
; 9332 : 						// Pretest successful (or the hidden OS has been booted for the first time since the user started installing a new decoy OS)
; 9333 : 
; 9334 : 						if (IsHiddenOSRunning())

  00afc	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  00b01	85 c0		 test	 eax, eax
  00b03	0f 85 58 01 00
	00		 jne	 $LN568@AfterWMIni

; 9335 : 						{
; 9336 : 							// The hidden OS has been booted for the first time since the user started installing a
; 9337 : 							// new decoy OS (presumably, our MBR config flags have been erased).
; 9338 : 							
; 9339 : 							// As for things we are responsible for, the process of hidden OS creation is completed
; 9340 : 							// (the rest is up to the user).
; 9341 : 
; 9342 : 							ManageStartupSeqWiz (TRUE, "");
; 9343 : 							ChangeSystemEncryptionStatus (SYSENC_STATUS_NONE);
; 9344 : 
; 9345 : 							EndMainDlg (MainDlg);
; 9346 : 							
; 9347 : 							return;
; 9348 : 						}
; 9349 : 
; 9350 : 						// Pretest successful (no hidden operating system involved)
; 9351 : 
; 9352 : 						LoadPage (hwndDlg, SYSENC_PRETEST_RESULT_PAGE);

  00b09	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  00b0e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  00b14	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  00b1a	85 c0		 test	 eax, eax
  00b1c	74 63		 je	 SHORT $LN424@AfterWMIni
  00b1e	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  00b28	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00b2b	75 43		 jne	 SHORT $LN418@AfterWMIni
  00b2d	6a 40		 push	 64			; 00000040H
  00b2f	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$22[ebp]
  00b35	6a 58		 push	 88			; 00000058H
  00b37	50		 push	 eax
  00b38	e8 00 00 00 00	 call	 _memset
  00b3d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  00b43	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$22[ebp]
  00b49	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b4c	c6 85 94 fe ff
	ff 00		 mov	 BYTE PTR _tmp$22[ebp+64], 0
  00b53	50		 push	 eax
  00b54	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  00b59	50		 push	 eax
  00b5a	ff d6		 call	 esi
  00b5c	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$22[ebp]
  00b62	50		 push	 eax
  00b63	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  00b68	50		 push	 eax
  00b69	ff d6		 call	 esi
  00b6b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN418@AfterWMIni:
  00b70	50		 push	 eax
  00b71	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00b77	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN424@AfterWMIni:
  00b81	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  00b8b	e8 00 00 00 00	 call	 _NormalCursor
  00b90	8b b5 b8 fc ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[ebp]
  00b96	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _rW$15[ebp]
  00b9c	50		 push	 eax
  00b9d	68 23 04 00 00	 push	 1059			; 00000423H
  00ba2	56		 push	 esi
  00ba3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00ba9	50		 push	 eax
  00baa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00bb0	6a 00		 push	 0
  00bb2	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00bb7	56		 push	 esi
  00bb8	6a 6c		 push	 108			; 0000006cH
  00bba	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00bc0	c7 05 00 00 00
	00 1e 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 30 ; nCurPageNo, 0000001eH
  00bca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  00bd0	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  00bd7	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  00bdc	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _rD$9[ebp]
  00be2	50		 push	 eax
  00be3	56		 push	 esi
  00be4	0f 11 85 7c fd
	ff ff		 movups	 XMMWORD PTR _rD$9[ebp], xmm0
  00beb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00bf1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  00bf7	85 c9		 test	 ecx, ecx
  00bf9	0f 84 7a 02 00
	00		 je	 $LN48@AfterWMIni
  00bff	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _rW$15[ebp+12]
  00c05	2b 85 e0 fd ff
	ff		 sub	 eax, DWORD PTR _rW$15[ebp+4]
  00c0b	6a 01		 push	 1
  00c0d	50		 push	 eax
  00c0e	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _rW$15[ebp+8]
  00c14	2b 85 dc fd ff
	ff		 sub	 eax, DWORD PTR _rW$15[ebp]
  00c1a	50		 push	 eax
  00c1b	ff b5 80 fd ff
	ff		 push	 DWORD PTR _rD$9[ebp+4]
  00c21	ff b5 7c fd ff
	ff		 push	 DWORD PTR _rD$9[ebp]

; 9353 : 						return;

  00c27	e9 8a f5 ff ff	 jmp	 $LN565@AfterWMIni
$LN51@AfterWMIni:

; 9375 : 						EndMainDlg (MainDlg);
; 9376 : 						return;
; 9377 : 					}
; 9378 : 				}
; 9379 : 				else
; 9380 : 				{
; 9381 : 					BOOL bAnswerTerminate = FALSE, bAnswerRetry = FALSE;
; 9382 : 
; 9383 : 					/* Pretest failed 
; 9384 : 					or hidden OS cloning has been interrupted (and non-hidden OS is running)
; 9385 : 					or wiping of the original OS has not been started (and non-hidden OS is running) */
; 9386 : 
; 9387 : 					if (hiddenOSCreationPhase == GST_HIDDEN_OS_CREATION_PHASE_NONE)

  00c2c	85 db		 test	 ebx, ebx
  00c2e	75 57		 jne	 SHORT $LN58@AfterWMIni

; 9388 : 					{
; 9389 : 						// Pretest failed (no hidden operating system involved)
; 9390 : 
; 9391 : 						if (AskWarnYesNo ("BOOT_PRETEST_FAILED_RETRY") == IDYES)

  00c30	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@DFBAAIPH@BOOT_PRETEST_FAILED_RETRY?$AA@
  00c35	e8 00 00 00 00	 call	 _AskWarnYesNo
  00c3a	83 c4 04	 add	 esp, 4
  00c3d	83 f8 06	 cmp	 eax, 6
  00c40	0f 84 d0 00 00
	00		 je	 $LN62@AfterWMIni
$LN552@AfterWMIni:

; 9468 : 						}
; 9469 : 
; 9470 : 						EndMainDlg (MainDlg);
; 9471 : 						return;
; 9472 : 					}
; 9473 : 					else if (bAnswerTerminate)
; 9474 : 					{
; 9475 : 						// User doesn't want to retry pretest (or OS cloning), but to terminate the entire process
; 9476 : 
; 9477 : 						try
; 9478 : 						{
; 9479 : 							BootEncObj->Deinstall (true);

  00c46	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00c4c	6a 01		 push	 1
  00c4e	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 8
  00c55	e8 00 00 00 00	 call	 ?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z ; GostCrypt::BootEncryption::Deinstall
$LN105@AfterWMIni:
  00c5a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN568@AfterWMIni:

; 9486 : 
; 9487 : 						ManageStartupSeqWiz (TRUE, "");

  00c61	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00c66	6a 01		 push	 1
  00c68	e8 00 00 00 00	 call	 _ManageStartupSeqWiz

; 9488 : 						ChangeSystemEncryptionStatus (SYSENC_STATUS_NONE);

  00c6d	6a 00		 push	 0
  00c6f	e8 00 00 00 00	 call	 ?ChangeSystemEncryptionStatus@@YAHH@Z ; ChangeSystemEncryptionStatus

; 9489 : 						EndMainDlg (MainDlg);

  00c74	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00c7a	e8 00 00 00 00	 call	 _EndMainDlg
  00c7f	83 c4 10	 add	 esp, 16			; 00000010H

; 9490 : 						return;

  00c82	e9 f2 01 00 00	 jmp	 $LN48@AfterWMIni
$LN58@AfterWMIni:

; 9392 : 						{
; 9393 : 							// User wants to retry the pretest
; 9394 : 							bAnswerTerminate = FALSE;
; 9395 : 							bAnswerRetry = TRUE;
; 9396 : 						}
; 9397 : 						else
; 9398 : 						{
; 9399 : 							// User doesn't want to retry the pretest
; 9400 : 							bAnswerTerminate = TRUE;
; 9401 : 							bAnswerRetry = FALSE;
; 9402 : 						}
; 9403 : 					}
; 9404 : 					else
; 9405 : 					{
; 9406 : 						// Hidden OS cloning was interrupted or wiping of the original OS has not been started
; 9407 : 						
; 9408 : 						char *tmpStr[] = {0,
; 9409 : 							hiddenOSCreationPhase == GST_HIDDEN_OS_CREATION_PHASE_WIPING ? "OS_WIPING_NOT_FINISHED_ASK" : "HIDDEN_OS_CREATION_NOT_FINISHED_ASK",

  00c87	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CE@BLKNBIFF@HIDDEN_OS_CREATION_NOT_FINISHED_@
  00c8c	c7 85 3c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$21[ebp], 0
  00c96	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H

; 9410 : 							"HIDDEN_OS_CREATION_NOT_FINISHED_CHOICE_RETRY",

  00c9c	c7 85 44 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$21[ebp+8], OFFSET ??_C@_0CN@NFNCFNOG@HIDDEN_OS_CREATION_NOT_FINISHED_@
  00ca6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BL@BAAJMEPI@OS_WIPING_NOT_FINISHED_ASK?$AA@

; 9411 : 							"HIDDEN_OS_CREATION_NOT_FINISHED_CHOICE_TERMINATE",

  00cab	c7 85 48 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$21[ebp+12], OFFSET ??_C@_0DB@KJCGFBOB@HIDDEN_OS_CREATION_NOT_FINISHED_@
  00cb5	0f 45 c1	 cmovne	 eax, ecx

; 9412 : 							"HIDDEN_OS_CREATION_NOT_FINISHED_CHOICE_ASK_LATER",

  00cb8	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$21[ebp+16], OFFSET ??_C@_0DB@IJPDGLEP@HIDDEN_OS_CREATION_NOT_FINISHED_@
  00cc2	89 85 40 fe ff
	ff		 mov	 DWORD PTR _tmpStr$21[ebp+4], eax

; 9413 : 							0};
; 9414 : 
; 9415 : 						switch (AskMultiChoice ((void **) tmpStr, FALSE))

  00cc8	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _tmpStr$21[ebp]
  00cce	6a 00		 push	 0
  00cd0	50		 push	 eax
  00cd1	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$21[ebp+20], 0
  00cdb	e8 00 00 00 00	 call	 _AskMultiChoice
  00ce0	83 c4 08	 add	 esp, 8
  00ce3	83 e8 01	 sub	 eax, 1
  00ce6	74 2e		 je	 SHORT $LN62@AfterWMIni
  00ce8	83 e8 01	 sub	 eax, 1
  00ceb	0f 84 55 ff ff
	ff		 je	 $LN552@AfterWMIni
$LN82@AfterWMIni:

; 9491 : 					}
; 9492 : 					else 
; 9493 : 					{
; 9494 : 						// User doesn't want to take any action now
; 9495 : 
; 9496 : 						AbortProcessSilent();

  00cf1	e8 00 00 00 00	 call	 _AbortProcessSilent

; 9511 : 		}
; 9512 : 	}
; 9513 : 	else

  00cf6	e9 7e 01 00 00	 jmp	 $LN48@AfterWMIni
__catch$_AfterWMInitTasks$8:

; 9480 : 						}
; 9481 : 						catch (Exception &e)
; 9482 : 						{
; 9483 : 							e.Show (hwndDlg);

  00cfb	8b 8d b0 fc ff
	ff		 mov	 ecx, DWORD PTR _e$5[ebp]
  00d01	ff b5 b8 fc ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00d07	8b 01		 mov	 eax, DWORD PTR [ecx]
  00d09	ff 10		 call	 DWORD PTR [eax]

; 9484 : 							AbortProcessSilent();

  00d0b	e8 00 00 00 00	 call	 _AbortProcessSilent

; 9485 : 						}

  00d10	b8 00 00 00 00	 mov	 eax, $LN105@AfterWMIni
  00d15	c3		 ret	 0
$LN62@AfterWMIni:

; 9416 : 						{
; 9417 : 						case 1:
; 9418 : 							// User wants to restart and continue/retry
; 9419 : 							bAnswerTerminate = FALSE;
; 9420 : 							bAnswerRetry = TRUE;
; 9421 : 							break;
; 9422 : 
; 9423 : 						case 2:
; 9424 : 							// User doesn't want to retry but wants to terminate the entire process of hidden OS creation
; 9425 : 							bAnswerTerminate = TRUE;
; 9426 : 							bAnswerRetry = FALSE;
; 9427 : 							break;
; 9428 : 
; 9429 : 						default:
; 9430 : 							// User doesn't want to do anything now
; 9431 : 							bAnswerTerminate = FALSE;
; 9432 : 							bAnswerRetry = FALSE;
; 9433 : 						}
; 9434 : 					}
; 9435 : 
; 9436 : 
; 9437 : 					if (bAnswerRetry)
; 9438 : 					{
; 9439 : 						// User wants to restart and retry the pretest (or hidden OS creation)
; 9440 : 
; 9441 : 						// We re-register the driver for boot because the user may have selected
; 9442 : 						// "Last Known Good Configuration" from the Windows boot menu.
; 9443 : 						// Note that we need to do this even when creating a hidden OS (because 
; 9444 : 						// the hidden OS needs our boot driver and it will be a clone of this OS).
; 9445 : 						try
; 9446 : 						{
; 9447 : 							BootEncObj->RegisterBootDriver (bHiddenOS ? true : false);

  00d16	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00d1d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00d23	0f 95 c0	 setne	 al
  00d26	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  00d2d	0f b6 c0	 movzx	 eax, al
  00d30	50		 push	 eax
  00d31	e8 00 00 00 00	 call	 ?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z ; GostCrypt::BootEncryption::RegisterBootDriver
$LN101@AfterWMIni:

; 9453 : 
; 9454 : 						if (AskWarnYesNo ("CONFIRM_RESTART") == IDYES)

  00d36	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ICICKJJH@CONFIRM_RESTART?$AA@
  00d3b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00d42	e8 00 00 00 00	 call	 _AskWarnYesNo
  00d47	83 c4 04	 add	 esp, 4
  00d4a	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00d50	83 f8 06	 cmp	 eax, 6
  00d53	0f 85 a8 f8 ff
	ff		 jne	 $LN68@AfterWMIni

; 9455 : 						{
; 9456 : 							EndMainDlg (MainDlg);
; 9457 : 
; 9458 : 							try
; 9459 : 							{
; 9460 : 								BootEncObj->RestartComputer ();

  00d59	e8 00 00 00 00	 call	 _EndMainDlg
  00d5e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00d64	83 c4 04	 add	 esp, 4
  00d67	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  00d6e	e8 00 00 00 00	 call	 ?RestartComputer@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::RestartComputer
$LN103@AfterWMIni:

; 9466 : 
; 9467 : 							return;

  00d73	e9 01 01 00 00	 jmp	 $LN48@AfterWMIni
__catch$_AfterWMInitTasks$4:

; 9448 : 						}
; 9449 : 						catch (Exception &e)
; 9450 : 						{
; 9451 : 							e.Show (NULL);

  00d78	8b 8d ac fc ff
	ff		 mov	 ecx, DWORD PTR _e$4[ebp]
  00d7e	6a 00		 push	 0
  00d80	8b 01		 mov	 eax, DWORD PTR [ecx]
  00d82	ff 10		 call	 DWORD PTR [eax]

; 9452 : 						}

  00d84	b8 00 00 00 00	 mov	 eax, $LN101@AfterWMIni
  00d89	c3		 ret	 0
__catch$_AfterWMInitTasks$6:

; 9461 : 							}
; 9462 : 							catch (Exception &e)
; 9463 : 							{
; 9464 : 								e.Show (hwndDlg);

  00d8a	8b 8d a8 fc ff
	ff		 mov	 ecx, DWORD PTR _e$3[ebp]
  00d90	ff b5 b8 fc ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00d96	8b 01		 mov	 eax, DWORD PTR [ecx]
  00d98	ff 10		 call	 DWORD PTR [eax]

; 9465 : 							}

  00d9a	b8 00 00 00 00	 mov	 eax, $LN103@AfterWMIni
  00d9f	c3		 ret	 0
__catch$_AfterWMInitTasks$2:

; 9315 : 				}
; 9316 : 				catch (Exception &e)
; 9317 : 				{
; 9318 : 					e.Show (hwndDlg);

  00da0	8b 8d a4 fc ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  00da6	ff b5 b8 fc ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00dac	8b 01		 mov	 eax, DWORD PTR [ecx]
  00dae	ff 10		 call	 DWORD PTR [eax]

; 9319 : 					Error ("ERR_GETTING_SYSTEM_ENCRYPTION_STATUS");

  00db0	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@
  00db5	e8 00 00 00 00	 call	 _Error

; 9320 : 					EndMainDlg (MainDlg);

  00dba	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00dc0	e8 00 00 00 00	 call	 _EndMainDlg
  00dc5	83 c4 08	 add	 esp, 8

; 9321 : 					return;

  00dc8	b8 00 00 00 00	 mov	 eax, $LN99@AfterWMIni
  00dcd	c3		 ret	 0
$LN99@AfterWMIni:
  00dce	e9 a6 00 00 00	 jmp	 $LN48@AfterWMIni
$LN47@AfterWMIni:

; 9514 : 	{
; 9515 : 		if (DirectDeviceEncMode)

  00dd3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DirectDeviceEncMode@@3HA, 0 ; DirectDeviceEncMode
  00dda	74 0a		 je	 SHORT $LN74@AfterWMIni

; 9516 : 		{
; 9517 : 			SwitchWizardToNonSysDeviceMode();

  00ddc	e8 00 00 00 00	 call	 ?SwitchWizardToNonSysDeviceMode@@YAXXZ ; SwitchWizardToNonSysDeviceMode

; 9518 : 			return;

  00de1	e9 93 00 00 00	 jmp	 $LN48@AfterWMIni
$LN74@AfterWMIni:

; 9519 : 		}
; 9520 : 
; 9521 : 		if (DirectPromptNonSysInplaceEncResumeMode
; 9522 : 			&& !bInPlaceEncNonSysPending)

  00de6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DirectPromptNonSysInplaceEncResumeMode@@3HA ; DirectPromptNonSysInplaceEncResumeMode
  00deb	85 c0		 test	 eax, eax
  00ded	74 33		 je	 SHORT $LN557@AfterWMIni
  00def	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSysPending, 0
  00df6	75 2a		 jne	 SHORT $LN557@AfterWMIni

; 9523 : 		{
; 9524 : 			// This instance of the wizard has been launched via the system startup sequence to prompt for resume of
; 9525 : 			// a non-system in-place encryption process. However, no config file indicates that any such process
; 9526 : 			// has been interrupted. This inconsistency may occur, for example, when the process is finished
; 9527 : 			// but the wizard is not removed from the startup sequence because system encryption is in progress.
; 9528 : 			// Therefore, we remove it from the startup sequence now if possible.
; 9529 : 
; 9530 : 			if (!IsNonInstallMode () && SystemEncryptionStatus == SYSENC_STATUS_NONE)

  00df8	e8 00 00 00 00	 call	 _IsNonInstallMode
  00dfd	85 c0		 test	 eax, eax
  00dff	75 17		 jne	 SHORT $LN76@AfterWMIni
  00e01	39 05 00 00 00
	00		 cmp	 DWORD PTR _SystemEncryptionStatus, eax
  00e07	75 0f		 jne	 SHORT $LN76@AfterWMIni

; 9531 : 				ManageStartupSeqWiz (TRUE, "");

  00e09	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00e0e	6a 01		 push	 1
  00e10	e8 00 00 00 00	 call	 _ManageStartupSeqWiz
  00e15	83 c4 08	 add	 esp, 8
$LN76@AfterWMIni:

; 9532 : 
; 9533 : 			AbortProcessSilent ();

  00e18	e8 00 00 00 00	 call	 _AbortProcessSilent
  00e1d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DirectPromptNonSysInplaceEncResumeMode@@3HA ; DirectPromptNonSysInplaceEncResumeMode
$LN557@AfterWMIni:

; 9534 : 		}
; 9535 : 
; 9536 : 		if (DirectNonSysInplaceEncResumeMode)

  00e22	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DirectNonSysInplaceEncResumeMode@@3HA, 0 ; DirectNonSysInplaceEncResumeMode
  00e29	75 20		 jne	 SHORT $LN569@AfterWMIni

; 9537 : 		{
; 9538 : 			SwitchWizardToNonSysInplaceEncResumeMode();
; 9539 : 			return;
; 9540 : 		}
; 9541 : 		else if (DirectPromptNonSysInplaceEncResumeMode)

  00e2b	85 c0		 test	 eax, eax
  00e2d	74 23		 je	 SHORT $LN79@AfterWMIni

; 9542 : 		{
; 9543 : 			if (NonSysInplaceEncInProgressElsewhere ())

  00e2f	e8 00 00 00 00	 call	 _NonSysInplaceEncInProgressElsewhere
  00e34	85 c0		 test	 eax, eax
  00e36	74 05		 je	 SHORT $LN81@AfterWMIni

; 9544 : 				AbortProcessSilent ();

  00e38	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN81@AfterWMIni:

; 9545 : 
; 9546 : 			if (AskNonSysInPlaceEncryptionResume() == IDYES)

  00e3d	e8 00 00 00 00	 call	 _AskNonSysInPlaceEncryptionResume
  00e42	83 f8 06	 cmp	 eax, 6
  00e45	0f 85 a6 fe ff
	ff		 jne	 $LN82@AfterWMIni
$LN569@AfterWMIni:

; 9547 : 				SwitchWizardToNonSysInplaceEncResumeMode();

  00e4b	e8 00 00 00 00	 call	 ?SwitchWizardToNonSysInplaceEncResumeMode@@YAXXZ ; SwitchWizardToNonSysInplaceEncResumeMode

; 9548 : 			else

  00e50	eb 27		 jmp	 SHORT $LN48@AfterWMIni
$LN79@AfterWMIni:

; 9549 : 				AbortProcessSilent ();
; 9550 : 
; 9551 : 			return;
; 9552 : 		}
; 9553 : 		else if (bInPlaceEncNonSysPending
; 9554 : 			&& !NonSysInplaceEncInProgressElsewhere ()
; 9555 : 			&& AskNonSysInPlaceEncryptionResume() == IDYES)

  00e52	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSysPending, 0
  00e59	74 13		 je	 SHORT $LN84@AfterWMIni
  00e5b	e8 00 00 00 00	 call	 _NonSysInplaceEncInProgressElsewhere
  00e60	85 c0		 test	 eax, eax
  00e62	75 0a		 jne	 SHORT $LN84@AfterWMIni
  00e64	e8 00 00 00 00	 call	 _AskNonSysInPlaceEncryptionResume
  00e69	83 f8 06	 cmp	 eax, 6
  00e6c	74 dd		 je	 SHORT $LN569@AfterWMIni
$LN84@AfterWMIni:

; 9556 : 		{
; 9557 : 			SwitchWizardToNonSysInplaceEncResumeMode();
; 9558 : 			return;
; 9559 : 		}
; 9560 : 
; 9561 : 		LoadPage (hwndDlg, INTRO_PAGE);

  00e6e	6a 00		 push	 0
  00e70	53		 push	 ebx
  00e71	e8 00 00 00 00	 call	 _LoadPage
$LN561@AfterWMIni:
  00e76	83 c4 08	 add	 esp, 8
$LN48@AfterWMIni:

; 9562 : 	}
; 9563 : }

  00e79	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00e7c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00e83	59		 pop	 ecx
  00e84	5f		 pop	 edi
  00e85	5e		 pop	 esi
  00e86	5b		 pop	 ebx
  00e87	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e8a	33 cd		 xor	 ecx, ebp
  00e8c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e91	8b e5		 mov	 esp, ebp
  00e93	5d		 pop	 ebp
  00e94	c3		 ret	 0
  00e95	0f 1f 00	 npad	 3
$LN570@AfterWMIni:
  00e98	00 00 00 00	 DD	 $LN20@AfterWMIni
  00e9c	00 00 00 00	 DD	 $LN20@AfterWMIni
  00ea0	00 00 00 00	 DD	 $LN26@AfterWMIni
  00ea4	00 00 00 00	 DD	 $LN2@AfterWMIni
  00ea8	00 00 00 00	 DD	 $LN31@AfterWMIni
  00eac	00 00 00 00	 DD	 $LN31@AfterWMIni
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_AfterWMInitTasks:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a a0 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-864]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_AfterWMInitTasks
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_AfterWMInitTasks ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _WipeHiddenOSCreationConfig
_TEXT	SEGMENT
_e$2 = -24						; size = 4
_finally8982$3 = -17					; size = 1
__$EHRec$ = -16						; size = 16
_WipeHiddenOSCreationConfig PROC			; COMDAT

; 8976 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_WipeHiddenOSCreationConfig
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 8977 : 	if (!IsHiddenOSRunning())

  0002b	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  00030	85 c0		 test	 eax, eax
  00032	75 1f		 jne	 SHORT __tryend$_WipeHiddenOSCreationConfig$1

; 8978 : 	{
; 8979 : 		try

  00034	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax

; 8980 : 		{
; 8981 : 			WaitCursor();

  00037	e8 00 00 00 00	 call	 _WaitCursor

; 8982 : 			finally_do ({ NormalCursor(); });
; 8983 : 
; 8984 : 			BootEncObj->WipeHiddenOSCreationConfig();

  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00042	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00046	e8 00 00 00 00	 call	 ?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::WipeHiddenOSCreationConfig

; 8985 : 		}

  0004b	8d 4d ef	 lea	 ecx, DWORD PTR _finally8982$3[ebp]
  0004e	e8 00 00 00 00	 call	 ??1Finally8982@?5??WipeHiddenOSCreationConfig@@YAHXZ@QAE@XZ ; `WipeHiddenOSCreationConfig'::`6'::Finally8982::~Finally8982
__tryend$_WipeHiddenOSCreationConfig$1:

; 8990 : 		}
; 8991 : 	}
; 8992 : 
; 8993 : 	return TRUE;

  00053	b8 01 00 00 00	 mov	 eax, 1

; 8994 : }

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
__catch$_WipeHiddenOSCreationConfig$0:

; 8986 : 		catch (Exception &e)
; 8987 : 		{
; 8988 : 			e.Show (MainDlg);

  0006a	8b 4d e8	 mov	 ecx, DWORD PTR _e$2[ebp]
  0006d	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00073	8b 01		 mov	 eax, DWORD PTR [ecx]
  00075	ff 10		 call	 DWORD PTR [eax]

; 8989 : 			return FALSE;

  00077	b8 00 00 00 00	 mov	 eax, $LN9@WipeHidden
  0007c	c3		 ret	 0
$LN9@WipeHidden:
  0007d	33 c0		 xor	 eax, eax

; 8994 : }

  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00089	59		 pop	 ecx
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_WipeHiddenOSCreationConfig$2:
  00000	8d 4d ef	 lea	 ecx, DWORD PTR _finally8982$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Finally8982@?5??WipeHiddenOSCreationConfig@@YAHXZ@QAE@XZ ; `WipeHiddenOSCreationConfig'::`6'::Finally8982::~Finally8982
__ehhandler$_WipeHiddenOSCreationConfig:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_WipeHiddenOSCreationConfig
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_WipeHiddenOSCreationConfig ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _ResolveUnknownSysEncDirection
_TEXT	SEGMENT
_e$2 = -144						; size = 4
$T3 = -140						; size = 94
_tmpStr$4 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_ResolveUnknownSysEncDirection PROC			; COMDAT

; 1243 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_ResolveUnknownSysEncDirection
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1244 : 	if (CreateSysEncMutex ())

  00031	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00036	85 c0		 test	 eax, eax
  00038	0f 84 34 01 00
	00		 je	 $LN4@ResolveUnk

; 1245 : 	{
; 1246 : 		if (SystemEncryptionStatus != SYSENC_STATUS_ENCRYPTING
; 1247 : 			&& SystemEncryptionStatus != SYSENC_STATUS_DECRYPTING)

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionStatus
  00043	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  00048	0f 84 1d 01 00
	00		 je	 $LN6@ResolveUnk
  0004e	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  00053	0f 84 12 01 00
	00		 je	 $LN6@ResolveUnk

; 1248 : 		{
; 1249 : 			try
; 1250 : 			{
; 1251 : 				BootEncStatus = BootEncObj->GetStatus();

  00059	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0005f	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00065	50		 push	 eax
  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0006d	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00072	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0007e	8b f0		 mov	 esi, eax
  00080	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  00085	f3 a5		 rep movsd
  00087	66 a5		 movsw
  00089	83 3d 3e 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+62, 0
  00090	74 22		 je	 SHORT $LN9@ResolveUnk

; 1258 : 			}
; 1259 : 
; 1260 : 			if (BootEncStatus.SetupInProgress)
; 1261 : 			{
; 1262 : 				return ChangeSystemEncryptionStatus (

  00092	83 3d 42 00 00
	00 02		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+66, 2
  00099	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  0009e	b8 58 02 00 00	 mov	 eax, 600		; 00000258H
  000a3	0f 45 c1	 cmovne	 eax, ecx
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ?ChangeSystemEncryptionStatus@@YAHH@Z ; ChangeSystemEncryptionStatus
  000ac	83 c4 04	 add	 esp, 4
  000af	e9 cd 00 00 00	 jmp	 $LN5@ResolveUnk
$LN9@ResolveUnk:

; 1263 : 					(BootEncStatus.SetupMode != SetupDecryption) ? SYSENC_STATUS_ENCRYPTING : SYSENC_STATUS_DECRYPTING);
; 1264 : 			}
; 1265 : 			else
; 1266 : 			{
; 1267 : 				// Ask the user to select encryption, decryption, or cancel
; 1268 : 
; 1269 : 				char *tmpStr[] = {0,
; 1270 : 					!BootEncStatus.DriveEncrypted ? "CHOOSE_ENCRYPT_OR_DECRYPT_FINALIZE_DECRYPT_NOTE" : "CHOOSE_ENCRYPT_OR_DECRYPT",

  000b4	83 3d 0e 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+14, 0
  000bb	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BK@CFANEEFJ@CHOOSE_ENCRYPT_OR_DECRYPT?$AA@
  000c0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DA@NNBJDAHG@CHOOSE_ENCRYPT_OR_DECRYPT_FINALI@
  000c5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _tmpStr$4[ebp], 0
  000cc	0f 45 c1	 cmovne	 eax, ecx

; 1271 : 					"ENCRYPT",

  000cf	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _tmpStr$4[ebp+8], OFFSET ??_C@_07CAOFPAJK@ENCRYPT?$AA@
  000d6	89 45 d8	 mov	 DWORD PTR _tmpStr$4[ebp+4], eax

; 1272 : 					"DECRYPT",
; 1273 : 					"IDCANCEL",
; 1274 : 					0};
; 1275 : 
; 1276 : 				switch (AskMultiChoice ((void **) tmpStr, FALSE))

  000d9	8d 45 d4	 lea	 eax, DWORD PTR _tmpStr$4[ebp]
  000dc	6a 00		 push	 0
  000de	50		 push	 eax
  000df	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _tmpStr$4[ebp+12], OFFSET ??_C@_07OOEIKEPO@DECRYPT?$AA@
  000e6	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _tmpStr$4[ebp+16], OFFSET ??_C@_08DDAIHKOO@IDCANCEL?$AA@
  000ed	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _tmpStr$4[ebp+20], 0
  000f4	e8 00 00 00 00	 call	 _AskMultiChoice
  000f9	83 c4 08	 add	 esp, 8
  000fc	83 e8 01	 sub	 eax, 1
  000ff	74 38		 je	 SHORT $LN11@ResolveUnk
  00101	83 e8 01	 sub	 eax, 1
  00104	75 79		 jne	 SHORT $LN27@ResolveUnk

; 1280 : 				case 2:
; 1281 : 					return ChangeSystemEncryptionStatus (SYSENC_STATUS_DECRYPTING);

  00106	e8 00 00 00 00	 call	 _CreateSysEncMutex
  0010b	85 c0		 test	 eax, eax
  0010d	74 63		 je	 SHORT $LN4@ResolveUnk
  0010f	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00115	c7 05 00 00 00
	00 58 02 00 00	 mov	 DWORD PTR _SystemEncryptionStatus, 600 ; 00000258H
  0011f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 1
  00129	e8 00 00 00 00	 call	 ?SaveSysEncSettings@@YAHPAUHWND__@@@Z ; SaveSysEncSettings
  0012e	83 c4 04	 add	 esp, 4
  00131	f7 d8		 neg	 eax
  00133	1b c0		 sbb	 eax, eax
  00135	f7 d8		 neg	 eax
  00137	eb 48		 jmp	 SHORT $LN5@ResolveUnk
$LN11@ResolveUnk:

; 1277 : 				{
; 1278 : 				case 1:
; 1279 : 					return ChangeSystemEncryptionStatus (SYSENC_STATUS_ENCRYPTING);

  00139	68 90 01 00 00	 push	 400			; 00000190H
  0013e	e8 00 00 00 00	 call	 ?ChangeSystemEncryptionStatus@@YAHH@Z ; ChangeSystemEncryptionStatus
  00143	83 c4 04	 add	 esp, 4
  00146	eb 39		 jmp	 SHORT $LN5@ResolveUnk
__catch$_ResolveUnknownSysEncDirection$0:

; 1252 : 			}
; 1253 : 			catch (Exception &e)
; 1254 : 			{
; 1255 : 				e.Show (MainDlg);

  00148	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  0014e	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00154	8b 01		 mov	 eax, DWORD PTR [ecx]
  00156	ff 10		 call	 DWORD PTR [eax]

; 1256 : 				Error ("ERR_GETTING_SYSTEM_ENCRYPTION_STATUS");

  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@
  0015d	e8 00 00 00 00	 call	 _Error
  00162	83 c4 04	 add	 esp, 4

; 1257 : 				return FALSE;

  00165	b8 00 00 00 00	 mov	 eax, $LN27@ResolveUnk
  0016a	c3		 ret	 0
$LN6@ResolveUnk:

; 1282 : 				default:
; 1283 : 					return FALSE;
; 1284 : 				}
; 1285 : 			}
; 1286 : 		}
; 1287 : 		else
; 1288 : 			return TRUE;

  0016b	b8 01 00 00 00	 mov	 eax, 1
  00170	eb 0f		 jmp	 SHORT $LN5@ResolveUnk
$LN4@ResolveUnk:

; 1289 : 	}
; 1290 : 	else
; 1291 : 	{
; 1292 : 		Error ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");

  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00177	e8 00 00 00 00	 call	 _Error
  0017c	83 c4 04	 add	 esp, 4
$LN27@ResolveUnk:

; 1293 : 		return FALSE;

  0017f	33 c0		 xor	 eax, eax
$LN5@ResolveUnk:

; 1294 : 	}
; 1295 : }

  00181	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00184	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018b	59		 pop	 ecx
  0018c	5f		 pop	 edi
  0018d	5e		 pop	 esi
  0018e	5b		 pop	 ebx
  0018f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00192	33 cd		 xor	 ecx, ebp
  00194	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_ResolveUnknownSysEncDirection:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 6c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-148]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_ResolveUnknownSysEncDirection
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_ResolveUnknownSysEncDirection ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _SwitchWizardToFileContainerMode
_TEXT	SEGMENT
_rD$1 = -104						; size = 16
_rW$2 = -88						; size = 16
_tmp$3 = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_SwitchWizardToFileContainerMode PROC			; COMDAT

; 1122 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1123 : 	ChangeWizardMode (WIZARD_MODE_FILE_CONTAINER);

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _WizardMode, 0
  00017	74 43		 je	 SHORT $LN4@SwitchWiza
  00019	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  00020	75 05		 jne	 SHORT $LN5@SwitchWiza
  00022	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
$LN5@SwitchWiza:
  00027	0f 57 c0	 xorps	 xmm0, xmm0
  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  00034	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  0003b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  00042	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  0004a	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  00052	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WizardMode, 0
$LN4@SwitchWiza:
  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  00061	f7 d8		 neg	 eax
  00063	1b c0		 sbb	 eax, eax
  00065	f7 d8		 neg	 eax
  00067	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  0006e	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice
  00073	75 05		 jne	 SHORT $LN12@SwitchWiza
  00075	e8 00 00 00 00	 call	 _CloseSysEncMutex
$LN12@SwitchWiza:

; 1124 : 
; 1125 : 	LoadPage (MainDlg, VOLUME_LOCATION_PAGE);

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  00085	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  0008b	53		 push	 ebx
  0008c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _MainDlg
  00092	56		 push	 esi
  00093	57		 push	 edi
  00094	85 c0		 test	 eax, eax
  00096	74 57		 je	 SHORT $LN26@SwitchWiza
  00098	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  000a2	83 f9 15	 cmp	 ecx, 21			; 00000015H
  000a5	75 37		 jne	 SHORT $LN20@SwitchWiza
  000a7	6a 40		 push	 64			; 00000040H
  000a9	8d 45 b8	 lea	 eax, DWORD PTR _tmp$3[ebp]
  000ac	6a 58		 push	 88			; 00000058H
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _memset
  000b4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  000ba	8d 45 b8	 lea	 eax, DWORD PTR _tmp$3[ebp]
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c0	c6 45 f8 00	 mov	 BYTE PTR _tmp$3[ebp+64], 0
  000c4	50		 push	 eax
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  000ca	50		 push	 eax
  000cb	ff d6		 call	 esi
  000cd	8d 45 b8	 lea	 eax, DWORD PTR _tmp$3[ebp]
  000d0	50		 push	 eax
  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  000d6	50		 push	 eax
  000d7	ff d6		 call	 esi
  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN20@SwitchWiza:
  000de	50		 push	 eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  000e5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN26@SwitchWiza:
  000ef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  000f9	e8 00 00 00 00	 call	 _NormalCursor
  000fe	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00104	8d 45 a8	 lea	 eax, DWORD PTR _rW$2[ebp]
  00107	50		 push	 eax
  00108	68 23 04 00 00	 push	 1059			; 00000423H
  0010d	53		 push	 ebx
  0010e	ff d7		 call	 edi
  00110	50		 push	 eax
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00117	6a 00		 push	 0
  00119	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  0011e	53		 push	 ebx
  0011f	6a 69		 push	 105			; 00000069H
  00121	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00127	c7 05 00 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 14 ; nCurPageNo, 0000000eH
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  00137	33 c9		 xor	 ecx, ecx
  00139	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  0013e	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?bHistoryCmdLine@@3HA, ecx ; bHistoryCmdLine
  00144	0f 94 c1	 sete	 cl
  00147	51		 push	 ecx
  00148	68 f4 03 00 00	 push	 1012			; 000003f4H
  0014d	50		 push	 eax
  0014e	ff d7		 call	 edi
  00150	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00156	50		 push	 eax
  00157	ff d6		 call	 esi
  00159	68 ea 03 00 00	 push	 1002			; 000003eaH
  0015e	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00164	ff d7		 call	 edi
  00166	50		 push	 eax
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  0016d	33 c9		 xor	 ecx, ecx
  0016f	85 c0		 test	 eax, eax
  00171	0f 9f c1	 setg	 cl
  00174	51		 push	 ecx
  00175	68 10 04 00 00	 push	 1040			; 00000410H
  0017a	53		 push	 ebx
  0017b	ff d7		 call	 edi
  0017d	50		 push	 eax
  0017e	ff d6		 call	 esi
  00180	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  00187	8d 45 98	 lea	 eax, DWORD PTR _rD$1[ebp]
  0018a	50		 push	 eax
  0018b	53		 push	 ebx
  0018c	0f 11 45 98	 movups	 XMMWORD PTR _rD$1[ebp], xmm0
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00196	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi
  0019e	5b		 pop	 ebx
  0019f	85 c9		 test	 ecx, ecx
  001a1	74 2b		 je	 SHORT $LN71@SwitchWiza
  001a3	8b 45 b4	 mov	 eax, DWORD PTR _rW$2[ebp+12]
  001a6	2b 45 ac	 sub	 eax, DWORD PTR _rW$2[ebp+4]
  001a9	6a 01		 push	 1
  001ab	50		 push	 eax
  001ac	8b 45 b0	 mov	 eax, DWORD PTR _rW$2[ebp+8]
  001af	2b 45 a8	 sub	 eax, DWORD PTR _rW$2[ebp]
  001b2	50		 push	 eax
  001b3	ff 75 9c	 push	 DWORD PTR _rD$1[ebp+4]
  001b6	ff 75 98	 push	 DWORD PTR _rD$1[ebp]
  001b9	51		 push	 ecx
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  001c0	6a 01		 push	 1
  001c2	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  001c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN71@SwitchWiza:

; 1126 : 
; 1127 : 	NormalCursor ();

  001ce	e8 00 00 00 00	 call	 _NormalCursor

; 1128 : }

  001d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d6	33 cd		 xor	 ecx, ebp
  001d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c3		 ret	 0
_SwitchWizardToFileContainerMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _SwitchWizardToSysEncMode
_TEXT	SEGMENT
_e$2 = -600						; size = 4
_e$3 = -596						; size = 4
_e$4 = -592						; size = 4
$T5 = -588						; size = 94
$T6 = -492						; size = 24
$T7 = -468						; size = 24
$T8 = -444						; size = 24
_rD$9 = -420						; size = 16
_rD$10 = -404						; size = 16
_rD$11 = -388						; size = 16
_rD$12 = -372						; size = 16
_rW$13 = -356						; size = 16
_rW$14 = -340						; size = 16
_rW$15 = -324						; size = 16
_rW$16 = -308						; size = 16
_tmp$17 = -292						; size = 65
_tmp$18 = -224						; size = 65
_tmp$19 = -156						; size = 65
_tmp$20 = -88						; size = 65
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_SwitchWizardToSysEncMode PROC				; COMDAT

; 915  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_SwitchWizardToSysEncMode
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 4c 02 00
	00		 sub	 esp, 588		; 0000024cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 916  : 	WaitCursor ();

  00031	e8 00 00 00 00	 call	 _WaitCursor

; 917  : 
; 918  : 	try
; 919  : 	{
; 920  : 		BootEncStatus = BootEncObj->GetStatus();

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0003c	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00042	50		 push	 eax
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0004a	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  0004f	8b f0		 mov	 esi, eax
  00051	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00056	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  0005b	f3 a5		 rep movsd

; 921  : 		bWholeSysDrive = BootEncObj->SystemPartitionCoversWholeDrive();

  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00063	66 a5		 movsw
  00065	e8 00 00 00 00	 call	 ?SystemPartitionCoversWholeDrive@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemPartitionCoversWholeDrive
  0006a	0f b6 c0	 movzx	 eax, al
  0006d	a3 00 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, eax ; bWholeSysDrive
  00072	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00079	e8 00 00 00 00	 call	 _CreateSysEncMutex
  0007e	85 c0		 test	 eax, eax
  00080	75 0f		 jne	 SHORT $LN3@SwitchWiza

; 929  : 	}
; 930  : 
; 931  : 	// From now on, we should be the only instance of the GST wizard allowed to deal with system encryption
; 932  : 	if (!CreateSysEncMutex ())
; 933  : 	{
; 934  : 		Warning ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");

  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00087	e8 00 00 00 00	 call	 _Warning

; 935  : 		NormalCursor ();
; 936  : 		return FALSE;

  0008c	e9 01 02 00 00	 jmp	 $LN393@SwitchWiza
$LN3@SwitchWiza:

; 937  : 	}
; 938  : 
; 939  : 	// User-mode app may have crashed and its mutex may have gotten lost, so we need to check the driver status too
; 940  : 	if (BootEncStatus.SetupInProgress)

  00091	83 3d 3e 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+62, 0
  00098	0f 84 1a 02 00
	00		 je	 $LN6@SwitchWiza

; 941  : 	{
; 942  : 		if (AskWarnYesNo ("SYSTEM_ENCRYPTION_RESUME_PROMPT") == IDYES)

  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HDGOHFPD@SYSTEM_ENCRYPTION_RESUME_PROMPT?$AA@
  000a3	e8 00 00 00 00	 call	 _AskWarnYesNo
  000a8	83 c4 04	 add	 esp, 4
  000ab	83 f8 06	 cmp	 eax, 6
  000ae	0f 85 cf 01 00
	00		 jne	 $LN5@SwitchWiza

; 943  : 		{
; 944  : 			if (SystemEncryptionStatus != SYSENC_STATUS_ENCRYPTING
; 945  : 				&& SystemEncryptionStatus != SYSENC_STATUS_DECRYPTING)

  000b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionStatus
  000b9	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  000be	74 1a		 je	 SHORT $LN8@SwitchWiza
  000c0	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  000c5	74 13		 je	 SHORT $LN8@SwitchWiza

; 946  : 			{
; 947  : 				// The config file with status was lost or not written correctly
; 948  : 				if (!ResolveUnknownSysEncDirection ())

  000c7	e8 00 00 00 00	 call	 _ResolveUnknownSysEncDirection
  000cc	85 c0		 test	 eax, eax
  000ce	75 0a		 jne	 SHORT $LN8@SwitchWiza
$LN390@SwitchWiza:

; 949  : 				{
; 950  : 					CloseSysEncMutex ();	

  000d0	e8 00 00 00 00	 call	 _CloseSysEncMutex

; 952  : 					return FALSE;

  000d5	e9 bb 01 00 00	 jmp	 $LN391@SwitchWiza
$LN8@SwitchWiza:

; 953  : 				}
; 954  : 			}
; 955  : 
; 956  : 			bDirectSysEncMode = TRUE;
; 957  : 			ChangeWizardMode (WIZARD_MODE_SYS_DEVICE);

  000da	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  000e1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDirectSysEncMode@@3HA, 1 ; bDirectSysEncMode
  000eb	74 57		 je	 SHORT $LN56@SwitchWiza
  000ed	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  000f2	e8 00 00 00 00	 call	 _CreateSysEncMutex
  000f7	85 c0		 test	 eax, eax
  000f9	75 0f		 jne	 SHORT $LN60@SwitchWiza
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00100	e8 00 00 00 00	 call	 _Error
  00105	83 c4 04	 add	 esp, 4
  00108	eb 4a		 jmp	 SHORT $LN64@SwitchWiza
$LN60@SwitchWiza:
  0010a	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
  0010f	0f 57 c0	 xorps	 xmm0, xmm0
  00112	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  0011c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  00123	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  0012a	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  00132	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  0013a	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _WizardMode, 2
$LN56@SwitchWiza:
  00144	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  00149	f7 d8		 neg	 eax
  0014b	1b c0		 sbb	 eax, eax
  0014d	f7 d8		 neg	 eax
  0014f	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice
$LN64@SwitchWiza:

; 958  : 			LoadPage (MainDlg, SYSENC_ENCRYPTION_PAGE);

  00154	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  00159	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  0015f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _MainDlg
  00165	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  0016b	85 c0		 test	 eax, eax
  0016d	74 57		 je	 SHORT $LN79@SwitchWiza
  0016f	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  00179	83 f9 15	 cmp	 ecx, 21			; 00000015H
  0017c	75 37		 jne	 SHORT $LN73@SwitchWiza
  0017e	6a 40		 push	 64			; 00000040H
  00180	8d 45 a8	 lea	 eax, DWORD PTR _tmp$20[ebp]
  00183	6a 58		 push	 88			; 00000058H
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 _memset
  0018b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  00191	8d 45 a8	 lea	 eax, DWORD PTR _tmp$20[ebp]
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH
  00197	c6 45 e8 00	 mov	 BYTE PTR _tmp$20[ebp+64], 0
  0019b	50		 push	 eax
  0019c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  001a1	50		 push	 eax
  001a2	ff d6		 call	 esi
  001a4	8d 45 a8	 lea	 eax, DWORD PTR _tmp$20[ebp]
  001a7	50		 push	 eax
  001a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  001ad	50		 push	 eax
  001ae	ff d6		 call	 esi
  001b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN73@SwitchWiza:
  001b5	50		 push	 eax
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  001bc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN79@SwitchWiza:
  001c6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  001d0	e8 00 00 00 00	 call	 _NormalCursor
  001d5	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _rW$16[ebp]
  001db	50		 push	 eax
  001dc	68 23 04 00 00	 push	 1059			; 00000423H
  001e1	57		 push	 edi
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001e8	50		 push	 eax
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  001ef	6a 00		 push	 0
  001f1	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  001f6	57		 push	 edi
  001f7	6a 7a		 push	 122			; 0000007aH
  001f9	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  001ff	c7 05 00 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 31 ; nCurPageNo, 0000001fH
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  0020f	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  00216	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  0021b	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _rD$12[ebp]
  00221	50		 push	 eax
  00222	57		 push	 edi
  00223	0f 11 85 8c fe
	ff ff		 movups	 XMMWORD PTR _rD$12[ebp], xmm0
  0022a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  00236	85 c9		 test	 ecx, ecx
  00238	74 3d		 je	 SHORT $LN124@SwitchWiza
  0023a	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rW$16[ebp+12]
  00240	2b 85 d0 fe ff
	ff		 sub	 eax, DWORD PTR _rW$16[ebp+4]
  00246	6a 01		 push	 1
  00248	50		 push	 eax
  00249	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _rW$16[ebp+8]
  0024f	2b 85 cc fe ff
	ff		 sub	 eax, DWORD PTR _rW$16[ebp]
  00255	50		 push	 eax
  00256	ff b5 90 fe ff
	ff		 push	 DWORD PTR _rD$12[ebp+4]
  0025c	ff b5 8c fe ff
	ff		 push	 DWORD PTR _rD$12[ebp]
$LN392@SwitchWiza:
  00262	51		 push	 ecx
  00263	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  00269	6a 01		 push	 1
  0026b	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN124@SwitchWiza:

; 959  : 			NormalCursor ();

  00277	e8 00 00 00 00	 call	 _NormalCursor

; 960  : 			return TRUE;

  0027c	b8 01 00 00 00	 mov	 eax, 1
  00281	eb 19		 jmp	 SHORT $LN10@SwitchWiza
$LN5@SwitchWiza:

; 961  : 		}
; 962  : 		else
; 963  : 		{
; 964  : 			CloseSysEncMutex ();	

  00283	e8 00 00 00 00	 call	 _CloseSysEncMutex

; 965  : 			Error ("SYS_ENCRYPTION_OR_DECRYPTION_IN_PROGRESS");

  00288	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@GFEACENL@SYS_ENCRYPTION_OR_DECRYPTION_IN_@
$LN394@SwitchWiza:

; 1029 : 		}
; 1030 : 
; 1031 : 		if (!ChangeWizardMode (WIZARD_MODE_SYS_DEVICE))

  0028d	e8 00 00 00 00	 call	 _Error
$LN393@SwitchWiza:

; 965  : 			Error ("SYS_ENCRYPTION_OR_DECRYPTION_IN_PROGRESS");

  00292	83 c4 04	 add	 esp, 4
$LN391@SwitchWiza:

; 951  : 					NormalCursor ();

  00295	e8 00 00 00 00	 call	 _NormalCursor
$LN50@SwitchWiza:

; 928  : 		return FALSE;

  0029a	33 c0		 xor	 eax, eax
$LN10@SwitchWiza:

; 1111 : 	}
; 1112 : }

  0029c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0029f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002a6	59		 pop	 ecx
  002a7	5f		 pop	 edi
  002a8	5e		 pop	 esi
  002a9	5b		 pop	 ebx
  002aa	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ad	33 cd		 xor	 ecx, ebp
  002af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b4	8b e5		 mov	 esp, ebp
  002b6	5d		 pop	 ebp
  002b7	c3		 ret	 0
$LN6@SwitchWiza:

; 966  : 			NormalCursor ();
; 967  : 			return FALSE;
; 968  : 		}
; 969  : 	}
; 970  : 
; 971  : 	if (BootEncStatus.DriveMounted
; 972  : 		|| BootEncStatus.DriveEncrypted
; 973  : 		|| SysEncryptionOrDecryptionRequired ())

  002b8	83 3d 06 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+6, 0
  002bf	0f 85 6b 05 00
	00		 jne	 $LN11@SwitchWiza
  002c5	83 3d 0e 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+14, 0
  002cc	0f 85 5e 05 00
	00		 jne	 $LN11@SwitchWiza
  002d2	e8 00 00 00 00	 call	 ?SysEncryptionOrDecryptionRequired@@YAHXZ ; SysEncryptionOrDecryptionRequired
  002d7	85 c0		 test	 eax, eax
  002d9	0f 85 51 05 00
	00		 jne	 $LN11@SwitchWiza

; 1005 : 		}
; 1006 : 	}
; 1007 : 	else
; 1008 : 	{
; 1009 : 		// Check compliance with requirements for boot encryption
; 1010 : 
; 1011 : 		if (!IsAdmin())

  002df	e8 00 00 00 00	 call	 _IsAdmin
  002e4	85 c0		 test	 eax, eax
  002e6	75 16		 jne	 SHORT $LN17@SwitchWiza

; 1012 : 		{
; 1013 : 			if (!IsUacSupported())

  002e8	e8 00 00 00 00	 call	 _IsUacSupported
  002ed	85 c0		 test	 eax, eax
  002ef	75 0d		 jne	 SHORT $LN17@SwitchWiza

; 1014 : 			{
; 1015 : 				Warning ("ADMIN_PRIVILEGES_WARN_DEVICES");

  002f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@
  002f6	e8 00 00 00 00	 call	 _Warning
  002fb	83 c4 04	 add	 esp, 4
$LN17@SwitchWiza:

; 1016 : 			}
; 1017 : 		}
; 1018 : 
; 1019 : 		try
; 1020 : 		{
; 1021 : 			BootEncObj->CheckRequirements ();

  002fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00304	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0030b	e8 00 00 00 00	 call	 ?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckRequirements

; 1029 : 		}
; 1030 : 
; 1031 : 		if (!ChangeWizardMode (WIZARD_MODE_SYS_DEVICE))

  00310	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  00317	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0031e	74 52		 je	 SHORT $LN221@SwitchWiza
  00320	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  00325	e8 00 00 00 00	 call	 _CreateSysEncMutex
  0032a	85 c0		 test	 eax, eax
  0032c	75 0a		 jne	 SHORT $LN225@SwitchWiza
  0032e	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@

; 1032 : 		{
; 1033 : 			NormalCursor ();
; 1034 : 			return FALSE;

  00333	e9 55 ff ff ff	 jmp	 $LN394@SwitchWiza

; 1029 : 		}
; 1030 : 
; 1031 : 		if (!ChangeWizardMode (WIZARD_MODE_SYS_DEVICE))

$LN225@SwitchWiza:
  00338	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
  0033d	0f 57 c0	 xorps	 xmm0, xmm0
  00340	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  0034a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  00351	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  00358	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  00360	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  00368	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _WizardMode, 2
$LN221@SwitchWiza:
  00372	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  00377	f7 d8		 neg	 eax
  00379	1b c0		 sbb	 eax, eax
  0037b	f7 d8		 neg	 eax

; 1035 : 		}
; 1036 : 
; 1037 : 		if (bSysDriveSelected || bSysPartitionSelected)

  0037d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bSysDriveSelected, 0
  00384	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice
  00389	0f 85 2d 01 00
	00		 jne	 $LN385@SwitchWiza
  0038f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bSysPartitionSelected, 0
  00396	0f 85 33 01 00
	00		 jne	 $LN38@SwitchWiza

; 1104 : 			}
; 1105 : 		}
; 1106 : 		else
; 1107 : 			LoadPage (MainDlg, SYSENC_TYPE_PAGE);

  0039c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  003a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  003a7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _MainDlg
  003ad	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  003b3	85 c0		 test	 eax, eax
  003b5	74 60		 je	 SHORT $LN326@SwitchWiza
  003b7	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  003c1	83 f9 15	 cmp	 ecx, 21			; 00000015H
  003c4	75 40		 jne	 SHORT $LN320@SwitchWiza
  003c6	6a 40		 push	 64			; 00000040H
  003c8	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$19[ebp]
  003ce	6a 58		 push	 88			; 00000058H
  003d0	50		 push	 eax
  003d1	e8 00 00 00 00	 call	 _memset
  003d6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  003dc	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$19[ebp]
  003e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e5	c6 45 a4 00	 mov	 BYTE PTR _tmp$19[ebp+64], 0
  003e9	50		 push	 eax
  003ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  003ef	50		 push	 eax
  003f0	ff d6		 call	 esi
  003f2	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$19[ebp]
  003f8	50		 push	 eax
  003f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  003fe	50		 push	 eax
  003ff	ff d6		 call	 esi
  00401	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN320@SwitchWiza:
  00406	50		 push	 eax
  00407	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  0040d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN326@SwitchWiza:
  00417	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  00421	e8 00 00 00 00	 call	 _NormalCursor
  00426	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _rW$15[ebp]
  0042c	50		 push	 eax
  0042d	68 23 04 00 00	 push	 1059			; 00000423H
  00432	57		 push	 edi
  00433	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00439	50		 push	 eax
  0043a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00440	6a 00		 push	 0
  00442	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00447	57		 push	 edi
  00448	6a 7e		 push	 126			; 0000007eH
  0044a	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00450	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 1 ; nCurPageNo
  0045a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  00460	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  00467	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  0046c	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _rD$11[ebp]
  00472	50		 push	 eax
  00473	57		 push	 edi
  00474	0f 11 85 7c fe
	ff ff		 movups	 XMMWORD PTR _rD$11[ebp], xmm0
  0047b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00481	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  00487	85 c9		 test	 ecx, ecx
  00489	0f 84 e8 fd ff
	ff		 je	 $LN124@SwitchWiza
  0048f	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _rW$15[ebp+12]
  00495	2b 85 c0 fe ff
	ff		 sub	 eax, DWORD PTR _rW$15[ebp+4]
  0049b	6a 01		 push	 1
  0049d	50		 push	 eax
  0049e	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _rW$15[ebp+8]
  004a4	2b 85 bc fe ff
	ff		 sub	 eax, DWORD PTR _rW$15[ebp]
  004aa	50		 push	 eax
  004ab	ff b5 80 fe ff
	ff		 push	 DWORD PTR _rD$11[ebp+4]
  004b1	ff b5 7c fe ff
	ff		 push	 DWORD PTR _rD$11[ebp]
  004b7	e9 a6 fd ff ff	 jmp	 $LN392@SwitchWiza
$LN385@SwitchWiza:

; 1038 : 		{
; 1039 : 			// The user selected the non-sys-device wizard mode but then selected a system device
; 1040 : 
; 1041 : 			bWholeSysDrive = (bSysDriveSelected && !bSysPartitionSelected);

  004bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bSysPartitionSelected, 0
  004c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, 1 ; bWholeSysDrive
  004cd	74 0a		 je	 SHORT $LN39@SwitchWiza
$LN38@SwitchWiza:
  004cf	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
$LN39@SwitchWiza:

; 1042 : 
; 1043 : 			bSysDriveSelected = FALSE;
; 1044 : 			bSysPartitionSelected = FALSE;
; 1045 : 
; 1046 : 			try
; 1047 : 			{
; 1048 : 				if (!bHiddenVol)

  004d9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  004e0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bSysDriveSelected, 0
  004ea	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bSysPartitionSelected, 0
  004f4	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  004fb	0f 85 c7 01 00
	00		 jne	 $LN34@SwitchWiza

; 1049 : 				{
; 1050 : 					if (bWholeSysDrive && !BootEncObj->SystemPartitionCoversWholeDrive())

  00501	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
  00508	0f 84 6a 01 00
	00		 je	 $LN25@SwitchWiza
  0050e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00514	e8 00 00 00 00	 call	 ?SystemPartitionCoversWholeDrive@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemPartitionCoversWholeDrive
  00519	84 c0		 test	 al, al
  0051b	0f 85 57 01 00
	00		 jne	 $LN25@SwitchWiza

; 1051 : 					{
; 1052 : 						if (BootEncObj->SystemDriveContainsNonStandardPartitions())

  00521	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00527	e8 00 00 00 00	 call	 ?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemDriveContainsNonStandardPartitions
  0052c	84 c0		 test	 al, al
  0052e	0f 84 a0 00 00
	00		 je	 $LN28@SwitchWiza

; 1053 : 						{
; 1054 : 							if (AskWarnYesNoString ((wstring (GetString ("SYSDRIVE_NON_STANDARD_PARTITIONS")) + L"\n\n" + GetString ("ASK_ENCRYPT_PARTITION_INSTEAD_OF_DRIVE")).c_str()) == IDYES)

  00534	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@CKHHFLEI@SYSDRIVE_NON_STANDARD_PARTITIONS@
  00539	e8 00 00 00 00	 call	 _GetString
  0053e	83 c4 04	 add	 esp, 4
  00541	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00547	50		 push	 eax
  00548	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0054d	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  00552	50		 push	 eax
  00553	8d 85 2c fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00559	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  0055d	50		 push	 eax
  0055e	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00563	83 c4 0c	 add	 esp, 12			; 0000000cH
  00566	8b f0		 mov	 esi, eax
  00568	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@KNBCDPOB@ASK_ENCRYPT_PARTITION_INSTEAD_OF@
  0056d	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  00571	e8 00 00 00 00	 call	 _GetString
  00576	50		 push	 eax
  00577	8d 85 44 fe ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  0057d	56		 push	 esi
  0057e	50		 push	 eax
  0057f	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00584	83 c4 10	 add	 esp, 16			; 00000010H
  00587	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0058b	72 02		 jb	 SHORT $LN250@SwitchWiza
  0058d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN250@SwitchWiza:
  0058f	50		 push	 eax
  00590	e8 00 00 00 00	 call	 _AskWarnYesNoString
  00595	83 c4 04	 add	 esp, 4
  00598	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0059e	83 f8 06	 cmp	 eax, 6
  005a1	0f 94 c3	 sete	 bl
  005a4	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  005a9	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  005af	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  005b4	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  005ba	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  005be	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  005c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bWholeSysDrive@@3HA ; bWholeSysDrive
  005c8	33 c9		 xor	 ecx, ecx
  005ca	84 db		 test	 bl, bl
  005cc	0f 45 c1	 cmovne	 eax, ecx
  005cf	a3 00 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, eax ; bWholeSysDrive
$LN28@SwitchWiza:

; 1055 : 								bWholeSysDrive = FALSE;
; 1056 : 						}
; 1057 : 
; 1058 : 						if (!IsOSAtLeast (WIN_VISTA) && bWholeSysDrive)

  005d4	6a 0b		 push	 11			; 0000000bH
  005d6	e8 00 00 00 00	 call	 _IsOSAtLeast
  005db	83 c4 04	 add	 esp, 4
  005de	85 c0		 test	 eax, eax
  005e0	75 59		 jne	 SHORT $LN33@SwitchWiza
  005e2	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, eax ; bWholeSysDrive
  005e8	74 51		 je	 SHORT $LN33@SwitchWiza

; 1059 : 						{
; 1060 : 							if (BootEncObj->SystemDriveContainsExtendedPartition())

  005ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  005f0	e8 00 00 00 00	 call	 ?SystemDriveContainsExtendedPartition@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemDriveContainsExtendedPartition
  005f5	84 c0		 test	 al, al
  005f7	74 35		 je	 SHORT $LN30@SwitchWiza

; 1061 : 							{
; 1062 : 								bWholeSysDrive = FALSE;
; 1063 : 
; 1064 : 								Error ("WDE_UNSUPPORTED_FOR_EXTENDED_PARTITIONS");

  005f9	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HLDNCEMH@WDE_UNSUPPORTED_FOR_EXTENDED_PAR@
  005fe	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
  00608	e8 00 00 00 00	 call	 _Error

; 1065 : 
; 1066 : 								if (AskYesNo ("ASK_ENCRYPT_PARTITION_INSTEAD_OF_DRIVE") == IDNO)

  0060d	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@KNBCDPOB@ASK_ENCRYPT_PARTITION_INSTEAD_OF@
  00612	e8 00 00 00 00	 call	 _AskYesNo
  00617	83 c4 08	 add	 esp, 8
  0061a	83 f8 07	 cmp	 eax, 7
  0061d	75 1c		 jne	 SHORT $LN33@SwitchWiza

; 1067 : 								{
; 1068 : 									ChangeWizardMode (WIZARD_MODE_NONSYS_DEVICE);

  0061f	6a 01		 push	 1
  00621	e8 00 00 00 00	 call	 ?ChangeWizardMode@@YAHH@Z ; ChangeWizardMode
  00626	83 c4 04	 add	 esp, 4

; 1069 : 									return FALSE;

  00629	e9 6c fc ff ff	 jmp	 $LN50@SwitchWiza
$LN30@SwitchWiza:

; 1070 : 								}
; 1071 : 							}
; 1072 : 							else
; 1073 : 								Warning ("WDE_EXTENDED_PARTITIONS_WARNING");

  0062e	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DBKKOPEJ@WDE_EXTENDED_PARTITIONS_WARNING?$AA@
  00633	e8 00 00 00 00	 call	 _Warning
  00638	83 c4 04	 add	 esp, 4
$LN33@SwitchWiza:

; 1086 : 			}
; 1087 : 
; 1088 : 			if (!bHiddenVol)

  0063b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00642	0f 85 80 00 00
	00		 jne	 $LN34@SwitchWiza

; 1089 : 			{
; 1090 : 				// Skip SYSENC_SPAN_PAGE and SYSENC_TYPE_PAGE as the user already made the choice
; 1091 : 				LoadPage (MainDlg, bWholeSysDrive ? SYSENC_PRE_DRIVE_ANALYSIS_PAGE : SYSENC_MULTI_BOOT_MODE_PAGE);	

  00648	33 c0		 xor	 eax, eax
  0064a	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, eax ; bWholeSysDrive
  00650	0f 94 c0	 sete	 al
  00653	8d 04 45 04 00
	00 00		 lea	 eax, DWORD PTR [eax*2+4]
  0065a	50		 push	 eax
  0065b	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00661	e8 00 00 00 00	 call	 _LoadPage
  00666	83 c4 08	 add	 esp, 8
  00669	e8 00 00 00 00	 call	 _NormalCursor
  0066e	b8 01 00 00 00	 mov	 eax, 1
  00673	e9 24 fc ff ff	 jmp	 $LN10@SwitchWiza
$LN25@SwitchWiza:

; 1074 : 						}
; 1075 : 					}
; 1076 : 					else if (BootEncObj->SystemPartitionCoversWholeDrive() 
; 1077 : 						&& !bWholeSysDrive)

  00678	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0067e	e8 00 00 00 00	 call	 ?SystemPartitionCoversWholeDrive@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemPartitionCoversWholeDrive
  00683	84 c0		 test	 al, al
  00685	74 b4		 je	 SHORT $LN33@SwitchWiza
  00687	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
  0068e	75 ab		 jne	 SHORT $LN33@SwitchWiza

; 1078 : 						bWholeSysDrive = (AskYesNo ("WHOLE_SYC_DEVICE_RECOM") == IDYES);

  00690	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@HHEGHILA@WHOLE_SYC_DEVICE_RECOM?$AA@
  00695	e8 00 00 00 00	 call	 _AskYesNo
  0069a	33 c9		 xor	 ecx, ecx
  0069c	83 c4 04	 add	 esp, 4
  0069f	83 f8 06	 cmp	 eax, 6
  006a2	0f 94 c1	 sete	 cl
  006a5	89 0d 00 00 00
	00		 mov	 DWORD PTR ?bWholeSysDrive@@3HA, ecx ; bWholeSysDrive
  006ab	eb 8e		 jmp	 SHORT $LN33@SwitchWiza
__catch$_SwitchWizardToSysEncMode$4:

; 1079 : 				}
; 1080 : 
; 1081 : 			}
; 1082 : 			catch (Exception &e)
; 1083 : 			{
; 1084 : 				e.Show (MainDlg);

  006ad	8b 8d b0 fd ff
	ff		 mov	 ecx, DWORD PTR _e$4[ebp]
  006b3	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  006b9	8b 01		 mov	 eax, DWORD PTR [ecx]
  006bb	ff 10		 call	 DWORD PTR [eax]

; 1085 : 				return FALSE;

  006bd	b8 00 00 00 00	 mov	 eax, $LN54@SwitchWiza
  006c2	c3		 ret	 0
$LN54@SwitchWiza:
  006c3	e9 d2 fb ff ff	 jmp	 $LN50@SwitchWiza
$LN34@SwitchWiza:

; 1092 : 			}
; 1093 : 			else
; 1094 : 			{
; 1095 : 				// The user selected the non-sys-device wizard mode but then selected a system device.
; 1096 : 				// In addition, he selected the hidden volume mode.
; 1097 : 
; 1098 : 				if (bWholeSysDrive)

  006c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
  006cf	74 0d		 je	 SHORT $LN36@SwitchWiza

; 1099 : 					Warning ("HIDDEN_OS_PRECLUDES_SINGLE_KEY_WDE");

  006d1	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NPEEBJKE@HIDDEN_OS_PRECLUDES_SINGLE_KEY_W@
  006d6	e8 00 00 00 00	 call	 _Warning
  006db	83 c4 04	 add	 esp, 4
$LN36@SwitchWiza:

; 1100 : 
; 1101 : 				bWholeSysDrive = FALSE;
; 1102 : 
; 1103 : 				LoadPage (MainDlg, SYSENC_TYPE_PAGE);

  006de	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  006e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  006e9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _MainDlg
  006ef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
  006f9	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  006ff	85 c0		 test	 eax, eax
  00701	74 63		 je	 SHORT $LN260@SwitchWiza
  00703	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  0070d	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00710	75 43		 jne	 SHORT $LN254@SwitchWiza
  00712	6a 40		 push	 64			; 00000040H
  00714	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$18[ebp]
  0071a	6a 58		 push	 88			; 00000058H
  0071c	50		 push	 eax
  0071d	e8 00 00 00 00	 call	 _memset
  00722	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  00728	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$18[ebp]
  0072e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00731	c6 85 60 ff ff
	ff 00		 mov	 BYTE PTR _tmp$18[ebp+64], 0
  00738	50		 push	 eax
  00739	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  0073e	50		 push	 eax
  0073f	ff d6		 call	 esi
  00741	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$18[ebp]
  00747	50		 push	 eax
  00748	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  0074d	50		 push	 eax
  0074e	ff d6		 call	 esi
  00750	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN254@SwitchWiza:
  00755	50		 push	 eax
  00756	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  0075c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN260@SwitchWiza:
  00766	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  00770	e8 00 00 00 00	 call	 _NormalCursor
  00775	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _rW$14[ebp]
  0077b	50		 push	 eax
  0077c	68 23 04 00 00	 push	 1059			; 00000423H
  00781	57		 push	 edi
  00782	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00788	50		 push	 eax
  00789	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  0078f	6a 00		 push	 0
  00791	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00796	57		 push	 edi
  00797	6a 7e		 push	 126			; 0000007eH
  00799	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  0079f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 1 ; nCurPageNo
  007a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  007af	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  007b6	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  007bb	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _rD$10[ebp]
  007c1	50		 push	 eax
  007c2	57		 push	 edi
  007c3	0f 11 85 6c fe
	ff ff		 movups	 XMMWORD PTR _rD$10[ebp], xmm0
  007ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  007d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  007d6	85 c9		 test	 ecx, ecx
  007d8	0f 84 99 fa ff
	ff		 je	 $LN124@SwitchWiza
  007de	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _rW$14[ebp+12]
  007e4	2b 85 b0 fe ff
	ff		 sub	 eax, DWORD PTR _rW$14[ebp+4]
  007ea	6a 01		 push	 1
  007ec	50		 push	 eax
  007ed	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _rW$14[ebp+8]
  007f3	2b 85 ac fe ff
	ff		 sub	 eax, DWORD PTR _rW$14[ebp]
  007f9	50		 push	 eax
  007fa	ff b5 70 fe ff
	ff		 push	 DWORD PTR _rD$10[ebp+4]
  00800	ff b5 6c fe ff
	ff		 push	 DWORD PTR _rD$10[ebp]

; 1108 : 
; 1109 : 		NormalCursor ();
; 1110 : 		return TRUE;

  00806	e9 57 fa ff ff	 jmp	 $LN392@SwitchWiza
__catch$_SwitchWizardToSysEncMode$2:

; 1022 : 		}
; 1023 : 		catch (Exception &e)
; 1024 : 		{
; 1025 : 			CloseSysEncMutex ();	

  0080b	e8 00 00 00 00	 call	 _CloseSysEncMutex

; 1026 : 			e.Show (MainDlg);

  00810	8b 8d ac fd ff
	ff		 mov	 ecx, DWORD PTR _e$3[ebp]
  00816	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0081c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0081e	ff 10		 call	 DWORD PTR [eax]

; 1027 : 			NormalCursor ();

  00820	e8 00 00 00 00	 call	 _NormalCursor

; 1028 : 			return FALSE;

  00825	b8 00 00 00 00	 mov	 eax, $LN52@SwitchWiza
  0082a	c3		 ret	 0
$LN52@SwitchWiza:
  0082b	e9 6a fa ff ff	 jmp	 $LN50@SwitchWiza
$LN11@SwitchWiza:

; 974  : 	{
; 975  : 
; 976  : 		if (!SysDriveOrPartitionFullyEncrypted (FALSE)
; 977  : 			&& AskWarnYesNo ("SYSTEM_ENCRYPTION_RESUME_PROMPT") == IDYES)

  00830	6a 00		 push	 0
  00832	e8 00 00 00 00	 call	 ?SysDriveOrPartitionFullyEncrypted@@YAHH@Z ; SysDriveOrPartitionFullyEncrypted
  00837	83 c4 04	 add	 esp, 4
  0083a	85 c0		 test	 eax, eax
  0083c	0f 85 c9 01 00
	00		 jne	 $LN12@SwitchWiza
  00842	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HDGOHFPD@SYSTEM_ENCRYPTION_RESUME_PROMPT?$AA@
  00847	e8 00 00 00 00	 call	 _AskWarnYesNo
  0084c	83 c4 04	 add	 esp, 4
  0084f	83 f8 06	 cmp	 eax, 6
  00852	0f 85 b3 01 00
	00		 jne	 $LN12@SwitchWiza

; 978  : 		{
; 979  : 			if (SystemEncryptionStatus == SYSENC_STATUS_NONE)

  00858	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionStatus, 0
  0085f	75 0d		 jne	 SHORT $LN15@SwitchWiza

; 980  : 			{
; 981  : 				// If the config file with status was lost or not written correctly, we
; 982  : 				// don't know whether to encrypt or decrypt (but we know that encryption or
; 983  : 				// decryption is required). Ask the user to select encryption, decryption, 
; 984  : 				// or cancel
; 985  : 				if (!ResolveUnknownSysEncDirection ())

  00861	e8 00 00 00 00	 call	 _ResolveUnknownSysEncDirection
  00866	85 c0		 test	 eax, eax
  00868	0f 84 62 f8 ff
	ff		 je	 $LN390@SwitchWiza
$LN15@SwitchWiza:

; 986  : 				{
; 987  : 					CloseSysEncMutex ();	
; 988  : 					NormalCursor ();
; 989  : 					return FALSE;
; 990  : 				}
; 991  : 			}
; 992  : 
; 993  : 			bDirectSysEncMode = TRUE;
; 994  : 			ChangeWizardMode (WIZARD_MODE_SYS_DEVICE);

  0086e	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  00875	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDirectSysEncMode@@3HA, 1 ; bDirectSysEncMode
  0087f	74 57		 je	 SHORT $LN139@SwitchWiza
  00881	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  00886	e8 00 00 00 00	 call	 _CreateSysEncMutex
  0088b	85 c0		 test	 eax, eax
  0088d	75 0f		 jne	 SHORT $LN143@SwitchWiza
  0088f	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  00894	e8 00 00 00 00	 call	 _Error
  00899	83 c4 04	 add	 esp, 4
  0089c	eb 4a		 jmp	 SHORT $LN147@SwitchWiza
$LN143@SwitchWiza:
  0089e	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
  008a3	0f 57 c0	 xorps	 xmm0, xmm0
  008a6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  008b0	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  008b7	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  008be	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  008c6	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  008ce	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _WizardMode, 2
$LN139@SwitchWiza:
  008d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  008dd	f7 d8		 neg	 eax
  008df	1b c0		 sbb	 eax, eax
  008e1	f7 d8		 neg	 eax
  008e3	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice
$LN147@SwitchWiza:

; 995  : 			LoadPage (MainDlg, SYSENC_ENCRYPTION_PAGE);

  008e8	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  008ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  008f3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _MainDlg
  008f9	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  008ff	85 c0		 test	 eax, eax
  00901	74 63		 je	 SHORT $LN161@SwitchWiza
  00903	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  0090d	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00910	75 43		 jne	 SHORT $LN155@SwitchWiza
  00912	6a 40		 push	 64			; 00000040H
  00914	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _tmp$17[ebp]
  0091a	6a 58		 push	 88			; 00000058H
  0091c	50		 push	 eax
  0091d	e8 00 00 00 00	 call	 _memset
  00922	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  00928	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _tmp$17[ebp]
  0092e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00931	c6 85 1c ff ff
	ff 00		 mov	 BYTE PTR _tmp$17[ebp+64], 0
  00938	50		 push	 eax
  00939	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  0093e	50		 push	 eax
  0093f	ff d6		 call	 esi
  00941	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _tmp$17[ebp]
  00947	50		 push	 eax
  00948	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  0094d	50		 push	 eax
  0094e	ff d6		 call	 esi
  00950	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN155@SwitchWiza:
  00955	50		 push	 eax
  00956	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  0095c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN161@SwitchWiza:
  00966	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  00970	e8 00 00 00 00	 call	 _NormalCursor
  00975	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _rW$13[ebp]
  0097b	50		 push	 eax
  0097c	68 23 04 00 00	 push	 1059			; 00000423H
  00981	57		 push	 edi
  00982	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00988	50		 push	 eax
  00989	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  0098f	6a 00		 push	 0
  00991	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00996	57		 push	 edi
  00997	6a 7a		 push	 122			; 0000007aH
  00999	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  0099f	c7 05 00 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 31 ; nCurPageNo, 0000001fH
  009a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  009af	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  009b6	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  009bb	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _rD$9[ebp]
  009c1	50		 push	 eax
  009c2	57		 push	 edi
  009c3	0f 11 85 5c fe
	ff ff		 movups	 XMMWORD PTR _rD$9[ebp], xmm0
  009ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  009d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  009d6	85 c9		 test	 ecx, ecx
  009d8	0f 84 99 f8 ff
	ff		 je	 $LN124@SwitchWiza
  009de	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _rW$13[ebp+12]
  009e4	2b 85 a0 fe ff
	ff		 sub	 eax, DWORD PTR _rW$13[ebp+4]
  009ea	6a 01		 push	 1
  009ec	50		 push	 eax
  009ed	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _rW$13[ebp+8]
  009f3	2b 85 9c fe ff
	ff		 sub	 eax, DWORD PTR _rW$13[ebp]
  009f9	50		 push	 eax
  009fa	ff b5 60 fe ff
	ff		 push	 DWORD PTR _rD$9[ebp+4]
  00a00	ff b5 5c fe ff
	ff		 push	 DWORD PTR _rD$9[ebp]

; 996  : 			NormalCursor ();
; 997  : 			return TRUE;

  00a06	e9 57 f8 ff ff	 jmp	 $LN392@SwitchWiza
$LN12@SwitchWiza:

; 998  : 		}
; 999  : 		else
; 1000 : 		{
; 1001 : 			CloseSysEncMutex ();	

  00a0b	e8 00 00 00 00	 call	 _CloseSysEncMutex

; 1002 : 			Error ("SETUP_FAILED_BOOT_DRIVE_ENCRYPTED");

  00a10	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@

; 1003 : 			NormalCursor ();
; 1004 : 			return FALSE;

  00a15	e9 73 f8 ff ff	 jmp	 $LN394@SwitchWiza
__catch$_SwitchWizardToSysEncMode$0:

; 922  : 	}
; 923  : 	catch (Exception &e)
; 924  : 	{
; 925  : 		e.Show (MainDlg);

  00a1a	8b 8d a8 fd ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  00a20	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00a26	8b 01		 mov	 eax, DWORD PTR [ecx]
  00a28	ff 10		 call	 DWORD PTR [eax]

; 926  : 		Error ("ERR_GETTING_SYSTEM_ENCRYPTION_STATUS");

  00a2a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@
  00a2f	e8 00 00 00 00	 call	 _Error
  00a34	83 c4 04	 add	 esp, 4

; 927  : 		NormalCursor ();

  00a37	e8 00 00 00 00	 call	 _NormalCursor

; 928  : 		return FALSE;

  00a3c	b8 00 00 00 00	 mov	 eax, $LN50@SwitchWiza
  00a41	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_SwitchWizardToSysEncMode$6:
  00000	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_SwitchWizardToSysEncMode$7:
  0000b	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$_SwitchWizardToSysEncMode:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a a4 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-604]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_SwitchWizardToSysEncMode
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_SwitchWizardToSysEncMode ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _GetFileVolSize
_TEXT	SEGMENT
_fileSize$ = -16					; size = 8
_ftLastAccessTime$ = -8					; size = 8
_hwndDlg$ = 8						; size = 4
_size$ = 12						; size = 4
_GetFileVolSize PROC					; COMDAT

; 3493 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 3494 : 	LARGE_INTEGER fileSize;
; 3495 : 	HANDLE hFile;
; 3496 : 
; 3497 : 	FILETIME ftLastAccessTime;
; 3498 : 	BOOL bTimeStampValid = FALSE;

  00008	33 ff		 xor	 edi, edi

; 3499 : 
; 3500 : 	hFile = CreateFile (szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

  0000a	57		 push	 edi
  0000b	57		 push	 edi
  0000c	6a 03		 push	 3
  0000e	57		 push	 edi
  0000f	6a 03		 push	 3
  00011	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00016	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00021	8b f0		 mov	 esi, eax

; 3501 : 
; 3502 : 	if (hFile == INVALID_HANDLE_VALUE)

  00023	83 fe ff	 cmp	 esi, -1
  00026	75 27		 jne	 SHORT $LN2@GetFileVol

; 3503 : 	{
; 3504 : 		MessageBoxW (hwndDlg, GetString ("CANT_ACCESS_VOL"), lpszTitle, ICON_HAND);

  00028	6a 10		 push	 16			; 00000010H
  0002a	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@
  00035	e8 00 00 00 00	 call	 _GetString
  0003a	83 c4 04	 add	 esp, 4
  0003d	50		 push	 eax
  0003e	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00047	5f		 pop	 edi

; 3505 : 		return FALSE;

  00048	33 c0		 xor	 eax, eax
  0004a	5e		 pop	 esi

; 3533 : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN2@GetFileVol:

; 3506 : 	}
; 3507 : 
; 3508 : 	if (bPreserveTimestamp)

  0004f	39 3d 00 00 00
	00		 cmp	 DWORD PTR _bPreserveTimestamp, edi
  00055	74 17		 je	 SHORT $LN4@GetFileVol

; 3509 : 	{
; 3510 : 		if (GetFileTime (hFile, NULL, &ftLastAccessTime, NULL) == 0)

  00057	6a 00		 push	 0
  00059	8d 45 f8	 lea	 eax, DWORD PTR _ftLastAccessTime$[ebp]
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	56		 push	 esi
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileTime@16
  00066	8b f8		 mov	 edi, eax
  00068	f7 df		 neg	 edi
  0006a	1b ff		 sbb	 edi, edi
  0006c	f7 df		 neg	 edi
$LN4@GetFileVol:

; 3511 : 			bTimeStampValid = FALSE;
; 3512 : 		else
; 3513 : 			bTimeStampValid = TRUE;
; 3514 : 	}
; 3515 : 
; 3516 : 	if (GetFileSizeEx(hFile, &fileSize) == 0)

  0006e	8d 45 f0	 lea	 eax, DWORD PTR _fileSize$[ebp]
  00071	50		 push	 eax
  00072	56		 push	 esi
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSizeEx@8
  00079	85 c0		 test	 eax, eax
  0007b	75 41		 jne	 SHORT $LN6@GetFileVol

; 3517 : 	{
; 3518 : 		MessageBoxW (hwndDlg, GetString ("CANT_GET_VOLSIZE"), lpszTitle, ICON_HAND);

  0007d	6a 10		 push	 16			; 00000010H
  0007f	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNOFFGJI@CANT_GET_VOLSIZE?$AA@
  0008a	e8 00 00 00 00	 call	 _GetString
  0008f	83 c4 04	 add	 esp, 4
  00092	50		 push	 eax
  00093	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  0009c	85 ff		 test	 edi, edi

; 3519 : 
; 3520 : 		if (bTimeStampValid)

  0009e	74 0f		 je	 SHORT $LN7@GetFileVol

; 3521 : 			SetFileTime (hFile, NULL, &ftLastAccessTime, NULL);

  000a0	6a 00		 push	 0
  000a2	8d 45 f8	 lea	 eax, DWORD PTR _ftLastAccessTime$[ebp]
  000a5	50		 push	 eax
  000a6	6a 00		 push	 0
  000a8	56		 push	 esi
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFileTime@16
$LN7@GetFileVol:

; 3522 : 
; 3523 : 		CloseHandle (hFile);

  000af	56		 push	 esi
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  000b6	5f		 pop	 edi

; 3524 : 		return FALSE;

  000b7	33 c0		 xor	 eax, eax
  000b9	5e		 pop	 esi

; 3533 : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN6@GetFileVol:
  000be	85 ff		 test	 edi, edi

; 3525 : 	}
; 3526 : 
; 3527 : 	if (bTimeStampValid)

  000c0	74 0f		 je	 SHORT $LN8@GetFileVol

; 3528 : 		SetFileTime (hFile, NULL, &ftLastAccessTime, NULL);

  000c2	6a 00		 push	 0
  000c4	8d 45 f8	 lea	 eax, DWORD PTR _ftLastAccessTime$[ebp]
  000c7	50		 push	 eax
  000c8	6a 00		 push	 0
  000ca	56		 push	 esi
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFileTime@16
$LN8@GetFileVol:

; 3529 : 
; 3530 : 	CloseHandle (hFile);

  000d1	56		 push	 esi
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3531 : 	*size = fileSize.QuadPart;

  000d8	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  000db	8b 45 f0	 mov	 eax, DWORD PTR _fileSize$[ebp]
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	89 01		 mov	 DWORD PTR [ecx], eax
  000e2	8b 45 f4	 mov	 eax, DWORD PTR _fileSize$[ebp+4]
  000e5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3532 : 	return TRUE;

  000e8	b8 01 00 00 00	 mov	 eax, 1

; 3533 : }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
_GetFileVolSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _IsSparseFile
_TEXT	SEGMENT
_ftLastAccessTime$ = -64				; size = 8
_bhFileInfo$ = -56					; size = 52
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_IsSparseFile PROC					; COMDAT

; 3441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3442 : 	HANDLE hFile;
; 3443 : 	BY_HANDLE_FILE_INFORMATION bhFileInfo;
; 3444 : 
; 3445 : 	FILETIME ftLastAccessTime;
; 3446 : 	BOOL bTimeStampValid = FALSE;

  00016	33 f6		 xor	 esi, esi

; 3447 : 
; 3448 : 	BOOL retCode = FALSE;
; 3449 : 
; 3450 : 	hFile = CreateFile (szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

  00018	56		 push	 esi
  00019	56		 push	 esi
  0001a	6a 03		 push	 3
  0001c	56		 push	 esi
  0001d	6a 03		 push	 3
  0001f	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00024	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  0002f	8b f8		 mov	 edi, eax

; 3451 : 
; 3452 : 	if (hFile == INVALID_HANDLE_VALUE)

  00031	83 ff ff	 cmp	 edi, -1
  00034	75 30		 jne	 SHORT $LN2@IsSparseFi

; 3453 : 	{
; 3454 : 		MessageBoxW (hwndDlg, GetString ("CANT_ACCESS_VOL"), lpszTitle, ICON_HAND);

  00036	6a 10		 push	 16			; 00000010H
  00038	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@
  00043	e8 00 00 00 00	 call	 _GetString
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	53		 push	 ebx
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 3455 : 		return FALSE;

  00055	33 c0		 xor	 eax, eax
  00057	5b		 pop	 ebx

; 3476 : 	return retCode;
; 3477 : }

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	33 cd		 xor	 ecx, ebp
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN2@IsSparseFi:

; 3456 : 	}
; 3457 : 
; 3458 : 	if (bPreserveTimestamp)

  00066	39 35 00 00 00
	00		 cmp	 DWORD PTR _bPreserveTimestamp, esi
  0006c	74 17		 je	 SHORT $LN4@IsSparseFi

; 3459 : 	{
; 3460 : 		if (GetFileTime (hFile, NULL, &ftLastAccessTime, NULL) == 0)

  0006e	6a 00		 push	 0
  00070	8d 45 c0	 lea	 eax, DWORD PTR _ftLastAccessTime$[ebp]
  00073	50		 push	 eax
  00074	6a 00		 push	 0
  00076	57		 push	 edi
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileTime@16
  0007d	8b f0		 mov	 esi, eax
  0007f	f7 de		 neg	 esi
  00081	1b f6		 sbb	 esi, esi
  00083	f7 de		 neg	 esi
$LN4@IsSparseFi:

; 3461 : 			bTimeStampValid = FALSE;
; 3462 : 		else
; 3463 : 			bTimeStampValid = TRUE;
; 3464 : 	}
; 3465 : 
; 3466 : 	bhFileInfo.dwFileAttributes = 0;
; 3467 : 
; 3468 : 	GetFileInformationByHandle(hFile, &bhFileInfo);

  00085	8d 45 c8	 lea	 eax, DWORD PTR _bhFileInfo$[ebp]
  00088	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _bhFileInfo$[ebp], 0
  0008f	50		 push	 eax
  00090	57		 push	 edi
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileInformationByHandle@8

; 3469 : 
; 3470 : 	retCode = bhFileInfo.dwFileAttributes & FILE_ATTRIBUTE_SPARSE_FILE;

  00097	8b 5d c8	 mov	 ebx, DWORD PTR _bhFileInfo$[ebp]
  0009a	81 e3 00 02 00
	00		 and	 ebx, 512		; 00000200H
  000a0	85 f6		 test	 esi, esi

; 3471 : 
; 3472 : 	if (bTimeStampValid)

  000a2	74 0f		 je	 SHORT $LN6@IsSparseFi

; 3473 : 		SetFileTime (hFile, NULL, &ftLastAccessTime, NULL);

  000a4	6a 00		 push	 0
  000a6	8d 45 c0	 lea	 eax, DWORD PTR _ftLastAccessTime$[ebp]
  000a9	50		 push	 eax
  000aa	6a 00		 push	 0
  000ac	57		 push	 edi
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFileTime@16
$LN6@IsSparseFi:

; 3474 : 
; 3475 : 	CloseHandle (hFile);

  000b3	57		 push	 edi
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3476 : 	return retCode;
; 3477 : }

  000ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bd	8b c3		 mov	 eax, ebx
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	33 cd		 xor	 ecx, ebp
  000c3	5b		 pop	 ebx
  000c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
_IsSparseFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _DetermineMaxHiddenVolSize
_TEXT	SEGMENT
?nMaximumHiddenVolSize@@3_JA$2 = -8			; size = 4
_nbrReserveBytes$2$ = -8				; size = 4
_nbrReserveBytes$1$ = -4				; size = 4
_hwndDlg$ = 8						; size = 4
_DetermineMaxHiddenVolSize PROC				; COMDAT

; 8612 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8613 : 	__int64 nbrReserveBytes;
; 8614 : 
; 8615 : 	if (nbrFreeClusters * realClusterSize < GST_MIN_HIDDEN_VOLUME_SIZE)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?realClusterSize@@3HA ; realClusterSize
  00008	83 ec 08	 sub	 esp, 8
  0000b	99		 cdq
  0000c	53		 push	 ebx
  0000d	ff 35 04 00 00
	00		 push	 DWORD PTR ?nbrFreeClusters@@3_JA+4
  00013	ff 35 00 00 00
	00		 push	 DWORD PTR ?nbrFreeClusters@@3_JA
  00019	52		 push	 edx
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __allmul
  00020	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  00023	85 d2		 test	 edx, edx
  00025	7f 3c		 jg	 SHORT $LN2@DetermineM
  00027	7c 07		 jl	 SHORT $LN10@DetermineM
  00029	3d 00 a0 00 00	 cmp	 eax, 40960		; 0000a000H
  0002e	73 33		 jae	 SHORT $LN2@DetermineM
$LN10@DetermineM:

; 8616 : 	{
; 8617 : 		MessageBoxW (hwndDlg, GetString ("NO_SPACE_FOR_HIDDEN_VOL"), lpszTitle, ICON_HAND);

  00030	6a 10		 push	 16			; 00000010H
  00032	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EIHCDBCC@NO_SPACE_FOR_HIDDEN_VOL?$AA@
  0003d	e8 00 00 00 00	 call	 _GetString
  00042	83 c4 04	 add	 esp, 4
  00045	50		 push	 eax
  00046	53		 push	 ebx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 8618 : 		UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE);

  0004d	6a 01		 push	 1
  0004f	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  00055	53		 push	 ebx
  00056	e8 00 00 00 00	 call	 _UnmountVolume
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8619 : 		AbortProcessSilent ();

  0005e	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN2@DetermineM:

; 8620 : 	}
; 8621 : 
; 8622 : 	// Add a reserve (in case the user mounts the outer volume and creates new files
; 8623 : 	// on it by accident or OS writes some new data behind his or her back, such as
; 8624 : 	// System Restore etc.)
; 8625 : 	nbrReserveBytes = GetVolumeDataAreaSize (FALSE, nHiddenVolHostSize) / 200;

  00063	ff 35 04 00 00
	00		 push	 DWORD PTR ?nHiddenVolHostSize@@3_KA+4
  00069	ff 35 00 00 00
	00		 push	 DWORD PTR ?nHiddenVolHostSize@@3_KA
  0006f	6a 00		 push	 0
  00071	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	6a 00		 push	 0
  0007b	68 c8 00 00 00	 push	 200			; 000000c8H
  00080	52		 push	 edx
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 __aulldiv
  00087	8b ca		 mov	 ecx, edx
  00089	89 45 fc	 mov	 DWORD PTR _nbrReserveBytes$1$[ebp], eax
  0008c	89 4d f8	 mov	 DWORD PTR _nbrReserveBytes$2$[ebp], ecx

; 8626 : 	if (nbrReserveBytes > BYTES_PER_MB * 10)

  0008f	85 c9		 test	 ecx, ecx
  00091	7c 17		 jl	 SHORT $LN3@DetermineM
  00093	7f 07		 jg	 SHORT $LN11@DetermineM
  00095	3d 00 00 a0 00	 cmp	 eax, 10485760		; 00a00000H
  0009a	76 0e		 jbe	 SHORT $LN3@DetermineM
$LN11@DetermineM:

; 8627 : 		nbrReserveBytes = BYTES_PER_MB * 10;

  0009c	c7 45 fc 00 00
	a0 00		 mov	 DWORD PTR _nbrReserveBytes$1$[ebp], 10485760 ; 00a00000H
  000a3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nbrReserveBytes$2$[ebp], 0
$LN3@DetermineM:

; 8628 : 
; 8629 : 	// Compute the final value
; 8630 : 
; 8631 : 	nMaximumHiddenVolSize = nbrFreeClusters * realClusterSize - GST_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE - nbrReserveBytes;

  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?realClusterSize@@3HA ; realClusterSize
  000af	56		 push	 esi
  000b0	57		 push	 edi
  000b1	ff 35 04 00 00
	00		 push	 DWORD PTR ?nbrFreeClusters@@3_JA+4
  000b7	99		 cdq
  000b8	ff 35 00 00 00
	00		 push	 DWORD PTR ?nbrFreeClusters@@3_JA
  000be	8b f2		 mov	 esi, edx
  000c0	8b f8		 mov	 edi, eax
  000c2	56		 push	 esi
  000c3	57		 push	 edi
  000c4	e8 00 00 00 00	 call	 __allmul
  000c9	8b d8		 mov	 ebx, eax
  000cb	8b c2		 mov	 eax, edx
  000cd	2b 5d fc	 sub	 ebx, DWORD PTR _nbrReserveBytes$1$[ebp]

; 8632 : 	nMaximumHiddenVolSize -= nMaximumHiddenVolSize % realClusterSize;		// Must be a multiple of the sector size

  000d0	56		 push	 esi
  000d1	1b 45 f8	 sbb	 eax, DWORD PTR _nbrReserveBytes$2$[ebp]
  000d4	81 eb 00 10 00
	00		 sub	 ebx, 4096		; 00001000H
  000da	57		 push	 edi
  000db	83 d8 00	 sbb	 eax, 0
  000de	50		 push	 eax
  000df	53		 push	 ebx
  000e0	89 45 f8	 mov	 DWORD PTR ?nMaximumHiddenVolSize@@3_JA$2[ebp], eax
  000e3	e8 00 00 00 00	 call	 __allrem
  000e8	2b d8		 sub	 ebx, eax
  000ea	8b 45 f8	 mov	 eax, DWORD PTR ?nMaximumHiddenVolSize@@3_JA$2[ebp]
  000ed	89 1d 00 00 00
	00		 mov	 DWORD PTR ?nMaximumHiddenVolSize@@3_JA, ebx
  000f3	1b c2		 sbb	 eax, edx
  000f5	a3 04 00 00 00	 mov	 DWORD PTR ?nMaximumHiddenVolSize@@3_JA+4, eax

; 8633 : 
; 8634 : 	if (nMaximumHiddenVolSize < GST_MIN_HIDDEN_VOLUME_SIZE)

  000fa	85 c0		 test	 eax, eax
  000fc	7f 4b		 jg	 SHORT $LN4@DetermineM
  000fe	7c 08		 jl	 SHORT $LN12@DetermineM
  00100	81 fb 00 a0 00
	00		 cmp	 ebx, 40960		; 0000a000H
  00106	73 41		 jae	 SHORT $LN4@DetermineM
$LN12@DetermineM:

; 8635 : 	{
; 8636 : 		MessageBoxW (hwndDlg, GetString ("NO_SPACE_FOR_HIDDEN_VOL"), lpszTitle, ICON_HAND);

  00108	6a 10		 push	 16			; 00000010H
  0010a	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EIHCDBCC@NO_SPACE_FOR_HIDDEN_VOL?$AA@
  00115	e8 00 00 00 00	 call	 _GetString
  0011a	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]
  0011d	83 c4 04	 add	 esp, 4
  00120	50		 push	 eax
  00121	56		 push	 esi
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 8637 : 		UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE);

  00128	6a 01		 push	 1
  0012a	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  00130	56		 push	 esi
  00131	e8 00 00 00 00	 call	 _UnmountVolume
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8638 : 		AbortProcessSilent ();

  00139	e8 00 00 00 00	 call	 _AbortProcessSilent
  0013e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?nMaximumHiddenVolSize@@3_JA+4
  00143	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?nMaximumHiddenVolSize@@3_JA
$LN4@DetermineM:

; 8639 : 	}
; 8640 : 
; 8641 : 	// Prepare the hidden volume size parameters
; 8642 : 	if (nMaximumHiddenVolSize < BYTES_PER_MB)

  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	85 c0		 test	 eax, eax
  0014d	7f 30		 jg	 SHORT $LN7@DetermineM
  0014f	7c 08		 jl	 SHORT $LN13@DetermineM
  00151	81 fb 00 00 10
	00		 cmp	 ebx, 1048576		; 00100000H
  00157	73 0c		 jae	 SHORT $LN5@DetermineM
$LN13@DetermineM:

; 8643 : 		nMultiplier = BYTES_PER_KB;

  00159	c7 05 00 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?nMultiplier@@3HA, 1024 ; nMultiplier, 00000400H
  00163	eb 24		 jmp	 SHORT $LN8@DetermineM
$LN5@DetermineM:

; 8644 : 	else if (nMaximumHiddenVolSize < BYTES_PER_GB)

  00165	85 c0		 test	 eax, eax
  00167	7f 16		 jg	 SHORT $LN7@DetermineM
  00169	7c 08		 jl	 SHORT $LN14@DetermineM
  0016b	81 fb 00 00 00
	40		 cmp	 ebx, 1073741824		; 40000000H
  00171	73 0c		 jae	 SHORT $LN7@DetermineM
$LN14@DetermineM:

; 8645 : 		nMultiplier = BYTES_PER_MB;

  00173	c7 05 00 00 00
	00 00 00 10 00	 mov	 DWORD PTR ?nMultiplier@@3HA, 1048576 ; nMultiplier, 00100000H

; 8646 : 	else

  0017d	eb 0a		 jmp	 SHORT $LN8@DetermineM
$LN7@DetermineM:

; 8647 : 		nMultiplier = BYTES_PER_GB;

  0017f	c7 05 00 00 00
	00 00 00 00 40	 mov	 DWORD PTR ?nMultiplier@@3HA, 1073741824 ; nMultiplier, 40000000H
$LN8@DetermineM:
  00189	0f 57 c0	 xorps	 xmm0, xmm0

; 8648 : 
; 8649 : 	nUIVolumeSize = 0;								// Set the initial value for the hidden volume size input field to the max
; 8650 : 	nVolumeSize = nUIVolumeSize * nMultiplier;		// Chop off possible remainder
; 8651 : 
; 8652 : 	return 1;

  0018c	b8 01 00 00 00	 mov	 eax, 1
  00191	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  00199	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  001a1	5b		 pop	 ebx

; 8653 : }

  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
_DetermineMaxHiddenVolSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _DisplayPortionsOfKeys
_TEXT	SEGMENT
$T1 = -92						; size = 4
_masterKeyHandle$GSCopy$1$ = -88			; size = 4
_masterKeyStr$GSCopy$1$ = -84				; size = 4
_headerKeyHandle$GSCopy$1$ = -80			; size = 4
$T2 = -76						; size = 24
$T3 = -76						; size = 24
$T4 = -52						; size = 24
$T5 = -52						; size = 24
$T6 = -28						; size = 24
$T7 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_headerKeyHandle$ = 8					; size = 4
_masterKeyHandle$ = 12					; size = 4
_headerKeyStr$ = 16					; size = 4
_masterKeyStr$ = 20					; size = 4
_hideKeys$ = 24						; size = 4
_DisplayPortionsOfKeys PROC				; COMDAT

; 2379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _masterKeyHandle$[ebp]
  00013	8b 55 10	 mov	 edx, DWORD PTR _headerKeyStr$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _headerKeyHandle$[ebp]
  0001b	33 db		 xor	 ebx, ebx
  0001d	57		 push	 edi

; 2380 : 	const wchar_t *hiddenKey = L"********************************                                              ";
; 2381 : 
; 2382 : 	SetWindowTextW (headerKeyHandle, hideKeys ? hiddenKey : (SingleStringToWide (headerKeyStr) + GetString ("TRIPLE_DOT_GLYPH_ELLIPSIS")).c_str());

  0001e	8b 7d 18	 mov	 edi, DWORD PTR _hideKeys$[ebp]
  00021	89 45 a8	 mov	 DWORD PTR _masterKeyHandle$GSCopy$1$[ebp], eax
  00024	8b 45 14	 mov	 eax, DWORD PTR _masterKeyStr$[ebp]
  00027	89 75 b0	 mov	 DWORD PTR _headerKeyHandle$GSCopy$1$[ebp], esi
  0002a	89 45 ac	 mov	 DWORD PTR _masterKeyStr$GSCopy$1$[ebp], eax
  0002d	89 5d a4	 mov	 DWORD PTR $T1[ebp], ebx
  00030	85 ff		 test	 edi, edi
  00032	74 07		 je	 SHORT $LN3@DisplayPor
  00034	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1JO@BPJIPIJP@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK@
  00039	eb 68		 jmp	 SHORT $LN126@DisplayPor
$LN3@DisplayPor:
  0003b	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH
  00042	89 5d f4	 mov	 DWORD PTR $T7[ebp+16], ebx
  00045	88 5d e4	 mov	 BYTE PTR $T7[ebp], bl
  00048	38 1a		 cmp	 BYTE PTR [edx], bl
  0004a	75 04		 jne	 SHORT $LN123@DisplayPor
  0004c	33 c9		 xor	 ecx, ecx
  0004e	eb 11		 jmp	 SHORT $LN124@DisplayPor
$LN123@DisplayPor:
  00050	8b ca		 mov	 ecx, edx
  00052	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL885@DisplayPor:
  00055	8a 01		 mov	 al, BYTE PTR [ecx]
  00057	41		 inc	 ecx
  00058	84 c0		 test	 al, al
  0005a	75 f9		 jne	 SHORT $LL885@DisplayPor
  0005c	2b ce		 sub	 ecx, esi
  0005e	8b 75 b0	 mov	 esi, DWORD PTR _headerKeyHandle$GSCopy$1$[ebp]
$LN124@DisplayPor:
  00061	51		 push	 ecx
  00062	52		 push	 edx
  00063	8d 4d e4	 lea	 ecx, DWORD PTR $T7[ebp]
  00066	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JMBFHJFE@TRIPLE_DOT_GLYPH_ELLIPSIS?$AA@
  00070	e8 00 00 00 00	 call	 _GetString
  00075	83 c4 04	 add	 esp, 4
  00078	50		 push	 eax
  00079	8d 45 e4	 lea	 eax, DWORD PTR $T7[ebp]
  0007c	50		 push	 eax
  0007d	8d 45 b4	 lea	 eax, DWORD PTR $T3[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  00086	83 c4 08	 add	 esp, 8
  00089	50		 push	 eax
  0008a	8d 45 cc	 lea	 eax, DWORD PTR $T5[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
  00096	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0009a	72 02		 jb	 SHORT $LN138@DisplayPor
  0009c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN138@DisplayPor:
  0009e	bb 07 00 00 00	 mov	 ebx, 7
$LN126@DisplayPor:
  000a3	50		 push	 eax
  000a4	56		 push	 esi
  000a5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  000ab	ff d6		 call	 esi
  000ad	f6 c3 04	 test	 bl, 4
  000b0	74 2c		 je	 SHORT $LN143@DisplayPor
  000b2	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp+20]
  000b5	83 e3 fb	 and	 ebx, -5			; fffffffbH
  000b8	83 f8 08	 cmp	 eax, 8
  000bb	72 0d		 jb	 SHORT $LN148@DisplayPor
  000bd	40		 inc	 eax
  000be	8d 4d cc	 lea	 ecx, DWORD PTR $T5[ebp]
  000c1	50		 push	 eax
  000c2	ff 75 cc	 push	 DWORD PTR $T5[ebp]
  000c5	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN148@DisplayPor:
  000ca	33 c0		 xor	 eax, eax
  000cc	c7 45 e0 07 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 7
  000d3	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0
  000da	66 89 45 cc	 mov	 WORD PTR $T5[ebp], ax
$LN143@DisplayPor:
  000de	f6 c3 02	 test	 bl, 2
  000e1	74 2c		 je	 SHORT $LN246@DisplayPor
  000e3	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp+20]
  000e6	83 e3 fd	 and	 ebx, -3			; fffffffdH
  000e9	83 f8 08	 cmp	 eax, 8
  000ec	72 0d		 jb	 SHORT $LN251@DisplayPor
  000ee	40		 inc	 eax
  000ef	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  000f2	50		 push	 eax
  000f3	ff 75 b4	 push	 DWORD PTR $T3[ebp]
  000f6	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN251@DisplayPor:
  000fb	33 c0		 xor	 eax, eax
  000fd	c7 45 c8 07 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 7
  00104	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
  0010b	66 89 45 b4	 mov	 WORD PTR $T3[ebp], ax
$LN246@DisplayPor:
  0010f	f6 c3 01	 test	 bl, 1
  00112	74 18		 je	 SHORT $LN354@DisplayPor
  00114	8b 45 f8	 mov	 eax, DWORD PTR $T7[ebp+20]
  00117	83 e3 fe	 and	 ebx, -2			; fffffffeH
  0011a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0011d	72 0d		 jb	 SHORT $LN354@DisplayPor
  0011f	40		 inc	 eax
  00120	8d 4d e4	 lea	 ecx, DWORD PTR $T7[ebp]
  00123	50		 push	 eax
  00124	ff 75 e4	 push	 DWORD PTR $T7[ebp]
  00127	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN354@DisplayPor:

; 2383 : 	SetWindowTextW (masterKeyHandle, hideKeys ? hiddenKey : (SingleStringToWide (masterKeyStr) + GetString ("TRIPLE_DOT_GLYPH_ELLIPSIS")).c_str());

  0012c	85 ff		 test	 edi, edi
  0012e	74 07		 je	 SHORT $LN5@DisplayPor
  00130	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1JO@BPJIPIJP@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK@
  00135	eb 72		 jmp	 SHORT $LN574@DisplayPor
$LN5@DisplayPor:
  00137	8b 7d ac	 mov	 edi, DWORD PTR _masterKeyStr$GSCopy$1$[ebp]
  0013a	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH
  00141	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0
  00148	c6 45 e4 00	 mov	 BYTE PTR $T6[ebp], 0
  0014c	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0014f	75 04		 jne	 SHORT $LN559@DisplayPor
  00151	33 c9		 xor	 ecx, ecx
  00153	eb 14		 jmp	 SHORT $LN560@DisplayPor
$LN559@DisplayPor:
  00155	8b cf		 mov	 ecx, edi
  00157	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0015a	66 0f 1f 44 00
	00		 npad	 6
$LL886@DisplayPor:
  00160	8a 01		 mov	 al, BYTE PTR [ecx]
  00162	41		 inc	 ecx
  00163	84 c0		 test	 al, al
  00165	75 f9		 jne	 SHORT $LL886@DisplayPor
  00167	2b ca		 sub	 ecx, edx
$LN560@DisplayPor:
  00169	51		 push	 ecx
  0016a	57		 push	 edi
  0016b	8d 4d e4	 lea	 ecx, DWORD PTR $T6[ebp]
  0016e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JMBFHJFE@TRIPLE_DOT_GLYPH_ELLIPSIS?$AA@
  00178	83 cb 38	 or	 ebx, 56			; 00000038H
  0017b	e8 00 00 00 00	 call	 _GetString
  00180	83 c4 04	 add	 esp, 4
  00183	50		 push	 eax
  00184	8d 45 e4	 lea	 eax, DWORD PTR $T6[ebp]
  00187	50		 push	 eax
  00188	8d 45 cc	 lea	 eax, DWORD PTR $T4[ebp]
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  00191	83 c4 08	 add	 esp, 8
  00194	50		 push	 eax
  00195	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0019e	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a1	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  001a5	72 02		 jb	 SHORT $LN574@DisplayPor
  001a7	8b 00		 mov	 eax, DWORD PTR [eax]
$LN574@DisplayPor:
  001a9	50		 push	 eax
  001aa	ff 75 a8	 push	 DWORD PTR _masterKeyHandle$GSCopy$1$[ebp]
  001ad	ff d6		 call	 esi
  001af	f6 c3 20	 test	 bl, 32			; 00000020H
  001b2	74 2c		 je	 SHORT $LN579@DisplayPor
  001b4	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp+20]
  001b7	83 e3 df	 and	 ebx, -33		; ffffffdfH
  001ba	83 f8 08	 cmp	 eax, 8
  001bd	72 0d		 jb	 SHORT $LN584@DisplayPor
  001bf	40		 inc	 eax
  001c0	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  001c3	50		 push	 eax
  001c4	ff 75 b4	 push	 DWORD PTR $T2[ebp]
  001c7	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN584@DisplayPor:
  001cc	33 c0		 xor	 eax, eax
  001ce	c7 45 c8 07 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 7
  001d5	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0
  001dc	66 89 45 b4	 mov	 WORD PTR $T2[ebp], ax
$LN579@DisplayPor:
  001e0	f6 c3 10	 test	 bl, 16			; 00000010H
  001e3	74 2c		 je	 SHORT $LN682@DisplayPor
  001e5	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp+20]
  001e8	83 e3 ef	 and	 ebx, -17		; ffffffefH
  001eb	83 f8 08	 cmp	 eax, 8
  001ee	72 0d		 jb	 SHORT $LN687@DisplayPor
  001f0	40		 inc	 eax
  001f1	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
  001f4	50		 push	 eax
  001f5	ff 75 cc	 push	 DWORD PTR $T4[ebp]
  001f8	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN687@DisplayPor:
  001fd	33 c0		 xor	 eax, eax
  001ff	c7 45 e0 07 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 7
  00206	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0
  0020d	66 89 45 cc	 mov	 WORD PTR $T4[ebp], ax
$LN682@DisplayPor:
  00211	5f		 pop	 edi
  00212	5e		 pop	 esi
  00213	f6 c3 08	 test	 bl, 8
  00216	5b		 pop	 ebx
  00217	74 15		 je	 SHORT $LN790@DisplayPor
  00219	8b 45 f8	 mov	 eax, DWORD PTR $T6[ebp+20]
  0021c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0021f	72 0d		 jb	 SHORT $LN790@DisplayPor
  00221	40		 inc	 eax
  00222	8d 4d e4	 lea	 ecx, DWORD PTR $T6[ebp]
  00225	50		 push	 eax
  00226	ff 75 e4	 push	 DWORD PTR $T6[ebp]
  00229	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN790@DisplayPor:

; 2384 : }

  0022e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00231	33 cd		 xor	 ecx, ebp
  00233	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00238	8b e5		 mov	 esp, ebp
  0023a	5d		 pop	 ebp
  0023b	c3		 ret	 0
_DisplayPortionsOfKeys ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _DisplayRandPool
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_hPoolDisplay$ = 8					; size = 4
tv226 = 12						; size = 4
_bShow$ = 12						; size = 4
_DisplayRandPool PROC					; COMDAT

; 2330 : {		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2331 : 	unsigned char tmp[4];
; 2332 : 	unsigned char tmpByte;
; 2333 : 	int col, row;
; 2334 : 	static BOOL bRandPoolDispAscii = FALSE;
; 2335 : 
; 2336 : 	if (!bShow)

  00004	83 7d 0c 00	 cmp	 DWORD PTR _bShow$[ebp], 0
  00008	75 12		 jne	 SHORT $LN8@DisplayRan

; 2337 : 	{
; 2338 : 		SetWindowText (hPoolDisplay, "");

  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0000f	ff 75 08	 push	 DWORD PTR _hPoolDisplay$[ebp]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 2362 : 	}
; 2363 : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
$LN8@DisplayRan:
  0001c	56		 push	 esi

; 2339 : 		return;
; 2340 : 	}
; 2341 : 
; 2342 : 	RandpeekBytes (randPool, sizeof (randPool));

  0001d	6a 78		 push	 120			; 00000078H
  0001f	68 00 00 00 00	 push	 OFFSET ?randPool@@3PAEA	; randPool
  00024	e8 00 00 00 00	 call	 _RandpeekBytes
  00029	83 c4 08	 add	 esp, 8

; 2343 : 
; 2344 : 	if (memcmp (lastRandPool, randPool, sizeof(lastRandPool)) != 0)

  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lastRandPool@@3PAEA ; lastRandPool
  00031	ba 00 00 00 00	 mov	 edx, OFFSET ?randPool@@3PAEA ; randPool
  00036	be 74 00 00 00	 mov	 esi, 116		; 00000074H
  0003b	0f 1f 44 00 00	 npad	 5
$LL27@DisplayRan:
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	3b 02		 cmp	 eax, DWORD PTR [edx]
  00044	75 10		 jne	 SHORT $LN26@DisplayRan
  00046	83 c1 04	 add	 ecx, 4
  00049	83 c2 04	 add	 edx, 4
  0004c	83 ee 04	 sub	 esi, 4
  0004f	73 ef		 jae	 SHORT $LL27@DisplayRan
  00051	5e		 pop	 esi

; 2362 : 	}
; 2363 : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN26@DisplayRan:

; 2345 : 	{
; 2346 : 		outRandPoolDispBuffer[0] = 0;

  00056	b8 00 00 00 00	 mov	 eax, OFFSET ?randPool@@3PAEA ; randPool
  0005b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?outRandPoolDispBuffer@@3PAEA, 0
  00062	53		 push	 ebx
  00063	89 45 0c	 mov	 DWORD PTR tv226[ebp], eax
  00066	57		 push	 edi
  00067	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@DisplayRan:

; 2347 : 
; 2348 : 		for (row = 0; row < RANDPOOL_DISPLAY_ROWS; row++)
; 2349 : 		{
; 2350 : 			for (col = 0; col < RANDPOOL_DISPLAY_COLUMNS; col++)

  00070	33 db		 xor	 ebx, ebx
$LL7@DisplayRan:

; 2351 : 			{
; 2352 : 				tmpByte = randPool[row * RANDPOOL_DISPLAY_COLUMNS + col];
; 2353 : 
; 2354 : 				sprintf ((char *) tmp, bRandPoolDispAscii ? ((tmpByte >= 32 && tmpByte < 255 && tmpByte != '&') ? " %c " : " . ") : "%02X ", tmpByte);

  00072	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bRandPoolDispAscii@?1??DisplayRandPool@@9@4HA, 0
  00079	8a 0c 18	 mov	 cl, BYTE PTR [eax+ebx]
  0007c	74 1a		 je	 SHORT $LN15@DisplayRan
  0007e	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  00081	3c de		 cmp	 al, 222			; 000000deH
  00083	77 0c		 ja	 SHORT $LN13@DisplayRan
  00085	80 f9 26	 cmp	 cl, 38			; 00000026H
  00088	74 07		 je	 SHORT $LN13@DisplayRan
  0008a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04LAOFCJDB@?5?$CFc?5?$AA@
  0008f	eb 0c		 jmp	 SHORT $LN16@DisplayRan
$LN13@DisplayRan:
  00091	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_03NJNOMAJF@?5?4?5?$AA@
  00096	eb 05		 jmp	 SHORT $LN16@DisplayRan
$LN15@DisplayRan:
  00098	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05BFHEBJNP@?$CF02X?5?$AA@
$LN16@DisplayRan:
  0009d	0f b6 c1	 movzx	 eax, cl
  000a0	50		 push	 eax
  000a1	52		 push	 edx
  000a2	8d 45 fc	 lea	 eax, DWORD PTR _tmp$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _sprintf

; 2355 : 				strcat ((char *) outRandPoolDispBuffer, (char *) tmp);

  000ab	8d 45 fc	 lea	 eax, DWORD PTR _tmp$[ebp]
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	8b f0		 mov	 esi, eax
$LL28@DisplayRan:
  000b3	8a 08		 mov	 cl, BYTE PTR [eax]
  000b5	40		 inc	 eax
  000b6	84 c9		 test	 cl, cl
  000b8	75 f9		 jne	 SHORT $LL28@DisplayRan
  000ba	bf 00 00 00 00	 mov	 edi, OFFSET ?outRandPoolDispBuffer@@3PAEA ; outRandPoolDispBuffer
  000bf	2b c6		 sub	 eax, esi
  000c1	4f		 dec	 edi
$LL29@DisplayRan:
  000c2	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000c5	47		 inc	 edi
  000c6	84 c9		 test	 cl, cl
  000c8	75 f8		 jne	 SHORT $LL29@DisplayRan
  000ca	8b c8		 mov	 ecx, eax
  000cc	43		 inc	 ebx
  000cd	c1 e9 02	 shr	 ecx, 2
  000d0	f3 a5		 rep movsd
  000d2	8b c8		 mov	 ecx, eax
  000d4	8b 45 0c	 mov	 eax, DWORD PTR tv226[ebp]
  000d7	83 e1 03	 and	 ecx, 3
  000da	f3 a4		 rep movsb
  000dc	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  000df	7c 91		 jl	 SHORT $LL7@DisplayRan

; 2356 : 			}
; 2357 : 			strcat ((char *) outRandPoolDispBuffer, "\n");

  000e1	bf 00 00 00 00	 mov	 edi, OFFSET ?outRandPoolDispBuffer@@3PAEA ; outRandPoolDispBuffer
  000e6	4f		 dec	 edi
$LL30@DisplayRan:
  000e7	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000ea	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  000ed	84 c0		 test	 al, al
  000ef	75 f6		 jne	 SHORT $LL30@DisplayRan
  000f1	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
  000f7	66 89 07	 mov	 WORD PTR [edi], ax
  000fa	8b 45 0c	 mov	 eax, DWORD PTR tv226[ebp]
  000fd	83 c0 0f	 add	 eax, 15			; 0000000fH
  00100	89 45 0c	 mov	 DWORD PTR tv226[ebp], eax
  00103	3d 78 00 00 00	 cmp	 eax, OFFSET ?randPool@@3PAEA+120
  00108	0f 8c 62 ff ff
	ff		 jl	 $LL4@DisplayRan

; 2358 : 		}
; 2359 : 		SetWindowText (hPoolDisplay, (char *) outRandPoolDispBuffer);

  0010e	68 00 00 00 00	 push	 OFFSET ?outRandPoolDispBuffer@@3PAEA ; outRandPoolDispBuffer
  00113	ff 75 08	 push	 DWORD PTR _hPoolDisplay$[ebp]
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 2360 : 
; 2361 : 		memcpy (lastRandPool, randPool, sizeof(lastRandPool));

  0011c	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  00121	be 00 00 00 00	 mov	 esi, OFFSET ?randPool@@3PAEA ; randPool
  00126	bf 00 00 00 00	 mov	 edi, OFFSET ?lastRandPool@@3PAEA ; lastRandPool
  0012b	f3 a5		 rep movsd
  0012d	5f		 pop	 edi
  0012e	5b		 pop	 ebx
  0012f	5e		 pop	 esi

; 2362 : 	}
; 2363 : }

  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
_DisplayRandPool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _ExtractCommandLine
_TEXT	SEGMENT
_as$1 = -688						; size = 8
_nArgPos$2 = -680					; size = 4
_lpszCommandLineArgs$ = -676				; size = 4
_i$3 = -672						; size = 4
_args$4 = -668						; size = 624
_szTmp$5 = -44						; size = 32
_szTmp$6 = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_lpszCommandLine$ = 12					; size = 4
_ExtractCommandLine PROC				; COMDAT

; 8358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 02 00
	00		 sub	 esp, 688		; 000002b0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _lpszCommandLine$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]

; 8359 : 	char **lpszCommandLineArgs;	/* Array of command line arguments */
; 8360 : 	int nNoCommandLineArgs;	/* The number of arguments in the array */
; 8361 : 
; 8362 : 	if (_stricmp (lpszCommandLine, "-Embedding") == 0)

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JGIDNNFC@?9Embedding?$AA@
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 __stricmp
  00026	83 c4 08	 add	 esp, 8
  00029	85 c0		 test	 eax, eax
  0002b	75 1a		 jne	 SHORT $LN9@ExtractCom

; 8363 : 	{
; 8364 : 		ComServerMode = TRUE;

  0002d	5f		 pop	 edi
  0002e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ComServerMode@@3HA, 1 ; ComServerMode
  00038	5e		 pop	 esi

; 8599 : 	}
; 8600 : }

  00039	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003c	33 cd		 xor	 ecx, ebp
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN9@ExtractCom:

; 8365 : 		return;
; 8366 : 	}
; 8367 : 
; 8368 : 	/* Extract command line arguments */
; 8369 : 	nNoCommandLineArgs = Win32CommandLine (lpszCommandLine, &lpszCommandLineArgs);

  00047	8d 85 5c fd ff
	ff		 lea	 eax, DWORD PTR _lpszCommandLineArgs$[ebp]
  0004d	50		 push	 eax
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 _Win32CommandLine
  00054	8b f0		 mov	 esi, eax
  00056	83 c4 08	 add	 esp, 8

; 8370 : 	if (nNoCommandLineArgs > 0)

  00059	85 f6		 test	 esi, esi
  0005b	0f 8e a0 08 00
	00		 jle	 $LN146@ExtractCom

; 8371 : 	{
; 8372 : 		int i;
; 8373 : 
; 8374 : 		for (i = 0; i < nNoCommandLineArgs; i++)

  00061	c7 85 60 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$3[ebp], 0
  0006b	0f 1f 44 00 00	 npad	 5
$LL4@ExtractCom:

; 8375 : 		{
; 8376 : 			enum
; 8377 : 			{
; 8378 : 				OptionHistory,
; 8379 : 				OptionNoIsoCheck,
; 8380 : 				OptionQuit,
; 8381 : 				OptionTokenLib,
; 8382 : 				CommandResumeSysEncLogOn,
; 8383 : 				CommandResumeSysEnc,
; 8384 : 				CommandDecryptSysEnc,
; 8385 : 				CommandEncDev,
; 8386 : 				CommandHiddenSys,
; 8387 : 				CommandResumeInplaceLogOn,
; 8388 : 				CommandResumeHiddenSys,
; 8389 : 				CommandSysEnc,
; 8390 : 				CommandResumeInplace,
; 8391 : 			};
; 8392 : 
; 8393 : 			argument args[]=
; 8394 : 			{
; 8395 : 				{ OptionHistory,				"/history",			"/h", FALSE },

  00070	0f b6 05 08 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_08BCLHLEKP@?1history?$AA@+8
  00077	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_08BCLHLEKP@?1history?$AA@
  0007f	88 85 70 fd ff
	ff		 mov	 BYTE PTR _args$4[ebp+12], al
  00085	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02JOILMGJP@?1h?$AA@
  0008c	66 89 85 88 fd
	ff ff		 mov	 WORD PTR _args$4[ebp+36], ax
  00093	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02JOILMGJP@?1h?$AA@+2
  0009a	88 85 8a fd ff
	ff		 mov	 BYTE PTR _args$4[ebp+38], al

; 8396 : 				{ OptionNoIsoCheck,				"/noisocheck",		"/n", FALSE },

  000a0	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0M@IEGCIDAG@?1noisocheck?$AA@+8
  000a5	89 85 a0 fd ff
	ff		 mov	 DWORD PTR _args$4[ebp+60], eax
  000ab	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02MINBGBBJ@?1n?$AA@
  000b2	66 89 85 b8 fd
	ff ff		 mov	 WORD PTR _args$4[ebp+84], ax
  000b9	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02MINBGBBJ@?1n?$AA@+2
  000c0	66 0f d6 85 68
	fd ff ff	 movq	 QWORD PTR _args$4[ebp+4], xmm0
  000c8	0f 57 c0	 xorps	 xmm0, xmm0
  000cb	88 85 ba fd ff
	ff		 mov	 BYTE PTR _args$4[ebp+86], al

; 8397 : 				{ OptionQuit,					"/quit",			"/q", FALSE },

  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05CMMBDMDD@?1quit?$AA@
  000d6	0f 11 85 71 fd
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+13], xmm0
  000dd	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _args$4[ebp+100], eax
  000e3	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0M@IEGCIDAG@?1noisocheck?$AA@
  000eb	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05CMMBDMDD@?1quit?$AA@+4
  000f2	66 0f d6 85 98
	fd ff ff	 movq	 QWORD PTR _args$4[ebp+52], xmm0
  000fa	0f 57 c0	 xorps	 xmm0, xmm0
  000fd	66 89 85 cc fd
	ff ff		 mov	 WORD PTR _args$4[ebp+104], ax
  00104	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02FILGPIH@?1q?$AA@
  0010b	0f 11 85 a4 fd
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+64], xmm0
  00112	66 89 85 e8 fd
	ff ff		 mov	 WORD PTR _args$4[ebp+132], ax
  00119	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02FILGPIH@?1q?$AA@+2
  00120	0f 11 85 ce fd
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+106], xmm0
  00127	88 85 ea fd ff
	ff		 mov	 BYTE PTR _args$4[ebp+134], al

; 8398 : 				{ OptionTokenLib,				"/tokenlib",		NULL, FALSE },

  0012d	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR ??_C@_09JABABBPB@?1tokenlib?$AA@+8
  00134	66 0f d6 85 de
	fd ff ff	 movq	 QWORD PTR _args$4[ebp+122], xmm0
  0013c	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_09JABABBPB@?1tokenlib?$AA@
  00144	66 0f d6 85 f8
	fd ff ff	 movq	 QWORD PTR _args$4[ebp+148], xmm0
  0014c	0f 57 c0	 xorps	 xmm0, xmm0
  0014f	66 89 85 00 fe
	ff ff		 mov	 WORD PTR _args$4[ebp+156], ax

; 8399 : 
; 8400 : 				{ CommandResumeSysEncLogOn,		"/acsysenc",		"/a", TRUE },

  00156	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR ??_C@_09PIOBCILE@?1acsysenc?$AA@+8
  0015d	0f 11 85 02 fe
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+158], xmm0
  00164	66 89 85 30 fe
	ff ff		 mov	 WORD PTR _args$4[ebp+204], ax
  0016b	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02EPEJHNNG@?1a?$AA@
  00172	66 0f d6 85 1a
	fe ff ff	 movq	 QWORD PTR _args$4[ebp+182], xmm0
  0017a	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_09PIOBCILE@?1acsysenc?$AA@
  00182	66 0f d6 85 28
	fe ff ff	 movq	 QWORD PTR _args$4[ebp+196], xmm0
  0018a	0f 57 c0	 xorps	 xmm0, xmm0
  0018d	0f 11 85 32 fe
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+206], xmm0
  00194	66 89 85 48 fe
	ff ff		 mov	 WORD PTR _args$4[ebp+228], ax
  0019b	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02EPEJHNNG@?1a?$AA@+2

; 8401 : 				{ CommandResumeSysEnc,			"/csysenc",			"/c", TRUE },

  001a2	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_08FFGENEKE@?1csysenc?$AA@
  001aa	88 85 4a fe ff
	ff		 mov	 BYTE PTR _args$4[ebp+230], al
  001b0	0f b6 05 08 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_08FFGENEKE@?1csysenc?$AA@+8
  001b7	66 0f d6 85 58
	fe ff ff	 movq	 QWORD PTR _args$4[ebp+244], xmm0
  001bf	0f 57 c0	 xorps	 xmm0, xmm0
  001c2	c7 85 64 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp], 0
  001cc	c7 85 81 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+29], 0
  001d6	66 c7 85 85 fd
	ff ff 00 00	 mov	 WORD PTR _args$4[ebp+33], 0
  001df	c6 85 87 fd ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+35], 0
  001e6	c7 85 8b fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+39], 0
  001f0	c6 85 8f fd ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+43], 0
  001f7	c7 85 90 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+44], 0
  00201	c7 85 94 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _args$4[ebp+48], 1
  0020b	c7 85 b4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+80], 0
  00215	c7 85 bb fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+87], 0
  0021f	c6 85 bf fd ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+91], 0
  00226	c7 85 c0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+92], 0
  00230	c7 85 c4 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _args$4[ebp+96], 2
  0023a	66 c7 85 e6 fd
	ff ff 00 00	 mov	 WORD PTR _args$4[ebp+130], 0
  00243	c7 85 eb fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+135], 0
  0024d	c6 85 ef fd ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+139], 0
  00254	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+140], 0
  0025e	c7 85 f4 fd ff
	ff 03 00 00 00	 mov	 DWORD PTR _args$4[ebp+144], 3
  00268	c7 85 12 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+174], 0
  00272	c7 85 16 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+178], 0
  0027c	66 c7 85 22 fe
	ff ff 00 00	 mov	 WORD PTR _args$4[ebp+190], 0
  00285	c7 85 24 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR _args$4[ebp+192], 4
  0028f	c7 85 42 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+222], 0
  00299	66 c7 85 46 fe
	ff ff 00 00	 mov	 WORD PTR _args$4[ebp+226], 0
  002a2	c7 85 4b fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+231], 0
  002ac	c6 85 4f fe ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+235], 0
  002b3	c7 85 50 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _args$4[ebp+236], 1
  002bd	c7 85 54 fe ff
	ff 05 00 00 00	 mov	 DWORD PTR _args$4[ebp+240], 5
  002c7	88 85 60 fe ff
	ff		 mov	 BYTE PTR _args$4[ebp+252], al
  002cd	0f 11 85 61 fe
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+253], xmm0
  002d4	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02HNHPBPFE@?1c?$AA@
  002db	66 89 85 78 fe
	ff ff		 mov	 WORD PTR _args$4[ebp+276], ax
  002e2	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02HNHPBPFE@?1c?$AA@+2
  002e9	88 85 7a fe ff
	ff		 mov	 BYTE PTR _args$4[ebp+278], al

; 8402 : 				{ CommandDecryptSysEnc,			"/dsysenc",			"/d", TRUE },

  002ef	0f b6 05 08 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_08FPKBNNLN@?1dsysenc?$AA@+8
  002f6	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_08FPKBNNLN@?1dsysenc?$AA@
  002fe	88 85 90 fe ff
	ff		 mov	 BYTE PTR _args$4[ebp+300], al
  00304	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02DCDOIJJD@?1d?$AA@
  0030b	66 89 85 a8 fe
	ff ff		 mov	 WORD PTR _args$4[ebp+324], ax
  00312	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02DCDOIJJD@?1d?$AA@+2
  00319	88 85 aa fe ff
	ff		 mov	 BYTE PTR _args$4[ebp+326], al

; 8403 : 				{ CommandEncDev,				"/encdev",			"/e", TRUE },

  0031f	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07MFEOHHG@?1encdev?$AA@
  00324	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _args$4[ebp+340], eax
  0032a	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_07MFEOHHG@?1encdev?$AA@+4
  0032f	89 85 bc fe ff
	ff		 mov	 DWORD PTR _args$4[ebp+344], eax
  00335	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02CLCFLINC@?1e?$AA@
  0033c	66 89 85 d8 fe
	ff ff		 mov	 WORD PTR _args$4[ebp+372], ax
  00343	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02CLCFLINC@?1e?$AA@+2
  0034a	88 85 da fe ff
	ff		 mov	 BYTE PTR _args$4[ebp+374], al

; 8404 : 				{ CommandHiddenSys,				"/isysenc",			"/i", TRUE },	

  00350	0f b6 05 08 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_08MEKEMIGM@?1isysenc?$AA@+8
  00357	88 85 f0 fe ff
	ff		 mov	 BYTE PTR _args$4[ebp+396], al
  0035d	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02IHJAPHNO@?1i?$AA@
  00364	66 0f d6 85 88
	fe ff ff	 movq	 QWORD PTR _args$4[ebp+292], xmm0
  0036c	0f 57 c0	 xorps	 xmm0, xmm0
  0036f	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _args$4[ebp+420], ax
  00376	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02IHJAPHNO@?1i?$AA@+2
  0037d	0f 11 85 91 fe
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+301], xmm0
  00384	88 85 0a ff ff
	ff		 mov	 BYTE PTR _args$4[ebp+422], al

; 8405 : 				{ CommandResumeInplaceLogOn,	"/prinplace",		"/p", TRUE },

  0038a	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0L@DLEMDKJB@?1prinplace?$AA@+8
  00391	0f 11 85 c0 fe
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+348], xmm0
  00398	66 89 85 20 ff
	ff ff		 mov	 WORD PTR _args$4[ebp+444], ax
  0039f	0f b6 05 0a 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_0L@DLEMDKJB@?1prinplace?$AA@+10
  003a6	66 0f d6 85 d0
	fe ff ff	 movq	 QWORD PTR _args$4[ebp+364], xmm0
  003ae	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_08MEKEMIGM@?1isysenc?$AA@
  003b6	66 0f d6 85 e8
	fe ff ff	 movq	 QWORD PTR _args$4[ebp+388], xmm0
  003be	0f 57 c0	 xorps	 xmm0, xmm0
  003c1	0f 11 85 f1 fe
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+397], xmm0
  003c8	88 85 22 ff ff
	ff		 mov	 BYTE PTR _args$4[ebp+446], al
  003ce	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@DLEMDKJB@?1prinplace?$AA@
  003d6	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02BMJAFOMG@?1p?$AA@
  003dd	66 0f d6 85 18
	ff ff ff	 movq	 QWORD PTR _args$4[ebp+436], xmm0
  003e5	0f 57 c0	 xorps	 xmm0, xmm0
  003e8	66 89 85 38 ff
	ff ff		 mov	 WORD PTR _args$4[ebp+468], ax
  003ef	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02BMJAFOMG@?1p?$AA@+2
  003f6	0f 11 85 23 ff
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+447], xmm0
  003fd	88 85 3a ff ff
	ff		 mov	 BYTE PTR _args$4[ebp+470], al

; 8406 : 				{ CommandResumeHiddenSys,		"/risysenc",		"/r", TRUE },	

  00403	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_09PMGMEKMI@?1risysenc?$AA@
  0040b	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR ??_C@_09PMGMEKMI@?1risysenc?$AA@+8
  00412	c7 85 71 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+269], 0
  0041c	66 c7 85 75 fe
	ff ff 00 00	 mov	 WORD PTR _args$4[ebp+273], 0
  00425	c6 85 77 fe ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+275], 0
  0042c	c7 85 7b fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+279], 0
  00436	c6 85 7f fe ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+283], 0
  0043d	c7 85 80 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _args$4[ebp+284], 1
  00447	c7 85 84 fe ff
	ff 06 00 00 00	 mov	 DWORD PTR _args$4[ebp+288], 6
  00451	c7 85 a1 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+317], 0
  0045b	66 c7 85 a5 fe
	ff ff 00 00	 mov	 WORD PTR _args$4[ebp+321], 0
  00464	c6 85 a7 fe ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+323], 0
  0046b	c7 85 ab fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+327], 0
  00475	c6 85 af fe ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+331], 0
  0047c	c7 85 b0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _args$4[ebp+332], 1
  00486	c7 85 b4 fe ff
	ff 07 00 00 00	 mov	 DWORD PTR _args$4[ebp+336], 7
  00490	c7 85 db fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+375], 0
  0049a	c6 85 df fe ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+379], 0
  004a1	c7 85 e0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _args$4[ebp+380], 1
  004ab	c7 85 e4 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _args$4[ebp+384], 8
  004b5	c7 85 01 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+413], 0
  004bf	66 c7 85 05 ff
	ff ff 00 00	 mov	 WORD PTR _args$4[ebp+417], 0
  004c8	c6 85 07 ff ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+419], 0
  004cf	c7 85 0b ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+423], 0
  004d9	c6 85 0f ff ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+427], 0
  004e0	c7 85 10 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _args$4[ebp+428], 1
  004ea	c7 85 14 ff ff
	ff 09 00 00 00	 mov	 DWORD PTR _args$4[ebp+432], 9
  004f4	c7 85 33 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+463], 0
  004fe	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+467], 0
  00505	c7 85 3b ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+471], 0
  0050f	c6 85 3f ff ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+475], 0
  00516	c7 85 40 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _args$4[ebp+476], 1
  00520	c7 85 44 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR _args$4[ebp+480], 10 ; 0000000aH
  0052a	66 0f d6 85 48
	ff ff ff	 movq	 QWORD PTR _args$4[ebp+484], xmm0
  00532	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _args$4[ebp+492], ax
  00539	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02COKGDMEE@?1r?$AA@
  00540	0f 57 c0	 xorps	 xmm0, xmm0
  00543	66 89 85 68 ff
	ff ff		 mov	 WORD PTR _args$4[ebp+516], ax
  0054a	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02COKGDMEE@?1r?$AA@+2

; 8407 : 				{ CommandSysEnc,				"/sysenc",			"/s", TRUE },	
; 8408 : 				{ CommandResumeInplace,			"/zinplace",		"/z", TRUE }
; 8409 : 			};
; 8410 : 
; 8411 : 			argumentspec as;
; 8412 : 
; 8413 : 			int nArgPos;
; 8414 : 			int x;
; 8415 : 
; 8416 : 			if (lpszCommandLineArgs[i] == NULL)

  00551	8b 8d 5c fd ff
	ff		 mov	 ecx, DWORD PTR _lpszCommandLineArgs$[ebp]
  00557	88 85 6a ff ff
	ff		 mov	 BYTE PTR _args$4[ebp+518], al
  0055d	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07PFDFIFLD@?1sysenc?$AA@
  00562	89 85 78 ff ff
	ff		 mov	 DWORD PTR _args$4[ebp+532], eax
  00568	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_07PFDFIFLD@?1sysenc?$AA@+4
  0056d	89 85 7c ff ff
	ff		 mov	 DWORD PTR _args$4[ebp+536], eax
  00573	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02DHLNANAF@?1s?$AA@
  0057a	66 89 45 98	 mov	 WORD PTR _args$4[ebp+564], ax
  0057e	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02DHLNANAF@?1s?$AA@+2
  00585	88 45 9a	 mov	 BYTE PTR _args$4[ebp+566], al
  00588	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR ??_C@_09FFOCOHMH@?1zinplace?$AA@+8
  0058f	66 89 45 b0	 mov	 WORD PTR _args$4[ebp+588], ax
  00593	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02OGHPLGEM@?1z?$AA@
  0059a	66 89 45 c8	 mov	 WORD PTR _args$4[ebp+612], ax
  0059e	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02OGHPLGEM@?1z?$AA@+2
  005a5	0f 11 85 52 ff
	ff ff		 movups	 XMMWORD PTR _args$4[ebp+494], xmm0
  005ac	88 45 ca	 mov	 BYTE PTR _args$4[ebp+614], al
  005af	8b 85 60 fd ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  005b5	0f 11 45 80	 movups	 XMMWORD PTR _args$4[ebp+540], xmm0
  005b9	c7 85 62 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+510], 0
  005c3	66 0f d6 45 90	 movq	 QWORD PTR _args$4[ebp+556], xmm0
  005c8	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_09FFOCOHMH@?1zinplace?$AA@
  005d0	66 0f d6 45 a8	 movq	 QWORD PTR _args$4[ebp+580], xmm0
  005d5	0f 57 c0	 xorps	 xmm0, xmm0
  005d8	66 c7 85 66 ff
	ff ff 00 00	 mov	 WORD PTR _args$4[ebp+514], 0
  005e1	c7 85 6b ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$4[ebp+519], 0
  005eb	c6 85 6f ff ff
	ff 00		 mov	 BYTE PTR _args$4[ebp+523], 0
  005f2	c7 85 70 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _args$4[ebp+524], 1
  005fc	c7 85 74 ff ff
	ff 0b 00 00 00	 mov	 DWORD PTR _args$4[ebp+528], 11 ; 0000000bH
  00606	c7 45 9b 00 00
	00 00		 mov	 DWORD PTR _args$4[ebp+567], 0
  0060d	c6 45 9f 00	 mov	 BYTE PTR _args$4[ebp+571], 0
  00611	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR _args$4[ebp+572], 1
  00618	c7 45 a4 0c 00
	00 00		 mov	 DWORD PTR _args$4[ebp+576], 12 ; 0000000cH
  0061f	0f 11 45 b2	 movups	 XMMWORD PTR _args$4[ebp+590], xmm0
  00623	c7 45 c2 00 00
	00 00		 mov	 DWORD PTR _args$4[ebp+606], 0
  0062a	66 c7 45 c6 00
	00		 mov	 WORD PTR _args$4[ebp+610], 0
  00630	c7 45 cb 00 00
	00 00		 mov	 DWORD PTR _args$4[ebp+615], 0
  00637	c6 45 cf 00	 mov	 BYTE PTR _args$4[ebp+619], 0
  0063b	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _args$4[ebp+620], 1
  00642	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00646	0f 84 a0 02 00
	00		 je	 $LN2@ExtractCom

; 8417 : 				continue;
; 8418 : 
; 8419 : 			as.args = args;

  0064c	8d 95 64 fd ff
	ff		 lea	 edx, DWORD PTR _args$4[ebp]

; 8420 : 			as.arg_cnt = sizeof(args)/ sizeof(args[0]);

  00652	c7 85 54 fd ff
	ff 0d 00 00 00	 mov	 DWORD PTR _as$1[ebp+4], 13 ; 0000000dH
  0065c	89 95 50 fd ff
	ff		 mov	 DWORD PTR _as$1[ebp], edx

; 8421 : 			
; 8422 : 			x = GetArgumentID (&as, lpszCommandLineArgs[i], &nArgPos);

  00662	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR _nArgPos$2[ebp]
  00668	52		 push	 edx
  00669	ff 34 81	 push	 DWORD PTR [ecx+eax*4]
  0066c	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR _as$1[ebp]
  00672	50		 push	 eax
  00673	e8 00 00 00 00	 call	 _GetArgumentID
  00678	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8423 : 
; 8424 : 			switch (x)

  0067b	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0067e	0f 87 c6 02 00
	00		 ja	 $LN43@ExtractCom
  00684	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN154@ExtractCom[eax*4]
$LN12@ExtractCom:

; 8425 : 			{
; 8426 : 			case CommandSysEnc:
; 8427 : 				// Encrypt system partition/drive (passed by Mount if system encryption hasn't started or to reverse decryption)
; 8428 : 
; 8429 : 				// From now on, we should be the only instance of the GST wizard allowed to deal with system encryption
; 8430 : 				if (CreateSysEncMutex ())

  0068b	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00690	85 c0		 test	 eax, eax
  00692	0f 84 9e 02 00
	00		 je	 $LN153@ExtractCom

; 8431 : 				{
; 8432 : 					bDirectSysEncMode = TRUE;
; 8433 : 					bDirectSysEncModeCommand = SYSENC_COMMAND_ENCRYPT;

  00698	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?bDirectSysEncModeCommand@@3HA, 3 ; bDirectSysEncModeCommand
$LN152@ExtractCom:

; 8434 : 					ChangeWizardMode (WIZARD_MODE_SYS_DEVICE);

  006a2	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  006a9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDirectSysEncMode@@3HA, 1 ; bDirectSysEncMode
  006b3	74 5a		 je	 SHORT $LN46@ExtractCom
  006b5	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  006ba	e8 00 00 00 00	 call	 _CreateSysEncMutex
  006bf	85 c0		 test	 eax, eax
  006c1	75 12		 jne	 SHORT $LN50@ExtractCom
  006c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  006c8	e8 00 00 00 00	 call	 _Error
  006cd	83 c4 04	 add	 esp, 4
  006d0	e9 17 02 00 00	 jmp	 $LN2@ExtractCom
$LN50@ExtractCom:
  006d5	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
  006da	0f 57 c0	 xorps	 xmm0, xmm0
  006dd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  006e7	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  006ee	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  006f5	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  006fd	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  00705	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _WizardMode, 2
$LN46@ExtractCom:
  0070f	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  00714	f7 d8		 neg	 eax
  00716	1b c0		 sbb	 eax, eax
  00718	f7 d8		 neg	 eax
  0071a	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice

; 8440 : 				}
; 8441 : 
; 8442 : 				break;

  0071f	e9 c8 01 00 00	 jmp	 $LN2@ExtractCom
$LN15@ExtractCom:

; 8443 : 
; 8444 : 			case CommandDecryptSysEnc:
; 8445 : 				// Decrypt system partition/drive (passed by Mount, also to reverse encryption in progress, when paused)
; 8446 : 
; 8447 : 				// From now on, we should be the only instance of the GST wizard allowed to deal with system encryption
; 8448 : 				if (CreateSysEncMutex ())

  00724	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00729	85 c0		 test	 eax, eax
  0072b	0f 84 05 02 00
	00		 je	 $LN153@ExtractCom

; 8449 : 				{
; 8450 : 					bDirectSysEncMode = TRUE;
; 8451 : 					bDirectSysEncModeCommand = SYSENC_COMMAND_DECRYPT;

  00731	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?bDirectSysEncModeCommand@@3HA, 4 ; bDirectSysEncModeCommand

; 8452 : 					ChangeWizardMode (WIZARD_MODE_SYS_DEVICE);

  0073b	e9 62 ff ff ff	 jmp	 $LN152@ExtractCom
$LN18@ExtractCom:

; 8453 : 				}
; 8454 : 				else
; 8455 : 				{
; 8456 : 					Warning ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");
; 8457 : 					exit(0);
; 8458 : 				}
; 8459 : 				break;
; 8460 : 
; 8461 : 			case CommandHiddenSys:
; 8462 : 				// Create a hidden operating system (passed by Mount when the user selects System -> Create Hidden Operating System)
; 8463 : 
; 8464 : 				// From now on, we should be the only instance of the GST wizard allowed to deal with system encryption
; 8465 : 				if (CreateSysEncMutex ())

  00740	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00745	85 c0		 test	 eax, eax
  00747	0f 84 e9 01 00
	00		 je	 $LN153@ExtractCom

; 8466 : 				{
; 8467 : 					bDirectSysEncMode = TRUE;
; 8468 : 					bDirectSysEncModeCommand = SYSENC_COMMAND_CREATE_HIDDEN_OS;

  0074d	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?bDirectSysEncModeCommand@@3HA, 5 ; bDirectSysEncModeCommand

; 8469 : 					ChangeWizardMode (WIZARD_MODE_SYS_DEVICE);

  00757	e9 46 ff ff ff	 jmp	 $LN152@ExtractCom
$LN21@ExtractCom:

; 8470 : 				}
; 8471 : 				else
; 8472 : 				{
; 8473 : 					Warning ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");
; 8474 : 					exit(0);
; 8475 : 				}
; 8476 : 
; 8477 : 				break;
; 8478 : 
; 8479 : 			case CommandResumeHiddenSys:
; 8480 : 				// Resume process of creation of a hidden operating system (passed by Wizard when the user needs to UAC-elevate the whole wizard process)
; 8481 : 
; 8482 : 				// From now on, we should be the only instance of the GST wizard allowed to deal with system encryption
; 8483 : 				if (CreateSysEncMutex ())

  0075c	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00761	85 c0		 test	 eax, eax
  00763	0f 84 cd 01 00
	00		 je	 $LN153@ExtractCom

; 8484 : 				{
; 8485 : 					bDirectSysEncMode = TRUE;
; 8486 : 					bDirectSysEncModeCommand = SYSENC_COMMAND_CREATE_HIDDEN_OS_ELEV;

  00769	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?bDirectSysEncModeCommand@@3HA, 6 ; bDirectSysEncModeCommand

; 8487 : 					ChangeWizardMode (WIZARD_MODE_SYS_DEVICE);

  00773	e9 2a ff ff ff	 jmp	 $LN152@ExtractCom
$LN24@ExtractCom:

; 8488 : 				}
; 8489 : 				else
; 8490 : 				{
; 8491 : 					Warning ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");
; 8492 : 					exit(0);
; 8493 : 				}
; 8494 : 
; 8495 : 				break;
; 8496 : 
; 8497 : 			case CommandResumeSysEnc:
; 8498 : 				// Resume previous system-encryption operation (passed by Mount) e.g. encryption, decryption, or pretest 
; 8499 : 
; 8500 : 				// From now on, we should be the only instance of the GST wizard allowed to deal with system encryption
; 8501 : 				if (CreateSysEncMutex ())

  00778	e8 00 00 00 00	 call	 _CreateSysEncMutex
  0077d	85 c0		 test	 eax, eax
  0077f	0f 84 b1 01 00
	00		 je	 $LN153@ExtractCom

; 8502 : 				{
; 8503 : 					bDirectSysEncMode = TRUE;
; 8504 : 					bDirectSysEncModeCommand = SYSENC_COMMAND_RESUME;

  00785	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDirectSysEncModeCommand@@3HA, 1 ; bDirectSysEncModeCommand

; 8505 : 					ChangeWizardMode (WIZARD_MODE_SYS_DEVICE);

  0078f	e9 0e ff ff ff	 jmp	 $LN152@ExtractCom
$LN27@ExtractCom:

; 8506 : 				}
; 8507 : 				else
; 8508 : 				{
; 8509 : 					Warning ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");
; 8510 : 					exit(0);
; 8511 : 				}
; 8512 : 				break;
; 8513 : 
; 8514 : 			case CommandResumeSysEncLogOn:
; 8515 : 				// Same as csysenc but passed only by the system (from the startup sequence)
; 8516 : 
; 8517 : 				// From now on, we should be the only instance of the GST wizard allowed to deal with system encryption
; 8518 : 				if (CreateSysEncMutex ())

  00794	e8 00 00 00 00	 call	 _CreateSysEncMutex
  00799	85 c0		 test	 eax, eax
  0079b	0f 84 95 01 00
	00		 je	 $LN153@ExtractCom

; 8519 : 				{
; 8520 : 					bDirectSysEncMode = TRUE;
; 8521 : 					bDirectSysEncModeCommand = SYSENC_COMMAND_STARTUP_SEQ_RESUME;

  007a1	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?bDirectSysEncModeCommand@@3HA, 2 ; bDirectSysEncModeCommand

; 8522 : 					ChangeWizardMode (WIZARD_MODE_SYS_DEVICE);

  007ab	e9 f2 fe ff ff	 jmp	 $LN152@ExtractCom
$LN30@ExtractCom:

; 8523 : 				}
; 8524 : 				else
; 8525 : 				{
; 8526 : 					Warning ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");
; 8527 : 					exit(0);
; 8528 : 				}
; 8529 : 				break;
; 8530 : 
; 8531 : 			case CommandEncDev:
; 8532 : 				// Resume process of creation of a non-sys-device-hosted volume (passed by Wizard when the user needs to UAC-elevate)
; 8533 : 				DirectDeviceEncMode = TRUE;

  007b0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DirectDeviceEncMode@@3HA, 1 ; DirectDeviceEncMode

; 8534 : 				break;

  007ba	e9 2d 01 00 00	 jmp	 $LN2@ExtractCom
$LN31@ExtractCom:

; 8535 : 
; 8536 : 			case CommandResumeInplace:
; 8537 : 				// Resume interrupted process of non-system in-place encryption of a partition
; 8538 : 				DirectNonSysInplaceEncResumeMode = TRUE;

  007bf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DirectNonSysInplaceEncResumeMode@@3HA, 1 ; DirectNonSysInplaceEncResumeMode

; 8539 : 				break;

  007c9	e9 1e 01 00 00	 jmp	 $LN2@ExtractCom
$LN32@ExtractCom:

; 8540 : 
; 8541 : 			case CommandResumeInplaceLogOn:
; 8542 : 				// Ask the user whether to resume interrupted process of non-system in-place encryption of a partition
; 8543 : 				// This switch is passed only by the system (from the startup sequence).
; 8544 : 				DirectPromptNonSysInplaceEncResumeMode = TRUE;

  007ce	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DirectPromptNonSysInplaceEncResumeMode@@3HA, 1 ; DirectPromptNonSysInplaceEncResumeMode

; 8545 : 				break;

  007d8	e9 0f 01 00 00	 jmp	 $LN2@ExtractCom
$LN33@ExtractCom:

; 8546 : 
; 8547 : 			case OptionNoIsoCheck:
; 8548 : 				bDontVerifyRescueDisk = TRUE;

  007dd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDontVerifyRescueDisk@@3HA, 1 ; bDontVerifyRescueDisk

; 8549 : 				break;

  007e7	e9 00 01 00 00	 jmp	 $LN2@ExtractCom
$LN34@ExtractCom:

; 8550 : 
; 8551 : 			case OptionHistory:
; 8552 : 				{
; 8553 : 					char szTmp[8];
; 8554 : 					GetArgumentValue (lpszCommandLineArgs, nArgPos, &i, nNoCommandLineArgs,

  007ec	6a 08		 push	 8
  007ee	8d 45 f4	 lea	 eax, DWORD PTR _szTmp$6[ebp]
  007f1	50		 push	 eax
  007f2	56		 push	 esi
  007f3	8d 85 60 fd ff
	ff		 lea	 eax, DWORD PTR _i$3[ebp]
  007f9	50		 push	 eax
  007fa	ff b5 58 fd ff
	ff		 push	 DWORD PTR _nArgPos$2[ebp]
  00800	ff b5 5c fd ff
	ff		 push	 DWORD PTR _lpszCommandLineArgs$[ebp]
  00806	e8 00 00 00 00	 call	 _GetArgumentValue

; 8555 : 						     szTmp, sizeof (szTmp));
; 8556 : 					if (!_stricmp(szTmp,"y") || !_stricmp(szTmp,"yes"))

  0080b	8d 45 f4	 lea	 eax, DWORD PTR _szTmp$6[ebp]
  0080e	68 00 00 00 00	 push	 OFFSET ??_C@_01EANLCPLP@y?$AA@
  00813	50		 push	 eax
  00814	e8 00 00 00 00	 call	 __stricmp
  00819	83 c4 20	 add	 esp, 32			; 00000020H
  0081c	85 c0		 test	 eax, eax
  0081e	74 15		 je	 SHORT $LN36@ExtractCom
  00820	8d 45 f4	 lea	 eax, DWORD PTR _szTmp$6[ebp]
  00823	68 00 00 00 00	 push	 OFFSET ??_C@_03ICICOMAL@yes?$AA@
  00828	50		 push	 eax
  00829	e8 00 00 00 00	 call	 __stricmp
  0082e	83 c4 08	 add	 esp, 8
  00831	85 c0		 test	 eax, eax
  00833	75 14		 jne	 SHORT $LN35@ExtractCom
$LN36@ExtractCom:

; 8557 : 					{
; 8558 : 						bHistory = TRUE;

  00835	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bHistory, 1

; 8559 : 						bHistoryCmdLine = TRUE;

  0083f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bHistoryCmdLine@@3HA, 1 ; bHistoryCmdLine
$LN35@ExtractCom:

; 8560 : 					}
; 8561 : 
; 8562 : 					if (!_stricmp(szTmp,"n") || !_stricmp(szTmp,"no"))

  00849	8d 45 f4	 lea	 eax, DWORD PTR _szTmp$6[ebp]
  0084c	68 00 00 00 00	 push	 OFFSET ??_C@_01EFFIKLCJ@n?$AA@
  00851	50		 push	 eax
  00852	e8 00 00 00 00	 call	 __stricmp
  00857	83 c4 08	 add	 esp, 8
  0085a	85 c0		 test	 eax, eax
  0085c	74 15		 je	 SHORT $LN38@ExtractCom
  0085e	8d 45 f4	 lea	 eax, DWORD PTR _szTmp$6[ebp]
  00861	68 00 00 00 00	 push	 OFFSET ??_C@_02KAJCLHKP@no?$AA@
  00866	50		 push	 eax
  00867	e8 00 00 00 00	 call	 __stricmp
  0086c	83 c4 08	 add	 esp, 8
  0086f	85 c0		 test	 eax, eax
  00871	75 79		 jne	 SHORT $LN2@ExtractCom
$LN38@ExtractCom:

; 8563 : 					{
; 8564 : 						bHistory = FALSE;

  00873	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHistory, 0

; 8565 : 						bHistoryCmdLine = TRUE;

  0087d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bHistoryCmdLine@@3HA, 1 ; bHistoryCmdLine

; 8566 : 					}
; 8567 : 				}
; 8568 : 				break;

  00887	eb 63		 jmp	 SHORT $LN2@ExtractCom
$LN39@ExtractCom:

; 8569 : 				
; 8570 : 			case OptionTokenLib:
; 8571 : 				if (GetArgumentValue (lpszCommandLineArgs, nArgPos, &i, nNoCommandLineArgs, SecurityTokenLibraryPath, sizeof (SecurityTokenLibraryPath)) == HAS_ARGUMENT)

  00889	68 04 01 00 00	 push	 260			; 00000104H
  0088e	68 00 00 00 00	 push	 OFFSET _SecurityTokenLibraryPath
  00893	56		 push	 esi
  00894	8d 85 60 fd ff
	ff		 lea	 eax, DWORD PTR _i$3[ebp]
  0089a	50		 push	 eax
  0089b	ff b5 58 fd ff
	ff		 push	 DWORD PTR _nArgPos$2[ebp]
  008a1	ff b5 5c fd ff
	ff		 push	 DWORD PTR _lpszCommandLineArgs$[ebp]
  008a7	e8 00 00 00 00	 call	 _GetArgumentValue
  008ac	83 c4 18	 add	 esp, 24			; 00000018H
  008af	83 f8 01	 cmp	 eax, 1
  008b2	75 07		 jne	 SHORT $LN40@ExtractCom

; 8572 : 					InitSecurityTokenLibrary();

  008b4	e8 00 00 00 00	 call	 _InitSecurityTokenLibrary

; 8573 : 				else

  008b9	eb 31		 jmp	 SHORT $LN2@ExtractCom
$LN40@ExtractCom:

; 8574 : 					Error ("COMMAND_LINE_ERROR");

  008bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LGCKNJIO@COMMAND_LINE_ERROR?$AA@
  008c0	e8 00 00 00 00	 call	 _Error
  008c5	83 c4 04	 add	 esp, 4

; 8575 : 
; 8576 : 				break;

  008c8	eb 22		 jmp	 SHORT $LN2@ExtractCom
$LN42@ExtractCom:

; 8577 : 
; 8578 : 			case OptionQuit:
; 8579 : 				{
; 8580 : 					// Used to indicate non-install elevation
; 8581 : 					char szTmp[32];
; 8582 : 					GetArgumentValue (lpszCommandLineArgs, nArgPos, &i, nNoCommandLineArgs, szTmp, sizeof (szTmp));

  008ca	6a 20		 push	 32			; 00000020H
  008cc	8d 45 d4	 lea	 eax, DWORD PTR _szTmp$5[ebp]
  008cf	50		 push	 eax
  008d0	56		 push	 esi
  008d1	8d 85 60 fd ff
	ff		 lea	 eax, DWORD PTR _i$3[ebp]
  008d7	50		 push	 eax
  008d8	ff b5 58 fd ff
	ff		 push	 DWORD PTR _nArgPos$2[ebp]
  008de	ff b5 5c fd ff
	ff		 push	 DWORD PTR _lpszCommandLineArgs$[ebp]
  008e4	e8 00 00 00 00	 call	 _GetArgumentValue
  008e9	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@ExtractCom:

; 8371 : 	{
; 8372 : 		int i;
; 8373 : 
; 8374 : 		for (i = 0; i < nNoCommandLineArgs; i++)

  008ec	8b 85 60 fd ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  008f2	40		 inc	 eax
  008f3	89 85 60 fd ff
	ff		 mov	 DWORD PTR _i$3[ebp], eax
  008f9	3b c6		 cmp	 eax, esi
  008fb	0f 8c 6f f7 ff
	ff		 jl	 $LL4@ExtractCom
$LN146@ExtractCom:

; 8591 : 			}
; 8592 : 		}
; 8593 : 	}
; 8594 : 
; 8595 : 	/* Free up the command line arguments */
; 8596 : 	while (--nNoCommandLineArgs >= 0)

  00901	83 ee 01	 sub	 esi, 1
  00904	78 20		 js	 SHORT $LN149@ExtractCom
  00906	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@ExtractCom:

; 8597 : 	{
; 8598 : 		free (lpszCommandLineArgs[nNoCommandLineArgs]);

  00910	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _lpszCommandLineArgs$[ebp]
  00916	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  00919	e8 00 00 00 00	 call	 _free
  0091e	83 c4 04	 add	 esp, 4
  00921	83 ee 01	 sub	 esi, 1
  00924	79 ea		 jns	 SHORT $LL7@ExtractCom
$LN149@ExtractCom:

; 8599 : 	}
; 8600 : }

  00926	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00929	5f		 pop	 edi
  0092a	33 cd		 xor	 ecx, ebp
  0092c	5e		 pop	 esi
  0092d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00932	8b e5		 mov	 esp, ebp
  00934	5d		 pop	 ebp
  00935	c3		 ret	 0
$LN153@ExtractCom:

; 8435 : 				}
; 8436 : 				else
; 8437 : 				{
; 8438 : 					Warning ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");

  00936	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  0093b	e8 00 00 00 00	 call	 _Warning
  00940	83 c4 04	 add	 esp, 4

; 8439 : 					exit(0);

  00943	6a 00		 push	 0
  00945	e8 00 00 00 00	 call	 _exit
$LN155@ExtractCom:
$LN43@ExtractCom:

; 8583 : 				}
; 8584 : 				break;
; 8585 : 
; 8586 : 			default:
; 8587 : 				DialogBoxParamW (hInst, MAKEINTRESOURCEW (IDD_COMMANDHELP_DLG), hwndDlg, (DLGPROC)

  0094a	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR _as$1[ebp]
  00950	50		 push	 eax
  00951	68 00 00 00 00	 push	 OFFSET _CommandHelpDlgProc@16
  00956	57		 push	 edi
  00957	68 fd 01 00 00	 push	 509			; 000001fdH
  0095c	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00962	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20

; 8588 : 						CommandHelpDlgProc, (LPARAM) &as);
; 8589 : 
; 8590 : 				exit(0);

  00968	6a 00		 push	 0
  0096a	e8 00 00 00 00	 call	 _exit
$LN156@ExtractCom:
$LN150@ExtractCom:
  0096f	90		 npad	 1
$LN154@ExtractCom:

; 8599 : 	}
; 8600 : }

  00970	00 00 00 00	 DD	 $LN34@ExtractCom
  00974	00 00 00 00	 DD	 $LN33@ExtractCom
  00978	00 00 00 00	 DD	 $LN42@ExtractCom
  0097c	00 00 00 00	 DD	 $LN39@ExtractCom
  00980	00 00 00 00	 DD	 $LN27@ExtractCom
  00984	00 00 00 00	 DD	 $LN24@ExtractCom
  00988	00 00 00 00	 DD	 $LN15@ExtractCom
  0098c	00 00 00 00	 DD	 $LN30@ExtractCom
  00990	00 00 00 00	 DD	 $LN18@ExtractCom
  00994	00 00 00 00	 DD	 $LN32@ExtractCom
  00998	00 00 00 00	 DD	 $LN21@ExtractCom
  0099c	00 00 00 00	 DD	 $LN12@ExtractCom
  009a0	00 00 00 00	 DD	 $LN31@ExtractCom
_ExtractCommandLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _MainDialogProc@16
_TEXT	SEGMENT
_volume$2 = -54136					; size = 56
$T3 = -54080						; size = 12
$T4 = -54068						; size = 12
_e$5 = -54056						; size = 4
_e$6 = -54052						; size = 4
_e$7 = -54048						; size = 4
_e$8 = -54044						; size = 4
_e$9 = -54040						; size = 4
_e$10 = -54036						; size = 4
_e$11 = -54032						; size = 4
_e$12 = -54028						; size = 4
_e$13 = -54024						; size = 4
_e$14 = -54020						; size = 4
_e$15 = -54016						; size = 4
_e$16 = -54012						; size = 4
_e$17 = -54008						; size = 4
_e$18 = -54004						; size = 4
_e$19 = -54000						; size = 4
_e$20 = -53996						; size = 4
_tmpbDevice$21 = -53992					; size = 4
_e$22 = -53988						; size = 4
_e$23 = -53984						; size = 4
_e$24 = -53980						; size = 4
_e$25 = -53976						; size = 4
_e$26 = -53972						; size = 4
_$S2$27 = -53968					; size = 28
_tmpbDevice$28 = -53940					; size = 4
_e$29 = -53936						; size = 4
_lParam$GSCopy$1$ = -53932				; size = 4
_tmpbDevice$30 = -53932					; size = 4
$T31 = -53928						; size = 4
tv4970 = -53924						; size = 8
_hwndDlg$GSCopy$1$ = -53920				; size = 4
tv4999 = -53920						; size = 4
tv4980 = -53920						; size = 4
tv4953 = -53920						; size = 4
$T32 = -53913						; size = 1
_hwndDlg$GSCopy$ = -53912				; size = 4
_nNewPageNo$1$ = -53908					; size = 4
$T33 = -53904						; size = 320
$T34 = -53584						; size = 320
$T35 = -53264						; size = 94
$T36 = -53168						; size = 94
$T37 = -53072						; size = 94
$T38 = -52976						; size = 94
$T39 = -52880						; size = 94
$T40 = -52784						; size = 16
$T41 = -52768						; size = 24
$T42 = -52744						; size = 24
$T43 = -52720						; size = 24
$T44 = -52696						; size = 24
$T45 = -52672						; size = 24
$T46 = -52648						; size = 24
$T47 = -52624						; size = 24
$T48 = -52600						; size = 24
$T49 = -52576						; size = 24
$T50 = -52552						; size = 24
$T51 = -52528						; size = 24
$T52 = -52504						; size = 24
$T53 = -52480						; size = 24
$T54 = -52456						; size = 24
$T55 = -52432						; size = 24
$T56 = -52408						; size = 24
$T57 = -52384						; size = 24
$T58 = -52360						; size = 24
$T59 = -52336						; size = 24
$T60 = -52312						; size = 24
$T61 = -52288						; size = 24
$T62 = -52264						; size = 24
$T63 = -52240						; size = 24
$T64 = -52216						; size = 24
$T65 = -52192						; size = 24
$T66 = -52168						; size = 24
$T67 = -52144						; size = 24
$T68 = -52120						; size = 24
$T69 = -52096						; size = 24
$T70 = -52072						; size = 24
$T71 = -52048						; size = 24
$T72 = -52024						; size = 24
$T73 = -52000						; size = 24
_rD$74 = -51976						; size = 16
_rD$75 = -51960						; size = 16
_rD$76 = -51944						; size = 16
_rW$77 = -51928						; size = 16
_rW$78 = -51912						; size = 16
_rW$79 = -51896						; size = 16
_rW$80 = -51880						; size = 16
_rD$81 = -51864						; size = 16
_decoySysPartitionWipeStatus$82 = -51864		; size = 16
_multiChoiceStr$83 = -51848				; size = 24
_szTmp$84 = -51824					; size = 8192
_szTmp$85 = -43632					; size = 8192
_szTmp$86 = -35440					; size = 16000
_msg$87 = -19440					; size = 16384
_szFileSystemNameBuffer$88 = -3056			; size = 256
_root$89 = -2800					; size = 260
_tmp$90 = -2540						; size = 641
_tmp$91 = -1896						; size = 641
_tmp$92 = -1252						; size = 371
_tmp$93 = -876						; size = 371
_tmp$94 = -500						; size = 65
_tmp$95 = -432						; size = 65
_tmp$96 = -364						; size = 65
_tmp$97 = -296						; size = 65
_tmp$98 = -228						; size = 65
_tmp$99 = -160						; size = 65
_tmp2$100 = -92						; size = 43
_tmp$101 = -48						; size = 17
tv4877 = -28						; size = 8
_tmp3$102 = -28						; size = 8
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_hwndDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_MainDialogProc@16 PROC					; COMDAT

; 5945 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_MainDialogProc@16
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	b8 68 d3 00 00	 mov	 eax, 54120		; 0000d368H
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00036	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00039	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]

; 5946 : 	WORD lw = LOWORD (wParam);
; 5947 : 
; 5948 : 	int nNewPageNo = nCurPageNo;
; 5949 : 
; 5950 : 	switch (uMsg)

  0003c	8b 55 0c	 mov	 edx, DWORD PTR _uMsg$[ebp]
  0003f	89 85 54 2d ff
	ff		 mov	 DWORD PTR _lParam$GSCopy$1$[ebp], eax
  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  0004a	8b c8		 mov	 ecx, eax
  0004c	89 9d 60 2d ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], ebx
  00052	89 9d 68 2d ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$[ebp], ebx
  00058	c7 85 58 2d ff
	ff 00 00 00 00	 mov	 DWORD PTR $T31[ebp], 0
  00062	89 8d 6c 2d ff
	ff		 mov	 DWORD PTR _nNewPageNo$1$[ebp], ecx
  00068	81 fa 10 01 00
	00		 cmp	 edx, 272		; 00000110H
  0006e	0f 87 04 02 00
	00		 ja	 $LN552@MainDialog
  00074	74 57		 je	 SHORT $LN51@MainDialog
  00076	83 fa 10	 cmp	 edx, 16			; 00000010H
  00079	0f 84 7f 27 00
	00		 je	 $LN384@MainDialog
  0007f	83 fa 16	 cmp	 edx, 22			; 00000016H
  00082	74 16		 je	 SHORT $LN511@MainDialog
  00084	83 fa 53	 cmp	 edx, 83			; 00000053H
  00087	75 24		 jne	 SHORT $LN2@MainDialog
$LN1509@MainDialog:

; 6500 : 		return 1;
; 6501 : 
; 6502 : 	case WM_HELP:
; 6503 : 
; 6504 : 		OpenPageHelp (hwndDlg, nCurPageNo);

  00089	50		 push	 eax
  0008a	53		 push	 ebx
  0008b	e8 00 00 00 00	 call	 _OpenPageHelp
  00090	83 c4 08	 add	 esp, 8
$ovf_end$1517:

; 6074 : 			}
; 6075 : 			return 1;

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	eb 15		 jmp	 SHORT $LN1@MainDialog
$LN511@MainDialog:

; 8329 : 
; 8330 : 			return 1;
; 8331 : 		}
; 8332 : 
; 8333 : 		return 0;
; 8334 : 
; 8335 : 	case WM_ENDSESSION:
; 8336 : 		EndMainDlg (MainDlg);

  0009a	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000a0	e8 00 00 00 00	 call	 _EndMainDlg
  000a5	83 c4 04	 add	 esp, 4

; 8337 : 		localcleanup ();

  000a8	e8 00 00 00 00	 call	 _localcleanup
$LN2@MainDialog:

; 8338 : 		return 0;
; 8339 : 
; 8340 : 	case WM_CLOSE:
; 8341 : 		PostMessage (hwndDlg, GST_APPMSG_FORMAT_USER_QUIT, 0, 0);
; 8342 : 		return 1;
; 8343 : 	}
; 8344 : 
; 8345 : 	return 0;

  000ad	33 c0		 xor	 eax, eax
$LN1@MainDialog:

; 8346 : }

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c0	33 cd		 xor	 ecx, ebp
  000c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 10 00	 ret	 16			; 00000010H
$LN51@MainDialog:

; 5951 : 	{
; 5952 : 	case WM_INITDIALOG:
; 5953 : 		{
; 5954 : 			MainDlg = hwndDlg;
; 5955 : 			InitDialog (hwndDlg);

  000cd	53		 push	 ebx
  000ce	89 1d 00 00 00
	00		 mov	 DWORD PTR _MainDlg, ebx
  000d4	e8 00 00 00 00	 call	 _InitDialog

; 5956 : 			LocalizeDialog (hwndDlg, "IDD_VOL_CREATION_WIZARD_DLG");

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IHMEHMBJ@IDD_VOL_CREATION_WIZARD_DLG?$AA@
  000de	53		 push	 ebx
  000df	e8 00 00 00 00	 call	 _LocalizeDialog
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5957 : 
; 5958 : 			if (IsGostCryptInstallerRunning())

  000e7	e8 00 00 00 00	 call	 _IsGostCryptInstallerRunning
  000ec	85 c0		 test	 eax, eax
  000ee	74 0d		 je	 SHORT $LN52@MainDialog

; 5959 : 				AbortProcess ("GST_INSTALLER_IS_RUNNING");

  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@
  000f5	e8 00 00 00 00	 call	 _AbortProcess
  000fa	83 c4 04	 add	 esp, 4
$LN52@MainDialog:

; 5960 : 
; 5961 : 			// Resize the bitmap if the user has a non-default DPI 
; 5962 : 			if (ScreenDPI != USER_DEFAULT_SCREEN_DPI)

  000fd	83 3d 00 00 00
	00 60		 cmp	 DWORD PTR _ScreenDPI, 96 ; 00000060H
  00104	74 28		 je	 SHORT $LN1419@MainDialog

; 5963 : 			{
; 5964 : 				hbmWizardBitmapRescaled = RenderBitmap (MAKEINTRESOURCE (IDB_WIZARD),

  00106	6a 00		 push	 0
  00108	6a 00		 push	 0
  0010a	6a 00		 push	 0
  0010c	6a 00		 push	 0
  0010e	6a 00		 push	 0
  00110	6a 00		 push	 0
  00112	68 24 04 00 00	 push	 1060			; 00000424H
  00117	53		 push	 ebx
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0011e	50		 push	 eax
  0011f	6a 74		 push	 116			; 00000074H
  00121	e8 00 00 00 00	 call	 _RenderBitmap
  00126	83 c4 20	 add	 esp, 32			; 00000020H
  00129	a3 00 00 00 00	 mov	 DWORD PTR ?hbmWizardBitmapRescaled@@3PAUHBITMAP__@@A, eax ; hbmWizardBitmapRescaled
$LN1419@MainDialog:

; 5965 : 					GetDlgItem (hwndDlg, IDC_BITMAP_WIZARD),
; 5966 : 					0, 0, 0, 0, FALSE, FALSE);
; 5967 : 			}
; 5968 : 
; 5969 : 			LoadSettings (hwndDlg);

  0012e	53		 push	 ebx
  0012f	e8 00 00 00 00	 call	 _LoadSettings
  00134	83 c4 04	 add	 esp, 4

; 5970 : 
; 5971 : 			LoadDefaultKeyFilesParam ();

  00137	e8 00 00 00 00	 call	 _LoadDefaultKeyFilesParam

; 5972 : 			RestoreDefaultKeyFilesParam ();

  0013c	e8 00 00 00 00	 call	 _RestoreDefaultKeyFilesParam
  00141	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff

; 5973 : 
; 5974 : 			SysEncMultiBootCfg.NumberOfSysDrives = -1;
; 5975 : 			SysEncMultiBootCfg.MultipleSystemsOnDrive = -1;
; 5976 : 			SysEncMultiBootCfg.BootLoaderLocation = -1;
; 5977 : 			SysEncMultiBootCfg.BootLoaderBrand = -1;
; 5978 : 			SysEncMultiBootCfg.SystemOnBootDrive = -1;
; 5979 : 
; 5980 : 			try
; 5981 : 			{
; 5982 : 				BootEncStatus = BootEncObj->GetStatus();

  00148	8d 85 50 30 ff
	ff		 lea	 eax, DWORD PTR $T36[ebp]
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00154	50		 push	 eax
  00155	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A, xmm0
  0015c	c7 05 10 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A+16, -1
  00166	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0016d	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00172	8b f0		 mov	 esi, eax
  00174	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00179	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  0017e	f3 a5		 rep movsd

; 5990 : 			}
; 5991 : 
; 5992 : 			SendMessage (GetDlgItem (hwndDlg, IDC_BOX_TITLE), WM_SETFONT, (WPARAM) hTitleFont, (LPARAM) TRUE);

  00180	6a 01		 push	 1
  00182	ff 35 00 00 00
	00		 push	 DWORD PTR _hTitleFont
  00188	6a 30		 push	 48			; 00000030H
  0018a	68 e8 03 00 00	 push	 1000			; 000003e8H
  0018f	53		 push	 ebx
  00190	66 a5		 movsw
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00198	50		 push	 eax
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 5993 : 			SetWindowTextW (hwndDlg, lpszTitle);

  0019f	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  001a5	53		 push	 ebx
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 5994 : 
; 5995 : 			ExtractCommandLine (hwndDlg, (char *) lParam);

  001ac	ff b5 54 2d ff
	ff		 push	 DWORD PTR _lParam$GSCopy$1$[ebp]
  001b2	53		 push	 ebx
  001b3	e8 00 00 00 00	 call	 _ExtractCommandLine
  001b8	83 c4 08	 add	 esp, 8

; 5996 : 
; 5997 : 			if (ComServerMode)

  001bb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ComServerMode@@3HA, 0 ; ComServerMode
  001c2	74 26		 je	 SHORT $LN55@MainDialog

; 5998 : 			{
; 5999 : 				InitDialog (hwndDlg);

  001c4	53		 push	 ebx
  001c5	e8 00 00 00 00	 call	 _InitDialog
  001ca	83 c4 04	 add	 esp, 4

; 6000 : 
; 6001 : 				if (!ComServerFormat ())

  001cd	e8 00 00 00 00	 call	 _ComServerFormat
  001d2	85 c0		 test	 eax, eax
  001d4	0f 85 44 0e 00
	00		 jne	 $LN56@MainDialog

; 6002 : 				{
; 6003 : 					handleWin32Error (hwndDlg);

  001da	53		 push	 ebx
  001db	e8 00 00 00 00	 call	 _handleWin32Error
  001e0	83 c4 04	 add	 esp, 4

; 6004 : 					exit (1);

  001e3	6a 01		 push	 1
  001e5	e8 00 00 00 00	 call	 _exit
$LN1514@MainDialog:
$LN55@MainDialog:

; 6005 : 				}
; 6006 : 				exit (0);
; 6007 : 			}
; 6008 : 
; 6009 : 			SHGetFolderPath (NULL, CSIDL_MYDOCUMENTS, NULL, 0, szRescueDiskISO);

  001ea	68 00 00 00 00	 push	 OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  001ef	6a 00		 push	 0
  001f1	6a 00		 push	 0
  001f3	6a 05		 push	 5
  001f5	6a 00		 push	 0
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetFolderPathA@20

; 6010 : 			strcat (szRescueDiskISO, "\\GostCrypt Rescue Disk.iso");

  001fd	bf 00 00 00 00	 mov	 edi, OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  00202	4f		 dec	 edi
$LL1372@MainDialog:
  00203	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00206	47		 inc	 edi
  00207	84 c0		 test	 al, al
  00209	75 f8		 jne	 SHORT $LL1372@MainDialog
  0020b	b9 06 00 00 00	 mov	 ecx, 6
  00210	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BL@JMGGGIDG@?2GostCrypt?5Rescue?5Disk?4iso?$AA@
  00215	f3 a5		 rep movsd

; 6011 : 
; 6012 : 			if (IsOSAtLeast (WIN_VISTA))

  00217	6a 0b		 push	 11			; 0000000bH
  00219	66 a5		 movsw
  0021b	a4		 movsb
  0021c	e8 00 00 00 00	 call	 _IsOSAtLeast
  00221	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bWarnDeviceFormatAdvanced
  00227	83 c4 04	 add	 esp, 4
  0022a	33 d2		 xor	 edx, edx
  0022c	85 c0		 test	 eax, eax
  0022e	0f 45 ca	 cmovne	 ecx, edx

; 6013 : 			{
; 6014 : 				// Availability of in-place encryption (which is pre-selected by default whenever
; 6015 : 				// possible) makes partition-hosted volume creation safer.
; 6016 : 				bWarnDeviceFormatAdvanced = FALSE;	
; 6017 : 			}
; 6018 : 
; 6019 : #ifdef _DEBUG
; 6020 : 			// For faster testing
; 6021 : 			strcpy (szVerify, "q");
; 6022 : 			strcpy (szRawPassword, "q");
; 6023 : #endif
; 6024 : 
; 6025 : 			PostMessage (hwndDlg, GST_APPMSG_PERFORM_POST_WMINIT_TASKS, 0, 0);

  00231	52		 push	 edx
  00232	52		 push	 edx
  00233	68 30 81 00 00	 push	 33072			; 00008130H
  00238	53		 push	 ebx
  00239	89 0d 00 00 00
	00		 mov	 DWORD PTR _bWarnDeviceFormatAdvanced, ecx
  0023f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 6026 : 		}
; 6027 : 		return 0;

  00245	e9 63 fe ff ff	 jmp	 $LN2@MainDialog
__catch$_MainDialogProc@16$0:

; 5983 : 			}
; 5984 : 			catch (Exception &e)
; 5985 : 			{
; 5986 : 				e.Show (hwndDlg);

  0024a	8b 8d 2c 2d ff
	ff		 mov	 ecx, DWORD PTR _e$26[ebp]
  00250	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00256	8b 01		 mov	 eax, DWORD PTR [ecx]
  00258	ff 10		 call	 DWORD PTR [eax]

; 5987 : 				Error ("ERR_GETTING_SYSTEM_ENCRYPTION_STATUS");

  0025a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@
  0025f	e8 00 00 00 00	 call	 _Error

; 5988 : 				EndMainDlg (MainDlg);

  00264	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0026a	e8 00 00 00 00	 call	 _EndMainDlg
  0026f	83 c4 08	 add	 esp, 8

; 5989 : 				return 0;

  00272	b8 00 00 00 00	 mov	 eax, $LN2@MainDialog
  00277	c3		 ret	 0
$LN552@MainDialog:

; 5946 : 	WORD lw = LOWORD (wParam);
; 5947 : 
; 5948 : 	int nNewPageNo = nCurPageNo;
; 5949 : 
; 5950 : 	switch (uMsg)

  00278	81 fa 2d 81 00
	00		 cmp	 edx, 33069		; 0000812dH
  0027e	0f 87 fe 3d 00
	00		 ja	 $LN553@MainDialog
  00284	0f 84 e6 3c 00
	00		 je	 $LN115@MainDialog
  0028a	81 ea 11 01 00
	00		 sub	 edx, 273		; 00000111H
  00290	0f 84 87 0c 00
	00		 je	 $LN146@MainDialog
  00296	83 ea 01	 sub	 edx, 1
  00299	0f 84 4c 0c 00
	00		 je	 $LN58@MainDialog
  0029f	83 ea 01	 sub	 edx, 1
  002a2	0f 85 05 fe ff
	ff		 jne	 $LN2@MainDialog

; 6033 : 			return 1;
; 6034 : 		}
; 6035 : 		return 0;
; 6036 : 
; 6037 : 	case WM_TIMER:
; 6038 : 
; 6039 : 		switch (wParam)

  002a8	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  002ab	05 01 ff ff ff	 add	 eax, -255		; ffffff01H
  002b0	83 f8 05	 cmp	 eax, 5
  002b3	0f 87 f4 fd ff
	ff		 ja	 $LN2@MainDialog
  002b9	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN1510@MainDialog[eax*4]
$LN61@MainDialog:

; 6040 : 		{
; 6041 : 		case TIMER_ID_RANDVIEW:
; 6042 : 
; 6043 : 			if (WizardMode == WIZARD_MODE_SYS_DEVICE
; 6044 : 				|| bInPlaceEncNonSys)

  002c0	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  002c7	0f 84 66 01 00
	00		 je	 $LN64@MainDialog
  002cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  002d4	0f 85 59 01 00
	00		 jne	 $LN64@MainDialog

; 6047 : 			}
; 6048 : 			else
; 6049 : 			{
; 6050 : 				unsigned char tmp[17];
; 6051 : 				char tmp2[43];
; 6052 : 				int i;
; 6053 : 
; 6054 : 				if (!showKeys) 

  002da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _showKeys, 0
  002e1	0f 84 60 01 00
	00		 je	 $LN15@MainDialog

; 6055 : 					return 1;
; 6056 : 
; 6057 : 				RandpeekBytes (tmp, sizeof (tmp));

  002e7	8d 45 d0	 lea	 eax, DWORD PTR _tmp$101[ebp]
  002ea	6a 11		 push	 17			; 00000011H
  002ec	50		 push	 eax
  002ed	e8 00 00 00 00	 call	 _RandpeekBytes
  002f2	83 c4 08	 add	 esp, 8

; 6058 : 
; 6059 : 				tmp2[0] = 0;

  002f5	c6 45 a4 00	 mov	 BYTE PTR _tmp2$100[ebp], 0

; 6060 : 
; 6061 : 				for (i = 0; i < sizeof (tmp); i++)

  002f9	33 db		 xor	 ebx, ebx
  002fb	0f 1f 44 00 00	 npad	 5
$LL8@MainDialog:

; 6062 : 				{
; 6063 : 					char tmp3[8];
; 6064 : 					sprintf (tmp3, "%02X", (int) (unsigned char) tmp[i]);

  00300	0f b6 44 1d d0	 movzx	 eax, BYTE PTR _tmp$101[ebp+ebx]
  00305	50		 push	 eax
  00306	8d 45 e4	 lea	 eax, DWORD PTR _tmp3$102[ebp]
  00309	68 00 00 00 00	 push	 OFFSET ??_C@_04JFFKLGJF@?$CF02X?$AA@
  0030e	50		 push	 eax
  0030f	e8 00 00 00 00	 call	 _sprintf

; 6065 : 					strcat (tmp2, tmp3);

  00314	8d 55 e4	 lea	 edx, DWORD PTR _tmp3$102[ebp]
  00317	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031a	8b f2		 mov	 esi, edx
  0031c	0f 1f 40 00	 npad	 4
$LL1373@MainDialog:
  00320	8a 02		 mov	 al, BYTE PTR [edx]
  00322	42		 inc	 edx
  00323	84 c0		 test	 al, al
  00325	75 f9		 jne	 SHORT $LL1373@MainDialog
  00327	8d 7d a4	 lea	 edi, DWORD PTR _tmp2$100[ebp]
  0032a	2b d6		 sub	 edx, esi
  0032c	4f		 dec	 edi
  0032d	0f 1f 00	 npad	 3
$LL1374@MainDialog:
  00330	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00333	47		 inc	 edi
  00334	84 c0		 test	 al, al
  00336	75 f8		 jne	 SHORT $LL1374@MainDialog
  00338	8b ca		 mov	 ecx, edx
  0033a	43		 inc	 ebx
  0033b	c1 e9 02	 shr	 ecx, 2
  0033e	f3 a5		 rep movsd
  00340	8b ca		 mov	 ecx, edx
  00342	83 e1 03	 and	 ecx, 3
  00345	f3 a4		 rep movsb
  00347	83 fb 11	 cmp	 ebx, 17			; 00000011H
  0034a	72 b4		 jb	 SHORT $LL8@MainDialog

; 6066 : 				}
; 6067 : 
; 6068 : 				tmp2[32] = 0;

  0034c	88 45 c4	 mov	 BYTE PTR _tmp2$100[ebp+32], al

; 6069 : 
; 6070 : 				SetWindowTextW (GetDlgItem (hCurPage, IDC_RANDOM_BYTES), (SingleStringToWide (tmp2) + GetString ("TRIPLE_DOT_GLYPH_ELLIPSIS")).c_str());

  0034f	8d 8d e0 34 ff
	ff		 lea	 ecx, DWORD PTR $T73[ebp]
  00355	8d 45 a4	 lea	 eax, DWORD PTR _tmp2$100[ebp]
  00358	50		 push	 eax
  00359	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0035e	8d 85 e0 34 ff
	ff		 lea	 eax, DWORD PTR $T73[ebp]
  00364	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0036b	50		 push	 eax
  0036c	8d 85 e8 32 ff
	ff		 lea	 eax, DWORD PTR $T52[ebp]
  00372	50		 push	 eax
  00373	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  00378	8b f0		 mov	 esi, eax
  0037a	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JMBFHJFE@TRIPLE_DOT_GLYPH_ELLIPSIS?$AA@
  0037f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  00383	e8 00 00 00 00	 call	 _GetString
  00388	50		 push	 eax
  00389	8d 85 00 33 ff
	ff		 lea	 eax, DWORD PTR $T53[ebp]
  0038f	56		 push	 esi
  00390	50		 push	 eax
  00391	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00396	83 c4 18	 add	 esp, 24			; 00000018H
  00399	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0039d	72 02		 jb	 SHORT $LN701@MainDialog
  0039f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN701@MainDialog:
  003a1	50		 push	 eax
  003a2	68 fc 03 00 00	 push	 1020			; 000003fcH
  003a7	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  003ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  003b3	50		 push	 eax
  003b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
  003ba	8d 8d 00 33 ff
	ff		 lea	 ecx, DWORD PTR $T53[ebp]
  003c0	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  003c5	8d 8d e8 32 ff
	ff		 lea	 ecx, DWORD PTR $T52[ebp]
  003cb	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  003d0	8d 8d e0 34 ff
	ff		 lea	 ecx, DWORD PTR $T73[ebp]
  003d6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 6071 : 
; 6072 : 				burn (tmp, sizeof(tmp));

  003db	8d 45 d0	 lea	 eax, DWORD PTR _tmp$101[ebp]
  003de	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  003e3	8b f1		 mov	 esi, ecx
  003e5	8b d0		 mov	 edx, eax
$LL706@MainDialog:
  003e7	c6 02 00	 mov	 BYTE PTR [edx], 0
  003ea	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  003ed	83 ee 01	 sub	 esi, 1
  003f0	75 f5		 jne	 SHORT $LL706@MainDialog
$LL12@MainDialog:
  003f2	c6 00 00	 mov	 BYTE PTR [eax], 0
  003f5	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  003f8	83 e9 01	 sub	 ecx, 1
  003fb	75 f5		 jne	 SHORT $LL12@MainDialog

; 6073 : 				burn (tmp2, sizeof(tmp2));

  003fd	8d 45 a4	 lea	 eax, DWORD PTR _tmp2$100[ebp]
  00400	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00405	8b f1		 mov	 esi, ecx
  00407	8b d0		 mov	 edx, eax
  00409	0f 1f 80 00 00
	00 00		 npad	 7
$LL710@MainDialog:
  00410	c6 02 00	 mov	 BYTE PTR [edx], 0
  00413	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00416	83 ee 01	 sub	 esi, 1
  00419	75 f5		 jne	 SHORT $LL710@MainDialog
  0041b	0f 1f 44 00 00	 npad	 5
$LL17@MainDialog:
  00420	c6 00 00	 mov	 BYTE PTR [eax], 0
  00423	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00426	83 e9 01	 sub	 ecx, 1
  00429	75 f5		 jne	 SHORT $LL17@MainDialog
$ovf_end_1$1518:

; 6074 : 			}
; 6075 : 			return 1;

  0042b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0042e	e9 7c fc ff ff	 jmp	 $LN1@MainDialog
$LN64@MainDialog:

; 6045 : 			{
; 6046 : 				DisplayRandPool (hRandPoolSys, showKeys);

  00433	ff 35 00 00 00
	00		 push	 DWORD PTR _showKeys
  00439	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hRandPoolSys@@3RAUHWND__@@A ; hRandPoolSys
  0043e	50		 push	 eax
  0043f	e8 00 00 00 00	 call	 _DisplayRandPool
  00444	83 c4 08	 add	 esp, 8
$LN15@MainDialog:
$ovf_end_2$1519:

; 6074 : 			}
; 6075 : 			return 1;

  00447	b8 01 00 00 00	 mov	 eax, 1
  0044c	e9 5e fc ff ff	 jmp	 $LN1@MainDialog
$LN66@MainDialog:

; 6076 : 
; 6077 : 		case TIMER_ID_SYSENC_PROGRESS:
; 6078 : 			{
; 6079 : 				// Manage system encryption/decryption and update related GUI
; 6080 : 
; 6081 : 				try
; 6082 : 				{
; 6083 : 					BootEncStatus = BootEncObj->GetStatus();

  00451	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00457	8d 85 70 31 ff
	ff		 lea	 eax, DWORD PTR $T39[ebp]
  0045d	50		 push	 eax
  0045e	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  00465	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  0046a	8b f0		 mov	 esi, eax
  0046c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00473	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00478	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  0047d	f3 a5		 rep movsd
  0047f	66 a5		 movsw
  00481	a1 3e 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+62
  00486	85 c0		 test	 eax, eax
  00488	74 0a		 je	 SHORT $LN69@MainDialog

; 6099 : 					Error ("ERR_GETTING_SYSTEM_ENCRYPTION_STATUS");
; 6100 : 					EndMainDlg (MainDlg);
; 6101 : 					return 1;
; 6102 : 				}
; 6103 : 
; 6104 : 				if (BootEncStatus.SetupInProgress)
; 6105 : 					UpdateSysEncProgressBar ();

  0048a	e8 00 00 00 00	 call	 ?UpdateSysEncProgressBar@@YAXXZ ; UpdateSysEncProgressBar
  0048f	a1 3e 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+62
$LN69@MainDialog:

; 6106 : 
; 6107 : 				if (bSystemEncryptionInProgress != BootEncStatus.SetupInProgress)

  00494	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, eax ; bSystemEncryptionInProgress
  0049a	74 ab		 je	 SHORT $LN15@MainDialog

; 6108 : 				{
; 6109 : 					bSystemEncryptionInProgress = BootEncStatus.SetupInProgress;

  0049c	a3 00 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, eax ; bSystemEncryptionInProgress

; 6110 : 
; 6111 : 					UpdateSysEncProgressBar ();

  004a1	e8 00 00 00 00	 call	 ?UpdateSysEncProgressBar@@YAXXZ ; UpdateSysEncProgressBar

; 6112 : 					UpdateSysEncControls ();

  004a6	e8 00 00 00 00	 call	 ?UpdateSysEncControls@@YAXXZ ; UpdateSysEncControls

; 6113 : 
; 6114 : 					if (!bSystemEncryptionInProgress)

  004ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, 0 ; bSystemEncryptionInProgress
  004b2	75 93		 jne	 SHORT $LN15@MainDialog

; 6115 : 					{
; 6116 : 						// The driver stopped encrypting/decrypting
; 6117 : 
; 6118 : 						// Allow the OS to enter Sleep mode when idle
; 6119 : 						SetThreadExecutionState (ES_CONTINUOUS);

  004b4	68 00 00 00 80	 push	 -2147483648		; 80000000H
  004b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadExecutionState@4

; 6120 : 
; 6121 : 						KillTimer (hwndDlg, TIMER_ID_SYSENC_PROGRESS);

  004bf	68 00 01 00 00	 push	 256			; 00000100H
  004c4	53		 push	 ebx
  004c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 6122 : 
; 6123 : 						try
; 6124 : 						{
; 6125 : 							if (BootEncStatus.DriveMounted)	// If we had been really encrypting/decrypting (not just proceeding to deinstall)

  004cb	83 3d 06 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+6, 0
  004d2	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 8
  004d9	0f 84 e0 00 00
	00		 je	 $LN73@MainDialog

; 6126 : 								BootEncObj->CheckEncryptionSetupResult();

  004df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  004e5	e8 00 00 00 00	 call	 ?CheckEncryptionSetupResult@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckEncryptionSetupResult
  004ea	e9 d0 00 00 00	 jmp	 $LN73@MainDialog
__catch$_MainDialogProc@16$6:

; 6127 : 						}
; 6128 : 						catch (SystemException &e)
; 6129 : 						{
; 6130 : 							if (!bTryToCorrectReadErrors
; 6131 : 								&& SystemEncryptionStatus == SYSENC_STATUS_ENCRYPTING
; 6132 : 								&& (IsDiskReadError (e.ErrorCode)))

  004ef	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bTryToCorrectReadErrors@@3HC, 0 ; bTryToCorrectReadErrors
  004f6	75 50		 jne	 SHORT $LN74@MainDialog
  004f8	81 3d 00 00 00
	00 90 01 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 400 ; 00000190H
  00502	75 44		 jne	 SHORT $LN74@MainDialog
  00504	8b 85 50 2d ff
	ff		 mov	 eax, DWORD PTR _e$29[ebp]
  0050a	ff 70 04	 push	 DWORD PTR [eax+4]
  0050d	e8 00 00 00 00	 call	 _IsDiskReadError
  00512	83 c4 04	 add	 esp, 4
  00515	85 c0		 test	 eax, eax
  00517	74 2f		 je	 SHORT $LN74@MainDialog

; 6133 : 							{
; 6134 : 								bTryToCorrectReadErrors = (AskWarnYesNo ("ENABLE_BAD_SECTOR_ZEROING") == IDYES);

  00519	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@
  0051e	e8 00 00 00 00	 call	 _AskWarnYesNo
  00523	33 c9		 xor	 ecx, ecx
  00525	83 c4 04	 add	 esp, 4
  00528	83 f8 06	 cmp	 eax, 6
  0052b	0f 94 c1	 sete	 cl
  0052e	89 0d 00 00 00
	00		 mov	 DWORD PTR ?bTryToCorrectReadErrors@@3HC, ecx ; bTryToCorrectReadErrors

; 6135 : 
; 6136 : 								if (bTryToCorrectReadErrors)

  00534	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bTryToCorrectReadErrors@@3HC, 0 ; bTryToCorrectReadErrors
  0053b	74 64		 je	 SHORT $LN1420@MainDialog

; 6137 : 								{
; 6138 : 									SysEncResume();

  0053d	e8 00 00 00 00	 call	 ?SysEncResume@@YAXXZ	; SysEncResume

; 6139 : 									return 1;

  00542	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  00547	c3		 ret	 0
$LN74@MainDialog:

; 6140 : 								}
; 6141 : 							}
; 6142 : 							else if (!DiscardUnreadableEncryptedSectors
; 6143 : 								&& SystemEncryptionStatus == SYSENC_STATUS_DECRYPTING
; 6144 : 								&& (IsDiskReadError (e.ErrorCode)))

  00548	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DiscardUnreadableEncryptedSectors@@3HC, 0 ; DiscardUnreadableEncryptedSectors
  0054f	75 50		 jne	 SHORT $LN1420@MainDialog
  00551	81 3d 00 00 00
	00 58 02 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 600 ; 00000258H
  0055b	75 44		 jne	 SHORT $LN1420@MainDialog
  0055d	8b b5 50 2d ff
	ff		 mov	 esi, DWORD PTR _e$29[ebp]
  00563	ff 76 04	 push	 DWORD PTR [esi+4]
  00566	e8 00 00 00 00	 call	 _IsDiskReadError
  0056b	83 c4 04	 add	 esp, 4
  0056e	85 c0		 test	 eax, eax
  00570	74 35		 je	 SHORT $LN78@MainDialog

; 6145 : 							{
; 6146 : 								DiscardUnreadableEncryptedSectors = (AskWarnYesNo ("DISCARD_UNREADABLE_ENCRYPTED_SECTORS") == IDYES);

  00572	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BKMHLPHL@DISCARD_UNREADABLE_ENCRYPTED_SEC@
  00577	e8 00 00 00 00	 call	 _AskWarnYesNo
  0057c	33 c9		 xor	 ecx, ecx
  0057e	83 c4 04	 add	 esp, 4
  00581	83 f8 06	 cmp	 eax, 6
  00584	0f 94 c1	 sete	 cl
  00587	89 0d 00 00 00
	00		 mov	 DWORD PTR ?DiscardUnreadableEncryptedSectors@@3HC, ecx ; DiscardUnreadableEncryptedSectors

; 6147 : 
; 6148 : 								if (DiscardUnreadableEncryptedSectors)

  0058d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DiscardUnreadableEncryptedSectors@@3HC, 0 ; DiscardUnreadableEncryptedSectors
  00594	74 0b		 je	 SHORT $LN1420@MainDialog

; 6149 : 								{
; 6150 : 									SysEncResume();

  00596	e8 00 00 00 00	 call	 ?SysEncResume@@YAXXZ	; SysEncResume

; 6151 : 									return 1;

  0059b	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  005a0	c3		 ret	 0
$LN1420@MainDialog:
  005a1	8b b5 50 2d ff
	ff		 mov	 esi, DWORD PTR _e$29[ebp]
$LN78@MainDialog:

; 6152 : 								}
; 6153 : 							}
; 6154 : 
; 6155 : 							e.Show (hwndDlg);

  005a7	8b 06		 mov	 eax, DWORD PTR [esi]
  005a9	8b ce		 mov	 ecx, esi
  005ab	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  005b1	ff 10		 call	 DWORD PTR [eax]

; 6156 : 						}

  005b3	b8 00 00 00 00	 mov	 eax, $LN653@MainDialog
  005b8	c3		 ret	 0
$LN653@MainDialog:

; 6160 : 						}

  005b9	8b 9d 68 2d ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN73@MainDialog:

; 6161 : 
; 6162 : 						switch (SystemEncryptionStatus)

  005bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionStatus
  005c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  005cb	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  005d0	0f 84 2c 01 00
	00		 je	 $LN79@MainDialog
  005d6	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  005db	0f 85 66 fe ff
	ff		 jne	 $LN15@MainDialog

; 6185 : 							}
; 6186 : 							break;
; 6187 : 
; 6188 : 						case SYSENC_STATUS_DECRYPTING:
; 6189 : 
; 6190 : 							if (!BootEncStatus.DriveEncrypted)

  005e1	83 3d 0e 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+14, 0
  005e8	0f 85 59 fe ff
	ff		 jne	 $LN15@MainDialog

; 6191 : 							{
; 6192 : 								// The partition/drive has been fully decrypted
; 6193 : 
; 6194 : 								try
; 6195 : 								{
; 6196 : 									// Finalize the process
; 6197 : 									BootEncObj->Deinstall ();

  005ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  005f4	6a 00		 push	 0
  005f6	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  005fd	e8 00 00 00 00	 call	 ?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z ; GostCrypt::BootEncryption::Deinstall
  00602	eb 32		 jmp	 SHORT $LN1486@MainDialog
__catch$_MainDialogProc@16$7:

; 6157 : 						catch (Exception &e)
; 6158 : 						{
; 6159 : 							e.Show (hwndDlg);

  00604	8b 8d 28 2d ff
	ff		 mov	 ecx, DWORD PTR _e$25[ebp]
  0060a	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00610	8b 01		 mov	 eax, DWORD PTR [ecx]
  00612	ff 10		 call	 DWORD PTR [eax]

; 6160 : 						}

  00614	b8 00 00 00 00	 mov	 eax, $LN653@MainDialog
  00619	c3		 ret	 0
__catch$_MainDialogProc@16$9:

; 6198 : 								}
; 6199 : 								catch (Exception &e)
; 6200 : 								{
; 6201 : 									e.Show (hwndDlg);

  0061a	8b 8d 24 2d ff
	ff		 mov	 ecx, DWORD PTR _e$24[ebp]
  00620	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00626	8b 01		 mov	 eax, DWORD PTR [ecx]
  00628	ff 10		 call	 DWORD PTR [eax]

; 6202 : 								}

  0062a	b8 00 00 00 00	 mov	 eax, $LN655@MainDialog
  0062f	c3		 ret	 0
$LN655@MainDialog:
  00630	8b 9d 68 2d ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN1486@MainDialog:

; 6203 : 					
; 6204 : 								ManageStartupSeqWiz (TRUE, "");

  00636	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0063b	6a 01		 push	 1
  0063d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00644	e8 00 00 00 00	 call	 _ManageStartupSeqWiz
  00649	6a 00		 push	 0
  0064b	e8 00 00 00 00	 call	 ?ChangeSystemEncryptionStatus@@YAHH@Z ; ChangeSystemEncryptionStatus
  00650	68 00 00 00 00	 push	 OFFSET ??_C@_08MFKGCNCO@FINALIZE?$AA@
  00655	e8 00 00 00 00	 call	 _GetString
  0065a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00660	83 c4 10	 add	 esp, 16			; 00000010H
  00663	50		 push	 eax
  00664	68 10 04 00 00	 push	 1040			; 00000410H
  00669	53		 push	 ebx
  0066a	ff d7		 call	 edi
  0066c	50		 push	 eax
  0066d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
  00673	6a 01		 push	 1
  00675	68 10 04 00 00	 push	 1040			; 00000410H
  0067a	53		 push	 ebx
  0067b	ff d7		 call	 edi
  0067d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00683	50		 push	 eax
  00684	ff d6		 call	 esi
  00686	6a 00		 push	 0
  00688	6a 02		 push	 2
  0068a	53		 push	 ebx
  0068b	ff d7		 call	 edi
  0068d	50		 push	 eax
  0068e	ff d6		 call	 esi
  00690	6a 00		 push	 0
  00692	68 41 04 00 00	 push	 1089			; 00000441H
  00697	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0069d	ff d7		 call	 edi
  0069f	50		 push	 eax
  006a0	ff d6		 call	 esi
  006a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HGGGHBLG@SYSTEM_DECRYPTION_FINISHED?$AA@
  006a7	e8 00 00 00 00	 call	 _Info
  006ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ICICKJJH@CONFIRM_RESTART?$AA@
  006b1	e8 00 00 00 00	 call	 _AskWarnYesNo
  006b6	83 c4 08	 add	 esp, 8
  006b9	83 f8 06	 cmp	 eax, 6
  006bc	0f 85 85 fd ff
	ff		 jne	 $LN15@MainDialog

; 6205 : 								ChangeSystemEncryptionStatus (SYSENC_STATUS_NONE);
; 6206 : 
; 6207 : 								SetWindowTextW (GetDlgItem (hwndDlg, IDC_NEXT), GetString ("FINALIZE"));
; 6208 : 								EnableWindow (GetDlgItem (hwndDlg, IDC_NEXT), TRUE);
; 6209 : 								EnableWindow (GetDlgItem (hwndDlg, IDCANCEL), FALSE);
; 6210 : 								EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), FALSE);
; 6211 : 
; 6212 : 								Info ("SYSTEM_DECRYPTION_FINISHED");
; 6213 : 
; 6214 : 								// Reboot is required to enable uninstallation and hibernation
; 6215 : 								if (AskWarnYesNo ("CONFIRM_RESTART") == IDYES)
; 6216 : 								{
; 6217 : 									EndMainDlg (MainDlg);

  006c2	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  006c8	e8 00 00 00 00	 call	 _EndMainDlg

; 6218 : 
; 6219 : 									try
; 6220 : 									{
; 6221 : 										BootEncObj->RestartComputer();

  006cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  006d3	83 c4 04	 add	 esp, 4
  006d6	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  006dd	e8 00 00 00 00	 call	 ?RestartComputer@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::RestartComputer
$ovf_end_3$1520:

; 6074 : 			}
; 6075 : 			return 1;

  006e2	b8 01 00 00 00	 mov	 eax, 1
  006e7	e9 c3 f9 ff ff	 jmp	 $LN1@MainDialog
__catch$_MainDialogProc@16$11:

; 6222 : 									}
; 6223 : 									catch (Exception &e)
; 6224 : 									{
; 6225 : 										e.Show (hwndDlg);

  006ec	8b 8d 20 2d ff
	ff		 mov	 ecx, DWORD PTR _e$23[ebp]
  006f2	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  006f8	8b 01		 mov	 eax, DWORD PTR [ecx]
  006fa	ff 10		 call	 DWORD PTR [eax]

; 6226 : 									}

  006fc	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  00701	c3		 ret	 0
$LN79@MainDialog:

; 6163 : 						{
; 6164 : 						case SYSENC_STATUS_ENCRYPTING:
; 6165 : 
; 6166 : 							if (BootEncStatus.ConfiguredEncryptedAreaStart == BootEncStatus.EncryptedAreaStart
; 6167 : 								&& BootEncStatus.ConfiguredEncryptedAreaEnd == BootEncStatus.EncryptedAreaEnd)

  00702	a1 1a 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+26
  00707	3b 05 2a 00 00
	00		 cmp	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+42
  0070d	0f 85 34 fd ff
	ff		 jne	 $LN15@MainDialog
  00713	a1 1e 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+30
  00718	3b 05 2e 00 00
	00		 cmp	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+46
  0071e	0f 85 23 fd ff
	ff		 jne	 $LN15@MainDialog
  00724	a1 22 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+34
  00729	3b 05 32 00 00
	00		 cmp	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+50
  0072f	0f 85 12 fd ff
	ff		 jne	 $LN15@MainDialog
  00735	a1 26 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+38
  0073a	3b 05 36 00 00
	00		 cmp	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+54
  00740	0f 85 01 fd ff
	ff		 jne	 $LN15@MainDialog

; 6168 : 							{
; 6169 : 								// The partition/drive has been fully encrypted
; 6170 : 
; 6171 : 								ManageStartupSeqWiz (TRUE, "");

  00746	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0074b	6a 01		 push	 1
  0074d	e8 00 00 00 00	 call	 _ManageStartupSeqWiz

; 6172 : 
; 6173 : 								SetWindowTextW (GetDlgItem (hwndDlg, IDC_NEXT), GetString ("FINALIZE"));

  00752	68 00 00 00 00	 push	 OFFSET ??_C@_08MFKGCNCO@FINALIZE?$AA@
  00757	e8 00 00 00 00	 call	 _GetString
  0075c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00762	83 c4 0c	 add	 esp, 12			; 0000000cH
  00765	50		 push	 eax
  00766	68 10 04 00 00	 push	 1040			; 00000410H
  0076b	53		 push	 ebx
  0076c	ff d7		 call	 edi
  0076e	50		 push	 eax
  0076f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 6174 : 								EnableWindow (GetDlgItem (hwndDlg, IDC_NEXT), TRUE);

  00775	6a 01		 push	 1
  00777	68 10 04 00 00	 push	 1040			; 00000410H
  0077c	53		 push	 ebx
  0077d	ff d7		 call	 edi
  0077f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00785	50		 push	 eax
  00786	ff d6		 call	 esi

; 6175 : 								EnableWindow (GetDlgItem (hwndDlg, IDCANCEL), FALSE);

  00788	6a 00		 push	 0
  0078a	6a 02		 push	 2
  0078c	53		 push	 ebx
  0078d	ff d7		 call	 edi
  0078f	50		 push	 eax
  00790	ff d6		 call	 esi

; 6176 : 								EnableWindow (GetDlgItem (hCurPage, IDC_WIPE_MODE), FALSE);

  00792	6a 00		 push	 0
  00794	68 3d 04 00 00	 push	 1085			; 0000043dH
  00799	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0079f	ff d7		 call	 edi
  007a1	50		 push	 eax
  007a2	ff d6		 call	 esi

; 6177 : 								EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), FALSE);

  007a4	6a 00		 push	 0
  007a6	68 41 04 00 00	 push	 1089			; 00000441H
  007ab	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  007b1	ff d7		 call	 edi
  007b3	50		 push	 eax
  007b4	ff d6		 call	 esi

; 6178 : 
; 6179 : 								WipeHiddenOSCreationConfig();	// For extra conservative security

  007b6	e8 00 00 00 00	 call	 _WipeHiddenOSCreationConfig

; 6180 : 
; 6181 : 								ChangeSystemEncryptionStatus (SYSENC_STATUS_NONE);

  007bb	6a 00		 push	 0
  007bd	e8 00 00 00 00	 call	 ?ChangeSystemEncryptionStatus@@YAHH@Z ; ChangeSystemEncryptionStatus

; 6182 : 
; 6183 : 								Info ("SYSTEM_ENCRYPTION_FINISHED");

  007c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LJPGNBNM@SYSTEM_ENCRYPTION_FINISHED?$AA@
  007c7	e8 00 00 00 00	 call	 _Info
  007cc	83 c4 08	 add	 esp, 8

; 6184 : 								return 1;

  007cf	b8 01 00 00 00	 mov	 eax, 1
  007d4	e9 d6 f8 ff ff	 jmp	 $LN1@MainDialog
__catch$_MainDialogProc@16$2:

; 6084 : 				}
; 6085 : 				catch (Exception &e)
; 6086 : 				{

  007d9	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 6087 : 					KillTimer (MainDlg, TIMER_ID_SYSENC_PROGRESS);

  007dc	68 00 01 00 00	 push	 256			; 00000100H
  007e1	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  007e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 6088 : 
; 6089 : 					try
; 6090 : 					{
; 6091 : 						BootEncObj->AbortSetup ();

  007ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  007f3	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  007f7	e8 00 00 00 00	 call	 ?AbortSetup@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::AbortSetup
$LN643@MainDialog:

; 6097 : 
; 6098 : 					e.Show (hwndDlg);

  007fc	8b 8d 1c 2d ff
	ff		 mov	 ecx, DWORD PTR _e$22[ebp]
  00802	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00808	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 5
  0080f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00811	ff 10		 call	 DWORD PTR [eax]
  00813	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@
  00818	e8 00 00 00 00	 call	 _Error
  0081d	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00823	e8 00 00 00 00	 call	 _EndMainDlg
  00828	83 c4 08	 add	 esp, 8
  0082b	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  00830	c3		 ret	 0
__catch$_MainDialogProc@16$3:

; 6092 : 					}
; 6093 : 					catch (Exception &e)
; 6094 : 					{
; 6095 : 						e.Show (hwndDlg);

  00831	8b 8d 08 2d ff
	ff		 mov	 ecx, DWORD PTR _e$17[ebp]
  00837	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  0083d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0083f	ff 10		 call	 DWORD PTR [eax]

; 6096 : 					}

  00841	b8 00 00 00 00	 mov	 eax, $LN643@MainDialog
  00846	c3		 ret	 0
$LN86@MainDialog:

; 6227 : 								}
; 6228 : 
; 6229 : 								return 1;
; 6230 : 							}
; 6231 : 							break;
; 6232 : 						}
; 6233 : 					}
; 6234 : 				}
; 6235 : 			}
; 6236 : 			return 1;
; 6237 : 
; 6238 : 		case TIMER_ID_NONSYS_INPLACE_ENC_PROGRESS:
; 6239 : 
; 6240 : 			if (bInPlaceEncNonSys)

  00847	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  0084e	0f 84 f3 fb ff
	ff		 je	 $LN15@MainDialog

; 6241 : 			{
; 6242 : 				// Non-system in-place encryption
; 6243 : 
; 6244 : 				if (!bVolTransformThreadRunning && !bVolTransformThreadToRun)

  00854	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  0085b	75 15		 jne	 SHORT $LN88@MainDialog
  0085d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  00864	75 0c		 jne	 SHORT $LN88@MainDialog

; 6245 : 				{
; 6246 : 					KillTimer (hwndDlg, TIMER_ID_NONSYS_INPLACE_ENC_PROGRESS);

  00866	68 01 01 00 00	 push	 257			; 00000101H
  0086b	53		 push	 ebx
  0086c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8
$LN88@MainDialog:

; 6247 : 				}
; 6248 : 
; 6249 : 				UpdateNonSysInPlaceEncControls ();

  00872	e8 00 00 00 00	 call	 _UpdateNonSysInPlaceEncControls

; 6250 : 			}
; 6251 : 			return 1;

  00877	b8 01 00 00 00	 mov	 eax, 1
  0087c	e9 2e f8 ff ff	 jmp	 $LN1@MainDialog
$LN89@MainDialog:

; 6252 : 
; 6253 : 		case TIMER_ID_KEYB_LAYOUT_GUARD:
; 6254 : 			if (SysEncInEffect ())

  00881	e8 00 00 00 00	 call	 _SysEncInEffect
  00886	85 c0		 test	 eax, eax
  00888	0f 84 b9 fb ff
	ff		 je	 $LN15@MainDialog

; 6255 : 			{
; 6256 : 				DWORD keybLayout = (DWORD) GetKeyboardLayout (NULL);

  0088e	6a 00		 push	 0
  00890	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyboardLayout@4

; 6257 : 
; 6258 : 				/* Watch the keyboard layout */
; 6259 : 
; 6260 : 				if (keybLayout != 0x00000409 && keybLayout != 0x04090409)

  00896	3d 09 04 00 00	 cmp	 eax, 1033		; 00000409H
  0089b	0f 84 51 01 00
	00		 je	 $LN1421@MainDialog
  008a1	3d 09 04 09 04	 cmp	 eax, 67699721		; 04090409H
  008a6	0f 84 46 01 00
	00		 je	 $LN1421@MainDialog

; 6261 : 				{
; 6262 : 					// Keyboard layout is not standard US
; 6263 : 
; 6264 : 					WipePasswordsAndKeyfiles ();

  008ac	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles

; 6265 : 
; 6266 : 					SetWindowText (GetDlgItem (hCurPage, IDC_PASSWORD), szRawPassword);

  008b1	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  008b7	68 00 00 00 00	 push	 OFFSET ?szRawPassword@@3PADA ; szRawPassword
  008bc	68 ec 03 00 00	 push	 1004			; 000003ecH
  008c1	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  008c7	ff d7		 call	 edi
  008c9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  008cf	50		 push	 eax
  008d0	ff d6		 call	 esi

; 6267 : 					SetWindowText (GetDlgItem (hCurPage, IDC_VERIFY), szVerify);

  008d2	68 00 00 00 00	 push	 OFFSET ?szVerify@@3PADA	; szVerify
  008d7	68 f2 03 00 00	 push	 1010			; 000003f2H
  008dc	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  008e2	ff d7		 call	 edi
  008e4	50		 push	 eax
  008e5	ff d6		 call	 esi

; 6268 : 
; 6269 : 					keybLayout = (DWORD) LoadKeyboardLayout ("00000409", KLF_ACTIVATE);

  008e7	6a 01		 push	 1
  008e9	68 00 00 00 00	 push	 OFFSET ??_C@_08OKJEGFFL@00000409?$AA@
  008ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadKeyboardLayoutA@8

; 6270 : 
; 6271 : 					if (keybLayout != 0x00000409 && keybLayout != 0x04090409)

  008f4	3d 09 04 00 00	 cmp	 eax, 1033		; 00000409H
  008f9	74 35		 je	 SHORT $LN92@MainDialog
  008fb	3d 09 04 09 04	 cmp	 eax, 67699721		; 04090409H
  00900	74 2e		 je	 SHORT $LN92@MainDialog

; 6272 : 					{
; 6273 : 						KillTimer (hwndDlg, TIMER_ID_KEYB_LAYOUT_GUARD);

  00902	68 04 01 00 00	 push	 260			; 00000104H
  00907	53		 push	 ebx
  00908	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 6274 : 						Error ("CANT_CHANGE_KEYB_LAYOUT_FOR_SYS_ENCRYPTION");

  0090e	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@KAEHBIEI@CANT_CHANGE_KEYB_LAYOUT_FOR_SYS_@
$LN1498@MainDialog:
  00913	e8 00 00 00 00	 call	 _Error

; 6275 : 						EndMainDlg (MainDlg);

  00918	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0091e	e8 00 00 00 00	 call	 _EndMainDlg
  00923	83 c4 08	 add	 esp, 8

; 6276 : 						return 1;

  00926	b8 01 00 00 00	 mov	 eax, 1
  0092b	e9 7f f7 ff ff	 jmp	 $LN1@MainDialog
$LN92@MainDialog:

; 6277 : 					}
; 6278 : 
; 6279 : 					bKeyboardLayoutChanged = TRUE;
; 6280 : 
; 6281 : 					wchar_t szTmp [4096];
; 6282 : 					wcscpy (szTmp, GetString ("KEYB_LAYOUT_CHANGE_PREVENTED"));

  00930	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MNCKOJDH@KEYB_LAYOUT_CHANGE_PREVENTED?$AA@
  00935	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bKeyboardLayoutChanged@@3HA, 1 ; bKeyboardLayoutChanged
  0093f	e8 00 00 00 00	 call	 _GetString
  00944	8d 95 90 35 ff
	ff		 lea	 edx, DWORD PTR _szTmp$84[ebp]
  0094a	83 c4 04	 add	 esp, 4
  0094d	2b d0		 sub	 edx, eax
  0094f	90		 npad	 1
$LL518@MainDialog:
  00950	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00953	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00956	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0095b	66 85 c9	 test	 cx, cx
  0095e	75 f0		 jne	 SHORT $LL518@MainDialog

; 6283 : 					wcscat (szTmp, L"\n\n");

  00960	8d 8d 90 35 ff
	ff		 lea	 ecx, DWORD PTR _szTmp$84[ebp]
  00966	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00969	0f 1f 80 00 00
	00 00		 npad	 7
$LL1375@MainDialog:
  00970	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  00974	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00977	66 85 c0	 test	 ax, ax
  0097a	75 f4		 jne	 SHORT $LL1375@MainDialog
  0097c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  00981	89 01		 mov	 DWORD PTR [ecx], eax
  00983	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@+4

; 6284 : 					wcscat (szTmp, GetString ("KEYB_LAYOUT_SYS_ENC_EXPLANATION"));

  00989	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HGCGAMEK@KEYB_LAYOUT_SYS_ENC_EXPLANATION?$AA@
  0098e	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  00992	e8 00 00 00 00	 call	 _GetString
  00997	8b d0		 mov	 edx, eax
  00999	83 c4 04	 add	 esp, 4
  0099c	8b f2		 mov	 esi, edx
  0099e	66 90		 npad	 2
$LL1376@MainDialog:
  009a0	66 8b 02	 mov	 ax, WORD PTR [edx]
  009a3	83 c2 02	 add	 edx, 2
  009a6	66 85 c0	 test	 ax, ax
  009a9	75 f5		 jne	 SHORT $LL1376@MainDialog
  009ab	8d bd 90 35 ff
	ff		 lea	 edi, DWORD PTR _szTmp$84[ebp]
  009b1	2b d6		 sub	 edx, esi
  009b3	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL1377@MainDialog:
  009b6	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  009ba	83 c7 02	 add	 edi, 2
  009bd	66 85 c0	 test	 ax, ax
  009c0	75 f4		 jne	 SHORT $LL1377@MainDialog
  009c2	8b ca		 mov	 ecx, edx

; 6285 : 					MessageBoxW (MainDlg, szTmp, lpszTitle, MB_ICONWARNING | MB_SETFOREGROUND | MB_TOPMOST);

  009c4	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__MessageBoxW@16
  009ca	c1 e9 02	 shr	 ecx, 2
  009cd	8d 85 90 35 ff
	ff		 lea	 eax, DWORD PTR _szTmp$84[ebp]
  009d3	f3 a5		 rep movsd
  009d5	68 30 00 05 00	 push	 327728			; 00050030H
  009da	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  009e0	8b ca		 mov	 ecx, edx
  009e2	50		 push	 eax
  009e3	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  009e9	83 e1 03	 and	 ecx, 3
  009ec	f3 a4		 rep movsb
  009ee	ff d3		 call	 ebx
  009f0	eb 06		 jmp	 SHORT $LN91@MainDialog
$LN1421@MainDialog:
  009f2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__MessageBoxW@16
$LN91@MainDialog:

; 6286 : 				}
; 6287 : 
; 6288 : 				/* Watch the right Alt key (which is used to enter various characters on non-US keyboards) */
; 6289 : 
; 6290 : 				if (bKeyboardLayoutChanged && !bKeybLayoutAltKeyWarningShown)

  009f8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bKeyboardLayoutChanged@@3HA, 0 ; bKeyboardLayoutChanged
  009ff	0f 84 42 fa ff
	ff		 je	 $LN15@MainDialog
  00a05	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bKeybLayoutAltKeyWarningShown@@3HA, 0 ; bKeybLayoutAltKeyWarningShown
  00a0c	0f 85 35 fa ff
	ff		 jne	 $LN15@MainDialog

; 6291 : 				{
; 6292 : 					if (GetAsyncKeyState (VK_RMENU) < 0)

  00a12	68 a5 00 00 00	 push	 165			; 000000a5H
  00a17	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetAsyncKeyState@4
  00a1d	66 85 c0	 test	 ax, ax
  00a20	0f 89 21 fa ff
	ff		 jns	 $LN15@MainDialog

; 6293 : 					{
; 6294 : 						bKeybLayoutAltKeyWarningShown = TRUE;
; 6295 : 
; 6296 : 						wchar_t szTmp [4096];
; 6297 : 						wcscpy (szTmp, GetString ("ALT_KEY_CHARS_NOT_FOR_SYS_ENCRYPTION"));

  00a26	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OEJEFNLJ@ALT_KEY_CHARS_NOT_FOR_SYS_ENCRYP@
  00a2b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bKeybLayoutAltKeyWarningShown@@3HA, 1 ; bKeybLayoutAltKeyWarningShown
  00a35	e8 00 00 00 00	 call	 _GetString
  00a3a	8d 95 90 55 ff
	ff		 lea	 edx, DWORD PTR _szTmp$85[ebp]
  00a40	83 c4 04	 add	 esp, 4
  00a43	2b d0		 sub	 edx, eax
$LL519@MainDialog:
  00a45	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00a48	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00a4b	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  00a50	66 85 c9	 test	 cx, cx
  00a53	75 f0		 jne	 SHORT $LL519@MainDialog

; 6298 : 						wcscat (szTmp, L"\n\n");

  00a55	8d 8d 90 55 ff
	ff		 lea	 ecx, DWORD PTR _szTmp$85[ebp]
  00a5b	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00a5e	66 90		 npad	 2
$LL1378@MainDialog:
  00a60	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  00a64	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00a67	66 85 c0	 test	 ax, ax
  00a6a	75 f4		 jne	 SHORT $LL1378@MainDialog
  00a6c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  00a71	89 01		 mov	 DWORD PTR [ecx], eax
  00a73	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@+4

; 6299 : 						wcscat (szTmp, GetString ("KEYB_LAYOUT_SYS_ENC_EXPLANATION"));

  00a79	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HGCGAMEK@KEYB_LAYOUT_SYS_ENC_EXPLANATION?$AA@
  00a7e	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  00a82	e8 00 00 00 00	 call	 _GetString
  00a87	8b d0		 mov	 edx, eax
  00a89	83 c4 04	 add	 esp, 4
  00a8c	8b f2		 mov	 esi, edx
  00a8e	66 90		 npad	 2
$LL1379@MainDialog:
  00a90	66 8b 02	 mov	 ax, WORD PTR [edx]
  00a93	83 c2 02	 add	 edx, 2
  00a96	66 85 c0	 test	 ax, ax
  00a99	75 f5		 jne	 SHORT $LL1379@MainDialog
  00a9b	8d bd 90 55 ff
	ff		 lea	 edi, DWORD PTR _szTmp$85[ebp]
  00aa1	2b d6		 sub	 edx, esi
  00aa3	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL1380@MainDialog:
  00aa6	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00aaa	83 c7 02	 add	 edi, 2
  00aad	66 85 c0	 test	 ax, ax
  00ab0	75 f4		 jne	 SHORT $LL1380@MainDialog
  00ab2	8b ca		 mov	 ecx, edx

; 6300 : 						MessageBoxW (MainDlg, szTmp, lpszTitle, MB_ICONINFORMATION  | MB_SETFOREGROUND | MB_TOPMOST);

  00ab4	8d 85 90 55 ff
	ff		 lea	 eax, DWORD PTR _szTmp$85[ebp]
  00aba	c1 e9 02	 shr	 ecx, 2
  00abd	f3 a5		 rep movsd
  00abf	68 40 00 05 00	 push	 327744			; 00050040H
  00ac4	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00aca	8b ca		 mov	 ecx, edx
  00acc	50		 push	 eax
  00acd	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00ad3	83 e1 03	 and	 ecx, 3
  00ad6	f3 a4		 rep movsb
  00ad8	ff d3		 call	 ebx

; 6301 : 					}
; 6302 : 				}
; 6303 : 			}
; 6304 : 			return 1;

  00ada	b8 01 00 00 00	 mov	 eax, 1
  00adf	e9 cb f5 ff ff	 jmp	 $LN1@MainDialog
$LN95@MainDialog:

; 6305 : 
; 6306 : 		case TIMER_ID_SYSENC_DRIVE_ANALYSIS_PROGRESS:
; 6307 : 
; 6308 : 			if (bSysEncDriveAnalysisInProgress)

  00ae4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bSysEncDriveAnalysisInProgress@@3HC, 0 ; bSysEncDriveAnalysisInProgress
  00aeb	74 59		 je	 SHORT $LN96@MainDialog

; 6309 : 			{
; 6310 : 				UpdateProgressBarProc (GetTickCount() - SysEncDriveAnalysisStart);

  00aed	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  00af3	ff d6		 call	 esi
  00af5	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?SysEncDriveAnalysisStart@@3HA ; SysEncDriveAnalysisStart
  00afb	6a 00		 push	 0
  00afd	50		 push	 eax
  00afe	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00b03	83 c4 08	 add	 esp, 8

; 6311 : 
; 6312 : 				if (GetTickCount() - SysEncDriveAnalysisStart > SYSENC_DRIVE_ANALYSIS_ETA)

  00b06	ff d6		 call	 esi
  00b08	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?SysEncDriveAnalysisStart@@3HA ; SysEncDriveAnalysisStart
  00b0e	3d 80 a9 03 00	 cmp	 eax, 240000		; 0003a980H
  00b13	76 22		 jbe	 SHORT $LN98@MainDialog

; 6313 : 				{
; 6314 : 					// It's taking longer than expected -- reinit the progress bar
; 6315 : 					SysEncDriveAnalysisStart = GetTickCount ();

  00b15	ff d6		 call	 esi

; 6316 : 					InitProgressBar (SYSENC_DRIVE_ANALYSIS_ETA, 0, FALSE, FALSE, FALSE, TRUE);

  00b17	6a 01		 push	 1
  00b19	6a 00		 push	 0
  00b1b	6a 00		 push	 0
  00b1d	6a 00		 push	 0
  00b1f	6a 00		 push	 0
  00b21	6a 00		 push	 0
  00b23	6a 00		 push	 0
  00b25	68 80 a9 03 00	 push	 240000			; 0003a980H
  00b2a	a3 00 00 00 00	 mov	 DWORD PTR ?SysEncDriveAnalysisStart@@3HA, eax ; SysEncDriveAnalysisStart
  00b2f	e8 00 00 00 00	 call	 _InitProgressBar
  00b34	83 c4 20	 add	 esp, 32			; 00000020H
$LN98@MainDialog:

; 6317 : 				}
; 6318 : 
; 6319 : 				ArrowWaitCursor ();

  00b37	e8 00 00 00 00	 call	 _ArrowWaitCursor
$ovf_end_4$1521:

; 6074 : 			}
; 6075 : 			return 1;

  00b3c	b8 01 00 00 00	 mov	 eax, 1
  00b41	e9 69 f5 ff ff	 jmp	 $LN1@MainDialog
$LN96@MainDialog:

; 6320 : 			}
; 6321 : 			else
; 6322 : 			{
; 6323 : 				KillTimer (hwndDlg, TIMER_ID_SYSENC_DRIVE_ANALYSIS_PROGRESS);

  00b46	68 03 01 00 00	 push	 259			; 00000103H
  00b4b	53		 push	 ebx
  00b4c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 6324 : 				UpdateProgressBarProc (SYSENC_DRIVE_ANALYSIS_ETA);

  00b52	6a 00		 push	 0
  00b54	68 80 a9 03 00	 push	 240000			; 0003a980H
  00b59	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00b5e	83 c4 08	 add	 esp, 8

; 6325 : 				Sleep (1500);	// User-friendly GUI

  00b61	68 dc 05 00 00	 push	 1500			; 000005dcH
  00b66	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 6326 : 
; 6327 : 				if (bSysEncDriveAnalysisTimeOutOccurred)

  00b6c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bSysEncDriveAnalysisTimeOutOccurred@@3HC, 0 ; bSysEncDriveAnalysisTimeOutOccurred
  00b73	74 0d		 je	 SHORT $LN99@MainDialog

; 6328 : 					Warning ("SYS_DRIVE_SIZE_PROBE_TIMEOUT");

  00b75	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@KCOCCGGE@SYS_DRIVE_SIZE_PROBE_TIMEOUT?$AA@
  00b7a	e8 00 00 00 00	 call	 _Warning
  00b7f	83 c4 04	 add	 esp, 4
$LN99@MainDialog:

; 6329 : 
; 6330 : 				LoadPage (hwndDlg, SYSENC_DRIVE_ANALYSIS_PAGE + 1);

  00b82	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  00b87	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  00b8d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  00b93	85 c0		 test	 eax, eax
  00b95	74 60		 je	 SHORT $LN720@MainDialog
  00b97	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  00ba1	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00ba4	75 40		 jne	 SHORT $LN714@MainDialog
  00ba6	6a 40		 push	 64			; 00000040H
  00ba8	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$99[ebp]
  00bae	6a 58		 push	 88			; 00000058H
  00bb0	50		 push	 eax
  00bb1	e8 00 00 00 00	 call	 _memset
  00bb6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  00bbc	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$99[ebp]
  00bc2	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bc5	c6 45 a0 00	 mov	 BYTE PTR _tmp$99[ebp+64], 0
  00bc9	50		 push	 eax
  00bca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  00bcf	50		 push	 eax
  00bd0	ff d6		 call	 esi
  00bd2	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$99[ebp]
  00bd8	50		 push	 eax
  00bd9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  00bde	50		 push	 eax
  00bdf	ff d6		 call	 esi
  00be1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN714@MainDialog:
  00be6	50		 push	 eax
  00be7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00bed	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN720@MainDialog:
  00bf7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  00c01	e8 00 00 00 00	 call	 _NormalCursor
  00c06	8d 85 58 35 ff
	ff		 lea	 eax, DWORD PTR _rW$80[ebp]
  00c0c	50		 push	 eax
  00c0d	68 23 04 00 00	 push	 1059			; 00000423H
  00c12	53		 push	 ebx
  00c13	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00c19	50		 push	 eax
  00c1a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00c20	6a 00		 push	 0
  00c22	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00c27	53		 push	 ebx
  00c28	6a 77		 push	 119			; 00000077H
  00c2a	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00c30	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 6 ; nCurPageNo
  00c3a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  00c40	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  00c47	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  00c4c	8d 85 68 35 ff
	ff		 lea	 eax, DWORD PTR _rD$81[ebp]
  00c52	50		 push	 eax
  00c53	53		 push	 ebx
  00c54	0f 11 85 68 35
	ff ff		 movups	 XMMWORD PTR _rD$81[ebp], xmm0
  00c5b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00c61	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  00c67	85 c9		 test	 ecx, ecx
  00c69	0f 84 d8 f7 ff
	ff		 je	 $LN15@MainDialog
  00c6f	8b 85 64 35 ff
	ff		 mov	 eax, DWORD PTR _rW$80[ebp+12]
  00c75	2b 85 5c 35 ff
	ff		 sub	 eax, DWORD PTR _rW$80[ebp+4]
  00c7b	6a 01		 push	 1
  00c7d	50		 push	 eax
  00c7e	8b 85 60 35 ff
	ff		 mov	 eax, DWORD PTR _rW$80[ebp+8]
  00c84	2b 85 58 35 ff
	ff		 sub	 eax, DWORD PTR _rW$80[ebp]
  00c8a	50		 push	 eax
  00c8b	ff b5 6c 35 ff
	ff		 push	 DWORD PTR _rD$81[ebp+4]
  00c91	ff b5 68 35 ff
	ff		 push	 DWORD PTR _rD$81[ebp]
$LN1501@MainDialog:
  00c97	51		 push	 ecx
  00c98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  00c9e	6a 01		 push	 1
  00ca0	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00ca6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 6331 : 			}
; 6332 : 			return 1;

  00cac	b8 01 00 00 00	 mov	 eax, 1
  00cb1	e9 f9 f3 ff ff	 jmp	 $LN1@MainDialog
$LN100@MainDialog:

; 6333 : 
; 6334 : 		case TIMER_ID_WIPE_PROGRESS:
; 6335 : 
; 6336 : 			// Manage device wipe and update related GUI
; 6337 : 
; 6338 : 			if (bHiddenOS && IsHiddenOSRunning())

  00cb6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00cbd	0f 84 84 f7 ff
	ff		 je	 $LN15@MainDialog
  00cc3	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  00cc8	85 c0		 test	 eax, eax
  00cca	0f 84 77 f7 ff
	ff		 je	 $LN15@MainDialog

; 6339 : 			{
; 6340 : 				// Decoy system partition wipe 
; 6341 : 
; 6342 : 				DecoySystemWipeStatus decoySysPartitionWipeStatus;
; 6343 : 
; 6344 : 				try
; 6345 : 				{
; 6346 : 					decoySysPartitionWipeStatus = BootEncObj->GetDecoyOSWipeStatus();

  00cd0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00cd6	8d 85 d0 31 ff
	ff		 lea	 eax, DWORD PTR $T40[ebp]
  00cdc	50		 push	 eax
  00cdd	c7 45 fc 0e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 14 ; 0000000eH
  00ce4	e8 00 00 00 00	 call	 ?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ ; GostCrypt::BootEncryption::GetDecoyOSWipeStatus

; 6347 : 					BootEncStatus = BootEncObj->GetStatus();

  00ce9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00cef	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00cf2	8d 85 b0 30 ff
	ff		 lea	 eax, DWORD PTR $T37[ebp]
  00cf8	50		 push	 eax
  00cf9	0f 11 85 68 35
	ff ff		 movups	 XMMWORD PTR _decoySysPartitionWipeStatus$82[ebp], xmm0
  00d00	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00d05	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00d0a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00d11	8b f0		 mov	 esi, eax
  00d13	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  00d18	f3 a5		 rep movsd
  00d1a	66 a5		 movsw
  00d1c	8b b5 68 35 ff
	ff		 mov	 esi, DWORD PTR _decoySysPartitionWipeStatus$82[ebp]
  00d22	85 f6		 test	 esi, esi
  00d24	74 0a		 je	 SHORT $LN105@MainDialog

; 6363 : 					EndMainDlg (MainDlg);
; 6364 : 					return 1;
; 6365 : 				}
; 6366 : 
; 6367 : 				if (decoySysPartitionWipeStatus.WipeInProgress)
; 6368 : 				{
; 6369 : 					ArrowWaitCursor ();
; 6370 : 
; 6371 : 					UpdateWipeProgressBar ();

  00d26	e8 00 00 00 00	 call	 _ArrowWaitCursor
  00d2b	e8 00 00 00 00	 call	 _UpdateWipeProgressBar
$LN105@MainDialog:

; 6372 : 				}
; 6373 : 
; 6374 : 				if (bDeviceWipeInProgress != decoySysPartitionWipeStatus.WipeInProgress)

  00d30	39 35 00 00 00
	00		 cmp	 DWORD PTR ?bDeviceWipeInProgress@@3HA, esi ; bDeviceWipeInProgress
  00d36	0f 84 0b f7 ff
	ff		 je	 $LN15@MainDialog

; 6375 : 				{
; 6376 : 					bDeviceWipeInProgress = decoySysPartitionWipeStatus.WipeInProgress;

  00d3c	89 35 00 00 00
	00		 mov	 DWORD PTR ?bDeviceWipeInProgress@@3HA, esi ; bDeviceWipeInProgress

; 6377 : 
; 6378 : 					UpdateWipeProgressBar ();

  00d42	e8 00 00 00 00	 call	 _UpdateWipeProgressBar

; 6379 : 					UpdateWipeControls ();

  00d47	e8 00 00 00 00	 call	 _UpdateWipeControls

; 6380 : 
; 6381 : 					if (!bDeviceWipeInProgress)

  00d4c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDeviceWipeInProgress@@3HA, 0 ; bDeviceWipeInProgress
  00d53	0f 85 ee f6 ff
	ff		 jne	 $LN15@MainDialog

; 6382 : 					{
; 6383 : 						// The driver stopped wiping
; 6384 : 
; 6385 : 						KillTimer (hwndDlg, TIMER_ID_WIPE_PROGRESS);

  00d59	68 02 01 00 00	 push	 258			; 00000102H
  00d5e	53		 push	 ebx
  00d5f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 6386 : 
; 6387 : 						try
; 6388 : 						{
; 6389 : 							BootEncObj->CheckDecoyOSWipeResult();

  00d65	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00d6b	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 18 ; 00000012H
  00d72	e8 00 00 00 00	 call	 ?CheckDecoyOSWipeResult@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckDecoyOSWipeResult
$LN663@MainDialog:

; 6396 : 
; 6397 : 						if (BootEncStatus.ConfiguredEncryptedAreaEnd == decoySysPartitionWipeStatus.WipedAreaEnd)

  00d77	a1 22 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+34
  00d7c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00d83	3b 85 70 35 ff
	ff		 cmp	 eax, DWORD PTR _decoySysPartitionWipeStatus$82[ebp+8]
  00d89	0f 85 b8 f6 ff
	ff		 jne	 $LN15@MainDialog
  00d8f	a1 26 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+38
  00d94	3b 85 74 35 ff
	ff		 cmp	 eax, DWORD PTR _decoySysPartitionWipeStatus$82[ebp+12]
  00d9a	0f 85 a7 f6 ff
	ff		 jne	 $LN15@MainDialog

; 6398 : 						{
; 6399 : 							// Decoy system partition has been fully wiped
; 6400 : 
; 6401 : 							ChangeHiddenOSCreationPhase (GST_HIDDEN_OS_CREATION_PHASE_WIPED);

  00da0	68 c0 00 00 00	 push	 192			; 000000c0H
  00da5	e8 00 00 00 00	 call	 ?ChangeHiddenOSCreationPhase@@YAHH@Z ; ChangeHiddenOSCreationPhase

; 6402 : 
; 6403 : 							SetWindowTextW (GetDlgItem (MainDlg, IDCANCEL), GetString ("EXIT"));

  00daa	68 00 00 00 00	 push	 OFFSET ??_C@_04GOLNGIJ@EXIT?$AA@
  00daf	e8 00 00 00 00	 call	 _GetString
  00db4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00dba	83 c4 08	 add	 esp, 8
  00dbd	50		 push	 eax
  00dbe	6a 02		 push	 2
  00dc0	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00dc6	ff d7		 call	 edi
  00dc8	50		 push	 eax
  00dc9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 6404 : 							EnableWindow (GetDlgItem (MainDlg, IDCANCEL), TRUE);

  00dcf	6a 01		 push	 1
  00dd1	6a 02		 push	 2
  00dd3	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00dd9	ff d7		 call	 edi
  00ddb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00de1	50		 push	 eax
  00de2	ff d6		 call	 esi

; 6405 : 							EnableWindow (GetDlgItem (MainDlg, IDC_PREV), FALSE);

  00de4	6a 00		 push	 0
  00de6	68 11 04 00 00	 push	 1041			; 00000411H
  00deb	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00df1	ff d7		 call	 edi
  00df3	50		 push	 eax
  00df4	ff d6		 call	 esi

; 6406 : 							EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), FALSE);

  00df6	6a 00		 push	 0
  00df8	68 10 04 00 00	 push	 1040			; 00000410H
  00dfd	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00e03	ff d7		 call	 edi
  00e05	50		 push	 eax
  00e06	ff d6		 call	 esi

; 6407 : 							EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), FALSE);

  00e08	6a 00		 push	 0
  00e0a	68 f8 03 00 00	 push	 1016			; 000003f8H
  00e0f	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00e15	ff d7		 call	 edi
  00e17	50		 push	 eax
  00e18	ff d6		 call	 esi

; 6408 : 
; 6409 : 							Info ("WIPE_FINISHED_DECOY_SYSTEM_PARTITION");

  00e1a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JGIFKPLM@WIPE_FINISHED_DECOY_SYSTEM_PARTI@
  00e1f	e8 00 00 00 00	 call	 _Info

; 6410 : 
; 6411 : 							TextInfoDialogBox (GST_TBXID_DECOY_OS_INSTRUCTIONS);

  00e24	6a 03		 push	 3
  00e26	e8 00 00 00 00	 call	 _TextInfoDialogBox

; 6412 : 
; 6413 : 							if (BootEncObj->GetSystemDriveConfiguration().ExtraBootPartitionPresent)

  00e2b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00e31	8d 85 70 2d ff
	ff		 lea	 eax, DWORD PTR $T33[ebp]
  00e37	83 c4 08	 add	 esp, 8
  00e3a	50		 push	 eax
  00e3b	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  00e40	8d 8d 70 2d ff
	ff		 lea	 ecx, DWORD PTR $T33[ebp]
  00e46	8a 98 a8 00 00
	00		 mov	 bl, BYTE PTR [eax+168]
  00e4c	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  00e51	84 db		 test	 bl, bl
  00e53	74 0d		 je	 SHORT $LN110@MainDialog

; 6414 : 								Warning ("DECOY_OS_VERSION_WARNING");

  00e55	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EAMLJMAO@DECOY_OS_VERSION_WARNING?$AA@
  00e5a	e8 00 00 00 00	 call	 _Warning
  00e5f	83 c4 04	 add	 esp, 4
$LN110@MainDialog:

; 6415 : 
; 6416 : 							return 1;

  00e62	b8 01 00 00 00	 mov	 eax, 1
  00e67	e9 43 f2 ff ff	 jmp	 $LN1@MainDialog
__catch$_MainDialogProc@16$17:

; 6390 : 						}
; 6391 : 						catch (Exception &e)
; 6392 : 						{
; 6393 : 							e.Show (hwndDlg);

  00e6c	8b 8d f8 2c ff
	ff		 mov	 ecx, DWORD PTR _e$13[ebp]
  00e72	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00e78	8b 01		 mov	 eax, DWORD PTR [ecx]
  00e7a	ff 10		 call	 DWORD PTR [eax]

; 6394 : 							AbortProcessSilent();

  00e7c	e8 00 00 00 00	 call	 _AbortProcessSilent

; 6395 : 						}

  00e81	b8 00 00 00 00	 mov	 eax, $LN663@MainDialog
  00e86	c3		 ret	 0
__catch$_MainDialogProc@16$13:

; 6348 : 				}
; 6349 : 				catch (Exception &e)
; 6350 : 				{
; 6351 : 					KillTimer (MainDlg, TIMER_ID_WIPE_PROGRESS);

  00e87	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00e8a	68 02 01 00 00	 push	 258			; 00000102H
  00e8f	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00e95	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 6352 : 
; 6353 : 					try
; 6354 : 					{
; 6355 : 						BootEncObj->AbortDecoyOSWipe ();

  00e9b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00ea1	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
  00ea5	e8 00 00 00 00	 call	 ?AbortDecoyOSWipe@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::AbortDecoyOSWipe
$LN659@MainDialog:

; 6361 : 
; 6362 : 					e.Show (hwndDlg);

  00eaa	8b 8d 00 2d ff
	ff		 mov	 ecx, DWORD PTR _e$15[ebp]
  00eb0	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00eb6	c7 45 fc 0f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 15 ; 0000000fH
  00ebd	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ebf	ff 10		 call	 DWORD PTR [eax]
  00ec1	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00ec7	e8 00 00 00 00	 call	 _EndMainDlg
  00ecc	83 c4 04	 add	 esp, 4
  00ecf	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  00ed4	c3		 ret	 0
__catch$_MainDialogProc@16$14:

; 6356 : 					}
; 6357 : 					catch (Exception &e)
; 6358 : 					{
; 6359 : 						e.Show (hwndDlg);

  00ed5	8b 8d fc 2c ff
	ff		 mov	 ecx, DWORD PTR _e$14[ebp]
  00edb	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00ee1	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ee3	ff 10		 call	 DWORD PTR [eax]

; 6360 : 					}

  00ee5	b8 00 00 00 00	 mov	 eax, $LN659@MainDialog
  00eea	c3		 ret	 0
$LN58@MainDialog:

; 6028 : 
; 6029 : 	case WM_SYSCOMMAND:
; 6030 : 		if (lw == IDC_ABOUT)

  00eeb	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00ef0	66 39 45 10	 cmp	 WORD PTR _wParam$[ebp], ax
  00ef4	0f 85 b3 f1 ff
	ff		 jne	 $LN2@MainDialog

; 6031 : 		{
; 6032 : 			DialogBoxW (hInst, MAKEINTRESOURCEW (IDD_ABOUT_DLG), hwndDlg, (DLGPROC) AboutDlgProc);

  00efa	6a 00		 push	 0
  00efc	68 00 00 00 00	 push	 OFFSET _AboutDlgProc@16
  00f01	53		 push	 ebx
  00f02	68 fc 01 00 00	 push	 508			; 000001fcH
  00f07	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00f0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20
$ovf_end_5$1522:

; 6074 : 			}
; 6075 : 			return 1;

  00f13	b8 01 00 00 00	 mov	 eax, 1
  00f18	e9 92 f1 ff ff	 jmp	 $LN1@MainDialog
$LN146@MainDialog:

; 6597 : 		return 1;
; 6598 : 
; 6599 : 
; 6600 : 	case WM_COMMAND:
; 6601 : 
; 6602 : 		if (lw == IDHELP)

  00f1d	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00f20	66 83 fa 09	 cmp	 dx, 9
  00f24	0f 84 5f f1 ff
	ff		 je	 $LN1509@MainDialog

; 6603 : 		{
; 6604 : 			OpenPageHelp (hwndDlg, nCurPageNo);
; 6605 : 			return 1;
; 6606 : 		}
; 6607 : 		else if (lw == IDCANCEL)

  00f2a	66 83 fa 02	 cmp	 dx, 2
  00f2e	0f 84 ca 18 00
	00		 je	 $LN384@MainDialog

; 6608 : 		{
; 6609 : 			PostMessage (hwndDlg, GST_APPMSG_FORMAT_USER_QUIT, 0, 0);
; 6610 : 			return 1;
; 6611 : 		}
; 6612 : 		else if (lw == IDC_NEXT)

  00f34	be 10 04 00 00	 mov	 esi, 1040		; 00000410H
  00f39	66 3b d6	 cmp	 dx, si
  00f3c	0f 85 b5 29 00
	00		 jne	 $LN151@MainDialog

; 6613 : 		{
; 6614 : 			if (nCurPageNo == INTRO_PAGE)

  00f42	85 c0		 test	 eax, eax
  00f44	0f 85 84 01 00
	00		 jne	 $LN153@MainDialog

; 6615 : 			{
; 6616 : 				switch (GetSelectedWizardMode (hCurPage))

  00f4a	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00f50	e8 00 00 00 00	 call	 ?GetSelectedWizardMode@@YAHPAUHWND__@@@Z ; GetSelectedWizardMode
  00f55	83 c4 04	 add	 esp, 4
  00f58	83 e8 00	 sub	 eax, 0
  00f5b	0f 84 76 00 00
	00		 je	 $LN155@MainDialog
  00f61	83 e8 01	 sub	 eax, 1
  00f64	74 31		 je	 SHORT $LN159@MainDialog
  00f66	83 e8 01	 sub	 eax, 1
  00f69	0f 85 05 07 00
	00		 jne	 $LN1474@MainDialog

; 6653 : 					break;
; 6654 : 
; 6655 : 				case WIZARD_MODE_SYS_DEVICE:
; 6656 : 
; 6657 : 					WaitCursor ();

  00f6f	e8 00 00 00 00	 call	 _WaitCursor

; 6658 : 					bHiddenVol = FALSE;

  00f74	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol

; 6659 : 					bInPlaceEncNonSys = FALSE;

  00f7e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0

; 6660 : 					SwitchWizardToSysEncMode ();

  00f88	e8 00 00 00 00	 call	 _SwitchWizardToSysEncMode
$ovf_end_6$1523:

; 6074 : 			}
; 6075 : 			return 1;

  00f8d	b8 01 00 00 00	 mov	 eax, 1
  00f92	e9 18 f1 ff ff	 jmp	 $LN1@MainDialog
$LN159@MainDialog:

; 6638 : 					break;
; 6639 : 
; 6640 : 				case WIZARD_MODE_NONSYS_DEVICE:
; 6641 : 
; 6642 : 					WaitCursor ();

  00f97	e8 00 00 00 00	 call	 _WaitCursor

; 6643 : 					CloseSysEncMutex ();

  00f9c	e8 00 00 00 00	 call	 _CloseSysEncMutex

; 6644 : 
; 6645 : 					if (!ChangeWizardMode (WIZARD_MODE_NONSYS_DEVICE))

  00fa1	6a 01		 push	 1
  00fa3	e8 00 00 00 00	 call	 ?ChangeWizardMode@@YAHH@Z ; ChangeWizardMode
  00fa8	83 c4 04	 add	 esp, 4
  00fab	85 c0		 test	 eax, eax
  00fad	0f 84 91 07 00
	00		 je	 $LN1291@MainDialog

; 6646 : 					{
; 6647 : 						NormalCursor ();
; 6648 : 						return 1;
; 6649 : 					}
; 6650 : 
; 6651 : 					bHiddenOS = FALSE;
; 6652 : 					nNewPageNo = VOLUME_TYPE_PAGE - 1;	// Skip irrelevant pages

  00fb3	be 0b 00 00 00	 mov	 esi, 11			; 0000000bH
  00fb8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS

; 8099 : 				}
; 8100 : 				return 1;
; 8101 : 			}
; 8102 : 
; 8103 : 			LoadPage (hwndDlg, nNewPageNo + 1);

  00fc2	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00fc5	50		 push	 eax
  00fc6	53		 push	 ebx
  00fc7	e8 00 00 00 00	 call	 _LoadPage
  00fcc	83 c4 08	 add	 esp, 8
$ovf_end_7$1524:

; 6074 : 			}
; 6075 : 			return 1;

  00fcf	8d 46 f6	 lea	 eax, DWORD PTR [esi-10]
  00fd2	e9 d8 f0 ff ff	 jmp	 $LN1@MainDialog
$LN155@MainDialog:

; 6617 : 				{
; 6618 : 				case WIZARD_MODE_FILE_CONTAINER:
; 6619 : 
; 6620 : 					if (CurrentOSMajor >= 6 && IsUacSupported() && IsAdmin() && !IsBuiltInAdmin() && !IsNonInstallMode())

  00fd7	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _CurrentOSMajor, 6
  00fde	7c 4c		 jl	 SHORT $LN157@MainDialog
  00fe0	e8 00 00 00 00	 call	 _IsUacSupported
  00fe5	85 c0		 test	 eax, eax
  00fe7	74 43		 je	 SHORT $LN157@MainDialog
  00fe9	e8 00 00 00 00	 call	 _IsAdmin
  00fee	85 c0		 test	 eax, eax
  00ff0	74 3a		 je	 SHORT $LN157@MainDialog
  00ff2	e8 00 00 00 00	 call	 _IsBuiltInAdmin
  00ff7	85 c0		 test	 eax, eax
  00ff9	75 31		 jne	 SHORT $LN157@MainDialog
  00ffb	e8 00 00 00 00	 call	 _IsNonInstallMode
  01000	85 c0		 test	 eax, eax
  01002	75 28		 jne	 SHORT $LN157@MainDialog

; 6621 : 					{
; 6622 : 						static bool warningConfirmed = false;
; 6623 : 						if (!warningConfirmed)

  01004	38 05 00 00 00
	00		 cmp	 BYTE PTR ?warningConfirmed@?NM@??MainDialogProc@@9@16@4_NA, al
  0100a	75 20		 jne	 SHORT $LN157@MainDialog

; 6624 : 						{
; 6625 : 							if (AskWarnYesNo ("CONTAINER_ADMIN_WARNING") == IDYES)

  0100c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BGKLALIE@CONTAINER_ADMIN_WARNING?$AA@
  01011	e8 00 00 00 00	 call	 _AskWarnYesNo
  01016	83 c4 04	 add	 esp, 4
  01019	83 f8 06	 cmp	 eax, 6
  0101c	75 07		 jne	 SHORT $LN158@MainDialog
$LN56@MainDialog:

; 6626 : 								exit (0);

  0101e	6a 00		 push	 0
  01020	e8 00 00 00 00	 call	 _exit
$LN1515@MainDialog:
$LN158@MainDialog:

; 6627 : 
; 6628 : 							warningConfirmed = true;

  01025	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?warningConfirmed@?NM@??MainDialogProc@@9@16@4_NA, 1
$LN157@MainDialog:

; 6629 : 						}
; 6630 : 					}
; 6631 : 
; 6632 : 					WaitCursor ();

  0102c	e8 00 00 00 00	 call	 _WaitCursor

; 6633 : 					CloseSysEncMutex ();

  01031	e8 00 00 00 00	 call	 _CloseSysEncMutex

; 6634 : 					ChangeWizardMode (WIZARD_MODE_FILE_CONTAINER);

  01036	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _WizardMode, 0
  0103d	74 43		 je	 SHORT $LN913@MainDialog
  0103f	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  01046	75 05		 jne	 SHORT $LN914@MainDialog
  01048	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
$LN914@MainDialog:
  0104d	0f 57 c0	 xorps	 xmm0, xmm0
  01050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  0105a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  01061	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  01068	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  01070	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  01078	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WizardMode, 0
$LN913@MainDialog:
  01082	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  01087	f7 d8		 neg	 eax
  01089	1b c0		 sbb	 eax, eax
  0108b	f7 d8		 neg	 eax
  0108d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  01094	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice
  01099	75 05		 jne	 SHORT $LN921@MainDialog
  0109b	e8 00 00 00 00	 call	 _CloseSysEncMutex
$LN921@MainDialog:

; 6635 : 					bHiddenOS = FALSE;
; 6636 : 					bInPlaceEncNonSys = FALSE;
; 6637 : 					nNewPageNo = VOLUME_TYPE_PAGE - 1;	// Skip irrelevant pages

  010a0	be 0b 00 00 00	 mov	 esi, 11			; 0000000bH
  010a5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  010af	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0

; 8099 : 				}
; 8100 : 				return 1;
; 8101 : 			}
; 8102 : 
; 8103 : 			LoadPage (hwndDlg, nNewPageNo + 1);

  010b9	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  010bc	50		 push	 eax
  010bd	53		 push	 ebx
  010be	e8 00 00 00 00	 call	 _LoadPage
  010c3	83 c4 08	 add	 esp, 8
$ovf_end_8$1525:

; 6074 : 			}
; 6075 : 			return 1;

  010c6	8d 46 f6	 lea	 eax, DWORD PTR [esi-10]
  010c9	e9 e1 ef ff ff	 jmp	 $LN1@MainDialog
$LN153@MainDialog:

; 6661 : 					return 1;
; 6662 : 				}
; 6663 : 			}
; 6664 : 			else if (nCurPageNo == SYSENC_TYPE_PAGE)

  010ce	83 f8 01	 cmp	 eax, 1
  010d1	75 44		 jne	 SHORT $LN162@MainDialog

; 6665 : 			{
; 6666 : 				if (bHiddenOS)

  010d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  010da	74 21		 je	 SHORT $LN1488@MainDialog

; 6667 : 				{
; 6668 : 					bWholeSysDrive = FALSE;

  010dc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive

; 6669 : 					bHiddenVolDirect = FALSE;

  010e6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHiddenVolDirect, 0

; 6670 : 				}
; 6671 : 
; 6672 : 				if (!bHiddenOS)

  010f0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  010f7	0f 85 77 05 00
	00		 jne	 $LN1474@MainDialog
$LN1488@MainDialog:

; 6673 : 					nNewPageNo = SYSENC_SPAN_PAGE - 1;	// Skip irrelevant pages

  010fd	be 02 00 00 00	 mov	 esi, 2

; 8099 : 				}
; 8100 : 				return 1;
; 8101 : 			}
; 8102 : 
; 8103 : 			LoadPage (hwndDlg, nNewPageNo + 1);

  01102	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  01105	50		 push	 eax
  01106	53		 push	 ebx
  01107	e8 00 00 00 00	 call	 _LoadPage
  0110c	83 c4 08	 add	 esp, 8
$ovf_end_9$1526:

; 6074 : 			}
; 6075 : 			return 1;

  0110f	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  01112	e9 98 ef ff ff	 jmp	 $LN1@MainDialog
$LN162@MainDialog:

; 6674 : 			}
; 6675 : 			else if (nCurPageNo == SYSENC_HIDDEN_OS_REQ_CHECK_PAGE)

  01117	83 f8 02	 cmp	 eax, 2
  0111a	0f 85 9c 01 00
	00		 jne	 $LN166@MainDialog

; 6676 : 			{
; 6677 : 				WaitCursor ();

  01120	e8 00 00 00 00	 call	 _WaitCursor

; 6678 : 				try
; 6679 : 				{
; 6680 : 					BootEncObj->CheckRequirementsHiddenOS ();

  01125	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0112b	c7 45 fc 16 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 22 ; 00000016H
  01132	e8 00 00 00 00	 call	 ?CheckRequirementsHiddenOS@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckRequirementsHiddenOS

; 6681 : 
; 6682 : 					if (CheckGapBetweenSysAndHiddenOS ())

  01137	e8 00 00 00 00	 call	 ?CheckGapBetweenSysAndHiddenOS@@YAHXZ ; CheckGapBetweenSysAndHiddenOS
  0113c	85 c0		 test	 eax, eax
  0113e	74 0d		 je	 SHORT $LN169@MainDialog

; 6683 : 						Warning ("GAP_BETWEEN_SYS_AND_HIDDEN_OS_PARTITION");

  01140	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HFDNHKMM@GAP_BETWEEN_SYS_AND_HIDDEN_OS_PA@
  01145	e8 00 00 00 00	 call	 _Warning
  0114a	83 c4 04	 add	 esp, 4
$LN169@MainDialog:

; 6690 : 				}
; 6691 : 
; 6692 : 				if (AskWarnYesNo ("DECOY_OS_REINSTALL_WARNING") == IDNO)

  0114d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IDNPDOGL@DECOY_OS_REINSTALL_WARNING?$AA@
  01152	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  01159	e8 00 00 00 00	 call	 _AskWarnYesNo
  0115e	83 c4 04	 add	 esp, 4
  01161	83 f8 07	 cmp	 eax, 7
  01164	0f 84 da 05 00
	00		 je	 $LN1291@MainDialog

; 6693 : 				{
; 6694 : 					NormalCursor ();
; 6695 : 					return 1;
; 6696 : 				}
; 6697 : 
; 6698 : 				WarningDirect ((wstring (GetString ("HIDDEN_OS_WRITE_PROTECTION_BRIEF_INFO"))

  0116a	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LFCLDECM@HIDDEN_OS_WRITE_PROTECTION_BRIEF@
  0116f	e8 00 00 00 00	 call	 _GetString
  01174	83 c4 04	 add	 esp, 4
  01177	8d 8d a0 32 ff
	ff		 lea	 ecx, DWORD PTR $T49[ebp]
  0117d	50		 push	 eax
  0117e	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  01183	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  01188	50		 push	 eax
  01189	8d 85 b8 32 ff
	ff		 lea	 eax, DWORD PTR $T50[ebp]
  0118f	c7 45 fc 18 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 24 ; 00000018H
  01196	50		 push	 eax
  01197	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0119c	8b f0		 mov	 esi, eax
  0119e	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OILEALFF@HIDDEN_OS_WRITE_PROTECTION_EXPLA@
  011a3	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+12], 25 ; 00000019H
  011a7	e8 00 00 00 00	 call	 _GetString
  011ac	50		 push	 eax
  011ad	8d 85 d0 32 ff
	ff		 lea	 eax, DWORD PTR $T51[ebp]
  011b3	56		 push	 esi
  011b4	50		 push	 eax
  011b5	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  011ba	83 c4 1c	 add	 esp, 28			; 0000001cH
  011bd	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  011c1	72 02		 jb	 SHORT $LN941@MainDialog
  011c3	8b 00		 mov	 eax, DWORD PTR [eax]
$LN941@MainDialog:
  011c5	50		 push	 eax
  011c6	e8 00 00 00 00	 call	 _WarningDirect
  011cb	83 c4 04	 add	 esp, 4
  011ce	8d 8d d0 32 ff
	ff		 lea	 ecx, DWORD PTR $T51[ebp]
  011d4	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  011d9	8d 8d b8 32 ff
	ff		 lea	 ecx, DWORD PTR $T50[ebp]
  011df	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  011e4	8d 8d a0 32 ff
	ff		 lea	 ecx, DWORD PTR $T49[ebp]
  011ea	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  011f1	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 6699 : 					+ L"\n\n"
; 6700 : 					+ GetString ("HIDDEN_OS_WRITE_PROTECTION_EXPLANATION")).c_str());
; 6701 : 
; 6702 : 				if (!IsAdmin() && IsUacSupported())

  011f6	e8 00 00 00 00	 call	 _IsAdmin
  011fb	85 c0		 test	 eax, eax
  011fd	75 52		 jne	 SHORT $LN172@MainDialog
  011ff	e8 00 00 00 00	 call	 _IsUacSupported
  01204	85 c0		 test	 eax, eax
  01206	74 49		 je	 SHORT $LN172@MainDialog

; 6703 : 				{
; 6704 : 					// If UAC elevation is needed, we need to elevate the complete wizard process here, because
; 6705 : 					// we will need to switch to the non-sys-device mode, which requires the whole wizard process
; 6706 : 					// to have admin rights.
; 6707 : 
; 6708 : 					CloseSysEncMutex ();

  01208	e8 00 00 00 00	 call	 _CloseSysEncMutex

; 6709 : 
; 6710 : 					if (!ElevateWholeWizardProcess ("/r"))

  0120d	83 ec 18	 sub	 esp, 24			; 00000018H
  01210	8b cc		 mov	 ecx, esp
  01212	68 00 00 00 00	 push	 OFFSET ??_C@_02COKGDMEE@?1r?$AA@
  01217	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0121c	e8 00 00 00 00	 call	 ?ElevateWholeWizardProcess@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ElevateWholeWizardProcess
  01221	83 c4 18	 add	 esp, 24			; 00000018H
  01224	85 c0		 test	 eax, eax
  01226	75 29		 jne	 SHORT $LN172@MainDialog

; 6711 : 					{
; 6712 : 						// Failed to obtain admin rights
; 6713 : 
; 6714 : 						NormalCursor ();

  01228	e8 00 00 00 00	 call	 _NormalCursor

; 6715 : 
; 6716 : 						if (!CreateSysEncMutex ())

  0122d	e8 00 00 00 00	 call	 _CreateSysEncMutex
  01232	85 c0		 test	 eax, eax
  01234	0f 85 0d f2 ff
	ff		 jne	 $LN15@MainDialog

; 6717 : 							AbortProcess ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");

  0123a	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  0123f	e8 00 00 00 00	 call	 _AbortProcess
  01244	83 c4 04	 add	 esp, 4
$ovf_end_10$1527:

; 6074 : 			}
; 6075 : 			return 1;

  01247	b8 01 00 00 00	 mov	 eax, 1
  0124c	e9 5e ee ff ff	 jmp	 $LN1@MainDialog
$LN172@MainDialog:

; 6718 : 
; 6719 : 						return 1;
; 6720 : 					}
; 6721 : 				}
; 6722 : 
; 6723 : 				// This check requires admin rights
; 6724 : 				try
; 6725 : 				{
; 6726 : 					BootEncObj->InitialSecurityChecksForHiddenOS ();

  01251	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  01257	c7 45 fc 1a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 26 ; 0000001aH
  0125e	e8 00 00 00 00	 call	 ?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::InitialSecurityChecksForHiddenOS

; 6733 : 				}
; 6734 : 
; 6735 : 				nNewPageNo = SYSENC_MULTI_BOOT_MODE_PAGE - 1;	// Skip irrelevant pages

  01263	be 05 00 00 00	 mov	 esi, 5

; 8099 : 				}
; 8100 : 				return 1;
; 8101 : 			}
; 8102 : 
; 8103 : 			LoadPage (hwndDlg, nNewPageNo + 1);

  01268	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0126b	50		 push	 eax
  0126c	53		 push	 ebx
  0126d	e8 00 00 00 00	 call	 _LoadPage
  01272	83 c4 08	 add	 esp, 8
$ovf_end_11$1528:

; 6074 : 			}
; 6075 : 			return 1;

  01275	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  01278	e9 32 ee ff ff	 jmp	 $LN1@MainDialog
__catch$_MainDialogProc@16$23:

; 6727 : 				}
; 6728 : 				catch (Exception &e)
; 6729 : 				{
; 6730 : 					e.Show (hwndDlg);

  0127d	8b 8d dc 2c ff
	ff		 mov	 ecx, DWORD PTR _e$6[ebp]
  01283	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  01289	8b 01		 mov	 eax, DWORD PTR [ecx]
  0128b	ff 10		 call	 DWORD PTR [eax]

; 6731 : 					EndMainDlg (MainDlg);	// Some of the checks need the wizard to be restarted (results are cached until exit and the checks would fail even if the issues were rectified).

  0128d	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  01293	e8 00 00 00 00	 call	 _EndMainDlg
  01298	83 c4 04	 add	 esp, 4

; 6732 : 					return 1;

  0129b	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  012a0	c3		 ret	 0
__catch$_MainDialogProc@16$21:

; 6684 : 				}
; 6685 : 				catch (Exception &e)
; 6686 : 				{
; 6687 : 					e.Show (hwndDlg);

  012a1	8b 8d e0 2c ff
	ff		 mov	 ecx, DWORD PTR _e$7[ebp]
  012a7	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  012ad	8b 01		 mov	 eax, DWORD PTR [ecx]
  012af	ff 10		 call	 DWORD PTR [eax]

; 6688 : 					NormalCursor ();

  012b1	e8 00 00 00 00	 call	 _NormalCursor

; 6689 : 					return 1;

  012b6	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  012bb	c3		 ret	 0
$LN166@MainDialog:

; 6736 : 			}
; 6737 : 			else if (nCurPageNo == SYSENC_SPAN_PAGE)

  012bc	83 f8 03	 cmp	 eax, 3
  012bf	0f 85 bb 01 00
	00		 jne	 $LN175@MainDialog

; 6738 : 			{
; 6739 : 				try
; 6740 : 				{
; 6741 : 					if (bWholeSysDrive && !BootEncObj->SystemPartitionCoversWholeDrive())

  012c5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
  012cc	c7 45 fc 1c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 28 ; 0000001cH
  012d3	0f 84 38 01 00
	00		 je	 $LN1339@MainDialog
  012d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  012df	e8 00 00 00 00	 call	 ?SystemPartitionCoversWholeDrive@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemPartitionCoversWholeDrive
  012e4	84 c0		 test	 al, al
  012e6	0f 85 17 01 00
	00		 jne	 $LN183@MainDialog

; 6742 : 					{
; 6743 : 						if (BootEncObj->SystemDriveContainsNonStandardPartitions())

  012ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  012f2	e8 00 00 00 00	 call	 ?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemDriveContainsNonStandardPartitions
  012f7	84 c0		 test	 al, al
  012f9	0f 84 a6 00 00
	00		 je	 $LN180@MainDialog

; 6744 : 						{
; 6745 : 							if (AskWarnYesNoString ((wstring (GetString ("SYSDRIVE_NON_STANDARD_PARTITIONS")) + L"\n\n" + GetString ("ASK_ENCRYPT_PARTITION_INSTEAD_OF_DRIVE")).c_str()) == IDYES)

  012ff	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@CKHHFLEI@SYSDRIVE_NON_STANDARD_PARTITIONS@
  01304	e8 00 00 00 00	 call	 _GetString
  01309	83 c4 04	 add	 esp, 4
  0130c	8d 8d 58 32 ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  01312	50		 push	 eax
  01313	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  01318	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  0131d	50		 push	 eax
  0131e	8d 85 70 32 ff
	ff		 lea	 eax, DWORD PTR $T47[ebp]
  01324	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+12], 29 ; 0000001dH
  01328	50		 push	 eax
  01329	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0132e	83 c4 0c	 add	 esp, 12			; 0000000cH
  01331	8b f0		 mov	 esi, eax
  01333	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@KNBCDPOB@ASK_ENCRYPT_PARTITION_INSTEAD_OF@
  01338	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+12], 30 ; 0000001eH
  0133c	e8 00 00 00 00	 call	 _GetString
  01341	50		 push	 eax
  01342	8d 85 88 32 ff
	ff		 lea	 eax, DWORD PTR $T48[ebp]
  01348	56		 push	 esi
  01349	50		 push	 eax
  0134a	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0134f	83 c4 10	 add	 esp, 16			; 00000010H
  01352	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  01356	72 02		 jb	 SHORT $LN958@MainDialog
  01358	8b 00		 mov	 eax, DWORD PTR [eax]
$LN958@MainDialog:
  0135a	50		 push	 eax
  0135b	e8 00 00 00 00	 call	 _AskWarnYesNoString
  01360	83 c4 04	 add	 esp, 4
  01363	8d 8d 88 32 ff
	ff		 lea	 ecx, DWORD PTR $T48[ebp]
  01369	83 f8 06	 cmp	 eax, 6
  0136c	0f 94 c3	 sete	 bl
  0136f	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  01374	8d 8d 70 32 ff
	ff		 lea	 ecx, DWORD PTR $T47[ebp]
  0137a	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0137f	8d 8d 58 32 ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  01385	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+12], 28 ; 0000001cH
  01389	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0138e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bWholeSysDrive@@3HA ; bWholeSysDrive
  01393	33 c9		 xor	 ecx, ecx
  01395	84 db		 test	 bl, bl
  01397	8b 9d 60 2d ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0139d	0f 45 c1	 cmovne	 eax, ecx
  013a0	a3 00 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, eax ; bWholeSysDrive
$LN180@MainDialog:

; 6746 : 								bWholeSysDrive = FALSE;
; 6747 : 						}
; 6748 : 
; 6749 : 						if (!IsOSAtLeast (WIN_VISTA) && bWholeSysDrive)

  013a5	6a 0b		 push	 11			; 0000000bH
  013a7	e8 00 00 00 00	 call	 _IsOSAtLeast
  013ac	83 c4 04	 add	 esp, 4
  013af	85 c0		 test	 eax, eax
  013b1	75 50		 jne	 SHORT $LN183@MainDialog
  013b3	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, eax ; bWholeSysDrive
  013b9	74 56		 je	 SHORT $LN1339@MainDialog

; 6750 : 						{
; 6751 : 							if (BootEncObj->SystemDriveContainsExtendedPartition())

  013bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  013c1	e8 00 00 00 00	 call	 ?SystemDriveContainsExtendedPartition@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemDriveContainsExtendedPartition
  013c6	84 c0		 test	 al, al
  013c8	74 2c		 je	 SHORT $LN182@MainDialog

; 6752 : 							{
; 6753 : 								Error ("WDE_UNSUPPORTED_FOR_EXTENDED_PARTITIONS");

  013ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HLDNCEMH@WDE_UNSUPPORTED_FOR_EXTENDED_PAR@
  013cf	e8 00 00 00 00	 call	 _Error

; 6754 : 
; 6755 : 								if (AskYesNo ("ASK_ENCRYPT_PARTITION_INSTEAD_OF_DRIVE") == IDNO)

  013d4	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@KNBCDPOB@ASK_ENCRYPT_PARTITION_INSTEAD_OF@
  013d9	e8 00 00 00 00	 call	 _AskYesNo
  013de	83 c4 08	 add	 esp, 8
  013e1	83 f8 07	 cmp	 eax, 7
  013e4	0f 84 5d f0 ff
	ff		 je	 $LN15@MainDialog

; 6756 : 									return 1;
; 6757 : 
; 6758 : 								bWholeSysDrive = FALSE;

  013ea	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive

; 6759 : 							}
; 6760 : 							else

  013f4	eb 1b		 jmp	 SHORT $LN1339@MainDialog
$LN182@MainDialog:

; 6761 : 								Warning ("WDE_EXTENDED_PARTITIONS_WARNING");

  013f6	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DBKKOPEJ@WDE_EXTENDED_PARTITIONS_WARNING?$AA@
  013fb	e8 00 00 00 00	 call	 _Warning
  01400	83 c4 04	 add	 esp, 4
$LN183@MainDialog:

; 6762 : 						}
; 6763 : 					}
; 6764 : 
; 6765 : 					if (!bWholeSysDrive && BootEncObj->SystemPartitionCoversWholeDrive())

  01403	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bWholeSysDrive@@3HA ; bWholeSysDrive
  01409	85 c9		 test	 ecx, ecx
  0140b	0f 85 63 02 00
	00		 jne	 $LN1474@MainDialog
$LN1339@MainDialog:
  01411	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  01417	e8 00 00 00 00	 call	 ?SystemPartitionCoversWholeDrive@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemPartitionCoversWholeDrive
  0141c	84 c0		 test	 al, al
  0141e	74 1d		 je	 SHORT $LN1422@MainDialog

; 6766 : 						bWholeSysDrive = (AskYesNo ("WHOLE_SYC_DEVICE_RECOM") == IDYES);

  01420	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@HHEGHILA@WHOLE_SYC_DEVICE_RECOM?$AA@
  01425	e8 00 00 00 00	 call	 _AskYesNo
  0142a	33 c9		 xor	 ecx, ecx
  0142c	83 c4 04	 add	 esp, 4
  0142f	83 f8 06	 cmp	 eax, 6
  01432	0f 94 c1	 sete	 cl
  01435	89 0d 00 00 00
	00		 mov	 DWORD PTR ?bWholeSysDrive@@3HA, ecx ; bWholeSysDrive
  0143b	eb 06		 jmp	 SHORT $LN185@MainDialog
$LN1422@MainDialog:
  0143d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bWholeSysDrive@@3HA ; bWholeSysDrive
$LN185@MainDialog:

; 6773 : 				}
; 6774 : 
; 6775 : 				if (!bWholeSysDrive)

  01443	85 c9		 test	 ecx, ecx
  01445	0f 85 29 02 00
	00		 jne	 $LN1474@MainDialog

; 6776 : 					nNewPageNo = SYSENC_MULTI_BOOT_MODE_PAGE - 1;	// Skip irrelevant pages

  0144b	be 05 00 00 00	 mov	 esi, 5

; 8099 : 				}
; 8100 : 				return 1;
; 8101 : 			}
; 8102 : 
; 8103 : 			LoadPage (hwndDlg, nNewPageNo + 1);

  01450	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  01453	50		 push	 eax
  01454	53		 push	 ebx
  01455	e8 00 00 00 00	 call	 _LoadPage
  0145a	83 c4 08	 add	 esp, 8
$ovf_end_12$1529:

; 6074 : 			}
; 6075 : 			return 1;

  0145d	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  01460	e9 4a ec ff ff	 jmp	 $LN1@MainDialog
__catch$_MainDialogProc@16$25:

; 6767 : 				}
; 6768 : 				catch (Exception &e)
; 6769 : 				{
; 6770 : 					e.Show (hwndDlg);

  01465	8b 8d e4 2c ff
	ff		 mov	 ecx, DWORD PTR _e$8[ebp]
  0146b	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  01471	8b 01		 mov	 eax, DWORD PTR [ecx]
  01473	ff 10		 call	 DWORD PTR [eax]

; 6771 : 					NormalCursor ();

  01475	e8 00 00 00 00	 call	 _NormalCursor

; 6772 : 					return 1;

  0147a	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  0147f	c3		 ret	 0
$LN175@MainDialog:

; 6777 : 			}
; 6778 : 			else if (nCurPageNo == SYSENC_PRE_DRIVE_ANALYSIS_PAGE)

  01480	83 f8 04	 cmp	 eax, 4
  01483	75 64		 jne	 SHORT $LN187@MainDialog

; 6779 : 			{
; 6780 : 				if ((SysEncDetectHiddenSectors = Get2RadButtonPageAnswer()) != 1)

  01485	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  0148a	a3 00 00 00 00	 mov	 DWORD PTR ?SysEncDetectHiddenSectors@@3HA, eax ; SysEncDetectHiddenSectors
  0148f	83 f8 01	 cmp	 eax, 1
  01492	0f 84 dc 01 00
	00		 je	 $LN1474@MainDialog

; 6781 : 				{
; 6782 : 					// Skip drive analysis
; 6783 : 					nNewPageNo = SYSENC_DRIVE_ANALYSIS_PAGE;
; 6784 : 
; 6785 : 					// If the user had already searched for hidden sectors, we must clear (invalidate) the
; 6786 : 					// result because now he changed his mind and no longer wishes to encrypt the hidden sectors.
; 6787 : 					try
; 6788 : 					{
; 6789 : 						BootEncObj->InvalidateCachedSysDriveProperties ();

  01498	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0149e	be 05 00 00 00	 mov	 esi, 5
  014a3	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 32 ; 00000020H
  014aa	e8 00 00 00 00	 call	 ?InvalidateCachedSysDriveProperties@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::InvalidateCachedSysDriveProperties

; 8099 : 				}
; 8100 : 				return 1;
; 8101 : 			}
; 8102 : 
; 8103 : 			LoadPage (hwndDlg, nNewPageNo + 1);

  014af	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  014b2	50		 push	 eax
  014b3	53		 push	 ebx
  014b4	e8 00 00 00 00	 call	 _LoadPage
  014b9	83 c4 08	 add	 esp, 8
$ovf_end_13$1530:

; 6074 : 			}
; 6075 : 			return 1;

  014bc	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  014bf	e9 eb eb ff ff	 jmp	 $LN1@MainDialog
__catch$_MainDialogProc@16$27:

; 6790 : 					}
; 6791 : 					catch (Exception &e)
; 6792 : 					{
; 6793 : 						e.Show (MainDlg);

  014c4	8b 8d e8 2c ff
	ff		 mov	 ecx, DWORD PTR _e$9[ebp]
  014ca	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  014d0	8b 01		 mov	 eax, DWORD PTR [ecx]
  014d2	ff 10		 call	 DWORD PTR [eax]

; 6794 : 						EndMainDlg (MainDlg);

  014d4	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  014da	e8 00 00 00 00	 call	 _EndMainDlg
  014df	83 c4 04	 add	 esp, 4

; 6795 : 						exit(0);

  014e2	6a 00		 push	 0
  014e4	e8 00 00 00 00	 call	 _exit
$LN1516@MainDialog:
$LN187@MainDialog:

; 6796 : 					}
; 6797 : 				}
; 6798 : 			}
; 6799 : 			else if (nCurPageNo == SYSENC_MULTI_BOOT_MODE_PAGE)

  014e9	83 f8 06	 cmp	 eax, 6
  014ec	0f 85 4d 01 00
	00		 jne	 $LN191@MainDialog

; 6800 : 			{
; 6801 : 				if (nMultiBoot > 1)

  014f2	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?nMultiBoot@@3HA, 1 ; nMultiBoot
  014f9	7e 4c		 jle	 SHORT $LN196@MainDialog

; 6802 : 				{
; 6803 : 					// Multi-boot 
; 6804 : 
; 6805 : 					if (AskWarnNoYes ("MULTI_BOOT_FOR_ADVANCED_ONLY") == IDNO)

  014fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@EDCHAEND@MULTI_BOOT_FOR_ADVANCED_ONLY?$AA@
  01500	e8 00 00 00 00	 call	 _AskWarnNoYes
  01505	83 c4 04	 add	 esp, 4
  01508	83 f8 07	 cmp	 eax, 7
  0150b	0f 84 36 ef ff
	ff		 je	 $LN15@MainDialog

; 6806 : 						return 1;
; 6807 : 
; 6808 : 					if (bHiddenOS)

  01511	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  01518	0f 84 fe 00 00
	00		 je	 $LN197@MainDialog

; 6809 : 					{
; 6810 : 						if (AskWarnNoYes ("HIDDEN_OS_MULTI_BOOT") == IDNO)

  0151e	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OEFLIJFC@HIDDEN_OS_MULTI_BOOT?$AA@
  01523	e8 00 00 00 00	 call	 _AskWarnNoYes
  01528	83 c4 04	 add	 esp, 4
  0152b	83 f8 07	 cmp	 eax, 7
  0152e	75 17		 jne	 SHORT $LN196@MainDialog

; 6811 : 						{
; 6812 : 							Error ("UNSUPPORTED_HIDDEN_OS_MULTI_BOOT_CFG");

  01530	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PJBIBHBE@UNSUPPORTED_HIDDEN_OS_MULTI_BOOT@
  01535	e8 00 00 00 00	 call	 _Error
  0153a	83 c4 04	 add	 esp, 4
$ovf_end_14$1531:

; 6074 : 			}
; 6075 : 			return 1;

  0153d	b8 01 00 00 00	 mov	 eax, 1
  01542	e9 68 eb ff ff	 jmp	 $LN1@MainDialog
$LN196@MainDialog:

; 6813 : 							return 1;
; 6814 : 						}
; 6815 : 					}
; 6816 : 				}
; 6817 : 
; 6818 : 				if (bHiddenOS)

  01547	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  0154e	0f 84 c8 00 00
	00		 je	 $LN197@MainDialog

; 6819 : 				{
; 6820 : 					if (IsOSAtLeast (WIN_7)
; 6821 : 						&& BootEncObj->GetSystemDriveConfiguration().ExtraBootPartitionPresent
; 6822 : 						&& AskWarnYesNo ("CONFIRM_HIDDEN_OS_EXTRA_BOOT_PARTITION") == IDNO)

  01554	6a 0d		 push	 13			; 0000000dH
  01556	e8 00 00 00 00	 call	 _IsOSAtLeast
  0155b	83 c4 04	 add	 esp, 4
  0155e	85 c0		 test	 eax, eax
  01560	74 3e		 je	 SHORT $LN526@MainDialog
  01562	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  01568	8d 85 b0 2e ff
	ff		 lea	 eax, DWORD PTR $T34[ebp]
  0156e	50		 push	 eax
  0156f	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  01574	c7 85 58 2d ff
	ff 01 00 00 00	 mov	 DWORD PTR $T31[ebp], 1
  0157e	80 b8 a8 00 00
	00 00		 cmp	 BYTE PTR [eax+168], 0
  01585	74 19		 je	 SHORT $LN526@MainDialog
  01587	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@PDMBGJBN@CONFIRM_HIDDEN_OS_EXTRA_BOOT_PAR@
  0158c	e8 00 00 00 00	 call	 _AskWarnYesNo
  01591	83 c4 04	 add	 esp, 4
  01594	c6 85 67 2d ff
	ff 01		 mov	 BYTE PTR $T32[ebp], 1
  0159b	83 f8 07	 cmp	 eax, 7
  0159e	74 07		 je	 SHORT $LN527@MainDialog
$LN526@MainDialog:
  015a0	c6 85 67 2d ff
	ff 00		 mov	 BYTE PTR $T32[ebp], 0
$LN527@MainDialog:
  015a7	f6 85 58 2d ff
	ff 01		 test	 BYTE PTR $T31[ebp], 1
  015ae	74 0b		 je	 SHORT $LN610@MainDialog
  015b0	8d 8d b0 2e ff
	ff		 lea	 ecx, DWORD PTR $T34[ebp]
  015b6	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
$LN610@MainDialog:
  015bb	80 bd 67 2d ff
	ff 00		 cmp	 BYTE PTR $T32[ebp], 0
  015c2	74 19		 je	 SHORT $LN199@MainDialog

; 6823 : 					{
; 6824 : 						TextInfoDialogBox (GST_TBXID_EXTRA_BOOT_PARTITION_REMOVAL_INSTRUCTIONS);

  015c4	6a 04		 push	 4
  015c6	e8 00 00 00 00	 call	 _TextInfoDialogBox
  015cb	83 c4 04	 add	 esp, 4

; 6825 : 						NormalCursor ();

  015ce	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_15$1532:

; 6074 : 			}
; 6075 : 			return 1;

  015d3	b8 01 00 00 00	 mov	 eax, 1
  015d8	e9 d2 ea ff ff	 jmp	 $LN1@MainDialog
$LN199@MainDialog:

; 6826 : 						return 1;
; 6827 : 					}
; 6828 : 
; 6829 : 					if (AskWarnYesNo ("DECOY_OS_REQUIREMENTS") == IDNO)

  015dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HEENEHGK@DECOY_OS_REQUIREMENTS?$AA@
  015e2	e8 00 00 00 00	 call	 _AskWarnYesNo
  015e7	83 c4 04	 add	 esp, 4
  015ea	83 f8 07	 cmp	 eax, 7
  015ed	0f 85 3f 01 00
	00		 jne	 $LN200@MainDialog

; 6925 : 					{
; 6926 : 						NormalCursor ();

  015f3	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_16$1533:

; 6074 : 			}
; 6075 : 			return 1;

  015f8	b8 01 00 00 00	 mov	 eax, 1
  015fd	e9 ad ea ff ff	 jmp	 $LN1@MainDialog
$LN201@MainDialog:

; 6830 : 					{
; 6831 : 						NormalCursor ();
; 6832 : 						return 1;
; 6833 : 					}
; 6834 : 
; 6835 : 					if (!ChangeWizardMode (WIZARD_MODE_NONSYS_DEVICE))
; 6836 : 					{
; 6837 : 						NormalCursor ();
; 6838 : 						return 1;
; 6839 : 					}
; 6840 : 
; 6841 : 					// Skip irrelevant pages
; 6842 : 					nNewPageNo = HIDDEN_VOL_HOST_PRE_CIPHER_PAGE - 1;

  01602	be 0f 00 00 00	 mov	 esi, 15			; 0000000fH

; 8099 : 				}
; 8100 : 				return 1;
; 8101 : 			}
; 8102 : 
; 8103 : 			LoadPage (hwndDlg, nNewPageNo + 1);

  01607	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0160a	50		 push	 eax
  0160b	53		 push	 ebx
  0160c	e8 00 00 00 00	 call	 _LoadPage
  01611	83 c4 08	 add	 esp, 8
$ovf_end_17$1534:

; 6074 : 			}
; 6075 : 			return 1;

  01614	8d 46 f2	 lea	 eax, DWORD PTR [esi-14]
  01617	e9 93 ea ff ff	 jmp	 $LN1@MainDialog
$LN197@MainDialog:

; 6843 : 				}
; 6844 : 				else if (nMultiBoot <= 1)

  0161c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?nMultiBoot@@3HA, 1 ; nMultiBoot
  01623	7f 4f		 jg	 SHORT $LN1474@MainDialog

; 6845 : 				{
; 6846 : 					// Single-boot (not creating a hidden OS)
; 6847 : 					
; 6848 : 					// Skip irrelevant pages
; 6849 : 					nNewPageNo = CIPHER_PAGE - 1;

  01625	be 11 00 00 00	 mov	 esi, 17			; 00000011H

; 8099 : 				}
; 8100 : 				return 1;
; 8101 : 			}
; 8102 : 
; 8103 : 			LoadPage (hwndDlg, nNewPageNo + 1);

  0162a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0162d	50		 push	 eax
  0162e	53		 push	 ebx
  0162f	e8 00 00 00 00	 call	 _LoadPage
  01634	83 c4 08	 add	 esp, 8
$ovf_end_18$1535:

; 6074 : 			}
; 6075 : 			return 1;

  01637	8d 46 f0	 lea	 eax, DWORD PTR [esi-16]
  0163a	e9 70 ea ff ff	 jmp	 $LN1@MainDialog
$LN191@MainDialog:

; 6850 : 				}
; 6851 : 			}
; 6852 : 			else if (nCurPageNo == SYSENC_MULTI_BOOT_SYS_EQ_BOOT_PAGE)

  0163f	83 f8 07	 cmp	 eax, 7
  01642	75 18		 jne	 SHORT $LN203@MainDialog

; 6853 : 			{
; 6854 : 				SysEncMultiBootCfg.SystemOnBootDrive = Get2RadButtonPageAnswer ();

  01644	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  01649	a3 10 00 00 00	 mov	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A+16, eax

; 6855 : 
; 6856 : 				if (!SysEncMultiBootCfg.SystemOnBootDrive)

  0164e	85 c0		 test	 eax, eax
  01650	75 22		 jne	 SHORT $LN1474@MainDialog

; 6857 : 				{
; 6858 : 					Error ("SYS_PARTITION_MUST_BE_ON_BOOT_DRIVE");

  01652	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@BLBEBHP@SYS_PARTITION_MUST_BE_ON_BOOT_DR@

; 6859 : 					EndMainDlg (MainDlg);
; 6860 : 					return 1;

  01657	e9 b7 f2 ff ff	 jmp	 $LN1498@MainDialog
$LN203@MainDialog:

; 6861 : 				}
; 6862 : 			}
; 6863 : 			else if (nCurPageNo == SYSENC_MULTI_BOOT_NBR_SYS_DRIVES_PAGE)

  0165c	83 f8 08	 cmp	 eax, 8
  0165f	75 4d		 jne	 SHORT $LN206@MainDialog

; 6864 : 			{
; 6865 : 				if (Get2RadButtonPageAnswer () == 0)

  01661	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  01666	85 c0		 test	 eax, eax
  01668	75 27		 jne	 SHORT $LN208@MainDialog

; 6866 : 				{
; 6867 : 					// 2 or more drives contain an OS
; 6868 : 
; 6869 : 					SysEncMultiBootCfg.NumberOfSysDrives = 2;		

  0166a	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A, 2
$LN1474@MainDialog:
  01674	8b b5 6c 2d ff
	ff		 mov	 esi, DWORD PTR _nNewPageNo$1$[ebp]
$LN310@MainDialog:

; 8099 : 				}
; 8100 : 				return 1;
; 8101 : 			}
; 8102 : 
; 8103 : 			LoadPage (hwndDlg, nNewPageNo + 1);

  0167a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0167d	50		 push	 eax
  0167e	53		 push	 ebx
  0167f	e8 00 00 00 00	 call	 _LoadPage
  01684	83 c4 08	 add	 esp, 8
$ovf_end_19$1536:

; 6074 : 			}
; 6075 : 			return 1;

  01687	b8 01 00 00 00	 mov	 eax, 1
  0168c	e9 1e ea ff ff	 jmp	 $LN1@MainDialog
$LN208@MainDialog:

; 6870 : 				}
; 6871 : 				else if (Get2RadButtonPageAnswer () == 1)

  01691	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  01696	83 f8 01	 cmp	 eax, 1
  01699	75 d9		 jne	 SHORT $LN1474@MainDialog

; 6872 : 				{
; 6873 : 					// Only 1 drive contains an OS
; 6874 : 
; 6875 : 					SysEncMultiBootCfg.NumberOfSysDrives = 1;		
; 6876 : 
; 6877 : 					if (bWholeSysDrive)

  0169b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
  016a2	a3 00 00 00 00	 mov	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A, eax
  016a7	75 21		 jne	 SHORT $LN1504@MainDialog

; 6878 : 					{
; 6879 : 						// Whole-system-drive encryption is currently not supported if the drive contains
; 6880 : 						// more than one system
; 6881 : 						Error ("WDE_UNSUPPORTED_FOR_MULTIPLE_SYSTEMS_ON_ONE_DRIVE");
; 6882 : 						return 1;
; 6883 : 					}
; 6884 : 
; 6885 : 					// Ask whether there is a non-Windows boot loader in the MBR
; 6886 : 					nNewPageNo = SYSENC_MULTI_BOOT_NONWIN_BOOT_LOADER_PAGE - 1;

  016a9	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 6887 : 				}
; 6888 : 			}

  016ac	eb cc		 jmp	 SHORT $LN310@MainDialog
$LN206@MainDialog:

; 6889 : 			else if (nCurPageNo == SYSENC_MULTI_BOOT_ADJACENT_SYS_PAGE)

  016ae	83 f8 09	 cmp	 eax, 9
  016b1	75 2e		 jne	 SHORT $LN212@MainDialog

; 6890 : 			{
; 6891 : 				SysEncMultiBootCfg.MultipleSystemsOnDrive = Get2RadButtonPageAnswer ();

  016b3	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  016b8	a3 04 00 00 00	 mov	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A+4, eax

; 6892 : 
; 6893 : 				if (SysEncMultiBootCfg.MultipleSystemsOnDrive && bWholeSysDrive)

  016bd	85 c0		 test	 eax, eax
  016bf	74 b3		 je	 SHORT $LN1474@MainDialog
  016c1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
  016c8	74 aa		 je	 SHORT $LN1474@MainDialog
$LN1504@MainDialog:

; 6894 : 				{
; 6895 : 					// Whole-system-drive encryption is currently not supported if the drive contains
; 6896 : 					// more than one system
; 6897 : 					Error ("WDE_UNSUPPORTED_FOR_MULTIPLE_SYSTEMS_ON_ONE_DRIVE");

  016ca	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@EAFFGLI@WDE_UNSUPPORTED_FOR_MULTIPLE_SYS@
  016cf	e8 00 00 00 00	 call	 _Error
  016d4	83 c4 04	 add	 esp, 4
$ovf_end_20$1537:

; 6074 : 			}
; 6075 : 			return 1;

  016d7	b8 01 00 00 00	 mov	 eax, 1
  016dc	e9 ce e9 ff ff	 jmp	 $LN1@MainDialog
$LN212@MainDialog:

; 6898 : 					return 1;
; 6899 : 				}
; 6900 : 			}
; 6901 : 
; 6902 : 			else if (nCurPageNo == SYSENC_MULTI_BOOT_NONWIN_BOOT_LOADER_PAGE)

  016e1	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  016e4	75 3a		 jne	 SHORT $LN215@MainDialog

; 6903 : 			{
; 6904 : 				SysEncMultiBootCfg.BootLoaderBrand = Get2RadButtonPageAnswer ();

  016e6	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  016eb	a3 0c 00 00 00	 mov	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A+12, eax

; 6905 : 
; 6906 : 				if (SysEncMultiBootCfg.BootLoaderBrand)

  016f0	85 c0		 test	 eax, eax
  016f2	74 0a		 je	 SHORT $LN217@MainDialog

; 6907 : 				{
; 6908 : 					// A non-Windows boot manager in the MBR
; 6909 : 					Error ("CUSTOM_BOOT_MANAGERS_IN_MBR_UNSUPPORTED");

  016f4	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KANLNDNO@CUSTOM_BOOT_MANAGERS_IN_MBR_UNSU@

; 6910 : 					EndMainDlg (MainDlg);
; 6911 : 					return 1;

  016f9	e9 15 f2 ff ff	 jmp	 $LN1498@MainDialog
$LN217@MainDialog:

; 6912 : 				}
; 6913 : 				else
; 6914 : 				{
; 6915 : 					// Either a standard Windows boot manager or no boot manager
; 6916 : 					wcscpy_s (SysEncMultiBootCfgOutcome, sizeof(SysEncMultiBootCfgOutcome) / 2, GetString ("WINDOWS_BOOT_LOADER_HINTS"));

  016fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@EHEECKKC@WINDOWS_BOOT_LOADER_HINTS?$AA@
  01703	e8 00 00 00 00	 call	 _GetString
  01708	50		 push	 eax
  01709	68 00 10 00 00	 push	 4096			; 00001000H
  0170e	68 00 00 00 00	 push	 OFFSET ?SysEncMultiBootCfgOutcome@@3PA_WA ; SysEncMultiBootCfgOutcome
  01713	e8 00 00 00 00	 call	 _wcscpy_s
  01718	83 c4 10	 add	 esp, 16			; 00000010H

; 6917 : 				}

  0171b	e9 54 ff ff ff	 jmp	 $LN1474@MainDialog
$LN215@MainDialog:

; 6918 : 			}
; 6919 : 
; 6920 : 			else if (nCurPageNo == SYSENC_MULTI_BOOT_OUTCOME_PAGE)

  01720	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  01723	75 2e		 jne	 SHORT $LN219@MainDialog

; 6921 : 			{
; 6922 : 				if (bHiddenOS)

  01725	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  0172c	0f 84 54 05 00
	00		 je	 $LN265@MainDialog
$LN200@MainDialog:

; 6923 : 				{
; 6924 : 					if (!ChangeWizardMode (WIZARD_MODE_NONSYS_DEVICE))

  01732	6a 01		 push	 1
  01734	e8 00 00 00 00	 call	 ?ChangeWizardMode@@YAHH@Z ; ChangeWizardMode
  01739	83 c4 04	 add	 esp, 4
  0173c	85 c0		 test	 eax, eax
  0173e	0f 85 be fe ff
	ff		 jne	 $LN201@MainDialog
$LN1291@MainDialog:

; 6925 : 					{
; 6926 : 						NormalCursor ();

  01744	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_21$1538:

; 6074 : 			}
; 6075 : 			return 1;

  01749	b8 01 00 00 00	 mov	 eax, 1
  0174e	e9 5c e9 ff ff	 jmp	 $LN1@MainDialog
$LN219@MainDialog:

; 6927 : 						return 1;
; 6928 : 					}
; 6929 : 
; 6930 : 					nNewPageNo = HIDDEN_VOL_HOST_PRE_CIPHER_PAGE - 1;		// Skip irrelevant pages
; 6931 : 				}
; 6932 : 				else
; 6933 : 					nNewPageNo = CIPHER_PAGE - 1;	// Skip irrelevant pages
; 6934 : 			}
; 6935 : 
; 6936 : 			else if (nCurPageNo == VOLUME_TYPE_PAGE)

  01753	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  01756	0f 85 a4 00 00
	00		 jne	 $LN224@MainDialog

; 6937 : 			{
; 6938 : 				if (IsButtonChecked (GetDlgItem (hCurPage, IDC_HIDDEN_VOL)))

  0175c	68 08 04 00 00	 push	 1032			; 00000408H
  01761	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01767	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0176d	50		 push	 eax
  0176e	e8 00 00 00 00	 call	 _IsButtonChecked
  01773	83 c4 04	 add	 esp, 4
  01776	85 c0		 test	 eax, eax
  01778	74 5e		 je	 SHORT $LN226@MainDialog

; 6939 : 				{
; 6940 : 					if (!IsAdmin() && !IsUacSupported ()
; 6941 : 						&& IDNO == MessageBoxW (hwndDlg, GetString ("ADMIN_PRIVILEGES_WARN_HIDVOL"),

  0177a	e8 00 00 00 00	 call	 _IsAdmin
  0177f	85 c0		 test	 eax, eax
  01781	75 32		 jne	 SHORT $LN228@MainDialog
  01783	e8 00 00 00 00	 call	 _IsUacSupported
  01788	85 c0		 test	 eax, eax
  0178a	75 29		 jne	 SHORT $LN228@MainDialog
  0178c	68 34 01 00 00	 push	 308			; 00000134H
  01791	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  01797	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DOPCDKC@ADMIN_PRIVILEGES_WARN_HIDVOL?$AA@
  0179c	e8 00 00 00 00	 call	 _GetString
  017a1	83 c4 04	 add	 esp, 4
  017a4	50		 push	 eax
  017a5	53		 push	 ebx
  017a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  017ac	83 f8 07	 cmp	 eax, 7
  017af	0f 84 92 ec ff
	ff		 je	 $LN15@MainDialog
$LN228@MainDialog:

; 6942 : 						lpszTitle, MB_ICONWARNING|MB_YESNO|MB_DEFBUTTON2))
; 6943 : 					{
; 6944 : 						return 1;
; 6945 : 					}
; 6946 : 					else
; 6947 : 					{
; 6948 : 						bHiddenVol = TRUE;

  017b5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bHiddenVol@@3HC, 1 ; bHiddenVol

; 6949 : 						bHiddenVolHost = TRUE;

  017bf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bHiddenVolHost, 1

; 6950 : 						bInPlaceEncNonSys = FALSE;

  017c9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0

; 6951 : 					}
; 6952 : 				}
; 6953 : 				else

  017d3	e9 9c fe ff ff	 jmp	 $LN1474@MainDialog
$LN226@MainDialog:

; 6954 : 				{
; 6955 : 					bHiddenVol = FALSE;

  017d8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol

; 6956 : 					bHiddenVolHost = FALSE;
; 6957 : 					bHiddenVolDirect = FALSE;
; 6958 : 					nNewPageNo = VOLUME_LOCATION_PAGE - 1;		// Skip the hidden volume creation wizard mode selection

  017e2	be 0d 00 00 00	 mov	 esi, 13			; 0000000dH
  017e7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHiddenVolHost, 0
  017f1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHiddenVolDirect, 0

; 6959 : 				}

  017fb	e9 7a fe ff ff	 jmp	 $LN310@MainDialog
$LN224@MainDialog:

; 6960 : 			}
; 6961 : 
; 6962 : 			else if (nCurPageNo == HIDDEN_VOL_WIZARD_MODE_PAGE)

  01800	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  01803	0f 85 50 01 00
	00		 jne	 $LN230@MainDialog

; 6963 : 			{
; 6964 : 				if (IsButtonChecked (GetDlgItem (hCurPage, IDC_HIDVOL_WIZ_MODE_DIRECT)))

  01809	68 0c 04 00 00	 push	 1036			; 0000040cH
  0180e	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01814	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0181a	50		 push	 eax
  0181b	e8 00 00 00 00	 call	 _IsButtonChecked
  01820	83 c4 04	 add	 esp, 4
  01823	85 c0		 test	 eax, eax
  01825	74 0f		 je	 SHORT $LN232@MainDialog

; 6965 : 					bHiddenVolDirect = TRUE;

  01827	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bHiddenVolDirect, 1

; 6966 : 				else

  01831	e9 3e fe ff ff	 jmp	 $LN1474@MainDialog
$LN232@MainDialog:

; 6967 : 				{
; 6968 : 					if (IsHiddenOSRunning())

  01836	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  0183b	85 c0		 test	 eax, eax
  0183d	0f 84 07 01 00
	00		 je	 $LN234@MainDialog

; 6969 : 					{
; 6970 : 						WarningDirect ((wstring (GetString ("HIDDEN_VOL_CREATION_UNDER_HIDDEN_OS_HOWTO"))

  01843	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NNPIGIED@HIDDEN_VOL_CREATION_UNDER_HIDDEN@
  01848	e8 00 00 00 00	 call	 _GetString
  0184d	83 c4 04	 add	 esp, 4
  01850	8d 8d 80 34 ff
	ff		 lea	 ecx, DWORD PTR $T69[ebp]
  01856	50		 push	 eax
  01857	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0185c	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  01861	50		 push	 eax
  01862	8d 85 e0 31 ff
	ff		 lea	 eax, DWORD PTR $T41[ebp]
  01868	c7 45 fc 22 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 34 ; 00000022H
  0186f	50		 push	 eax
  01870	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  01875	8b f0		 mov	 esi, eax
  01877	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JPAMOBPC@NOTE_BEGINNING?$AA@
  0187c	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+12], 35 ; 00000023H
  01880	e8 00 00 00 00	 call	 _GetString
  01885	50		 push	 eax
  01886	8d 85 f8 31 ff
	ff		 lea	 eax, DWORD PTR $T42[ebp]
  0188c	56		 push	 esi
  0188d	50		 push	 eax
  0188e	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  01893	8b f0		 mov	 esi, eax
  01895	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LFCLDECM@HIDDEN_OS_WRITE_PROTECTION_BRIEF@
  0189a	c6 45 fc 24	 mov	 BYTE PTR __$EHRec$[ebp+12], 36 ; 00000024H
  0189e	e8 00 00 00 00	 call	 _GetString
  018a3	50		 push	 eax
  018a4	8d 85 10 32 ff
	ff		 lea	 eax, DWORD PTR $T43[ebp]
  018aa	56		 push	 esi
  018ab	50		 push	 eax
  018ac	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  018b1	68 00 00 00 00	 push	 OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  018b6	50		 push	 eax
  018b7	8d 85 28 32 ff
	ff		 lea	 eax, DWORD PTR $T44[ebp]
  018bd	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+12], 37 ; 00000025H
  018c1	50		 push	 eax
  018c2	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  018c7	8b f0		 mov	 esi, eax
  018c9	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OILEALFF@HIDDEN_OS_WRITE_PROTECTION_EXPLA@
  018ce	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+12], 38 ; 00000026H
  018d2	e8 00 00 00 00	 call	 _GetString
  018d7	50		 push	 eax
  018d8	8d 85 40 32 ff
	ff		 lea	 eax, DWORD PTR $T45[ebp]
  018de	56		 push	 esi
  018df	50		 push	 eax
  018e0	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  018e5	83 c4 48	 add	 esp, 72			; 00000048H
  018e8	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  018ec	72 02		 jb	 SHORT $LN975@MainDialog
  018ee	8b 00		 mov	 eax, DWORD PTR [eax]
$LN975@MainDialog:
  018f0	50		 push	 eax
  018f1	e8 00 00 00 00	 call	 _WarningDirect
  018f6	83 c4 04	 add	 esp, 4
  018f9	8d 8d 40 32 ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  018ff	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  01904	8d 8d 28 32 ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  0190a	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0190f	8d 8d 10 32 ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  01915	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0191a	8d 8d f8 31 ff
	ff		 lea	 ecx, DWORD PTR $T42[ebp]
  01920	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  01925	8d 8d e0 31 ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  0192b	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  01930	8d 8d 80 34 ff
	ff		 lea	 ecx, DWORD PTR $T69[ebp]
  01936	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 6971 : 							+ L"\n\n"
; 6972 : 							+ GetString ("NOTE_BEGINNING")
; 6973 : 							+ GetString ("HIDDEN_OS_WRITE_PROTECTION_BRIEF_INFO")
; 6974 : 							+ L" "
; 6975 : 							+ GetString ("HIDDEN_OS_WRITE_PROTECTION_EXPLANATION")).c_str());
; 6976 : 						NormalCursor ();

  0193b	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_22$1539:

; 6074 : 			}
; 6075 : 			return 1;

  01940	b8 01 00 00 00	 mov	 eax, 1
  01945	e9 65 e7 ff ff	 jmp	 $LN1@MainDialog
$LN234@MainDialog:

; 6977 : 						return 1;
; 6978 : 					}
; 6979 : 
; 6980 : 					bHiddenVolDirect = FALSE;

  0194a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHiddenVolDirect, 0

; 6981 : 				}

  01954	e9 1b fd ff ff	 jmp	 $LN1474@MainDialog
$LN230@MainDialog:

; 6982 : 			}
; 6983 : 
; 6984 : 			else if (nCurPageNo == VOLUME_LOCATION_PAGE)

  01959	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0195c	0f 85 92 02 00
	00		 jne	 $LN235@MainDialog

; 6985 : 			{
; 6986 : 				BOOL tmpbDevice;
; 6987 : 
; 6988 : 				WaitCursor();

  01962	e8 00 00 00 00	 call	 _WaitCursor

; 6989 : 
; 6990 : 				GetWindowText (GetDlgItem (hCurPage, IDC_COMBO_BOX), szFileName, sizeof (szFileName));

  01967	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0196d	68 05 01 00 00	 push	 261			; 00000105H
  01972	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  01977	68 ea 03 00 00	 push	 1002			; 000003eaH
  0197c	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01982	ff d7		 call	 edi
  01984	50		 push	 eax
  01985	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 6991 : 				RelativePath2Absolute (szFileName);

  0198b	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  01990	e8 00 00 00 00	 call	 _RelativePath2Absolute

; 6992 : 				CreateFullVolumePath (szDiskFile, szFileName, &tmpbDevice);

  01995	8d 85 54 2d ff
	ff		 lea	 eax, DWORD PTR _tmpbDevice$30[ebp]
  0199b	50		 push	 eax
  0199c	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  019a1	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  019a6	e8 00 00 00 00	 call	 _CreateFullVolumePath

; 6993 : 
; 6994 : 				if (tmpbDevice != bDevice)

  019ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bDevice@@3HA ; bDevice
  019b0	83 c4 10	 add	 esp, 16			; 00000010H
  019b3	39 85 54 2d ff
	ff		 cmp	 DWORD PTR _tmpbDevice$30[ebp], eax
  019b9	74 4a		 je	 SHORT $LN239@MainDialog

; 6995 : 				{
; 6996 : 					if (bDevice)

  019bb	85 c0		 test	 eax, eax
  019bd	74 1c		 je	 SHORT $LN238@MainDialog

; 6997 : 					{
; 6998 : 						// Not a valid device path
; 6999 : 						Error ("CANNOT_CALC_SPACE");

  019bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@LBACDGOD@CANNOT_CALC_SPACE?$AA@
  019c4	e8 00 00 00 00	 call	 _Error
  019c9	83 c4 04	 add	 esp, 4

; 7000 : 						NormalCursor ();

  019cc	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_23$1540:

; 6074 : 			}
; 6075 : 			return 1;

  019d1	b8 01 00 00 00	 mov	 eax, 1
  019d6	e9 d4 e6 ff ff	 jmp	 $LN1@MainDialog
$LN238@MainDialog:

; 7001 : 						return 1;
; 7002 : 					}
; 7003 : 					else
; 7004 : 					{
; 7005 : 						if (AskWarnYesNo ("DEVICE_SELECTED_IN_NON_DEVICE_MODE") == IDNO)

  019db	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DKKKPMLO@DEVICE_SELECTED_IN_NON_DEVICE_MO@
  019e0	e8 00 00 00 00	 call	 _AskWarnYesNo
  019e5	83 c4 04	 add	 esp, 4
  019e8	83 f8 07	 cmp	 eax, 7
  019eb	0f 84 53 fd ff
	ff		 je	 $LN1291@MainDialog

; 7006 : 						{
; 7007 : 							NormalCursor ();
; 7008 : 							return 1;
; 7009 : 						}
; 7010 : 
; 7011 : 						SwitchWizardToNonSysDeviceMode ();

  019f1	e8 00 00 00 00	 call	 ?SwitchWizardToNonSysDeviceMode@@YAXXZ ; SwitchWizardToNonSysDeviceMode

; 7012 : 						NormalCursor ();

  019f6	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_24$1541:

; 6074 : 			}
; 6075 : 			return 1;

  019fb	b8 01 00 00 00	 mov	 eax, 1
  01a00	e9 aa e6 ff ff	 jmp	 $LN1@MainDialog
$LN239@MainDialog:

; 7013 : 						return 1;
; 7014 : 					}
; 7015 : 				}
; 7016 : 
; 7017 : 				MoveEditToCombo (GetDlgItem (hCurPage, IDC_COMBO_BOX), bHistory);

  01a05	ff 35 00 00 00
	00		 push	 DWORD PTR _bHistory
  01a0b	68 ea 03 00 00	 push	 1002			; 000003eaH
  01a10	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01a16	ff d7		 call	 edi
  01a18	50		 push	 eax
  01a19	e8 00 00 00 00	 call	 _MoveEditToCombo

; 7018 : 
; 7019 : 				if (IsMountedVolume (szDiskFile))

  01a1e	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  01a23	e8 00 00 00 00	 call	 _IsMountedVolume
  01a28	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a2b	85 c0		 test	 eax, eax
  01a2d	74 1c		 je	 SHORT $LN241@MainDialog

; 7020 : 				{
; 7021 : 					Error ("ALREADY_MOUNTED");

  01a2f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ECFGGOBI@ALREADY_MOUNTED?$AA@
  01a34	e8 00 00 00 00	 call	 _Error
  01a39	83 c4 04	 add	 esp, 4

; 7022 : 					NormalCursor ();

  01a3c	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_25$1542:

; 6074 : 			}
; 6075 : 			return 1;

  01a41	b8 01 00 00 00	 mov	 eax, 1
  01a46	e9 64 e6 ff ff	 jmp	 $LN1@MainDialog
$LN241@MainDialog:

; 7023 : 					return 1;
; 7024 : 				}
; 7025 : 
; 7026 : 				if (bDevice)

  01a4b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  01a52	74 53		 je	 SHORT $LN242@MainDialog

; 7027 : 				{
; 7028 : 					switch (IsSystemDevicePath (szDiskFile, hCurPage, TRUE))

  01a54	6a 01		 push	 1
  01a56	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01a5c	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  01a61	e8 00 00 00 00	 call	 _IsSystemDevicePath
  01a66	48		 dec	 eax
  01a67	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a6a	83 f8 02	 cmp	 eax, 2
  01a6d	77 5f		 ja	 SHORT $LN247@MainDialog

; 7029 : 					{
; 7030 : 					case 1:
; 7031 : 					case 2:
; 7032 : 					case 3:
; 7033 : 						if (AskYesNo ("CONFIRM_SYSTEM_ENCRYPTION_MODE") == IDNO)

  01a6f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@NCOMIFAB@CONFIRM_SYSTEM_ENCRYPTION_MODE?$AA@
  01a74	e8 00 00 00 00	 call	 _AskYesNo
  01a79	83 c4 04	 add	 esp, 4
  01a7c	83 f8 07	 cmp	 eax, 7
  01a7f	0f 84 bf fc ff
	ff		 je	 $LN1291@MainDialog

; 7034 : 						{
; 7035 : 							NormalCursor ();
; 7036 : 							return 1;
; 7037 : 						}
; 7038 : 						szFileName[0] = 0;

  01a85	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0

; 7039 : 						szDiskFile[0] = 0;

  01a8c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0

; 7040 : 						SwitchWizardToSysEncMode ();

  01a93	e8 00 00 00 00	 call	 _SwitchWizardToSysEncMode

; 7041 : 						NormalCursor ();

  01a98	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_26$1543:

; 6074 : 			}
; 6075 : 			return 1;

  01a9d	b8 01 00 00 00	 mov	 eax, 1
  01aa2	e9 08 e6 ff ff	 jmp	 $LN1@MainDialog
$LN242@MainDialog:

; 7042 : 						return 1;
; 7043 : 
; 7044 : 					case -1:
; 7045 : 						// In some environments (such as PE), the system volume is not located on a hard drive.
; 7046 : 						// Therefore, we must interpret this return code as "Not a system device path" (otherwise,
; 7047 : 						// non-system devices could not be GST-formatted in such environments). Note that this is
; 7048 : 						// rather safe, because bReliableRequired is set to TRUE.
; 7049 : 
; 7050 : 						// NOP
; 7051 : 						break;
; 7052 : 					}
; 7053 : 				}
; 7054 : 				else
; 7055 : 				{
; 7056 : 					if (CheckFileExtension(szFileName) 
; 7057 : 						&& AskWarnNoYes ("EXE_FILE_EXTENSION_CONFIRM") == IDNO)

  01aa7	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  01aac	e8 00 00 00 00	 call	 _CheckFileExtension
  01ab1	83 c4 04	 add	 esp, 4
  01ab4	85 c0		 test	 eax, eax
  01ab6	74 16		 je	 SHORT $LN247@MainDialog
  01ab8	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LHDMMKJO@EXE_FILE_EXTENSION_CONFIRM?$AA@
  01abd	e8 00 00 00 00	 call	 _AskWarnNoYes
  01ac2	83 c4 04	 add	 esp, 4
  01ac5	83 f8 07	 cmp	 eax, 7
  01ac8	0f 84 76 fc ff
	ff		 je	 $LN1291@MainDialog
$LN247@MainDialog:

; 7058 : 					{
; 7059 : 						NormalCursor ();
; 7060 : 						return 1;
; 7061 : 					}
; 7062 : 				}
; 7063 : 
; 7064 : 				bHistory = !IsButtonChecked (GetDlgItem (hCurPage, IDC_NO_HISTORY));

  01ace	68 f4 03 00 00	 push	 1012			; 000003f4H
  01ad3	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01ad9	ff d7		 call	 edi
  01adb	50		 push	 eax
  01adc	e8 00 00 00 00	 call	 _IsButtonChecked

; 7065 : 
; 7066 : 				SaveSettings (hCurPage);

  01ae1	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01ae7	f7 d8		 neg	 eax
  01ae9	1b c0		 sbb	 eax, eax
  01aeb	40		 inc	 eax
  01aec	a3 00 00 00 00	 mov	 DWORD PTR _bHistory, eax
  01af1	e8 00 00 00 00	 call	 _SaveSettings
  01af6	83 c4 08	 add	 esp, 8

; 7067 : 
; 7068 : 				if (bHiddenVolDirect && bHiddenVolHost)

  01af9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolDirect, 0
  01b00	0f 84 b9 00 00
	00		 je	 $LN248@MainDialog
  01b06	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  01b0d	0f 84 ac 00 00
	00		 je	 $LN248@MainDialog

; 7069 : 				{
; 7070 : 					nNewPageNo = HIDDEN_VOL_HOST_PASSWORD_PAGE - 1;
; 7071 : 
; 7072 : 					if (bDevice)

  01b13	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  01b1a	be 13 00 00 00	 mov	 esi, 19			; 00000013H
  01b1f	74 5b		 je	 SHORT $LN250@MainDialog

; 7073 : 					{
; 7074 : 						if(!QueryFreeSpace (hwndDlg, GetDlgItem (hwndDlg, IDC_SPACE_LEFT), FALSE))

  01b21	6a 00		 push	 0
  01b23	68 f1 03 00 00	 push	 1009			; 000003f1H
  01b28	53		 push	 ebx
  01b29	ff d7		 call	 edi
  01b2b	50		 push	 eax
  01b2c	53		 push	 ebx
  01b2d	e8 00 00 00 00	 call	 _QueryFreeSpace
  01b32	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b35	85 c0		 test	 eax, eax
  01b37	75 2a		 jne	 SHORT $LN252@MainDialog

; 7075 : 						{
; 7076 : 							MessageBoxW (hwndDlg, GetString ("CANT_GET_VOLSIZE"), lpszTitle, ICON_HAND);

  01b39	6a 10		 push	 16			; 00000010H
  01b3b	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  01b41	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNOFFGJI@CANT_GET_VOLSIZE?$AA@
  01b46	e8 00 00 00 00	 call	 _GetString
  01b4b	83 c4 04	 add	 esp, 4
  01b4e	50		 push	 eax
  01b4f	53		 push	 ebx
  01b50	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 7077 : 							NormalCursor ();

  01b56	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_27$1544:

; 6074 : 			}
; 6075 : 			return 1;

  01b5b	8d 46 ee	 lea	 eax, DWORD PTR [esi-18]
  01b5e	e9 4c e5 ff ff	 jmp	 $LN1@MainDialog
$LN252@MainDialog:

; 7078 : 							return 1;
; 7079 : 						}
; 7080 : 						else
; 7081 : 							nHiddenVolHostSize = nVolumeSize;

  01b63	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nVolumeSize@@3_KA
  01b68	a3 00 00 00 00	 mov	 DWORD PTR ?nHiddenVolHostSize@@3_KA, eax
  01b6d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?nVolumeSize@@3_KA+4
  01b72	a3 04 00 00 00	 mov	 DWORD PTR ?nHiddenVolHostSize@@3_KA+4, eax

; 7082 : 					}
; 7083 : 					else

  01b77	e9 fe fa ff ff	 jmp	 $LN310@MainDialog
$LN250@MainDialog:

; 7084 : 					{
; 7085 : 						if (!GetFileVolSize (hwndDlg, &nHiddenVolHostSize))

  01b7c	68 00 00 00 00	 push	 OFFSET ?nHiddenVolHostSize@@3_KA ; nHiddenVolHostSize
  01b81	53		 push	 ebx
  01b82	e8 00 00 00 00	 call	 _GetFileVolSize
  01b87	83 c4 08	 add	 esp, 8
  01b8a	85 c0		 test	 eax, eax
  01b8c	0f 84 b2 fb ff
	ff		 je	 $LN1291@MainDialog

; 7086 : 						{
; 7087 : 							NormalCursor ();
; 7088 : 							return 1;
; 7089 : 						}
; 7090 : 						else if (IsSparseFile (hwndDlg))

  01b92	53		 push	 ebx
  01b93	e8 00 00 00 00	 call	 _IsSparseFile
  01b98	83 c4 04	 add	 esp, 4
  01b9b	85 c0		 test	 eax, eax
  01b9d	0f 84 d7 fa ff
	ff		 je	 $LN310@MainDialog

; 7091 : 						{
; 7092 : 							// Hidden volumes must not be created within sparse file containers
; 7093 : 							Warning ("HIDDEN_VOL_HOST_SPARSE");

  01ba3	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BGCKDFKI@HIDDEN_VOL_HOST_SPARSE?$AA@
  01ba8	e8 00 00 00 00	 call	 _Warning
  01bad	83 c4 04	 add	 esp, 4

; 7094 : 							NormalCursor ();

  01bb0	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_28$1545:

; 6074 : 			}
; 6075 : 			return 1;

  01bb5	b8 01 00 00 00	 mov	 eax, 1
  01bba	e9 f0 e4 ff ff	 jmp	 $LN1@MainDialog
$LN248@MainDialog:

; 7095 : 							return 1;
; 7096 : 						}
; 7097 : 					}
; 7098 : 				}
; 7099 : 				else
; 7100 : 				{
; 7101 : 					if (!bHiddenVol && !bDevice)

  01bbf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  01bc6	75 1a		 jne	 SHORT $LN1492@MainDialog
  01bc8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  01bcf	0f 84 b1 00 00
	00		 je	 $LN265@MainDialog

; 7102 : 						nNewPageNo = CIPHER_PAGE - 1;
; 7103 : 					else if (bHiddenVol)

  01bd5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  01bdc	0f 84 92 fa ff
	ff		 je	 $LN1474@MainDialog
$LN1492@MainDialog:

; 7104 : 						nNewPageNo = (bHiddenVolHost ? HIDDEN_VOL_HOST_PRE_CIPHER_PAGE : HIDDEN_VOL_PRE_CIPHER_PAGE) - 1;

  01be2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _bHiddenVolHost
  01be8	f7 de		 neg	 esi
  01bea	1b f6		 sbb	 esi, esi
  01bec	83 c6 10	 add	 esi, 16			; 00000010H

; 7105 : 				}

  01bef	e9 86 fa ff ff	 jmp	 $LN310@MainDialog
$LN235@MainDialog:

; 7106 : 			}
; 7107 : 
; 7108 : 			else if (nCurPageNo == DEVICE_TRANSFORM_MODE_PAGE)

  01bf4	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  01bf7	0f 85 77 00 00
	00		 jne	 $LN260@MainDialog

; 7109 : 			{
; 7110 : 				if (bInPlaceEncNonSys)

  01bfd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  01c04	0f 84 7c 00 00
	00		 je	 $LN265@MainDialog

; 7111 : 				{
; 7112 : 					// Check requirements for non-system in-place encryption
; 7113 : 
; 7114 : 					if (!CheckRequirementsForNonSysInPlaceEnc (szDiskFile, FALSE))

  01c0a	6a 00		 push	 0
  01c0c	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  01c11	e8 00 00 00 00	 call	 _CheckRequirementsForNonSysInPlaceEnc
  01c16	83 c4 08	 add	 esp, 8
  01c19	85 c0		 test	 eax, eax
  01c1b	0f 84 26 e8 ff
	ff		 je	 $LN15@MainDialog

; 7115 : 					{
; 7116 : 						return 1;
; 7117 : 					}
; 7118 : 
; 7119 : 					// We are going to skip the Size page so we must get the size here
; 7120 : 					nVolumeSize = GetDeviceSize (szDiskFile);

  01c21	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  01c26	e8 00 00 00 00	 call	 _GetDeviceSize
  01c2b	a3 00 00 00 00	 mov	 DWORD PTR ?nVolumeSize@@3_KA, eax
  01c30	83 c4 04	 add	 esp, 4

; 7121 : 
; 7122 : 					if (nVolumeSize == -1)

  01c33	23 c2		 and	 eax, edx
  01c35	89 15 04 00 00
	00		 mov	 DWORD PTR ?nVolumeSize@@3_KA+4, edx
  01c3b	83 f8 ff	 cmp	 eax, -1
  01c3e	75 18		 jne	 SHORT $LN264@MainDialog

; 7123 : 					{
; 7124 : 						handleWin32Error (MainDlg);

  01c40	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  01c46	e8 00 00 00 00	 call	 _handleWin32Error
  01c4b	83 c4 04	 add	 esp, 4
$ovf_end_29$1546:

; 6074 : 			}
; 6075 : 			return 1;

  01c4e	b8 01 00 00 00	 mov	 eax, 1
  01c53	e9 57 e4 ff ff	 jmp	 $LN1@MainDialog
$LN264@MainDialog:

; 7125 : 						return 1;
; 7126 : 					}
; 7127 : 
; 7128 : 					if (AskWarnYesNo ("NONSYS_INPLACE_ENC_CONFIRM_BACKUP") == IDNO)

  01c58	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@NCAFIIDC@NONSYS_INPLACE_ENC_CONFIRM_BACKU@
  01c5d	e8 00 00 00 00	 call	 _AskWarnYesNo
  01c62	83 c4 04	 add	 esp, 4
  01c65	83 f8 07	 cmp	 eax, 7
  01c68	75 1c		 jne	 SHORT $LN265@MainDialog
$ovf_end_30$1547:

; 6074 : 			}
; 6075 : 			return 1;

  01c6a	b8 01 00 00 00	 mov	 eax, 1
  01c6f	e9 3b e4 ff ff	 jmp	 $LN1@MainDialog
$LN260@MainDialog:

; 7129 : 						return 1;
; 7130 : 				}
; 7131 : 				nNewPageNo = CIPHER_PAGE - 1;
; 7132 : 			}
; 7133 : 
; 7134 : 			else if (nCurPageNo == HIDDEN_VOL_HOST_PRE_CIPHER_PAGE)

  01c74	83 f8 10	 cmp	 eax, 16			; 00000010H
  01c77	75 17		 jne	 SHORT $LN266@MainDialog

; 7135 : 			{
; 7136 : 				if (bHiddenVolHost)

  01c79	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  01c80	0f 84 ee f9 ff
	ff		 je	 $LN1474@MainDialog
$LN265@MainDialog:

; 7137 : 					nNewPageNo = CIPHER_PAGE - 1;		// Skip the info on the hiddem volume

  01c86	be 11 00 00 00	 mov	 esi, 17			; 00000011H

; 7138 : 			}

  01c8b	e9 ea f9 ff ff	 jmp	 $LN310@MainDialog
$LN266@MainDialog:

; 7139 : 
; 7140 : 			else if (nCurPageNo == CIPHER_PAGE)

  01c90	83 f8 12	 cmp	 eax, 18			; 00000012H
  01c93	0f 85 ea 00 00
	00		 jne	 $LN269@MainDialog

; 7141 : 			{
; 7142 : 				LPARAM nIndex;
; 7143 : 				nIndex = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX), CB_GETCURSEL, 0, 0);

  01c99	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  01c9f	6a 00		 push	 0
  01ca1	6a 00		 push	 0
  01ca3	68 47 01 00 00	 push	 327			; 00000147H
  01ca8	68 ea 03 00 00	 push	 1002			; 000003eaH
  01cad	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01cb3	ff d6		 call	 esi
  01cb5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SendMessageA@16
  01cbb	50		 push	 eax
  01cbc	ff d7		 call	 edi

; 7144 : 				nVolumeEA = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX), CB_GETITEMDATA, nIndex, 0);

  01cbe	6a 00		 push	 0
  01cc0	50		 push	 eax
  01cc1	68 50 01 00 00	 push	 336			; 00000150H
  01cc6	68 ea 03 00 00	 push	 1002			; 000003eaH
  01ccb	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01cd1	ff d6		 call	 esi
  01cd3	50		 push	 eax
  01cd4	ff d7		 call	 edi
  01cd6	a3 00 00 00 00	 mov	 DWORD PTR ?nVolumeEA@@3HA, eax ; nVolumeEA

; 7145 : 
; 7146 : 				if (SysEncInEffect ()
; 7147 : 					&& EAGetCipherCount (nVolumeEA) > 1)		// Cascade?

  01cdb	e8 00 00 00 00	 call	 _SysEncInEffect
  01ce0	85 c0		 test	 eax, eax
  01ce2	74 3f		 je	 SHORT $LN273@MainDialog
  01ce4	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeEA@@3HA ; nVolumeEA
  01cea	e8 00 00 00 00	 call	 _EAGetCipherCount
  01cef	83 c4 04	 add	 esp, 4
  01cf2	83 f8 01	 cmp	 eax, 1
  01cf5	7e 2c		 jle	 SHORT $LN273@MainDialog

; 7148 : 				{
; 7149 : 					if (AskWarnNoYes ("CONFIRM_CASCADE_FOR_SYS_ENCRYPTION") == IDNO)

  01cf7	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@HEIAMGDN@CONFIRM_CASCADE_FOR_SYS_ENCRYPTI@
  01cfc	e8 00 00 00 00	 call	 _AskWarnNoYes
  01d01	83 c4 04	 add	 esp, 4
  01d04	83 f8 07	 cmp	 eax, 7
  01d07	0f 84 3a e7 ff
	ff		 je	 $LN15@MainDialog

; 7150 : 						return 1;
; 7151 : 
; 7152 : 					if (!bHiddenOS)

  01d0d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  01d14	75 0d		 jne	 SHORT $LN273@MainDialog

; 7153 : 						Info ("NOTE_CASCADE_FOR_SYS_ENCRYPTION");

  01d16	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HENDJLLF@NOTE_CASCADE_FOR_SYS_ENCRYPTION?$AA@
  01d1b	e8 00 00 00 00	 call	 _Info
  01d20	83 c4 04	 add	 esp, 4
$LN273@MainDialog:

; 7154 : 				}
; 7155 : 
; 7156 : 				nIndex = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX_HASH_ALGO), CB_GETCURSEL, 0, 0);

  01d23	6a 00		 push	 0
  01d25	6a 00		 push	 0
  01d27	68 47 01 00 00	 push	 327			; 00000147H
  01d2c	68 f0 03 00 00	 push	 1008			; 000003f0H
  01d31	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01d37	ff d6		 call	 esi
  01d39	50		 push	 eax
  01d3a	ff d7		 call	 edi

; 7157 : 				hash_algo = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX_HASH_ALGO), CB_GETITEMDATA, nIndex, 0);

  01d3c	6a 00		 push	 0
  01d3e	50		 push	 eax
  01d3f	68 50 01 00 00	 push	 336			; 00000150H
  01d44	68 f0 03 00 00	 push	 1008			; 000003f0H
  01d49	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01d4f	ff d6		 call	 esi
  01d51	50		 push	 eax
  01d52	ff d7		 call	 edi

; 7158 : 
; 7159 : 				RandSetHashFunction (hash_algo);

  01d54	50		 push	 eax
  01d55	a3 00 00 00 00	 mov	 DWORD PTR ?hash_algo@@3HA, eax ; hash_algo
  01d5a	e8 00 00 00 00	 call	 _RandSetHashFunction
  01d5f	83 c4 04	 add	 esp, 4

; 7160 : 
; 7161 : 				if (SysEncInEffect () || bInPlaceEncNonSys)

  01d62	e8 00 00 00 00	 call	 _SysEncInEffect
  01d67	85 c0		 test	 eax, eax
  01d69	0f 85 9e 01 00
	00		 jne	 $LN286@MainDialog
  01d6f	39 05 00 00 00
	00		 cmp	 DWORD PTR _bInPlaceEncNonSys, eax
  01d75	0f 84 f9 f8 ff
	ff		 je	 $LN1474@MainDialog

; 7162 : 					nNewPageNo = PASSWORD_PAGE - 1;			// Skip irrelevant pages

  01d7b	8d 70 14	 lea	 esi, DWORD PTR [eax+20]

; 7163 : 			}

  01d7e	e9 f7 f8 ff ff	 jmp	 $LN310@MainDialog
$LN269@MainDialog:

; 7164 : 
; 7165 : 			else if (nCurPageNo == SIZE_PAGE)

  01d83	83 f8 13	 cmp	 eax, 19			; 00000013H
  01d86	0f 85 8b 01 00
	00		 jne	 $LN276@MainDialog

; 7166 : 			{
; 7167 : 				char szFileSystemNameBuffer[256];
; 7168 : 
; 7169 : 				VerifySizeAndUpdate (hCurPage, TRUE);

  01d8c	6a 01		 push	 1
  01d8e	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01d94	e8 00 00 00 00	 call	 _VerifySizeAndUpdate
  01d99	83 c4 08	 add	 esp, 8

; 7170 : 
; 7171 : 				if (!bDevice)

  01d9c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  01da3	0f 85 dd 00 00
	00		 jne	 $LN281@MainDialog

; 7172 : 				{
; 7173 : 					/* Verify that the volume would not be too large for the host file system */
; 7174 : 
; 7175 : 					char root[GST_MAX_PATH];
; 7176 : 
; 7177 : 					if (GetVolumePathName (szDiskFile, root, sizeof (root))
; 7178 : 						&& GetVolumeInformation (root, NULL, 0, NULL, NULL, NULL, szFileSystemNameBuffer, sizeof(szFileSystemNameBuffer))
; 7179 : 						&& !strncmp (szFileSystemNameBuffer, "FAT32", 5))

  01da9	68 04 01 00 00	 push	 260			; 00000104H
  01dae	8d 85 10 f5 ff
	ff		 lea	 eax, DWORD PTR _root$89[ebp]
  01db4	50		 push	 eax
  01db5	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  01dba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumePathNameA@12
  01dc0	85 c0		 test	 eax, eax
  01dc2	0f 84 7c 00 00
	00		 je	 $LN280@MainDialog
  01dc8	68 00 01 00 00	 push	 256			; 00000100H
  01dcd	8d 85 10 f4 ff
	ff		 lea	 eax, DWORD PTR _szFileSystemNameBuffer$88[ebp]
  01dd3	50		 push	 eax
  01dd4	6a 00		 push	 0
  01dd6	6a 00		 push	 0
  01dd8	6a 00		 push	 0
  01dda	6a 00		 push	 0
  01ddc	6a 00		 push	 0
  01dde	8d 85 10 f5 ff
	ff		 lea	 eax, DWORD PTR _root$89[ebp]
  01de4	50		 push	 eax
  01de5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeInformationA@32
  01deb	85 c0		 test	 eax, eax
  01ded	74 55		 je	 SHORT $LN280@MainDialog
  01def	6a 05		 push	 5
  01df1	8d 85 10 f4 ff
	ff		 lea	 eax, DWORD PTR _szFileSystemNameBuffer$88[ebp]
  01df7	68 00 00 00 00	 push	 OFFSET ??_C@_05HNJNFBJJ@FAT32?$AA@
  01dfc	50		 push	 eax
  01dfd	e8 00 00 00 00	 call	 _strncmp
  01e02	83 c4 0c	 add	 esp, 12			; 0000000cH
  01e05	85 c0		 test	 eax, eax
  01e07	75 3b		 jne	 SHORT $LN280@MainDialog

; 7180 : 					{
; 7181 : 						// The host file system is FAT32
; 7182 : 						if (nUIVolumeSize * nMultiplier >= 4 * BYTES_PER_GB)

  01e09	ff 35 04 00 00
	00		 push	 DWORD PTR ?nUIVolumeSize@@3_KA+4
  01e0f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nMultiplier@@3HA ; nMultiplier
  01e14	ff 35 00 00 00
	00		 push	 DWORD PTR ?nUIVolumeSize@@3_KA
  01e1a	99		 cdq
  01e1b	52		 push	 edx
  01e1c	50		 push	 eax
  01e1d	e8 00 00 00 00	 call	 __allmul
  01e22	83 fa 01	 cmp	 edx, 1
  01e25	72 1d		 jb	 SHORT $LN280@MainDialog
  01e27	77 04		 ja	 SHORT $LN1381@MainDialog
  01e29	85 c0		 test	 eax, eax
  01e2b	72 17		 jb	 SHORT $LN280@MainDialog
$LN1381@MainDialog:

; 7183 : 						{
; 7184 : 							Error ("VOLUME_TOO_LARGE_FOR_FAT32");

  01e2d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FEGMEEPN@VOLUME_TOO_LARGE_FOR_FAT32?$AA@
  01e32	e8 00 00 00 00	 call	 _Error
  01e37	83 c4 04	 add	 esp, 4
$ovf_end_31$1548:

; 6074 : 			}
; 6075 : 			return 1;

  01e3a	b8 01 00 00 00	 mov	 eax, 1
  01e3f	e9 6b e2 ff ff	 jmp	 $LN1@MainDialog
$LN280@MainDialog:

; 7185 : 							return 1;
; 7186 : 						}
; 7187 : 					}
; 7188 : 
; 7189 : 					/* Verify that the volume would not be too large for the operating system */
; 7190 : 
; 7191 : 					if (!IsOSAtLeast (WIN_VISTA)
; 7192 : 						&& nUIVolumeSize * nMultiplier > 2 * BYTES_PER_TB)

  01e44	6a 0b		 push	 11			; 0000000bH
  01e46	e8 00 00 00 00	 call	 _IsOSAtLeast
  01e4b	83 c4 04	 add	 esp, 4
  01e4e	85 c0		 test	 eax, eax
  01e50	75 34		 jne	 SHORT $LN281@MainDialog
  01e52	ff 35 04 00 00
	00		 push	 DWORD PTR ?nUIVolumeSize@@3_KA+4
  01e58	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nMultiplier@@3HA ; nMultiplier
  01e5d	ff 35 00 00 00
	00		 push	 DWORD PTR ?nUIVolumeSize@@3_KA
  01e63	99		 cdq
  01e64	52		 push	 edx
  01e65	50		 push	 eax
  01e66	e8 00 00 00 00	 call	 __allmul
  01e6b	81 fa 00 02 00
	00		 cmp	 edx, 512		; 00000200H
  01e71	72 13		 jb	 SHORT $LN281@MainDialog
  01e73	77 04		 ja	 SHORT $LN1382@MainDialog
  01e75	85 c0		 test	 eax, eax
  01e77	74 0d		 je	 SHORT $LN281@MainDialog
$LN1382@MainDialog:

; 7193 : 					{
; 7194 : 						Warning ("VOLUME_TOO_LARGE_FOR_WINXP");

  01e79	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IAHLEEBN@VOLUME_TOO_LARGE_FOR_WINXP?$AA@
  01e7e	e8 00 00 00 00	 call	 _Warning
  01e83	83 c4 04	 add	 esp, 4
$LN281@MainDialog:

; 7195 : 					}
; 7196 : 				}
; 7197 : 
; 7198 : 				if (bHiddenVol && !bHiddenVolHost)	// If it's a hidden volume

  01e86	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  01e8d	74 68		 je	 SHORT $LN284@MainDialog
  01e8f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  01e96	75 5f		 jne	 SHORT $LN284@MainDialog

; 7199 : 				{
; 7200 : 					/* Ask for confirmation if the hidden volume is too large for the user to be
; 7201 : 					able to write much more data to the outer volume. */
; 7202 : 
; 7203 : 					if (((double) nUIVolumeSize / (nMaximumHiddenVolSize / nMultiplier)) > 0.85)	// 85%

  01e98	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?nUIVolumeSize@@3_KA+4
  01e9e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nUIVolumeSize@@3_KA
  01ea4	e8 00 00 00 00	 call	 __ultod3
  01ea9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nMultiplier@@3HA ; nMultiplier
  01eae	99		 cdq
  01eaf	52		 push	 edx
  01eb0	50		 push	 eax
  01eb1	ff 35 04 00 00
	00		 push	 DWORD PTR ?nMaximumHiddenVolSize@@3_JA+4
  01eb7	f2 0f 11 45 e4	 movsd	 QWORD PTR tv4877[ebp], xmm0
  01ebc	ff 35 00 00 00
	00		 push	 DWORD PTR ?nMaximumHiddenVolSize@@3_JA
  01ec2	e8 00 00 00 00	 call	 __alldiv
  01ec7	8b c8		 mov	 ecx, eax
  01ec9	e8 00 00 00 00	 call	 __ltod3
  01ece	f2 0f 10 4d e4	 movsd	 xmm1, QWORD PTR tv4877[ebp]
  01ed3	f2 0f 5e c8	 divsd	 xmm1, xmm0
  01ed7	66 0f 2f 0d 00
	00 00 00	 comisd	 xmm1, QWORD PTR __real@3feb333333333333
  01edf	76 16		 jbe	 SHORT $LN284@MainDialog

; 7204 : 					{
; 7205 : 						if (AskWarnNoYes ("FREE_SPACE_FOR_WRITING_TO_OUTER_VOLUME") == IDNO)

  01ee1	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@NJLIGNCF@FREE_SPACE_FOR_WRITING_TO_OUTER_@
  01ee6	e8 00 00 00 00	 call	 _AskWarnNoYes
  01eeb	83 c4 04	 add	 esp, 4
  01eee	83 f8 07	 cmp	 eax, 7
  01ef1	0f 84 50 e5 ff
	ff		 je	 $LN15@MainDialog
$LN284@MainDialog:

; 7206 : 							return 1;
; 7207 : 					}
; 7208 : 				}
; 7209 : 
; 7210 : 				if (!(bHiddenVolDirect && bHiddenVolHost))

  01ef7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolDirect, 0
  01efe	74 0d		 je	 SHORT $LN286@MainDialog
  01f00	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  01f07	0f 85 67 f7 ff
	ff		 jne	 $LN1474@MainDialog
$LN286@MainDialog:

; 7211 : 					nNewPageNo = PASSWORD_PAGE - 1;

  01f0d	be 14 00 00 00	 mov	 esi, 20			; 00000014H

; 7212 : 			}

  01f12	e9 63 f7 ff ff	 jmp	 $LN310@MainDialog
$LN276@MainDialog:

; 7213 : 
; 7214 : 			else if (nCurPageNo == PASSWORD_PAGE)

  01f17	83 f8 15	 cmp	 eax, 21			; 00000015H
  01f1a	0f 85 ba 01 00
	00		 jne	 $LN287@MainDialog

; 7215 : 			{
; 7216 : 				VerifyPasswordAndUpdate (hwndDlg, GetDlgItem (MainDlg, IDC_NEXT),

  01f20	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KeyFilesEnable, 0
  01f27	74 19		 je	 SHORT $LN532@MainDialog
  01f29	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _FirstKeyFile, 0
  01f30	74 10		 je	 SHORT $LN532@MainDialog
  01f32	e8 00 00 00 00	 call	 _SysEncInEffect
  01f37	85 c0		 test	 eax, eax
  01f39	75 07		 jne	 SHORT $LN532@MainDialog
  01f3b	b8 01 00 00 00	 mov	 eax, 1
  01f40	eb 02		 jmp	 SHORT $LN533@MainDialog
$LN532@MainDialog:
  01f42	33 c0		 xor	 eax, eax
$LN533@MainDialog:
  01f44	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  01f4a	50		 push	 eax
  01f4b	68 00 00 00 00	 push	 OFFSET ?szVerify@@3PADA	; szVerify
  01f50	68 04 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A+4
  01f55	68 f2 03 00 00	 push	 1010			; 000003f2H
  01f5a	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01f60	ff d6		 call	 esi
  01f62	50		 push	 eax
  01f63	68 ec 03 00 00	 push	 1004			; 000003ecH
  01f68	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01f6e	ff d6		 call	 esi
  01f70	50		 push	 eax
  01f71	68 10 04 00 00	 push	 1040			; 00000410H
  01f76	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  01f7c	ff d6		 call	 esi
  01f7e	50		 push	 eax
  01f7f	53		 push	 ebx
  01f80	e8 00 00 00 00	 call	 _VerifyPasswordAndUpdate

; 7217 : 					GetDlgItem (hCurPage, IDC_PASSWORD),
; 7218 : 					GetDlgItem (hCurPage, IDC_VERIFY),
; 7219 : 					volumePassword.Text,
; 7220 : 					szVerify,
; 7221 : 					KeyFilesEnable && FirstKeyFile!=NULL && !SysEncInEffect());
; 7222 : 
; 7223 : 				volumePassword.Length = strlen ((char *) volumePassword.Text);

  01f85	b9 04 00 00 00	 mov	 ecx, OFFSET ?volumePassword@@3UPassword@@A+4
  01f8a	83 c4 1c	 add	 esp, 28			; 0000001cH
  01f8d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL1383@MainDialog:
  01f90	8a 01		 mov	 al, BYTE PTR [ecx]
  01f92	41		 inc	 ecx
  01f93	84 c0		 test	 al, al
  01f95	75 f9		 jne	 SHORT $LL1383@MainDialog
  01f97	2b ca		 sub	 ecx, edx
  01f99	89 0d 00 00 00
	00		 mov	 DWORD PTR ?volumePassword@@3UPassword@@A, ecx

; 7224 : 
; 7225 : 				if (volumePassword.Length > 0)

  01f9f	74 5b		 je	 SHORT $LN292@MainDialog

; 7226 : 				{
; 7227 : 					// Password character encoding
; 7228 : 					if (!CheckPasswordCharEncoding (GetDlgItem (hCurPage, IDC_PASSWORD), NULL))

  01fa1	6a 00		 push	 0
  01fa3	68 ec 03 00 00	 push	 1004			; 000003ecH
  01fa8	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01fae	ff d6		 call	 esi
  01fb0	50		 push	 eax
  01fb1	e8 00 00 00 00	 call	 _CheckPasswordCharEncoding
  01fb6	83 c4 08	 add	 esp, 8
  01fb9	85 c0		 test	 eax, eax
  01fbb	75 17		 jne	 SHORT $LN290@MainDialog

; 7229 : 					{
; 7230 : 						Error ("UNSUPPORTED_CHARS_IN_PWD");

  01fbd	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CPHEENHA@UNSUPPORTED_CHARS_IN_PWD?$AA@
  01fc2	e8 00 00 00 00	 call	 _Error
  01fc7	83 c4 04	 add	 esp, 4
$ovf_end_32$1549:

; 6074 : 			}
; 6075 : 			return 1;

  01fca	b8 01 00 00 00	 mov	 eax, 1
  01fcf	e9 db e0 ff ff	 jmp	 $LN1@MainDialog
$LN290@MainDialog:

; 7231 : 						return 1;
; 7232 : 					}
; 7233 : 					// Check password length (do not check if it's for an outer volume).
; 7234 : 					else if (!bHiddenVolHost
; 7235 : 						&& !CheckPasswordLength (hwndDlg, GetDlgItem (hCurPage, IDC_PASSWORD)))

  01fd4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  01fdb	75 1f		 jne	 SHORT $LN292@MainDialog
  01fdd	68 ec 03 00 00	 push	 1004			; 000003ecH
  01fe2	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  01fe8	ff d6		 call	 esi
  01fea	50		 push	 eax
  01feb	53		 push	 ebx
  01fec	e8 00 00 00 00	 call	 _CheckPasswordLength
  01ff1	83 c4 08	 add	 esp, 8
  01ff4	85 c0		 test	 eax, eax
  01ff6	0f 84 4b e4 ff
	ff		 je	 $LN15@MainDialog
$LN292@MainDialog:

; 7236 : 					{
; 7237 : 						return 1;
; 7238 : 					}
; 7239 : 				}
; 7240 : 
; 7241 : 				// Store the password in case we need to restore it after keyfile is applied to it
; 7242 : 				GetWindowText (GetDlgItem (hCurPage, IDC_PASSWORD), szRawPassword, sizeof (szRawPassword));

  01ffc	6a 41		 push	 65			; 00000041H
  01ffe	68 00 00 00 00	 push	 OFFSET ?szRawPassword@@3PADA ; szRawPassword
  02003	68 ec 03 00 00	 push	 1004			; 000003ecH
  02008	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0200e	ff d6		 call	 esi
  02010	50		 push	 eax
  02011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 7243 : 
; 7244 : 				if (!SysEncInEffect ()) 

  02017	e8 00 00 00 00	 call	 _SysEncInEffect
  0201c	85 c0		 test	 eax, eax
  0201e	75 46		 jne	 SHORT $LN293@MainDialog

; 7245 : 				{
; 7246 : 					if (KeyFilesEnable)

  02020	39 05 00 00 00
	00		 cmp	 DWORD PTR _KeyFilesEnable, eax
  02026	74 25		 je	 SHORT $LN1479@MainDialog

; 7247 : 					{
; 7248 : 						WaitCursor ();

  02028	e8 00 00 00 00	 call	 _WaitCursor

; 7249 : 
; 7250 : 						if (!KeyFilesApply (&volumePassword, FirstKeyFile))

  0202d	ff 35 00 00 00
	00		 push	 DWORD PTR _FirstKeyFile
  02033	68 00 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A ; volumePassword
  02038	e8 00 00 00 00	 call	 _KeyFilesApply
  0203d	83 c4 08	 add	 esp, 8
  02040	85 c0		 test	 eax, eax
  02042	0f 84 fc f6 ff
	ff		 je	 $LN1291@MainDialog

; 7251 : 						{
; 7252 : 							NormalCursor ();
; 7253 : 							return 1;
; 7254 : 						}
; 7255 : 
; 7256 : 						NormalCursor ();

  02048	e8 00 00 00 00	 call	 _NormalCursor
$LN1479@MainDialog:
  0204d	8b b5 6c 2d ff
	ff		 mov	 esi, DWORD PTR _nNewPageNo$1$[ebp]
$LN294@MainDialog:

; 7274 : 				}
; 7275 : 
; 7276 : 				if (bInPlaceEncNonSys)

  02053	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  0205a	74 55		 je	 SHORT $LN300@MainDialog

; 7277 : 				{
; 7278 : 					nNewPageNo = NONSYS_INPLACE_ENC_RAND_DATA_PAGE - 1;		// Skip irrelevant pages

  0205c	be 21 00 00 00	 mov	 esi, 33			; 00000021H

; 7279 : 				}
; 7280 : 				else if (WizardMode != WIZARD_MODE_SYS_DEVICE

  02061	e9 14 f6 ff ff	 jmp	 $LN310@MainDialog
$LN293@MainDialog:

; 7257 : 					}
; 7258 : 
; 7259 : 				}
; 7260 : 				else
; 7261 : 				{
; 7262 : 					KillTimer (hwndDlg, TIMER_ID_KEYB_LAYOUT_GUARD);

  02066	68 04 01 00 00	 push	 260			; 00000104H
  0206b	53		 push	 ebx
  0206c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 7263 : 
; 7264 : 					if (bKeyboardLayoutChanged)

  02072	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bKeyboardLayoutChanged@@3HA, 0 ; bKeyboardLayoutChanged
  02079	74 2f		 je	 SHORT $LN299@MainDialog

; 7265 : 					{
; 7266 : 						// Restore the original keyboard layout
; 7267 : 						if (LoadKeyboardLayout (OrigKeyboardLayout, KLF_ACTIVATE | KLF_SUBSTITUTE_OK) == NULL) 

  0207b	6a 03		 push	 3
  0207d	68 00 00 00 00	 push	 OFFSET ?OrigKeyboardLayout@@3PADA ; OrigKeyboardLayout
  02082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadKeyboardLayoutA@8
  02088	85 c0		 test	 eax, eax
  0208a	75 14		 jne	 SHORT $LN298@MainDialog

; 7268 : 							Warning ("CANNOT_RESTORE_KEYBOARD_LAYOUT");

  0208c	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BGCHIACG@CANNOT_RESTORE_KEYBOARD_LAYOUT?$AA@
  02091	e8 00 00 00 00	 call	 _Warning
  02096	83 c4 04	 add	 esp, 4

; 7271 : 					}
; 7272 : 
; 7273 : 					nNewPageNo = SYSENC_COLLECTING_RANDOM_DATA_PAGE - 1;	// Skip irrelevant pages

  02099	be 16 00 00 00	 mov	 esi, 22			; 00000016H
  0209e	eb b3		 jmp	 SHORT $LN294@MainDialog
$LN298@MainDialog:

; 7269 : 						else
; 7270 : 							bKeyboardLayoutChanged = FALSE;

  020a0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bKeyboardLayoutChanged@@3HA, 0 ; bKeyboardLayoutChanged
$LN299@MainDialog:

; 7271 : 					}
; 7272 : 
; 7273 : 					nNewPageNo = SYSENC_COLLECTING_RANDOM_DATA_PAGE - 1;	// Skip irrelevant pages

  020aa	be 16 00 00 00	 mov	 esi, 22			; 00000016H
  020af	eb a2		 jmp	 SHORT $LN294@MainDialog
$LN300@MainDialog:

; 7281 : 					&& !FileSize4GBLimitQuestionNeeded () 
; 7282 : 					|| CreatingHiddenSysVol())		// If we're creating a hidden volume for a hidden OS, we don't need to format it with any filesystem (the entire OS will be copied to the hidden volume sector by sector).

  020b1	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  020b8	74 09		 je	 SHORT $LN304@MainDialog
  020ba	e8 00 00 00 00	 call	 ?FileSize4GBLimitQuestionNeeded@@YAHXZ ; FileSize4GBLimitQuestionNeeded
  020bf	85 c0		 test	 eax, eax
  020c1	74 0d		 je	 SHORT $LN303@MainDialog
$LN304@MainDialog:
  020c3	e8 00 00 00 00	 call	 _CreatingHiddenSysVol
  020c8	85 c0		 test	 eax, eax
  020ca	0f 84 aa f5 ff
	ff		 je	 $LN310@MainDialog
$LN303@MainDialog:

; 7283 : 				{
; 7284 : 					nNewPageNo = FORMAT_PAGE - 1;				// Skip irrelevant pages

  020d0	be 25 00 00 00	 mov	 esi, 37			; 00000025H

; 7285 : 				}
; 7286 : 			}
; 7287 : 
; 7288 : 			else if (nCurPageNo == HIDDEN_VOL_HOST_PASSWORD_PAGE

  020d5	e9 a0 f5 ff ff	 jmp	 $LN310@MainDialog
$LN287@MainDialog:

; 7289 : 				|| nCurPageNo == NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE)

  020da	83 f8 14	 cmp	 eax, 20			; 00000014H
  020dd	0f 84 2a 13 00
	00		 je	 $LN307@MainDialog
  020e3	83 f8 20	 cmp	 eax, 32			; 00000020H
  020e6	0f 84 21 13 00
	00		 je	 $LN307@MainDialog

; 7478 : 				}
; 7479 : 
; 7480 : 			}
; 7481 : 
; 7482 : 			else if (nCurPageNo == FILESYS_PAGE)

  020ec	83 f8 16	 cmp	 eax, 22			; 00000016H
  020ef	0f 85 a2 01 00
	00		 jne	 $LN338@MainDialog

; 7483 : 			{
; 7484 : 				if (!bHiddenVol && IsHiddenOSRunning() && Get2RadButtonPageAnswer() == 1)

  020f5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  020fc	0f 85 6a 01 00
	00		 jne	 $LN340@MainDialog
  02102	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  02107	85 c0		 test	 eax, eax
  02109	0f 84 5d 01 00
	00		 je	 $LN340@MainDialog
  0210f	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  02114	83 f8 01	 cmp	 eax, 1
  02117	0f 85 4f 01 00
	00		 jne	 $LN340@MainDialog

; 7485 : 				{
; 7486 : 					// The user wants to store files larger than 4GB on the non-hidden volume about to be created and a hidden OS is running
; 7487 : 
; 7488 : 					WarningDirect ((wstring (GetString ("CANNOT_SATISFY_OVER_4G_FILE_SIZE_REQ"))

  0211d	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HFPIFBIF@CANNOT_SATISFY_OVER_4G_FILE_SIZE@
  02122	e8 00 00 00 00	 call	 _GetString
  02127	83 c4 04	 add	 esp, 4
  0212a	8d 8d c0 33 ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp]
  02130	50		 push	 eax
  02131	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02136	68 00 00 00 00	 push	 OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  0213b	50		 push	 eax
  0213c	8d 85 d8 33 ff
	ff		 lea	 eax, DWORD PTR $T62[ebp]
  02142	c7 45 fc 2a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 42 ; 0000002aH
  02149	50		 push	 eax
  0214a	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0214f	8b f0		 mov	 esi, eax
  02151	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KNHACFHE@CANNOT_CREATE_NON_HIDDEN_NTFS_VO@
  02156	c6 45 fc 2b	 mov	 BYTE PTR __$EHRec$[ebp+12], 43 ; 0000002bH
  0215a	e8 00 00 00 00	 call	 _GetString
  0215f	50		 push	 eax
  02160	8d 85 f0 33 ff
	ff		 lea	 eax, DWORD PTR $T63[ebp]
  02166	56		 push	 esi
  02167	50		 push	 eax
  02168	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0216d	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  02172	50		 push	 eax
  02173	8d 85 08 34 ff
	ff		 lea	 eax, DWORD PTR $T64[ebp]
  02179	c6 45 fc 2c	 mov	 BYTE PTR __$EHRec$[ebp+12], 44 ; 0000002cH
  0217d	50		 push	 eax
  0217e	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02183	8b f0		 mov	 esi, eax
  02185	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JPAMOBPC@NOTE_BEGINNING?$AA@
  0218a	c6 45 fc 2d	 mov	 BYTE PTR __$EHRec$[ebp+12], 45 ; 0000002dH
  0218e	e8 00 00 00 00	 call	 _GetString
  02193	50		 push	 eax
  02194	8d 85 20 34 ff
	ff		 lea	 eax, DWORD PTR $T65[ebp]
  0219a	56		 push	 esi
  0219b	50		 push	 eax
  0219c	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  021a1	8b f0		 mov	 esi, eax
  021a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LFCLDECM@HIDDEN_OS_WRITE_PROTECTION_BRIEF@
  021a8	c6 45 fc 2e	 mov	 BYTE PTR __$EHRec$[ebp+12], 46 ; 0000002eH
  021ac	e8 00 00 00 00	 call	 _GetString
  021b1	50		 push	 eax
  021b2	8d 85 38 34 ff
	ff		 lea	 eax, DWORD PTR $T66[ebp]
  021b8	56		 push	 esi
  021b9	50		 push	 eax
  021ba	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  021bf	83 c4 48	 add	 esp, 72			; 00000048H
  021c2	68 00 00 00 00	 push	 OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  021c7	50		 push	 eax
  021c8	8d 85 50 34 ff
	ff		 lea	 eax, DWORD PTR $T67[ebp]
  021ce	c6 45 fc 2f	 mov	 BYTE PTR __$EHRec$[ebp+12], 47 ; 0000002fH
  021d2	50		 push	 eax
  021d3	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  021d8	8b f0		 mov	 esi, eax
  021da	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OILEALFF@HIDDEN_OS_WRITE_PROTECTION_EXPLA@
  021df	c6 45 fc 30	 mov	 BYTE PTR __$EHRec$[ebp+12], 48 ; 00000030H
  021e3	e8 00 00 00 00	 call	 _GetString
  021e8	50		 push	 eax
  021e9	8d 85 68 34 ff
	ff		 lea	 eax, DWORD PTR $T68[ebp]
  021ef	56		 push	 esi
  021f0	50		 push	 eax
  021f1	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  021f6	83 c4 1c	 add	 esp, 28			; 0000001cH
  021f9	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  021fd	72 02		 jb	 SHORT $LN1125@MainDialog
  021ff	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1125@MainDialog:
  02201	50		 push	 eax
  02202	e8 00 00 00 00	 call	 _WarningDirect
  02207	83 c4 04	 add	 esp, 4
  0220a	8d 8d 68 34 ff
	ff		 lea	 ecx, DWORD PTR $T68[ebp]
  02210	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02215	8d 8d 50 34 ff
	ff		 lea	 ecx, DWORD PTR $T67[ebp]
  0221b	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02220	8d 8d 38 34 ff
	ff		 lea	 ecx, DWORD PTR $T66[ebp]
  02226	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0222b	8d 8d 20 34 ff
	ff		 lea	 ecx, DWORD PTR $T65[ebp]
  02231	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02236	8d 8d 08 34 ff
	ff		 lea	 ecx, DWORD PTR $T64[ebp]
  0223c	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02241	8d 8d f0 33 ff
	ff		 lea	 ecx, DWORD PTR $T63[ebp]
  02247	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0224c	8d 8d d8 33 ff
	ff		 lea	 ecx, DWORD PTR $T62[ebp]
  02252	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02257	8d 8d c0 33 ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp]
  0225d	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$ovf_end_33$1550:

; 6074 : 			}
; 6075 : 			return 1;

  02262	b8 01 00 00 00	 mov	 eax, 1
  02267	e9 43 de ff ff	 jmp	 $LN1@MainDialog
$LN340@MainDialog:

; 7489 : 						+ L" "
; 7490 : 						+ GetString ("CANNOT_CREATE_NON_HIDDEN_NTFS_VOLUMES_UNDER_HIDDEN_OS")
; 7491 : 						+ L"\n\n"
; 7492 : 						+ GetString ("NOTE_BEGINNING")
; 7493 : 						+ GetString ("HIDDEN_OS_WRITE_PROTECTION_BRIEF_INFO")
; 7494 : 						+ L" "
; 7495 : 						+ GetString ("HIDDEN_OS_WRITE_PROTECTION_EXPLANATION")).c_str());
; 7496 : 
; 7497 : 					return 1;
; 7498 : 				}
; 7499 : 
; 7500 : 				if (nNeedToStoreFilesOver4GB != Get2RadButtonPageAnswer())

  0226c	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  02271	39 05 00 00 00
	00		 cmp	 DWORD PTR ?nNeedToStoreFilesOver4GB@@3HA, eax ; nNeedToStoreFilesOver4GB
  02277	74 0a		 je	 SHORT $LN341@MainDialog

; 7501 : 					fileSystem = FILESYS_NONE;	// The user may have gone back and changed the answer, so default file system must be reselected

  02279	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?fileSystem@@3HC, 0 ; fileSystem
$LN341@MainDialog:

; 7502 : 	
; 7503 : 				nNeedToStoreFilesOver4GB = Get2RadButtonPageAnswer();

  02283	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  02288	a3 00 00 00 00	 mov	 DWORD PTR ?nNeedToStoreFilesOver4GB@@3HA, eax ; nNeedToStoreFilesOver4GB

; 7504 : 
; 7505 : 				nNewPageNo = FORMAT_PAGE - 1;	// Skip irrelevant pages

  0228d	be 25 00 00 00	 mov	 esi, 37			; 00000025H

; 7506 : 			}
; 7507 : 
; 7508 : 			else if (nCurPageNo == SYSENC_COLLECTING_RANDOM_DATA_PAGE

  02292	e9 e3 f3 ff ff	 jmp	 $LN310@MainDialog
$LN338@MainDialog:

; 7509 : 				|| nCurPageNo == NONSYS_INPLACE_ENC_RAND_DATA_PAGE)

  02297	83 f8 17	 cmp	 eax, 23			; 00000017H
  0229a	0f 84 a5 10 00
	00		 je	 $LN344@MainDialog
  022a0	83 f8 22	 cmp	 eax, 34			; 00000022H
  022a3	0f 84 9c 10 00
	00		 je	 $LN344@MainDialog

; 7538 : 			}
; 7539 : 
; 7540 : 			else if (nCurPageNo == SYSENC_KEYS_GEN_PAGE)

  022a9	83 f8 18	 cmp	 eax, 24			; 00000018H
  022ac	75 43		 jne	 SHORT $LN347@MainDialog

; 7541 : 			{
; 7542 : 				char tmp[KEY_GUI_VIEW_SIZE+1];
; 7543 : 
; 7544 : 				// Attempt to wipe the GUI fields showing portions of the master and header keys
; 7545 : 				memset (tmp, 'X', sizeof(tmp));

  022ae	6a 41		 push	 65			; 00000041H
  022b0	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR _tmp$94[ebp]
  022b6	6a 58		 push	 88			; 00000058H
  022b8	50		 push	 eax
  022b9	e8 00 00 00 00	 call	 _memset

; 7546 : 				tmp [sizeof(tmp)-1] = 0;
; 7547 : 				SetWindowText (hMasterKey, tmp);

  022be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  022c4	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR _tmp$94[ebp]
  022ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  022cd	c6 85 4c fe ff
	ff 00		 mov	 BYTE PTR _tmp$94[ebp+64], 0
  022d4	50		 push	 eax
  022d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMasterKey
  022da	50		 push	 eax
  022db	ff d6		 call	 esi

; 7548 : 				SetWindowText (hHeaderKey, tmp);

  022dd	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR _tmp$94[ebp]
  022e3	50		 push	 eax
  022e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _hHeaderKey
  022e9	50		 push	 eax
  022ea	ff d6		 call	 esi
  022ec	e9 83 f3 ff ff	 jmp	 $LN1474@MainDialog
$LN347@MainDialog:

; 7549 : 			}
; 7550 : 
; 7551 : 			else if (nCurPageNo == SYSENC_RESCUE_DISK_CREATION_PAGE)

  022f1	83 f8 19	 cmp	 eax, 25			; 00000019H
  022f4	0f 85 d6 01 00
	00		 jne	 $LN349@MainDialog

; 7552 : 			{
; 7553 : 				/* Generate rescue disk for boot encryption */
; 7554 : 
; 7555 : 				GetWindowText (GetDlgItem (hCurPage, IDC_RESCUE_DISK_ISO_PATH), szRescueDiskISO, sizeof (szRescueDiskISO));

  022fa	68 05 01 00 00	 push	 261			; 00000105H
  022ff	68 00 00 00 00	 push	 OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  02304	68 e9 03 00 00	 push	 1001			; 000003e9H
  02309	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0230f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  02315	50		 push	 eax
  02316	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 7556 : 
; 7557 : 				try

  0231c	c7 45 fc 34 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 52 ; 00000034H

; 7558 : 				{
; 7559 : 					WaitCursor();

  02323	e8 00 00 00 00	 call	 _WaitCursor

; 7560 : 					BootEncObj->CreateRescueIsoImage (true, szRescueDiskISO);

  02328	68 00 00 00 00	 push	 OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  0232d	8d 8d c8 34 ff
	ff		 lea	 ecx, DWORD PTR $T72[ebp]
  02333	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  02338	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0233e	8d 85 c8 34 ff
	ff		 lea	 eax, DWORD PTR $T72[ebp]
  02344	50		 push	 eax
  02345	6a 01		 push	 1
  02347	c6 45 fc 35	 mov	 BYTE PTR __$EHRec$[ebp+12], 53 ; 00000035H
  0234b	e8 00 00 00 00	 call	 ?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::BootEncryption::CreateRescueIsoImage
  02350	8d 8d c8 34 ff
	ff		 lea	 ecx, DWORD PTR $T72[ebp]
  02356	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 7568 : 				}
; 7569 : 
; 7570 : retryCDDriveCheck:
; 7571 : 				if (!bDontVerifyRescueDisk && !BootEncObj->IsCDDrivePresent())

  0235b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDontVerifyRescueDisk@@3HA, 0 ; bDontVerifyRescueDisk
  02362	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  02369	0f 85 75 00 00
	00		 jne	 $LN1478@MainDialog
  0236f	90		 npad	 1
$retryCDDriveCheck$1551:
  02370	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  02376	e8 00 00 00 00	 call	 ?IsCDDrivePresent@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::IsCDDrivePresent
  0237b	84 c0		 test	 al, al
  0237d	75 65		 jne	 SHORT $LN1478@MainDialog

; 7572 : 				{
; 7573 : 					char *multiChoiceStr[] = { 0, "CD_BURNER_NOT_PRESENT",
; 7574 : 						"CD_BURNER_NOT_PRESENT_WILL_STORE_ISO",
; 7575 : 						"CD_BURNER_NOT_PRESENT_WILL_CONNECT_LATER",
; 7576 : 						"CD_BURNER_NOT_PRESENT_CONNECTED_NOW",
; 7577 : 						0 };
; 7578 : 
; 7579 : 					switch (AskMultiChoice ((void **) multiChoiceStr, FALSE))

  0237f	8d 85 78 35 ff
	ff		 lea	 eax, DWORD PTR _multiChoiceStr$83[ebp]
  02385	c7 85 78 35 ff
	ff 00 00 00 00	 mov	 DWORD PTR _multiChoiceStr$83[ebp], 0
  0238f	6a 00		 push	 0
  02391	50		 push	 eax
  02392	c7 85 7c 35 ff
	ff 00 00 00 00	 mov	 DWORD PTR _multiChoiceStr$83[ebp+4], OFFSET ??_C@_0BG@GLKAIFEA@CD_BURNER_NOT_PRESENT?$AA@
  0239c	c7 85 80 35 ff
	ff 00 00 00 00	 mov	 DWORD PTR _multiChoiceStr$83[ebp+8], OFFSET ??_C@_0CF@OBJIPJKN@CD_BURNER_NOT_PRESENT_WILL_STORE@
  023a6	c7 85 84 35 ff
	ff 00 00 00 00	 mov	 DWORD PTR _multiChoiceStr$83[ebp+12], OFFSET ??_C@_0CJ@FCOKHALJ@CD_BURNER_NOT_PRESENT_WILL_CONNE@
  023b0	c7 85 88 35 ff
	ff 00 00 00 00	 mov	 DWORD PTR _multiChoiceStr$83[ebp+16], OFFSET ??_C@_0CE@FEAJEJEJ@CD_BURNER_NOT_PRESENT_CONNECTED_@
  023ba	c7 85 8c 35 ff
	ff 00 00 00 00	 mov	 DWORD PTR _multiChoiceStr$83[ebp+20], 0
  023c4	e8 00 00 00 00	 call	 _AskMultiChoice
  023c9	83 c4 08	 add	 esp, 8
  023cc	83 e8 01	 sub	 eax, 1
  023cf	74 49		 je	 SHORT $LN353@MainDialog
  023d1	83 e8 01	 sub	 eax, 1
  023d4	74 3d		 je	 SHORT $LN354@MainDialog
  023d6	83 e8 01	 sub	 eax, 1
  023d9	74 09		 je	 SHORT $LN1478@MainDialog

; 7568 : 				}
; 7569 : 
; 7570 : retryCDDriveCheck:
; 7571 : 				if (!bDontVerifyRescueDisk && !BootEncObj->IsCDDrivePresent())

  023db	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDontVerifyRescueDisk@@3HA, 0 ; bDontVerifyRescueDisk
  023e2	74 8c		 je	 SHORT $retryCDDriveCheck$1551
$LN1478@MainDialog:
  023e4	8b b5 6c 2d ff
	ff		 mov	 esi, DWORD PTR _nNewPageNo$1$[ebp]
$LN39@MainDialog:

; 7596 : 
; 7597 : 					default:
; 7598 : 						goto retryCDDriveCheck;
; 7599 : 					}
; 7600 : 				}
; 7601 : 
; 7602 : 				if (IsWindowsIsoBurnerAvailable() && !bDontVerifyRescueDisk)

  023ea	e8 00 00 00 00	 call	 _IsWindowsIsoBurnerAvailable
  023ef	85 c0		 test	 eax, eax
  023f1	74 16		 je	 SHORT $LN357@MainDialog
  023f3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDontVerifyRescueDisk@@3HA, 0 ; bDontVerifyRescueDisk
  023fa	75 0d		 jne	 SHORT $LN357@MainDialog

; 7603 : 					Info ("RESCUE_DISK_WIN_ISOBURN_PRELAUNCH_NOTE");

  023fc	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GAGHEKIC@RESCUE_DISK_WIN_ISOBURN_PRELAUNC@
  02401	e8 00 00 00 00	 call	 _Info
  02406	83 c4 04	 add	 esp, 4
$LN357@MainDialog:

; 7604 : 
; 7605 : 				NormalCursor ();

  02409	e8 00 00 00 00	 call	 _NormalCursor
  0240e	e9 67 f2 ff ff	 jmp	 $LN310@MainDialog
$LN354@MainDialog:

; 7589 : 						break;
; 7590 : 
; 7591 : 					case 2:
; 7592 : 						AbortProcessSilent();

  02413	e8 00 00 00 00	 call	 _AbortProcessSilent

; 7593 : 
; 7594 : 					case 3:
; 7595 : 						break;

  02418	eb ca		 jmp	 SHORT $LN1478@MainDialog
$LN353@MainDialog:

; 7580 : 					{
; 7581 : 					case 1:
; 7582 : 						wchar_t msg[8192];
; 7583 : 						swprintf_s (msg, array_capacity (msg), GetString ("CD_BURNER_NOT_PRESENT_WILL_STORE_ISO_INFO"), SingleStringToWide (szRescueDiskISO).c_str());

  0241a	68 00 00 00 00	 push	 OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  0241f	8d 8d b0 34 ff
	ff		 lea	 ecx, DWORD PTR $T71[ebp]
  02425	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0242a	8d 85 b0 34 ff
	ff		 lea	 eax, DWORD PTR $T71[ebp]
  02430	c7 45 fc 37 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 55 ; 00000037H
  02437	50		 push	 eax
  02438	8d 85 a8 33 ff
	ff		 lea	 eax, DWORD PTR $T60[ebp]
  0243e	50		 push	 eax
  0243f	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  02444	83 c4 08	 add	 esp, 8
  02447	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0244b	72 02		 jb	 SHORT $LN1142@MainDialog
  0244d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1142@MainDialog:
  0244f	50		 push	 eax
  02450	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BHLKCEED@CD_BURNER_NOT_PRESENT_WILL_STORE@
  02455	e8 00 00 00 00	 call	 _GetString
  0245a	83 c4 04	 add	 esp, 4
  0245d	50		 push	 eax
  0245e	8d 85 10 b4 ff
	ff		 lea	 eax, DWORD PTR _msg$87[ebp]
  02464	68 00 20 00 00	 push	 8192			; 00002000H
  02469	50		 push	 eax
  0246a	e8 00 00 00 00	 call	 _swprintf_s
  0246f	83 c4 10	 add	 esp, 16			; 00000010H
  02472	8d 8d a8 33 ff
	ff		 lea	 ecx, DWORD PTR $T60[ebp]
  02478	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0247d	8d 8d b0 34 ff
	ff		 lea	 ecx, DWORD PTR $T71[ebp]
  02483	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 7584 : 						WarningDirect (msg);

  02488	8d 85 10 b4 ff
	ff		 lea	 eax, DWORD PTR _msg$87[ebp]
  0248e	50		 push	 eax
  0248f	e8 00 00 00 00	 call	 _WarningDirect

; 7585 : 
; 7586 : 						Warning ("RESCUE_DISK_BURN_NO_CHECK_WARN");

  02494	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EJPBDEFG@RESCUE_DISK_BURN_NO_CHECK_WARN?$AA@
  02499	e8 00 00 00 00	 call	 _Warning
  0249e	83 c4 08	 add	 esp, 8

; 7587 : 						bDontVerifyRescueDisk = TRUE;

  024a1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDontVerifyRescueDisk@@3HA, 1 ; bDontVerifyRescueDisk

; 7588 : 						nNewPageNo = SYSENC_RESCUE_DISK_VERIFIED_PAGE;

  024ab	be 1b 00 00 00	 mov	 esi, 27			; 0000001bH
  024b0	e9 35 ff ff ff	 jmp	 $LN39@MainDialog
__catch$_MainDialogProc@16$31:

; 7561 : 
; 7562 : 				}
; 7563 : 				catch (Exception &e)
; 7564 : 				{
; 7565 : 					e.Show (hwndDlg);

  024b5	8b 8d d8 2c ff
	ff		 mov	 ecx, DWORD PTR _e$5[ebp]
  024bb	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  024c1	8b 01		 mov	 eax, DWORD PTR [ecx]
  024c3	ff 10		 call	 DWORD PTR [eax]

; 7566 : 					NormalCursor ();

  024c5	e8 00 00 00 00	 call	 _NormalCursor

; 7567 : 					return 1;

  024ca	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  024cf	c3		 ret	 0
$LN349@MainDialog:

; 7606 : 			}
; 7607 : 
; 7608 : 			else if (nCurPageNo == SYSENC_RESCUE_DISK_BURN_PAGE)

  024d0	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  024d3	0f 85 b4 00 00
	00		 jne	 $LN358@MainDialog

; 7609 : 			{
; 7610 : 				if (!bDontVerifyRescueDisk)

  024d9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDontVerifyRescueDisk@@3HA, 0 ; bDontVerifyRescueDisk
  024e0	0f 85 90 00 00
	00		 jne	 $LN360@MainDialog

; 7611 : 				{
; 7612 : 					/* Verify that the rescue disk has been written correctly */
; 7613 : 
; 7614 : 					try

  024e6	c7 45 fc 38 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 56 ; 00000038H

; 7615 : 					{
; 7616 : 						WaitCursor();

  024ed	e8 00 00 00 00	 call	 _WaitCursor

; 7617 : 						if (!BootEncObj->VerifyRescueDisk ())

  024f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  024f8	e8 00 00 00 00	 call	 ?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::VerifyRescueDisk
  024fd	84 c0		 test	 al, al
  024ff	0f 85 e3 0e 00
	00		 jne	 $LN363@MainDialog

; 7618 : 						{
; 7619 : 							wchar_t szTmp[8000];
; 7620 : 
; 7621 : 							swprintf (szTmp, GetString ("RESCUE_DISK_CHECK_FAILED"), 

  02505	e8 00 00 00 00	 call	 _IsWindowsIsoBurnerAvailable
  0250a	85 c0		 test	 eax, eax
  0250c	74 07		 je	 SHORT $LN540@MainDialog
  0250e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  02513	eb 0d		 jmp	 SHORT $LN541@MainDialog
$LN540@MainDialog:
  02515	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LCMPFPDG@RESCUE_DISK_CHECK_FAILED_SENTENC@
  0251a	e8 00 00 00 00	 call	 _GetString
  0251f	83 c4 04	 add	 esp, 4
$LN541@MainDialog:
  02522	50		 push	 eax
  02523	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KDGMPLJF@RESCUE_DISK_CHECK_FAILED?$AA@
  02528	e8 00 00 00 00	 call	 _GetString
  0252d	83 c4 04	 add	 esp, 4
  02530	50		 push	 eax
  02531	8d 85 90 75 ff
	ff		 lea	 eax, DWORD PTR _szTmp$86[ebp]
  02537	50		 push	 eax
  02538	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf

; 7622 : 								IsWindowsIsoBurnerAvailable () ? L"" : GetString ("RESCUE_DISK_CHECK_FAILED_SENTENCE_APPENDIX"));
; 7623 : 
; 7624 : 							ErrorDirect (szTmp);

  0253d	8d 85 90 75 ff
	ff		 lea	 eax, DWORD PTR _szTmp$86[ebp]
  02543	50		 push	 eax
  02544	e8 00 00 00 00	 call	 _ErrorDirect
  02549	83 c4 10	 add	 esp, 16			; 00000010H

; 7625 : 
; 7626 : 							NormalCursor ();

  0254c	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_34$1552:

; 6074 : 			}
; 6075 : 			return 1;

  02551	b8 01 00 00 00	 mov	 eax, 1
  02556	e9 54 db ff ff	 jmp	 $LN1@MainDialog
__catch$_MainDialogProc@16$33:

; 7627 : #ifndef _DEBUG
; 7628 : 							return 1;
; 7629 : #endif
; 7630 : 						}
; 7631 : 					}
; 7632 : 					catch (Exception &e)
; 7633 : 					{
; 7634 : 						e.Show (hwndDlg);

  0255b	8b 8d f0 2c ff
	ff		 mov	 ecx, DWORD PTR _e$11[ebp]
  02561	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  02567	8b 01		 mov	 eax, DWORD PTR [ecx]
  02569	ff 10		 call	 DWORD PTR [eax]

; 7635 : 						NormalCursor ();

  0256b	e8 00 00 00 00	 call	 _NormalCursor

; 7636 : 						return 1;

  02570	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  02575	c3		 ret	 0
$LN360@MainDialog:

; 7637 : 					}
; 7638 : 					NormalCursor ();
; 7639 : 				}
; 7640 : 				else
; 7641 : 				{
; 7642 : 					Warning ("RESCUE_DISK_BURN_NO_CHECK_WARN");

  02576	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EJPBDEFG@RESCUE_DISK_BURN_NO_CHECK_WARN?$AA@
  0257b	e8 00 00 00 00	 call	 _Warning
  02580	83 c4 04	 add	 esp, 4

; 7643 : 					nNewPageNo = SYSENC_RESCUE_DISK_VERIFIED_PAGE;		// Skip irrelevant pages

  02583	be 1b 00 00 00	 mov	 esi, 27			; 0000001bH

; 7644 : 				}
; 7645 : 			}
; 7646 : 
; 7647 : 			else if (nCurPageNo == SYSENC_WIPE_MODE_PAGE

  02588	e9 ed f0 ff ff	 jmp	 $LN310@MainDialog
$LN358@MainDialog:

; 7648 : 				|| nCurPageNo == NONSYS_INPLACE_ENC_WIPE_MODE_PAGE)

  0258d	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  02590	0f 84 82 0d 00
	00		 je	 $LN366@MainDialog
  02596	83 f8 23	 cmp	 eax, 35			; 00000023H
  02599	0f 84 79 0d 00
	00		 je	 $LN366@MainDialog

; 7652 : 					return 1;
; 7653 : 			}
; 7654 : 
; 7655 : 			else if (nCurPageNo == SYSENC_PRETEST_INFO_PAGE)

  0259f	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  025a2	0f 85 f5 01 00
	00		 jne	 $LN368@MainDialog

; 7656 : 			{
; 7657 : 				if (LocalizationActive
; 7658 : 					&& AskWarnYesNo ("PREBOOT_NOT_LOCALIZED") == IDNO)

  025a8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _LocalizationActive, 0
  025af	74 16		 je	 SHORT $LN370@MainDialog
  025b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DGIFCGMK@PREBOOT_NOT_LOCALIZED?$AA@
  025b6	e8 00 00 00 00	 call	 _AskWarnYesNo
  025bb	83 c4 04	 add	 esp, 4
  025be	83 f8 07	 cmp	 eax, 7
  025c1	0f 84 80 de ff
	ff		 je	 $LN15@MainDialog
$LN370@MainDialog:

; 7659 : 					return 1;
; 7660 : 
; 7661 : 				bConfirmQuitSysEncPretest = TRUE;

  025c7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bConfirmQuitSysEncPretest@@3HC, 1 ; bConfirmQuitSysEncPretest

; 7662 : 				
; 7663 : 				if (!bHiddenOS)	// This text is not tailored to hidden OS

  025d1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  025d8	75 0a		 jne	 SHORT $LN371@MainDialog

; 7664 : 					TextInfoDialogBox (GST_TBXID_SYS_ENCRYPTION_PRETEST);

  025da	6a 01		 push	 1
  025dc	e8 00 00 00 00	 call	 _TextInfoDialogBox
  025e1	83 c4 04	 add	 esp, 4
$LN371@MainDialog:

; 7665 : 
; 7666 : 				if (AskWarnYesNo ("CONFIRM_RESTART") == IDNO)

  025e4	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ICICKJJH@CONFIRM_RESTART?$AA@
  025e9	e8 00 00 00 00	 call	 _AskWarnYesNo
  025ee	83 c4 04	 add	 esp, 4
  025f1	83 f8 07	 cmp	 eax, 7
  025f4	0f 84 4d de ff
	ff		 je	 $LN15@MainDialog

; 7667 : 					return 1;
; 7668 : 
; 7669 : 				/* Install the pre-boot authentication component and initiate the system encryption pretest.
; 7670 : 				   If we are creating a hidden OS, pretest is omitted and OS cloning will follow. */
; 7671 : 
; 7672 : 				try

  025fa	c7 45 fc 3a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 58 ; 0000003aH

; 7673 : 				{
; 7674 : 					WaitCursor();

  02601	e8 00 00 00 00	 call	 _WaitCursor

; 7675 : 
; 7676 : #if 0
; 7677 : 					// Make sure the Rescue Disk is not in the drive
; 7678 : 					while (BootEncObj->VerifyRescueDisk ())
; 7679 : 					{
; 7680 : 						Error ("REMOVE_RESCUE_DISK_FROM_DRIVE");
; 7681 : 					}
; 7682 : #endif
; 7683 : 
; 7684 : 					BootEncObj->Install (bHiddenOS ? true : false);

  02606	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  0260d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  02613	0f 95 c0	 setne	 al
  02616	0f b6 c0	 movzx	 eax, al
  02619	50		 push	 eax
  0261a	e8 00 00 00 00	 call	 ?Install@BootEncryption@GostCrypt@@QAEX_N@Z ; GostCrypt::BootEncryption::Install

; 7692 : 				}
; 7693 : 
; 7694 : 
; 7695 : 				/* Add the main GostCrypt app to the system startup sequence (the GostCrypt Background Task), which
; 7696 : 				we need e.g. for notifications about prevented hibernation, about hidden OS leak protection, about 
; 7697 : 				inconsistent hidden OS installs (GostCrypt upgraded in the decoy system but not in the hidden one), etc.
; 7698 : 				Note that this must be done before calling ChangeSystemEncryptionStatus(), which broadcasts the change,
; 7699 : 				so that the main app (if it's running with different cached settings) will not overwrite our new
; 7700 : 				settings when it exits. */
; 7701 : 				bStartOnLogon = TRUE;
; 7702 : 				SaveSettings (NULL);

  0261f	6a 00		 push	 0
  02621	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  02628	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bStartOnLogon, 1
  02632	e8 00 00 00 00	 call	 _SaveSettings
  02637	83 c4 04	 add	 esp, 4
  0263a	e8 00 00 00 00	 call	 _ManageStartupSeq
  0263f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  02646	0f 84 73 00 00
	00		 je	 $LN374@MainDialog

; 7703 : 				ManageStartupSeq ();
; 7704 : 
; 7705 : 
; 7706 : 				if (bHiddenOS)
; 7707 : 				{
; 7708 : 					/* When we are going to create a hidden OS, the system encryption status is set
; 7709 : 					to SYSENC_STATUS_PRETEST (not to any special hidden-OS status), in case the XML 
; 7710 : 					configuration file and its properties somehow leaks somewhere outside the system
; 7711 : 					partition (which will be wiped later on) indicating that a hidden OS has been created
; 7712 : 					on the computer. Instead, we update our raw config flags in the master boot record
; 7713 : 					(which is also altered when our boot loader is installed). */
; 7714 : 
; 7715 : 					if (!ChangeSystemEncryptionStatus (SYSENC_STATUS_PRETEST)
; 7716 : 						|| !ChangeHiddenOSCreationPhase (GST_HIDDEN_OS_CREATION_PHASE_CLONING))

  0264c	e8 00 00 00 00	 call	 _CreateSysEncMutex
  02651	85 c0		 test	 eax, eax
  02653	75 0f		 jne	 SHORT $LN1147@MainDialog
  02655	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  0265a	e8 00 00 00 00	 call	 _Error
  0265f	83 c4 04	 add	 esp, 4
  02662	eb 38		 jmp	 SHORT $LN377@MainDialog
$LN1147@MainDialog:
  02664	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0266a	c7 05 00 00 00
	00 c8 00 00 00	 mov	 DWORD PTR _SystemEncryptionStatus, 200 ; 000000c8H
  02674	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 1
  0267e	e8 00 00 00 00	 call	 ?SaveSysEncSettings@@YAHPAUHWND__@@@Z ; SaveSysEncSettings
  02683	83 c4 04	 add	 esp, 4
  02686	85 c0		 test	 eax, eax
  02688	74 12		 je	 SHORT $LN377@MainDialog
  0268a	6a 40		 push	 64			; 00000040H
  0268c	e8 00 00 00 00	 call	 ?ChangeHiddenOSCreationPhase@@YAHH@Z ; ChangeHiddenOSCreationPhase
  02691	83 c4 04	 add	 esp, 4
  02694	85 c0		 test	 eax, eax
  02696	0f 85 7d 00 00
	00		 jne	 $LN378@MainDialog
$LN377@MainDialog:

; 7717 : 					{
; 7718 : 						ChangeSystemEncryptionStatus (SYSENC_STATUS_NONE);

  0269c	6a 00		 push	 0
  0269e	e8 00 00 00 00	 call	 ?ChangeSystemEncryptionStatus@@YAHH@Z ; ChangeSystemEncryptionStatus

; 7719 : 						Error ("CANNOT_INITIATE_HIDDEN_OS_CREATION");

  026a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DFDNFFMK@CANNOT_INITIATE_HIDDEN_OS_CREATI@
  026a8	e8 00 00 00 00	 call	 _Error
  026ad	83 c4 08	 add	 esp, 8

; 7720 : 						NormalCursor ();

  026b0	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_35$1553:

; 6074 : 			}
; 6075 : 			return 1;

  026b5	b8 01 00 00 00	 mov	 eax, 1
  026ba	e9 f0 d9 ff ff	 jmp	 $LN1@MainDialog
$LN374@MainDialog:

; 7721 : 						return 1;
; 7722 : 					}
; 7723 : 				}
; 7724 : 				else if (!ChangeSystemEncryptionStatus (SYSENC_STATUS_PRETEST))

  026bf	e8 00 00 00 00	 call	 _CreateSysEncMutex
  026c4	85 c0		 test	 eax, eax
  026c6	75 0f		 jne	 SHORT $LN1154@MainDialog
  026c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  026cd	e8 00 00 00 00	 call	 _Error
  026d2	83 c4 04	 add	 esp, 4
  026d5	eb 26		 jmp	 SHORT $LN1355@MainDialog
$LN1154@MainDialog:
  026d7	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  026dd	c7 05 00 00 00
	00 c8 00 00 00	 mov	 DWORD PTR _SystemEncryptionStatus, 200 ; 000000c8H
  026e7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionStatusChanged@@3HA, 1
  026f1	e8 00 00 00 00	 call	 ?SaveSysEncSettings@@YAHPAUHWND__@@@Z ; SaveSysEncSettings
  026f6	83 c4 04	 add	 esp, 4
  026f9	85 c0		 test	 eax, eax
  026fb	75 1c		 jne	 SHORT $LN378@MainDialog
$LN1355@MainDialog:

; 7725 : 				{
; 7726 : 					Error ("CANNOT_INITIATE_SYS_ENCRYPTION_PRETEST");

  026fd	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MGEMKCIE@CANNOT_INITIATE_SYS_ENCRYPTION_P@
  02702	e8 00 00 00 00	 call	 _Error
  02707	83 c4 04	 add	 esp, 4

; 7727 : 					NormalCursor ();

  0270a	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_36$1554:

; 6074 : 			}
; 6075 : 			return 1;

  0270f	b8 01 00 00 00	 mov	 eax, 1
  02714	e9 96 d9 ff ff	 jmp	 $LN1@MainDialog
$LN378@MainDialog:

; 7728 : 					return 1;
; 7729 : 				}
; 7730 : 
; 7731 : 				// Add the wizard to the system startup sequence
; 7732 : 				ManageStartupSeqWiz (FALSE, "/acsysenc");

  02719	68 00 00 00 00	 push	 OFFSET ??_C@_09PIOBCILE@?1acsysenc?$AA@
  0271e	6a 00		 push	 0
  02720	e8 00 00 00 00	 call	 _ManageStartupSeqWiz

; 7733 : 
; 7734 : 				EndMainDlg (MainDlg);

  02725	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0272b	e8 00 00 00 00	 call	 _EndMainDlg

; 7735 : 
; 7736 : 				try
; 7737 : 				{
; 7738 : 					BootEncObj->RestartComputer ();

  02730	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  02736	83 c4 0c	 add	 esp, 12			; 0000000cH
  02739	c7 45 fc 3c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 60 ; 0000003cH
  02740	e8 00 00 00 00	 call	 ?RestartComputer@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::RestartComputer
$ovf_end_37$1555:

; 6074 : 			}
; 6075 : 			return 1;

  02745	b8 01 00 00 00	 mov	 eax, 1
  0274a	e9 60 d9 ff ff	 jmp	 $LN1@MainDialog
__catch$_MainDialogProc@16$37:

; 7739 : 				}
; 7740 : 				catch (Exception &e)
; 7741 : 				{
; 7742 : 					e.Show (hwndDlg);

  0274f	8b 8d f4 2c ff
	ff		 mov	 ecx, DWORD PTR _e$12[ebp]
  02755	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  0275b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0275d	ff 10		 call	 DWORD PTR [eax]

; 7743 : 				}

  0275f	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  02764	c3		 ret	 0
__catch$_MainDialogProc@16$35:

; 7685 : 				}
; 7686 : 				catch (Exception &e)
; 7687 : 				{
; 7688 : 					e.Show (hwndDlg);

  02765	8b 8d ec 2c ff
	ff		 mov	 ecx, DWORD PTR _e$10[ebp]
  0276b	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  02771	8b 01		 mov	 eax, DWORD PTR [ecx]
  02773	ff 10		 call	 DWORD PTR [eax]

; 7689 : 					Error (bHiddenOS ? "CANNOT_INITIATE_HIDDEN_OS_CREATION" : "CANNOT_INITIATE_SYS_ENCRYPTION_PRETEST");

  02775	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenOS@@3HC ; bHiddenOS
  0277a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CH@MGEMKCIE@CANNOT_INITIATE_SYS_ENCRYPTION_P@
  0277f	85 c0		 test	 eax, eax
  02781	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CD@DFDNFFMK@CANNOT_INITIATE_HIDDEN_OS_CREATI@
  02786	0f 44 ca	 cmove	 ecx, edx
  02789	51		 push	 ecx
  0278a	e8 00 00 00 00	 call	 _Error
  0278f	83 c4 04	 add	 esp, 4

; 7690 : 					NormalCursor ();

  02792	e8 00 00 00 00	 call	 _NormalCursor

; 7691 : 					return 1;

  02797	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  0279c	c3		 ret	 0
$LN368@MainDialog:

; 7744 : 
; 7745 : 				return 1;
; 7746 : 			}
; 7747 : 			else if (nCurPageNo == SYSENC_PRETEST_RESULT_PAGE)

  0279d	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  027a0	75 19		 jne	 SHORT $LN380@MainDialog

; 7748 : 			{
; 7749 : 				TextInfoDialogBox (GST_TBXID_SYS_ENC_RESCUE_DISK);

  027a2	6a 02		 push	 2
  027a4	e8 00 00 00 00	 call	 _TextInfoDialogBox

; 7750 : 
; 7751 : 				// Begin the actual encryption process
; 7752 : 
; 7753 : 				ChangeSystemEncryptionStatus (SYSENC_STATUS_ENCRYPTING);

  027a9	68 90 01 00 00	 push	 400			; 00000190H
  027ae	e8 00 00 00 00	 call	 ?ChangeSystemEncryptionStatus@@YAHH@Z ; ChangeSystemEncryptionStatus
  027b3	83 c4 08	 add	 esp, 8

; 7754 : 			}
; 7755 : 
; 7756 : 			else if (nCurPageNo == SYSENC_ENCRYPTION_PAGE

  027b6	e9 b9 ee ff ff	 jmp	 $LN1474@MainDialog
$LN380@MainDialog:

; 7757 : 				&& CreateSysEncMutex ())

  027bb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  027be	75 5d		 jne	 SHORT $LN382@MainDialog
  027c0	e8 00 00 00 00	 call	 _CreateSysEncMutex
  027c5	85 c0		 test	 eax, eax
  027c7	74 4f		 je	 SHORT $LN1423@MainDialog

; 7758 : 			{
; 7759 : 				// The 'Next' button functions as Finish or Resume
; 7760 : 
; 7761 : 				if (SystemEncryptionStatus != SYSENC_STATUS_NONE)

  027c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionStatus, 0
  027d0	74 2c		 je	 SHORT $LN384@MainDialog

; 7762 : 				{
; 7763 : 					try

  027d2	c7 45 fc 3e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 62 ; 0000003eH

; 7764 : 					{
; 7765 : 						// Resume
; 7766 : 						SysEncResume ();

  027d9	e8 00 00 00 00	 call	 ?SysEncResume@@YAXXZ	; SysEncResume
$LN685@MainDialog:
$ovf_end_38$1556:

; 6074 : 			}
; 6075 : 			return 1;

  027de	b8 01 00 00 00	 mov	 eax, 1
  027e3	e9 c7 d8 ff ff	 jmp	 $LN1@MainDialog
__catch$_MainDialogProc@16$39:

; 7767 : 					}
; 7768 : 					catch (Exception &e)
; 7769 : 					{
; 7770 : 						e.Show (hwndDlg);

  027e8	8b 8d 04 2d ff
	ff		 mov	 ecx, DWORD PTR _e$16[ebp]
  027ee	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  027f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  027f6	ff 10		 call	 DWORD PTR [eax]

; 7771 : 					}

  027f8	b8 00 00 00 00	 mov	 eax, $LN685@MainDialog
  027fd	c3		 ret	 0
$LN384@MainDialog:

; 7772 : 				}
; 7773 : 				else
; 7774 : 				{
; 7775 : 					// Finish
; 7776 : 					PostMessage (hwndDlg, GST_APPMSG_FORMAT_USER_QUIT, 0, 0);

  027fe	6a 00		 push	 0
  02800	6a 00		 push	 0
  02802	68 2f 81 00 00	 push	 33071			; 0000812fH
  02807	53		 push	 ebx
  02808	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
$ovf_end_39$1557:

; 6074 : 			}
; 6075 : 			return 1;

  0280e	b8 01 00 00 00	 mov	 eax, 1
  02813	e9 97 d8 ff ff	 jmp	 $LN1@MainDialog
$LN1423@MainDialog:

; 7777 : 				}
; 7778 : 
; 7779 : 				return 1;

  02818	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
$LN382@MainDialog:

; 7780 : 			}
; 7781 : 			else if (nCurPageNo == NONSYS_INPLACE_ENC_RESUME_PARTITION_SEL_PAGE)

  0281d	83 f8 21	 cmp	 eax, 33			; 00000021H
  02820	75 08		 jne	 SHORT $LN387@MainDialog

; 7782 : 			{
; 7783 : 				nNewPageNo = NONSYS_INPLACE_ENC_ENCRYPTION_PAGE - 1;	// Skip irrelevant pages

  02822	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  02825	e9 50 ee ff ff	 jmp	 $LN310@MainDialog
$LN387@MainDialog:

; 7784 : 			}
; 7785 : 			else if (nCurPageNo == NONSYS_INPLACE_ENC_ENCRYPTION_PAGE)

  0282a	83 f8 24	 cmp	 eax, 36			; 00000024H
  0282d	75 0f		 jne	 SHORT $LN389@MainDialog

; 7786 : 			{
; 7787 : 				/* In-place encryption start  (the 'Next' button has been clicked) */
; 7788 : 
; 7789 : 				NonSysInplaceEncResume ();

  0282f	e8 00 00 00 00	 call	 _NonSysInplaceEncResume
$ovf_end_40$1558:

; 6074 : 			}
; 6075 : 			return 1;

  02834	b8 01 00 00 00	 mov	 eax, 1
  02839	e9 71 d8 ff ff	 jmp	 $LN1@MainDialog
$LN389@MainDialog:

; 7790 : 				return 1;
; 7791 : 			}
; 7792 : 			else if (nCurPageNo == NONSYS_INPLACE_ENC_ENCRYPTION_FINISHED_PAGE)

  0283e	83 f8 25	 cmp	 eax, 37			; 00000025H
  02841	74 bb		 je	 SHORT $LN384@MainDialog

; 7793 : 			{
; 7794 : 				PostMessage (hwndDlg, GST_APPMSG_FORMAT_USER_QUIT, 0, 0);
; 7795 : 				return 1;
; 7796 : 			}
; 7797 : 			else if (nCurPageNo == FORMAT_PAGE)

  02843	83 f8 26	 cmp	 eax, 38			; 00000026H
  02846	0f 85 c4 05 00
	00		 jne	 $LN393@MainDialog

; 7798 : 			{
; 7799 : 				/* Format start  (the 'Next' button has been clicked on the Format page) */
; 7800 : 
; 7801 : 				if (bVolTransformThreadRunning || bVolTransformThreadToRun)

  0284c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  02853	0f 85 ee db ff
	ff		 jne	 $LN15@MainDialog
  02859	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  02860	0f 85 e1 db ff
	ff		 jne	 $LN15@MainDialog

; 7802 : 					return 1;
; 7803 : 				
; 7804 : 				bVolTransformThreadCancel = FALSE;
; 7805 : 
; 7806 : 				bVolTransformThreadToRun = TRUE;
; 7807 : 
; 7808 : 				fileSystem = SendMessage (GetDlgItem (hCurPage, IDC_FILESYS), CB_GETITEMDATA,

  02866	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0286c	6a 00		 push	 0
  0286e	6a 00		 push	 0
  02870	6a 00		 push	 0
  02872	68 47 01 00 00	 push	 327			; 00000147H
  02877	68 05 04 00 00	 push	 1029			; 00000405H
  0287c	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  02882	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bVolTransformThreadCancel, 0
  0288c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 1 ; bVolTransformThreadToRun
  02896	ff d7		 call	 edi
  02898	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  0289e	50		 push	 eax
  0289f	ff d6		 call	 esi
  028a1	50		 push	 eax
  028a2	68 50 01 00 00	 push	 336			; 00000150H
  028a7	68 05 04 00 00	 push	 1029			; 00000405H
  028ac	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  028b2	ff d7		 call	 edi
  028b4	50		 push	 eax
  028b5	ff d6		 call	 esi

; 7809 : 					SendMessage (GetDlgItem (hCurPage, IDC_FILESYS), CB_GETCURSEL, 0, 0) , 0);
; 7810 : 
; 7811 : 				clusterSize = SendMessage (GetDlgItem (hCurPage, IDC_CLUSTERSIZE), CB_GETITEMDATA,

  028b7	6a 00		 push	 0
  028b9	6a 00		 push	 0
  028bb	6a 00		 push	 0
  028bd	68 47 01 00 00	 push	 327			; 00000147H
  028c2	68 04 04 00 00	 push	 1028			; 00000404H
  028c7	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  028cd	a3 00 00 00 00	 mov	 DWORD PTR ?fileSystem@@3HC, eax ; fileSystem
  028d2	ff d7		 call	 edi
  028d4	50		 push	 eax
  028d5	ff d6		 call	 esi
  028d7	50		 push	 eax
  028d8	68 50 01 00 00	 push	 336			; 00000150H
  028dd	68 04 04 00 00	 push	 1028			; 00000404H
  028e2	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  028e8	ff d7		 call	 edi
  028ea	50		 push	 eax
  028eb	ff d6		 call	 esi

; 7812 : 					SendMessage (GetDlgItem (hCurPage, IDC_CLUSTERSIZE), CB_GETCURSEL, 0, 0) , 0);
; 7813 : 
; 7814 : 				quickFormat = IsButtonChecked (GetDlgItem (hCurPage, IDC_QUICKFORMAT));

  028ed	68 ff 03 00 00	 push	 1023			; 000003ffH
  028f2	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  028f8	a3 00 00 00 00	 mov	 DWORD PTR ?clusterSize@@3HC, eax ; clusterSize
  028fd	ff d7		 call	 edi
  028ff	50		 push	 eax
  02900	e8 00 00 00 00	 call	 _IsButtonChecked
  02905	83 c4 04	 add	 esp, 4
  02908	a3 00 00 00 00	 mov	 DWORD PTR ?quickFormat@@3HC, eax ; quickFormat

; 7815 : 
; 7816 : 
; 7817 : 				if (!bHiddenVol && IsHiddenOSRunning())

  0290d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  02914	0f 85 8f 01 00
	00		 jne	 $LN400@MainDialog
  0291a	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  0291f	85 c0		 test	 eax, eax
  02921	0f 84 82 01 00
	00		 je	 $LN400@MainDialog

; 7818 : 				{
; 7819 : 					// Creating a non-hidden volume under a hidden OS
; 7820 : 
; 7821 : 					if (fileSystem == FILESYS_NTFS)	

  02927	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?fileSystem@@3HC, 2 ; fileSystem
  0292e	0f 85 75 01 00
	00		 jne	 $LN400@MainDialog

; 7822 : 					{
; 7823 : 						WarningDirect ((wstring (GetString ("CANNOT_CREATE_NON_HIDDEN_NTFS_VOLUMES_UNDER_HIDDEN_OS"))

  02934	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KNHACFHE@CANNOT_CREATE_NON_HIDDEN_NTFS_VO@
  02939	e8 00 00 00 00	 call	 _GetString
  0293e	83 c4 04	 add	 esp, 4
  02941	8d 8d 18 33 ff
	ff		 lea	 ecx, DWORD PTR $T54[ebp]
  02947	50		 push	 eax
  02948	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0294d	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  02952	50		 push	 eax
  02953	8d 85 30 33 ff
	ff		 lea	 eax, DWORD PTR $T55[ebp]
  02959	c7 45 fc 40 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 64 ; 00000040H
  02960	50		 push	 eax
  02961	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02966	8b f0		 mov	 esi, eax
  02968	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JPAMOBPC@NOTE_BEGINNING?$AA@
  0296d	c6 45 fc 41	 mov	 BYTE PTR __$EHRec$[ebp+12], 65 ; 00000041H
  02971	e8 00 00 00 00	 call	 _GetString
  02976	50		 push	 eax
  02977	8d 85 48 33 ff
	ff		 lea	 eax, DWORD PTR $T56[ebp]
  0297d	56		 push	 esi
  0297e	50		 push	 eax
  0297f	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02984	8b f0		 mov	 esi, eax
  02986	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LFCLDECM@HIDDEN_OS_WRITE_PROTECTION_BRIEF@
  0298b	c6 45 fc 42	 mov	 BYTE PTR __$EHRec$[ebp+12], 66 ; 00000042H
  0298f	e8 00 00 00 00	 call	 _GetString
  02994	50		 push	 eax
  02995	8d 85 60 33 ff
	ff		 lea	 eax, DWORD PTR $T57[ebp]
  0299b	56		 push	 esi
  0299c	50		 push	 eax
  0299d	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  029a2	68 00 00 00 00	 push	 OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  029a7	50		 push	 eax
  029a8	8d 85 78 33 ff
	ff		 lea	 eax, DWORD PTR $T58[ebp]
  029ae	c6 45 fc 43	 mov	 BYTE PTR __$EHRec$[ebp+12], 67 ; 00000043H
  029b2	50		 push	 eax
  029b3	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  029b8	8b f0		 mov	 esi, eax
  029ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OILEALFF@HIDDEN_OS_WRITE_PROTECTION_EXPLA@
  029bf	c6 45 fc 44	 mov	 BYTE PTR __$EHRec$[ebp+12], 68 ; 00000044H
  029c3	e8 00 00 00 00	 call	 _GetString
  029c8	50		 push	 eax
  029c9	8d 85 90 33 ff
	ff		 lea	 eax, DWORD PTR $T59[ebp]
  029cf	56		 push	 esi
  029d0	50		 push	 eax
  029d1	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  029d6	83 c4 48	 add	 esp, 72			; 00000048H
  029d9	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  029dd	72 02		 jb	 SHORT $LN1173@MainDialog
  029df	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1173@MainDialog:
  029e1	50		 push	 eax
  029e2	e8 00 00 00 00	 call	 _WarningDirect
  029e7	83 c4 04	 add	 esp, 4
  029ea	8d 8d 90 33 ff
	ff		 lea	 ecx, DWORD PTR $T59[ebp]
  029f0	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  029f5	8d 8d 78 33 ff
	ff		 lea	 ecx, DWORD PTR $T58[ebp]
  029fb	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02a00	8d 8d 60 33 ff
	ff		 lea	 ecx, DWORD PTR $T57[ebp]
  02a06	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02a0b	8d 8d 48 33 ff
	ff		 lea	 ecx, DWORD PTR $T56[ebp]
  02a11	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02a16	8d 8d 30 33 ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  02a1c	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  02a21	8d 8d 18 33 ff
	ff		 lea	 ecx, DWORD PTR $T54[ebp]
  02a27	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  02a2e	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 7824 : 							+ L"\n\n"
; 7825 : 							+ GetString ("NOTE_BEGINNING")
; 7826 : 							+ GetString ("HIDDEN_OS_WRITE_PROTECTION_BRIEF_INFO")
; 7827 : 							+ L" "
; 7828 : 							+ GetString ("HIDDEN_OS_WRITE_PROTECTION_EXPLANATION")).c_str());
; 7829 : 
; 7830 : 						if (GetVolumeDataAreaSize (FALSE, nVolumeSize) <= GST_MAX_FAT_SECTOR_COUNT * GetFormatSectorSize()
; 7831 : 							&& AskYesNo("OFFER_FAT_FORMAT_ALTERNATIVE") == IDYES)

  02a33	ff 35 04 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA+4
  02a39	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA
  02a3f	6a 00		 push	 0
  02a41	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  02a46	83 c4 0c	 add	 esp, 12			; 0000000cH
  02a49	89 85 60 2d ff
	ff		 mov	 DWORD PTR tv4953[ebp], eax
  02a4f	8b f2		 mov	 esi, edx
  02a51	e8 00 00 00 00	 call	 _GetFormatSectorSize
  02a56	99		 cdq
  02a57	3b f0		 cmp	 esi, eax
  02a59	0f 87 78 01 00
	00		 ja	 $LN399@MainDialog
  02a5f	72 0d		 jb	 SHORT $LN1384@MainDialog
  02a61	83 bd 60 2d ff
	ff 00		 cmp	 DWORD PTR tv4953[ebp], 0
  02a68	0f 87 69 01 00
	00		 ja	 $LN399@MainDialog
$LN1384@MainDialog:
  02a6e	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@EFIGHBDJ@OFFER_FAT_FORMAT_ALTERNATIVE?$AA@
  02a73	e8 00 00 00 00	 call	 _AskYesNo
  02a78	83 c4 04	 add	 esp, 4
  02a7b	83 f8 06	 cmp	 eax, 6
  02a7e	0f 85 53 01 00
	00		 jne	 $LN399@MainDialog

; 7832 : 						{
; 7833 : 							fileSystem = FILESYS_FAT;
; 7834 : 							SelectAlgo (GetDlgItem (hCurPage, IDC_FILESYS), (int *) &fileSystem);

  02a84	68 00 00 00 00	 push	 OFFSET ?fileSystem@@3HC	; fileSystem
  02a89	68 05 04 00 00	 push	 1029			; 00000405H
  02a8e	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  02a94	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?fileSystem@@3HC, 1 ; fileSystem
  02a9e	ff d7		 call	 edi
  02aa0	50		 push	 eax
  02aa1	e8 00 00 00 00	 call	 _SelectAlgo
  02aa6	83 c4 08	 add	 esp, 8
$LN400@MainDialog:

; 7842 : 							return 1;
; 7843 : 						}
; 7844 : 					}
; 7845 : 				}
; 7846 : 
; 7847 : 				if (bHiddenVolHost)

  02aa9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  02ab0	0f 84 c5 01 00
	00		 je	 $LN402@MainDialog

; 7848 : 				{
; 7849 : 					hiddenVolHostDriveNo = -1;
; 7850 : 					nMaximumHiddenVolSize = 0;
; 7851 : 
; 7852 : 					if (fileSystem == FILESYS_NTFS)	

  02ab6	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?fileSystem@@3HC, 2 ; fileSystem
  02abd	0f 57 c0	 xorps	 xmm0, xmm0
  02ac0	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?hiddenVolHostDriveNo@@3HA, -1 ; hiddenVolHostDriveNo
  02aca	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nMaximumHiddenVolSize@@3_JA, xmm0
  02ad2	0f 85 bb 01 00
	00		 jne	 $LN413@MainDialog

; 7853 : 					{
; 7854 : 						if (bHiddenOS
; 7855 : 							&& (double) nVolumeSize / GetSystemPartitionSize() < MIN_HIDDENOS_DECOY_PARTITION_SIZE_RATIO_NTFS)

  02ad8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  02adf	0f 84 bb 00 00
	00		 je	 $LN407@MainDialog
  02ae5	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?nVolumeSize@@3_KA+4
  02aeb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nVolumeSize@@3_KA
  02af1	e8 00 00 00 00	 call	 __ultod3
  02af6	f2 0f 11 85 5c
	2d ff ff	 movsd	 QWORD PTR tv4970[ebp], xmm0
  02afe	e8 00 00 00 00	 call	 ?GetSystemPartitionSize@@YA_JXZ ; GetSystemPartitionSize
  02b03	8b c8		 mov	 ecx, eax
  02b05	e8 00 00 00 00	 call	 __ltod3
  02b0a	f2 0f 10 95 5c
	2d ff ff	 movsd	 xmm2, QWORD PTR tv4970[ebp]
  02b12	f2 0f 5e d0	 divsd	 xmm2, xmm0
  02b16	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000cccccccccccd
  02b1e	66 0f 2f ca	 comisd	 xmm1, xmm2
  02b22	0f 86 78 00 00
	00		 jbe	 $LN407@MainDialog

; 7856 : 						{
; 7857 : 							Error("OUTER_VOLUME_TOO_SMALL_FOR_HIDDEN_OS_NTFS");

  02b28	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PNCJJOHK@OUTER_VOLUME_TOO_SMALL_FOR_HIDDE@
  02b2d	e8 00 00 00 00	 call	 _Error

; 7858 : 
; 7859 : 							if (GetVolumeDataAreaSize (FALSE, nVolumeSize) <= GST_MAX_FAT_SECTOR_COUNT * GetFormatSectorSize()
; 7860 : 								&& AskYesNo("OFFER_FAT_FORMAT_ALTERNATIVE") == IDYES)

  02b32	ff 35 04 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA+4
  02b38	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA
  02b3e	6a 00		 push	 0
  02b40	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  02b45	83 c4 10	 add	 esp, 16			; 00000010H
  02b48	89 85 60 2d ff
	ff		 mov	 DWORD PTR tv4980[ebp], eax
  02b4e	8b f2		 mov	 esi, edx
  02b50	e8 00 00 00 00	 call	 _GetFormatSectorSize
  02b55	99		 cdq
  02b56	3b f0		 cmp	 esi, eax
  02b58	0f 87 79 00 00
	00		 ja	 $LN399@MainDialog
  02b5e	72 09		 jb	 SHORT $LN1386@MainDialog
  02b60	83 bd 60 2d ff
	ff 00		 cmp	 DWORD PTR tv4980[ebp], 0
  02b67	77 6e		 ja	 SHORT $LN399@MainDialog
$LN1386@MainDialog:
  02b69	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@EFIGHBDJ@OFFER_FAT_FORMAT_ALTERNATIVE?$AA@
  02b6e	e8 00 00 00 00	 call	 _AskYesNo
  02b73	83 c4 04	 add	 esp, 4
  02b76	83 f8 06	 cmp	 eax, 6
  02b79	75 5c		 jne	 SHORT $LN399@MainDialog

; 7861 : 							{
; 7862 : 								fileSystem = FILESYS_FAT;
; 7863 : 								SelectAlgo (GetDlgItem (hCurPage, IDC_FILESYS), (int *) &fileSystem);

  02b7b	68 00 00 00 00	 push	 OFFSET ?fileSystem@@3HC	; fileSystem
  02b80	68 05 04 00 00	 push	 1029			; 00000405H
  02b85	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  02b8b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?fileSystem@@3HC, 1 ; fileSystem
  02b95	ff d7		 call	 edi
  02b97	50		 push	 eax
  02b98	e8 00 00 00 00	 call	 _SelectAlgo
  02b9d	83 c4 08	 add	 esp, 8
$LN407@MainDialog:

; 7864 : 							}
; 7865 : 							else
; 7866 : 							{
; 7867 : 								if (GetVolumeDataAreaSize (FALSE, nVolumeSize) > GST_MAX_FAT_SECTOR_COUNT * GetFormatSectorSize())
; 7868 : 									Info ("FAT_NOT_AVAILABLE_FOR_SO_LARGE_VOLUME");
; 7869 : 
; 7870 : 								bVolTransformThreadToRun = FALSE;
; 7871 : 								return 1;
; 7872 : 							}
; 7873 : 						}
; 7874 : 
; 7875 : 						if (fileSystem == FILESYS_NTFS)	// The file system may have been changed in the previous block

  02ba0	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?fileSystem@@3HC, 2 ; fileSystem
  02ba7	0f 85 e6 00 00
	00		 jne	 $LN413@MainDialog

; 7876 : 						{
; 7877 : 							if (nCurrentOS == WIN_2000)

  02bad	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _nCurrentOS, 7
  02bb4	75 6c		 jne	 SHORT $LN410@MainDialog

; 7878 : 							{
; 7879 : 								Error("HIDDEN_VOL_HOST_UNSUPPORTED_FILESYS_WIN2000");

  02bb6	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PCAIDDLK@HIDDEN_VOL_HOST_UNSUPPORTED_FILE@
  02bbb	e8 00 00 00 00	 call	 _Error
  02bc0	83 c4 04	 add	 esp, 4
  02bc3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
$ovf_end_41$1559:

; 6074 : 			}
; 6075 : 			return 1;

  02bcd	b8 01 00 00 00	 mov	 eax, 1
  02bd2	e9 d8 d4 ff ff	 jmp	 $LN1@MainDialog
$LN399@MainDialog:

; 7835 : 						}
; 7836 : 						else
; 7837 : 						{
; 7838 : 							if (GetVolumeDataAreaSize (FALSE, nVolumeSize) > GST_MAX_FAT_SECTOR_COUNT * GetFormatSectorSize())

  02bd7	ff 35 04 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA+4
  02bdd	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA
  02be3	6a 00		 push	 0
  02be5	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  02bea	83 c4 0c	 add	 esp, 12			; 0000000cH
  02bed	8b f2		 mov	 esi, edx
  02bef	8b f8		 mov	 edi, eax
  02bf1	e8 00 00 00 00	 call	 _GetFormatSectorSize
  02bf6	99		 cdq
  02bf7	3b f0		 cmp	 esi, eax
  02bf9	72 13		 jb	 SHORT $LN401@MainDialog
  02bfb	77 04		 ja	 SHORT $LN1385@MainDialog
  02bfd	85 ff		 test	 edi, edi
  02bff	74 0d		 je	 SHORT $LN401@MainDialog
$LN1385@MainDialog:

; 7839 : 								Info ("FAT_NOT_AVAILABLE_FOR_SO_LARGE_VOLUME");

  02c01	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HAPBHPDC@FAT_NOT_AVAILABLE_FOR_SO_LARGE_V@
  02c06	e8 00 00 00 00	 call	 _Info
  02c0b	83 c4 04	 add	 esp, 4
$LN401@MainDialog:

; 7840 : 
; 7841 : 							bVolTransformThreadToRun = FALSE;

  02c0e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
$ovf_end_42$1560:

; 6074 : 			}
; 6075 : 			return 1;

  02c18	b8 01 00 00 00	 mov	 eax, 1
  02c1d	e9 8d d4 ff ff	 jmp	 $LN1@MainDialog
$LN410@MainDialog:

; 7880 : 								bVolTransformThreadToRun = FALSE;
; 7881 : 								return 1;
; 7882 : 							}
; 7883 : 							else if (GetVolumeDataAreaSize (FALSE, nVolumeSize) <= GST_MAX_FAT_SECTOR_COUNT * GetFormatSectorSize()
; 7884 : 								&& AskYesNo("HIDDEN_VOL_HOST_NTFS_ASK") == IDNO)

  02c22	ff 35 04 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA+4
  02c28	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA
  02c2e	6a 00		 push	 0
  02c30	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  02c35	83 c4 0c	 add	 esp, 12			; 0000000cH
  02c38	89 85 60 2d ff
	ff		 mov	 DWORD PTR tv4999[ebp], eax
  02c3e	8b f2		 mov	 esi, edx
  02c40	e8 00 00 00 00	 call	 _GetFormatSectorSize
  02c45	99		 cdq
  02c46	3b f0		 cmp	 esi, eax
  02c48	77 49		 ja	 SHORT $LN413@MainDialog
  02c4a	72 09		 jb	 SHORT $LN1388@MainDialog
  02c4c	83 bd 60 2d ff
	ff 00		 cmp	 DWORD PTR tv4999[ebp], 0
  02c53	77 3e		 ja	 SHORT $LN413@MainDialog
$LN1388@MainDialog:
  02c55	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@NALGNOGO@HIDDEN_VOL_HOST_NTFS_ASK?$AA@
  02c5a	e8 00 00 00 00	 call	 _AskYesNo
  02c5f	83 c4 04	 add	 esp, 4
  02c62	83 f8 07	 cmp	 eax, 7
  02c65	75 2c		 jne	 SHORT $LN413@MainDialog

; 7840 : 
; 7841 : 							bVolTransformThreadToRun = FALSE;

  02c67	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
$ovf_end_43$1561:

; 6074 : 			}
; 6075 : 			return 1;

  02c71	b8 01 00 00 00	 mov	 eax, 1
  02c76	e9 34 d4 ff ff	 jmp	 $LN1@MainDialog
$LN402@MainDialog:

; 7885 : 							{
; 7886 : 								bVolTransformThreadToRun = FALSE;
; 7887 : 								return 1;
; 7888 : 							}
; 7889 : 						}
; 7890 : 					}
; 7891 : 				}
; 7892 : 				else if (bHiddenVol)

  02c7b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  02c82	74 0f		 je	 SHORT $LN413@MainDialog

; 7893 : 				{
; 7894 : 					// Hidden volume is always quick-formatted (if, however, the meaning of quickFormat is 
; 7895 : 					// whether to create a sparse file, it must be set to FALSE).
; 7896 : 					quickFormat = !bSparseFileSwitch;	

  02c84	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bSparseFileSwitch@@3HC ; bSparseFileSwitch
  02c89	f7 d8		 neg	 eax
  02c8b	1b c0		 sbb	 eax, eax
  02c8d	40		 inc	 eax
  02c8e	a3 00 00 00 00	 mov	 DWORD PTR ?quickFormat@@3HC, eax ; quickFormat
$LN413@MainDialog:

; 7897 : 				}
; 7898 : 
; 7899 : 
; 7900 : 				if (fileSystem == FILESYS_FAT
; 7901 : 					&& nNeedToStoreFilesOver4GB == 1
; 7902 : 					&& AskWarnNoYes("CONFIRM_FAT_FOR_FILES_OVER_4GB") == IDNO)

  02c93	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?fileSystem@@3HC, 1 ; fileSystem
  02c9a	75 1f		 jne	 SHORT $LN414@MainDialog
  02c9c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?nNeedToStoreFilesOver4GB@@3HA, 1 ; nNeedToStoreFilesOver4GB
  02ca3	75 16		 jne	 SHORT $LN414@MainDialog
  02ca5	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@NLBJKNFD@CONFIRM_FAT_FOR_FILES_OVER_4GB?$AA@
  02caa	e8 00 00 00 00	 call	 _AskWarnNoYes
  02caf	83 c4 04	 add	 esp, 4
  02cb2	83 f8 07	 cmp	 eax, 7
  02cb5	0f 84 53 ff ff
	ff		 je	 $LN401@MainDialog
$LN414@MainDialog:

; 7903 : 				{
; 7904 : 					bVolTransformThreadToRun = FALSE;
; 7905 : 					return 1;
; 7906 : 				}
; 7907 : 
; 7908 : 				EnableWindow (GetDlgItem (hwndDlg, IDC_PREV), FALSE);

  02cbb	6a 00		 push	 0
  02cbd	68 11 04 00 00	 push	 1041			; 00000411H
  02cc2	53		 push	 ebx
  02cc3	ff d7		 call	 edi
  02cc5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  02ccb	50		 push	 eax
  02ccc	ff d6		 call	 esi

; 7909 : 				EnableWindow (GetDlgItem (hwndDlg, IDC_NEXT), FALSE);

  02cce	6a 00		 push	 0
  02cd0	68 10 04 00 00	 push	 1040			; 00000410H
  02cd5	53		 push	 ebx
  02cd6	ff d7		 call	 edi
  02cd8	50		 push	 eax
  02cd9	ff d6		 call	 esi

; 7910 : 				EnableWindow (GetDlgItem (hwndDlg, IDHELP), FALSE);

  02cdb	6a 00		 push	 0
  02cdd	6a 09		 push	 9
  02cdf	53		 push	 ebx
  02ce0	ff d7		 call	 edi
  02ce2	50		 push	 eax
  02ce3	ff d6		 call	 esi

; 7911 : 				EnableWindow (GetDlgItem (hwndDlg, IDCANCEL), FALSE);

  02ce5	6a 00		 push	 0
  02ce7	6a 02		 push	 2
  02ce9	53		 push	 ebx
  02cea	ff d7		 call	 edi
  02cec	50		 push	 eax
  02ced	ff d6		 call	 esi

; 7912 : 				EnableWindow (GetDlgItem (hCurPage, IDC_QUICKFORMAT), FALSE);

  02cef	6a 00		 push	 0
  02cf1	68 ff 03 00 00	 push	 1023			; 000003ffH
  02cf6	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  02cfc	ff d7		 call	 edi
  02cfe	50		 push	 eax
  02cff	ff d6		 call	 esi

; 7913 : 				EnableWindow (GetDlgItem (hCurPage, IDC_CLUSTERSIZE), FALSE);

  02d01	6a 00		 push	 0
  02d03	68 04 04 00 00	 push	 1028			; 00000404H
  02d08	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  02d0e	ff d7		 call	 edi
  02d10	50		 push	 eax
  02d11	ff d6		 call	 esi

; 7914 : 				EnableWindow (GetDlgItem (hCurPage, IDC_FILESYS), FALSE);

  02d13	6a 00		 push	 0
  02d15	68 05 04 00 00	 push	 1029			; 00000405H
  02d1a	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  02d20	ff d7		 call	 edi
  02d22	50		 push	 eax
  02d23	ff d6		 call	 esi

; 7915 : 				EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), TRUE);

  02d25	6a 01		 push	 1
  02d27	68 f8 03 00 00	 push	 1016			; 000003f8H
  02d2c	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  02d32	ff d7		 call	 edi
  02d34	50		 push	 eax
  02d35	ff d6		 call	 esi

; 7916 : 				SetFocus (GetDlgItem (hCurPage, IDC_ABORT_BUTTON));

  02d37	68 f8 03 00 00	 push	 1016			; 000003f8H
  02d3c	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  02d42	ff d7		 call	 edi
  02d44	50		 push	 eax
  02d45	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 7917 : 
; 7918 : 				// Increase cluster size if it's too small for this volume size (causes size of
; 7919 : 				// free space to be 0). Note that the below constant 0x2000000 is based on
; 7920 : 				// results of tests performed under Windows XP.
; 7921 : 				if (fileSystem == FILESYS_FAT && clusterSize > 0)

  02d4b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?fileSystem@@3HC, 1 ; fileSystem
  02d52	0f 85 8a 00 00
	00		 jne	 $LN416@MainDialog
  02d58	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?clusterSize@@3HC, 0 ; clusterSize
  02d5f	0f 8e 7d 00 00
	00		 jle	 $LN416@MainDialog

; 7922 : 				{
; 7923 : 					BOOL fixed = FALSE;

  02d65	33 f6		 xor	 esi, esi

; 7924 : 					while (clusterSize < 128 
; 7925 : 						&& nVolumeSize / (clusterSize * GetFormatSectorSize()) > 0x2000000)

  02d67	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR ?clusterSize@@3HC, 128 ; clusterSize, 00000080H
  02d71	0f 8d 6b 00 00
	00		 jge	 $LN416@MainDialog
$LL41@MainDialog:
  02d77	e8 00 00 00 00	 call	 _GetFormatSectorSize
  02d7c	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?clusterSize@@3HC ; clusterSize
  02d83	99		 cdq
  02d84	52		 push	 edx
  02d85	50		 push	 eax
  02d86	ff 35 04 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA+4
  02d8c	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA
  02d92	e8 00 00 00 00	 call	 __aulldiv
  02d97	85 d2		 test	 edx, edx
  02d99	75 07		 jne	 SHORT $LN1389@MainDialog
  02d9b	3d 00 00 00 02	 cmp	 eax, 33554432		; 02000000H
  02da0	76 1f		 jbe	 SHORT $LN42@MainDialog
$LN1389@MainDialog:

; 7926 : 					{
; 7927 : 						clusterSize *= 2;

  02da2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?clusterSize@@3HC ; clusterSize

; 7928 : 						fixed = TRUE;

  02da7	be 01 00 00 00	 mov	 esi, 1
  02dac	03 c0		 add	 eax, eax
  02dae	a3 00 00 00 00	 mov	 DWORD PTR ?clusterSize@@3HC, eax ; clusterSize
  02db3	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR ?clusterSize@@3HC, 128 ; clusterSize, 00000080H
  02dbd	7c b8		 jl	 SHORT $LL41@MainDialog

; 7924 : 					while (clusterSize < 128 
; 7925 : 						&& nVolumeSize / (clusterSize * GetFormatSectorSize()) > 0x2000000)

  02dbf	eb 04		 jmp	 SHORT $LN1452@MainDialog
$LN42@MainDialog:
  02dc1	85 f6		 test	 esi, esi

; 7929 : 					}
; 7930 : 					if (fixed)

  02dc3	74 1d		 je	 SHORT $LN416@MainDialog
$LN1452@MainDialog:

; 7931 : 						MessageBoxW (hwndDlg, GetString ("CLUSTER_TOO_SMALL"), lpszTitle, MB_ICONWARNING);

  02dc5	6a 30		 push	 48			; 00000030H
  02dc7	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  02dcd	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DADPIOMM@CLUSTER_TOO_SMALL?$AA@
  02dd2	e8 00 00 00 00	 call	 _GetString
  02dd7	83 c4 04	 add	 esp, 4
  02dda	50		 push	 eax
  02ddb	53		 push	 ebx
  02ddc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$LN416@MainDialog:

; 7932 : 				}
; 7933 : 
; 7934 : 				LastDialogId = "FORMAT_IN_PROGRESS";

  02de2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LastDialogId, OFFSET ??_C@_0BD@NGECJJAH@FORMAT_IN_PROGRESS?$AA@

; 7935 : 				ArrowWaitCursor ();

  02dec	e8 00 00 00 00	 call	 _ArrowWaitCursor

; 7936 : 				_beginthread (volTransformThreadFunction, 0, MainDlg);

  02df1	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  02df7	6a 00		 push	 0
  02df9	68 00 00 00 00	 push	 OFFSET _volTransformThreadFunction
  02dfe	e8 00 00 00 00	 call	 __beginthread
  02e03	83 c4 0c	 add	 esp, 12			; 0000000cH
$ovf_end_44$1562:

; 6074 : 			}
; 6075 : 			return 1;

  02e06	b8 01 00 00 00	 mov	 eax, 1
  02e0b	e9 9f d2 ff ff	 jmp	 $LN1@MainDialog
$LN393@MainDialog:

; 7937 : 
; 7938 : 				return 1;
; 7939 : 			}
; 7940 : 
; 7941 : 			else if (nCurPageNo == FORMAT_FINISHED_PAGE)

  02e10	83 f8 27	 cmp	 eax, 39			; 00000027H
  02e13	0f 85 b4 04 00
	00		 jne	 $LN417@MainDialog

; 7942 : 			{
; 7943 : 				if (!bHiddenVol || bHiddenVolFinished)

  02e19	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  02e20	0f 84 5e 02 00
	00		 je	 $LN421@MainDialog
  02e26	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVolFinished@@3HC, 0 ; bHiddenVolFinished
  02e2d	0f 85 51 02 00
	00		 jne	 $LN421@MainDialog

; 7977 : 
; 7978 : 					return 1;
; 7979 : 				}
; 7980 : 				else
; 7981 : 				{
; 7982 : 					/* We're going to scan the bitmap of the hidden volume host (in the non-Direct hidden volume wizard mode) */
; 7983 : 					int retCode;
; 7984 : 					WaitCursor ();

  02e33	e8 00 00 00 00	 call	 _WaitCursor

; 7985 : 
; 7986 : 					if (hiddenVolHostDriveNo != -1)		// If the hidden volume host is mounted

  02e38	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  02e3d	83 f8 ff	 cmp	 eax, -1
  02e40	0f 84 70 00 00
	00		 je	 $LN1425@MainDialog

; 7987 : 					{
; 7988 : 						BOOL tmp_result;
; 7989 : 
; 7990 : 						// Dismount the hidden volume host (in order to remount it as read-only subsequently)
; 7991 : 						CloseVolumeExplorerWindows (hwndDlg, hiddenVolHostDriveNo);

  02e46	50		 push	 eax
  02e47	53		 push	 ebx
  02e48	e8 00 00 00 00	 call	 _CloseVolumeExplorerWindows

; 7992 : 						while (!(tmp_result = UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE)))

  02e4d	6a 01		 push	 1
  02e4f	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  02e55	53		 push	 ebx
  02e56	e8 00 00 00 00	 call	 _UnmountVolume
  02e5b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__MessageBoxW@16
  02e61	83 c4 14	 add	 esp, 20			; 00000014H
  02e64	85 c0		 test	 eax, eax
  02e66	75 42		 jne	 SHORT $LN1338@MainDialog
  02e68	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL43@MainDialog:

; 7993 : 						{
; 7994 : 							if (MessageBoxW (hwndDlg, GetString ("CANT_DISMOUNT_OUTER_VOL"), lpszTitle, MB_RETRYCANCEL | MB_ICONERROR | MB_SETFOREGROUND) != IDRETRY)

  02e70	68 15 00 01 00	 push	 65557			; 00010015H
  02e75	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  02e7b	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GNHKCMLM@CANT_DISMOUNT_OUTER_VOL?$AA@
  02e80	e8 00 00 00 00	 call	 _GetString
  02e85	83 c4 04	 add	 esp, 4
  02e88	50		 push	 eax
  02e89	53		 push	 ebx
  02e8a	ff d6		 call	 esi
  02e8c	83 f8 04	 cmp	 eax, 4
  02e8f	0f 85 af e8 ff
	ff		 jne	 $LN1291@MainDialog

; 7992 : 						while (!(tmp_result = UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE)))

  02e95	6a 01		 push	 1
  02e97	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  02e9d	53		 push	 ebx
  02e9e	e8 00 00 00 00	 call	 _UnmountVolume
  02ea3	83 c4 0c	 add	 esp, 12			; 0000000cH
  02ea6	85 c0		 test	 eax, eax
  02ea8	74 c6		 je	 SHORT $LL43@MainDialog
$LN1338@MainDialog:

; 7995 : 							{
; 7996 : 								// Cancel
; 7997 : 								NormalCursor();
; 7998 : 								return 1;
; 7999 : 							}
; 8000 : 						}
; 8001 : 						if (tmp_result)		// If dismounted
; 8002 : 							hiddenVolHostDriveNo = -1;

  02eaa	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?hiddenVolHostDriveNo@@3HA, -1 ; hiddenVolHostDriveNo
  02eb4	eb 06		 jmp	 SHORT $LN428@MainDialog
$LN1425@MainDialog:
  02eb6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__MessageBoxW@16
$LN428@MainDialog:

; 8003 : 					}
; 8004 : 
; 8005 : 					if (hiddenVolHostDriveNo < 0)		// If the hidden volume host is not mounted
; 8006 : 					{
; 8007 : 						// Remount the hidden volume host as read-only (to ensure consistent and secure
; 8008 : 						// results of the volume bitmap scanning)
; 8009 : 						switch (MountHiddenVolHost (hwndDlg, szDiskFile, &hiddenVolHostDriveNo, &volumePassword, TRUE))

  02ebc	6a 01		 push	 1
  02ebe	68 00 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A ; volumePassword
  02ec3	68 00 00 00 00	 push	 OFFSET ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  02ec8	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  02ecd	53		 push	 ebx
  02ece	e8 00 00 00 00	 call	 _MountHiddenVolHost
  02ed3	83 c4 14	 add	 esp, 20			; 00000014H
  02ed6	83 f8 18	 cmp	 eax, 24			; 00000018H
  02ed9	0f 87 95 e7 ff
	ff		 ja	 $LN1474@MainDialog
  02edf	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN1390@MainDialog[eax]
  02ee6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN1511@MainDialog[eax*4]
$LN430@MainDialog:

; 8010 : 						{
; 8011 : 						case ERR_NO_FREE_DRIVES:
; 8012 : 							MessageBoxW (hwndDlg, GetString ("NO_FREE_DRIVE_FOR_OUTER_VOL"), lpszTitle, ICON_HAND);

  02eed	6a 10		 push	 16			; 00000010H
  02eef	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  02ef5	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DNIPKEFC@NO_FREE_DRIVE_FOR_OUTER_VOL?$AA@
  02efa	e8 00 00 00 00	 call	 _GetString
  02eff	83 c4 04	 add	 esp, 4
  02f02	50		 push	 eax
  02f03	53		 push	 ebx
  02f04	ff d6		 call	 esi

; 8013 : 							NormalCursor ();

  02f06	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_45$1563:

; 6074 : 			}
; 6075 : 			return 1;

  02f0b	b8 01 00 00 00	 mov	 eax, 1
  02f10	e9 9a d1 ff ff	 jmp	 $LN1@MainDialog
$LN432@MainDialog:

; 8014 : 							return 1;
; 8015 : 
; 8016 : 						case ERR_VOL_MOUNT_FAILED:
; 8017 : 						case ERR_PASSWORD_WRONG:
; 8018 : 							NormalCursor ();
; 8019 : 							return 1;
; 8020 : 
; 8021 : 						case 0:
; 8022 : 
; 8023 : 							/* Hidden volume host successfully mounted as read-only */
; 8024 : 
; 8025 : 							// Verify that the outer volume contains a suitable file system, retrieve cluster size, and 
; 8026 : 							// scan the volume bitmap
; 8027 : 							if (!IsAdmin () && IsUacSupported ())

  02f15	e8 00 00 00 00	 call	 _IsAdmin
  02f1a	85 c0		 test	 eax, eax
  02f1c	75 38		 jne	 SHORT $LN433@MainDialog
  02f1e	e8 00 00 00 00	 call	 _IsUacSupported
  02f23	85 c0		 test	 eax, eax
  02f25	74 2f		 je	 SHORT $LN433@MainDialog

; 8028 : 								retCode = UacAnalyzeHiddenVolumeHost (hwndDlg, &hiddenVolHostDriveNo, GetVolumeDataAreaSize (FALSE, nHiddenVolHostSize), &realClusterSize, &nbrFreeClusters);

  02f27	68 00 00 00 00	 push	 OFFSET ?nbrFreeClusters@@3_JA ; nbrFreeClusters
  02f2c	68 00 00 00 00	 push	 OFFSET ?realClusterSize@@3HA ; realClusterSize
  02f31	ff 35 04 00 00
	00		 push	 DWORD PTR ?nHiddenVolHostSize@@3_KA+4
  02f37	ff 35 00 00 00
	00		 push	 DWORD PTR ?nHiddenVolHostSize@@3_KA
  02f3d	6a 00		 push	 0
  02f3f	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  02f44	83 c4 0c	 add	 esp, 12			; 0000000cH
  02f47	52		 push	 edx
  02f48	50		 push	 eax
  02f49	68 00 00 00 00	 push	 OFFSET ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  02f4e	53		 push	 ebx
  02f4f	e8 00 00 00 00	 call	 _UacAnalyzeHiddenVolumeHost

; 8029 : 							else

  02f54	eb 2d		 jmp	 SHORT $LN1494@MainDialog
$LN433@MainDialog:

; 8030 : 								retCode = AnalyzeHiddenVolumeHost (hwndDlg, &hiddenVolHostDriveNo, GetVolumeDataAreaSize (FALSE, nHiddenVolHostSize), &realClusterSize, &nbrFreeClusters);

  02f56	68 00 00 00 00	 push	 OFFSET ?nbrFreeClusters@@3_JA ; nbrFreeClusters
  02f5b	68 00 00 00 00	 push	 OFFSET ?realClusterSize@@3HA ; realClusterSize
  02f60	ff 35 04 00 00
	00		 push	 DWORD PTR ?nHiddenVolHostSize@@3_KA+4
  02f66	ff 35 00 00 00
	00		 push	 DWORD PTR ?nHiddenVolHostSize@@3_KA
  02f6c	6a 00		 push	 0
  02f6e	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  02f73	83 c4 0c	 add	 esp, 12			; 0000000cH
  02f76	52		 push	 edx
  02f77	50		 push	 eax
  02f78	68 00 00 00 00	 push	 OFFSET ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  02f7d	53		 push	 ebx
  02f7e	e8 00 00 00 00	 call	 _AnalyzeHiddenVolumeHost
$LN1494@MainDialog:
  02f83	83 c4 18	 add	 esp, 24			; 00000018H

; 8031 : 
; 8032 : 							switch (retCode)

  02f86	83 f8 ff	 cmp	 eax, -1
  02f89	0f 84 ba 00 00
	00		 je	 $LN435@MainDialog
  02f8f	85 c0		 test	 eax, eax
  02f91	0f 84 ad e7 ff
	ff		 je	 $LN1291@MainDialog
  02f97	83 f8 01	 cmp	 eax, 1
  02f9a	0f 85 d4 e6 ff
	ff		 jne	 $LN1474@MainDialog

; 8041 : 								break;
; 8042 : 
; 8043 : 							case 0:		// Unsupported file system (or other non-fatal error which has already been reported)
; 8044 : 								NormalCursor ();
; 8045 : 								return 1;
; 8046 : 
; 8047 : 							case 1:		// Success
; 8048 : 								{
; 8049 : 									BOOL tmp_result;
; 8050 : 
; 8051 : 									// Determine the maximum possible size of the hidden volume
; 8052 : 									if (DetermineMaxHiddenVolSize (hwndDlg) < 1)

  02fa0	53		 push	 ebx
  02fa1	e8 00 00 00 00	 call	 _DetermineMaxHiddenVolSize
  02fa6	83 c4 04	 add	 esp, 4
  02fa9	83 f8 01	 cmp	 eax, 1
  02fac	0f 8c 92 e7 ff
	ff		 jl	 $LN1291@MainDialog

; 8053 : 									{
; 8054 : 										NormalCursor ();
; 8055 : 										goto ovf_end;
; 8056 : 									}
; 8057 : 
; 8058 : 									/* Maximum possible size of the hidden volume successfully determined */
; 8059 : 
; 8060 : 									// Dismount the hidden volume host
; 8061 : 									while (!(tmp_result = UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE)))

  02fb2	6a 01		 push	 1
  02fb4	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  02fba	53		 push	 ebx
  02fbb	e8 00 00 00 00	 call	 _UnmountVolume
  02fc0	83 c4 0c	 add	 esp, 12			; 0000000cH
  02fc3	85 c0		 test	 eax, eax
  02fc5	75 40		 jne	 SHORT $LN50@MainDialog
  02fc7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL49@MainDialog:

; 8062 : 									{
; 8063 : 										if (MessageBoxW (hwndDlg, GetString ("CANT_DISMOUNT_OUTER_VOL"), lpszTitle, MB_RETRYCANCEL) != IDRETRY)

  02fd0	6a 05		 push	 5
  02fd2	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  02fd8	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GNHKCMLM@CANT_DISMOUNT_OUTER_VOL?$AA@
  02fdd	e8 00 00 00 00	 call	 _GetString
  02fe2	83 c4 04	 add	 esp, 4
  02fe5	50		 push	 eax
  02fe6	53		 push	 ebx
  02fe7	ff d6		 call	 esi
  02fe9	83 f8 04	 cmp	 eax, 4
  02fec	0f 85 52 e7 ff
	ff		 jne	 $LN1291@MainDialog

; 8053 : 									{
; 8054 : 										NormalCursor ();
; 8055 : 										goto ovf_end;
; 8056 : 									}
; 8057 : 
; 8058 : 									/* Maximum possible size of the hidden volume successfully determined */
; 8059 : 
; 8060 : 									// Dismount the hidden volume host
; 8061 : 									while (!(tmp_result = UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE)))

  02ff2	6a 01		 push	 1
  02ff4	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  02ffa	53		 push	 ebx
  02ffb	e8 00 00 00 00	 call	 _UnmountVolume
  03000	83 c4 0c	 add	 esp, 12			; 0000000cH
  03003	85 c0		 test	 eax, eax
  03005	74 c9		 je	 SHORT $LL49@MainDialog
$LN50@MainDialog:

; 8064 : 										{
; 8065 : 											// Cancel
; 8066 : 											NormalCursor ();
; 8067 : 											goto ovf_end;
; 8068 : 										}
; 8069 : 									}
; 8070 : 
; 8071 : 									// Prevent having to recreate the outer volume due to inadvertent exit
; 8072 : 									bConfirmQuit = TRUE;

  03007	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bConfirmQuit@@3HC, 1 ; bConfirmQuit

; 8073 : 
; 8074 : 									hiddenVolHostDriveNo = -1;
; 8075 : 
; 8076 : 									nNewPageNo = HIDDEN_VOL_HOST_PRE_CIPHER_PAGE;

  03011	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  03016	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?hiddenVolHostDriveNo@@3HA, -1 ; hiddenVolHostDriveNo

; 8077 : 
; 8078 : 									// Clear the outer volume password
; 8079 : 									WipePasswordsAndKeyfiles ();

  03020	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles

; 8080 : 
; 8081 : 									EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), TRUE);

  03025	6a 01		 push	 1
  03027	68 10 04 00 00	 push	 1040			; 00000410H
  0302c	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  03032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  03038	50		 push	 eax
  03039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 8082 : 									NormalCursor ();

  0303f	e8 00 00 00 00	 call	 _NormalCursor
  03044	e9 31 e6 ff ff	 jmp	 $LN310@MainDialog
$LN435@MainDialog:

; 8033 : 							{
; 8034 : 							case -1:	// Fatal error
; 8035 : 								CloseVolumeExplorerWindows (hwndDlg, hiddenVolHostDriveNo);

  03049	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  0304f	53		 push	 ebx
  03050	e8 00 00 00 00	 call	 _CloseVolumeExplorerWindows

; 8036 : 
; 8037 : 								if (UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE))

  03055	6a 01		 push	 1
  03057	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  0305d	53		 push	 ebx
  0305e	e8 00 00 00 00	 call	 _UnmountVolume
  03063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  03069	83 ca ff	 or	 edx, -1
  0306c	83 c4 14	 add	 esp, 20			; 00000014H
  0306f	85 c0		 test	 eax, eax
  03071	0f 45 ca	 cmovne	 ecx, edx
  03074	89 0d 00 00 00
	00		 mov	 DWORD PTR ?hiddenVolHostDriveNo@@3HA, ecx ; hiddenVolHostDriveNo

; 8038 : 									hiddenVolHostDriveNo = -1;
; 8039 : 
; 8040 : 								AbortProcessSilent ();

  0307a	e8 00 00 00 00	 call	 _AbortProcessSilent

; 8083 : 
; 8084 : 								}
; 8085 : 								break;
; 8086 : 							}
; 8087 : 							break;
; 8088 : 						}
; 8089 : 					}
; 8090 : 				}

  0307f	e9 f0 e5 ff ff	 jmp	 $LN1474@MainDialog
$LN421@MainDialog:

; 7944 : 				{
; 7945 : 					/* Wizard loop restart */
; 7946 : 
; 7947 : 					if (bHiddenOS)

  03084	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  0308b	0f 84 f3 01 00
	00		 je	 $LN422@MainDialog

; 7948 : 					{
; 7949 : 						if (!ChangeWizardMode (WIZARD_MODE_SYS_DEVICE))

  03091	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  03098	74 5f		 je	 SHORT $LN1178@MainDialog
  0309a	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  0309f	e8 00 00 00 00	 call	 _CreateSysEncMutex
  030a4	85 c0		 test	 eax, eax
  030a6	75 17		 jne	 SHORT $LN1182@MainDialog
  030a8	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  030ad	e8 00 00 00 00	 call	 _Error
  030b2	83 c4 04	 add	 esp, 4
$ovf_end_46$1564:

; 6074 : 			}
; 6075 : 			return 1;

  030b5	b8 01 00 00 00	 mov	 eax, 1
  030ba	e9 f0 cf ff ff	 jmp	 $LN1@MainDialog

; 7948 : 					{
; 7949 : 						if (!ChangeWizardMode (WIZARD_MODE_SYS_DEVICE))

$LN1182@MainDialog:
  030bf	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
  030c4	0f 57 c0	 xorps	 xmm0, xmm0
  030c7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  030d1	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  030d8	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  030df	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  030e7	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  030ef	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _WizardMode, 2
$LN1178@MainDialog:
  030f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  030fe	f7 d8		 neg	 eax

; 7950 : 							return 1;
; 7951 : 
; 7952 : 						// Hidden volume for hidden OS has been created. Now we will prepare our boot loader
; 7953 : 						// that will handle the OS cloning. 
; 7954 : 						try

  03100	c7 45 fc 45 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 69 ; 00000045H
  03107	1b c0		 sbb	 eax, eax
  03109	f7 d8		 neg	 eax
  0310b	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice

; 7955 : 						{
; 7956 : 							WaitCursor();

  03110	e8 00 00 00 00	 call	 _WaitCursor

; 7957 : 
; 7958 : 							BootEncObj->PrepareHiddenOSCreation (nVolumeEA, FIRST_MODE_OF_OPERATION_ID, hash_algo);

  03115	ff 35 00 00 00
	00		 push	 DWORD PTR ?hash_algo@@3HA ; hash_algo
  0311b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  03121	6a 01		 push	 1
  03123	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeEA@@3HA ; nVolumeEA
  03129	e8 00 00 00 00	 call	 ?PrepareHiddenOSCreation@BootEncryption@GostCrypt@@QAEXHHH@Z ; GostCrypt::BootEncryption::PrepareHiddenOSCreation

; 7965 : 						}
; 7966 : 
; 7967 : 						bHiddenVol = FALSE;
; 7968 : 
; 7969 : 						LoadPage (hwndDlg, SYSENC_PRETEST_INFO_PAGE);

  0312e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  03133	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  03139	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  03143	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  03149	85 c0		 test	 eax, eax
  0314b	74 63		 je	 SHORT $LN1200@MainDialog
  0314d	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  03157	83 f9 15	 cmp	 ecx, 21			; 00000015H
  0315a	75 43		 jne	 SHORT $LN1194@MainDialog
  0315c	6a 40		 push	 64			; 00000040H
  0315e	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$95[ebp]
  03164	6a 58		 push	 88			; 00000058H
  03166	50		 push	 eax
  03167	e8 00 00 00 00	 call	 _memset
  0316c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  03172	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$95[ebp]
  03178	83 c4 0c	 add	 esp, 12			; 0000000cH
  0317b	c6 85 90 fe ff
	ff 00		 mov	 BYTE PTR _tmp$95[ebp+64], 0
  03182	50		 push	 eax
  03183	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  03188	50		 push	 eax
  03189	ff d6		 call	 esi
  0318b	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$95[ebp]
  03191	50		 push	 eax
  03192	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  03197	50		 push	 eax
  03198	ff d6		 call	 esi
  0319a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN1194@MainDialog:
  0319f	50		 push	 eax
  031a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  031a6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN1200@MainDialog:
  031b0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  031ba	e8 00 00 00 00	 call	 _NormalCursor
  031bf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  031c5	8d 85 48 35 ff
	ff		 lea	 eax, DWORD PTR _rW$79[ebp]
  031cb	50		 push	 eax
  031cc	68 23 04 00 00	 push	 1059			; 00000423H
  031d1	53		 push	 ebx
  031d2	ff d6		 call	 esi
  031d4	50		 push	 eax
  031d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  031db	6a 00		 push	 0
  031dd	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  031e2	53		 push	 ebx
  031e3	6a 6c		 push	 108			; 0000006cH
  031e5	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  031eb	c7 05 00 00 00
	00 1d 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 29 ; nCurPageNo, 0000001dH
  031f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  031fb	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  03202	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  03207	8d 85 18 35 ff
	ff		 lea	 eax, DWORD PTR _rD$76[ebp]
  0320d	50		 push	 eax
  0320e	53		 push	 ebx
  0320f	0f 11 85 18 35
	ff ff		 movups	 XMMWORD PTR _rD$76[ebp], xmm0
  03216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  0321c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  03222	85 c9		 test	 ecx, ecx
  03224	0f 84 6b 00 00
	00		 je	 $LN423@MainDialog
  0322a	8b 85 54 35 ff
	ff		 mov	 eax, DWORD PTR _rW$79[ebp+12]
  03230	2b 85 4c 35 ff
	ff		 sub	 eax, DWORD PTR _rW$79[ebp+4]
  03236	6a 01		 push	 1
  03238	50		 push	 eax
  03239	8b 85 50 35 ff
	ff		 mov	 eax, DWORD PTR _rW$79[ebp+8]
  0323f	2b 85 48 35 ff
	ff		 sub	 eax, DWORD PTR _rW$79[ebp]
  03245	50		 push	 eax
  03246	ff b5 1c 35 ff
	ff		 push	 DWORD PTR _rD$76[ebp+4]
  0324c	ff b5 18 35 ff
	ff		 push	 DWORD PTR _rD$76[ebp]
  03252	51		 push	 ecx
  03253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  03259	6a 01		 push	 1
  0325b	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 7970 : 					}
; 7971 : 					else

  03267	eb 2c		 jmp	 SHORT $LN423@MainDialog
__catch$_MainDialogProc@16$41:

; 7959 : 						}
; 7960 : 						catch (Exception &e)
; 7961 : 						{
; 7962 : 							e.Show (MainDlg);

  03269	8b 8d 10 2d ff
	ff		 mov	 ecx, DWORD PTR _e$19[ebp]
  0326f	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  03275	8b 01		 mov	 eax, DWORD PTR [ecx]
  03277	ff 10		 call	 DWORD PTR [eax]

; 7963 : 							NormalCursor();

  03279	e8 00 00 00 00	 call	 _NormalCursor

; 7964 : 							return 1;

  0327e	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  03283	c3		 ret	 0
$LN422@MainDialog:

; 7972 : 						LoadPage (hwndDlg, INTRO_PAGE);

  03284	6a 00		 push	 0
  03286	53		 push	 ebx
  03287	e8 00 00 00 00	 call	 _LoadPage
  0328c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  03292	83 c4 08	 add	 esp, 8
$LN423@MainDialog:

; 7973 : 
; 7974 : 					SetWindowTextW (GetDlgItem (MainDlg, IDCANCEL), GetString ("CANCEL"));

  03295	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  0329a	e8 00 00 00 00	 call	 _GetString
  0329f	83 c4 04	 add	 esp, 4
  032a2	50		 push	 eax
  032a3	6a 02		 push	 2
  032a5	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  032ab	ff d6		 call	 esi
  032ad	50		 push	 eax
  032ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 7975 : 					bHiddenVolFinished = FALSE;

  032b4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bHiddenVolFinished@@3HC, 0 ; bHiddenVolFinished

; 7976 : 					WipePasswordsAndKeyfiles ();

  032be	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
$ovf_end_47$1565:

; 6074 : 			}
; 6075 : 			return 1;

  032c3	b8 01 00 00 00	 mov	 eax, 1
  032c8	e9 e2 cd ff ff	 jmp	 $LN1@MainDialog
$LN417@MainDialog:

; 8091 : 			}
; 8092 : 
; 8093 : 			else if (nCurPageNo == DEVICE_WIPE_PAGE)

  032cd	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  032d0	0f 85 9e e3 ff
	ff		 jne	 $LN1474@MainDialog

; 8094 : 			{
; 8095 : 				if (AskWarnOkCancel (bHiddenOS && IsHiddenOSRunning() ? "CONFIRM_WIPE_START_DECOY_SYS_PARTITION" : "CONFIRM_WIPE_START") == IDOK)

  032d6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  032dd	74 0e		 je	 SHORT $LN542@MainDialog
  032df	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  032e4	85 c0		 test	 eax, eax
  032e6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CH@LLDBJBEP@CONFIRM_WIPE_START_DECOY_SYS_PAR@
  032eb	75 05		 jne	 SHORT $LN543@MainDialog
$LN542@MainDialog:
  032ed	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@ICCGDAH@CONFIRM_WIPE_START?$AA@
$LN543@MainDialog:
  032f2	50		 push	 eax
  032f3	e8 00 00 00 00	 call	 _AskWarnOkCancel
  032f8	83 c4 04	 add	 esp, 4
  032fb	83 f8 01	 cmp	 eax, 1
  032fe	0f 85 43 d1 ff
	ff		 jne	 $LN15@MainDialog

; 8096 : 				{
; 8097 : 					WipeStart ();

  03304	e8 00 00 00 00	 call	 _WipeStart

; 8098 : 					ArrowWaitCursor();

  03309	e8 00 00 00 00	 call	 _ArrowWaitCursor
$ovf_end_48$1566:

; 6074 : 			}
; 6075 : 			return 1;

  0330e	b8 01 00 00 00	 mov	 eax, 1
  03313	e9 97 cd ff ff	 jmp	 $LN1@MainDialog
$LN366@MainDialog:

; 7649 : 			{
; 7650 : 				if (nWipeMode > 0 
; 7651 : 					&& AskWarnYesNo ("WIPE_MODE_WARN") == IDNO)

  03318	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nWipeMode, 0
  0331f	0f 8e 4f e3 ff
	ff		 jle	 $LN1474@MainDialog
  03325	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BMFNBJAJ@WIPE_MODE_WARN?$AA@
  0332a	e8 00 00 00 00	 call	 _AskWarnYesNo
  0332f	83 c4 04	 add	 esp, 4
  03332	83 f8 07	 cmp	 eax, 7
  03335	0f 85 39 e3 ff
	ff		 jne	 $LN1474@MainDialog
$ovf_end_49$1567:

; 6074 : 			}
; 6075 : 			return 1;

  0333b	b8 01 00 00 00	 mov	 eax, 1
  03340	e9 6a cd ff ff	 jmp	 $LN1@MainDialog
$LN344@MainDialog:

; 7510 : 			{
; 7511 : 				char tmp[RANDPOOL_DISPLAY_SIZE+1];
; 7512 : 
; 7513 : 				if (!bInPlaceEncNonSys)

  03345	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  0334c	75 5e		 jne	 SHORT __tryend$_MainDialogProc@16$30

; 7514 : 				{
; 7515 : 					/* Generate master key and other related data (except the rescue disk) for system encryption. */
; 7516 : 
; 7517 : 					try

  0334e	c7 45 fc 31 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 49 ; 00000031H

; 7518 : 					{
; 7519 : 						WaitCursor();

  03355	e8 00 00 00 00	 call	 _WaitCursor

; 7520 : 						BootEncObj->PrepareInstallation (!bWholeSysDrive, volumePassword, nVolumeEA, FIRST_MODE_OF_OPERATION_ID, hash_algo, "");

  0335a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0335f	8d 8d 98 34 ff
	ff		 lea	 ecx, DWORD PTR $T70[ebp]
  03365	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0336a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, 0 ; bWholeSysDrive
  03371	8d 85 98 34 ff
	ff		 lea	 eax, DWORD PTR $T70[ebp]
  03377	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0337d	50		 push	 eax
  0337e	ff 35 00 00 00
	00		 push	 DWORD PTR ?hash_algo@@3HA ; hash_algo
  03384	0f 94 c0	 sete	 al
  03387	c6 45 fc 32	 mov	 BYTE PTR __$EHRec$[ebp+12], 50 ; 00000032H
  0338b	6a 01		 push	 1
  0338d	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeEA@@3HA ; nVolumeEA
  03393	0f b6 c0	 movzx	 eax, al
  03396	68 00 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A ; volumePassword
  0339b	50		 push	 eax
  0339c	e8 00 00 00 00	 call	 ?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::BootEncryption::PrepareInstallation
  033a1	8d 8d 98 34 ff
	ff		 lea	 ecx, DWORD PTR $T70[ebp]
  033a7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__tryend$_MainDialogProc@16$30:

; 7527 : 					}
; 7528 : 				}
; 7529 : 
; 7530 : 				KillTimer (hwndDlg, TIMER_ID_RANDVIEW);

  033ac	68 ff 00 00 00	 push	 255			; 000000ffH
  033b1	53		 push	 ebx
  033b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 7531 : 
; 7532 : 				// Attempt to wipe the GUI field showing portions of randpool
; 7533 : 				memset (tmp, 'X', sizeof(tmp));

  033b8	68 73 01 00 00	 push	 371			; 00000173H
  033bd	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR _tmp$92[ebp]
  033c3	6a 58		 push	 88			; 00000058H
  033c5	50		 push	 eax
  033c6	e8 00 00 00 00	 call	 _memset
  033cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7534 : 				tmp [sizeof(tmp)-1] = 0;

  033ce	c6 85 8e fc ff
	ff 00		 mov	 BYTE PTR _tmp$92[ebp+370], 0

; 7535 : 				SetWindowText (hRandPoolSys, tmp);

  033d5	8d 85 1c fb ff
	ff		 lea	 eax, DWORD PTR _tmp$92[ebp]
  033db	50		 push	 eax
  033dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hRandPoolSys@@3RAUHWND__@@A ; hRandPoolSys
  033e1	50		 push	 eax
  033e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN363@MainDialog:

; 7536 : 
; 7537 : 				NormalCursor ();

  033e8	e8 00 00 00 00	 call	 _NormalCursor
  033ed	e9 82 e2 ff ff	 jmp	 $LN1474@MainDialog
__catch$_MainDialogProc@16$29:

; 7521 : 					}
; 7522 : 					catch (Exception &e)
; 7523 : 					{
; 7524 : 						e.Show (hwndDlg);

  033f2	8b 8d 14 2d ff
	ff		 mov	 ecx, DWORD PTR _e$20[ebp]
  033f8	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  033fe	8b 01		 mov	 eax, DWORD PTR [ecx]
  03400	ff 10		 call	 DWORD PTR [eax]

; 7525 : 						NormalCursor ();

  03402	e8 00 00 00 00	 call	 _NormalCursor

; 7526 : 						return 1;

  03407	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  0340c	c3		 ret	 0
$LN307@MainDialog:

; 7290 : 			{
; 7291 : 				WaitCursor ();
; 7292 : 
; 7293 : 				GetWindowText (GetDlgItem (hCurPage, IDC_PASSWORD_DIRECT), (char *) volumePassword.Text, sizeof (volumePassword.Text));

  0340d	e8 00 00 00 00	 call	 _WaitCursor
  03412	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  03418	6a 41		 push	 65			; 00000041H
  0341a	68 04 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A+4
  0341f	68 0d 04 00 00	 push	 1037			; 0000040dH
  03424	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0342a	ff d7		 call	 edi
  0342c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetWindowTextA@12
  03432	50		 push	 eax
  03433	ff d6		 call	 esi

; 7294 : 				volumePassword.Length = strlen ((char *) volumePassword.Text);

  03435	b9 04 00 00 00	 mov	 ecx, OFFSET ?volumePassword@@3UPassword@@A+4
  0343a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0343d	0f 1f 00	 npad	 3
$LL1391@MainDialog:
  03440	8a 01		 mov	 al, BYTE PTR [ecx]
  03442	41		 inc	 ecx
  03443	84 c0		 test	 al, al
  03445	75 f9		 jne	 SHORT $LL1391@MainDialog

; 7295 : 
; 7296 : 				// Store the password in case we need to restore it after keyfile is applied to it
; 7297 : 				GetWindowText (GetDlgItem (hCurPage, IDC_PASSWORD_DIRECT), szRawPassword, sizeof (szRawPassword));

  03447	6a 41		 push	 65			; 00000041H
  03449	68 00 00 00 00	 push	 OFFSET ?szRawPassword@@3PADA ; szRawPassword
  0344e	68 0d 04 00 00	 push	 1037			; 0000040dH
  03453	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03459	2b ca		 sub	 ecx, edx
  0345b	89 0d 00 00 00
	00		 mov	 DWORD PTR ?volumePassword@@3UPassword@@A, ecx
  03461	ff d7		 call	 edi
  03463	50		 push	 eax
  03464	ff d6		 call	 esi

; 7298 : 
; 7299 : 				if (KeyFilesEnable)

  03466	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KeyFilesEnable, 0
  0346d	74 13		 je	 SHORT $LN308@MainDialog

; 7300 : 				{
; 7301 : 					KeyFilesApply (&volumePassword, FirstKeyFile);

  0346f	ff 35 00 00 00
	00		 push	 DWORD PTR _FirstKeyFile
  03475	68 00 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A ; volumePassword
  0347a	e8 00 00 00 00	 call	 _KeyFilesApply
  0347f	83 c4 08	 add	 esp, 8
$LN308@MainDialog:

; 7302 : 				}
; 7303 : 			
; 7304 : 				if (!bInPlaceEncNonSys)

  03482	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  03489	0f 85 4e 02 00
	00		 jne	 $LN309@MainDialog

; 7305 : 				{
; 7306 : 
; 7307 : 					/* Mount the volume which is to host the new hidden volume as read only */
; 7308 : 
; 7309 : 					if (hiddenVolHostDriveNo >= 0)		// If the hidden volume host is currently mounted (e.g. after previous unsuccessful dismount attempt)

  0348f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  03494	85 c0		 test	 eax, eax
  03496	78 5b		 js	 SHORT $LN1427@MainDialog

; 7310 : 					{
; 7311 : 						BOOL tmp_result;
; 7312 : 
; 7313 : 						// Dismount the hidden volume host (in order to remount it as read-only subsequently)
; 7314 : 						while (!(tmp_result = UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE)))

  03498	6a 01		 push	 1
  0349a	50		 push	 eax
  0349b	53		 push	 ebx
  0349c	e8 00 00 00 00	 call	 _UnmountVolume
  034a1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__MessageBoxW@16
  034a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  034aa	85 c0		 test	 eax, eax
  034ac	75 39		 jne	 SHORT $LN1336@MainDialog
  034ae	66 90		 npad	 2
$LL25@MainDialog:

; 7315 : 						{
; 7316 : 							if (MessageBoxW (hwndDlg, GetString ("CANT_DISMOUNT_OUTER_VOL"), lpszTitle, MB_RETRYCANCEL) != IDRETRY)

  034b0	6a 05		 push	 5
  034b2	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  034b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GNHKCMLM@CANT_DISMOUNT_OUTER_VOL?$AA@
  034bd	e8 00 00 00 00	 call	 _GetString
  034c2	83 c4 04	 add	 esp, 4
  034c5	50		 push	 eax
  034c6	53		 push	 ebx
  034c7	ff d6		 call	 esi
  034c9	83 f8 04	 cmp	 eax, 4
  034cc	0f 85 72 e2 ff
	ff		 jne	 $LN1291@MainDialog

; 7310 : 					{
; 7311 : 						BOOL tmp_result;
; 7312 : 
; 7313 : 						// Dismount the hidden volume host (in order to remount it as read-only subsequently)
; 7314 : 						while (!(tmp_result = UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE)))

  034d2	6a 01		 push	 1
  034d4	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  034da	53		 push	 ebx
  034db	e8 00 00 00 00	 call	 _UnmountVolume
  034e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  034e3	85 c0		 test	 eax, eax
  034e5	74 c9		 je	 SHORT $LL25@MainDialog
$LN1336@MainDialog:

; 7317 : 							{
; 7318 : 								// Cancel
; 7319 : 								NormalCursor();
; 7320 : 								return 1;
; 7321 : 							}
; 7322 : 						}
; 7323 : 						if (tmp_result)		// If dismounted
; 7324 : 							hiddenVolHostDriveNo = -1;

  034e7	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?hiddenVolHostDriveNo@@3HA, -1 ; hiddenVolHostDriveNo
  034f1	eb 06		 jmp	 SHORT $LN1337@MainDialog
$LN1427@MainDialog:
  034f3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__MessageBoxW@16
$LN1337@MainDialog:

; 7325 : 					}
; 7326 : 
; 7327 : 					if (hiddenVolHostDriveNo < 0)		// If the hidden volume host is not mounted
; 7328 : 					{
; 7329 : 						int retCode;
; 7330 : 
; 7331 : 						// Mount the hidden volume host as read-only (to ensure consistent and secure
; 7332 : 						// results of the volume bitmap scanning)
; 7333 : 						switch (MountHiddenVolHost (hwndDlg, szDiskFile, &hiddenVolHostDriveNo, &volumePassword, TRUE))

  034f9	6a 01		 push	 1
  034fb	68 00 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A ; volumePassword
  03500	68 00 00 00 00	 push	 OFFSET ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  03505	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0350a	53		 push	 ebx
  0350b	e8 00 00 00 00	 call	 _MountHiddenVolHost
  03510	83 c4 14	 add	 esp, 20			; 00000014H
  03513	83 f8 18	 cmp	 eax, 24			; 00000018H
  03516	0f 87 58 e1 ff
	ff		 ja	 $LN1474@MainDialog
  0351c	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN1392@MainDialog[eax]
  03523	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN1512@MainDialog[eax*4]
$LN315@MainDialog:

; 7334 : 						{
; 7335 : 						case ERR_NO_FREE_DRIVES:
; 7336 : 							NormalCursor ();

  0352a	e8 00 00 00 00	 call	 _NormalCursor

; 7337 : 							MessageBoxW (hwndDlg, GetString ("NO_FREE_DRIVE_FOR_OUTER_VOL"), lpszTitle, ICON_HAND);

  0352f	6a 10		 push	 16			; 00000010H
  03531	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  03537	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DNIPKEFC@NO_FREE_DRIVE_FOR_OUTER_VOL?$AA@
  0353c	e8 00 00 00 00	 call	 _GetString
  03541	83 c4 04	 add	 esp, 4
  03544	50		 push	 eax
  03545	53		 push	 ebx
  03546	ff d6		 call	 esi
$ovf_end_50$1568:

; 6074 : 			}
; 6075 : 			return 1;

  03548	b8 01 00 00 00	 mov	 eax, 1
  0354d	e9 5d cb ff ff	 jmp	 $LN1@MainDialog
$LN317@MainDialog:

; 7338 : 							return 1;
; 7339 : 						case ERR_VOL_MOUNT_FAILED:
; 7340 : 						case ERR_PASSWORD_WRONG:
; 7341 : 							NormalCursor ();
; 7342 : 							return 1;
; 7343 : 						case 0:
; 7344 : 
; 7345 : 							/* Hidden volume host successfully mounted as read-only */
; 7346 : 
; 7347 : 							WaitCursor ();

  03552	e8 00 00 00 00	 call	 _WaitCursor

; 7348 : 
; 7349 : 							// Verify that the outer volume contains a suitable file system, retrieve cluster size, and 
; 7350 : 							// scan the volume bitmap
; 7351 : 							if (!IsAdmin () && IsUacSupported ())

  03557	e8 00 00 00 00	 call	 _IsAdmin
  0355c	85 c0		 test	 eax, eax
  0355e	75 38		 jne	 SHORT $LN318@MainDialog
  03560	e8 00 00 00 00	 call	 _IsUacSupported
  03565	85 c0		 test	 eax, eax
  03567	74 2f		 je	 SHORT $LN318@MainDialog

; 7352 : 								retCode = UacAnalyzeHiddenVolumeHost (hwndDlg, &hiddenVolHostDriveNo, GetVolumeDataAreaSize (FALSE, nHiddenVolHostSize), &realClusterSize, &nbrFreeClusters);

  03569	68 00 00 00 00	 push	 OFFSET ?nbrFreeClusters@@3_JA ; nbrFreeClusters
  0356e	68 00 00 00 00	 push	 OFFSET ?realClusterSize@@3HA ; realClusterSize
  03573	ff 35 04 00 00
	00		 push	 DWORD PTR ?nHiddenVolHostSize@@3_KA+4
  03579	ff 35 00 00 00
	00		 push	 DWORD PTR ?nHiddenVolHostSize@@3_KA
  0357f	6a 00		 push	 0
  03581	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  03586	83 c4 0c	 add	 esp, 12			; 0000000cH
  03589	52		 push	 edx
  0358a	50		 push	 eax
  0358b	68 00 00 00 00	 push	 OFFSET ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  03590	53		 push	 ebx
  03591	e8 00 00 00 00	 call	 _UacAnalyzeHiddenVolumeHost

; 7353 : 							else

  03596	eb 2d		 jmp	 SHORT $LN1495@MainDialog
$LN318@MainDialog:

; 7354 : 								retCode = AnalyzeHiddenVolumeHost (hwndDlg, &hiddenVolHostDriveNo, GetVolumeDataAreaSize (FALSE, nHiddenVolHostSize), &realClusterSize, &nbrFreeClusters);

  03598	68 00 00 00 00	 push	 OFFSET ?nbrFreeClusters@@3_JA ; nbrFreeClusters
  0359d	68 00 00 00 00	 push	 OFFSET ?realClusterSize@@3HA ; realClusterSize
  035a2	ff 35 04 00 00
	00		 push	 DWORD PTR ?nHiddenVolHostSize@@3_KA+4
  035a8	ff 35 00 00 00
	00		 push	 DWORD PTR ?nHiddenVolHostSize@@3_KA
  035ae	6a 00		 push	 0
  035b0	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  035b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  035b8	52		 push	 edx
  035b9	50		 push	 eax
  035ba	68 00 00 00 00	 push	 OFFSET ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  035bf	53		 push	 ebx
  035c0	e8 00 00 00 00	 call	 _AnalyzeHiddenVolumeHost
$LN1495@MainDialog:
  035c5	83 c4 18	 add	 esp, 24			; 00000018H

; 7355 : 
; 7356 : 							switch (retCode)

  035c8	83 f8 ff	 cmp	 eax, -1
  035cb	0f 84 78 fa ff
	ff		 je	 $LN435@MainDialog
  035d1	85 c0		 test	 eax, eax
  035d3	0f 84 bb 00 00
	00		 je	 $LN322@MainDialog
  035d9	83 f8 01	 cmp	 eax, 1
  035dc	0f 85 92 e0 ff
	ff		 jne	 $LN1474@MainDialog

; 7376 : 								return 1;
; 7377 : 
; 7378 : 							case 1:
; 7379 : 
; 7380 : 								// Determine the maximum possible size of the hidden volume
; 7381 : 								if (DetermineMaxHiddenVolSize (hwndDlg) < 1)

  035e2	53		 push	 ebx
  035e3	e8 00 00 00 00	 call	 _DetermineMaxHiddenVolSize
  035e8	83 c4 04	 add	 esp, 4
  035eb	83 f8 01	 cmp	 eax, 1
  035ee	0f 8c 50 e1 ff
	ff		 jl	 $LN1291@MainDialog

; 7382 : 								{
; 7383 : 									// Non-fatal error while determining maximum possible size of the hidden volume
; 7384 : 									NormalCursor();
; 7385 : 									return 1;
; 7386 : 								}
; 7387 : 								else
; 7388 : 								{
; 7389 : 									BOOL tmp_result;
; 7390 : 
; 7391 : 									/* Maximum possible size of the hidden volume successfully determined */
; 7392 : 
; 7393 : 									// Dismount the hidden volume host
; 7394 : 									while (!(tmp_result = UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE)))

  035f4	6a 01		 push	 1
  035f6	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  035fc	53		 push	 ebx
  035fd	e8 00 00 00 00	 call	 _UnmountVolume
  03602	83 c4 0c	 add	 esp, 12			; 0000000cH
  03605	85 c0		 test	 eax, eax
  03607	75 3e		 jne	 SHORT $LN1335@MainDialog
  03609	0f 1f 80 00 00
	00 00		 npad	 7
$LL31@MainDialog:

; 7395 : 									{
; 7396 : 										if (MessageBoxW (hwndDlg, GetString ("CANT_DISMOUNT_OUTER_VOL"), lpszTitle, MB_RETRYCANCEL) != IDRETRY)

  03610	6a 05		 push	 5
  03612	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  03618	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GNHKCMLM@CANT_DISMOUNT_OUTER_VOL?$AA@
  0361d	e8 00 00 00 00	 call	 _GetString
  03622	83 c4 04	 add	 esp, 4
  03625	50		 push	 eax
  03626	53		 push	 ebx
  03627	ff d6		 call	 esi
  03629	83 f8 04	 cmp	 eax, 4
  0362c	0f 85 12 e1 ff
	ff		 jne	 $LN1291@MainDialog

; 7382 : 								{
; 7383 : 									// Non-fatal error while determining maximum possible size of the hidden volume
; 7384 : 									NormalCursor();
; 7385 : 									return 1;
; 7386 : 								}
; 7387 : 								else
; 7388 : 								{
; 7389 : 									BOOL tmp_result;
; 7390 : 
; 7391 : 									/* Maximum possible size of the hidden volume successfully determined */
; 7392 : 
; 7393 : 									// Dismount the hidden volume host
; 7394 : 									while (!(tmp_result = UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE)))

  03632	6a 01		 push	 1
  03634	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  0363a	53		 push	 ebx
  0363b	e8 00 00 00 00	 call	 _UnmountVolume
  03640	83 c4 0c	 add	 esp, 12			; 0000000cH
  03643	85 c0		 test	 eax, eax
  03645	74 c9		 je	 SHORT $LL31@MainDialog
$LN1335@MainDialog:

; 7397 : 										{
; 7398 : 											// Cancel
; 7399 : 											NormalCursor();
; 7400 : 											return 1;
; 7401 : 										}
; 7402 : 									}
; 7403 : 
; 7404 : 									if (tmp_result)		// If dismounted
; 7405 : 									{
; 7406 : 										hiddenVolHostDriveNo = -1;

  03647	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?hiddenVolHostDriveNo@@3HA, -1 ; hiddenVolHostDriveNo

; 7407 : 
; 7408 : 										bHiddenVolHost = FALSE; 

  03651	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHiddenVolHost, 0

; 7409 : 										bHiddenVolFinished = FALSE;

  0365b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bHiddenVolFinished@@3HC, 0 ; bHiddenVolFinished

; 7410 : 
; 7411 : 										// Clear the outer volume password
; 7412 : 										WipePasswordsAndKeyfiles ();

  03665	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles

; 7413 : 
; 7414 : 										RestoreDefaultKeyFilesParam ();

  0366a	e8 00 00 00 00	 call	 _RestoreDefaultKeyFilesParam

; 7415 : 
; 7416 : 										EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), TRUE);

  0366f	6a 01		 push	 1
  03671	68 10 04 00 00	 push	 1040			; 00000410H
  03676	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0367c	ff d7		 call	 edi
  0367e	50		 push	 eax
  0367f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 7417 : 										NormalCursor ();

  03685	e8 00 00 00 00	 call	 _NormalCursor

; 7418 : 
; 7419 : 										nNewPageNo = HIDDEN_VOL_HOST_PRE_CIPHER_PAGE;

  0368a	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  0368f	e9 e6 df ff ff	 jmp	 $LN310@MainDialog
$LN322@MainDialog:

; 7357 : 							{
; 7358 : 							case -1:	// Fatal error
; 7359 : 								CloseVolumeExplorerWindows (hwndDlg, hiddenVolHostDriveNo);
; 7360 : 
; 7361 : 								if (UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE))
; 7362 : 									hiddenVolHostDriveNo = -1;
; 7363 : 
; 7364 : 								AbortProcessSilent ();
; 7365 : 								break;
; 7366 : 
; 7367 : 							case 0:		// Unsupported file system (or other non-fatal error which has already been reported)
; 7368 : 								if (bHiddenVolDirect)

  03694	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolDirect, 0
  0369b	74 31		 je	 SHORT $LN324@MainDialog

; 7369 : 								{
; 7370 : 									CloseVolumeExplorerWindows (hwndDlg, hiddenVolHostDriveNo);

  0369d	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  036a3	53		 push	 ebx
  036a4	e8 00 00 00 00	 call	 _CloseVolumeExplorerWindows

; 7371 : 
; 7372 : 									if (UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE))

  036a9	6a 01		 push	 1
  036ab	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  036b1	53		 push	 ebx
  036b2	e8 00 00 00 00	 call	 _UnmountVolume
  036b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  036bd	83 ca ff	 or	 edx, -1
  036c0	83 c4 14	 add	 esp, 20			; 00000014H
  036c3	85 c0		 test	 eax, eax
  036c5	0f 45 ca	 cmovne	 ecx, edx
  036c8	89 0d 00 00 00
	00		 mov	 DWORD PTR ?hiddenVolHostDriveNo@@3HA, ecx ; hiddenVolHostDriveNo
$LN324@MainDialog:

; 7373 : 										hiddenVolHostDriveNo = -1;
; 7374 : 								}
; 7375 : 								NormalCursor ();

  036ce	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_51$1569:

; 6074 : 			}
; 6075 : 			return 1;

  036d3	b8 01 00 00 00	 mov	 eax, 1
  036d8	e9 d2 c9 ff ff	 jmp	 $LN1@MainDialog
$LN309@MainDialog:

; 7420 : 									}
; 7421 : 								}
; 7422 : 								break;
; 7423 : 							}
; 7424 : 							break;
; 7425 : 						}
; 7426 : 					}
; 7427 : 				}
; 7428 : 				else
; 7429 : 				{
; 7430 : 					/* Scan all available partitions to discover all partitions where non-system in-place
; 7431 : 					encryption has been interrupted. */
; 7432 : 
; 7433 : 					BOOL tmpbDevice;
; 7434 : 					DeferredNonSysInPlaceEncDevices.clear();

  036dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A ; DeferredNonSysInPlaceEncDevices
  036e2	e8 00 00 00 00	 call	 ?clear@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::clear

; 7435 : 
; 7436 : 					foreach (const HostDevice &device, GetAvailableHostDevices (true, true))

  036e7	6a 00		 push	 0
  036e9	6a 01		 push	 1
  036eb	6a 01		 push	 1
  036ed	8d 85 cc 2c ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  036f3	6a 01		 push	 1
  036f5	50		 push	 eax
  036f6	e8 00 00 00 00	 call	 ?GetAvailableHostDevices@@YA?AV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@_N000@Z ; GetAvailableHostDevices
  036fb	50		 push	 eax
  036fc	8d 85 30 2d ff
	ff		 lea	 eax, DWORD PTR _$S2$27[ebp]
  03702	c7 45 fc 27 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 39 ; 00000027H
  03709	50		 push	 eax
  0370a	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >
  0370f	83 c4 1c	 add	 esp, 28			; 0000001cH
  03712	8d 8d cc 2c ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  03718	c6 45 fc 29	 mov	 BYTE PTR __$EHRec$[ebp+12], 41 ; 00000029H
  0371c	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy
  03721	8b 85 30 2d ff
	ff		 mov	 eax, DWORD PTR _$S2$27[ebp]
  03727	8d 8d 30 2d ff
	ff		 lea	 ecx, DWORD PTR _$S2$27[ebp]
  0372d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  03730	ff d0		 call	 eax
  03732	84 c0		 test	 al, al
  03734	0f 84 05 01 00
	00		 je	 $LN34@MainDialog
  0373a	8b 9d 58 2d ff
	ff		 mov	 ebx, DWORD PTR $T31[ebp]
$LL35@MainDialog:
  03740	8b b5 48 2d ff
	ff		 mov	 esi, DWORD PTR _$S2$27[ebp+24]
  03746	f6 c3 02	 test	 bl, 2
  03749	74 0e		 je	 SHORT $LN991@MainDialog
  0374b	8d 8d c0 2c ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  03751	83 e3 fd	 and	 ebx, -3			; fffffffdH
  03754	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy
$LN991@MainDialog:
  03759	33 c0		 xor	 eax, eax
  0375b	38 85 35 2d ff
	ff		 cmp	 BYTE PTR _$S2$27[ebp+5], al
  03761	0f 94 c0	 sete	 al
  03764	88 85 35 2d ff
	ff		 mov	 BYTE PTR _$S2$27[ebp+5], al
  0376a	84 c0		 test	 al, al
  0376c	0f 84 9f 00 00
	00		 je	 $LN33@MainDialog
$LL38@MainDialog:

; 7437 : 					{
; 7438 : 						if (device.IsPartition || device.DynamicVolume)

  03772	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  03776	75 0a		 jne	 SHORT $LN331@MainDialog
  03778	80 7e 02 00	 cmp	 BYTE PTR [esi+2], 0
  0377c	0f 84 6f 00 00
	00		 je	 $LN36@MainDialog
$LN331@MainDialog:

; 7439 : 						{
; 7440 : 							OpenVolumeContext volume;
; 7441 : 
; 7442 : 							if (OpenVolume (&volume, device.Path.c_str(), &volumePassword, FALSE, FALSE, TRUE) == ERR_SUCCESS)

  03782	83 7e 4c 10	 cmp	 DWORD PTR [esi+76], 16	; 00000010H
  03786	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  03789	72 02		 jb	 SHORT $LN1010@MainDialog
  0378b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1010@MainDialog:
  0378d	6a 01		 push	 1
  0378f	6a 00		 push	 0
  03791	6a 00		 push	 0
  03793	68 00 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A ; volumePassword
  03798	50		 push	 eax
  03799	8d 85 88 2c ff
	ff		 lea	 eax, DWORD PTR _volume$2[ebp]
  0379f	50		 push	 eax
  037a0	e8 00 00 00 00	 call	 _OpenVolume
  037a5	83 c4 18	 add	 esp, 24			; 00000018H
  037a8	85 c0		 test	 eax, eax
  037aa	75 45		 jne	 SHORT $LN36@MainDialog

; 7443 : 							{
; 7444 : 								if ((volume.CryptoInfo->HeaderFlags & GST_HEADER_FLAG_NONSYS_INPLACE_ENC) != 0
; 7445 : 									&& volume.CryptoInfo->EncryptedAreaLength.Value != volume.CryptoInfo->VolumeSize.Value)

  037ac	8b 8d 8c 2c ff
	ff		 mov	 ecx, DWORD PTR _volume$2[ebp+4]
  037b2	f6 81 08 1f 00
	00 02		 test	 BYTE PTR [ecx+7944], 2
  037b9	74 27		 je	 SHORT $LN333@MainDialog
  037bb	8b 81 00 1f 00
	00		 mov	 eax, DWORD PTR [ecx+7936]
  037c1	3b 81 f0 1e 00
	00		 cmp	 eax, DWORD PTR [ecx+7920]
  037c7	75 0e		 jne	 SHORT $LN1393@MainDialog
  037c9	8b 81 04 1f 00
	00		 mov	 eax, DWORD PTR [ecx+7940]
  037cf	3b 81 f4 1e 00
	00		 cmp	 eax, DWORD PTR [ecx+7924]
  037d5	74 0b		 je	 SHORT $LN333@MainDialog
$LN1393@MainDialog:

; 7446 : 								{
; 7447 : 									DeferredNonSysInPlaceEncDevices.push_back (device);

  037d7	56		 push	 esi
  037d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A ; DeferredNonSysInPlaceEncDevices
  037dd	e8 00 00 00 00	 call	 ?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::push_back
$LN333@MainDialog:

; 7448 : 								}
; 7449 : 
; 7450 : 								CloseVolume (&volume);

  037e2	8d 85 88 2c ff
	ff		 lea	 eax, DWORD PTR _volume$2[ebp]
  037e8	50		 push	 eax
  037e9	e8 00 00 00 00	 call	 _CloseVolume
  037ee	83 c4 04	 add	 esp, 4
$LN36@MainDialog:

; 7435 : 
; 7436 : 					foreach (const HostDevice &device, GetAvailableHostDevices (true, true))

  037f1	33 c0		 xor	 eax, eax
  037f3	c6 85 34 2d ff
	ff 01		 mov	 BYTE PTR _$S2$27[ebp+4], 1
  037fa	38 85 35 2d ff
	ff		 cmp	 BYTE PTR _$S2$27[ebp+5], al
  03800	0f 94 c0	 sete	 al
  03803	88 85 35 2d ff
	ff		 mov	 BYTE PTR _$S2$27[ebp+5], al
  03809	84 c0		 test	 al, al
  0380b	0f 85 61 ff ff
	ff		 jne	 $LL38@MainDialog
$LN33@MainDialog:
  03811	8b 85 30 2d ff
	ff		 mov	 eax, DWORD PTR _$S2$27[ebp]
  03817	8d 8d 30 2d ff
	ff		 lea	 ecx, DWORD PTR _$S2$27[ebp]
  0381d	ff 50 08	 call	 DWORD PTR [eax+8]
  03820	8b 85 30 2d ff
	ff		 mov	 eax, DWORD PTR _$S2$27[ebp]
  03826	8d 8d 30 2d ff
	ff		 lea	 ecx, DWORD PTR _$S2$27[ebp]
  0382c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0382f	ff d0		 call	 eax
  03831	84 c0		 test	 al, al
  03833	0f 85 07 ff ff
	ff		 jne	 $LL35@MainDialog
  03839	8b 9d 60 2d ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
$LN34@MainDialog:

; 7451 : 							}
; 7452 : 						}
; 7453 : 					}

  0383f	8d 8d 38 2d ff
	ff		 lea	 ecx, DWORD PTR _$S2$27[ebp+8]
  03845	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy

; 7454 : 
; 7455 : 					if (DeferredNonSysInPlaceEncDevices.empty())

  0384a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A
  03850	a1 04 00 00 00	 mov	 eax, DWORD PTR ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A+4
  03855	3b c8		 cmp	 ecx, eax
  03857	75 1c		 jne	 SHORT $LN334@MainDialog

; 7456 : 					{
; 7457 : 						Warning ("FOUND_NO_PARTITION_W_DEFERRED_INPLACE_ENC");

  03859	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@DBNLNPHP@FOUND_NO_PARTITION_W_DEFERRED_IN@
  0385e	e8 00 00 00 00	 call	 _Warning
  03863	83 c4 04	 add	 esp, 4

; 7458 : 
; 7459 : 						NormalCursor();

  03866	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_52$1570:

; 6074 : 			}
; 6075 : 			return 1;

  0386b	b8 01 00 00 00	 mov	 eax, 1
  03870	e9 3a c8 ff ff	 jmp	 $LN1@MainDialog
$LN334@MainDialog:

; 7460 : 						return 1;
; 7461 : 					}
; 7462 : 					else if (DeferredNonSysInPlaceEncDevices.size() == 1)

  03875	2b c1		 sub	 eax, ecx
  03877	83 e8 70	 sub	 eax, 112		; 00000070H
  0387a	83 f8 70	 cmp	 eax, 112		; 00000070H
  0387d	73 68		 jae	 SHORT $LN1475@MainDialog

; 7463 : 					{
; 7464 : 						CreateFullVolumePath (szDiskFile, DeferredNonSysInPlaceEncDevices.front().Path.c_str(), &tmpbDevice);

  0387f	83 79 4c 10	 cmp	 DWORD PTR [ecx+76], 16	; 00000010H
  03883	8d 41 38	 lea	 eax, DWORD PTR [ecx+56]
  03886	72 02		 jb	 SHORT $LN1108@MainDialog
  03888	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1108@MainDialog:
  0388a	8d 8d 18 2d ff
	ff		 lea	 ecx, DWORD PTR _tmpbDevice$21[ebp]
  03890	51		 push	 ecx
  03891	50		 push	 eax
  03892	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  03897	e8 00 00 00 00	 call	 _CreateFullVolumePath

; 7465 : 
; 7466 : 						nVolumeSize = GetDeviceSize (szDiskFile);

  0389c	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  038a1	e8 00 00 00 00	 call	 _GetDeviceSize
  038a6	a3 00 00 00 00	 mov	 DWORD PTR ?nVolumeSize@@3_KA, eax
  038ab	83 c4 10	 add	 esp, 16			; 00000010H

; 7467 : 						if (nVolumeSize == -1)

  038ae	23 c2		 and	 eax, edx
  038b0	89 15 04 00 00
	00		 mov	 DWORD PTR ?nVolumeSize@@3_KA+4, edx
  038b6	83 f8 ff	 cmp	 eax, -1
  038b9	75 1d		 jne	 SHORT $LN337@MainDialog

; 7468 : 						{
; 7469 : 							handleWin32Error (MainDlg);

  038bb	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  038c1	e8 00 00 00 00	 call	 _handleWin32Error
  038c6	83 c4 04	 add	 esp, 4

; 7470 : 							NormalCursor();

  038c9	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_53$1571:

; 6074 : 			}
; 6075 : 			return 1;

  038ce	b8 01 00 00 00	 mov	 eax, 1
  038d3	e9 d7 c7 ff ff	 jmp	 $LN1@MainDialog
$LN337@MainDialog:

; 7471 : 							return 1;
; 7472 : 						}
; 7473 : 
; 7474 : 						nNewPageNo = NONSYS_INPLACE_ENC_ENCRYPTION_PAGE - 1;	// Skip irrelevant pages

  038d8	be 23 00 00 00	 mov	 esi, 35			; 00000023H

; 7475 : 					}
; 7476 : 
; 7477 : 					NormalCursor();

  038dd	e8 00 00 00 00	 call	 _NormalCursor
  038e2	e9 93 dd ff ff	 jmp	 $LN310@MainDialog
$LN1475@MainDialog:
  038e7	8b b5 6c 2d ff
	ff		 mov	 esi, DWORD PTR _nNewPageNo$1$[ebp]
  038ed	e8 00 00 00 00	 call	 _NormalCursor
  038f2	e9 83 dd ff ff	 jmp	 $LN310@MainDialog
$LN151@MainDialog:

; 8104 : ovf_end:
; 8105 : 			return 1;
; 8106 : 		}
; 8107 : 
; 8108 : 		else if (lw == IDC_PREV)

  038f7	be 11 04 00 00	 mov	 esi, 1041		; 00000411H
  038fc	66 3b d6	 cmp	 dx, si
  038ff	0f 85 a8 c7 ff
	ff		 jne	 $LN2@MainDialog

; 8109 : 		{
; 8110 : 			if (nCurPageNo == SYSENC_SPAN_PAGE)

  03905	83 f8 03	 cmp	 eax, 3
  03908	75 1a		 jne	 SHORT $LN447@MainDialog

; 8111 : 			{
; 8112 : 				// Skip irrelevant pages when going back
; 8113 : 				if (!bHiddenOS)

  0390a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenOS@@3HC ; bHiddenOS
  0390f	ba 02 00 00 00	 mov	 edx, 2
  03914	85 c0		 test	 eax, eax
  03916	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  0391b	0f 44 ca	 cmove	 ecx, edx
  0391e	89 8d 6c 2d ff
	ff		 mov	 DWORD PTR _nNewPageNo$1$[ebp], ecx
$LN447@MainDialog:

; 8114 : 					nNewPageNo = SYSENC_TYPE_PAGE + 1;
; 8115 : 			}
; 8116 : 			if (nCurPageNo == SYSENC_MULTI_BOOT_MODE_PAGE)

  03924	83 f8 06	 cmp	 eax, 6
  03927	75 4a		 jne	 SHORT $LN448@MainDialog

; 8117 : 			{
; 8118 : 				// Skip the drive analysis page(s) or other irrelevant pages when going back
; 8119 : 				if (bHiddenOS)

  03929	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  03930	74 1c		 je	 SHORT $LN450@MainDialog

; 8120 : 					nNewPageNo = SYSENC_HIDDEN_OS_REQ_CHECK_PAGE + 1;

  03932	b9 03 00 00 00	 mov	 ecx, 3

; 8324 : 						nNewPageNo = PASSWORD_PAGE + 1;		
; 8325 : 				}
; 8326 : 			}
; 8327 : 
; 8328 : 			LoadPage (hwndDlg, nNewPageNo - 1);

  03937	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0393a	50		 push	 eax
  0393b	53		 push	 ebx
  0393c	e8 00 00 00 00	 call	 _LoadPage
  03941	83 c4 08	 add	 esp, 8
$ovf_end_54$1572:

; 6074 : 			}
; 6075 : 			return 1;

  03944	b8 01 00 00 00	 mov	 eax, 1
  03949	e9 61 c7 ff ff	 jmp	 $LN1@MainDialog
$LN450@MainDialog:

; 8121 : 				else if (bWholeSysDrive)

  0394e	33 c9		 xor	 ecx, ecx
  03950	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?bWholeSysDrive@@3HA, ecx ; bWholeSysDrive
  03956	0f 95 c1	 setne	 cl
  03959	83 c1 04	 add	 ecx, 4

; 8324 : 						nNewPageNo = PASSWORD_PAGE + 1;		
; 8325 : 				}
; 8326 : 			}
; 8327 : 
; 8328 : 			LoadPage (hwndDlg, nNewPageNo - 1);

  0395c	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0395f	50		 push	 eax
  03960	53		 push	 ebx
  03961	e8 00 00 00 00	 call	 _LoadPage
  03966	83 c4 08	 add	 esp, 8
$ovf_end_55$1573:

; 6074 : 			}
; 6075 : 			return 1;

  03969	b8 01 00 00 00	 mov	 eax, 1
  0396e	e9 3c c7 ff ff	 jmp	 $LN1@MainDialog
$LN448@MainDialog:

; 8122 : 					nNewPageNo = SYSENC_PRE_DRIVE_ANALYSIS_PAGE + 1;	
; 8123 : 				else
; 8124 : 					nNewPageNo = SYSENC_SPAN_PAGE + 1;	
; 8125 : 			}
; 8126 : 			else if (nCurPageNo == SYSENC_MULTI_BOOT_NONWIN_BOOT_LOADER_PAGE)

  03973	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  03976	75 29		 jne	 SHORT $LN454@MainDialog

; 8127 : 			{
; 8128 : 				if (SysEncMultiBootCfg.NumberOfSysDrives == 1)

  03978	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A, 1
  0397f	0f 85 17 01 00
	00		 jne	 $LN498@MainDialog

; 8129 : 				{
; 8130 : 					// We can skip SYSENC_MULTI_BOOT_ADJACENT_SYS_PAGE (it is implied that there are multiple systems on the drive)
; 8131 : 					nNewPageNo = SYSENC_MULTI_BOOT_NBR_SYS_DRIVES_PAGE + 1;

  03985	b9 09 00 00 00	 mov	 ecx, 9

; 8324 : 						nNewPageNo = PASSWORD_PAGE + 1;		
; 8325 : 				}
; 8326 : 			}
; 8327 : 
; 8328 : 			LoadPage (hwndDlg, nNewPageNo - 1);

  0398a	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0398d	50		 push	 eax
  0398e	53		 push	 ebx
  0398f	e8 00 00 00 00	 call	 _LoadPage
  03994	83 c4 08	 add	 esp, 8
$ovf_end_56$1574:

; 6074 : 			}
; 6075 : 			return 1;

  03997	b8 01 00 00 00	 mov	 eax, 1
  0399c	e9 0e c7 ff ff	 jmp	 $LN1@MainDialog
$LN454@MainDialog:

; 8132 : 				}
; 8133 : 			}
; 8134 : 			else if (nCurPageNo == HIDDEN_VOL_HOST_PRE_CIPHER_PAGE)

  039a1	83 f8 10	 cmp	 eax, 16			; 00000010H
  039a4	0f 85 c2 00 00
	00		 jne	 $LN457@MainDialog

; 8135 : 			{
; 8136 : 				if (bHiddenOS)

  039aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  039b1	0f 84 99 00 00
	00		 je	 $LN459@MainDialog

; 8137 : 				{
; 8138 : 					if (!ChangeWizardMode (WIZARD_MODE_SYS_DEVICE))

  039b7	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  039be	74 64		 je	 SHORT $LN1260@MainDialog
  039c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  039c5	e8 00 00 00 00	 call	 _CreateSysEncMutex
  039ca	85 c0		 test	 eax, eax
  039cc	75 1c		 jne	 SHORT $LN1264@MainDialog
  039ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  039d3	e8 00 00 00 00	 call	 _Error
  039d8	83 c4 04	 add	 esp, 4

; 8139 : 					{
; 8140 : 						NormalCursor ();

  039db	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_57$1575:

; 6074 : 			}
; 6075 : 			return 1;

  039e0	b8 01 00 00 00	 mov	 eax, 1
  039e5	e9 c5 c6 ff ff	 jmp	 $LN1@MainDialog

; 8137 : 				{
; 8138 : 					if (!ChangeWizardMode (WIZARD_MODE_SYS_DEVICE))

$LN1264@MainDialog:
  039ea	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles
  039ef	0f 57 c0	 xorps	 xmm0, xmm0
  039f2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0
  039fc	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szFileName@@3PADA, 0
  03a03	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szDiskFile@@3PADA, 0
  03a0a	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  03a12	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  03a1a	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _WizardMode, 2
$LN1260@MainDialog:
  03a24	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode

; 8141 : 						return 1;
; 8142 : 					}
; 8143 : 
; 8144 : 					// Skip irrelevant pages.
; 8145 : 					// Note that we're ignoring nMultiBoot here, as the multi-boot question pages are skipped
; 8146 : 					// when creating a hidden OS (only a single message box is displayed with requirements).
; 8147 : 					nNewPageNo = SYSENC_MULTI_BOOT_MODE_PAGE + 1;		

  03a29	b9 07 00 00 00	 mov	 ecx, 7
  03a2e	f7 d8		 neg	 eax
  03a30	1b c0		 sbb	 eax, eax
  03a32	f7 d8		 neg	 eax
  03a34	a3 00 00 00 00	 mov	 DWORD PTR ?bDevice@@3HA, eax ; bDevice

; 8324 : 						nNewPageNo = PASSWORD_PAGE + 1;		
; 8325 : 				}
; 8326 : 			}
; 8327 : 
; 8328 : 			LoadPage (hwndDlg, nNewPageNo - 1);

  03a39	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  03a3c	50		 push	 eax
  03a3d	53		 push	 ebx
  03a3e	e8 00 00 00 00	 call	 _LoadPage
  03a43	83 c4 08	 add	 esp, 8
$ovf_end_58$1576:

; 6074 : 			}
; 6075 : 			return 1;

  03a46	b8 01 00 00 00	 mov	 eax, 1
  03a4b	e9 5f c6 ff ff	 jmp	 $LN1@MainDialog
$LN459@MainDialog:

; 8148 : 				}
; 8149 : 				else
; 8150 : 				{
; 8151 : 					nNewPageNo = VOLUME_LOCATION_PAGE + 1;

  03a50	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH

; 8324 : 						nNewPageNo = PASSWORD_PAGE + 1;		
; 8325 : 				}
; 8326 : 			}
; 8327 : 
; 8328 : 			LoadPage (hwndDlg, nNewPageNo - 1);

  03a55	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  03a58	50		 push	 eax
  03a59	53		 push	 ebx
  03a5a	e8 00 00 00 00	 call	 _LoadPage
  03a5f	83 c4 08	 add	 esp, 8
$ovf_end_59$1577:

; 6074 : 			}
; 6075 : 			return 1;

  03a62	b8 01 00 00 00	 mov	 eax, 1
  03a67	e9 43 c6 ff ff	 jmp	 $LN1@MainDialog
$LN457@MainDialog:

; 8152 : 				}
; 8153 : 			}
; 8154 : 			else if (nCurPageNo == HIDDEN_VOL_WIZARD_MODE_PAGE)

  03a6c	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  03a6f	75 42		 jne	 SHORT $LN462@MainDialog

; 8155 : 			{
; 8156 : 				if (IsButtonChecked (GetDlgItem (hCurPage, IDC_HIDVOL_WIZ_MODE_DIRECT)))

  03a71	68 0c 04 00 00	 push	 1036			; 0000040cH
  03a76	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03a7c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  03a82	50		 push	 eax
  03a83	e8 00 00 00 00	 call	 _IsButtonChecked
  03a88	83 c4 04	 add	 esp, 4
  03a8b	f7 d8		 neg	 eax
  03a8d	1b c0		 sbb	 eax, eax
  03a8f	f7 d8		 neg	 eax
  03a91	a3 00 00 00 00	 mov	 DWORD PTR _bHiddenVolDirect, eax
$LN1483@MainDialog:
  03a96	8b 8d 6c 2d ff
	ff		 mov	 ecx, DWORD PTR _nNewPageNo$1$[ebp]
$LN498@MainDialog:

; 8324 : 						nNewPageNo = PASSWORD_PAGE + 1;		
; 8325 : 				}
; 8326 : 			}
; 8327 : 
; 8328 : 			LoadPage (hwndDlg, nNewPageNo - 1);

  03a9c	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  03a9f	50		 push	 eax
  03aa0	53		 push	 ebx
  03aa1	e8 00 00 00 00	 call	 _LoadPage
  03aa6	83 c4 08	 add	 esp, 8
$ovf_end_60$1578:

; 6074 : 			}
; 6075 : 			return 1;

  03aa9	b8 01 00 00 00	 mov	 eax, 1
  03aae	e9 fc c5 ff ff	 jmp	 $LN1@MainDialog
$LN462@MainDialog:

; 8157 : 					bHiddenVolDirect = TRUE;
; 8158 : 				else
; 8159 : 					bHiddenVolDirect = FALSE;
; 8160 : 			}
; 8161 : 			else if (nCurPageNo == VOLUME_TYPE_PAGE)

  03ab3	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  03ab6	75 0e		 jne	 SHORT $LN466@MainDialog

; 8162 : 			{
; 8163 : 				if (WizardMode != WIZARD_MODE_SYS_DEVICE)

  03ab8	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  03abf	74 db		 je	 SHORT $LN498@MainDialog

; 8164 : 					nNewPageNo = INTRO_PAGE + 1;	// Skip irrelevant pages

  03ac1	8d 48 f5	 lea	 ecx, DWORD PTR [eax-11]

; 8165 : 			}

  03ac4	eb d6		 jmp	 SHORT $LN498@MainDialog
$LN466@MainDialog:

; 8166 : 			else if (nCurPageNo == VOLUME_LOCATION_PAGE)

  03ac6	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  03ac9	0f 85 89 00 00
	00		 jne	 $LN469@MainDialog

; 8167 : 			{
; 8168 : 				BOOL tmpbDevice;
; 8169 : 
; 8170 : 				GetWindowText (GetDlgItem (hCurPage, IDC_COMBO_BOX), szFileName, sizeof (szFileName));

  03acf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  03ad5	68 05 01 00 00	 push	 261			; 00000105H
  03ada	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  03adf	68 ea 03 00 00	 push	 1002			; 000003eaH
  03ae4	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03aea	ff d6		 call	 esi
  03aec	50		 push	 eax
  03aed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 8171 : 				CreateFullVolumePath (szDiskFile, szFileName, &tmpbDevice);

  03af3	8d 85 4c 2d ff
	ff		 lea	 eax, DWORD PTR _tmpbDevice$28[ebp]
  03af9	50		 push	 eax
  03afa	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  03aff	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  03b04	e8 00 00 00 00	 call	 _CreateFullVolumePath

; 8172 : 
; 8173 : 				if (tmpbDevice == bDevice)

  03b09	8b 85 4c 2d ff
	ff		 mov	 eax, DWORD PTR _tmpbDevice$28[ebp]
  03b0f	83 c4 0c	 add	 esp, 12			; 0000000cH
  03b12	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?bDevice@@3HA ; bDevice
  03b18	75 27		 jne	 SHORT $LN471@MainDialog

; 8174 : 				{
; 8175 : 					MoveEditToCombo (GetDlgItem (hCurPage, IDC_COMBO_BOX), bHistory);

  03b1a	ff 35 00 00 00
	00		 push	 DWORD PTR _bHistory
  03b20	68 ea 03 00 00	 push	 1002			; 000003eaH
  03b25	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03b2b	ff d6		 call	 esi
  03b2d	50		 push	 eax
  03b2e	e8 00 00 00 00	 call	 _MoveEditToCombo

; 8176 : 					SaveSettings (hCurPage);

  03b33	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03b39	e8 00 00 00 00	 call	 _SaveSettings
  03b3e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN471@MainDialog:

; 8177 : 				}
; 8178 : 
; 8179 : 				if (!bHiddenVol)

  03b41	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  03b48	0f 85 48 ff ff
	ff		 jne	 $LN1483@MainDialog

; 8180 : 					nNewPageNo = VOLUME_TYPE_PAGE + 1;		// Skip the hidden volume creation wizard mode selection

  03b4e	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH

; 8181 : 			}

  03b53	e9 44 ff ff ff	 jmp	 $LN498@MainDialog
$LN469@MainDialog:

; 8182 : 
; 8183 : 			else if (nCurPageNo == CIPHER_PAGE)

  03b58	83 f8 12	 cmp	 eax, 18			; 00000012H
  03b5b	0f 85 d6 00 00
	00		 jne	 $LN473@MainDialog

; 8184 : 			{
; 8185 : 				LPARAM nIndex;
; 8186 : 				nIndex = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX), CB_GETCURSEL, 0, 0);

  03b61	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  03b67	6a 00		 push	 0
  03b69	6a 00		 push	 0
  03b6b	68 47 01 00 00	 push	 327			; 00000147H
  03b70	68 ea 03 00 00	 push	 1002			; 000003eaH
  03b75	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03b7b	ff d7		 call	 edi
  03b7d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  03b83	50		 push	 eax
  03b84	ff d6		 call	 esi

; 8187 : 				nVolumeEA = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX), CB_GETITEMDATA, nIndex, 0);

  03b86	6a 00		 push	 0
  03b88	50		 push	 eax
  03b89	68 50 01 00 00	 push	 336			; 00000150H
  03b8e	68 ea 03 00 00	 push	 1002			; 000003eaH
  03b93	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03b99	ff d7		 call	 edi
  03b9b	50		 push	 eax
  03b9c	ff d6		 call	 esi

; 8188 : 
; 8189 : 				nIndex = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX_HASH_ALGO), CB_GETCURSEL, 0, 0);

  03b9e	6a 00		 push	 0
  03ba0	6a 00		 push	 0
  03ba2	68 47 01 00 00	 push	 327			; 00000147H
  03ba7	68 f0 03 00 00	 push	 1008			; 000003f0H
  03bac	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03bb2	a3 00 00 00 00	 mov	 DWORD PTR ?nVolumeEA@@3HA, eax ; nVolumeEA
  03bb7	ff d7		 call	 edi
  03bb9	50		 push	 eax
  03bba	ff d6		 call	 esi

; 8190 : 				hash_algo = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX_HASH_ALGO), CB_GETITEMDATA, nIndex, 0);

  03bbc	6a 00		 push	 0
  03bbe	50		 push	 eax
  03bbf	68 50 01 00 00	 push	 336			; 00000150H
  03bc4	68 f0 03 00 00	 push	 1008			; 000003f0H
  03bc9	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03bcf	ff d7		 call	 edi
  03bd1	50		 push	 eax
  03bd2	ff d6		 call	 esi

; 8191 : 
; 8192 : 				RandSetHashFunction (hash_algo);

  03bd4	50		 push	 eax
  03bd5	a3 00 00 00 00	 mov	 DWORD PTR ?hash_algo@@3HA, eax ; hash_algo
  03bda	e8 00 00 00 00	 call	 _RandSetHashFunction
  03bdf	83 c4 04	 add	 esp, 4

; 8193 : 
; 8194 : 				if (WizardMode == WIZARD_MODE_SYS_DEVICE)

  03be2	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  03be9	75 19		 jne	 SHORT $LN475@MainDialog

; 8195 : 				{
; 8196 : 					if (nMultiBoot > 1)

  03beb	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?nMultiBoot@@3HA, 1 ; nMultiBoot
  03bf2	b9 07 00 00 00	 mov	 ecx, 7
  03bf7	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  03bfc	0f 4f c8	 cmovg	 ecx, eax

; 8197 : 						nNewPageNo = SYSENC_MULTI_BOOT_OUTCOME_PAGE + 1;	// Skip irrelevant pages
; 8198 : 					else
; 8199 : 						nNewPageNo = SYSENC_MULTI_BOOT_MODE_PAGE + 1;		// Skip irrelevant pages

  03bff	e9 98 fe ff ff	 jmp	 $LN498@MainDialog
$LN475@MainDialog:

; 8200 : 				}
; 8201 : 				else if (!bHiddenVol)

  03c04	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  03c0b	75 13		 jne	 SHORT $LN479@MainDialog

; 8202 : 					nNewPageNo = (bDevice ? DEVICE_TRANSFORM_MODE_PAGE : VOLUME_LOCATION_PAGE) + 1;	

  03c0d	33 c9		 xor	 ecx, ecx
  03c0f	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?bDevice@@3HA, ecx ; bDevice
  03c15	0f 95 c1	 setne	 cl
  03c18	83 c1 0f	 add	 ecx, 15			; 0000000fH
  03c1b	e9 7c fe ff ff	 jmp	 $LN498@MainDialog
$LN479@MainDialog:

; 8203 : 				else if (bHiddenVolHost)

  03c20	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  03c27	0f 84 69 fe ff
	ff		 je	 $LN1483@MainDialog

; 8204 : 					nNewPageNo = HIDDEN_VOL_HOST_PRE_CIPHER_PAGE + 1;		// Skip the info on the hidden volume

  03c2d	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H

; 8205 : 			}

  03c32	e9 65 fe ff ff	 jmp	 $LN498@MainDialog
$LN473@MainDialog:

; 8206 : 
; 8207 : 			else if (nCurPageNo == SIZE_PAGE)

  03c37	83 f8 13	 cmp	 eax, 19			; 00000013H
  03c3a	75 15		 jne	 SHORT $LN482@MainDialog

; 8208 : 			{
; 8209 : 				VerifySizeAndUpdate (hCurPage, TRUE);

  03c3c	6a 01		 push	 1
  03c3e	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03c44	e8 00 00 00 00	 call	 _VerifySizeAndUpdate
  03c49	83 c4 08	 add	 esp, 8
  03c4c	e9 45 fe ff ff	 jmp	 $LN1483@MainDialog
$LN482@MainDialog:

; 8210 : 			}
; 8211 : 
; 8212 : 			else if (nCurPageNo == FILESYS_PAGE)

  03c51	83 f8 16	 cmp	 eax, 22			; 00000016H
  03c54	75 26		 jne	 SHORT $LN484@MainDialog

; 8213 : 			{
; 8214 : 				if (nNeedToStoreFilesOver4GB != Get2RadButtonPageAnswer())

  03c56	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  03c5b	39 05 00 00 00
	00		 cmp	 DWORD PTR ?nNeedToStoreFilesOver4GB@@3HA, eax ; nNeedToStoreFilesOver4GB
  03c61	74 0a		 je	 SHORT $LN486@MainDialog

; 8215 : 					fileSystem = FILESYS_NONE;	// The user may have gone back and changed the answer, so default file system must be reselected

  03c63	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?fileSystem@@3HC, 0 ; fileSystem
$LN486@MainDialog:

; 8216 : 	
; 8217 : 				nNeedToStoreFilesOver4GB = Get2RadButtonPageAnswer();

  03c6d	e8 00 00 00 00	 call	 ?Get2RadButtonPageAnswer@@YAHXZ ; Get2RadButtonPageAnswer
  03c72	a3 00 00 00 00	 mov	 DWORD PTR ?nNeedToStoreFilesOver4GB@@3HA, eax ; nNeedToStoreFilesOver4GB
  03c77	e9 1a fe ff ff	 jmp	 $LN1483@MainDialog
$LN484@MainDialog:

; 8218 : 			}
; 8219 : 
; 8220 : 			else if (nCurPageNo == PASSWORD_PAGE)

  03c7c	83 f8 15	 cmp	 eax, 21			; 00000015H
  03c7f	0f 85 15 01 00
	00		 jne	 $LN487@MainDialog

; 8221 : 			{
; 8222 : 				// Store the password in case we need to restore it after keyfile is applied to it
; 8223 : 				GetWindowText (GetDlgItem (hCurPage, IDC_PASSWORD), szRawPassword, sizeof (szRawPassword));

  03c85	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  03c8b	6a 41		 push	 65			; 00000041H
  03c8d	68 00 00 00 00	 push	 OFFSET ?szRawPassword@@3PADA ; szRawPassword
  03c92	68 ec 03 00 00	 push	 1004			; 000003ecH
  03c97	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03c9d	ff d6		 call	 esi
  03c9f	50		 push	 eax
  03ca0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 8224 : 
; 8225 : 				VerifyPasswordAndUpdate (hwndDlg, GetDlgItem (MainDlg, IDC_NEXT),

  03ca6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KeyFilesEnable, 0
  03cad	74 19		 je	 SHORT $LN544@MainDialog
  03caf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _FirstKeyFile, 0
  03cb6	74 10		 je	 SHORT $LN544@MainDialog
  03cb8	e8 00 00 00 00	 call	 _SysEncInEffect
  03cbd	85 c0		 test	 eax, eax
  03cbf	75 07		 jne	 SHORT $LN544@MainDialog
  03cc1	b8 01 00 00 00	 mov	 eax, 1
  03cc6	eb 02		 jmp	 SHORT $LN545@MainDialog
$LN544@MainDialog:
  03cc8	33 c0		 xor	 eax, eax
$LN545@MainDialog:
  03cca	50		 push	 eax
  03ccb	68 00 00 00 00	 push	 OFFSET ?szVerify@@3PADA	; szVerify
  03cd0	68 04 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A+4
  03cd5	68 f2 03 00 00	 push	 1010			; 000003f2H
  03cda	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03ce0	ff d6		 call	 esi
  03ce2	50		 push	 eax
  03ce3	68 ec 03 00 00	 push	 1004			; 000003ecH
  03ce8	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03cee	ff d6		 call	 esi
  03cf0	50		 push	 eax
  03cf1	68 10 04 00 00	 push	 1040			; 00000410H
  03cf6	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  03cfc	ff d6		 call	 esi
  03cfe	50		 push	 eax
  03cff	53		 push	 ebx
  03d00	e8 00 00 00 00	 call	 _VerifyPasswordAndUpdate

; 8226 : 					GetDlgItem (hCurPage, IDC_PASSWORD),
; 8227 : 					GetDlgItem (hCurPage, IDC_VERIFY),
; 8228 : 					volumePassword.Text,
; 8229 : 					szVerify,
; 8230 : 					KeyFilesEnable && FirstKeyFile!=NULL && !SysEncInEffect ());
; 8231 : 
; 8232 : 				volumePassword.Length = strlen ((char *) volumePassword.Text);

  03d05	b9 04 00 00 00	 mov	 ecx, OFFSET ?volumePassword@@3UPassword@@A+4
  03d0a	83 c4 1c	 add	 esp, 28			; 0000001cH
  03d0d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL1394@MainDialog:
  03d10	8a 01		 mov	 al, BYTE PTR [ecx]
  03d12	41		 inc	 ecx
  03d13	84 c0		 test	 al, al
  03d15	75 f9		 jne	 SHORT $LL1394@MainDialog
  03d17	2b ca		 sub	 ecx, edx
  03d19	89 0d 00 00 00
	00		 mov	 DWORD PTR ?volumePassword@@3UPassword@@A, ecx

; 8233 : 
; 8234 : 				nNewPageNo = SIZE_PAGE + 1;		// Skip the hidden volume host password page

  03d1f	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H

; 8235 : 
; 8236 : 				if (SysEncInEffect ())

  03d24	e8 00 00 00 00	 call	 _SysEncInEffect
  03d29	85 c0		 test	 eax, eax
  03d2b	74 56		 je	 SHORT $LN489@MainDialog

; 8237 : 				{
; 8238 : 					nNewPageNo = CIPHER_PAGE + 1;				// Skip irrelevant pages
; 8239 : 
; 8240 : 					KillTimer (hwndDlg, TIMER_ID_KEYB_LAYOUT_GUARD);

  03d2d	68 04 01 00 00	 push	 260			; 00000104H
  03d32	be 13 00 00 00	 mov	 esi, 19			; 00000013H
  03d37	53		 push	 ebx
  03d38	89 b5 6c 2d ff
	ff		 mov	 DWORD PTR _nNewPageNo$1$[ebp], esi
  03d3e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 8241 : 
; 8242 : 					if (bKeyboardLayoutChanged)

  03d44	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bKeyboardLayoutChanged@@3HA, 0 ; bKeyboardLayoutChanged
  03d4b	0f 84 18 02 00
	00		 je	 $LN1480@MainDialog

; 8243 : 					{
; 8244 : 						// Restore the original keyboard layout
; 8245 : 						if (LoadKeyboardLayout (OrigKeyboardLayout, KLF_ACTIVATE | KLF_SUBSTITUTE_OK) == NULL) 

  03d51	6a 03		 push	 3
  03d53	68 00 00 00 00	 push	 OFFSET ?OrigKeyboardLayout@@3PADA ; OrigKeyboardLayout
  03d58	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadKeyboardLayoutA@8
  03d5e	85 c0		 test	 eax, eax
  03d60	75 12		 jne	 SHORT $LN492@MainDialog

; 8246 : 							Warning ("CANNOT_RESTORE_KEYBOARD_LAYOUT");

  03d62	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BGCHIACG@CANNOT_RESTORE_KEYBOARD_LAYOUT?$AA@
  03d67	e8 00 00 00 00	 call	 _Warning
  03d6c	83 c4 04	 add	 esp, 4

; 8247 : 						else

  03d6f	e9 22 fd ff ff	 jmp	 $LN1483@MainDialog
$LN492@MainDialog:

; 8248 : 							bKeyboardLayoutChanged = FALSE;

  03d74	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bKeyboardLayoutChanged@@3HA, 0 ; bKeyboardLayoutChanged

; 8249 : 					}
; 8250 : 				}

  03d7e	e9 13 fd ff ff	 jmp	 $LN1483@MainDialog
$LN489@MainDialog:

; 8251 : 				else if (bInPlaceEncNonSys)

  03d83	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  03d8a	0f 84 0c fd ff
	ff		 je	 $LN498@MainDialog

; 8252 : 					nNewPageNo = CIPHER_PAGE + 1;

  03d90	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H

; 8253 : 			}
; 8254 : 
; 8255 : 			else if (nCurPageNo == HIDDEN_VOL_HOST_PASSWORD_PAGE

  03d95	e9 02 fd ff ff	 jmp	 $LN498@MainDialog
$LN487@MainDialog:

; 8256 : 				|| nCurPageNo == NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE)

  03d9a	83 f8 14	 cmp	 eax, 20			; 00000014H
  03d9d	0f 84 57 01 00
	00		 je	 $LN497@MainDialog
  03da3	83 f8 20	 cmp	 eax, 32			; 00000020H
  03da6	0f 84 4e 01 00
	00		 je	 $LN497@MainDialog

; 8265 : 					nNewPageNo = VOLUME_LOCATION_PAGE + 1;
; 8266 : 			}
; 8267 : 
; 8268 : 			else if (nCurPageNo == SYSENC_COLLECTING_RANDOM_DATA_PAGE
; 8269 : 				|| nCurPageNo == NONSYS_INPLACE_ENC_RAND_DATA_PAGE)

  03dac	83 f8 17	 cmp	 eax, 23			; 00000017H
  03daf	0f 84 ff 00 00
	00		 je	 $LN501@MainDialog
  03db5	83 f8 22	 cmp	 eax, 34			; 00000022H
  03db8	0f 84 f6 00 00
	00		 je	 $LN501@MainDialog

; 8281 : 			}
; 8282 : 
; 8283 : 			else if (nCurPageNo == SYSENC_KEYS_GEN_PAGE)

  03dbe	83 f8 18	 cmp	 eax, 24			; 00000018H
  03dc1	75 43		 jne	 SHORT $LN502@MainDialog

; 8284 : 			{
; 8285 : 				char tmp[KEY_GUI_VIEW_SIZE+1];
; 8286 : 
; 8287 : 				// Attempt to wipe the GUI fields showing portions of the master and header keys
; 8288 : 				memset (tmp, 'X', sizeof(tmp));

  03dc3	6a 41		 push	 65			; 00000041H
  03dc5	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$96[ebp]
  03dcb	6a 58		 push	 88			; 00000058H
  03dcd	50		 push	 eax
  03dce	e8 00 00 00 00	 call	 _memset

; 8289 : 				tmp [sizeof(tmp)-1] = 0;
; 8290 : 				SetWindowText (hMasterKey, tmp);

  03dd3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  03dd9	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$96[ebp]
  03ddf	83 c4 0c	 add	 esp, 12			; 0000000cH
  03de2	c6 85 d4 fe ff
	ff 00		 mov	 BYTE PTR _tmp$96[ebp+64], 0
  03de9	50		 push	 eax
  03dea	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMasterKey
  03def	50		 push	 eax
  03df0	ff d6		 call	 esi

; 8291 : 				SetWindowText (hHeaderKey, tmp);

  03df2	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$96[ebp]
  03df8	50		 push	 eax
  03df9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hHeaderKey
  03dfe	50		 push	 eax
  03dff	ff d6		 call	 esi
  03e01	e9 90 fc ff ff	 jmp	 $LN1483@MainDialog
$LN502@MainDialog:

; 8292 : 			}
; 8293 : 
; 8294 : 			else if (nCurPageNo == SYSENC_WIPE_MODE_PAGE)

  03e06	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  03e09	75 15		 jne	 SHORT $LN504@MainDialog

; 8295 : 			{
; 8296 : 				if (bDontVerifyRescueDisk)

  03e0b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDontVerifyRescueDisk@@3HA, 0 ; bDontVerifyRescueDisk
  03e12	0f 84 84 fc ff
	ff		 je	 $LN498@MainDialog

; 8297 : 					nNewPageNo = SYSENC_RESCUE_DISK_VERIFIED_PAGE;	// Skip irrelevant pages

  03e18	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]

; 8298 : 			}

  03e1b	e9 7c fc ff ff	 jmp	 $LN498@MainDialog
$LN504@MainDialog:

; 8299 : 
; 8300 : 			else if (nCurPageNo == FORMAT_PAGE)

  03e20	83 f8 26	 cmp	 eax, 38			; 00000026H
  03e23	0f 85 73 fc ff
	ff		 jne	 $LN498@MainDialog

; 8301 : 			{
; 8302 : 				char tmp[RNG_POOL_SIZE*2+1];
; 8303 : 
; 8304 : 				KillTimer (hwndDlg, TIMER_ID_RANDVIEW);

  03e29	68 ff 00 00 00	 push	 255			; 000000ffH
  03e2e	53		 push	 ebx
  03e2f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 8305 : 
; 8306 : 				// Attempt to wipe the GUI fields showing portions of randpool, of the master and header keys
; 8307 : 				memset (tmp, 'X', sizeof(tmp));

  03e35	68 81 02 00 00	 push	 641			; 00000281H
  03e3a	8d 85 14 f6 ff
	ff		 lea	 eax, DWORD PTR _tmp$90[ebp]
  03e40	6a 58		 push	 88			; 00000058H
  03e42	50		 push	 eax
  03e43	e8 00 00 00 00	 call	 _memset

; 8308 : 				tmp [sizeof(tmp)-1] = 0;
; 8309 : 				SetWindowText (hRandPool, tmp);

  03e48	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  03e4e	8d 85 14 f6 ff
	ff		 lea	 eax, DWORD PTR _tmp$90[ebp]
  03e54	83 c4 0c	 add	 esp, 12			; 0000000cH
  03e57	c6 85 94 f8 ff
	ff 00		 mov	 BYTE PTR _tmp$90[ebp+640], 0
  03e5e	50		 push	 eax
  03e5f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hRandPool@@3RAUHWND__@@A ; hRandPool
  03e64	50		 push	 eax
  03e65	ff d6		 call	 esi

; 8310 : 				SetWindowText (hMasterKey, tmp);

  03e67	8d 85 14 f6 ff
	ff		 lea	 eax, DWORD PTR _tmp$90[ebp]
  03e6d	50		 push	 eax
  03e6e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMasterKey
  03e73	50		 push	 eax
  03e74	ff d6		 call	 esi

; 8311 : 				SetWindowText (hHeaderKey, tmp);

  03e76	8d 85 14 f6 ff
	ff		 lea	 eax, DWORD PTR _tmp$90[ebp]
  03e7c	50		 push	 eax
  03e7d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hHeaderKey
  03e82	50		 push	 eax
  03e83	ff d6		 call	 esi

; 8312 : 
; 8313 : 				if (WizardMode != WIZARD_MODE_SYS_DEVICE)

  03e85	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  03e8c	0f 84 04 fc ff
	ff		 je	 $LN1483@MainDialog

; 8314 : 				{
; 8315 : 					// Skip irrelevant pages
; 8316 : 
; 8317 : 					if (FileSize4GBLimitQuestionNeeded ()
; 8318 : 						&& !CreatingHiddenSysVol()		// If we're creating a hidden volume for a hidden OS, we don't need to format it with any filesystem (the entire OS will be copied to the hidden volume sector by sector).
; 8319 : 						&& !bInPlaceEncNonSys)

  03e92	e8 00 00 00 00	 call	 ?FileSize4GBLimitQuestionNeeded@@YAHXZ ; FileSize4GBLimitQuestionNeeded
  03e97	85 c0		 test	 eax, eax
  03e99	74 55		 je	 SHORT $LN509@MainDialog
  03e9b	e8 00 00 00 00	 call	 _CreatingHiddenSysVol
  03ea0	85 c0		 test	 eax, eax
  03ea2	75 4c		 jne	 SHORT $LN509@MainDialog
  03ea4	39 05 00 00 00
	00		 cmp	 DWORD PTR _bInPlaceEncNonSys, eax
  03eaa	75 44		 jne	 SHORT $LN509@MainDialog

; 8320 : 					{
; 8321 : 						nNewPageNo = FILESYS_PAGE + 1;

  03eac	8d 48 17	 lea	 ecx, DWORD PTR [eax+23]

; 8322 : 					}
; 8323 : 					else

  03eaf	e9 e8 fb ff ff	 jmp	 $LN498@MainDialog
$LN501@MainDialog:

; 8270 : 			{
; 8271 : 				char tmp[RANDPOOL_DISPLAY_SIZE+1];
; 8272 : 
; 8273 : 				KillTimer (hwndDlg, TIMER_ID_RANDVIEW);

  03eb4	68 ff 00 00 00	 push	 255			; 000000ffH
  03eb9	53		 push	 ebx
  03eba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 8274 : 
; 8275 : 				// Attempt to wipe the GUI field showing portions of randpool
; 8276 : 				memset (tmp, 'X', sizeof(tmp));

  03ec0	68 73 01 00 00	 push	 371			; 00000173H
  03ec5	8d 85 94 fc ff
	ff		 lea	 eax, DWORD PTR _tmp$93[ebp]
  03ecb	6a 58		 push	 88			; 00000058H
  03ecd	50		 push	 eax
  03ece	e8 00 00 00 00	 call	 _memset
  03ed3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8277 : 				tmp [sizeof(tmp)-1] = 0;

  03ed6	c6 85 06 fe ff
	ff 00		 mov	 BYTE PTR _tmp$93[ebp+370], 0

; 8278 : 				SetWindowText (hRandPoolSys, tmp);

  03edd	8d 85 94 fc ff
	ff		 lea	 eax, DWORD PTR _tmp$93[ebp]
  03ee3	50		 push	 eax
  03ee4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hRandPoolSys@@3RAUHWND__@@A ; hRandPoolSys
  03ee9	50		 push	 eax
  03eea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN509@MainDialog:

; 8279 : 
; 8280 : 				nNewPageNo = PASSWORD_PAGE + 1;		// Skip irrelevant pages

  03ef0	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  03ef5	e9 a2 fb ff ff	 jmp	 $LN498@MainDialog
$LN497@MainDialog:

; 8257 : 			{
; 8258 : 				// Store the password in case we need to restore it after keyfile is applied to it
; 8259 : 				GetWindowText (GetDlgItem (hCurPage, IDC_PASSWORD_DIRECT), szRawPassword, sizeof (szRawPassword));

  03efa	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  03f00	6a 41		 push	 65			; 00000041H
  03f02	68 00 00 00 00	 push	 OFFSET ?szRawPassword@@3PADA ; szRawPassword
  03f07	68 0d 04 00 00	 push	 1037			; 0000040dH
  03f0c	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03f12	ff d7		 call	 edi
  03f14	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetWindowTextA@12
  03f1a	50		 push	 eax
  03f1b	ff d6		 call	 esi

; 8260 : 
; 8261 : 				GetWindowText (GetDlgItem (hCurPage, IDC_PASSWORD_DIRECT), (char *) volumePassword.Text, sizeof (volumePassword.Text));

  03f1d	6a 41		 push	 65			; 00000041H
  03f1f	68 04 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A+4
  03f24	68 0d 04 00 00	 push	 1037			; 0000040dH
  03f29	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03f2f	ff d7		 call	 edi
  03f31	50		 push	 eax
  03f32	ff d6		 call	 esi

; 8262 : 				volumePassword.Length = strlen ((char *) volumePassword.Text);

  03f34	b9 04 00 00 00	 mov	 ecx, OFFSET ?volumePassword@@3UPassword@@A+4
  03f39	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  03f3c	0f 1f 40 00	 npad	 4
$LL1395@MainDialog:
  03f40	8a 01		 mov	 al, BYTE PTR [ecx]
  03f42	41		 inc	 ecx
  03f43	84 c0		 test	 al, al
  03f45	75 f9		 jne	 SHORT $LL1395@MainDialog

; 8263 : 
; 8264 : 				if (!bInPlaceEncNonSys)

  03f47	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  03f4c	2b ca		 sub	 ecx, edx
  03f4e	89 0d 00 00 00
	00		 mov	 DWORD PTR ?volumePassword@@3UPassword@@A, ecx
  03f54	85 c0		 test	 eax, eax
  03f56	8b 8d 6c 2d ff
	ff		 mov	 ecx, DWORD PTR _nNewPageNo$1$[ebp]
  03f5c	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  03f61	0f 44 ca	 cmove	 ecx, edx
  03f64	e9 33 fb ff ff	 jmp	 $LN498@MainDialog
$LN1480@MainDialog:
  03f69	8b ce		 mov	 ecx, esi
  03f6b	e9 2c fb ff ff	 jmp	 $LN498@MainDialog
$LN115@MainDialog:

; 6472 : 
; 6473 : 	case GST_APPMSG_VOL_TRANSFORM_THREAD_ENDED:
; 6474 : 
; 6475 : 		if (bInPlaceEncNonSys)

  03f70	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  03f77	74 20		 je	 SHORT $LN116@MainDialog

; 6476 : 		{
; 6477 : 			// In-place encryption was interrupted/paused (did not finish)
; 6478 : 
; 6479 : 			KillTimer (hwndDlg, TIMER_ID_NONSYS_INPLACE_ENC_PROGRESS);

  03f79	68 01 01 00 00	 push	 257			; 00000101H
  03f7e	53		 push	 ebx
  03f7f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 6480 : 
; 6481 : 			UpdateNonSysInPlaceEncControls ();

  03f85	e8 00 00 00 00	 call	 _UpdateNonSysInPlaceEncControls

; 6497 : 		}
; 6498 : 
; 6499 : 		NormalCursor ();

  03f8a	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_61$1579:

; 6074 : 			}
; 6075 : 			return 1;

  03f8f	b8 01 00 00 00	 mov	 eax, 1
  03f94	e9 16 c1 ff ff	 jmp	 $LN1@MainDialog
$LN116@MainDialog:

; 6482 : 		}
; 6483 : 		else
; 6484 : 		{
; 6485 : 			// Format has been aborted (did not finish)
; 6486 : 
; 6487 : 			EnableWindow (GetDlgItem (hCurPage, IDC_QUICKFORMAT), (bDevice || bSparseFileSwitch) && !(bHiddenVol && !bHiddenVolHost));

  03f99	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  03fa0	75 09		 jne	 SHORT $LN522@MainDialog
  03fa2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bSparseFileSwitch@@3HC, 0 ; bSparseFileSwitch
  03fa9	74 12		 je	 SHORT $LN524@MainDialog
$LN522@MainDialog:
  03fab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  03fb2	74 0d		 je	 SHORT $LN523@MainDialog
  03fb4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  03fbb	75 04		 jne	 SHORT $LN523@MainDialog
$LN524@MainDialog:
  03fbd	33 c0		 xor	 eax, eax
  03fbf	eb 05		 jmp	 SHORT $LN525@MainDialog
$LN523@MainDialog:
  03fc1	b8 01 00 00 00	 mov	 eax, 1
$LN525@MainDialog:
  03fc6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  03fcc	50		 push	 eax
  03fcd	68 ff 03 00 00	 push	 1023			; 000003ffH
  03fd2	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03fd8	ff d7		 call	 edi
  03fda	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  03fe0	50		 push	 eax
  03fe1	ff d6		 call	 esi

; 6488 : 			EnableWindow (GetDlgItem (hCurPage, IDC_FILESYS), TRUE);

  03fe3	6a 01		 push	 1
  03fe5	68 05 04 00 00	 push	 1029			; 00000405H
  03fea	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03ff0	ff d7		 call	 edi
  03ff2	50		 push	 eax
  03ff3	ff d6		 call	 esi

; 6489 : 			EnableWindow (GetDlgItem (hCurPage, IDC_CLUSTERSIZE), TRUE);

  03ff5	6a 01		 push	 1
  03ff7	68 04 04 00 00	 push	 1028			; 00000404H
  03ffc	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  04002	ff d7		 call	 edi
  04004	50		 push	 eax
  04005	ff d6		 call	 esi

; 6490 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_PREV), TRUE);

  04007	6a 01		 push	 1
  04009	68 11 04 00 00	 push	 1041			; 00000411H
  0400e	53		 push	 ebx
  0400f	ff d7		 call	 edi
  04011	50		 push	 eax
  04012	ff d6		 call	 esi

; 6491 : 			EnableWindow (GetDlgItem (hwndDlg, IDHELP), TRUE);

  04014	6a 01		 push	 1
  04016	6a 09		 push	 9
  04018	53		 push	 ebx
  04019	ff d7		 call	 edi
  0401b	50		 push	 eax
  0401c	ff d6		 call	 esi

; 6492 : 			EnableWindow (GetDlgItem (hwndDlg, IDCANCEL), TRUE);

  0401e	6a 01		 push	 1
  04020	6a 02		 push	 2
  04022	53		 push	 ebx
  04023	ff d7		 call	 edi
  04025	50		 push	 eax
  04026	ff d6		 call	 esi

; 6493 : 			EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), FALSE);

  04028	6a 00		 push	 0
  0402a	68 f8 03 00 00	 push	 1016			; 000003f8H
  0402f	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  04035	ff d7		 call	 edi
  04037	50		 push	 eax
  04038	ff d6		 call	 esi

; 6494 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_NEXT), TRUE);

  0403a	6a 01		 push	 1
  0403c	68 10 04 00 00	 push	 1040			; 00000410H
  04041	53		 push	 ebx
  04042	ff d7		 call	 edi
  04044	50		 push	 eax
  04045	ff d6		 call	 esi

; 6495 : 			SendMessage (GetDlgItem (hCurPage, IDC_PROGRESS_BAR), PBM_SETPOS, 0, 0L);

  04047	6a 00		 push	 0
  04049	6a 00		 push	 0
  0404b	68 02 04 00 00	 push	 1026			; 00000402H
  04050	68 f6 03 00 00	 push	 1014			; 000003f6H
  04055	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0405b	ff d7		 call	 edi
  0405d	50		 push	 eax
  0405e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 6496 : 			SetFocus (GetDlgItem (hwndDlg, IDC_NEXT));

  04064	68 10 04 00 00	 push	 1040			; 00000410H
  04069	53		 push	 ebx
  0406a	ff d7		 call	 edi
  0406c	50		 push	 eax
  0406d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 6497 : 		}
; 6498 : 
; 6499 : 		NormalCursor ();

  04073	e8 00 00 00 00	 call	 _NormalCursor
$ovf_end_62$1580:

; 6074 : 			}
; 6075 : 			return 1;

  04078	b8 01 00 00 00	 mov	 eax, 1
  0407d	e9 2d c0 ff ff	 jmp	 $LN1@MainDialog
$LN553@MainDialog:

; 5946 : 	WORD lw = LOWORD (wParam);
; 5947 : 
; 5948 : 	int nNewPageNo = nCurPageNo;
; 5949 : 
; 5950 : 	switch (uMsg)

  04082	81 c2 d2 7e ff
	ff		 add	 edx, -33070		; ffff7ed2H
  04088	83 fa 04	 cmp	 edx, 4
  0408b	0f 87 1c c0 ff
	ff		 ja	 $LN2@MainDialog
  04091	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN1513@MainDialog[edx*4]
$LN111@MainDialog:

; 6417 : 						}
; 6418 : 					}
; 6419 : 				}
; 6420 : 			}
; 6421 : 			else
; 6422 : 			{
; 6423 : 				// Regular device wipe (not decoy system partition wipe)
; 6424 : 
; 6425 : 				//Info ("WIPE_FINISHED");
; 6426 : 			}
; 6427 : 			return 1;
; 6428 : 		}
; 6429 : 
; 6430 : 		return 0;
; 6431 : 
; 6432 : 
; 6433 : 	case GST_APPMSG_PERFORM_POST_WMINIT_TASKS:
; 6434 : 
; 6435 : 		AfterWMInitTasks (hwndDlg);

  04098	53		 push	 ebx
  04099	e8 00 00 00 00	 call	 _AfterWMInitTasks
  0409e	83 c4 04	 add	 esp, 4

; 6436 : 		return 1;

  040a1	b8 01 00 00 00	 mov	 eax, 1
  040a6	e9 04 c0 ff ff	 jmp	 $LN1@MainDialog
$LN112@MainDialog:

; 6437 : 
; 6438 : 	case GST_APPMSG_FORMAT_FINISHED:
; 6439 : 		{
; 6440 : 			char tmp[RNG_POOL_SIZE*2+1];
; 6441 : 
; 6442 : 			EnableWindow (GetDlgItem (hCurPage, IDC_ABORT_BUTTON), FALSE);

  040ab	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  040b1	6a 00		 push	 0
  040b3	68 f8 03 00 00	 push	 1016			; 000003f8H
  040b8	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  040be	ff d7		 call	 edi
  040c0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  040c6	50		 push	 eax
  040c7	ff d6		 call	 esi

; 6443 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_PREV), TRUE);

  040c9	6a 01		 push	 1
  040cb	68 11 04 00 00	 push	 1041			; 00000411H
  040d0	53		 push	 ebx
  040d1	ff d7		 call	 edi
  040d3	50		 push	 eax
  040d4	ff d6		 call	 esi

; 6444 : 			EnableWindow (GetDlgItem (hwndDlg, IDHELP), TRUE);

  040d6	6a 01		 push	 1
  040d8	6a 09		 push	 9
  040da	53		 push	 ebx
  040db	ff d7		 call	 edi
  040dd	50		 push	 eax
  040de	ff d6		 call	 esi

; 6445 : 			EnableWindow (GetDlgItem (hwndDlg, IDCANCEL), TRUE);

  040e0	6a 01		 push	 1
  040e2	6a 02		 push	 2
  040e4	53		 push	 ebx
  040e5	ff d7		 call	 edi
  040e7	50		 push	 eax
  040e8	ff d6		 call	 esi

; 6446 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_NEXT), TRUE);

  040ea	6a 01		 push	 1
  040ec	68 10 04 00 00	 push	 1040			; 00000410H
  040f1	53		 push	 ebx
  040f2	ff d7		 call	 edi
  040f4	50		 push	 eax
  040f5	ff d6		 call	 esi

; 6447 : 			SetFocus (GetDlgItem (hwndDlg, IDC_NEXT));

  040f7	68 10 04 00 00	 push	 1040			; 00000410H
  040fc	53		 push	 ebx
  040fd	ff d7		 call	 edi
  040ff	50		 push	 eax
  04100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 6448 : 
; 6449 : 			if (nCurPageNo == FORMAT_PAGE)

  04106	83 3d 00 00 00
	00 26		 cmp	 DWORD PTR ?nCurPageNo@@3HA, 38 ; nCurPageNo, 00000026H
  0410d	75 0c		 jne	 SHORT $LN113@MainDialog

; 6450 : 				KillTimer (hwndDlg, TIMER_ID_RANDVIEW);

  0410f	68 ff 00 00 00	 push	 255			; 000000ffH
  04114	53		 push	 ebx
  04115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8
$LN113@MainDialog:

; 6451 : 
; 6452 : 			// Attempt to wipe the GUI fields showing portions of randpool, of the master and header keys
; 6453 : 			memset (tmp, 'X', sizeof(tmp));

  0411b	68 81 02 00 00	 push	 641			; 00000281H
  04120	8d 85 98 f8 ff
	ff		 lea	 eax, DWORD PTR _tmp$91[ebp]
  04126	6a 58		 push	 88			; 00000058H
  04128	50		 push	 eax
  04129	e8 00 00 00 00	 call	 _memset

; 6454 : 			tmp [sizeof(tmp)-1] = 0;
; 6455 : 			SetWindowText (hRandPool, tmp);

  0412e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  04134	8d 85 98 f8 ff
	ff		 lea	 eax, DWORD PTR _tmp$91[ebp]
  0413a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0413d	c6 85 18 fb ff
	ff 00		 mov	 BYTE PTR _tmp$91[ebp+640], 0
  04144	50		 push	 eax
  04145	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hRandPool@@3RAUHWND__@@A ; hRandPool
  0414a	50		 push	 eax
  0414b	ff d6		 call	 esi

; 6456 : 			SetWindowText (hMasterKey, tmp);

  0414d	8d 85 98 f8 ff
	ff		 lea	 eax, DWORD PTR _tmp$91[ebp]
  04153	50		 push	 eax
  04154	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMasterKey
  04159	50		 push	 eax
  0415a	ff d6		 call	 esi

; 6457 : 			SetWindowText (hHeaderKey, tmp);

  0415c	8d 85 98 f8 ff
	ff		 lea	 eax, DWORD PTR _tmp$91[ebp]
  04162	50		 push	 eax
  04163	a1 00 00 00 00	 mov	 eax, DWORD PTR _hHeaderKey
  04168	50		 push	 eax
  04169	ff d6		 call	 esi

; 6458 : 
; 6459 : 			LoadPage (hwndDlg, FORMAT_FINISHED_PAGE);

  0416b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  04170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  04176	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  0417c	85 c0		 test	 eax, eax
  0417e	74 5d		 je	 SHORT $LN787@MainDialog
  04180	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  0418a	83 f9 15	 cmp	 ecx, 21			; 00000015H
  0418d	75 3d		 jne	 SHORT $LN781@MainDialog
  0418f	6a 40		 push	 64			; 00000040H
  04191	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$97[ebp]
  04197	6a 58		 push	 88			; 00000058H
  04199	50		 push	 eax
  0419a	e8 00 00 00 00	 call	 _memset
  0419f	83 c4 0c	 add	 esp, 12			; 0000000cH
  041a2	c6 85 18 ff ff
	ff 00		 mov	 BYTE PTR _tmp$97[ebp+64], 0
  041a9	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$97[ebp]
  041af	50		 push	 eax
  041b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  041b5	50		 push	 eax
  041b6	ff d6		 call	 esi
  041b8	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$97[ebp]
  041be	50		 push	 eax
  041bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  041c4	50		 push	 eax
  041c5	ff d6		 call	 esi
  041c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN781@MainDialog:
  041cc	50		 push	 eax
  041cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  041d3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN787@MainDialog:
  041dd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  041e7	e8 00 00 00 00	 call	 _NormalCursor
  041ec	8d 85 38 35 ff
	ff		 lea	 eax, DWORD PTR _rW$78[ebp]
  041f2	50		 push	 eax
  041f3	68 23 04 00 00	 push	 1059			; 00000423H
  041f8	53		 push	 ebx
  041f9	ff d7		 call	 edi
  041fb	50		 push	 eax
  041fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  04202	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  04209	c7 05 00 00 00
	00 27 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 39 ; nCurPageNo, 00000027H
  04213	74 17		 je	 SHORT $LN836@MainDialog
  04215	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  0421c	75 0e		 jne	 SHORT $LN836@MainDialog
  0421e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVolFinished@@3HC, 0 ; bHiddenVolFinished
  04225	b8 6d 00 00 00	 mov	 eax, 109		; 0000006dH
  0422a	74 05		 je	 SHORT $LN837@MainDialog
$LN836@MainDialog:
  0422c	b8 6c 00 00 00	 mov	 eax, 108		; 0000006cH
$LN837@MainDialog:
  04231	6a 00		 push	 0
  04233	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  04238	53		 push	 ebx
  04239	0f b7 c0	 movzx	 eax, ax
  0423c	50		 push	 eax
  0423d	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  04243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  04249	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  04250	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  04255	8d 85 08 35 ff
	ff		 lea	 eax, DWORD PTR _rD$75[ebp]
  0425b	50		 push	 eax
  0425c	53		 push	 ebx
  0425d	0f 11 85 08 35
	ff ff		 movups	 XMMWORD PTR _rD$75[ebp], xmm0
  04264	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  0426a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  04270	85 c9		 test	 ecx, ecx
  04272	0f 84 cf c1 ff
	ff		 je	 $LN15@MainDialog
  04278	8b 85 44 35 ff
	ff		 mov	 eax, DWORD PTR _rW$78[ebp+12]
  0427e	2b 85 3c 35 ff
	ff		 sub	 eax, DWORD PTR _rW$78[ebp+4]
  04284	6a 01		 push	 1
  04286	50		 push	 eax
  04287	8b 85 40 35 ff
	ff		 mov	 eax, DWORD PTR _rW$78[ebp+8]
  0428d	2b 85 38 35 ff
	ff		 sub	 eax, DWORD PTR _rW$78[ebp]
  04293	50		 push	 eax
  04294	ff b5 0c 35 ff
	ff		 push	 DWORD PTR _rD$75[ebp+4]
  0429a	ff b5 08 35 ff
	ff		 push	 DWORD PTR _rD$75[ebp]

; 6460 : 		}
; 6461 : 		return 1;

  042a0	e9 f2 c9 ff ff	 jmp	 $LN1501@MainDialog
$LN114@MainDialog:

; 6462 : 
; 6463 : 	case GST_APPMSG_NONSYS_INPLACE_ENC_FINISHED:
; 6464 : 
; 6465 : 		// A partition has just been fully encrypted in place
; 6466 : 
; 6467 : 		KillTimer (hwndDlg, TIMER_ID_NONSYS_INPLACE_ENC_PROGRESS);

  042a5	68 01 01 00 00	 push	 257			; 00000101H
  042aa	53		 push	 ebx
  042ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 6468 : 
; 6469 : 		LoadPage (hwndDlg, NONSYS_INPLACE_ENC_ENCRYPTION_FINISHED_PAGE);

  042b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  042b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  042bc	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  042c2	85 c0		 test	 eax, eax
  042c4	74 63		 je	 SHORT $LN853@MainDialog
  042c6	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo
  042d0	83 f9 15	 cmp	 ecx, 21			; 00000015H
  042d3	75 43		 jne	 SHORT $LN847@MainDialog
  042d5	6a 40		 push	 64			; 00000040H
  042d7	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _tmp$98[ebp]
  042dd	6a 58		 push	 88			; 00000058H
  042df	50		 push	 eax
  042e0	e8 00 00 00 00	 call	 _memset
  042e5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  042eb	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _tmp$98[ebp]
  042f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  042f4	c6 85 5c ff ff
	ff 00		 mov	 BYTE PTR _tmp$98[ebp+64], 0
  042fb	50		 push	 eax
  042fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  04301	50		 push	 eax
  04302	ff d6		 call	 esi
  04304	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _tmp$98[ebp]
  0430a	50		 push	 eax
  0430b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  04310	50		 push	 eax
  04311	ff d6		 call	 esi
  04313	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN847@MainDialog:
  04318	50		 push	 eax
  04319	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  0431f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN853@MainDialog:
  04329	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0
  04333	e8 00 00 00 00	 call	 _NormalCursor
  04338	8d 85 28 35 ff
	ff		 lea	 eax, DWORD PTR _rW$77[ebp]
  0433e	50		 push	 eax
  0433f	68 23 04 00 00	 push	 1059			; 00000423H
  04344	53		 push	 ebx
  04345	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0434b	50		 push	 eax
  0434c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  04352	6a 00		 push	 0
  04354	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  04359	53		 push	 ebx
  0435a	6a 6c		 push	 108			; 0000006cH
  0435c	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  04362	c7 05 00 00 00
	00 25 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 37 ; nCurPageNo, 00000025H
  0436c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  04372	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  04379	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  0437e	8d 85 f8 34 ff
	ff		 lea	 eax, DWORD PTR _rD$74[ebp]
  04384	50		 push	 eax
  04385	53		 push	 ebx
  04386	0f 11 85 f8 34
	ff ff		 movups	 XMMWORD PTR _rD$74[ebp], xmm0
  0438d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  04393	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  04399	85 c9		 test	 ecx, ecx
  0439b	0f 84 a6 c0 ff
	ff		 je	 $LN15@MainDialog
  043a1	8b 85 34 35 ff
	ff		 mov	 eax, DWORD PTR _rW$77[ebp+12]
  043a7	2b 85 2c 35 ff
	ff		 sub	 eax, DWORD PTR _rW$77[ebp+4]
  043ad	6a 01		 push	 1
  043af	50		 push	 eax
  043b0	8b 85 30 35 ff
	ff		 mov	 eax, DWORD PTR _rW$77[ebp+8]
  043b6	2b 85 28 35 ff
	ff		 sub	 eax, DWORD PTR _rW$77[ebp]
  043bc	50		 push	 eax
  043bd	ff b5 fc 34 ff
	ff		 push	 DWORD PTR _rD$74[ebp+4]
  043c3	ff b5 f8 34 ff
	ff		 push	 DWORD PTR _rD$74[ebp]

; 6470 : 
; 6471 : 		return 1;

  043c9	e9 c9 c8 ff ff	 jmp	 $LN1501@MainDialog
$LN119@MainDialog:

; 6505 : 		return 1;
; 6506 : 
; 6507 : 	case GST_APPMSG_FORMAT_USER_QUIT:
; 6508 : 
; 6509 : 		if (nCurPageNo == NONSYS_INPLACE_ENC_ENCRYPTION_PAGE
; 6510 : 			&& (bVolTransformThreadRunning || bVolTransformThreadToRun || bInPlaceEncNonSysResumed))

  043ce	83 f8 24	 cmp	 eax, 36			; 00000024H
  043d1	75 49		 jne	 SHORT $LN120@MainDialog
  043d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  043da	75 12		 jne	 SHORT $LN122@MainDialog
  043dc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  043e3	75 09		 jne	 SHORT $LN122@MainDialog
  043e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSysResumed, 0
  043ec	74 2e		 je	 SHORT $LN120@MainDialog
$LN122@MainDialog:

; 6511 : 		{
; 6512 : 			// Non-system encryption in progress
; 6513 : 			if (AskNoYes ("NONSYS_INPLACE_ENC_DEFER_CONFIRM") == IDYES)

  043ee	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MEPMKNNG@NONSYS_INPLACE_ENC_DEFER_CONFIRM@
  043f3	e8 00 00 00 00	 call	 _AskNoYes
  043f8	83 c4 04	 add	 esp, 4
  043fb	83 f8 06	 cmp	 eax, 6
  043fe	0f 85 43 c0 ff
	ff		 jne	 $LN15@MainDialog

; 6514 : 			{
; 6515 : 				NonSysInplaceEncPause ();

  04404	e8 00 00 00 00	 call	 _NonSysInplaceEncPause

; 6516 : 
; 6517 : 				EndMainDlg (hwndDlg);

  04409	53		 push	 ebx
  0440a	e8 00 00 00 00	 call	 _EndMainDlg
  0440f	83 c4 04	 add	 esp, 4
$ovf_end_63$1581:

; 6074 : 			}
; 6075 : 			return 1;

  04412	b8 01 00 00 00	 mov	 eax, 1
  04417	e9 93 bc ff ff	 jmp	 $LN1@MainDialog
$LN120@MainDialog:

; 6518 : 				return 1;
; 6519 : 			}
; 6520 : 			else
; 6521 : 				return 1;	// Disallow close
; 6522 : 		}
; 6523 : 		else if (bVolTransformThreadRunning || bVolTransformThreadToRun)

  0441c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  04423	0f 85 a2 01 00
	00		 jne	 $LN127@MainDialog
  04429	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  04430	0f 85 95 01 00
	00		 jne	 $LN127@MainDialog

; 6531 : 				return 1;
; 6532 : 			}
; 6533 : 			else
; 6534 : 				return 1;	// Disallow close
; 6535 : 		}
; 6536 : 		else if ((nCurPageNo == SYSENC_ENCRYPTION_PAGE || nCurPageNo == SYSENC_PRETEST_RESULT_PAGE)
; 6537 : 			&& SystemEncryptionStatus != SYSENC_STATUS_NONE
; 6538 : 			&& InstanceHasSysEncMutex ())

  04436	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  0443b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0443e	74 09		 je	 SHORT $LN132@MainDialog
  04440	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  04443	0f 85 0e 01 00
	00		 jne	 $LN130@MainDialog
$LN132@MainDialog:
  04449	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionStatus, 0
  04450	0f 84 01 01 00
	00		 je	 $LN130@MainDialog
  04456	e8 00 00 00 00	 call	 _InstanceHasSysEncMutex
  0445b	85 c0		 test	 eax, eax
  0445d	0f 84 f4 00 00
	00		 je	 $LN130@MainDialog

; 6539 : 		{
; 6540 : 			// System encryption/decryption in progress
; 6541 : 
; 6542 : 			if (AskYesNo (SystemEncryptionStatus == SYSENC_STATUS_DECRYPTING ? 
; 6543 : 				"SYSTEM_DECRYPTION_DEFER_CONFIRM" : "SYSTEM_ENCRYPTION_DEFER_CONFIRM") == IDYES)

  04463	81 3d 00 00 00
	00 58 02 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 600 ; 00000258H
  0446d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CA@OMHIMMHH@SYSTEM_ENCRYPTION_DEFER_CONFIRM?$AA@
  04472	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CA@MDOAMJOP@SYSTEM_DECRYPTION_DEFER_CONFIRM?$AA@
  04477	0f 45 c1	 cmovne	 eax, ecx
  0447a	50		 push	 eax
  0447b	e8 00 00 00 00	 call	 _AskYesNo
  04480	83 c4 04	 add	 esp, 4
  04483	83 f8 06	 cmp	 eax, 6
  04486	0f 85 bb bf ff
	ff		 jne	 $LN15@MainDialog

; 6544 : 			{
; 6545 : 				if (nCurPageNo == SYSENC_PRETEST_RESULT_PAGE)

  0448c	83 3d 00 00 00
	00 1e		 cmp	 DWORD PTR ?nCurPageNo@@3HA, 30 ; nCurPageNo, 0000001eH
  04493	75 0a		 jne	 SHORT $LN135@MainDialog

; 6546 : 					TextInfoDialogBox (GST_TBXID_SYS_ENC_RESCUE_DISK);

  04495	6a 02		 push	 2
  04497	e8 00 00 00 00	 call	 _TextInfoDialogBox
  0449c	83 c4 04	 add	 esp, 4
$LN135@MainDialog:

; 6547 : 
; 6548 : 				try
; 6549 : 				{
; 6550 : 					BootEncStatus = BootEncObj->GetStatus();

  0449f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  044a5	8d 85 10 31 ff
	ff		 lea	 eax, DWORD PTR $T38[ebp]
  044ab	50		 push	 eax
  044ac	c7 45 fc 14 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 20 ; 00000014H
  044b3	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  044b8	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  044bd	8b f0		 mov	 esi, eax
  044bf	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  044c4	f3 a5		 rep movsd
  044c6	66 a5		 movsw

; 6551 : 
; 6552 : 					if (BootEncStatus.SetupInProgress)

  044c8	83 3d 3e 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+62, 0
  044cf	74 58		 je	 SHORT $LN1334@MainDialog

; 6553 : 					{
; 6554 : 						BootEncObj->AbortSetupWait ();

  044d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  044d7	e8 00 00 00 00	 call	 ?AbortSetupWait@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::AbortSetupWait

; 6555 : 						Sleep (200);

  044dc	68 c8 00 00 00	 push	 200			; 000000c8H
  044e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 6556 : 						BootEncStatus = BootEncObj->GetStatus();

  044e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  044ed	8d 85 f0 2f ff
	ff		 lea	 eax, DWORD PTR $T35[ebp]
  044f3	50		 push	 eax
  044f4	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  044f9	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  044fe	8b f0		 mov	 esi, eax
  04500	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  04505	f3 a5		 rep movsd
  04507	66 a5		 movsw

; 6557 : 					}
; 6558 : 
; 6559 : 					if (!BootEncStatus.SetupInProgress)

  04509	83 3d 3e 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+62, 0
  04510	74 17		 je	 SHORT $LN1334@MainDialog

; 6562 : 						return 1;
; 6563 : 					}
; 6564 : 					else
; 6565 : 					{
; 6566 : 						Error ("FAILED_TO_INTERRUPT_SYSTEM_ENCRYPTION");

  04512	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OIGJDCBH@FAILED_TO_INTERRUPT_SYSTEM_ENCRY@
  04517	e8 00 00 00 00	 call	 _Error
  0451c	83 c4 04	 add	 esp, 4
$ovf_end_64$1582:

; 6074 : 			}
; 6075 : 			return 1;

  0451f	b8 01 00 00 00	 mov	 eax, 1
  04524	e9 86 bb ff ff	 jmp	 $LN1@MainDialog
$LN1334@MainDialog:

; 6560 : 					{
; 6561 : 						EndMainDlg (MainDlg);

  04529	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0452f	e8 00 00 00 00	 call	 _EndMainDlg
  04534	83 c4 04	 add	 esp, 4
$ovf_end_65$1583:

; 6074 : 			}
; 6075 : 			return 1;

  04537	b8 01 00 00 00	 mov	 eax, 1
  0453c	e9 6e bb ff ff	 jmp	 $LN1@MainDialog
__catch$_MainDialogProc@16$19:

; 6567 : 						return 1;	// Disallow close
; 6568 : 					}
; 6569 : 				}
; 6570 : 				catch (Exception &e)
; 6571 : 				{
; 6572 : 					e.Show (hwndDlg);

  04541	8b 8d 0c 2d ff
	ff		 mov	 ecx, DWORD PTR _e$18[ebp]
  04547	ff b5 68 2d ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  0454d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0454f	ff 10		 call	 DWORD PTR [eax]

; 6573 : 				}

  04551	b8 00 00 00 00	 mov	 eax, $LN15@MainDialog
  04556	c3		 ret	 0
$LN130@MainDialog:

; 6574 : 				return 1;	// Disallow close
; 6575 : 			}
; 6576 : 			else
; 6577 : 				return 1;	// Disallow close
; 6578 : 		}
; 6579 : 		else if (bConfirmQuitSysEncPretest)

  04557	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bConfirmQuitSysEncPretest@@3HC, 0 ; bConfirmQuitSysEncPretest
  0455e	74 17		 je	 SHORT $LN140@MainDialog

; 6580 : 		{
; 6581 : 			if (AskWarnNoYes (bHiddenOS ? "CONFIRM_CANCEL_HIDDEN_OS_CREATION" : "CONFIRM_CANCEL_SYS_ENC_PRETEST") == IDNO)

  04560	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenOS@@3HC ; bHiddenOS
  04565	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CC@KDAJHHMG@CONFIRM_CANCEL_HIDDEN_OS_CREATIO@
  0456a	85 c0		 test	 eax, eax
  0456c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@IFOLEKLB@CONFIRM_CANCEL_SYS_ENC_PRETEST?$AA@
  04571	0f 44 ca	 cmove	 ecx, edx
  04574	51		 push	 ecx

; 6582 : 				return 1;	// Disallow close

  04575	eb 0e		 jmp	 SHORT $LN1503@MainDialog
$LN140@MainDialog:

; 6583 : 		}
; 6584 : 		else if (bConfirmQuit)

  04577	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bConfirmQuit@@3HC, 0 ; bConfirmQuit
  0457e	74 16		 je	 SHORT $LN144@MainDialog

; 6585 : 		{
; 6586 : 			if (AskWarnNoYes ("CONFIRM_EXIT_UNIVERSAL") == IDNO)

  04580	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@
$LN1503@MainDialog:
  04585	e8 00 00 00 00	 call	 _AskWarnNoYes
  0458a	83 c4 04	 add	 esp, 4
  0458d	83 f8 07	 cmp	 eax, 7
  04590	0f 84 b1 be ff
	ff		 je	 $LN15@MainDialog
$LN144@MainDialog:

; 6587 : 				return 1;	// Disallow close
; 6588 : 		}
; 6589 : 
; 6590 : 		if (hiddenVolHostDriveNo > -1)

  04596	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  0459b	83 f8 ff	 cmp	 eax, -1
  0459e	7e 18		 jle	 SHORT $LN145@MainDialog

; 6591 : 		{
; 6592 : 			CloseVolumeExplorerWindows (hwndDlg, hiddenVolHostDriveNo);

  045a0	50		 push	 eax
  045a1	53		 push	 ebx
  045a2	e8 00 00 00 00	 call	 _CloseVolumeExplorerWindows

; 6593 : 			UnmountVolume (hwndDlg, hiddenVolHostDriveNo, TRUE);

  045a7	6a 01		 push	 1
  045a9	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  045af	53		 push	 ebx
  045b0	e8 00 00 00 00	 call	 _UnmountVolume
  045b5	83 c4 14	 add	 esp, 20			; 00000014H
$LN145@MainDialog:

; 6594 : 		}
; 6595 : 
; 6596 : 		EndMainDlg (hwndDlg);

  045b8	53		 push	 ebx
  045b9	e8 00 00 00 00	 call	 _EndMainDlg
  045be	83 c4 04	 add	 esp, 4
$ovf_end_66$1584:

; 6074 : 			}
; 6075 : 			return 1;

  045c1	b8 01 00 00 00	 mov	 eax, 1
  045c6	e9 e4 ba ff ff	 jmp	 $LN1@MainDialog
$LN127@MainDialog:

; 6524 : 		{
; 6525 : 			// Format (non-in-place encryption) in progress
; 6526 : 			if (AskNoYes ("FORMAT_ABORT") == IDYES)

  045cb	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LNDFLMFM@FORMAT_ABORT?$AA@
  045d0	e8 00 00 00 00	 call	 _AskNoYes
  045d5	83 c4 04	 add	 esp, 4
  045d8	83 f8 06	 cmp	 eax, 6
  045db	0f 85 66 be ff
	ff		 jne	 $LN15@MainDialog

; 6527 : 			{
; 6528 : 				bVolTransformThreadCancel = TRUE;
; 6529 : 
; 6530 : 				EndMainDlg (hwndDlg);

  045e1	53		 push	 ebx
  045e2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bVolTransformThreadCancel, 1
  045ec	e8 00 00 00 00	 call	 _EndMainDlg
  045f1	83 c4 04	 add	 esp, 4
$ovf_end_67$1585:

; 6074 : 			}
; 6075 : 			return 1;

  045f4	b8 01 00 00 00	 mov	 eax, 1
  045f9	e9 b1 ba ff ff	 jmp	 $LN1@MainDialog
$LN1485@MainDialog:
  045fe	66 90		 npad	 2
$LN1510@MainDialog:

; 8346 : }

  04600	00 00 00 00	 DD	 $LN61@MainDialog
  04604	00 00 00 00	 DD	 $LN66@MainDialog
  04608	00 00 00 00	 DD	 $LN86@MainDialog
  0460c	00 00 00 00	 DD	 $LN100@MainDialog
  04610	00 00 00 00	 DD	 $LN95@MainDialog
  04614	00 00 00 00	 DD	 $LN89@MainDialog
$LN1511@MainDialog:
  04618	00 00 00 00	 DD	 $LN432@MainDialog
  0461c	00 00 00 00	 DD	 $LN1291@MainDialog
  04620	00 00 00 00	 DD	 $LN430@MainDialog
  04624	00 00 00 00	 DD	 $LN1474@MainDialog
$LN1390@MainDialog:
  04628	00		 DB	 0
  04629	03		 DB	 3
  0462a	03		 DB	 3
  0462b	01		 DB	 1
  0462c	03		 DB	 3
  0462d	03		 DB	 3
  0462e	03		 DB	 3
  0462f	03		 DB	 3
  04630	03		 DB	 3
  04631	03		 DB	 3
  04632	03		 DB	 3
  04633	03		 DB	 3
  04634	03		 DB	 3
  04635	03		 DB	 3
  04636	03		 DB	 3
  04637	03		 DB	 3
  04638	03		 DB	 3
  04639	03		 DB	 3
  0463a	03		 DB	 3
  0463b	03		 DB	 3
  0463c	03		 DB	 3
  0463d	03		 DB	 3
  0463e	02		 DB	 2
  0463f	03		 DB	 3
  04640	01		 DB	 1
  04641	0f 1f 00	 npad	 3
$LN1512@MainDialog:
  04644	00 00 00 00	 DD	 $LN317@MainDialog
  04648	00 00 00 00	 DD	 $LN1291@MainDialog
  0464c	00 00 00 00	 DD	 $LN315@MainDialog
  04650	00 00 00 00	 DD	 $LN1474@MainDialog
$LN1392@MainDialog:
  04654	00		 DB	 0
  04655	03		 DB	 3
  04656	03		 DB	 3
  04657	01		 DB	 1
  04658	03		 DB	 3
  04659	03		 DB	 3
  0465a	03		 DB	 3
  0465b	03		 DB	 3
  0465c	03		 DB	 3
  0465d	03		 DB	 3
  0465e	03		 DB	 3
  0465f	03		 DB	 3
  04660	03		 DB	 3
  04661	03		 DB	 3
  04662	03		 DB	 3
  04663	03		 DB	 3
  04664	03		 DB	 3
  04665	03		 DB	 3
  04666	03		 DB	 3
  04667	03		 DB	 3
  04668	03		 DB	 3
  04669	03		 DB	 3
  0466a	02		 DB	 2
  0466b	03		 DB	 3
  0466c	01		 DB	 1
  0466d	0f 1f 00	 npad	 3
$LN1513@MainDialog:
  04670	00 00 00 00	 DD	 $LN112@MainDialog
  04674	00 00 00 00	 DD	 $LN119@MainDialog
  04678	00 00 00 00	 DD	 $LN111@MainDialog
  0467c	00 00 00 00	 DD	 $LN2@MainDialog
  04680	00 00 00 00	 DD	 $LN114@MainDialog
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_MainDialogProc@16$45:
  00000	8d 8d e0 34 ff
	ff		 lea	 ecx, DWORD PTR $T73[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_MainDialogProc@16$46:
  0000b	8d 8d e8 32 ff
	ff		 lea	 ecx, DWORD PTR $T52[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$49:
  00016	8d 8d a0 32 ff
	ff		 lea	 ecx, DWORD PTR $T49[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$50:
  00021	8d 8d b8 32 ff
	ff		 lea	 ecx, DWORD PTR $T50[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$53:
  0002c	8d 8d 58 32 ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$54:
  00037	8d 8d 70 32 ff
	ff		 lea	 ecx, DWORD PTR $T47[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$57:
  00042	8d 8d 80 34 ff
	ff		 lea	 ecx, DWORD PTR $T69[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$58:
  0004d	8d 8d e0 31 ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$59:
  00058	8d 8d f8 31 ff
	ff		 lea	 ecx, DWORD PTR $T42[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$60:
  00063	8d 8d 10 32 ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$61:
  0006e	8d 8d 28 32 ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$66:
  00079	8d 8d c0 33 ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp]
  0007f	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$67:
  00084	8d 8d d8 33 ff
	ff		 lea	 ecx, DWORD PTR $T62[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$68:
  0008f	8d 8d f0 33 ff
	ff		 lea	 ecx, DWORD PTR $T63[ebp]
  00095	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$69:
  0009a	8d 8d 08 34 ff
	ff		 lea	 ecx, DWORD PTR $T64[ebp]
  000a0	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$70:
  000a5	8d 8d 20 34 ff
	ff		 lea	 ecx, DWORD PTR $T65[ebp]
  000ab	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$71:
  000b0	8d 8d 38 34 ff
	ff		 lea	 ecx, DWORD PTR $T66[ebp]
  000b6	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$72:
  000bb	8d 8d 50 34 ff
	ff		 lea	 ecx, DWORD PTR $T67[ebp]
  000c1	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$75:
  000c6	8d 8d c8 34 ff
	ff		 lea	 ecx, DWORD PTR $T72[ebp]
  000cc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_MainDialogProc@16$76:
  000d1	8d 8d b0 34 ff
	ff		 lea	 ecx, DWORD PTR $T71[ebp]
  000d7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_MainDialogProc@16$78:
  000dc	8d 8d 18 33 ff
	ff		 lea	 ecx, DWORD PTR $T54[ebp]
  000e2	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$79:
  000e7	8d 8d 30 33 ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  000ed	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$80:
  000f2	8d 8d 48 33 ff
	ff		 lea	 ecx, DWORD PTR $T56[ebp]
  000f8	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$81:
  000fd	8d 8d 60 33 ff
	ff		 lea	 ecx, DWORD PTR $T57[ebp]
  00103	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$82:
  00108	8d 8d 78 33 ff
	ff		 lea	 ecx, DWORD PTR $T58[ebp]
  0010e	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_MainDialogProc@16$74:
  00113	8d 8d 98 34 ff
	ff		 lea	 ecx, DWORD PTR $T70[ebp]
  00119	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_MainDialogProc@16$63:
  0011e	8d 8d cc 2c ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00124	e9 00 00 00 00	 jmp	 ??1?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ ; std::vector<HostDevice,std::allocator<HostDevice> >::~vector<HostDevice,std::allocator<HostDevice> >
__unwindfunclet$_MainDialogProc@16$64:
  00129	8d 8d 30 2d ff
	ff		 lea	 ecx, DWORD PTR _$S2$27[ebp]
  0012f	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__ehhandler$_MainDialogProc@16:
  00134	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00138	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0013b	8b 8a 84 2c ff
	ff		 mov	 ecx, DWORD PTR [edx-54140]
  00141	33 c8		 xor	 ecx, eax
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0014b	33 c8		 xor	 ecx, eax
  0014d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00152	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_MainDialogProc@16
  00157	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_MainDialogProc@16 ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _PageDialogProc@16
_TEXT	SEGMENT
_s$2 = -71044						; size = 176
_e$3 = -70868						; size = 4
_e$4 = -70864						; size = 4
_e$5 = -70860						; size = 4
_$S1$6 = -70856						; size = 28
_tmpbDevice$7 = -70828					; size = 4
_param$8 = -70824					; size = 8
_savedWipeAlgorithm$9 = -70816				; size = 4
_fileSystemFlags$10 = -70812				; size = 4
$T11 = -70808						; size = 4
_dataAreaSize$1$ = -70804				; size = 4
_bFATallowed$1$ = -70800				; size = 4
_dataAreaSize$2$ = -70796				; size = 4
_hwndDlg$GSCopy$ = -70796				; size = 4
tv7962 = -70792						; size = 4
_lParam$GSCopy$1$ = -70792				; size = 4
_selPartitionItemId$1$ = -70792				; size = 4
_bNoFSallowed$1$ = -70792				; size = 4
tv6252 = -70792						; size = 4
_this$ = -70792						; size = 4
_this$12 = -70792					; size = 4
_hwndDlg$GSCopy$1$ = -70788				; size = 4
_bNTFSallowed$1$ = -70788				; size = 4
_nID$1$ = -70788					; size = 4
$T13 = -70784						; size = 320
$T14 = -70464						; size = 94
_locBootEncStatus$15 = -70368				; size = 94
$T16 = -70368						; size = 94
$T17 = -70272						; size = 24
$T18 = -70248						; size = 24
$T19 = -70224						; size = 24
_tmpStr$20 = -70200					; size = 24
_szTmp$21 = -70176					; size = 16384
_finalMsg$22 = -53792					; size = 16048
_msg$23 = -37744					; size = 8192
_szTmp$24 = -29552					; size = 8192
_szTmp$25 = -21360					; size = 16384
_str$26 = -4976						; size = 2000
_str$27 = -2976						; size = 2000
_root$28 = -976						; size = 260
_tmpszRescueDiskISO$29 = -716				; size = 261
_buf$30 = -452						; size = 100
_szMaxRecomOuterVolFillSize$31 = -352			; size = 200
_name$32 = -152						; size = 100
_szTmp$33 = -52						; size = 32
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_hwndDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_PageDialogProc@16 PROC					; COMDAT

; 3847 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_PageDialogProc@16
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	b8 74 15 01 00	 mov	 eax, 71028		; 00011574H
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00036	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]

; 3848 : 	static char PageDebugId[128];
; 3849 : 	WORD lw = LOWORD (wParam);
; 3850 : 	WORD hw = HIWORD (wParam);

  00039	8b 75 10	 mov	 esi, DWORD PTR _wParam$[ebp]
  0003c	8b fe		 mov	 edi, esi
  0003e	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  00041	89 85 78 eb fe
	ff		 mov	 DWORD PTR _lParam$GSCopy$1$[ebp], eax

; 3851 : 
; 3852 : 	hCurPage = hwndDlg;
; 3853 : 
; 3854 : 	switch (uMsg)

  00047	8b 45 0c	 mov	 eax, DWORD PTR _uMsg$[ebp]
  0004a	c1 ef 10	 shr	 edi, 16			; 00000010H
  0004d	c7 85 68 eb fe
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp], 0
  00057	89 9d 7c eb fe
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], ebx
  0005d	89 9d 74 eb fe
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$[ebp], ebx
  00063	89 1d 00 00 00
	00		 mov	 DWORD PTR _hCurPage, ebx
  00069	3d 11 01 00 00	 cmp	 eax, 273		; 00000111H
  0006e	0f 87 3b 53 00
	00		 ja	 $LN370@PageDialog
  00074	0f 84 c3 3e 00
	00		 je	 $LN206@PageDialog
  0007a	83 f8 53	 cmp	 eax, 83			; 00000053H
  0007d	0f 84 9f 3e 00
	00		 je	 $LN204@PageDialog
  00083	3d 10 01 00 00	 cmp	 eax, 272		; 00000110H
  00088	0f 85 4b 07 00
	00		 jne	 $LN384@PageDialog

; 3855 : 	{
; 3856 : 	case WM_INITDIALOG:
; 3857 : 		LocalizeDialog (hwndDlg, "IDD_VOL_CREATION_WIZARD_DLG");

  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IHMEHMBJ@IDD_VOL_CREATION_WIZARD_DLG?$AA@
  00093	53		 push	 ebx
  00094	e8 00 00 00 00	 call	 _LocalizeDialog

; 3858 : 
; 3859 : 		sprintf (PageDebugId, "FORMAT_PAGE_%d", nCurPageNo);

  00099	ff 35 00 00 00
	00		 push	 DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IDKFBPLE@FORMAT_PAGE_?$CFd?$AA@
  000a4	68 00 00 00 00	 push	 OFFSET ?PageDebugId@?1??PageDialogProc@@9@16@4PADA
  000a9	e8 00 00 00 00	 call	 _sprintf

; 3860 : 		LastDialogId = PageDebugId;
; 3861 : 
; 3862 : 		switch (nCurPageNo)

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  000b3	83 c4 14	 add	 esp, 20			; 00000014H
  000b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LastDialogId, OFFSET ?PageDebugId@?1??PageDialogProc@@9@16@4PADA
  000c0	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  000c3	0f 87 10 07 00
	00		 ja	 $LN384@PageDialog
  000c9	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN789@PageDialog[eax*4]
$LN53@PageDialog:

; 3863 : 		{
; 3864 : 		case INTRO_PAGE:
; 3865 : 
; 3866 : 			SendMessage (GetDlgItem (hwndDlg, IDC_FILE_CONTAINER), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  000d0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  000d6	6a 01		 push	 1
  000d8	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  000de	6a 30		 push	 48			; 00000030H
  000e0	68 25 04 00 00	 push	 1061			; 00000425H
  000e5	53		 push	 ebx
  000e6	ff d7		 call	 edi
  000e8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  000ee	50		 push	 eax
  000ef	ff d6		 call	 esi

; 3867 : 			SendMessage (GetDlgItem (hwndDlg, IDC_NONSYS_DEVICE), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  000f1	6a 01		 push	 1
  000f3	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  000f9	6a 30		 push	 48			; 00000030H
  000fb	68 26 04 00 00	 push	 1062			; 00000426H
  00100	53		 push	 ebx
  00101	ff d7		 call	 edi
  00103	50		 push	 eax
  00104	ff d6		 call	 esi

; 3868 : 			SendMessage (GetDlgItem (hwndDlg, IDC_SYS_DEVICE), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  00106	6a 01		 push	 1
  00108	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  0010e	6a 30		 push	 48			; 00000030H
  00110	68 27 04 00 00	 push	 1063			; 00000427H
  00115	53		 push	 ebx
  00116	ff d7		 call	 edi
  00118	50		 push	 eax
  00119	ff d6		 call	 esi

; 3869 : 
; 3870 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("INTRO_TITLE"));

  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BGLIKHAN@INTRO_TITLE?$AA@
  00120	e8 00 00 00 00	 call	 _GetString
  00125	83 c4 04	 add	 esp, 4
  00128	50		 push	 eax
  00129	68 e8 03 00 00	 push	 1000			; 000003e8H
  0012e	53		 push	 ebx
  0012f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  00135	ff d3		 call	 ebx
  00137	50		 push	 eax
  00138	ff d7		 call	 edi
  0013a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00140	50		 push	 eax
  00141	ff d6		 call	 esi

; 3871 : 
; 3872 : 			ToHyperlink (hwndDlg, IDC_MORE_INFO_ON_CONTAINERS);

  00143	68 33 04 00 00	 push	 1075			; 00000433H
  00148	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0014e	e8 00 00 00 00	 call	 _ToHyperlink

; 3873 : 			ToHyperlink (hwndDlg, IDC_MORE_INFO_ON_SYS_ENCRYPTION);

  00153	68 31 04 00 00	 push	 1073			; 00000431H
  00158	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0015e	e8 00 00 00 00	 call	 _ToHyperlink
  00163	83 c4 10	 add	 esp, 16			; 00000010H

; 3874 : 
; 3875 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_STD_VOL), TRUE);

  00166	6a 01		 push	 1
  00168	68 07 04 00 00	 push	 1031			; 00000407H
  0016d	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00173	ff d7		 call	 edi
  00175	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  0017b	50		 push	 eax
  0017c	ff d7		 call	 edi

; 3876 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_HIDDEN_VOL), TRUE);

  0017e	6a 01		 push	 1
  00180	68 08 04 00 00	 push	 1032			; 00000408H
  00185	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00191	50		 push	 eax
  00192	ff d7		 call	 edi

; 3877 : 
; 3878 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  00194	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00199	e8 00 00 00 00	 call	 _GetString
  0019e	83 c4 04	 add	 esp, 4
  001a1	50		 push	 eax
  001a2	68 10 04 00 00	 push	 1040			; 00000410H
  001a7	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  001ad	ff d3		 call	 ebx
  001af	50		 push	 eax
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001b6	50		 push	 eax
  001b7	ff d6		 call	 esi

; 3879 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  001be	e8 00 00 00 00	 call	 _GetString
  001c3	83 c4 04	 add	 esp, 4
  001c6	50		 push	 eax
  001c7	68 11 04 00 00	 push	 1041			; 00000411H
  001cc	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  001d2	ff d3		 call	 ebx
  001d4	50		 push	 eax
  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001db	50		 push	 eax
  001dc	ff d6		 call	 esi

; 3880 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("CANCEL"));

  001de	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  001e3	e8 00 00 00 00	 call	 _GetString
  001e8	83 c4 04	 add	 esp, 4
  001eb	50		 push	 eax
  001ec	6a 02		 push	 2
  001ee	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  001f4	ff d3		 call	 ebx
  001f6	50		 push	 eax
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001fd	50		 push	 eax
  001fe	ff d6		 call	 esi

; 3881 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  00200	6a 01		 push	 1
  00202	68 10 04 00 00	 push	 1040			; 00000410H
  00207	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0020d	ff d3		 call	 ebx
  0020f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00215	50		 push	 eax
  00216	ff d6		 call	 esi
  00218	50		 push	 eax
  00219	ff d7		 call	 edi

; 3882 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  0021b	6a 00		 push	 0
  0021d	68 11 04 00 00	 push	 1041			; 00000411H
  00222	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00228	ff d3		 call	 ebx
  0022a	50		 push	 eax
  0022b	ff d6		 call	 esi
  0022d	50		 push	 eax
  0022e	ff d7		 call	 edi

; 3883 : 
; 3884 : 			UpdateWizardModeControls (hwndDlg, WizardMode);

  00230	a1 00 00 00 00	 mov	 eax, DWORD PTR _WizardMode
  00235	50		 push	 eax
  00236	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0023c	e8 00 00 00 00	 call	 ?UpdateWizardModeControls@@YAXPAUHWND__@@H@Z ; UpdateWizardModeControls

; 3973 : 				{
; 3974 : 				case 1:
; 3975 : 					// Do not try again
; 3976 : 					LoadPage (MainDlg, SYSENC_DRIVE_ANALYSIS_PAGE + 1);

  00241	83 c4 08	 add	 esp, 8

; 3977 : 					return 0;

  00244	33 c0		 xor	 eax, eax
  00246	e9 7d 51 00 00	 jmp	 $LN1@PageDialog
$LN54@PageDialog:

; 3885 : 			break;
; 3886 : 
; 3887 : 		case SYSENC_TYPE_PAGE:
; 3888 : 
; 3889 : 			bHiddenVolHost = bHiddenVol = bHiddenOS;

  0024b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenOS@@3HC ; bHiddenOS
  00250	a3 00 00 00 00	 mov	 DWORD PTR ?bHiddenVol@@3HC, eax ; bHiddenVol
  00255	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenVol@@3HC ; bHiddenVol

; 3890 : 
; 3891 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_TYPE_PAGE_TITLE"));

  0025a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LFFPJFCG@SYSENC_TYPE_PAGE_TITLE?$AA@
  0025f	a3 00 00 00 00	 mov	 DWORD PTR _bHiddenVolHost, eax
  00264	e8 00 00 00 00	 call	 _GetString
  00269	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  0026f	83 c4 04	 add	 esp, 4
  00272	50		 push	 eax
  00273	68 e8 03 00 00	 push	 1000			; 000003e8H
  00278	53		 push	 ebx
  00279	ff d7		 call	 edi
  0027b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00281	50		 push	 eax
  00282	ff d6		 call	 esi
  00284	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SetWindowTextW@8
  0028a	50		 push	 eax
  0028b	ff d3		 call	 ebx

; 3892 : 
; 3893 : 			SendMessage (GetDlgItem (hwndDlg, IDC_SYSENC_HIDDEN), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  0028d	6a 01		 push	 1
  0028f	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  00295	6a 30		 push	 48			; 00000030H
  00297	68 49 04 00 00	 push	 1097			; 00000449H
  0029c	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  002a2	ff d6		 call	 esi
  002a4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  002aa	50		 push	 eax
  002ab	ff d6		 call	 esi

; 3894 : 			SendMessage (GetDlgItem (hwndDlg, IDC_SYSENC_NORMAL), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  002ad	6a 01		 push	 1
  002af	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  002b5	6a 30		 push	 48			; 00000030H
  002b7	68 48 04 00 00	 push	 1096			; 00000448H
  002bc	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  002c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  002c8	50		 push	 eax
  002c9	ff d6		 call	 esi

; 3895 : 
; 3896 : 			CheckButton (GetDlgItem (hwndDlg, bHiddenOS ? IDC_SYSENC_HIDDEN : IDC_SYSENC_NORMAL));

  002cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenOS@@3HC ; bHiddenOS
  002d0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  002d6	f7 d8		 neg	 eax
  002d8	1b c0		 sbb	 eax, eax
  002da	f7 d8		 neg	 eax
  002dc	05 48 04 00 00	 add	 eax, 1096		; 00000448H
  002e1	50		 push	 eax
  002e2	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  002e8	ff d6		 call	 esi
  002ea	50		 push	 eax
  002eb	e8 00 00 00 00	 call	 _CheckButton

; 3897 : 
; 3898 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYSENC_HIDDEN_TYPE_HELP"));

  002f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FECPKDFP@SYSENC_HIDDEN_TYPE_HELP?$AA@
  002f5	e8 00 00 00 00	 call	 _GetString
  002fa	83 c4 08	 add	 esp, 8
  002fd	50		 push	 eax
  002fe	68 eb 03 00 00	 push	 1003			; 000003ebH
  00303	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00309	ff d6		 call	 esi
  0030b	50		 push	 eax
  0030c	ff d3		 call	 ebx

; 3899 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP_SYSENC_NORMAL), GetString ("SYSENC_NORMAL_TYPE_HELP"));

  0030e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EEMGDNEH@SYSENC_NORMAL_TYPE_HELP?$AA@
  00313	e8 00 00 00 00	 call	 _GetString
  00318	83 c4 04	 add	 esp, 4
  0031b	50		 push	 eax
  0031c	68 4a 04 00 00	 push	 1098			; 0000044aH
  00321	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00327	ff d6		 call	 esi
  00329	50		 push	 eax
  0032a	ff d3		 call	 ebx

; 3900 : 
; 3901 : 			ToHyperlink (hwndDlg, IDC_HIDDEN_SYSENC_INFO_LINK);

  0032c	68 4b 04 00 00	 push	 1099			; 0000044bH
  00331	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00337	e8 00 00 00 00	 call	 _ToHyperlink
  0033c	83 c4 08	 add	 esp, 8

; 3902 : 
; 3903 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  0033f	6a 01		 push	 1
  00341	68 10 04 00 00	 push	 1040			; 00000410H
  00346	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0034c	ff d7		 call	 edi
  0034e	50		 push	 eax
  0034f	ff d6		 call	 esi
  00351	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00357	50		 push	 eax
  00358	ff d6		 call	 esi

; 3904 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), !bDirectSysEncMode);

  0035a	33 c0		 xor	 eax, eax
  0035c	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bDirectSysEncMode@@3HA, eax ; bDirectSysEncMode
  00362	0f 94 c0	 sete	 al
  00365	50		 push	 eax
  00366	68 11 04 00 00	 push	 1041			; 00000411H
  0036b	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00371	ff d7		 call	 edi
  00373	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00379	50		 push	 eax
  0037a	ff d7		 call	 edi
  0037c	50		 push	 eax
  0037d	ff d6		 call	 esi

; 3905 : 
; 3906 : 			SetWindowTextW (GetDlgItem (MainDlg, IDC_NEXT), GetString ("NEXT"));

  0037f	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00384	e8 00 00 00 00	 call	 _GetString
  00389	83 c4 04	 add	 esp, 4
  0038c	50		 push	 eax
  0038d	68 10 04 00 00	 push	 1040			; 00000410H
  00392	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00398	ff d7		 call	 edi
  0039a	50		 push	 eax
  0039b	ff d3		 call	 ebx

; 3907 : 			SetWindowTextW (GetDlgItem (MainDlg, IDC_PREV), GetString ("PREV"));

  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  003a2	e8 00 00 00 00	 call	 _GetString
  003a7	83 c4 04	 add	 esp, 4
  003aa	50		 push	 eax
  003ab	68 11 04 00 00	 push	 1041			; 00000411H
  003b0	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  003b6	ff d7		 call	 edi
  003b8	50		 push	 eax
  003b9	ff d3		 call	 ebx

; 3908 : 			SetWindowTextW (GetDlgItem (MainDlg, IDCANCEL), GetString ("CANCEL"));

  003bb	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  003c0	e8 00 00 00 00	 call	 _GetString
  003c5	83 c4 04	 add	 esp, 4
  003c8	50		 push	 eax
  003c9	6a 02		 push	 2
  003cb	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  003d1	ff d7		 call	 edi
  003d3	50		 push	 eax
  003d4	ff d3		 call	 ebx

; 3977 : 					return 0;

  003d6	33 c0		 xor	 eax, eax
  003d8	e9 eb 4f 00 00	 jmp	 $LN1@PageDialog
$LN55@PageDialog:

; 3909 : 			break;
; 3910 : 
; 3911 : 		case SYSENC_HIDDEN_OS_REQ_CHECK_PAGE:
; 3912 : 
; 3913 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_TITLE"));

  003dd	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CLMIJGGF@SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_@
  003e2	e8 00 00 00 00	 call	 _GetString
  003e7	83 c4 04	 add	 esp, 4
  003ea	50		 push	 eax
  003eb	68 e8 03 00 00	 push	 1000			; 000003e8H
  003f0	53		 push	 ebx
  003f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  003f7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  003fd	50		 push	 eax
  003fe	ff d7		 call	 edi
  00400	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00406	50		 push	 eax
  00407	ff d6		 call	 esi

; 3914 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_HELP"));

  00409	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GBPOCIAL@SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_@
  0040e	e8 00 00 00 00	 call	 _GetString
  00413	83 c4 04	 add	 esp, 4
  00416	50		 push	 eax
  00417	68 eb 03 00 00	 push	 1003			; 000003ebH
  0041c	53		 push	 ebx
  0041d	ff d7		 call	 edi
  0041f	50		 push	 eax
  00420	ff d6		 call	 esi

; 3915 : 			SetWindowTextW (GetDlgItem (MainDlg, IDC_NEXT), GetString ("NEXT"));

  00422	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00427	e8 00 00 00 00	 call	 _GetString
  0042c	83 c4 04	 add	 esp, 4
  0042f	50		 push	 eax
  00430	68 10 04 00 00	 push	 1040			; 00000410H
  00435	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0043b	ff d7		 call	 edi
  0043d	50		 push	 eax
  0043e	ff d6		 call	 esi

; 3916 : 			SetWindowTextW (GetDlgItem (MainDlg, IDC_PREV), GetString ("PREV"));

  00440	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  00445	e8 00 00 00 00	 call	 _GetString
  0044a	83 c4 04	 add	 esp, 4
  0044d	50		 push	 eax
  0044e	68 11 04 00 00	 push	 1041			; 00000411H
  00453	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00459	ff d7		 call	 edi
  0045b	50		 push	 eax
  0045c	ff d6		 call	 esi

; 3917 : 			SetWindowTextW (GetDlgItem (MainDlg, IDCANCEL), GetString ("CANCEL"));

  0045e	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  00463	e8 00 00 00 00	 call	 _GetString
  00468	83 c4 04	 add	 esp, 4
  0046b	50		 push	 eax
  0046c	6a 02		 push	 2
  0046e	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00474	ff d7		 call	 edi
  00476	50		 push	 eax
  00477	ff d6		 call	 esi

; 3918 : 
; 3919 : 			EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), TRUE);

  00479	6a 01		 push	 1
  0047b	68 10 04 00 00	 push	 1040			; 00000410H
  00480	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00486	ff d7		 call	 edi
  00488	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  0048e	50		 push	 eax
  0048f	ff d6		 call	 esi

; 3920 : 			EnableWindow (GetDlgItem (MainDlg, IDC_PREV), bDirectSysEncModeCommand != SYSENC_COMMAND_CREATE_HIDDEN_OS && bDirectSysEncModeCommand != SYSENC_COMMAND_CREATE_HIDDEN_OS_ELEV);

  00491	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bDirectSysEncModeCommand@@3HA ; bDirectSysEncModeCommand
  00496	83 f8 05	 cmp	 eax, 5
  00499	74 0c		 je	 SHORT $LN331@PageDialog
  0049b	83 f8 06	 cmp	 eax, 6
  0049e	74 07		 je	 SHORT $LN331@PageDialog
  004a0	b8 01 00 00 00	 mov	 eax, 1
  004a5	eb 02		 jmp	 SHORT $LN332@PageDialog
$LN331@PageDialog:
  004a7	33 c0		 xor	 eax, eax
$LN332@PageDialog:
  004a9	50		 push	 eax
  004aa	68 11 04 00 00	 push	 1041			; 00000411H
  004af	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  004b5	ff d7		 call	 edi
  004b7	50		 push	 eax
  004b8	ff d6		 call	 esi

; 3921 : 
; 3922 : 			ToHyperlink (hwndDlg, IDC_HIDDEN_SYSENC_INFO_LINK);

  004ba	68 4b 04 00 00	 push	 1099			; 0000044bH
  004bf	53		 push	 ebx
  004c0	e8 00 00 00 00	 call	 _ToHyperlink

; 3973 : 				{
; 3974 : 				case 1:
; 3975 : 					// Do not try again
; 3976 : 					LoadPage (MainDlg, SYSENC_DRIVE_ANALYSIS_PAGE + 1);

  004c5	83 c4 08	 add	 esp, 8

; 3977 : 					return 0;

  004c8	33 c0		 xor	 eax, eax
  004ca	e9 f9 4e 00 00	 jmp	 $LN1@PageDialog
$LN56@PageDialog:

; 3923 : 			break;
; 3924 : 
; 3925 : 		case SYSENC_SPAN_PAGE:
; 3926 : 
; 3927 : 			SendMessage (GetDlgItem (hwndDlg, IDC_WHOLE_SYS_DRIVE), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  004cf	6a 01		 push	 1
  004d1	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  004d7	6a 30		 push	 48			; 00000030H
  004d9	68 2b 04 00 00	 push	 1067			; 0000042bH
  004de	53		 push	 ebx
  004df	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  004e5	ff d3		 call	 ebx
  004e7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  004ed	50		 push	 eax
  004ee	ff d6		 call	 esi

; 3928 : 			SendMessage (GetDlgItem (hwndDlg, IDC_SYS_PARTITION), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  004f0	8b bd 7c eb fe
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  004f6	6a 01		 push	 1
  004f8	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  004fe	6a 30		 push	 48			; 00000030H
  00500	68 2c 04 00 00	 push	 1068			; 0000042cH
  00505	57		 push	 edi
  00506	ff d3		 call	 ebx
  00508	50		 push	 eax
  00509	ff d6		 call	 esi

; 3929 : 
; 3930 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYS_ENCRYPTION_SPAN_TITLE"));

  0050b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FBGFJBLB@SYS_ENCRYPTION_SPAN_TITLE?$AA@
  00510	e8 00 00 00 00	 call	 _GetString
  00515	83 c4 04	 add	 esp, 4
  00518	50		 push	 eax
  00519	68 e8 03 00 00	 push	 1000			; 000003e8H
  0051e	57		 push	 edi
  0051f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  00525	ff d7		 call	 edi
  00527	50		 push	 eax
  00528	ff d3		 call	 ebx
  0052a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00530	50		 push	 eax
  00531	ff d6		 call	 esi

; 3931 : 
; 3932 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDT_WHOLE_SYS_DRIVE), GetString ("SYS_ENCRYPTION_SPAN_WHOLE_SYS_DRIVE_HELP"));

  00533	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CMOPFEFD@SYS_ENCRYPTION_SPAN_WHOLE_SYS_DR@
  00538	e8 00 00 00 00	 call	 _GetString
  0053d	83 c4 04	 add	 esp, 4
  00540	50		 push	 eax
  00541	68 2d 04 00 00	 push	 1069			; 0000042dH
  00546	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0054c	ff d3		 call	 ebx
  0054e	50		 push	 eax
  0054f	ff d6		 call	 esi

; 3933 : 
; 3934 : 			CheckButton (GetDlgItem (hwndDlg, bWholeSysDrive ? IDC_WHOLE_SYS_DRIVE : IDC_SYS_PARTITION));

  00551	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bWholeSysDrive@@3HA ; bWholeSysDrive
  00556	f7 d8		 neg	 eax
  00558	1b c0		 sbb	 eax, eax
  0055a	05 2c 04 00 00	 add	 eax, 1068		; 0000042cH
  0055f	50		 push	 eax
  00560	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00566	ff d3		 call	 ebx
  00568	50		 push	 eax
  00569	e8 00 00 00 00	 call	 _CheckButton

; 3935 : 
; 3936 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  0056e	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00573	e8 00 00 00 00	 call	 _GetString
  00578	83 c4 08	 add	 esp, 8
  0057b	50		 push	 eax
  0057c	68 10 04 00 00	 push	 1040			; 00000410H
  00581	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00587	ff d7		 call	 edi
  00589	50		 push	 eax
  0058a	ff d3		 call	 ebx
  0058c	50		 push	 eax
  0058d	ff d6		 call	 esi

; 3937 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  0058f	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  00594	e8 00 00 00 00	 call	 _GetString
  00599	83 c4 04	 add	 esp, 4
  0059c	50		 push	 eax
  0059d	68 11 04 00 00	 push	 1041			; 00000411H
  005a2	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  005a8	ff d7		 call	 edi
  005aa	50		 push	 eax
  005ab	ff d3		 call	 ebx
  005ad	50		 push	 eax
  005ae	ff d6		 call	 esi

; 3938 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("CANCEL"));

  005b0	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  005b5	e8 00 00 00 00	 call	 _GetString
  005ba	83 c4 04	 add	 esp, 4
  005bd	50		 push	 eax
  005be	6a 02		 push	 2
  005c0	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  005c6	ff d7		 call	 edi
  005c8	50		 push	 eax
  005c9	ff d3		 call	 ebx
  005cb	50		 push	 eax
  005cc	ff d6		 call	 esi

; 3939 : 
; 3940 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  005ce	6a 01		 push	 1
  005d0	68 10 04 00 00	 push	 1040			; 00000410H
  005d5	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  005db	ff d7		 call	 edi
  005dd	50		 push	 eax
  005de	ff d3		 call	 ebx
  005e0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
$LN786@PageDialog:
  005e6	50		 push	 eax
  005e7	ff d6		 call	 esi

; 3941 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  005e9	6a 01		 push	 1
  005eb	68 11 04 00 00	 push	 1041			; 00000411H
  005f0	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  005f6	ff d7		 call	 edi
  005f8	50		 push	 eax
  005f9	ff d3		 call	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  005fb	50		 push	 eax
  005fc	ff d6		 call	 esi
  005fe	33 c0		 xor	 eax, eax
  00600	e9 c3 4d 00 00	 jmp	 $LN1@PageDialog
$LN57@PageDialog:

; 3942 : 			break;
; 3943 : 
; 3944 : 
; 3945 : 		case SYSENC_PRE_DRIVE_ANALYSIS_PAGE:
; 3946 : 
; 3947 : 			Init2RadButtonPageYesNo (SysEncDetectHiddenSectors);

  00605	ff 35 00 00 00
	00		 push	 DWORD PTR ?SysEncDetectHiddenSectors@@3HA ; SysEncDetectHiddenSectors
  0060b	e8 00 00 00 00	 call	 ?Init2RadButtonPageYesNo@@YAXH@Z ; Init2RadButtonPageYesNo

; 3948 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_PRE_DRIVE_ANALYSIS_TITLE"));

  00610	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IIEHPPGP@SYSENC_PRE_DRIVE_ANALYSIS_TITLE?$AA@
  00615	e8 00 00 00 00	 call	 _GetString
  0061a	83 c4 08	 add	 esp, 8
  0061d	50		 push	 eax
  0061e	68 e8 03 00 00	 push	 1000			; 000003e8H
  00623	53		 push	 ebx
  00624	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0062a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00630	50		 push	 eax
  00631	ff d7		 call	 edi
  00633	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00639	50		 push	 eax
  0063a	ff d6		 call	 esi

; 3949 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYSENC_PRE_DRIVE_ANALYSIS_HELP"));

  0063c	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@FCJHFGGJ@SYSENC_PRE_DRIVE_ANALYSIS_HELP?$AA@
  00641	e8 00 00 00 00	 call	 _GetString
  00646	83 c4 04	 add	 esp, 4
  00649	50		 push	 eax
  0064a	68 eb 03 00 00	 push	 1003			; 000003ebH
  0064f	53		 push	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00650	ff d7		 call	 edi
  00652	50		 push	 eax
  00653	ff d6		 call	 esi
  00655	33 c0		 xor	 eax, eax
  00657	e9 6c 4d 00 00	 jmp	 $LN1@PageDialog
$LN58@PageDialog:

; 3950 : 			break;
; 3951 : 
; 3952 : 
; 3953 : 		case SYSENC_DRIVE_ANALYSIS_PAGE:
; 3954 : 
; 3955 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_DRIVE_ANALYSIS_TITLE"));

  0065c	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@EGLOODHA@SYSENC_DRIVE_ANALYSIS_TITLE?$AA@
  00661	e8 00 00 00 00	 call	 _GetString
  00666	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  0066c	83 c4 04	 add	 esp, 4
  0066f	50		 push	 eax
  00670	68 e8 03 00 00	 push	 1000			; 000003e8H
  00675	53		 push	 ebx
  00676	ff d7		 call	 edi
  00678	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  0067e	50		 push	 eax
  0067f	ff d3		 call	 ebx
  00681	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00687	50		 push	 eax
  00688	ff d6		 call	 esi

; 3956 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDT_SYSENC_DRIVE_ANALYSIS_INFO), GetString ("SYSENC_DRIVE_ANALYSIS_INFO"));

  0068a	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OAMDPDOH@SYSENC_DRIVE_ANALYSIS_INFO?$AA@
  0068f	e8 00 00 00 00	 call	 _GetString
  00694	83 c4 04	 add	 esp, 4
  00697	50		 push	 eax
  00698	68 47 04 00 00	 push	 1095			; 00000447H
  0069d	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  006a3	ff d3		 call	 ebx
  006a5	50		 push	 eax
  006a6	ff d6		 call	 esi

; 3957 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  006a8	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  006ad	e8 00 00 00 00	 call	 _GetString
  006b2	83 c4 04	 add	 esp, 4
  006b5	50		 push	 eax
  006b6	68 10 04 00 00	 push	 1040			; 00000410H
  006bb	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  006c1	ff d7		 call	 edi
  006c3	50		 push	 eax
  006c4	ff d3		 call	 ebx
  006c6	50		 push	 eax
  006c7	ff d6		 call	 esi

; 3958 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  006c9	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  006ce	e8 00 00 00 00	 call	 _GetString
  006d3	83 c4 04	 add	 esp, 4
  006d6	50		 push	 eax
  006d7	68 11 04 00 00	 push	 1041			; 00000411H
  006dc	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  006e2	ff d7		 call	 edi
  006e4	50		 push	 eax
  006e5	ff d3		 call	 ebx
  006e7	50		 push	 eax
  006e8	ff d6		 call	 esi

; 3959 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("CANCEL"));

  006ea	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  006ef	e8 00 00 00 00	 call	 _GetString
  006f4	83 c4 04	 add	 esp, 4
  006f7	50		 push	 eax
  006f8	6a 02		 push	 2
  006fa	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00700	ff d7		 call	 edi
  00702	50		 push	 eax
  00703	ff d3		 call	 ebx
  00705	50		 push	 eax
  00706	ff d6		 call	 esi

; 3960 : 			EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), FALSE);

  00708	6a 00		 push	 0
  0070a	68 10 04 00 00	 push	 1040			; 00000410H
  0070f	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00715	ff d3		 call	 ebx
  00717	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  0071d	50		 push	 eax
  0071e	ff d6		 call	 esi

; 3961 : 			EnableWindow (GetDlgItem (MainDlg, IDC_PREV), FALSE);

  00720	6a 00		 push	 0
  00722	68 11 04 00 00	 push	 1041			; 00000411H
  00727	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0072d	ff d3		 call	 ebx
  0072f	50		 push	 eax
  00730	ff d6		 call	 esi

; 3962 : 			EnableWindow (GetDlgItem (MainDlg, IDCANCEL), FALSE);

  00732	6a 00		 push	 0
  00734	6a 02		 push	 2
  00736	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0073c	ff d3		 call	 ebx
  0073e	50		 push	 eax
  0073f	ff d6		 call	 esi

; 3963 : 
; 3964 : 			LoadSettings (hwndDlg);

  00741	8b 9d 7c eb fe
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00747	53		 push	 ebx
  00748	e8 00 00 00 00	 call	 _LoadSettings
  0074d	83 c4 04	 add	 esp, 4

; 3965 : 
; 3966 : 			if (HiddenSectorDetectionStatus == 1)

  00750	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _HiddenSectorDetectionStatus, 1
  00757	0f 85 83 00 00
	00		 jne	 $LN6@PageDialog

; 3967 : 			{
; 3968 : 				// Detection of hidden sectors was already in progress but it did not finish successfully.
; 3969 : 				// Ask the user if he wants to try again (to prevent repeated system freezing, etc.)
; 3970 : 
; 3971 : 				char *tmpStr[] = {0, "HIDDEN_SECTOR_DETECTION_FAILED_PREVIOUSLY", "SKIP_HIDDEN_SECTOR_DETECTION", "RETRY_HIDDEN_SECTOR_DETECTION", "IDC_EXIT", 0};
; 3972 : 				switch (AskMultiChoice ((void **) tmpStr, FALSE))

  0075d	8d 85 c8 ed fe
	ff		 lea	 eax, DWORD PTR _tmpStr$20[ebp]
  00763	c7 85 c8 ed fe
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$20[ebp], 0
  0076d	6a 00		 push	 0
  0076f	50		 push	 eax
  00770	c7 85 cc ed fe
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$20[ebp+4], OFFSET ??_C@_0CK@KEHMFNIA@HIDDEN_SECTOR_DETECTION_FAILED_P@
  0077a	c7 85 d0 ed fe
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$20[ebp+8], OFFSET ??_C@_0BN@GHOENGPC@SKIP_HIDDEN_SECTOR_DETECTION?$AA@
  00784	c7 85 d4 ed fe
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$20[ebp+12], OFFSET ??_C@_0BO@OEFOGNPK@RETRY_HIDDEN_SECTOR_DETECTION?$AA@
  0078e	c7 85 d8 ed fe
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$20[ebp+16], OFFSET ??_C@_08HBBNJJLH@IDC_EXIT?$AA@
  00798	c7 85 dc ed fe
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$20[ebp+20], 0
  007a2	e8 00 00 00 00	 call	 _AskMultiChoice
  007a7	83 c4 08	 add	 esp, 8
  007aa	83 e8 01	 sub	 eax, 1
  007ad	74 1a		 je	 SHORT $LN60@PageDialog
  007af	83 e8 01	 sub	 eax, 1
  007b2	74 2c		 je	 SHORT $LN6@PageDialog

; 3978 : 
; 3979 : 				case 2:
; 3980 : 					// Try again
; 3981 : 					break;
; 3982 : 
; 3983 : 				default:
; 3984 : 					EndMainDlg (MainDlg);

  007b4	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  007ba	e8 00 00 00 00	 call	 _EndMainDlg
  007bf	83 c4 04	 add	 esp, 4

; 3985 : 					return 0;

  007c2	33 c0		 xor	 eax, eax
  007c4	e9 ff 4b 00 00	 jmp	 $LN1@PageDialog
$LN60@PageDialog:

; 3973 : 				{
; 3974 : 				case 1:
; 3975 : 					// Do not try again
; 3976 : 					LoadPage (MainDlg, SYSENC_DRIVE_ANALYSIS_PAGE + 1);

  007c9	6a 06		 push	 6
  007cb	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  007d1	e8 00 00 00 00	 call	 _LoadPage
  007d6	83 c4 08	 add	 esp, 8
$LN384@PageDialog:

; 3977 : 					return 0;

  007d9	33 c0		 xor	 eax, eax
  007db	e9 e8 4b 00 00	 jmp	 $LN1@PageDialog
$LN6@PageDialog:

; 3986 : 				}
; 3987 : 			}
; 3988 : 
; 3989 : 			SetTimer (MainDlg, TIMER_ID_SYSENC_DRIVE_ANALYSIS_PROGRESS, TIMER_INTERVAL_SYSENC_DRIVE_ANALYSIS_PROGRESS, NULL);

  007e0	6a 00		 push	 0
  007e2	6a 64		 push	 100			; 00000064H
  007e4	68 03 01 00 00	 push	 259			; 00000103H
  007e9	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  007ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 3990 : 			bSysEncDriveAnalysisInProgress = TRUE;

  007f5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSysEncDriveAnalysisInProgress@@3HC, 1 ; bSysEncDriveAnalysisInProgress

; 3991 : 			ArrowWaitCursor ();

  007ff	e8 00 00 00 00	 call	 _ArrowWaitCursor

; 3992 : 			SysEncDriveAnalysisStart = GetTickCount ();

  00804	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 3993 : 			InitProgressBar (SYSENC_DRIVE_ANALYSIS_ETA, 0, FALSE, FALSE, FALSE, TRUE);

  0080a	6a 01		 push	 1
  0080c	6a 00		 push	 0
  0080e	6a 00		 push	 0
  00810	6a 00		 push	 0
  00812	6a 00		 push	 0
  00814	6a 00		 push	 0
  00816	6a 00		 push	 0
  00818	68 80 a9 03 00	 push	 240000			; 0003a980H
  0081d	a3 00 00 00 00	 mov	 DWORD PTR ?SysEncDriveAnalysisStart@@3HA, eax ; SysEncDriveAnalysisStart
  00822	e8 00 00 00 00	 call	 _InitProgressBar

; 3994 : 
; 3995 : 			_beginthread (sysEncDriveAnalysisThread, 0, hwndDlg);

  00827	53		 push	 ebx
  00828	6a 00		 push	 0
  0082a	68 00 00 00 00	 push	 OFFSET _sysEncDriveAnalysisThread
  0082f	e8 00 00 00 00	 call	 __beginthread
  00834	83 c4 2c	 add	 esp, 44			; 0000002cH
  00837	33 c0		 xor	 eax, eax
  00839	e9 8a 4b 00 00	 jmp	 $LN1@PageDialog
$LN63@PageDialog:

; 3996 : 
; 3997 : 			break;
; 3998 : 
; 3999 : 
; 4000 : 		case SYSENC_MULTI_BOOT_MODE_PAGE:
; 4001 : 
; 4002 : 			SendMessage (GetDlgItem (hwndDlg, IDC_SINGLE_BOOT), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  0083e	6a 01		 push	 1
  00840	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  00846	6a 30		 push	 48			; 00000030H
  00848	68 34 04 00 00	 push	 1076			; 00000434H
  0084d	53		 push	 ebx
  0084e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  00854	ff d3		 call	 ebx
  00856	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  0085c	50		 push	 eax
  0085d	ff d6		 call	 esi

; 4003 : 			SendMessage (GetDlgItem (hwndDlg, IDC_MULTI_BOOT), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  0085f	8b bd 7c eb fe
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00865	6a 01		 push	 1
  00867	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  0086d	6a 30		 push	 48			; 00000030H
  0086f	68 35 04 00 00	 push	 1077			; 00000435H
  00874	57		 push	 edi
  00875	ff d3		 call	 ebx
  00877	50		 push	 eax
  00878	ff d6		 call	 esi

; 4004 : 
; 4005 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYS_MULTI_BOOT_MODE_TITLE"));

  0087a	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@NAIABFPC@SYS_MULTI_BOOT_MODE_TITLE?$AA@
  0087f	e8 00 00 00 00	 call	 _GetString
  00884	83 c4 04	 add	 esp, 4
  00887	50		 push	 eax
  00888	68 e8 03 00 00	 push	 1000			; 000003e8H
  0088d	57		 push	 edi
  0088e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  00894	ff d7		 call	 edi
  00896	50		 push	 eax
  00897	ff d3		 call	 ebx
  00899	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  0089f	50		 push	 eax
  008a0	ff d6		 call	 esi

; 4006 : 
; 4007 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  008a2	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  008a7	e8 00 00 00 00	 call	 _GetString
  008ac	83 c4 04	 add	 esp, 4
  008af	50		 push	 eax
  008b0	68 10 04 00 00	 push	 1040			; 00000410H
  008b5	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  008bb	ff d7		 call	 edi
  008bd	50		 push	 eax
  008be	ff d3		 call	 ebx
  008c0	50		 push	 eax
  008c1	ff d6		 call	 esi

; 4008 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  008c3	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  008c8	e8 00 00 00 00	 call	 _GetString
  008cd	83 c4 04	 add	 esp, 4
  008d0	50		 push	 eax
  008d1	68 11 04 00 00	 push	 1041			; 00000411H
  008d6	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  008dc	ff d7		 call	 edi
  008de	50		 push	 eax
  008df	ff d3		 call	 ebx
  008e1	50		 push	 eax
  008e2	ff d6		 call	 esi

; 4009 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("CANCEL"));

  008e4	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  008e9	e8 00 00 00 00	 call	 _GetString
  008ee	83 c4 04	 add	 esp, 4
  008f1	50		 push	 eax
  008f2	6a 02		 push	 2
  008f4	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  008fa	ff d7		 call	 edi
  008fc	50		 push	 eax
  008fd	ff d3		 call	 ebx
  008ff	50		 push	 eax
  00900	ff d6		 call	 esi

; 4010 : 
; 4011 : 			RefreshMultiBootControls (hwndDlg);

  00902	8b b5 7c eb fe
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00908	56		 push	 esi
  00909	e8 00 00 00 00	 call	 ?RefreshMultiBootControls@@YAXPAUHWND__@@@Z ; RefreshMultiBootControls
  0090e	83 c4 04	 add	 esp, 4

; 4012 : 
; 4013 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), nMultiBoot > 0);

  00911	33 c0		 xor	 eax, eax
  00913	39 05 00 00 00
	00		 cmp	 DWORD PTR ?nMultiBoot@@3HA, eax ; nMultiBoot
  00919	0f 9f c0	 setg	 al
  0091c	50		 push	 eax
  0091d	68 10 04 00 00	 push	 1040			; 00000410H
  00922	56		 push	 esi
  00923	ff d7		 call	 edi
  00925	50		 push	 eax
  00926	ff d3		 call	 ebx
  00928	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  0092e	50		 push	 eax
  0092f	ff d6		 call	 esi

; 4014 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00931	6a 01		 push	 1
  00933	68 11 04 00 00	 push	 1041			; 00000411H
  00938	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0093e	ff d7		 call	 edi
  00940	50		 push	 eax
  00941	ff d3		 call	 ebx
  00943	50		 push	 eax
  00944	ff d6		 call	 esi

; 4015 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  00946	6a 01		 push	 1
  00948	6a 02		 push	 2
  0094a	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00950	ff d7		 call	 edi
  00952	50		 push	 eax
  00953	ff d3		 call	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00955	50		 push	 eax
  00956	ff d6		 call	 esi
  00958	33 c0		 xor	 eax, eax
  0095a	e9 69 4a 00 00	 jmp	 $LN1@PageDialog
$LN64@PageDialog:

; 4016 : 			break;
; 4017 : 
; 4018 : 
; 4019 : 		case SYSENC_MULTI_BOOT_SYS_EQ_BOOT_PAGE:
; 4020 : 
; 4021 : 			Init2RadButtonPageYesNo (SysEncMultiBootCfg.SystemOnBootDrive);

  0095f	ff 35 10 00 00
	00		 push	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A+16
  00965	e8 00 00 00 00	 call	 ?Init2RadButtonPageYesNo@@YAXH@Z ; Init2RadButtonPageYesNo

; 4022 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_MULTI_BOOT_SYS_EQ_BOOT_TITLE"));

  0096a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HOKCHJKA@SYSENC_MULTI_BOOT_SYS_EQ_BOOT_TI@
  0096f	e8 00 00 00 00	 call	 _GetString
  00974	83 c4 08	 add	 esp, 8
  00977	50		 push	 eax
  00978	68 e8 03 00 00	 push	 1000			; 000003e8H
  0097d	53		 push	 ebx
  0097e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00984	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0098a	50		 push	 eax
  0098b	ff d7		 call	 edi
  0098d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00993	50		 push	 eax
  00994	ff d6		 call	 esi

; 4023 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYSENC_MULTI_BOOT_SYS_EQ_BOOT_HELP"));

  00996	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ODHMCLM@SYSENC_MULTI_BOOT_SYS_EQ_BOOT_HE@
  0099b	e8 00 00 00 00	 call	 _GetString
  009a0	83 c4 04	 add	 esp, 4
  009a3	50		 push	 eax
  009a4	68 eb 03 00 00	 push	 1003			; 000003ebH
  009a9	53		 push	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  009aa	ff d7		 call	 edi
  009ac	50		 push	 eax
  009ad	ff d6		 call	 esi
  009af	33 c0		 xor	 eax, eax
  009b1	e9 12 4a 00 00	 jmp	 $LN1@PageDialog
$LN65@PageDialog:

; 4024 : 			break;
; 4025 : 
; 4026 : 
; 4027 : 		case SYSENC_MULTI_BOOT_NBR_SYS_DRIVES_PAGE:
; 4028 : 
; 4029 : 			SetWindowTextW (GetDlgItem (hCurPage, IDC_CHOICE1), GetString ("DIGIT_ONE"));

  009b6	68 00 00 00 00	 push	 OFFSET ??_C@_09BCPPDPEL@DIGIT_ONE?$AA@
  009bb	e8 00 00 00 00	 call	 _GetString
  009c0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  009c6	83 c4 04	 add	 esp, 4
  009c9	50		 push	 eax
  009ca	68 dd 13 00 00	 push	 5085			; 000013ddH
  009cf	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  009d5	ff d7		 call	 edi
  009d7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  009dd	50		 push	 eax
  009de	ff d6		 call	 esi

; 4030 : 			SetWindowTextW (GetDlgItem (hCurPage, IDC_CHOICE2), GetString ("TWO_OR_MORE"));

  009e0	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BAIFEFDO@TWO_OR_MORE?$AA@
  009e5	e8 00 00 00 00	 call	 _GetString
  009ea	83 c4 04	 add	 esp, 4
  009ed	50		 push	 eax
  009ee	68 df 13 00 00	 push	 5087			; 000013dfH
  009f3	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  009f9	ff d7		 call	 edi
  009fb	50		 push	 eax
  009fc	ff d6		 call	 esi

; 4031 : 
; 4032 : 			SetWindowTextW (GetDlgItem (MainDlg, IDC_NEXT), GetString ("NEXT"));

  009fe	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00a03	e8 00 00 00 00	 call	 _GetString
  00a08	83 c4 04	 add	 esp, 4
  00a0b	50		 push	 eax
  00a0c	68 10 04 00 00	 push	 1040			; 00000410H
  00a11	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00a17	ff d7		 call	 edi
  00a19	50		 push	 eax
  00a1a	ff d6		 call	 esi

; 4033 : 			SetWindowTextW (GetDlgItem (MainDlg, IDC_PREV), GetString ("PREV"));

  00a1c	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  00a21	e8 00 00 00 00	 call	 _GetString
  00a26	83 c4 04	 add	 esp, 4
  00a29	50		 push	 eax
  00a2a	68 11 04 00 00	 push	 1041			; 00000411H
  00a2f	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00a35	ff d7		 call	 edi
  00a37	50		 push	 eax
  00a38	ff d6		 call	 esi

; 4034 : 			SetWindowTextW (GetDlgItem (MainDlg, IDCANCEL), GetString ("CANCEL"));

  00a3a	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  00a3f	e8 00 00 00 00	 call	 _GetString
  00a44	83 c4 04	 add	 esp, 4
  00a47	50		 push	 eax
  00a48	6a 02		 push	 2
  00a4a	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00a50	ff d7		 call	 edi
  00a52	50		 push	 eax
  00a53	ff d6		 call	 esi

; 4035 : 
; 4036 : 			EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), SysEncMultiBootCfg.NumberOfSysDrives > 0);

  00a55	33 c0		 xor	 eax, eax
  00a57	39 05 00 00 00
	00		 cmp	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A, eax
  00a5d	0f 9f c0	 setg	 al
  00a60	50		 push	 eax
  00a61	68 10 04 00 00	 push	 1040			; 00000410H
  00a66	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00a6c	ff d7		 call	 edi
  00a6e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00a74	50		 push	 eax
  00a75	ff d6		 call	 esi

; 4037 : 			EnableWindow (GetDlgItem (MainDlg, IDC_PREV), TRUE);

  00a77	6a 01		 push	 1
  00a79	68 11 04 00 00	 push	 1041			; 00000411H
  00a7e	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00a84	ff d7		 call	 edi
  00a86	50		 push	 eax
  00a87	ff d6		 call	 esi

; 4038 : 
; 4039 : 			if (SysEncMultiBootCfg.NumberOfSysDrives == 2)

  00a89	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A

; 4040 : 				Update2RadButtonPage (0); // 2 or more drives contain an OS

  00a8e	6a 00		 push	 0
  00a90	83 f8 02	 cmp	 eax, 2
  00a93	75 23		 jne	 SHORT $LN66@PageDialog
  00a95	6a 00		 push	 0
  00a97	68 f1 00 00 00	 push	 241			; 000000f1H
  00a9c	68 dd 13 00 00	 push	 5085			; 000013ddH
  00aa1	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00aa7	ff d7		 call	 edi
  00aa9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  00aaf	50		 push	 eax
  00ab0	ff d6		 call	 esi
  00ab2	6a 00		 push	 0
  00ab4	6a 01		 push	 1
  00ab6	eb 29		 jmp	 SHORT $LN743@PageDialog
$LN66@PageDialog:

; 4041 : 			else if (SysEncMultiBootCfg.NumberOfSysDrives == 1)

  00ab8	83 f8 01	 cmp	 eax, 1
  00abb	75 03		 jne	 SHORT $LN68@PageDialog

; 4042 : 				Update2RadButtonPage (1); // Only 1 drive contains an OS

  00abd	50		 push	 eax

; 4043 : 			else

  00abe	eb 02		 jmp	 SHORT $LN744@PageDialog
$LN68@PageDialog:

; 4044 : 				Update2RadButtonPage (-1);

  00ac0	6a 00		 push	 0
$LN744@PageDialog:
  00ac2	68 f1 00 00 00	 push	 241			; 000000f1H
  00ac7	68 dd 13 00 00	 push	 5085			; 000013ddH
  00acc	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00ad2	ff d7		 call	 edi
  00ad4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  00ada	50		 push	 eax
  00adb	ff d6		 call	 esi
  00add	6a 00		 push	 0
  00adf	6a 00		 push	 0
$LN743@PageDialog:
  00ae1	68 f1 00 00 00	 push	 241			; 000000f1H
  00ae6	68 df 13 00 00	 push	 5087			; 000013dfH
  00aeb	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00af1	ff d7		 call	 edi
  00af3	50		 push	 eax
  00af4	ff d6		 call	 esi

; 4045 : 
; 4046 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_MULTI_BOOT_NBR_SYS_DRIVES_TITLE"));

  00af6	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@IMKPMBEM@SYSENC_MULTI_BOOT_NBR_SYS_DRIVES@
  00afb	e8 00 00 00 00	 call	 _GetString
  00b00	83 c4 04	 add	 esp, 4
  00b03	50		 push	 eax
  00b04	68 e8 03 00 00	 push	 1000			; 000003e8H
  00b09	53		 push	 ebx
  00b0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00b10	50		 push	 eax
  00b11	ff d7		 call	 edi
  00b13	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00b19	50		 push	 eax
  00b1a	ff d6		 call	 esi

; 4047 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYSENC_MULTI_BOOT_NBR_SYS_DRIVES_HELP"));

  00b1c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GBIPGAOP@SYSENC_MULTI_BOOT_NBR_SYS_DRIVES@
  00b21	e8 00 00 00 00	 call	 _GetString
  00b26	83 c4 04	 add	 esp, 4
  00b29	50		 push	 eax
  00b2a	68 eb 03 00 00	 push	 1003			; 000003ebH
  00b2f	53		 push	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00b30	ff d7		 call	 edi
  00b32	50		 push	 eax
  00b33	ff d6		 call	 esi
  00b35	33 c0		 xor	 eax, eax
  00b37	e9 8c 48 00 00	 jmp	 $LN1@PageDialog
$LN70@PageDialog:

; 4048 : 			break;
; 4049 : 
; 4050 : 
; 4051 : 		case SYSENC_MULTI_BOOT_ADJACENT_SYS_PAGE:
; 4052 : 
; 4053 : 			Init2RadButtonPageYesNo (SysEncMultiBootCfg.MultipleSystemsOnDrive);

  00b3c	ff 35 04 00 00
	00		 push	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A+4
  00b42	e8 00 00 00 00	 call	 ?Init2RadButtonPageYesNo@@YAXH@Z ; Init2RadButtonPageYesNo

; 4054 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_MULTI_BOOT_ADJACENT_SYS_TITLE"));

  00b47	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MINJEEM@SYSENC_MULTI_BOOT_ADJACENT_SYS_T@
  00b4c	e8 00 00 00 00	 call	 _GetString
  00b51	83 c4 08	 add	 esp, 8
  00b54	50		 push	 eax
  00b55	68 e8 03 00 00	 push	 1000			; 000003e8H
  00b5a	53		 push	 ebx
  00b5b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00b61	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00b67	50		 push	 eax
  00b68	ff d7		 call	 edi
  00b6a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00b70	50		 push	 eax
  00b71	ff d6		 call	 esi

; 4055 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYSENC_MULTI_BOOT_ADJACENT_SYS_HELP"));

  00b73	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CGLNKLHK@SYSENC_MULTI_BOOT_ADJACENT_SYS_H@
  00b78	e8 00 00 00 00	 call	 _GetString
  00b7d	83 c4 04	 add	 esp, 4
  00b80	50		 push	 eax
  00b81	68 eb 03 00 00	 push	 1003			; 000003ebH
  00b86	53		 push	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00b87	ff d7		 call	 edi
  00b89	50		 push	 eax
  00b8a	ff d6		 call	 esi
  00b8c	33 c0		 xor	 eax, eax
  00b8e	e9 35 48 00 00	 jmp	 $LN1@PageDialog
$LN71@PageDialog:

; 4056 : 			break;
; 4057 : 
; 4058 : 
; 4059 : 		case SYSENC_MULTI_BOOT_NONWIN_BOOT_LOADER_PAGE:
; 4060 : 
; 4061 : 			Init2RadButtonPageYesNo (SysEncMultiBootCfg.BootLoaderBrand);

  00b93	ff 35 0c 00 00
	00		 push	 DWORD PTR ?SysEncMultiBootCfg@@3USYSENC_MULTIBOOT_CFG@@A+12
  00b99	e8 00 00 00 00	 call	 ?Init2RadButtonPageYesNo@@YAXH@Z ; Init2RadButtonPageYesNo

; 4062 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_MULTI_BOOT_NONWIN_BOOT_LOADER_TITLE"));

  00b9e	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@PKMEBLJM@SYSENC_MULTI_BOOT_NONWIN_BOOT_LO@
  00ba3	e8 00 00 00 00	 call	 _GetString
  00ba8	83 c4 08	 add	 esp, 8
  00bab	50		 push	 eax
  00bac	68 e8 03 00 00	 push	 1000			; 000003e8H
  00bb1	53		 push	 ebx
  00bb2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00bb8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00bbe	50		 push	 eax
  00bbf	ff d7		 call	 edi
  00bc1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00bc7	50		 push	 eax
  00bc8	ff d6		 call	 esi

; 4063 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYSENC_MULTI_BOOT_NONWIN_BOOT_LOADER_HELP"));

  00bca	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NGBECAKP@SYSENC_MULTI_BOOT_NONWIN_BOOT_LO@
  00bcf	e8 00 00 00 00	 call	 _GetString
  00bd4	83 c4 04	 add	 esp, 4
  00bd7	50		 push	 eax
  00bd8	68 eb 03 00 00	 push	 1003			; 000003ebH
  00bdd	53		 push	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00bde	ff d7		 call	 edi
  00be0	50		 push	 eax
  00be1	ff d6		 call	 esi
  00be3	33 c0		 xor	 eax, eax
  00be5	e9 de 47 00 00	 jmp	 $LN1@PageDialog
$LN72@PageDialog:

; 4064 : 			break;
; 4065 : 
; 4066 : 
; 4067 : 		case SYSENC_MULTI_BOOT_OUTCOME_PAGE:
; 4068 : 
; 4069 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_MULTI_BOOT_OUTCOME_TITLE"));

  00bea	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FOODICMO@SYSENC_MULTI_BOOT_OUTCOME_TITLE?$AA@
  00bef	e8 00 00 00 00	 call	 _GetString
  00bf4	83 c4 04	 add	 esp, 4
  00bf7	50		 push	 eax
  00bf8	68 e8 03 00 00	 push	 1000			; 000003e8H
  00bfd	53		 push	 ebx
  00bfe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00c04	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00c0a	50		 push	 eax
  00c0b	ff d7		 call	 edi
  00c0d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00c13	50		 push	 eax
  00c14	ff d6		 call	 esi

; 4070 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), SysEncMultiBootCfgOutcome);

  00c16	68 00 00 00 00	 push	 OFFSET ?SysEncMultiBootCfgOutcome@@3PA_WA ; SysEncMultiBootCfgOutcome
  00c1b	68 eb 03 00 00	 push	 1003			; 000003ebH
  00c20	53		 push	 ebx
  00c21	ff d7		 call	 edi
  00c23	50		 push	 eax
  00c24	ff d6		 call	 esi

; 4071 : 			SetWindowTextW (GetDlgItem (MainDlg, IDC_NEXT), GetString ("NEXT"));

  00c26	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00c2b	e8 00 00 00 00	 call	 _GetString
  00c30	83 c4 04	 add	 esp, 4
  00c33	50		 push	 eax
  00c34	68 10 04 00 00	 push	 1040			; 00000410H
  00c39	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00c3f	ff d7		 call	 edi
  00c41	50		 push	 eax
  00c42	ff d6		 call	 esi

; 4072 : 			SetWindowTextW (GetDlgItem (MainDlg, IDC_PREV), GetString ("PREV"));

  00c44	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  00c49	e8 00 00 00 00	 call	 _GetString
  00c4e	83 c4 04	 add	 esp, 4
  00c51	50		 push	 eax
  00c52	68 11 04 00 00	 push	 1041			; 00000411H
  00c57	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00c5d	ff d7		 call	 edi
  00c5f	50		 push	 eax
  00c60	ff d6		 call	 esi

; 4073 : 			SetWindowTextW (GetDlgItem (MainDlg, IDCANCEL), GetString ("CANCEL"));

  00c62	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  00c67	e8 00 00 00 00	 call	 _GetString
  00c6c	83 c4 04	 add	 esp, 4
  00c6f	50		 push	 eax
  00c70	6a 02		 push	 2
  00c72	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00c78	ff d7		 call	 edi
  00c7a	50		 push	 eax
  00c7b	ff d6		 call	 esi

; 4074 : 			EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), TRUE);

  00c7d	6a 01		 push	 1
  00c7f	68 10 04 00 00	 push	 1040			; 00000410H
  00c84	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00c8a	ff d7		 call	 edi
  00c8c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00c92	50		 push	 eax
  00c93	ff d6		 call	 esi

; 4075 : 			EnableWindow (GetDlgItem (MainDlg, IDC_PREV), TRUE);

  00c95	6a 01		 push	 1
  00c97	68 11 04 00 00	 push	 1041			; 00000411H
  00c9c	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00ca2	ff d7		 call	 edi
  00ca4	50		 push	 eax
  00ca5	ff d6		 call	 esi
  00ca7	33 c0		 xor	 eax, eax
  00ca9	e9 1a 47 00 00	 jmp	 $LN1@PageDialog
$LN73@PageDialog:

; 4076 : 			break;
; 4077 : 
; 4078 : 
; 4079 : 		case VOLUME_TYPE_PAGE:
; 4080 : 
; 4081 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("VOLUME_TYPE_TITLE"));

  00cae	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@IMPHNJMH@VOLUME_TYPE_TITLE?$AA@
  00cb3	e8 00 00 00 00	 call	 _GetString
  00cb8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  00cbe	83 c4 04	 add	 esp, 4
  00cc1	50		 push	 eax
  00cc2	68 e8 03 00 00	 push	 1000			; 000003e8H
  00cc7	53		 push	 ebx
  00cc8	ff d7		 call	 edi
  00cca	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00cd0	50		 push	 eax
  00cd1	ff d6		 call	 esi
  00cd3	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SetWindowTextW@8
  00cd9	50		 push	 eax
  00cda	ff d3		 call	 ebx

; 4082 : 
; 4083 : 			SendMessage (GetDlgItem (hwndDlg, IDC_HIDDEN_VOL), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  00cdc	6a 01		 push	 1
  00cde	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  00ce4	6a 30		 push	 48			; 00000030H
  00ce6	68 08 04 00 00	 push	 1032			; 00000408H
  00ceb	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00cf1	ff d6		 call	 esi
  00cf3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  00cf9	50		 push	 eax
  00cfa	ff d6		 call	 esi

; 4084 : 			SendMessage (GetDlgItem (hwndDlg, IDC_STD_VOL), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  00cfc	6a 01		 push	 1
  00cfe	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  00d04	6a 30		 push	 48			; 00000030H
  00d06	68 07 04 00 00	 push	 1031			; 00000407H
  00d0b	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00d11	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00d17	50		 push	 eax
  00d18	ff d6		 call	 esi

; 4085 : 
; 4086 : 			CheckButton (GetDlgItem (hwndDlg, bHiddenVol ? IDC_HIDDEN_VOL : IDC_STD_VOL));

  00d1a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenVol@@3HC ; bHiddenVol
  00d1f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00d25	f7 d8		 neg	 eax
  00d27	1b c0		 sbb	 eax, eax
  00d29	f7 d8		 neg	 eax
  00d2b	05 07 04 00 00	 add	 eax, 1031		; 00000407H
  00d30	50		 push	 eax
  00d31	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00d37	ff d6		 call	 esi
  00d39	50		 push	 eax
  00d3a	e8 00 00 00 00	 call	 _CheckButton

; 4087 : 
; 4088 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("HIDDEN_VOLUME_TYPE_HELP"));

  00d3f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OMMJFNJB@HIDDEN_VOLUME_TYPE_HELP?$AA@
  00d44	e8 00 00 00 00	 call	 _GetString
  00d49	83 c4 08	 add	 esp, 8
  00d4c	50		 push	 eax
  00d4d	68 eb 03 00 00	 push	 1003			; 000003ebH
  00d52	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00d58	ff d6		 call	 esi
  00d5a	50		 push	 eax
  00d5b	ff d3		 call	 ebx

; 4089 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP_NORMAL_VOL), GetString ("NORMAL_VOLUME_TYPE_HELP"));

  00d5d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OKEJAKDK@NORMAL_VOLUME_TYPE_HELP?$AA@
  00d62	e8 00 00 00 00	 call	 _GetString
  00d67	83 c4 04	 add	 esp, 4
  00d6a	50		 push	 eax
  00d6b	68 44 04 00 00	 push	 1092			; 00000444H
  00d70	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00d76	ff d6		 call	 esi
  00d78	50		 push	 eax
  00d79	ff d3		 call	 ebx

; 4090 : 
; 4091 : 			ToHyperlink (hwndDlg, IDC_HIDDEN_VOL_HELP);

  00d7b	68 09 04 00 00	 push	 1033			; 00000409H
  00d80	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00d86	e8 00 00 00 00	 call	 _ToHyperlink
  00d8b	83 c4 08	 add	 esp, 8

; 4092 : 
; 4093 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  00d8e	6a 01		 push	 1
  00d90	68 10 04 00 00	 push	 1040			; 00000410H
  00d95	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00d9b	ff d7		 call	 edi
  00d9d	50		 push	 eax
  00d9e	ff d6		 call	 esi
  00da0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00da6	50		 push	 eax
  00da7	ff d6		 call	 esi

; 4094 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00da9	6a 01		 push	 1
  00dab	68 11 04 00 00	 push	 1041			; 00000411H
  00db0	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00db6	ff d7		 call	 edi
  00db8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00dbe	50		 push	 eax
  00dbf	ff d7		 call	 edi
  00dc1	50		 push	 eax
  00dc2	ff d6		 call	 esi

; 4095 : 
; 4096 : 			SetWindowTextW (GetDlgItem (MainDlg, IDC_NEXT), GetString ("NEXT"));

  00dc4	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00dc9	e8 00 00 00 00	 call	 _GetString
  00dce	83 c4 04	 add	 esp, 4
  00dd1	50		 push	 eax
  00dd2	68 10 04 00 00	 push	 1040			; 00000410H
  00dd7	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00ddd	ff d7		 call	 edi
  00ddf	50		 push	 eax
  00de0	ff d3		 call	 ebx

; 4097 : 			SetWindowTextW (GetDlgItem (MainDlg, IDC_PREV), GetString ("PREV"));

  00de2	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  00de7	e8 00 00 00 00	 call	 _GetString
  00dec	83 c4 04	 add	 esp, 4
  00def	50		 push	 eax
  00df0	68 11 04 00 00	 push	 1041			; 00000411H
  00df5	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00dfb	ff d7		 call	 edi
  00dfd	50		 push	 eax
  00dfe	ff d3		 call	 ebx

; 4098 : 			SetWindowTextW (GetDlgItem (MainDlg, IDCANCEL), GetString ("CANCEL"));

  00e00	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  00e05	e8 00 00 00 00	 call	 _GetString
  00e0a	83 c4 04	 add	 esp, 4
  00e0d	50		 push	 eax
  00e0e	6a 02		 push	 2
  00e10	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00e16	ff d7		 call	 edi
  00e18	50		 push	 eax
  00e19	ff d3		 call	 ebx
  00e1b	33 c0		 xor	 eax, eax
  00e1d	e9 a6 45 00 00	 jmp	 $LN1@PageDialog
$LN74@PageDialog:

; 4099 : 			break;
; 4100 : 
; 4101 : 		case HIDDEN_VOL_WIZARD_MODE_PAGE:
; 4102 : 
; 4103 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("HIDDEN_VOL_WIZARD_MODE_TITLE"));

  00e22	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@CFKNBCJG@HIDDEN_VOL_WIZARD_MODE_TITLE?$AA@
  00e27	e8 00 00 00 00	 call	 _GetString
  00e2c	83 c4 04	 add	 esp, 4
  00e2f	50		 push	 eax
  00e30	68 e8 03 00 00	 push	 1000			; 000003e8H
  00e35	53		 push	 ebx
  00e36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00e3c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  00e42	50		 push	 eax
  00e43	ff d3		 call	 ebx
  00e45	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetWindowTextW@8
  00e4b	50		 push	 eax
  00e4c	ff d7		 call	 edi

; 4104 : 
; 4105 : 			SendMessage (GetDlgItem (hwndDlg, IDC_HIDVOL_WIZ_MODE_DIRECT), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  00e4e	6a 01		 push	 1
  00e50	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  00e56	6a 30		 push	 48			; 00000030H
  00e58	68 0c 04 00 00	 push	 1036			; 0000040cH
  00e5d	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00e63	ff d3		 call	 ebx
  00e65	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  00e6b	50		 push	 eax
  00e6c	ff d6		 call	 esi

; 4106 : 			SendMessage (GetDlgItem (hwndDlg, IDC_HIDVOL_WIZ_MODE_FULL), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  00e6e	6a 01		 push	 1
  00e70	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  00e76	6a 30		 push	 48			; 00000030H
  00e78	68 0b 04 00 00	 push	 1035			; 0000040bH
  00e7d	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00e83	ff d3		 call	 ebx
  00e85	50		 push	 eax
  00e86	ff d6		 call	 esi

; 4107 : 
; 4108 : 			CheckButton (GetDlgItem (hwndDlg, bHiddenVolDirect ? IDC_HIDVOL_WIZ_MODE_DIRECT : IDC_HIDVOL_WIZ_MODE_FULL));

  00e88	a1 00 00 00 00	 mov	 eax, DWORD PTR _bHiddenVolDirect
  00e8d	8b b5 7c eb fe
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00e93	f7 d8		 neg	 eax
  00e95	1b c0		 sbb	 eax, eax
  00e97	f7 d8		 neg	 eax
  00e99	05 0b 04 00 00	 add	 eax, 1035		; 0000040bH
  00e9e	50		 push	 eax
  00e9f	56		 push	 esi
  00ea0	ff d3		 call	 ebx
  00ea2	50		 push	 eax
  00ea3	e8 00 00 00 00	 call	 _CheckButton

; 4109 : 
; 4110 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("HIDDEN_VOL_WIZARD_MODE_NORMAL_HELP"));

  00ea8	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LJCMOGBH@HIDDEN_VOL_WIZARD_MODE_NORMAL_HE@
  00ead	e8 00 00 00 00	 call	 _GetString
  00eb2	83 c4 08	 add	 esp, 8
  00eb5	50		 push	 eax
  00eb6	68 eb 03 00 00	 push	 1003			; 000003ebH
  00ebb	56		 push	 esi
  00ebc	ff d3		 call	 ebx
  00ebe	50		 push	 eax
  00ebf	ff d7		 call	 edi

; 4111 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP2), GetString ("HIDDEN_VOL_WIZARD_MODE_DIRECT_HELP"));

  00ec1	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BGGCLDPJ@HIDDEN_VOL_WIZARD_MODE_DIRECT_HE@
  00ec6	e8 00 00 00 00	 call	 _GetString
  00ecb	83 c4 04	 add	 esp, 4
  00ece	50		 push	 eax
  00ecf	68 ee 03 00 00	 push	 1006			; 000003eeH
  00ed4	56		 push	 esi
  00ed5	ff d3		 call	 ebx
  00ed7	50		 push	 eax
  00ed8	ff d7		 call	 edi

; 4112 : 
; 4113 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_HIDVOL_WIZ_MODE_DIRECT), TRUE);

  00eda	6a 01		 push	 1
  00edc	68 0c 04 00 00	 push	 1036			; 0000040cH
  00ee1	56		 push	 esi
  00ee2	ff d3		 call	 ebx
  00ee4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00eea	50		 push	 eax
  00eeb	ff d6		 call	 esi

; 4114 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_HIDVOL_WIZ_MODE_FULL), TRUE);

  00eed	6a 01		 push	 1
  00eef	68 0b 04 00 00	 push	 1035			; 0000040bH
  00ef4	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00efa	ff d3		 call	 ebx
  00efc	50		 push	 eax
  00efd	ff d6		 call	 esi

; 4115 : 
; 4116 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  00eff	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00f04	e8 00 00 00 00	 call	 _GetString
  00f09	83 c4 04	 add	 esp, 4
  00f0c	50		 push	 eax
  00f0d	68 10 04 00 00	 push	 1040			; 00000410H
  00f12	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00f18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00f1e	50		 push	 eax
  00f1f	ff d3		 call	 ebx
  00f21	50		 push	 eax
  00f22	ff d7		 call	 edi

; 4117 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  00f24	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  00f29	e8 00 00 00 00	 call	 _GetString
  00f2e	83 c4 04	 add	 esp, 4
  00f31	50		 push	 eax
  00f32	68 11 04 00 00	 push	 1041			; 00000411H
  00f37	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00f3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00f43	50		 push	 eax
  00f44	ff d3		 call	 ebx
  00f46	50		 push	 eax
  00f47	ff d7		 call	 edi

; 4118 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("CANCEL"));

  00f49	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  00f4e	e8 00 00 00 00	 call	 _GetString
  00f53	83 c4 04	 add	 esp, 4
  00f56	50		 push	 eax
  00f57	6a 02		 push	 2
  00f59	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00f5f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00f65	50		 push	 eax
  00f66	ff d3		 call	 ebx
  00f68	50		 push	 eax
  00f69	ff d7		 call	 edi

; 4119 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  00f6b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  00f71	6a 01		 push	 1
  00f73	68 10 04 00 00	 push	 1040			; 00000410H
  00f78	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00f7e	ff d7		 call	 edi
  00f80	50		 push	 eax
  00f81	ff d3		 call	 ebx

; 4120 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);
; 4121 : 
; 4122 : 			break;

  00f83	e9 5e f6 ff ff	 jmp	 $LN786@PageDialog
$LN75@PageDialog:

; 4123 : 
; 4124 : 		case VOLUME_LOCATION_PAGE:
; 4125 : 			{
; 4126 : 				char *nID;
; 4127 : 
; 4128 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_SELECT_VOLUME_LOCATION),

  00f88	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  00f8f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BA@HOMDJPL@IDC_SELECT_FILE?$AA@
  00f94	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@NHEENOIC@IDC_SELECT_DEVICE?$AA@
  00f99	0f 44 c1	 cmove	 eax, ecx
  00f9c	50		 push	 eax
  00f9d	e8 00 00 00 00	 call	 _GetString
  00fa2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00fa8	83 c4 04	 add	 esp, 4
  00fab	50		 push	 eax
  00fac	68 0f 04 00 00	 push	 1039			; 0000040fH
  00fb1	53		 push	 ebx
  00fb2	ff d7		 call	 edi
  00fb4	50		 push	 eax
  00fb5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4129 : 					GetString (bDevice ? "IDC_SELECT_DEVICE" : "IDC_SELECT_FILE"));
; 4130 : 
; 4131 : 				if (bHiddenVolDirect && bHiddenVolHost)

  00fbb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolDirect, 0
  00fc2	74 15		 je	 SHORT $LN76@PageDialog
  00fc4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00fcb	74 0c		 je	 SHORT $LN76@PageDialog

; 4132 : 				{
; 4133 : 					nID = "FILE_HELP_HIDDEN_HOST_VOL_DIRECT";

  00fcd	c7 85 7c eb fe
	ff 00 00 00 00	 mov	 DWORD PTR _nID$1$[ebp], OFFSET ??_C@_0CB@LOIOBDOO@FILE_HELP_HIDDEN_HOST_VOL_DIRECT@

; 4134 : 				}
; 4135 : 				else

  00fd7	eb 2f		 jmp	 SHORT $LN79@PageDialog
$LN76@PageDialog:

; 4136 : 				{
; 4137 : 					if (bDevice)

  00fd9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice

; 4138 : 						nID = bHiddenVolHost ? "DEVICE_HELP_HIDDEN_HOST_VOL" : "DEVICE_HELP";

  00fe0	a1 00 00 00 00	 mov	 eax, DWORD PTR _bHiddenVolHost
  00fe5	74 0c		 je	 SHORT $LN78@PageDialog
  00fe7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BM@DMHDGBOJ@DEVICE_HELP_HIDDEN_HOST_VOL?$AA@
  00fec	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@JNOAPEGE@DEVICE_HELP?$AA@

; 4139 : 					else

  00ff1	eb 0a		 jmp	 SHORT $LN745@PageDialog
$LN78@PageDialog:

; 4140 : 						nID = bHiddenVolHost ? "FILE_HELP_HIDDEN_HOST_VOL" : "FILE_HELP";

  00ff3	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BK@JMGOJAKG@FILE_HELP_HIDDEN_HOST_VOL?$AA@
  00ff8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_09GPELPABL@FILE_HELP?$AA@
$LN745@PageDialog:
  00ffd	85 c0		 test	 eax, eax
  00fff	0f 44 ca	 cmove	 ecx, edx
  01002	89 8d 7c eb fe
	ff		 mov	 DWORD PTR _nID$1$[ebp], ecx
$LN79@PageDialog:

; 4141 : 				}
; 4142 : 
; 4143 : 				SendMessage (GetDlgItem (hwndDlg, IDC_COMBO_BOX), CB_RESETCONTENT, 0, 0);

  01008	6a 00		 push	 0
  0100a	6a 00		 push	 0
  0100c	68 4b 01 00 00	 push	 331			; 0000014bH
  01011	68 ea 03 00 00	 push	 1002			; 000003eaH
  01016	53		 push	 ebx
  01017	ff d7		 call	 edi
  01019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  0101f	50		 push	 eax
  01020	ff d6		 call	 esi

; 4144 : 
; 4145 : 				SendMessage (GetDlgItem (hwndDlg, IDC_COMBO_BOX), CB_LIMITTEXT, GST_MAX_PATH, 0);

  01022	6a 00		 push	 0
  01024	68 04 01 00 00	 push	 260			; 00000104H
  01029	68 41 01 00 00	 push	 321			; 00000141H
  0102e	68 ea 03 00 00	 push	 1002			; 000003eaH
  01033	53		 push	 ebx
  01034	ff d7		 call	 edi
  01036	50		 push	 eax
  01037	ff d6		 call	 esi

; 4146 : 
; 4147 : 				LoadCombo (GetDlgItem (hwndDlg, IDC_COMBO_BOX));

  01039	68 ea 03 00 00	 push	 1002			; 000003eaH
  0103e	53		 push	 ebx
  0103f	ff d7		 call	 edi
  01041	50		 push	 eax
  01042	e8 00 00 00 00	 call	 _LoadCombo
  01047	83 c4 04	 add	 esp, 4

; 4148 : 
; 4149 : 				SendMessage (GetDlgItem (hwndDlg, IDC_NO_HISTORY), BM_SETCHECK, bHistory ? BST_UNCHECKED : BST_CHECKED, 0);

  0104a	33 c0		 xor	 eax, eax
  0104c	39 05 00 00 00
	00		 cmp	 DWORD PTR _bHistory, eax
  01052	0f 94 c0	 sete	 al
  01055	6a 00		 push	 0
  01057	50		 push	 eax
  01058	68 f1 00 00 00	 push	 241			; 000000f1H
  0105d	68 f4 03 00 00	 push	 1012			; 000003f4H
  01062	53		 push	 ebx
  01063	ff d7		 call	 edi
  01065	50		 push	 eax
  01066	ff d6		 call	 esi

; 4150 : 
; 4151 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("FILE_TITLE"));

  01068	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DGHBDDNJ@FILE_TITLE?$AA@
  0106d	e8 00 00 00 00	 call	 _GetString
  01072	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetParent@4
  01078	83 c4 04	 add	 esp, 4
  0107b	50		 push	 eax
  0107c	68 e8 03 00 00	 push	 1000			; 000003e8H
  01081	53		 push	 ebx
  01082	ff d6		 call	 esi
  01084	50		 push	 eax
  01085	ff d7		 call	 edi
  01087	50		 push	 eax
  01088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4152 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString (nID));

  0108e	ff b5 7c eb fe
	ff		 push	 DWORD PTR _nID$1$[ebp]
  01094	e8 00 00 00 00	 call	 _GetString
  01099	83 c4 04	 add	 esp, 4
  0109c	50		 push	 eax
  0109d	68 eb 03 00 00	 push	 1003			; 000003ebH
  010a2	53		 push	 ebx
  010a3	ff d7		 call	 edi
  010a5	50		 push	 eax
  010a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4153 : 
; 4154 : 				SetFocus (GetDlgItem (hwndDlg, IDC_COMBO_BOX));

  010ac	68 ea 03 00 00	 push	 1002			; 000003eaH
  010b1	53		 push	 ebx
  010b2	ff d7		 call	 edi
  010b4	50		 push	 eax
  010b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 4155 : 
; 4156 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  010bb	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  010c0	e8 00 00 00 00	 call	 _GetString
  010c5	83 c4 04	 add	 esp, 4
  010c8	50		 push	 eax
  010c9	68 10 04 00 00	 push	 1040			; 00000410H
  010ce	53		 push	 ebx
  010cf	ff d6		 call	 esi
  010d1	50		 push	 eax
  010d2	ff d7		 call	 edi
  010d4	50		 push	 eax
  010d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4157 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  010db	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  010e0	e8 00 00 00 00	 call	 _GetString
  010e5	83 c4 04	 add	 esp, 4
  010e8	50		 push	 eax
  010e9	68 11 04 00 00	 push	 1041			; 00000411H
  010ee	53		 push	 ebx
  010ef	ff d6		 call	 esi
  010f1	50		 push	 eax
  010f2	ff d7		 call	 edi
  010f4	50		 push	 eax
  010f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4158 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  010fb	6a 01		 push	 1
  010fd	68 11 04 00 00	 push	 1041			; 00000411H
  01102	53		 push	 ebx
  01103	ff d6		 call	 esi
  01105	50		 push	 eax
  01106	ff d7		 call	 edi
  01108	50		 push	 eax
  01109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4159 : 
; 4160 : 				AddComboItem (GetDlgItem (hwndDlg, IDC_COMBO_BOX), szFileName, bHistory);

  0110f	ff 35 00 00 00
	00		 push	 DWORD PTR _bHistory
  01115	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  0111a	68 ea 03 00 00	 push	 1002			; 000003eaH
  0111f	53		 push	 ebx
  01120	ff d7		 call	 edi
  01122	50		 push	 eax
  01123	e8 00 00 00 00	 call	 _AddComboItem
  01128	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4161 : 
; 4162 : 				EnableDisableFileNext (GetDlgItem (hwndDlg, IDC_COMBO_BOX),

  0112b	68 10 04 00 00	 push	 1040			; 00000410H
  01130	53		 push	 ebx
  01131	ff d6		 call	 esi
  01133	50		 push	 eax
  01134	ff d7		 call	 edi
  01136	50		 push	 eax
  01137	68 ea 03 00 00	 push	 1002			; 000003eaH
  0113c	53		 push	 ebx
  0113d	ff d7		 call	 edi
  0113f	50		 push	 eax
  01140	e8 00 00 00 00	 call	 _EnableDisableFileNext
  01145	83 c4 08	 add	 esp, 8
  01148	33 c0		 xor	 eax, eax
  0114a	e9 79 42 00 00	 jmp	 $LN1@PageDialog
$LN80@PageDialog:

; 4163 : 				GetDlgItem (GetParent (hwndDlg), IDC_NEXT));
; 4164 : 
; 4165 : 			}
; 4166 : 			break;
; 4167 : 
; 4168 : 		case DEVICE_TRANSFORM_MODE_PAGE:
; 4169 : 
; 4170 : 			if (!bDeviceTransformModeChoiceMade && !bInPlaceEncNonSys)

  0114f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDeviceTransformModeChoiceMade@@3HA, 0 ; bDeviceTransformModeChoiceMade
  01156	75 38		 jne	 SHORT $LN82@PageDialog
  01158	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  0115f	75 2f		 jne	 SHORT $LN82@PageDialog

; 4171 : 			{
; 4172 : 				// The user has not chosen whether to perform in-place encryption or format yet.
; 4173 : 				// We will preselect in-place encryption if the requirements are met and if the
; 4174 : 				// filesystem does not appear empty.
; 4175 : 
; 4176 : 				WaitCursor();

  01161	e8 00 00 00 00	 call	 _WaitCursor

; 4177 : 
; 4178 : 				if (CheckRequirementsForNonSysInPlaceEnc (szDiskFile, TRUE))

  01166	6a 01		 push	 1
  01168	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0116d	e8 00 00 00 00	 call	 _CheckRequirementsForNonSysInPlaceEnc
  01172	83 c4 08	 add	 esp, 8
  01175	85 c0		 test	 eax, eax
  01177	74 17		 je	 SHORT $LN82@PageDialog

; 4179 : 				{
; 4180 : 					bInPlaceEncNonSys = (FileSystemAppearsEmpty (szDiskFile) == 0);

  01179	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0117e	e8 00 00 00 00	 call	 _FileSystemAppearsEmpty
  01183	83 c4 04	 add	 esp, 4
  01186	f7 d8		 neg	 eax
  01188	1b c0		 sbb	 eax, eax
  0118a	40		 inc	 eax
  0118b	a3 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, eax
$LN82@PageDialog:

; 4181 : 				}
; 4182 : 			}
; 4183 : 
; 4184 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("DEVICE_TRANSFORM_MODE_PAGE_TITLE"));

  01190	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@IJHCDAO@DEVICE_TRANSFORM_MODE_PAGE_TITLE@
  01195	e8 00 00 00 00	 call	 _GetString
  0119a	83 c4 04	 add	 esp, 4
  0119d	50		 push	 eax
  0119e	68 e8 03 00 00	 push	 1000			; 000003e8H
  011a3	53		 push	 ebx
  011a4	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  011aa	ff d3		 call	 ebx
  011ac	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  011b2	50		 push	 eax
  011b3	ff d6		 call	 esi
  011b5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetWindowTextW@8
  011bb	50		 push	 eax
  011bc	ff d7		 call	 edi

; 4185 : 
; 4186 : 			SendMessage (GetDlgItem (hwndDlg, IDC_DEVICE_TRANSFORM_MODE_INPLACE), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  011be	6a 01		 push	 1
  011c0	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  011c6	6a 30		 push	 48			; 00000030H
  011c8	68 4e 04 00 00	 push	 1102			; 0000044eH
  011cd	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  011d3	ff d6		 call	 esi
  011d5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  011db	50		 push	 eax
  011dc	ff d6		 call	 esi

; 4187 : 			SendMessage (GetDlgItem (hwndDlg, IDC_DEVICE_TRANSFORM_MODE_FORMAT), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  011de	6a 01		 push	 1
  011e0	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  011e6	6a 30		 push	 48			; 00000030H
  011e8	68 4d 04 00 00	 push	 1101			; 0000044dH
  011ed	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  011f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  011f9	50		 push	 eax
  011fa	ff d6		 call	 esi

; 4188 : 
; 4189 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("DEVICE_TRANSFORM_MODE_PAGE_FORMAT_HELP"));

  011fc	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@CJGGIKCO@DEVICE_TRANSFORM_MODE_PAGE_FORMA@
  01201	e8 00 00 00 00	 call	 _GetString
  01206	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  0120c	83 c4 04	 add	 esp, 4
  0120f	50		 push	 eax
  01210	68 eb 03 00 00	 push	 1003			; 000003ebH
  01215	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0121b	ff d6		 call	 esi
  0121d	50		 push	 eax
  0121e	ff d7		 call	 edi

; 4190 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP2), GetString ("DEVICE_TRANSFORM_MODE_PAGE_INPLACE_HELP"));

  01220	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FGJIGFAK@DEVICE_TRANSFORM_MODE_PAGE_INPLA@
  01225	e8 00 00 00 00	 call	 _GetString
  0122a	83 c4 04	 add	 esp, 4
  0122d	50		 push	 eax
  0122e	68 ee 03 00 00	 push	 1006			; 000003eeH
  01233	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  01239	ff d6		 call	 esi
  0123b	50		 push	 eax
  0123c	ff d7		 call	 edi

; 4191 : 
; 4192 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  0123e	8b bd 7c eb fe
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  01244	6a 01		 push	 1
  01246	68 10 04 00 00	 push	 1040			; 00000410H
  0124b	57		 push	 edi
  0124c	ff d3		 call	 ebx
  0124e	50		 push	 eax
  0124f	ff d6		 call	 esi
  01251	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  01257	50		 push	 eax
  01258	ff d6		 call	 esi

; 4193 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  0125a	6a 01		 push	 1
  0125c	68 11 04 00 00	 push	 1041			; 00000411H
  01261	57		 push	 edi
  01262	ff d3		 call	 ebx
  01264	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  0126a	50		 push	 eax
  0126b	ff d3		 call	 ebx
  0126d	50		 push	 eax
  0126e	ff d6		 call	 esi

; 4194 : 
; 4195 : 			CheckButton (GetDlgItem (hwndDlg, bInPlaceEncNonSys ? IDC_DEVICE_TRANSFORM_MODE_INPLACE : IDC_DEVICE_TRANSFORM_MODE_FORMAT));

  01270	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  01275	f7 d8		 neg	 eax
  01277	1b c0		 sbb	 eax, eax
  01279	f7 d8		 neg	 eax
  0127b	05 4d 04 00 00	 add	 eax, 1101		; 0000044dH
  01280	50		 push	 eax
  01281	57		 push	 edi
  01282	ff d3		 call	 ebx
  01284	50		 push	 eax
  01285	e8 00 00 00 00	 call	 _CheckButton
  0128a	83 c4 04	 add	 esp, 4

; 4196 : 
; 4197 : 			NormalCursor();

  0128d	e8 00 00 00 00	 call	 _NormalCursor

; 3977 : 					return 0;

  01292	33 c0		 xor	 eax, eax
  01294	e9 2f 41 00 00	 jmp	 $LN1@PageDialog
$LN83@PageDialog:

; 4198 : 
; 4199 : 			break;
; 4200 : 
; 4201 : 		case HIDDEN_VOL_HOST_PRE_CIPHER_PAGE:
; 4202 : 			{
; 4203 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("HIDVOL_HOST_PRE_CIPHER_TITLE"));

  01299	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PMMGMENG@HIDVOL_HOST_PRE_CIPHER_TITLE?$AA@
  0129e	e8 00 00 00 00	 call	 _GetString
  012a3	83 c4 04	 add	 esp, 4
  012a6	50		 push	 eax
  012a7	68 e8 03 00 00	 push	 1000			; 000003e8H
  012ac	53		 push	 ebx
  012ad	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  012b3	ff d3		 call	 ebx
  012b5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  012bb	50		 push	 eax
  012bc	ff d7		 call	 edi
  012be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  012c4	50		 push	 eax
  012c5	ff d6		 call	 esi

; 4204 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString (bHiddenOS ? "HIDVOL_HOST_PRE_CIPHER_HELP_SYSENC" : "HIDVOL_HOST_PRE_CIPHER_HELP"));

  012c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenOS@@3HC ; bHiddenOS
  012cc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BM@GCHOHFOK@HIDVOL_HOST_PRE_CIPHER_HELP?$AA@
  012d1	85 c0		 test	 eax, eax
  012d3	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CD@OMGBOOGK@HIDVOL_HOST_PRE_CIPHER_HELP_SYSE@
  012d8	0f 44 ca	 cmove	 ecx, edx
  012db	51		 push	 ecx
  012dc	e8 00 00 00 00	 call	 _GetString
  012e1	83 c4 04	 add	 esp, 4
  012e4	50		 push	 eax
  012e5	68 eb 03 00 00	 push	 1003			; 000003ebH
  012ea	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  012f0	ff d7		 call	 edi
  012f2	50		 push	 eax
  012f3	ff d6		 call	 esi

; 4205 : 
; 4206 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  012f5	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  012fa	e8 00 00 00 00	 call	 _GetString
  012ff	83 c4 04	 add	 esp, 4
  01302	50		 push	 eax
  01303	68 10 04 00 00	 push	 1040			; 00000410H
  01308	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0130e	ff d3		 call	 ebx
  01310	50		 push	 eax
  01311	ff d7		 call	 edi
  01313	50		 push	 eax
  01314	ff d6		 call	 esi

; 4207 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  01316	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  0131b	e8 00 00 00 00	 call	 _GetString
  01320	83 c4 04	 add	 esp, 4
  01323	50		 push	 eax
  01324	68 11 04 00 00	 push	 1041			; 00000411H
  01329	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0132f	ff d3		 call	 ebx
  01331	50		 push	 eax
  01332	ff d7		 call	 edi
  01334	50		 push	 eax
  01335	ff d6		 call	 esi

; 4208 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  01337	6a 01		 push	 1
  01339	68 10 04 00 00	 push	 1040			; 00000410H
  0133e	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  01344	ff d3		 call	 ebx
  01346	50		 push	 eax
  01347	ff d7		 call	 edi
  01349	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  0134f	50		 push	 eax
  01350	ff d6		 call	 esi

; 4209 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  01352	6a 01		 push	 1
  01354	68 11 04 00 00	 push	 1041			; 00000411H
  01359	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0135f	ff d3		 call	 ebx
  01361	50		 push	 eax
  01362	ff d7		 call	 edi
  01364	50		 push	 eax
  01365	ff d6		 call	 esi

; 4210 : 
; 4211 : 				if (bHiddenOS)

  01367	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  0136e	0f 84 65 f4 ff
	ff		 je	 $LN384@PageDialog

; 4212 : 				{
; 4213 : 					if (!GetDevicePathForHiddenOS())

  01374	e8 00 00 00 00	 call	 ?GetDevicePathForHiddenOS@@YAHXZ ; GetDevicePathForHiddenOS
  01379	85 c0		 test	 eax, eax
  0137b	0f 85 58 f4 ff
	ff		 jne	 $LN384@PageDialog

; 4214 : 						AbortProcess ("INVALID_PATH");

  01381	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PJPEEMEG@INVALID_PATH?$AA@
  01386	e8 00 00 00 00	 call	 _AbortProcess
  0138b	83 c4 04	 add	 esp, 4
  0138e	33 c0		 xor	 eax, eax
  01390	e9 33 40 00 00	 jmp	 $LN1@PageDialog
$LN86@PageDialog:

; 4215 : 				}
; 4216 : 			}
; 4217 : 			break;
; 4218 : 
; 4219 : 		case HIDDEN_VOL_PRE_CIPHER_PAGE:
; 4220 : 			{
; 4221 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  01395	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  0139a	e8 00 00 00 00	 call	 _GetString
  0139f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  013a5	83 c4 04	 add	 esp, 4
  013a8	50		 push	 eax
  013a9	68 10 04 00 00	 push	 1040			; 00000410H
  013ae	53		 push	 ebx
  013af	ff d7		 call	 edi
  013b1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  013b7	50		 push	 eax
  013b8	ff d6		 call	 esi
  013ba	50		 push	 eax
  013bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4222 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  013c1	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  013c6	e8 00 00 00 00	 call	 _GetString
  013cb	83 c4 04	 add	 esp, 4
  013ce	50		 push	 eax
  013cf	68 11 04 00 00	 push	 1041			; 00000411H
  013d4	53		 push	 ebx
  013d5	ff d7		 call	 edi
  013d7	50		 push	 eax
  013d8	ff d6		 call	 esi
  013da	50		 push	 eax
  013db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4223 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  013e1	6a 01		 push	 1
  013e3	68 10 04 00 00	 push	 1040			; 00000410H
  013e8	53		 push	 ebx
  013e9	ff d7		 call	 edi
  013eb	50		 push	 eax
  013ec	ff d6		 call	 esi
  013ee	50		 push	 eax
  013ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4224 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  013f5	6a 00		 push	 0
  013f7	68 11 04 00 00	 push	 1041			; 00000411H
  013fc	53		 push	 ebx
  013fd	ff d7		 call	 edi
  013ff	50		 push	 eax
  01400	ff d6		 call	 esi
  01402	50		 push	 eax
  01403	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4225 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("HIDVOL_PRE_CIPHER_TITLE"));

  01409	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@JOBKEAGA@HIDVOL_PRE_CIPHER_TITLE?$AA@
  0140e	e8 00 00 00 00	 call	 _GetString
  01413	83 c4 04	 add	 esp, 4
  01416	50		 push	 eax
  01417	68 e8 03 00 00	 push	 1000			; 000003e8H
  0141c	53		 push	 ebx
  0141d	ff d7		 call	 edi
  0141f	50		 push	 eax
  01420	ff d6		 call	 esi
  01422	50		 push	 eax
  01423	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4226 : 
; 4227 : 				if (bHiddenOS)

  01429	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  01430	0f 84 e3 00 00
	00		 je	 $LN87@PageDialog

; 4228 : 				{
; 4229 : 					// Verify whether the clone of the OS fits in the hidden volume (the hidden
; 4230 : 					// volume is to host a hidden OS).
; 4231 : 					if (nMaximumHiddenVolSize - GST_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH < GetSystemPartitionSize())

  01436	e8 00 00 00 00	 call	 ?GetSystemPartitionSize@@YA_JXZ ; GetSystemPartitionSize
  0143b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nMaximumHiddenVolSize@@3_JA
  01441	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H
  01447	89 8d 78 eb fe
	ff		 mov	 DWORD PTR tv7962[ebp], ecx
  0144d	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?nMaximumHiddenVolSize@@3_JA+4
  01453	83 d9 00	 sbb	 ecx, 0
  01456	3b ca		 cmp	 ecx, edx
  01458	0f 8f 9c 00 00
	00		 jg	 $LN89@PageDialog
  0145e	7c 0c		 jl	 SHORT $LN705@PageDialog
  01460	39 85 78 eb fe
	ff		 cmp	 DWORD PTR tv7962[ebp], eax
  01466	0f 83 8e 00 00
	00		 jae	 $LN89@PageDialog
$LN705@PageDialog:

; 4232 : 					{
; 4233 : 						SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("HIDDEN_VOLUME_TOO_SMALL_FOR_OS_CLONE"));

  0146c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OIPNIHCG@HIDDEN_VOLUME_TOO_SMALL_FOR_OS_C@
  01471	e8 00 00 00 00	 call	 _GetString
  01476	83 c4 04	 add	 esp, 4
  01479	50		 push	 eax
  0147a	68 eb 03 00 00	 push	 1003			; 000003ebH
  0147f	53		 push	 ebx
  01480	ff d6		 call	 esi
  01482	50		 push	 eax
  01483	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4234 : 
; 4235 : 						SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("EXIT"));

  01489	68 00 00 00 00	 push	 OFFSET ??_C@_04GOLNGIJ@EXIT?$AA@
  0148e	e8 00 00 00 00	 call	 _GetString
  01493	83 c4 04	 add	 esp, 4
  01496	50		 push	 eax
  01497	6a 02		 push	 2
  01499	53		 push	 ebx
  0149a	ff d7		 call	 edi
  0149c	50		 push	 eax
  0149d	ff d6		 call	 esi
  0149f	50		 push	 eax
  014a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4236 : 						EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  014a6	6a 01		 push	 1
  014a8	6a 02		 push	 2
  014aa	53		 push	 ebx
  014ab	ff d7		 call	 edi
  014ad	50		 push	 eax
  014ae	ff d6		 call	 esi
  014b0	50		 push	 eax
  014b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4237 : 						EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), FALSE);

  014b7	6a 00		 push	 0
  014b9	68 10 04 00 00	 push	 1040			; 00000410H
  014be	53		 push	 ebx
  014bf	ff d7		 call	 edi
  014c1	50		 push	 eax
  014c2	ff d6		 call	 esi
  014c4	50		 push	 eax
  014c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4238 : 						EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  014cb	6a 00		 push	 0
  014cd	68 11 04 00 00	 push	 1041			; 00000411H
  014d2	53		 push	 ebx
  014d3	ff d7		 call	 edi
  014d5	50		 push	 eax
  014d6	ff d6		 call	 esi
  014d8	50		 push	 eax
  014d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4239 : 
; 4240 : 						bConfirmQuit = FALSE;

  014df	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bConfirmQuit@@3HC, 0 ; bConfirmQuit
  014e9	33 c0		 xor	 eax, eax

; 4241 : 						bConfirmQuitSysEncPretest = FALSE;

  014eb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bConfirmQuitSysEncPretest@@3HC, 0 ; bConfirmQuitSysEncPretest
  014f5	e9 ce 3e 00 00	 jmp	 $LN1@PageDialog
$LN89@PageDialog:

; 4242 : 					}
; 4243 : 					else
; 4244 : 					{
; 4245 : 						// The hidden volume must be as large as the system partition
; 4246 : 						nVolumeSize = GetSystemPartitionSize() + GST_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH;	

  014fa	e8 00 00 00 00	 call	 ?GetSystemPartitionSize@@YA_JXZ ; GetSystemPartitionSize
  014ff	05 00 00 02 00	 add	 eax, 131072		; 00020000H
  01504	a3 00 00 00 00	 mov	 DWORD PTR ?nVolumeSize@@3_KA, eax
  01509	83 d2 00	 adc	 edx, 0
  0150c	89 15 04 00 00
	00		 mov	 DWORD PTR ?nVolumeSize@@3_KA+4, edx

; 4247 : 
; 4248 : 						SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("HIDDEN_OS_PRE_CIPHER_HELP"));

  01512	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FGHOHKMP@HIDDEN_OS_PRE_CIPHER_HELP?$AA@

; 4249 : 					}
; 4250 : 				}
; 4251 : 				else

  01517	eb 05		 jmp	 SHORT $LN766@PageDialog
$LN87@PageDialog:

; 4252 : 				{
; 4253 : 					SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("HIDVOL_PRE_CIPHER_HELP"));

  01519	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GDOHBMLG@HIDVOL_PRE_CIPHER_HELP?$AA@
$LN766@PageDialog:
  0151e	e8 00 00 00 00	 call	 _GetString
  01523	83 c4 04	 add	 esp, 4
  01526	50		 push	 eax
  01527	68 eb 03 00 00	 push	 1003			; 000003ebH
  0152c	53		 push	 ebx
  0152d	ff d6		 call	 esi
  0152f	50		 push	 eax
  01530	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
  01536	33 c0		 xor	 eax, eax
  01538	e9 8b 3e 00 00	 jmp	 $LN1@PageDialog
$LN91@PageDialog:

; 4254 : 				}
; 4255 : 			}
; 4256 : 			break;
; 4257 : 
; 4258 : 		case CIPHER_PAGE:
; 4259 : 			{
; 4260 : 				int ea, hid;
; 4261 : 				char buf[100];
; 4262 : 
; 4263 : 				// Encryption algorithms
; 4264 : 
; 4265 : 				SendMessage (GetDlgItem (hwndDlg, IDC_COMBO_BOX), CB_RESETCONTENT, 0, 0);

  0153d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  01543	6a 00		 push	 0
  01545	6a 00		 push	 0
  01547	68 4b 01 00 00	 push	 331			; 0000014bH
  0154c	68 ea 03 00 00	 push	 1002			; 000003eaH
  01551	53		 push	 ebx
  01552	ff d7		 call	 edi
  01554	50		 push	 eax
  01555	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4266 : 
; 4267 : 				if (bHiddenVol)

  0155b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  01562	74 17		 je	 SHORT $LN92@PageDialog

; 4268 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString (bHiddenVolHost ? "CIPHER_HIDVOL_HOST_TITLE" : "CIPHER_HIDVOL_TITLE"));

  01564	a1 00 00 00 00	 mov	 eax, DWORD PTR _bHiddenVolHost
  01569	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BJ@GGKKJCIG@CIPHER_HIDVOL_HOST_TITLE?$AA@
  0156e	85 c0		 test	 eax, eax
  01570	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BE@JFKJAJEK@CIPHER_HIDVOL_TITLE?$AA@
  01575	0f 44 ca	 cmove	 ecx, edx
  01578	51		 push	 ecx

; 4269 : 				else

  01579	eb 05		 jmp	 SHORT $LN746@PageDialog
$LN92@PageDialog:

; 4270 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("CIPHER_TITLE"));

  0157b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IMFDFPGM@CIPHER_TITLE?$AA@
$LN746@PageDialog:
  01580	e8 00 00 00 00	 call	 _GetString
  01585	83 c4 04	 add	 esp, 4
  01588	50		 push	 eax
  01589	68 e8 03 00 00	 push	 1000			; 000003e8H
  0158e	53		 push	 ebx
  0158f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  01595	50		 push	 eax
  01596	ff d7		 call	 edi
  01598	50		 push	 eax
  01599	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4271 : 
; 4272 : 				for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  0159f	e8 00 00 00 00	 call	 _EAGetFirst
  015a4	8b f0		 mov	 esi, eax
  015a6	85 f6		 test	 esi, esi
  015a8	74 45		 je	 SHORT $LN9@PageDialog
  015aa	66 0f 1f 44 00
	00		 npad	 6
$LL10@PageDialog:

; 4273 : 				{
; 4274 : 					if (EAIsFormatEnabled (ea))

  015b0	56		 push	 esi
  015b1	e8 00 00 00 00	 call	 _EAIsFormatEnabled
  015b6	83 c4 04	 add	 esp, 4
  015b9	85 c0		 test	 eax, eax
  015bb	74 23		 je	 SHORT $LN8@PageDialog

; 4275 : 						AddComboPair (GetDlgItem (hwndDlg, IDC_COMBO_BOX), EAGetName (buf, ea), ea);

  015bd	56		 push	 esi
  015be	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _buf$30[ebp]
  015c4	56		 push	 esi
  015c5	50		 push	 eax
  015c6	e8 00 00 00 00	 call	 _EAGetName
  015cb	83 c4 08	 add	 esp, 8
  015ce	50		 push	 eax
  015cf	68 ea 03 00 00	 push	 1002			; 000003eaH
  015d4	53		 push	 ebx
  015d5	ff d7		 call	 edi
  015d7	50		 push	 eax
  015d8	e8 00 00 00 00	 call	 _AddComboPair
  015dd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@PageDialog:

; 4271 : 
; 4272 : 				for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  015e0	56		 push	 esi
  015e1	e8 00 00 00 00	 call	 _EAGetNext
  015e6	8b f0		 mov	 esi, eax
  015e8	83 c4 04	 add	 esp, 4
  015eb	85 f6		 test	 esi, esi
  015ed	75 c1		 jne	 SHORT $LL10@PageDialog
$LN9@PageDialog:

; 4276 : 				}
; 4277 : 
; 4278 : 				SelectAlgo (GetDlgItem (hwndDlg, IDC_COMBO_BOX), &nVolumeEA);

  015ef	68 00 00 00 00	 push	 OFFSET ?nVolumeEA@@3HA	; nVolumeEA
  015f4	68 ea 03 00 00	 push	 1002			; 000003eaH
  015f9	53		 push	 ebx
  015fa	ff d7		 call	 edi
  015fc	50		 push	 eax
  015fd	e8 00 00 00 00	 call	 _SelectAlgo

; 4279 : 				ComboSelChangeEA (hwndDlg);

  01602	53		 push	 ebx
  01603	e8 00 00 00 00	 call	 _ComboSelChangeEA
  01608	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4280 : 				SetFocus (GetDlgItem (hwndDlg, IDC_COMBO_BOX));

  0160b	68 ea 03 00 00	 push	 1002			; 000003eaH
  01610	53		 push	 ebx
  01611	ff d7		 call	 edi
  01613	50		 push	 eax
  01614	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 4281 : 
; 4282 : 				ToHyperlink (hwndDlg, IDC_LINK_MORE_INFO_ABOUT_CIPHER);

  0161a	68 21 04 00 00	 push	 1057			; 00000421H
  0161f	53		 push	 ebx
  01620	e8 00 00 00 00	 call	 _ToHyperlink
  01625	83 c4 08	 add	 esp, 8

; 4283 : 
; 4284 : 				// Hash algorithms
; 4285 : 
; 4286 : 				if (SysEncInEffect ())

  01628	e8 00 00 00 00	 call	 _SysEncInEffect
  0162d	85 c0		 test	 eax, eax
  0162f	74 16		 je	 SHORT $LN95@PageDialog

; 4287 : 				{
; 4288 : 					hash_algo = DEFAULT_HASH_ALGORITHM_BOOT;
; 4289 : 					RandSetHashFunction (DEFAULT_HASH_ALGORITHM_BOOT);

  01631	6a 01		 push	 1
  01633	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?hash_algo@@3HA, 1 ; hash_algo
  0163d	e8 00 00 00 00	 call	 _RandSetHashFunction
  01642	83 c4 04	 add	 esp, 4

; 4290 : 				}
; 4291 : 				else

  01645	eb 0a		 jmp	 SHORT $LN96@PageDialog
$LN95@PageDialog:

; 4292 : 					hash_algo = RandGetHashFunction();

  01647	e8 00 00 00 00	 call	 _RandGetHashFunction
  0164c	a3 00 00 00 00	 mov	 DWORD PTR ?hash_algo@@3HA, eax ; hash_algo
$LN96@PageDialog:

; 4293 : 
; 4294 : 				for (hid = FIRST_PRF_ID; hid <= LAST_PRF_ID; hid++)

  01651	be 01 00 00 00	 mov	 esi, 1
$LL13@PageDialog:

; 4295 : 				{
; 4296 : 					if (!HashIsDeprecated (hid))

  01656	56		 push	 esi
  01657	e8 00 00 00 00	 call	 _HashIsDeprecated
  0165c	83 c4 04	 add	 esp, 4
  0165f	85 c0		 test	 eax, eax
  01661	75 1c		 jne	 SHORT $LN11@PageDialog

; 4297 : 						AddComboPair (GetDlgItem (hwndDlg, IDC_COMBO_BOX_HASH_ALGO), HashGetName(hid), hid);

  01663	56		 push	 esi
  01664	56		 push	 esi
  01665	e8 00 00 00 00	 call	 _HashGetName
  0166a	83 c4 04	 add	 esp, 4
  0166d	50		 push	 eax
  0166e	68 f0 03 00 00	 push	 1008			; 000003f0H
  01673	53		 push	 ebx
  01674	ff d7		 call	 edi
  01676	50		 push	 eax
  01677	e8 00 00 00 00	 call	 _AddComboPair
  0167c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@PageDialog:

; 4293 : 
; 4294 : 				for (hid = FIRST_PRF_ID; hid <= LAST_PRF_ID; hid++)

  0167f	46		 inc	 esi
  01680	83 fe 03	 cmp	 esi, 3
  01683	7e d1		 jle	 SHORT $LL13@PageDialog

; 4298 : 				}
; 4299 : 				SelectAlgo (GetDlgItem (hwndDlg, IDC_COMBO_BOX_HASH_ALGO), &hash_algo);

  01685	68 00 00 00 00	 push	 OFFSET ?hash_algo@@3HA	; hash_algo
  0168a	68 f0 03 00 00	 push	 1008			; 000003f0H
  0168f	53		 push	 ebx
  01690	ff d7		 call	 edi
  01692	50		 push	 eax
  01693	e8 00 00 00 00	 call	 _SelectAlgo

; 4300 : 
; 4301 : 				ToHyperlink (hwndDlg, IDC_LINK_HASH_INFO);

  01698	68 22 04 00 00	 push	 1058			; 00000422H
  0169d	53		 push	 ebx
  0169e	e8 00 00 00 00	 call	 _ToHyperlink

; 4302 : 
; 4303 : 				// Wizard buttons
; 4304 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  016a3	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  016a8	e8 00 00 00 00	 call	 _GetString
  016ad	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetParent@4
  016b3	83 c4 14	 add	 esp, 20			; 00000014H
$LN787@PageDialog:
  016b6	50		 push	 eax
  016b7	68 10 04 00 00	 push	 1040			; 00000410H
  016bc	53		 push	 ebx
  016bd	ff d6		 call	 esi
  016bf	50		 push	 eax
  016c0	ff d7		 call	 edi
  016c2	50		 push	 eax
  016c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4305 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  016c9	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  016ce	e8 00 00 00 00	 call	 _GetString
  016d3	83 c4 04	 add	 esp, 4
  016d6	50		 push	 eax
  016d7	68 11 04 00 00	 push	 1041			; 00000411H
  016dc	53		 push	 ebx
  016dd	ff d6		 call	 esi
  016df	50		 push	 eax
  016e0	ff d7		 call	 edi
  016e2	50		 push	 eax
  016e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4306 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  016e9	6a 01		 push	 1
  016eb	68 11 04 00 00	 push	 1041			; 00000411H
  016f0	53		 push	 ebx
  016f1	ff d6		 call	 esi
  016f3	50		 push	 eax
  016f4	ff d7		 call	 edi
  016f6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  016fc	50		 push	 eax
  016fd	ff d6		 call	 esi

; 4307 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  016ff	6a 01		 push	 1
  01701	68 10 04 00 00	 push	 1040			; 00000410H

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  01706	53		 push	 ebx
  01707	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0170d	50		 push	 eax
  0170e	ff d7		 call	 edi
  01710	50		 push	 eax
  01711	ff d6		 call	 esi
  01713	33 c0		 xor	 eax, eax
  01715	e9 ae 3c 00 00	 jmp	 $LN1@PageDialog
$LN98@PageDialog:

; 4308 : 			}
; 4309 : 			break;
; 4310 : 
; 4311 : 		case SIZE_PAGE:
; 4312 : 			{
; 4313 : 				wchar_t str[1000];
; 4314 : 
; 4315 : 				if (bHiddenVolHost)

  0171a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0

; 4316 : 				{
; 4317 : 					wcsncpy (str, GetString ("SIZE_HELP_HIDDEN_HOST_VOL"), sizeof (str) / 2);

  01721	68 e8 03 00 00	 push	 1000			; 000003e8H
  01726	74 07		 je	 SHORT $LN99@PageDialog
  01728	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@DEODNGPK@SIZE_HELP_HIDDEN_HOST_VOL?$AA@

; 4318 : 				}
; 4319 : 				else

  0172d	eb 15		 jmp	 SHORT $LN748@PageDialog
$LN99@PageDialog:

; 4320 : 				{
; 4321 : 					wcsncpy (str, GetString (bHiddenVol ? "SIZE_HELP_HIDDEN_VOL" : "SIZE_HELP"), sizeof (str) / 2);

  0172f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenVol@@3HC ; bHiddenVol
  01734	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BF@LOOCDJPI@SIZE_HELP_HIDDEN_VOL?$AA@
  01739	85 c0		 test	 eax, eax
  0173b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_09BEBIICBL@SIZE_HELP?$AA@
  01740	0f 44 ca	 cmove	 ecx, edx
  01743	51		 push	 ecx
$LN748@PageDialog:
  01744	e8 00 00 00 00	 call	 _GetString
  01749	83 c4 04	 add	 esp, 4
  0174c	50		 push	 eax
  0174d	8d 85 90 ec ff
	ff		 lea	 eax, DWORD PTR _str$26[ebp]
  01753	50		 push	 eax
  01754	e8 00 00 00 00	 call	 _wcsncpy
  01759	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4322 : 				}
; 4323 : 
; 4324 : 				if (bDevice && !(bHiddenVol && !bHiddenVolHost))	// If raw device but not a hidden volume

  0175c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  01763	74 7a		 je	 SHORT $LN101@PageDialog
  01765	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  0176c	74 09		 je	 SHORT $LN102@PageDialog
  0176e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  01775	74 68		 je	 SHORT $LN101@PageDialog
$LN102@PageDialog:

; 4325 : 				{
; 4326 : 					_snwprintf (str, sizeof str / 2, L"%s%s",

  01777	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  0177e	74 1a		 je	 SHORT $LN333@PageDialog
  01780	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  01787	75 11		 jne	 SHORT $LN333@PageDialog
  01789	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@JPPBFIHO@SIZE_PARTITION_HIDDEN_VOL_HELP?$AA@
  0178e	e8 00 00 00 00	 call	 _GetString
  01793	83 c4 04	 add	 esp, 4
  01796	8b c8		 mov	 ecx, eax
  01798	eb 05		 jmp	 SHORT $LN334@PageDialog
$LN333@PageDialog:
  0179a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
$LN334@PageDialog:
  0179f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  017a6	74 0e		 je	 SHORT $LN335@PageDialog
  017a8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  017af	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CC@MIIACKDF@SIZE_PARTITION_HIDDEN_SYSENC_HEL@
  017b4	75 05		 jne	 SHORT $LN336@PageDialog
$LN335@PageDialog:
  017b6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BE@FGKMPGH@SIZE_PARTITION_HELP?$AA@
$LN336@PageDialog:
  017bb	51		 push	 ecx
  017bc	50		 push	 eax
  017bd	e8 00 00 00 00	 call	 _GetString
  017c2	83 c4 04	 add	 esp, 4
  017c5	50		 push	 eax
  017c6	68 00 00 00 00	 push	 OFFSET ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
  017cb	8d 85 90 ec ff
	ff		 lea	 eax, DWORD PTR _str$26[ebp]
  017d1	68 e8 03 00 00	 push	 1000			; 000003e8H
  017d6	50		 push	 eax
  017d7	e8 00 00 00 00	 call	 __snwprintf
  017dc	83 c4 14	 add	 esp, 20			; 00000014H
$LN101@PageDialog:

; 4327 : 						GetString ((bHiddenOS && bHiddenVol) ? "SIZE_PARTITION_HIDDEN_SYSENC_HELP" : "SIZE_PARTITION_HELP"),
; 4328 : 						 (bHiddenVolHost && !bHiddenOS) ? GetString ("SIZE_PARTITION_HIDDEN_VOL_HELP") : L"");
; 4329 : 				}
; 4330 : 
; 4331 : 				SendMessage (GetDlgItem (hwndDlg, IDC_SPACE_LEFT), WM_SETFONT, (WPARAM) hBoldFont, (LPARAM) TRUE);

  017df	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  017e5	6a 01		 push	 1
  017e7	ff 35 00 00 00
	00		 push	 DWORD PTR _hBoldFont
  017ed	6a 30		 push	 48			; 00000030H
  017ef	68 f1 03 00 00	 push	 1009			; 000003f1H
  017f4	53		 push	 ebx
  017f5	ff d6		 call	 esi
  017f7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SendMessageA@16
  017fd	50		 push	 eax
  017fe	ff d7		 call	 edi

; 4332 : 				SendMessage (GetDlgItem (hwndDlg, IDC_SIZEBOX), EM_LIMITTEXT, 12, 0);

  01800	6a 00		 push	 0
  01802	6a 0c		 push	 12			; 0000000cH
  01804	68 c5 00 00 00	 push	 197			; 000000c5H
  01809	68 0e 04 00 00	 push	 1038			; 0000040eH
  0180e	53		 push	 ebx
  0180f	ff d6		 call	 esi
  01811	50		 push	 eax
  01812	ff d7		 call	 edi

; 4333 : 
; 4334 : 				if(!QueryFreeSpace (hwndDlg, GetDlgItem (hwndDlg, IDC_SPACE_LEFT), TRUE))

  01814	6a 01		 push	 1
  01816	68 f1 03 00 00	 push	 1009			; 000003f1H
  0181b	53		 push	 ebx
  0181c	ff d6		 call	 esi
  0181e	50		 push	 eax
  0181f	53		 push	 ebx
  01820	e8 00 00 00 00	 call	 _QueryFreeSpace
  01825	83 c4 0c	 add	 esp, 12			; 0000000cH
  01828	85 c0		 test	 eax, eax
  0182a	75 61		 jne	 SHORT $LN103@PageDialog

; 4335 : 				{
; 4336 : 					nUIVolumeSize=0;
; 4337 : 					nVolumeSize=0;
; 4338 : 					SetWindowTextW (GetDlgItem (hwndDlg, IDC_SIZEBOX), GetString ("UNKNOWN"));

  0182c	0f 57 c0	 xorps	 xmm0, xmm0
  0182f	68 00 00 00 00	 push	 OFFSET ??_C@_07NFANNNEC@UNKNOWN?$AA@
  01834	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nUIVolumeSize@@3_KA, xmm0
  0183c	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?nVolumeSize@@3_KA, xmm0
  01844	e8 00 00 00 00	 call	 _GetString
  01849	83 c4 04	 add	 esp, 4
  0184c	50		 push	 eax
  0184d	68 0e 04 00 00	 push	 1038			; 0000040eH
  01852	53		 push	 ebx
  01853	ff d6		 call	 esi
  01855	50		 push	 eax
  01856	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
$LN107@PageDialog:

; 4339 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_SIZEBOX), FALSE);

  0185c	6a 00		 push	 0
  0185e	68 0e 04 00 00	 push	 1038			; 0000040eH
  01863	53		 push	 ebx
  01864	ff d6		 call	 esi
  01866	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  0186c	50		 push	 eax
  0186d	ff d7		 call	 edi

; 4340 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_KB), FALSE);

  0186f	6a 00		 push	 0
  01871	68 f3 03 00 00	 push	 1011			; 000003f3H
  01876	53		 push	 ebx
  01877	ff d6		 call	 esi
  01879	50		 push	 eax
  0187a	ff d7		 call	 edi

; 4341 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_MB), FALSE);

  0187c	6a 00		 push	 0
  0187e	68 f5 03 00 00	 push	 1013			; 000003f5H
  01883	53		 push	 ebx
  01884	ff d6		 call	 esi
  01886	50		 push	 eax
  01887	ff d7		 call	 edi

; 4342 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_GB), FALSE);

  01889	6a 00		 push	 0
  0188b	eb 4a		 jmp	 SHORT $LN749@PageDialog
$LN103@PageDialog:

; 4343 : 
; 4344 : 				}
; 4345 : 				else if (bDevice && !(bHiddenVol && !bHiddenVolHost))	// If raw device but not a hidden volume

  0188d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  01894	74 12		 je	 SHORT $LN105@PageDialog
  01896	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  0189d	74 bd		 je	 SHORT $LN107@PageDialog
  0189f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  018a6	75 b4		 jne	 SHORT $LN107@PageDialog
$LN105@PageDialog:

; 4346 : 				{
; 4347 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_SIZEBOX), FALSE);
; 4348 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_KB), FALSE);
; 4349 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_MB), FALSE);
; 4350 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_GB), FALSE);
; 4351 : 				}
; 4352 : 				else
; 4353 : 				{
; 4354 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_SIZEBOX), TRUE);

  018a8	6a 01		 push	 1
  018aa	68 0e 04 00 00	 push	 1038			; 0000040eH
  018af	53		 push	 ebx
  018b0	ff d6		 call	 esi
  018b2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  018b8	50		 push	 eax
  018b9	ff d7		 call	 edi

; 4355 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_KB), TRUE);

  018bb	6a 01		 push	 1
  018bd	68 f3 03 00 00	 push	 1011			; 000003f3H
  018c2	53		 push	 ebx
  018c3	ff d6		 call	 esi
  018c5	50		 push	 eax
  018c6	ff d7		 call	 edi

; 4356 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_MB), TRUE);

  018c8	6a 01		 push	 1
  018ca	68 f5 03 00 00	 push	 1013			; 000003f5H
  018cf	53		 push	 ebx
  018d0	ff d6		 call	 esi
  018d2	50		 push	 eax
  018d3	ff d7		 call	 edi

; 4357 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_GB), TRUE);

  018d5	6a 01		 push	 1
$LN749@PageDialog:
  018d7	68 f7 03 00 00	 push	 1015			; 000003f7H
  018dc	53		 push	 ebx
  018dd	ff d6		 call	 esi
  018df	50		 push	 eax
  018e0	ff d7		 call	 edi

; 4358 : 				}
; 4359 : 
; 4360 : 				SendMessage (GetDlgItem (hwndDlg, IDC_KB), BM_SETCHECK, BST_UNCHECKED, 0);

  018e2	6a 00		 push	 0
  018e4	6a 00		 push	 0
  018e6	68 f1 00 00 00	 push	 241			; 000000f1H
  018eb	68 f3 03 00 00	 push	 1011			; 000003f3H
  018f0	53		 push	 ebx
  018f1	ff d6		 call	 esi
  018f3	50		 push	 eax
  018f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4361 : 				SendMessage (GetDlgItem (hwndDlg, IDC_MB), BM_SETCHECK, BST_UNCHECKED, 0);

  018fa	6a 00		 push	 0
  018fc	6a 00		 push	 0
  018fe	68 f1 00 00 00	 push	 241			; 000000f1H
  01903	68 f5 03 00 00	 push	 1013			; 000003f5H
  01908	53		 push	 ebx
  01909	ff d6		 call	 esi
  0190b	50		 push	 eax
  0190c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4362 : 				SendMessage (GetDlgItem (hwndDlg, IDC_GB), BM_SETCHECK, BST_UNCHECKED, 0);

  01912	6a 00		 push	 0
  01914	6a 00		 push	 0
  01916	68 f1 00 00 00	 push	 241			; 000000f1H
  0191b	68 f7 03 00 00	 push	 1015			; 000003f7H
  01920	53		 push	 ebx
  01921	ff d6		 call	 esi
  01923	50		 push	 eax
  01924	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4363 : 
; 4364 : 				switch (nMultiplier)

  0192a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nMultiplier@@3HA ; nMultiplier
  0192f	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  01934	74 2e		 je	 SHORT $LN108@PageDialog
  01936	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  0193b	74 17		 je	 SHORT $LN109@PageDialog
  0193d	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  01942	75 38		 jne	 SHORT $LN14@PageDialog

; 4372 : 				case BYTES_PER_GB:
; 4373 : 					SendMessage (GetDlgItem (hwndDlg, IDC_GB), BM_SETCHECK, BST_CHECKED, 0);

  01944	6a 00		 push	 0
  01946	6a 01		 push	 1
  01948	68 f1 00 00 00	 push	 241			; 000000f1H
  0194d	68 f7 03 00 00	 push	 1015			; 000003f7H
  01952	eb 1e		 jmp	 SHORT $LN750@PageDialog
$LN109@PageDialog:

; 4368 : 					break;
; 4369 : 				case BYTES_PER_MB:
; 4370 : 					SendMessage (GetDlgItem (hwndDlg, IDC_MB), BM_SETCHECK, BST_CHECKED, 0);

  01954	6a 00		 push	 0
  01956	6a 01		 push	 1
  01958	68 f1 00 00 00	 push	 241			; 000000f1H
  0195d	68 f5 03 00 00	 push	 1013			; 000003f5H

; 4371 : 					break;

  01962	eb 0e		 jmp	 SHORT $LN750@PageDialog
$LN108@PageDialog:

; 4365 : 				{
; 4366 : 				case BYTES_PER_KB:
; 4367 : 					SendMessage (GetDlgItem (hwndDlg, IDC_KB), BM_SETCHECK, BST_CHECKED, 0);

  01964	6a 00		 push	 0
  01966	6a 01		 push	 1
  01968	68 f1 00 00 00	 push	 241			; 000000f1H
  0196d	68 f3 03 00 00	 push	 1011			; 000003f3H
$LN750@PageDialog:
  01972	53		 push	 ebx
  01973	ff d6		 call	 esi
  01975	50		 push	 eax
  01976	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN14@PageDialog:

; 4374 : 					break;
; 4375 : 				}
; 4376 : 
; 4377 : 				if (nUIVolumeSize != 0)

  0197c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nUIVolumeSize@@3_KA
  01982	8b c1		 mov	 eax, ecx
  01984	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?nUIVolumeSize@@3_KA+4
  0198a	0b c2		 or	 eax, edx
  0198c	74 26		 je	 SHORT $LN111@PageDialog

; 4378 : 				{
; 4379 : 					char szTmp[32];
; 4380 : 					sprintf (szTmp, "%I64u", nUIVolumeSize);

  0198e	52		 push	 edx
  0198f	51		 push	 ecx
  01990	8d 45 cc	 lea	 eax, DWORD PTR _szTmp$33[ebp]
  01993	68 00 00 00 00	 push	 OFFSET ??_C@_05OINFJHGD@?$CFI64u?$AA@
  01998	50		 push	 eax
  01999	e8 00 00 00 00	 call	 _sprintf
  0199e	83 c4 10	 add	 esp, 16			; 00000010H

; 4381 : 					SetWindowText (GetDlgItem (hwndDlg, IDC_SIZEBOX), szTmp);

  019a1	8d 45 cc	 lea	 eax, DWORD PTR _szTmp$33[ebp]
  019a4	50		 push	 eax
  019a5	68 0e 04 00 00	 push	 1038			; 0000040eH
  019aa	53		 push	 ebx
  019ab	ff d6		 call	 esi
  019ad	50		 push	 eax
  019ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN111@PageDialog:

; 4382 : 				}
; 4383 : 
; 4384 : 				SetFocus (GetDlgItem (hwndDlg, IDC_SIZEBOX));

  019b4	68 0e 04 00 00	 push	 1038			; 0000040eH
  019b9	53		 push	 ebx
  019ba	ff d6		 call	 esi
  019bc	50		 push	 eax
  019bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 4385 : 
; 4386 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), str);

  019c3	8d 85 90 ec ff
	ff		 lea	 eax, DWORD PTR _str$26[ebp]
  019c9	50		 push	 eax
  019ca	68 eb 03 00 00	 push	 1003			; 000003ebH
  019cf	53		 push	 ebx
  019d0	ff d6		 call	 esi
  019d2	50		 push	 eax
  019d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4387 : 
; 4388 : 				if (bHiddenVol)

  019d9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  019e0	74 17		 je	 SHORT $LN112@PageDialog

; 4389 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString (bHiddenVolHost ? "SIZE_HIDVOL_HOST_TITLE" : "SIZE_HIDVOL_TITLE"));

  019e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _bHiddenVolHost
  019e7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BH@GBEPPLEC@SIZE_HIDVOL_HOST_TITLE?$AA@
  019ec	85 c0		 test	 eax, eax
  019ee	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@COPDBOHD@SIZE_HIDVOL_TITLE?$AA@
  019f3	0f 44 ca	 cmove	 ecx, edx
  019f6	51		 push	 ecx

; 4390 : 				else

  019f7	eb 05		 jmp	 SHORT $LN751@PageDialog
$LN112@PageDialog:

; 4391 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SIZE_TITLE"));

  019f9	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DGAKGAKL@SIZE_TITLE?$AA@
$LN751@PageDialog:
  019fe	e8 00 00 00 00	 call	 _GetString
  01a03	83 c4 04	 add	 esp, 4
  01a06	50		 push	 eax
  01a07	68 e8 03 00 00	 push	 1000			; 000003e8H
  01a0c	53		 push	 ebx
  01a0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  01a13	50		 push	 eax
  01a14	ff d6		 call	 esi
  01a16	50		 push	 eax
  01a17	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4392 : 
; 4393 : 
; 4394 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  01a1d	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  01a22	e8 00 00 00 00	 call	 _GetString
  01a27	83 c4 04	 add	 esp, 4
  01a2a	50		 push	 eax
  01a2b	68 10 04 00 00	 push	 1040			; 00000410H
  01a30	53		 push	 ebx
  01a31	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  01a37	50		 push	 eax
  01a38	ff d6		 call	 esi
  01a3a	50		 push	 eax
  01a3b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4395 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  01a41	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  01a46	e8 00 00 00 00	 call	 _GetString
  01a4b	83 c4 04	 add	 esp, 4
  01a4e	50		 push	 eax
  01a4f	68 11 04 00 00	 push	 1041			; 00000411H
  01a54	53		 push	 ebx
  01a55	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  01a5b	50		 push	 eax
  01a5c	ff d6		 call	 esi
  01a5e	50		 push	 eax
  01a5f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4396 : 
; 4397 : 
; 4398 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  01a65	6a 01		 push	 1
  01a67	68 11 04 00 00	 push	 1041			; 00000411H
  01a6c	53		 push	 ebx
  01a6d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  01a73	50		 push	 eax
  01a74	ff d6		 call	 esi
  01a76	50		 push	 eax
  01a77	ff d7		 call	 edi

; 4399 : 
; 4400 : 				VerifySizeAndUpdate (hwndDlg, FALSE);

  01a79	6a 00		 push	 0
  01a7b	53		 push	 ebx
  01a7c	e8 00 00 00 00	 call	 _VerifySizeAndUpdate
  01a81	83 c4 08	 add	 esp, 8
  01a84	33 c0		 xor	 eax, eax
  01a86	e9 3d 39 00 00	 jmp	 $LN1@PageDialog
$LN114@PageDialog:

; 4401 : 			}
; 4402 : 			break;
; 4403 : 
; 4404 : 		case HIDDEN_VOL_HOST_PASSWORD_PAGE:
; 4405 : 		case NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE:
; 4406 : 
; 4407 : 			SendMessage (GetDlgItem (hwndDlg, IDC_PASSWORD_DIRECT), EM_LIMITTEXT, MAX_PASSWORD, 0);

  01a8b	6a 00		 push	 0
  01a8d	6a 40		 push	 64			; 00000040H
  01a8f	68 c5 00 00 00	 push	 197			; 000000c5H
  01a94	68 0d 04 00 00	 push	 1037			; 0000040dH
  01a99	53		 push	 ebx
  01a9a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  01aa0	ff d3		 call	 ebx
  01aa2	50		 push	 eax
  01aa3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4408 : 
; 4409 : 			SetWindowText (GetDlgItem (hwndDlg, IDC_PASSWORD_DIRECT), szRawPassword);

  01aa9	8b bd 7c eb fe
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  01aaf	68 00 00 00 00	 push	 OFFSET ?szRawPassword@@3PADA ; szRawPassword
  01ab4	68 0d 04 00 00	 push	 1037			; 0000040dH
  01ab9	57		 push	 edi
  01aba	ff d3		 call	 ebx
  01abc	50		 push	 eax
  01abd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 4410 : 
; 4411 : 			SetFocus (GetDlgItem (hwndDlg, IDC_PASSWORD_DIRECT));

  01ac3	68 0d 04 00 00	 push	 1037			; 0000040dH
  01ac8	57		 push	 edi
  01ac9	ff d3		 call	 ebx
  01acb	50		 push	 eax
  01acc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 4412 : 
; 4413 : 			SetCheckBox (hwndDlg, IDC_KEYFILES_ENABLE, KeyFilesEnable);

  01ad2	ff 35 00 00 00
	00		 push	 DWORD PTR _KeyFilesEnable
  01ad8	68 c5 13 00 00	 push	 5061			; 000013c5H
  01add	57		 push	 edi
  01ade	e8 00 00 00 00	 call	 _SetCheckBox

; 4414 : 
; 4415 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString (bInPlaceEncNonSys ? "NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE_HELP" : "PASSWORD_HIDDENVOL_HOST_DIRECT_HELP"));

  01ae3	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  01ae8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CE@MPBBLHJC@PASSWORD_HIDDENVOL_HOST_DIRECT_H@
  01aed	85 c0		 test	 eax, eax
  01aef	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CN@CCCDIOBF@NONSYS_INPLACE_ENC_RESUME_PASSWO@
  01af4	0f 44 ca	 cmove	 ecx, edx
  01af7	51		 push	 ecx
  01af8	e8 00 00 00 00	 call	 _GetString
  01afd	83 c4 10	 add	 esp, 16			; 00000010H
  01b00	50		 push	 eax
  01b01	68 eb 03 00 00	 push	 1003			; 000003ebH
  01b06	57		 push	 edi
  01b07	ff d3		 call	 ebx
  01b09	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  01b0f	50		 push	 eax
  01b10	ff d6		 call	 esi

; 4416 : 
; 4417 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString (bInPlaceEncNonSys ? "PASSWORD" : "PASSWORD_HIDVOL_HOST_TITLE"));

  01b12	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  01b17	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@DDMDKDAG@PASSWORD_HIDVOL_HOST_TITLE?$AA@
  01b1c	85 c0		 test	 eax, eax
  01b1e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08KENNMKEI@PASSWORD?$AA@
  01b23	0f 44 ca	 cmove	 ecx, edx
  01b26	51		 push	 ecx
  01b27	e8 00 00 00 00	 call	 _GetString
  01b2c	83 c4 04	 add	 esp, 4
  01b2f	50		 push	 eax
  01b30	68 e8 03 00 00	 push	 1000			; 000003e8H
  01b35	57		 push	 edi
  01b36	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  01b3c	ff d7		 call	 edi
  01b3e	50		 push	 eax
  01b3f	ff d3		 call	 ebx
  01b41	50		 push	 eax
  01b42	ff d6		 call	 esi

; 4418 : 
; 4419 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  01b44	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  01b49	e8 00 00 00 00	 call	 _GetString
  01b4e	83 c4 04	 add	 esp, 4
  01b51	50		 push	 eax
  01b52	68 10 04 00 00	 push	 1040			; 00000410H
  01b57	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  01b5d	ff d7		 call	 edi
  01b5f	50		 push	 eax
  01b60	ff d3		 call	 ebx
  01b62	50		 push	 eax
  01b63	ff d6		 call	 esi

; 4420 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  01b65	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  01b6a	e8 00 00 00 00	 call	 _GetString
  01b6f	83 c4 04	 add	 esp, 4
  01b72	50		 push	 eax
  01b73	68 11 04 00 00	 push	 1041			; 00000411H
  01b78	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  01b7e	ff d7		 call	 edi
  01b80	50		 push	 eax
  01b81	ff d3		 call	 ebx
  01b83	50		 push	 eax
  01b84	ff d6		 call	 esi

; 4421 : 
; 4422 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), !bInPlaceEncNonSys);

  01b86	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  01b8b	f7 d8		 neg	 eax
  01b8d	1b c0		 sbb	 eax, eax
  01b8f	40		 inc	 eax
  01b90	50		 push	 eax
  01b91	68 11 04 00 00	 push	 1041			; 00000411H
  01b96	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  01b9c	ff d7		 call	 edi
  01b9e	50		 push	 eax
  01b9f	ff d3		 call	 ebx
  01ba1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  01ba7	50		 push	 eax
  01ba8	ff d6		 call	 esi

; 4423 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  01baa	6a 01		 push	 1
  01bac	68 10 04 00 00	 push	 1040			; 00000410H
  01bb1	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  01bb7	ff d7		 call	 edi
  01bb9	50		 push	 eax
  01bba	ff d3		 call	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  01bbc	50		 push	 eax
  01bbd	ff d6		 call	 esi
  01bbf	33 c0		 xor	 eax, eax
  01bc1	e9 02 38 00 00	 jmp	 $LN1@PageDialog
$LN115@PageDialog:

; 4424 : 
; 4425 : 			break;
; 4426 : 
; 4427 : 		case PASSWORD_PAGE:
; 4428 : 			{
; 4429 : 				wchar_t str[1000];
; 4430 : 
; 4431 : 				hPasswordInputField = GetDlgItem (hwndDlg, IDC_PASSWORD);

  01bc6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  01bcc	68 ec 03 00 00	 push	 1004			; 000003ecH
  01bd1	53		 push	 ebx
  01bd2	ff d7		 call	 edi

; 4432 : 				hVerifyPasswordInputField = GetDlgItem (hwndDlg, IDC_VERIFY);

  01bd4	68 f2 03 00 00	 push	 1010			; 000003f2H
  01bd9	53		 push	 ebx
  01bda	a3 00 00 00 00	 mov	 DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A, eax ; hPasswordInputField
  01bdf	ff d7		 call	 edi
  01be1	a3 00 00 00 00	 mov	 DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A, eax ; hVerifyPasswordInputField

; 4433 : 
; 4434 : 				if (SysEncInEffect ())

  01be6	e8 00 00 00 00	 call	 _SysEncInEffect
  01beb	85 c0		 test	 eax, eax
  01bed	0f 84 c2 00 00
	00		 je	 $LN119@PageDialog

; 4435 : 				{
; 4436 : 					ToBootPwdField (hwndDlg, IDC_PASSWORD);

  01bf3	68 ec 03 00 00	 push	 1004			; 000003ecH
  01bf8	53		 push	 ebx
  01bf9	e8 00 00 00 00	 call	 _ToBootPwdField

; 4437 : 					ToBootPwdField (hwndDlg, IDC_VERIFY);

  01bfe	68 f2 03 00 00	 push	 1010			; 000003f2H
  01c03	53		 push	 ebx
  01c04	e8 00 00 00 00	 call	 _ToBootPwdField

; 4438 : 
; 4439 : 					sprintf (OrigKeyboardLayout, "%08X", (DWORD) GetKeyboardLayout (NULL) & 0xFFFF);

  01c09	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetKeyboardLayout@4
  01c0f	83 c4 10	 add	 esp, 16			; 00000010H
  01c12	6a 00		 push	 0
  01c14	ff d6		 call	 esi
  01c16	0f b7 c0	 movzx	 eax, ax
  01c19	50		 push	 eax
  01c1a	68 00 00 00 00	 push	 OFFSET ??_C@_04JIMNDDED@?$CF08X?$AA@
  01c1f	68 00 00 00 00	 push	 OFFSET ?OrigKeyboardLayout@@3PADA ; OrigKeyboardLayout
  01c24	e8 00 00 00 00	 call	 _sprintf
  01c29	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4440 : 
; 4441 : 					if ((DWORD) GetKeyboardLayout (NULL) != 0x00000409 && (DWORD) GetKeyboardLayout (NULL) != 0x04090409)

  01c2c	6a 00		 push	 0
  01c2e	ff d6		 call	 esi
  01c30	3d 09 04 00 00	 cmp	 eax, 1033		; 00000409H
  01c35	74 4d		 je	 SHORT $LN117@PageDialog
  01c37	6a 00		 push	 0
  01c39	ff d6		 call	 esi
  01c3b	3d 09 04 09 04	 cmp	 eax, 67699721		; 04090409H
  01c40	74 42		 je	 SHORT $LN117@PageDialog

; 4442 : 					{
; 4443 : 						DWORD keybLayout = (DWORD) LoadKeyboardLayout ("00000409", KLF_ACTIVATE);

  01c42	6a 01		 push	 1
  01c44	68 00 00 00 00	 push	 OFFSET ??_C@_08OKJEGFFL@00000409?$AA@
  01c49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadKeyboardLayoutA@8

; 4444 : 
; 4445 : 						if (keybLayout != 0x00000409 && keybLayout != 0x04090409)

  01c4f	3d 09 04 00 00	 cmp	 eax, 1033		; 00000409H
  01c54	74 24		 je	 SHORT $LN118@PageDialog
  01c56	3d 09 04 09 04	 cmp	 eax, 67699721		; 04090409H
  01c5b	74 1d		 je	 SHORT $LN118@PageDialog

; 4446 : 						{
; 4447 : 							Error ("CANT_CHANGE_KEYB_LAYOUT_FOR_SYS_ENCRYPTION");

  01c5d	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@KAEHBIEI@CANT_CHANGE_KEYB_LAYOUT_FOR_SYS_@
$LN773@PageDialog:
  01c62	e8 00 00 00 00	 call	 _Error

; 4448 : 							EndMainDlg (MainDlg);

  01c67	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  01c6d	e8 00 00 00 00	 call	 _EndMainDlg
  01c72	83 c4 08	 add	 esp, 8

; 4449 : 							return 1;

  01c75	e9 49 37 00 00	 jmp	 $LN752@PageDialog
$LN118@PageDialog:

; 4450 : 						}
; 4451 : 						bKeyboardLayoutChanged = TRUE;

  01c7a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bKeyboardLayoutChanged@@3HA, 1 ; bKeyboardLayoutChanged
$LN117@PageDialog:

; 4452 : 					}
; 4453 : 
; 4454 : 					ShowWindow(GetDlgItem(hwndDlg, IDC_SHOW_PASSWORD), SW_HIDE);

  01c84	6a 00		 push	 0
  01c86	68 20 04 00 00	 push	 1056			; 00000420H
  01c8b	53		 push	 ebx
  01c8c	ff d7		 call	 edi
  01c8e	50		 push	 eax
  01c8f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 4455 : 
; 4456 : 					if (SetTimer (MainDlg, TIMER_ID_KEYB_LAYOUT_GUARD, TIMER_INTERVAL_KEYB_LAYOUT_GUARD, NULL) == 0)

  01c95	6a 00		 push	 0
  01c97	6a 0a		 push	 10			; 0000000aH
  01c99	68 04 01 00 00	 push	 260			; 00000104H
  01c9e	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  01ca4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
  01caa	85 c0		 test	 eax, eax
  01cac	75 07		 jne	 SHORT $LN119@PageDialog

; 4457 : 					{
; 4458 : 						Error ("CANNOT_SET_TIMER");

  01cae	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MMDPAFIK@CANNOT_SET_TIMER?$AA@

; 4459 : 						EndMainDlg (MainDlg);
; 4460 : 						return 1;

  01cb3	eb ad		 jmp	 SHORT $LN773@PageDialog
$LN119@PageDialog:

; 4461 : 					}
; 4462 : 				}
; 4463 : 
; 4464 : 				if (bHiddenVolHost)

  01cb5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  01cbc	74 1c		 je	 SHORT $LN120@PageDialog

; 4465 : 				{
; 4466 : 					wcsncpy (str, GetString (bHiddenOS ? "PASSWORD_SYSENC_OUTERVOL_HELP" : "PASSWORD_HIDDENVOL_HOST_HELP"), sizeof (str) / 2);

  01cbe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenOS@@3HC ; bHiddenOS
  01cc3	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BO@EJBBHKGE@PASSWORD_SYSENC_OUTERVOL_HELP?$AA@
  01cc8	85 c0		 test	 eax, eax
  01cca	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@OJJOHFMM@PASSWORD_HIDDENVOL_HOST_HELP?$AA@
  01ccf	68 e8 03 00 00	 push	 1000			; 000003e8H
  01cd4	0f 44 ca	 cmove	 ecx, edx
  01cd7	51		 push	 ecx
  01cd8	eb 5a		 jmp	 SHORT $LN753@PageDialog
$LN120@PageDialog:

; 4467 : 				}
; 4468 : 				else if (bHiddenVol)

  01cda	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  01ce1	74 47		 je	 SHORT $LN122@PageDialog

; 4469 : 				{
; 4470 : 					_snwprintf (str, sizeof str / 2, L"%s%s",

  01ce3	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MEODOKDB@PASSWORD_HELP?$AA@
  01ce8	e8 00 00 00 00	 call	 _GetString
  01ced	83 c4 04	 add	 esp, 4
  01cf0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BI@MNFELCPB@PASSWORD_HIDDENVOL_HELP?$AA@
  01cf5	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BI@PAGBOIIN@PASSWORD_HIDDEN_OS_HELP?$AA@
  01cfa	50		 push	 eax
  01cfb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenOS@@3HC ; bHiddenOS
  01d00	85 c0		 test	 eax, eax
  01d02	0f 44 ca	 cmove	 ecx, edx
  01d05	51		 push	 ecx
  01d06	e8 00 00 00 00	 call	 _GetString
  01d0b	83 c4 04	 add	 esp, 4
  01d0e	50		 push	 eax
  01d0f	68 00 00 00 00	 push	 OFFSET ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
  01d14	8d 85 60 f4 ff
	ff		 lea	 eax, DWORD PTR _str$27[ebp]
  01d1a	68 e8 03 00 00	 push	 1000			; 000003e8H
  01d1f	50		 push	 eax
  01d20	e8 00 00 00 00	 call	 __snwprintf
  01d25	83 c4 14	 add	 esp, 20			; 00000014H

; 4471 : 						GetString (bHiddenOS ? "PASSWORD_HIDDEN_OS_HELP" : "PASSWORD_HIDDENVOL_HELP"),
; 4472 : 						GetString ("PASSWORD_HELP"));
; 4473 : 				}
; 4474 : 				else

  01d28	eb 22		 jmp	 SHORT $LN123@PageDialog
$LN122@PageDialog:

; 4475 : 				{
; 4476 : 					wcsncpy (str, GetString ("PASSWORD_HELP"), sizeof (str) / 2);

  01d2a	68 e8 03 00 00	 push	 1000			; 000003e8H
  01d2f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MEODOKDB@PASSWORD_HELP?$AA@
$LN753@PageDialog:
  01d34	e8 00 00 00 00	 call	 _GetString
  01d39	83 c4 04	 add	 esp, 4
  01d3c	50		 push	 eax
  01d3d	8d 85 60 f4 ff
	ff		 lea	 eax, DWORD PTR _str$27[ebp]
  01d43	50		 push	 eax
  01d44	e8 00 00 00 00	 call	 _wcsncpy
  01d49	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN123@PageDialog:

; 4477 : 				}
; 4478 : 
; 4479 : 				SendMessage (GetDlgItem (hwndDlg, IDC_PASSWORD), EM_LIMITTEXT, MAX_PASSWORD, 0);

  01d4c	6a 00		 push	 0
  01d4e	6a 40		 push	 64			; 00000040H
  01d50	68 c5 00 00 00	 push	 197			; 000000c5H
  01d55	68 ec 03 00 00	 push	 1004			; 000003ecH
  01d5a	53		 push	 ebx
  01d5b	ff d7		 call	 edi
  01d5d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  01d63	50		 push	 eax
  01d64	ff d6		 call	 esi

; 4480 : 				SendMessage (GetDlgItem (hwndDlg, IDC_VERIFY), EM_LIMITTEXT, MAX_PASSWORD, 0);

  01d66	6a 00		 push	 0
  01d68	6a 40		 push	 64			; 00000040H
  01d6a	68 c5 00 00 00	 push	 197			; 000000c5H
  01d6f	68 f2 03 00 00	 push	 1010			; 000003f2H
  01d74	53		 push	 ebx
  01d75	ff d7		 call	 edi
  01d77	50		 push	 eax
  01d78	ff d6		 call	 esi

; 4481 : 
; 4482 : 				SetWindowText (GetDlgItem (hwndDlg, IDC_PASSWORD), szRawPassword);

  01d7a	68 00 00 00 00	 push	 OFFSET ?szRawPassword@@3PADA ; szRawPassword
  01d7f	68 ec 03 00 00	 push	 1004			; 000003ecH
  01d84	53		 push	 ebx
  01d85	ff d7		 call	 edi
  01d87	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  01d8d	50		 push	 eax
  01d8e	ff d6		 call	 esi

; 4483 : 				SetWindowText (GetDlgItem (hwndDlg, IDC_VERIFY), szVerify);

  01d90	68 00 00 00 00	 push	 OFFSET ?szVerify@@3PADA	; szVerify
  01d95	68 f2 03 00 00	 push	 1010			; 000003f2H
  01d9a	53		 push	 ebx
  01d9b	ff d7		 call	 edi
  01d9d	50		 push	 eax
  01d9e	ff d6		 call	 esi

; 4484 : 
; 4485 : 				SetFocus (GetDlgItem (hwndDlg, IDC_PASSWORD));

  01da0	68 ec 03 00 00	 push	 1004			; 000003ecH
  01da5	53		 push	 ebx
  01da6	ff d7		 call	 edi
  01da8	50		 push	 eax
  01da9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 4486 : 
; 4487 : 				SetCheckBox (hwndDlg, IDC_KEYFILES_ENABLE, KeyFilesEnable && !SysEncInEffect());

  01daf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KeyFilesEnable, 0
  01db6	74 10		 je	 SHORT $LN337@PageDialog
  01db8	e8 00 00 00 00	 call	 _SysEncInEffect
  01dbd	85 c0		 test	 eax, eax
  01dbf	75 07		 jne	 SHORT $LN337@PageDialog
  01dc1	b8 01 00 00 00	 mov	 eax, 1
  01dc6	eb 02		 jmp	 SHORT $LN338@PageDialog
$LN337@PageDialog:
  01dc8	33 c0		 xor	 eax, eax
$LN338@PageDialog:
  01dca	50		 push	 eax
  01dcb	68 c5 13 00 00	 push	 5061			; 000013c5H
  01dd0	53		 push	 ebx
  01dd1	e8 00 00 00 00	 call	 _SetCheckBox
  01dd6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4488 : 				EnableWindow (GetDlgItem (hwndDlg, IDC_KEY_FILES), KeyFilesEnable);

  01dd9	ff 35 00 00 00
	00		 push	 DWORD PTR _KeyFilesEnable
  01ddf	68 02 04 00 00	 push	 1026			; 00000402H
  01de4	53		 push	 ebx
  01de5	ff d7		 call	 edi
  01de7	50		 push	 eax
  01de8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4489 : 
; 4490 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), str);

  01dee	8d 85 60 f4 ff
	ff		 lea	 eax, DWORD PTR _str$27[ebp]
  01df4	50		 push	 eax
  01df5	68 eb 03 00 00	 push	 1003			; 000003ebH
  01dfa	53		 push	 ebx
  01dfb	ff d7		 call	 edi
  01dfd	50		 push	 eax
  01dfe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4491 : 
; 4492 : 				if (CreatingHiddenSysVol())

  01e04	e8 00 00 00 00	 call	 _CreatingHiddenSysVol
  01e09	85 c0		 test	 eax, eax
  01e0b	74 07		 je	 SHORT $LN124@PageDialog

; 4493 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("PASSWORD_HIDDEN_OS_TITLE"));

  01e0d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CPICCPLA@PASSWORD_HIDDEN_OS_TITLE?$AA@
  01e12	eb 35		 jmp	 SHORT $LN754@PageDialog
$LN124@PageDialog:

; 4494 : 				else if (bHiddenVol)

  01e14	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  01e1b	74 17		 je	 SHORT $LN126@PageDialog

; 4495 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString (bHiddenVolHost ? "PASSWORD_HIDVOL_HOST_TITLE" : "PASSWORD_HIDVOL_TITLE"));

  01e1d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bHiddenVolHost
  01e22	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BL@DDMDKDAG@PASSWORD_HIDVOL_HOST_TITLE?$AA@
  01e27	85 c0		 test	 eax, eax
  01e29	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@ILMPEOM@PASSWORD_HIDVOL_TITLE?$AA@
  01e2e	0f 44 ca	 cmove	 ecx, edx
  01e31	51		 push	 ecx
  01e32	eb 15		 jmp	 SHORT $LN754@PageDialog
$LN126@PageDialog:

; 4496 : 				else if (WizardMode == WIZARD_MODE_SYS_DEVICE)

  01e34	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  01e3b	75 07		 jne	 SHORT $LN128@PageDialog

; 4497 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("PASSWORD"));

  01e3d	68 00 00 00 00	 push	 OFFSET ??_C@_08KENNMKEI@PASSWORD?$AA@

; 4498 : 				else

  01e42	eb 05		 jmp	 SHORT $LN754@PageDialog
$LN128@PageDialog:

; 4499 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("PASSWORD_TITLE"));

  01e44	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ONGBFCBF@PASSWORD_TITLE?$AA@
$LN754@PageDialog:
  01e49	e8 00 00 00 00	 call	 _GetString
  01e4e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetParent@4
  01e54	83 c4 04	 add	 esp, 4
  01e57	50		 push	 eax
  01e58	68 e8 03 00 00	 push	 1000			; 000003e8H
  01e5d	53		 push	 ebx
  01e5e	ff d6		 call	 esi
  01e60	50		 push	 eax
  01e61	ff d7		 call	 edi
  01e63	50		 push	 eax
  01e64	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__SetWindowTextW@8
  01e69	ff d0		 call	 eax

; 4500 : 
; 4501 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  01e6b	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  01e70	e8 00 00 00 00	 call	 _GetString
  01e75	83 c4 04	 add	 esp, 4
  01e78	50		 push	 eax
  01e79	68 10 04 00 00	 push	 1040			; 00000410H
  01e7e	53		 push	 ebx
  01e7f	ff d6		 call	 esi
  01e81	50		 push	 eax
  01e82	ff d7		 call	 edi
  01e84	50		 push	 eax
  01e85	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4502 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  01e8b	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  01e90	e8 00 00 00 00	 call	 _GetString
  01e95	83 c4 04	 add	 esp, 4
  01e98	50		 push	 eax
  01e99	68 11 04 00 00	 push	 1041			; 00000411H
  01e9e	53		 push	 ebx
  01e9f	ff d6		 call	 esi
  01ea1	50		 push	 eax
  01ea2	ff d7		 call	 edi
  01ea4	50		 push	 eax
  01ea5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4503 : 
; 4504 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  01eab	6a 01		 push	 1
  01ead	68 11 04 00 00	 push	 1041			; 00000411H
  01eb2	53		 push	 ebx
  01eb3	ff d6		 call	 esi
  01eb5	50		 push	 eax
  01eb6	ff d7		 call	 edi
  01eb8	50		 push	 eax
  01eb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4505 : 
; 4506 : 				VerifyPasswordAndUpdate (hwndDlg, GetDlgItem (GetParent (hwndDlg), IDC_NEXT),

  01ebf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KeyFilesEnable, 0
  01ec6	74 19		 je	 SHORT $LN339@PageDialog
  01ec8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _FirstKeyFile, 0
  01ecf	74 10		 je	 SHORT $LN339@PageDialog
  01ed1	e8 00 00 00 00	 call	 _SysEncInEffect
  01ed6	85 c0		 test	 eax, eax
  01ed8	75 07		 jne	 SHORT $LN339@PageDialog
  01eda	b8 01 00 00 00	 mov	 eax, 1
  01edf	eb 02		 jmp	 SHORT $LN340@PageDialog
$LN339@PageDialog:
  01ee1	33 c0		 xor	 eax, eax
$LN340@PageDialog:
  01ee3	50		 push	 eax
  01ee4	6a 00		 push	 0
  01ee6	6a 00		 push	 0
  01ee8	68 f2 03 00 00	 push	 1010			; 000003f2H
  01eed	53		 push	 ebx
  01eee	ff d7		 call	 edi
  01ef0	50		 push	 eax
  01ef1	68 ec 03 00 00	 push	 1004			; 000003ecH
  01ef6	53		 push	 ebx
  01ef7	ff d7		 call	 edi
  01ef9	50		 push	 eax
  01efa	68 10 04 00 00	 push	 1040			; 00000410H
  01eff	53		 push	 ebx
  01f00	ff d6		 call	 esi
  01f02	50		 push	 eax
  01f03	ff d7		 call	 edi
  01f05	50		 push	 eax
  01f06	53		 push	 ebx
  01f07	e8 00 00 00 00	 call	 _VerifyPasswordAndUpdate

; 4507 : 					 GetDlgItem (hwndDlg, IDC_PASSWORD),
; 4508 : 					   GetDlgItem (hwndDlg, IDC_VERIFY),
; 4509 : 						      NULL,
; 4510 : 							  NULL,
; 4511 : 							  KeyFilesEnable && FirstKeyFile!=NULL && !SysEncInEffect());
; 4512 : 				volumePassword.Length = strlen ((char *) volumePassword.Text);

  01f0c	b9 04 00 00 00	 mov	 ecx, OFFSET ?volumePassword@@3UPassword@@A+4
  01f11	83 c4 1c	 add	 esp, 28			; 0000001cH
  01f14	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL706@PageDialog:
  01f17	8a 01		 mov	 al, BYTE PTR [ecx]
  01f19	41		 inc	 ecx
  01f1a	84 c0		 test	 al, al
  01f1c	75 f9		 jne	 SHORT $LL706@PageDialog
  01f1e	2b ca		 sub	 ecx, edx
  01f20	33 c0		 xor	 eax, eax
  01f22	89 0d 00 00 00
	00		 mov	 DWORD PTR ?volumePassword@@3UPassword@@A, ecx
  01f28	e9 9b 34 00 00	 jmp	 $LN1@PageDialog
$LN130@PageDialog:

; 4513 : 			}
; 4514 : 			break;
; 4515 : 
; 4516 : 		case FILESYS_PAGE:
; 4517 : 			{
; 4518 : 				wchar_t szTmp[8192];
; 4519 : 
; 4520 : 				Init2RadButtonPageYesNo (nNeedToStoreFilesOver4GB);

  01f2d	ff 35 00 00 00
	00		 push	 DWORD PTR ?nNeedToStoreFilesOver4GB@@3HA ; nNeedToStoreFilesOver4GB
  01f33	e8 00 00 00 00	 call	 ?Init2RadButtonPageYesNo@@YAXH@Z ; Init2RadButtonPageYesNo

; 4521 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("FILESYS_PAGE_TITLE"));

  01f38	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LCAKBGFA@FILESYS_PAGE_TITLE?$AA@
  01f3d	e8 00 00 00 00	 call	 _GetString
  01f42	83 c4 08	 add	 esp, 8
  01f45	50		 push	 eax
  01f46	68 e8 03 00 00	 push	 1000			; 000003e8H
  01f4b	53		 push	 ebx
  01f4c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  01f52	50		 push	 eax
  01f53	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  01f59	50		 push	 eax
  01f5a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4522 : 
; 4523 : 				wcscpy (szTmp, GetString ("FILESYS_PAGE_HELP_QUESTION"));

  01f60	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IEILEGP@FILESYS_PAGE_HELP_QUESTION?$AA@
  01f65	e8 00 00 00 00	 call	 _GetString
  01f6a	8d 95 e0 ed fe
	ff		 lea	 edx, DWORD PTR _szTmp$21[ebp]
  01f70	83 c4 04	 add	 esp, 4
  01f73	2b d0		 sub	 edx, eax
$LL341@PageDialog:
  01f75	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  01f78	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  01f7b	66 89 4c 10 fe	 mov	 WORD PTR [eax+edx-2], cx
  01f80	66 85 c9	 test	 cx, cx
  01f83	75 f0		 jne	 SHORT $LL341@PageDialog

; 4524 : 
; 4525 : 				if (bHiddenVolHost)

  01f85	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0

; 4526 : 					wcscat (szTmp, L"\n\n");

  01f8c	8d 8d e0 ed fe
	ff		 lea	 ecx, DWORD PTR _szTmp$21[ebp]
  01f92	74 2b		 je	 SHORT $LN131@PageDialog
  01f94	83 c1 fe	 add	 ecx, -2			; fffffffeH
  01f97	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL707@PageDialog:
  01fa0	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  01fa4	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  01fa7	66 85 c0	 test	 ax, ax
  01faa	75 f4		 jne	 SHORT $LL707@PageDialog
  01fac	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  01fb1	89 01		 mov	 DWORD PTR [ecx], eax
  01fb3	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@+4
  01fb9	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 4527 : 				else

  01fbd	eb 61		 jmp	 SHORT $LN132@PageDialog
$LN131@PageDialog:

; 4528 : 				{
; 4529 : 					wcscat (szTmp, L"\n\n\n");

  01fbf	83 c1 fe	 add	 ecx, -2			; fffffffeH
$LL708@PageDialog:
  01fc2	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  01fc6	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  01fc9	66 85 c0	 test	 ax, ax
  01fcc	75 f4		 jne	 SHORT $LL708@PageDialog
  01fce	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@
  01fd3	89 01		 mov	 DWORD PTR [ecx], eax
  01fd5	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@+4

; 4530 : 					wcscat (szTmp, GetString ("NOTE_BEGINNING"));

  01fda	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JPAMOBPC@NOTE_BEGINNING?$AA@
  01fdf	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  01fe2	e8 00 00 00 00	 call	 _GetString
  01fe7	8b d0		 mov	 edx, eax
  01fe9	83 c4 04	 add	 esp, 4
  01fec	8b f2		 mov	 esi, edx
  01fee	66 90		 npad	 2
$LL709@PageDialog:
  01ff0	66 8b 02	 mov	 ax, WORD PTR [edx]
  01ff3	83 c2 02	 add	 edx, 2
  01ff6	66 85 c0	 test	 ax, ax
  01ff9	75 f5		 jne	 SHORT $LL709@PageDialog
  01ffb	8d bd e0 ed fe
	ff		 lea	 edi, DWORD PTR _szTmp$21[ebp]
  02001	2b d6		 sub	 edx, esi
  02003	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL710@PageDialog:
  02006	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  0200a	83 c7 02	 add	 edi, 2
  0200d	66 85 c0	 test	 ax, ax
  02010	75 f4		 jne	 SHORT $LL710@PageDialog
  02012	8b ca		 mov	 ecx, edx
  02014	c1 e9 02	 shr	 ecx, 2
  02017	f3 a5		 rep movsd
  02019	8b ca		 mov	 ecx, edx
  0201b	83 e1 03	 and	 ecx, 3
  0201e	f3 a4		 rep movsb
$LN132@PageDialog:

; 4531 : 				}
; 4532 : 
; 4533 : 				wcscat (szTmp, GetString ("FILESYS_PAGE_HELP_EXPLANATION"));

  02020	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NPNHCCNA@FILESYS_PAGE_HELP_EXPLANATION?$AA@
  02025	e8 00 00 00 00	 call	 _GetString
  0202a	8b d0		 mov	 edx, eax
  0202c	83 c4 04	 add	 esp, 4
  0202f	8b f2		 mov	 esi, edx
$LL711@PageDialog:
  02031	66 8b 02	 mov	 ax, WORD PTR [edx]
  02034	83 c2 02	 add	 edx, 2
  02037	66 85 c0	 test	 ax, ax
  0203a	75 f5		 jne	 SHORT $LL711@PageDialog
  0203c	8d bd e0 ed fe
	ff		 lea	 edi, DWORD PTR _szTmp$21[ebp]
  02042	2b d6		 sub	 edx, esi
  02044	83 c7 fe	 add	 edi, -2			; fffffffeH
  02047	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL712@PageDialog:
  02050	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  02054	83 c7 02	 add	 edi, 2
  02057	66 85 c0	 test	 ax, ax
  0205a	75 f4		 jne	 SHORT $LL712@PageDialog
  0205c	8b ca		 mov	 ecx, edx
  0205e	c1 e9 02	 shr	 ecx, 2
  02061	f3 a5		 rep movsd
  02063	8b ca		 mov	 ecx, edx
  02065	83 e1 03	 and	 ecx, 3

; 4534 : 
; 4535 : 				if (bHiddenVolHost)

  02068	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  0206f	f3 a4		 rep movsb
  02071	74 67		 je	 SHORT $LN133@PageDialog

; 4536 : 				{
; 4537 : 					wcscat (szTmp, L" ");

  02073	8d bd e0 ed fe
	ff		 lea	 edi, DWORD PTR _szTmp$21[ebp]
  02079	83 c7 fe	 add	 edi, -2			; fffffffeH
  0207c	0f 1f 40 00	 npad	 4
$LL713@PageDialog:
  02080	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  02084	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]
  02087	66 85 c0	 test	 ax, ax
  0208a	75 f4		 jne	 SHORT $LL713@PageDialog
  0208c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@

; 4538 : 					wcscat (szTmp, GetString ("FILESYS_PAGE_HELP_EXPLANATION_HIDVOL"));

  02091	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BDOPEICN@FILESYS_PAGE_HELP_EXPLANATION_HI@
  02096	89 07		 mov	 DWORD PTR [edi], eax
  02098	e8 00 00 00 00	 call	 _GetString
  0209d	8b d0		 mov	 edx, eax
  0209f	83 c4 04	 add	 esp, 4
  020a2	8b f2		 mov	 esi, edx
$LL714@PageDialog:
  020a4	66 8b 02	 mov	 ax, WORD PTR [edx]
  020a7	83 c2 02	 add	 edx, 2
  020aa	66 85 c0	 test	 ax, ax
  020ad	75 f5		 jne	 SHORT $LL714@PageDialog
  020af	8d bd e0 ed fe
	ff		 lea	 edi, DWORD PTR _szTmp$21[ebp]
  020b5	2b d6		 sub	 edx, esi
  020b7	83 c7 fe	 add	 edi, -2			; fffffffeH
  020ba	66 0f 1f 44 00
	00		 npad	 6
$LL715@PageDialog:
  020c0	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  020c4	83 c7 02	 add	 edi, 2
  020c7	66 85 c0	 test	 ax, ax
  020ca	75 f4		 jne	 SHORT $LL715@PageDialog
  020cc	8b ca		 mov	 ecx, edx
  020ce	c1 e9 02	 shr	 ecx, 2
  020d1	f3 a5		 rep movsd
  020d3	8b ca		 mov	 ecx, edx
  020d5	83 e1 03	 and	 ecx, 3
  020d8	f3 a4		 rep movsb
$LN133@PageDialog:

; 4539 : 				}
; 4540 : 
; 4541 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), szTmp);

  020da	8d 85 e0 ed fe
	ff		 lea	 eax, DWORD PTR _szTmp$21[ebp]
  020e0	50		 push	 eax
  020e1	68 eb 03 00 00	 push	 1003			; 000003ebH
  020e6	53		 push	 ebx
  020e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  020ed	50		 push	 eax
  020ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
  020f4	33 c0		 xor	 eax, eax
  020f6	e9 cd 32 00 00	 jmp	 $LN1@PageDialog
$LN134@PageDialog:

; 4542 : 			}
; 4543 : 			break;
; 4544 : 
; 4545 : 		case SYSENC_COLLECTING_RANDOM_DATA_PAGE:
; 4546 : 		case NONSYS_INPLACE_ENC_RAND_DATA_PAGE:
; 4547 : 
; 4548 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("COLLECTING_RANDOM_DATA_TITLE"));

  020fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DAHBFIJD@COLLECTING_RANDOM_DATA_TITLE?$AA@
  02100	e8 00 00 00 00	 call	 _GetString
  02105	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  0210b	83 c4 04	 add	 esp, 4
  0210e	50		 push	 eax
  0210f	68 e8 03 00 00	 push	 1000			; 000003e8H
  02114	53		 push	 ebx
  02115	ff d7		 call	 edi
  02117	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  0211d	50		 push	 eax
  0211e	ff d3		 call	 ebx
  02120	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  02126	50		 push	 eax
  02127	ff d6		 call	 esi

; 4549 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  02129	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  0212e	e8 00 00 00 00	 call	 _GetString
  02133	83 c4 04	 add	 esp, 4
  02136	50		 push	 eax
  02137	68 10 04 00 00	 push	 1040			; 00000410H
  0213c	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02142	ff d7		 call	 edi
  02144	50		 push	 eax
  02145	ff d3		 call	 ebx
  02147	50		 push	 eax
  02148	ff d6		 call	 esi

; 4550 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  0214a	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  0214f	e8 00 00 00 00	 call	 _GetString
  02154	83 c4 04	 add	 esp, 4
  02157	50		 push	 eax
  02158	68 11 04 00 00	 push	 1041			; 00000411H
  0215d	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02163	ff d7		 call	 edi
  02165	50		 push	 eax
  02166	ff d3		 call	 ebx
  02168	50		 push	 eax
  02169	ff d6		 call	 esi

; 4551 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  0216b	6a 01		 push	 1
  0216d	68 10 04 00 00	 push	 1040			; 00000410H
  02172	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02178	ff d7		 call	 edi
  0217a	50		 push	 eax
  0217b	ff d3		 call	 ebx
  0217d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  02183	50		 push	 eax
  02184	ff d6		 call	 esi

; 4552 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  02186	6a 01		 push	 1
  02188	68 11 04 00 00	 push	 1041			; 00000411H
  0218d	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02193	ff d7		 call	 edi
  02195	50		 push	 eax
  02196	ff d3		 call	 ebx
  02198	50		 push	 eax
  02199	ff d6		 call	 esi

; 4553 : 
; 4554 : 			SetTimer (GetParent (hwndDlg), TIMER_ID_RANDVIEW, TIMER_INTERVAL_RANDVIEW, NULL);

  0219b	8b b5 7c eb fe
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  021a1	6a 00		 push	 0
  021a3	6a 1e		 push	 30			; 0000001eH
  021a5	68 ff 00 00 00	 push	 255			; 000000ffH
  021aa	56		 push	 esi
  021ab	ff d7		 call	 edi
  021ad	50		 push	 eax
  021ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 4555 : 
; 4556 : 			hRandPoolSys = GetDlgItem (hwndDlg, IDC_SYS_POOL_CONTENTS);

  021b4	68 38 04 00 00	 push	 1080			; 00000438H
  021b9	56		 push	 esi
  021ba	ff d3		 call	 ebx

; 4557 : 
; 4558 : 			SendMessage (GetDlgItem (hwndDlg, IDC_SYS_POOL_CONTENTS), WM_SETFONT, (WPARAM) hFixedDigitFont, (LPARAM) TRUE);

  021bc	6a 01		 push	 1
  021be	ff 35 00 00 00
	00		 push	 DWORD PTR _hFixedDigitFont
  021c4	a3 00 00 00 00	 mov	 DWORD PTR ?hRandPoolSys@@3RAUHWND__@@A, eax ; hRandPoolSys
  021c9	6a 30		 push	 48			; 00000030H
  021cb	68 38 04 00 00	 push	 1080			; 00000438H
  021d0	56		 push	 esi
  021d1	ff d3		 call	 ebx
  021d3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  021d9	50		 push	 eax
  021da	ff d6		 call	 esi

; 4559 : 
; 4560 : 			SendMessage (GetDlgItem (hwndDlg, IDC_DISPLAY_POOL_CONTENTS), BM_SETCHECK, showKeys ? BST_CHECKED : BST_UNCHECKED, 0);

  021dc	33 c0		 xor	 eax, eax
  021de	39 05 00 00 00
	00		 cmp	 DWORD PTR _showKeys, eax
  021e4	6a 00		 push	 0
  021e6	0f 95 c0	 setne	 al
  021e9	50		 push	 eax
  021ea	68 f1 00 00 00	 push	 241			; 000000f1H
  021ef	68 da 13 00 00	 push	 5082			; 000013daH
  021f4	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  021fa	ff d3		 call	 ebx
  021fc	50		 push	 eax
  021fd	ff d6		 call	 esi

; 4561 : 
; 4562 : 			DisplayRandPool (hRandPoolSys, showKeys);

  021ff	ff 35 00 00 00
	00		 push	 DWORD PTR _showKeys
  02205	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hRandPoolSys@@3RAUHWND__@@A ; hRandPoolSys
  0220a	50		 push	 eax
  0220b	e8 00 00 00 00	 call	 _DisplayRandPool
  02210	83 c4 08	 add	 esp, 8
  02213	33 c0		 xor	 eax, eax
  02215	e9 ae 31 00 00	 jmp	 $LN1@PageDialog
$LN135@PageDialog:

; 4563 : 
; 4564 : 			break;
; 4565 : 
; 4566 : 		case SYSENC_KEYS_GEN_PAGE:
; 4567 : 
; 4568 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("KEYS_GEN_TITLE"));

  0221a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KEHBBAFI@KEYS_GEN_TITLE?$AA@
  0221f	e8 00 00 00 00	 call	 _GetString
  02224	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  0222a	83 c4 04	 add	 esp, 4
  0222d	50		 push	 eax
  0222e	68 e8 03 00 00	 push	 1000			; 000003e8H
  02233	53		 push	 ebx
  02234	ff d7		 call	 edi
  02236	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  0223c	50		 push	 eax
  0223d	ff d3		 call	 ebx
  0223f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  02245	50		 push	 eax
  02246	ff d6		 call	 esi

; 4569 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  02248	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  0224d	e8 00 00 00 00	 call	 _GetString
  02252	83 c4 04	 add	 esp, 4
  02255	50		 push	 eax
  02256	68 10 04 00 00	 push	 1040			; 00000410H
  0225b	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02261	ff d7		 call	 edi
  02263	50		 push	 eax
  02264	ff d3		 call	 ebx
  02266	50		 push	 eax
  02267	ff d6		 call	 esi

; 4570 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  02269	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  0226e	e8 00 00 00 00	 call	 _GetString
  02273	83 c4 04	 add	 esp, 4
  02276	50		 push	 eax
  02277	68 11 04 00 00	 push	 1041			; 00000411H
  0227c	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02282	ff d7		 call	 edi
  02284	50		 push	 eax
  02285	ff d3		 call	 ebx
  02287	50		 push	 eax
  02288	ff d6		 call	 esi

; 4571 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  0228a	6a 01		 push	 1
  0228c	68 10 04 00 00	 push	 1040			; 00000410H
  02291	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02297	ff d7		 call	 edi
  02299	50		 push	 eax
  0229a	ff d3		 call	 ebx
  0229c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  022a2	50		 push	 eax
  022a3	ff d6		 call	 esi

; 4572 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  022a5	6a 01		 push	 1
  022a7	68 11 04 00 00	 push	 1041			; 00000411H
  022ac	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  022b2	ff d7		 call	 edi
  022b4	50		 push	 eax
  022b5	ff d3		 call	 ebx
  022b7	50		 push	 eax
  022b8	ff d6		 call	 esi

; 4573 : 
; 4574 : 			hMasterKey = GetDlgItem (hwndDlg, IDC_DISK_KEY);

  022ba	8b bd 7c eb fe
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  022c0	68 fb 03 00 00	 push	 1019			; 000003fbH
  022c5	57		 push	 edi
  022c6	ff d3		 call	 ebx

; 4575 : 			hHeaderKey = GetDlgItem (hwndDlg, IDC_HEADER_KEY);

  022c8	68 f9 03 00 00	 push	 1017			; 000003f9H
  022cd	57		 push	 edi
  022ce	a3 00 00 00 00	 mov	 DWORD PTR _hMasterKey, eax
  022d3	ff d3		 call	 ebx

; 4576 : 
; 4577 : 			SendMessage (GetDlgItem (hwndDlg, IDC_DISK_KEY), WM_SETFONT, (WPARAM) hFixedDigitFont, (LPARAM) TRUE);

  022d5	6a 01		 push	 1
  022d7	ff 35 00 00 00
	00		 push	 DWORD PTR _hFixedDigitFont
  022dd	a3 00 00 00 00	 mov	 DWORD PTR _hHeaderKey, eax
  022e2	6a 30		 push	 48			; 00000030H
  022e4	68 fb 03 00 00	 push	 1019			; 000003fbH
  022e9	57		 push	 edi
  022ea	ff d3		 call	 ebx
  022ec	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  022f2	50		 push	 eax
  022f3	ff d6		 call	 esi

; 4578 : 			SendMessage (GetDlgItem (hwndDlg, IDC_HEADER_KEY), WM_SETFONT, (WPARAM) hFixedDigitFont, (LPARAM) TRUE);

  022f5	6a 01		 push	 1
  022f7	ff 35 00 00 00
	00		 push	 DWORD PTR _hFixedDigitFont
  022fd	6a 30		 push	 48			; 00000030H
  022ff	68 f9 03 00 00	 push	 1017			; 000003f9H
  02304	57		 push	 edi
  02305	ff d3		 call	 ebx
  02307	50		 push	 eax
  02308	ff d6		 call	 esi

; 4579 : 
; 4580 : 			SendMessage (GetDlgItem (hwndDlg, IDC_DISPLAY_KEYS), BM_SETCHECK, showKeys ? BST_CHECKED : BST_UNCHECKED, 0);

  0230a	6a 00		 push	 0
  0230c	33 c0		 xor	 eax, eax
  0230e	39 05 00 00 00
	00		 cmp	 DWORD PTR _showKeys, eax
  02314	0f 95 c0	 setne	 al
  02317	50		 push	 eax
  02318	68 f1 00 00 00	 push	 241			; 000000f1H
  0231d	68 40 04 00 00	 push	 1088			; 00000440H
  02322	57		 push	 edi
  02323	ff d3		 call	 ebx
  02325	50		 push	 eax
  02326	ff d6		 call	 esi

; 4581 : 
; 4582 : 			DisplayPortionsOfKeys (hHeaderKey, hMasterKey, HeaderKeyGUIView, MasterKeyGUIView, !showKeys);

  02328	33 c0		 xor	 eax, eax
  0232a	39 05 00 00 00
	00		 cmp	 DWORD PTR _showKeys, eax
  02330	0f 94 c0	 sete	 al
  02333	50		 push	 eax
  02334	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMasterKey
  02339	68 00 00 00 00	 push	 OFFSET _MasterKeyGUIView
  0233e	68 00 00 00 00	 push	 OFFSET _HeaderKeyGUIView
  02343	50		 push	 eax
  02344	a1 00 00 00 00	 mov	 eax, DWORD PTR _hHeaderKey
  02349	50		 push	 eax
  0234a	e8 00 00 00 00	 call	 _DisplayPortionsOfKeys
  0234f	83 c4 14	 add	 esp, 20			; 00000014H
  02352	33 c0		 xor	 eax, eax
  02354	e9 6f 30 00 00	 jmp	 $LN1@PageDialog
$LN136@PageDialog:

; 4583 : 
; 4584 : 			break;
; 4585 : 
; 4586 : 		case SYSENC_RESCUE_DISK_CREATION_PAGE:
; 4587 : 
; 4588 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("RESCUE_DISK"));

  02359	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IGHMLIGA@RESCUE_DISK?$AA@
  0235e	e8 00 00 00 00	 call	 _GetString
  02363	83 c4 04	 add	 esp, 4
  02366	50		 push	 eax
  02367	68 e8 03 00 00	 push	 1000			; 000003e8H
  0236c	53		 push	 ebx
  0236d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  02373	ff d3		 call	 ebx
  02375	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0237b	50		 push	 eax
  0237c	ff d7		 call	 edi
  0237e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  02384	50		 push	 eax
  02385	ff d6		 call	 esi

; 4589 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  02387	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  0238c	e8 00 00 00 00	 call	 _GetString
  02391	83 c4 04	 add	 esp, 4
  02394	50		 push	 eax
  02395	68 10 04 00 00	 push	 1040			; 00000410H
  0239a	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  023a0	ff d3		 call	 ebx
  023a2	50		 push	 eax
  023a3	ff d7		 call	 edi
  023a5	50		 push	 eax
  023a6	ff d6		 call	 esi

; 4590 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  023a8	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  023ad	e8 00 00 00 00	 call	 _GetString
  023b2	83 c4 04	 add	 esp, 4
  023b5	50		 push	 eax
  023b6	68 11 04 00 00	 push	 1041			; 00000411H
  023bb	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  023c1	ff d3		 call	 ebx
  023c3	50		 push	 eax
  023c4	ff d7		 call	 edi
  023c6	50		 push	 eax
  023c7	ff d6		 call	 esi

; 4591 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDT_RESCUE_DISK_INFO), GetString ("RESCUE_DISK_INFO"));

  023c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KBMALCGN@RESCUE_DISK_INFO?$AA@
  023ce	e8 00 00 00 00	 call	 _GetString
  023d3	83 c4 04	 add	 esp, 4
  023d6	50		 push	 eax
  023d7	68 2f 04 00 00	 push	 1071			; 0000042fH
  023dc	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  023e2	ff d7		 call	 edi
  023e4	50		 push	 eax
  023e5	ff d6		 call	 esi

; 4592 : 			SetDlgItemText (hwndDlg, IDC_RESCUE_DISK_ISO_PATH, szRescueDiskISO);

  023e7	8b b5 7c eb fe
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  023ed	68 00 00 00 00	 push	 OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  023f2	68 e9 03 00 00	 push	 1001			; 000003e9H
  023f7	56		 push	 esi
  023f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextA@12

; 4593 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), (GetWindowTextLength (GetDlgItem (hwndDlg, IDC_RESCUE_DISK_ISO_PATH)) > 1));

  023fe	68 e9 03 00 00	 push	 1001			; 000003e9H
  02403	56		 push	 esi
  02404	ff d7		 call	 edi
  02406	50		 push	 eax
  02407	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  0240d	33 c9		 xor	 ecx, ecx
  0240f	83 f8 01	 cmp	 eax, 1
  02412	0f 9f c1	 setg	 cl
  02415	51		 push	 ecx
  02416	68 10 04 00 00	 push	 1040			; 00000410H
  0241b	56		 push	 esi
  0241c	ff d3		 call	 ebx
  0241e	50		 push	 eax
  0241f	ff d7		 call	 edi
  02421	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  02427	50		 push	 eax
  02428	ff d6		 call	 esi

; 4594 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  0242a	6a 01		 push	 1
  0242c	68 11 04 00 00	 push	 1041			; 00000411H
  02431	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02437	ff d3		 call	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  02439	50		 push	 eax
  0243a	ff d7		 call	 edi
  0243c	50		 push	 eax
  0243d	ff d6		 call	 esi
  0243f	33 c0		 xor	 eax, eax
  02441	e9 82 2f 00 00	 jmp	 $LN1@PageDialog
$LN137@PageDialog:

; 4595 : 
; 4596 : 			break;
; 4597 : 
; 4598 : 		case SYSENC_RESCUE_DISK_BURN_PAGE:
; 4599 : 			{
; 4600 : 				wchar_t szTmp[8192];
; 4601 : 
; 4602 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString (bDontVerifyRescueDisk ? "RESCUE_DISK_CREATED_TITLE" : "RESCUE_DISK_RECORDING_TITLE"));

  02446	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDontVerifyRescueDisk@@3HA, 0 ; bDontVerifyRescueDisk
  0244d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BM@GPDOJGLC@RESCUE_DISK_RECORDING_TITLE?$AA@
  02452	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BK@NAGNMEFO@RESCUE_DISK_CREATED_TITLE?$AA@
  02457	0f 44 c1	 cmove	 eax, ecx
  0245a	50		 push	 eax
  0245b	e8 00 00 00 00	 call	 _GetString
  02460	83 c4 04	 add	 esp, 4
  02463	50		 push	 eax
  02464	68 e8 03 00 00	 push	 1000			; 000003e8H
  02469	53		 push	 ebx
  0246a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  02470	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  02476	50		 push	 eax
  02477	ff d7		 call	 edi
  02479	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  0247f	50		 push	 eax
  02480	ff d6		 call	 esi

; 4603 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  02482	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  02487	e8 00 00 00 00	 call	 _GetString
  0248c	83 c4 04	 add	 esp, 4
  0248f	50		 push	 eax
  02490	68 10 04 00 00	 push	 1040			; 00000410H
  02495	53		 push	 ebx
  02496	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0249c	50		 push	 eax
  0249d	ff d7		 call	 edi
  0249f	50		 push	 eax
  024a0	ff d6		 call	 esi

; 4604 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  024a2	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  024a7	e8 00 00 00 00	 call	 _GetString
  024ac	83 c4 04	 add	 esp, 4
  024af	50		 push	 eax
  024b0	68 11 04 00 00	 push	 1041			; 00000411H
  024b5	53		 push	 ebx
  024b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  024bc	50		 push	 eax
  024bd	ff d7		 call	 edi
  024bf	50		 push	 eax
  024c0	ff d6		 call	 esi

; 4605 : 
; 4606 : 				_snwprintf (szTmp, sizeof szTmp / 2,

  024c2	e8 00 00 00 00	 call	 _IsWindowsIsoBurnerAvailable
  024c7	85 c0		 test	 eax, eax
  024c9	74 07		 je	 SHORT $LN342@PageDialog
  024cb	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  024d0	eb 0d		 jmp	 SHORT $LN343@PageDialog
$LN342@PageDialog:
  024d2	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@IHEJGKND@RESCUE_DISK_BURN_INFO_NONWIN_ISO@
  024d7	e8 00 00 00 00	 call	 _GetString
  024dc	83 c4 04	 add	 esp, 4
$LN343@PageDialog:
  024df	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDontVerifyRescueDisk@@3HA, 0 ; bDontVerifyRescueDisk
  024e6	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BG@KIJPDAJH@RESCUE_DISK_BURN_INFO?$AA@
  024eb	50		 push	 eax
  024ec	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BP@JAENMDIB@RESCUE_DISK_BURN_INFO_NO_CHECK?$AA@
  024f1	0f 44 c1	 cmove	 eax, ecx
  024f4	68 00 00 00 00	 push	 OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  024f9	50		 push	 eax
  024fa	e8 00 00 00 00	 call	 _GetString
  024ff	83 c4 04	 add	 esp, 4
  02502	50		 push	 eax
  02503	8d 85 90 ac ff
	ff		 lea	 eax, DWORD PTR _szTmp$25[ebp]
  02509	68 00 20 00 00	 push	 8192			; 00002000H
  0250e	50		 push	 eax
  0250f	e8 00 00 00 00	 call	 __snwprintf
  02514	83 c4 14	 add	 esp, 20			; 00000014H

; 4607 : 					GetString (bDontVerifyRescueDisk ? "RESCUE_DISK_BURN_INFO_NO_CHECK" : "RESCUE_DISK_BURN_INFO"),
; 4608 : 					szRescueDiskISO, IsWindowsIsoBurnerAvailable() ? L"" : GetString ("RESCUE_DISK_BURN_INFO_NONWIN_ISO_BURNER"));
; 4609 : 
; 4610 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDT_RESCUE_DISK_BURN_INFO), szTmp);

  02517	8d 85 90 ac ff
	ff		 lea	 eax, DWORD PTR _szTmp$25[ebp]
  0251d	50		 push	 eax
  0251e	68 3b 04 00 00	 push	 1083			; 0000043bH
  02523	53		 push	 ebx
  02524	ff d7		 call	 edi
  02526	50		 push	 eax
  02527	ff d6		 call	 esi

; 4611 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  02529	6a 01		 push	 1
  0252b	68 10 04 00 00	 push	 1040			; 00000410H
  02530	53		 push	 ebx
  02531	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  02537	50		 push	 eax
  02538	ff d7		 call	 edi
  0253a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  02540	50		 push	 eax
  02541	ff d6		 call	 esi

; 4612 : 
; 4613 : 				/* The 'Back' button must be disabled now because the user could burn a Rescue Disk, then go back, and
; 4614 : 				generate a different master key, which would cause the Rescue Disk verification to fail (the result
; 4615 : 				would be confusion and bug reports). */
; 4616 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  02543	6a 00		 push	 0
  02545	68 11 04 00 00	 push	 1041			; 00000411H
  0254a	53		 push	 ebx
  0254b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  02551	50		 push	 eax
  02552	ff d7		 call	 edi
  02554	50		 push	 eax
  02555	ff d6		 call	 esi

; 4617 : 
; 4618 : 				if (IsWindowsIsoBurnerAvailable())

  02557	e8 00 00 00 00	 call	 _IsWindowsIsoBurnerAvailable
  0255c	85 c0		 test	 eax, eax
  0255e	74 1d		 je	 SHORT $LN138@PageDialog

; 4619 : 					SetWindowTextW (GetDlgItem (hwndDlg, IDC_DOWNLOAD_CD_BURN_SOFTWARE), GetString ("LAUNCH_WIN_ISOBURN"));

  02560	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CHINNFGJ@LAUNCH_WIN_ISOBURN?$AA@
  02565	e8 00 00 00 00	 call	 _GetString
  0256a	83 c4 04	 add	 esp, 4
  0256d	50		 push	 eax
  0256e	68 3a 04 00 00	 push	 1082			; 0000043aH
  02573	53		 push	 ebx
  02574	ff d7		 call	 edi
  02576	50		 push	 eax
  02577	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
$LN138@PageDialog:

; 4620 : 
; 4621 : 				ToHyperlink (hwndDlg, IDC_DOWNLOAD_CD_BURN_SOFTWARE);

  0257d	68 3a 04 00 00	 push	 1082			; 0000043aH
  02582	53		 push	 ebx
  02583	e8 00 00 00 00	 call	 _ToHyperlink
  02588	83 c4 08	 add	 esp, 8

; 4622 : 
; 4623 : 				if (IsWindowsIsoBurnerAvailable() && !bDontVerifyRescueDisk)

  0258b	e8 00 00 00 00	 call	 _IsWindowsIsoBurnerAvailable
  02590	85 c0		 test	 eax, eax
  02592	0f 84 41 e2 ff
	ff		 je	 $LN384@PageDialog
  02598	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDontVerifyRescueDisk@@3HA, 0 ; bDontVerifyRescueDisk
  0259f	0f 85 34 e2 ff
	ff		 jne	 $LN384@PageDialog

; 4624 : 					LaunchWindowsIsoBurner (hwndDlg, szRescueDiskISO);

  025a5	68 00 00 00 00	 push	 OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  025aa	53		 push	 ebx
  025ab	e8 00 00 00 00	 call	 _LaunchWindowsIsoBurner
  025b0	83 c4 08	 add	 esp, 8
  025b3	33 c0		 xor	 eax, eax
  025b5	e9 0e 2e 00 00	 jmp	 $LN1@PageDialog
$LN140@PageDialog:

; 4625 : 			}
; 4626 : 			break;
; 4627 : 
; 4628 : 		case SYSENC_RESCUE_DISK_VERIFIED_PAGE:
; 4629 : 
; 4630 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("RESCUE_DISK_DISK_VERIFIED_TITLE"));

  025ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@OFKHEBFP@RESCUE_DISK_DISK_VERIFIED_TITLE?$AA@
  025bf	e8 00 00 00 00	 call	 _GetString
  025c4	83 c4 04	 add	 esp, 4
  025c7	50		 push	 eax
  025c8	68 e8 03 00 00	 push	 1000			; 000003e8H
  025cd	53		 push	 ebx
  025ce	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  025d4	ff d3		 call	 ebx
  025d6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  025dc	50		 push	 eax
  025dd	ff d7		 call	 edi
  025df	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  025e5	50		 push	 eax
  025e6	ff d6		 call	 esi

; 4631 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("RESCUE_DISK_VERIFIED_INFO"));

  025e8	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PHEMJDOE@RESCUE_DISK_VERIFIED_INFO?$AA@
  025ed	e8 00 00 00 00	 call	 _GetString
  025f2	83 c4 04	 add	 esp, 4
  025f5	50		 push	 eax
  025f6	68 eb 03 00 00	 push	 1003			; 000003ebH
  025fb	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02601	ff d7		 call	 edi
  02603	50		 push	 eax
  02604	ff d6		 call	 esi

; 4632 : 
; 4633 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  02606	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  0260b	e8 00 00 00 00	 call	 _GetString
  02610	83 c4 04	 add	 esp, 4
  02613	50		 push	 eax
  02614	68 10 04 00 00	 push	 1040			; 00000410H
  02619	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0261f	ff d3		 call	 ebx
  02621	50		 push	 eax
  02622	ff d7		 call	 edi
  02624	50		 push	 eax
  02625	ff d6		 call	 esi

; 4634 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  02627	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  0262c	e8 00 00 00 00	 call	 _GetString
  02631	83 c4 04	 add	 esp, 4
  02634	50		 push	 eax
  02635	68 11 04 00 00	 push	 1041			; 00000411H
  0263a	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02640	ff d3		 call	 ebx
  02642	50		 push	 eax
  02643	ff d7		 call	 edi
  02645	50		 push	 eax
  02646	ff d6		 call	 esi

; 4635 : 
; 4636 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  02648	6a 01		 push	 1
  0264a	68 10 04 00 00	 push	 1040			; 00000410H
  0264f	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02655	ff d3		 call	 ebx
  02657	50		 push	 eax
  02658	ff d7		 call	 edi
  0265a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  02660	50		 push	 eax
  02661	ff d6		 call	 esi

; 4637 : 
; 4638 : 			// Rescue Disk has been verified, no need to go back
; 4639 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  02663	6a 00		 push	 0
  02665	68 11 04 00 00	 push	 1041			; 00000411H
  0266a	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02670	ff d3		 call	 ebx
  02672	50		 push	 eax
  02673	ff d7		 call	 edi
  02675	50		 push	 eax
  02676	ff d6		 call	 esi

; 4640 : 
; 4641 : 			// Prevent losing the burned rescue disk by inadvertent exit
; 4642 : 			bConfirmQuit = TRUE;

  02678	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bConfirmQuit@@3HC, 1 ; bConfirmQuit
  02682	33 c0		 xor	 eax, eax
  02684	e9 3f 2d 00 00	 jmp	 $LN1@PageDialog
$LN141@PageDialog:

; 4643 : 
; 4644 : 			break;
; 4645 : 
; 4646 : 		case SYSENC_WIPE_MODE_PAGE:
; 4647 : 		case NONSYS_INPLACE_ENC_WIPE_MODE_PAGE:
; 4648 : 			{
; 4649 : 				if (nWipeMode == GST_WIPE_1_RAND)

  02689	a1 00 00 00 00	 mov	 eax, DWORD PTR _nWipeMode
  0268e	33 c9		 xor	 ecx, ecx
  02690	83 f8 64	 cmp	 eax, 100		; 00000064H

; 4650 : 					nWipeMode = GST_WIPE_NONE;
; 4651 : 
; 4652 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("WIPE_MODE_TITLE"));

  02693	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GEMFOMCA@WIPE_MODE_TITLE?$AA@
  02698	0f 44 c1	 cmove	 eax, ecx
  0269b	a3 00 00 00 00	 mov	 DWORD PTR _nWipeMode, eax
  026a0	e8 00 00 00 00	 call	 _GetString
  026a5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetParent@4
  026ab	83 c4 04	 add	 esp, 4
  026ae	50		 push	 eax
  026af	68 e8 03 00 00	 push	 1000			; 000003e8H
  026b4	53		 push	 ebx
  026b5	ff d6		 call	 esi
  026b7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  026bd	50		 push	 eax
  026be	ff d7		 call	 edi
  026c0	50		 push	 eax
  026c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4653 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDT_WIPE_MODE_INFO), GetString ("INPLACE_ENC_WIPE_MODE_INFO"));

  026c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KPLPAAMG@INPLACE_ENC_WIPE_MODE_INFO?$AA@
  026cc	e8 00 00 00 00	 call	 _GetString
  026d1	83 c4 04	 add	 esp, 4
  026d4	50		 push	 eax
  026d5	68 3c 04 00 00	 push	 1084			; 0000043cH
  026da	53		 push	 ebx
  026db	ff d7		 call	 edi
  026dd	50		 push	 eax
  026de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4654 : 
; 4655 : 				PopulateWipeModeCombo (GetDlgItem (hwndDlg, IDC_WIPE_MODE), 

  026e4	81 3d 00 00 00
	00 58 02 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 600 ; 00000258H
  026ee	75 10		 jne	 SHORT $LN344@PageDialog
  026f0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  026f7	75 07		 jne	 SHORT $LN344@PageDialog
  026f9	b8 01 00 00 00	 mov	 eax, 1
  026fe	eb 02		 jmp	 SHORT $LN345@PageDialog
$LN344@PageDialog:
  02700	33 c0		 xor	 eax, eax
$LN345@PageDialog:
  02702	6a 01		 push	 1
  02704	50		 push	 eax
  02705	68 3d 04 00 00	 push	 1085			; 0000043dH
  0270a	53		 push	 ebx
  0270b	ff d7		 call	 edi
  0270d	50		 push	 eax
  0270e	e8 00 00 00 00	 call	 _PopulateWipeModeCombo
  02713	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4656 : 					SystemEncryptionStatus == SYSENC_STATUS_DECRYPTING && !bInPlaceEncNonSys,
; 4657 : 					TRUE);
; 4658 : 
; 4659 : 				SelectAlgo (GetDlgItem (hwndDlg, IDC_WIPE_MODE), (int *) &nWipeMode);

  02716	68 00 00 00 00	 push	 OFFSET _nWipeMode
  0271b	68 3d 04 00 00	 push	 1085			; 0000043dH
  02720	53		 push	 ebx
  02721	ff d7		 call	 edi
  02723	50		 push	 eax
  02724	e8 00 00 00 00	 call	 _SelectAlgo

; 4660 : 
; 4661 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  02729	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  0272e	e8 00 00 00 00	 call	 _GetString
  02733	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4662 : 
; 4663 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));
; 4664 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);
; 4665 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);
; 4666 : 			}
; 4667 : 			break;

  02736	e9 7b ef ff ff	 jmp	 $LN787@PageDialog
$LN143@PageDialog:

; 4668 : 
; 4669 : 		case SYSENC_PRETEST_INFO_PAGE:
; 4670 : 
; 4671 : 			if (bHiddenOS)

  0273b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  02742	74 70		 je	 SHORT $LN144@PageDialog

; 4672 : 			{
; 4673 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("HIDDEN_OS_CREATION_PREINFO_TITLE"));

  02744	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PAHHLDJJ@HIDDEN_OS_CREATION_PREINFO_TITLE@
  02749	e8 00 00 00 00	 call	 _GetString
  0274e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  02754	83 c4 04	 add	 esp, 4
  02757	50		 push	 eax
  02758	68 e8 03 00 00	 push	 1000			; 000003e8H
  0275d	53		 push	 ebx
  0275e	ff d7		 call	 edi
  02760	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  02766	50		 push	 eax
  02767	ff d6		 call	 esi
  02769	50		 push	 eax
  0276a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4674 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("HIDDEN_OS_CREATION_PREINFO_HELP"));

  02770	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@GFBCACCB@HIDDEN_OS_CREATION_PREINFO_HELP?$AA@
  02775	e8 00 00 00 00	 call	 _GetString
  0277a	83 c4 04	 add	 esp, 4
  0277d	50		 push	 eax
  0277e	68 eb 03 00 00	 push	 1003			; 000003ebH
  02783	53		 push	 ebx
  02784	ff d6		 call	 esi
  02786	50		 push	 eax
  02787	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4675 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("START"));

  0278d	68 00 00 00 00	 push	 OFFSET ??_C@_05JLPDBANI@START?$AA@
  02792	e8 00 00 00 00	 call	 _GetString
  02797	83 c4 04	 add	 esp, 4
  0279a	50		 push	 eax
  0279b	68 10 04 00 00	 push	 1040			; 00000410H
  027a0	53		 push	 ebx
  027a1	ff d7		 call	 edi
  027a3	50		 push	 eax
  027a4	ff d6		 call	 esi
  027a6	50		 push	 eax
  027a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4676 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  027ad	6a 00		 push	 0

; 4677 : 			}
; 4678 : 			else

  027af	e9 bc 00 00 00	 jmp	 $LN756@PageDialog
$LN144@PageDialog:
  027b4	68 b0 3e 00 00	 push	 16048			; 00003eb0H
  027b9	8d 85 e0 2d ff
	ff		 lea	 eax, DWORD PTR _finalMsg$22[ebp]
  027bf	6a 00		 push	 0
  027c1	50		 push	 eax
  027c2	e8 00 00 00 00	 call	 _memset

; 4679 : 			{
; 4680 : 				wchar_t finalMsg[8024] = {0};
; 4681 : 
; 4682 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYS_ENCRYPTION_PRETEST_TITLE"));

  027c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OJLMLLFE@SYS_ENCRYPTION_PRETEST_TITLE?$AA@
  027cc	e8 00 00 00 00	 call	 _GetString
  027d1	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  027d7	83 c4 10	 add	 esp, 16			; 00000010H
  027da	50		 push	 eax
  027db	68 e8 03 00 00	 push	 1000			; 000003e8H
  027e0	53		 push	 ebx
  027e1	ff d7		 call	 edi
  027e3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  027e9	50		 push	 eax
  027ea	ff d6		 call	 esi
  027ec	50		 push	 eax
  027ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4683 : 
; 4684 : 				try
; 4685 : 				{
; 4686 : 					wsprintfW (finalMsg, 

  027f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  027f9	8d 85 80 eb fe
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  027ff	50		 push	 eax
  02800	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  02807	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  0280c	ff 70 30	 push	 DWORD PTR [eax+48]
  0280f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OIIAJLEO@SYS_ENCRYPTION_PRETEST_INFO?$AA@
  02814	e8 00 00 00 00	 call	 _GetString
  02819	83 c4 04	 add	 esp, 4
  0281c	50		 push	 eax
  0281d	8d 85 e0 2d ff
	ff		 lea	 eax, DWORD PTR _finalMsg$22[ebp]
  02823	50		 push	 eax
  02824	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  0282a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0282d	8d 8d 80 eb fe
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  02833	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 4695 : 				}
; 4696 : 
; 4697 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), finalMsg);

  02838	8d 85 e0 2d ff
	ff		 lea	 eax, DWORD PTR _finalMsg$22[ebp]
  0283e	50		 push	 eax
  0283f	68 eb 03 00 00	 push	 1003			; 000003ebH
  02844	53		 push	 ebx
  02845	ff d6		 call	 esi
  02847	50		 push	 eax
  02848	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4698 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("TEST"));

  0284e	68 00 00 00 00	 push	 OFFSET ??_C@_04OIKJMBFP@TEST?$AA@
  02853	e8 00 00 00 00	 call	 _GetString
  02858	83 c4 04	 add	 esp, 4
  0285b	50		 push	 eax
  0285c	68 10 04 00 00	 push	 1040			; 00000410H
  02861	53		 push	 ebx
  02862	ff d7		 call	 edi
  02864	50		 push	 eax
  02865	ff d6		 call	 esi
  02867	50		 push	 eax
  02868	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4699 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  0286e	6a 01		 push	 1
$LN756@PageDialog:
  02870	68 11 04 00 00	 push	 1041			; 00000411H
  02875	53		 push	 ebx
  02876	ff d7		 call	 edi
  02878	50		 push	 eax
  02879	ff d6		 call	 esi
  0287b	50		 push	 eax
  0287c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4700 : 			}
; 4701 : 
; 4702 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  02882	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  02887	e8 00 00 00 00	 call	 _GetString
  0288c	83 c4 04	 add	 esp, 4
  0288f	50		 push	 eax
  02890	68 11 04 00 00	 push	 1041			; 00000411H
  02895	53		 push	 ebx
  02896	ff d7		 call	 edi
  02898	50		 push	 eax
  02899	ff d6		 call	 esi
  0289b	50		 push	 eax
  0289c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4703 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  028a2	6a 01		 push	 1
  028a4	68 10 04 00 00	 push	 1040			; 00000410H
  028a9	53		 push	 ebx
  028aa	ff d7		 call	 edi
  028ac	50		 push	 eax
  028ad	ff d6		 call	 esi
  028af	50		 push	 eax
  028b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  028b6	33 c0		 xor	 eax, eax
  028b8	e9 0b 2b 00 00	 jmp	 $LN1@PageDialog
__catch$_PageDialogProc@16$0:

; 4687 : 						GetString ("SYS_ENCRYPTION_PRETEST_INFO"), 
; 4688 : 						BootEncObj->GetSystemDriveConfiguration().DriveNumber);
; 4689 : 				}
; 4690 : 				catch (Exception &e)
; 4691 : 				{
; 4692 : 					e.Show (hwndDlg);

  028bd	8b 8d 34 eb fe
	ff		 mov	 ecx, DWORD PTR _e$5[ebp]
  028c3	ff b5 74 eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  028c9	8b 01		 mov	 eax, DWORD PTR [ecx]
  028cb	ff 10		 call	 DWORD PTR [eax]

; 4693 : 					EndMainDlg (MainDlg);

  028cd	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  028d3	e8 00 00 00 00	 call	 _EndMainDlg
  028d8	83 c4 04	 add	 esp, 4

; 4694 : 					return 0;

  028db	b8 00 00 00 00	 mov	 eax, $LN384@PageDialog
  028e0	c3		 ret	 0
$LN147@PageDialog:

; 4704 : 
; 4705 : 			break;
; 4706 : 
; 4707 : 		case SYSENC_PRETEST_RESULT_PAGE:
; 4708 : 
; 4709 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYS_ENCRYPTION_PRETEST_RESULT_TITLE"));

  028e1	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FEPHBNLJ@SYS_ENCRYPTION_PRETEST_RESULT_TI@
  028e6	e8 00 00 00 00	 call	 _GetString
  028eb	83 c4 04	 add	 esp, 4
  028ee	50		 push	 eax
  028ef	68 e8 03 00 00	 push	 1000			; 000003e8H
  028f4	53		 push	 ebx
  028f5	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  028fb	ff d3		 call	 ebx
  028fd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  02903	50		 push	 eax
  02904	ff d7		 call	 edi
  02906	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  0290c	50		 push	 eax
  0290d	ff d6		 call	 esi

; 4710 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYS_ENCRYPTION_PRETEST_RESULT_INFO"));

  0290f	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BONEGKLO@SYS_ENCRYPTION_PRETEST_RESULT_IN@
  02914	e8 00 00 00 00	 call	 _GetString
  02919	83 c4 04	 add	 esp, 4
  0291c	50		 push	 eax
  0291d	68 eb 03 00 00	 push	 1003			; 000003ebH
  02922	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02928	ff d7		 call	 edi
  0292a	50		 push	 eax
  0292b	ff d6		 call	 esi

; 4711 : 
; 4712 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("ENCRYPT"));

  0292d	68 00 00 00 00	 push	 OFFSET ??_C@_07CAOFPAJK@ENCRYPT?$AA@
  02932	e8 00 00 00 00	 call	 _GetString
  02937	83 c4 04	 add	 esp, 4
  0293a	50		 push	 eax
  0293b	68 10 04 00 00	 push	 1040			; 00000410H
  02940	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02946	ff d3		 call	 ebx
  02948	50		 push	 eax
  02949	ff d7		 call	 edi
  0294b	50		 push	 eax
  0294c	ff d6		 call	 esi

; 4713 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  0294e	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  02953	e8 00 00 00 00	 call	 _GetString
  02958	83 c4 04	 add	 esp, 4
  0295b	50		 push	 eax
  0295c	68 11 04 00 00	 push	 1041			; 00000411H
  02961	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02967	ff d3		 call	 ebx
  02969	50		 push	 eax
  0296a	ff d7		 call	 edi
  0296c	50		 push	 eax
  0296d	ff d6		 call	 esi

; 4714 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("DEFER"));

  0296f	68 00 00 00 00	 push	 OFFSET ??_C@_05KEELGAD@DEFER?$AA@
  02974	e8 00 00 00 00	 call	 _GetString
  02979	83 c4 04	 add	 esp, 4
  0297c	50		 push	 eax
  0297d	6a 02		 push	 2
  0297f	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02985	ff d3		 call	 ebx
  02987	50		 push	 eax
  02988	ff d7		 call	 edi
  0298a	50		 push	 eax
  0298b	ff d6		 call	 esi

; 4715 : 
; 4716 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  0298d	6a 01		 push	 1
  0298f	68 10 04 00 00	 push	 1040			; 00000410H
  02994	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0299a	ff d3		 call	 ebx
  0299c	50		 push	 eax
  0299d	ff d7		 call	 edi
  0299f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  029a5	50		 push	 eax
  029a6	ff d6		 call	 esi

; 4717 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  029a8	6a 00		 push	 0
  029aa	68 11 04 00 00	 push	 1041			; 00000411H
  029af	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  029b5	ff d3		 call	 ebx
  029b7	50		 push	 eax
  029b8	ff d7		 call	 edi
  029ba	50		 push	 eax
  029bb	ff d6		 call	 esi

; 4718 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  029bd	6a 01		 push	 1
  029bf	6a 02		 push	 2
  029c1	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  029c7	ff d3		 call	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  029c9	50		 push	 eax
  029ca	ff d7		 call	 edi
  029cc	50		 push	 eax
  029cd	ff d6		 call	 esi

; 3977 : 					return 0;

  029cf	33 c0		 xor	 eax, eax
  029d1	e9 f2 29 00 00	 jmp	 $LN1@PageDialog
$LN148@PageDialog:

; 4719 : 
; 4720 : 			break;
; 4721 : 
; 4722 : 		case SYSENC_ENCRYPTION_PAGE:
; 4723 : 
; 4724 : 			if (CreateSysEncMutex ())

  029d6	e8 00 00 00 00	 call	 _CreateSysEncMutex
  029db	85 c0		 test	 eax, eax
  029dd	0f 84 68 02 00
	00		 je	 $LN149@PageDialog

; 4725 : 			{
; 4726 : 				try
; 4727 : 				{
; 4728 : 					BootEncStatus = BootEncObj->GetStatus();

  029e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  029e9	8d 85 20 ed fe
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  029ef	50		 push	 eax
  029f0	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  029f7	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  029fc	8b f0		 mov	 esi, eax

; 4737 : 				}
; 4738 : 
; 4739 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE),

  029fe	81 3d 00 00 00
	00 58 02 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 600 ; 00000258H
  02a08	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  02a0d	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  02a12	f3 a5		 rep movsd
  02a14	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@POBGFBLK@DECRYPTION?$AA@
  02a19	66 a5		 movsw
  02a1b	a1 3e 00 00 00	 mov	 eax, DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+62
  02a20	a3 00 00 00 00	 mov	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, eax ; bSystemEncryptionInProgress
  02a25	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@MHHIHFIN@ENCRYPTION?$AA@
  02a2a	0f 44 c1	 cmove	 eax, ecx
  02a2d	50		 push	 eax
  02a2e	e8 00 00 00 00	 call	 _GetString
  02a33	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  02a39	83 c4 04	 add	 esp, 4
  02a3c	50		 push	 eax
  02a3d	68 e8 03 00 00	 push	 1000			; 000003e8H
  02a42	53		 push	 ebx
  02a43	ff d7		 call	 edi
  02a45	50		 push	 eax
  02a46	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  02a4c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  02a52	50		 push	 eax
  02a53	ff d6		 call	 esi

; 4740 : 					GetString (SystemEncryptionStatus != SYSENC_STATUS_DECRYPTING ? "ENCRYPTION" : "DECRYPTION"));
; 4741 : 
; 4742 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYSENC_ENCRYPTION_PAGE_INFO"));

  02a55	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LFGBLAAC@SYSENC_ENCRYPTION_PAGE_INFO?$AA@
  02a5a	e8 00 00 00 00	 call	 _GetString
  02a5f	83 c4 04	 add	 esp, 4
  02a62	50		 push	 eax
  02a63	68 eb 03 00 00	 push	 1003			; 000003ebH
  02a68	53		 push	 ebx
  02a69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  02a6f	50		 push	 eax
  02a70	ff d6		 call	 esi

; 4743 : 
; 4744 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("DEFER"));

  02a72	68 00 00 00 00	 push	 OFFSET ??_C@_05KEELGAD@DEFER?$AA@
  02a77	e8 00 00 00 00	 call	 _GetString
  02a7c	83 c4 04	 add	 esp, 4
  02a7f	50		 push	 eax
  02a80	6a 02		 push	 2
  02a82	53		 push	 ebx
  02a83	ff d7		 call	 edi
  02a85	50		 push	 eax
  02a86	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  02a8c	50		 push	 eax
  02a8d	ff d6		 call	 esi

; 4745 : 
; 4746 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  02a8f	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  02a94	e8 00 00 00 00	 call	 _GetString
  02a99	83 c4 04	 add	 esp, 4
  02a9c	50		 push	 eax
  02a9d	68 11 04 00 00	 push	 1041			; 00000411H
  02aa2	53		 push	 ebx
  02aa3	ff d7		 call	 edi
  02aa5	50		 push	 eax
  02aa6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  02aac	50		 push	 eax
  02aad	ff d6		 call	 esi

; 4747 : 
; 4748 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT),

  02aaf	81 3d 00 00 00
	00 58 02 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 600 ; 00000258H
  02ab9	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07OOEIKEPO@DECRYPT?$AA@
  02abe	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07CAOFPAJK@ENCRYPT?$AA@
  02ac3	0f 44 c1	 cmove	 eax, ecx
  02ac6	50		 push	 eax
  02ac7	e8 00 00 00 00	 call	 _GetString
  02acc	83 c4 04	 add	 esp, 4
  02acf	50		 push	 eax
  02ad0	68 10 04 00 00	 push	 1040			; 00000410H
  02ad5	53		 push	 ebx
  02ad6	ff d7		 call	 edi
  02ad8	50		 push	 eax
  02ad9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  02adf	50		 push	 eax
  02ae0	ff d6		 call	 esi

; 4749 : 					GetString (SystemEncryptionStatus != SYSENC_STATUS_DECRYPTING ? "ENCRYPT" : "DECRYPT"));
; 4750 : 
; 4751 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_PAUSE),

  02ae2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, 0 ; bSystemEncryptionInProgress
  02ae9	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_06PPGAKMJI@RESUME?$AA@
  02aee	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09PJBBBIIP@IDC_PAUSE?$AA@
  02af3	0f 44 c1	 cmove	 eax, ecx
  02af6	50		 push	 eax
  02af7	e8 00 00 00 00	 call	 _GetString
  02afc	83 c4 04	 add	 esp, 4
  02aff	50		 push	 eax
  02b00	68 41 04 00 00	 push	 1089			; 00000441H
  02b05	53		 push	 ebx
  02b06	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  02b0c	50		 push	 eax
  02b0d	ff d6		 call	 esi

; 4752 : 					GetString (bSystemEncryptionInProgress ? "IDC_PAUSE" : "RESUME"));
; 4753 : 
; 4754 : 				EnableWindow (GetDlgItem (hwndDlg, IDC_PAUSE), BootEncStatus.DriveEncrypted);

  02b0f	ff 35 0e 00 00
	00		 push	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+14
  02b15	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  02b1b	68 41 04 00 00	 push	 1089			; 00000441H
  02b20	53		 push	 ebx
  02b21	ff d6		 call	 esi
  02b23	50		 push	 eax
  02b24	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4755 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  02b2a	6a 00		 push	 0
  02b2c	68 11 04 00 00	 push	 1041			; 00000411H
  02b31	53		 push	 ebx
  02b32	ff d7		 call	 edi
  02b34	50		 push	 eax
  02b35	ff d6		 call	 esi
  02b37	50		 push	 eax
  02b38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4756 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), !BootEncStatus.SetupInProgress);

  02b3e	33 c0		 xor	 eax, eax
  02b40	39 05 3e 00 00
	00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+62, eax
  02b46	0f 94 c0	 sete	 al
  02b49	50		 push	 eax
  02b4a	68 10 04 00 00	 push	 1040			; 00000410H
  02b4f	53		 push	 ebx
  02b50	ff d7		 call	 edi
  02b52	50		 push	 eax
  02b53	ff d6		 call	 esi
  02b55	50		 push	 eax
  02b56	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4757 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  02b5c	6a 01		 push	 1
  02b5e	6a 02		 push	 2
  02b60	53		 push	 ebx
  02b61	ff d7		 call	 edi
  02b63	50		 push	 eax
  02b64	ff d6		 call	 esi
  02b66	50		 push	 eax
  02b67	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4758 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDHELP), TRUE);

  02b6d	6a 01		 push	 1
  02b6f	6a 09		 push	 9
  02b71	53		 push	 ebx
  02b72	ff d7		 call	 edi
  02b74	50		 push	 eax
  02b75	ff d6		 call	 esi
  02b77	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  02b7d	50		 push	 eax
  02b7e	ff d7		 call	 edi

; 4759 : 
; 4760 : 				ToHyperlink (hwndDlg, IDC_MORE_INFO_SYS_ENCRYPTION);

  02b80	68 43 04 00 00	 push	 1091			; 00000443H
  02b85	53		 push	 ebx
  02b86	e8 00 00 00 00	 call	 _ToHyperlink
  02b8b	83 c4 08	 add	 esp, 8

; 4761 : 
; 4762 : 				if (SystemEncryptionStatus == SYSENC_STATUS_DECRYPTING)

  02b8e	81 3d 00 00 00
	00 58 02 00 00	 cmp	 DWORD PTR _SystemEncryptionStatus, 600 ; 00000258H
  02b98	75 2a		 jne	 SHORT $LN152@PageDialog

; 4763 : 				{
; 4764 : 					nWipeMode = GST_WIPE_NONE;
; 4765 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_WIPE_MODE), FALSE);

  02b9a	6a 00		 push	 0
  02b9c	68 3d 04 00 00	 push	 1085			; 0000043dH
  02ba1	53		 push	 ebx
  02ba2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nWipeMode, 0
  02bac	ff d6		 call	 esi
  02bae	50		 push	 eax
  02baf	ff d7		 call	 edi

; 4766 : 					EnableWindow (GetDlgItem (hwndDlg, IDT_WIPE_MODE), FALSE);

  02bb1	6a 00		 push	 0
  02bb3	68 42 04 00 00	 push	 1090			; 00000442H
  02bb8	53		 push	 ebx
  02bb9	ff d6		 call	 esi
  02bbb	50		 push	 eax
  02bbc	ff d7		 call	 edi

; 4767 : 					PopulateWipeModeCombo (GetDlgItem (hwndDlg, IDC_WIPE_MODE), TRUE, TRUE);

  02bbe	6a 01		 push	 1
  02bc0	6a 01		 push	 1

; 4768 : 					SelectAlgo (GetDlgItem (hwndDlg, IDC_WIPE_MODE), (int *) &nWipeMode);
; 4769 : 				}
; 4770 : 				else

  02bc2	eb 1b		 jmp	 SHORT $LN757@PageDialog
$LN152@PageDialog:

; 4771 : 				{
; 4772 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_WIPE_MODE), !bSystemEncryptionInProgress);

  02bc4	33 c0		 xor	 eax, eax
  02bc6	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bSystemEncryptionInProgress@@3HA, eax ; bSystemEncryptionInProgress
  02bcc	0f 94 c0	 sete	 al
  02bcf	50		 push	 eax
  02bd0	68 3d 04 00 00	 push	 1085			; 0000043dH
  02bd5	53		 push	 ebx
  02bd6	ff d6		 call	 esi
  02bd8	50		 push	 eax
  02bd9	ff d7		 call	 edi

; 4773 : 					PopulateWipeModeCombo (GetDlgItem (hwndDlg, IDC_WIPE_MODE), FALSE, TRUE);

  02bdb	6a 01		 push	 1
  02bdd	6a 00		 push	 0
$LN757@PageDialog:
  02bdf	68 3d 04 00 00	 push	 1085			; 0000043dH
  02be4	53		 push	 ebx
  02be5	ff d6		 call	 esi
  02be7	50		 push	 eax
  02be8	e8 00 00 00 00	 call	 _PopulateWipeModeCombo
  02bed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4774 : 					SelectAlgo (GetDlgItem (hwndDlg, IDC_WIPE_MODE), (int *) &nWipeMode);

  02bf0	68 00 00 00 00	 push	 OFFSET _nWipeMode
  02bf5	68 3d 04 00 00	 push	 1085			; 0000043dH
  02bfa	53		 push	 ebx
  02bfb	ff d6		 call	 esi
  02bfd	50		 push	 eax
  02bfe	e8 00 00 00 00	 call	 _SelectAlgo
  02c03	83 c4 08	 add	 esp, 8

; 4775 : 				}
; 4776 : 
; 4777 : 				PostMessage (hwndDlg, GST_APPMSG_PERFORM_POST_SYSENC_WMINIT_TASKS, 0, 0);

  02c06	6a 00		 push	 0
  02c08	6a 00		 push	 0
  02c0a	68 31 81 00 00	 push	 33073			; 00008131H
  02c0f	53		 push	 ebx
  02c10	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 4784 : 			}
; 4785 : 			return 0;

  02c16	33 c0		 xor	 eax, eax
  02c18	e9 ab 27 00 00	 jmp	 $LN1@PageDialog
__catch$_PageDialogProc@16$2:

; 4729 : 					bSystemEncryptionInProgress = BootEncStatus.SetupInProgress;
; 4730 : 				}
; 4731 : 				catch (Exception &e)
; 4732 : 				{
; 4733 : 					e.Show (hwndDlg);

  02c1d	8b 8d 2c eb fe
	ff		 mov	 ecx, DWORD PTR _e$3[ebp]
  02c23	ff b5 74 eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  02c29	8b 01		 mov	 eax, DWORD PTR [ecx]
  02c2b	ff 10		 call	 DWORD PTR [eax]

; 4734 : 					Error ("ERR_GETTING_SYSTEM_ENCRYPTION_STATUS");

  02c2d	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BOINGOPM@ERR_GETTING_SYSTEM_ENCRYPTION_ST@
  02c32	e8 00 00 00 00	 call	 _Error

; 4735 : 					EndMainDlg (MainDlg);

  02c37	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  02c3d	e8 00 00 00 00	 call	 _EndMainDlg
  02c42	83 c4 08	 add	 esp, 8

; 4736 : 					return 0;

  02c45	b8 00 00 00 00	 mov	 eax, $LN384@PageDialog
  02c4a	c3		 ret	 0
$LN149@PageDialog:

; 4778 : 			}
; 4779 : 			else
; 4780 : 			{
; 4781 : 				Error ("SYSTEM_ENCRYPTION_IN_PROGRESS_ELSEWHERE");

  02c4b	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FPFBOAHN@SYSTEM_ENCRYPTION_IN_PROGRESS_EL@
  02c50	e8 00 00 00 00	 call	 _Error
$LN783@PageDialog:

; 4782 : 				EndMainDlg (MainDlg);

  02c55	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  02c5b	e8 00 00 00 00	 call	 _EndMainDlg
  02c60	83 c4 08	 add	 esp, 8

; 4783 : 				return 0;

  02c63	33 c0		 xor	 eax, eax
  02c65	e9 5e 27 00 00	 jmp	 $LN1@PageDialog
$LN154@PageDialog:

; 4786 : 
; 4787 : 		case NONSYS_INPLACE_ENC_RESUME_PARTITION_SEL_PAGE:
; 4788 : 
; 4789 : 			{
; 4790 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("FILE_TITLE"));

  02c6a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DGHBDDNJ@FILE_TITLE?$AA@
  02c6f	e8 00 00 00 00	 call	 _GetString
  02c74	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  02c7a	83 c4 04	 add	 esp, 4
  02c7d	50		 push	 eax
  02c7e	68 e8 03 00 00	 push	 1000			; 000003e8H
  02c83	53		 push	 ebx
  02c84	ff d7		 call	 edi
  02c86	50		 push	 eax
  02c87	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  02c8d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  02c93	50		 push	 eax
  02c94	ff d6		 call	 esi

; 4791 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("NONSYS_INPLACE_ENC_RESUME_VOL_SELECT_HELP"));

  02c96	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KEEMKNMD@NONSYS_INPLACE_ENC_RESUME_VOL_SE@
  02c9b	e8 00 00 00 00	 call	 _GetString
  02ca0	83 c4 04	 add	 esp, 4
  02ca3	50		 push	 eax
  02ca4	68 eb 03 00 00	 push	 1003			; 000003ebH
  02ca9	53		 push	 ebx
  02caa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  02cb0	50		 push	 eax
  02cb1	ff d6		 call	 esi

; 4792 : 
; 4793 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  02cb3	6a 01		 push	 1
  02cb5	68 11 04 00 00	 push	 1041			; 00000411H
  02cba	53		 push	 ebx
  02cbb	ff d7		 call	 edi
  02cbd	50		 push	 eax
  02cbe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  02cc4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  02cca	50		 push	 eax
  02ccb	ff d6		 call	 esi

; 4794 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), FALSE);

  02ccd	6a 00		 push	 0
  02ccf	68 10 04 00 00	 push	 1040			; 00000410H
  02cd4	53		 push	 ebx
  02cd5	ff d7		 call	 edi
  02cd7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  02cdd	50		 push	 eax
  02cde	ff d7		 call	 edi
  02ce0	50		 push	 eax
  02ce1	ff d6		 call	 esi

; 4795 : 				
; 4796 : 				foreach (const HostDevice &device, DeferredNonSysInPlaceEncDevices)

  02ce3	8d 85 38 eb fe
	ff		 lea	 eax, DWORD PTR _$S1$6[ebp]
  02ce9	68 00 00 00 00	 push	 OFFSET ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A ; DeferredNonSysInPlaceEncDevices
  02cee	50		 push	 eax
  02cef	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@01@ABV?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<HostDevice,std::allocator<HostDevice> > >
  02cf4	83 c4 08	 add	 esp, 8
  02cf7	8b 85 38 eb fe
	ff		 mov	 eax, DWORD PTR _$S1$6[ebp]
  02cfd	8d 8d 38 eb fe
	ff		 lea	 ecx, DWORD PTR _$S1$6[ebp]
  02d03	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  02d0a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  02d0d	ff d0		 call	 eax
  02d0f	84 c0		 test	 al, al
  02d11	0f 84 92 00 00
	00		 je	 $LN17@PageDialog
  02d17	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@PageDialog:
  02d20	33 c0		 xor	 eax, eax
  02d22	38 85 3d eb fe
	ff		 cmp	 BYTE PTR _$S1$6[ebp+5], al
  02d28	0f 94 c0	 sete	 al
  02d2b	88 85 3d eb fe
	ff		 mov	 BYTE PTR _$S1$6[ebp+5], al
  02d31	84 c0		 test	 al, al
  02d33	74 4c		 je	 SHORT $LN16@PageDialog
  02d35	8b b5 50 eb fe
	ff		 mov	 esi, DWORD PTR _$S1$6[ebp+24]
  02d3b	0f 1f 44 00 00	 npad	 5
$LL21@PageDialog:

; 4797 : 				{
; 4798 : 					SendMessage (GetDlgItem (hwndDlg, IDC_LIST_BOX), LB_ADDSTRING, 0, (LPARAM) device.Path.c_str());

  02d40	83 7e 4c 10	 cmp	 DWORD PTR [esi+76], 16	; 00000010H
  02d44	72 05		 jb	 SHORT $LN486@PageDialog
  02d46	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  02d49	eb 03		 jmp	 SHORT $LN487@PageDialog
$LN486@PageDialog:
  02d4b	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
$LN487@PageDialog:
  02d4e	50		 push	 eax
  02d4f	6a 00		 push	 0
  02d51	68 80 01 00 00	 push	 384			; 00000180H
  02d56	68 fa 03 00 00	 push	 1018			; 000003faH
  02d5b	53		 push	 ebx
  02d5c	ff d7		 call	 edi
  02d5e	50		 push	 eax
  02d5f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  02d65	33 c0		 xor	 eax, eax
  02d67	c6 85 3c eb fe
	ff 01		 mov	 BYTE PTR _$S1$6[ebp+4], 1
  02d6e	38 85 3d eb fe
	ff		 cmp	 BYTE PTR _$S1$6[ebp+5], al
  02d74	0f 94 c0	 sete	 al
  02d77	88 85 3d eb fe
	ff		 mov	 BYTE PTR _$S1$6[ebp+5], al
  02d7d	84 c0		 test	 al, al
  02d7f	75 bf		 jne	 SHORT $LL21@PageDialog
$LN16@PageDialog:

; 4795 : 				
; 4796 : 				foreach (const HostDevice &device, DeferredNonSysInPlaceEncDevices)

  02d81	8b 85 38 eb fe
	ff		 mov	 eax, DWORD PTR _$S1$6[ebp]
  02d87	8d 8d 38 eb fe
	ff		 lea	 ecx, DWORD PTR _$S1$6[ebp]
  02d8d	ff 50 08	 call	 DWORD PTR [eax+8]
  02d90	8b 85 38 eb fe
	ff		 mov	 eax, DWORD PTR _$S1$6[ebp]
  02d96	8d 8d 38 eb fe
	ff		 lea	 ecx, DWORD PTR _$S1$6[ebp]
  02d9c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  02d9f	ff d0		 call	 eax
  02da1	84 c0		 test	 al, al
  02da3	0f 85 77 ff ff
	ff		 jne	 $LL18@PageDialog
$LN17@PageDialog:

; 4799 : 				}

  02da9	8d 8d 40 eb fe
	ff		 lea	 ecx, DWORD PTR _$S1$6[ebp+8]
  02daf	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy

; 4800 : 				 
; 4801 : 				// Deselect all
; 4802 : 				SendMessage (GetDlgItem (hwndDlg, IDC_LIST_BOX), LB_SETCURSEL, (WPARAM) -1, 0);

  02db4	6a 00		 push	 0
  02db6	6a ff		 push	 -1
  02db8	68 86 01 00 00	 push	 390			; 00000186H
  02dbd	68 fa 03 00 00	 push	 1018			; 000003faH
  02dc2	53		 push	 ebx
  02dc3	ff d7		 call	 edi
  02dc5	50		 push	 eax
  02dc6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  02dcc	33 c0		 xor	 eax, eax
  02dce	e9 f5 25 00 00	 jmp	 $LN1@PageDialog
$LN155@PageDialog:

; 4803 : 			}
; 4804 : 
; 4805 : 			break;
; 4806 : 
; 4807 : 		case NONSYS_INPLACE_ENC_ENCRYPTION_PAGE:
; 4808 : 
; 4809 : 			if (bInPlaceEncNonSysResumed)

  02dd3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSysResumed, 0
  02dda	74 2e		 je	 SHORT $LN157@PageDialog

; 4810 : 			{
; 4811 : 				WipeAlgorithmId savedWipeAlgorithm = GST_WIPE_NONE;
; 4812 : 
; 4813 : 				if (LoadNonSysInPlaceEncSettings (&savedWipeAlgorithm) != 0)

  02ddc	8d 85 60 eb fe
	ff		 lea	 eax, DWORD PTR _savedWipeAlgorithm$9[ebp]
  02de2	c7 85 60 eb fe
	ff 00 00 00 00	 mov	 DWORD PTR _savedWipeAlgorithm$9[ebp], 0
  02dec	50		 push	 eax
  02ded	e8 00 00 00 00	 call	 _LoadNonSysInPlaceEncSettings
  02df2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nWipeMode
  02df8	83 c4 04	 add	 esp, 4
  02dfb	85 c0		 test	 eax, eax
  02dfd	0f 45 8d 60 eb
	fe ff		 cmovne	 ecx, DWORD PTR _savedWipeAlgorithm$9[ebp]
  02e04	89 0d 00 00 00
	00		 mov	 DWORD PTR _nWipeMode, ecx
$LN157@PageDialog:

; 4814 : 					nWipeMode = savedWipeAlgorithm;
; 4815 : 			}
; 4816 : 
; 4817 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("ENCRYPTION"));

  02e0a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MHHIHFIN@ENCRYPTION?$AA@
  02e0f	e8 00 00 00 00	 call	 _GetString
  02e14	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  02e1a	83 c4 04	 add	 esp, 4
  02e1d	50		 push	 eax
  02e1e	68 e8 03 00 00	 push	 1000			; 000003e8H
  02e23	53		 push	 ebx
  02e24	ff d7		 call	 edi
  02e26	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  02e2c	50		 push	 eax
  02e2d	ff d3		 call	 ebx
  02e2f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  02e35	50		 push	 eax
  02e36	ff d6		 call	 esi

; 4818 : 
; 4819 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("NONSYS_INPLACE_ENC_ENCRYPTION_PAGE_INFO"));

  02e38	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@MDGBIFPN@NONSYS_INPLACE_ENC_ENCRYPTION_PA@
  02e3d	e8 00 00 00 00	 call	 _GetString
  02e42	83 c4 04	 add	 esp, 4
  02e45	50		 push	 eax
  02e46	68 eb 03 00 00	 push	 1003			; 000003ebH
  02e4b	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02e51	ff d3		 call	 ebx
  02e53	50		 push	 eax
  02e54	ff d6		 call	 esi

; 4820 : 
; 4821 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString (bInPlaceEncNonSysResumed ? "DEFER" : "CANCEL"));

  02e56	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSysResumed
  02e5b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  02e60	85 c0		 test	 eax, eax
  02e62	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05KEELGAD@DEFER?$AA@
  02e67	0f 44 ca	 cmove	 ecx, edx
  02e6a	51		 push	 ecx
  02e6b	e8 00 00 00 00	 call	 _GetString
  02e70	83 c4 04	 add	 esp, 4
  02e73	50		 push	 eax
  02e74	6a 02		 push	 2
  02e76	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02e7c	ff d7		 call	 edi
  02e7e	50		 push	 eax
  02e7f	ff d3		 call	 ebx
  02e81	50		 push	 eax
  02e82	ff d6		 call	 esi

; 4822 : 
; 4823 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  02e84	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  02e89	e8 00 00 00 00	 call	 _GetString
  02e8e	83 c4 04	 add	 esp, 4
  02e91	50		 push	 eax
  02e92	68 11 04 00 00	 push	 1041			; 00000411H
  02e97	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02e9d	ff d7		 call	 edi
  02e9f	50		 push	 eax
  02ea0	ff d3		 call	 ebx
  02ea2	50		 push	 eax
  02ea3	ff d6		 call	 esi

; 4824 : 
; 4825 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString (bInPlaceEncNonSysResumed ? "RESUME" : "ENCRYPT"));

  02ea5	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSysResumed
  02eaa	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07CAOFPAJK@ENCRYPT?$AA@
  02eaf	85 c0		 test	 eax, eax
  02eb1	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_06PPGAKMJI@RESUME?$AA@
  02eb6	0f 44 ca	 cmove	 ecx, edx
  02eb9	51		 push	 ecx
  02eba	e8 00 00 00 00	 call	 _GetString
  02ebf	83 c4 04	 add	 esp, 4
  02ec2	50		 push	 eax
  02ec3	68 10 04 00 00	 push	 1040			; 00000410H
  02ec8	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02ece	ff d7		 call	 edi
  02ed0	50		 push	 eax
  02ed1	ff d3		 call	 ebx
  02ed3	50		 push	 eax
  02ed4	ff d6		 call	 esi

; 4826 : 
; 4827 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_PAUSE), GetString ("IDC_PAUSE"));

  02ed6	68 00 00 00 00	 push	 OFFSET ??_C@_09PJBBBIIP@IDC_PAUSE?$AA@
  02edb	e8 00 00 00 00	 call	 _GetString
  02ee0	83 c4 04	 add	 esp, 4
  02ee3	50		 push	 eax
  02ee4	68 41 04 00 00	 push	 1089			; 00000441H
  02ee9	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02eef	ff d3		 call	 ebx
  02ef1	50		 push	 eax
  02ef2	ff d6		 call	 esi

; 4828 : 
; 4829 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), !bInPlaceEncNonSysResumed);

  02ef4	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSysResumed
  02ef9	f7 d8		 neg	 eax
  02efb	1b c0		 sbb	 eax, eax
  02efd	40		 inc	 eax
  02efe	50		 push	 eax
  02eff	68 11 04 00 00	 push	 1041			; 00000411H
  02f04	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02f0a	ff d7		 call	 edi
  02f0c	50		 push	 eax
  02f0d	ff d3		 call	 ebx
  02f0f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  02f15	50		 push	 eax
  02f16	ff d6		 call	 esi

; 4830 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  02f18	6a 01		 push	 1
  02f1a	68 10 04 00 00	 push	 1040			; 00000410H
  02f1f	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02f25	ff d7		 call	 edi
  02f27	50		 push	 eax
  02f28	ff d3		 call	 ebx
  02f2a	50		 push	 eax
  02f2b	ff d6		 call	 esi

; 4831 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  02f2d	6a 01		 push	 1
  02f2f	6a 02		 push	 2
  02f31	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02f37	ff d7		 call	 edi
  02f39	50		 push	 eax
  02f3a	ff d3		 call	 ebx
  02f3c	50		 push	 eax
  02f3d	ff d6		 call	 esi

; 4832 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDHELP), TRUE);

  02f3f	6a 01		 push	 1
  02f41	6a 09		 push	 9
  02f43	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02f49	ff d7		 call	 edi
  02f4b	50		 push	 eax
  02f4c	ff d3		 call	 ebx
  02f4e	50		 push	 eax
  02f4f	ff d6		 call	 esi

; 4833 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_PAUSE), FALSE);

  02f51	8b bd 7c eb fe
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  02f57	6a 00		 push	 0
  02f59	68 41 04 00 00	 push	 1089			; 00000441H
  02f5e	57		 push	 edi
  02f5f	ff d3		 call	 ebx
  02f61	50		 push	 eax
  02f62	ff d6		 call	 esi

; 4834 : 
; 4835 : 			ShowWindow (GetDlgItem (hwndDlg, IDC_MORE_INFO_SYS_ENCRYPTION), SW_HIDE);

  02f64	6a 00		 push	 0
  02f66	68 43 04 00 00	 push	 1091			; 00000443H
  02f6b	57		 push	 edi
  02f6c	ff d3		 call	 ebx
  02f6e	50		 push	 eax
  02f6f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 4836 : 
; 4837 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_WIPE_MODE), TRUE);

  02f75	6a 01		 push	 1
  02f77	68 3d 04 00 00	 push	 1085			; 0000043dH
  02f7c	57		 push	 edi
  02f7d	ff d3		 call	 ebx
  02f7f	50		 push	 eax
  02f80	ff d6		 call	 esi

; 4838 : 			PopulateWipeModeCombo (GetDlgItem (hwndDlg, IDC_WIPE_MODE), FALSE, TRUE);

  02f82	6a 01		 push	 1
  02f84	6a 00		 push	 0
  02f86	68 3d 04 00 00	 push	 1085			; 0000043dH
  02f8b	57		 push	 edi
  02f8c	ff d3		 call	 ebx
  02f8e	50		 push	 eax
  02f8f	e8 00 00 00 00	 call	 _PopulateWipeModeCombo
  02f94	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4839 : 			SelectAlgo (GetDlgItem (hwndDlg, IDC_WIPE_MODE), (int *) &nWipeMode);

  02f97	68 00 00 00 00	 push	 OFFSET _nWipeMode
  02f9c	68 3d 04 00 00	 push	 1085			; 0000043dH
  02fa1	57		 push	 edi
  02fa2	ff d3		 call	 ebx
  02fa4	50		 push	 eax
  02fa5	e8 00 00 00 00	 call	 _SelectAlgo
  02faa	83 c4 08	 add	 esp, 8
  02fad	33 c0		 xor	 eax, eax
  02faf	e9 14 24 00 00	 jmp	 $LN1@PageDialog
$LN158@PageDialog:

; 4840 : 
; 4841 : 			break;
; 4842 : 
; 4843 : 		case NONSYS_INPLACE_ENC_ENCRYPTION_FINISHED_PAGE:
; 4844 : 
; 4845 : 			bConfirmQuit = FALSE;
; 4846 : 
; 4847 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("NONSYS_INPLACE_ENC_FINISHED_TITLE"));

  02fb4	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@LOJCKPNA@NONSYS_INPLACE_ENC_FINISHED_TITL@
  02fb9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bConfirmQuit@@3HC, 0 ; bConfirmQuit
  02fc3	e8 00 00 00 00	 call	 _GetString
  02fc8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetParent@4
  02fce	83 c4 04	 add	 esp, 4
  02fd1	50		 push	 eax
  02fd2	68 e8 03 00 00	 push	 1000			; 000003e8H
  02fd7	53		 push	 ebx
  02fd8	ff d6		 call	 esi
  02fda	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  02fe0	50		 push	 eax
  02fe1	ff d3		 call	 ebx
  02fe3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetWindowTextW@8
  02fe9	50		 push	 eax
  02fea	ff d7		 call	 edi

; 4848 : 
; 4849 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("NONSYS_INPLACE_ENC_FINISHED_INFO"));

  02fec	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KOCBDKDK@NONSYS_INPLACE_ENC_FINISHED_INFO@
  02ff1	e8 00 00 00 00	 call	 _GetString
  02ff6	83 c4 04	 add	 esp, 4
  02ff9	50		 push	 eax
  02ffa	68 eb 03 00 00	 push	 1003			; 000003ebH
  02fff	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03005	ff d3		 call	 ebx
  03007	50		 push	 eax
  03008	ff d7		 call	 edi

; 4850 : 
; 4851 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  0300a	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  0300f	e8 00 00 00 00	 call	 _GetString
  03014	83 c4 04	 add	 esp, 4
  03017	50		 push	 eax
  03018	68 11 04 00 00	 push	 1041			; 00000411H
  0301d	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03023	ff d6		 call	 esi
  03025	50		 push	 eax
  03026	ff d3		 call	 ebx
  03028	50		 push	 eax
  03029	ff d7		 call	 edi

; 4852 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("FINALIZE"));

  0302b	68 00 00 00 00	 push	 OFFSET ??_C@_08MFKGCNCO@FINALIZE?$AA@
  03030	e8 00 00 00 00	 call	 _GetString
  03035	83 c4 04	 add	 esp, 4
  03038	50		 push	 eax
  03039	68 10 04 00 00	 push	 1040			; 00000410H
  0303e	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03044	ff d6		 call	 esi
  03046	50		 push	 eax
  03047	ff d3		 call	 ebx
  03049	50		 push	 eax
  0304a	ff d7		 call	 edi

; 4853 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  0304c	6a 00		 push	 0
  0304e	68 11 04 00 00	 push	 1041			; 00000411H
  03053	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03059	ff d6		 call	 esi
  0305b	50		 push	 eax
  0305c	ff d3		 call	 ebx
  0305e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  03064	50		 push	 eax
  03065	ff d6		 call	 esi

; 4854 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  03067	6a 01		 push	 1
  03069	68 10 04 00 00	 push	 1040			; 00000410H
  0306e	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0307a	50		 push	 eax
  0307b	ff d3		 call	 ebx
  0307d	50		 push	 eax
  0307e	ff d6		 call	 esi

; 4855 : 
; 4856 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("EXIT"));

  03080	68 00 00 00 00	 push	 OFFSET ??_C@_04GOLNGIJ@EXIT?$AA@
  03085	e8 00 00 00 00	 call	 _GetString
  0308a	83 c4 04	 add	 esp, 4
  0308d	50		 push	 eax
  0308e	6a 02		 push	 2
  03090	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0309c	50		 push	 eax
  0309d	ff d3		 call	 ebx
  0309f	50		 push	 eax
  030a0	ff d7		 call	 edi

; 4857 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), FALSE);

  030a2	6a 00		 push	 0
  030a4	6a 02		 push	 2
  030a6	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  030ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  030b2	50		 push	 eax
  030b3	ff d3		 call	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  030b5	50		 push	 eax
  030b6	ff d6		 call	 esi
  030b8	33 c0		 xor	 eax, eax
  030ba	e9 09 23 00 00	 jmp	 $LN1@PageDialog
$LN159@PageDialog:

; 4858 : 
; 4859 : 			break;
; 4860 : 
; 4861 : 		case FORMAT_PAGE:
; 4862 : 			{
; 4863 : 				BOOL bNTFSallowed = FALSE;
; 4864 : 				BOOL bFATallowed = FALSE;
; 4865 : 				BOOL bNoFSallowed = FALSE;
; 4866 : 
; 4867 : 				SetTimer (GetParent (hwndDlg), TIMER_ID_RANDVIEW, TIMER_INTERVAL_RANDVIEW, NULL);

  030bf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetParent@4
  030c5	6a 00		 push	 0
  030c7	6a 1e		 push	 30			; 0000001eH
  030c9	68 ff 00 00 00	 push	 255			; 000000ffH
  030ce	53		 push	 ebx
  030cf	ff d6		 call	 esi
  030d1	50		 push	 eax
  030d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 4868 : 
; 4869 : 				hMasterKey = GetDlgItem (hwndDlg, IDC_DISK_KEY);

  030d8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  030de	68 fb 03 00 00	 push	 1019			; 000003fbH
  030e3	53		 push	 ebx
  030e4	ff d7		 call	 edi

; 4870 : 				hHeaderKey = GetDlgItem (hwndDlg, IDC_HEADER_KEY);

  030e6	68 f9 03 00 00	 push	 1017			; 000003f9H
  030eb	53		 push	 ebx
  030ec	a3 00 00 00 00	 mov	 DWORD PTR _hMasterKey, eax
  030f1	ff d7		 call	 edi

; 4871 : 				hRandPool = GetDlgItem (hwndDlg, IDC_RANDOM_BYTES);

  030f3	68 fc 03 00 00	 push	 1020			; 000003fcH
  030f8	53		 push	 ebx
  030f9	a3 00 00 00 00	 mov	 DWORD PTR _hHeaderKey, eax
  030fe	ff d7		 call	 edi

; 4872 : 
; 4873 : 				SendMessage (GetDlgItem (hwndDlg, IDC_RANDOM_BYTES), WM_SETFONT, (WPARAM) hFixedDigitFont, (LPARAM) TRUE);

  03100	6a 01		 push	 1
  03102	ff 35 00 00 00
	00		 push	 DWORD PTR _hFixedDigitFont
  03108	a3 00 00 00 00	 mov	 DWORD PTR ?hRandPool@@3RAUHWND__@@A, eax ; hRandPool
  0310d	6a 30		 push	 48			; 00000030H
  0310f	68 fc 03 00 00	 push	 1020			; 000003fcH
  03114	53		 push	 ebx
  03115	ff d7		 call	 edi
  03117	50		 push	 eax
  03118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4874 : 				SendMessage (GetDlgItem (hwndDlg, IDC_DISK_KEY), WM_SETFONT, (WPARAM) hFixedDigitFont, (LPARAM) TRUE);

  0311e	6a 01		 push	 1
  03120	ff 35 00 00 00
	00		 push	 DWORD PTR _hFixedDigitFont
  03126	6a 30		 push	 48			; 00000030H
  03128	68 fb 03 00 00	 push	 1019			; 000003fbH
  0312d	53		 push	 ebx
  0312e	ff d7		 call	 edi
  03130	50		 push	 eax
  03131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4875 : 				SendMessage (GetDlgItem (hwndDlg, IDC_HEADER_KEY), WM_SETFONT, (WPARAM) hFixedDigitFont, (LPARAM) TRUE);

  03137	6a 01		 push	 1
  03139	ff 35 00 00 00
	00		 push	 DWORD PTR _hFixedDigitFont
  0313f	6a 30		 push	 48			; 00000030H
  03141	68 f9 03 00 00	 push	 1017			; 000003f9H
  03146	53		 push	 ebx
  03147	ff d7		 call	 edi
  03149	50		 push	 eax
  0314a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4876 : 
; 4877 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP),

  03150	a1 00 00 00 00	 mov	 eax, DWORD PTR _bHiddenVolHost
  03155	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@EEPPFDAO@FORMAT_HELP?$AA@
  0315a	85 c0		 test	 eax, eax
  0315c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BI@MEDALEIG@FORMAT_HIDVOL_HOST_HELP?$AA@
  03161	0f 44 ca	 cmove	 ecx, edx
  03164	51		 push	 ecx
  03165	e8 00 00 00 00	 call	 _GetString
  0316a	83 c4 04	 add	 esp, 4
  0316d	50		 push	 eax
  0316e	68 eb 03 00 00	 push	 1003			; 000003ebH
  03173	53		 push	 ebx
  03174	ff d7		 call	 edi
  03176	50		 push	 eax
  03177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 4878 : 					GetString (bHiddenVolHost ? "FORMAT_HIDVOL_HOST_HELP" : "FORMAT_HELP"));
; 4879 : 
; 4880 : 				if (bHiddenVol)

  0317d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  03184	74 17		 je	 SHORT $LN160@PageDialog

; 4881 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString (bHiddenVolHost ? "FORMAT_HIDVOL_HOST_TITLE" : "FORMAT_HIDVOL_TITLE"));

  03186	a1 00 00 00 00	 mov	 eax, DWORD PTR _bHiddenVolHost
  0318b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BJ@LIGEKHGE@FORMAT_HIDVOL_HOST_TITLE?$AA@
  03190	85 c0		 test	 eax, eax
  03192	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BE@CEEOMNDM@FORMAT_HIDVOL_TITLE?$AA@
  03197	0f 44 ca	 cmove	 ecx, edx
  0319a	51		 push	 ecx

; 4882 : 				else

  0319b	eb 05		 jmp	 SHORT $LN758@PageDialog
$LN160@PageDialog:

; 4883 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("FORMAT_TITLE"));

  0319d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FLIHGDJB@FORMAT_TITLE?$AA@
$LN758@PageDialog:
  031a2	e8 00 00 00 00	 call	 _GetString
  031a7	83 c4 04	 add	 esp, 4
  031aa	50		 push	 eax
  031ab	68 e8 03 00 00	 push	 1000			; 000003e8H
  031b0	53		 push	 ebx
  031b1	ff d6		 call	 esi
  031b3	50		 push	 eax
  031b4	ff d7		 call	 edi
  031b6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  031bc	50		 push	 eax
  031bd	ff d6		 call	 esi

; 4884 : 
; 4885 : 				/* Quick/Dynamic */
; 4886 : 
; 4887 : 				if (bHiddenVol)

  031bf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  031c6	0f 84 81 00 00
	00		 je	 $LN162@PageDialog

; 4888 : 				{
; 4889 : 					quickFormat = !bHiddenVolHost;

  031cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _bHiddenVolHost
  031d1	f7 d8		 neg	 eax
  031d3	1b c0		 sbb	 eax, eax
  031d5	40		 inc	 eax
  031d6	a3 00 00 00 00	 mov	 DWORD PTR ?quickFormat@@3HC, eax ; quickFormat

; 4890 : 					bSparseFileSwitch = FALSE;

  031db	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bSparseFileSwitch@@3HC, 0 ; bSparseFileSwitch

; 4891 : 
; 4892 : 					SetCheckBox (hwndDlg, IDC_QUICKFORMAT, quickFormat);

  031e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?quickFormat@@3HC ; quickFormat
  031ea	50		 push	 eax
  031eb	68 ff 03 00 00	 push	 1023			; 000003ffH
  031f0	53		 push	 ebx
  031f1	e8 00 00 00 00	 call	 _SetCheckBox
  031f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4893 : 					SetWindowTextW (GetDlgItem (hwndDlg, IDC_QUICKFORMAT), GetString ((bDevice || !bHiddenVolHost) ? "IDC_QUICKFORMAT" : "SPARSE_FILE"));

  031f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  03200	75 0e		 jne	 SHORT $LN348@PageDialog
  03202	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  03209	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@GPMOAIEF@SPARSE_FILE?$AA@
  0320e	75 05		 jne	 SHORT $LN349@PageDialog
$LN348@PageDialog:
  03210	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BA@LBGDFDPO@IDC_QUICKFORMAT?$AA@
$LN349@PageDialog:
  03215	50		 push	 eax
  03216	e8 00 00 00 00	 call	 _GetString
  0321b	83 c4 04	 add	 esp, 4
  0321e	50		 push	 eax
  0321f	68 ff 03 00 00	 push	 1023			; 000003ffH
  03224	53		 push	 ebx
  03225	ff d7		 call	 edi
  03227	50		 push	 eax
  03228	ff d6		 call	 esi

; 4894 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_QUICKFORMAT), bDevice && bHiddenVolHost);

  0322a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  03231	74 13		 je	 SHORT $LN350@PageDialog
  03233	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  0323a	74 0a		 je	 SHORT $LN350@PageDialog
  0323c	b8 01 00 00 00	 mov	 eax, 1
  03241	e9 b4 00 00 00	 jmp	 $LN351@PageDialog
$LN350@PageDialog:
  03246	33 c0		 xor	 eax, eax

; 4895 : 				}
; 4896 : 				else

  03248	e9 ad 00 00 00	 jmp	 $LN351@PageDialog
$LN162@PageDialog:

; 4897 : 				{
; 4898 : 					if (bDevice)

  0324d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  03254	74 27		 je	 SHORT $LN164@PageDialog

; 4899 : 					{
; 4900 : 						bSparseFileSwitch = FALSE;
; 4901 : 						SetWindowTextW (GetDlgItem (hwndDlg, IDC_QUICKFORMAT), GetString("IDC_QUICKFORMAT"));

  03256	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LBGDFDPO@IDC_QUICKFORMAT?$AA@
  0325b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bSparseFileSwitch@@3HC, 0 ; bSparseFileSwitch
  03265	e8 00 00 00 00	 call	 _GetString
  0326a	83 c4 04	 add	 esp, 4
  0326d	50		 push	 eax
  0326e	68 ff 03 00 00	 push	 1023			; 000003ffH
  03273	53		 push	 ebx
  03274	ff d7		 call	 edi
  03276	50		 push	 eax
  03277	ff d6		 call	 esi

; 4902 : 						EnableWindow (GetDlgItem (hwndDlg, IDC_QUICKFORMAT), TRUE);

  03279	6a 01		 push	 1

; 4903 : 					}
; 4904 : 					else

  0327b	eb 7e		 jmp	 SHORT $LN759@PageDialog
$LN164@PageDialog:

; 4905 : 					{
; 4906 : 						char root[GST_MAX_PATH];
; 4907 : 						DWORD fileSystemFlags = 0;
; 4908 : 
; 4909 : 						SetWindowTextW (GetDlgItem (hwndDlg, IDC_QUICKFORMAT), GetString("SPARSE_FILE"));

  0327d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GPMOAIEF@SPARSE_FILE?$AA@
  03282	c7 85 64 eb fe
	ff 00 00 00 00	 mov	 DWORD PTR _fileSystemFlags$10[ebp], 0
  0328c	e8 00 00 00 00	 call	 _GetString
  03291	83 c4 04	 add	 esp, 4
  03294	50		 push	 eax
  03295	68 ff 03 00 00	 push	 1023			; 000003ffH
  0329a	53		 push	 ebx
  0329b	ff d7		 call	 edi
  0329d	50		 push	 eax
  0329e	ff d6		 call	 esi

; 4910 : 
; 4911 : 						/* Check if the host file system supports sparse files */
; 4912 : 
; 4913 : 						if (GetVolumePathName (szFileName, root, sizeof (root)))

  032a0	68 04 01 00 00	 push	 260			; 00000104H
  032a5	8d 85 30 fc ff
	ff		 lea	 eax, DWORD PTR _root$28[ebp]
  032ab	50		 push	 eax
  032ac	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  032b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumePathNameA@12
  032b7	85 c0		 test	 eax, eax
  032b9	74 30		 je	 SHORT $LN166@PageDialog

; 4914 : 						{
; 4915 : 							GetVolumeInformation (root, NULL, 0, NULL, NULL, &fileSystemFlags, NULL, 0);

  032bb	6a 00		 push	 0
  032bd	6a 00		 push	 0
  032bf	8d 85 64 eb fe
	ff		 lea	 eax, DWORD PTR _fileSystemFlags$10[ebp]
  032c5	50		 push	 eax
  032c6	6a 00		 push	 0
  032c8	6a 00		 push	 0
  032ca	6a 00		 push	 0
  032cc	6a 00		 push	 0
  032ce	8d 85 30 fc ff
	ff		 lea	 eax, DWORD PTR _root$28[ebp]
  032d4	50		 push	 eax
  032d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeInformationA@32

; 4916 : 							bSparseFileSwitch = fileSystemFlags & FILE_SUPPORTS_SPARSE_FILES;

  032db	8b 85 64 eb fe
	ff		 mov	 eax, DWORD PTR _fileSystemFlags$10[ebp]
  032e1	83 e0 40	 and	 eax, 64			; 00000040H
  032e4	a3 00 00 00 00	 mov	 DWORD PTR ?bSparseFileSwitch@@3HC, eax ; bSparseFileSwitch

; 4917 : 						}
; 4918 : 						else

  032e9	eb 0a		 jmp	 SHORT $LN167@PageDialog
$LN166@PageDialog:

; 4919 : 							bSparseFileSwitch = FALSE;

  032eb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bSparseFileSwitch@@3HC, 0 ; bSparseFileSwitch
$LN167@PageDialog:

; 4920 : 
; 4921 : 						EnableWindow (GetDlgItem (hwndDlg, IDC_QUICKFORMAT), bSparseFileSwitch);

  032f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bSparseFileSwitch@@3HC ; bSparseFileSwitch
$LN351@PageDialog:
  032fa	50		 push	 eax
$LN759@PageDialog:
  032fb	68 ff 03 00 00	 push	 1023			; 000003ffH
  03300	53		 push	 ebx
  03301	ff d7		 call	 edi
  03303	50		 push	 eax
  03304	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 4922 : 					}
; 4923 : 				}
; 4924 : 
; 4925 : 				SendMessage (GetDlgItem (hwndDlg, IDC_SHOW_KEYS), BM_SETCHECK, showKeys ? BST_CHECKED : BST_UNCHECKED, 0);

  0330a	33 c0		 xor	 eax, eax
  0330c	39 05 00 00 00
	00		 cmp	 DWORD PTR _showKeys, eax
  03312	6a 00		 push	 0
  03314	0f 95 c0	 setne	 al
  03317	50		 push	 eax
  03318	68 f1 00 00 00	 push	 241			; 000000f1H
  0331d	68 06 04 00 00	 push	 1030			; 00000406H
  03322	53		 push	 ebx
  03323	ff d7		 call	 edi
  03325	50		 push	 eax
  03326	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4926 : 				SetWindowText (GetDlgItem (hwndDlg, IDC_RANDOM_BYTES), showKeys ? "" : "********************************                                              ");

  0332c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _showKeys, 0
  03333	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0EP@NPBFJCJA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
  03338	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0333d	0f 44 c1	 cmove	 eax, ecx
  03340	50		 push	 eax
  03341	68 fc 03 00 00	 push	 1020			; 000003fcH
  03346	53		 push	 ebx
  03347	ff d7		 call	 edi
  03349	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  0334f	50		 push	 eax
  03350	ff d6		 call	 esi

; 4927 : 				SetWindowText (GetDlgItem (hwndDlg, IDC_HEADER_KEY), showKeys ? "" : "********************************                                              ");

  03352	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _showKeys, 0
  03359	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0EP@NPBFJCJA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
  0335e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  03363	0f 44 c1	 cmove	 eax, ecx
  03366	50		 push	 eax
  03367	68 f9 03 00 00	 push	 1017			; 000003f9H
  0336c	53		 push	 ebx
  0336d	ff d7		 call	 edi
  0336f	50		 push	 eax
  03370	ff d6		 call	 esi

; 4928 : 				SetWindowText (GetDlgItem (hwndDlg, IDC_DISK_KEY), showKeys ? "" : "********************************                                              ");

  03372	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _showKeys, 0
  03379	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0EP@NPBFJCJA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
  0337e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  03383	0f 44 c1	 cmove	 eax, ecx
  03386	50		 push	 eax
  03387	68 fb 03 00 00	 push	 1019			; 000003fbH
  0338c	53		 push	 ebx
  0338d	ff d7		 call	 edi
  0338f	50		 push	 eax
  03390	ff d6		 call	 esi

; 4929 : 
; 4930 : 				SendMessage (GetDlgItem (hwndDlg, IDC_CLUSTERSIZE), CB_RESETCONTENT, 0, 0);

  03392	6a 00		 push	 0
  03394	6a 00		 push	 0
  03396	68 4b 01 00 00	 push	 331			; 0000014bH
  0339b	68 04 04 00 00	 push	 1028			; 00000404H
  033a0	53		 push	 ebx
  033a1	ff d7		 call	 edi
  033a3	50		 push	 eax
  033a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4931 : 				AddComboPairW (GetDlgItem (hwndDlg, IDC_CLUSTERSIZE), GetString ("DEFAULT"), 0);

  033aa	6a 00		 push	 0
  033ac	68 00 00 00 00	 push	 OFFSET ??_C@_07MGCPDNLD@DEFAULT?$AA@
  033b1	e8 00 00 00 00	 call	 _GetString
  033b6	83 c4 04	 add	 esp, 4
  033b9	50		 push	 eax
  033ba	68 04 04 00 00	 push	 1028			; 00000404H
  033bf	53		 push	 ebx
  033c0	ff d7		 call	 edi
  033c2	50		 push	 eax
  033c3	e8 00 00 00 00	 call	 _AddComboPairW
  033c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4932 : 
; 4933 : 				for (int i = 1; i <= 128; i *= 2)

  033cb	be 01 00 00 00	 mov	 esi, 1
$LL24@PageDialog:

; 4934 : 				{
; 4935 : 					wstringstream s;

  033d0	c7 85 7c ea fe
	ff 00 00 00 00	 mov	 DWORD PTR _s$2[ebp], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
  033da	c7 85 8c ea fe
	ff 00 00 00 00	 mov	 DWORD PTR _s$2[ebp+16], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
  033e4	83 8d 68 eb fe
	ff 01		 or	 DWORD PTR $T11[ebp], 1
  033eb	8d 85 94 ea fe
	ff		 lea	 eax, DWORD PTR _s$2[ebp+24]
  033f1	6a 00		 push	 0
  033f3	0f 57 c0	 xorps	 xmm0, xmm0
  033f6	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 5
  033fd	50		 push	 eax
  033fe	8d 8d e4 ea fe
	ff		 lea	 ecx, DWORD PTR _s$2[ebp+104]
  03404	c7 85 e4 ea fe
	ff 00 00 00 00	 mov	 DWORD PTR _s$2[ebp+104], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  0340e	c7 85 e0 ea fe
	ff 50 00 00 00	 mov	 DWORD PTR _s$2[ebp+100], 80 ; 00000050H
  03418	66 0f 13 85 84
	ea fe ff	 movlpd	 QWORD PTR _s$2[ebp+8], xmm0
  03420	e8 00 00 00 00	 call	 ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
  03425	8d 85 8c ea fe
	ff		 lea	 eax, DWORD PTR _s$2[ebp+16]
  0342b	89 85 78 eb fe
	ff		 mov	 DWORD PTR _this$12[ebp], eax
  03431	8b 85 8c ea fe
	ff		 mov	 eax, DWORD PTR _s$2[ebp+16]
  03437	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0343a	c7 84 05 8c ea
	fe ff 00 00 00
	00		 mov	 DWORD PTR _s$2[ebp+eax+16], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  03445	8b 85 8c ea fe
	ff		 mov	 eax, DWORD PTR _s$2[ebp+16]
  0344b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0344e	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  03451	89 84 0d 88 ea
	fe ff		 mov	 DWORD PTR _s$2[ebp+ecx+12], eax
  03458	8b 85 7c ea fe
	ff		 mov	 eax, DWORD PTR _s$2[ebp]
  0345e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  03461	c7 84 05 7c ea
	fe ff 00 00 00
	00		 mov	 DWORD PTR _s$2[ebp+eax], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  0346c	8b 85 7c ea fe
	ff		 mov	 eax, DWORD PTR _s$2[ebp]
  03472	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  03475	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  03478	89 84 0d 78 ea
	fe ff		 mov	 DWORD PTR _s$2[ebp+ecx-4], eax
  0347f	8b 85 7c ea fe
	ff		 mov	 eax, DWORD PTR _s$2[ebp]
  03485	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  0348c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0348f	c7 84 05 7c ea
	fe ff 00 00 00
	00		 mov	 DWORD PTR _s$2[ebp+eax], OFFSET ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0349a	8b 85 7c ea fe
	ff		 mov	 eax, DWORD PTR _s$2[ebp]
  034a0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  034a3	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  034a6	89 84 0d 78 ea
	fe ff		 mov	 DWORD PTR _s$2[ebp+ecx-4], eax
  034ad	8d 85 94 ea fe
	ff		 lea	 eax, DWORD PTR _s$2[ebp+24]
  034b3	8b c8		 mov	 ecx, eax
  034b5	89 85 78 eb fe
	ff		 mov	 DWORD PTR _this$[ebp], eax
  034bb	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  034c0	c7 85 94 ea fe
	ff 00 00 00 00	 mov	 DWORD PTR _s$2[ebp+24], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  034ca	c7 85 cc ea fe
	ff 00 00 00 00	 mov	 DWORD PTR _s$2[ebp+80], 0
  034d4	c7 85 d0 ea fe
	ff 00 00 00 00	 mov	 DWORD PTR _s$2[ebp+84], 0
  034de	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 12 ; 0000000cH

; 4936 : 					int size = GetFormatSectorSize() * i;

  034e5	e8 00 00 00 00	 call	 _GetFormatSectorSize
  034ea	0f af c6	 imul	 eax, esi

; 4937 : 
; 4938 : 					if (size > GST_MAX_FAT_CLUSTER_SIZE)

  034ed	3d 00 00 04 00	 cmp	 eax, 262144		; 00040000H
  034f2	0f 8f be 00 00
	00		 jg	 $LN672@PageDialog

; 4940 : 
; 4941 : 					if (size == 512)

  034f8	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  034fd	75 16		 jne	 SHORT $LN169@PageDialog

; 4942 : 						s << L"0.5";

  034ff	8d 85 8c ea fe
	ff		 lea	 eax, DWORD PTR _s$2[ebp+16]
  03505	68 00 00 00 00	 push	 OFFSET ??_C@_17OFEDBPDO@?$AA0?$AA?4?$AA5?$AA?$AA@
  0350a	50		 push	 eax
  0350b	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  03510	83 c4 08	 add	 esp, 8

; 4943 : 					else

  03513	eb 1c		 jmp	 SHORT $LN170@PageDialog
$LN169@PageDialog:

; 4944 : 						s << size / BYTES_PER_KB;

  03515	6a 00		 push	 0
  03517	99		 cdq
  03518	68 00 04 00 00	 push	 1024			; 00000400H
  0351d	52		 push	 edx
  0351e	50		 push	 eax
  0351f	e8 00 00 00 00	 call	 __alldiv
  03524	52		 push	 edx
  03525	50		 push	 eax
  03526	8d 8d 8c ea fe
	ff		 lea	 ecx, DWORD PTR _s$2[ebp+16]
  0352c	e8 00 00 00 00	 call	 ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
$LN170@PageDialog:

; 4945 : 
; 4946 : 					s << L" " << GetString ("KB");

  03531	68 00 00 00 00	 push	 OFFSET ??_C@_02LODOGJEL@KB?$AA@
  03536	e8 00 00 00 00	 call	 _GetString
  0353b	83 c4 04	 add	 esp, 4
  0353e	50		 push	 eax
  0353f	8d 85 8c ea fe
	ff		 lea	 eax, DWORD PTR _s$2[ebp+16]
  03545	68 00 00 00 00	 push	 OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  0354a	50		 push	 eax
  0354b	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  03550	83 c4 08	 add	 esp, 8
  03553	50		 push	 eax
  03554	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  03559	83 c4 08	 add	 esp, 8

; 4947 : 
; 4948 : 					AddComboPairW (GetDlgItem (hwndDlg, IDC_CLUSTERSIZE), s.str().c_str(), i);

  0355c	8d 85 b0 ed fe
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  03562	8d 8d 7c ea fe
	ff		 lea	 ecx, DWORD PTR _s$2[ebp]
  03568	50		 push	 eax
  03569	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
  0356e	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  03572	72 02		 jb	 SHORT $LN606@PageDialog
  03574	8b 00		 mov	 eax, DWORD PTR [eax]
$LN606@PageDialog:
  03576	56		 push	 esi
  03577	50		 push	 eax
  03578	68 04 04 00 00	 push	 1028			; 00000404H
  0357d	53		 push	 ebx
  0357e	ff d7		 call	 edi
  03580	50		 push	 eax
  03581	e8 00 00 00 00	 call	 _AddComboPairW
  03586	83 c4 0c	 add	 esp, 12			; 0000000cH
  03589	8d 8d b0 ed fe
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  0358f	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 4949 : 				}

  03594	8d 8d 7c ea fe
	ff		 lea	 ecx, DWORD PTR _s$2[ebp]
  0359a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  035a1	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
  035a6	03 f6		 add	 esi, esi
  035a8	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  035ae	0f 8e 1c fe ff
	ff		 jle	 $LL24@PageDialog

; 4937 : 
; 4938 : 					if (size > GST_MAX_FAT_CLUSTER_SIZE)

  035b4	eb 0b		 jmp	 SHORT $LN23@PageDialog
$LN672@PageDialog:

; 4939 : 						break;

  035b6	8d 8d 7c ea fe
	ff		 lea	 ecx, DWORD PTR _s$2[ebp]
  035bc	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
$LN23@PageDialog:

; 4950 : 
; 4951 : 				SendMessage (GetDlgItem (hwndDlg, IDC_CLUSTERSIZE), CB_SETCURSEL, 0, 0);

  035c1	6a 00		 push	 0
  035c3	6a 00		 push	 0
  035c5	68 4e 01 00 00	 push	 334			; 0000014eH
  035ca	68 04 04 00 00	 push	 1028			; 00000404H
  035cf	53		 push	 ebx
  035d0	ff d7		 call	 edi
  035d2	50		 push	 eax
  035d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4952 : 
; 4953 : 				EnableWindow (GetDlgItem (hwndDlg, IDC_CLUSTERSIZE), TRUE);

  035d9	6a 01		 push	 1
  035db	68 04 04 00 00	 push	 1028			; 00000404H
  035e0	53		 push	 ebx
  035e1	ff d7		 call	 edi
  035e3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  035e9	50		 push	 eax
  035ea	ff d6		 call	 esi

; 4954 : 
; 4955 : 				/* Filesystems */
; 4956 : 
; 4957 : 				bNTFSallowed = FALSE;
; 4958 : 				bFATallowed = FALSE;
; 4959 : 				bNoFSallowed = FALSE;
; 4960 : 
; 4961 : 				SendMessage (GetDlgItem (hwndDlg, IDC_FILESYS), CB_RESETCONTENT, 0, 0);

  035ec	6a 00		 push	 0
  035ee	6a 00		 push	 0
  035f0	68 4b 01 00 00	 push	 331			; 0000014bH
  035f5	68 05 04 00 00	 push	 1029			; 00000405H
  035fa	53		 push	 ebx
  035fb	c7 85 7c eb fe
	ff 00 00 00 00	 mov	 DWORD PTR _bNTFSallowed$1$[ebp], 0
  03605	c7 85 70 eb fe
	ff 00 00 00 00	 mov	 DWORD PTR _bFATallowed$1$[ebp], 0
  0360f	c7 85 78 eb fe
	ff 00 00 00 00	 mov	 DWORD PTR _bNoFSallowed$1$[ebp], 0
  03619	ff d7		 call	 edi
  0361b	50		 push	 eax
  0361c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 4962 : 
; 4963 : 				EnableWindow (GetDlgItem (hwndDlg, IDC_FILESYS), TRUE);

  03622	6a 01		 push	 1
  03624	68 05 04 00 00	 push	 1029			; 00000405H
  03629	53		 push	 ebx
  0362a	ff d7		 call	 edi
  0362c	50		 push	 eax
  0362d	ff d6		 call	 esi

; 4964 : 
; 4965 : 				uint64 dataAreaSize = GetVolumeDataAreaSize (bHiddenVol && !bHiddenVolHost, nVolumeSize);

  0362f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  03636	74 10		 je	 SHORT $LN356@PageDialog
  03638	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  0363f	75 07		 jne	 SHORT $LN356@PageDialog
  03641	b8 01 00 00 00	 mov	 eax, 1
  03646	eb 02		 jmp	 SHORT $LN357@PageDialog
$LN356@PageDialog:
  03648	33 c0		 xor	 eax, eax
$LN357@PageDialog:
  0364a	ff 35 04 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA+4
  03650	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA
  03656	50		 push	 eax
  03657	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  0365c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0365f	89 95 74 eb fe
	ff		 mov	 DWORD PTR _dataAreaSize$2$[ebp], edx
  03665	8b c8		 mov	 ecx, eax
  03667	89 8d 6c eb fe
	ff		 mov	 DWORD PTR _dataAreaSize$1$[ebp], ecx

; 4966 : 
; 4967 : 				if (!CreatingHiddenSysVol())	

  0366d	e8 00 00 00 00	 call	 _CreatingHiddenSysVol
  03672	85 c0		 test	 eax, eax
  03674	0f 85 92 00 00
	00		 jne	 $LN171@PageDialog

; 4968 : 				{
; 4969 : 					if (dataAreaSize >= GST_MIN_NTFS_FS_SIZE && dataAreaSize <= GST_MAX_NTFS_FS_SIZE)

  0367a	8b c1		 mov	 eax, ecx
  0367c	8b ca		 mov	 ecx, edx
  0367e	05 00 c0 c8 ff	 add	 eax, -3620864		; ffc8c000H
  03683	83 d1 ff	 adc	 ecx, -1
  03686	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0368c	77 31		 ja	 SHORT $LN173@PageDialog
  0368e	72 07		 jb	 SHORT $LN716@PageDialog
  03690	3d 00 c0 c8 ff	 cmp	 eax, -3620864		; ffc8c000H
  03695	77 28		 ja	 SHORT $LN173@PageDialog
$LN716@PageDialog:

; 4970 : 					{
; 4971 : 						AddComboPair (GetDlgItem (hwndDlg, IDC_FILESYS), "NTFS", FILESYS_NTFS);

  03697	6a 02		 push	 2
  03699	68 00 00 00 00	 push	 OFFSET ??_C@_04HPPAIJNK@NTFS?$AA@
  0369e	68 05 04 00 00	 push	 1029			; 00000405H
  036a3	53		 push	 ebx
  036a4	ff d7		 call	 edi
  036a6	50		 push	 eax
  036a7	e8 00 00 00 00	 call	 _AddComboPair
  036ac	8b 95 74 eb fe
	ff		 mov	 edx, DWORD PTR _dataAreaSize$2$[ebp]
  036b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4972 : 						bNTFSallowed = TRUE;

  036b5	c7 85 7c eb fe
	ff 01 00 00 00	 mov	 DWORD PTR _bNTFSallowed$1$[ebp], 1
$LN173@PageDialog:

; 4973 : 					}
; 4974 : 
; 4975 : 					if (dataAreaSize >= GST_MIN_FAT_FS_SIZE && dataAreaSize <= GST_MAX_FAT_SECTOR_COUNT * GetFormatSectorSize())

  036bf	85 d2		 test	 edx, edx
  036c1	75 0c		 jne	 SHORT $LN717@PageDialog
  036c3	81 bd 6c eb fe
	ff 00 90 00 00	 cmp	 DWORD PTR _dataAreaSize$1$[ebp], 36864 ; 00009000H
  036cd	72 57		 jb	 SHORT $LN172@PageDialog
$LN717@PageDialog:
  036cf	e8 00 00 00 00	 call	 _GetFormatSectorSize
  036d4	99		 cdq
  036d5	39 85 74 eb fe
	ff		 cmp	 DWORD PTR _dataAreaSize$2$[ebp], eax
  036db	77 49		 ja	 SHORT $LN172@PageDialog
  036dd	72 09		 jb	 SHORT $LN718@PageDialog
  036df	83 bd 6c eb fe
	ff 00		 cmp	 DWORD PTR _dataAreaSize$1$[ebp], 0
  036e6	77 3e		 ja	 SHORT $LN172@PageDialog
$LN718@PageDialog:

; 4976 : 					{
; 4977 : 						AddComboPair (GetDlgItem (hwndDlg, IDC_FILESYS), "FAT", FILESYS_FAT);

  036e8	6a 01		 push	 1
  036ea	68 00 00 00 00	 push	 OFFSET ??_C@_03MPELFIKF@FAT?$AA@
  036ef	68 05 04 00 00	 push	 1029			; 00000405H
  036f4	53		 push	 ebx
  036f5	ff d7		 call	 edi
  036f7	50		 push	 eax
  036f8	e8 00 00 00 00	 call	 _AddComboPair
  036fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4978 : 						bFATallowed = TRUE;

  03700	c7 85 70 eb fe
	ff 01 00 00 00	 mov	 DWORD PTR _bFATallowed$1$[ebp], 1

; 4979 : 					}
; 4980 : 				}
; 4981 : 				else

  0370a	eb 1a		 jmp	 SHORT $LN172@PageDialog
$LN171@PageDialog:

; 4982 : 				{
; 4983 : 					// We're creating a hidden volume for a hidden OS, so we don't need to format it with
; 4984 : 					// any filesystem (the entire OS will be copied to the hidden volume sector by sector).
; 4985 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_FILESYS), FALSE);

  0370c	6a 00		 push	 0
  0370e	68 05 04 00 00	 push	 1029			; 00000405H
  03713	53		 push	 ebx
  03714	ff d7		 call	 edi
  03716	50		 push	 eax
  03717	ff d6		 call	 esi

; 4986 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_CLUSTERSIZE), FALSE);

  03719	6a 00		 push	 0
  0371b	68 04 04 00 00	 push	 1028			; 00000404H
  03720	53		 push	 ebx
  03721	ff d7		 call	 edi
  03723	50		 push	 eax
  03724	ff d6		 call	 esi
$LN172@PageDialog:

; 4987 : 				}
; 4988 : 
; 4989 : 				if (!bHiddenVolHost)

  03726	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  0372d	75 2b		 jne	 SHORT $LN175@PageDialog

; 4990 : 				{
; 4991 : 					AddComboPairW (GetDlgItem (hwndDlg, IDC_FILESYS), GetString ("NONE"), FILESYS_NONE);

  0372f	6a 00		 push	 0
  03731	68 00 00 00 00	 push	 OFFSET ??_C@_04OKGDLNCL@NONE?$AA@
  03736	e8 00 00 00 00	 call	 _GetString
  0373b	83 c4 04	 add	 esp, 4
  0373e	50		 push	 eax
  0373f	68 05 04 00 00	 push	 1029			; 00000405H
  03744	53		 push	 ebx
  03745	ff d7		 call	 edi
  03747	50		 push	 eax
  03748	e8 00 00 00 00	 call	 _AddComboPairW
  0374d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4992 : 					bNoFSallowed = TRUE;

  03750	c7 85 78 eb fe
	ff 01 00 00 00	 mov	 DWORD PTR _bNoFSallowed$1$[ebp], 1
$LN175@PageDialog:

; 4993 : 				}
; 4994 : 
; 4995 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  0375a	6a 01		 push	 1
  0375c	68 10 04 00 00	 push	 1040			; 00000410H
  03761	53		 push	 ebx
  03762	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03768	50		 push	 eax
  03769	ff d7		 call	 edi
  0376b	50		 push	 eax
  0376c	ff d6		 call	 esi

; 4996 : 
; 4997 : 				if (fileSystem == FILESYS_NONE)	// If no file system has been previously selected

  0376e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?fileSystem@@3HC, 0 ; fileSystem
  03775	0f 85 7d 00 00
	00		 jne	 $LN183@PageDialog
  0377b	83 bd 70 eb fe
	ff 00		 cmp	 DWORD PTR _bFATallowed$1$[ebp], 0

; 4998 : 				{
; 4999 : 					// Set default file system
; 5000 : 
; 5001 : 					if (bFATallowed && !(nNeedToStoreFilesOver4GB == 1 && bNTFSallowed))

  03782	74 1e		 je	 SHORT $LN177@PageDialog
  03784	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?nNeedToStoreFilesOver4GB@@3HA, 1 ; nNeedToStoreFilesOver4GB
  0378b	75 09		 jne	 SHORT $LN179@PageDialog
  0378d	83 bd 7c eb fe
	ff 00		 cmp	 DWORD PTR _bNTFSallowed$1$[ebp], 0
  03794	75 15		 jne	 SHORT $LN701@PageDialog
$LN179@PageDialog:

; 5002 : 						fileSystem = FILESYS_FAT;

  03796	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?fileSystem@@3HC, 1 ; fileSystem
  037a0	eb 56		 jmp	 SHORT $LN183@PageDialog
$LN177@PageDialog:
  037a2	83 bd 7c eb fe
	ff 00		 cmp	 DWORD PTR _bNTFSallowed$1$[ebp], 0

; 5003 : 					else if (bNTFSallowed)

  037a9	74 0c		 je	 SHORT $LN180@PageDialog
$LN701@PageDialog:

; 5004 : 						fileSystem = FILESYS_NTFS;

  037ab	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?fileSystem@@3HC, 2 ; fileSystem
  037b5	eb 41		 jmp	 SHORT $LN183@PageDialog
$LN180@PageDialog:
  037b7	83 bd 78 eb fe
	ff 00		 cmp	 DWORD PTR _bNoFSallowed$1$[ebp], 0

; 5005 : 					else if (bNoFSallowed)

  037be	74 0c		 je	 SHORT $LN182@PageDialog

; 5006 : 						fileSystem = FILESYS_NONE;

  037c0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?fileSystem@@3HC, 0 ; fileSystem

; 5007 : 					else

  037ca	eb 2c		 jmp	 SHORT $LN183@PageDialog
$LN182@PageDialog:

; 5008 : 					{
; 5009 : 						AddComboPair (GetDlgItem (hwndDlg, IDC_FILESYS), "---", 0);

  037cc	6a 00		 push	 0
  037ce	68 00 00 00 00	 push	 OFFSET ??_C@_03JMFMNIFM@?9?9?9?$AA@
  037d3	68 05 04 00 00	 push	 1029			; 00000405H
  037d8	53		 push	 ebx
  037d9	ff d7		 call	 edi
  037db	50		 push	 eax
  037dc	e8 00 00 00 00	 call	 _AddComboPair
  037e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5010 : 						EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), FALSE);

  037e4	6a 00		 push	 0
  037e6	68 10 04 00 00	 push	 1040			; 00000410H
  037eb	53		 push	 ebx
  037ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  037f2	50		 push	 eax
  037f3	ff d7		 call	 edi
  037f5	50		 push	 eax
  037f6	ff d6		 call	 esi
$LN183@PageDialog:

; 5011 : 					}
; 5012 : 				}
; 5013 : 
; 5014 : 				SendMessage (GetDlgItem (hwndDlg, IDC_FILESYS), CB_SETCURSEL, 0, 0);

  037f8	6a 00		 push	 0
  037fa	6a 00		 push	 0
  037fc	68 4e 01 00 00	 push	 334			; 0000014eH
  03801	68 05 04 00 00	 push	 1029			; 00000405H
  03806	53		 push	 ebx
  03807	ff d7		 call	 edi
  03809	50		 push	 eax
  0380a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 5015 : 				SelectAlgo (GetDlgItem (hwndDlg, IDC_FILESYS), (int *) &fileSystem);

  03810	68 00 00 00 00	 push	 OFFSET ?fileSystem@@3HC	; fileSystem
  03815	68 05 04 00 00	 push	 1029			; 00000405H
  0381a	53		 push	 ebx
  0381b	ff d7		 call	 edi
  0381d	50		 push	 eax
  0381e	e8 00 00 00 00	 call	 _SelectAlgo
  03823	83 c4 08	 add	 esp, 8

; 5016 : 
; 5017 : 				EnableWindow (GetDlgItem (hwndDlg, IDC_ABORT_BUTTON), FALSE);

  03826	6a 00		 push	 0
  03828	68 f8 03 00 00	 push	 1016			; 000003f8H
  0382d	53		 push	 ebx
  0382e	ff d7		 call	 edi
  03830	50		 push	 eax
  03831	ff d6		 call	 esi

; 5018 : 
; 5019 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("FORMAT"));

  03833	68 00 00 00 00	 push	 OFFSET ??_C@_06DPGELLJH@FORMAT?$AA@
  03838	e8 00 00 00 00	 call	 _GetString
  0383d	83 c4 04	 add	 esp, 4
  03840	50		 push	 eax
  03841	68 10 04 00 00	 push	 1040			; 00000410H
  03846	53		 push	 ebx
  03847	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0384d	50		 push	 eax
  0384e	ff d7		 call	 edi
  03850	50		 push	 eax
  03851	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 5020 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  03857	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  0385c	e8 00 00 00 00	 call	 _GetString
  03861	83 c4 04	 add	 esp, 4
  03864	50		 push	 eax
  03865	68 11 04 00 00	 push	 1041			; 00000411H
  0386a	53		 push	 ebx
  0386b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03871	50		 push	 eax
  03872	ff d7		 call	 edi
  03874	50		 push	 eax
  03875	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 5021 : 
; 5022 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  0387b	6a 01		 push	 1
  0387d	68 11 04 00 00	 push	 1041			; 00000411H
  03882	53		 push	 ebx
  03883	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03889	50		 push	 eax
  0388a	ff d7		 call	 edi
  0388c	50		 push	 eax
  0388d	ff d6		 call	 esi

; 5023 : 
; 5024 : 				SetFocus (GetDlgItem (GetParent (hwndDlg), IDC_NEXT));

  0388f	68 10 04 00 00	 push	 1040			; 00000410H
  03894	53		 push	 ebx
  03895	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0389b	50		 push	 eax
  0389c	ff d7		 call	 edi
  0389e	50		 push	 eax
  0389f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4
  038a5	33 c0		 xor	 eax, eax
  038a7	e9 1c 1b 00 00	 jmp	 $LN1@PageDialog
$LN184@PageDialog:

; 5025 : 			}
; 5026 : 			break;
; 5027 : 
; 5028 : 		case FORMAT_FINISHED_PAGE:
; 5029 : 			{
; 5030 : 				if (!bHiddenVolHost && bHiddenVol && !bHiddenVolFinished)

  038ac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  038b3	0f 85 f1 00 00
	00		 jne	 $LN185@PageDialog
  038b9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  038c0	0f 84 e4 00 00
	00		 je	 $LN185@PageDialog
  038c6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVolFinished@@3HC, 0 ; bHiddenVolFinished
  038cd	0f 85 d7 00 00
	00		 jne	 $LN185@PageDialog

; 5031 : 				{
; 5032 : 					wchar_t msg[4096];
; 5033 : 
; 5034 : 					nNeedToStoreFilesOver4GB = -1;
; 5035 : 
; 5036 : 					if (bHiddenOS)

  038d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  038da	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nNeedToStoreFilesOver4GB@@3HA, -1 ; nNeedToStoreFilesOver4GB
  038e4	74 76		 je	 SHORT $LN187@PageDialog

; 5037 : 					{
; 5038 : 						wchar_t szMaxRecomOuterVolFillSize[100];
; 5039 : 
; 5040 : 						__int64 maxRecomOuterVolFillSize = 0;
; 5041 : 
; 5042 : 						// Determine the maximum recommended total size of files that can be copied to the outer volume
; 5043 : 						// while leaving enough space for the hidden volume, which must contain a clone of the OS
; 5044 : 
; 5045 : 						maxRecomOuterVolFillSize = nVolumeSize - GetSystemPartitionSize(); 

  038e6	e8 00 00 00 00	 call	 ?GetSystemPartitionSize@@YA_JXZ ; GetSystemPartitionSize
  038eb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?nVolumeSize@@3_KA
  038f1	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?nVolumeSize@@3_KA+4
  038f7	2b f8		 sub	 edi, eax

; 5046 : 
; 5047 : 						// -50% reserve for filesystem "peculiarities"
; 5048 : 						maxRecomOuterVolFillSize /= 2;	
; 5049 : 
; 5050 : 						swprintf (szMaxRecomOuterVolFillSize, L"%I64d %s", maxRecomOuterVolFillSize / BYTES_PER_MB, GetString ("MB"));

  038f9	68 00 00 00 00	 push	 OFFSET ??_C@_02LKLDBFPJ@MB?$AA@
  038fe	1b f2		 sbb	 esi, edx
  03900	e8 00 00 00 00	 call	 _GetString
  03905	83 c4 04	 add	 esp, 4
  03908	50		 push	 eax
  03909	6a 00		 push	 0
  0390b	68 00 00 20 00	 push	 2097152			; 00200000H
  03910	56		 push	 esi
  03911	57		 push	 edi
  03912	e8 00 00 00 00	 call	 __alldiv
  03917	52		 push	 edx
  03918	50		 push	 eax
  03919	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _szMaxRecomOuterVolFillSize$31[ebp]
  0391f	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@JJPHEOJD@?$AA?$CF?$AAI?$AA6?$AA4?$AAd?$AA?5?$AA?$CF?$AAs?$AA?$AA@
  03924	50		 push	 eax
  03925	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf
  0392a	83 c4 14	 add	 esp, 20			; 00000014H

; 5051 : 
; 5052 : 						swprintf (msg, GetString ("HIDVOL_HOST_FILLING_HELP_SYSENC"), hiddenVolHostDriveNo + 'A', szMaxRecomOuterVolFillSize);			

  0392d	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _szMaxRecomOuterVolFillSize$31[ebp]
  03933	50		 push	 eax
  03934	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  03939	83 c0 41	 add	 eax, 65			; 00000041H
  0393c	50		 push	 eax
  0393d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NGPBKLAB@HIDVOL_HOST_FILLING_HELP_SYSENC?$AA@
  03942	e8 00 00 00 00	 call	 _GetString
  03947	83 c4 04	 add	 esp, 4
  0394a	50		 push	 eax
  0394b	8d 85 90 6c ff
	ff		 lea	 eax, DWORD PTR _msg$23[ebp]
  03951	50		 push	 eax
  03952	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf
  03957	83 c4 10	 add	 esp, 16			; 00000010H

; 5053 : 					}
; 5054 : 					else

  0395a	eb 26		 jmp	 SHORT $LN188@PageDialog
$LN187@PageDialog:

; 5055 : 						swprintf (msg, GetString ("HIDVOL_HOST_FILLING_HELP"), hiddenVolHostDriveNo + 'A');

  0395c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  03961	83 c0 41	 add	 eax, 65			; 00000041H
  03964	50		 push	 eax
  03965	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@NMHGGMKI@HIDVOL_HOST_FILLING_HELP?$AA@
  0396a	e8 00 00 00 00	 call	 _GetString
  0396f	83 c4 04	 add	 esp, 4
  03972	50		 push	 eax
  03973	8d 85 90 6c ff
	ff		 lea	 eax, DWORD PTR _msg$23[ebp]
  03979	50		 push	 eax
  0397a	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf
  0397f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN188@PageDialog:

; 5056 : 
; 5057 : 					SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), msg);

  03982	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  03988	8d 85 90 6c ff
	ff		 lea	 eax, DWORD PTR _msg$23[ebp]
  0398e	50		 push	 eax
  0398f	68 eb 03 00 00	 push	 1003			; 000003ebH
  03994	53		 push	 ebx
  03995	ff d6		 call	 esi
  03997	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetWindowTextW@8
  0399d	50		 push	 eax
  0399e	ff d7		 call	 edi

; 5058 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("HIDVOL_HOST_FILLING_TITLE"));

  039a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@GEKKOMHD@HIDVOL_HOST_FILLING_TITLE?$AA@

; 5059 : 				}
; 5060 : 				else 

  039a5	e9 84 00 00 00	 jmp	 $LN760@PageDialog
$LN185@PageDialog:

; 5061 : 				{
; 5062 : 					if (bHiddenOS)

  039aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  039b1	74 27		 je	 SHORT $LN189@PageDialog

; 5063 : 						SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYSENC_HIDDEN_VOL_FORMAT_FINISHED_HELP"));

  039b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DILBCENC@SYSENC_HIDDEN_VOL_FORMAT_FINISHE@
  039b8	e8 00 00 00 00	 call	 _GetString
  039bd	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  039c3	83 c4 04	 add	 esp, 4
  039c6	50		 push	 eax
  039c7	68 eb 03 00 00	 push	 1003			; 000003ebH
  039cc	53		 push	 ebx
  039cd	ff d6		 call	 esi
  039cf	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetWindowTextW@8
  039d5	50		 push	 eax
  039d6	ff d7		 call	 edi

; 5064 : 					else

  039d8	eb 3f		 jmp	 SHORT $LN190@PageDialog
$LN189@PageDialog:

; 5065 : 					{
; 5066 : 						SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString (bInPlaceEncNonSys ? "NONSYS_INPLACE_ENC_FINISHED_INFO" : "FORMAT_FINISHED_HELP"));

  039da	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  039df	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BF@GBMPIMLF@FORMAT_FINISHED_HELP?$AA@
  039e4	85 c0		 test	 eax, eax
  039e6	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CB@KOCBDKDK@NONSYS_INPLACE_ENC_FINISHED_INFO@
  039eb	0f 44 ca	 cmove	 ecx, edx
  039ee	51		 push	 ecx
  039ef	e8 00 00 00 00	 call	 _GetString
  039f4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  039fa	83 c4 04	 add	 esp, 4
  039fd	50		 push	 eax
  039fe	68 eb 03 00 00	 push	 1003			; 000003ebH
  03a03	53		 push	 ebx
  03a04	ff d6		 call	 esi
  03a06	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetWindowTextW@8
  03a0c	50		 push	 eax
  03a0d	ff d7		 call	 edi

; 5067 : 						bConfirmQuit = FALSE;

  03a0f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bConfirmQuit@@3HC, 0 ; bConfirmQuit
$LN190@PageDialog:

; 5068 : 					}
; 5069 : 
; 5070 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString (bHiddenVol ? "HIDVOL_FORMAT_FINISHED_TITLE" : "FORMAT_FINISHED_TITLE"));

  03a19	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bHiddenVol@@3HC ; bHiddenVol
  03a1e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BN@DJMJCNLA@HIDVOL_FORMAT_FINISHED_TITLE?$AA@
  03a23	85 c0		 test	 eax, eax
  03a25	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@HBBDJEK@FORMAT_FINISHED_TITLE?$AA@
  03a2a	0f 44 ca	 cmove	 ecx, edx
  03a2d	51		 push	 ecx
$LN760@PageDialog:
  03a2e	e8 00 00 00 00	 call	 _GetString
  03a33	83 c4 04	 add	 esp, 4
  03a36	50		 push	 eax
  03a37	68 e8 03 00 00	 push	 1000			; 000003e8H
  03a3c	53		 push	 ebx
  03a3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03a43	50		 push	 eax
  03a44	ff d6		 call	 esi
  03a46	50		 push	 eax
  03a47	ff d7		 call	 edi

; 5071 : 				}
; 5072 : 
; 5073 : 
; 5074 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  03a49	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  03a4e	e8 00 00 00 00	 call	 _GetString
  03a53	83 c4 04	 add	 esp, 4
  03a56	50		 push	 eax
  03a57	68 10 04 00 00	 push	 1040			; 00000410H
  03a5c	53		 push	 ebx
  03a5d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03a63	50		 push	 eax
  03a64	ff d6		 call	 esi
  03a66	50		 push	 eax
  03a67	ff d7		 call	 edi

; 5075 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  03a69	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  03a6e	e8 00 00 00 00	 call	 _GetString
  03a73	83 c4 04	 add	 esp, 4
  03a76	50		 push	 eax
  03a77	68 11 04 00 00	 push	 1041			; 00000411H
  03a7c	53		 push	 ebx
  03a7d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03a83	50		 push	 eax
  03a84	ff d6		 call	 esi
  03a86	50		 push	 eax
  03a87	ff d7		 call	 edi

; 5076 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  03a89	6a 01		 push	 1
  03a8b	68 10 04 00 00	 push	 1040			; 00000410H
  03a90	53		 push	 ebx
  03a91	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03a97	50		 push	 eax
  03a98	ff d6		 call	 esi
  03a9a	50		 push	 eax
  03a9b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 5077 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), (!bHiddenVol || bHiddenVolFinished) && !bHiddenOS && !bInPlaceEncNonSys);

  03aa1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  03aa8	74 09		 je	 SHORT $LN358@PageDialog
  03aaa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVolFinished@@3HC, 0 ; bHiddenVolFinished
  03ab1	74 19		 je	 SHORT $LN359@PageDialog
$LN358@PageDialog:
  03ab3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  03aba	75 10		 jne	 SHORT $LN359@PageDialog
  03abc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  03ac3	75 07		 jne	 SHORT $LN359@PageDialog
  03ac5	b8 01 00 00 00	 mov	 eax, 1
  03aca	eb 02		 jmp	 SHORT $LN360@PageDialog
$LN359@PageDialog:
  03acc	33 c0		 xor	 eax, eax
$LN360@PageDialog:
  03ace	50		 push	 eax
  03acf	68 11 04 00 00	 push	 1041			; 00000411H
  03ad4	53		 push	 ebx
  03ad5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03adb	50		 push	 eax
  03adc	ff d6		 call	 esi
  03ade	50		 push	 eax
  03adf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 5078 : 
; 5079 : 				if ((!bHiddenVol || bHiddenVolFinished) && !bHiddenOS)

  03ae5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  03aec	74 0d		 je	 SHORT $LN192@PageDialog
  03aee	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVolFinished@@3HC, 0 ; bHiddenVolFinished
  03af5	0f 84 de cc ff
	ff		 je	 $LN384@PageDialog
$LN192@PageDialog:
  03afb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  03b02	0f 85 d1 cc ff
	ff		 jne	 $LN384@PageDialog

; 5080 : 					SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("EXIT"));

  03b08	68 00 00 00 00	 push	 OFFSET ??_C@_04GOLNGIJ@EXIT?$AA@
  03b0d	e8 00 00 00 00	 call	 _GetString
  03b12	83 c4 04	 add	 esp, 4
  03b15	50		 push	 eax
  03b16	6a 02		 push	 2
  03b18	53		 push	 ebx
  03b19	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03b1f	50		 push	 eax
  03b20	ff d6		 call	 esi
  03b22	50		 push	 eax
  03b23	ff d7		 call	 edi
  03b25	33 c0		 xor	 eax, eax
  03b27	e9 9c 18 00 00	 jmp	 $LN1@PageDialog
$LN193@PageDialog:

; 5081 : 			}
; 5082 : 			break;
; 5083 : 
; 5084 : 		case SYSENC_HIDDEN_OS_INITIAL_INFO_PAGE:
; 5085 : 
; 5086 : 			if (!IsHiddenOSRunning() || !bHiddenOS)

  03b2c	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  03b31	85 c0		 test	 eax, eax
  03b33	0f 84 02 01 00
	00		 je	 $LN195@PageDialog
  03b39	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  03b40	0f 84 f5 00 00
	00		 je	 $LN195@PageDialog

; 5091 : 			}
; 5092 : 
; 5093 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_HIDDEN_OS_INITIAL_INFO_TITLE"));

  03b46	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LLANPMHF@SYSENC_HIDDEN_OS_INITIAL_INFO_TI@
  03b4b	e8 00 00 00 00	 call	 _GetString
  03b50	83 c4 04	 add	 esp, 4
  03b53	50		 push	 eax
  03b54	68 e8 03 00 00	 push	 1000			; 000003e8H
  03b59	53		 push	 ebx
  03b5a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  03b60	ff d3		 call	 ebx
  03b62	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  03b68	50		 push	 eax
  03b69	ff d7		 call	 edi
  03b6b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  03b71	50		 push	 eax
  03b72	ff d6		 call	 esi

; 5094 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("FIRST_HIDDEN_OS_BOOT_INFO"));

  03b74	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FHELJNGN@FIRST_HIDDEN_OS_BOOT_INFO?$AA@
  03b79	e8 00 00 00 00	 call	 _GetString
  03b7e	83 c4 04	 add	 esp, 4
  03b81	50		 push	 eax
  03b82	68 eb 03 00 00	 push	 1003			; 000003ebH
  03b87	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03b8d	ff d7		 call	 edi
  03b8f	50		 push	 eax
  03b90	ff d6		 call	 esi

; 5095 : 
; 5096 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  03b92	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  03b97	e8 00 00 00 00	 call	 _GetString
  03b9c	83 c4 04	 add	 esp, 4
  03b9f	50		 push	 eax
  03ba0	68 10 04 00 00	 push	 1040			; 00000410H
  03ba5	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03bab	ff d3		 call	 ebx
  03bad	50		 push	 eax
  03bae	ff d7		 call	 edi
  03bb0	50		 push	 eax
  03bb1	ff d6		 call	 esi

; 5097 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  03bb3	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  03bb8	e8 00 00 00 00	 call	 _GetString
  03bbd	83 c4 04	 add	 esp, 4
  03bc0	50		 push	 eax
  03bc1	68 11 04 00 00	 push	 1041			; 00000411H
  03bc6	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03bcc	ff d3		 call	 ebx
  03bce	50		 push	 eax
  03bcf	ff d7		 call	 edi
  03bd1	50		 push	 eax
  03bd2	ff d6		 call	 esi

; 5098 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("DEFER"));

  03bd4	68 00 00 00 00	 push	 OFFSET ??_C@_05KEELGAD@DEFER?$AA@
  03bd9	e8 00 00 00 00	 call	 _GetString
  03bde	83 c4 04	 add	 esp, 4
  03be1	50		 push	 eax
  03be2	6a 02		 push	 2
  03be4	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03bea	ff d3		 call	 ebx
  03bec	50		 push	 eax
  03bed	ff d7		 call	 edi
  03bef	50		 push	 eax
  03bf0	ff d6		 call	 esi

; 5099 : 
; 5100 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  03bf2	6a 01		 push	 1
  03bf4	68 10 04 00 00	 push	 1040			; 00000410H
  03bf9	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03bff	ff d3		 call	 ebx
  03c01	50		 push	 eax
  03c02	ff d7		 call	 edi
  03c04	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  03c0a	50		 push	 eax
  03c0b	ff d6		 call	 esi

; 5101 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  03c0d	6a 00		 push	 0
  03c0f	68 11 04 00 00	 push	 1041			; 00000411H
  03c14	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03c1a	ff d3		 call	 ebx
  03c1c	50		 push	 eax
  03c1d	ff d7		 call	 edi
  03c1f	50		 push	 eax
  03c20	ff d6		 call	 esi

; 5102 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  03c22	6a 01		 push	 1
  03c24	6a 02		 push	 2
  03c26	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03c2c	ff d3		 call	 ebx

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  03c2e	50		 push	 eax
  03c2f	ff d7		 call	 edi
  03c31	50		 push	 eax
  03c32	ff d6		 call	 esi

; 3977 : 					return 0;

  03c34	33 c0		 xor	 eax, eax
  03c36	e9 8d 17 00 00	 jmp	 $LN1@PageDialog
$LN195@PageDialog:

; 5087 : 			{
; 5088 : 				ReportUnexpectedState (SRC_POS);

  03c3b	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KFFNPDGB@PageDialogProc?35088?$AA@
  03c40	e8 00 00 00 00	 call	 _ReportUnexpectedState

; 5089 : 				EndMainDlg (MainDlg);
; 5090 : 				return 0;

  03c45	e9 0b f0 ff ff	 jmp	 $LN783@PageDialog
$LN196@PageDialog:

; 5103 : 			break;
; 5104 : 
; 5105 : 		case SYSENC_HIDDEN_OS_WIPE_INFO_PAGE:
; 5106 : 
; 5107 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SYSENC_HIDDEN_OS_WIPE_INFO_TITLE"));

  03c4a	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MMHOKPDB@SYSENC_HIDDEN_OS_WIPE_INFO_TITLE@
  03c4f	e8 00 00 00 00	 call	 _GetString
  03c54	83 c4 04	 add	 esp, 4
  03c57	50		 push	 eax
  03c58	68 e8 03 00 00	 push	 1000			; 000003e8H
  03c5d	53		 push	 ebx
  03c5e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  03c64	ff d3		 call	 ebx
  03c66	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  03c6c	50		 push	 eax
  03c6d	ff d7		 call	 edi
  03c6f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  03c75	50		 push	 eax
  03c76	ff d6		 call	 esi

; 5108 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SYSENC_HIDDEN_OS_WIPE_INFO"));

  03c78	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KAEKPGLE@SYSENC_HIDDEN_OS_WIPE_INFO?$AA@
  03c7d	e8 00 00 00 00	 call	 _GetString
  03c82	83 c4 04	 add	 esp, 4
  03c85	50		 push	 eax
  03c86	68 eb 03 00 00	 push	 1003			; 000003ebH
  03c8b	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03c91	ff d7		 call	 edi
  03c93	50		 push	 eax
  03c94	ff d6		 call	 esi

; 5109 : 
; 5110 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  03c96	6a 01		 push	 1
  03c98	68 11 04 00 00	 push	 1041			; 00000411H
  03c9d	ff b5 7c eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  03ca3	ff d3		 call	 ebx
  03ca5	50		 push	 eax
  03ca6	ff d7		 call	 edi
  03ca8	50		 push	 eax
  03ca9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  03caf	33 c0		 xor	 eax, eax
  03cb1	e9 12 17 00 00	 jmp	 $LN1@PageDialog
$LN197@PageDialog:

; 5111 : 
; 5112 : 			break;
; 5113 : 
; 5114 : 		case DEVICE_WIPE_MODE_PAGE:
; 5115 : 
; 5116 : 			if (nWipeMode == GST_WIPE_NONE)

  03cb6	a1 00 00 00 00	 mov	 eax, DWORD PTR _nWipeMode
  03cbb	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  03cc0	85 c0		 test	 eax, eax
  03cc2	0f 44 c1	 cmove	 eax, ecx

; 5117 : 				nWipeMode = GST_WIPE_1_RAND;
; 5118 : 
; 5119 : 			if (bHiddenOS && IsHiddenOSRunning())

  03cc5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  03ccc	a3 00 00 00 00	 mov	 DWORD PTR _nWipeMode, eax
  03cd1	74 39		 je	 SHORT $LN199@PageDialog
  03cd3	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  03cd8	85 c0		 test	 eax, eax
  03cda	74 30		 je	 SHORT $LN199@PageDialog

; 5120 : 			{
; 5121 : 				// Decoy system partition wipe
; 5122 : 
; 5123 : 				WipeAbort(); // In case the GUI previously crashed and the driver is still wiping

  03cdc	e8 00 00 00 00	 call	 _WipeAbort

; 5124 : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("CANCEL"));

  03ce1	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  03ce6	e8 00 00 00 00	 call	 _GetString
  03ceb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  03cf1	83 c4 04	 add	 esp, 4
  03cf4	50		 push	 eax
  03cf5	6a 02		 push	 2
  03cf7	53		 push	 ebx
  03cf8	ff d7		 call	 edi
  03cfa	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  03d00	50		 push	 eax
  03d01	ff d6		 call	 esi
  03d03	50		 push	 eax
  03d04	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 5125 : 			}
; 5126 : 			else

  03d0a	eb 31		 jmp	 SHORT $LN200@PageDialog
$LN199@PageDialog:

; 5127 : 			{
; 5128 : 				// Regular device wipe (not decoy system partition wipe)
; 5129 : 
; 5130 : 				// Title bar
; 5131 : 				SetWindowText (MainDlg, GST_APP_NAME);

  03d0c	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  03d11	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  03d17	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 5132 : 
; 5133 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  03d1d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  03d23	6a 00		 push	 0
  03d25	68 11 04 00 00	 push	 1041			; 00000411H
  03d2a	53		 push	 ebx
  03d2b	ff d7		 call	 edi
  03d2d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  03d33	50		 push	 eax
  03d34	ff d6		 call	 esi
  03d36	50		 push	 eax
  03d37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
$LN200@PageDialog:

; 5134 : 			}
; 5135 : 
; 5136 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("WIPE_MODE_TITLE"));

  03d3d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GEMFOMCA@WIPE_MODE_TITLE?$AA@
  03d42	e8 00 00 00 00	 call	 _GetString
  03d47	83 c4 04	 add	 esp, 4
  03d4a	50		 push	 eax
  03d4b	68 e8 03 00 00	 push	 1000			; 000003e8H
  03d50	53		 push	 ebx
  03d51	ff d7		 call	 edi
  03d53	50		 push	 eax
  03d54	ff d6		 call	 esi
  03d56	50		 push	 eax
  03d57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 5137 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDT_WIPE_MODE_INFO), GetString ("WIPE_MODE_INFO"));

  03d5d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JJNKBKFB@WIPE_MODE_INFO?$AA@
  03d62	e8 00 00 00 00	 call	 _GetString
  03d67	83 c4 04	 add	 esp, 4
  03d6a	50		 push	 eax
  03d6b	68 3c 04 00 00	 push	 1084			; 0000043cH
  03d70	53		 push	 ebx
  03d71	ff d6		 call	 esi
  03d73	50		 push	 eax
  03d74	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 5138 : 
; 5139 : 			PopulateWipeModeCombo (GetDlgItem (hwndDlg, IDC_WIPE_MODE), FALSE, FALSE);

  03d7a	6a 00		 push	 0
  03d7c	6a 00		 push	 0
  03d7e	68 3d 04 00 00	 push	 1085			; 0000043dH
  03d83	53		 push	 ebx
  03d84	ff d6		 call	 esi
  03d86	50		 push	 eax
  03d87	e8 00 00 00 00	 call	 _PopulateWipeModeCombo
  03d8c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5140 : 
; 5141 : 			SelectAlgo (GetDlgItem (hwndDlg, IDC_WIPE_MODE), (int *) &nWipeMode);

  03d8f	68 00 00 00 00	 push	 OFFSET _nWipeMode
  03d94	68 3d 04 00 00	 push	 1085			; 0000043dH
  03d99	53		 push	 ebx
  03d9a	ff d6		 call	 esi
  03d9c	50		 push	 eax
  03d9d	e8 00 00 00 00	 call	 _SelectAlgo

; 5142 : 
; 5143 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  03da2	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  03da7	e8 00 00 00 00	 call	 _GetString
  03dac	83 c4 0c	 add	 esp, 12			; 0000000cH
  03daf	50		 push	 eax
  03db0	68 10 04 00 00	 push	 1040			; 00000410H
  03db5	53		 push	 ebx
  03db6	ff d7		 call	 edi
  03db8	50		 push	 eax
  03db9	ff d6		 call	 esi
  03dbb	50		 push	 eax
  03dbc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 5144 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  03dc2	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  03dc7	e8 00 00 00 00	 call	 _GetString
  03dcc	83 c4 04	 add	 esp, 4
  03dcf	50		 push	 eax
  03dd0	68 11 04 00 00	 push	 1041			; 00000411H
  03dd5	53		 push	 ebx
  03dd6	ff d7		 call	 edi
  03dd8	50		 push	 eax
  03dd9	ff d6		 call	 esi
  03ddb	50		 push	 eax
  03ddc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 5145 : 
; 5146 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  03de2	6a 01		 push	 1
  03de4	68 10 04 00 00	 push	 1040			; 00000410H
  03de9	53		 push	 ebx
  03dea	ff d7		 call	 edi
  03dec	50		 push	 eax
  03ded	ff d6		 call	 esi
  03def	50		 push	 eax
  03df0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 5147 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  03df6	6a 01		 push	 1
  03df8	6a 02		 push	 2
  03dfa	53		 push	 ebx
  03dfb	ff d7		 call	 edi
  03dfd	50		 push	 eax
  03dfe	ff d6		 call	 esi
  03e00	50		 push	 eax
  03e01	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  03e07	33 c0		 xor	 eax, eax
  03e09	e9 ba 15 00 00	 jmp	 $LN1@PageDialog
$LN201@PageDialog:

; 5148 : 
; 5149 : 			break;
; 5150 : 
; 5151 : 		case DEVICE_WIPE_PAGE:
; 5152 : 
; 5153 : 			if (bHiddenOS && IsHiddenOSRunning())

  03e0e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  03e15	74 10		 je	 SHORT $LN202@PageDialog
  03e17	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  03e1c	85 c0		 test	 eax, eax
  03e1e	74 07		 je	 SHORT $LN202@PageDialog

; 5154 : 			{
; 5155 : 				// Decoy system partition wipe
; 5156 : 
; 5157 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("DEVICE_WIPE_PAGE_INFO_HIDDEN_OS"));

  03e20	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NHNKCAEG@DEVICE_WIPE_PAGE_INFO_HIDDEN_OS?$AA@

; 5158 : 			}
; 5159 : 			else

  03e25	eb 05		 jmp	 SHORT $LN761@PageDialog
$LN202@PageDialog:

; 5160 : 			{
; 5161 : 				// Regular device wipe (not decoy system partition wipe)
; 5162 : 
; 5163 : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("DEVICE_WIPE_PAGE_INFO"));

  03e27	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@OABGGIFL@DEVICE_WIPE_PAGE_INFO?$AA@
$LN761@PageDialog:
  03e2c	e8 00 00 00 00	 call	 _GetString
  03e31	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  03e37	83 c4 04	 add	 esp, 4
  03e3a	50		 push	 eax
  03e3b	68 eb 03 00 00	 push	 1003			; 000003ebH
  03e40	53		 push	 ebx
  03e41	ff d7		 call	 edi
  03e43	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  03e49	50		 push	 eax
  03e4a	ff d6		 call	 esi

; 5164 : 			}
; 5165 : 
; 5166 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("DEVICE_WIPE_PAGE_TITLE"));

  03e4c	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@IEGJMJEM@DEVICE_WIPE_PAGE_TITLE?$AA@
  03e51	e8 00 00 00 00	 call	 _GetString
  03e56	83 c4 04	 add	 esp, 4
  03e59	50		 push	 eax
  03e5a	68 e8 03 00 00	 push	 1000			; 000003e8H
  03e5f	53		 push	 ebx
  03e60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03e66	50		 push	 eax
  03e67	ff d7		 call	 edi
  03e69	50		 push	 eax
  03e6a	ff d6		 call	 esi

; 5167 : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("WIPE"));

  03e6c	68 00 00 00 00	 push	 OFFSET ??_C@_04LEEAJJHO@WIPE?$AA@
  03e71	e8 00 00 00 00	 call	 _GetString
  03e76	83 c4 04	 add	 esp, 4
  03e79	50		 push	 eax
  03e7a	68 10 04 00 00	 push	 1040			; 00000410H
  03e7f	53		 push	 ebx
  03e80	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03e86	50		 push	 eax
  03e87	ff d7		 call	 edi
  03e89	50		 push	 eax
  03e8a	ff d6		 call	 esi

; 5168 : 			SetWindowTextW (GetDlgItem (hCurPage, IDC_WIPE_MODE), (wstring (L"  ") + GetWipeModeName (nWipeMode)).c_str());

  03e8c	68 00 00 00 00	 push	 OFFSET ??_C@_15OJKDPEFE@?$AA?5?$AA?5?$AA?$AA@
  03e91	8d 8d 80 ed fe
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  03e97	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  03e9c	8b f0		 mov	 esi, eax
  03e9e	ff 35 00 00 00
	00		 push	 DWORD PTR _nWipeMode
  03ea4	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 13 ; 0000000dH
  03eab	e8 00 00 00 00	 call	 _GetWipeModeName
  03eb0	50		 push	 eax
  03eb1	8d 85 98 ed fe
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  03eb7	56		 push	 esi
  03eb8	50		 push	 eax
  03eb9	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  03ebe	83 c4 10	 add	 esp, 16			; 00000010H
  03ec1	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  03ec5	72 02		 jb	 SHORT $LN623@PageDialog
  03ec7	8b 00		 mov	 eax, DWORD PTR [eax]
$LN623@PageDialog:
  03ec9	50		 push	 eax
  03eca	68 3d 04 00 00	 push	 1085			; 0000043dH
  03ecf	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  03ed5	ff d7		 call	 edi
  03ed7	50		 push	 eax
  03ed8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
  03ede	8d 8d 98 ed fe
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  03ee4	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  03ee9	8d 8d 80 ed fe
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  03eef	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 5169 : 
; 5170 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_ABORT_BUTTON), FALSE);

  03ef4	6a 00		 push	 0
  03ef6	68 f8 03 00 00	 push	 1016			; 000003f8H
  03efb	53		 push	 ebx
  03efc	ff d7		 call	 edi
  03efe	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  03f04	50		 push	 eax
  03f05	ff d6		 call	 esi

; 5171 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  03f07	6a 01		 push	 1
  03f09	68 11 04 00 00	 push	 1041			; 00000411H
  03f0e	53		 push	 ebx
  03f0f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03f15	50		 push	 eax
  03f16	ff d7		 call	 edi
  03f18	50		 push	 eax
  03f19	ff d6		 call	 esi
  03f1b	33 c0		 xor	 eax, eax
  03f1d	e9 a6 14 00 00	 jmp	 $LN1@PageDialog
$LN204@PageDialog:

; 5172 : 
; 5173 : 			break;
; 5174 : 		}
; 5175 : 		return 0;
; 5176 : 
; 5177 : 	case WM_HELP:
; 5178 : 		OpenPageHelp (GetParent (hwndDlg), nCurPageNo);

  03f22	ff 35 00 00 00
	00		 push	 DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  03f28	53		 push	 ebx
  03f29	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03f2f	50		 push	 eax
  03f30	e8 00 00 00 00	 call	 _OpenPageHelp
  03f35	83 c4 08	 add	 esp, 8
  03f38	e9 86 14 00 00	 jmp	 $LN752@PageDialog
$LN206@PageDialog:

; 5184 : 
; 5185 : 	case WM_COMMAND:
; 5186 : 
; 5187 : 		if (nCurPageNo == INTRO_PAGE)

  03f3d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  03f43	85 c9		 test	 ecx, ecx
  03f45	0f 85 f6 00 00
	00		 jne	 $LN25@PageDialog

; 5188 : 		{
; 5189 : 			switch (lw)

  03f4b	0f b7 c6	 movzx	 eax, si
  03f4e	05 db fb ff ff	 add	 eax, -1061		; fffffbdbH
  03f53	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  03f56	0f 87 f0 01 00
	00		 ja	 $LN31@PageDialog
  03f5c	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN719@PageDialog[eax]
  03f63	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN790@PageDialog[eax*4]
$LN208@PageDialog:

; 5190 : 			{
; 5191 : 			case IDC_FILE_CONTAINER:
; 5192 : 				UpdateWizardModeControls (hwndDlg, WIZARD_MODE_FILE_CONTAINER);

  03f6a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  03f70	6a 00		 push	 0
  03f72	6a 01		 push	 1
  03f74	68 f1 00 00 00	 push	 241			; 000000f1H
  03f79	68 25 04 00 00	 push	 1061			; 00000425H
  03f7e	53		 push	 ebx
  03f7f	ff d7		 call	 edi
  03f81	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  03f87	50		 push	 eax
  03f88	ff d6		 call	 esi
  03f8a	6a 00		 push	 0
  03f8c	6a 00		 push	 0
  03f8e	68 f1 00 00 00	 push	 241			; 000000f1H
  03f93	68 26 04 00 00	 push	 1062			; 00000426H
  03f98	53		 push	 ebx
  03f99	ff d7		 call	 edi
  03f9b	50		 push	 eax
  03f9c	ff d6		 call	 esi
  03f9e	6a 00		 push	 0
  03fa0	6a 00		 push	 0
$LN775@PageDialog:
  03fa2	68 f1 00 00 00	 push	 241			; 000000f1H
  03fa7	68 27 04 00 00	 push	 1063			; 00000427H
  03fac	53		 push	 ebx
  03fad	ff d7		 call	 edi
  03faf	50		 push	 eax
  03fb0	ff d6		 call	 esi

; 5193 : 				return 1;

  03fb2	e9 0c 14 00 00	 jmp	 $LN752@PageDialog
$LN209@PageDialog:

; 5194 : 
; 5195 : 			case IDC_NONSYS_DEVICE:
; 5196 : 				UpdateWizardModeControls (hwndDlg, WIZARD_MODE_NONSYS_DEVICE);

  03fb7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  03fbd	6a 00		 push	 0
  03fbf	6a 00		 push	 0
  03fc1	68 f1 00 00 00	 push	 241			; 000000f1H
  03fc6	68 25 04 00 00	 push	 1061			; 00000425H
  03fcb	53		 push	 ebx
  03fcc	ff d7		 call	 edi
  03fce	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  03fd4	50		 push	 eax
  03fd5	ff d6		 call	 esi
  03fd7	6a 00		 push	 0
  03fd9	6a 01		 push	 1
  03fdb	68 f1 00 00 00	 push	 241			; 000000f1H
  03fe0	68 26 04 00 00	 push	 1062			; 00000426H
  03fe5	53		 push	 ebx
  03fe6	ff d7		 call	 edi
  03fe8	50		 push	 eax
  03fe9	ff d6		 call	 esi
  03feb	6a 00		 push	 0
  03fed	6a 00		 push	 0
  03fef	68 f1 00 00 00	 push	 241			; 000000f1H
  03ff4	68 27 04 00 00	 push	 1063			; 00000427H
  03ff9	53		 push	 ebx
  03ffa	ff d7		 call	 edi
  03ffc	50		 push	 eax
  03ffd	ff d6		 call	 esi

; 5197 : 				return 1;

  03fff	e9 bf 13 00 00	 jmp	 $LN752@PageDialog
$LN210@PageDialog:

; 5198 : 
; 5199 : 			case IDC_SYS_DEVICE:
; 5200 : 				UpdateWizardModeControls (hwndDlg, WIZARD_MODE_SYS_DEVICE);

  04004	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0400a	6a 00		 push	 0
  0400c	6a 00		 push	 0
  0400e	68 f1 00 00 00	 push	 241			; 000000f1H
  04013	68 25 04 00 00	 push	 1061			; 00000425H
  04018	53		 push	 ebx
  04019	ff d7		 call	 edi
  0401b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  04021	50		 push	 eax
  04022	ff d6		 call	 esi
  04024	6a 00		 push	 0
  04026	6a 00		 push	 0
  04028	68 f1 00 00 00	 push	 241			; 000000f1H
  0402d	68 26 04 00 00	 push	 1062			; 00000426H
  04032	53		 push	 ebx
  04033	ff d7		 call	 edi
  04035	50		 push	 eax
  04036	ff d6		 call	 esi
  04038	6a 00		 push	 0
  0403a	6a 01		 push	 1

; 5201 : 				return 1;

  0403c	e9 61 ff ff ff	 jmp	 $LN775@PageDialog
$LN25@PageDialog:

; 5202 : 
; 5203 : 			case IDC_MORE_INFO_ON_CONTAINERS:
; 5204 : 				//Applink ("introcontainer", TRUE, "");
; 5205 : 				Extlink("http://www.gostcrypt.org/redirect.php?a=2");
; 5206 : 				return 1;
; 5207 : 
; 5208 : 			case IDC_MORE_INFO_ON_SYS_ENCRYPTION:
; 5209 : 				//Applink ("introsysenc", TRUE, "");
; 5210 : 				Extlink("http://www.gostcrypt.org/redirect.php?a=2");
; 5211 : 				return 1;
; 5212 : 			}
; 5213 : 		}
; 5214 : 
; 5215 : 		if (nCurPageNo == SYSENC_TYPE_PAGE)

  04041	83 f9 01	 cmp	 ecx, 1
  04044	75 6c		 jne	 SHORT $LN27@PageDialog

; 5216 : 		{
; 5217 : 			switch (lw)

  04046	0f b7 c6	 movzx	 eax, si
  04049	2d 48 04 00 00	 sub	 eax, 1096		; 00000448H
  0404e	74 3f		 je	 SHORT $LN215@PageDialog
  04050	2b c1		 sub	 eax, ecx
  04052	74 18		 je	 SHORT $LN214@PageDialog
  04054	83 e8 02	 sub	 eax, 2
  04057	0f 85 a4 00 00
	00		 jne	 $LN29@PageDialog
$LN211@PageDialog:

; 5230 : 
; 5231 : 			case IDC_HIDDEN_SYSENC_INFO_LINK:
; 5232 : 				//Applink ("hiddensysenc", TRUE, "");
; 5233 : 				Extlink("http://www.gostcrypt.org/redirect.php?a=2");

  0405d	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@
  04062	e8 00 00 00 00	 call	 _Extlink

; 5234 : 				return 1;

  04067	e9 54 13 00 00	 jmp	 $LN767@PageDialog
$LN214@PageDialog:

; 5218 : 			{
; 5219 : 			case IDC_SYSENC_HIDDEN:
; 5220 : 				bHiddenOS = TRUE;

  0406c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bHiddenOS@@3HC, 1 ; bHiddenOS

; 5221 : 				bHiddenVol = TRUE;

  04076	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bHiddenVol@@3HC, 1 ; bHiddenVol

; 5222 : 				bHiddenVolHost = TRUE;

  04080	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bHiddenVolHost, 1

; 5223 : 				return 1;

  0408a	e9 34 13 00 00	 jmp	 $LN752@PageDialog
$LN215@PageDialog:

; 5224 : 
; 5225 : 			case IDC_SYSENC_NORMAL:
; 5226 : 				bHiddenOS = FALSE;

  0408f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
$LN776@PageDialog:

; 5227 : 				bHiddenVol = FALSE;

  04099	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol

; 5228 : 				bHiddenVolHost = FALSE;

  040a3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHiddenVolHost, 0

; 5229 : 				return 1;

  040ad	e9 11 13 00 00	 jmp	 $LN752@PageDialog
$LN27@PageDialog:

; 5235 : 			}
; 5236 : 		}
; 5237 : 
; 5238 : 		if (nCurPageNo == SYSENC_HIDDEN_OS_REQ_CHECK_PAGE && lw == IDC_HIDDEN_SYSENC_INFO_LINK)

  040b2	83 f9 02	 cmp	 ecx, 2
  040b5	75 1d		 jne	 SHORT $LN217@PageDialog
  040b7	b8 4b 04 00 00	 mov	 eax, 1099		; 0000044bH
  040bc	66 3b f0	 cmp	 si, ax
  040bf	0f 85 87 00 00
	00		 jne	 $LN31@PageDialog

; 5239 : 		{
; 5240 : 			//Applink ("hiddensysenc", TRUE, "");
; 5241 : 			Extlink("http://www.gostcrypt.org/redirect.php?a=2");

  040c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@
  040ca	e8 00 00 00 00	 call	 _Extlink

; 5242 : 			return 1;

  040cf	e9 ec 12 00 00	 jmp	 $LN767@PageDialog
$LN217@PageDialog:

; 5243 : 		}
; 5244 : 
; 5245 : 		if (nCurPageNo == SYSENC_SPAN_PAGE)

  040d4	83 f9 03	 cmp	 ecx, 3
  040d7	75 28		 jne	 SHORT $LN29@PageDialog

; 5246 : 		{
; 5247 : 			switch (lw)

  040d9	0f b7 c6	 movzx	 eax, si
  040dc	2d 2b 04 00 00	 sub	 eax, 1067		; 0000042bH
  040e1	74 0f		 je	 SHORT $LN219@PageDialog
  040e3	83 e8 01	 sub	 eax, 1
  040e6	75 64		 jne	 SHORT $LN31@PageDialog

; 5252 : 			case IDC_SYS_PARTITION:
; 5253 : 				bWholeSysDrive = FALSE;

  040e8	a3 00 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, eax ; bWholeSysDrive

; 5254 : 				return 1;

  040ed	e9 d1 12 00 00	 jmp	 $LN752@PageDialog
$LN219@PageDialog:

; 5248 : 			{
; 5249 : 			case IDC_WHOLE_SYS_DRIVE:
; 5250 : 				bWholeSysDrive = TRUE;

  040f2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bWholeSysDrive@@3HA, 1 ; bWholeSysDrive

; 5251 : 				return 1;

  040fc	e9 c2 12 00 00	 jmp	 $LN752@PageDialog
$LN29@PageDialog:

; 5255 : 			}
; 5256 : 
; 5257 : 		}
; 5258 : 
; 5259 : 		if (nCurPageNo == SYSENC_MULTI_BOOT_MODE_PAGE)

  04101	83 f9 06	 cmp	 ecx, 6
  04104	75 46		 jne	 SHORT $LN31@PageDialog

; 5260 : 		{
; 5261 : 			switch (lw)

  04106	0f b7 c6	 movzx	 eax, si
  04109	2d 34 04 00 00	 sub	 eax, 1076		; 00000434H
  0410e	74 30		 je	 SHORT $LN222@PageDialog
  04110	83 e8 01	 sub	 eax, 1
  04113	75 37		 jne	 SHORT $LN31@PageDialog

; 5267 : 			case IDC_MULTI_BOOT:
; 5268 : 				nMultiBoot = 2;

  04115	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?nMultiBoot@@3HA, 2 ; nMultiBoot
$LN777@PageDialog:

; 5269 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  0411f	6a 01		 push	 1
  04121	68 10 04 00 00	 push	 1040			; 00000410H
  04126	53		 push	 ebx
  04127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0412d	50		 push	 eax
  0412e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  04134	50		 push	 eax
  04135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 5270 : 				return 1;

  0413b	e9 83 12 00 00	 jmp	 $LN752@PageDialog
$LN222@PageDialog:

; 5262 : 			{
; 5263 : 			case IDC_SINGLE_BOOT:
; 5264 : 				nMultiBoot = 1;

  04140	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?nMultiBoot@@3HA, 1 ; nMultiBoot

; 5265 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);
; 5266 : 				return 1;

  0414a	eb d3		 jmp	 SHORT $LN777@PageDialog
$LN31@PageDialog:

; 5271 : 			}
; 5272 : 		}
; 5273 : 
; 5274 : 		// Dual choice pages
; 5275 : 		switch (nCurPageNo)

  0414c	83 f9 04	 cmp	 ecx, 4
  0414f	74 12		 je	 SHORT $LN224@PageDialog
  04151	8d 41 f9	 lea	 eax, DWORD PTR [ecx-7]
  04154	83 f8 03	 cmp	 eax, 3
  04157	76 0a		 jbe	 SHORT $LN224@PageDialog

; 5276 : 		{
; 5277 : 		case SYSENC_MULTI_BOOT_SYS_EQ_BOOT_PAGE:
; 5278 : 		case SYSENC_MULTI_BOOT_NBR_SYS_DRIVES_PAGE:
; 5279 : 		case SYSENC_MULTI_BOOT_ADJACENT_SYS_PAGE:
; 5280 : 		case SYSENC_MULTI_BOOT_NONWIN_BOOT_LOADER_PAGE:
; 5281 : 		case SYSENC_PRE_DRIVE_ANALYSIS_PAGE:
; 5282 : 
; 5283 : 			if (lw == IDC_CHOICE1 || lw == IDC_CHOICE2)

  04159	b8 dd 13 00 00	 mov	 eax, 5085		; 000013ddH
  0415e	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  04161	eb 14		 jmp	 SHORT $LN225@PageDialog
$LN224@PageDialog:
  04163	b8 dd 13 00 00	 mov	 eax, 5085		; 000013ddH
  04168	66 3b f0	 cmp	 si, ax
  0416b	74 b2		 je	 SHORT $LN777@PageDialog
  0416d	ba df 13 00 00	 mov	 edx, 5087		; 000013dfH
  04172	66 3b f2	 cmp	 si, dx
  04175	74 a8		 je	 SHORT $LN777@PageDialog
$LN225@PageDialog:

; 5284 : 			{
; 5285 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);
; 5286 : 				return 1;
; 5287 : 			}
; 5288 : 			break;
; 5289 : 		}
; 5290 : 
; 5291 : 		if (nCurPageNo == FILESYS_PAGE && (lw == IDC_CHOICE1 || lw == IDC_CHOICE2))

  04177	83 f9 16	 cmp	 ecx, 22			; 00000016H
  0417a	0f 85 10 01 00
	00		 jne	 $LN227@PageDialog
  04180	66 3b f0	 cmp	 si, ax
  04183	74 09		 je	 SHORT $LN228@PageDialog
  04185	66 3b f2	 cmp	 si, dx
  04188	0f 85 02 01 00
	00		 jne	 $LN227@PageDialog
$LN228@PageDialog:

; 5292 : 		{
; 5293 : 			if (bWarnOuterVolSuitableFileSys && lw == IDC_CHOICE1 && bHiddenVolHost)

  0418e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bWarnOuterVolSuitableFileSys@@3HA, 0 ; bWarnOuterVolSuitableFileSys
  04195	74 88		 je	 SHORT $LN777@PageDialog
  04197	66 3b f0	 cmp	 si, ax
  0419a	75 83		 jne	 SHORT $LN777@PageDialog
  0419c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  041a3	0f 84 76 ff ff
	ff		 je	 $LN777@PageDialog

; 5294 : 			{
; 5295 : 				wchar_t szTmp [4096];
; 5296 : 
; 5297 : 				bWarnOuterVolSuitableFileSys = FALSE;	// Do not show this warning anymore (this also prevents potential endless repetition due to some race conditions)
; 5298 : 
; 5299 : 				wcscpy (szTmp, GetString ("FILESYS_PAGE_HELP_EXPLANATION_HIDVOL"));

  041a9	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BDOPEICN@FILESYS_PAGE_HELP_EXPLANATION_HI@
  041ae	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bWarnOuterVolSuitableFileSys@@3HA, 0 ; bWarnOuterVolSuitableFileSys
  041b8	e8 00 00 00 00	 call	 _GetString
  041bd	8d 95 90 8c ff
	ff		 lea	 edx, DWORD PTR _szTmp$24[ebp]
  041c3	83 c4 04	 add	 esp, 4
  041c6	2b d0		 sub	 edx, eax
  041c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL361@PageDialog:
  041d0	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  041d3	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  041d6	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  041db	66 85 c9	 test	 cx, cx
  041de	75 f0		 jne	 SHORT $LL361@PageDialog

; 5300 : 				wcscat (szTmp, L"\n\n");

  041e0	8d 8d 90 8c ff
	ff		 lea	 ecx, DWORD PTR _szTmp$24[ebp]
  041e6	83 c1 fe	 add	 ecx, -2			; fffffffeH
  041e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL720@PageDialog:
  041f0	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  041f4	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  041f7	66 85 c0	 test	 ax, ax
  041fa	75 f4		 jne	 SHORT $LL720@PageDialog
  041fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  04201	89 01		 mov	 DWORD PTR [ecx], eax
  04203	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@+4

; 5301 : 				wcscat (szTmp, GetString ("FILESYS_PAGE_HELP_EXPLANATION_HIDVOL_CONFIRM"));

  04209	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@EDGNFMHB@FILESYS_PAGE_HELP_EXPLANATION_HI@
  0420e	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  04212	e8 00 00 00 00	 call	 _GetString
  04217	8b d0		 mov	 edx, eax
  04219	83 c4 04	 add	 esp, 4
  0421c	8b f2		 mov	 esi, edx
  0421e	66 90		 npad	 2
$LL721@PageDialog:
  04220	66 8b 02	 mov	 ax, WORD PTR [edx]
  04223	83 c2 02	 add	 edx, 2
  04226	66 85 c0	 test	 ax, ax
  04229	75 f5		 jne	 SHORT $LL721@PageDialog
  0422b	8d bd 90 8c ff
	ff		 lea	 edi, DWORD PTR _szTmp$24[ebp]
  04231	2b d6		 sub	 edx, esi
  04233	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL722@PageDialog:
  04236	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  0423a	83 c7 02	 add	 edi, 2
  0423d	66 85 c0	 test	 ax, ax
  04240	75 f4		 jne	 SHORT $LL722@PageDialog
  04242	8b ca		 mov	 ecx, edx

; 5302 : 
; 5303 : 				if (MessageBoxW (MainDlg, szTmp, lpszTitle, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2) == IDNO)

  04244	8d 85 90 8c ff
	ff		 lea	 eax, DWORD PTR _szTmp$24[ebp]
  0424a	c1 e9 02	 shr	 ecx, 2
  0424d	f3 a5		 rep movsd
  0424f	68 34 01 00 00	 push	 308			; 00000134H
  04254	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  0425a	8b ca		 mov	 ecx, edx
  0425c	50		 push	 eax
  0425d	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  04263	83 e1 03	 and	 ecx, 3
  04266	f3 a4		 rep movsb
  04268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  0426e	83 f8 07	 cmp	 eax, 7
  04271	0f 85 a8 fe ff
	ff		 jne	 $LN777@PageDialog

; 5304 : 				{
; 5305 : 					nNeedToStoreFilesOver4GB = 0;
; 5306 : 					Init2RadButtonPageYesNo (nNeedToStoreFilesOver4GB);

  04277	6a 00		 push	 0
  04279	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?nNeedToStoreFilesOver4GB@@3HA, 0 ; nNeedToStoreFilesOver4GB
  04283	e8 00 00 00 00	 call	 ?Init2RadButtonPageYesNo@@YAXH@Z ; Init2RadButtonPageYesNo
  04288	83 c4 04	 add	 esp, 4

; 5307 : 				}
; 5308 : 			}
; 5309 : 
; 5310 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);
; 5311 : 			return 1;

  0428b	e9 8f fe ff ff	 jmp	 $LN777@PageDialog
$LN227@PageDialog:

; 5312 : 		}
; 5313 : 
; 5314 : 		if (lw == IDC_HIDDEN_VOL && nCurPageNo == VOLUME_TYPE_PAGE)

  04290	b8 08 04 00 00	 mov	 eax, 1032		; 00000408H
  04295	66 3b f0	 cmp	 si, ax
  04298	75 28		 jne	 SHORT $LN231@PageDialog
  0429a	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  0429d	75 36		 jne	 SHORT $LN232@PageDialog

; 5315 : 		{
; 5316 : 			bHiddenVol = TRUE;

  0429f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bHiddenVol@@3HC, 1 ; bHiddenVol

; 5317 : 			bHiddenVolHost = TRUE;

  042a9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bHiddenVolHost, 1

; 5318 : 			bInPlaceEncNonSys = FALSE;

  042b3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0

; 5319 : 			return 1;

  042bd	e9 01 11 00 00	 jmp	 $LN752@PageDialog
$LN231@PageDialog:

; 5320 : 		}
; 5321 : 
; 5322 : 		if (lw == IDC_STD_VOL && nCurPageNo == VOLUME_TYPE_PAGE)

  042c2	b8 07 04 00 00	 mov	 eax, 1031		; 00000407H
  042c7	66 3b f0	 cmp	 si, ax
  042ca	75 09		 jne	 SHORT $LN232@PageDialog
  042cc	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  042cf	0f 84 c4 fd ff
	ff		 je	 $LN776@PageDialog
$LN232@PageDialog:

; 5323 : 		{
; 5324 : 			bHiddenVol = FALSE;
; 5325 : 			bHiddenVolHost = FALSE;
; 5326 : 			return 1;
; 5327 : 		}
; 5328 : 
; 5329 : 		if (nCurPageNo == SYSENC_ENCRYPTION_PAGE)

  042d5	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  042d8	0f 85 cc 00 00
	00		 jne	 $LN239@PageDialog

; 5330 : 		{
; 5331 : 			BootEncryptionStatus locBootEncStatus;
; 5332 : 
; 5333 : 			switch (lw)

  042de	0f b7 c6	 movzx	 eax, si
  042e1	2d 3d 04 00 00	 sub	 eax, 1085		; 0000043dH
  042e6	74 7a		 je	 SHORT $LN238@PageDialog
  042e8	83 e8 04	 sub	 eax, 4
  042eb	74 18		 je	 SHORT $LN234@PageDialog
  042ed	83 e8 02	 sub	 eax, 2
  042f0	0f 85 b4 00 00
	00		 jne	 $LN239@PageDialog

; 5360 : 				}
; 5361 : 				break;
; 5362 : 
; 5363 : 			case IDC_MORE_INFO_SYS_ENCRYPTION:
; 5364 : 				//Applink ("sysencprogressinfo", TRUE, "");
; 5365 : 				Extlink("http://www.gostcrypt.org/redirect.php?a=2");

  042f6	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@
  042fb	e8 00 00 00 00	 call	 _Extlink

; 5366 : 				return 1;

  04300	e9 bb 10 00 00	 jmp	 $LN767@PageDialog
$LN234@PageDialog:

; 5334 : 			{
; 5335 : 			case IDC_PAUSE:
; 5336 : 				try
; 5337 : 				{
; 5338 : 					locBootEncStatus = BootEncObj->GetStatus();

  04305	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0430b	8d 85 c0 ec fe
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  04311	50		 push	 eax
  04312	c7 45 fc 0e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 14 ; 0000000eH
  04319	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  0431e	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  04323	8d bd 20 ed fe
	ff		 lea	 edi, DWORD PTR _locBootEncStatus$15[ebp]
  04329	8b f0		 mov	 esi, eax
  0432b	f3 a5		 rep movsd
  0432d	66 a5		 movsw

; 5339 : 
; 5340 : 					if (locBootEncStatus.SetupInProgress)

  0432f	83 bd 5e ed fe
	ff 00		 cmp	 DWORD PTR _locBootEncStatus$15[ebp+62], 0
  04336	74 0a		 je	 SHORT $LN236@PageDialog

; 5341 : 						SysEncPause ();

  04338	e8 00 00 00 00	 call	 ?SysEncPause@@YAXXZ	; SysEncPause

; 5342 : 					else

  0433d	e9 81 10 00 00	 jmp	 $LN752@PageDialog
$LN236@PageDialog:

; 5343 : 						SysEncResume ();

  04342	e8 00 00 00 00	 call	 ?SysEncResume@@YAXXZ	; SysEncResume
  04347	e9 77 10 00 00	 jmp	 $LN752@PageDialog
__catch$_PageDialogProc@16$4:

; 5344 : 				}
; 5345 : 				catch (Exception &e)
; 5346 : 				{
; 5347 : 					e.Show (hwndDlg);

  0434c	8b 8d 30 eb fe
	ff		 mov	 ecx, DWORD PTR _e$4[ebp]
  04352	ff b5 74 eb fe
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  04358	8b 01		 mov	 eax, DWORD PTR [ecx]
  0435a	ff 10		 call	 DWORD PTR [eax]

; 5348 : 				}

  0435c	b8 00 00 00 00	 mov	 eax, $LN752@PageDialog
  04361	c3		 ret	 0
$LN238@PageDialog:

; 5349 : 				return 1;
; 5350 : 
; 5351 : 			case IDC_WIPE_MODE:
; 5352 : 				if (hw == CBN_SELCHANGE)

  04362	66 83 ff 01	 cmp	 di, 1
  04366	75 42		 jne	 SHORT $LN239@PageDialog

; 5353 : 				{
; 5354 : 					nWipeMode = (WipeAlgorithmId) SendMessage (GetDlgItem (hCurPage, IDC_WIPE_MODE),

  04368	6a 00		 push	 0
  0436a	6a 00		 push	 0
  0436c	6a 00		 push	 0
  0436e	68 47 01 00 00	 push	 327			; 00000147H
  04373	68 3d 04 00 00	 push	 1085			; 0000043dH
  04378	53		 push	 ebx
$LN779@PageDialog:
  04379	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0437f	ff d7		 call	 edi
  04381	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  04387	50		 push	 eax
  04388	ff d6		 call	 esi
  0438a	50		 push	 eax
  0438b	68 50 01 00 00	 push	 336			; 00000150H
  04390	68 3d 04 00 00	 push	 1085			; 0000043dH
  04395	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0439b	ff d7		 call	 edi
  0439d	50		 push	 eax
  0439e	ff d6		 call	 esi
  043a0	a3 00 00 00 00	 mov	 DWORD PTR _nWipeMode, eax

; 5355 : 						CB_GETITEMDATA, 
; 5356 : 						SendMessage (GetDlgItem (hCurPage, IDC_WIPE_MODE), CB_GETCURSEL, 0, 0),
; 5357 : 						0);
; 5358 : 
; 5359 : 					return 1;

  043a5	e9 19 10 00 00	 jmp	 $LN752@PageDialog
$LN239@PageDialog:

; 5367 : 			}
; 5368 : 		}
; 5369 : 
; 5370 : 		if (bInPlaceEncNonSys)

  043aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0

; 5371 : 		{
; 5372 : 			switch (nCurPageNo)

  043b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  043b6	0f 84 c4 01 00
	00		 je	 $LN243@PageDialog
  043bc	83 f8 21	 cmp	 eax, 33			; 00000021H
  043bf	0f 84 80 00 00
	00		 je	 $LN242@PageDialog
  043c5	83 f8 24	 cmp	 eax, 36			; 00000024H
  043c8	0f 85 b2 01 00
	00		 jne	 $LN243@PageDialog

; 5407 : 
; 5408 : 					return 1;
; 5409 : 				}
; 5410 : 				break;
; 5411 : 
; 5412 : 			case  NONSYS_INPLACE_ENC_ENCRYPTION_PAGE:
; 5413 : 				{
; 5414 : 					switch (lw)

  043ce	0f b7 ce	 movzx	 ecx, si
  043d1	81 e9 3d 04 00
	00		 sub	 ecx, 1085		; 0000043dH
  043d7	74 47		 je	 SHORT $LN252@PageDialog
  043d9	83 e9 04	 sub	 ecx, 4
  043dc	0f 85 9e 01 00
	00		 jne	 $LN243@PageDialog

; 5415 : 					{
; 5416 : 					case IDC_PAUSE:
; 5417 : 
; 5418 : 						// Pause/resume non-system in-place encryption
; 5419 : 
; 5420 : 						if (bVolTransformThreadRunning || bVolTransformThreadToRun)

  043e2	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, ecx ; bVolTransformThreadRunning
  043e8	75 12		 jne	 SHORT $LN251@PageDialog
  043ea	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, ecx ; bVolTransformThreadToRun
  043f0	75 0a		 jne	 SHORT $LN251@PageDialog

; 5424 : 						}
; 5425 : 						else
; 5426 : 							NonSysInplaceEncResume ();

  043f2	e8 00 00 00 00	 call	 _NonSysInplaceEncResume
  043f7	e9 c7 0f 00 00	 jmp	 $LN752@PageDialog
$LN251@PageDialog:

; 5421 : 						{
; 5422 : 							EnableWindow (GetDlgItem (hCurPage, IDC_PAUSE), FALSE);

  043fc	6a 00		 push	 0
  043fe	68 41 04 00 00	 push	 1089			; 00000441H
  04403	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  04409	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0440f	50		 push	 eax
  04410	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 5423 : 							NonSysInplaceEncPause ();

  04416	e8 00 00 00 00	 call	 _NonSysInplaceEncPause

; 5427 : 
; 5428 : 						return 1;

  0441b	e9 a3 0f 00 00	 jmp	 $LN752@PageDialog
$LN252@PageDialog:

; 5429 : 
; 5430 : 					case IDC_WIPE_MODE:
; 5431 : 						if (hw == CBN_SELCHANGE)

  04420	66 83 ff 01	 cmp	 di, 1
  04424	0f 85 56 01 00
	00		 jne	 $LN243@PageDialog

; 5432 : 						{
; 5433 : 							nWipeMode = (WipeAlgorithmId) SendMessage (GetDlgItem (hCurPage, IDC_WIPE_MODE),

  0442a	6a 00		 push	 0
  0442c	6a 00		 push	 0
  0442e	6a 00		 push	 0
  04430	68 47 01 00 00	 push	 327			; 00000147H
  04435	68 3d 04 00 00	 push	 1085			; 0000043dH
  0443a	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage

; 5434 : 								CB_GETITEMDATA, 
; 5435 : 								SendMessage (GetDlgItem (hCurPage, IDC_WIPE_MODE), CB_GETCURSEL, 0, 0),
; 5436 : 								0);
; 5437 : 
; 5438 : 							return 1;

  04440	e9 34 ff ff ff	 jmp	 $LN779@PageDialog
$LN242@PageDialog:

; 5373 : 			{
; 5374 : 			case NONSYS_INPLACE_ENC_RESUME_PARTITION_SEL_PAGE:
; 5375 : 
; 5376 : 				if (lw == IDC_LIST_BOX 
; 5377 : 					&& (hw == LBN_SELCHANGE || hw == LBN_DBLCLK))

  04445	b9 fa 03 00 00	 mov	 ecx, 1018		; 000003faH
  0444a	66 3b f1	 cmp	 si, cx
  0444d	0f 85 2d 01 00
	00		 jne	 $LN243@PageDialog
  04453	66 83 ff 01	 cmp	 di, 1
  04457	74 0a		 je	 SHORT $LN244@PageDialog
  04459	66 83 ff 02	 cmp	 di, 2
  0445d	0f 85 8a 03 00
	00		 jne	 $LN264@PageDialog
$LN244@PageDialog:

; 5378 : 				{
; 5379 : 					BOOL tmpbDevice = FALSE;
; 5380 : 
; 5381 : 					EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), FALSE);

  04463	6a 00		 push	 0
  04465	68 10 04 00 00	 push	 1040			; 00000410H
  0446a	53		 push	 ebx
  0446b	c7 85 54 eb fe
	ff 00 00 00 00	 mov	 DWORD PTR _tmpbDevice$7[ebp], 0
  04475	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0447b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  04481	50		 push	 eax
  04482	ff d6		 call	 esi
  04484	50		 push	 eax
  04485	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 5382 : 
; 5383 : 					int selPartitionItemId = (int) SendMessage (GetDlgItem (hwndDlg, IDC_LIST_BOX), LB_GETCURSEL, 0, 0);

  0448b	6a 00		 push	 0
  0448d	6a 00		 push	 0
  0448f	68 88 01 00 00	 push	 392			; 00000188H
  04494	68 fa 03 00 00	 push	 1018			; 000003faH
  04499	53		 push	 ebx
  0449a	ff d6		 call	 esi
  0449c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SendMessageA@16
  044a2	50		 push	 eax
  044a3	ff d7		 call	 edi
  044a5	89 85 78 eb fe
	ff		 mov	 DWORD PTR _selPartitionItemId$1$[ebp], eax

; 5384 : 
; 5385 : 					if (selPartitionItemId == LB_ERR)

  044ab	83 f8 ff	 cmp	 eax, -1
  044ae	75 2c		 jne	 SHORT $LN245@PageDialog

; 5386 : 					{
; 5387 : 						// Deselect all
; 5388 : 						SendMessage (GetDlgItem (hwndDlg, IDC_LIST_BOX), LB_SETCURSEL, (WPARAM) -1, 0);

  044b0	6a 00		 push	 0
  044b2	50		 push	 eax
  044b3	68 86 01 00 00	 push	 390			; 00000186H
  044b8	68 fa 03 00 00	 push	 1018			; 000003faH
  044bd	53		 push	 ebx
  044be	ff d6		 call	 esi
  044c0	50		 push	 eax
  044c1	ff d7		 call	 edi

; 5389 : 
; 5390 : 						SetFocus (GetDlgItem (MainDlg, IDC_NEXT));

  044c3	68 10 04 00 00	 push	 1040			; 00000410H
  044c8	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  044ce	ff d6		 call	 esi
  044d0	50		 push	 eax
  044d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 5391 : 						return 1;

  044d7	e9 e7 0e 00 00	 jmp	 $LN752@PageDialog
$LN245@PageDialog:

; 5392 : 					}
; 5393 : 
; 5394 : 					SetFocus (GetDlgItem (MainDlg, IDC_NEXT));

  044dc	68 10 04 00 00	 push	 1040			; 00000410H
  044e1	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  044e7	ff d6		 call	 esi
  044e9	50		 push	 eax
  044ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 5395 : 
; 5396 : 					strcpy (szFileName, DeferredNonSysInPlaceEncDevices [selPartitionItemId].Path.c_str());

  044f0	6b 8d 78 eb fe
	ff 70		 imul	 ecx, DWORD PTR _selPartitionItemId$1$[ebp], 112
  044f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DeferredNonSysInPlaceEncDevices@@3V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@A
  044fc	83 c0 38	 add	 eax, 56			; 00000038H
  044ff	03 c8		 add	 ecx, eax
  04501	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  04505	72 02		 jb	 SHORT $LN657@PageDialog
  04507	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN657@PageDialog:
  04509	ba 00 00 00 00	 mov	 edx, OFFSET ?szFileName@@3PADA ; szFileName
  0450e	66 90		 npad	 2
$LL362@PageDialog:
  04510	8a 01		 mov	 al, BYTE PTR [ecx]
  04512	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  04515	88 02		 mov	 BYTE PTR [edx], al
  04517	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0451a	84 c0		 test	 al, al
  0451c	75 f2		 jne	 SHORT $LL362@PageDialog

; 5397 : 					CreateFullVolumePath (szDiskFile, szFileName, &tmpbDevice);

  0451e	8d 85 54 eb fe
	ff		 lea	 eax, DWORD PTR _tmpbDevice$7[ebp]
  04524	50		 push	 eax
  04525	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  0452a	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0452f	e8 00 00 00 00	 call	 _CreateFullVolumePath

; 5398 : 
; 5399 : 					nVolumeSize = GetDeviceSize (szDiskFile);

  04534	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  04539	e8 00 00 00 00	 call	 _GetDeviceSize
  0453e	a3 00 00 00 00	 mov	 DWORD PTR ?nVolumeSize@@3_KA, eax
  04543	83 c4 10	 add	 esp, 16			; 00000010H

; 5400 : 					if (nVolumeSize == -1)

  04546	23 c2		 and	 eax, edx
  04548	89 15 04 00 00
	00		 mov	 DWORD PTR ?nVolumeSize@@3_KA+4, edx
  0454e	83 f8 ff	 cmp	 eax, -1
  04551	75 10		 jne	 SHORT $LN246@PageDialog

; 5401 : 					{
; 5402 : 						handleWin32Error (MainDlg);

  04553	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  04559	e8 00 00 00 00	 call	 _handleWin32Error

; 5403 : 						return 1;

  0455e	e9 5d 0e 00 00	 jmp	 $LN767@PageDialog
$LN246@PageDialog:

; 5404 : 					}
; 5405 : 
; 5406 : 					EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  04563	6a 01		 push	 1
  04565	68 10 04 00 00	 push	 1040			; 00000410H
  0456a	53		 push	 ebx
  0456b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  04571	50		 push	 eax
  04572	ff d6		 call	 esi
  04574	50		 push	 eax
  04575	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  0457b	e9 43 0e 00 00	 jmp	 $LN752@PageDialog
$LN243@PageDialog:

; 5439 : 						}
; 5440 : 						break;
; 5441 : 					}
; 5442 : 				}
; 5443 : 				break;
; 5444 : 			}
; 5445 : 		}
; 5446 : 
; 5447 : 
; 5448 : 		if (lw == IDC_OPEN_OUTER_VOLUME && nCurPageNo == FORMAT_FINISHED_PAGE)

  04580	b9 0a 04 00 00	 mov	 ecx, 1034		; 0000040aH
  04585	66 3b f1	 cmp	 si, cx
  04588	75 19		 jne	 SHORT $LN254@PageDialog
  0458a	83 f8 27	 cmp	 eax, 39			; 00000027H
  0458d	0f 85 5a 02 00
	00		 jne	 $LN264@PageDialog

; 5449 : 		{
; 5450 : 			OpenVolumeExplorerWindow (hiddenVolHostDriveNo);

  04593	ff 35 00 00 00
	00		 push	 DWORD PTR ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  04599	e8 00 00 00 00	 call	 _OpenVolumeExplorerWindow

; 5451 : 			return 1;

  0459e	e9 1d 0e 00 00	 jmp	 $LN767@PageDialog
$LN254@PageDialog:

; 5452 : 		}
; 5453 : 
; 5454 : 		if (lw == IDC_HIDDEN_VOL_HELP && nCurPageNo == VOLUME_TYPE_PAGE)

  045a3	b9 09 04 00 00	 mov	 ecx, 1033		; 00000409H
  045a8	66 3b f1	 cmp	 si, cx
  045ab	75 18		 jne	 SHORT $LN255@PageDialog
  045ad	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  045b0	0f 85 37 02 00
	00		 jne	 $LN264@PageDialog

; 5455 : 		{
; 5456 : 			//Applink ("hiddenvolume", TRUE, "");
; 5457 : 			Extlink("http://www.gostcrypt.org/redirect.php?a=2");

  045b6	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@
  045bb	e8 00 00 00 00	 call	 _Extlink

; 5458 : 			return 1;

  045c0	e9 fb 0d 00 00	 jmp	 $LN767@PageDialog
$LN255@PageDialog:

; 5459 : 		}
; 5460 : 
; 5461 : 		if (lw == IDC_ABORT_BUTTON && nCurPageNo == FORMAT_PAGE)

  045c5	b9 f8 03 00 00	 mov	 ecx, 1016		; 000003f8H
  045ca	66 3b f1	 cmp	 si, cx
  045cd	75 41		 jne	 SHORT $LN256@PageDialog
  045cf	83 f8 26	 cmp	 eax, 38			; 00000026H
  045d2	0f 85 15 02 00
	00		 jne	 $LN264@PageDialog

; 5462 : 		{
; 5463 : 			if (MessageBoxW (hwndDlg, GetString ("FORMAT_ABORT"), lpszTitle, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 ) == IDYES)

  045d8	68 24 01 00 00	 push	 292			; 00000124H
  045dd	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  045e3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LNDFLMFM@FORMAT_ABORT?$AA@
  045e8	e8 00 00 00 00	 call	 _GetString
  045ed	83 c4 04	 add	 esp, 4
  045f0	50		 push	 eax
  045f1	53		 push	 ebx
  045f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  045f8	83 f8 06	 cmp	 eax, 6
  045fb	0f 85 c2 0d 00
	00		 jne	 $LN752@PageDialog

; 5464 : 				bVolTransformThreadCancel = TRUE;

  04601	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bVolTransformThreadCancel, 1

; 5465 : 			return 1;

  0460b	e9 b3 0d 00 00	 jmp	 $LN752@PageDialog
$LN256@PageDialog:

; 5466 : 		}
; 5467 : 
; 5468 : 		if (lw == IDC_CIPHER_TEST && nCurPageNo == CIPHER_PAGE)

  04610	b9 fd 03 00 00	 mov	 ecx, 1021		; 000003fdH
  04615	66 3b f1	 cmp	 si, cx
  04618	0f 85 99 00 00
	00		 jne	 $LN258@PageDialog
  0461e	83 f8 12	 cmp	 eax, 18			; 00000012H
  04621	0f 85 c6 01 00
	00		 jne	 $LN264@PageDialog

; 5469 : 		{
; 5470 : 			LPARAM nIndex;
; 5471 : 			int c;
; 5472 : 
; 5473 : 			nIndex = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX), CB_GETCURSEL, 0, 0);

  04627	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0462d	6a 00		 push	 0
  0462f	6a 00		 push	 0
  04631	68 47 01 00 00	 push	 327			; 00000147H
  04636	68 ea 03 00 00	 push	 1002			; 000003eaH
  0463b	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  04641	ff d7		 call	 edi
  04643	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  04649	50		 push	 eax
  0464a	ff d6		 call	 esi

; 5474 : 			nVolumeEA = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX), CB_GETITEMDATA, nIndex, 0);

  0464c	6a 00		 push	 0
  0464e	50		 push	 eax
  0464f	68 50 01 00 00	 push	 336			; 00000150H
  04654	68 ea 03 00 00	 push	 1002			; 000003eaH
  04659	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0465f	ff d7		 call	 edi
  04661	50		 push	 eax
  04662	ff d6		 call	 esi

; 5475 : 
; 5476 : 			for (c = EAGetLastCipher (nVolumeEA); c != 0; c = EAGetPreviousCipher (nVolumeEA, c))

  04664	50		 push	 eax
  04665	a3 00 00 00 00	 mov	 DWORD PTR ?nVolumeEA@@3HA, eax ; nVolumeEA
  0466a	e8 00 00 00 00	 call	 _EAGetLastCipher
  0466f	8b f0		 mov	 esi, eax
  04671	83 c4 04	 add	 esp, 4
  04674	85 f6		 test	 esi, esi
  04676	0f 84 47 0d 00
	00		 je	 $LN752@PageDialog
  0467c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
$LL43@PageDialog:

; 5477 : 			{
; 5478 : 				DialogBoxParamW (hInst, MAKEINTRESOURCEW (IDD_CIPHER_TEST_DLG), 

  04682	56		 push	 esi
  04683	68 00 00 00 00	 push	 OFFSET _CipherTestDialogProc@16
  04688	53		 push	 ebx
  04689	ff d7		 call	 edi
  0468b	50		 push	 eax
  0468c	68 02 02 00 00	 push	 514			; 00000202H
  04691	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  04697	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20
  0469d	56		 push	 esi
  0469e	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeEA@@3HA ; nVolumeEA
  046a4	e8 00 00 00 00	 call	 _EAGetPreviousCipher
  046a9	8b f0		 mov	 esi, eax
  046ab	83 c4 08	 add	 esp, 8
  046ae	85 f6		 test	 esi, esi
  046b0	75 d0		 jne	 SHORT $LL43@PageDialog

; 5479 : 					GetParent (hwndDlg), (DLGPROC) CipherTestDialogProc, (LPARAM) c);
; 5480 : 			}
; 5481 : 			return 1;

  046b2	e9 0c 0d 00 00	 jmp	 $LN752@PageDialog
$LN258@PageDialog:

; 5482 : 		}
; 5483 : 
; 5484 : 		if (lw == IDC_BENCHMARK && nCurPageNo == CIPHER_PAGE)

  046b7	b9 fe 03 00 00	 mov	 ecx, 1022		; 000003feH
  046bc	66 3b f1	 cmp	 si, cx
  046bf	75 4f		 jne	 SHORT $LN259@PageDialog
  046c1	83 f8 12	 cmp	 eax, 18			; 00000012H
  046c4	0f 85 23 01 00
	00		 jne	 $LN264@PageDialog

; 5485 : 		{
; 5486 : 			// Reduce CPU load
; 5487 : 			bFastPollEnabled = FALSE;	
; 5488 : 			bRandmixEnabled = FALSE;
; 5489 : 
; 5490 : 			DialogBoxParamW (hInst,

  046ca	6a 00		 push	 0
  046cc	68 00 00 00 00	 push	 OFFSET _BenchmarkDlgProc@16
  046d1	53		 push	 ebx
  046d2	68 f7 01 00 00	 push	 503			; 000001f7H
  046d7	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  046dd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bFastPollEnabled, 0
  046e7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bRandmixEnabled, 0
  046f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20

; 5491 : 				MAKEINTRESOURCEW (IDD_BENCHMARK_DLG), hwndDlg,
; 5492 : 				(DLGPROC) BenchmarkDlgProc, (LPARAM) NULL);
; 5493 : 
; 5494 : 			bFastPollEnabled = TRUE;

  046f7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bFastPollEnabled, 1

; 5495 : 			bRandmixEnabled = TRUE;

  04701	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bRandmixEnabled, 1

; 5496 : 
; 5497 : 			return 1;

  0470b	e9 b3 0c 00 00	 jmp	 $LN752@PageDialog
$LN259@PageDialog:

; 5498 : 		}
; 5499 : 
; 5500 : 		if (lw == IDC_LINK_MORE_INFO_ABOUT_CIPHER && nCurPageNo == CIPHER_PAGE)

  04710	b9 21 04 00 00	 mov	 ecx, 1057		; 00000421H
  04715	66 3b f1	 cmp	 si, cx
  04718	0f 85 bc 00 00
	00		 jne	 $LN260@PageDialog
  0471e	83 f8 12	 cmp	 eax, 18			; 00000012H
  04721	0f 85 c6 00 00
	00		 jne	 $LN264@PageDialog

; 5501 : 		{
; 5502 : 			char name[100];
; 5503 : 
; 5504 : 			int nIndex = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX), CB_GETCURSEL, 0, 0);

  04727	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0472d	6a 00		 push	 0
  0472f	6a 00		 push	 0
  04731	68 47 01 00 00	 push	 327			; 00000147H
  04736	68 ea 03 00 00	 push	 1002			; 000003eaH
  0473b	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  04741	ff d7		 call	 edi
  04743	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  04749	50		 push	 eax
  0474a	ff d6		 call	 esi

; 5505 : 			nIndex = SendMessage (GetDlgItem (hCurPage, IDC_COMBO_BOX), CB_GETITEMDATA, nIndex, 0);

  0474c	6a 00		 push	 0
  0474e	50		 push	 eax
  0474f	68 50 01 00 00	 push	 336			; 00000150H
  04754	68 ea 03 00 00	 push	 1002			; 000003eaH
  04759	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0475f	ff d7		 call	 edi
  04761	50		 push	 eax
  04762	ff d6		 call	 esi
  04764	8b f0		 mov	 esi, eax

; 5506 : 			EAGetName (name, nIndex);

  04766	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _name$32[ebp]
  0476c	56		 push	 esi
  0476d	50		 push	 eax
  0476e	e8 00 00 00 00	 call	 _EAGetName
  04773	83 c4 08	 add	 esp, 8

; 5507 : 
; 5508 : 			if (strcmp (name, "GOST 28147-89") == 0)

  04776	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _name$32[ebp]
  0477c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
$LL723@PageDialog:
  04781	8a 01		 mov	 al, BYTE PTR [ecx]
  04783	3a 02		 cmp	 al, BYTE PTR [edx]
  04785	75 1a		 jne	 SHORT $LN724@PageDialog
  04787	84 c0		 test	 al, al
  04789	74 12		 je	 SHORT $LN725@PageDialog
  0478b	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  0478e	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  04791	75 0e		 jne	 SHORT $LN724@PageDialog
  04793	83 c1 02	 add	 ecx, 2
  04796	83 c2 02	 add	 edx, 2
  04799	84 c0		 test	 al, al
  0479b	75 e4		 jne	 SHORT $LL723@PageDialog
$LN725@PageDialog:
  0479d	33 c0		 xor	 eax, eax
  0479f	eb 05		 jmp	 SHORT $LN726@PageDialog
$LN724@PageDialog:
  047a1	1b c0		 sbb	 eax, eax
  047a3	83 c8 01	 or	 eax, 1
$LN726@PageDialog:
  047a6	85 c0		 test	 eax, eax
  047a8	75 0f		 jne	 SHORT $LN261@PageDialog

; 5509 : 				Extlink("http://www.ietf.org/rfc/rfc5830.txt");

  047aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@BFLBCKJG@http?3?1?1www?4ietf?4org?1rfc?1rfc5830?4@

; 5511 : 				//Applink ("cascades", TRUE, "");
; 5512 : 				Extlink("http://www.gostcrypt.org/redirect.php?a=2");

  047af	e8 00 00 00 00	 call	 _Extlink

; 5513 : 
; 5514 : 			return 1;

  047b4	e9 07 0c 00 00	 jmp	 $LN767@PageDialog
$LN261@PageDialog:

; 5510 : 			else if (EAGetCipherCount (nIndex) > 1)

  047b9	56		 push	 esi
  047ba	e8 00 00 00 00	 call	 _EAGetCipherCount
  047bf	83 c4 04	 add	 esp, 4
  047c2	83 f8 01	 cmp	 eax, 1
  047c5	0f 8e f8 0b 00
	00		 jle	 $LN752@PageDialog

; 5511 : 				//Applink ("cascades", TRUE, "");
; 5512 : 				Extlink("http://www.gostcrypt.org/redirect.php?a=2");

  047cb	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@
  047d0	e8 00 00 00 00	 call	 _Extlink

; 5513 : 
; 5514 : 			return 1;

  047d5	e9 e6 0b 00 00	 jmp	 $LN767@PageDialog
$LN260@PageDialog:

; 5515 : 		}
; 5516 : 
; 5517 : 		if (lw == IDC_LINK_HASH_INFO && nCurPageNo == CIPHER_PAGE)

  047da	b9 22 04 00 00	 mov	 ecx, 1058		; 00000422H
  047df	66 3b f1	 cmp	 si, cx
  047e2	75 09		 jne	 SHORT $LN264@PageDialog
  047e4	83 f8 12	 cmp	 eax, 18			; 00000012H
  047e7	0f 84 70 f8 ff
	ff		 je	 $LN211@PageDialog
$LN264@PageDialog:

; 5518 : 		{
; 5519 : 			//Applink ("hashalgorithms", TRUE, "");
; 5520 : 			Extlink("http://www.gostcrypt.org/redirect.php?a=2");
; 5521 : 			return 1;
; 5522 : 		}
; 5523 : 
; 5524 : 		if (hw == CBN_EDITCHANGE && nCurPageNo == VOLUME_LOCATION_PAGE)

  047ed	66 83 ff 05	 cmp	 di, 5
  047f1	75 5a		 jne	 SHORT $LN265@PageDialog
  047f3	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  047f6	0f 85 98 00 00
	00		 jne	 $LN734@PageDialog

; 5525 : 		{
; 5526 : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), 

  047fc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  04802	68 ea 03 00 00	 push	 1002			; 000003eaH
  04807	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0480d	ff d6		 call	 esi
  0480f	50		 push	 eax
  04810	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  04816	33 c9		 xor	 ecx, ecx
  04818	85 c0		 test	 eax, eax
  0481a	0f 9f c1	 setg	 cl
  0481d	51		 push	 ecx
$LN769@PageDialog:
  0481e	68 10 04 00 00	 push	 1040			; 00000410H
  04823	53		 push	 ebx
  04824	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0482a	50		 push	 eax
  0482b	ff d6		 call	 esi
  0482d	50		 push	 eax
  0482e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
$LN781@PageDialog:

; 5527 : 				GetWindowTextLength (GetDlgItem (hCurPage, IDC_COMBO_BOX)) > 0);
; 5528 : 
; 5529 : 			bDeviceTransformModeChoiceMade = FALSE;

  04834	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bDeviceTransformModeChoiceMade@@3HA, 0 ; bDeviceTransformModeChoiceMade

; 5530 : 			bInPlaceEncNonSys = FALSE;

  0483e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0

; 5531 : 
; 5532 : 			return 1;

  04848	e9 76 0b 00 00	 jmp	 $LN752@PageDialog
$LN265@PageDialog:

; 5533 : 		}
; 5534 : 		
; 5535 : 		if (hw == CBN_SELCHANGE && nCurPageNo == VOLUME_LOCATION_PAGE)

  0484d	66 83 ff 01	 cmp	 di, 1
  04851	0f 85 e0 00 00
	00		 jne	 $LN266@PageDialog
  04857	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0485a	75 38		 jne	 SHORT $LN734@PageDialog

; 5536 : 		{
; 5537 : 			LPARAM nIndex;
; 5538 : 
; 5539 : 			nIndex = MoveEditToCombo ((HWND) lParam, bHistory);

  0485c	ff 35 00 00 00
	00		 push	 DWORD PTR _bHistory
  04862	ff b5 78 eb fe
	ff		 push	 DWORD PTR _lParam$GSCopy$1$[ebp]
  04868	e8 00 00 00 00	 call	 _MoveEditToCombo

; 5540 : 			nIndex = UpdateComboOrder (GetDlgItem (hwndDlg, IDC_COMBO_BOX));

  0486d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  04873	83 c4 08	 add	 esp, 8
  04876	68 ea 03 00 00	 push	 1002			; 000003eaH
  0487b	53		 push	 ebx
  0487c	ff d6		 call	 esi
  0487e	50		 push	 eax
  0487f	e8 00 00 00 00	 call	 _UpdateComboOrder
  04884	83 c4 04	 add	 esp, 4

; 5541 : 
; 5542 : 			if (nIndex != CB_ERR)

  04887	83 f8 ff	 cmp	 eax, -1
  0488a	74 04		 je	 SHORT $LN267@PageDialog

; 5543 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  0488c	6a 01		 push	 1

; 5544 : 			else

  0488e	eb 8e		 jmp	 SHORT $LN769@PageDialog
$LN267@PageDialog:

; 5545 : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), FALSE);

  04890	6a 00		 push	 0

; 5546 : 
; 5547 : 			bDeviceTransformModeChoiceMade = FALSE;
; 5548 : 			bInPlaceEncNonSys = FALSE;
; 5549 : 
; 5550 : 			return 1;

  04892	eb 8a		 jmp	 SHORT $LN769@PageDialog
$LN734@PageDialog:

; 5568 : 
; 5569 : 			return 1;

  04894	b9 00 03 00 00	 mov	 ecx, 768		; 00000300H
$LN270@PageDialog:

; 5570 : 		}
; 5571 : 
; 5572 : 		if (lw == IDC_SHOW_PASSWORD && nCurPageNo == PASSWORD_PAGE)

  04899	ba 20 04 00 00	 mov	 edx, 1056		; 00000420H
  0489e	66 3b f2	 cmp	 si, dx
  048a1	0f 85 2d 01 00
	00		 jne	 $LN271@PageDialog
  048a7	83 f8 15	 cmp	 eax, 21			; 00000015H
  048aa	0f 85 29 01 00
	00		 jne	 $LN699@PageDialog

; 5573 : 		{
; 5574 : 			SendMessage (GetDlgItem (hwndDlg, IDC_PASSWORD),

  048b0	6a 00		 push	 0
  048b2	52		 push	 edx
  048b3	53		 push	 ebx
  048b4	e8 00 00 00 00	 call	 _GetCheckBox
  048b9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  048bf	83 c4 08	 add	 esp, 8
  048c2	f7 d8		 neg	 eax
  048c4	1b c0		 sbb	 eax, eax
  048c6	83 e0 d6	 and	 eax, -42		; ffffffd6H
  048c9	83 c0 2a	 add	 eax, 42			; 0000002aH
  048cc	50		 push	 eax
  048cd	68 cc 00 00 00	 push	 204			; 000000ccH
  048d2	68 ec 03 00 00	 push	 1004			; 000003ecH
  048d7	53		 push	 ebx
  048d8	ff d7		 call	 edi
  048da	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  048e0	50		 push	 eax
  048e1	ff d6		 call	 esi

; 5575 : 						EM_SETPASSWORDCHAR,
; 5576 : 						GetCheckBox (hwndDlg, IDC_SHOW_PASSWORD) ? 0 : '*',
; 5577 : 						0);
; 5578 : 			SendMessage (GetDlgItem (hwndDlg, IDC_VERIFY),

  048e3	6a 00		 push	 0
  048e5	68 20 04 00 00	 push	 1056			; 00000420H
  048ea	53		 push	 ebx
  048eb	e8 00 00 00 00	 call	 _GetCheckBox
  048f0	83 c4 08	 add	 esp, 8
  048f3	f7 d8		 neg	 eax
  048f5	1b c0		 sbb	 eax, eax
  048f7	83 e0 d6	 and	 eax, -42		; ffffffd6H
  048fa	83 c0 2a	 add	 eax, 42			; 0000002aH
  048fd	50		 push	 eax
  048fe	68 cc 00 00 00	 push	 204			; 000000ccH
  04903	68 f2 03 00 00	 push	 1010			; 000003f2H
  04908	53		 push	 ebx
  04909	ff d7		 call	 edi
  0490b	50		 push	 eax
  0490c	ff d6		 call	 esi

; 5579 : 						EM_SETPASSWORDCHAR,
; 5580 : 						GetCheckBox (hwndDlg, IDC_SHOW_PASSWORD) ? 0 : '*',
; 5581 : 						0);
; 5582 : 			InvalidateRect (GetDlgItem (hwndDlg, IDC_PASSWORD), NULL, TRUE);

  0490e	6a 01		 push	 1
  04910	6a 00		 push	 0
  04912	68 ec 03 00 00	 push	 1004			; 000003ecH
  04917	53		 push	 ebx
  04918	ff d7		 call	 edi
  0491a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__InvalidateRect@12
  04920	50		 push	 eax
  04921	ff d6		 call	 esi

; 5583 : 			InvalidateRect (GetDlgItem (hwndDlg, IDC_VERIFY), NULL, TRUE);

  04923	6a 01		 push	 1
  04925	6a 00		 push	 0
  04927	68 f2 03 00 00	 push	 1010			; 000003f2H
  0492c	53		 push	 ebx
  0492d	ff d7		 call	 edi
  0492f	50		 push	 eax
  04930	ff d6		 call	 esi

; 5584 : 			return 1;

  04932	e9 8c 0a 00 00	 jmp	 $LN752@PageDialog
$LN266@PageDialog:

; 5551 : 		}
; 5552 : 		
; 5553 : 		if (hw == EN_CHANGE && nCurPageNo == SIZE_PAGE)

  04937	b9 00 03 00 00	 mov	 ecx, 768		; 00000300H
  0493c	66 3b f9	 cmp	 di, cx
  0493f	0f 85 54 ff ff
	ff		 jne	 $LN270@PageDialog
  04945	83 f8 13	 cmp	 eax, 19			; 00000013H
  04948	0f 84 9d 03 00
	00		 je	 $LN44@PageDialog

; 5554 : 		{
; 5555 : 			VerifySizeAndUpdate (hwndDlg, FALSE);
; 5556 : 			return 1;
; 5557 : 		}
; 5558 : 		
; 5559 : 		if (hw == EN_CHANGE && nCurPageNo == PASSWORD_PAGE)

  0494e	83 f8 15	 cmp	 eax, 21			; 00000015H
  04951	0f 85 42 ff ff
	ff		 jne	 $LN270@PageDialog

; 5560 : 		{
; 5561 : 			VerifyPasswordAndUpdate (hwndDlg, GetDlgItem (GetParent (hwndDlg), IDC_NEXT),

  04957	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KeyFilesEnable, 0
  0495e	74 19		 je	 SHORT $LN363@PageDialog
  04960	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _FirstKeyFile, 0
  04967	74 10		 je	 SHORT $LN363@PageDialog
  04969	e8 00 00 00 00	 call	 _SysEncInEffect
  0496e	85 c0		 test	 eax, eax
  04970	75 07		 jne	 SHORT $LN363@PageDialog
  04972	b8 01 00 00 00	 mov	 eax, 1
  04977	eb 02		 jmp	 SHORT $LN364@PageDialog
$LN363@PageDialog:
  04979	33 c0		 xor	 eax, eax
$LN364@PageDialog:
  0497b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  04981	50		 push	 eax
  04982	6a 00		 push	 0
  04984	6a 00		 push	 0
  04986	68 f2 03 00 00	 push	 1010			; 000003f2H
  0498b	53		 push	 ebx
  0498c	ff d6		 call	 esi
  0498e	50		 push	 eax
  0498f	68 ec 03 00 00	 push	 1004			; 000003ecH
  04994	53		 push	 ebx
  04995	ff d6		 call	 esi
  04997	50		 push	 eax
  04998	68 10 04 00 00	 push	 1040			; 00000410H
  0499d	53		 push	 ebx
  0499e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  049a4	50		 push	 eax
  049a5	ff d6		 call	 esi
  049a7	50		 push	 eax
  049a8	53		 push	 ebx
  049a9	e8 00 00 00 00	 call	 _VerifyPasswordAndUpdate

; 5562 : 				GetDlgItem (hwndDlg, IDC_PASSWORD),
; 5563 : 				GetDlgItem (hwndDlg, IDC_VERIFY),
; 5564 : 				NULL,
; 5565 : 				NULL,
; 5566 : 				KeyFilesEnable && FirstKeyFile!=NULL && !SysEncInEffect());
; 5567 : 			volumePassword.Length = strlen ((char *) volumePassword.Text);

  049ae	b9 04 00 00 00	 mov	 ecx, OFFSET ?volumePassword@@3UPassword@@A+4
  049b3	83 c4 1c	 add	 esp, 28			; 0000001cH
  049b6	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  049b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL727@PageDialog:
  049c0	8a 01		 mov	 al, BYTE PTR [ecx]
  049c2	41		 inc	 ecx
  049c3	84 c0		 test	 al, al
  049c5	75 f9		 jne	 SHORT $LL727@PageDialog
  049c7	2b ca		 sub	 ecx, edx
  049c9	89 0d 00 00 00
	00		 mov	 DWORD PTR ?volumePassword@@3UPassword@@A, ecx

; 5568 : 
; 5569 : 			return 1;

  049cf	e9 ef 09 00 00	 jmp	 $LN752@PageDialog
$LN271@PageDialog:

; 5585 : 		}
; 5586 : 		
; 5587 : 		if (nCurPageNo == PASSWORD_PAGE 
; 5588 : 			|| nCurPageNo == HIDDEN_VOL_HOST_PASSWORD_PAGE 
; 5589 : 			|| nCurPageNo == NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE)

  049d4	83 f8 15	 cmp	 eax, 21			; 00000015H
  049d7	74 0e		 je	 SHORT $LN273@PageDialog
$LN699@PageDialog:
  049d9	83 f8 14	 cmp	 eax, 20			; 00000014H
  049dc	74 09		 je	 SHORT $LN273@PageDialog
  049de	83 f8 20	 cmp	 eax, 32			; 00000020H
  049e1	0f 85 99 01 00
	00		 jne	 $LN279@PageDialog
$LN273@PageDialog:

; 5590 : 		{
; 5591 : 			if (lw == IDC_KEY_FILES)

  049e7	ba 02 04 00 00	 mov	 edx, 1026		; 00000402H
  049ec	66 3b f2	 cmp	 si, dx
  049ef	0f 85 20 01 00
	00		 jne	 $LN274@PageDialog

; 5592 : 			{
; 5593 : 				if (SysEncInEffect())

  049f5	e8 00 00 00 00	 call	 _SysEncInEffect
  049fa	85 c0		 test	 eax, eax
  049fc	74 0f		 je	 SHORT $LN275@PageDialog

; 5594 : 				{
; 5595 : 					Warning ("KEYFILES_NOT_SUPPORTED_FOR_SYS_ENCRYPTION");

  049fe	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PHDAOPJF@KEYFILES_NOT_SUPPORTED_FOR_SYS_E@
  04a03	e8 00 00 00 00	 call	 _Warning

; 5596 : 					return 1;

  04a08	e9 b3 09 00 00	 jmp	 $LN767@PageDialog
$LN275@PageDialog:

; 5597 : 				}
; 5598 : 
; 5599 : 				KeyFilesDlgParam param;
; 5600 : 				param.EnableKeyFiles = KeyFilesEnable;

  04a0d	a1 00 00 00 00	 mov	 eax, DWORD PTR _KeyFilesEnable
  04a12	89 85 58 eb fe
	ff		 mov	 DWORD PTR _param$8[ebp], eax

; 5601 : 				param.FirstKeyFile = FirstKeyFile;

  04a18	a1 00 00 00 00	 mov	 eax, DWORD PTR _FirstKeyFile
  04a1d	89 85 5c eb fe
	ff		 mov	 DWORD PTR _param$8[ebp+4], eax

; 5602 : 
; 5603 : 				if (IDOK == DialogBoxParamW (hInst,

  04a23	8d 85 58 eb fe
	ff		 lea	 eax, DWORD PTR _param$8[ebp]
  04a29	50		 push	 eax
  04a2a	68 00 00 00 00	 push	 OFFSET _KeyFilesDlgProc@16
  04a2f	53		 push	 ebx
  04a30	68 f9 01 00 00	 push	 505			; 000001f9H
  04a35	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  04a3b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20
  04a41	83 f8 01	 cmp	 eax, 1
  04a44	0f 85 79 09 00
	00		 jne	 $LN752@PageDialog

; 5604 : 					MAKEINTRESOURCEW (IDD_KEYFILES), hwndDlg,
; 5605 : 					(DLGPROC) KeyFilesDlgProc, (LPARAM) &param))
; 5606 : 				{
; 5607 : 					KeyFilesEnable = param.EnableKeyFiles;

  04a4a	8b 8d 58 eb fe
	ff		 mov	 ecx, DWORD PTR _param$8[ebp]

; 5608 : 					FirstKeyFile = param.FirstKeyFile;

  04a50	8b 85 5c eb fe
	ff		 mov	 eax, DWORD PTR _param$8[ebp+4]

; 5609 : 
; 5610 : 					SetCheckBox (hwndDlg, IDC_KEYFILES_ENABLE, KeyFilesEnable);

  04a56	51		 push	 ecx
  04a57	68 c5 13 00 00	 push	 5061			; 000013c5H
  04a5c	53		 push	 ebx
  04a5d	89 0d 00 00 00
	00		 mov	 DWORD PTR _KeyFilesEnable, ecx
  04a63	a3 00 00 00 00	 mov	 DWORD PTR _FirstKeyFile, eax
  04a68	e8 00 00 00 00	 call	 _SetCheckBox

; 5611 : 
; 5612 : 					if (nCurPageNo != HIDDEN_VOL_HOST_PASSWORD_PAGE && nCurPageNo != NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE)

  04a6d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  04a72	83 c4 0c	 add	 esp, 12			; 0000000cH
  04a75	83 f8 14	 cmp	 eax, 20			; 00000014H
  04a78	0f 84 45 09 00
	00		 je	 $LN752@PageDialog

; 5613 : 						EnableWindow (GetDlgItem (hwndDlg, IDC_KEY_FILES), KeyFilesEnable);

  04a7e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  04a84	83 f8 20	 cmp	 eax, 32			; 00000020H
  04a87	74 1a		 je	 SHORT $LN277@PageDialog
  04a89	ff 35 00 00 00
	00		 push	 DWORD PTR _KeyFilesEnable
  04a8f	68 02 04 00 00	 push	 1026			; 00000402H
  04a94	53		 push	 ebx
  04a95	ff d6		 call	 esi
  04a97	50		 push	 eax
  04a98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  04a9e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
$LN277@PageDialog:

; 5614 : 
; 5615 : 					if (nCurPageNo != HIDDEN_VOL_HOST_PASSWORD_PAGE && nCurPageNo != NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE)

  04aa3	83 f8 14	 cmp	 eax, 20			; 00000014H
  04aa6	0f 84 17 09 00
	00		 je	 $LN752@PageDialog
  04aac	83 f8 20	 cmp	 eax, 32			; 00000020H
  04aaf	0f 84 0e 09 00
	00		 je	 $LN752@PageDialog

; 5616 : 					{
; 5617 : 						VerifyPasswordAndUpdate (hwndDlg, GetDlgItem (GetParent (hwndDlg), IDC_NEXT),

  04ab5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KeyFilesEnable, 0
  04abc	74 10		 je	 SHORT $LN365@PageDialog
  04abe	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _FirstKeyFile, 0
  04ac5	74 07		 je	 SHORT $LN365@PageDialog
  04ac7	b8 01 00 00 00	 mov	 eax, 1
  04acc	eb 02		 jmp	 SHORT $LN366@PageDialog
$LN365@PageDialog:
  04ace	33 c0		 xor	 eax, eax
$LN366@PageDialog:
  04ad0	50		 push	 eax
  04ad1	68 00 00 00 00	 push	 OFFSET ?szVerify@@3PADA	; szVerify
  04ad6	68 04 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A+4
  04adb	68 f2 03 00 00	 push	 1010			; 000003f2H
  04ae0	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  04ae6	ff d6		 call	 esi
  04ae8	50		 push	 eax
  04ae9	68 ec 03 00 00	 push	 1004			; 000003ecH
  04aee	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  04af4	ff d6		 call	 esi
  04af6	50		 push	 eax
  04af7	68 10 04 00 00	 push	 1040			; 00000410H
  04afc	53		 push	 ebx
  04afd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  04b03	50		 push	 eax
  04b04	ff d6		 call	 esi
  04b06	50		 push	 eax
  04b07	53		 push	 ebx
  04b08	e8 00 00 00 00	 call	 _VerifyPasswordAndUpdate
  04b0d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5618 : 							GetDlgItem (hCurPage, IDC_PASSWORD),
; 5619 : 							GetDlgItem (hCurPage, IDC_VERIFY),
; 5620 : 							volumePassword.Text, szVerify, KeyFilesEnable && FirstKeyFile!=NULL);
; 5621 : 					}
; 5622 : 				}
; 5623 : 
; 5624 : 				return 1;

  04b10	e9 ae 08 00 00	 jmp	 $LN752@PageDialog
$LN274@PageDialog:

; 5625 : 			}
; 5626 : 
; 5627 : 			if (lw == IDC_KEYFILES_ENABLE)

  04b15	ba c5 13 00 00	 mov	 edx, 5061		; 000013c5H
  04b1a	66 3b f2	 cmp	 si, dx
  04b1d	75 61		 jne	 SHORT $LN279@PageDialog

; 5628 : 			{
; 5629 : 				KeyFilesEnable = GetCheckBox (hwndDlg, IDC_KEYFILES_ENABLE);

  04b1f	52		 push	 edx
  04b20	53		 push	 ebx
  04b21	e8 00 00 00 00	 call	 _GetCheckBox

; 5630 : 
; 5631 : 				if (nCurPageNo != HIDDEN_VOL_HOST_PASSWORD_PAGE && nCurPageNo != NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE)

  04b26	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  04b2c	83 c4 08	 add	 esp, 8
  04b2f	a3 00 00 00 00	 mov	 DWORD PTR _KeyFilesEnable, eax
  04b34	83 f9 14	 cmp	 ecx, 20			; 00000014H
  04b37	0f 84 86 08 00
	00		 je	 $LN752@PageDialog
  04b3d	83 f9 20	 cmp	 ecx, 32			; 00000020H
  04b40	0f 84 7d 08 00
	00		 je	 $LN752@PageDialog

; 5632 : 				{
; 5633 : 					EnableWindow (GetDlgItem (hwndDlg, IDC_KEY_FILES), KeyFilesEnable);

  04b46	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  04b4c	50		 push	 eax
  04b4d	68 02 04 00 00	 push	 1026			; 00000402H
  04b52	53		 push	 ebx
  04b53	ff d6		 call	 esi
  04b55	50		 push	 eax
  04b56	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 5634 : 
; 5635 : 					VerifyPasswordAndUpdate (hwndDlg, GetDlgItem (GetParent (hwndDlg), IDC_NEXT),

  04b5c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KeyFilesEnable, 0
  04b63	0f 84 65 ff ff
	ff		 je	 $LN365@PageDialog
  04b69	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _FirstKeyFile, 0
  04b70	0f 84 58 ff ff
	ff		 je	 $LN365@PageDialog
  04b76	b8 01 00 00 00	 mov	 eax, 1
  04b7b	e9 50 ff ff ff	 jmp	 $LN366@PageDialog
$LN279@PageDialog:

; 5636 : 						GetDlgItem (hCurPage, IDC_PASSWORD),
; 5637 : 						GetDlgItem (hCurPage, IDC_VERIFY),
; 5638 : 						volumePassword.Text, szVerify, KeyFilesEnable && FirstKeyFile!=NULL);
; 5639 : 				}
; 5640 : 
; 5641 : 				return 1;
; 5642 : 			}
; 5643 : 		}
; 5644 : 
; 5645 : 		if (nCurPageNo == HIDDEN_VOL_HOST_PASSWORD_PAGE
; 5646 : 			|| nCurPageNo == NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE)

  04b80	83 f8 14	 cmp	 eax, 20			; 00000014H
  04b83	74 09		 je	 SHORT $LN282@PageDialog
  04b85	83 f8 20	 cmp	 eax, 32			; 00000020H
  04b88	0f 85 99 00 00
	00		 jne	 $LN284@PageDialog
$LN282@PageDialog:

; 5647 : 		{
; 5648 : 			if (hw == EN_CHANGE)

  04b8e	66 3b f9	 cmp	 di, cx
  04b91	75 41		 jne	 SHORT $LN283@PageDialog

; 5649 : 			{
; 5650 : 				GetWindowText (GetDlgItem (hCurPage, IDC_PASSWORD_DIRECT), (char *) volumePassword.Text, sizeof (volumePassword.Text));

  04b93	6a 41		 push	 65			; 00000041H
  04b95	68 04 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A+4
  04b9a	68 0d 04 00 00	 push	 1037			; 0000040dH
  04b9f	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  04ba5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  04bab	50		 push	 eax
  04bac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 5651 : 				volumePassword.Length = strlen ((char *) volumePassword.Text);

  04bb2	b9 04 00 00 00	 mov	 ecx, OFFSET ?volumePassword@@3UPassword@@A+4
  04bb7	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  04bba	66 0f 1f 44 00
	00		 npad	 6
$LL728@PageDialog:
  04bc0	8a 01		 mov	 al, BYTE PTR [ecx]
  04bc2	41		 inc	 ecx
  04bc3	84 c0		 test	 al, al
  04bc5	75 f9		 jne	 SHORT $LL728@PageDialog
  04bc7	2b ca		 sub	 ecx, edx
  04bc9	89 0d 00 00 00
	00		 mov	 DWORD PTR ?volumePassword@@3UPassword@@A, ecx

; 5652 : 				return 1;

  04bcf	e9 ef 07 00 00	 jmp	 $LN752@PageDialog
$LN283@PageDialog:

; 5653 : 			}
; 5654 : 
; 5655 : 			if (lw == IDC_SHOW_PASSWORD_SINGLE)

  04bd4	b9 1f 04 00 00	 mov	 ecx, 1055		; 0000041fH
  04bd9	66 3b f1	 cmp	 si, cx
  04bdc	75 49		 jne	 SHORT $LN284@PageDialog

; 5656 : 			{
; 5657 : 				SendMessage (GetDlgItem (hwndDlg, IDC_PASSWORD_DIRECT),

  04bde	6a 00		 push	 0
  04be0	51		 push	 ecx
  04be1	53		 push	 ebx
  04be2	e8 00 00 00 00	 call	 _GetCheckBox
  04be7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  04bed	83 c4 08	 add	 esp, 8
  04bf0	f7 d8		 neg	 eax
  04bf2	1b c0		 sbb	 eax, eax
  04bf4	83 e0 d6	 and	 eax, -42		; ffffffd6H
  04bf7	83 c0 2a	 add	 eax, 42			; 0000002aH
  04bfa	50		 push	 eax
  04bfb	68 cc 00 00 00	 push	 204			; 000000ccH
  04c00	68 0d 04 00 00	 push	 1037			; 0000040dH
  04c05	53		 push	 ebx
  04c06	ff d6		 call	 esi
  04c08	50		 push	 eax
  04c09	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 5658 : 					EM_SETPASSWORDCHAR,
; 5659 : 					GetCheckBox (hwndDlg, IDC_SHOW_PASSWORD_SINGLE) ? 0 : '*',
; 5660 : 					0);
; 5661 : 				InvalidateRect (GetDlgItem (hwndDlg, IDC_PASSWORD_DIRECT), NULL, TRUE);

  04c0f	6a 01		 push	 1
  04c11	6a 00		 push	 0
  04c13	68 0d 04 00 00	 push	 1037			; 0000040dH
  04c18	53		 push	 ebx
  04c19	ff d6		 call	 esi
  04c1b	50		 push	 eax
  04c1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 5662 : 				return 1;

  04c22	e9 9c 07 00 00	 jmp	 $LN752@PageDialog
$LN284@PageDialog:

; 5663 : 			}
; 5664 : 		}
; 5665 : 
; 5666 : 		if ((lw == IDC_KB || lw == IDC_MB || lw == IDC_GB) && nCurPageNo == SIZE_PAGE)

  04c27	b9 f3 03 00 00	 mov	 ecx, 1011		; 000003f3H
  04c2c	66 3b f1	 cmp	 si, cx
  04c2f	74 18		 je	 SHORT $LN286@PageDialog
  04c31	b9 f5 03 00 00	 mov	 ecx, 1013		; 000003f5H
  04c36	66 3b f1	 cmp	 si, cx
  04c39	74 0e		 je	 SHORT $LN286@PageDialog
  04c3b	b9 f7 03 00 00	 mov	 ecx, 1015		; 000003f7H
  04c40	66 3b f1	 cmp	 si, cx
  04c43	0f 85 b2 00 00
	00		 jne	 $LN285@PageDialog
$LN286@PageDialog:
  04c49	83 f8 13	 cmp	 eax, 19			; 00000013H
  04c4c	0f 85 a9 00 00
	00		 jne	 $LN285@PageDialog

; 5667 : 		{
; 5668 : 			SendMessage (GetDlgItem (hwndDlg, IDC_KB), BM_SETCHECK, BST_UNCHECKED, 0);

  04c52	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  04c58	6a 00		 push	 0
  04c5a	6a 00		 push	 0
  04c5c	68 f1 00 00 00	 push	 241			; 000000f1H
  04c61	68 f3 03 00 00	 push	 1011			; 000003f3H
  04c66	53		 push	 ebx
  04c67	ff d7		 call	 edi
  04c69	50		 push	 eax
  04c6a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 5669 : 			SendMessage (GetDlgItem (hwndDlg, IDC_MB), BM_SETCHECK, BST_UNCHECKED, 0);

  04c70	6a 00		 push	 0
  04c72	6a 00		 push	 0
  04c74	68 f1 00 00 00	 push	 241			; 000000f1H
  04c79	68 f5 03 00 00	 push	 1013			; 000003f5H
  04c7e	53		 push	 ebx
  04c7f	ff d7		 call	 edi
  04c81	50		 push	 eax
  04c82	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 5670 : 			SendMessage (GetDlgItem (hwndDlg, IDC_GB), BM_SETCHECK, BST_UNCHECKED, 0);

  04c88	6a 00		 push	 0
  04c8a	6a 00		 push	 0
  04c8c	68 f1 00 00 00	 push	 241			; 000000f1H
  04c91	68 f7 03 00 00	 push	 1015			; 000003f7H
  04c96	53		 push	 ebx
  04c97	ff d7		 call	 edi
  04c99	50		 push	 eax
  04c9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 5671 : 
; 5672 : 			switch (lw)

  04ca0	0f b7 c6	 movzx	 eax, si
  04ca3	2d f3 03 00 00	 sub	 eax, 1011		; 000003f3H
  04ca8	74 29		 je	 SHORT $LN287@PageDialog
  04caa	83 e8 02	 sub	 eax, 2
  04cad	74 14		 je	 SHORT $LN288@PageDialog
  04caf	83 e8 02	 sub	 eax, 2
  04cb2	75 37		 jne	 SHORT $LN44@PageDialog

; 5680 : 			case IDC_GB:
; 5681 : 				SendMessage (GetDlgItem (hwndDlg, IDC_GB), BM_SETCHECK, BST_CHECKED, 0);

  04cb4	50		 push	 eax
  04cb5	6a 01		 push	 1
  04cb7	68 f1 00 00 00	 push	 241			; 000000f1H
  04cbc	68 f7 03 00 00	 push	 1015			; 000003f7H
  04cc1	eb 1e		 jmp	 SHORT $LN770@PageDialog
$LN288@PageDialog:

; 5676 : 				break;
; 5677 : 			case IDC_MB:
; 5678 : 				SendMessage (GetDlgItem (hwndDlg, IDC_MB), BM_SETCHECK, BST_CHECKED, 0);

  04cc3	6a 00		 push	 0
  04cc5	6a 01		 push	 1
  04cc7	68 f1 00 00 00	 push	 241			; 000000f1H
  04ccc	68 f5 03 00 00	 push	 1013			; 000003f5H

; 5679 : 				break;

  04cd1	eb 0e		 jmp	 SHORT $LN770@PageDialog
$LN287@PageDialog:

; 5673 : 			{
; 5674 : 			case IDC_KB:
; 5675 : 				SendMessage (GetDlgItem (hwndDlg, IDC_KB), BM_SETCHECK, BST_CHECKED, 0);

  04cd3	6a 00		 push	 0
  04cd5	6a 01		 push	 1
  04cd7	68 f1 00 00 00	 push	 241			; 000000f1H
  04cdc	68 f3 03 00 00	 push	 1011			; 000003f3H
$LN770@PageDialog:
  04ce1	53		 push	 ebx
  04ce2	ff d7		 call	 edi
  04ce4	50		 push	 eax
  04ce5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN44@PageDialog:

; 5682 : 				break;
; 5683 : 			}
; 5684 : 
; 5685 : 			VerifySizeAndUpdate (hwndDlg, FALSE);

  04ceb	6a 00		 push	 0
  04ced	53		 push	 ebx
  04cee	e8 00 00 00 00	 call	 _VerifySizeAndUpdate
  04cf3	83 c4 08	 add	 esp, 8
  04cf6	e9 c8 06 00 00	 jmp	 $LN752@PageDialog
$LN285@PageDialog:

; 5686 : 			return 1;
; 5687 : 		}
; 5688 : 
; 5689 : 		if (lw == IDC_HIDVOL_WIZ_MODE_DIRECT && nCurPageNo == HIDDEN_VOL_WIZARD_MODE_PAGE)

  04cfb	b9 0c 04 00 00	 mov	 ecx, 1036		; 0000040cH
  04d00	66 3b f1	 cmp	 si, cx
  04d03	75 71		 jne	 SHORT $LN290@PageDialog
  04d05	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  04d08	75 0f		 jne	 SHORT $LN736@PageDialog

; 5690 : 		{
; 5691 : 			bHiddenVolDirect = TRUE;

  04d0a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bHiddenVolDirect, 1

; 5692 : 			return 1;

  04d14	e9 aa 06 00 00	 jmp	 $LN752@PageDialog
$LN736@PageDialog:

; 5734 : 						GetDlgItem (GetParent (hwndDlg), IDC_NEXT));
; 5735 : 
; 5736 : 					bDeviceTransformModeChoiceMade = FALSE;
; 5737 : 					bInPlaceEncNonSys = FALSE;
; 5738 : 				}
; 5739 : 				return 1;

  04d19	ba 0b 04 00 00	 mov	 edx, 1035		; 0000040bH
$LN294@PageDialog:

; 5740 : 			}
; 5741 : 		}
; 5742 : 
; 5743 : 		if (nCurPageNo == DEVICE_TRANSFORM_MODE_PAGE)

  04d1e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  04d21	0f 85 e8 01 00
	00		 jne	 $LN46@PageDialog

; 5744 : 		{
; 5745 : 			switch (lw)

  04d27	0f b7 ce	 movzx	 ecx, si
  04d2a	81 e9 4d 04 00
	00		 sub	 ecx, 1101		; 0000044dH
  04d30	0f 84 c0 01 00
	00		 je	 $LN299@PageDialog
  04d36	83 e9 01	 sub	 ecx, 1
  04d39	0f 85 d0 01 00
	00		 jne	 $LN46@PageDialog

; 5753 : 
; 5754 : 			case IDC_DEVICE_TRANSFORM_MODE_INPLACE:
; 5755 : 
; 5756 : 				bInPlaceEncNonSys = TRUE;

  04d3f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 1

; 5757 : 				bDeviceTransformModeChoiceMade = TRUE;

  04d49	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDeviceTransformModeChoiceMade@@3HA, 1 ; bDeviceTransformModeChoiceMade

; 5758 : 
; 5759 : 				bHiddenVol = FALSE;

  04d53	89 0d 00 00 00
	00		 mov	 DWORD PTR ?bHiddenVol@@3HC, ecx ; bHiddenVol

; 5760 : 				bHiddenVolDirect = FALSE;

  04d59	89 0d 00 00 00
	00		 mov	 DWORD PTR _bHiddenVolDirect, ecx

; 5761 : 				bHiddenVolHost = FALSE;

  04d5f	89 0d 00 00 00
	00		 mov	 DWORD PTR _bHiddenVolHost, ecx

; 5762 : 				bSparseFileSwitch = FALSE;

  04d65	89 0d 00 00 00
	00		 mov	 DWORD PTR ?bSparseFileSwitch@@3HC, ecx ; bSparseFileSwitch

; 5763 : 				quickFormat = FALSE;

  04d6b	89 0d 00 00 00
	00		 mov	 DWORD PTR ?quickFormat@@3HC, ecx ; quickFormat

; 5764 : 
; 5765 : 				return 1;

  04d71	e9 4d 06 00 00	 jmp	 $LN752@PageDialog
$LN290@PageDialog:

; 5693 : 		}
; 5694 : 
; 5695 : 		if (lw == IDC_HIDVOL_WIZ_MODE_FULL && nCurPageNo == HIDDEN_VOL_WIZARD_MODE_PAGE)

  04d76	ba 0b 04 00 00	 mov	 edx, 1035		; 0000040bH
  04d7b	66 3b f2	 cmp	 si, dx
  04d7e	75 14		 jne	 SHORT $LN291@PageDialog
  04d80	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  04d83	75 99		 jne	 SHORT $LN294@PageDialog
$LN782@PageDialog:

; 5696 : 		{
; 5697 : 			bHiddenVolDirect = FALSE;

  04d85	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHiddenVolDirect, 0

; 5698 : 			return 1;

  04d8f	e9 2f 06 00 00	 jmp	 $LN752@PageDialog
$LN291@PageDialog:

; 5699 : 		}
; 5700 : 
; 5701 : 		if (lw == IDC_SELECT_VOLUME_LOCATION && nCurPageNo == VOLUME_LOCATION_PAGE)

  04d94	b9 0f 04 00 00	 mov	 ecx, 1039		; 0000040fH
  04d99	66 3b f1	 cmp	 si, cx
  04d9c	75 80		 jne	 SHORT $LN294@PageDialog
  04d9e	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  04da1	0f 85 77 ff ff
	ff		 jne	 $LN294@PageDialog

; 5702 : 		{
; 5703 : 			if (!bDevice)

  04da7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  04dae	75 76		 jne	 SHORT $LN293@PageDialog

; 5704 : 			{
; 5705 : 				// Select file
; 5706 : 
; 5707 : 				if (BrowseFiles (hwndDlg, "OPEN_TITLE", szFileName, bHistory, !bHiddenVolDirect, NULL) == FALSE)

  04db0	a1 00 00 00 00	 mov	 eax, DWORD PTR _bHiddenVolDirect
  04db5	f7 d8		 neg	 eax
  04db7	6a 00		 push	 0
  04db9	1b c0		 sbb	 eax, eax
  04dbb	40		 inc	 eax
  04dbc	50		 push	 eax
  04dbd	ff 35 00 00 00
	00		 push	 DWORD PTR _bHistory
  04dc3	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  04dc8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GHEOANHD@OPEN_TITLE?$AA@
  04dcd	53		 push	 ebx
  04dce	e8 00 00 00 00	 call	 _BrowseFiles
  04dd3	83 c4 18	 add	 esp, 24			; 00000018H
  04dd6	85 c0		 test	 eax, eax
  04dd8	0f 84 e5 05 00
	00		 je	 $LN752@PageDialog

; 5708 : 					return 1;
; 5709 : 
; 5710 : 				AddComboItem (GetDlgItem (hwndDlg, IDC_COMBO_BOX), szFileName, bHistory);

  04dde	ff 35 00 00 00
	00		 push	 DWORD PTR _bHistory
  04de4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  04dea	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  04def	68 ea 03 00 00	 push	 1002			; 000003eaH
  04df4	53		 push	 ebx
  04df5	ff d6		 call	 esi
  04df7	50		 push	 eax
  04df8	e8 00 00 00 00	 call	 _AddComboItem
  04dfd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5711 : 
; 5712 : 				EnableDisableFileNext (GetDlgItem (hwndDlg, IDC_COMBO_BOX),

  04e00	68 10 04 00 00	 push	 1040			; 00000410H
  04e05	53		 push	 ebx
  04e06	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  04e0c	50		 push	 eax
  04e0d	ff d6		 call	 esi
  04e0f	50		 push	 eax
  04e10	68 ea 03 00 00	 push	 1002			; 000003eaH
  04e15	53		 push	 ebx
  04e16	ff d6		 call	 esi
  04e18	50		 push	 eax
  04e19	e8 00 00 00 00	 call	 _EnableDisableFileNext
  04e1e	83 c4 08	 add	 esp, 8
  04e21	e9 9d 05 00 00	 jmp	 $LN752@PageDialog
$LN293@PageDialog:

; 5713 : 					GetDlgItem (GetParent (hwndDlg), IDC_NEXT));
; 5714 : 
; 5715 : 				return 1;
; 5716 : 			}
; 5717 : 			else
; 5718 : 			{
; 5719 : 				// Select device
; 5720 : 
; 5721 : 				int nResult = DialogBoxParamW (hInst,

  04e26	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  04e2c	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  04e31	68 00 00 00 00	 push	 OFFSET _RawDevicesDlgProc@16
  04e36	53		 push	 ebx
  04e37	ff d7		 call	 edi
  04e39	50		 push	 eax
  04e3a	68 fe 01 00 00	 push	 510			; 000001feH
  04e3f	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  04e45	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20

; 5722 : 					MAKEINTRESOURCEW (IDD_RAWDEVICES_DLG), GetParent (hwndDlg),
; 5723 : 					(DLGPROC) RawDevicesDlgProc, (LPARAM) & szFileName[0]);
; 5724 : 
; 5725 : 				// Check administrator privileges
; 5726 : 				if (!strstr (szFileName, "Floppy") && !IsAdmin() && !IsUacSupported ())

  04e4b	68 00 00 00 00	 push	 OFFSET ??_C@_06OACPEFAM@Floppy?$AA@
  04e50	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  04e55	8b f0		 mov	 esi, eax
  04e57	e8 00 00 00 00	 call	 _strstr
  04e5c	83 c4 08	 add	 esp, 8
  04e5f	85 c0		 test	 eax, eax
  04e61	75 2f		 jne	 SHORT $LN296@PageDialog
  04e63	e8 00 00 00 00	 call	 _IsAdmin
  04e68	85 c0		 test	 eax, eax
  04e6a	75 26		 jne	 SHORT $LN296@PageDialog
  04e6c	e8 00 00 00 00	 call	 _IsUacSupported
  04e71	85 c0		 test	 eax, eax
  04e73	75 1d		 jne	 SHORT $LN296@PageDialog

; 5727 : 					MessageBoxW (hwndDlg, GetString ("ADMIN_PRIVILEGES_WARN_DEVICES"), lpszTitle, MB_OK|MB_ICONWARNING);

  04e75	6a 30		 push	 48			; 00000030H
  04e77	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  04e7d	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@
  04e82	e8 00 00 00 00	 call	 _GetString
  04e87	83 c4 04	 add	 esp, 4
  04e8a	50		 push	 eax
  04e8b	53		 push	 ebx
  04e8c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$LN296@PageDialog:

; 5728 : 
; 5729 : 				if (nResult == IDOK && strlen (szFileName) > 0)

  04e92	83 fe 01	 cmp	 esi, 1
  04e95	0f 85 28 05 00
	00		 jne	 $LN752@PageDialog
  04e9b	b9 00 00 00 00	 mov	 ecx, OFFSET ?szFileName@@3PADA ; szFileName
  04ea0	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL729@PageDialog:
  04ea3	8a 01		 mov	 al, BYTE PTR [ecx]
  04ea5	41		 inc	 ecx
  04ea6	84 c0		 test	 al, al
  04ea8	75 f9		 jne	 SHORT $LL729@PageDialog
  04eaa	2b ca		 sub	 ecx, edx
  04eac	0f 84 11 05 00
	00		 je	 $LN752@PageDialog

; 5730 : 				{
; 5731 : 					AddComboItem (GetDlgItem (hwndDlg, IDC_COMBO_BOX), szFileName, bHistory);

  04eb2	ff 35 00 00 00
	00		 push	 DWORD PTR _bHistory
  04eb8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  04ebe	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  04ec3	68 ea 03 00 00	 push	 1002			; 000003eaH
  04ec8	53		 push	 ebx
  04ec9	ff d6		 call	 esi
  04ecb	50		 push	 eax
  04ecc	e8 00 00 00 00	 call	 _AddComboItem
  04ed1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5732 : 
; 5733 : 					EnableDisableFileNext (GetDlgItem (hwndDlg, IDC_COMBO_BOX),

  04ed4	68 10 04 00 00	 push	 1040			; 00000410H
  04ed9	53		 push	 ebx
  04eda	ff d7		 call	 edi
  04edc	50		 push	 eax
  04edd	ff d6		 call	 esi
  04edf	50		 push	 eax
  04ee0	68 ea 03 00 00	 push	 1002			; 000003eaH
  04ee5	53		 push	 ebx
  04ee6	ff d6		 call	 esi
  04ee8	50		 push	 eax
  04ee9	e8 00 00 00 00	 call	 _EnableDisableFileNext
  04eee	83 c4 08	 add	 esp, 8

; 5734 : 						GetDlgItem (GetParent (hwndDlg), IDC_NEXT));
; 5735 : 
; 5736 : 					bDeviceTransformModeChoiceMade = FALSE;
; 5737 : 					bInPlaceEncNonSys = FALSE;
; 5738 : 				}
; 5739 : 				return 1;

  04ef1	e9 3e f9 ff ff	 jmp	 $LN781@PageDialog
$LN299@PageDialog:

; 5746 : 			{
; 5747 : 			case IDC_DEVICE_TRANSFORM_MODE_FORMAT:
; 5748 : 
; 5749 : 				bInPlaceEncNonSys = FALSE;

  04ef6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSys, 0

; 5750 : 				bDeviceTransformModeChoiceMade = TRUE;

  04f00	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDeviceTransformModeChoiceMade@@3HA, 1 ; bDeviceTransformModeChoiceMade

; 5751 : 
; 5752 : 				return 1;

  04f0a	e9 b4 04 00 00	 jmp	 $LN752@PageDialog
$LN46@PageDialog:

; 5766 : 			}
; 5767 : 		}
; 5768 : 
; 5769 : 		if (lw == IDC_HIDVOL_WIZ_MODE_FULL && nCurPageNo == HIDDEN_VOL_WIZARD_MODE_PAGE)

  04f0f	66 3b f2	 cmp	 si, dx
  04f12	75 09		 jne	 SHORT $LN301@PageDialog
  04f14	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  04f17	0f 84 68 fe ff
	ff		 je	 $LN782@PageDialog
$LN301@PageDialog:

; 5770 : 		{
; 5771 : 			bHiddenVolDirect = FALSE;
; 5772 : 			return 1;
; 5773 : 		}
; 5774 : 			
; 5775 : 		if (hw == CBN_SELCHANGE && nCurPageNo == CIPHER_PAGE)

  04f1d	66 83 ff 01	 cmp	 di, 1
  04f21	0f 85 ad 00 00
	00		 jne	 $LN302@PageDialog
  04f27	83 f8 12	 cmp	 eax, 18			; 00000012H
  04f2a	0f 85 a4 00 00
	00		 jne	 $LN302@PageDialog

; 5776 : 		{
; 5777 : 			switch (lw)

  04f30	0f b7 c6	 movzx	 eax, si
  04f33	2d ea 03 00 00	 sub	 eax, 1002		; 000003eaH
  04f38	0f 84 8b 00 00
	00		 je	 $LN303@PageDialog
  04f3e	83 e8 06	 sub	 eax, 6
  04f41	0f 85 7c 04 00
	00		 jne	 $LN752@PageDialog

; 5781 : 				break;
; 5782 : 
; 5783 : 			case IDC_COMBO_BOX_HASH_ALGO:
; 5784 : 				if (SysEncInEffect ()
; 5785 : 					&& SendMessage (GetDlgItem (hwndDlg, IDC_COMBO_BOX_HASH_ALGO), CB_GETITEMDATA, 

  04f47	e8 00 00 00 00	 call	 _SysEncInEffect
  04f4c	85 c0		 test	 eax, eax
  04f4e	0f 84 6f 04 00
	00		 je	 $LN752@PageDialog
  04f54	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  04f5a	6a 00		 push	 0
  04f5c	6a 00		 push	 0
  04f5e	6a 00		 push	 0
  04f60	68 47 01 00 00	 push	 327			; 00000147H
  04f65	68 f0 03 00 00	 push	 1008			; 000003f0H
  04f6a	53		 push	 ebx
  04f6b	ff d7		 call	 edi
  04f6d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  04f73	50		 push	 eax
  04f74	ff d6		 call	 esi
  04f76	50		 push	 eax
  04f77	68 50 01 00 00	 push	 336			; 00000150H
  04f7c	68 f0 03 00 00	 push	 1008			; 000003f0H
  04f81	53		 push	 ebx
  04f82	ff d7		 call	 edi
  04f84	50		 push	 eax
  04f85	ff d6		 call	 esi
  04f87	83 f8 01	 cmp	 eax, 1
  04f8a	0f 84 33 04 00
	00		 je	 $LN752@PageDialog

; 5786 : 					SendMessage (GetDlgItem (hwndDlg, IDC_COMBO_BOX_HASH_ALGO), CB_GETCURSEL, 0, 0), 0) 
; 5787 : 					!= DEFAULT_HASH_ALGORITHM_BOOT)
; 5788 : 				{
; 5789 : 					hash_algo = DEFAULT_HASH_ALGORITHM_BOOT;
; 5790 : 					RandSetHashFunction (DEFAULT_HASH_ALGORITHM_BOOT);

  04f90	6a 01		 push	 1
  04f92	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?hash_algo@@3HA, 1 ; hash_algo
  04f9c	e8 00 00 00 00	 call	 _RandSetHashFunction

; 5791 : 					Info ("ALGO_NOT_SUPPORTED_FOR_SYS_ENCRYPTION");

  04fa1	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@FCGANOF@ALGO_NOT_SUPPORTED_FOR_SYS_ENCRY@
  04fa6	e8 00 00 00 00	 call	 _Info
  04fab	83 c4 08	 add	 esp, 8

; 5792 : 					SelectAlgo (GetDlgItem (hwndDlg, IDC_COMBO_BOX_HASH_ALGO), &hash_algo);

  04fae	68 00 00 00 00	 push	 OFFSET ?hash_algo@@3HA	; hash_algo
  04fb3	68 f0 03 00 00	 push	 1008			; 000003f0H
  04fb8	53		 push	 ebx
  04fb9	ff d7		 call	 edi
  04fbb	50		 push	 eax
  04fbc	e8 00 00 00 00	 call	 _SelectAlgo
  04fc1	83 c4 08	 add	 esp, 8
  04fc4	e9 fa 03 00 00	 jmp	 $LN752@PageDialog
$LN303@PageDialog:

; 5778 : 			{
; 5779 : 			case IDC_COMBO_BOX:
; 5780 : 				ComboSelChangeEA (hwndDlg);

  04fc9	53		 push	 ebx
  04fca	e8 00 00 00 00	 call	 _ComboSelChangeEA

; 5793 : 				}
; 5794 : 				break;
; 5795 : 			}
; 5796 : 			return 1;

  04fcf	e9 ec 03 00 00	 jmp	 $LN767@PageDialog
$LN302@PageDialog:

; 5797 : 
; 5798 : 		}
; 5799 : 
; 5800 : 		if (lw == IDC_QUICKFORMAT && IsButtonChecked (GetDlgItem (hCurPage, IDC_QUICKFORMAT)))

  04fd4	b9 ff 03 00 00	 mov	 ecx, 1023		; 000003ffH
  04fd9	66 3b f1	 cmp	 si, cx
  04fdc	0f 85 fa 00 00
	00		 jne	 $LN306@PageDialog
  04fe2	51		 push	 ecx
  04fe3	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  04fe9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  04fef	50		 push	 eax
  04ff0	e8 00 00 00 00	 call	 _IsButtonChecked
  04ff5	83 c4 04	 add	 esp, 4
  04ff8	85 c0		 test	 eax, eax
  04ffa	74 3b		 je	 SHORT $LN738@PageDialog

; 5801 : 		{
; 5802 : 			if (bSparseFileSwitch)

  04ffc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bSparseFileSwitch@@3HC, 0 ; bSparseFileSwitch
  05003	74 07		 je	 SHORT $LN307@PageDialog

; 5803 : 			{
; 5804 : 				if (AskWarnYesNo("CONFIRM_SPARSE_FILE") == IDNO)

  05005	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NLHJLKOB@CONFIRM_SPARSE_FILE?$AA@

; 5805 : 					SetCheckBox (hwndDlg, IDC_QUICKFORMAT, FALSE); 
; 5806 : 			}
; 5807 : 			else

  0500a	eb 05		 jmp	 SHORT $LN772@PageDialog
$LN307@PageDialog:

; 5808 : 			{
; 5809 : 				if (AskWarnYesNo("WARN_QUICK_FORMAT") == IDNO)

  0500c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@LJAPGPK@WARN_QUICK_FORMAT?$AA@
$LN772@PageDialog:
  05011	e8 00 00 00 00	 call	 _AskWarnYesNo
  05016	83 c4 04	 add	 esp, 4
  05019	83 f8 07	 cmp	 eax, 7
  0501c	0f 85 a1 03 00
	00		 jne	 $LN752@PageDialog

; 5810 : 					SetCheckBox (hwndDlg, IDC_QUICKFORMAT, FALSE); 

  05022	6a 00		 push	 0
  05024	68 ff 03 00 00	 push	 1023			; 000003ffH
  05029	53		 push	 ebx
  0502a	e8 00 00 00 00	 call	 _SetCheckBox
  0502f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5811 : 			}
; 5812 : 			return 1;

  05032	e9 8c 03 00 00	 jmp	 $LN752@PageDialog
$LN738@PageDialog:

; 5847 : 			return 1;

  05037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
$LN315@PageDialog:

; 5848 : 		}
; 5849 : 
; 5850 : 		if (nCurPageNo == SYSENC_RESCUE_DISK_CREATION_PAGE)

  0503c	83 f8 19	 cmp	 eax, 25			; 00000019H
  0503f	0f 85 6a 02 00
	00		 jne	 $LN319@PageDialog

; 5851 : 		{
; 5852 : 			if (lw == IDC_BROWSE)

  05045	b8 ed 03 00 00	 mov	 eax, 1005		; 000003edH
  0504a	66 3b f0	 cmp	 si, ax
  0504d	0f 85 33 02 00
	00		 jne	 $LN317@PageDialog

; 5853 : 			{
; 5854 : 				char tmpszRescueDiskISO [GST_MAX_PATH+1];
; 5855 : 
; 5856 : 				if (!BrowseFiles (hwndDlg, "OPEN_TITLE", tmpszRescueDiskISO, FALSE, TRUE, NULL))

  05053	6a 00		 push	 0
  05055	6a 01		 push	 1
  05057	6a 00		 push	 0
  05059	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _tmpszRescueDiskISO$29[ebp]
  0505f	50		 push	 eax
  05060	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GHEOANHD@OPEN_TITLE?$AA@
  05065	53		 push	 ebx
  05066	e8 00 00 00 00	 call	 _BrowseFiles
  0506b	83 c4 18	 add	 esp, 24			; 00000018H
  0506e	85 c0		 test	 eax, eax
  05070	0f 84 4d 03 00
	00		 je	 $LN752@PageDialog

; 5857 : 					return 1;
; 5858 : 
; 5859 : 				strcpy (szRescueDiskISO, tmpszRescueDiskISO);

  05076	33 c9		 xor	 ecx, ecx
  05078	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL369@PageDialog:
  05080	8a 84 0d 34 fd
	ff ff		 mov	 al, BYTE PTR _tmpszRescueDiskISO$29[ebp+ecx]
  05087	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0508a	88 81 ff ff ff
	ff		 mov	 BYTE PTR ?szRescueDiskISO@@3PADA[ecx-1], al
  05090	84 c0		 test	 al, al
  05092	75 ec		 jne	 SHORT $LL369@PageDialog

; 5860 : 
; 5861 : 				SetDlgItemText (hwndDlg, IDC_RESCUE_DISK_ISO_PATH, szRescueDiskISO);

  05094	68 00 00 00 00	 push	 OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  05099	68 e9 03 00 00	 push	 1001			; 000003e9H
  0509e	53		 push	 ebx
  0509f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextA@12
$LN788@PageDialog:

; 5862 : 				EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), (GetWindowTextLength (GetDlgItem (hwndDlg, IDC_RESCUE_DISK_ISO_PATH)) > 1));

  050a5	68 e9 03 00 00	 push	 1001			; 000003e9H
  050aa	53		 push	 ebx
  050ab	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  050b1	ff d3		 call	 ebx
  050b3	50		 push	 eax
  050b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  050ba	33 c9		 xor	 ecx, ecx
  050bc	83 f8 01	 cmp	 eax, 1
  050bf	0f 9f c1	 setg	 cl
  050c2	51		 push	 ecx
  050c3	68 10 04 00 00	 push	 1040			; 00000410H
  050c8	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  050ce	ff d3		 call	 ebx
  050d0	50		 push	 eax
  050d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  050d7	e9 e7 02 00 00	 jmp	 $LN752@PageDialog
$LN306@PageDialog:

; 5813 : 		}
; 5814 : 
; 5815 : 		if (lw == IDC_FILESYS && hw == CBN_SELCHANGE)

  050dc	b9 05 04 00 00	 mov	 ecx, 1029		; 00000405H
  050e1	66 3b f1	 cmp	 si, cx
  050e4	75 4d		 jne	 SHORT $LN311@PageDialog
  050e6	66 83 ff 01	 cmp	 di, 1
  050ea	0f 85 4c ff ff
	ff		 jne	 $LN315@PageDialog

; 5816 : 		{
; 5817 : 			fileSystem = SendMessage (GetDlgItem (hCurPage, IDC_FILESYS), CB_GETITEMDATA,

  050f0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  050f6	6a 00		 push	 0
  050f8	6a 00		 push	 0
  050fa	6a 00		 push	 0
  050fc	68 47 01 00 00	 push	 327			; 00000147H
  05101	51		 push	 ecx
  05102	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  05108	ff d7		 call	 edi
  0510a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  05110	50		 push	 eax
  05111	ff d6		 call	 esi
  05113	50		 push	 eax
  05114	68 50 01 00 00	 push	 336			; 00000150H
  05119	68 05 04 00 00	 push	 1029			; 00000405H
  0511e	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  05124	ff d7		 call	 edi
  05126	50		 push	 eax
  05127	ff d6		 call	 esi
  05129	a3 00 00 00 00	 mov	 DWORD PTR ?fileSystem@@3HC, eax ; fileSystem

; 5818 : 				SendMessage (GetDlgItem (hCurPage, IDC_FILESYS), CB_GETCURSEL, 0, 0) , 0);
; 5819 : 
; 5820 : 			return 1;

  0512e	e9 90 02 00 00	 jmp	 $LN752@PageDialog
$LN311@PageDialog:

; 5821 : 		}
; 5822 : 
; 5823 : 		if (lw == IDC_SHOW_KEYS && nCurPageNo == FORMAT_PAGE)

  05133	b9 06 04 00 00	 mov	 ecx, 1030		; 00000406H
  05138	66 3b f1	 cmp	 si, cx
  0513b	0f 85 98 00 00
	00		 jne	 $LN312@PageDialog
  05141	83 f8 26	 cmp	 eax, 38			; 00000026H
  05144	0f 85 f2 fe ff
	ff		 jne	 $LN315@PageDialog

; 5824 : 		{
; 5825 : 			showKeys = IsButtonChecked (GetDlgItem (hCurPage, IDC_SHOW_KEYS));

  0514a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  05150	51		 push	 ecx
  05151	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  05157	ff d7		 call	 edi
  05159	50		 push	 eax
  0515a	e8 00 00 00 00	 call	 _IsButtonChecked
  0515f	83 c4 04	 add	 esp, 4
  05162	a3 00 00 00 00	 mov	 DWORD PTR _showKeys, eax

; 5826 : 
; 5827 : 			SetWindowText (GetDlgItem (hCurPage, IDC_RANDOM_BYTES), showKeys ? "                                                                              " : "********************************                                              ");

  05167	85 c0		 test	 eax, eax
  05169	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EP@NPBFJCJA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
  0516e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0EP@HCFFCIHD@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
  05173	0f 44 ca	 cmove	 ecx, edx
  05176	51		 push	 ecx
  05177	68 fc 03 00 00	 push	 1020			; 000003fcH
  0517c	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  05182	ff d7		 call	 edi
  05184	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  0518a	50		 push	 eax
  0518b	ff d6		 call	 esi

; 5828 : 			SetWindowText (GetDlgItem (hCurPage, IDC_HEADER_KEY), showKeys ? "" : "********************************                                              ");

  0518d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _showKeys, 0
  05194	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  05199	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0EP@NPBFJCJA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
  0519e	8b c3		 mov	 eax, ebx
  051a0	0f 44 c1	 cmove	 eax, ecx
  051a3	50		 push	 eax
  051a4	68 f9 03 00 00	 push	 1017			; 000003f9H
  051a9	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  051af	ff d7		 call	 edi
  051b1	50		 push	 eax
  051b2	ff d6		 call	 esi

; 5829 : 			SetWindowText (GetDlgItem (hCurPage, IDC_DISK_KEY), showKeys ? "" : "********************************                                              ");

  051b4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _showKeys, 0
  051bb	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EP@NPBFJCJA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
  051c0	0f 44 d8	 cmove	 ebx, eax
  051c3	53		 push	 ebx
  051c4	68 fb 03 00 00	 push	 1019			; 000003fbH
  051c9	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  051cf	ff d7		 call	 edi
  051d1	50		 push	 eax
  051d2	ff d6		 call	 esi

; 5830 : 			return 1;

  051d4	e9 ea 01 00 00	 jmp	 $LN752@PageDialog
$LN312@PageDialog:

; 5831 : 		}
; 5832 : 		
; 5833 : 		if (lw == IDC_DISPLAY_POOL_CONTENTS 
; 5834 : 			&& (nCurPageNo == SYSENC_COLLECTING_RANDOM_DATA_PAGE || nCurPageNo == NONSYS_INPLACE_ENC_RAND_DATA_PAGE))

  051d9	b9 da 13 00 00	 mov	 ecx, 5082		; 000013daH
  051de	66 3b f1	 cmp	 si, cx
  051e1	75 3e		 jne	 SHORT $LN313@PageDialog
  051e3	83 f8 17	 cmp	 eax, 23			; 00000017H
  051e6	74 09		 je	 SHORT $LN314@PageDialog
  051e8	83 f8 22	 cmp	 eax, 34			; 00000022H
  051eb	0f 85 4b fe ff
	ff		 jne	 $LN315@PageDialog
$LN314@PageDialog:

; 5835 : 		{
; 5836 : 			showKeys = IsButtonChecked (GetDlgItem (hCurPage, IDC_DISPLAY_POOL_CONTENTS));

  051f1	68 da 13 00 00	 push	 5082			; 000013daH
  051f6	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  051fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  05202	50		 push	 eax
  05203	e8 00 00 00 00	 call	 _IsButtonChecked

; 5837 : 			DisplayRandPool (hRandPoolSys, showKeys);

  05208	50		 push	 eax
  05209	a3 00 00 00 00	 mov	 DWORD PTR _showKeys, eax
  0520e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hRandPoolSys@@3RAUHWND__@@A ; hRandPoolSys
  05213	50		 push	 eax
  05214	e8 00 00 00 00	 call	 _DisplayRandPool
  05219	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5838 : 
; 5839 : 			return 1;

  0521c	e9 a2 01 00 00	 jmp	 $LN752@PageDialog
$LN313@PageDialog:

; 5840 : 		}
; 5841 : 
; 5842 : 		if (lw == IDC_DISPLAY_KEYS && nCurPageNo == SYSENC_KEYS_GEN_PAGE)

  05221	b9 40 04 00 00	 mov	 ecx, 1088		; 00000440H
  05226	66 3b f1	 cmp	 si, cx
  05229	0f 85 0d fe ff
	ff		 jne	 $LN315@PageDialog
  0522f	83 f8 18	 cmp	 eax, 24			; 00000018H
  05232	0f 85 04 fe ff
	ff		 jne	 $LN315@PageDialog

; 5843 : 		{
; 5844 : 			showKeys = IsButtonChecked (GetDlgItem (hCurPage, IDC_DISPLAY_KEYS));

  05238	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  0523e	51		 push	 ecx
  0523f	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  05245	ff d6		 call	 esi
  05247	50		 push	 eax
  05248	e8 00 00 00 00	 call	 _IsButtonChecked
  0524d	83 c4 04	 add	 esp, 4
  05250	a3 00 00 00 00	 mov	 DWORD PTR _showKeys, eax

; 5845 : 
; 5846 : 			DisplayPortionsOfKeys (GetDlgItem (hwndDlg, IDC_HEADER_KEY), GetDlgItem (hwndDlg, IDC_DISK_KEY), HeaderKeyGUIView, MasterKeyGUIView, !showKeys);

  05255	33 c9		 xor	 ecx, ecx
  05257	85 c0		 test	 eax, eax
  05259	0f 94 c1	 sete	 cl
  0525c	51		 push	 ecx
  0525d	68 00 00 00 00	 push	 OFFSET _MasterKeyGUIView
  05262	68 00 00 00 00	 push	 OFFSET _HeaderKeyGUIView
  05267	68 fb 03 00 00	 push	 1019			; 000003fbH
  0526c	53		 push	 ebx
  0526d	ff d6		 call	 esi
  0526f	50		 push	 eax
  05270	68 f9 03 00 00	 push	 1017			; 000003f9H
  05275	53		 push	 ebx
  05276	ff d6		 call	 esi
  05278	50		 push	 eax
  05279	e8 00 00 00 00	 call	 _DisplayPortionsOfKeys
  0527e	83 c4 14	 add	 esp, 20			; 00000014H

; 5847 : 			return 1;

  05281	e9 3d 01 00 00	 jmp	 $LN752@PageDialog
$LN317@PageDialog:

; 5863 : 				return 1;
; 5864 : 			}
; 5865 : 
; 5866 : 			if ( hw == EN_CHANGE )

  05286	b8 00 03 00 00	 mov	 eax, 768		; 00000300H
  0528b	66 3b f8	 cmp	 di, ax
  0528e	0f 85 d2 00 00
	00		 jne	 $LN50@PageDialog

; 5867 : 			{
; 5868 : 				GetDlgItemText (hwndDlg, IDC_RESCUE_DISK_ISO_PATH, szRescueDiskISO, sizeof(szRescueDiskISO));

  05294	68 05 01 00 00	 push	 261			; 00000105H
  05299	68 00 00 00 00	 push	 OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  0529e	68 e9 03 00 00	 push	 1001			; 000003e9H
  052a3	53		 push	 ebx
  052a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemTextA@16

; 5869 : 				EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), (GetWindowTextLength (GetDlgItem (hwndDlg, IDC_RESCUE_DISK_ISO_PATH)) > 1));
; 5870 : 				return 1;

  052aa	e9 f6 fd ff ff	 jmp	 $LN788@PageDialog
$LN319@PageDialog:

; 5871 : 			}
; 5872 : 		}
; 5873 : 
; 5874 : 		if (nCurPageNo == SYSENC_RESCUE_DISK_BURN_PAGE && lw == IDC_DOWNLOAD_CD_BURN_SOFTWARE)

  052af	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  052b2	75 2e		 jne	 SHORT $LN320@PageDialog
  052b4	b8 3a 04 00 00	 mov	 eax, 1082		; 0000043aH
  052b9	66 3b f0	 cmp	 si, ax
  052bc	0f 85 a4 00 00
	00		 jne	 $LN50@PageDialog

; 5875 : 		{
; 5876 : 			if (IsWindowsIsoBurnerAvailable())

  052c2	e8 00 00 00 00	 call	 _IsWindowsIsoBurnerAvailable
  052c7	85 c0		 test	 eax, eax
  052c9	0f 84 8e ed ff
	ff		 je	 $LN211@PageDialog

; 5877 : 				LaunchWindowsIsoBurner (hwndDlg, szRescueDiskISO);

  052cf	68 00 00 00 00	 push	 OFFSET ?szRescueDiskISO@@3PADA ; szRescueDiskISO
  052d4	53		 push	 ebx
  052d5	e8 00 00 00 00	 call	 _LaunchWindowsIsoBurner
  052da	83 c4 08	 add	 esp, 8
  052dd	e9 e1 00 00 00	 jmp	 $LN752@PageDialog
$LN320@PageDialog:

; 5878 : 			else
; 5879 : 				//Applink ("isoburning", TRUE, "");
; 5880 : 				Extlink("http://www.gostcrypt.org/redirect.php?a=2");
; 5881 : 
; 5882 : 			return 1;
; 5883 : 		}
; 5884 : 
; 5885 : 		if ((nCurPageNo == SYSENC_WIPE_MODE_PAGE 
; 5886 : 			|| nCurPageNo == NONSYS_INPLACE_ENC_WIPE_MODE_PAGE 
; 5887 : 			|| nCurPageNo == DEVICE_WIPE_MODE_PAGE)
; 5888 : 			&& hw == CBN_SELCHANGE)

  052e2	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  052e5	74 0a		 je	 SHORT $LN324@PageDialog
  052e7	83 f8 23	 cmp	 eax, 35			; 00000023H
  052ea	74 05		 je	 SHORT $LN324@PageDialog
  052ec	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  052ef	75 4d		 jne	 SHORT $LN323@PageDialog
$LN324@PageDialog:
  052f1	66 83 ff 01	 cmp	 di, 1
  052f5	75 47		 jne	 SHORT $LN323@PageDialog

; 5889 : 		{
; 5890 : 			nWipeMode = (WipeAlgorithmId) SendMessage (GetDlgItem (hCurPage, IDC_WIPE_MODE),

  052f7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  052fd	6a 00		 push	 0
  052ff	6a 00		 push	 0
  05301	6a 00		 push	 0
  05303	68 47 01 00 00	 push	 327			; 00000147H
  05308	68 3d 04 00 00	 push	 1085			; 0000043dH
  0530d	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  05313	ff d3		 call	 ebx
  05315	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  0531b	50		 push	 eax
  0531c	ff d6		 call	 esi
  0531e	50		 push	 eax
  0531f	68 50 01 00 00	 push	 336			; 00000150H
  05324	68 3d 04 00 00	 push	 1085			; 0000043dH
  05329	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0532f	ff d3		 call	 ebx
  05331	50		 push	 eax
  05332	ff d6		 call	 esi
  05334	a3 00 00 00 00	 mov	 DWORD PTR _nWipeMode, eax
  05339	e9 85 00 00 00	 jmp	 $LN752@PageDialog
$LN323@PageDialog:

; 5891 : 				CB_GETITEMDATA, 
; 5892 : 				SendMessage (GetDlgItem (hCurPage, IDC_WIPE_MODE), CB_GETCURSEL, 0, 0),
; 5893 : 				0);
; 5894 : 
; 5895 : 			return 1;
; 5896 : 		}
; 5897 : 
; 5898 : 		if (nCurPageNo == DEVICE_WIPE_PAGE)

  0533e	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  05341	75 23		 jne	 SHORT $LN50@PageDialog

; 5899 : 		{
; 5900 : 			switch (lw)

  05343	b8 f8 03 00 00	 mov	 eax, 1016		; 000003f8H
  05348	66 3b f0	 cmp	 si, ax
  0534b	75 19		 jne	 SHORT $LN50@PageDialog

; 5901 : 			{
; 5902 : 			case IDC_ABORT_BUTTON:
; 5903 : 
; 5904 : 				if (AskWarnNoYes ("CONFIRM_WIPE_ABORT") == IDYES)

  0534d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EJEDNFIG@CONFIRM_WIPE_ABORT?$AA@
  05352	e8 00 00 00 00	 call	 _AskWarnNoYes
  05357	83 c4 04	 add	 esp, 4
  0535a	83 f8 06	 cmp	 eax, 6
  0535d	75 64		 jne	 SHORT $LN752@PageDialog

; 5905 : 					WipeAbort();

  0535f	e8 00 00 00 00	 call	 _WipeAbort

; 5906 : 
; 5907 : 				return 1;

  05364	eb 5d		 jmp	 SHORT $LN752@PageDialog
$LN50@PageDialog:

; 5908 : 			}
; 5909 : 		}
; 5910 : 
; 5911 : 		if (lw == IDC_NO_HISTORY)

  05366	b8 f4 03 00 00	 mov	 eax, 1012		; 000003f4H
  0536b	66 3b f0	 cmp	 si, ax
  0536e	0f 85 65 b4 ff
	ff		 jne	 $LN384@PageDialog

; 5912 : 		{
; 5913 : 			if (!(bHistory = !IsButtonChecked (GetDlgItem (hCurPage, IDC_NO_HISTORY))))

  05374	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  0537a	50		 push	 eax
  0537b	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  05381	ff d3		 call	 ebx
  05383	50		 push	 eax
  05384	e8 00 00 00 00	 call	 _IsButtonChecked
  05389	83 c4 04	 add	 esp, 4
  0538c	f7 d8		 neg	 eax
  0538e	1b c0		 sbb	 eax, eax
  05390	83 c0 01	 add	 eax, 1
  05393	a3 00 00 00 00	 mov	 DWORD PTR _bHistory, eax
  05398	75 29		 jne	 SHORT $LN752@PageDialog

; 5914 : 				ClearHistory (GetDlgItem (hCurPage, IDC_COMBO_BOX));

  0539a	68 ea 03 00 00	 push	 1002			; 000003eaH
  0539f	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  053a5	ff d3		 call	 ebx
  053a7	50		 push	 eax
  053a8	e8 00 00 00 00	 call	 _ClearHistory

; 5915 : 
; 5916 : 			return 1;

  053ad	eb 11		 jmp	 SHORT $LN767@PageDialog
$LN370@PageDialog:

; 3851 : 
; 3852 : 	hCurPage = hwndDlg;
; 3853 : 
; 3854 : 	switch (uMsg)

  053af	3d 31 81 00 00	 cmp	 eax, 33073		; 00008131H
  053b4	0f 85 1f b4 ff
	ff		 jne	 $LN384@PageDialog

; 5179 : 		return 1;
; 5180 : 
; 5181 : 	case GST_APPMSG_PERFORM_POST_SYSENC_WMINIT_TASKS:
; 5182 : 		AfterSysEncProgressWMInitTasks (hwndDlg);

  053ba	53		 push	 ebx
  053bb	e8 00 00 00 00	 call	 _AfterSysEncProgressWMInitTasks
$LN767@PageDialog:
  053c0	83 c4 04	 add	 esp, 4
$LN752@PageDialog:

; 5183 : 		return 1;

  053c3	b8 01 00 00 00	 mov	 eax, 1
$LN1@PageDialog:

; 5917 : 		}
; 5918 : 
; 5919 : 		return 0;
; 5920 : 	}
; 5921 : 
; 5922 : 	return 0;
; 5923 : }

  053c8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  053cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  053d2	59		 pop	 ecx
  053d3	5f		 pop	 edi
  053d4	5e		 pop	 esi
  053d5	5b		 pop	 ebx
  053d6	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  053d9	33 cd		 xor	 ecx, ebp
  053db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  053e0	8b e5		 mov	 esp, ebp
  053e2	5d		 pop	 ebp
  053e3	c2 10 00	 ret	 16			; 00000010H
  053e6	66 90		 npad	 2
$LN789@PageDialog:
  053e8	00 00 00 00	 DD	 $LN53@PageDialog
  053ec	00 00 00 00	 DD	 $LN54@PageDialog
  053f0	00 00 00 00	 DD	 $LN55@PageDialog
  053f4	00 00 00 00	 DD	 $LN56@PageDialog
  053f8	00 00 00 00	 DD	 $LN57@PageDialog
  053fc	00 00 00 00	 DD	 $LN58@PageDialog
  05400	00 00 00 00	 DD	 $LN63@PageDialog
  05404	00 00 00 00	 DD	 $LN64@PageDialog
  05408	00 00 00 00	 DD	 $LN65@PageDialog
  0540c	00 00 00 00	 DD	 $LN70@PageDialog
  05410	00 00 00 00	 DD	 $LN71@PageDialog
  05414	00 00 00 00	 DD	 $LN72@PageDialog
  05418	00 00 00 00	 DD	 $LN73@PageDialog
  0541c	00 00 00 00	 DD	 $LN74@PageDialog
  05420	00 00 00 00	 DD	 $LN75@PageDialog
  05424	00 00 00 00	 DD	 $LN80@PageDialog
  05428	00 00 00 00	 DD	 $LN83@PageDialog
  0542c	00 00 00 00	 DD	 $LN86@PageDialog
  05430	00 00 00 00	 DD	 $LN91@PageDialog
  05434	00 00 00 00	 DD	 $LN98@PageDialog
  05438	00 00 00 00	 DD	 $LN114@PageDialog
  0543c	00 00 00 00	 DD	 $LN115@PageDialog
  05440	00 00 00 00	 DD	 $LN130@PageDialog
  05444	00 00 00 00	 DD	 $LN134@PageDialog
  05448	00 00 00 00	 DD	 $LN135@PageDialog
  0544c	00 00 00 00	 DD	 $LN136@PageDialog
  05450	00 00 00 00	 DD	 $LN137@PageDialog
  05454	00 00 00 00	 DD	 $LN140@PageDialog
  05458	00 00 00 00	 DD	 $LN141@PageDialog
  0545c	00 00 00 00	 DD	 $LN143@PageDialog
  05460	00 00 00 00	 DD	 $LN147@PageDialog
  05464	00 00 00 00	 DD	 $LN148@PageDialog
  05468	00 00 00 00	 DD	 $LN114@PageDialog
  0546c	00 00 00 00	 DD	 $LN154@PageDialog
  05470	00 00 00 00	 DD	 $LN134@PageDialog
  05474	00 00 00 00	 DD	 $LN141@PageDialog
  05478	00 00 00 00	 DD	 $LN155@PageDialog
  0547c	00 00 00 00	 DD	 $LN158@PageDialog
  05480	00 00 00 00	 DD	 $LN159@PageDialog
  05484	00 00 00 00	 DD	 $LN184@PageDialog
  05488	00 00 00 00	 DD	 $LN193@PageDialog
  0548c	00 00 00 00	 DD	 $LN196@PageDialog
  05490	00 00 00 00	 DD	 $LN197@PageDialog
  05494	00 00 00 00	 DD	 $LN201@PageDialog
$LN790@PageDialog:
  05498	00 00 00 00	 DD	 $LN208@PageDialog
  0549c	00 00 00 00	 DD	 $LN209@PageDialog
  054a0	00 00 00 00	 DD	 $LN210@PageDialog
  054a4	00 00 00 00	 DD	 $LN211@PageDialog
  054a8	00 00 00 00	 DD	 $LN217@PageDialog
$LN719@PageDialog:
  054ac	00		 DB	 0
  054ad	01		 DB	 1
  054ae	02		 DB	 2
  054af	04		 DB	 4
  054b0	04		 DB	 4
  054b1	04		 DB	 4
  054b2	04		 DB	 4
  054b3	04		 DB	 4
  054b4	04		 DB	 4
  054b5	04		 DB	 4
  054b6	04		 DB	 4
  054b7	04		 DB	 4
  054b8	03		 DB	 3
  054b9	04		 DB	 4
  054ba	03		 DB	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_PageDialogProc@16$7:
  00000	8d 8d 38 eb fe
	ff		 lea	 ecx, DWORD PTR _$S1$6[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$_PageDialogProc@16$18:
  0000b	8b 85 68 eb fe
	ff		 mov	 eax, DWORD PTR $T11[ebp]
  00011	83 e0 01	 and	 eax, 1
  00014	0f 84 12 00 00
	00		 je	 $LN503@PageDialog
  0001a	83 a5 68 eb fe
	ff fe		 and	 DWORD PTR $T11[ebp], -2	; fffffffeH
  00021	8d 8d e4 ea fe
	ff		 lea	 ecx, DWORD PTR _s$2[ebp+104]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN503@PageDialog:
  0002c	c3		 ret	 0
__unwindfunclet$_PageDialogProc@16$22:
  0002d	8d 8d 94 ea fe
	ff		 lea	 ecx, DWORD PTR _s$2[ebp+24]
  00033	e9 00 00 00 00	 jmp	 ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$_PageDialogProc@16$19:
  00038	8d 8d 9c ea fe
	ff		 lea	 ecx, DWORD PTR _s$2[ebp+32]
  0003e	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$_PageDialogProc@16$26:
  00043	8b 8d 78 eb fe
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$_PageDialogProc@16$8:
  0004e	8d 8d 7c ea fe
	ff		 lea	 ecx, DWORD PTR _s$2[ebp]
  00054	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
__unwindfunclet$_PageDialogProc@16$10:
  00059	8d 8d 80 ed fe
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  0005f	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$_PageDialogProc@16:
  00064	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00068	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0006b	8b 8a 78 ea fe
	ff		 mov	 ecx, DWORD PTR [edx-71048]
  00071	33 c8		 xor	 ecx, eax
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0007b	33 c8		 xor	 ecx, eax
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_PageDialogProc@16
  00087	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_PageDialogProc@16 ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _HandleOldAssignedDriveLetter
_TEXT	SEGMENT
_szTmp$1 = -16908					; size = 16384
_deviceName$2 = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_HandleOldAssignedDriveLetter PROC			; COMDAT

; 3785 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 0c 42 00 00	 mov	 eax, 16908		; 0000420cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3786 : 	if (bDevice)

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  0001e	0f 84 93 00 00
	00		 je	 $LN3@HandleOldA

; 3787 : 	{
; 3788 : 		// Handle assigned drive letter (if any)
; 3789 : 
; 3790 : 		WCHAR deviceName[MAX_PATH];
; 3791 : 		int driveLetter = -1;
; 3792 : 
; 3793 : 		strcpy ((char *)deviceName, szDiskFile);

  00024	33 c0		 xor	 eax, eax
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@HandleOldA:
  00030	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?szDiskFile@@3PADA[eax]
  00036	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00039	88 8c 05 f3 fd
	ff ff		 mov	 BYTE PTR _deviceName$2[ebp+eax-1], cl
  00040	84 c9		 test	 cl, cl
  00042	75 ec		 jne	 SHORT $LL5@HandleOldA

; 3794 : 		ToUNICODE ((char *)deviceName);

  00044	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _deviceName$2[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _ToUNICODE

; 3795 : 		driveLetter = GetDiskDeviceDriveLetter (deviceName);

  00050	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _deviceName$2[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  0005c	83 c4 08	 add	 esp, 8

; 3796 : 
; 3797 : 		if (!bHiddenVolHost
; 3798 : 			&& !bHiddenOS
; 3799 : 			&& driveLetter > 1)		// If a drive letter is assigned to the device, but not A: or B:

  0005f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00066	75 4f		 jne	 SHORT $LN3@HandleOldA
  00068	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  0006f	75 46		 jne	 SHORT $LN3@HandleOldA
  00071	83 f8 01	 cmp	 eax, 1
  00074	7e 41		 jle	 SHORT $LN3@HandleOldA

; 3800 : 		{
; 3801 : 			char rootPath[] = { (char) driveLetter + 'A', ':', '\\', 0 };

  00076	04 41		 add	 al, 65			; 00000041H

; 3802 : 			wchar_t szTmp[8192];
; 3803 : 
; 3804 : 			swprintf (szTmp, GetString ("AFTER_FORMAT_DRIVE_LETTER_WARN"), rootPath[0], rootPath[0], rootPath[0], rootPath[0]);

  00078	0f be c0	 movsx	 eax, al
  0007b	50		 push	 eax
  0007c	50		 push	 eax
  0007d	50		 push	 eax
  0007e	50		 push	 eax
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DGIMBADH@AFTER_FORMAT_DRIVE_LETTER_WARN?$AA@
  00084	e8 00 00 00 00	 call	 _GetString
  00089	83 c4 04	 add	 esp, 4
  0008c	50		 push	 eax
  0008d	8d 85 f4 bd ff
	ff		 lea	 eax, DWORD PTR _szTmp$1[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf
  00099	83 c4 18	 add	 esp, 24			; 00000018H

; 3805 : 			MessageBoxW (MainDlg, szTmp, lpszTitle, MB_ICONWARNING);

  0009c	8d 85 f4 bd ff
	ff		 lea	 eax, DWORD PTR _szTmp$1[ebp]
  000a2	6a 30		 push	 48			; 00000030H
  000a4	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  000aa	50		 push	 eax
  000ab	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$LN3@HandleOldA:

; 3806 : 		}
; 3807 : 	}
; 3808 : }

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
_HandleOldAssignedDriveLetter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _FinalPreTransformPrompts
_TEXT	SEGMENT
_occupiedBytes$1 = -26364				; size = 8
_percentFreeSpace$2 = -26356				; size = 4
_bTmpIsPartition$3 = -26352				; size = 4
_tmpStr$4 = -26348					; size = 20
_tmpMcMsg$5 = -26328					; size = 16000
_szTmp$ = -10328					; size = 8192
_tmpMcOption1$6 = -2136					; size = 1000
_deviceName$ = -1136					; size = 520
_drive$7 = -616						; size = 256
_tmpMcOptionCancel$8 = -360				; size = 100
_volumeLabel$9 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_FinalPreTransformPrompts PROC				; COMDAT

; 3674 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 fc 66 00 00	 mov	 eax, 26364		; 000066fcH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3675 : 	int x;
; 3676 : 	wchar_t szTmp[4096];
; 3677 : 	int driveNo;
; 3678 : 	WCHAR deviceName[MAX_PATH];
; 3679 : 
; 3680 : 	strcpy ((char *)deviceName, szFileName);

  00017	33 c9		 xor	 ecx, ecx
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL20@FinalPreTr:
  00020	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?szFileName@@3PADA[ecx]
  00026	88 84 0d 90 fb
	ff ff		 mov	 BYTE PTR _deviceName$[ebp+ecx], al
  0002d	41		 inc	 ecx
  0002e	84 c0		 test	 al, al
  00030	75 ee		 jne	 SHORT $LL20@FinalPreTr

; 3681 : 	ToUNICODE ((char *)deviceName);

  00032	53		 push	 ebx
  00033	8d 85 90 fb ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  00039	56		 push	 esi
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _ToUNICODE

; 3682 : 
; 3683 : 	driveNo = GetDiskDeviceDriveLetter (deviceName);

  00040	8d 85 90 fb ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  0004c	83 c4 08	 add	 esp, 8
  0004f	8b d8		 mov	 ebx, eax

; 3684 : 
; 3685 : 	if (!(bHiddenVol && !bHiddenVolHost))	// Do not ask for permission to overwrite an existing volume if we're creating a hidden volume within it

  00051	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00058	74 0d		 je	 SHORT $LN5@FinalPreTr
  0005a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00061	0f 84 c6 05 00
	00		 je	 $LN17@FinalPreTr
$LN5@FinalPreTr:

; 3686 : 	{
; 3687 : 		wchar_t drive[128];
; 3688 : 		wchar_t volumeLabel[128];
; 3689 : 		wchar_t *type;
; 3690 : 		BOOL bTmpIsPartition = FALSE;
; 3691 : 
; 3692 : 		type = GetPathType (szFileName, !bInPlaceEncNonSys, &bTmpIsPartition);

  00067	8d 85 10 99 ff
	ff		 lea	 eax, DWORD PTR _bTmpIsPartition$3[ebp]
  0006d	c7 85 10 99 ff
	ff 00 00 00 00	 mov	 DWORD PTR _bTmpIsPartition$3[ebp], 0
  00077	50		 push	 eax
  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  0007d	f7 d8		 neg	 eax
  0007f	1b c0		 sbb	 eax, eax
  00081	40		 inc	 eax
  00082	50		 push	 eax
  00083	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  00088	e8 00 00 00 00	 call	 _GetPathType
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	8b f0		 mov	 esi, eax

; 3693 : 
; 3694 : 		if (driveNo != -1)

  00092	83 fb ff	 cmp	 ebx, -1
  00095	74 65		 je	 SHORT $LN6@FinalPreTr

; 3695 : 		{
; 3696 : 			if (!GetDriveLabel (driveNo, volumeLabel, sizeof (volumeLabel)))

  00097	68 00 01 00 00	 push	 256			; 00000100H
  0009c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _volumeLabel$9[ebp]
  000a2	50		 push	 eax
  000a3	53		 push	 ebx
  000a4	e8 00 00 00 00	 call	 _GetDriveLabel
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	85 c0		 test	 eax, eax
  000ae	75 0b		 jne	 SHORT $LN65@FinalPreTr

; 3697 : 				volumeLabel[0] = 0;

  000b0	33 c9		 xor	 ecx, ecx
  000b2	66 89 8d fc fe
	ff ff		 mov	 WORD PTR _volumeLabel$9[ebp], cx
  000b9	eb 07		 jmp	 SHORT $LN8@FinalPreTr
$LN65@FinalPreTr:
  000bb	66 8b 8d fc fe
	ff ff		 mov	 cx, WORD PTR _volumeLabel$9[ebp]
$LN8@FinalPreTr:

; 3698 : 
; 3699 : 			swprintf_s (drive, sizeof (drive)/2, volumeLabel[0] ? L" (%hc: '%s')" : L" (%hc:%s)", 'A' + driveNo, volumeLabel[0] ? volumeLabel : L"");

  000c2	66 85 c9	 test	 cx, cx
  000c5	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _volumeLabel$9[ebp]
  000cb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  000d0	0f 44 c2	 cmove	 eax, edx
  000d3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_1BE@LDCEEKNB@?$AA?5?$AA?$CI?$AA?$CF?$AAh?$AAc?$AA?3?$AA?$CF?$AAs?$AA?$CJ?$AA?$AA@
  000d8	50		 push	 eax
  000d9	8d 43 41	 lea	 eax, DWORD PTR [ebx+65]
  000dc	50		 push	 eax
  000dd	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BK@GHMHFLJL@?$AA?5?$AA?$CI?$AA?$CF?$AAh?$AAc?$AA?3?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?$CJ?$AA?$AA@
  000e2	0f 44 c2	 cmove	 eax, edx
  000e5	50		 push	 eax
  000e6	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR _drive$7[ebp]
  000ec	68 80 00 00 00	 push	 128			; 00000080H
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _swprintf_s
  000f7	83 c4 14	 add	 esp, 20			; 00000014H

; 3700 : 		}
; 3701 : 		else

  000fa	eb 10		 jmp	 SHORT $LN7@FinalPreTr
$LN6@FinalPreTr:

; 3702 : 		{
; 3703 : 			drive[0] = 0;

  000fc	33 c0		 xor	 eax, eax
  000fe	66 89 85 98 fd
	ff ff		 mov	 WORD PTR _drive$7[ebp], ax

; 3704 : 			volumeLabel[0] = 0;

  00105	66 89 85 fc fe
	ff ff		 mov	 WORD PTR _volumeLabel$9[ebp], ax
$LN7@FinalPreTr:

; 3705 : 		}
; 3706 : 
; 3707 : 		if (bHiddenOS && bHiddenVolHost)

  0010c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00113	74 34		 je	 SHORT $LN9@FinalPreTr
  00115	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  0011c	74 2b		 je	 SHORT $LN9@FinalPreTr

; 3708 : 			swprintf (szTmp, GetString ("OVERWRITEPROMPT_DEVICE_HIDDEN_OS_PARTITION"), szFileName, drive);

  0011e	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR _drive$7[ebp]
  00124	50		 push	 eax
  00125	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@KCMNHFDO@OVERWRITEPROMPT_DEVICE_HIDDEN_OS@
  0012f	e8 00 00 00 00	 call	 _GetString
  00134	83 c4 04	 add	 esp, 4
  00137	50		 push	 eax
  00138	8d 85 a8 d7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf
  00144	83 c4 10	 add	 esp, 16			; 00000010H

; 3709 : 		else

  00147	eb 3a		 jmp	 SHORT $LN10@FinalPreTr
$LN9@FinalPreTr:

; 3710 : 			swprintf (szTmp, GetString (bInPlaceEncNonSys ? "NONSYS_INPLACE_ENC_CONFIRM" : "OVERWRITEPROMPT_DEVICE"), type, szFileName, drive);

  00149	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR _drive$7[ebp]
  0014f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BH@JPJDALOG@OVERWRITEPROMPT_DEVICE?$AA@
  00154	50		 push	 eax
  00155	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  0015a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BL@IMNAFHOP@NONSYS_INPLACE_ENC_CONFIRM?$AA@
  0015f	85 c0		 test	 eax, eax
  00161	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  00166	0f 44 ca	 cmove	 ecx, edx
  00169	56		 push	 esi
  0016a	51		 push	 ecx
  0016b	e8 00 00 00 00	 call	 _GetString
  00170	83 c4 04	 add	 esp, 4
  00173	50		 push	 eax
  00174	8d 85 a8 d7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf
  00180	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@FinalPreTr:

; 3711 : 
; 3712 : 
; 3713 : 		x = MessageBoxW (MainDlg, szTmp, lpszTitle, YES_NO | MB_ICONWARNING | (bInPlaceEncNonSys ? MB_DEFBUTTON1 : MB_DEFBUTTON2));

  00183	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  00188	f7 d8		 neg	 eax
  0018a	1b c0		 sbb	 eax, eax
  0018c	25 00 ff ff ff	 and	 eax, -256		; ffffff00H
  00191	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00196	83 c8 34	 or	 eax, 52			; 00000034H
  00199	50		 push	 eax
  0019a	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  001a0	8d 85 a8 d7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  001a6	50		 push	 eax
  001a7	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 3714 : 		if (x != IDYES)

  001b3	83 f8 06	 cmp	 eax, 6
  001b6	74 12		 je	 SHORT $LN11@FinalPreTr
$LN66@FinalPreTr:
  001b8	5e		 pop	 esi

; 3715 : 			return FALSE;

  001b9	33 c0		 xor	 eax, eax
  001bb	5b		 pop	 ebx

; 3760 : 					{
; 3761 : 					case 1:
; 3762 : 						// Proceed 
; 3763 : 
; 3764 : 						// NOP
; 3765 : 						break;
; 3766 : 
; 3767 : 					default:
; 3768 : 						return FALSE;
; 3769 : 					}
; 3770 : 				}
; 3771 : 			}
; 3772 : 		}
; 3773 : 	}
; 3774 : 	return TRUE;
; 3775 : }

  001bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bf	33 cd		 xor	 ecx, ebp
  001c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c3		 ret	 0
$LN11@FinalPreTr:

; 3716 : 
; 3717 : 
; 3718 : 		if (driveNo != -1 && bTmpIsPartition && !bInPlaceEncNonSys)

  001ca	83 fb ff	 cmp	 ebx, -1
  001cd	0f 84 5a 04 00
	00		 je	 $LN17@FinalPreTr
  001d3	83 bd 10 99 ff
	ff 00		 cmp	 DWORD PTR _bTmpIsPartition$3[ebp], 0
  001da	0f 84 4d 04 00
	00		 je	 $LN17@FinalPreTr
  001e0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  001e7	0f 85 40 04 00
	00		 jne	 $LN17@FinalPreTr

; 3719 : 		{
; 3720 : 			float percentFreeSpace = 100.0;
; 3721 : 			__int64 occupiedBytes = 0;
; 3722 : 
; 3723 : 			// Do a second check. If we find that the partition contains more than 1GB of data or more than 12%
; 3724 : 			// of its space is occupied, we will display an extra warning, however, this time it won't be a Yes/No
; 3725 : 			// dialog box (because users often ignore such dialog boxes).
; 3726 : 
; 3727 : 			if (GetStatsFreeSpaceOnPartition (szFileName, &percentFreeSpace, &occupiedBytes, TRUE) != -1)

  001ed	6a 01		 push	 1
  001ef	8d 85 04 99 ff
	ff		 lea	 eax, DWORD PTR _occupiedBytes$1[ebp]
  001f5	c7 85 0c 99 ff
	ff 00 00 c8 42	 mov	 DWORD PTR _percentFreeSpace$2[ebp], 1120403456 ; 42c80000H
  001ff	50		 push	 eax
  00200	8d 85 0c 99 ff
	ff		 lea	 eax, DWORD PTR _percentFreeSpace$2[ebp]
  00206	0f 57 c0	 xorps	 xmm0, xmm0
  00209	50		 push	 eax
  0020a	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  0020f	66 0f 13 85 04
	99 ff ff	 movlpd	 QWORD PTR _occupiedBytes$1[ebp], xmm0
  00217	e8 00 00 00 00	 call	 _GetStatsFreeSpaceOnPartition
  0021c	23 c2		 and	 eax, edx
  0021e	83 c4 10	 add	 esp, 16			; 00000010H
  00221	83 f8 ff	 cmp	 eax, -1
  00224	0f 84 03 04 00
	00		 je	 $LN17@FinalPreTr

; 3728 : 			{
; 3729 : 				if (occupiedBytes > BYTES_PER_GB && percentFreeSpace < 99.99	// "percentFreeSpace < 99.99" is needed because an NTFS filesystem larger than several terabytes can have more than 1GB of data in use, even if there are no files stored on it.
; 3730 : 					|| percentFreeSpace < 88)		// A 24-MB NTFS filesystem has 11.5% of space in use even if there are no files stored on it.

  0022a	83 bd 08 99 ff
	ff 00		 cmp	 DWORD PTR _occupiedBytes$1[ebp+4], 0
  00231	f3 0f 10 95 0c
	99 ff ff	 movss	 xmm2, DWORD PTR _percentFreeSpace$2[ebp]
  00239	7c 1f		 jl	 SHORT $LN16@FinalPreTr
  0023b	7f 0c		 jg	 SHORT $LN44@FinalPreTr
  0023d	81 bd 04 99 ff
	ff 00 00 00 40	 cmp	 DWORD PTR _occupiedBytes$1[ebp], 1073741824 ; 40000000H
  00247	76 11		 jbe	 SHORT $LN16@FinalPreTr
$LN44@FinalPreTr:
  00249	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4058ff5c28f5c28f
  00251	0f 5a ca	 cvtps2pd xmm1, xmm2
  00254	66 0f 2f c1	 comisd	 xmm0, xmm1
  00258	77 11		 ja	 SHORT $LN15@FinalPreTr
$LN16@FinalPreTr:
  0025a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42b00000
  00262	0f 2f c2	 comiss	 xmm0, xmm2
  00265	0f 86 c2 03 00
	00		 jbe	 $LN17@FinalPreTr
$LN15@FinalPreTr:

; 3731 : 				{
; 3732 : 					wchar_t tmpMcMsg [8000];
; 3733 : 					wchar_t tmpMcOption1 [500];
; 3734 : 					wchar_t tmpMcOptionCancel [50];
; 3735 : 
; 3736 : 					wcscpy (tmpMcMsg, GetString("OVERWRITEPROMPT_DEVICE_SECOND_WARNING_LOTS_OF_DATA"));

  0026b	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@GFFEJLFD@OVERWRITEPROMPT_DEVICE_SECOND_WA@
  00270	e8 00 00 00 00	 call	 _GetString
  00275	8d 95 28 99 ff
	ff		 lea	 edx, DWORD PTR _tmpMcMsg$5[ebp]
  0027b	83 c4 04	 add	 esp, 4
  0027e	2b d0		 sub	 edx, eax
$LL27@FinalPreTr:
  00280	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00283	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00286	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0028b	66 85 c9	 test	 cx, cx
  0028e	75 f0		 jne	 SHORT $LL27@FinalPreTr

; 3737 : 					wcscpy (tmpMcOption1, GetString("ERASE_FILES_BY_CREATING_VOLUME"));

  00290	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IMKLJEFC@ERASE_FILES_BY_CREATING_VOLUME?$AA@
  00295	e8 00 00 00 00	 call	 _GetString
  0029a	8d 95 a8 f7 ff
	ff		 lea	 edx, DWORD PTR _tmpMcOption1$6[ebp]
  002a0	83 c4 04	 add	 esp, 4
  002a3	2b d0		 sub	 edx, eax
$LL28@FinalPreTr:
  002a5	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002a8	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  002ab	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  002b0	66 85 c9	 test	 cx, cx
  002b3	75 f0		 jne	 SHORT $LL28@FinalPreTr

; 3738 : 					wcscpy (tmpMcOptionCancel, GetString("CANCEL"));

  002b5	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  002ba	e8 00 00 00 00	 call	 _GetString
  002bf	8d 95 98 fe ff
	ff		 lea	 edx, DWORD PTR _tmpMcOptionCancel$8[ebp]
  002c5	83 c4 04	 add	 esp, 4
  002c8	2b d0		 sub	 edx, eax
  002ca	66 0f 1f 44 00
	00		 npad	 6
$LL29@FinalPreTr:
  002d0	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002d3	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  002d6	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  002db	66 85 c9	 test	 cx, cx
  002de	75 f0		 jne	 SHORT $LL29@FinalPreTr

; 3739 : 
; 3740 : 					wcscat (tmpMcMsg, L"\n\n");

  002e0	8d 8d 28 99 ff
	ff		 lea	 ecx, DWORD PTR _tmpMcMsg$5[ebp]
  002e6	83 c1 fe	 add	 ecx, -2			; fffffffeH
  002e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL45@FinalPreTr:
  002f0	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  002f4	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  002f7	66 85 c0	 test	 ax, ax
  002fa	75 f4		 jne	 SHORT $LL45@FinalPreTr
  002fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  00301	89 01		 mov	 DWORD PTR [ecx], eax
  00303	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@+4

; 3741 : 					wcscat (tmpMcMsg, GetString("DRIVE_LETTER_ITEM"));

  00309	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@ELOGDKJ@DRIVE_LETTER_ITEM?$AA@
  0030e	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  00312	e8 00 00 00 00	 call	 _GetString
  00317	8b d0		 mov	 edx, eax
  00319	83 c4 04	 add	 esp, 4
  0031c	8b f2		 mov	 esi, edx
  0031e	66 90		 npad	 2
$LL46@FinalPreTr:
  00320	66 8b 02	 mov	 ax, WORD PTR [edx]
  00323	83 c2 02	 add	 edx, 2
  00326	66 85 c0	 test	 ax, ax
  00329	75 f5		 jne	 SHORT $LL46@FinalPreTr
  0032b	57		 push	 edi
  0032c	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  00332	2b d6		 sub	 edx, esi
  00334	83 c7 fe	 add	 edi, -2			; fffffffeH
  00337	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL47@FinalPreTr:
  00340	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00344	83 c7 02	 add	 edi, 2
  00347	66 85 c0	 test	 ax, ax
  0034a	75 f4		 jne	 SHORT $LL47@FinalPreTr
  0034c	8b ca		 mov	 ecx, edx

; 3742 : 					swprintf_s (szTmp, sizeof (szTmp)/2, L"%hc:", 'A' + driveNo);

  0034e	8d 43 41	 lea	 eax, DWORD PTR [ebx+65]
  00351	c1 e9 02	 shr	 ecx, 2
  00354	f3 a5		 rep movsd
  00356	50		 push	 eax
  00357	8b ca		 mov	 ecx, edx
  00359	8d 85 a8 d7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_19KHPJIBCC@?$AA?$CF?$AAh?$AAc?$AA?3?$AA?$AA@
  00364	83 e1 03	 and	 ecx, 3
  00367	68 00 10 00 00	 push	 4096			; 00001000H
  0036c	f3 a4		 rep movsb
  0036e	50		 push	 eax
  0036f	e8 00 00 00 00	 call	 _swprintf_s

; 3743 : 					wcscat (tmpMcMsg, szTmp);

  00374	8d 95 a8 d7 ff
	ff		 lea	 edx, DWORD PTR _szTmp$[ebp]
  0037a	83 c4 10	 add	 esp, 16			; 00000010H
  0037d	8b f2		 mov	 esi, edx
  0037f	90		 npad	 1
$LL48@FinalPreTr:
  00380	66 8b 02	 mov	 ax, WORD PTR [edx]
  00383	83 c2 02	 add	 edx, 2
  00386	66 85 c0	 test	 ax, ax
  00389	75 f5		 jne	 SHORT $LL48@FinalPreTr
  0038b	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  00391	2b d6		 sub	 edx, esi
  00393	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL49@FinalPreTr:
  00396	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  0039a	83 c7 02	 add	 edi, 2
  0039d	66 85 c0	 test	 ax, ax
  003a0	75 f4		 jne	 SHORT $LL49@FinalPreTr
  003a2	8b ca		 mov	 ecx, edx
  003a4	c1 e9 02	 shr	 ecx, 2
  003a7	f3 a5		 rep movsd
  003a9	8b ca		 mov	 ecx, edx
  003ab	83 e1 03	 and	 ecx, 3
  003ae	f3 a4		 rep movsb

; 3744 : 
; 3745 : 					wcscat (tmpMcMsg, L"\n");

  003b0	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  003b6	83 c7 fe	 add	 edi, -2			; fffffffeH
  003b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL50@FinalPreTr:
  003c0	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  003c4	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]
  003c7	66 85 c0	 test	 ax, ax
  003ca	75 f4		 jne	 SHORT $LL50@FinalPreTr
  003cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@

; 3746 : 					wcscat (tmpMcMsg, GetString("LABEL_ITEM"));

  003d1	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PEDCDHCM@LABEL_ITEM?$AA@
  003d6	89 07		 mov	 DWORD PTR [edi], eax
  003d8	e8 00 00 00 00	 call	 _GetString
  003dd	8b d0		 mov	 edx, eax
  003df	83 c4 04	 add	 esp, 4
  003e2	8b f2		 mov	 esi, edx
$LL51@FinalPreTr:
  003e4	66 8b 02	 mov	 ax, WORD PTR [edx]
  003e7	83 c2 02	 add	 edx, 2
  003ea	66 85 c0	 test	 ax, ax
  003ed	75 f5		 jne	 SHORT $LL51@FinalPreTr
  003ef	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  003f5	2b d6		 sub	 edx, esi
  003f7	83 c7 fe	 add	 edi, -2			; fffffffeH
  003fa	66 0f 1f 44 00
	00		 npad	 6
$LL52@FinalPreTr:
  00400	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00404	83 c7 02	 add	 edi, 2
  00407	66 85 c0	 test	 ax, ax
  0040a	75 f4		 jne	 SHORT $LL52@FinalPreTr
  0040c	8b ca		 mov	 ecx, edx
  0040e	c1 e9 02	 shr	 ecx, 2
  00411	f3 a5		 rep movsd
  00413	8b ca		 mov	 ecx, edx
  00415	83 e1 03	 and	 ecx, 3
  00418	f3 a4		 rep movsb

; 3747 : 					wcscat (tmpMcMsg, volumeLabel[0] != 0 ? volumeLabel : GetString("NOT_APPLICABLE_OR_NOT_AVAILABLE"));

  0041a	66 39 85 fc fe
	ff ff		 cmp	 WORD PTR _volumeLabel$9[ebp], ax
  00421	74 08		 je	 SHORT $LN30@FinalPreTr
  00423	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _volumeLabel$9[ebp]
  00429	eb 0f		 jmp	 SHORT $LN31@FinalPreTr
$LN30@FinalPreTr:
  0042b	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@KEHLKHJA@NOT_APPLICABLE_OR_NOT_AVAILABLE?$AA@
  00430	e8 00 00 00 00	 call	 _GetString
  00435	83 c4 04	 add	 esp, 4
  00438	8b d0		 mov	 edx, eax
$LN31@FinalPreTr:
  0043a	8b f2		 mov	 esi, edx
  0043c	0f 1f 40 00	 npad	 4
$LL53@FinalPreTr:
  00440	66 8b 02	 mov	 ax, WORD PTR [edx]
  00443	83 c2 02	 add	 edx, 2
  00446	66 85 c0	 test	 ax, ax
  00449	75 f5		 jne	 SHORT $LL53@FinalPreTr
  0044b	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  00451	2b d6		 sub	 edx, esi
  00453	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL54@FinalPreTr:
  00456	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  0045a	83 c7 02	 add	 edi, 2
  0045d	66 85 c0	 test	 ax, ax
  00460	75 f4		 jne	 SHORT $LL54@FinalPreTr
  00462	8b ca		 mov	 ecx, edx
  00464	c1 e9 02	 shr	 ecx, 2
  00467	f3 a5		 rep movsd
  00469	8b ca		 mov	 ecx, edx
  0046b	83 e1 03	 and	 ecx, 3
  0046e	f3 a4		 rep movsb

; 3748 : 
; 3749 : 					wcscat (tmpMcMsg, L"\n");

  00470	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  00476	83 c7 fe	 add	 edi, -2			; fffffffeH
  00479	0f 1f 80 00 00
	00 00		 npad	 7
$LL55@FinalPreTr:
  00480	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00484	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]
  00487	66 85 c0	 test	 ax, ax
  0048a	75 f4		 jne	 SHORT $LL55@FinalPreTr
  0048c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@

; 3750 : 					wcscat (tmpMcMsg, GetString("SIZE_ITEM"));

  00491	68 00 00 00 00	 push	 OFFSET ??_C@_09DBGAMMMC@SIZE_ITEM?$AA@
  00496	89 07		 mov	 DWORD PTR [edi], eax
  00498	e8 00 00 00 00	 call	 _GetString
  0049d	8b d0		 mov	 edx, eax
  0049f	83 c4 04	 add	 esp, 4
  004a2	8b f2		 mov	 esi, edx
$LL56@FinalPreTr:
  004a4	66 8b 02	 mov	 ax, WORD PTR [edx]
  004a7	83 c2 02	 add	 edx, 2
  004aa	66 85 c0	 test	 ax, ax
  004ad	75 f5		 jne	 SHORT $LL56@FinalPreTr
  004af	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  004b5	2b d6		 sub	 edx, esi
  004b7	83 c7 fe	 add	 edi, -2			; fffffffeH
  004ba	66 0f 1f 44 00
	00		 npad	 6
$LL57@FinalPreTr:
  004c0	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  004c4	83 c7 02	 add	 edi, 2
  004c7	66 85 c0	 test	 ax, ax
  004ca	75 f4		 jne	 SHORT $LL57@FinalPreTr
  004cc	8b ca		 mov	 ecx, edx

; 3751 : 					GetSizeString (nVolumeSize, szTmp);

  004ce	8d 85 a8 d7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  004d4	c1 e9 02	 shr	 ecx, 2
  004d7	f3 a5		 rep movsd
  004d9	50		 push	 eax
  004da	ff 35 04 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA+4
  004e0	8b ca		 mov	 ecx, edx
  004e2	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA
  004e8	83 e1 03	 and	 ecx, 3
  004eb	f3 a4		 rep movsb
  004ed	e8 00 00 00 00	 call	 _GetSizeString

; 3752 : 					wcscat (tmpMcMsg, szTmp);

  004f2	8d 95 a8 d7 ff
	ff		 lea	 edx, DWORD PTR _szTmp$[ebp]
  004f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  004fb	8b f2		 mov	 esi, edx
  004fd	0f 1f 00	 npad	 3
$LL58@FinalPreTr:
  00500	66 8b 02	 mov	 ax, WORD PTR [edx]
  00503	83 c2 02	 add	 edx, 2
  00506	66 85 c0	 test	 ax, ax
  00509	75 f5		 jne	 SHORT $LL58@FinalPreTr
  0050b	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  00511	2b d6		 sub	 edx, esi
  00513	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL59@FinalPreTr:
  00516	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  0051a	83 c7 02	 add	 edi, 2
  0051d	66 85 c0	 test	 ax, ax
  00520	75 f4		 jne	 SHORT $LL59@FinalPreTr
  00522	8b ca		 mov	 ecx, edx
  00524	c1 e9 02	 shr	 ecx, 2
  00527	f3 a5		 rep movsd
  00529	8b ca		 mov	 ecx, edx
  0052b	83 e1 03	 and	 ecx, 3
  0052e	f3 a4		 rep movsb

; 3753 : 
; 3754 : 					wcscat (tmpMcMsg, L"\n");

  00530	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  00536	83 c7 fe	 add	 edi, -2			; fffffffeH
  00539	0f 1f 80 00 00
	00 00		 npad	 7
$LL60@FinalPreTr:
  00540	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00544	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]
  00547	66 85 c0	 test	 ax, ax
  0054a	75 f4		 jne	 SHORT $LL60@FinalPreTr
  0054c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@

; 3755 : 					wcscat (tmpMcMsg, GetString("PATH_ITEM"));

  00551	68 00 00 00 00	 push	 OFFSET ??_C@_09BFNCKGCL@PATH_ITEM?$AA@
  00556	89 07		 mov	 DWORD PTR [edi], eax
  00558	e8 00 00 00 00	 call	 _GetString
  0055d	8b d0		 mov	 edx, eax
  0055f	83 c4 04	 add	 esp, 4
  00562	8b f2		 mov	 esi, edx
$LL61@FinalPreTr:
  00564	66 8b 02	 mov	 ax, WORD PTR [edx]
  00567	83 c2 02	 add	 edx, 2
  0056a	66 85 c0	 test	 ax, ax
  0056d	75 f5		 jne	 SHORT $LL61@FinalPreTr
  0056f	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  00575	2b d6		 sub	 edx, esi
  00577	83 c7 fe	 add	 edi, -2			; fffffffeH
  0057a	66 0f 1f 44 00
	00		 npad	 6
$LL62@FinalPreTr:
  00580	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00584	83 c7 02	 add	 edi, 2
  00587	66 85 c0	 test	 ax, ax
  0058a	75 f4		 jne	 SHORT $LL62@FinalPreTr
  0058c	8b ca		 mov	 ecx, edx
  0058e	c1 e9 02	 shr	 ecx, 2
  00591	f3 a5		 rep movsd
  00593	8b ca		 mov	 ecx, edx

; 3756 : 					wcscat (tmpMcMsg, deviceName);

  00595	8d 95 90 fb ff
	ff		 lea	 edx, DWORD PTR _deviceName$[ebp]
  0059b	83 e1 03	 and	 ecx, 3
  0059e	f3 a4		 rep movsb
  005a0	8b f2		 mov	 esi, edx
$LL63@FinalPreTr:
  005a2	66 8b 02	 mov	 ax, WORD PTR [edx]
  005a5	83 c2 02	 add	 edx, 2
  005a8	66 85 c0	 test	 ax, ax
  005ab	75 f5		 jne	 SHORT $LL63@FinalPreTr
  005ad	8d bd 28 99 ff
	ff		 lea	 edi, DWORD PTR _tmpMcMsg$5[ebp]
  005b3	2b d6		 sub	 edx, esi
  005b5	83 c7 fe	 add	 edi, -2			; fffffffeH
  005b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL64@FinalPreTr:
  005c0	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  005c4	83 c7 02	 add	 edi, 2
  005c7	66 85 c0	 test	 ax, ax
  005ca	75 f4		 jne	 SHORT $LL64@FinalPreTr
  005cc	8b ca		 mov	 ecx, edx

; 3757 : 
; 3758 : 					wchar_t *tmpStr[] = {L"", tmpMcMsg, tmpMcOption1, tmpMcOptionCancel, 0};

  005ce	c7 85 14 99 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$4[ebp], OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  005d8	c1 e9 02	 shr	 ecx, 2
  005db	8d 85 28 99 ff
	ff		 lea	 eax, DWORD PTR _tmpMcMsg$5[ebp]
  005e1	f3 a5		 rep movsd
  005e3	89 85 18 99 ff
	ff		 mov	 DWORD PTR _tmpStr$4[ebp+4], eax
  005e9	8b ca		 mov	 ecx, edx
  005eb	8d 85 a8 f7 ff
	ff		 lea	 eax, DWORD PTR _tmpMcOption1$6[ebp]
  005f1	c7 85 24 99 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpStr$4[ebp+16], 0
  005fb	89 85 1c 99 ff
	ff		 mov	 DWORD PTR _tmpStr$4[ebp+8], eax
  00601	83 e1 03	 and	 ecx, 3
  00604	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR _tmpMcOptionCancel$8[ebp]
  0060a	89 85 20 99 ff
	ff		 mov	 DWORD PTR _tmpStr$4[ebp+12], eax

; 3759 : 					switch (AskMultiChoice ((void **) tmpStr, TRUE))

  00610	8d 85 14 99 ff
	ff		 lea	 eax, DWORD PTR _tmpStr$4[ebp]
  00616	6a 01		 push	 1
  00618	f3 a4		 rep movsb
  0061a	50		 push	 eax
  0061b	e8 00 00 00 00	 call	 _AskMultiChoice
  00620	83 c4 08	 add	 esp, 8
  00623	5f		 pop	 edi
  00624	83 e8 01	 sub	 eax, 1
  00627	0f 85 8b fb ff
	ff		 jne	 $LN66@FinalPreTr
$LN17@FinalPreTr:

; 3760 : 					{
; 3761 : 					case 1:
; 3762 : 						// Proceed 
; 3763 : 
; 3764 : 						// NOP
; 3765 : 						break;
; 3766 : 
; 3767 : 					default:
; 3768 : 						return FALSE;
; 3769 : 					}
; 3770 : 				}
; 3771 : 			}
; 3772 : 		}
; 3773 : 	}
; 3774 : 	return TRUE;
; 3775 : }

  0062d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00630	b8 01 00 00 00	 mov	 eax, 1
  00635	5e		 pop	 esi
  00636	33 cd		 xor	 ecx, ebp
  00638	5b		 pop	 ebx
  00639	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0063e	8b e5		 mov	 esp, ebp
  00640	5d		 pop	 ebp
  00641	c3		 ret	 0
_FinalPreTransformPrompts ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _QueryFreeSpace
_TEXT	SEGMENT
_lDiskFree$1 = -612					; size = 8
_free$2 = -604						; size = 8
_lDiskFree$3 = -596					; size = 8
_lDiskFree$4 = -588					; size = 8
_diskInfo$5 = -580					; size = 32
_driveInfo$6 = -548					; size = 24
_szTmp$7 = -524						; size = 260
_root$8 = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_hwndTextBox$ = 12					; size = 4
_display$ = 16						; size = 4
_QueryFreeSpace PROC					; COMDAT

; 3554 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 02 00
	00		 sub	 esp, 612		; 00000264H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3555 : 	if (bHiddenVol && !bHiddenVolHost)	// If it's a hidden volume

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _hwndTextBox$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  00022	74 51		 je	 SHORT $LN2@QueryFreeS
  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  0002b	75 48		 jne	 SHORT $LN2@QueryFreeS

; 3556 : 	{
; 3557 : 		LARGE_INTEGER lDiskFree;
; 3558 : 		char szTmp[GST_MAX_PATH];
; 3559 : 
; 3560 : 		lDiskFree.QuadPart = nMaximumHiddenVolSize;
; 3561 : 
; 3562 : 		if (display)

  0002d	83 7d 10 00	 cmp	 DWORD PTR _display$[ebp], 0
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nMaximumHiddenVolSize@@3_JA
  00036	89 85 ac fd ff
	ff		 mov	 DWORD PTR _lDiskFree$3[ebp], eax
  0003c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?nMaximumHiddenVolSize@@3_JA+4
  00041	89 85 b0 fd ff
	ff		 mov	 DWORD PTR _lDiskFree$3[ebp+4], eax
  00047	74 17		 je	 SHORT $LN4@QueryFreeS

; 3563 : 			PrintFreeSpace (hwndTextBox, szTmp, &lDiskFree);

  00049	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _lDiskFree$3[ebp]
  0004f	50		 push	 eax
  00050	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp$7[ebp]
  00056	50		 push	 eax
  00057	56		 push	 esi
  00058	e8 00 00 00 00	 call	 _PrintFreeSpace
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@QueryFreeS:

; 3564 : 
; 3565 : 		return TRUE;

  00060	5f		 pop	 edi
  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	5e		 pop	 esi

; 3659 : 	}
; 3660 : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	33 cd		 xor	 ecx, ebp
  0006c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN2@QueryFreeS:

; 3566 : 	}
; 3567 : 	else if (bDevice == FALSE)

  00075	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  0007c	0f 85 a5 00 00
	00		 jne	 $LN5@QueryFreeS

; 3568 : 	{
; 3569 : 		char root[GST_MAX_PATH];
; 3570 : 		ULARGE_INTEGER free;
; 3571 : 
; 3572 : 		if (!GetVolumePathName (szFileName, root, sizeof (root)))

  00082	68 04 01 00 00	 push	 260			; 00000104H
  00087	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _root$8[ebp]
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumePathNameA@12
  00099	85 c0		 test	 eax, eax
  0009b	75 0b		 jne	 SHORT $LN7@QueryFreeS

; 3573 : 		{
; 3574 : 			handleWin32Error (hwndDlg);

  0009d	57		 push	 edi
  0009e	e8 00 00 00 00	 call	 _handleWin32Error

; 3575 : 			return FALSE;

  000a3	e9 3d 02 00 00	 jmp	 $LN26@QueryFreeS
$LN7@QueryFreeS:

; 3576 : 		}
; 3577 : 
; 3578 : 		if (!GetDiskFreeSpaceEx (root, &free, 0, 0))

  000a8	6a 00		 push	 0
  000aa	6a 00		 push	 0
  000ac	8d 85 a4 fd ff
	ff		 lea	 eax, DWORD PTR _free$2[ebp]
  000b2	50		 push	 eax
  000b3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _root$8[ebp]
  000b9	50		 push	 eax
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDiskFreeSpaceExA@16
  000c0	85 c0		 test	 eax, eax
  000c2	75 15		 jne	 SHORT $LN8@QueryFreeS
$LN27@QueryFreeS:

; 3579 : 		{
; 3580 : 			if (display)

  000c4	83 7d 10 00	 cmp	 DWORD PTR _display$[ebp], 0
  000c8	0f 84 1a 02 00
	00		 je	 $LN10@QueryFreeS

; 3581 : 				DisplaySizingErrorText (hwndTextBox);

  000ce	56		 push	 esi
  000cf	e8 00 00 00 00	 call	 _DisplaySizingErrorText

; 3582 : 
; 3583 : 			return FALSE;

  000d4	e9 0c 02 00 00	 jmp	 $LN26@QueryFreeS
$LN8@QueryFreeS:

; 3584 : 		}
; 3585 : 		else
; 3586 : 		{
; 3587 : 			LARGE_INTEGER lDiskFree;
; 3588 : 			lDiskFree.QuadPart = free.QuadPart;
; 3589 : 
; 3590 : 			if (display)

  000d9	83 7d 10 00	 cmp	 DWORD PTR _display$[ebp], 0
  000dd	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _free$2[ebp]
  000e3	89 85 9c fd ff
	ff		 mov	 DWORD PTR _lDiskFree$1[ebp], eax
  000e9	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _free$2[ebp+4]
  000ef	89 85 a0 fd ff
	ff		 mov	 DWORD PTR _lDiskFree$1[ebp+4], eax
  000f5	0f 84 65 ff ff
	ff		 je	 $LN4@QueryFreeS

; 3591 : 				PrintFreeSpace (hwndTextBox, root, &lDiskFree);

  000fb	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _lDiskFree$1[ebp]
  00101	50		 push	 eax
  00102	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _root$8[ebp]
  00108	50		 push	 eax
  00109	56		 push	 esi
  0010a	e8 00 00 00 00	 call	 _PrintFreeSpace
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3592 : 
; 3593 : 			return TRUE;

  00112	b8 01 00 00 00	 mov	 eax, 1
  00117	5f		 pop	 edi
  00118	5e		 pop	 esi

; 3659 : 	}
; 3660 : }

  00119	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011c	33 cd		 xor	 ecx, ebp
  0011e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
$LN5@QueryFreeS:

; 3594 : 		}
; 3595 : 	}
; 3596 : 	else
; 3597 : 	{
; 3598 : 		DISK_GEOMETRY driveInfo;
; 3599 : 		PARTITION_INFORMATION diskInfo;
; 3600 : 		BOOL piValid = FALSE;
; 3601 : 		BOOL gValid = FALSE;
; 3602 : 
; 3603 : 		// Query partition size
; 3604 : 		piValid = GetPartitionInfo (szDiskFile, &diskInfo);

  00127	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _diskInfo$5[ebp]
  0012d	50		 push	 eax
  0012e	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  00133	e8 00 00 00 00	 call	 _GetPartitionInfo
  00138	8b f8		 mov	 edi, eax

; 3605 : 		gValid = GetDriveGeometry (szDiskFile, &driveInfo);

  0013a	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _driveInfo$6[ebp]
  00140	50		 push	 eax
  00141	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  00146	e8 00 00 00 00	 call	 _GetDriveGeometry
  0014b	83 c4 10	 add	 esp, 16			; 00000010H

; 3606 : 
; 3607 : 		if (!piValid && !gValid)

  0014e	85 ff		 test	 edi, edi
  00150	75 08		 jne	 SHORT $LN12@QueryFreeS
  00152	85 c0		 test	 eax, eax
  00154	0f 84 6a ff ff
	ff		 je	 $LN27@QueryFreeS
$LN12@QueryFreeS:

; 3608 : 		{
; 3609 : 			if (display)
; 3610 : 				DisplaySizingErrorText (hwndTextBox);
; 3611 : 
; 3612 : 			return FALSE;
; 3613 : 		}
; 3614 : 
; 3615 : 		int sectorSize = GetFormatSectorSize();

  0015a	e8 00 00 00 00	 call	 _GetFormatSectorSize

; 3616 : 
; 3617 : 		if (sectorSize < GST_MIN_VOLUME_SECTOR_SIZE
; 3618 : 			|| sectorSize > GST_MAX_VOLUME_SECTOR_SIZE
; 3619 : 			|| sectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  0015f	8d 88 00 fe ff
	ff		 lea	 ecx, DWORD PTR [eax-512]
  00165	81 f9 00 0e 00
	00		 cmp	 ecx, 3584		; 00000e00H
  0016b	0f 87 6a 01 00
	00		 ja	 $LN15@QueryFreeS
  00171	25 ff 01 00 80	 and	 eax, -2147483137	; 800001ffH
  00176	79 07		 jns	 SHORT $LN25@QueryFreeS
  00178	48		 dec	 eax
  00179	0d 00 fe ff ff	 or	 eax, -512		; fffffe00H
  0017e	40		 inc	 eax
$LN25@QueryFreeS:
  0017f	0f 85 56 01 00
	00		 jne	 $LN15@QueryFreeS

; 3622 : 			return FALSE;
; 3623 : 		}
; 3624 : 
; 3625 : 		if (piValid)

  00185	85 ff		 test	 edi, edi
  00187	0f 84 a7 00 00
	00		 je	 $LN16@QueryFreeS

; 3626 : 		{
; 3627 : 			nVolumeSize = diskInfo.PartitionLength.QuadPart;
; 3628 : 
; 3629 : 			if(display)

  0018d	83 7d 10 00	 cmp	 DWORD PTR _display$[ebp], 0
  00191	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _diskInfo$5[ebp+8]
  00197	8b f9		 mov	 edi, ecx
  00199	53		 push	 ebx
  0019a	8b 9d c8 fd ff
	ff		 mov	 ebx, DWORD PTR _diskInfo$5[ebp+12]
  001a0	89 3d 00 00 00
	00		 mov	 DWORD PTR ?nVolumeSize@@3_KA, edi
  001a6	89 1d 04 00 00
	00		 mov	 DWORD PTR ?nVolumeSize@@3_KA+4, ebx
  001ac	74 2e		 je	 SHORT $LN23@QueryFreeS

; 3630 : 				nMultiplier = PrintFreeSpace (hwndTextBox, szDiskFile, &diskInfo.PartitionLength);

  001ae	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _diskInfo$5[ebp+8]
  001b4	50		 push	 eax
  001b5	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  001ba	56		 push	 esi
  001bb	e8 00 00 00 00	 call	 _PrintFreeSpace
  001c0	8b 9d c8 fd ff
	ff		 mov	 ebx, DWORD PTR _diskInfo$5[ebp+12]
  001c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c9	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _diskInfo$5[ebp+8]
  001cf	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?nVolumeSize@@3_KA
  001d5	a3 00 00 00 00	 mov	 DWORD PTR ?nMultiplier@@3HA, eax ; nMultiplier
  001da	eb 05		 jmp	 SHORT $LN18@QueryFreeS
$LN23@QueryFreeS:
  001dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nMultiplier@@3HA ; nMultiplier
$LN18@QueryFreeS:

; 3631 : 
; 3632 : 			nUIVolumeSize = diskInfo.PartitionLength.QuadPart / nMultiplier;

  001e1	99		 cdq
  001e2	52		 push	 edx
  001e3	50		 push	 eax
  001e4	53		 push	 ebx
  001e5	51		 push	 ecx
  001e6	e8 00 00 00 00	 call	 __alldiv

; 3633 : 
; 3634 : 			if (nVolumeSize == 0)

  001eb	0b 3d 04 00 00
	00		 or	 edi, DWORD PTR ?nVolumeSize@@3_KA+4
  001f1	a3 00 00 00 00	 mov	 DWORD PTR ?nUIVolumeSize@@3_KA, eax
  001f6	89 15 04 00 00
	00		 mov	 DWORD PTR ?nUIVolumeSize@@3_KA+4, edx
  001fc	5b		 pop	 ebx
  001fd	0f 85 c3 00 00
	00		 jne	 $LN17@QueryFreeS

; 3635 : 			{
; 3636 : 				if (display)

  00203	83 7d 10 00	 cmp	 DWORD PTR _display$[ebp], 0
  00207	0f 84 db 00 00
	00		 je	 $LN10@QueryFreeS

; 3637 : 					SetWindowTextW (hwndTextBox, GetString ("EXT_PARTITION"));

  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MKGMJGFE@EXT_PARTITION?$AA@
  00212	e8 00 00 00 00	 call	 _GetString
  00217	83 c4 04	 add	 esp, 4
  0021a	50		 push	 eax
  0021b	56		 push	 esi
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
  00222	5f		 pop	 edi
  00223	33 c0		 xor	 eax, eax
  00225	5e		 pop	 esi

; 3659 : 	}
; 3660 : }

  00226	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00229	33 cd		 xor	 ecx, ebp
  0022b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	c3		 ret	 0
$LN16@QueryFreeS:

; 3638 : 
; 3639 : 				return FALSE;
; 3640 : 			}
; 3641 : 		}
; 3642 : 		else
; 3643 : 		{
; 3644 : 			LARGE_INTEGER lDiskFree;
; 3645 : 
; 3646 : 			// Drive geometry info is used only when GetPartitionInfo() fails
; 3647 : 			lDiskFree.QuadPart = driveInfo.Cylinders.QuadPart * driveInfo.BytesPerSector *

  00234	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _driveInfo$6[ebp+12]
  0023a	f7 a5 ec fd ff
	ff		 mul	 DWORD PTR _driveInfo$6[ebp+16]
  00240	6a 00		 push	 0
  00242	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _driveInfo$6[ebp+20]
  00248	52		 push	 edx
  00249	50		 push	 eax
  0024a	e8 00 00 00 00	 call	 __allmul
  0024f	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _driveInfo$6[ebp+4]
  00255	ff b5 dc fd ff
	ff		 push	 DWORD PTR _driveInfo$6[ebp]
  0025b	52		 push	 edx
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 __allmul

; 3648 : 				driveInfo.SectorsPerTrack * driveInfo.TracksPerCylinder;
; 3649 : 
; 3650 : 			nVolumeSize = lDiskFree.QuadPart;
; 3651 : 
; 3652 : 			if (display)

  00262	83 7d 10 00	 cmp	 DWORD PTR _display$[ebp], 0
  00266	8b c8		 mov	 ecx, eax
  00268	8b fa		 mov	 edi, edx
  0026a	89 8d b4 fd ff
	ff		 mov	 DWORD PTR _lDiskFree$4[ebp], ecx
  00270	89 bd b8 fd ff
	ff		 mov	 DWORD PTR _lDiskFree$4[ebp+4], edi
  00276	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nVolumeSize@@3_KA, ecx
  0027c	89 3d 04 00 00
	00		 mov	 DWORD PTR ?nVolumeSize@@3_KA+4, edi
  00282	74 28		 je	 SHORT $LN24@QueryFreeS

; 3653 : 				nMultiplier = PrintFreeSpace (hwndTextBox, szDiskFile, &lDiskFree);

  00284	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _lDiskFree$4[ebp]
  0028a	50		 push	 eax
  0028b	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  00290	56		 push	 esi
  00291	e8 00 00 00 00	 call	 _PrintFreeSpace
  00296	8b bd b8 fd ff
	ff		 mov	 edi, DWORD PTR _lDiskFree$4[ebp+4]
  0029c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0029f	8b 8d b4 fd ff
	ff		 mov	 ecx, DWORD PTR _lDiskFree$4[ebp]
  002a5	a3 00 00 00 00	 mov	 DWORD PTR ?nMultiplier@@3HA, eax ; nMultiplier
  002aa	eb 05		 jmp	 SHORT $LN21@QueryFreeS
$LN24@QueryFreeS:
  002ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nMultiplier@@3HA ; nMultiplier
$LN21@QueryFreeS:

; 3654 : 
; 3655 : 			nUIVolumeSize = lDiskFree.QuadPart / nMultiplier;

  002b1	99		 cdq
  002b2	52		 push	 edx
  002b3	50		 push	 eax
  002b4	57		 push	 edi
  002b5	51		 push	 ecx
  002b6	e8 00 00 00 00	 call	 __alldiv
  002bb	a3 00 00 00 00	 mov	 DWORD PTR ?nUIVolumeSize@@3_KA, eax
  002c0	89 15 04 00 00
	00		 mov	 DWORD PTR ?nUIVolumeSize@@3_KA+4, edx
$LN17@QueryFreeS:

; 3656 : 		}
; 3657 : 
; 3658 : 		return TRUE;

  002c6	5f		 pop	 edi
  002c7	b8 01 00 00 00	 mov	 eax, 1
  002cc	5e		 pop	 esi

; 3659 : 	}
; 3660 : }

  002cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d0	33 cd		 xor	 ecx, ebp
  002d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d7	8b e5		 mov	 esp, ebp
  002d9	5d		 pop	 ebp
  002da	c3		 ret	 0
$LN15@QueryFreeS:

; 3620 : 		{
; 3621 : 			Error ("SECTOR_SIZE_UNSUPPORTED");

  002db	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
  002e0	e8 00 00 00 00	 call	 _Error
$LN26@QueryFreeS:
  002e5	83 c4 04	 add	 esp, 4
$LN10@QueryFreeS:

; 3659 : 	}
; 3660 : }

  002e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002eb	33 c0		 xor	 eax, eax
  002ed	5f		 pop	 edi
  002ee	33 cd		 xor	 ecx, ebp
  002f0	5e		 pop	 esi
  002f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f6	8b e5		 mov	 esp, ebp
  002f8	5d		 pop	 ebp
  002f9	c3		 ret	 0
_QueryFreeSpace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _EnableDisableFileNext
_TEXT	SEGMENT
_hComboBox$ = 8						; size = 4
_hMainButton$ = 12					; size = 4
_EnableDisableFileNext PROC				; COMDAT

; 3416 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3417 : 	LPARAM nIndex = SendMessage (hComboBox, CB_GETCURSEL, 0, 0);

  00004	8b 75 08	 mov	 esi, DWORD PTR _hComboBox$[ebp]
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	68 47 01 00 00	 push	 327			; 00000147H
  00010	56		 push	 esi
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 3418 : 	if (bHistory && nIndex == CB_ERR)

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHistory, 0
  0001e	74 1a		 je	 SHORT $LN2@EnableDisa
  00020	83 f8 ff	 cmp	 eax, -1
  00023	75 15		 jne	 SHORT $LN2@EnableDisa

; 3419 : 	{
; 3420 : 		EnableWindow (hMainButton, FALSE);

  00025	6a 00		 push	 0
  00027	ff 75 0c	 push	 DWORD PTR _hMainButton$[ebp]

; 3421 : 		SetFocus (hComboBox);
; 3422 : 	}
; 3423 : 	else
; 3424 : 	{
; 3425 : 		EnableWindow (hMainButton, TRUE);

  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 3426 : 		SetFocus (hMainButton);

  00030	56		 push	 esi
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4
  00037	5e		 pop	 esi

; 3427 : 	}
; 3428 : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN2@EnableDisa:

; 3421 : 		SetFocus (hComboBox);
; 3422 : 	}
; 3423 : 	else
; 3424 : 	{
; 3425 : 		EnableWindow (hMainButton, TRUE);

  0003a	8b 75 0c	 mov	 esi, DWORD PTR _hMainButton$[ebp]
  0003d	6a 01		 push	 1
  0003f	56		 push	 esi
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 3426 : 		SetFocus (hMainButton);

  00046	56		 push	 esi
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4
  0004d	5e		 pop	 esi

; 3427 : 	}
; 3428 : }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_EnableDisableFileNext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _DisplaySizingErrorText
_TEXT	SEGMENT
_szTmp2$1 = -4100					; size = 2048
_szTmp$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_hwndTextBox$ = 8					; size = 4
_DisplaySizingErrorText PROC				; COMDAT

; 3390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 10 00 00	 mov	 eax, 4100		; 00001004H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _hwndTextBox$[ebp]

; 3391 : 	wchar_t szTmp[1024];
; 3392 : 
; 3393 : 	if (translateWin32Error (szTmp, sizeof (szTmp) / sizeof(szTmp[0])))

  0001b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00021	68 00 04 00 00	 push	 1024			; 00000400H
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _translateWin32Error
  0002c	83 c4 08	 add	 esp, 8
  0002f	85 c0		 test	 eax, eax
  00031	74 47		 je	 SHORT $LN2@DisplaySiz

; 3394 : 	{
; 3395 : 		wchar_t szTmp2[1024];
; 3396 : 		wsprintfW (szTmp2, L"%s\n%s", GetString ("CANNOT_CALC_SPACE"), szTmp);

  00033	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@LBACDGOD@CANNOT_CALC_SPACE?$AA@
  0003f	e8 00 00 00 00	 call	 _GetString
  00044	83 c4 04	 add	 esp, 4
  00047	50		 push	 eax
  00048	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _szTmp2$1[ebp]
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_1M@KGONCMNM@?$AA?$CF?$AAs?$AA?6?$AA?$CF?$AAs?$AA?$AA@
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  0005a	83 c4 10	 add	 esp, 16			; 00000010H

; 3397 : 		SetWindowTextW (hwndTextBox, szTmp2);

  0005d	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _szTmp2$1[ebp]
  00063	50		 push	 eax
  00064	56		 push	 esi
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
  0006b	5e		 pop	 esi

; 3402 : 	}
; 3403 : }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	33 cd		 xor	 ecx, ebp
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
$LN2@DisplaySiz:

; 3398 : 	}
; 3399 : 	else
; 3400 : 	{
; 3401 : 		SetWindowText (hwndTextBox, "");

  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0007f	56		 push	 esi
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 3402 : 	}
; 3403 : }

  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	5e		 pop	 esi
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_DisplaySizingErrorText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _PrintFreeSpace
_TEXT	SEGMENT
_lpszDrive$GSCopy$1$ = -524				; size = 4
_hwndTextBox$GSCopy$1$ = -520				; size = 4
_szTmp2$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_hwndTextBox$ = 8					; size = 4
_lpszDrive$ = 12					; size = 4
_lDiskFree$ = 16					; size = 4
_PrintFreeSpace PROC					; COMDAT

; 3314 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _hwndTextBox$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 10	 mov	 ebx, DWORD PTR _lDiskFree$[ebp]
  0001a	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _hwndTextBox$GSCopy$1$[ebp], eax
  00020	8b 45 0c	 mov	 eax, DWORD PTR _lpszDrive$[ebp]
  00023	56		 push	 esi

; 3315 : 	char *nResourceString;
; 3316 : 	int nMultiplier;
; 3317 : 	wchar_t szTmp2[256];
; 3318 : 
; 3319 : 	if (lDiskFree->QuadPart < BYTES_PER_KB)

  00024	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00027	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _lpszDrive$GSCopy$1$[ebp], eax
  0002d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002f	57		 push	 edi
  00030	85 c9		 test	 ecx, ecx
  00032	0f 8f a7 00 00
	00		 jg	 $LN6@PrintFreeS
  00038	7c 07		 jl	 SHORT $LN37@PrintFreeS
  0003a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0003f	73 30		 jae	 SHORT $LN2@PrintFreeS
$LN37@PrintFreeS:

; 3324 : 		nMultiplier = BYTES_PER_MB;
; 3325 : 	else
; 3326 : 		nMultiplier = BYTES_PER_GB;
; 3327 : 
; 3328 : 	if (nMultiplier == 1)
; 3329 : 	{
; 3330 : 		if (bHiddenVol && !bHiddenVolHost)	// If it's a hidden volume

  00041	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00048	bf 01 00 00 00	 mov	 edi, 1
  0004d	74 13		 je	 SHORT $LN10@PrintFreeS
  0004f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00056	75 0a		 jne	 SHORT $LN10@PrintFreeS

; 3331 : 			nResourceString = "MAX_HIDVOL_SIZE_BYTES";

  00058	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@OMPICDCM@MAX_HIDVOL_SIZE_BYTES?$AA@
  0005d	e9 af 00 00 00	 jmp	 $LN28@PrintFreeS
$LN10@PrintFreeS:

; 3332 : 		else if (bDevice)

  00062	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BC@DDPKPAD@DEVICE_FREE_BYTES?$AA@
  00067	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BA@GNIBCOCE@DISK_FREE_BYTES?$AA@

; 3333 : 			nResourceString = "DEVICE_FREE_BYTES";
; 3334 : 		else
; 3335 : 			nResourceString = "DISK_FREE_BYTES";

  0006c	e9 96 00 00 00	 jmp	 $LN43@PrintFreeS
$LN2@PrintFreeS:

; 3320 : 		nMultiplier = 1;
; 3321 : 	else if (lDiskFree->QuadPart < BYTES_PER_MB)

  00071	85 c9		 test	 ecx, ecx
  00073	7f 6a		 jg	 SHORT $LN6@PrintFreeS
  00075	7c 07		 jl	 SHORT $LN38@PrintFreeS
  00077	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  0007c	73 2a		 jae	 SHORT $LN4@PrintFreeS
$LN38@PrintFreeS:

; 3336 : 	}
; 3337 : 	else if (nMultiplier == BYTES_PER_KB)
; 3338 : 	{
; 3339 : 		if (bHiddenVol && !bHiddenVolHost)	// If it's a hidden volume

  0007e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00085	bf 00 04 00 00	 mov	 edi, 1024		; 00000400H
  0008a	74 10		 je	 SHORT $LN16@PrintFreeS
  0008c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00093	75 07		 jne	 SHORT $LN16@PrintFreeS

; 3340 : 			nResourceString = "MAX_HIDVOL_SIZE_KB";

  00095	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BD@NCFPMHAA@MAX_HIDVOL_SIZE_KB?$AA@
  0009a	eb 75		 jmp	 SHORT $LN28@PrintFreeS
$LN16@PrintFreeS:

; 3341 : 		else if (bDevice)

  0009c	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0P@IKBGAMLK@DEVICE_FREE_KB?$AA@
  000a1	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@LDEICJLE@DISK_FREE_KB?$AA@

; 3342 : 			nResourceString = "DEVICE_FREE_KB";
; 3343 : 		else
; 3344 : 			nResourceString = "DISK_FREE_KB";

  000a6	eb 5f		 jmp	 SHORT $LN43@PrintFreeS
$LN4@PrintFreeS:

; 3322 : 		nMultiplier = BYTES_PER_KB;
; 3323 : 	else if (lDiskFree->QuadPart < BYTES_PER_GB)

  000a8	85 c9		 test	 ecx, ecx
  000aa	7f 33		 jg	 SHORT $LN6@PrintFreeS
  000ac	7c 07		 jl	 SHORT $LN39@PrintFreeS
  000ae	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  000b3	73 2a		 jae	 SHORT $LN6@PrintFreeS
$LN39@PrintFreeS:

; 3345 : 	}
; 3346 : 	else if (nMultiplier == BYTES_PER_MB)
; 3347 : 	{
; 3348 : 		if (bHiddenVol && !bHiddenVolHost)	// If it's a hidden volume

  000b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  000bc	bf 00 00 10 00	 mov	 edi, 1048576		; 00100000H
  000c1	74 10		 je	 SHORT $LN22@PrintFreeS
  000c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  000ca	75 07		 jne	 SHORT $LN22@PrintFreeS

; 3349 : 			nResourceString = "MAX_HIDVOL_SIZE_MB";

  000cc	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BD@NGNCLLLC@MAX_HIDVOL_SIZE_MB?$AA@
  000d1	eb 3e		 jmp	 SHORT $LN28@PrintFreeS
$LN22@PrintFreeS:

; 3350 : 		else if (bDevice)

  000d3	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0P@IOJLHAAI@DEVICE_FREE_MB?$AA@
  000d8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@LHMFFFAG@DISK_FREE_MB?$AA@

; 3351 : 			nResourceString = "DEVICE_FREE_MB";
; 3352 : 		else
; 3353 : 			nResourceString = "DISK_FREE_MB";
; 3354 : 	}
; 3355 :  	else 

  000dd	eb 28		 jmp	 SHORT $LN43@PrintFreeS
$LN6@PrintFreeS:

; 3356 : 	{
; 3357 : 		if (bHiddenVol && !bHiddenVolHost)	// If it's a hidden volume

  000df	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  000e6	bf 00 00 00 40	 mov	 edi, 1073741824		; 40000000H
  000eb	74 10		 je	 SHORT $LN26@PrintFreeS
  000ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  000f4	75 07		 jne	 SHORT $LN26@PrintFreeS

; 3358 : 			nResourceString = "MAX_HIDVOL_SIZE_GB";

  000f6	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BD@NLEFDOGE@MAX_HIDVOL_SIZE_GB?$AA@
  000fb	eb 14		 jmp	 SHORT $LN28@PrintFreeS
$LN26@PrintFreeS:

; 3359 : 		else if (bDevice)

  000fd	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0P@IDAMPFNO@DEVICE_FREE_GB?$AA@
  00102	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@LKFCNANA@DISK_FREE_GB?$AA@
$LN43@PrintFreeS:
  00107	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  0010e	0f 44 f0	 cmove	 esi, eax
$LN28@PrintFreeS:

; 3360 : 			nResourceString = "DEVICE_FREE_GB";
; 3361 : 		else
; 3362 : 			nResourceString = "DISK_FREE_GB";
; 3363 : 	}
; 3364 : 
; 3365 : 	if (bHiddenVol && !bHiddenVolHost)	// If it's a hidden volume

  00111	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00118	74 68		 je	 SHORT $LN30@PrintFreeS
  0011a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00121	75 5f		 jne	 SHORT $LN30@PrintFreeS

; 3366 : 	{
; 3367 : 		_snwprintf (szTmp2, sizeof szTmp2 / 2, GetString (nResourceString), ((double) lDiskFree->QuadPart) / nMultiplier);

  00123	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00126	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00128	e8 00 00 00 00	 call	 __ltod3
  0012d	66 0f 6e cf	 movd	 xmm1, edi
  00131	83 ec 08	 sub	 esp, 8
  00134	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00138	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0013c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00141	56		 push	 esi
  00142	e8 00 00 00 00	 call	 _GetString
  00147	83 c4 04	 add	 esp, 4
  0014a	50		 push	 eax
  0014b	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00151	68 00 01 00 00	 push	 256			; 00000100H
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 __snwprintf
  0015c	83 c4 14	 add	 esp, 20			; 00000014H

; 3368 : 		SetWindowTextW (GetDlgItem (hwndTextBox, IDC_SIZEBOX), szTmp2);

  0015f	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00165	50		 push	 eax
  00166	68 0e 04 00 00	 push	 1038			; 0000040eH
  0016b	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _hwndTextBox$GSCopy$1$[ebp]
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00177	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  0017d	50		 push	 eax
  0017e	ff d6		 call	 esi

; 3369 : 	}
; 3370 : 	else

  00180	eb 48		 jmp	 SHORT $LN31@PrintFreeS
$LN30@PrintFreeS:

; 3371 : 		_snwprintf (szTmp2, sizeof szTmp2 / 2, GetString (nResourceString), lpszDrive, ((double) lDiskFree->QuadPart) / nMultiplier);

  00182	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00185	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00187	e8 00 00 00 00	 call	 __ltod3
  0018c	66 0f 6e cf	 movd	 xmm1, edi
  00190	83 ec 08	 sub	 esp, 8
  00193	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00197	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0019b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001a0	ff b5 f4 fd ff
	ff		 push	 DWORD PTR _lpszDrive$GSCopy$1$[ebp]
  001a6	56		 push	 esi
  001a7	e8 00 00 00 00	 call	 _GetString
  001ac	83 c4 04	 add	 esp, 4
  001af	50		 push	 eax
  001b0	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  001b6	68 00 01 00 00	 push	 256			; 00000100H
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 __snwprintf
  001c1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  001c7	83 c4 18	 add	 esp, 24			; 00000018H
$LN31@PrintFreeS:

; 3372 : 
; 3373 : 	SetWindowTextW (hwndTextBox, szTmp2);

  001ca	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  001d0	50		 push	 eax
  001d1	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _hwndTextBox$GSCopy$1$[ebp]
  001d7	ff d6		 call	 esi

; 3374 : 
; 3375 : 	if (lDiskFree->QuadPart % (__int64) BYTES_PER_MB != 0)

  001d9	6a 00		 push	 0
  001db	68 00 00 10 00	 push	 1048576			; 00100000H
  001e0	ff 73 04	 push	 DWORD PTR [ebx+4]
  001e3	ff 33		 push	 DWORD PTR [ebx]
  001e5	e8 00 00 00 00	 call	 __allrem
  001ea	0b c2		 or	 eax, edx

; 3376 : 		nMultiplier = BYTES_PER_KB;
; 3377 : 
; 3378 : 	return nMultiplier;

  001ec	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  001f1	75 02		 jne	 SHORT $LN32@PrintFreeS
  001f3	8b c7		 mov	 eax, edi
$LN32@PrintFreeS:

; 3379 : }

  001f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f8	5f		 pop	 edi
  001f9	5e		 pop	 esi
  001fa	33 cd		 xor	 ecx, ebp
  001fc	5b		 pop	 ebx
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c3		 ret	 0
_PrintFreeSpace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _LoadPage
_TEXT	SEGMENT
_rD$ = -104						; size = 16
_rW$ = -88						; size = 16
_tmp$1 = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_nPageNo$ = 12						; size = 4
_LoadPage PROC						; COMDAT

; 3029 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3030 : 	RECT rD, rW;
; 3031 : 
; 3032 : 	nLastPageNo = nCurPageNo;
; 3033 : 
; 3034 : 	if (hCurPage != NULL)

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  0001b	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastPageNo@@3HA, ecx ; nLastPageNo
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	74 57		 je	 SHORT $LN8@LoadPage

; 3035 : 	{
; 3036 : 		// WARNING: nCurPageNo must be set to a non-existent ID here before wiping the password fields below in
; 3037 : 		// this function, etc. Otherwise, such actions (SetWindowText) would invoke the EN_CHANGE handlers, which 
; 3038 : 		// would, if keyfiles were applied, e.g. use strlen() on a buffer full of random data, in most cases 
; 3039 : 		// not null-terminated.
; 3040 : 		nCurPageNo = -1;

  0002b	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?nCurPageNo@@3HA, -1 ; nCurPageNo

; 3041 : 
; 3042 : 
; 3043 : 		// Place here any actions that need to be performed at the latest possible time when leaving a wizard page
; 3044 : 		// (i.e. right before "destroying" the page). Also, code that needs to be executed both on IDC_NEXT and
; 3045 : 		// on IDC_PREV can be placed here so as to avoid code doubling. 
; 3046 : 
; 3047 : 		switch (nLastPageNo)

  00035	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00038	75 37		 jne	 SHORT $LN2@LoadPage

; 3048 : 		{
; 3049 : 		case PASSWORD_PAGE:
; 3050 : 			{
; 3051 : 				char tmp[MAX_PASSWORD+1];
; 3052 : 
; 3053 : 				// Attempt to wipe passwords stored in the input field buffers. This is performed here (and 
; 3054 : 				// not in the IDC_PREV or IDC_NEXT sections) in order to prevent certain race conditions
; 3055 : 				// when keyfiles are used.
; 3056 : 				memset (tmp, 'X', MAX_PASSWORD);

  0003a	6a 40		 push	 64			; 00000040H
  0003c	8d 45 b8	 lea	 eax, DWORD PTR _tmp$1[ebp]
  0003f	6a 58		 push	 88			; 00000058H
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _memset

; 3057 : 				tmp [MAX_PASSWORD] = 0;
; 3058 : 				SetWindowText (hPasswordInputField, tmp);

  00047	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  0004d	8d 45 b8	 lea	 eax, DWORD PTR _tmp$1[ebp]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	c6 45 f8 00	 mov	 BYTE PTR _tmp$1[ebp+64], 0
  00057	50		 push	 eax
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPasswordInputField@@3RAUHWND__@@A ; hPasswordInputField
  0005d	50		 push	 eax
  0005e	ff d6		 call	 esi

; 3059 : 				SetWindowText (hVerifyPasswordInputField, tmp);

  00060	8d 45 b8	 lea	 eax, DWORD PTR _tmp$1[ebp]
  00063	50		 push	 eax
  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVerifyPasswordInputField@@3RAUHWND__@@A ; hVerifyPasswordInputField
  00069	50		 push	 eax
  0006a	ff d6		 call	 esi
  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCurPage
$LN2@LoadPage:

; 3060 : 			}
; 3061 : 			break;
; 3062 : 		}
; 3063 : 
; 3064 : 		DestroyWindow (hCurPage);

  00071	50		 push	 eax
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4

; 3065 : 		hCurPage = NULL;

  00078	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hCurPage, 0
$LN8@LoadPage:

; 3066 : 	}
; 3067 : 
; 3068 : 	// This prevents the mouse pointer from remaining as the "hand" cursor when the user presses Enter
; 3069 : 	// while hovering over a hyperlink.
; 3070 : 	bHyperLinkBeingTracked = FALSE;

  00082	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHyperLinkBeingTracked, 0

; 3071 : 	NormalCursor();

  0008c	e8 00 00 00 00	 call	 _NormalCursor

; 3072 : 
; 3073 : 	GetWindowRect (GetDlgItem (hwndDlg, IDC_POS_BOX), &rW);

  00091	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00097	8d 45 a8	 lea	 eax, DWORD PTR _rW$[ebp]
  0009a	50		 push	 eax
  0009b	68 23 04 00 00	 push	 1059			; 00000423H
  000a0	57		 push	 edi
  000a1	ff d6		 call	 esi
  000a3	50		 push	 eax
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 3074 : 
; 3075 : 
; 3076 : 	nCurPageNo = nPageNo;

  000aa	8b 5d 0c	 mov	 ebx, DWORD PTR _nPageNo$[ebp]
  000ad	89 1d 00 00 00
	00		 mov	 DWORD PTR ?nCurPageNo@@3HA, ebx ; nCurPageNo

; 3077 : 
; 3078 : 
; 3079 : 	switch (nPageNo)

  000b3	83 fb 2b	 cmp	 ebx, 43			; 0000002bH
  000b6	0f 87 26 02 00
	00		 ja	 $LN4@LoadPage
  000bc	ff 24 9d 00 00
	00 00		 jmp	 DWORD PTR $LN72@LoadPage[ebx*4]
$LN10@LoadPage:

; 3080 : 	{
; 3081 : 	case INTRO_PAGE:
; 3082 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INTRO_PAGE_DLG), hwndDlg,

  000c3	6a 00		 push	 0
  000c5	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  000ca	57		 push	 edi
  000cb	6a 6b		 push	 107			; 0000006bH

; 3083 : 					 (DLGPROC) PageDialogProc);
; 3084 : 		break;

  000cd	e9 ff 01 00 00	 jmp	 $LN69@LoadPage
$LN11@LoadPage:

; 3085 : 
; 3086 : 	case SYSENC_TYPE_PAGE:
; 3087 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SYSENC_TYPE_PAGE_DLG), hwndDlg,

  000d2	6a 00		 push	 0
  000d4	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  000d9	57		 push	 edi
  000da	6a 7e		 push	 126			; 0000007eH

; 3088 : 					 (DLGPROC) PageDialogProc);
; 3089 : 		break;

  000dc	e9 f0 01 00 00	 jmp	 $LN69@LoadPage
$LN12@LoadPage:

; 3090 : 
; 3091 : 	case SYSENC_HIDDEN_OS_REQ_CHECK_PAGE:
; 3092 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SYSENC_HIDDEN_OS_REQ_CHECK_PAGE_DLG), hwndDlg,

  000e1	6a 00		 push	 0
  000e3	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  000e8	57		 push	 edi
  000e9	6a 7f		 push	 127			; 0000007fH

; 3093 : 					 (DLGPROC) PageDialogProc);
; 3094 : 		break;

  000eb	e9 e1 01 00 00	 jmp	 $LN69@LoadPage
$LN13@LoadPage:

; 3095 : 
; 3096 : 	case SYSENC_SPAN_PAGE:
; 3097 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SYSENC_SPAN_PAGE_DLG), hwndDlg,

  000f0	6a 00		 push	 0
  000f2	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  000f7	57		 push	 edi
  000f8	6a 73		 push	 115			; 00000073H

; 3098 : 					 (DLGPROC) PageDialogProc);
; 3099 : 		break;

  000fa	e9 d2 01 00 00	 jmp	 $LN69@LoadPage
$LN14@LoadPage:

; 3100 : 
; 3101 : 	case SYSENC_PRE_DRIVE_ANALYSIS_PAGE:
; 3102 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_UNIVERSAL_DUAL_CHOICE_PAGE_DLG), hwndDlg,

  000ff	6a 00		 push	 0
  00101	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00106	57		 push	 edi
  00107	6a 7c		 push	 124			; 0000007cH

; 3103 : 					 (DLGPROC) PageDialogProc);
; 3104 : 		break;

  00109	e9 c3 01 00 00	 jmp	 $LN69@LoadPage
$LN15@LoadPage:

; 3105 : 
; 3106 : 	case SYSENC_DRIVE_ANALYSIS_PAGE:
; 3107 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SYSENC_DRIVE_ANALYSIS_PAGE_DLG), hwndDlg,

  0010e	6a 00		 push	 0
  00110	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00115	57		 push	 edi
  00116	6a 7d		 push	 125			; 0000007dH

; 3108 : 					 (DLGPROC) PageDialogProc);
; 3109 : 		break;

  00118	e9 b4 01 00 00	 jmp	 $LN69@LoadPage
$LN16@LoadPage:

; 3110 : 
; 3111 : 	case SYSENC_MULTI_BOOT_MODE_PAGE:
; 3112 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SYSENC_MULTI_BOOT_MODE_PAGE_DLG), hwndDlg,

  0011d	6a 00		 push	 0
  0011f	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00124	57		 push	 edi
  00125	6a 77		 push	 119			; 00000077H

; 3113 : 					 (DLGPROC) PageDialogProc);
; 3114 : 		break;

  00127	e9 a5 01 00 00	 jmp	 $LN69@LoadPage
$LN18@LoadPage:

; 3115 : 
; 3116 : 	case SYSENC_MULTI_BOOT_SYS_EQ_BOOT_PAGE:
; 3117 : 	case SYSENC_MULTI_BOOT_NBR_SYS_DRIVES_PAGE:
; 3118 : 	case SYSENC_MULTI_BOOT_ADJACENT_SYS_PAGE:
; 3119 : 	case SYSENC_MULTI_BOOT_NONWIN_BOOT_LOADER_PAGE:
; 3120 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_UNIVERSAL_DUAL_CHOICE_PAGE_DLG), hwndDlg,
; 3121 : 					 (DLGPROC) PageDialogProc);
; 3122 : 		break;
; 3123 : 
; 3124 : 	case SYSENC_MULTI_BOOT_OUTCOME_PAGE:
; 3125 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INFO_PAGE_DLG), hwndDlg,

  0012c	6a 00		 push	 0
  0012e	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00133	57		 push	 edi
  00134	6a 6c		 push	 108			; 0000006cH

; 3126 : 					 (DLGPROC) PageDialogProc);
; 3127 : 		break;

  00136	e9 96 01 00 00	 jmp	 $LN69@LoadPage
$LN19@LoadPage:

; 3128 : 
; 3129 : 	case VOLUME_TYPE_PAGE:
; 3130 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_VOLUME_TYPE_PAGE_DLG), hwndDlg,

  0013b	6a 00		 push	 0
  0013d	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00142	57		 push	 edi
  00143	6a 71		 push	 113			; 00000071H

; 3131 : 					 (DLGPROC) PageDialogProc);
; 3132 : 		break;

  00145	e9 87 01 00 00	 jmp	 $LN69@LoadPage
$LN20@LoadPage:

; 3133 : 
; 3134 : 	case HIDDEN_VOL_WIZARD_MODE_PAGE:
; 3135 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_HIDDEN_VOL_WIZARD_MODE_PAGE_DLG), hwndDlg,

  0014a	6a 00		 push	 0
  0014c	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00151	57		 push	 edi
  00152	6a 6e		 push	 110			; 0000006eH

; 3136 : 					 (DLGPROC) PageDialogProc);
; 3137 : 		break;

  00154	e9 78 01 00 00	 jmp	 $LN69@LoadPage
$LN21@LoadPage:

; 3138 : 
; 3139 : 	case VOLUME_LOCATION_PAGE:
; 3140 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_VOLUME_LOCATION_PAGE_DLG), hwndDlg,

  00159	6a 00		 push	 0
  0015b	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00160	57		 push	 edi
  00161	6a 69		 push	 105			; 00000069H
  00163	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20

; 3141 : 					 (DLGPROC) PageDialogProc);
; 3142 : 
; 3143 : 		EnableWindow (GetDlgItem(hCurPage, IDC_NO_HISTORY), !bHistoryCmdLine);

  0016f	33 c9		 xor	 ecx, ecx
  00171	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
  00176	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?bHistoryCmdLine@@3HA, ecx ; bHistoryCmdLine
  0017c	0f 94 c1	 sete	 cl
  0017f	51		 push	 ecx
  00180	68 f4 03 00 00	 push	 1012			; 000003f4H
  00185	50		 push	 eax
  00186	ff d6		 call	 esi
  00188	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  0018e	50		 push	 eax
  0018f	ff d6		 call	 esi

; 3144 : 
; 3145 : 		EnableWindow (GetDlgItem (hwndDlg, IDC_NEXT), 

  00191	68 ea 03 00 00	 push	 1002			; 000003eaH
  00196	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001a2	50		 push	 eax
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  001a9	33 c9		 xor	 ecx, ecx
  001ab	85 c0		 test	 eax, eax
  001ad	0f 9f c1	 setg	 cl
  001b0	51		 push	 ecx
  001b1	68 10 04 00 00	 push	 1040			; 00000410H
  001b6	57		 push	 edi
  001b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001bd	50		 push	 eax
  001be	ff d6		 call	 esi

; 3146 : 			GetWindowTextLength (GetDlgItem (hCurPage, IDC_COMBO_BOX)) > 0);
; 3147 : 
; 3148 : 		break;

  001c0	e9 1d 01 00 00	 jmp	 $LN4@LoadPage
$LN22@LoadPage:

; 3149 : 
; 3150 : 	case DEVICE_TRANSFORM_MODE_PAGE:
; 3151 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_DEVICE_TRANSFORM_MODE_DLG), hwndDlg,

  001c5	6a 00		 push	 0
  001c7	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  001cc	57		 push	 edi
  001cd	68 82 00 00 00	 push	 130			; 00000082H

; 3152 : 					 (DLGPROC) PageDialogProc);
; 3153 : 		break;

  001d2	e9 fa 00 00 00	 jmp	 $LN69@LoadPage
$LN25@LoadPage:

; 3154 : 	case HIDDEN_VOL_HOST_PRE_CIPHER_PAGE:
; 3155 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INFO_PAGE_DLG), hwndDlg,
; 3156 : 					 (DLGPROC) PageDialogProc);
; 3157 : 		break;
; 3158 : 	case HIDDEN_VOL_PRE_CIPHER_PAGE:
; 3159 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INFO_PAGE_DLG), hwndDlg,
; 3160 : 					 (DLGPROC) PageDialogProc);
; 3161 : 		break;
; 3162 : 	case CIPHER_PAGE:
; 3163 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_CIPHER_PAGE_DLG), hwndDlg,

  001d7	6a 00		 push	 0
  001d9	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  001de	57		 push	 edi
  001df	6a 66		 push	 102			; 00000066H

; 3164 : 					 (DLGPROC) PageDialogProc);
; 3165 : 		break;

  001e1	e9 eb 00 00 00	 jmp	 $LN69@LoadPage
$LN26@LoadPage:

; 3166 : 	case SIZE_PAGE:
; 3167 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SIZE_PAGE_DLG), hwndDlg,

  001e6	6a 00		 push	 0
  001e8	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  001ed	57		 push	 edi
  001ee	6a 67		 push	 103			; 00000067H

; 3168 : 					 (DLGPROC) PageDialogProc);
; 3169 : 		break;

  001f0	e9 dc 00 00 00	 jmp	 $LN69@LoadPage
$LN27@LoadPage:

; 3170 : 	case HIDDEN_VOL_HOST_PASSWORD_PAGE:
; 3171 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_PASSWORD_ENTRY_PAGE_DLG), hwndDlg,

  001f5	6a 00		 push	 0
  001f7	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  001fc	57		 push	 edi
  001fd	6a 6f		 push	 111			; 0000006fH

; 3172 : 					 (DLGPROC) PageDialogProc);
; 3173 : 		break;

  001ff	e9 cd 00 00 00	 jmp	 $LN69@LoadPage
$LN28@LoadPage:

; 3174 : 	case PASSWORD_PAGE:
; 3175 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_PASSWORD_PAGE_DLG), hwndDlg,

  00204	6a 00		 push	 0
  00206	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  0020b	57		 push	 edi
  0020c	6a 68		 push	 104			; 00000068H

; 3176 : 					 (DLGPROC) PageDialogProc);
; 3177 : 		break;

  0020e	e9 be 00 00 00	 jmp	 $LN69@LoadPage
$LN30@LoadPage:

; 3178 : 	case FILESYS_PAGE:
; 3179 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_UNIVERSAL_DUAL_CHOICE_PAGE_DLG), hwndDlg,
; 3180 : 					 (DLGPROC) PageDialogProc);
; 3181 : 		break;
; 3182 : 	case SYSENC_COLLECTING_RANDOM_DATA_PAGE:
; 3183 : 	case NONSYS_INPLACE_ENC_RAND_DATA_PAGE:
; 3184 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SYSENC_COLLECTING_RANDOM_DATA_DLG), hwndDlg,

  00213	6a 00		 push	 0
  00215	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  0021a	57		 push	 edi
  0021b	6a 76		 push	 118			; 00000076H

; 3185 : 					 (DLGPROC) PageDialogProc);
; 3186 : 		break;

  0021d	e9 af 00 00 00	 jmp	 $LN69@LoadPage
$LN31@LoadPage:

; 3187 : 	case SYSENC_KEYS_GEN_PAGE:
; 3188 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SYSENC_KEYS_GEN_PAGE_DLG), hwndDlg,

  00222	6a 00		 push	 0
  00224	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00229	57		 push	 edi
  0022a	6a 7b		 push	 123			; 0000007bH

; 3189 : 					 (DLGPROC) PageDialogProc);
; 3190 : 		break;

  0022c	e9 a0 00 00 00	 jmp	 $LN69@LoadPage
$LN32@LoadPage:

; 3191 : 	case SYSENC_RESCUE_DISK_CREATION_PAGE:
; 3192 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SYSENC_RESCUE_DISK_CREATION_DLG), hwndDlg,

  00231	6a 00		 push	 0
  00233	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00238	57		 push	 edi
  00239	6a 75		 push	 117			; 00000075H

; 3193 : 					 (DLGPROC) PageDialogProc);
; 3194 : 		break;

  0023b	e9 91 00 00 00	 jmp	 $LN69@LoadPage
$LN33@LoadPage:

; 3195 : 	case SYSENC_RESCUE_DISK_BURN_PAGE:
; 3196 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SYSENC_RESCUE_DISK_BURN_PAGE_DLG), hwndDlg,

  00240	6a 00		 push	 0
  00242	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00247	57		 push	 edi
  00248	6a 78		 push	 120			; 00000078H

; 3197 : 			(DLGPROC) PageDialogProc);
; 3198 : 		break;

  0024a	e9 82 00 00 00	 jmp	 $LN69@LoadPage
$LN35@LoadPage:

; 3199 : 	case SYSENC_RESCUE_DISK_VERIFIED_PAGE:
; 3200 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INFO_PAGE_DLG), hwndDlg,
; 3201 : 					 (DLGPROC) PageDialogProc);
; 3202 : 		break;
; 3203 : 	case SYSENC_WIPE_MODE_PAGE:
; 3204 : 	case NONSYS_INPLACE_ENC_WIPE_MODE_PAGE:
; 3205 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_SYSENC_WIPE_MODE_PAGE_DLG), hwndDlg,

  0024f	6a 00		 push	 0
  00251	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00256	57		 push	 edi
  00257	6a 79		 push	 121			; 00000079H

; 3206 : 			(DLGPROC) PageDialogProc);
; 3207 : 		break;

  00259	eb 76		 jmp	 SHORT $LN69@LoadPage
$LN38@LoadPage:

; 3208 : 	case SYSENC_PRETEST_INFO_PAGE:
; 3209 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INFO_PAGE_DLG), hwndDlg,
; 3210 : 					 (DLGPROC) PageDialogProc);
; 3211 : 		break;
; 3212 : 	case SYSENC_PRETEST_RESULT_PAGE:
; 3213 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INFO_PAGE_DLG), hwndDlg,
; 3214 : 					 (DLGPROC) PageDialogProc);
; 3215 : 		break;
; 3216 : 	case SYSENC_ENCRYPTION_PAGE:
; 3217 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INPLACE_ENCRYPTION_PAGE_DLG), hwndDlg,

  0025b	6a 00		 push	 0
  0025d	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00262	57		 push	 edi
  00263	6a 7a		 push	 122			; 0000007aH

; 3218 : 			(DLGPROC) PageDialogProc);
; 3219 : 		break;

  00265	eb 6a		 jmp	 SHORT $LN69@LoadPage
$LN40@LoadPage:

; 3220 : 
; 3221 : 	case NONSYS_INPLACE_ENC_RESUME_PASSWORD_PAGE:
; 3222 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_PASSWORD_ENTRY_PAGE_DLG), hwndDlg,
; 3223 : 			(DLGPROC) PageDialogProc);
; 3224 : 		break;
; 3225 : 
; 3226 : 	case NONSYS_INPLACE_ENC_RESUME_PARTITION_SEL_PAGE:
; 3227 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_EXPANDED_LIST_SELECT_PAGE_DLG), hwndDlg,

  00267	6a 00		 push	 0
  00269	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  0026e	57		 push	 edi
  0026f	68 83 00 00 00	 push	 131			; 00000083H

; 3228 : 			(DLGPROC) PageDialogProc);
; 3229 : 		break;

  00274	eb 5b		 jmp	 SHORT $LN69@LoadPage
$LN43@LoadPage:

; 3230 : 
; 3231 : 	case NONSYS_INPLACE_ENC_ENCRYPTION_PAGE:
; 3232 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INPLACE_ENCRYPTION_PAGE_DLG), hwndDlg,
; 3233 : 			(DLGPROC) PageDialogProc);
; 3234 : 		break;
; 3235 : 
; 3236 : 	case NONSYS_INPLACE_ENC_ENCRYPTION_FINISHED_PAGE:
; 3237 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INFO_PAGE_DLG), hwndDlg,
; 3238 : 					 (DLGPROC) PageDialogProc);
; 3239 : 		break;
; 3240 : 
; 3241 : 	case FORMAT_PAGE:
; 3242 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_FORMAT_PAGE_DLG), hwndDlg,

  00276	6a 00		 push	 0
  00278	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  0027d	57		 push	 edi
  0027e	6a 6a		 push	 106			; 0000006aH

; 3243 : 					 (DLGPROC) PageDialogProc);
; 3244 : 		break;

  00280	eb 4f		 jmp	 SHORT $LN69@LoadPage
$LN44@LoadPage:

; 3245 : 	case FORMAT_FINISHED_PAGE:
; 3246 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW ((bHiddenVol && !bHiddenVolHost && !bHiddenVolFinished) ? IDD_HIDVOL_HOST_FILL_PAGE_DLG : IDD_INFO_PAGE_DLG), hwndDlg,

  00282	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00289	74 17		 je	 SHORT $LN57@LoadPage
  0028b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00292	75 0e		 jne	 SHORT $LN57@LoadPage
  00294	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVolFinished@@3HC, 0 ; bHiddenVolFinished
  0029b	b8 6d 00 00 00	 mov	 eax, 109		; 0000006dH
  002a0	74 05		 je	 SHORT $LN58@LoadPage
$LN57@LoadPage:
  002a2	b8 6c 00 00 00	 mov	 eax, 108		; 0000006cH
$LN58@LoadPage:
  002a7	6a 00		 push	 0
  002a9	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  002ae	57		 push	 edi
  002af	0f b7 c0	 movzx	 eax, ax
  002b2	50		 push	 eax

; 3247 : 					 (DLGPROC) PageDialogProc);
; 3248 : 		break;

  002b3	eb 1c		 jmp	 SHORT $LN69@LoadPage
$LN47@LoadPage:

; 3249 : 
; 3250 : 	case SYSENC_HIDDEN_OS_INITIAL_INFO_PAGE:
; 3251 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INFO_PAGE_DLG), hwndDlg, (DLGPROC) PageDialogProc);
; 3252 : 		break;
; 3253 : 
; 3254 : 	case SYSENC_HIDDEN_OS_WIPE_INFO_PAGE:
; 3255 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INFO_PAGE_DLG), hwndDlg, (DLGPROC) PageDialogProc);
; 3256 : 		break;
; 3257 : 
; 3258 : 	case DEVICE_WIPE_MODE_PAGE:
; 3259 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_DEVICE_WIPE_MODE_PAGE_DLG), hwndDlg, (DLGPROC) PageDialogProc);

  002b5	6a 00		 push	 0
  002b7	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  002bc	57		 push	 edi
  002bd	68 81 00 00 00	 push	 129			; 00000081H

; 3260 : 		break;

  002c2	eb 0d		 jmp	 SHORT $LN69@LoadPage
$LN48@LoadPage:

; 3261 : 
; 3262 : 	case DEVICE_WIPE_PAGE:
; 3263 : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_DEVICE_WIPE_PAGE_DLG), hwndDlg, (DLGPROC) PageDialogProc);

  002c4	6a 00		 push	 0
  002c6	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  002cb	57		 push	 edi
  002cc	68 80 00 00 00	 push	 128			; 00000080H
$LN69@LoadPage:
  002d1	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  002d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  002dd	a3 00 00 00 00	 mov	 DWORD PTR _hCurPage, eax
$LN4@LoadPage:

; 3264 : 		break;
; 3265 : 	}
; 3266 : 
; 3267 : 	rD.left = 162;
; 3268 : 	rD.top = 25;
; 3269 : 	rD.right = 0;
; 3270 : 	rD.bottom = 0;
; 3271 : 	MapDialogRect (hwndDlg, &rD);

  002e2	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000000000019000000a2
  002e9	8d 45 98	 lea	 eax, DWORD PTR _rD$[ebp]
  002ec	50		 push	 eax
  002ed	57		 push	 edi
  002ee	0f 11 45 98	 movups	 XMMWORD PTR _rD$[ebp], xmm0
  002f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8

; 3272 : 
; 3273 : 	if (hCurPage != NULL)

  002f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hCurPage
  002fe	85 c9		 test	 ecx, ecx
  00300	0f 84 8a 00 00
	00		 je	 $LN53@LoadPage

; 3274 : 	{
; 3275 : 		MoveWindow (hCurPage, rD.left, rD.top, rW.right - rW.left, rW.bottom - rW.top, TRUE);

  00306	8b 45 b4	 mov	 eax, DWORD PTR _rW$[ebp+12]
  00309	2b 45 ac	 sub	 eax, DWORD PTR _rW$[ebp+4]
  0030c	6a 01		 push	 1
  0030e	50		 push	 eax
  0030f	8b 45 b0	 mov	 eax, DWORD PTR _rW$[ebp+8]
  00312	2b 45 a8	 sub	 eax, DWORD PTR _rW$[ebp]
  00315	50		 push	 eax
  00316	ff 75 9c	 push	 DWORD PTR _rD$[ebp+4]
  00319	ff 75 98	 push	 DWORD PTR _rD$[ebp]
  0031c	51		 push	 ecx
  0031d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24

; 3276 : 		ShowWindow (hCurPage, SW_SHOWNORMAL);

  00323	6a 01		 push	 1
  00325	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0032b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 3277 : 
; 3278 : 		// Place here any message boxes that need to be displayed as soon as a new page is displayed. This 
; 3279 : 		// ensures that the page is fully rendered (otherwise it would remain blank, until the message box
; 3280 : 		// is closed).
; 3281 : 		switch (nPageNo)

  00331	83 fb 12	 cmp	 ebx, 18			; 00000012H
  00334	74 32		 je	 SHORT $LN52@LoadPage
  00336	83 fb 15	 cmp	 ebx, 21			; 00000015H
  00339	75 55		 jne	 SHORT $LN53@LoadPage

; 3282 : 		{
; 3283 : 		case PASSWORD_PAGE:
; 3284 : 
; 3285 : 			CheckCapsLock (hwndDlg, FALSE);

  0033b	6a 00		 push	 0
  0033d	57		 push	 edi
  0033e	e8 00 00 00 00	 call	 _CheckCapsLock
  00343	83 c4 08	 add	 esp, 8

; 3286 : 
; 3287 : 			if (CreatingHiddenSysVol())

  00346	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  0034d	74 41		 je	 SHORT $LN53@LoadPage
  0034f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00356	74 38		 je	 SHORT $LN53@LoadPage
  00358	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  0035f	75 2f		 jne	 SHORT $LN53@LoadPage

; 3288 : 				Warning ("PASSWORD_HIDDEN_OS_NOTE");

  00361	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DFBMOJJF@PASSWORD_HIDDEN_OS_NOTE?$AA@

; 3289 : 
; 3290 : 			break;

  00366	eb 20		 jmp	 SHORT $LN70@LoadPage
$LN52@LoadPage:

; 3291 : 
; 3292 : 		case CIPHER_PAGE:
; 3293 : 
; 3294 : 			if (CreatingHiddenSysVol())

  00368	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  0036f	74 1f		 je	 SHORT $LN53@LoadPage
  00371	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00378	74 16		 je	 SHORT $LN53@LoadPage
  0037a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00381	75 0d		 jne	 SHORT $LN53@LoadPage

; 3295 : 				Warning ("HIDDEN_OS_PRE_CIPHER_WARNING");

  00383	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GMGGDPEP@HIDDEN_OS_PRE_CIPHER_WARNING?$AA@
$LN70@LoadPage:
  00388	e8 00 00 00 00	 call	 _Warning
  0038d	83 c4 04	 add	 esp, 4
$LN53@LoadPage:

; 3296 : 
; 3297 : 			break;
; 3298 : 		}
; 3299 : 	}
; 3300 : }

  00390	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00393	5f		 pop	 edi
  00394	5e		 pop	 esi
  00395	33 cd		 xor	 ecx, ebp
  00397	5b		 pop	 ebx
  00398	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0039d	8b e5		 mov	 esp, ebp
  0039f	5d		 pop	 ebp
  003a0	c3		 ret	 0
  003a1	0f 1f 00	 npad	 3
$LN72@LoadPage:
  003a4	00 00 00 00	 DD	 $LN10@LoadPage
  003a8	00 00 00 00	 DD	 $LN11@LoadPage
  003ac	00 00 00 00	 DD	 $LN12@LoadPage
  003b0	00 00 00 00	 DD	 $LN13@LoadPage
  003b4	00 00 00 00	 DD	 $LN14@LoadPage
  003b8	00 00 00 00	 DD	 $LN15@LoadPage
  003bc	00 00 00 00	 DD	 $LN16@LoadPage
  003c0	00 00 00 00	 DD	 $LN14@LoadPage
  003c4	00 00 00 00	 DD	 $LN14@LoadPage
  003c8	00 00 00 00	 DD	 $LN14@LoadPage
  003cc	00 00 00 00	 DD	 $LN14@LoadPage
  003d0	00 00 00 00	 DD	 $LN18@LoadPage
  003d4	00 00 00 00	 DD	 $LN19@LoadPage
  003d8	00 00 00 00	 DD	 $LN20@LoadPage
  003dc	00 00 00 00	 DD	 $LN21@LoadPage
  003e0	00 00 00 00	 DD	 $LN22@LoadPage
  003e4	00 00 00 00	 DD	 $LN18@LoadPage
  003e8	00 00 00 00	 DD	 $LN18@LoadPage
  003ec	00 00 00 00	 DD	 $LN25@LoadPage
  003f0	00 00 00 00	 DD	 $LN26@LoadPage
  003f4	00 00 00 00	 DD	 $LN27@LoadPage
  003f8	00 00 00 00	 DD	 $LN28@LoadPage
  003fc	00 00 00 00	 DD	 $LN14@LoadPage
  00400	00 00 00 00	 DD	 $LN30@LoadPage
  00404	00 00 00 00	 DD	 $LN31@LoadPage
  00408	00 00 00 00	 DD	 $LN32@LoadPage
  0040c	00 00 00 00	 DD	 $LN33@LoadPage
  00410	00 00 00 00	 DD	 $LN18@LoadPage
  00414	00 00 00 00	 DD	 $LN35@LoadPage
  00418	00 00 00 00	 DD	 $LN18@LoadPage
  0041c	00 00 00 00	 DD	 $LN18@LoadPage
  00420	00 00 00 00	 DD	 $LN38@LoadPage
  00424	00 00 00 00	 DD	 $LN27@LoadPage
  00428	00 00 00 00	 DD	 $LN40@LoadPage
  0042c	00 00 00 00	 DD	 $LN30@LoadPage
  00430	00 00 00 00	 DD	 $LN35@LoadPage
  00434	00 00 00 00	 DD	 $LN38@LoadPage
  00438	00 00 00 00	 DD	 $LN18@LoadPage
  0043c	00 00 00 00	 DD	 $LN43@LoadPage
  00440	00 00 00 00	 DD	 $LN44@LoadPage
  00444	00 00 00 00	 DD	 $LN18@LoadPage
  00448	00 00 00 00	 DD	 $LN18@LoadPage
  0044c	00 00 00 00	 DD	 $LN47@LoadPage
  00450	00 00 00 00	 DD	 $LN48@LoadPage
_LoadPage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _volTransformThreadFunction
_TEXT	SEGMENT
_dwWin32FormatError$1$ = -17444				; size = 4
_hPartition$1 = -17440					; size = 4
_geometry$2 = -17436					; size = 24
_szMsg$3 = -17412					; size = 16384
_szTmp$4 = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_hwndDlgArg$ = 8					; size = 4
_volTransformThreadFunction PROC			; COMDAT

; 2703 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 24 44 00 00	 mov	 eax, 17444		; 00004424H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlgArg$[ebp]
  0001b	56		 push	 esi
  0001c	57		 push	 edi

; 2704 : 	int nStatus;
; 2705 : 	DWORD dwWin32FormatError;
; 2706 : 	BOOL bHidden;
; 2707 : 	HWND hwndDlg = (HWND) hwndDlgArg;
; 2708 : 	volatile FORMAT_VOL_PARAMETERS *volParams = (FORMAT_VOL_PARAMETERS *) malloc (sizeof(FORMAT_VOL_PARAMETERS));

  0001d	6a 50		 push	 80			; 00000050H
  0001f	e8 00 00 00 00	 call	 _malloc
  00024	8b f0		 mov	 esi, eax
  00026	83 c4 04	 add	 esp, 4

; 2709 : 
; 2710 : 	if (volParams == NULL)

  00029	85 f6		 test	 esi, esi
  0002b	75 0d		 jne	 SHORT $LN14@volTransfo

; 2711 : 		AbortProcess ("ERR_MEM_ALLOC");

  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@
  00032	e8 00 00 00 00	 call	 _AbortProcess
  00037	83 c4 04	 add	 esp, 4
$LN14@volTransfo:

; 2712 : 
; 2713 : 	VirtualLock ((LPVOID) volParams, sizeof(FORMAT_VOL_PARAMETERS));

  0003a	6a 50		 push	 80			; 00000050H
  0003c	56		 push	 esi
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 2714 : 
; 2715 : 	bVolTransformThreadRunning = TRUE;

  00043	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 1 ; bVolTransformThreadRunning

; 2716 : 	bVolTransformThreadToRun = FALSE;

  0004d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun

; 2717 : 
; 2718 : 	// Check administrator privileges
; 2719 : 	if (!IsAdmin () && !IsUacSupported ())

  00057	e8 00 00 00 00	 call	 _IsAdmin
  0005c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__MessageBoxW@16
  00062	85 c0		 test	 eax, eax
  00064	75 65		 jne	 SHORT $LN20@volTransfo
  00066	e8 00 00 00 00	 call	 _IsUacSupported
  0006b	85 c0		 test	 eax, eax
  0006d	75 5c		 jne	 SHORT $LN20@volTransfo

; 2720 : 	{
; 2721 : 		if (fileSystem == FILESYS_NTFS)

  0006f	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?fileSystem@@3HC, 2 ; fileSystem
  00076	75 25		 jne	 SHORT $LN17@volTransfo

; 2722 : 		{
; 2723 : 			if (MessageBoxW (hwndDlg, GetString ("ADMIN_PRIVILEGES_WARN_NTFS"), lpszTitle, MB_OKCANCEL|MB_ICONWARNING|MB_DEFBUTTON2) == IDCANCEL)

  00078	68 31 01 00 00	 push	 305			; 00000131H
  0007d	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MHDAJDPI@ADMIN_PRIVILEGES_WARN_NTFS?$AA@
  00088	e8 00 00 00 00	 call	 _GetString
  0008d	83 c4 04	 add	 esp, 4
  00090	50		 push	 eax
  00091	53		 push	 ebx
  00092	ff d7		 call	 edi
  00094	83 f8 02	 cmp	 eax, 2
  00097	0f 84 53 04 00
	00		 je	 $cancel$144
$LN17@volTransfo:

; 2724 : 				goto cancel;
; 2725 : 		}
; 2726 : 		if (bDevice)

  0009d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  000a4	74 25		 je	 SHORT $LN20@volTransfo

; 2727 : 		{
; 2728 : 			if (MessageBoxW (hwndDlg, GetString ("ADMIN_PRIVILEGES_WARN_DEVICES"), lpszTitle, MB_OKCANCEL|MB_ICONWARNING|MB_DEFBUTTON2) == IDCANCEL)

  000a6	68 31 01 00 00	 push	 305			; 00000131H
  000ab	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@
  000b6	e8 00 00 00 00	 call	 _GetString
  000bb	83 c4 04	 add	 esp, 4
  000be	50		 push	 eax
  000bf	53		 push	 ebx
  000c0	ff d7		 call	 edi
  000c2	83 f8 02	 cmp	 eax, 2
  000c5	0f 84 25 04 00
	00		 je	 $cancel$144
$LN20@volTransfo:

; 2729 : 				goto cancel;
; 2730 : 		}
; 2731 : 	}
; 2732 : 
; 2733 : 	if (!bInPlaceEncNonSys)

  000cb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  000d2	0f 85 fa 00 00
	00		 jne	 $LN35@volTransfo

; 2734 : 	{
; 2735 : 		if (!bDevice)

  000d8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  000df	0f 85 e0 00 00
	00		 jne	 $LN23@volTransfo

; 2736 : 		{
; 2737 : 			int x = _access (szDiskFile, 06);

  000e5	6a 06		 push	 6
  000e7	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  000ec	e8 00 00 00 00	 call	 __access
  000f1	83 c4 08	 add	 esp, 8

; 2738 : 			if (x == 0 || errno != ENOENT)

  000f4	85 c0		 test	 eax, eax
  000f6	74 0a		 je	 SHORT $LN26@volTransfo
  000f8	e8 00 00 00 00	 call	 __errno
  000fd	83 38 02	 cmp	 DWORD PTR [eax], 2
  00100	74 72		 je	 SHORT $LN29@volTransfo
$LN26@volTransfo:

; 2739 : 			{
; 2740 : 				wchar_t szTmp[512];
; 2741 : 
; 2742 : 				if (! ((bHiddenVol && !bHiddenVolHost) && errno != EACCES))	// Only ask ask for permission to overwrite an existing volume if we're not creating a hidden volume

  00102	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00109	74 13		 je	 SHORT $LN28@volTransfo
  0010b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00112	75 0a		 jne	 SHORT $LN28@volTransfo
  00114	e8 00 00 00 00	 call	 __errno
  00119	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  0011c	75 56		 jne	 SHORT $LN29@volTransfo
$LN28@volTransfo:

; 2743 : 				{
; 2744 : 					_snwprintf (szTmp, sizeof szTmp / 2,

  0011e	e8 00 00 00 00	 call	 __errno
  00123	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@JEAHJACA@OVERWRITEPROMPT?$AA@
  00128	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0P@EMHOIPJB@READONLYPROMPT?$AA@
  0012d	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  00132	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  00135	0f 45 ca	 cmovne	 ecx, edx
  00138	51		 push	 ecx
  00139	e8 00 00 00 00	 call	 _GetString
  0013e	83 c4 04	 add	 esp, 4
  00141	50		 push	 eax
  00142	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$4[ebp]
  00148	68 00 02 00 00	 push	 512			; 00000200H
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 __snwprintf
  00153	83 c4 10	 add	 esp, 16			; 00000010H

; 2745 : 						GetString (errno == EACCES ? "READONLYPROMPT" : "OVERWRITEPROMPT"),
; 2746 : 						szDiskFile);
; 2747 : 
; 2748 : 					x = MessageBoxW (hwndDlg, szTmp, lpszTitle, YES_NO|MB_ICONWARNING|MB_DEFBUTTON2);

  00156	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$4[ebp]
  0015c	68 34 01 00 00	 push	 308			; 00000134H
  00161	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00167	50		 push	 eax
  00168	53		 push	 ebx
  00169	ff d7		 call	 edi

; 2749 : 
; 2750 : 					if (x != IDYES)

  0016b	83 f8 06	 cmp	 eax, 6
  0016e	0f 85 7c 03 00
	00		 jne	 $cancel$144
$LN29@volTransfo:

; 2751 : 						goto cancel;
; 2752 : 				}
; 2753 : 			}
; 2754 : 
; 2755 : 			if (_access (szDiskFile, 06) != 0)

  00174	6a 06		 push	 6
  00176	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0017b	e8 00 00 00 00	 call	 __access
  00180	83 c4 08	 add	 esp, 8
  00183	85 c0		 test	 eax, eax
  00185	74 4b		 je	 SHORT $LN35@volTransfo

; 2756 : 			{
; 2757 : 				if (errno == EACCES)

  00187	e8 00 00 00 00	 call	 __errno
  0018c	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  0018f	75 41		 jne	 SHORT $LN35@volTransfo

; 2758 : 				{
; 2759 : 					if (_chmod (szDiskFile, _S_IREAD | _S_IWRITE) != 0)

  00191	68 80 01 00 00	 push	 384			; 00000180H
  00196	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0019b	e8 00 00 00 00	 call	 __chmod
  001a0	83 c4 08	 add	 esp, 8
  001a3	85 c0		 test	 eax, eax
  001a5	74 2b		 je	 SHORT $LN35@volTransfo

; 2760 : 					{
; 2761 : 						MessageBoxW (hwndDlg, GetString ("ACCESSMODEFAIL"), lpszTitle, ICON_HAND);

  001a7	6a 10		 push	 16			; 00000010H
  001a9	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JKCBOPBP@ACCESSMODEFAIL?$AA@
  001b4	e8 00 00 00 00	 call	 _GetString
  001b9	83 c4 04	 add	 esp, 4
  001bc	50		 push	 eax
  001bd	53		 push	 ebx
  001be	ff d7		 call	 edi

; 2987 : 		}
; 2988 : 	}
; 2989 : 
; 2990 : cancel:

  001c0	e9 2b 03 00 00	 jmp	 $cancel$144
$LN23@volTransfo:

; 2762 : 						goto cancel;
; 2763 : 					}
; 2764 : 				}
; 2765 : 			}
; 2766 : 
; 2767 : 		}
; 2768 : 		else
; 2769 : 		{
; 2770 : 			// Partition / device / dynamic volume
; 2771 : 
; 2772 : 			if (!FinalPreTransformPrompts ())

  001c5	e8 00 00 00 00	 call	 _FinalPreTransformPrompts
  001ca	85 c0		 test	 eax, eax
  001cc	0f 84 1e 03 00
	00		 je	 $cancel$144
$LN35@volTransfo:

; 2773 : 				goto cancel;
; 2774 : 		}
; 2775 : 	}
; 2776 : 
; 2777 : 	// Prevent the OS from entering Sleep mode when idle
; 2778 : 	SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);

  001d2	68 01 00 00 80	 push	 -2147483647		; 80000001H
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadExecutionState@4

; 2779 : 
; 2780 : 	bHidden = bHiddenVol && !bHiddenVolHost;

  001dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  001e4	74 10		 je	 SHORT $LN82@volTransfo
  001e6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  001ed	75 07		 jne	 SHORT $LN82@volTransfo
  001ef	bf 01 00 00 00	 mov	 edi, 1
  001f4	eb 02		 jmp	 SHORT $LN83@volTransfo
$LN82@volTransfo:
  001f6	33 ff		 xor	 edi, edi
$LN83@volTransfo:

; 2781 : 
; 2782 : 	volParams->bDevice = bDevice;

  001f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bDevice@@3HA ; bDevice
  001fd	89 06		 mov	 DWORD PTR [esi], eax

; 2783 : 	volParams->hiddenVol = bHidden;

  001ff	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 2784 : 	volParams->volumePath = szDiskFile;

  00202	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ?szDiskFile@@3PADA ; szDiskFile

; 2785 : 	volParams->size = nVolumeSize;

  00209	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nVolumeSize@@3_KA
  0020e	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00211	a1 04 00 00 00	 mov	 eax, DWORD PTR ?nVolumeSize@@3_KA+4
  00216	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 2786 : 	volParams->hiddenVolHostSize = nHiddenVolHostSize;

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nHiddenVolHostSize@@3_KA
  0021e	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00221	a1 04 00 00 00	 mov	 eax, DWORD PTR ?nHiddenVolHostSize@@3_KA+4
  00226	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 2787 : 	volParams->ea = nVolumeEA;

  00229	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nVolumeEA@@3HA ; nVolumeEA
  0022e	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 2788 : 	volParams->pkcs5 = hash_algo;

  00231	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hash_algo@@3HA ; hash_algo
  00236	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 2789 : 	volParams->headerFlags = CreatingHiddenSysVol() ? GST_HEADER_FLAG_ENCRYPTED_SYSTEM : 0;

  00239	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00240	74 19		 je	 SHORT $LN86@volTransfo
  00242	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00249	74 10		 je	 SHORT $LN86@volTransfo
  0024b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00252	75 07		 jne	 SHORT $LN86@volTransfo
  00254	b8 01 00 00 00	 mov	 eax, 1
  00259	eb 02		 jmp	 SHORT $LN87@volTransfo
$LN86@volTransfo:
  0025b	33 c0		 xor	 eax, eax
$LN87@volTransfo:
  0025d	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 2790 : 	volParams->fileSystem = fileSystem;

  00260	a1 00 00 00 00	 mov	 eax, DWORD PTR ?fileSystem@@3HC ; fileSystem
  00265	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 2791 : 	volParams->clusterSize = clusterSize;

  00268	a1 00 00 00 00	 mov	 eax, DWORD PTR ?clusterSize@@3HC ; clusterSize
  0026d	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 2792 : 	volParams->sparseFileSwitch = bSparseFileSwitch;

  00270	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bSparseFileSwitch@@3HC ; bSparseFileSwitch
  00275	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 2793 : 	volParams->quickFormat = quickFormat;

  00278	a1 00 00 00 00	 mov	 eax, DWORD PTR ?quickFormat@@3HC ; quickFormat
  0027d	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 2794 : 	volParams->sectorSize = GetFormatSectorSize();

  00280	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  00287	75 07		 jne	 SHORT $LN89@volTransfo
  00289	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0028e	eb 31		 jmp	 SHORT $LN88@volTransfo
$LN89@volTransfo:
  00290	8d 85 e4 bb ff
	ff		 lea	 eax, DWORD PTR _geometry$2[ebp]
  00296	50		 push	 eax
  00297	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0029c	e8 00 00 00 00	 call	 _GetDriveGeometry
  002a1	83 c4 08	 add	 esp, 8
  002a4	85 c0		 test	 eax, eax
  002a6	75 13		 jne	 SHORT $LN90@volTransfo
  002a8	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  002ae	e8 00 00 00 00	 call	 _handleWin32Error
  002b3	83 c4 04	 add	 esp, 4
  002b6	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN90@volTransfo:
  002bb	8b 85 f8 bb ff
	ff		 mov	 eax, DWORD PTR _geometry$2[ebp+20]
$LN88@volTransfo:
  002c1	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 2795 : 	volParams->realClusterSize = &realClusterSize;

  002c4	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], OFFSET ?realClusterSize@@3HA ; realClusterSize

; 2796 : 	volParams->password = &volumePassword;

  002cb	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], OFFSET ?volumePassword@@3UPassword@@A ; volumePassword

; 2797 : 	volParams->hwndDlg = hwndDlg;

  002d2	89 5e 48	 mov	 DWORD PTR [esi+72], ebx

; 2798 : 
; 2799 : 	if (bInPlaceEncNonSys)

  002d5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0

; 2800 : 	{
; 2801 : 		HANDLE hPartition = INVALID_HANDLE_VALUE;
; 2802 : 
; 2803 : 		SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PREPARING);

  002dc	6a 01		 push	 1
  002de	0f 84 93 00 00
	00		 je	 $LN37@volTransfo
  002e4	c7 85 e0 bb ff
	ff ff ff ff ff	 mov	 DWORD PTR _hPartition$1[ebp], -1
  002ee	e8 00 00 00 00	 call	 _SetNonSysInplaceEncUIStatus
  002f3	83 c4 04	 add	 esp, 4

; 2804 : 
; 2805 : 		if (!bInPlaceEncNonSysResumed)

  002f6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSysResumed, 0
  002fd	75 60		 jne	 SHORT $LN39@volTransfo

; 2806 : 		{
; 2807 : 			bTryToCorrectReadErrors = FALSE;
; 2808 : 
; 2809 : 			nStatus = EncryptPartitionInPlaceBegin (volParams, &hPartition, nWipeMode);

  002ff	ff 35 00 00 00
	00		 push	 DWORD PTR _nWipeMode
  00305	8d 85 e0 bb ff
	ff		 lea	 eax, DWORD PTR _hPartition$1[ebp]
  0030b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bTryToCorrectReadErrors@@3HC, 0 ; bTryToCorrectReadErrors
  00315	50		 push	 eax
  00316	56		 push	 esi
  00317	e8 00 00 00 00	 call	 _EncryptPartitionInPlaceBegin
  0031c	8b f8		 mov	 edi, eax
  0031e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2810 : 
; 2811 : 			if (nStatus == ERR_SUCCESS)

  00321	85 ff		 test	 edi, edi
  00323	75 1c		 jne	 SHORT $LN41@volTransfo

; 2812 : 			{
; 2813 : 				nStatus = EncryptPartitionInPlaceResume (hPartition, volParams, nWipeMode, &bTryToCorrectReadErrors);

  00325	68 00 00 00 00	 push	 OFFSET ?bTryToCorrectReadErrors@@3HC ; bTryToCorrectReadErrors
  0032a	ff 35 00 00 00
	00		 push	 DWORD PTR _nWipeMode
  00330	56		 push	 esi
  00331	ff b5 e0 bb ff
	ff		 push	 DWORD PTR _hPartition$1[ebp]
  00337	e8 00 00 00 00	 call	 _EncryptPartitionInPlaceResume
  0033c	83 c4 10	 add	 esp, 16			; 00000010H
  0033f	eb 65		 jmp	 SHORT $LN137@volTransfo
$LN41@volTransfo:

; 2814 : 			}
; 2815 : 			else if (hPartition != INVALID_HANDLE_VALUE)

  00341	8b 85 e0 bb ff
	ff		 mov	 eax, DWORD PTR _hPartition$1[ebp]
  00347	83 f8 ff	 cmp	 eax, -1
  0034a	74 5c		 je	 SHORT $LN38@volTransfo

; 2816 : 			{
; 2817 : 				CloseHandle (hPartition);

  0034c	50		 push	 eax
  0034d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2818 : 				hPartition = INVALID_HANDLE_VALUE;

  00353	c7 85 e0 bb ff
	ff ff ff ff ff	 mov	 DWORD PTR _hPartition$1[ebp], -1

; 2819 : 			}
; 2820 : 		}
; 2821 : 		else

  0035d	eb 49		 jmp	 SHORT $LN38@volTransfo
$LN39@volTransfo:

; 2822 : 		{
; 2823 : 			nStatus = EncryptPartitionInPlaceResume (INVALID_HANDLE_VALUE, volParams, nWipeMode, &bTryToCorrectReadErrors);

  0035f	68 00 00 00 00	 push	 OFFSET ?bTryToCorrectReadErrors@@3HC ; bTryToCorrectReadErrors
  00364	ff 35 00 00 00
	00		 push	 DWORD PTR _nWipeMode
  0036a	56		 push	 esi
  0036b	6a ff		 push	 -1
  0036d	e8 00 00 00 00	 call	 _EncryptPartitionInPlaceResume
  00372	83 c4 10	 add	 esp, 16			; 00000010H

; 2824 : 		}
; 2825 : 	}
; 2826 : 	else

  00375	eb 2f		 jmp	 SHORT $LN137@volTransfo
$LN37@volTransfo:

; 2827 : 	{
; 2828 : 		InitProgressBar (GetVolumeDataAreaSize (bHidden, nVolumeSize), 0, FALSE, FALSE, FALSE, TRUE);

  00377	6a 00		 push	 0
  00379	6a 00		 push	 0
  0037b	6a 00		 push	 0
  0037d	6a 00		 push	 0
  0037f	6a 00		 push	 0
  00381	ff 35 04 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA+4
  00387	ff 35 00 00 00
	00		 push	 DWORD PTR ?nVolumeSize@@3_KA
  0038d	57		 push	 edi
  0038e	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  00393	83 c4 0c	 add	 esp, 12			; 0000000cH
  00396	52		 push	 edx
  00397	50		 push	 eax
  00398	e8 00 00 00 00	 call	 _InitProgressBar

; 2829 : 
; 2830 : 		nStatus = GSTFormatVolume (volParams);

  0039d	56		 push	 esi
  0039e	e8 00 00 00 00	 call	 _GSTFormatVolume
  003a3	83 c4 24	 add	 esp, 36			; 00000024H
$LN137@volTransfo:
  003a6	8b f8		 mov	 edi, eax
$LN38@volTransfo:

; 2831 : 	}
; 2832 : 
; 2833 : 	// Allow the OS to enter Sleep mode when idle
; 2834 : 	SetThreadExecutionState (ES_CONTINUOUS);

  003a8	68 00 00 00 80	 push	 -2147483648		; 80000000H
  003ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadExecutionState@4

; 2835 : 
; 2836 : 	if (nStatus == ERR_OUTOFMEMORY)

  003b3	83 ff 02	 cmp	 edi, 2
  003b6	75 0d		 jne	 SHORT $LN44@volTransfo

; 2837 : 	{
; 2838 : 		AbortProcess ("OUTOFMEMORY");

  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@
  003bd	e8 00 00 00 00	 call	 _AbortProcess
  003c2	83 c4 04	 add	 esp, 4
$LN44@volTransfo:

; 2839 : 	}
; 2840 : 
; 2841 : 	if (bInPlaceEncNonSys
; 2842 : 		&& nStatus == ERR_USER_ABORT
; 2843 : 		&& NonSysInplaceEncStatus == NONSYS_INPLACE_ENC_STATUS_FINISHED)

  003c5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  003cc	74 12		 je	 SHORT $LN45@volTransfo
  003ce	83 ff 21	 cmp	 edi, 33			; 00000021H
  003d1	75 0d		 jne	 SHORT $LN45@volTransfo
  003d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _NonSysInplaceEncStatus
  003d8	33 c9		 xor	 ecx, ecx
  003da	83 f8 06	 cmp	 eax, 6
  003dd	0f 44 f9	 cmove	 edi, ecx
$LN45@volTransfo:

; 2844 : 	{
; 2845 : 		// Ignore user abort if non-system in-place encryption successfully finished
; 2846 : 		nStatus = ERR_SUCCESS;
; 2847 : 	}
; 2848 : 
; 2849 : 
; 2850 : 	dwWin32FormatError = GetLastError ();

  003e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 2851 : 
; 2852 : 	if (bHiddenVolHost && !bVolTransformThreadCancel && nStatus == 0)

  003e6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  003ed	89 85 dc bb ff
	ff		 mov	 DWORD PTR _dwWin32FormatError$1$[ebp], eax
  003f3	74 67		 je	 SHORT $LN2@volTransfo
  003f5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bVolTransformThreadCancel, 0
  003fc	75 5e		 jne	 SHORT $LN2@volTransfo
  003fe	85 ff		 test	 edi, edi
  00400	75 5a		 jne	 SHORT $LN2@volTransfo

; 2853 : 	{
; 2854 : 		/* Auto mount the newly created hidden volume host */
; 2855 : 		switch (MountHiddenVolHost (hwndDlg, szDiskFile, &hiddenVolHostDriveNo, &volumePassword, FALSE))

  00402	57		 push	 edi
  00403	68 00 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A ; volumePassword
  00408	68 00 00 00 00	 push	 OFFSET ?hiddenVolHostDriveNo@@3HA ; hiddenVolHostDriveNo
  0040d	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  00412	53		 push	 ebx
  00413	e8 00 00 00 00	 call	 _MountHiddenVolHost
  00418	83 c4 14	 add	 esp, 20			; 00000014H
  0041b	83 e8 03	 sub	 eax, 3
  0041e	74 0e		 je	 SHORT $LN48@volTransfo
  00420	83 e8 13	 sub	 eax, 19			; 00000013H
  00423	0f 84 99 01 00
	00		 je	 $LN47@volTransfo
  00429	83 e8 02	 sub	 eax, 2
  0042c	75 28		 jne	 SHORT $LN138@volTransfo
$LN48@volTransfo:

; 2861 : 		case ERR_VOL_MOUNT_FAILED:
; 2862 : 		case ERR_PASSWORD_WRONG:
; 2863 : 			MessageBoxW (hwndDlg, GetString ("CANT_MOUNT_OUTER_VOL"), lpszTitle, ICON_HAND);

  0042e	6a 10		 push	 16			; 00000010H
  00430	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00436	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IAAAEIAJ@CANT_MOUNT_OUTER_VOL?$AA@
$LN139@volTransfo:
  0043b	e8 00 00 00 00	 call	 _GetString
  00440	83 c4 04	 add	 esp, 4
  00443	50		 push	 eax
  00444	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__MessageBoxW@16
  00449	53		 push	 ebx
  0044a	ff d0		 call	 eax

; 2864 : 			bVolTransformThreadCancel = TRUE;

  0044c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bVolTransformThreadCancel, 1
$LN138@volTransfo:
  00456	8b 85 dc bb ff
	ff		 mov	 eax, DWORD PTR _dwWin32FormatError$1$[ebp]
$LN2@volTransfo:

; 2865 : 			break;
; 2866 : 		}
; 2867 : 	}
; 2868 : 
; 2869 : 	SetLastError (dwWin32FormatError);

  0045c	50		 push	 eax
  0045d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 2870 : 
; 2871 : 	if ((bVolTransformThreadCancel || nStatus == ERR_USER_ABORT)
; 2872 : 		&& !(bInPlaceEncNonSys && NonSysInplaceEncStatus == NONSYS_INPLACE_ENC_STATUS_FINISHED))	// Ignore user abort if non-system in-place encryption successfully finished.

  00463	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bVolTransformThreadCancel, 0
  0046a	75 05		 jne	 SHORT $LN50@volTransfo
  0046c	83 ff 21	 cmp	 edi, 33			; 00000021H
  0046f	75 17		 jne	 SHORT $LN118@volTransfo
$LN50@volTransfo:
  00471	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  00478	74 4e		 je	 SHORT $LN51@volTransfo
  0047a	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _NonSysInplaceEncStatus, 6
  00481	75 45		 jne	 SHORT $LN51@volTransfo

; 2877 : 		}
; 2878 : 
; 2879 : 		goto cancel;
; 2880 : 	}
; 2881 : 
; 2882 : 	if (nStatus != ERR_USER_ABORT)

  00483	83 ff 21	 cmp	 edi, 33			; 00000021H
  00486	74 68		 je	 SHORT $cancel$144
$LN118@volTransfo:

; 2883 : 	{
; 2884 : 		if (nStatus != 0)

  00488	85 ff		 test	 edi, edi
  0048a	0f 84 b2 01 00
	00		 je	 $LN56@volTransfo

; 2885 : 		{
; 2886 : 			/* An error occurred */
; 2887 : 
; 2888 : 			wchar_t szMsg[8192];
; 2889 : 
; 2890 : 			handleError (hwndDlg, nStatus);

  00490	57		 push	 edi
  00491	53		 push	 ebx
  00492	e8 00 00 00 00	 call	 _handleError
  00497	83 c4 08	 add	 esp, 8

; 2891 : 
; 2892 : 			if (bInPlaceEncNonSys)

  0049a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  004a1	0f 84 48 01 00
	00		 je	 $LN58@volTransfo

; 2893 : 			{
; 2894 : 				if (bInPlaceEncNonSysResumed)

  004a7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSysResumed, 0
  004ae	0f 84 20 01 00
	00		 je	 $LN60@volTransfo

; 2895 : 				{
; 2896 : 					SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PAUSED);

  004b4	6a 05		 push	 5
  004b6	e8 00 00 00 00	 call	 _SetNonSysInplaceEncUIStatus

; 2897 : 					Error ("INPLACE_ENC_GENERIC_ERR_RESUME");

  004bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CBCIBGL@INPLACE_ENC_GENERIC_ERR_RESUME?$AA@
  004c0	e8 00 00 00 00	 call	 _Error
  004c5	83 c4 08	 add	 esp, 8
$LN51@volTransfo:

; 2873 : 	{
; 2874 : 		if (!bDevice && !(bHiddenVol && !bHiddenVolHost))	// If we're not creating a hidden volume and if it's a file container

  004c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  004cf	75 1f		 jne	 SHORT $cancel$144
  004d1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  004d8	74 09		 je	 SHORT $LN53@volTransfo
  004da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  004e1	74 0d		 je	 SHORT $cancel$144
$LN53@volTransfo:

; 2875 : 		{
; 2876 : 			remove (szDiskFile);		// Delete the container

  004e3	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  004e8	e8 00 00 00 00	 call	 _remove
  004ed	83 c4 04	 add	 esp, 4
$cancel$144:

; 2991 : 
; 2992 : 	LastDialogId = (bInPlaceEncNonSys ? "NONSYS_INPLACE_ENC_CANCELED" : "FORMAT_CANCELED");

  004f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  004f5	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BM@JKEOLKCL@NONSYS_INPLACE_ENC_CANCELED?$AA@
  004fa	85 c0		 test	 eax, eax
  004fc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@NLOHJLIM@FORMAT_CANCELED?$AA@
  00501	0f 44 ca	 cmove	 ecx, edx

; 2993 : 
; 2994 : 	if (!bInPlaceEncNonSys)

  00504	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  0050b	89 0d 00 00 00
	00		 mov	 DWORD PTR _LastDialogId, ecx
  00511	75 10		 jne	 SHORT $LN78@volTransfo

; 2995 : 		SetTimer (hwndDlg, TIMER_ID_RANDVIEW, TIMER_INTERVAL_RANDVIEW, NULL);

  00513	6a 00		 push	 0
  00515	6a 1e		 push	 30			; 0000001eH
  00517	68 ff 00 00 00	 push	 255			; 000000ffH
  0051c	53		 push	 ebx
  0051d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
$LN78@volTransfo:

; 2996 : 
; 2997 : 	if (volParams != NULL)

  00523	85 f6		 test	 esi, esi
  00525	74 36		 je	 SHORT $LN79@volTransfo

; 2998 : 	{
; 2999 : 		burn ((LPVOID) volParams, sizeof(FORMAT_VOL_PARAMETERS));

  00527	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0052c	8b c6		 mov	 eax, esi
  0052e	8b f9		 mov	 edi, ecx
  00530	8b d6		 mov	 edx, esi
$LL97@volTransfo:
  00532	c6 02 00	 mov	 BYTE PTR [edx], 0
  00535	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00538	83 ef 01	 sub	 edi, 1
  0053b	75 f5		 jne	 SHORT $LL97@volTransfo
  0053d	0f 1f 00	 npad	 3
$LL12@volTransfo:
  00540	c6 00 00	 mov	 BYTE PTR [eax], 0
  00543	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00546	83 e9 01	 sub	 ecx, 1
  00549	75 f5		 jne	 SHORT $LL12@volTransfo

; 3000 : 		VirtualUnlock ((LPVOID) volParams, sizeof(FORMAT_VOL_PARAMETERS));

  0054b	6a 50		 push	 80			; 00000050H
  0054d	56		 push	 esi
  0054e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 3001 : 		free ((LPVOID) volParams);

  00554	56		 push	 esi
  00555	e8 00 00 00 00	 call	 _free
  0055a	83 c4 04	 add	 esp, 4
$LN79@volTransfo:

; 3002 : 		volParams = NULL;
; 3003 : 	}
; 3004 : 
; 3005 : 	bVolTransformThreadRunning = FALSE;

  0055d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning

; 3006 : 	bVolTransformThreadCancel = FALSE;
; 3007 : 
; 3008 : 	// Allow the OS to enter Sleep mode when idle
; 3009 : 	SetThreadExecutionState (ES_CONTINUOUS);

  00567	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0056c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bVolTransformThreadCancel, 0
  00576	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadExecutionState@4

; 3010 : 
; 3011 : 	PostMessage (hwndDlg, GST_APPMSG_VOL_TRANSFORM_THREAD_ENDED, 0, 0);

  0057c	6a 00		 push	 0
  0057e	6a 00		 push	 0
  00580	68 2d 81 00 00	 push	 33069			; 0000812dH
  00585	53		 push	 ebx
  00586	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 3012 : 
; 3013 : 	if (bHiddenVolHost && hiddenVolHostDriveNo < -1 && !bVolTransformThreadCancel)	// If hidden volume host could not be mounted

  0058c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00593	5f		 pop	 edi
  00594	5e		 pop	 esi
  00595	5b		 pop	 ebx
  00596	74 17		 je	 SHORT $LN80@volTransfo
  00598	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?hiddenVolHostDriveNo@@3HA, -1 ; hiddenVolHostDriveNo
  0059f	7d 0e		 jge	 SHORT $LN80@volTransfo
  005a1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bVolTransformThreadCancel, 0
  005a8	75 05		 jne	 SHORT $LN80@volTransfo

; 3014 : 		AbortProcessSilent ();

  005aa	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN80@volTransfo:

; 3015 : 
; 3016 : 	_endthread ();

  005af	e8 00 00 00 00	 call	 __endthread

; 3017 : }

  005b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b7	33 cd		 xor	 ecx, ebp
  005b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005be	8b e5		 mov	 esp, ebp
  005c0	5d		 pop	 ebp
  005c1	c3		 ret	 0
$LN47@volTransfo:

; 2856 : 		{
; 2857 : 		case ERR_NO_FREE_DRIVES:
; 2858 : 			MessageBoxW (hwndDlg, GetString ("NO_FREE_DRIVE_FOR_OUTER_VOL"), lpszTitle, ICON_HAND);

  005c2	6a 10		 push	 16			; 00000010H
  005c4	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  005ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DNIPKEFC@NO_FREE_DRIVE_FOR_OUTER_VOL?$AA@

; 2859 : 			bVolTransformThreadCancel = TRUE;
; 2860 : 			break;

  005cf	e9 67 fe ff ff	 jmp	 $LN139@volTransfo
$LN60@volTransfo:

; 2898 : 				}
; 2899 : 				else
; 2900 : 				{
; 2901 : 					SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_ERROR);

  005d4	6a 07		 push	 7
  005d6	e8 00 00 00 00	 call	 _SetNonSysInplaceEncUIStatus

; 2902 : 					ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_GENERIC_ERR_ALT_STEPS", TRUE);

  005db	6a 01		 push	 1
  005dd	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GOJAHDJH@INPLACE_ENC_GENERIC_ERR_ALT_STEP@
  005e2	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  005e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2903 : 				}

  005ea	e9 d9 fe ff ff	 jmp	 $LN51@volTransfo
$LN58@volTransfo:

; 2904 : 			}
; 2905 : 			else if (!(bHiddenVolHost && hiddenVolHostDriveNo < 0))  // If the error was not that the hidden volume host could not be mounted (this error has already been reported to the user)

  005ef	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  005f6	74 0d		 je	 SHORT $LN63@volTransfo
  005f8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?hiddenVolHostDriveNo@@3HA, 0 ; hiddenVolHostDriveNo
  005ff	0f 8c c3 fe ff
	ff		 jl	 $LN51@volTransfo
$LN63@volTransfo:

; 2906 : 			{
; 2907 : 				swprintf (szMsg, GetString ("CREATE_FAILED"), szDiskFile);

  00605	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0060a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OIAKNAOK@CREATE_FAILED?$AA@
  0060f	e8 00 00 00 00	 call	 _GetString
  00614	83 c4 04	 add	 esp, 4
  00617	50		 push	 eax
  00618	8d 85 fc bb ff
	ff		 lea	 eax, DWORD PTR _szMsg$3[ebp]
  0061e	50		 push	 eax
  0061f	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf
  00624	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2908 : 				MessageBoxW (hwndDlg, szMsg, lpszTitle, ICON_HAND);

  00627	8d 85 fc bb ff
	ff		 lea	 eax, DWORD PTR _szMsg$3[ebp]
  0062d	6a 10		 push	 16			; 00000010H
  0062f	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00635	50		 push	 eax
  00636	53		 push	 ebx
  00637	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 2909 : 			}
; 2910 : 
; 2911 : 			if (!bDevice && !(bHiddenVol && !bHiddenVolHost))	// If we're not creating a hidden volume and if it's a file container
; 2912 : 			{
; 2913 : 				remove (szDiskFile);		// Delete the container
; 2914 : 			}
; 2915 : 
; 2916 : 			goto cancel;

  0063d	e9 86 fe ff ff	 jmp	 $LN51@volTransfo
$LN56@volTransfo:

; 2917 : 		}
; 2918 : 		else
; 2919 : 		{
; 2920 : 			/* Volume successfully created */
; 2921 : 
; 2922 : 			RestoreDefaultKeyFilesParam ();

  00642	e8 00 00 00 00	 call	 _RestoreDefaultKeyFilesParam

; 2923 : 
; 2924 : 			if (bDevice && !bInPlaceEncNonSys)

  00647	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  0064e	74 0e		 je	 SHORT $LN67@volTransfo
  00650	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  00657	75 05		 jne	 SHORT $LN67@volTransfo

; 2925 : 			{
; 2926 : 				// Handle assigned drive letter (if any)
; 2927 : 
; 2928 : 				HandleOldAssignedDriveLetter ();

  00659	e8 00 00 00 00	 call	 _HandleOldAssignedDriveLetter
$LN67@volTransfo:

; 2929 : 			}
; 2930 : 
; 2931 : 			if (!bHiddenVolHost)

  0065e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00665	75 7d		 jne	 SHORT $LN68@volTransfo

; 2932 : 			{
; 2933 : 				if (bHiddenVol)

  00667	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  0066e	74 29		 je	 SHORT $LN70@volTransfo

; 2934 : 				{
; 2935 : 					bHiddenVolFinished = TRUE;

  00670	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bHiddenVolFinished@@3HC, 1 ; bHiddenVolFinished

; 2936 : 
; 2937 : 					if (!bHiddenOS)

  0067a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenOS@@3HC, 0 ; bHiddenOS
  00681	0f 85 ac 00 00
	00		 jne	 $LN69@volTransfo

; 2938 : 						Warning ("HIDVOL_FORMAT_FINISHED_HELP");

  00687	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NHKMKNFC@HIDVOL_FORMAT_FINISHED_HELP?$AA@
  0068c	e8 00 00 00 00	 call	 _Warning
  00691	83 c4 04	 add	 esp, 4

; 2939 : 				}

  00694	e9 9a 00 00 00	 jmp	 $LN69@volTransfo
$LN70@volTransfo:

; 2940 : 				else if (bInPlaceEncNonSys)

  00699	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  006a0	74 14		 je	 SHORT $LN73@volTransfo

; 2941 : 				{
; 2942 : 					Warning ("NONSYS_INPLACE_ENC_FINISHED_INFO");

  006a2	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KOCBDKDK@NONSYS_INPLACE_ENC_FINISHED_INFO@
  006a7	e8 00 00 00 00	 call	 _Warning
  006ac	83 c4 04	 add	 esp, 4

; 2943 : 
; 2944 : 					HandleOldAssignedDriveLetter ();

  006af	e8 00 00 00 00	 call	 _HandleOldAssignedDriveLetter

; 2945 : 				}
; 2946 : 				else 

  006b4	eb 7d		 jmp	 SHORT $LN69@volTransfo
$LN73@volTransfo:

; 2947 : 				{
; 2948 : 					Info("FORMAT_FINISHED_INFO");

  006b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@ELGDKJEM@FORMAT_FINISHED_INFO?$AA@
  006bb	e8 00 00 00 00	 call	 _Info
  006c0	83 c4 04	 add	 esp, 4

; 2949 : 
; 2950 : 					if (bSparseFileSwitch && quickFormat)

  006c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bSparseFileSwitch@@3HC, 0 ; bSparseFileSwitch
  006ca	74 67		 je	 SHORT $LN69@volTransfo
  006cc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?quickFormat@@3HC, 0 ; quickFormat
  006d3	74 5e		 je	 SHORT $LN69@volTransfo

; 2951 : 						Warning("SPARSE_FILE_SIZE_NOTE");

  006d5	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PHMPDKJN@SPARSE_FILE_SIZE_NOTE?$AA@
  006da	e8 00 00 00 00	 call	 _Warning
  006df	83 c4 04	 add	 esp, 4

; 2952 : 				}
; 2953 : 			}
; 2954 : 			else

  006e2	eb 4f		 jmp	 SHORT $LN69@volTransfo
$LN68@volTransfo:

; 2955 : 			{
; 2956 : 				/* We've just created an outer volume (to host a hidden volume within) */
; 2957 : 
; 2958 : 				bHiddenVolHost = FALSE; 
; 2959 : 				bHiddenVolFinished = FALSE;
; 2960 : 				nHiddenVolHostSize = nVolumeSize;

  006e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nVolumeSize@@3_KA

; 2961 : 
; 2962 : 				// Clear the outer volume password
; 2963 : 				memset(&szVerify[0], 0, sizeof (szVerify));

  006e9	6a 41		 push	 65			; 00000041H
  006eb	a3 00 00 00 00	 mov	 DWORD PTR ?nHiddenVolHostSize@@3_KA, eax
  006f0	a1 04 00 00 00	 mov	 eax, DWORD PTR ?nVolumeSize@@3_KA+4
  006f5	6a 00		 push	 0
  006f7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bHiddenVolHost, 0
  00701	68 00 00 00 00	 push	 OFFSET ?szVerify@@3PADA	; szVerify
  00706	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bHiddenVolFinished@@3HC, 0 ; bHiddenVolFinished
  00710	a3 04 00 00 00	 mov	 DWORD PTR ?nHiddenVolHostSize@@3_KA+4, eax
  00715	e8 00 00 00 00	 call	 _memset

; 2964 : 				memset(&szRawPassword[0], 0, sizeof (szRawPassword));

  0071a	6a 41		 push	 65			; 00000041H
  0071c	6a 00		 push	 0
  0071e	68 00 00 00 00	 push	 OFFSET ?szRawPassword@@3PADA ; szRawPassword
  00723	e8 00 00 00 00	 call	 _memset
  00728	83 c4 18	 add	 esp, 24			; 00000018H

; 2965 : 
; 2966 : 				MessageBeep (MB_OK);

  0072b	6a 00		 push	 0
  0072d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBeep@4
$LN69@volTransfo:

; 2967 : 			}
; 2968 : 
; 2969 : 			if (!bInPlaceEncNonSys)

  00733	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  0073a	75 10		 jne	 SHORT $LN76@volTransfo

; 2970 : 				SetTimer (hwndDlg, TIMER_ID_RANDVIEW, TIMER_INTERVAL_RANDVIEW, NULL);

  0073c	6a 00		 push	 0
  0073e	6a 1e		 push	 30			; 0000001eH
  00740	68 ff 00 00 00	 push	 255			; 000000ffH
  00745	53		 push	 ebx
  00746	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
$LN76@volTransfo:

; 2971 : 
; 2972 : 			if (volParams != NULL)
; 2973 : 			{
; 2974 : 				burn ((LPVOID) volParams, sizeof(FORMAT_VOL_PARAMETERS));

  0074c	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00751	8b c6		 mov	 eax, esi
  00753	8b f9		 mov	 edi, ecx
  00755	8b d6		 mov	 edx, esi
$LL93@volTransfo:
  00757	c6 02 00	 mov	 BYTE PTR [edx], 0
  0075a	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0075d	83 ef 01	 sub	 edi, 1
  00760	75 f5		 jne	 SHORT $LL93@volTransfo
$LL7@volTransfo:
  00762	c6 00 00	 mov	 BYTE PTR [eax], 0
  00765	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00768	83 e9 01	 sub	 ecx, 1
  0076b	75 f5		 jne	 SHORT $LL7@volTransfo

; 2975 : 				VirtualUnlock ((LPVOID) volParams, sizeof(FORMAT_VOL_PARAMETERS));

  0076d	6a 50		 push	 80			; 00000050H
  0076f	56		 push	 esi
  00770	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 2976 : 				free ((LPVOID) volParams);

  00776	56		 push	 esi
  00777	e8 00 00 00 00	 call	 _free

; 2977 : 				volParams = NULL;

  0077c	33 f6		 xor	 esi, esi
  0077e	83 c4 04	 add	 esp, 4

; 2978 : 			}
; 2979 : 
; 2980 : 			bVolTransformThreadRunning = FALSE;

  00781	89 35 00 00 00
	00		 mov	 DWORD PTR ?bVolTransformThreadRunning@@3HC, esi ; bVolTransformThreadRunning

; 2981 : 			bVolTransformThreadCancel = FALSE;

  00787	89 35 00 00 00
	00		 mov	 DWORD PTR _bVolTransformThreadCancel, esi

; 2982 : 
; 2983 : 			PostMessage (hwndDlg, bInPlaceEncNonSys ? GST_APPMSG_NONSYS_INPLACE_ENC_FINISHED : GST_APPMSG_FORMAT_FINISHED, 0, 0);

  0078d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bInPlaceEncNonSys
  00792	f7 d8		 neg	 eax
  00794	56		 push	 esi
  00795	1b c0		 sbb	 eax, eax
  00797	83 e0 04	 and	 eax, 4
  0079a	56		 push	 esi
  0079b	05 2e 81 00 00	 add	 eax, 33070		; 0000812eH
  007a0	50		 push	 eax
  007a1	53		 push	 ebx
  007a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 2984 : 
; 2985 : 			LastDialogId = "FORMAT_FINISHED";

  007a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LastDialogId, OFFSET ??_C@_0BA@IDMMBDGF@FORMAT_FINISHED?$AA@

; 2986 : 			_endthread ();

  007b2	e8 00 00 00 00	 call	 __endthread

; 2987 : 		}
; 2988 : 	}
; 2989 : 
; 2990 : cancel:

  007b7	e9 34 fd ff ff	 jmp	 $cancel$144
_volTransformThreadFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _sysEncDriveAnalysisThread
_TEXT	SEGMENT
_e$2 = -28						; size = 4
_bSuccess$3 = -24					; size = 4
_bSuccess$4 = -20					; size = 4
__$EHRec$ = -16						; size = 16
_hwndDlgArg$ = 8					; size = 4
_sysEncDriveAnalysisThread PROC				; COMDAT

; 2655 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_sysEncDriveAnalysisThread
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2656 : 	// Mark the detection process as 'in progress'
; 2657 : 	HiddenSectorDetectionStatus = 1;
; 2658 : 	SaveSettings (NULL);

  0002b	6a 00		 push	 0
  0002d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _HiddenSectorDetectionStatus, 1
  00037	e8 00 00 00 00	 call	 _SaveSettings

; 2659 : 	BroadcastSysEncCfgUpdate ();

  0003c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnumWindows@8
  00042	8d 45 ec	 lea	 eax, DWORD PTR _bSuccess$4[ebp]
  00045	83 c4 04	 add	 esp, 4
  00048	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bSuccess$4[ebp], 0
  0004f	50		 push	 eax
  00050	68 00 00 00 00	 push	 OFFSET ?BroadcastSysEncCfgUpdateCallb@@YGHPAUHWND__@@J@Z ; BroadcastSysEncCfgUpdateCallb
  00055	ff d6		 call	 esi

; 2660 : 
; 2661 : 	try
; 2662 : 	{
; 2663 : 		BootEncObj->ProbeRealSystemDriveSize ();

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00064	e8 00 00 00 00	 call	 ?ProbeRealSystemDriveSize@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::ProbeRealSystemDriveSize

; 2664 : 		bSysEncDriveAnalysisTimeOutOccurred = FALSE;

  00069	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bSysEncDriveAnalysisTimeOutOccurred@@3HC, 0 ; bSysEncDriveAnalysisTimeOutOccurred
  00073	eb 16		 jmp	 SHORT $LN8@sysEncDriv
__catch$_sysEncDriveAnalysisThread$0:

; 2665 : 	}
; 2666 : 	catch (TimeOut &)
; 2667 : 	{
; 2668 : 		bSysEncDriveAnalysisTimeOutOccurred = TRUE;

  00075	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bSysEncDriveAnalysisTimeOutOccurred@@3HC, 1 ; bSysEncDriveAnalysisTimeOutOccurred

; 2669 : 	}

  0007f	b8 00 00 00 00	 mov	 eax, $LN15@sysEncDriv
  00084	c3		 ret	 0
$LN15@sysEncDriv:
  00085	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnumWindows@8
$LN8@sysEncDriv:

; 2680 : 	}
; 2681 : 
; 2682 : 	// Mark the detection process as completed
; 2683 : 	HiddenSectorDetectionStatus = 0;
; 2684 : 	SaveSettings (NULL);

  0008b	6a 00		 push	 0
  0008d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _HiddenSectorDetectionStatus, 0
  00097	e8 00 00 00 00	 call	 _SaveSettings
  0009c	83 c4 04	 add	 esp, 4

; 2685 : 	BroadcastSysEncCfgUpdate ();

  0009f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bSuccess$3[ebp], 0
  000a6	8d 45 e8	 lea	 eax, DWORD PTR _bSuccess$3[ebp]
  000a9	50		 push	 eax
  000aa	68 00 00 00 00	 push	 OFFSET ?BroadcastSysEncCfgUpdateCallb@@YGHPAUHWND__@@J@Z ; BroadcastSysEncCfgUpdateCallb
  000af	ff d6		 call	 esi

; 2686 : 
; 2687 : 	// This artificial delay prevents user confusion on systems where the analysis ends almost instantly
; 2688 : 	Sleep (3000);

  000b1	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 2689 : 
; 2690 : 	bSysEncDriveAnalysisInProgress = FALSE;

  000bc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bSysEncDriveAnalysisInProgress@@3HC, 0 ; bSysEncDriveAnalysisInProgress

; 2691 : }

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d0	59		 pop	 ecx
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
__catch$_sysEncDriveAnalysisThread$1:

; 2670 : 	catch (Exception &e)
; 2671 : 	{
; 2672 : 		// There was a problem but the system did not freeze. Mark the detection process as completed.
; 2673 : 		HiddenSectorDetectionStatus = 0;
; 2674 : 		SaveSettings (NULL);

  000d8	6a 00		 push	 0
  000da	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _HiddenSectorDetectionStatus, 0
  000e4	e8 00 00 00 00	 call	 _SaveSettings
  000e9	83 c4 04	 add	 esp, 4

; 2675 : 		BroadcastSysEncCfgUpdate ();

  000ec	e8 00 00 00 00	 call	 ?BroadcastSysEncCfgUpdate@@YAHXZ ; BroadcastSysEncCfgUpdate

; 2676 : 
; 2677 : 		e.Show (NULL);

  000f1	8b 4d e4	 mov	 ecx, DWORD PTR _e$2[ebp]
  000f4	6a 00		 push	 0
  000f6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f8	ff 10		 call	 DWORD PTR [eax]

; 2678 : 		EndMainDlg (MainDlg);

  000fa	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00100	e8 00 00 00 00	 call	 _EndMainDlg
  00105	83 c4 04	 add	 esp, 4

; 2679 : 		exit(0);

  00108	6a 00		 push	 0
  0010a	e8 00 00 00 00	 call	 _exit
$LN18@sysEncDriv:
$LN17@sysEncDriv:
  0010f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_sysEncDriveAnalysisThread:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_sysEncDriveAnalysisThread
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_sysEncDriveAnalysisThread ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _VerifySizeAndUpdate
_TEXT	SEGMENT
_hwndDlg$GSCopy$1$ = -108				; size = 4
tv411 = -104						; size = 4
tv417 = -100						; size = 4
tv416 = -96						; size = 4
tv410 = -92						; size = 4
tv351 = -92						; size = 4
_lTmp$2$ = -88						; size = 4
_lTmp$1$ = -84						; size = 4
_geometry$1 = -80					; size = 24
_szTmp$ = -56						; size = 50
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_bUpdate$ = 12						; size = 4
_VerifySizeAndUpdate PROC				; COMDAT

; 1480 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]

; 1481 : 	BOOL bEnable = TRUE;
; 1482 : 	char szTmp[50];
; 1483 : 	__int64 lTmp;
; 1484 : 	size_t i;
; 1485 : 	static unsigned __int64 nLastVolumeSize = 0;
; 1486 : 
; 1487 : 	GetWindowText (GetDlgItem (hwndDlg, IDC_SIZEBOX), szTmp, sizeof (szTmp));

  00015	8d 45 c8	 lea	 eax, DWORD PTR _szTmp$[ebp]
  00018	57		 push	 edi
  00019	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0001f	bb 01 00 00 00	 mov	 ebx, 1
  00024	6a 32		 push	 50			; 00000032H
  00026	50		 push	 eax
  00027	68 0e 04 00 00	 push	 1038			; 0000040eH
  0002c	56		 push	 esi
  0002d	89 75 94	 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], esi
  00030	ff d7		 call	 edi
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 1488 : 
; 1489 : 	for (i = 0; i < strlen (szTmp); i++)

  00039	8d 4d c8	 lea	 ecx, DWORD PTR _szTmp$[ebp]
  0003c	33 d2		 xor	 edx, edx
  0003e	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00041	89 45 a4	 mov	 DWORD PTR tv351[ebp], eax
$LL38@VerifySize:
  00044	8a 01		 mov	 al, BYTE PTR [ecx]
  00046	41		 inc	 ecx
  00047	84 c0		 test	 al, al
  00049	75 f9		 jne	 SHORT $LL38@VerifySize
  0004b	2b 4d a4	 sub	 ecx, DWORD PTR tv351[ebp]
  0004e	74 15		 je	 SHORT $LN3@VerifySize
$LL4@VerifySize:

; 1490 : 	{
; 1491 : 		if (szTmp[i] >= '0' && szTmp[i] <= '9')

  00050	8a 44 15 c8	 mov	 al, BYTE PTR _szTmp$[ebp+edx]
  00054	3c 30		 cmp	 al, 48			; 00000030H
  00056	7c 0b		 jl	 SHORT $LN5@VerifySize
  00058	3c 39		 cmp	 al, 57			; 00000039H
  0005a	7f 07		 jg	 SHORT $LN5@VerifySize

; 1488 : 
; 1489 : 	for (i = 0; i < strlen (szTmp); i++)

  0005c	42		 inc	 edx
  0005d	3b d1		 cmp	 edx, ecx
  0005f	72 ef		 jb	 SHORT $LL4@VerifySize
  00061	eb 02		 jmp	 SHORT $LN3@VerifySize
$LN5@VerifySize:

; 1492 : 			continue;
; 1493 : 		else
; 1494 : 		{
; 1495 : 			bEnable = FALSE;

  00063	33 db		 xor	 ebx, ebx
$LN3@VerifySize:

; 1496 : 			break;
; 1497 : 		}
; 1498 : 	}
; 1499 : 
; 1500 : 	if (IsButtonChecked (GetDlgItem (hwndDlg, IDC_KB)))

  00065	68 f3 03 00 00	 push	 1011			; 000003f3H
  0006a	56		 push	 esi
  0006b	ff d7		 call	 edi
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _IsButtonChecked
  00073	83 c4 04	 add	 esp, 4
  00076	85 c0		 test	 eax, eax
  00078	74 07		 je	 SHORT $LN7@VerifySize

; 1501 : 		nMultiplier = BYTES_PER_KB;

  0007a	be 00 04 00 00	 mov	 esi, 1024		; 00000400H
  0007f	eb 23		 jmp	 SHORT $LN46@VerifySize
$LN7@VerifySize:

; 1502 : 	else if (IsButtonChecked (GetDlgItem (hwndDlg, IDC_MB)))

  00081	68 f5 03 00 00	 push	 1013			; 000003f5H
  00086	56		 push	 esi
  00087	ff d7		 call	 edi
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _IsButtonChecked
  0008f	83 c4 04	 add	 esp, 4
  00092	8b f0		 mov	 esi, eax
  00094	f7 de		 neg	 esi
  00096	1b f6		 sbb	 esi, esi
  00098	81 e6 00 00 10
	c0		 and	 esi, -1072693248	; c0100000H
  0009e	81 c6 00 00 00
	40		 add	 esi, 1073741824		; 40000000H
$LN46@VerifySize:

; 1503 : 		nMultiplier = BYTES_PER_MB;
; 1504 : 	else
; 1505 : 		nMultiplier = BYTES_PER_GB;
; 1506 : 
; 1507 : 	if (bDevice && !(bHiddenVol && !bHiddenVolHost))	// If raw device but not a hidden volume

  000a4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  000ab	89 35 00 00 00
	00		 mov	 DWORD PTR ?nMultiplier@@3HA, esi ; nMultiplier
  000b1	74 18		 je	 SHORT $LN11@VerifySize
  000b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  000ba	74 31		 je	 SHORT $LN13@VerifySize
  000bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  000c3	75 28		 jne	 SHORT $LN13@VerifySize

; 1511 : 	}
; 1512 : 	else

  000c5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?nMultiplier@@3HA ; nMultiplier
$LN11@VerifySize:

; 1513 : 	{
; 1514 : 		i = nMultiplier;
; 1515 : 		lTmp = _atoi64 (szTmp);

  000cb	8d 45 c8	 lea	 eax, DWORD PTR _szTmp$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 __atoi64
  000d4	83 c4 04	 add	 esp, 4
  000d7	89 45 ac	 mov	 DWORD PTR _lTmp$1$[ebp], eax

; 1516 : 
; 1517 : 		int sectorSize = GetFormatSectorSize();

  000da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  000e1	89 55 a8	 mov	 DWORD PTR _lTmp$2$[ebp], edx
  000e4	75 22		 jne	 SHORT $LN31@VerifySize
  000e6	bf 00 02 00 00	 mov	 edi, 512		; 00000200H
  000eb	eb 46		 jmp	 SHORT $LN30@VerifySize
$LN13@VerifySize:

; 1508 : 	{
; 1509 : 		lTmp = nVolumeSize;

  000ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nVolumeSize@@3_KA

; 1510 : 		i = 1;

  000f2	be 01 00 00 00	 mov	 esi, 1
  000f7	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?nVolumeSize@@3_KA+4
  000fd	89 45 ac	 mov	 DWORD PTR _lTmp$1$[ebp], eax
  00100	89 4d a8	 mov	 DWORD PTR _lTmp$2$[ebp], ecx

; 1511 : 	}
; 1512 : 	else

  00103	e9 8a 00 00 00	 jmp	 $LN14@VerifySize

; 1516 : 
; 1517 : 		int sectorSize = GetFormatSectorSize();

$LN31@VerifySize:
  00108	8d 45 b0	 lea	 eax, DWORD PTR _geometry$1[ebp]
  0010b	50		 push	 eax
  0010c	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  00111	e8 00 00 00 00	 call	 _GetDriveGeometry
  00116	83 c4 08	 add	 esp, 8
  00119	85 c0		 test	 eax, eax
  0011b	75 13		 jne	 SHORT $LN32@VerifySize
  0011d	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00123	e8 00 00 00 00	 call	 _handleWin32Error
  00128	83 c4 04	 add	 esp, 4
  0012b	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN32@VerifySize:
  00130	8b 7d c4	 mov	 edi, DWORD PTR _geometry$1[ebp+20]
$LN30@VerifySize:

; 1518 : 		uint32 sectorSizeRem = (lTmp * nMultiplier) % sectorSize;

  00133	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nMultiplier@@3HA ; nMultiplier
  00138	8b 4d a8	 mov	 ecx, DWORD PTR _lTmp$2$[ebp]
  0013b	51		 push	 ecx
  0013c	ff 75 ac	 push	 DWORD PTR _lTmp$1$[ebp]
  0013f	99		 cdq
  00140	89 45 a4	 mov	 DWORD PTR tv410[ebp], eax
  00143	8b c2		 mov	 eax, edx
  00145	50		 push	 eax
  00146	ff 75 a4	 push	 DWORD PTR tv410[ebp]
  00149	89 45 98	 mov	 DWORD PTR tv411[ebp], eax
  0014c	e8 00 00 00 00	 call	 __allmul
  00151	89 45 a0	 mov	 DWORD PTR tv416[ebp], eax
  00154	8b ca		 mov	 ecx, edx
  00156	8b c7		 mov	 eax, edi
  00158	89 4d 9c	 mov	 DWORD PTR tv417[ebp], ecx
  0015b	99		 cdq
  0015c	52		 push	 edx
  0015d	50		 push	 eax
  0015e	51		 push	 ecx
  0015f	ff 75 a0	 push	 DWORD PTR tv416[ebp]
  00162	e8 00 00 00 00	 call	 __allrem

; 1519 : 
; 1520 : 		if (sectorSizeRem != 0)

  00167	85 c0		 test	 eax, eax
  00169	74 21		 je	 SHORT $LN45@VerifySize

; 1521 : 			lTmp = (lTmp * nMultiplier + (sectorSize - sectorSizeRem)) / nMultiplier;

  0016b	ff 75 98	 push	 DWORD PTR tv411[ebp]
  0016e	2b f8		 sub	 edi, eax
  00170	33 c0		 xor	 eax, eax
  00172	03 7d a0	 add	 edi, DWORD PTR tv416[ebp]
  00175	ff 75 a4	 push	 DWORD PTR tv410[ebp]
  00178	13 45 9c	 adc	 eax, DWORD PTR tv417[ebp]
  0017b	50		 push	 eax
  0017c	57		 push	 edi
  0017d	e8 00 00 00 00	 call	 __alldiv
  00182	8b ca		 mov	 ecx, edx
  00184	89 45 ac	 mov	 DWORD PTR _lTmp$1$[ebp], eax
  00187	89 4d a8	 mov	 DWORD PTR _lTmp$2$[ebp], ecx
  0018a	eb 06		 jmp	 SHORT $LN14@VerifySize
$LN45@VerifySize:
  0018c	8b 45 ac	 mov	 eax, DWORD PTR _lTmp$1$[ebp]
  0018f	8b 4d a8	 mov	 ecx, DWORD PTR _lTmp$2$[ebp]
$LN14@VerifySize:
  00192	85 db		 test	 ebx, ebx

; 1522 : 	}
; 1523 : 
; 1524 : 	if (bEnable)

  00194	0f 84 88 00 00
	00		 je	 $LN44@VerifySize

; 1525 : 	{
; 1526 : 		if (lTmp * i < (bHiddenVolHost ? GST_MIN_HIDDEN_VOLUME_HOST_SIZE : (bHiddenVol ? GST_MIN_HIDDEN_VOLUME_SIZE : GST_MIN_VOLUME_SIZE)))

  0019a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  001a1	74 07		 je	 SHORT $LN26@VerifySize
  001a3	bf 00 50 05 00	 mov	 edi, 348160		; 00055000H
  001a8	eb 16		 jmp	 SHORT $LN27@VerifySize
$LN26@VerifySize:
  001aa	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?bHiddenVol@@3HC ; bHiddenVol
  001b0	f7 df		 neg	 edi
  001b2	1b ff		 sbb	 edi, edi
  001b4	81 e7 00 10 fc
	ff		 and	 edi, -258048		; fffc1000H
  001ba	81 c7 00 90 04
	00		 add	 edi, 299008		; 00049000H
$LN27@VerifySize:
  001c0	51		 push	 ecx
  001c1	50		 push	 eax
  001c2	6a 00		 push	 0
  001c4	56		 push	 esi
  001c5	e8 00 00 00 00	 call	 __allmul
  001ca	85 d2		 test	 edx, edx
  001cc	7f 08		 jg	 SHORT $LN16@VerifySize
  001ce	7c 04		 jl	 SHORT $LN39@VerifySize
  001d0	3b c7		 cmp	 eax, edi
  001d2	73 02		 jae	 SHORT $LN16@VerifySize
$LN39@VerifySize:

; 1527 : 			bEnable = FALSE;

  001d4	33 db		 xor	 ebx, ebx
$LN16@VerifySize:

; 1528 : 
; 1529 : 		if (!bHiddenVolHost && bHiddenVol)

  001d6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  001dd	75 24		 jne	 SHORT $LN48@VerifySize
  001df	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  001e6	74 12		 je	 SHORT $LN17@VerifySize

; 1530 : 		{
; 1531 : 			if (lTmp * i > nMaximumHiddenVolSize)

  001e8	3b 15 04 00 00
	00		 cmp	 edx, DWORD PTR ?nMaximumHiddenVolSize@@3_JA+4
  001ee	7c 32		 jl	 SHORT $LN44@VerifySize
  001f0	7f 2e		 jg	 SHORT $LN41@VerifySize
  001f2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?nMaximumHiddenVolSize@@3_JA

; 1532 : 				bEnable = FALSE;
; 1533 : 		}
; 1534 : 		else

  001f8	eb 24		 jmp	 SHORT $LN49@VerifySize
$LN17@VerifySize:

; 1535 : 		{
; 1536 : 			if (lTmp * i > (bHiddenVolHost ? GST_MAX_HIDDEN_VOLUME_HOST_SIZE : GST_MAX_VOLUME_SIZE))

  001fa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00201	74 0c		 je	 SHORT $LN28@VerifySize
$LN48@VerifySize:
  00203	bf 00 00 fc ff	 mov	 edi, -262144		; fffc0000H
  00208	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0020d	eb 07		 jmp	 SHORT $LN29@VerifySize
$LN28@VerifySize:
  0020f	33 ff		 xor	 edi, edi
  00211	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
$LN29@VerifySize:
  00216	3b d1		 cmp	 edx, ecx
  00218	7c 08		 jl	 SHORT $LN44@VerifySize
  0021a	7f 04		 jg	 SHORT $LN41@VerifySize
  0021c	3b c7		 cmp	 eax, edi
$LN49@VerifySize:
  0021e	76 02		 jbe	 SHORT $LN44@VerifySize
$LN41@VerifySize:

; 1537 : 				bEnable = FALSE;

  00220	33 db		 xor	 ebx, ebx
$LN44@VerifySize:

; 1538 : 		}
; 1539 : 	}
; 1540 : 
; 1541 : 	if (bUpdate)

  00222	83 7d 0c 00	 cmp	 DWORD PTR _bUpdate$[ebp], 0
  00226	74 41		 je	 SHORT $LN22@VerifySize

; 1542 : 	{
; 1543 : 		nUIVolumeSize = lTmp;
; 1544 : 
; 1545 : 		if (!bDevice || (bHiddenVol && !bHiddenVolHost))	// Update only if it's not a raw device or if it's a hidden volume

  00228	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDevice@@3HA, 0 ; bDevice
  0022f	8b 45 ac	 mov	 eax, DWORD PTR _lTmp$1$[ebp]
  00232	8b 4d a8	 mov	 ecx, DWORD PTR _lTmp$2$[ebp]
  00235	a3 00 00 00 00	 mov	 DWORD PTR ?nUIVolumeSize@@3_KA, eax
  0023a	89 0d 04 00 00
	00		 mov	 DWORD PTR ?nUIVolumeSize@@3_KA+4, ecx
  00240	74 12		 je	 SHORT $LN23@VerifySize
  00242	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bHiddenVol@@3HC, 0 ; bHiddenVol
  00249	74 1e		 je	 SHORT $LN22@VerifySize
  0024b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHiddenVolHost, 0
  00252	75 15		 jne	 SHORT $LN22@VerifySize
$LN23@VerifySize:

; 1546 : 			nVolumeSize = i * lTmp;

  00254	51		 push	 ecx
  00255	50		 push	 eax
  00256	6a 00		 push	 0
  00258	56		 push	 esi
  00259	e8 00 00 00 00	 call	 __allmul
  0025e	a3 00 00 00 00	 mov	 DWORD PTR ?nVolumeSize@@3_KA, eax
  00263	89 15 04 00 00
	00		 mov	 DWORD PTR ?nVolumeSize@@3_KA+4, edx
$LN22@VerifySize:

; 1547 : 	}
; 1548 : 
; 1549 : 	EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), bEnable);

  00269	53		 push	 ebx
  0026a	68 10 04 00 00	 push	 1040			; 00000410H
  0026f	ff 75 94	 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00272	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00278	50		 push	 eax
  00279	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0027f	50		 push	 eax
  00280	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1550 : 
; 1551 : 	if (nVolumeSize != nLastVolumeSize)

  00286	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nVolumeSize@@3_KA
  0028c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?nVolumeSize@@3_KA+4
  00291	5f		 pop	 edi
  00292	5e		 pop	 esi
  00293	5b		 pop	 ebx
  00294	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?nLastVolumeSize@?1??VerifySizeAndUpdate@@9@4_KA
  0029a	75 08		 jne	 SHORT $LN42@VerifySize
  0029c	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR ?nLastVolumeSize@?1??VerifySizeAndUpdate@@9@4_KA+4
  002a2	74 15		 je	 SHORT $LN24@VerifySize
$LN42@VerifySize:

; 1552 : 	{
; 1553 : 		// Change of volume size may make some file systems allowed or disallowed, so the default filesystem must
; 1554 : 		// be reselected.
; 1555 : 		fileSystem = FILESYS_NONE;	

  002a4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?fileSystem@@3HC, 0 ; fileSystem

; 1556 : 		nLastVolumeSize = nVolumeSize;

  002ae	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nLastVolumeSize@?1??VerifySizeAndUpdate@@9@4_KA, ecx
  002b4	a3 04 00 00 00	 mov	 DWORD PTR ?nLastVolumeSize@?1??VerifySizeAndUpdate@@9@4_KA+4, eax
$LN24@VerifySize:

; 1557 : 	}
; 1558 : }

  002b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bc	33 cd		 xor	 ecx, ebp
  002be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c3	8b e5		 mov	 esp, ebp
  002c5	5d		 pop	 ebp
  002c6	c3		 ret	 0
_VerifySizeAndUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _ComboSelChangeEA
_TEXT	SEGMENT
_nIndex$1$ = -8832					; size = 4
_cipherIDs$1 = -8828					; size = 20
_auxLine$2 = -8808					; size = 8192
_hyperLink$3 = -616					; size = 512
_name$4 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_ComboSelChangeEA PROC					; COMDAT

; 1398 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 80 22 00 00	 mov	 eax, 8832		; 00002280H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi

; 1399 : 	LPARAM nIndex = SendMessage (GetDlgItem (hwndDlg, IDC_COMBO_BOX), CB_GETCURSEL, 0, 0);

  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  0001f	57		 push	 edi
  00020	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	68 47 01 00 00	 push	 327			; 00000147H
  0002c	68 ea 03 00 00	 push	 1002			; 000003eaH
  00031	57		 push	 edi
  00032	ff d6		 call	 esi
  00034	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SendMessageA@16
  0003a	50		 push	 eax
  0003b	ff d3		 call	 ebx
  0003d	89 85 80 dd ff
	ff		 mov	 DWORD PTR _nIndex$1$[ebp], eax

; 1400 : 
; 1401 : 	if (nIndex == CB_ERR)

  00043	83 f8 ff	 cmp	 eax, -1
  00046	75 25		 jne	 SHORT $LN6@ComboSelCh

; 1402 : 	{
; 1403 : 		SetWindowText (GetDlgItem (hwndDlg, IDC_BOX_HELP), "");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0004d	68 eb 03 00 00	 push	 1003			; 000003ebH
  00052	57		 push	 edi
  00053	ff d6		 call	 esi
  00055	50		 push	 eax
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx

; 1467 : 	}
; 1468 : }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN6@ComboSelCh:
  0006d	68 00 02 00 00	 push	 512			; 00000200H
  00072	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR _hyperLink$3[ebp]
  00078	6a 00		 push	 0
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _memset
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1404 : 	}
; 1405 : 	else
; 1406 : 	{
; 1407 : 		char name[100];
; 1408 : 		wchar_t auxLine[4096];
; 1409 : 		wchar_t hyperLink[256] = { 0 };
; 1410 : 		int cipherIDs[5];
; 1411 : 		int i, cnt = 0;
; 1412 : 
; 1413 : 		nIndex = SendMessage (GetDlgItem (hwndDlg, IDC_COMBO_BOX), CB_GETITEMDATA, nIndex, 0);

  00083	6a 00		 push	 0
  00085	ff b5 80 dd ff
	ff		 push	 DWORD PTR _nIndex$1$[ebp]
  0008b	68 50 01 00 00	 push	 336			; 00000150H
  00090	68 ea 03 00 00	 push	 1002			; 000003eaH
  00095	57		 push	 edi
  00096	ff d6		 call	 esi
  00098	50		 push	 eax
  00099	ff d3		 call	 ebx
  0009b	8b d8		 mov	 ebx, eax

; 1414 : 		EAGetName (name, nIndex);

  0009d	8d 45 98	 lea	 eax, DWORD PTR _name$4[ebp]
  000a0	53		 push	 ebx
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _EAGetName
  000a7	83 c4 08	 add	 esp, 8

; 1415 : 
; 1416 : 		if (strcmp (name, "GOST 28147-89") == 0)

  000aa	8d 4d 98	 lea	 ecx, DWORD PTR _name$4[ebp]
  000ad	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
$LL19@ComboSelCh:
  000b2	8a 01		 mov	 al, BYTE PTR [ecx]
  000b4	3a 02		 cmp	 al, BYTE PTR [edx]
  000b6	75 1a		 jne	 SHORT $LN20@ComboSelCh
  000b8	84 c0		 test	 al, al
  000ba	74 12		 je	 SHORT $LN21@ComboSelCh
  000bc	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000bf	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  000c2	75 0e		 jne	 SHORT $LN20@ComboSelCh
  000c4	83 c1 02	 add	 ecx, 2
  000c7	83 c2 02	 add	 edx, 2
  000ca	84 c0		 test	 al, al
  000cc	75 e4		 jne	 SHORT $LL19@ComboSelCh
$LN21@ComboSelCh:
  000ce	33 c0		 xor	 eax, eax
  000d0	eb 05		 jmp	 SHORT $LN22@ComboSelCh
$LN20@ComboSelCh:
  000d2	1b c0		 sbb	 eax, eax
  000d4	83 c8 01	 or	 eax, 1
$LN22@ComboSelCh:
  000d7	85 c0		 test	 eax, eax
  000d9	75 36		 jne	 SHORT $LN8@ComboSelCh

; 1417 : 		{
; 1418 : 			swprintf_s (hyperLink, sizeof(hyperLink) / 2, GetString ("MORE_INFO_ABOUT"), name);

  000db	8d 45 98	 lea	 eax, DWORD PTR _name$4[ebp]
  000de	50		 push	 eax
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LGBFJNHH@MORE_INFO_ABOUT?$AA@
  000e4	e8 00 00 00 00	 call	 _GetString
  000e9	83 c4 04	 add	 esp, 4
  000ec	50		 push	 eax
  000ed	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR _hyperLink$3[ebp]
  000f3	68 00 01 00 00	 push	 256			; 00000100H
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 _swprintf_s

; 1419 : 			
; 1420 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("GOST_HELP"));

  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_09JHKBFGFC@GOST_HELP?$AA@
  00103	e8 00 00 00 00	 call	 _GetString
  00108	83 c4 14	 add	 esp, 20			; 00000014H
  0010b	50		 push	 eax
  0010c	e9 6a 01 00 00	 jmp	 $LN23@ComboSelCh
$LN8@ComboSelCh:

; 1421 : 		}
; 1422 : 		else if (EAGetCipherCount (nIndex) > 1)

  00111	53		 push	 ebx
  00112	e8 00 00 00 00	 call	 _EAGetCipherCount
  00117	83 c4 04	 add	 esp, 4
  0011a	83 f8 01	 cmp	 eax, 1
  0011d	0f 8e 53 01 00
	00		 jle	 $LN10@ComboSelCh

; 1423 : 		{
; 1424 : 			// Cascade
; 1425 : 			cipherIDs[cnt++] = i = EAGetLastCipher(nIndex);

  00123	53		 push	 ebx
  00124	e8 00 00 00 00	 call	 _EAGetLastCipher

; 1426 : 			while (i = EAGetPreviousCipher(nIndex, i))

  00129	50		 push	 eax
  0012a	53		 push	 ebx
  0012b	89 85 84 dd ff
	ff		 mov	 DWORD PTR _cipherIDs$1[ebp], eax
  00131	be 01 00 00 00	 mov	 esi, 1
  00136	e8 00 00 00 00	 call	 _EAGetPreviousCipher
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013e	85 c0		 test	 eax, eax
  00140	74 16		 je	 SHORT $LN3@ComboSelCh
$LL2@ComboSelCh:
  00142	50		 push	 eax

; 1427 : 			{
; 1428 : 				cipherIDs[cnt] = i;

  00143	89 84 b5 84 dd
	ff ff		 mov	 DWORD PTR _cipherIDs$1[ebp+esi*4], eax

; 1429 : 				cnt++; 

  0014a	46		 inc	 esi
  0014b	53		 push	 ebx
  0014c	e8 00 00 00 00	 call	 _EAGetPreviousCipher
  00151	83 c4 08	 add	 esp, 8
  00154	85 c0		 test	 eax, eax
  00156	75 ea		 jne	 SHORT $LL2@ComboSelCh
$LN3@ComboSelCh:

; 1430 : 			}
; 1431 : 
; 1432 : 			switch (cnt)	// Number of ciphers in the cascade

  00158	83 ee 02	 sub	 esi, 2
  0015b	0f 84 7f 00 00
	00		 je	 $LN12@ComboSelCh
  00161	83 ee 01	 sub	 esi, 1
  00164	0f 85 cd 00 00
	00		 jne	 $LN4@ComboSelCh

; 1436 : 					CipherGetName (cipherIDs[1]),
; 1437 : 					CipherGetKeySize (cipherIDs[1])*8,
; 1438 : 					CipherGetName (cipherIDs[0]),
; 1439 : 					CipherGetKeySize (cipherIDs[0])*8);
; 1440 : 				break;
; 1441 : 
; 1442 : 			case 3:
; 1443 : 				swprintf (auxLine, GetString ("THREE_LAYER_CASCADE_HELP"), 

  0016a	8b b5 84 dd ff
	ff		 mov	 esi, DWORD PTR _cipherIDs$1[ebp]
  00170	56		 push	 esi
  00171	e8 00 00 00 00	 call	 _CipherGetKeySize
  00176	83 c4 04	 add	 esp, 4
  00179	c1 e0 03	 shl	 eax, 3
  0017c	50		 push	 eax
  0017d	56		 push	 esi
  0017e	e8 00 00 00 00	 call	 _CipherGetName
  00183	8b b5 88 dd ff
	ff		 mov	 esi, DWORD PTR _cipherIDs$1[ebp+4]
  00189	83 c4 04	 add	 esp, 4
  0018c	50		 push	 eax
  0018d	56		 push	 esi
  0018e	e8 00 00 00 00	 call	 _CipherGetKeySize
  00193	83 c4 04	 add	 esp, 4
  00196	c1 e0 03	 shl	 eax, 3
  00199	50		 push	 eax
  0019a	56		 push	 esi
  0019b	e8 00 00 00 00	 call	 _CipherGetName
  001a0	8b b5 8c dd ff
	ff		 mov	 esi, DWORD PTR _cipherIDs$1[ebp+8]
  001a6	83 c4 04	 add	 esp, 4
  001a9	50		 push	 eax
  001aa	56		 push	 esi
  001ab	e8 00 00 00 00	 call	 _CipherGetKeySize
  001b0	83 c4 04	 add	 esp, 4
  001b3	c1 e0 03	 shl	 eax, 3
  001b6	50		 push	 eax
  001b7	56		 push	 esi
  001b8	e8 00 00 00 00	 call	 _CipherGetName
  001bd	83 c4 04	 add	 esp, 4
  001c0	50		 push	 eax
  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CFADADFJ@THREE_LAYER_CASCADE_HELP?$AA@
  001c6	e8 00 00 00 00	 call	 _GetString
  001cb	83 c4 04	 add	 esp, 4
  001ce	50		 push	 eax
  001cf	8d 85 98 dd ff
	ff		 lea	 eax, DWORD PTR _auxLine$2[ebp]
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf
  001db	83 c4 20	 add	 esp, 32			; 00000020H
  001de	eb 57		 jmp	 SHORT $LN4@ComboSelCh
$LN12@ComboSelCh:

; 1433 : 			{
; 1434 : 			case 2:
; 1435 : 				swprintf (auxLine, GetString ("TWO_LAYER_CASCADE_HELP"), 

  001e0	8b b5 84 dd ff
	ff		 mov	 esi, DWORD PTR _cipherIDs$1[ebp]
  001e6	56		 push	 esi
  001e7	e8 00 00 00 00	 call	 _CipherGetKeySize
  001ec	83 c4 04	 add	 esp, 4
  001ef	c1 e0 03	 shl	 eax, 3
  001f2	50		 push	 eax
  001f3	56		 push	 esi
  001f4	e8 00 00 00 00	 call	 _CipherGetName
  001f9	8b b5 88 dd ff
	ff		 mov	 esi, DWORD PTR _cipherIDs$1[ebp+4]
  001ff	83 c4 04	 add	 esp, 4
  00202	50		 push	 eax
  00203	56		 push	 esi
  00204	e8 00 00 00 00	 call	 _CipherGetKeySize
  00209	83 c4 04	 add	 esp, 4
  0020c	c1 e0 03	 shl	 eax, 3
  0020f	50		 push	 eax
  00210	56		 push	 esi
  00211	e8 00 00 00 00	 call	 _CipherGetName
  00216	83 c4 04	 add	 esp, 4
  00219	50		 push	 eax
  0021a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PJGBOAEF@TWO_LAYER_CASCADE_HELP?$AA@
  0021f	e8 00 00 00 00	 call	 _GetString
  00224	83 c4 04	 add	 esp, 4
  00227	50		 push	 eax
  00228	8d 85 98 dd ff
	ff		 lea	 eax, DWORD PTR _auxLine$2[ebp]
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf
  00234	83 c4 18	 add	 esp, 24			; 00000018H
$LN4@ComboSelCh:

; 1444 : 					CipherGetName (cipherIDs[2]),
; 1445 : 					CipherGetKeySize (cipherIDs[2])*8,
; 1446 : 					CipherGetName (cipherIDs[1]),
; 1447 : 					CipherGetKeySize (cipherIDs[1])*8,
; 1448 : 					CipherGetName (cipherIDs[0]),
; 1449 : 					CipherGetKeySize (cipherIDs[0])*8);
; 1450 : 				break;
; 1451 : 			}
; 1452 : 
; 1453 : 			wcscpy_s (hyperLink, sizeof(hyperLink) / 2, GetString ("IDC_LINK_MORE_INFO_ABOUT_CIPHER"));

  00237	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@EHDIKOJL@IDC_LINK_MORE_INFO_ABOUT_CIPHER?$AA@
  0023c	e8 00 00 00 00	 call	 _GetString
  00241	50		 push	 eax
  00242	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR _hyperLink$3[ebp]
  00248	68 00 01 00 00	 push	 256			; 00000100H
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 _wcscpy_s

; 1454 : 
; 1455 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), auxLine);

  00253	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  00259	8d 85 98 dd ff
	ff		 lea	 eax, DWORD PTR _auxLine$2[ebp]
  0025f	83 c4 10	 add	 esp, 16			; 00000010H
  00262	50		 push	 eax
  00263	68 eb 03 00 00	 push	 1003			; 000003ebH
  00268	57		 push	 edi
  00269	ff d3		 call	 ebx
  0026b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00271	50		 push	 eax
  00272	ff d6		 call	 esi

; 1456 : 		}
; 1457 : 		else

  00274	eb 1c		 jmp	 SHORT $LN11@ComboSelCh
$LN10@ComboSelCh:

; 1458 : 		{
; 1459 : 			// No info available for this encryption algorithm
; 1460 : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), L"");

  00276	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
$LN23@ComboSelCh:
  0027b	68 eb 03 00 00	 push	 1003			; 000003ebH
  00280	57		 push	 edi
  00281	ff d6		 call	 esi
  00283	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00289	50		 push	 eax
  0028a	ff d6		 call	 esi
  0028c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
$LN11@ComboSelCh:

; 1461 : 		}
; 1462 : 
; 1463 : 
; 1464 : 		// Update hyperlink
; 1465 : 		SetWindowTextW (GetDlgItem (hwndDlg, IDC_LINK_MORE_INFO_ABOUT_CIPHER), hyperLink);

  00292	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR _hyperLink$3[ebp]
  00298	50		 push	 eax
  00299	68 21 04 00 00	 push	 1057			; 00000421H
  0029e	57		 push	 edi
  0029f	ff d3		 call	 ebx
  002a1	50		 push	 eax
  002a2	ff d6		 call	 esi

; 1466 : 		AccommodateTextField (hwndDlg, IDC_LINK_MORE_INFO_ABOUT_CIPHER, FALSE, hUserUnderlineFont);

  002a4	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserUnderlineFont
  002aa	6a 00		 push	 0
  002ac	68 21 04 00 00	 push	 1057			; 00000421H
  002b1	57		 push	 edi
  002b2	e8 00 00 00 00	 call	 _AccommodateTextField

; 1467 : 	}
; 1468 : }

  002b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ba	83 c4 10	 add	 esp, 16			; 00000010H
  002bd	33 cd		 xor	 ecx, ebp
  002bf	5f		 pop	 edi
  002c0	5e		 pop	 esi
  002c1	5b		 pop	 ebx
  002c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c7	8b e5		 mov	 esp, ebp
  002c9	5d		 pop	 ebp
  002ca	c3		 ret	 0
_ComboSelChangeEA ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _EndMainDlg
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_EndMainDlg PROC					; COMDAT

; 810  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 811  : 	if (nCurPageNo == VOLUME_LOCATION_PAGE)

  00003	83 3d 00 00 00
	00 0e		 cmp	 DWORD PTR ?nCurPageNo@@3HA, 14 ; nCurPageNo, 0000000eH
  0000a	56		 push	 esi
  0000b	75 69		 jne	 SHORT $LN2@EndMainDlg

; 812  : 	{
; 813  : 		if (IsWindow(GetDlgItem(hCurPage, IDC_NO_HISTORY)))

  0000d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00013	68 f4 03 00 00	 push	 1012			; 000003f4H
  00018	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0001e	ff d6		 call	 esi
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsWindow@4
  00027	85 c0		 test	 eax, eax
  00029	74 22		 je	 SHORT $LN7@EndMainDlg

; 814  : 			bHistory = !IsButtonChecked (GetDlgItem (hCurPage, IDC_NO_HISTORY));

  0002b	68 f4 03 00 00	 push	 1012			; 000003f4H
  00030	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  00036	ff d6		 call	 esi
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _IsButtonChecked
  0003e	83 c4 04	 add	 esp, 4
  00041	f7 d8		 neg	 eax
  00043	1b c0		 sbb	 eax, eax
  00045	40		 inc	 eax
  00046	a3 00 00 00 00	 mov	 DWORD PTR _bHistory, eax
  0004b	eb 05		 jmp	 SHORT $LN4@EndMainDlg
$LN7@EndMainDlg:
  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bHistory
$LN4@EndMainDlg:

; 815  : 
; 816  : 		MoveEditToCombo (GetDlgItem (hCurPage, IDC_COMBO_BOX), bHistory);

  00052	50		 push	 eax
  00053	68 ea 03 00 00	 push	 1002			; 000003eaH
  00058	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0005e	ff d6		 call	 esi
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _MoveEditToCombo

; 817  : 		SaveSettings (hCurPage);

  00066	ff 35 00 00 00
	00		 push	 DWORD PTR _hCurPage
  0006c	e8 00 00 00 00	 call	 _SaveSettings
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 818  : 	}
; 819  : 	else 

  00074	eb 0a		 jmp	 SHORT $LN3@EndMainDlg
$LN2@EndMainDlg:

; 820  : 	{
; 821  : 		SaveSettings (NULL);

  00076	6a 00		 push	 0
  00078	e8 00 00 00 00	 call	 _SaveSettings
  0007d	83 c4 04	 add	 esp, 4
$LN3@EndMainDlg:

; 822  : 	}
; 823  : 
; 824  : 	SaveSysEncSettings (hwndDlg);

  00080	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]
  00083	56		 push	 esi
  00084	e8 00 00 00 00	 call	 ?SaveSysEncSettings@@YAHPAUHWND__@@@Z ; SaveSysEncSettings
  00089	83 c4 04	 add	 esp, 4

; 825  : 
; 826  : 	if (!bHistory)

  0008c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bHistory, 0
  00093	75 05		 jne	 SHORT $LN5@EndMainDlg

; 827  : 		CleanLastVisitedMRU ();

  00095	e8 00 00 00 00	 call	 _CleanLastVisitedMRU
$LN5@EndMainDlg:

; 828  : 
; 829  : 	EndDialog (hwndDlg, 0);

  0009a	6a 00		 push	 0
  0009c	56		 push	 esi
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8
  000a3	5e		 pop	 esi

; 830  : }

  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
_EndMainDlg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _SaveSettings
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_SaveSettings PROC					; COMDAT

; 778  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  : 	WaitCursor ();

  00003	e8 00 00 00 00	 call	 _WaitCursor

; 780  : 
; 781  : 	if (hwndDlg != NULL)

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _hwndDlg$[ebp]
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 21		 je	 SHORT $LN2@SaveSettin

; 782  : 		DumpCombo (GetDlgItem (hwndDlg, IDC_COMBO_BOX), !bHistory);

  0000f	33 c0		 xor	 eax, eax
  00011	39 05 00 00 00
	00		 cmp	 DWORD PTR _bHistory, eax
  00017	0f 94 c0	 sete	 al
  0001a	50		 push	 eax
  0001b	68 ea 03 00 00	 push	 1002			; 000003eaH
  00020	51		 push	 ecx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _DumpCombo
  0002d	83 c4 08	 add	 esp, 8
$LN2@SaveSettin:

; 783  : 
; 784  : 	ConfigWriteBegin ();

  00030	e8 00 00 00 00	 call	 _ConfigWriteBegin

; 785  : 
; 786  : 	ConfigWriteInt ("StartOnLogon",	bStartOnLogon);

  00035	ff 35 00 00 00
	00		 push	 DWORD PTR _bStartOnLogon
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PLOGBODB@StartOnLogon?$AA@
  00040	e8 00 00 00 00	 call	 _ConfigWriteInt

; 787  : 	ConfigWriteInt ("HiddenSectorDetectionStatus", HiddenSectorDetectionStatus);

  00045	ff 35 00 00 00
	00		 push	 DWORD PTR _HiddenSectorDetectionStatus
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GHIJBHNC@HiddenSectorDetectionStatus?$AA@
  00050	e8 00 00 00 00	 call	 _ConfigWriteInt

; 788  : 	ConfigWriteInt ("SaveVolumeHistory", bHistory);

  00055	ff 35 00 00 00
	00		 push	 DWORD PTR _bHistory
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CGLEBHPJ@SaveVolumeHistory?$AA@
  00060	e8 00 00 00 00	 call	 _ConfigWriteInt

; 789  : 	ConfigWriteString ("SecurityTokenLibrary", SecurityTokenLibraryPath[0] ? SecurityTokenLibraryPath : "");

  00065	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _SecurityTokenLibraryPath, 0
  0006c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00071	b8 00 00 00 00	 mov	 eax, OFFSET _SecurityTokenLibraryPath
  00076	0f 44 c1	 cmove	 eax, ecx
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MIMCAHPI@SecurityTokenLibrary?$AA@
  0007f	e8 00 00 00 00	 call	 _ConfigWriteString
  00084	83 c4 20	 add	 esp, 32			; 00000020H

; 790  : 
; 791  : 	if (GetPreferredLangId () != NULL)

  00087	e8 00 00 00 00	 call	 _GetPreferredLangId
  0008c	85 c0		 test	 eax, eax
  0008e	74 13		 je	 SHORT $LN3@SaveSettin

; 792  : 		ConfigWriteString ("Language", GetPreferredLangId ());

  00090	e8 00 00 00 00	 call	 _GetPreferredLangId
  00095	50		 push	 eax
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_08BENDAOKD@Language?$AA@
  0009b	e8 00 00 00 00	 call	 _ConfigWriteString
  000a0	83 c4 08	 add	 esp, 8
$LN3@SaveSettin:

; 793  : 
; 794  : 	ConfigWriteEnd ();

  000a3	e8 00 00 00 00	 call	 _ConfigWriteEnd

; 797  : }

  000a8	5d		 pop	 ebp

; 795  : 
; 796  : 	NormalCursor ();

  000a9	e9 00 00 00 00	 jmp	 _NormalCursor
_SaveSettings ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _LoadSettings
_TEXT	SEGMENT
_savedWipeAlgorithm$ = -4				; size = 4
_hwndDlg$ = 8						; size = 4
_LoadSettings PROC					; COMDAT

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 738  : 	EnableHwEncryption ((ReadDriverConfigurationFlags() & GST_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION) ? FALSE : TRUE);

  00005	e8 00 00 00 00	 call	 _ReadDriverConfigurationFlags
  0000a	c1 e8 03	 shr	 eax, 3
  0000d	f7 d0		 not	 eax
  0000f	83 e0 01	 and	 eax, 1
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _EnableHwEncryption

; 739  : 
; 740  : 	WipeAlgorithmId savedWipeAlgorithm = GST_WIPE_NONE;
; 741  : 
; 742  : 	LoadSysEncSettings (hwndDlg);

  00018	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]
  0001b	56		 push	 esi
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _savedWipeAlgorithm$[ebp], 0
  00023	e8 00 00 00 00	 call	 _LoadSysEncSettings

; 743  : 
; 744  : 	if (LoadNonSysInPlaceEncSettings (&savedWipeAlgorithm) != 0)

  00028	8d 45 fc	 lea	 eax, DWORD PTR _savedWipeAlgorithm$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _LoadNonSysInPlaceEncSettings
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bInPlaceEncNonSysPending
  00037	85 c0		 test	 eax, eax
  00039	ba 01 00 00 00	 mov	 edx, 1

; 745  : 		bInPlaceEncNonSysPending = TRUE;
; 746  : 
; 747  : 	defaultKeyFilesParam.EnableKeyFiles = FALSE;

  0003e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _defaultKeyFilesParam, 0
  00048	0f 45 ca	 cmovne	 ecx, edx

; 748  : 
; 749  : 	bStartOnLogon =	ConfigReadInt ("StartOnLogon", FALSE);

  0004b	6a 00		 push	 0
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PLOGBODB@StartOnLogon?$AA@
  00052	89 0d 00 00 00
	00		 mov	 DWORD PTR _bInPlaceEncNonSysPending, ecx
  00058	e8 00 00 00 00	 call	 _ConfigReadInt

; 750  : 
; 751  : 	HiddenSectorDetectionStatus = ConfigReadInt ("HiddenSectorDetectionStatus", 0);

  0005d	6a 00		 push	 0
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GHIJBHNC@HiddenSectorDetectionStatus?$AA@
  00064	a3 00 00 00 00	 mov	 DWORD PTR _bStartOnLogon, eax
  00069	e8 00 00 00 00	 call	 _ConfigReadInt

; 752  : 
; 753  : 	bHistory = ConfigReadInt ("SaveVolumeHistory", FALSE);

  0006e	6a 00		 push	 0
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CGLEBHPJ@SaveVolumeHistory?$AA@
  00075	a3 00 00 00 00	 mov	 DWORD PTR _HiddenSectorDetectionStatus, eax
  0007a	e8 00 00 00 00	 call	 _ConfigReadInt

; 754  : 
; 755  : 	ConfigReadString ("SecurityTokenLibrary", "", SecurityTokenLibraryPath, sizeof (SecurityTokenLibraryPath) - 1);

  0007f	68 03 01 00 00	 push	 259			; 00000103H
  00084	68 00 00 00 00	 push	 OFFSET _SecurityTokenLibraryPath
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MIMCAHPI@SecurityTokenLibrary?$AA@
  00093	a3 00 00 00 00	 mov	 DWORD PTR _bHistory, eax
  00098	e8 00 00 00 00	 call	 _ConfigReadString
  0009d	83 c4 34	 add	 esp, 52			; 00000034H

; 756  : 	if (SecurityTokenLibraryPath[0])

  000a0	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _SecurityTokenLibraryPath, 0
  000a7	74 05		 je	 SHORT $LN3@LoadSettin

; 757  : 		InitSecurityTokenLibrary();

  000a9	e8 00 00 00 00	 call	 _InitSecurityTokenLibrary
$LN3@LoadSettin:

; 758  : 
; 759  : 	if (hwndDlg != NULL)

  000ae	85 f6		 test	 esi, esi
  000b0	74 15		 je	 SHORT $LN4@LoadSettin

; 760  : 	{
; 761  : 		LoadCombo (GetDlgItem (hwndDlg, IDC_COMBO_BOX));

  000b2	68 ea 03 00 00	 push	 1002			; 000003eaH
  000b7	56		 push	 esi
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _LoadCombo
  000c4	83 c4 04	 add	 esp, 4
$LN4@LoadSettin:
  000c7	5e		 pop	 esi

; 762  : 		return;
; 763  : 	}
; 764  : 
; 765  : 	if (bHistoryCmdLine)
; 766  : 		return;
; 767  : }

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
_LoadSettings ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _localcleanup
_TEXT	SEGMENT
$T2 = -492						; size = 94
_tmp$ = -396						; size = 371
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_localcleanup PROC					; COMDAT

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_localcleanup
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e0 01 00
	00		 sub	 esp, 480		; 000001e0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 333  : 	char tmp[RANDPOOL_DISPLAY_SIZE+1];
; 334  : 
; 335  : 	// System encryption
; 336  : 
; 337  : 	if (WizardMode == WIZARD_MODE_SYS_DEVICE
; 338  : 		&& InstanceHasSysEncMutex ())

  00031	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _WizardMode, 2
  00038	75 46		 jne	 SHORT $LN53@localclean
  0003a	e8 00 00 00 00	 call	 _InstanceHasSysEncMutex
  0003f	85 c0		 test	 eax, eax
  00041	74 3d		 je	 SHORT $LN53@localclean

; 339  : 	{
; 340  : 		try
; 341  : 		{
; 342  : 			BootEncStatus = BootEncObj->GetStatus();

  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  00049	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0004f	50		 push	 eax
  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00057	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  0005c	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00061	8b f0		 mov	 esi, eax
  00063	bf 00 00 00 00	 mov	 edi, OFFSET ?BootEncStatus@@3UBootEncryptionStatus@@A ; BootEncStatus
  00068	f3 a5		 rep movsd
  0006a	66 a5		 movsw

; 343  : 
; 344  : 			if (BootEncStatus.SetupInProgress)

  0006c	83 3d 3e 00 00
	00 00		 cmp	 DWORD PTR ?BootEncStatus@@3UBootEncryptionStatus@@A+62, 0
  00073	74 0b		 je	 SHORT $LN53@localclean

; 345  : 			{
; 346  : 				BootEncObj->AbortSetup ();

  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0007b	e8 00 00 00 00	 call	 ?AbortSetup@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::AbortSetup
$LN53@localclean:

; 353  : 	}
; 354  : 
; 355  : 	// Mon-system in-place encryption
; 356  : 
; 357  : 	if (bInPlaceEncNonSys && (bVolTransformThreadRunning || bVolTransformThreadToRun))

  00080	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bInPlaceEncNonSys, 0
  00087	74 17		 je	 SHORT $LN40@localclean
  00089	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadRunning@@3HC, 0 ; bVolTransformThreadRunning
  00090	75 09		 jne	 SHORT $LN41@localclean
  00092	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bVolTransformThreadToRun@@3HC, 0 ; bVolTransformThreadToRun
  00099	74 05		 je	 SHORT $LN40@localclean
$LN41@localclean:

; 358  : 	{
; 359  : 		NonSysInplaceEncPause ();

  0009b	e8 00 00 00 00	 call	 _NonSysInplaceEncPause
$LN40@localclean:

; 360  : 	}
; 361  : 
; 362  : 	CloseNonSysInplaceEncMutex ();

  000a0	e8 00 00 00 00	 call	 _CloseNonSysInplaceEncMutex

; 363  : 	
; 364  : 
; 365  : 	// Device wipe
; 366  : 
; 367  : 	if (bDeviceWipeInProgress)

  000a5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDeviceWipeInProgress@@3HA, 0 ; bDeviceWipeInProgress
  000ac	74 05		 je	 SHORT $LN42@localclean

; 368  : 		WipeAbort();

  000ae	e8 00 00 00 00	 call	 _WipeAbort
$LN42@localclean:

; 369  : 
; 370  : 
; 371  : 	WipePasswordsAndKeyfiles ();

  000b3	e8 00 00 00 00	 call	 ?WipePasswordsAndKeyfiles@@YAXXZ ; WipePasswordsAndKeyfiles

; 372  : 
; 373  : 	RandStop (TRUE);

  000b8	6a 01		 push	 1
  000ba	e8 00 00 00 00	 call	 _RandStop

; 374  : 
; 375  : 	burn (HeaderKeyGUIView, sizeof(HeaderKeyGUIView));

  000bf	b8 00 00 00 00	 mov	 eax, OFFSET _HeaderKeyGUIView
  000c4	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000c9	83 c4 04	 add	 esp, 4
  000cc	8b f1		 mov	 esi, ecx
  000ce	8b d0		 mov	 edx, eax
$LL55@localclean:
  000d0	c6 02 00	 mov	 BYTE PTR [edx], 0
  000d3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000d6	83 ee 01	 sub	 esi, 1
  000d9	75 f5		 jne	 SHORT $LL55@localclean
  000db	0f 1f 44 00 00	 npad	 5
$LL5@localclean:
  000e0	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000e6	83 e9 01	 sub	 ecx, 1
  000e9	75 f5		 jne	 SHORT $LL5@localclean

; 376  : 	burn (MasterKeyGUIView, sizeof(MasterKeyGUIView));

  000eb	b8 00 00 00 00	 mov	 eax, OFFSET _MasterKeyGUIView
  000f0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f5	8b f1		 mov	 esi, ecx
  000f7	8b d0		 mov	 edx, eax
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL59@localclean:
  00100	c6 02 00	 mov	 BYTE PTR [edx], 0
  00103	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00106	83 ee 01	 sub	 esi, 1
  00109	75 f5		 jne	 SHORT $LL59@localclean
  0010b	0f 1f 44 00 00	 npad	 5
$LL10@localclean:
  00110	c6 00 00	 mov	 BYTE PTR [eax], 0
  00113	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00116	83 e9 01	 sub	 ecx, 1
  00119	75 f5		 jne	 SHORT $LL10@localclean

; 377  : 	burn (randPool, sizeof(randPool));

  0011b	b8 00 00 00 00	 mov	 eax, OFFSET ?randPool@@3PAEA ; randPool
  00120	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00125	8b f1		 mov	 esi, ecx
  00127	8b d0		 mov	 edx, eax
  00129	0f 1f 80 00 00
	00 00		 npad	 7
$LL63@localclean:
  00130	c6 02 00	 mov	 BYTE PTR [edx], 0
  00133	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00136	83 ee 01	 sub	 esi, 1
  00139	75 f5		 jne	 SHORT $LL63@localclean
  0013b	0f 1f 44 00 00	 npad	 5
$LL15@localclean:
  00140	c6 00 00	 mov	 BYTE PTR [eax], 0
  00143	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00146	83 e9 01	 sub	 ecx, 1
  00149	75 f5		 jne	 SHORT $LL15@localclean

; 378  : 	burn (lastRandPool, sizeof(lastRandPool));

  0014b	b8 00 00 00 00	 mov	 eax, OFFSET ?lastRandPool@@3PAEA ; lastRandPool
  00150	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00155	8b f1		 mov	 esi, ecx
  00157	8b d0		 mov	 edx, eax
  00159	0f 1f 80 00 00
	00 00		 npad	 7
$LL67@localclean:
  00160	c6 02 00	 mov	 BYTE PTR [edx], 0
  00163	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00166	83 ee 01	 sub	 esi, 1
  00169	75 f5		 jne	 SHORT $LL67@localclean
  0016b	0f 1f 44 00 00	 npad	 5
$LL20@localclean:
  00170	c6 00 00	 mov	 BYTE PTR [eax], 0
  00173	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00176	83 e9 01	 sub	 ecx, 1
  00179	75 f5		 jne	 SHORT $LL20@localclean

; 379  : 	burn (outRandPoolDispBuffer, sizeof(outRandPoolDispBuffer));

  0017b	b8 00 00 00 00	 mov	 eax, OFFSET ?outRandPoolDispBuffer@@3PAEA ; outRandPoolDispBuffer
  00180	b9 72 01 00 00	 mov	 ecx, 370		; 00000172H
  00185	8b f1		 mov	 esi, ecx
  00187	8b d0		 mov	 edx, eax
  00189	0f 1f 80 00 00
	00 00		 npad	 7
$LL71@localclean:
  00190	c6 02 00	 mov	 BYTE PTR [edx], 0
  00193	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00196	83 ee 01	 sub	 esi, 1
  00199	75 f5		 jne	 SHORT $LL71@localclean
  0019b	0f 1f 44 00 00	 npad	 5
$LL25@localclean:
  001a0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001a3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  001a6	83 e9 01	 sub	 ecx, 1
  001a9	75 f5		 jne	 SHORT $LL25@localclean

; 380  : 	burn (szFileName, sizeof(szFileName));

  001ab	b8 00 00 00 00	 mov	 eax, OFFSET ?szFileName@@3PADA ; szFileName
  001b0	b9 05 01 00 00	 mov	 ecx, 261		; 00000105H
  001b5	8b f1		 mov	 esi, ecx
  001b7	8b d0		 mov	 edx, eax
  001b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL75@localclean:
  001c0	c6 02 00	 mov	 BYTE PTR [edx], 0
  001c3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  001c6	83 ee 01	 sub	 esi, 1
  001c9	75 f5		 jne	 SHORT $LL75@localclean
  001cb	0f 1f 44 00 00	 npad	 5
$LL30@localclean:
  001d0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001d3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  001d6	83 e9 01	 sub	 ecx, 1
  001d9	75 f5		 jne	 SHORT $LL30@localclean

; 381  : 	burn (szDiskFile, sizeof(szDiskFile));

  001db	b8 00 00 00 00	 mov	 eax, OFFSET ?szDiskFile@@3PADA ; szDiskFile
  001e0	b9 05 01 00 00	 mov	 ecx, 261		; 00000105H
  001e5	8b f1		 mov	 esi, ecx
  001e7	8b d0		 mov	 edx, eax
  001e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL79@localclean:
  001f0	c6 02 00	 mov	 BYTE PTR [edx], 0
  001f3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  001f6	83 ee 01	 sub	 esi, 1
  001f9	75 f5		 jne	 SHORT $LL79@localclean
  001fb	0f 1f 44 00 00	 npad	 5
$LL35@localclean:
  00200	c6 00 00	 mov	 BYTE PTR [eax], 0
  00203	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00206	83 e9 01	 sub	 ecx, 1
  00209	75 f5		 jne	 SHORT $LL35@localclean

; 382  : 
; 383  : 	// Attempt to wipe the GUI fields showing portions of randpool, of the master and header keys
; 384  : 	memset (tmp, 'X', sizeof(tmp));

  0020b	68 73 01 00 00	 push	 371			; 00000173H
  00210	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00216	6a 58		 push	 88			; 00000058H
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 _memset

; 385  : 	tmp [sizeof(tmp)-1] = 0;
; 386  : 	SetWindowText (hRandPool, tmp);

  0021e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextA@8
  00224	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  0022a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022d	c6 45 e6 00	 mov	 BYTE PTR _tmp$[ebp+370], 0
  00231	50		 push	 eax
  00232	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hRandPool@@3RAUHWND__@@A ; hRandPool
  00237	50		 push	 eax
  00238	ff d6		 call	 esi

; 387  : 	SetWindowText (hRandPoolSys, tmp);

  0023a	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00240	50		 push	 eax
  00241	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hRandPoolSys@@3RAUHWND__@@A ; hRandPoolSys
  00246	50		 push	 eax
  00247	ff d6		 call	 esi

; 388  : 	SetWindowText (hMasterKey, tmp);

  00249	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  0024f	50		 push	 eax
  00250	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMasterKey
  00255	50		 push	 eax
  00256	ff d6		 call	 esi

; 389  : 	SetWindowText (hHeaderKey, tmp);

  00258	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  0025e	50		 push	 eax
  0025f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hHeaderKey
  00264	50		 push	 eax
  00265	ff d6		 call	 esi

; 390  : 
; 391  : 	UnregisterRedTick (hInst);

  00267	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  0026d	e8 00 00 00 00	 call	 _UnregisterRedTick

; 392  : 
; 393  : 	// Delete buffered bitmaps (if any)
; 394  : 	if (hbmWizardBitmapRescaled != NULL)

  00272	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hbmWizardBitmapRescaled@@3PAUHBITMAP__@@A ; hbmWizardBitmapRescaled
  00277	83 c4 04	 add	 esp, 4
  0027a	85 c0		 test	 eax, eax
  0027c	74 11		 je	 SHORT $LN43@localclean

; 395  : 	{
; 396  : 		DeleteObject ((HGDIOBJ) hbmWizardBitmapRescaled);

  0027e	50		 push	 eax
  0027f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 397  : 		hbmWizardBitmapRescaled = NULL;

  00285	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hbmWizardBitmapRescaled@@3PAUHBITMAP__@@A, 0 ; hbmWizardBitmapRescaled
$LN43@localclean:

; 398  : 	}
; 399  : 
; 400  : 	// Cleanup common code resources
; 401  : 	cleanup ();

  0028f	e8 00 00 00 00	 call	 _cleanup

; 402  : 
; 403  : 	if (BootEncObj != NULL)

  00294	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
  0029a	85 f6		 test	 esi, esi
  0029c	74 1f		 je	 SHORT $LN44@localclean

; 404  : 	{
; 405  : 		delete BootEncObj;

  0029e	8b ce		 mov	 ecx, esi
  002a0	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  002a5	68 c8 05 00 00	 push	 1480			; 000005c8H
  002aa	56		 push	 esi
  002ab	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002b0	83 c4 08	 add	 esp, 8

; 406  : 		BootEncObj = NULL;

  002b3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A, 0 ; BootEncObj
$LN44@localclean:

; 407  : 	}
; 408  : }

  002bd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002c7	59		 pop	 ecx
  002c8	5f		 pop	 edi
  002c9	5e		 pop	 esi
  002ca	5b		 pop	 ebx
  002cb	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ce	33 cd		 xor	 ecx, ebp
  002d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d5	8b e5		 mov	 esp, ebp
  002d7	5d		 pop	 ebp
  002d8	c3		 ret	 0
__catch$_localcleanup$0:

; 347  : 			}
; 348  : 		}
; 349  : 		catch (...)
; 350  : 		{
; 351  : 			// NOP
; 352  : 		}

  002d9	b8 00 00 00 00	 mov	 eax, $LN53@localclean
  002de	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$_localcleanup:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 10 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-496]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_localcleanup
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_localcleanup ENDP
; Function compile flags: /Ogtp
;	COMDAT ??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z PROC		; GostCrypt::ForEach::Container::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z ENDP		; GostCrypt::ForEach::Container::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ
_TEXT	SEGMENT
?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ PROC ; GostCrypt::ForEach::Container::InnerIsNotEnd, COMDAT
; _this$ = ecx

; 23   : 			bool InnerIsNotEnd () const { return InnerEndCondition = !InnerEndCondition; }

  00000	33 c0		 xor	 eax, eax
  00002	38 41 05	 cmp	 BYTE PTR [ecx+5], al
  00005	0f 94 c0	 sete	 al
  00008	88 41 05	 mov	 BYTE PTR [ecx+5], al
  0000b	c3		 ret	 0
?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ ENDP ; GostCrypt::ForEach::Container::InnerIsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Continue@Container@ForEach@GostCrypt@@QBEXXZ
_TEXT	SEGMENT
?Continue@Container@ForEach@GostCrypt@@QBEXXZ PROC	; GostCrypt::ForEach::Container::Continue, COMDAT
; _this$ = ecx

; 22   : 			void Continue () const { InnerContinue = true; }

  00000	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1
  00004	c3		 ret	 0
?Continue@Container@ForEach@GostCrypt@@QBEXXZ ENDP	; GostCrypt::ForEach::Container::Continue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??1Container@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1Container@ForEach@GostCrypt@@UAE@XZ PROC		; GostCrypt::ForEach::Container::~Container, COMDAT
; _this$ = ecx

; 20   : 			virtual ~Container () { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00006	c3		 ret	 0
??1Container@ForEach@GostCrypt@@UAE@XZ ENDP		; GostCrypt::ForEach::Container::~Container
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0Container@ForEach@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0Container@ForEach@GostCrypt@@QAE@XZ PROC		; GostCrypt::ForEach::Container::Container, COMDAT
; _this$ = ecx

; 19   : 			Container () : InnerContinue (true), InnerEndCondition (false) { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	66 c7 41 04 01
	00		 mov	 WORD PTR [ecx+4], 1
  0000e	c3		 ret	 0
??0Container@ForEach@GostCrypt@@QAE@XZ ENDP		; GostCrypt::ForEach::Container::Container
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GBootEncryption@GostCrypt@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GBootEncryption@GostCrypt@@QAEPAXI@Z PROC		; GostCrypt::BootEncryption::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 c8 05 00 00	 push	 1480			; 000005c8H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GBootEncryption@GostCrypt@@QAEPAXI@Z ENDP		; GostCrypt::BootEncryption::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1SystemDriveConfiguration@GostCrypt@@QAE@XZ PROC	; GostCrypt::SystemDriveConfiguration::~SystemDriveConfiguration, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8d 8f c0 00 00
	00		 lea	 ecx, DWORD PTR [edi+192]
  0000a	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  0000f	8d 8f b8 00 00
	00		 lea	 ecx, DWORD PTR [edi+184]
  00015	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
  0001a	ff b7 b8 00 00
	00		 push	 DWORD PTR [edi+184]
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
  00028	8d 4f 38	 lea	 ecx, DWORD PTR [edi+56]
  0002b	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  00030	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00033	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00036	83 f8 10	 cmp	 eax, 16			; 00000010H
  00039	72 0b		 jb	 SHORT $LN82@SystemDriv
  0003b	40		 inc	 eax
  0003c	8b ce		 mov	 ecx, esi
  0003e	50		 push	 eax
  0003f	ff 36		 push	 DWORD PTR [esi]
  00041	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN82@SystemDriv:
  00046	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0004d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00051	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00058	72 02		 jb	 SHORT $LN170@SystemDriv
  0005a	8b 36		 mov	 esi, DWORD PTR [esi]
$LN170@SystemDriv:
  0005c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0005f	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00062	83 f8 10	 cmp	 eax, 16			; 00000010H
  00065	72 0b		 jb	 SHORT $LN183@SystemDriv
  00067	40		 inc	 eax
  00068	8b cf		 mov	 ecx, edi
  0006a	50		 push	 eax
  0006b	ff 37		 push	 DWORD PTR [edi]
  0006d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN183@SystemDriv:
  00072	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00079	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  0007d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00084	72 08		 jb	 SHORT $LN271@SystemDriv
  00086	8b 07		 mov	 eax, DWORD PTR [edi]
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0008d	c3		 ret	 0
$LN271@SystemDriv:
  0008e	c6 07 00	 mov	 BYTE PTR [edi], 0
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	c3		 ret	 0
??1SystemDriveConfiguration@GostCrypt@@QAE@XZ ENDP	; GostCrypt::SystemDriveConfiguration::~SystemDriveConfiguration
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Tidy@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Tidy, COMDAT
; _this$ = ecx

; 1884 : 		clear();

  00000	e9 00 00 00 00	 jmp	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
?_Tidy@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear, COMDAT
; _this$ = ecx

; 1500 : 		{	// erase all

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 1501 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1502 : 
; 1503 : 		this->_Orphan_ptr(nullptr);
; 1504 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1505 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

  00004	8b 03		 mov	 eax, DWORD PTR [ebx]
  00006	8b 30		 mov	 esi, DWORD PTR [eax]

; 1506 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

  00008	89 00		 mov	 DWORD PTR [eax], eax

; 1507 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

  0000a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1508 : 		this->_Mysize() = 0;

  0000f	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1509 : 
; 1510 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  00016	3b 33		 cmp	 esi, DWORD PTR [ebx]
  00018	74 20		 je	 SHORT $LN3@clear
  0001a	57		 push	 edi
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@clear:

; 1511 : 			{	// delete an element
; 1512 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1513 : 			this->_Freenode(_Pnode);

  00022	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00025	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00030	83 c4 04	 add	 esp, 4
  00033	8b f7		 mov	 esi, edi
  00035	3b 3b		 cmp	 edi, DWORD PTR [ebx]
  00037	75 e7		 jne	 SHORT $LL4@clear
  00039	5f		 pop	 edi
$LN3@clear:
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 1514 : 			}
; 1515 : 		}

  0003c	c3		 ret	 0
?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >, COMDAT
; _this$ = ecx

; 1097 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1098 : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear

; 1099 : 		}

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
  00012	5e		 pop	 esi
  00013	c3		 ret	 0
??1?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >, COMDAT
; _this$ = ecx
  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z PROC ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Freenode, COMDAT
; _this$ = ecx

; 848  : 		{	// give node back

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 853  : 		this->_Getal().destroy(

  00004	8b 75 08	 mov	 esi, DWORD PTR __Pnode$[ebp]
  00007	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000a	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ

; 854  : 			_STD addressof(this->_Myval(_Pnode)));
; 855  : 		this->_Getal().deallocate(_Pnode, 1);

  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
  00018	5e		 pop	 esi

; 856  : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?_Freenode@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z ENDP ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Myval, COMDAT

; 545  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 547  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Prevnode, COMDAT

; 540  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 541  : 		return ((_Nodepref)_Pnode->_Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 542  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Nextnode, COMDAT

; 535  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 537  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Mysize, COMDAT
; _this$ = ecx

; 792  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 793  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Myhead, COMDAT
; _this$ = ecx

; 782  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 783  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Get_data, COMDAT
; _this$ = ecx

; 772  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 773  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Getal, COMDAT
; _this$ = ecx

; 762  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 763  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 719  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Getal().destroy(
; 721  : 			_STD addressof(_Nextnode(_Pnode)));
; 722  : 		_Getal().destroy(
; 723  : 			_STD addressof(_Prevnode(_Pnode)));
; 724  : 		_Getal().deallocate(_Pnode, 1);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 725  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::~_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >, COMDAT
; _this$ = ecx

; 617  : 		_Freeheadnode(_Myhead());

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx

; 618  : 		}

  00008	c3		 ret	 0
??1?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::~_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Myval, COMDAT

; 595  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 596  : 		return (_List_val<_Val_types>::_Myval(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 597  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Prevnode, COMDAT

; 590  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 591  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 592  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Nextnode, COMDAT

; 585  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 587  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 988  : 		}

  00003	5d		 pop	 ebp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	81 fa 22 22 22
	02		 cmp	 edx, 35791394		; 02222222H
  0000f	77 38		 ja	 SHORT $LN13@deallocate
  00011	8b c2		 mov	 eax, edx
  00013	c1 e0 04	 shl	 eax, 4
  00016	2b c2		 sub	 eax, edx
  00018	c1 e0 03	 shl	 eax, 3
  0001b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00020	72 1a		 jb	 SHORT $LN5@deallocate
  00022	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00025	75 27		 jne	 SHORT $LN15@deallocate
  00027	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0002a	3b c1		 cmp	 eax, ecx
  0002c	73 25		 jae	 SHORT $LN16@deallocate
  0002e	2b c8		 sub	 ecx, eax
  00030	83 f9 04	 cmp	 ecx, 4
  00033	72 23		 jb	 SHORT $LN17@deallocate
  00035	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00038	77 23		 ja	 SHORT $LN18@deallocate
  0003a	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00042	83 c4 04	 add	 esp, 4

; 721  : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  0005d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00062	cc		 int	 3
?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GPartition@GostCrypt@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GPartition@GostCrypt@@QAEPAXI@Z PROC			; GostCrypt::Partition::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 70		 push	 112			; 00000070H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GPartition@GostCrypt@@QAEPAXI@Z ENDP			; GostCrypt::Partition::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1Partition@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1Partition@GostCrypt@@QAE@XZ PROC			; GostCrypt::Partition::~Partition, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00006	57		 push	 edi
  00007	8d 7e 58	 lea	 edi, DWORD PTR [esi+88]
  0000a	83 f8 08	 cmp	 eax, 8
  0000d	72 0b		 jb	 SHORT $LN9@Partition
  0000f	40		 inc	 eax
  00010	8b cf		 mov	 ecx, edi
  00012	50		 push	 eax
  00013	ff 37		 push	 DWORD PTR [edi]
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN9@Partition:
  0001a	c7 47 14 07 00
	00 00		 mov	 DWORD PTR [edi+20], 7
  00021	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8
  00025	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0002c	72 02		 jb	 SHORT $LN99@Partition
  0002e	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN99@Partition:
  00030	33 c0		 xor	 eax, eax
  00032	66 89 07	 mov	 WORD PTR [edi], ax
  00035	8d 7e 38	 lea	 edi, DWORD PTR [esi+56]
  00038	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0003b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0003e	72 0b		 jb	 SHORT $LN112@Partition
  00040	40		 inc	 eax
  00041	8b cf		 mov	 ecx, edi
  00043	50		 push	 eax
  00044	ff 37		 push	 DWORD PTR [edi]
  00046	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN112@Partition:
  0004b	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00052	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00056	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0005d	72 02		 jb	 SHORT $LN200@Partition
  0005f	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN200@Partition:
  00061	c6 07 00	 mov	 BYTE PTR [edi], 0
  00064	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00067	83 f8 10	 cmp	 eax, 16			; 00000010H
  0006a	72 0b		 jb	 SHORT $LN213@Partition
  0006c	40		 inc	 eax
  0006d	8b ce		 mov	 ecx, esi
  0006f	50		 push	 eax
  00070	ff 36		 push	 DWORD PTR [esi]
  00072	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN213@Partition:
  00077	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0007e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00082	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00089	72 08		 jb	 SHORT $LN301@Partition
  0008b	8b 06		 mov	 eax, DWORD PTR [esi]
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00092	c3		 ret	 0
$LN301@Partition:
  00093	5f		 pop	 edi
  00094	c6 06 00	 mov	 BYTE PTR [esi], 0
  00097	5e		 pop	 esi
  00098	c3		 ret	 0
??1Partition@GostCrypt@@QAE@XZ ENDP			; GostCrypt::Partition::~Partition
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GHostDevice@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GHostDevice@@QAEPAXI@Z PROC				; HostDevice::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1HostDevice@@QAE@XZ	; HostDevice::~HostDevice
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 70		 push	 112			; 00000070H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GHostDevice@@QAEPAXI@Z ENDP				; HostDevice::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0HostDevice@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0HostDevice@@QAE@ABU0@@Z PROC				; HostDevice::HostDevice, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0HostDevice@@QAE@ABU0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  0002e	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00031	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00034	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  00037	88 06		 mov	 BYTE PTR [esi], al
  00039	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0003d	88 46 01	 mov	 BYTE PTR [esi+1], al
  00040	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  00044	88 46 02	 mov	 BYTE PTR [esi+2], al
  00047	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0004b	88 46 03	 mov	 BYTE PTR [esi+3], al
  0004e	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00052	88 46 04	 mov	 BYTE PTR [esi+4], al
  00055	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00059	88 46 05	 mov	 BYTE PTR [esi+5], al
  0005c	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  00060	88 46 06	 mov	 BYTE PTR [esi+6], al
  00063	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0006a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00071	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00075	72 04		 jb	 SHORT $LN125@HostDevice
  00077	8b 01		 mov	 eax, DWORD PTR [ecx]
  00079	eb 02		 jmp	 SHORT $LN126@HostDevice
$LN125@HostDevice:
  0007b	8b c1		 mov	 eax, ecx
$LN126@HostDevice:
  0007d	6a ff		 push	 -1
  0007f	6a 00		 push	 0
  00081	52		 push	 edx
  00082	c6 00 00	 mov	 BYTE PTR [eax], 0
  00085	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0008a	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  0008d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00094	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  0009b	8d 57 20	 lea	 edx, DWORD PTR [edi+32]
  0009e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  000a5	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  000a9	72 04		 jb	 SHORT $LN252@HostDevice
  000ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ad	eb 02		 jmp	 SHORT $LN253@HostDevice
$LN252@HostDevice:
  000af	8b c1		 mov	 eax, ecx
$LN253@HostDevice:
  000b1	6a ff		 push	 -1
  000b3	33 db		 xor	 ebx, ebx
  000b5	53		 push	 ebx
  000b6	52		 push	 edx
  000b7	66 89 18	 mov	 WORD PTR [eax], bx
  000ba	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  000bf	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  000c2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000c6	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  000cd	8d 57 38	 lea	 edx, DWORD PTR [edi+56]
  000d0	89 59 10	 mov	 DWORD PTR [ecx+16], ebx
  000d3	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000d7	72 04		 jb	 SHORT $LN377@HostDevice
  000d9	8b 01		 mov	 eax, DWORD PTR [ecx]
  000db	eb 02		 jmp	 SHORT $LN378@HostDevice
$LN377@HostDevice:
  000dd	8b c1		 mov	 eax, ecx
$LN378@HostDevice:
  000df	6a ff		 push	 -1
  000e1	6a 00		 push	 0
  000e3	52		 push	 edx
  000e4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000ec	8a 47 50	 mov	 al, BYTE PTR [edi+80]
  000ef	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  000f2	88 46 50	 mov	 BYTE PTR [esi+80], al
  000f5	8b 47 58	 mov	 eax, DWORD PTR [edi+88]
  000f8	89 46 58	 mov	 DWORD PTR [esi+88], eax
  000fb	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  000fe	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00101	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00104	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00107	8d 47 64	 lea	 eax, DWORD PTR [edi+100]
  0010a	50		 push	 eax
  0010b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0010f	e8 00 00 00 00	 call	 ??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::vector<HostDevice,std::allocator<HostDevice> >
  00114	8b c6		 mov	 eax, esi
  00116	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00119	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00120	59		 pop	 ecx
  00121	5f		 pop	 edi
  00122	5e		 pop	 esi
  00123	5b		 pop	 ebx
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HostDevice@@QAE@ABU0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 08	 add	 ecx, 8
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0HostDevice@@QAE@ABU0@@Z$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 20	 add	 ecx, 32			; 00000020H
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$??0HostDevice@@QAE@ABU0@@Z$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 38	 add	 ecx, 56			; 00000038H
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0HostDevice@@QAE@ABU0@@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0HostDevice@@QAE@ABU0@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0HostDevice@@QAE@ABU0@@Z ENDP				; HostDevice::HostDevice
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBEXPAUHostDevice@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBEXPAUHostDevice@@0@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBEXPAUHostDevice@@0@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBEXXZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Xlen, COMDAT
; _this$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBEXXZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 1637 : 		if (this->_Myfirst() != pointer())

  00004	8b 33		 mov	 esi, DWORD PTR [ebx]
  00006	85 f6		 test	 esi, esi
  00008	74 4e		 je	 SHORT $LN2@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  0000a	57		 push	 edi
  0000b	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 0e		 je	 SHORT $LN43@Tidy
$LL44@Tidy:
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ??1HostDevice@@QAE@XZ	; HostDevice::~HostDevice
  00019	83 c6 70	 add	 esi, 112		; 00000070H
  0001c	3b f7		 cmp	 esi, edi
  0001e	75 f2		 jne	 SHORT $LL44@Tidy
$LN43@Tidy:

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

  00020	8b 33		 mov	 esi, DWORD PTR [ebx]
  00022	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00027	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0002a	2b ce		 sub	 ecx, esi
  0002c	f7 e9		 imul	 ecx
  0002e	03 d1		 add	 edx, ecx
  00030	8b cb		 mov	 ecx, ebx
  00032	c1 fa 06	 sar	 edx, 6
  00035	8b c2		 mov	 eax, edx
  00037	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003a	03 c2		 add	 eax, edx
  0003c	50		 push	 eax
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@I@Z ; std::_Wrap_alloc<std::allocator<HostDevice> >::deallocate

; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();

  00043	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 1644 : 			this->_Mylast() = pointer();

  00049	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1645 : 			this->_Myend() = pointer();

  00050	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00057	5f		 pop	 edi
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	c3		 ret	 0
?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv275 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

  00006	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00010	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00013	2b f7		 sub	 esi, edi
  00015	f7 ee		 imul	 esi
  00017	03 d6		 add	 edx, esi
  00019	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  0001c	c1 fa 06	 sar	 edx, 6
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00024	03 c2		 add	 eax, edx
  00026	3b c6		 cmp	 eax, esi
  00028	73 62		 jae	 SHORT $LN2@Reserve

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

  0002a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002c	2b f8		 sub	 edi, eax
  0002e	89 45 08	 mov	 DWORD PTR tv275[ebp], eax
  00031	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00036	f7 ef		 imul	 edi
  00038	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H
  0003d	03 d7		 add	 edx, edi
  0003f	c1 fa 06	 sar	 edx, 6
  00042	8b ca		 mov	 ecx, edx
  00044	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00047	03 ca		 add	 ecx, edx
  00049	2b c1		 sub	 eax, ecx
  0004b	3b c6		 cmp	 eax, esi
  0004d	72 44		 jb	 SHORT $LN134@Reserve

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

  0004f	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  00052	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00057	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0005a	2b 4d 08	 sub	 ecx, DWORD PTR tv275[ebp]
  0005d	f7 e9		 imul	 ecx
  0005f	03 d1		 add	 edx, ecx
  00061	33 c9		 xor	 ecx, ecx
  00063	c1 fa 06	 sar	 edx, 6
  00066	8b f2		 mov	 esi, edx
  00068	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0006b	03 f2		 add	 esi, edx
  0006d	ba 92 24 49 02	 mov	 edx, 38347922		; 02492492H
  00072	8b c6		 mov	 eax, esi
  00074	d1 e8		 shr	 eax, 1
  00076	2b d0		 sub	 edx, eax
  00078	03 c6		 add	 eax, esi
  0007a	3b d6		 cmp	 edx, esi
  0007c	0f 43 c8	 cmovae	 ecx, eax
  0007f	3b cf		 cmp	 ecx, edi
  00081	0f 43 f9	 cmovae	 edi, ecx
  00084	8b cb		 mov	 ecx, ebx
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::_Reallocate
$LN2@Reserve:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx

; 1632 : 			}
; 1633 : 		}

  0008f	5d		 pop	 ebp
  00090	c2 04 00	 ret	 4
$LN134@Reserve:

; 1630 : 				_Xlen();

  00093	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00098	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  0009d	cc		 int	 3
?_Reserve@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Size$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
__Last$1$ = -20						; size = 4
$T2 = -20						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d e4	 mov	 DWORD PTR _this$[ebp], edi

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UHostDevice@@@std@@QAEPAUHostDevice@@I@Z ; std::allocator<HostDevice>::allocate

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  00038	51		 push	 ecx
  00039	c6 45 ec 00	 mov	 BYTE PTR $T2[ebp], 0
  0003d	8b d8		 mov	 ebx, eax
  0003f	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00042	89 5d e8	 mov	 DWORD PTR __Ptr$[ebp], ebx
  00045	57		 push	 edi
  00046	53		 push	 ebx
  00047	ff 77 04	 push	 DWORD PTR [edi+4]
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00051	ff 37		 push	 DWORD PTR [edi]
  00053	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<HostDevice *,HostDevice *,std::allocator<HostDevice> >

; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();

  00058	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0005b	83 c4 18	 add	 esp, 24			; 00000018H
  0005e	8b 37		 mov	 esi, DWORD PTR [edi]
  00060	8b c8		 mov	 ecx, eax
  00062	89 45 ec	 mov	 DWORD PTR __Last$1$[ebp], eax
  00065	2b ce		 sub	 ecx, esi
  00067	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0006c	f7 e9		 imul	 ecx
  0006e	03 d1		 add	 edx, ecx
  00070	c1 fa 06	 sar	 edx, 6
  00073	8b c2		 mov	 eax, edx
  00075	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00078	03 c2		 add	 eax, edx
  0007a	89 45 e8	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1612 : 		if (this->_Myfirst() != pointer())

  0007d	85 f6		 test	 esi, esi
  0007f	74 37		 je	 SHORT $LN3@Reallocate

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  00081	3b 75 ec	 cmp	 esi, DWORD PTR __Last$1$[ebp]
  00084	74 0f		 je	 SHORT $LN126@Reallocate
$LL127@Reallocate:
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ??1HostDevice@@QAE@XZ	; HostDevice::~HostDevice
  0008d	83 c6 70	 add	 esi, 112		; 00000070H
  00090	3b 75 ec	 cmp	 esi, DWORD PTR __Last$1$[ebp]
  00093	75 f1		 jne	 SHORT $LL127@Reallocate
$LN126@Reallocate:

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

  00095	8b 37		 mov	 esi, DWORD PTR [edi]
  00097	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0009c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0009f	2b ce		 sub	 ecx, esi
  000a1	f7 e9		 imul	 ecx
  000a3	03 d1		 add	 edx, ecx
  000a5	8b cf		 mov	 ecx, edi
  000a7	c1 fa 06	 sar	 edx, 6
  000aa	8b c2		 mov	 eax, edx
  000ac	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000af	03 c2		 add	 eax, edx
  000b1	50		 push	 eax
  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@I@Z ; std::_Wrap_alloc<std::allocator<HostDevice> >::deallocate
$LN3@Reallocate:

; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();
; 1620 : 		this->_Myend() = _Ptr + _Count;

  000b8	6b 45 08 70	 imul	 eax, DWORD PTR __Count$[ebp], 112
  000bc	03 c3		 add	 eax, ebx
  000be	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

  000c1	6b 45 e8 70	 imul	 eax, DWORD PTR __Size$1$[ebp], 112
  000c5	03 c3		 add	 eax, ebx
  000c7	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

  000ca	89 1f		 mov	 DWORD PTR [edi], ebx

; 1623 : 		}

  000cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d6	59		 pop	 ecx
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z$0:

; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);

  000e0	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000e3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	ff 75 e8	 push	 DWORD PTR __Ptr$[ebp]
  000e9	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@I@Z ; std::_Wrap_alloc<std::allocator<HostDevice> >::deallocate

; 1608 : 		_RERAISE;

  000ee	6a 00		 push	 0
  000f0	6a 00		 push	 0
  000f2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN207@Reallocate:
$LN206@Reallocate:
  000f7	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBE_NPBUHostDevice@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBE_NPBUHostDevice@@@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1598 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1598 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBE_NPBUHostDevice@@@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBEII@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1586 : 		size_type _Capacity = capacity();

  00004	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00007	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000c	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000e	f7 ee		 imul	 esi
  00010	03 d6		 add	 edx, esi
  00012	c1 fa 06	 sar	 edx, 6
  00015	8b f2		 mov	 esi, edx
  00017	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001a	03 f2		 add	 esi, edx

; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0001c	ba 92 24 49 02	 mov	 edx, 38347922		; 02492492H
  00021	8b c6		 mov	 eax, esi
  00023	d1 e8		 shr	 eax, 1
  00025	2b d0		 sub	 edx, eax
  00027	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0002a	33 c0		 xor	 eax, eax
  0002c	3b d6		 cmp	 edx, esi
  0002e	5e		 pop	 esi
  0002f	0f 43 c1	 cmovae	 eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

  00032	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00035	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Grow_to@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IBEII@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXPAUHostDevice@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXPAUHostDevice@@0@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Destroy, COMDAT
; _this$ = ecx

; 1580 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN13@Destroy
  0000f	90		 npad	 1
$LL14@Destroy:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1HostDevice@@QAE@XZ	; HostDevice::~HostDevice
  00017	83 c6 70	 add	 esi, 112		; 00000070H
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL14@Destroy
$LN13@Destroy:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1582 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?_Destroy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXPAUHostDevice@@0@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAE_NI@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1562 : 		this->_Myfirst() = pointer();
; 1563 : 		this->_Mylast() = pointer();
; 1564 : 		this->_Myend() = pointer();
; 1565 : 
; 1566 : 		if (_Capacity == 0)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001e	85 ff		 test	 edi, edi
  00020	75 08		 jne	 SHORT $LN2@Buy

; 1567 : 			return (false);

  00022	5f		 pop	 edi
  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 1577 : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN2@Buy:

; 1568 : 		else if (max_size() < _Capacity)

  0002a	81 ff 92 24 49
	02		 cmp	 edi, 38347922		; 02492492H
  00030	77 1b		 ja	 SHORT $LN109@Buy

; 1570 : 		else
; 1571 : 			{	// nonempty array, allocate storage
; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UHostDevice@@@std@@QAEPAUHostDevice@@I@Z ; std::allocator<HostDevice>::allocate
  00038	89 06		 mov	 DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();

  0003a	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  0003d	6b c7 70	 imul	 eax, edi, 112
  00040	5f		 pop	 edi
  00041	03 06		 add	 eax, DWORD PTR [esi]
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

  00046	b0 01		 mov	 al, 1
  00048	5e		 pop	 esi

; 1577 : 		}

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN109@Buy:

; 1569 : 			_Xlen();	// result too long

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00052	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN111@Buy:
$LN108@Buy:
  00057	cc		 int	 3
?_Buy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXXZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::clear, COMDAT
; _this$ = ecx

; 1539 : 		{	// erase all

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());

  00005	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00008	8b 37		 mov	 esi, DWORD PTR [edi]
  0000a	3b f3		 cmp	 esi, ebx
  0000c	74 19		 je	 SHORT $LN70@clear
  0000e	66 90		 npad	 2
$LL34@clear:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1HostDevice@@QAE@XZ	; HostDevice::~HostDevice
  00017	83 c6 70	 add	 esi, 112		; 00000070H
  0001a	3b f3		 cmp	 esi, ebx
  0001c	75 f2		 jne	 SHORT $LL34@clear

; 1542 : 		this->_Mylast() = this->_Myfirst();

  0001e	8b 07		 mov	 eax, DWORD PTR [edi]
  00020	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx

; 1543 : 		}

  00026	c3		 ret	 0
$LN70@clear:

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00027	8b c6		 mov	 eax, esi
  00029	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 1543 : 		}

  0002f	c3		 ret	 0
?clear@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXXZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
$T5 = 8							; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx

; 1277 : 		if (_Inside(_STD addressof(_Val)))

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0002d	3b f9		 cmp	 edi, ecx
  0002f	73 45		 jae	 SHORT $LN2@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	3b c7		 cmp	 eax, edi
  00035	77 3f		 ja	 SHORT $LN2@push_back

; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

  00037	2b f8		 sub	 edi, eax
  00039	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0003e	f7 ef		 imul	 edi
  00040	03 d7		 add	 edx, edi
  00042	c1 fa 06	 sar	 edx, 6
  00045	8b fa		 mov	 edi, edx
  00047	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0004a	03 fa		 add	 edi, edx

; 1280 : 			if (this->_Mylast() == this->_Myend())

  0004c	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0004f	75 09		 jne	 SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::_Reserve
$LN4@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  0005a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005d	6b c7 70	 imul	 eax, edi, 112
  00060	89 4d 08	 mov	 DWORD PTR $T5[ebp], ecx
  00063	89 4d f0	 mov	 DWORD PTR $T3[ebp], ecx
  00066	03 06		 add	 eax, DWORD PTR [esi]
  00068	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006f	85 c9		 test	 ecx, ecx
  00071	74 2b		 je	 SHORT $LN210@push_back
  00073	50		 push	 eax

; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();
; 1286 : 			}
; 1287 : 		else

  00074	eb 23		 jmp	 SHORT $LN229@push_back
$LN2@push_back:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

  00076	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00079	75 09		 jne	 SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

  0007b	6a 01		 push	 1
  0007d	8b ce		 mov	 ecx, esi
  0007f	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXI@Z ; std::vector<HostDevice,std::allocator<HostDevice> >::_Reserve
$LN5@push_back:

; 1291 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1292 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00084	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00087	89 4d 08	 mov	 DWORD PTR $T4[ebp], ecx
  0008a	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  0008d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00094	85 c9		 test	 ecx, ecx
  00096	74 06		 je	 SHORT $LN210@push_back
  00098	57		 push	 edi
$LN229@push_back:
  00099	e8 00 00 00 00	 call	 ??0HostDevice@@QAE@ABU0@@Z
$LN210@push_back:

; 1293 : 				_Val);
; 1294 : 			++this->_Mylast();

  0009e	83 46 04 70	 add	 DWORD PTR [esi+4], 112	; 00000070H

; 1295 : 			}
; 1296 : 		}

  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z$33:
  00000	8b 45 08	 mov	 eax, DWORD PTR $T5[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__unwindfunclet$?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z$57:
  00011	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00014	50		 push	 eax
  00015	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0001e	83 c4 08	 add	 esp, 8
  00021	c3		 ret	 0
__ehhandler$?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?push_back@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEXABUHostDevice@@@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?front@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEAAUHostDevice@@XZ
_TEXT	SEGMENT
?front@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEAAUHostDevice@@XZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::front, COMDAT
; _this$ = ecx

; 1257 : 		return (*begin());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1258 : 		}

  00002	c3		 ret	 0
?front@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEAAUHostDevice@@XZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEAAUHostDevice@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEAAUHostDevice@@I@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::operator[], COMDAT
; _this$ = ecx

; 1230 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

  00003	6b 45 08 70	 imul	 eax, DWORD PTR __Pos$[ebp], 112
  00007	03 01		 add	 eax, DWORD PTR [ecx]

; 1243 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
??A?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAEAAUHostDevice@@I@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?empty@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBE_NXZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::empty, COMDAT
; _this$ = ecx

; 1189 : 		{	// test if sequence is empty

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00005	0f 94 c0	 sete	 al

; 1190 : 		return (this->_Myfirst() == this->_Mylast());
; 1191 : 		}

  00008	c3		 ret	 0
?empty@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBE_NXZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::max_size, COMDAT
; _this$ = ecx

; 1185 : 		return (this->_Getal().max_size());

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 1186 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::size, COMDAT
; _this$ = ecx

; 1179 : 		{	// return length of sequence

  00000	56		 push	 esi

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 06	 sar	 edx, 6
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 1181 : 		}

  0001a	c3		 ret	 0
?size@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@2@XZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::end, COMDAT
; _this$ = ecx

; 1072 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1073 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1074 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@2@XZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@2@XZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::begin, COMDAT
; _this$ = ecx

; 1062 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1063 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1064 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@2@XZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@2@XZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1059 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@@2@XZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		{	// micro-optimization for capacity() - size()

  00000	56		 push	 esi

; 1048 : 		return (this->_Myend() - this->_Mylast());

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 71 04	 sub	 esi, DWORD PTR [ecx+4]
  0000c	f7 ee		 imul	 esi
  0000e	03 d6		 add	 edx, esi
  00010	c1 fa 06	 sar	 edx, 6
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx
  0001a	5e		 pop	 esi

; 1049 : 		}

  0001b	c3		 ret	 0
?_Unused_capacity@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		{	// return current length of allocated storage

  00000	56		 push	 esi

; 1043 : 		return (this->_Myend() - this->_Myfirst());

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 06	 sar	 edx, 6
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 1044 : 		}

  0001a	c3		 ret	 0
?capacity@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QBEIXZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::~vector<HostDevice,std::allocator<HostDevice> >, COMDAT
; _this$ = ecx

; 976  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy
??1?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::~vector<HostDevice,std::allocator<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Right$ = 8						; size = 4
??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::vector<HostDevice,std::allocator<HostDevice> >, COMDAT
; _this$ = ecx

; 748  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 749  : 		if (_Buy(_Right.size()))

  00030	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00033	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0004f	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00051	f7 e9		 imul	 ecx
  00053	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00059	03 d1		 add	 edx, ecx
  0005b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00062	c1 fa 06	 sar	 edx, 6
  00065	8b fa		 mov	 edi, edx
  00067	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0006e	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00071	03 fa		 add	 edi, edx
  00073	74 49		 je	 SHORT $LN7@vector
  00075	81 ff 92 24 49
	02		 cmp	 edi, 38347922		; 02492492H
  0007b	76 0a		 jbe	 SHORT $LN58@vector
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00082	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN257@vector:
$LN58@vector:
  00087	57		 push	 edi
  00088	8b ce		 mov	 ecx, esi
  0008a	e8 00 00 00 00	 call	 ?allocate@?$allocator@UHostDevice@@@std@@QAEPAUHostDevice@@I@Z ; std::allocator<HostDevice>::allocate
  0008f	89 06		 mov	 DWORD PTR [esi], eax
  00091	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 750  : 			_TRY_BEGIN
; 751  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),

  00094	51		 push	 ecx
  00095	6b c7 70	 imul	 eax, edi, 112
  00098	c6 45 08 00	 mov	 BYTE PTR $T2[ebp], 0
  0009c	ff 75 08	 push	 DWORD PTR $T2[ebp]
  0009f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000a6	56		 push	 esi
  000a7	03 06		 add	 eax, DWORD PTR [esi]
  000a9	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000ac	ff 36		 push	 DWORD PTR [esi]
  000ae	ff 73 04	 push	 DWORD PTR [ebx+4]
  000b1	ff 33		 push	 DWORD PTR [ebx]
  000b3	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUHostDevice@@PAU1@V?$allocator@UHostDevice@@@std@@@std@@YAPAUHostDevice@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<HostDevice const *,HostDevice *,std::allocator<HostDevice> >
  000b8	83 c4 18	 add	 esp, 24			; 00000018H
  000bb	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@vector:

; 756  : 			_CATCH_END
; 757  : 		}

  000be	8b c6		 mov	 eax, esi
  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 04 00	 ret	 4
__catch$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z$0:

; 752  : 				this->_Myfirst());
; 753  : 			_CATCH_ALL
; 754  : 			_Tidy();

  000d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy

; 755  : 			_RERAISE;

  000dc	6a 00		 push	 0
  000de	6a 00		 push	 0
  000e0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN258@vector:
$LN256@vector:
  000e5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::vector<HostDevice,std::allocator<HostDevice> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ PROC ; std::vector<HostDevice,std::allocator<HostDevice> >::vector<HostDevice,std::allocator<HostDevice> >, COMDAT
; _this$ = ecx

; 706  : 		: _Mybase()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 708  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ ENDP ; std::vector<HostDevice,std::allocator<HostDevice> >::vector<HostDevice,std::allocator<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<HostDevice> >,std::_Vector_val<std::_Simple_types<HostDevice> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<HostDevice> >::_Vector_val<std::_Simple_types<HostDevice> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 489  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<HostDevice> >::_Vector_val<std::_Simple_types<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABQAUHostDevice@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABQAUHostDevice@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 669  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABQAUHostDevice@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAPAUHostDevice@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAPAUHostDevice@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 664  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAPAUHostDevice@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABQAUHostDevice@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABQAUHostDevice@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 659  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABQAUHostDevice@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAPAUHostDevice@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAPAUHostDevice@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 654  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAPAUHostDevice@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABQAUHostDevice@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABQAUHostDevice@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 649  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABQAUHostDevice@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAPAUHostDevice@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAPAUHostDevice@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 644  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAPAUHostDevice@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 639  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 634  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UHostDevice@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 629  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 624  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >, COMDAT
; _this$ = ecx

; 519  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 521  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >::_Vector_alloc<std::_Vec_base_types<HostDevice,std::allocator<HostDevice> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@I@Z PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d 92 24 49 02	 cmp	 eax, 38347922		; 02492492H
  0000e	77 31		 ja	 SHORT $LN16@deallocate
  00010	6b c0 70	 imul	 eax, eax, 112
  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate
  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate
  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate
  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate
  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate
  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEXPAUHostDevice@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEPAUHostDevice@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEPAUHostDevice@@I@Z PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@UHostDevice@@@std@@QAEPAUHostDevice@@I@Z ; std::allocator<HostDevice>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAEPAUHostDevice@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::_Wrap_alloc<std::allocator<HostDevice> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::_Wrap_alloc<std::allocator<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::_Wrap_alloc<std::allocator<HostDevice> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::_Wrap_alloc<std::allocator<HostDevice> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<HostDevice> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UHostDevice@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<HostDevice> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SA?AV?$allocator@UHostDevice@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SA?AV?$allocator@UHostDevice@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<HostDevice> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SA?AV?$allocator@UHostDevice@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<HostDevice> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAIABV?$allocator@UHostDevice@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAIABV?$allocator@UHostDevice@@@2@@Z PROC ; std::allocator_traits<std::allocator<HostDevice> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UHostDevice@@@std@@@std@@SAIABV?$allocator@UHostDevice@@@2@@Z ENDP ; std::allocator_traits<std::allocator<HostDevice> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UHostDevice@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UHostDevice@@@std@@QBEIXZ PROC	; std::allocator<HostDevice>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UHostDevice@@@std@@QBEIXZ ENDP	; std::allocator<HostDevice>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UHostDevice@@@std@@QAEPAUHostDevice@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UHostDevice@@@std@@QAEPAUHostDevice@@I@Z PROC ; std::allocator<HostDevice>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 92 24 49 02	 cmp	 eax, 38347922		; 02492492H
  00013	77 3c		 ja	 SHORT $LN14@allocate
  00015	6b c0 70	 imul	 eax, eax, 112
  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate
  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate
  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4
  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@UHostDevice@@@std@@QAEPAUHostDevice@@I@Z ENDP ; std::allocator<HostDevice>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@I@Z PROC ; std::allocator<HostDevice>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d 92 24 49 02	 cmp	 eax, 38347922		; 02492492H
  0000e	77 31		 ja	 SHORT $LN13@deallocate
  00010	6b c0 70	 imul	 eax, eax, 112
  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate
  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate
  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate
  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate
  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate
  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@UHostDevice@@@std@@QAEXPAUHostDevice@@I@Z ENDP ; std::allocator<HostDevice>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UHostDevice@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UHostDevice@@@std@@QAE@ABV01@@Z PROC	; std::allocator<HostDevice>::allocator<HostDevice>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@UHostDevice@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<HostDevice>::allocator<HostDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UHostDevice@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UHostDevice@@@std@@QAE@XZ PROC		; std::allocator<HostDevice>::allocator<HostDevice>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UHostDevice@@@std@@QAE@XZ ENDP		; std::allocator<HostDevice>::allocator<HostDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\dlgcode.h
;	COMDAT ??1HostDevice@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1HostDevice@@QAE@XZ PROC				; HostDevice::~HostDevice, COMDAT
; _this$ = ecx

; 495  : 	~HostDevice () { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1HostDevice@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	8d 4f 64	 lea	 ecx, DWORD PTR [edi+100]
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UHostDevice@@V?$allocator@UHostDevice@@@std@@@std@@IAEXXZ ; std::vector<HostDevice,std::allocator<HostDevice> >::_Tidy
  00035	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00038	8d 77 38	 lea	 esi, DWORD PTR [edi+56]
  0003b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0003e	72 0b		 jb	 SHORT $LN143@HostDevice
  00040	40		 inc	 eax
  00041	8b ce		 mov	 ecx, esi
  00043	50		 push	 eax
  00044	ff 36		 push	 DWORD PTR [esi]
  00046	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN143@HostDevice:
  0004b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00052	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00056	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0005d	72 02		 jb	 SHORT $LN232@HostDevice
  0005f	8b 36		 mov	 esi, DWORD PTR [esi]
$LN232@HostDevice:
  00061	c6 06 00	 mov	 BYTE PTR [esi], 0
  00064	8d 77 20	 lea	 esi, DWORD PTR [edi+32]
  00067	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0006a	83 f8 08	 cmp	 eax, 8
  0006d	72 0b		 jb	 SHORT $LN244@HostDevice
  0006f	40		 inc	 eax
  00070	8b ce		 mov	 ecx, esi
  00072	50		 push	 eax
  00073	ff 36		 push	 DWORD PTR [esi]
  00075	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN244@HostDevice:
  0007a	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00081	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00085	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0008c	72 02		 jb	 SHORT $LN335@HostDevice
  0008e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN335@HostDevice:
  00090	33 c0		 xor	 eax, eax
  00092	66 89 06	 mov	 WORD PTR [esi], ax
  00095	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00098	83 f8 10	 cmp	 eax, 16			; 00000010H
  0009b	72 0d		 jb	 SHORT $LN347@HostDevice
  0009d	40		 inc	 eax
  0009e	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  000a1	50		 push	 eax
  000a2	ff 77 08	 push	 DWORD PTR [edi+8]
  000a5	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN347@HostDevice:
  000aa	c7 47 1c 0f 00
	00 00		 mov	 DWORD PTR [edi+28], 15	; 0000000fH
  000b1	83 7f 1c 10	 cmp	 DWORD PTR [edi+28], 16	; 00000010H
  000b5	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  000bc	72 17		 jb	 SHORT $LN435@HostDevice
  000be	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000c1	c6 00 00	 mov	 BYTE PTR [eax], 0
  000c4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ce	59		 pop	 ecx
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
$LN435@HostDevice:
  000d5	c6 47 08 00	 mov	 BYTE PTR [edi+8], 0
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1HostDevice@@QAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1HostDevice@@QAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1HostDevice@@QAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1HostDevice@@QAE@XZ ENDP				; HostDevice::~HostDevice
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 29		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00014	72 23		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0e		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00020	50		 push	 eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 _memcpy
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0002b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002e	8b ce		 mov	 ecx, esi
  00030	40		 inc	 eax
  00031	50		 push	 eax
  00032	53		 push	 ebx
  00033	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  00038	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00039	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7

; 2261 : 		_Eos(_Newsize);

  00040	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00044	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00047	72 0e		 jb	 SHORT $LN94@Tidy
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	33 c9		 xor	 ecx, ecx
  0004d	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 2262 : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN94@Tidy:
  00057	33 c0		 xor	 eax, eax
  00059	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 2262 : 		}

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2e		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 08	 cmp	 eax, 8
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1c		 jb	 SHORT $LN4@Inside
  0001d	83 f8 08	 cmp	 eax, 8
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  0002e	3b c2		 cmp	 eax, edx
  00030	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00032	b0 01		 mov	 al, 1
  00034	5e		 pop	 esi

; 2244 : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 2244 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0000d	77 5b		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000f	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  00012	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00014	ff 71 10	 push	 DWORD PTR [ecx+16]
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0001d	85 f6		 test	 esi, esi
  0001f	5e		 pop	 esi
  00020	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00027	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0002b	74 1f		 je	 SHORT $LN5@Grow
  0002d	83 fe 08	 cmp	 esi, 8
  00030	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  00032	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00035	3b f0		 cmp	 esi, eax
  00037	0f 42 c6	 cmovb	 eax, esi
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00042	85 f6		 test	 esi, esi
  00044	5e		 pop	 esi
  00045	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  0004c	85 f6		 test	 esi, esi
  0004e	75 12		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  00050	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00054	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00057	72 02		 jb	 SHORT $LN80@Grow
  00059	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 f6		 test	 esi, esi
  0005f	66 89 01	 mov	 WORD PTR [ecx], ax
$LN88@Grow:
  00062	0f 95 c0	 setne	 al
  00065	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  00074	cc		 int	 3
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0c		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	33 c9		 xor	 ecx, ecx
  00013	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 2220 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  0001b	33 c0		 xor	 eax, eax
  0001d	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 2220 : 		}

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 07	 or	 edi, 7

; 2184 : 		if (max_size() < _Newres)

  00038	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  0003e	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  00040	8b f8		 mov	 edi, eax
  00042	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00044	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00047	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0004c	f7 e7		 mul	 edi
  0004e	8b cb		 mov	 ecx, ebx
  00050	d1 e9		 shr	 ecx, 1
  00052	d1 ea		 shr	 edx, 1
  00054	3b ca		 cmp	 ecx, edx
  00056	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00058	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005d	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  00060	2b c1		 sub	 eax, ecx
  00062	3b d8		 cmp	 ebx, eax
  00064	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00066	bf fe ff ff 7f	 mov	 edi, 2147483646		; 7ffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  0006b	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00075	50		 push	 eax
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  0007d	8b d0		 mov	 edx, eax
  0007f	eb 29		 jmp	 SHORT $LN429@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00081	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  0008a	40		 inc	 eax
  0008b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0008e	50		 push	 eax
  0008f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00093	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  00098	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  0009b	b8 00 00 00 00	 mov	 eax, $LN426@Copy
  000a0	c3		 ret	 0
$LN426@Copy:
  000a1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000a4	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000a7	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN429@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000aa	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000ad	89 55 e8	 mov	 DWORD PTR __Ptr$1$[ebp], edx
  000b0	85 db		 test	 ebx, ebx
  000b2	74 1e		 je	 SHORT $LN260@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000b4	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b8	72 04		 jb	 SHORT $LN251@Copy
  000ba	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000bc	eb 02		 jmp	 SHORT $LN252@Copy
$LN251@Copy:
  000be	8b ce		 mov	 ecx, esi
$LN252@Copy:
  000c0	85 db		 test	 ebx, ebx
  000c2	74 0e		 je	 SHORT $LN260@Copy
  000c4	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  000c7	50		 push	 eax
  000c8	51		 push	 ecx
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _memcpy
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN260@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  000d2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000d5	83 f8 08	 cmp	 eax, 8
  000d8	72 0b		 jb	 SHORT $LN266@Copy
  000da	40		 inc	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	50		 push	 eax
  000de	ff 36		 push	 DWORD PTR [esi]
  000e0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN266@Copy:
  000e5	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  000ec	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000f0	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000f7	72 04		 jb	 SHORT $LN356@Copy
  000f9	8b 06		 mov	 eax, DWORD PTR [esi]
  000fb	eb 02		 jmp	 SHORT $LN357@Copy
$LN356@Copy:
  000fd	8b c6		 mov	 eax, esi
$LN357@Copy:
  000ff	33 c9		 xor	 ecx, ecx
  00101	66 89 08	 mov	 WORD PTR [eax], cx

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);

  00104	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00107	89 06		 mov	 DWORD PTR [esi], eax

; 2212 : 		this->_Myres() = _Newres;

  00109	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 2213 : 		_Eos(_Oldlen);

  0010c	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00110	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00113	72 02		 jb	 SHORT $LN420@Copy
  00115	8b f0		 mov	 esi, eax
$LN420@Copy:
  00117	33 c0		 xor	 eax, eax
  00119	66 89 04 5e	 mov	 WORD PTR [esi+ebx*2], ax

; 2214 : 		}

  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00120	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00127	59		 pop	 ecx
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00131	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00134	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00137	83 f8 08	 cmp	 eax, 8
  0013a	72 0b		 jb	 SHORT $LN144@Copy
  0013c	40		 inc	 eax
  0013d	8b ce		 mov	 ecx, esi
  0013f	50		 push	 eax
  00140	ff 36		 push	 DWORD PTR [esi]
  00142	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN144@Copy:
  00147	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0014e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00152	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00159	72 02		 jb	 SHORT $LN235@Copy
  0015b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN235@Copy:
  0015d	33 c0		 xor	 eax, eax

; 2203 : 			_RERAISE;

  0015f	50		 push	 eax
  00160	50		 push	 eax
  00161	66 89 06	 mov	 WORD PTR [esi], ax
  00164	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN430@Copy:
$LN428@Copy:
  00169	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 2
?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 2175 : 		if (_Count == 1)

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00008	83 f9 01	 cmp	 ecx, 1
  0000b	75 17		 jne	 SHORT $LN2@Chassign

; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);

  0000d	83 7a 14 08	 cmp	 DWORD PTR [edx+20], 8
  00011	72 02		 jb	 SHORT $LN15@Chassign
  00013	8b 12		 mov	 edx, DWORD PTR [edx]
$LN15@Chassign:
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00018	66 8b 45 10	 mov	 ax, WORD PTR __Ch$[ebp]
  0001c	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 2179 : 		}

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Chassign:

; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

  00024	83 7a 14 08	 cmp	 DWORD PTR [edx+20], 8
  00028	72 02		 jb	 SHORT $LN32@Chassign
  0002a	8b 12		 mov	 edx, DWORD PTR [edx]
$LN32@Chassign:
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0002f	57		 push	 edi
  00030	8d 3c 42	 lea	 edi, DWORD PTR [edx+eax*2]
  00033	85 c9		 test	 ecx, ecx
  00035	74 16		 je	 SHORT $LN47@Chassign
  00037	8b 45 10	 mov	 eax, DWORD PTR __Ch$[ebp]
  0003a	0f b7 d0	 movzx	 edx, ax
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e2 10	 shl	 edx, 16			; 00000010H
  00042	0b c2		 or	 eax, edx
  00044	d1 e9		 shr	 ecx, 1
  00046	f3 ab		 rep stosd
  00048	13 c9		 adc	 ecx, ecx
  0004a	66 f3 ab	 rep stosw
$LN47@Chassign:
  0004d	5f		 pop	 edi

; 2179 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 0c 00	 ret	 12			; 0000000cH
?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator, COMDAT
; _this$ = ecx

; 2168 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2171 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1766 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1680 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1681 : 		if (this->_Mysize() < _Off)	// sic
; 1682 : 			_DEBUG_ERROR("string subscript out of range");
; 1683 : 
; 1684 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1685 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1686 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1687 : 
; 1688 : 		return (this->_Myptr()[_Off]);

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	72 02		 jb	 SHORT $LN13@operator
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@operator:
  0000e	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 1689 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	0f 82 88 00 00
	00		 jb	 $LN95@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00018	8b c7		 mov	 eax, edi
  0001a	2b c1		 sub	 eax, ecx
  0001c	3b c2		 cmp	 eax, edx
  0001e	77 27		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00027	72 10		 jb	 SHORT $LN41@erase
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	33 d2		 xor	 edx, edx
  0002d	5f		 pop	 edi
  0002e	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1357 : 			}
; 1358 : 		return (*this);

  00032	8b c6		 mov	 eax, esi
  00034	5e		 pop	 esi

; 1359 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00039	8b c6		 mov	 eax, esi
  0003b	33 d2		 xor	 edx, edx
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1359 : 		}

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  00047	85 d2		 test	 edx, edx
  00049	74 4a		 je	 SHORT $LN92@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  0004b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004f	72 04		 jb	 SHORT $LN58@erase
  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  00055	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  00057	2b fa		 sub	 edi, edx
  00059	53		 push	 ebx
  0005a	8d 1c 48	 lea	 ebx, DWORD PTR [eax+ecx*2]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  0005d	8b c7		 mov	 eax, edi
  0005f	2b c1		 sub	 eax, ecx
  00061	74 10		 je	 SHORT $LN74@erase
  00063	03 c0		 add	 eax, eax
  00065	50		 push	 eax
  00066	8d 04 53	 lea	 eax, DWORD PTR [ebx+edx*2]
  00069	50		 push	 eax
  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _memmove
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00073	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	5b		 pop	 ebx
  0007b	72 10		 jb	 SHORT $LN87@erase
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	33 c9		 xor	 ecx, ecx
  00081	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1357 : 			}
; 1358 : 		return (*this);

  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 1359 : 		}

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN87@erase:
  0008d	8b c6		 mov	 eax, esi
  0008f	33 c9		 xor	 ecx, ecx
  00091	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN92@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00095	5f		 pop	 edi
  00096	8b c6		 mov	 eax, esi
  00098	5e		 pop	 esi

; 1359 : 		}

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
$LN95@erase:

; 1348 : 		_Check_offset(_Off);

  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000a2	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN97@erase:
$LN94@erase:
  000a7	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 29		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00012	72 10		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	56		 push	 esi
  00017	33 f6		 xor	 esi, esi
  00019	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0001d	8b c1		 mov	 eax, ecx
  0001f	5e		 pop	 esi

; 1344 : 		}

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00024	8b d1		 mov	 edx, ecx
  00026	56		 push	 esi
  00027	33 f6		 xor	 esi, esi
  00029	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0002d	8b c1		 mov	 eax, ecx
  0002f	5e		 pop	 esi

; 1344 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00039	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  0003e	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
tv569 = 12						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 2
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1278 : 		{	// insert _Count * _Ch at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1279 : 		_Check_offset(_Off);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000e	3b ca		 cmp	 ecx, edx
  00010	0f 82 e1 00 00
	00		 jb	 $LN190@insert

; 1280 : 		if (npos - this->_Mysize() <= _Count)

  00016	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00019	8b c1		 mov	 eax, ecx
  0001b	f7 d0		 not	 eax
  0001d	3b c3		 cmp	 eax, ebx
  0001f	0f 86 dc 00 00
	00		 jbe	 $LN192@insert

; 1282 : 		const size_type _Num = this->_Mysize() + _Count;

  00025	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]

; 1283 : 		if (0 < _Count && _Grow(_Num))

  00028	85 db		 test	 ebx, ebx
  0002a	0f 84 be 00 00
	00		 je	 $LN185@insert
  00030	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00036	0f 87 cf 00 00
	00		 ja	 $LN193@insert
  0003c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0003f	73 23		 jae	 SHORT $LN43@insert
  00041	51		 push	 ecx
  00042	57		 push	 edi
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0004a	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0004d	85 ff		 test	 edi, edi
  0004f	0f 84 99 00 00
	00		 je	 $LN185@insert
$LN189@insert:

; 1284 : 			{	// make room and insert new stuff
; 1285 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00055	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00058	83 f8 08	 cmp	 eax, 8
  0005b	72 32		 jb	 SHORT $LN146@insert
  0005d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005f	89 4d 0c	 mov	 DWORD PTR tv569[ebp], ecx
  00062	eb 2e		 jmp	 SHORT $LN147@insert

; 1283 : 		if (0 < _Count && _Grow(_Num))

$LN43@insert:
  00064	85 ff		 test	 edi, edi
  00066	75 ed		 jne	 SHORT $LN189@insert
  00068	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0006b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0006f	72 10		 jb	 SHORT $LN120@insert
  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	33 c9		 xor	 ecx, ecx
  00075	5f		 pop	 edi
  00076	66 89 08	 mov	 WORD PTR [eax], cx

; 1290 : 			}
; 1291 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx

; 1292 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH

; 1283 : 		if (0 < _Count && _Grow(_Num))

$LN120@insert:
  00081	8b c6		 mov	 eax, esi
  00083	33 c9		 xor	 ecx, ecx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	66 89 08	 mov	 WORD PTR [eax], cx

; 1292 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 0c 00	 ret	 12			; 0000000cH

; 1284 : 			{	// make room and insert new stuff
; 1285 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN146@insert:
  0008f	89 75 0c	 mov	 DWORD PTR tv569[ebp], esi
$LN147@insert:
  00092	83 f8 08	 cmp	 eax, 8
  00095	72 04		 jb	 SHORT $LN160@insert
  00097	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00099	eb 02		 jmp	 SHORT $LN161@insert
$LN160@insert:
  0009b	8b ce		 mov	 ecx, esi
$LN161@insert:
  0009d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000a0	2b c2		 sub	 eax, edx
  000a2	74 1c		 je	 SHORT $LN167@insert
  000a4	03 c0		 add	 eax, eax
  000a6	50		 push	 eax
  000a7	8b 45 0c	 mov	 eax, DWORD PTR tv569[ebp]
  000aa	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  000ad	50		 push	 eax
  000ae	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000b1	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _memmove
  000ba	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN167@insert:

; 1286 : 				this->_Myptr() + _Off,
; 1287 : 				this->_Mysize() - _Off);	// empty out hole
; 1288 : 			_Chassign(_Off, _Count, _Ch);	// fill hole

  000c0	ff 75 10	 push	 DWORD PTR __Ch$[ebp]
  000c3	8b ce		 mov	 ecx, esi
  000c5	53		 push	 ebx
  000c6	52		 push	 edx
  000c7	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign

; 1289 : 			_Eos(_Num);

  000cc	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d0	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d3	72 11		 jb	 SHORT $LN180@insert
  000d5	8b 06		 mov	 eax, DWORD PTR [esi]
  000d7	33 c9		 xor	 ecx, ecx
  000d9	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1290 : 			}
; 1291 : 		return (*this);

  000dd	8b c6		 mov	 eax, esi
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx

; 1292 : 		}

  000e2	5d		 pop	 ebp
  000e3	c2 0c 00	 ret	 12			; 0000000cH

; 1289 : 			_Eos(_Num);

$LN180@insert:
  000e6	8b c6		 mov	 eax, esi
  000e8	33 c9		 xor	 ecx, ecx
  000ea	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN185@insert:

; 1290 : 			}
; 1291 : 		return (*this);

  000ee	5f		 pop	 edi
  000ef	8b c6		 mov	 eax, esi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx

; 1292 : 		}

  000f3	5d		 pop	 ebp
  000f4	c2 0c 00	 ret	 12			; 0000000cH
$LN190@insert:

; 1279 : 		_Check_offset(_Off);

  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000fc	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN194@insert:
$LN192@insert:

; 1281 : 			_Xlen();	// result too long

  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00106	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN195@insert:
$LN193@insert:

; 1283 : 		if (0 < _Count && _Grow(_Num))

  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00110	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN196@insert:
$LN187@insert:
  00115	cc		 int	 3
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 2
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1186 : 		{	// assign _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1187 : 		if (_Count == npos)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	83 ff ff	 cmp	 edi, -1
  0000d	74 79		 je	 SHORT $LN114@assign

; 1189 : 
; 1190 : 		if (_Grow(_Count))

  0000f	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00015	77 7b		 ja	 SHORT $LN116@assign
  00017	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0001a	73 33		 jae	 SHORT $LN10@assign
  0001c	ff 76 10	 push	 DWORD PTR [esi+16]
  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00025	85 ff		 test	 edi, edi
  00027	74 57		 je	 SHORT $LN109@assign
$LN113@assign:

; 1191 : 			{	// make room and assign new stuff
; 1192 : 			_Chassign(0, _Count, _Ch);

  00029	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  0002c	8b ce		 mov	 ecx, esi
  0002e	57		 push	 edi
  0002f	6a 00		 push	 0
  00031	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign

; 1193 : 			_Eos(_Count);

  00036	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0003a	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0003d	72 39		 jb	 SHORT $LN104@assign
  0003f	8b 06		 mov	 eax, DWORD PTR [esi]
  00041	33 c9		 xor	 ecx, ecx
  00043	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1194 : 			}
; 1195 : 		return (*this);

  00047	8b c6		 mov	 eax, esi
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi

; 1196 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1189 : 
; 1190 : 		if (_Grow(_Count))

$LN10@assign:
  0004f	85 ff		 test	 edi, edi
  00051	75 d6		 jne	 SHORT $LN113@assign
  00053	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00057	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0005a	72 0f		 jb	 SHORT $LN87@assign
  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	33 c9		 xor	 ecx, ecx
  00060	5f		 pop	 edi
  00061	66 89 08	 mov	 WORD PTR [eax], cx

; 1194 : 			}
; 1195 : 		return (*this);

  00064	8b c6		 mov	 eax, esi
  00066	5e		 pop	 esi

; 1196 : 		}

  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8

; 1189 : 
; 1190 : 		if (_Grow(_Count))

$LN87@assign:
  0006b	8b c6		 mov	 eax, esi
  0006d	33 c9		 xor	 ecx, ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	66 89 08	 mov	 WORD PTR [eax], cx

; 1196 : 		}

  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8

; 1193 : 			_Eos(_Count);

$LN104@assign:
  00078	8b c6		 mov	 eax, esi
  0007a	33 c9		 xor	 ecx, ecx
  0007c	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN109@assign:

; 1194 : 			}
; 1195 : 		return (*this);

  00080	5f		 pop	 edi
  00081	8b c6		 mov	 eax, esi
  00083	5e		 pop	 esi

; 1196 : 		}

  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
$LN114@assign:

; 1188 : 			_Xlen();	// result too long

  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0008d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN117@assign:
$LN116@assign:

; 1189 : 
; 1190 : 		if (_Grow(_Count))

  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00097	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN118@assign:
$LN111@assign:
  0009c	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN5@assign
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00018	5e		 pop	 esi

; 1183 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL7@assign:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL7@assign
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003c	5e		 pop	 esi

; 1183 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 48		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 08	 cmp	 ecx, 8
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 36		 jb	 SHORT $LN2@assign
  00020	83 f9 08	 cmp	 ecx, 8
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00031	3b c3		 cmp	 eax, ebx
  00033	76 21		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00035	83 f9 08	 cmp	 ecx, 8
  00038	72 04		 jb	 SHORT $LN57@assign
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN58@assign
$LN57@assign:
  0003e	8b c6		 mov	 eax, esi
$LN58@assign:
  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	2b d8		 sub	 ebx, eax
  00045	8b ce		 mov	 ecx, esi
  00047	d1 fb		 sar	 ebx, 1
  00049	53		 push	 ebx
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 1177 : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN2@assign:
  00056	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00057	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 88 00 00
	00		 ja	 $LN189@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 19		 jae	 SHORT $LN63@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	85 ff		 test	 edi, edi
  00078	74 6b		 je	 SHORT $LN183@assign
$LN188@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 2f		 jb	 SHORT $LN158@assign
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	eb 2d		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  00084	85 ff		 test	 edi, edi
  00086	75 f2		 jne	 SHORT $LN188@assign
  00088	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0008c	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0008f	72 10		 jb	 SHORT $LN140@assign
  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	33 c9		 xor	 ecx, ecx
  00095	5f		 pop	 edi
  00096	66 89 08	 mov	 WORD PTR [eax], cx

; 1175 : 			}
; 1176 : 		return (*this);

  00099	8b c6		 mov	 eax, esi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx

; 1177 : 		}

  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a1	8b c6		 mov	 eax, esi
  000a3	33 c9		 xor	 ecx, ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	66 89 08	 mov	 WORD PTR [eax], cx

; 1177 : 		}

  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000af	8b ce		 mov	 ecx, esi
$LN159@assign:
  000b1	85 ff		 test	 edi, edi
  000b3	74 0e		 je	 SHORT $LN165@assign
  000b5	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000b8	50		 push	 eax
  000b9	53		 push	 ebx
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c3	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c7	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ca	72 11		 jb	 SHORT $LN178@assign
  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
  000ce	33 c9		 xor	 ecx, ecx
  000d0	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1175 : 			}
; 1176 : 		return (*this);

  000d4	8b c6		 mov	 eax, esi
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 1177 : 		}

  000d9	5d		 pop	 ebp
  000da	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN178@assign:
  000dd	8b c6		 mov	 eax, esi
  000df	33 c9		 xor	 ecx, ecx
  000e1	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN183@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e5	5f		 pop	 edi
  000e6	8b c6		 mov	 eax, esi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 1177 : 		}

  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
$LN189@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN191@assign:
$LN186@assign:
  000f8	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e3 00 00
	00		 jb	 $LN210@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 33		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d3 00 00
	00		 jb	 $LN212@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0003a	72 04		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	eb 02		 jmp	 SHORT $LN64@assign
$LN63@assign:
  00040	8b d6		 mov	 edx, esi
$LN64@assign:
  00042	33 ff		 xor	 edi, edi
  00044	51		 push	 ecx
  00045	57		 push	 edi
  00046	8b ce		 mov	 ecx, esi
  00048	66 89 3c 42	 mov	 WORD PTR [edx+eax*2], di
  0004c	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
  00051	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00052	8b c6		 mov	 eax, esi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 1162 : 		}

  00056	5d		 pop	 ebp
  00057	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 aa 00 00
	00		 ja	 $LN213@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 24		 jae	 SHORT $LN72@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00079	85 ff		 test	 edi, edi
  0007b	74 76		 je	 SHORT $LN205@assign
$LN209@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0007d	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00081	72 02		 jb	 SHORT $LN166@assign
  00083	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00085	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00089	72 2f		 jb	 SHORT $LN180@assign
  0008b	8b 16		 mov	 edx, DWORD PTR [esi]
  0008d	eb 2d		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  0008f	85 ff		 test	 edi, edi
  00091	75 ea		 jne	 SHORT $LN209@assign
  00093	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00097	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0009a	72 10		 jb	 SHORT $LN149@assign
  0009c	8b 06		 mov	 eax, DWORD PTR [esi]
  0009e	33 c9		 xor	 ecx, ecx
  000a0	5f		 pop	 edi
  000a1	66 89 08	 mov	 WORD PTR [eax], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 1162 : 		}

  000a8	5d		 pop	 ebp
  000a9	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000ac	8b c6		 mov	 eax, esi
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	66 89 08	 mov	 WORD PTR [eax], cx

; 1162 : 		}

  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000ba	8b d6		 mov	 edx, esi
$LN181@assign:
  000bc	85 ff		 test	 edi, edi
  000be	74 11		 je	 SHORT $LN187@assign
  000c0	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000c3	50		 push	 eax
  000c4	8d 04 4b	 lea	 eax, DWORD PTR [ebx+ecx*2]
  000c7	50		 push	 eax
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _memcpy
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000d1	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d8	72 11		 jb	 SHORT $LN200@assign
  000da	8b 06		 mov	 eax, DWORD PTR [esi]
  000dc	33 c9		 xor	 ecx, ecx
  000de	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000e2	8b c6		 mov	 eax, esi
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1162 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN200@assign:
  000eb	8b c6		 mov	 eax, esi
  000ed	33 c9		 xor	 ecx, ecx
  000ef	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN205@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f3	5f		 pop	 edi
  000f4	8b c6		 mov	 eax, esi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx

; 1162 : 		}

  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
$LN210@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00101	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN214@assign:
$LN212@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0010b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN215@assign:
$LN213@assign:

; 1155 : 		else if (_Grow(_Count))

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00115	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN216@assign:
$LN207@assign:
  0011a	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1144 : 		return (assign(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1145 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN5@append
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00018	5e		 pop	 esi

; 1108 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

$LN5@append:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL7@append:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL7@append
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0003c	5e		 pop	 esi

; 1108 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1088 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1089 : 		if (_Inside(_Ptr))

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	74 48		 je	 SHORT $LN2@append
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 08	 cmp	 ecx, 8
  00014	72 04		 jb	 SHORT $LN21@append
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN22@append
$LN21@append:
  0001a	8b c6		 mov	 eax, esi
$LN22@append:
  0001c	3b f8		 cmp	 edi, eax
  0001e	72 36		 jb	 SHORT $LN2@append
  00020	83 f9 08	 cmp	 ecx, 8
  00023	72 04		 jb	 SHORT $LN35@append
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN36@append
$LN35@append:
  00029	8b d6		 mov	 edx, esi
$LN36@append:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00031	3b c7		 cmp	 eax, edi
  00033	76 21		 jbe	 SHORT $LN2@append

; 1090 : 			return (append(*this,

  00035	83 f9 08	 cmp	 ecx, 8
  00038	72 04		 jb	 SHORT $LN58@append
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN59@append
$LN58@append:
  0003e	8b c6		 mov	 eax, esi
$LN59@append:
  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	2b f8		 sub	 edi, eax
  00045	8b ce		 mov	 ecx, esi
  00047	d1 ff		 sar	 edi, 1
  00049	57		 push	 edi
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 1102 : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

  00056	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00059	8b c2		 mov	 eax, edx
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005e	f7 d0		 not	 eax
  00060	3b c1		 cmp	 eax, ecx
  00062	0f 86 a7 00 00
	00		 jbe	 $LN219@append

; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

  00068	53		 push	 ebx
  00069	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

  0006c	85 c9		 test	 ecx, ecx
  0006e	0f 84 92 00 00
	00		 je	 $LN213@append
  00074	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  0007a	0f 87 99 00 00
	00		 ja	 $LN221@append
  00080	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00083	73 1a		 jae	 SHORT $LN85@append
  00085	52		 push	 edx
  00086	53		 push	 ebx
  00087	8b ce		 mov	 ecx, esi
  00089	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00091	85 db		 test	 ebx, ebx
  00093	74 71		 je	 SHORT $LN213@append
$LN218@append:

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

  00095	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00099	72 2f		 jb	 SHORT $LN179@append
  0009b	8b 16		 mov	 edx, DWORD PTR [esi]
  0009d	eb 2d		 jmp	 SHORT $LN180@append

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN85@append:
  0009f	85 db		 test	 ebx, ebx
  000a1	75 f2		 jne	 SHORT $LN218@append
  000a3	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000a6	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000aa	72 10		 jb	 SHORT $LN162@append
  000ac	8b 06		 mov	 eax, DWORD PTR [esi]
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5b		 pop	 ebx
  000b1	5f		 pop	 edi
  000b2	66 89 08	 mov	 WORD PTR [eax], cx

; 1100 : 			}
; 1101 : 		return (*this);

  000b5	8b c6		 mov	 eax, esi
  000b7	5e		 pop	 esi

; 1102 : 		}

  000b8	5d		 pop	 ebp
  000b9	c2 08 00	 ret	 8

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN162@append:
  000bc	8b c6		 mov	 eax, esi
  000be	33 c9		 xor	 ecx, ecx
  000c0	5b		 pop	 ebx
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	66 89 08	 mov	 WORD PTR [eax], cx

; 1102 : 		}

  000c6	5d		 pop	 ebp
  000c7	c2 08 00	 ret	 8

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

$LN179@append:
  000ca	8b d6		 mov	 edx, esi
$LN180@append:
  000cc	85 c9		 test	 ecx, ecx
  000ce	74 14		 je	 SHORT $LN195@append
  000d0	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  000d3	50		 push	 eax
  000d4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d7	57		 push	 edi
  000d8	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _memcpy
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN195@append:

; 1099 : 			_Eos(_Num);

  000e4	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000e8	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000eb	72 11		 jb	 SHORT $LN208@append
  000ed	8b 06		 mov	 eax, DWORD PTR [esi]
  000ef	33 c9		 xor	 ecx, ecx
  000f1	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx

; 1100 : 			}
; 1101 : 		return (*this);

  000f5	8b c6		 mov	 eax, esi
  000f7	5b		 pop	 ebx
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 1102 : 		}

  000fa	5d		 pop	 ebp
  000fb	c2 08 00	 ret	 8

; 1099 : 			_Eos(_Num);

$LN208@append:
  000fe	8b c6		 mov	 eax, esi
  00100	33 c9		 xor	 ecx, ecx
  00102	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN213@append:

; 1100 : 			}
; 1101 : 		return (*this);

  00106	5b		 pop	 ebx
  00107	5f		 pop	 edi
  00108	8b c6		 mov	 eax, esi
  0010a	5e		 pop	 esi

; 1102 : 		}

  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
$LN219@append:

; 1093 : 			_Xlen();	// result too long

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00114	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN222@append:
$LN221@append:

; 1096 : 		if (0 < _Count && _Grow(_Num))

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN223@append:
$LN216@append:
  00123	cc		 int	 3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1071 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 d0 00 00
	00		 jb	 $LN203@append

; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

  00019	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	3b c8		 cmp	 ecx, eax
  00023	0f 47 c8	 cmova	 ecx, eax
  00026	8b c2		 mov	 eax, edx
  00028	f7 d0		 not	 eax
  0002a	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx
  0002d	3b c1		 cmp	 eax, ecx
  0002f	0f 86 be 00 00
	00		 jbe	 $LN205@append

; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

  00035	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

  00038	85 c9		 test	 ecx, ecx
  0003a	0f 84 a0 00 00
	00		 je	 $LN198@append
  00040	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00046	0f 87 b1 00 00
	00		 ja	 $LN206@append
  0004c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0004f	73 22		 jae	 SHORT $LN56@append
  00051	52		 push	 edx
  00052	57		 push	 edi
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0005a	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005d	85 ff		 test	 edi, edi
  0005f	74 7f		 je	 SHORT $LN198@append
$LN202@append:

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

  00061	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00065	72 02		 jb	 SHORT $LN150@append
  00067	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN150@append:
  00069	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0006d	72 2f		 jb	 SHORT $LN164@append
  0006f	8b 16		 mov	 edx, DWORD PTR [esi]
  00071	eb 2d		 jmp	 SHORT $LN165@append

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN56@append:
  00073	85 ff		 test	 edi, edi
  00075	75 ea		 jne	 SHORT $LN202@append
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 10		 jb	 SHORT $LN133@append
  00080	8b 06		 mov	 eax, DWORD PTR [esi]
  00082	33 c9		 xor	 ecx, ecx
  00084	5f		 pop	 edi
  00085	66 89 08	 mov	 WORD PTR [eax], cx

; 1082 : 			}
; 1083 : 		return (*this);

  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1084 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 0c 00	 ret	 12			; 0000000cH

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN133@append:
  00090	8b c6		 mov	 eax, esi
  00092	33 c9		 xor	 ecx, ecx
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	66 89 08	 mov	 WORD PTR [eax], cx

; 1084 : 		}

  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

$LN164@append:
  0009e	8b d6		 mov	 edx, esi
$LN165@append:
  000a0	85 c9		 test	 ecx, ecx
  000a2	74 1a		 je	 SHORT $LN180@append
  000a4	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  000a7	50		 push	 eax
  000a8	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000ab	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  000ae	50		 push	 eax
  000af	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b2	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _memcpy
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@append:

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

  000be	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c2	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000c5	72 11		 jb	 SHORT $LN193@append
  000c7	8b 06		 mov	 eax, DWORD PTR [esi]
  000c9	33 c9		 xor	 ecx, ecx
  000cb	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1082 : 			}
; 1083 : 		return (*this);

  000cf	8b c6		 mov	 eax, esi
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 1084 : 		}

  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

$LN193@append:
  000d8	8b c6		 mov	 eax, esi
  000da	33 c9		 xor	 ecx, ecx
  000dc	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN198@append:

; 1082 : 			}
; 1083 : 		return (*this);

  000e0	5f		 pop	 edi
  000e1	8b c6		 mov	 eax, esi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx

; 1084 : 		}

  000e5	5d		 pop	 ebp
  000e6	c2 0c 00	 ret	 12			; 0000000cH
$LN203@append:

; 1071 : 		_Right._Check_offset(_Roff);

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000ee	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN207@append:
$LN205@append:

; 1074 : 			_Xlen();	// result too long

  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f8	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN208@append:
$LN206@append:

; 1077 : 		if (0 < _Count && _Grow(_Num))

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00102	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN209@append:
$LN200@append:
  00107	cc		 int	 3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1024 : 		if (this != &_Right)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 0a		 je	 SHORT $LN134@operator

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);

  0000d	6a ff		 push	 -1
  0000f	6a 00		 push	 0
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN134@operator:

; 1034 : 			}
; 1035 : 		return (*this);

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 1036 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 08	 cmp	 eax, 8
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 09		 jb	 SHORT $LN96@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	5e		 pop	 esi
  0002d	66 89 08	 mov	 WORD PTR [eax], cx

; 1018 : 		}

  00030	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN96@basic_stri:
  00031	33 c0		 xor	 eax, eax
  00033	66 89 06	 mov	 WORD PTR [esi], ax
  00036	5e		 pop	 esi

; 1018 : 		}

  00037	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0000e	73 17		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1d		 je	 SHORT $LN3@Assign_rv
  00018	03 c0		 add	 eax, eax
  0001a	50		 push	 eax
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00025	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00027	85 ff		 test	 edi, edi
  00029	74 04		 je	 SHORT $LN86@Assign_rv
  0002b	8b 06		 mov	 eax, DWORD PTR [esi]
  0002d	89 07		 mov	 DWORD PTR [edi], eax
$LN86@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00035	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00038	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  0003b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003e	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00053	72 0d		 jb	 SHORT $LN231@Assign_rv
  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	33 c9		 xor	 ecx, ecx
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	66 89 08	 mov	 WORD PTR [eax], cx

; 973  : 		}

  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN231@Assign_rv:
  00062	33 c0		 xor	 eax, eax
  00064	5f		 pop	 edi
  00065	66 89 06	 mov	 WORD PTR [esi], ax
  00068	5e		 pop	 esi

; 973  : 		}

  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 946  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 947  : 		if (this == &_Right)

  00025	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00028	74 3a		 je	 SHORT $LN279@assign

; 948  : 			;
; 949  : 		else if (get_allocator() != _Right.get_allocator()
; 950  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 951  : 			*this = _Right;
; 952  : 		else
; 953  : 			{	// not same, clear this and steal from _Right
; 954  : 			_Tidy(true);

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	83 f8 08	 cmp	 eax, 8
  00030	72 09		 jb	 SHORT $LN179@assign
  00032	40		 inc	 eax
  00033	50		 push	 eax
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN179@assign:
  0003b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00042	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	72 04		 jb	 SHORT $LN269@assign
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN270@assign
$LN269@assign:
  00053	8b c6		 mov	 eax, esi
$LN270@assign:

; 955  : 			_Assign_rv(_STD forward<_Myt>(_Right));

  00055	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00058	33 c9		 xor	 ecx, ecx
  0005a	66 89 08	 mov	 WORD PTR [eax], cx
  0005d	8b ce		 mov	 ecx, esi
  0005f	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN279@assign:

; 956  : 			}
; 957  : 		return (*this);

  00064	8b c6		 mov	 eax, esi

; 958  : 		}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5e		 pop	 esi
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv

; 914  : 		}

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 2
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 850  : 		{	// construct from _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 851  : 		_Tidy();
; 852  : 		assign(_Count, _Ch);

  00004	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0000e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	66 89 06	 mov	 WORD PTR [esi], ax
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 853  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	66 39 02	 cmp	 WORD PTR [edx], ax
  0001f	75 12		 jne	 SHORT $LN113@basic_stri
  00021	33 c9		 xor	 ecx, ecx
  00023	51		 push	 ecx
  00024	52		 push	 edx
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN113@basic_stri:
  00033	8b ca		 mov	 ecx, edx
  00035	57		 push	 edi
  00036	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL115@basic_stri:
  00040	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00043	83 c1 02	 add	 ecx, 2
  00046	66 85 c0	 test	 ax, ax
  00049	75 f5		 jne	 SHORT $LL115@basic_stri
  0004b	2b cf		 sub	 ecx, edi
  0004d	d1 f9		 sar	 ecx, 1
  0004f	5f		 pop	 edi
  00050	51		 push	 ecx
  00051	52		 push	 edx
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 822  : 		{	// construct from [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 823  : 		_Tidy();
; 824  : 		assign(_Ptr, _Count);

  00004	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	66 89 06	 mov	 WORD PTR [esi], ax
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 825  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 795  : 		_Tidy();

  00000	33 c0		 xor	 eax, eax
  00002	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	66 89 01	 mov	 WORD PTR [ecx], ax

; 796  : 		}

  00013	8b c1		 mov	 eax, ecx
  00015	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 781  : 		_Tidy();

  00006	33 c0		 xor	 eax, eax

; 782  : 		assign(_Right, 0, npos);

  00008	6a ff		 push	 -1
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	66 89 06	 mov	 WORD PTR [esi], ax
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 783  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 602  : 		_Pocca(_Getal(), _Al);
; 603  : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN16@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN7@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN18@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN19@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN20@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN21@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  00059	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00013	77 3b		 ja	 SHORT $LN14@allocate
  00015	03 c0		 add	 eax, eax
  00017	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001c	72 23		 jb	 SHORT $LN6@allocate
  0001e	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00021	3b c8		 cmp	 ecx, eax
  00023	76 30		 jbe	 SHORT $LN16@allocate
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	8b c8		 mov	 ecx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c9		 test	 ecx, ecx
  00032	74 26		 je	 SHORT $LN17@allocate
  00034	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00037	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003a	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00047	83 c4 04	 add	 esp, 4
  0004a	85 c0		 test	 eax, eax
  0004c	75 bc		 jne	 SHORT $LN12@allocate
  0004e	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00050	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00055	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN13@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN5@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN15@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN16@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN17@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN18@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00059	cc		 int	 3
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gios_base@std@@UAEPAXI@Z PROC			; std::ios_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gios_base@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	56		 push	 esi
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00033	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00038	83 c4 04	 add	 esp, 4
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN7@scalar
  00041	6a 38		 push	 56			; 00000038H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gios_base@std@@UAEPAXI@Z$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_Gios_base@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gios_base@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gios_base@std@@UAEPAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?_Init@ios_base@std@@IAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?_Init@ios_base@std@@IAEXXZ PROC			; std::ios_base::_Init, COMDAT
; _this$ = ecx

; 538  : 		{	// initialize a new ios_base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Init@ios_base@std@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 539  : 		_Ploc = 0;
; 540  : 		_Stdstr = 0;
; 541  : 		_Except = goodbit;
; 542  : 		_Fmtfl = (fmtflags)(skipws | dec);
; 543  : 		_Prec = 6;
; 544  : 		_Wide = 0;
; 545  : 		_Arr = 0;
; 546  : 		_Calls = 0;
; 547  : 		clear(goodbit);

  00026	6a 00		 push	 0
  00028	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  0002f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00036	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0003d	c7 46 14 01 02
	00 00		 mov	 DWORD PTR [esi+20], 513	; 00000201H
  00044	c7 46 18 06 00
	00 00		 mov	 DWORD PTR [esi+24], 6
  0004b	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00052	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00059	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00060	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00067	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  0006e	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH@Z ; std::ios_base::clear

; 548  : 		_Ploc = new locale;

  00073	6a 08		 push	 8
  00075	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007a	8b f8		 mov	 edi, eax
  0007c	83 c4 04	 add	 esp, 4
  0007f	85 ff		 test	 edi, edi
  00081	74 28		 je	 SHORT $LN3@Init
  00083	6a 01		 push	 1
  00085	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008c	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  00091	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00094	83 c4 04	 add	 esp, 4
  00097	89 7e 30	 mov	 DWORD PTR [esi+48], edi

; 549  : 		}

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a4	59		 pop	 ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN3@Init:

; 548  : 		_Ploc = new locale;

  000ab	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 549  : 		}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Init@ios_base@std@@IAEXXZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$?_Init@ios_base@std@@IAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Init@ios_base@std@@IAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Init@ios_base@std@@IAEXXZ ENDP			; std::ios_base::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??0ios_base@std@@IAE@XZ
_TEXT	SEGMENT
??0ios_base@std@@IAE@XZ PROC				; std::ios_base::ios_base, COMDAT
; _this$ = ecx

; 534  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@

; 535  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0ios_base@std@@IAE@XZ ENDP				; std::ios_base::ios_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??1ios_base@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ios_base@std@@UAE@XZ PROC				; std::ios_base::~ios_base, COMDAT
; _this$ = ecx

; 523  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ios_base@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 524  : 		_Ios_base_dtor(this);

  00022	51		 push	 ecx
  00023	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00029	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0002e	83 c4 04	 add	 esp, 4

; 525  : 		}

  00031	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00034	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003b	59		 pop	 ecx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ios_base@std@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ios_base@std@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ios_base@std@@UAE@XZ ENDP				; std::ios_base::~ios_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 434  : 		{	// get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 435  : 		return (*_Ploc);

  00024	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00027	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00031	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	ff 52 04	 call	 DWORD PTR [edx+4]
  00043	8b c6		 mov	 eax, esi

; 436  : 		}

  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004f	59		 pop	 ecx
  00050	5e		 pop	 esi
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 427  : 		{	// set width to argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 		streamsize _Oldwidth = _Wide;

  00003	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00006	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00009	56		 push	 esi

; 429  : 		_Wide = _Newwidth;

  0000a	8b 75 08	 mov	 esi, DWORD PTR __Newwidth$[ebp]
  0000d	89 71 20	 mov	 DWORD PTR [ecx+32], esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR __Newwidth$[ebp+4]
  00013	89 71 24	 mov	 DWORD PTR [ecx+36], esi
  00016	5e		 pop	 esi

; 430  : 		return (_Oldwidth);
; 431  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 423  : 		return (_Wide);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]

; 424  : 		}

  00006	c3		 ret	 0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?precision@ios_base@std@@QBE_JXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 411  : 		return (_Prec);

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 412  : 		}

  00006	c3		 ret	 0
?precision@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 378  : 		return (_Fmtfl);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 379  : 		}

  00003	c3		 ret	 0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 338  : 		{	// test if no state bits are set

  00000	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00004	0f 94 c0	 sete	 al

; 339  : 		return (rdstate() == goodbit);
; 340  : 		}

  00007	c3		 ret	 0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 315  : 		return (_Mystate);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 316  : 		}

  00003	c3		 ret	 0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -20						; size = 20
__State$ = 8						; size = 4
?clear@ios_base@std@@QAEXH@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 302  : 		{	// set state to argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 303  : 		clear(_State, false);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	83 e0 17	 and	 eax, 23			; 00000017H
  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0000f	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00012	23 c8		 and	 ecx, eax
  00014	74 22		 je	 SHORT $LN11@clear
  00016	f6 c1 04	 test	 cl, 4
  00019	75 23		 jne	 SHORT $LN52@clear
  0001b	f6 c1 02	 test	 cl, 2
  0001e	74 0c		 je	 SHORT $LN10@clear
  00020	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  0002a	eb 1c		 jmp	 SHORT $LN51@clear
$LN10@clear:
  0002c	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  00036	eb 10		 jmp	 SHORT $LN51@clear
$LN11@clear:

; 304  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
$LN52@clear:

; 303  : 		clear(_State, false);

  0003e	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN51@clear:
  00048	50		 push	 eax
  00049	6a 01		 push	 1
  0004b	8d 4d ec	 lea	 ecx, DWORD PTR $T1[ebp]
  0004e	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00053	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00058	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  0005b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN54@clear:
$LN50@clear:
  00068	cc		 int	 3
?clear@ios_base@std@@QAEXH@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -20						; size = 20
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 287  : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  : 		_Mystate = (iostate)(_State & _Statmask);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	83 e0 17	 and	 eax, 23			; 00000017H
  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 289  : 		if ((_Mystate & _Except) == 0)

  0000f	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00012	23 c8		 and	 ecx, eax
  00014	74 28		 je	 SHORT $LN9@clear

; 290  : 			;
; 291  : 		else if (_Reraise)

  00016	80 7d 0c 00	 cmp	 BYTE PTR __Reraise$[ebp], 0
  0001a	75 28		 jne	 SHORT $LN49@clear

; 293  : 		else if (_Mystate & _Except & badbit)

  0001c	f6 c1 04	 test	 cl, 4
  0001f	75 2c		 jne	 SHORT $LN51@clear

; 295  : 		else if (_Mystate & _Except & failbit)

  00021	f6 c1 02	 test	 cl, 2
  00024	74 0c		 je	 SHORT $LN8@clear

; 296  : 			_THROW_NCEE(failure, "ios_base::failbit set");

  00026	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  00030	eb 25		 jmp	 SHORT $LN48@clear
$LN8@clear:

; 297  : 		else
; 298  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

  00032	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  0003c	eb 19		 jmp	 SHORT $LN48@clear
$LN9@clear:

; 299  : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN49@clear:

; 292  : 			_RERAISE;

  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN52@clear:
$LN51@clear:

; 294  : 			_THROW_NCEE(failure, "ios_base::badbit set");

  0004d	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN48@clear:
  00057	50		 push	 eax
  00058	6a 01		 push	 1
  0005a	8d 4d ec	 lea	 ecx, DWORD PTR $T1[ebp]
  0005d	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00062	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00067	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  0006a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN53@clear:
$LN47@clear:
  00077	cc		 int	 3
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00039	8b c7		 mov	 eax, edi
  0003b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7failure@ios_base@std@@6B@
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 238  : 			{	// construct with message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 237  : 			: system_error(_Errcode, _Message)

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00007	56		 push	 esi
  00008	ff 75 08	 push	 DWORD PTR __Message$[ebp]

; 238  : 			{	// construct with message

  0000b	8b f1		 mov	 esi, ecx
  0000d	ff 70 04	 push	 DWORD PTR [eax+4]
  00010	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00013	ff 30		 push	 DWORD PTR [eax]
  00015	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@

; 239  : 			}

  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ PROC ; std::_Immortalize<std::_Iostream_error_category>, COMDAT

; 698  : 	/* MAGIC */ static _Immortalizer<_Ty> _Static;

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  0000c	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00014	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  0001a	7f 06		 jg	 SHORT $LN22@Immortaliz
$LN20@Immortaliz:

; 699  : 	return (*reinterpret_cast<_Ty *>(&_Static._Storage));

  0001c	b8 00 00 00 00	 mov	 eax, OFFSET ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Static

; 700  : 	}

  00021	c3		 ret	 0
$LN22@Immortaliz:

; 698  : 	/* MAGIC */ static _Immortalizer<_Ty> _Static;

  00022	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00027	e8 00 00 00 00	 call	 __Init_thread_header
  0002c	83 c4 04	 add	 esp, 4
  0002f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA, -1 ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00036	75 e4		 jne	 SHORT $LN20@Immortaliz
  00038	68 00 00 00 00	 push	 OFFSET ??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static''
  0003d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A, OFFSET ??_7_Iostream_error_category@std@@6B@
  00047	c7 05 04 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A+4, 5
  00051	e8 00 00 00 00	 call	 _atexit
  00056	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  0005b	e8 00 00 00 00	 call	 __Init_thread_footer
  00060	83 c4 08	 add	 esp, 8
  00063	eb b7		 jmp	 SHORT $LN20@Immortaliz
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ENDP ; std::_Immortalize<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
  00010	74 0b		 je	 SHORT $LN13@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
  00006	c3		 ret	 0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 626  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 627  : 		if (_Errcode == (int)io_errc::stream)

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000e	56		 push	 esi

; 628  : 			return ("iostream stream error");

  0000f	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00012	83 f8 01	 cmp	 eax, 1
  00015	75 28		 jne	 SHORT $LN2@message
  00017	6a 15		 push	 21			; 00000015H
  00019	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00020	8b ce		 mov	 ecx, esi
  00022	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
  0002e	c6 06 00	 mov	 BYTE PTR [esi], 0
  00031	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 629  : 		else
; 630  : 			return (_Generic_error_category::message(_Errcode));

  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi

; 631  : 		}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@message:

; 629  : 		else
; 630  : 			return (_Generic_error_category::message(_Errcode));

  0003f	50		 push	 eax
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 631  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 622  : 		return ("iostream");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 623  : 		}

  00005	c3		 ret	 0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 616  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@

; 617  : 		_Addr = _Iostream_addr;
; 618  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 05 00
	00 00		 mov	 DWORD PTR [ecx+4], 5
  0000f	c3		 ret	 0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
  00010	74 0b		 je	 SHORT $LN10@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
  00006	c3		 ret	 0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 605  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 606  : 		return (_Syserror_map(_Errcode));

  00005	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp]
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map
  00014	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00017	8b d0		 mov	 edx, eax
  00019	83 c4 04	 add	 esp, 4
  0001c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00023	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002d	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00030	75 14		 jne	 SHORT $LN115@message
  00032	33 c9		 xor	 ecx, ecx
  00034	51		 push	 ecx
  00035	52		 push	 edx
  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi

; 607  : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 606  : 		return (_Syserror_map(_Errcode));

$LN115@message:
  00046	8b ca		 mov	 ecx, edx
  00048	57		 push	 edi
  00049	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0004c	0f 1f 40 00	 npad	 4
$LL117@message:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL117@message
  00057	2b cf		 sub	 ecx, edi
  00059	5f		 pop	 edi
  0005a	51		 push	 ecx
  0005b	52		 push	 edx
  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00063	8b c6		 mov	 eax, esi
  00065	5e		 pop	 esi

; 607  : 		}

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 601  : 		return ("generic");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 602  : 		}

  00005	c3		 ret	 0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 595  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Generic_error_category@std@@6B@

; 596  : 		_Addr = _Generic_addr;
; 597  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 03 00
	00 00		 mov	 DWORD PTR [ecx+4], 3
  0000f	c3		 ret	 0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN15@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN15@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00039	8b c7		 mov	 eax, edi
  0003b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7system_error@std@@6B@
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 548  : 		{	// construct from error code and message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx
  0002c	89 75 d4	 mov	 DWORD PTR _this$[ebp], esi
  0002f	8b 55 10	 mov	 edx, DWORD PTR __Message$[ebp]

; 547  : 		: _Mybase(_Errcode, _Message)

  00032	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
  00039	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0
  00040	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0
  00044	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00047	75 04		 jne	 SHORT $LN115@system_err
  00049	33 c9		 xor	 ecx, ecx
  0004b	eb 0e		 jmp	 SHORT $LN116@system_err
$LN115@system_err:
  0004d	8b ca		 mov	 ecx, edx
  0004f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL218@system_err:
  00052	8a 01		 mov	 al, BYTE PTR [ecx]
  00054	41		 inc	 ecx
  00055	84 c0		 test	 al, al
  00057	75 f9		 jne	 SHORT $LL218@system_err
  00059	2b cf		 sub	 ecx, edi
$LN116@system_err:
  0005b	51		 push	 ecx
  0005c	52		 push	 edx
  0005d	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00060	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00065	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  00068	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006f	50		 push	 eax
  00070	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp+4]
  00073	8b ce		 mov	 ecx, esi
  00075	ff 75 08	 push	 DWORD PTR __Errcode$[ebp]
  00078	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  0007d	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp+20]
  00080	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00083	72 0d		 jb	 SHORT $LN219@system_err
  00085	41		 inc	 ecx
  00086	51		 push	 ecx
  00087	ff 75 d8	 push	 DWORD PTR $T2[ebp]
  0008a	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0008d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN219@system_err:

; 549  : 		}

  00092	8b c6		 mov	 eax, esi

; 548  : 		{	// construct from error code and message string

  00094	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@

; 549  : 		}

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a4	59		 pop	 ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000aa	33 cd		 xor	 ecx, ebp
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Ogtp
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00039	8b c7		 mov	 eax, edi
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$1 = -36					; size = 8
_this$ = -32						; size = 4
$T2 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 523  : 		{	// construct from error code and message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  00013	56		 push	 esi
  00014	83 ec 18	 sub	 esp, 24			; 00000018H
  00017	8b f1		 mov	 esi, ecx
  00019	8b cc		 mov	 ecx, esp
  0001b	89 75 e0	 mov	 DWORD PTR _this$[ebp], esi
  0001e	6a ff		 push	 -1
  00020	6a 00		 push	 0
  00022	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00029	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00030	50		 push	 eax
  00031	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00034	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00039	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp+4]
  0003c	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  0003f	ff 75 08	 push	 DWORD PTR __Errcode$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
  00048	8b c8		 mov	 ecx, eax
  0004a	83 c4 24	 add	 esp, 36			; 00000024H
  0004d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00051	72 02		 jb	 SHORT $LN147@System_err

; 522  : 		: runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)

  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN147@System_err:
  00055	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	89 4d dc	 mov	 DWORD PTR __InitData$1[ebp], ecx
  00064	50		 push	 eax
  00065	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00069	8d 45 dc	 lea	 eax, DWORD PTR __InitData$1[ebp]
  0006c	50		 push	 eax
  0006d	c6 45 e0 01	 mov	 BYTE PTR __InitData$1[ebp+4], 1
  00071	e8 00 00 00 00	 call	 ___std_exception_copy
  00076	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp+20]
  00079	83 c4 08	 add	 esp, 8
  0007c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  00082	83 f8 10	 cmp	 eax, 16			; 00000010H
  00085	72 0d		 jb	 SHORT $LN158@System_err
  00087	40		 inc	 eax
  00088	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  0008b	50		 push	 eax
  0008c	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  0008f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN158@System_err:
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Errcode$[ebp]

; 524  : 		}

  00097	8b c6		 mov	 eax, esi
  00099	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  0009f	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_System_error@std@@6B@
  000ab	33 cd		 xor	 ecx, ebp
  000ad	5e		 pop	 esi
  000ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 0c 00	 ret	 12			; 0000000cH
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T2 = -44						; size = 4
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 24
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 513  : 		{	// compose error message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00033	83 7d 24 00	 cmp	 DWORD PTR __Message$[ebp+16], 0
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 514  : 		if (!_Message.empty())

  0003e	74 0f		 je	 SHORT $LN2@Makestr

; 515  : 			_Message.append(": ");

  00040	6a 02		 push	 2
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
  00047	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  0004a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Makestr:

; 516  : 		_Message.append(_Errcode.message());

  0004f	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00052	50		 push	 eax
  00053	8d 4d 0c	 lea	 ecx, DWORD PTR __Errcode$[ebp]
  00056	e8 00 00 00 00	 call	 ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
  0005b	6a ff		 push	 -1
  0005d	6a 00		 push	 0
  0005f	50		 push	 eax
  00060	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00067	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0006c	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp+20]
  0006f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00072	72 0d		 jb	 SHORT $LN34@Makestr
  00074	40		 inc	 eax
  00075	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00078	50		 push	 eax
  00079	ff 75 d8	 push	 DWORD PTR $T3[ebp]
  0007c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN34@Makestr:

; 517  : 		return (_Message);

  00081	8d 45 14	 lea	 eax, DWORD PTR __Message$[ebp]
  00084	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0008b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00092	8b ce		 mov	 ecx, esi
  00094	50		 push	 eax
  00095	c6 06 00	 mov	 BYTE PTR [esi], 0
  00098	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0009d	8b 4d 28	 mov	 ecx, DWORD PTR __Message$[ebp+20]
  000a0	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000a3	72 0d		 jb	 SHORT $LN355@Makestr
  000a5	41		 inc	 ecx
  000a6	51		 push	 ecx
  000a7	ff 75 14	 push	 DWORD PTR __Message$[ebp]
  000aa	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  000ad	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN355@Makestr:
  000b2	8b c6		 mov	 eax, esi

; 518  : 		}

  000b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000be	59		 pop	 ecx
  000bf	5e		 pop	 esi
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	33 cd		 xor	 ecx, ebp
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 392  : 	{	// test errors for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 393  : 	return (_Left.category() == _Right.category()

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00016	75 0b		 jne	 SHORT $LN3@operator
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	3b 06		 cmp	 eax, DWORD PTR [esi]
  0001c	75 05		 jne	 SHORT $LN3@operator
  0001e	b0 01		 mov	 al, 1
  00020	5e		 pop	 esi

; 394  : 		&& _Left.value() == _Right.value());
; 395  : 	}

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN3@operator:

; 393  : 	return (_Left.category() == _Right.category()

  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 394  : 		&& _Left.value() == _Right.value());
; 395  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 346  : 		return (*_Mycat);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 347  : 		}

  00003	c3		 ret	 0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 341  : 		return (_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 342  : 		}

  00002	c3		 ret	 0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 307  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 306  : 		: _Myval(_Val), _Mycat(&_Cat)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 308  : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 279  : 		{	// get name of error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 280  : 		return (category().message(value()));

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	ff 31		 push	 DWORD PTR [ecx]
  00009	8b c8		 mov	 ecx, eax
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	ff 52 08	 call	 DWORD PTR [edx+8]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 281  : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 273  : 		return (*_Mycat);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 274  : 		}

  00003	c3		 ret	 0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 268  : 		return (_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 269  : 		}

  00002	c3		 ret	 0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 234  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 233  : 		: _Myval(_Val), _Mycat(&_Cat)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 235  : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 191  : 		{	// compare categories for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0000c	0f 94 c0	 sete	 al

; 192  : 		return (_Addr == _Right._Addr);
; 193  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 462  : 	{	// test if conditions same for this category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 463  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __Code$[ebp]
  0000a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000d	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00010	75 0e		 jne	 SHORT $LN3@equivalent
  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  00017	75 07		 jne	 SHORT $LN3@equivalent
  00019	b0 01		 mov	 al, 1
  0001b	5e		 pop	 esi

; 464  : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
$LN3@equivalent:

; 463  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  00020	32 c0		 xor	 al, al
  00022	5e		 pop	 esi

; 464  : 	}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 455  : 	{	// test if error code same condition

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 456  : 	return (default_error_condition(_Errval) == _Cond);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	ff 75 08	 push	 DWORD PTR __Errval$[ebp]
  0000f	52		 push	 edx
  00010	ff 50 0c	 call	 DWORD PTR [eax+12]
  00013	8b 75 0c	 mov	 esi, DWORD PTR __Cond$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001f	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00022	75 0f		 jne	 SHORT $LN5@equivalent
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	3b 06		 cmp	 eax, DWORD PTR [esi]
  00028	75 09		 jne	 SHORT $LN5@equivalent
  0002a	b0 01		 mov	 al, 1
  0002c	5e		 pop	 esi

; 457  : 	}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8

; 456  : 	return (default_error_condition(_Errval) == _Cond);

$LN5@equivalent:
  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 457  : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 448  : 	{	// make error_condition for error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 449  : 	return (error_condition(_Errval, *this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Errval$[ebp]
  00009	89 10		 mov	 DWORD PTR [eax], edx
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 450  : 	}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 174  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 175  : 		}

  00006	c3		 ret	 0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 169  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 170  : 		_Addr = reinterpret_cast<uintptr_t>(this);
; 171  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000b	c3		 ret	 0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 709  : 	return (_Immortalize<_Iostream_error_category>());

  00000	e9 00 00 00 00	 jmp	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 479  : 	{	// make an error_code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 480  : 	return (error_code((int)_Errno, iostream_category()));

  00003	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00008	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Errno$[ebp]
  0000e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00011	8b c2		 mov	 eax, edx
  00013	89 0a		 mov	 DWORD PTR [edx], ecx

; 481  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@_W@std@@MAEPAXI@Z PROC			; std::ctype<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	ff 76 0c	 push	 DWORD PTR [esi+12]
  00015	e8 00 00 00 00	 call	 _free
  0001a	83 c4 04	 add	 esp, 4
$LN5@scalar:
  0001d	ff 76 14	 push	 DWORD PTR [esi+20]
  00020	e8 00 00 00 00	 call	 _free
  00025	83 c4 04	 add	 esp, 4
  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00032	74 0b		 je	 SHORT $LN17@scalar
  00034	6a 44		 push	 68			; 00000044H
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN17@scalar:
  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
??_G?$ctype@_W@std@@MAEPAXI@Z ENDP			; std::ctype<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
_TEXT	SEGMENT
__Mbst$1 = -28						; size = 8
tv164 = -20						; size = 4
tv168 = -16						; size = 4
__Buf$2 = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dflt$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z PROC	; std::ctype<wchar_t>::do_narrow, COMDAT
; _this$ = ecx

; 2779 : 		{	// narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 14	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00014	33 d2		 xor	 edx, edx
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0001e	2b fe		 sub	 edi, esi
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv168[ebp], 0
  00027	47		 inc	 edi
  00028	d1 ef		 shr	 edi, 1
  0002a	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0002d	0f 47 fa	 cmova	 edi, edx

; 2780 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2781 : 		for (; _First != _Last; ++_First, ++_Dest)

  00030	85 ff		 test	 edi, edi
  00032	74 4e		 je	 SHORT $LN14@do_narrow
  00034	83 c1 18	 add	 ecx, 24			; 00000018H
  00037	89 4d ec	 mov	 DWORD PTR tv164[ebp], ecx
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL4@do_narrow:

; 2782 : 			*_Dest = _Donarrow(*_First, _Dflt);

  00040	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00043	0f 57 c0	 xorps	 xmm0, xmm0
  00046	51		 push	 ecx
  00047	8d 4d e4	 lea	 ecx, DWORD PTR __Mbst$1[ebp]
  0004a	66 0f d6 45 e4	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  0004f	51		 push	 ecx
  00050	50		 push	 eax
  00051	8d 45 f4	 lea	 eax, DWORD PTR __Buf$2[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 __Wcrtomb
  0005a	0f b6 4d 10	 movzx	 ecx, BYTE PTR __Dflt$[ebp]
  0005e	8d 5b 01	 lea	 ebx, DWORD PTR [ebx+1]
  00061	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$2[ebp]
  00065	83 c4 10	 add	 esp, 16			; 00000010H
  00068	83 f8 01	 cmp	 eax, 1
  0006b	8b 45 f0	 mov	 eax, DWORD PTR tv168[ebp]
  0006e	0f 45 d1	 cmovne	 edx, ecx
  00071	8b 4d ec	 mov	 ecx, DWORD PTR tv164[ebp]
  00074	40		 inc	 eax
  00075	88 53 ff	 mov	 BYTE PTR [ebx-1], dl
  00078	83 c6 02	 add	 esi, 2
  0007b	89 45 f0	 mov	 DWORD PTR tv168[ebp], eax
  0007e	3b c7		 cmp	 eax, edi
  00080	75 be		 jne	 SHORT $LL4@do_narrow
$LN14@do_narrow:

; 2783 : 		return (_First);
; 2784 : 		}

  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	33 cd		 xor	 ecx, ebp
  0008b	5b		 pop	 ebx
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z ENDP	; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MBED_WD@Z
_TEXT	SEGMENT
__Mbst$1 = -20						; size = 8
__Buf$2 = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__Ch$ = 8						; size = 2
__Dflt$ = 12						; size = 1
?do_narrow@?$ctype@_W@std@@MBED_WD@Z PROC		; std::ctype<wchar_t>::do_narrow, COMDAT
; _this$ = ecx

; 2773 : 		{	// narrow element to char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2774 : 		return (_Donarrow(_Ch, _Dflt));

  00010	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	50		 push	 eax
  00017	8d 45 ec	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  0001a	66 0f d6 45 ec	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00023	8d 45 f4	 lea	 eax, DWORD PTR __Buf$2[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Wcrtomb
  0002c	0f b6 4d 0c	 movzx	 ecx, BYTE PTR __Dflt$[ebp]
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$2[ebp]
  00037	83 f8 01	 cmp	 eax, 1
  0003a	0f 45 d1	 cmovne	 edx, ecx

; 2775 : 		}

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	8a c2		 mov	 al, dl
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?do_narrow@?$ctype@_W@std@@MBED_WD@Z ENDP		; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Donarrow@?$ctype@_W@std@@IBED_WD@Z
_TEXT	SEGMENT
__Mbst$ = -20						; size = 8
__Buf$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__Ch$ = 8						; size = 2
__Dflt$ = 12						; size = 1
?_Donarrow@?$ctype@_W@std@@IBED_WD@Z PROC		; std::ctype<wchar_t>::_Donarrow, COMDAT
; _this$ = ecx

; 2765 : 		{	// narrow element to char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2766 : 		char _Buf[MB_LEN_MAX];
; 2767 : 		_Mbstinit(_Mbst);
; 2768 : 		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1

  00010	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	50		 push	 eax
  00017	8d 45 ec	 lea	 eax, DWORD PTR __Mbst$[ebp]
  0001a	66 0f d6 45 ec	 movq	 QWORD PTR __Mbst$[ebp], xmm0
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00023	8d 45 f4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Wcrtomb
  0002c	0f b6 4d 0c	 movzx	 ecx, BYTE PTR __Dflt$[ebp]
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$[ebp]
  00037	83 f8 01	 cmp	 eax, 1
  0003a	0f 45 d1	 cmovne	 edx, ecx

; 2769 : 			? _Dflt : _Buf[0]);
; 2770 : 		}

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	8a c2		 mov	 al, dl
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?_Donarrow@?$ctype@_W@std@@IBED_WD@Z ENDP		; std::ctype<wchar_t>::_Donarrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
_TEXT	SEGMENT
__Mbst$1 = -16						; size = 8
tv129 = -8						; size = 4
tv160 = -4						; size = 4
__Wc$2 = 8						; size = 2
__First$ = 8						; size = 4
__Byte$ = 12						; size = 1
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z PROC		; std::ctype<wchar_t>::do_widen, COMDAT
; _this$ = ecx

; 2757 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000a	33 d2		 xor	 edx, edx
  0000c	57		 push	 edi
  0000d	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00010	2b fe		 sub	 edi, esi
  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
  00019	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001c	0f 47 fa	 cmova	 edi, edx

; 2758 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2759 : 		for (; _First != _Last; ++_First, ++_Dest)

  0001f	85 ff		 test	 edi, edi
  00021	74 56		 je	 SHORT $LN12@do_widen
  00023	83 c1 18	 add	 ecx, 24			; 00000018H
  00026	53		 push	 ebx
  00027	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv129[ebp], ecx
  0002d	0f 1f 00	 npad	 3
$LL4@do_widen:

; 2760 : 			*_Dest = _Dowiden(*_First);

  00030	8a 06		 mov	 al, BYTE PTR [esi]
  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	88 45 0c	 mov	 BYTE PTR __Byte$[ebp], al
  00038	8d 45 f0	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	6a 01		 push	 1
  0003f	8d 45 0c	 lea	 eax, DWORD PTR __Byte$[ebp]
  00042	66 0f d6 45 f0	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  00047	50		 push	 eax
  00048	8d 45 08	 lea	 eax, DWORD PTR __Wc$2[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 __Mbrtowc
  00051	0f b7 4d 08	 movzx	 ecx, WORD PTR __Wc$2[ebp]
  00055	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]
  00058	83 c4 14	 add	 esp, 20			; 00000014H
  0005b	85 c0		 test	 eax, eax
  0005d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00062	0f 48 c8	 cmovs	 ecx, eax
  00065	8b 45 fc	 mov	 eax, DWORD PTR tv160[ebp]
  00068	40		 inc	 eax
  00069	66 89 4b fe	 mov	 WORD PTR [ebx-2], cx
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR tv129[ebp]
  00070	46		 inc	 esi
  00071	89 45 fc	 mov	 DWORD PTR tv160[ebp], eax
  00074	3b c7		 cmp	 eax, edi
  00076	75 b8		 jne	 SHORT $LL4@do_widen
  00078	5b		 pop	 ebx
$LN12@do_widen:
  00079	5f		 pop	 edi

; 2761 : 		return (_First);

  0007a	8b c6		 mov	 eax, esi
  0007c	5e		 pop	 esi

; 2762 : 		}

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z ENDP		; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MBE_WD@Z
_TEXT	SEGMENT
__Mbst$1 = -12						; size = 8
__Wc$2 = -4						; size = 2
__Byte$ = 8						; size = 1
__Byte$ = 8						; size = 1
?do_widen@?$ctype@_W@std@@MBE_WD@Z PROC			; std::ctype<wchar_t>::do_widen, COMDAT
; _this$ = ecx

; 2751 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2752 : 		return (_Dowiden(_Byte));

  00006	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	88 45 08	 mov	 BYTE PTR __Byte$[ebp], al
  0000f	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00012	50		 push	 eax
  00013	8d 45 f4	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  00016	66 0f d6 45 f4	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  0001b	50		 push	 eax
  0001c	6a 01		 push	 1
  0001e	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR __Wc$2[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 __Mbrtowc
  0002b	0f b7 4d fc	 movzx	 ecx, WORD PTR __Wc$2[ebp]
  0002f	83 c4 14	 add	 esp, 20			; 00000014H
  00032	85 c0		 test	 eax, eax
  00034	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00039	0f 48 ca	 cmovs	 ecx, edx
  0003c	66 8b c1	 mov	 ax, cx

; 2753 : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?do_widen@?$ctype@_W@std@@MBE_WD@Z ENDP			; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Dowiden@?$ctype@_W@std@@IBE_WD@Z
_TEXT	SEGMENT
__Mbst$ = -12						; size = 8
__Wc$ = -4						; size = 2
__Byte$ = 8						; size = 1
?_Dowiden@?$ctype@_W@std@@IBE_WD@Z PROC			; std::ctype<wchar_t>::_Dowiden, COMDAT
; _this$ = ecx

; 2743 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2744 : 		_Mbstinit(_Mbst);
; 2745 : 		wchar_t _Wc;
; 2746 : 		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0

  00006	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	50		 push	 eax
  0000d	8d 45 f4	 lea	 eax, DWORD PTR __Mbst$[ebp]
  00010	66 0f d6 45 f4	 movq	 QWORD PTR __Mbst$[ebp], xmm0
  00015	50		 push	 eax
  00016	6a 01		 push	 1
  00018	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  0001b	50		 push	 eax
  0001c	8d 45 fc	 lea	 eax, DWORD PTR __Wc$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 __Mbrtowc
  00025	0f b7 4d fc	 movzx	 ecx, WORD PTR __Wc$[ebp]
  00029	83 c4 14	 add	 esp, 20			; 00000014H
  0002c	85 c0		 test	 eax, eax
  0002e	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00033	0f 48 ca	 cmovs	 ecx, edx
  00036	66 8b c1	 mov	 ax, cx

; 2747 : 			? (wchar_t)WEOF : _Wc);
; 2748 : 		}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Dowiden@?$ctype@_W@std@@IBE_WD@Z ENDP			; std::ctype<wchar_t>::_Dowiden
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv131 = 12						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z PROC	; std::ctype<wchar_t>::do_toupper, COMDAT
; _this$ = ecx

; 2735 : 		{	// convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	43		 inc	 ebx
  00010	d1 eb		 shr	 ebx, 1
  00012	57		 push	 edi
  00013	33 ff		 xor	 edi, edi
  00015	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00018	0f 47 da	 cmova	 ebx, edx

; 2736 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2737 : 		for (; _First != _Last; ++_First)

  0001b	85 db		 test	 ebx, ebx
  0001d	74 21		 je	 SHORT $LN10@do_toupper
  0001f	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00022	89 45 0c	 mov	 DWORD PTR tv131[ebp], eax
$LL4@do_toupper:

; 2738 : 			*_First = _Towupper(*_First, &_Ctype);

  00025	50		 push	 eax
  00026	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 __Towupper
  0002f	66 89 06	 mov	 WORD PTR [esi], ax
  00032	47		 inc	 edi
  00033	8b 45 0c	 mov	 eax, DWORD PTR tv131[ebp]
  00036	83 c4 08	 add	 esp, 8
  00039	83 c6 02	 add	 esi, 2
  0003c	3b fb		 cmp	 edi, ebx
  0003e	75 e5		 jne	 SHORT $LL4@do_toupper
$LN10@do_toupper:
  00040	5f		 pop	 edi

; 2739 : 		return ((const _Elem *)_First);

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 2740 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z ENDP	; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?do_toupper@?$ctype@_W@std@@MBE_W_W@Z PROC		; std::ctype<wchar_t>::do_toupper, COMDAT
; _this$ = ecx

; 2729 : 		{	// convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2730 : 		return (_Towupper(_Ch, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Towupper
  0000f	83 c4 08	 add	 esp, 8

; 2731 : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?do_toupper@?$ctype@_W@std@@MBE_W_W@Z ENDP		; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv131 = 12						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z PROC	; std::ctype<wchar_t>::do_tolower, COMDAT
; _this$ = ecx

; 2721 : 		{	// convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	43		 inc	 ebx
  00010	d1 eb		 shr	 ebx, 1
  00012	57		 push	 edi
  00013	33 ff		 xor	 edi, edi
  00015	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00018	0f 47 da	 cmova	 ebx, edx

; 2722 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2723 : 		for (; _First != _Last; ++_First)

  0001b	85 db		 test	 ebx, ebx
  0001d	74 21		 je	 SHORT $LN10@do_tolower
  0001f	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00022	89 45 0c	 mov	 DWORD PTR tv131[ebp], eax
$LL4@do_tolower:

; 2724 : 			*_First = _Towlower(*_First, &_Ctype);

  00025	50		 push	 eax
  00026	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 __Towlower
  0002f	66 89 06	 mov	 WORD PTR [esi], ax
  00032	47		 inc	 edi
  00033	8b 45 0c	 mov	 eax, DWORD PTR tv131[ebp]
  00036	83 c4 08	 add	 esp, 8
  00039	83 c6 02	 add	 esi, 2
  0003c	3b fb		 cmp	 edi, ebx
  0003e	75 e5		 jne	 SHORT $LL4@do_tolower
$LN10@do_tolower:
  00040	5f		 pop	 edi

; 2725 : 		return ((const _Elem *)_First);

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 2726 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z ENDP	; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?do_tolower@?$ctype@_W@std@@MBE_W_W@Z PROC		; std::ctype<wchar_t>::do_tolower, COMDAT
; _this$ = ecx

; 2715 : 		{	// convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2716 : 		return (_Towlower(_Ch, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Towlower
  0000f	83 c4 08	 add	 esp, 8

; 2717 : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?do_tolower@?$ctype@_W@std@@MBE_W_W@Z ENDP		; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_not, COMDAT
; _this$ = ecx

; 2707 : 		{	// find first in [_First, _Last) not fitting mask classification

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2708 : 		_DEBUG_RANGE(_First, _Last);
; 2709 : 		for (; _First != _Last && is(_Maskval, *_First); ++_First)

  00005	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 1b		 je	 SHORT $LN12@do_scan_no
$LL4@do_scan_no:
  00012	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00015	8b cb		 mov	 ecx, ebx
  00017	8b 13		 mov	 edx, DWORD PTR [ebx]
  00019	50		 push	 eax
  0001a	ff 75 08	 push	 DWORD PTR __Maskval$[ebp]
  0001d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00020	ff d0		 call	 eax
  00022	84 c0		 test	 al, al
  00024	74 07		 je	 SHORT $LN12@do_scan_no
  00026	83 c6 02	 add	 esi, 2
  00029	3b f7		 cmp	 esi, edi
  0002b	75 e5		 jne	 SHORT $LL4@do_scan_no
$LN12@do_scan_no:
  0002d	5f		 pop	 edi

; 2710 : 			;
; 2711 : 		return (_First);

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx

; 2712 : 		}

  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_not
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_is, COMDAT
; _this$ = ecx

; 2698 : 		{	// find first in [_First, _Last) that fits mask classification

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2699 : 		_DEBUG_RANGE(_First, _Last);
; 2700 : 		for (; _First != _Last && !is(_Maskval, *_First); ++_First)

  00005	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 1b		 je	 SHORT $LN12@do_scan_is
$LL4@do_scan_is:
  00012	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00015	8b cb		 mov	 ecx, ebx
  00017	8b 13		 mov	 edx, DWORD PTR [ebx]
  00019	50		 push	 eax
  0001a	ff 75 08	 push	 DWORD PTR __Maskval$[ebp]
  0001d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00020	ff d0		 call	 eax
  00022	84 c0		 test	 al, al
  00024	75 07		 jne	 SHORT $LN12@do_scan_is
  00026	83 c6 02	 add	 esi, 2
  00029	3b f7		 cmp	 esi, edi
  0002b	75 e5		 jne	 SHORT $LL4@do_scan_is
$LN12@do_scan_is:
  0002d	5f		 pop	 edi

; 2701 : 			;
; 2702 : 		return (_First);

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx

; 2703 : 		}

  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z PROC		; std::ctype<wchar_t>::do_is, COMDAT
; _this$ = ecx

; 2691 : 		{	// get mask sequence for elements in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2692 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2693 : 		return (_CSTD _Getwctypes(_First, _Last, _Dest, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 __Getwctypes
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2694 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z ENDP		; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MBE_NF_W@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 2
?do_is@?$ctype@_W@std@@MBE_NF_W@Z PROC			; std::ctype<wchar_t>::do_is, COMDAT
; _this$ = ecx

; 2685 : 		{	// test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2686 : 		return ((_CSTD _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Getwctype
  0000f	83 c4 08	 add	 esp, 8
  00012	66 85 45 08	 test	 WORD PTR __Maskval$[ebp], ax
  00016	0f 95 c0	 setne	 al

; 2687 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?do_is@?$ctype@_W@std@@MBE_NF_W@Z ENDP			; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Init@?$ctype@_W@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -60						; size = 44
$T2 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@_W@std@@IAEXABV_Locinfo@2@@Z PROC	; std::ctype<wchar_t>::_Init, COMDAT
; _this$ = ecx

; 2679 : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 2680 : 		_Ctype = _Lobj._Getctype();

  00006	8d 45 f0	 lea	 eax, DWORD PTR $T2[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 __Getctype
  00012	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]

; 2681 : 		_Cvt = _Lobj._Getcvt();

  00015	8d 45 c4	 lea	 eax, DWORD PTR $T1[ebp]
  00018	50		 push	 eax
  00019	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0001d	e8 00 00 00 00	 call	 __Getcvt
  00022	83 c4 08	 add	 esp, 8
  00025	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00028	0f 11 46 18	 movups	 XMMWORD PTR [esi+24], xmm0
  0002c	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00030	0f 11 46 28	 movups	 XMMWORD PTR [esi+40], xmm0
  00034	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  00039	66 0f d6 46 38	 movq	 QWORD PTR [esi+56], xmm0
  0003e	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00041	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00044	5e		 pop	 esi

; 2682 : 		}

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?_Init@?$ctype@_W@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::ctype<wchar_t>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1?$ctype@_W@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@_W@std@@MAE@XZ PROC				; std::ctype<wchar_t>::~ctype<wchar_t>, COMDAT
; _this$ = ecx

; 2671 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2672 : 		if (_Ctype._Delfl)

  00003	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  0000d	74 0b		 je	 SHORT $LN2@ctype

; 2673 : 			_CSTD free((void *)_Ctype._Table);

  0000f	ff 76 0c	 push	 DWORD PTR [esi+12]
  00012	e8 00 00 00 00	 call	 _free
  00017	83 c4 04	 add	 esp, 4
$LN2@ctype:

; 2674 : 
; 2675 : 		_CSTD free(_Ctype._LocaleName);

  0001a	ff 76 14	 push	 DWORD PTR [esi+20]
  0001d	e8 00 00 00 00	 call	 _free
  00022	83 c4 04	 add	 esp, 4

; 2676 : 		}

  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002b	5e		 pop	 esi
  0002c	c3		 ret	 0
??1?$ctype@_W@std@@MAE@XZ ENDP				; std::ctype<wchar_t>::~ctype<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<wchar_t>::_Getcat, COMDAT

; 2662 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2663 : 		if (_Ppf != 0 && *_Ppf == 0)

  00028	8b 75 08	 mov	 esi, DWORD PTR __Ppf$[ebp]
  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00030	85 f6		 test	 esi, esi
  00032	74 60		 je	 SHORT $LN19@Getcat
  00034	39 1e		 cmp	 DWORD PTR [esi], ebx
  00036	75 5c		 jne	 SHORT $LN19@Getcat

; 2664 : 			*_Ppf = new ctype<_Elem>(

  00038	6a 44		 push	 68			; 00000044H
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f8		 mov	 edi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 7d 08	 mov	 DWORD PTR $T4[ebp], edi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 ff		 test	 edi, edi
  0004c	74 35		 je	 SHORT $LN4@Getcat
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00051	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	6a 00		 push	 0
  00074	50		 push	 eax
  00075	8b cf		 mov	 ecx, edi
  00077	bb 01 00 00 00	 mov	 ebx, 1
  0007c	e8 00 00 00 00	 call	 ??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z ; std::ctype<wchar_t>::ctype<wchar_t>
  00081	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00083	33 c0		 xor	 eax, eax
$LN5@Getcat:
  00085	89 06		 mov	 DWORD PTR [esi], eax
  00087	f6 c3 01	 test	 bl, 1
  0008a	74 08		 je	 SHORT $LN19@Getcat
  0008c	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0008f	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN19@Getcat:

; 2665 : 				_Locinfo(_Ploc->c_str()));
; 2666 : 		return (_X_CTYPE);

  00094	b8 02 00 00 00	 mov	 eax, 2

; 2667 : 		}

  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 44		 push	 68			; 00000044H
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<wchar_t>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T1 = -64						; size = 44
$T2 = -20						; size = 16
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<wchar_t>::ctype<wchar_t>, COMDAT
; _this$ = ecx

; 2656 : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 2655 : 		: ctype_base(_Refs)

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00009	56		 push	 esi

; 2656 : 		{	// construct from specified locale

  0000a	8b f1		 mov	 esi, ecx
  0000c	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2657 : 		_Init(_Lobj);

  00012	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00015	50		 push	 eax
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  0001c	e8 00 00 00 00	 call	 __Getctype
  00021	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00024	8d 45 c0	 lea	 eax, DWORD PTR $T1[ebp]
  00027	50		 push	 eax
  00028	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0002c	e8 00 00 00 00	 call	 __Getcvt
  00031	83 c4 08	 add	 esp, 8
  00034	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00037	0f 11 46 18	 movups	 XMMWORD PTR [esi+24], xmm0
  0003b	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0003f	0f 11 46 28	 movups	 XMMWORD PTR [esi+40], xmm0
  00043	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  00048	66 0f d6 46 38	 movq	 QWORD PTR [esi+56], xmm0
  0004d	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00050	89 46 40	 mov	 DWORD PTR [esi+64], eax

; 2658 : 		}

  00053	8b c6		 mov	 eax, esi
  00055	5e		 pop	 esi
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<wchar_t>::ctype<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@_W@std@@QBEPBDPBD0PA_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@_W@std@@QBEPBDPBD0PA_W@Z PROC		; std::ctype<wchar_t>::widen, COMDAT
; _this$ = ecx

; 2629 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2630 : 		return (do_widen(_First, _Last, _Dest));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2631 : 		}

  00005	5d		 pop	 ebp

; 2630 : 		return (do_widen(_First, _Last, _Dest));

  00006	ff 60 2c	 jmp	 DWORD PTR [eax+44]
?widen@?$ctype@_W@std@@QBEPBDPBD0PA_W@Z ENDP		; std::ctype<wchar_t>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@_W@std@@QBE_WD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?widen@?$ctype@_W@std@@QBE_WD@Z PROC			; std::ctype<wchar_t>::widen, COMDAT
; _this$ = ecx

; 2623 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2624 : 		return (do_widen(_Byte));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2625 : 		}

  00005	5d		 pop	 ebp

; 2624 : 		return (do_widen(_Byte));

  00006	ff 60 30	 jmp	 DWORD PTR [eax+48]
?widen@?$ctype@_W@std@@QBE_WD@Z ENDP			; std::ctype<wchar_t>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?is@?$ctype@_W@std@@QBE_NF_W@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 2
?is@?$ctype@_W@std@@QBE_NF_W@Z PROC			; std::ctype<wchar_t>::is, COMDAT
; _this$ = ecx

; 2580 : 		{	// test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2581 : 		return (do_is(_Maskval, _Ch));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 2582 : 		}

  00008	5d		 pop	 ebp

; 2581 : 		return (do_is(_Maskval, _Ch));

  00009	ff e0		 jmp	 eax
?is@?$ctype@_W@std@@QBE_NF_W@Z ENDP			; std::ctype<wchar_t>::is
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN13@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2108 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2103 : 		{	// default constructor

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2102 : 		: locale::facet(_Refs)

  00004	8b 45 08	 mov	 eax, DWORD PTR __Refs$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2104 : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Mbst2$ = -24						; size = 8
__Mbst1$ = -16						; size = 8
__Count1$1$ = -8					; size = 4
__Wc$ = -4						; size = 2
__Ptrdest$1$ = 8					; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 740  : 	{	// convert C string to wchar_t sequence using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx

; 741  : 	size_t _Count, _Count1;
; 742  : 	size_t _Wchars;
; 743  : 	const char *_Ptr1;
; 744  : 	int _Bytes;
; 745  : 	wchar_t _Wc;
; 746  : 	_Mbstinit(_Mbst1);
; 747  : 
; 748  : 	_Count1 = _CSTD strlen(_Ptr) + 1;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	8b cb		 mov	 ecx, ebx
  0000f	66 0f d6 45 f0	 movq	 QWORD PTR __Mbst1$[ebp], xmm0
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL22@Maklocstr:
  00020	8a 01		 mov	 al, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL22@Maklocstr
  00027	2b ca		 sub	 ecx, edx

; 749  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;

  00029	33 f6		 xor	 esi, esi
  0002b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0002e	89 45 f8	 mov	 DWORD PTR __Count1$1$[ebp], eax
  00031	8b f8		 mov	 edi, eax
  00033	85 c0		 test	 eax, eax
  00035	74 23		 je	 SHORT $LN14@Maklocstr
$LL4@Maklocstr:

; 751  : 		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)

  00037	ff 75 10	 push	 DWORD PTR __Cvt$[ebp]
  0003a	8d 45 f0	 lea	 eax, DWORD PTR __Mbst1$[ebp]
  0003d	50		 push	 eax
  0003e	57		 push	 edi
  0003f	8d 45 fc	 lea	 eax, DWORD PTR __Wc$[ebp]
  00042	53		 push	 ebx
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 __Mbrtowc
  00049	83 c4 14	 add	 esp, 20			; 00000014H
  0004c	85 c0		 test	 eax, eax
  0004e	7e 07		 jle	 SHORT $LN23@Maklocstr

; 750  : 		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)

  00050	03 d8		 add	 ebx, eax
  00052	46		 inc	 esi
  00053	2b f8		 sub	 edi, eax
  00055	75 e0		 jne	 SHORT $LL4@Maklocstr
$LN23@Maklocstr:
  00057	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN14@Maklocstr:

; 752  : 			break;
; 753  : 	++_Wchars;	// count terminating nul

  0005a	46		 inc	 esi

; 754  : 
; 755  : 	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),

  0005b	6a 02		 push	 2
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 _calloc
  00063	83 c4 08	 add	 esp, 8
  00066	89 45 08	 mov	 DWORD PTR __Ptrdest$1$[ebp], eax

; 756  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 757  : 
; 758  : 	if (!_Ptrdest)

  00069	85 c0		 test	 eax, eax
  0006b	74 44		 je	 SHORT $LN26@Maklocstr

; 760  : 	wchar_t *_Ptrnext = _Ptrdest;

  0006d	0f 57 c0	 xorps	 xmm0, xmm0
  00070	8b f8		 mov	 edi, eax

; 761  : 	_Mbstinit(_Mbst2);

  00072	66 0f d6 45 e8	 movq	 QWORD PTR __Mbst2$[ebp], xmm0

; 762  : 
; 763  :  #pragma warning(push)
; 764  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 765  : 	for (; 0 < _Wchars;

  00077	85 f6		 test	 esi, esi
  00079	74 2a		 je	 SHORT $LN15@Maklocstr
  0007b	0f 1f 44 00 00	 npad	 5
$LL7@Maklocstr:

; 767  : 		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)

  00080	ff 75 10	 push	 DWORD PTR __Cvt$[ebp]
  00083	8d 45 e8	 lea	 eax, DWORD PTR __Mbst2$[ebp]
  00086	50		 push	 eax
  00087	ff 75 f8	 push	 DWORD PTR __Count1$1$[ebp]
  0008a	53		 push	 ebx
  0008b	57		 push	 edi
  0008c	e8 00 00 00 00	 call	 __Mbrtowc
  00091	83 c4 14	 add	 esp, 20			; 00000014H
  00094	85 c0		 test	 eax, eax
  00096	7e 0a		 jle	 SHORT $LN24@Maklocstr

; 766  : 		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)

  00098	03 d8		 add	 ebx, eax
  0009a	83 c7 02	 add	 edi, 2
  0009d	83 ee 01	 sub	 esi, 1
  000a0	75 de		 jne	 SHORT $LL7@Maklocstr
$LN24@Maklocstr:
  000a2	8b 45 08	 mov	 eax, DWORD PTR __Ptrdest$1$[ebp]
$LN15@Maklocstr:

; 768  : 			break;
; 769  : 	*_Ptrnext = L'\0';

  000a5	33 c9		 xor	 ecx, ecx
  000a7	66 89 0f	 mov	 WORD PTR [edi], cx
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx

; 770  :  #pragma warning(pop)
; 771  : 
; 772  : 	return (_Ptrdest);
; 773  : 	}

  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
$LN26@Maklocstr:

; 759  : 		_Xbad_alloc();

  000b1	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN28@Maklocstr:
$LN25@Maklocstr:
  000b6	cc		 int	 3
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Mbst1$ = -12						; size = 8
__Wc$ = -4						; size = 2
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocchr<wchar_t>, COMDAT

; 693  : 	{	// convert char to wchar_t using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 694  : 	wchar_t _Wc = L'\0';
; 695  : 	_Mbstinit(_Mbst1);
; 696  : 	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);

  00006	ff 75 10	 push	 DWORD PTR __Cvt$[ebp]
  00009	8d 45 f4	 lea	 eax, DWORD PTR __Mbst1$[ebp]
  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Wc$[ebp], 0
  00013	50		 push	 eax
  00014	6a 01		 push	 1
  00016	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  00019	0f 57 c0	 xorps	 xmm0, xmm0
  0001c	50		 push	 eax
  0001d	8d 45 fc	 lea	 eax, DWORD PTR __Wc$[ebp]
  00020	66 0f d6 45 f4	 movq	 QWORD PTR __Mbst1$[ebp], xmm0
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 __Mbrtowc

; 697  : 	return (_Wc);

  0002b	66 8b 45 fc	 mov	 ax, WORD PTR __Wc$[ebp]
  0002f	83 c4 14	 add	 esp, 20			; 00000014H

; 698  : 	}

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocchr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Glocale@std@@QAEPAXI@Z PROC				; std::locale::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Glocale@std@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002f	85 c9		 test	 ecx, ecx
  00031	74 11		 je	 SHORT $LN7@scalar
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	ff 50 08	 call	 DWORD PTR [eax+8]
  00038	85 c0		 test	 eax, eax
  0003a	74 08		 je	 SHORT $LN7@scalar
  0003c	8b 10		 mov	 edx, DWORD PTR [eax]
  0003e	8b c8		 mov	 ecx, eax
  00040	6a 01		 push	 1
  00042	ff 12		 call	 DWORD PTR [edx]
$LN7@scalar:
  00044	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00048	74 0b		 je	 SHORT $LN10@scalar
  0004a	6a 08		 push	 8
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00052	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00055	8b c6		 mov	 eax, esi
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Glocale@std@@QAEPAXI@Z$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_Glocale@std@@QAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Glocale@std@@QAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Glocale@std@@QAEPAXI@Z ENDP				; std::locale::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 458  : 		{	// look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 459  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __Id$[ebp]
  0000a	3b 71 0c	 cmp	 esi, DWORD PTR [ecx+12]
  0000d	73 0c		 jae	 SHORT $LN6@Getfacet
  0000f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00012	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 460  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 461  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00015	85 c0		 test	 eax, eax
  00017	75 21		 jne	 SHORT $LN3@Getfacet
  00019	eb 02		 jmp	 SHORT $LN10@Getfacet
$LN6@Getfacet:

; 459  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0001b	33 c0		 xor	 eax, eax
$LN10@Getfacet:

; 460  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 461  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0001d	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00021	74 17		 je	 SHORT $LN3@Getfacet

; 462  : 			return (_Facptr);	// found facet or not transparent
; 463  : 		else
; 464  : 			{	// look in current locale
; 465  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00023	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 466  : 			return (_Id < _Ptr0->_Facetcount

  00028	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  0002b	73 0b		 jae	 SHORT $LN8@Getfacet
  0002d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00030	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00033	5e		 pop	 esi

; 467  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 468  : 				: 0);	// no entry in current locale
; 469  : 			}
; 470  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN8@Getfacet:

; 466  : 			return (_Id < _Ptr0->_Facetcount

  00038	33 c0		 xor	 eax, eax
$LN3@Getfacet:
  0003a	5e		 pop	 esi

; 467  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 468  : 				: 0);	// no entry in current locale
; 469  : 			}
; 470  : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 454  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 06		 jne	 SHORT $LN3@c_str
  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 455  : 		}

  0000c	c3		 ret	 0
$LN3@c_str:

; 454  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

  0000d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00010	85 c9		 test	 ecx, ecx
  00012	74 03		 je	 SHORT $LN7@c_str
  00014	8b c1		 mov	 eax, ecx

; 455  : 		}

  00016	c3		 ret	 0

; 454  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

$LN7@c_str:
  00017	83 c0 1c	 add	 eax, 28			; 0000001cH

; 455  : 		}

  0001a	c3		 ret	 0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 430  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1locale@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 431  : 		if (_Ptr != 0)

  00022	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00025	85 c9		 test	 ecx, ecx
  00027	74 11		 je	 SHORT $LN4@locale

; 432  : 			delete _Ptr->_Decref();

  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	ff 50 08	 call	 DWORD PTR [eax+8]
  0002e	85 c0		 test	 eax, eax
  00030	74 08		 je	 SHORT $LN4@locale
  00032	8b 10		 mov	 edx, DWORD PTR [eax]
  00034	8b c8		 mov	 ecx, eax
  00036	6a 01		 push	 1
  00038	ff 12		 call	 DWORD PTR [edx]
$LN4@locale:

; 433  : 		}

  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1locale@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1locale@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = ecx

; 331  : 		{	// construct from current locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0locale@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 330  : 		: _Ptr(_Init(true))

  00025	6a 01		 push	 1
  00027	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002f	83 c4 04	 add	 esp, 4

; 332  : 		}

  00032	8b c6		 mov	 eax, esi
  00034	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00037	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003e	59		 pop	 ecx
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 325  : 		{	// construct by copying

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0locale@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 324  : 		: _Ptr(_Right._Ptr)

  00025	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00028	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 326  : 		_Ptr->_Incref();

  0002e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00030	ff 50 04	 call	 DWORD PTR [eax+4]

; 327  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00038	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003f	59		 pop	 ecx
  00040	5e		 pop	 esi
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
; Function compile flags: /Ogtp
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN10@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 172  : 			}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 165  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 166  : 			{	// construct with initial reference count
; 167  : 			_Init_atomic_counter(_Myrefs, (_Atomic_integral_t)_Initrefs);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Initrefs$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 168  : 			}

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 155  : 			if (_MT_DECR(_Myrefs) == 0)

  00000	83 c8 ff	 or	 eax, -1
  00003	f0 0f c1 41 04	 lock	  xadd	 DWORD PTR [ecx+4], eax
  00008	b8 00 00 00 00	 mov	 eax, 0
  0000d	0f 44 c1	 cmove	 eax, ecx

; 156  : 				return (this);
; 157  : 			else
; 158  : 				return (0);
; 159  : 			}

  00010	c3		 ret	 0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 150  : 			_MT_INCR(_Myrefs);

  00000	f0 ff 41 04	 lock	  inc	 DWORD PTR [ecx+4]

; 151  : 			}

  00004	c3		 ret	 0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 114  : 			{	// get stamp, with lazy allocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 115  : 			if (_Id == 0)

  00007	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000a	75 24		 jne	 SHORT $LN6@operator

; 116  : 				{	// still zero, allocate stamp
; 117  : 				_BEGIN_LOCK(_LOCK_LOCALE)

  0000c	6a 00		 push	 0
  0000e	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 118  : 					if (_Id == 0)

  00016	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00019	75 0d		 jne	 SHORT $LN3@operator

; 119  : 						_Id = ++_Id_cnt;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00020	40		 inc	 eax
  00021	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00026	89 06		 mov	 DWORD PTR [esi], eax
$LN3@operator:

; 120  : 				_END_LOCK()

  00028	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  0002b	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN6@operator:

; 121  : 				}
; 122  : 			return (_Id);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	5e		 pop	 esi

; 123  : 			}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 110  : 			{	// construct with specified stamp value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 109  : 			: _Id(_Val)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 111  : 			}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 04		 push	 4
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 24   : 		{	// ensure that derived classes can be destroyed properly

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@

; 25   : 		}

  00006	c3		 ret	 0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 3796 : 		{	// discard any string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3797 : 		if (_Myptr != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN4@Tidy

; 3798 : 
; 3799 :  #ifdef _DEBUG
; 3800 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3801 : 
; 3802 :  #else /* _DEBUG */
; 3803 : 			_CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 3804 :  #endif /* _DEBUG */
; 3805 : 
; 3806 : 		_Myptr = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3807 : 		}

  00019	c3		 ret	 0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3770 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3771 : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Yarn
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN6@Yarn:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3772 : 		}

  00019	c3		 ret	 0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3719 : 		: _Myptr(0), _Nul(0)

  00000	33 c0		 xor	 eax, eax
  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00008	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 3721 : 		}

  0000c	8b c1		 mov	 eax, ecx
  0000e	c3		 ret	 0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3796 : 		{	// discard any string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3797 : 		if (_Myptr != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN4@Tidy

; 3798 : 
; 3799 :  #ifdef _DEBUG
; 3800 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3801 : 
; 3802 :  #else /* _DEBUG */
; 3803 : 			_CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 3804 :  #endif /* _DEBUG */
; 3805 : 
; 3806 : 		_Myptr = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3807 : 		}

  00019	c3		 ret	 0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3781 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 03		 jne	 SHORT $LN4@c_str
  00006	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 3782 : 		}

  00009	c3		 ret	 0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3770 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3771 : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Yarn
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN6@Yarn:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3772 : 		}

  00019	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 3719 : 		: _Myptr(0), _Nul(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 3721 : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  0000c	c3		 ret	 0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 172  : 		return ("true");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04LOAJBDKD@true?$AA@

; 173  : 		}

  00005	c3		 ret	 0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 167  : 		return ("false");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05LAPONLG@false?$AA@

; 168  : 		}

  00005	c3		 ret	 0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 127  : 		return (localeconv());

  00000	e9 00 00 00 00	 jmp	 _localeconv
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = -44						; size = 44
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 121  : 		{	// return codecvt stuff

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 122  : 		return (::_Getcvt());

  00006	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Getcvt
  0000f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00012	83 c4 04	 add	 esp, 4
  00015	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00018	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0001b	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0001e	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00022	0f 11 42 10	 movups	 XMMWORD PTR [edx+16], xmm0
  00026	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  0002b	8b c2		 mov	 eax, edx
  0002d	66 0f d6 42 20	 movq	 QWORD PTR [edx+32], xmm0
  00032	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 123  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 116  : 		{	// return ctype stuff

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 117  : 		return (::_Getctype());

  00006	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Getctype
  0000f	83 c4 04	 add	 esp, 4
  00012	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 118  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Locinfo@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 95   : 		_Locinfo_dtor(this);

  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 96   : 		}

  0002b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	74 09		 je	 SHORT $LN7@Locinfo
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _free
  0003b	83 c4 04	 add	 esp, 4
$LN7@Locinfo:
  0003e	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  00045	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00048	85 c0		 test	 eax, eax
  0004a	74 09		 je	 SHORT $LN13@Locinfo
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _free
  00052	83 c4 04	 add	 esp, 4
$LN13@Locinfo:
  00055	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  0005c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0005f	85 c0		 test	 eax, eax
  00061	74 09		 je	 SHORT $LN19@Locinfo
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _free
  00069	83 c4 04	 add	 esp, 4
$LN19@Locinfo:
  0006c	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00073	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00076	85 c0		 test	 eax, eax
  00078	74 09		 je	 SHORT $LN25@Locinfo
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _free
  00080	83 c4 04	 add	 esp, 4
$LN25@Locinfo:
  00083	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0008a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0008d	85 c0		 test	 eax, eax
  0008f	74 09		 je	 SHORT $LN31@Locinfo
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _free
  00097	83 c4 04	 add	 esp, 4
$LN31@Locinfo:
  0009a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  000a1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a4	85 c0		 test	 eax, eax
  000a6	74 09		 je	 SHORT $LN37@Locinfo
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _free
  000ae	83 c4 04	 add	 esp, 4
$LN37@Locinfo:
  000b1	8b ce		 mov	 ecx, esi
  000b3	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  000ba	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	5e		 pop	 esi
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__InitData$3 = -24					; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 76   : 		{	// construct from NTBS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 73   : 		: _Lock(_LOCK_LOCALE)

  0002b	6a 00		 push	 0
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 76   : 		{	// construct from NTBS

  00039	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00040	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
  00044	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0004b	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0004f	33 c0		 xor	 eax, eax
  00051	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00058	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  0005c	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0005f	66 89 46 20	 mov	 WORD PTR [esi+32], ax
  00063	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00066	88 46 28	 mov	 BYTE PTR [esi+40], al
  00069	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0006c	88 46 30	 mov	 BYTE PTR [esi+48], al

; 77   : 		if (_Pch == 0)

  0006f	8b 45 08	 mov	 eax, DWORD PTR __Pch$[ebp]
  00072	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00076	85 c0		 test	 eax, eax
  00078	75 3f		 jne	 SHORT $LN2@Locinfo

; 78   : 			_THROW_NCEE(runtime_error, "bad locale name");

  0007a	8d 45 e0	 lea	 eax, DWORD PTR $T2[ebp+4]
  0007d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7exception@std@@6B@
  00084	50		 push	 eax
  00085	8d 45 e8	 lea	 eax, DWORD PTR __InitData$3[ebp]
  00088	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __InitData$3[ebp], OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
  0008f	0f 57 c0	 xorps	 xmm0, xmm0
  00092	c6 45 ec 01	 mov	 BYTE PTR __InitData$3[ebp+4], 1
  00096	50		 push	 eax
  00097	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  0009c	e8 00 00 00 00	 call	 ___std_exception_copy
  000a1	83 c4 08	 add	 esp, 8
  000a4	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7runtime_error@std@@6B@
  000ab	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000ae	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@Locinfo:
$LN2@Locinfo:

; 79   : 		_Locinfo_ctor(this, _Pch);

  000b9	50		 push	 eax
  000ba	56		 push	 esi
  000bb	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  000c0	83 c4 08	 add	 esp, 8

; 80   : 		}

  000c3	8b c6		 mov	 eax, esi
  000c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cf	59		 pop	 ecx
  000d0	5e		 pop	 esi
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 04 00	 ret	 4
$LN28@Locinfo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 24	 add	 ecx, 36			; 00000024H
  0003a	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00045	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  0004a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00051	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00054	33 c8		 xor	 ecx, eax
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Ogtp
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 125  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 126  :     }

  00003	8b c1		 mov	 eax, ecx
  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@
  00017	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 168  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 167  : 		: _Mybase(_Message)

  00006	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	56		 push	 esi

; 168  : 		{	// construct from message string

  0000d	8b f1		 mov	 esi, ecx
  0000f	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00012	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00015	89 45 f8	 mov	 DWORD PTR __InitData$1[ebp], eax
  00018	8d 45 f8	 lea	 eax, DWORD PTR __InitData$1[ebp]
  0001b	52		 push	 edx
  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00022	50		 push	 eax
  00023	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00027	c6 45 fc 01	 mov	 BYTE PTR __InitData$1[ebp+4], 1
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	83 c4 08	 add	 esp, 8
  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 169  : 		}

  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 162  : 		: _Mybase(_Message.c_str())

  00006	8b 55 08	 mov	 edx, DWORD PTR __Message$[ebp]
  00009	56		 push	 esi

; 163  : 		{	// construct from message string

  0000a	8b f1		 mov	 esi, ecx
  0000c	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000f	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00013	72 02		 jb	 SHORT $LN17@runtime_er

; 162  : 		: _Mybase(_Message.c_str())

  00015	8b 12		 mov	 edx, DWORD PTR [edx]
$LN17@runtime_er:
  00017	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00020	0f 57 c0	 xorps	 xmm0, xmm0
  00023	89 55 f8	 mov	 DWORD PTR __InitData$1[ebp], edx
  00026	50		 push	 eax
  00027	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0002b	8d 45 f8	 lea	 eax, DWORD PTR __InitData$1[ebp]
  0002e	50		 push	 eax
  0002f	c6 45 fc 01	 mov	 BYTE PTR __InitData$1[ebp+4], 1
  00033	e8 00 00 00 00	 call	 ___std_exception_copy
  00038	83 c4 08	 add	 esp, 8

; 163  : 		{	// construct from message string

  0003b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 164  : 		}

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 26		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 20		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	8b ce		 mov	 ecx, esi
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00035	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2261 : 		_Eos(_Newsize);

  0003d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00041	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00044	72 0c		 jb	 SHORT $LN92@Tidy
  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 2262 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN92@Tidy:
  00052	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 2262 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2d		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1b		 jb	 SHORT $LN4@Inside
  0001d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	03 c6		 add	 eax, esi
  0002d	3b c2		 cmp	 eax, edx
  0002f	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2244 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2244 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	77 59		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000c	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  0000f	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00011	ff 71 10	 push	 DWORD PTR [ecx+16]
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0001a	85 f6		 test	 esi, esi
  0001c	5e		 pop	 esi
  0001d	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00024	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  00028	74 1f		 je	 SHORT $LN5@Grow
  0002a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0002d	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  0002f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00032	3b f0		 cmp	 esi, eax
  00034	0f 42 c6	 cmovb	 eax, esi
  00037	50		 push	 eax
  00038	6a 01		 push	 1
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0003f	85 f6		 test	 esi, esi
  00041	5e		 pop	 esi
  00042	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  00049	85 f6		 test	 esi, esi
  0004b	75 10		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  0004d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00051	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00054	72 02		 jb	 SHORT $LN80@Grow
  00056	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  00058	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0005b	85 f6		 test	 esi, esi
$LN88@Grow:
  0005d	0f 95 c0	 setne	 al
  00060	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  0006f	cc		 int	 3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0a		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 2220 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0

; 2220 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 0f	 or	 edi, 15			; 0000000fH

; 2184 : 		if (max_size() < _Newres)

  00038	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f8		 mov	 edi, eax
  0003f	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00041	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e7		 mul	 edi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005a	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00063	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  00068	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00072	85 c0		 test	 eax, eax
  00074	75 04		 jne	 SHORT $LN136@Copy
  00076	33 db		 xor	 ebx, ebx
  00078	eb 6d		 jmp	 SHORT $LN19@Copy
$LN136@Copy:
  0007a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007f	72 29		 jb	 SHORT $LN138@Copy
  00081	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00084	3b c8		 cmp	 ecx, eax
  00086	77 05		 ja	 SHORT $LN140@Copy
  00088	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN435@Copy:
$LN140@Copy:
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00093	83 c4 04	 add	 esp, 4
  00096	85 c0		 test	 eax, eax
  00098	75 05		 jne	 SHORT $LN141@Copy
  0009a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN436@Copy:
$LN141@Copy:
  0009f	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000a2	83 e3 e0	 and	 ebx, -32		; ffffffe0H
  000a5	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  000a8	eb 3d		 jmp	 SHORT $LN19@Copy
$LN138@Copy:
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b0	8b d8		 mov	 ebx, eax
  000b2	83 c4 04	 add	 esp, 4
  000b5	85 db		 test	 ebx, ebx
  000b7	75 2e		 jne	 SHORT $LN19@Copy
  000b9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN437@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000be	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  000c7	40		 inc	 eax
  000c8	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000cb	50		 push	 eax
  000cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000d0	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000d5	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  000d8	b8 00 00 00 00	 mov	 eax, $LN432@Copy
  000dd	c3		 ret	 0
$LN432@Copy:
  000de	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000e1	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000e4	8b 5d e8	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000e7	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  000ea	85 c0		 test	 eax, eax
  000ec	74 1b		 je	 SHORT $LN270@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000ee	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000f2	72 04		 jb	 SHORT $LN261@Copy
  000f4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f6	eb 02		 jmp	 SHORT $LN262@Copy
$LN261@Copy:
  000f8	8b ce		 mov	 ecx, esi
$LN262@Copy:
  000fa	85 c0		 test	 eax, eax
  000fc	74 0b		 je	 SHORT $LN270@Copy
  000fe	50		 push	 eax
  000ff	51		 push	 ecx
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _memcpy
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN270@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  00109	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0010c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010f	72 0b		 jb	 SHORT $LN274@Copy
  00111	40		 inc	 eax
  00112	8b ce		 mov	 ecx, esi
  00114	50		 push	 eax
  00115	ff 36		 push	 DWORD PTR [esi]
  00117	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN274@Copy:
  0011c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00123	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00127	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0012e	72 04		 jb	 SHORT $LN362@Copy
  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	eb 02		 jmp	 SHORT $LN363@Copy
$LN362@Copy:
  00134	8b c6		 mov	 eax, esi
$LN363@Copy:
  00136	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);
; 2212 : 		this->_Myres() = _Newres;
; 2213 : 		_Eos(_Oldlen);

  00139	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  0013c	89 1e		 mov	 DWORD PTR [esi], ebx
  0013e	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00141	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00145	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00148	72 02		 jb	 SHORT $LN426@Copy
  0014a	8b f3		 mov	 esi, ebx
$LN426@Copy:
  0014c	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 2214 : 		}

  00150	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00153	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015a	59		 pop	 ecx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00164	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00167	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0016a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0016d	72 0b		 jb	 SHORT $LN156@Copy
  0016f	40		 inc	 eax
  00170	8b ce		 mov	 ecx, esi
  00172	50		 push	 eax
  00173	ff 36		 push	 DWORD PTR [esi]
  00175	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN156@Copy:
  0017a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00181	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00185	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0018c	72 02		 jb	 SHORT $LN245@Copy
  0018e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN245@Copy:

; 2203 : 			_RERAISE;

  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	c6 06 00	 mov	 BYTE PTR [esi], 0
  00197	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN438@Copy:
$LN434@Copy:
  0019c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2175 : 		if (_Count == 1)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	83 f8 01	 cmp	 eax, 1
  0000b	75 15		 jne	 SHORT $LN2@Chassign

; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);

  0000d	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00011	72 02		 jb	 SHORT $LN16@Chassign
  00013	8b 12		 mov	 edx, DWORD PTR [edx]
$LN16@Chassign:
  00015	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00018	8a 4d 10	 mov	 cl, BYTE PTR __Ch$[ebp]
  0001b	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2179 : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Chassign:

; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

  00022	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00026	72 02		 jb	 SHORT $LN33@Chassign
  00028	8b 12		 mov	 edx, DWORD PTR [edx]
$LN33@Chassign:
  0002a	50		 push	 eax
  0002b	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0002f	50		 push	 eax
  00030	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00033	03 c2		 add	 eax, edx
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _memset
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2179 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1803 : 		{	// test if sequence is empty

  00000	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00004	0f 94 c0	 sete	 al

; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}

  00007	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1780 : 		{	// determine new length, padding with _Ch elements as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1781 : 		if (_Newsize <= this->_Mysize())

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	77 13		 ja	 SHORT $LN2@resize

; 1782 : 			_Eos(_Newsize);

  0000d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00010	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00014	72 02		 jb	 SHORT $LN25@resize
  00016	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN25@resize:
  00018	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1785 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
$LN2@resize:

; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

  00020	2b c2		 sub	 eax, edx
  00022	89 45 08	 mov	 DWORD PTR __Newsize$[ebp], eax

; 1785 : 		}

  00025	5d		 pop	 ebp

; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

  00026	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1775 : 		{	// determine new length, padding with null elements as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1776 : 		resize(_Newsize, _Elem());

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	77 13		 ja	 SHORT $LN4@resize
  0000d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00010	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00014	72 02		 jb	 SHORT $LN27@resize
  00016	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN27@resize:
  00018	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1777 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 1776 : 		resize(_Newsize, _Elem());

$LN4@resize:
  00020	6a 00		 push	 0
  00022	2b c2		 sub	 eax, edx
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1777 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1766 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1692 : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1693 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1694 : 		if (this->_Mysize() < _Off)	// sic
; 1695 : 			_DEBUG_ERROR("string subscript out of range");
; 1696 : 
; 1697 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1698 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1699 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1700 : 
; 1701 : 		return (this->_Myptr()[_Off]);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	72 02		 jb	 SHORT $LN13@operator
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@operator:
  0000e	03 c1		 add	 eax, ecx

; 1702 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	72 7e		 jb	 SHORT $LN93@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00014	8b c7		 mov	 eax, edi
  00016	2b c1		 sub	 eax, ecx
  00018	3b c2		 cmp	 eax, edx
  0001a	77 23		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  0001c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0001f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00023	72 0e		 jb	 SHORT $LN41@erase
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5f		 pop	 edi
  00028	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1357 : 			}
; 1358 : 		return (*this);

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 1359 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1359 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  0003f	85 d2		 test	 edx, edx
  00041	74 44		 je	 SHORT $LN90@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  00043	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00047	72 04		 jb	 SHORT $LN58@erase
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  0004d	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  0004f	2b fa		 sub	 edi, edx
  00051	53		 push	 ebx
  00052	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00055	8b c7		 mov	 eax, edi
  00057	2b c1		 sub	 eax, ecx
  00059	74 0e		 je	 SHORT $LN74@erase
  0005b	50		 push	 eax
  0005c	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0005f	50		 push	 eax
  00060	53		 push	 ebx
  00061	e8 00 00 00 00	 call	 _memmove
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00069	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00070	5b		 pop	 ebx
  00071	72 0e		 jb	 SHORT $LN85@erase
  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1357 : 			}
; 1358 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1359 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN85@erase:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN90@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi

; 1359 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN93@erase:

; 1348 : 		_Check_offset(_Off);

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00094	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN95@erase:
$LN92@erase:
  00099	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 21		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00012	72 0c		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 1344 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00020	8b d1		 mov	 edx, ecx
  00022	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  00026	8b c1		 mov	 eax, ecx

; 1344 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  00036	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@assign
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1183 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@assign:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@assign
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1183 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@assign
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN57@assign
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1177 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1168 : 			return (assign(*this,

$LN57@assign:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1177 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@assign:
  00065	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00066	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00069	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006c	77 7d		 ja	 SHORT $LN187@assign
  0006e	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00071	73 19		 jae	 SHORT $LN63@assign
  00073	ff 76 10	 push	 DWORD PTR [esi+16]
  00076	8b ce		 mov	 ecx, esi
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0007e	85 ff		 test	 edi, edi
  00080	74 60		 je	 SHORT $LN181@assign
$LN186@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  00082	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00086	72 2b		 jb	 SHORT $LN158@assign
  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	eb 29		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  0008c	85 ff		 test	 edi, edi
  0008e	75 f2		 jne	 SHORT $LN186@assign
  00090	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00094	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00097	72 0e		 jb	 SHORT $LN140@assign
  00099	8b 06		 mov	 eax, DWORD PTR [esi]
  0009b	5f		 pop	 edi
  0009c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1175 : 			}
; 1176 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 1177 : 		}

  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a7	8b c6		 mov	 eax, esi
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1177 : 		}

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000b3	8b c6		 mov	 eax, esi
$LN159@assign:
  000b5	85 ff		 test	 edi, edi
  000b7	74 0b		 je	 SHORT $LN165@assign
  000b9	57		 push	 edi
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000cb	72 0f		 jb	 SHORT $LN176@assign
  000cd	8b 06		 mov	 eax, DWORD PTR [esi]
  000cf	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1175 : 			}
; 1176 : 		return (*this);

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 1177 : 		}

  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN176@assign:
  000dc	8b c6		 mov	 eax, esi
  000de	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN181@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e2	5f		 pop	 edi
  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1177 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN187@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f0	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN189@assign:
$LN184@assign:
  000f5	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e9 00 00
	00		 jb	 $LN208@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 47		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d9 00 00
	00		 jb	 $LN210@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0003a	72 19		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	51		 push	 ecx
  0003f	6a 00		 push	 0
  00041	8b ce		 mov	 ecx, esi
  00043	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00047	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0004c	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 1162 : 		}

  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

$LN63@assign:
  00055	8b d6		 mov	 edx, esi
  00057	51		 push	 ecx
  00058	6a 00		 push	 0
  0005a	8b ce		 mov	 ecx, esi
  0005c	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00060	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00065	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00066	8b c6		 mov	 eax, esi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 1162 : 		}

  0006a	5d		 pop	 ebp
  0006b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0006e	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00071	0f 87 9f 00 00
	00		 ja	 $LN211@assign
  00077	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0007a	73 24		 jae	 SHORT $LN72@assign
  0007c	ff 76 10	 push	 DWORD PTR [esi+16]
  0007f	8b ce		 mov	 ecx, esi
  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0008a	85 ff		 test	 edi, edi
  0008c	74 6b		 je	 SHORT $LN203@assign
$LN207@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0008e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00092	72 02		 jb	 SHORT $LN166@assign
  00094	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00096	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0009a	72 2b		 jb	 SHORT $LN180@assign
  0009c	8b 16		 mov	 edx, DWORD PTR [esi]
  0009e	eb 29		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  000a0	85 ff		 test	 edi, edi
  000a2	75 ea		 jne	 SHORT $LN207@assign
  000a4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ab	72 0e		 jb	 SHORT $LN149@assign
  000ad	8b 06		 mov	 eax, DWORD PTR [esi]
  000af	5f		 pop	 edi
  000b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000b3	8b c6		 mov	 eax, esi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 1162 : 		}

  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000bb	8b c6		 mov	 eax, esi
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1162 : 		}

  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000c7	8b d6		 mov	 edx, esi
$LN181@assign:
  000c9	85 ff		 test	 edi, edi
  000cb	74 0e		 je	 SHORT $LN187@assign
  000cd	57		 push	 edi
  000ce	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000d1	50		 push	 eax
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000db	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000df	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000e2	72 0f		 jb	 SHORT $LN198@assign
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000ea	8b c6		 mov	 eax, esi
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx

; 1162 : 		}

  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN198@assign:
  000f3	8b c6		 mov	 eax, esi
  000f5	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN203@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f9	5f		 pop	 edi
  000fa	8b c6		 mov	 eax, esi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 1162 : 		}

  000fe	5d		 pop	 ebp
  000ff	c2 0c 00	 ret	 12			; 0000000cH
$LN208@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00107	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN212@assign:
$LN210@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00111	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN213@assign:
$LN211@assign:

; 1155 : 		else if (_Grow(_Count))

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN214@assign:
$LN205@assign:
  00120	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1111 : 		{	// append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1112 : 		if (npos - this->_Mysize() <= _Count)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000e	8b c1		 mov	 eax, ecx
  00010	f7 d0		 not	 eax
  00012	3b c3		 cmp	 eax, ebx
  00014	76 7a		 jbe	 SHORT $LN141@append

; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

  00016	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]

; 1116 : 		if (0 < _Count && _Grow(_Num))

  00019	85 db		 test	 ebx, ebx
  0001b	74 6a		 je	 SHORT $LN136@append
  0001d	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00020	77 78		 ja	 SHORT $LN143@append
  00022	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00025	73 33		 jae	 SHORT $LN28@append
  00027	51		 push	 ecx
  00028	57		 push	 edi
  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00030	85 ff		 test	 edi, edi
  00032	74 53		 je	 SHORT $LN136@append
$LN140@append:

; 1117 : 			{	// make room and append new stuff using assign
; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

  00034	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00037	8b ce		 mov	 ecx, esi
  00039	53		 push	 ebx
  0003a	ff 76 10	 push	 DWORD PTR [esi+16]
  0003d	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1119 : 			_Eos(_Num);

  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00049	72 36		 jb	 SHORT $LN131@append
  0004b	8b 06		 mov	 eax, DWORD PTR [esi]
  0004d	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1120 : 			}
; 1121 : 		return (*this);

  00051	8b c6		 mov	 eax, esi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 1122 : 		}

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8

; 1116 : 		if (0 < _Count && _Grow(_Num))

$LN28@append:
  0005a	85 ff		 test	 edi, edi
  0005c	75 d6		 jne	 SHORT $LN140@append
  0005e	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00061	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00065	72 0e		 jb	 SHORT $LN105@append
  00067	8b 06		 mov	 eax, DWORD PTR [esi]
  00069	5f		 pop	 edi
  0006a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1120 : 			}
; 1121 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 1122 : 		}

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8

; 1116 : 		if (0 < _Count && _Grow(_Num))

$LN105@append:
  00075	8b c6		 mov	 eax, esi
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1122 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1119 : 			_Eos(_Num);

$LN131@append:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN136@append:

; 1120 : 			}
; 1121 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1122 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
$LN141@append:

; 1113 : 			_Xlen();	// result too long

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00095	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN144@append:
$LN143@append:

; 1116 : 		if (0 < _Count && _Grow(_Num))

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0009f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN145@append:
$LN138@append:
  000a4	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@append
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00015	5e		 pop	 esi

; 1108 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

$LN5@append:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@append:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@append
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00031	5e		 pop	 esi

; 1108 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1088 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1089 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@append
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN21@append
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN22@append
$LN21@append:
  0001a	8b c6		 mov	 eax, esi
$LN22@append:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@append
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN35@append
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN36@append
$LN35@append:
  00029	8b d6		 mov	 edx, esi
$LN36@append:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@append

; 1090 : 			return (append(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN58@append
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1102 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1090 : 			return (append(*this,

$LN58@append:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1102 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

  00065	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00068	8b c2		 mov	 eax, edx
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0006d	f7 d0		 not	 eax
  0006f	3b c1		 cmp	 eax, ecx
  00071	0f 86 98 00 00
	00		 jbe	 $LN217@append

; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

  00077	57		 push	 edi
  00078	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

  0007b	85 c9		 test	 ecx, ecx
  0007d	0f 84 83 00 00
	00		 je	 $LN211@append
  00083	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00086	0f 87 8d 00 00
	00		 ja	 $LN219@append
  0008c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0008f	73 1a		 jae	 SHORT $LN85@append
  00091	52		 push	 edx
  00092	57		 push	 edi
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0009d	85 ff		 test	 edi, edi
  0009f	74 65		 je	 SHORT $LN211@append
$LN216@append:

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

  000a1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a5	72 2b		 jb	 SHORT $LN179@append
  000a7	8b 16		 mov	 edx, DWORD PTR [esi]
  000a9	eb 29		 jmp	 SHORT $LN180@append

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN85@append:
  000ab	85 ff		 test	 edi, edi
  000ad	75 f2		 jne	 SHORT $LN216@append
  000af	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b6	72 0e		 jb	 SHORT $LN162@append
  000b8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ba	5f		 pop	 edi
  000bb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1100 : 			}
; 1101 : 		return (*this);

  000be	8b c6		 mov	 eax, esi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx

; 1102 : 		}

  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN162@append:
  000c6	8b c6		 mov	 eax, esi
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1102 : 		}

  000ce	5d		 pop	 ebp
  000cf	c2 08 00	 ret	 8

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

$LN179@append:
  000d2	8b d6		 mov	 edx, esi
$LN180@append:
  000d4	85 c9		 test	 ecx, ecx
  000d6	74 10		 je	 SHORT $LN195@append
  000d8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000db	51		 push	 ecx
  000dc	03 c2		 add	 eax, edx
  000de	53		 push	 ebx
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _memcpy
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN195@append:

; 1099 : 			_Eos(_Num);

  000e8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000ec	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ef	72 0f		 jb	 SHORT $LN206@append
  000f1	8b 06		 mov	 eax, DWORD PTR [esi]
  000f3	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1100 : 			}
; 1101 : 		return (*this);

  000f7	8b c6		 mov	 eax, esi
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx

; 1102 : 		}

  000fc	5d		 pop	 ebp
  000fd	c2 08 00	 ret	 8

; 1099 : 			_Eos(_Num);

$LN206@append:
  00100	8b c6		 mov	 eax, esi
  00102	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN211@append:

; 1100 : 			}
; 1101 : 		return (*this);

  00106	5f		 pop	 edi
  00107	8b c6		 mov	 eax, esi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx

; 1102 : 		}

  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
$LN217@append:

; 1093 : 			_Xlen();	// result too long

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00114	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN220@append:
$LN219@append:

; 1096 : 		if (0 < _Count && _Grow(_Num))

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN221@append:
$LN214@append:
  00123	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1071 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 c0 00 00
	00		 jb	 $LN201@append

; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

  00019	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	3b c8		 cmp	 ecx, eax
  00023	0f 47 c8	 cmova	 ecx, eax
  00026	8b c2		 mov	 eax, edx
  00028	f7 d0		 not	 eax
  0002a	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx
  0002d	3b c1		 cmp	 eax, ecx
  0002f	0f 86 ae 00 00
	00		 jbe	 $LN203@append

; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

  00035	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

  00038	85 c9		 test	 ecx, ecx
  0003a	0f 84 90 00 00
	00		 je	 $LN196@append
  00040	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00043	0f 87 a4 00 00
	00		 ja	 $LN204@append
  00049	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0004c	73 22		 jae	 SHORT $LN56@append
  0004e	52		 push	 edx
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00057	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005a	85 ff		 test	 edi, edi
  0005c	74 72		 je	 SHORT $LN196@append
$LN200@append:

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

  0005e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00062	72 02		 jb	 SHORT $LN150@append
  00064	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN150@append:
  00066	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006a	72 2b		 jb	 SHORT $LN164@append
  0006c	8b 16		 mov	 edx, DWORD PTR [esi]
  0006e	eb 29		 jmp	 SHORT $LN165@append

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN56@append:
  00070	85 ff		 test	 edi, edi
  00072	75 ea		 jne	 SHORT $LN200@append
  00074	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00077	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0007b	72 0e		 jb	 SHORT $LN133@append
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	5f		 pop	 edi
  00080	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1082 : 			}
; 1083 : 		return (*this);

  00083	8b c6		 mov	 eax, esi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 1084 : 		}

  00087	5d		 pop	 ebp
  00088	c2 0c 00	 ret	 12			; 0000000cH

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN133@append:
  0008b	8b c6		 mov	 eax, esi
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1084 : 		}

  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

$LN164@append:
  00097	8b d6		 mov	 edx, esi
$LN165@append:
  00099	85 c9		 test	 ecx, ecx
  0009b	74 15		 je	 SHORT $LN180@append
  0009d	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000a0	03 c3		 add	 eax, ebx
  000a2	51		 push	 ecx
  000a3	50		 push	 eax
  000a4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000a7	03 c2		 add	 eax, edx
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memcpy
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@append:

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b6	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b9	72 0f		 jb	 SHORT $LN191@append
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1082 : 			}
; 1083 : 		return (*this);

  000c1	8b c6		 mov	 eax, esi
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx

; 1084 : 		}

  000c6	5d		 pop	 ebp
  000c7	c2 0c 00	 ret	 12			; 0000000cH

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

$LN191@append:
  000ca	8b c6		 mov	 eax, esi
  000cc	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN196@append:

; 1082 : 			}
; 1083 : 		return (*this);

  000d0	5f		 pop	 edi
  000d1	8b c6		 mov	 eax, esi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx

; 1084 : 		}

  000d5	5d		 pop	 ebp
  000d6	c2 0c 00	 ret	 12			; 0000000cH
$LN201@append:

; 1071 : 		_Right._Check_offset(_Roff);

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000de	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN205@append:
$LN203@append:

; 1074 : 			_Xlen();	// result too long

  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000e8	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN206@append:
$LN204@append:

; 1077 : 		if (0 < _Count && _Grow(_Num))

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f2	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN207@append:
$LN198@append:
  000f7	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1064 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1066 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 07		 jb	 SHORT $LN94@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	5e		 pop	 esi
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1018 : 		}

  0002e	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN94@basic_stri:
  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	5e		 pop	 esi

; 1018 : 		}

  00033	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000e	73 15		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1b		 je	 SHORT $LN3@Assign_rv
  00018	50		 push	 eax
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00023	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00025	85 ff		 test	 edi, edi
  00027	74 04		 je	 SHORT $LN84@Assign_rv
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 07		 mov	 DWORD PTR [edi], eax
$LN84@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  00039	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003c	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  0003f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00046	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0004a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00051	72 0b		 jb	 SHORT $LN227@Assign_rv
  00053	8b 06		 mov	 eax, DWORD PTR [esi]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	c6 00 00	 mov	 BYTE PTR [eax], 0

; 973  : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN227@Assign_rv:
  0005e	5f		 pop	 edi
  0005f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00062	5e		 pop	 esi

; 973  : 		}

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 914  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0001d	75 12		 jne	 SHORT $LN111@basic_stri
  0001f	33 d2		 xor	 edx, edx
  00021	52		 push	 edx
  00022	51		 push	 ecx
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN111@basic_stri:
  00031	8b d1		 mov	 edx, ecx
  00033	57		 push	 edi
  00034	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL113@basic_stri:
  00037	8a 02		 mov	 al, BYTE PTR [edx]
  00039	42		 inc	 edx
  0003a	84 c0		 test	 al, al
  0003c	75 f9		 jne	 SHORT $LL113@basic_stri
  0003e	2b d7		 sub	 edx, edi
  00040	5f		 pop	 edi
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 795  : 		_Tidy();

  00000	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 796  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 781  : 		_Tidy();
; 782  : 		assign(_Right, 0, npos);

  00006	6a ff		 push	 -1
  00008	6a 00		 push	 0
  0000a	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 1009 : 		}

  00003	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN7@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN16@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN18@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN19@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN20@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN7@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 988  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN18@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN19@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN20@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN15@deallocate:
  00049	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 976  : 		return (_Mybase::allocate(_Count));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN6@allocate
$LN15@allocate:

; 977  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN6@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN8@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN17@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN19@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 977  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN8@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN15@allocate
  00045	eb 0a		 jmp	 SHORT $LN20@allocate
$LN17@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN21@allocate:
$LN19@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN20@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@allocate:
$LN16@allocate:
  00056	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 870  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 750  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN6@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN14@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN16@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN12@allocate
  00045	eb 0a		 jmp	 SHORT $LN17@allocate
$LN14@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN18@allocate:
$LN16@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN17@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN13@allocate:
  00056	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN5@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN13@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN15@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN16@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN17@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN5@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 721  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN15@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN16@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN17@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN12@deallocate:
  00049	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xatomic0.h
;	COMDAT ?_Init_atomic_counter@std@@YAXAAKK@Z
_TEXT	SEGMENT
__Counter$ = 8						; size = 4
__Value$ = 12						; size = 4
?_Init_atomic_counter@std@@YAXAAKK@Z PROC		; std::_Init_atomic_counter, COMDAT

; 62   : 	{	// non-atomically initialize counter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Counter = _Value;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Counter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Value$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 64   : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?_Init_atomic_counter@std@@YAXAAKK@Z ENDP		; std::_Init_atomic_counter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 95   : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 133  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 67   : 			_Xbad_alloc();	// report no memory
; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 559  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00003	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00006	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 _memset
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 561  : 		}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00012	5d		 pop	 ebp

; 553  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 530  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00012	5d		 pop	 ebp

; 530  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 04		 jne	 SHORT $LN3@length
  0000b	33 c0		 xor	 eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

  0000f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL5@length:
  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	40		 inc	 eax
  00015	84 c9		 test	 cl, cl
  00017	75 f9		 jne	 SHORT $LL5@length
  00019	2b c2		 sub	 eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@_W@std@@SAGXZ
_TEXT	SEGMENT
?eof@?$char_traits@_W@std@@SAGXZ PROC			; std::char_traits<wchar_t>::eof, COMDAT

; 386  : 		return (WEOF);

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 387  : 		}

  00005	c3		 ret	 0
?eof@?$char_traits@_W@std@@SAGXZ ENDP			; std::char_traits<wchar_t>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@_W@std@@SAGABG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@_W@std@@SAGABG@Z PROC		; std::char_traits<wchar_t>::not_eof, COMDAT

; 380  : 		{	// return anything but EOF

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 381  : 		return (_Meta != eof() ? _Meta : !eof());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0000b	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0000e	66 3b c1	 cmp	 ax, cx
  00011	75 02		 jne	 SHORT $LN4@not_eof
  00013	33 c0		 xor	 eax, eax
$LN4@not_eof:

; 382  : 		}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?not_eof@?$char_traits@_W@std@@SAGABG@Z ENDP		; std::char_traits<wchar_t>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z PROC	; std::char_traits<wchar_t>::eq_int_type, COMDAT

; 374  : 		{	// test for metacharacter equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	66 3b 08	 cmp	 cx, WORD PTR [eax]
  0000f	0f 94 c0	 sete	 al

; 375  : 		return (_Left == _Right);
; 376  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z ENDP	; std::char_traits<wchar_t>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z PROC	; std::char_traits<wchar_t>::to_int_type, COMDAT

; 368  : 		{	// convert character to metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  : 		return (_Ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]

; 370  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z ENDP	; std::char_traits<wchar_t>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@_W@std@@SA_WABG@Z PROC	; std::char_traits<wchar_t>::to_char_type, COMDAT

; 362  : 		{	// convert metacharacter to character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 363  : 		return (_Meta);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]

; 364  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_char_type@?$char_traits@_W@std@@SA_WABG@Z ENDP	; std::char_traits<wchar_t>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq@?$char_traits@_W@std@@SA_NAB_W0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq@?$char_traits@_W@std@@SA_NAB_W0@Z PROC		; std::char_traits<wchar_t>::eq, COMDAT

; 350  : 		{	// test for element equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	66 3b 08	 cmp	 cx, WORD PTR [eax]
  0000f	0f 94 c0	 sete	 al

; 351  : 		return (_Left == _Right);
; 352  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?eq@?$char_traits@_W@std@@SA_NAB_W0@Z ENDP		; std::char_traits<wchar_t>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 344  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 345  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	66 89 08	 mov	 WORD PTR [eax], cx

; 346  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 2
?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 339  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 340  : 		return ((_Elem *)_CSTD wmemset(_First, _Ch, _Count));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN12@assign
  0000a	8b 45 10	 mov	 eax, DWORD PTR __Ch$[ebp]
  0000d	0f b7 d0	 movzx	 edx, ax
  00010	8b c2		 mov	 eax, edx
  00012	c1 e2 10	 shl	 edx, 16			; 00000010H
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00019	0b c2		 or	 eax, edx
  0001b	d1 e9		 shr	 ecx, 1
  0001d	f3 ab		 rep stosd
  0001f	13 c9		 adc	 ecx, ecx
  00021	66 f3 ab	 rep stosw
  00024	5f		 pop	 edi
$LN12@assign:
  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 341  : 		}

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 332  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 333  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  00014	5d		 pop	 ebp

; 333  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 309  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 310  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  00014	5d		 pop	 ebp

; 310  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIPB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 302  : 		{	// find length of null-terminated sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 303  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0000a	75 04		 jne	 SHORT $LN3@length
  0000c	33 c0		 xor	 eax, eax

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN3@length:

; 303  : 		return (*_First == 0 ? 0

  00010	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL5@length:
  00013	66 8b 08	 mov	 cx, WORD PTR [eax]
  00016	83 c0 02	 add	 eax, 2
  00019	66 85 c9	 test	 cx, cx
  0001c	75 f5		 jne	 SHORT $LL5@length
  0001e	2b c2		 sub	 eax, edx
  00020	d1 f8		 sar	 eax, 1

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?length@?$char_traits@_W@std@@SAIPB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 94   :         return;
; 95   :     }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 90   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 85   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 68   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 60   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 61   :         _Data._What = _Message;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  0000f	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  00014	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 62   :     }

  00017	8b c1		 mov	 eax, ecx
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -8					; size = 8
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 53   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 54   :         __std_exception_data _InitData = { _Message, true };

  00006	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	89 45 f8	 mov	 DWORD PTR __InitData$[ebp], eax
  00012	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00015	c6 45 fc 01	 mov	 BYTE PTR __InitData$[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

  00019	52		 push	 edx
  0001a	8d 45 f8	 lea	 eax, DWORD PTR __InitData$[ebp]
  0001d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00023	50		 push	 eax
  00024	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00028	e8 00 00 00 00	 call	 ___std_exception_copy
  0002d	83 c4 08	 add	 esp, 8

; 56   :     }

  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemset
_TEXT	SEGMENT
__S$ = 8						; size = 4
__C$ = 12						; size = 2
__N$ = 16						; size = 4
_wmemset PROC						; COMDAT

; 258  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 260  :         for (; 0 < _N; ++_Su, --_N)

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __N$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN10@wmemset

; 259  :         wchar_t *_Su = _S;

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __C$[ebp]
  0000d	0f b7 d0	 movzx	 edx, ax
  00010	8b c2		 mov	 eax, edx
  00012	c1 e2 10	 shl	 edx, 16			; 00000010H
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR __S$[ebp]
  00019	0b c2		 or	 eax, edx
  0001b	d1 e9		 shr	 ecx, 1
  0001d	f3 ab		 rep stosd
  0001f	13 c9		 adc	 ecx, ecx
  00021	66 f3 ab	 rep stosw
  00024	5f		 pop	 edi
$LN10@wmemset:

; 261  :         {
; 262  :             *_Su = _C;
; 263  :         }
; 264  :         return _S;

  00025	8b 45 08	 mov	 eax, DWORD PTR __S$[ebp]

; 265  :     }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_wmemset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC						; COMDAT

; 244  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 248  :         #pragma warning(pop)
; 249  :     }

  0000b	5d		 pop	 ebp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memmove
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 231  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 235  :         #pragma warning(pop)
; 236  :     }

  0000b	5d		 pop	 ebp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memcpy
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1834 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);
; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s
  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1839 :         __crt_va_end(_ArgList);
; 1840 :         return _Result;
; 1841 :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1493 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1499 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);
; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 836  :     __crt_va_end(_ArgList);
; 837  :     return _Result;
; 838  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 640  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT ?swprintf@@YAHQA_WQB_WZZ
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
?swprintf@@YAHQA_WQB_WZZ PROC				; swprintf, COMDAT

; 1824 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1825 :             int _Result;
; 1826 :             va_list _ArgList;
; 1827 :             __crt_va_start(_ArgList, _Format);
; 1828 :             #pragma warning(suppress: 28719)
; 1829 :             _Result = vswprintf(_Buffer, _CRT_INT_MAX, _Format, _ArgList);       

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00011	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00014	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	ff 30		 push	 DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ___stdio_common_vswprintf
  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1830 :             __crt_va_end(_ArgList);
; 1831 :             return _Result;
; 1832 :         }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?swprintf@@YAHQA_WQB_WZZ ENDP				; swprintf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<wchar_t const *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT _swprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_swprintf_s PROC					; COMDAT

; 1536 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1537 :         int _Result;
; 1538 :         va_list _ArgList;
; 1539 :         __crt_va_start(_ArgList, _Format);
; 1540 :         _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vswprintf_s
  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1541 :         __crt_va_end(_ArgList);
; 1542 :         return _Result;
; 1543 :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_swprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_s_l PROC					; COMDAT

; 1262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1263 :     int const _Result = __stdio_common_vswprintf_s(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vswprintf_s

; 1264 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1265 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1266 : 
; 1267 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1268 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vswprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT _vswprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vswprintf PROC						; COMDAT

; 1245 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1246 :     return _vswprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vswprintf
  00020	83 c9 ff	 or	 ecx, -1
  00023	83 c4 1c	 add	 esp, 28			; 0000001cH
  00026	85 c0		 test	 eax, eax
  00028	0f 48 c1	 cmovs	 eax, ecx

; 1247 : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_vswprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_c_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_c_l PROC					; COMDAT

; 1158 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1159 :     int const _Result = __stdio_common_vswprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vswprintf

; 1160 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1161 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1162 : 
; 1163 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1164 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vswprintf_c_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __snwprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snwprintf PROC					; COMDAT

; 1673 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1674 :     int _Result;
; 1675 :     va_list _ArgList;
; 1676 :     __crt_va_start(_ArgList, _Format);
; 1677 : 
; 1678 :     #pragma warning(push)
; 1679 :     #pragma warning(disable: 4996) // Deprecation
; 1680 :     _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vswprintf
  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1681 :     #pragma warning(pop)
; 1682 : 
; 1683 :     __crt_va_end(_ArgList);
; 1684 :     return _Result;
; 1685 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snwprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vsnwprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnwprintf_l PROC					; COMDAT

; 1056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1057 :     int const _Result = __stdio_common_vswprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vswprintf

; 1058 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1059 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1060 : 
; 1061 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1062 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnwprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<wchar_t const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _frexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_frexpl	PROC						; COMDAT

; 849  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 850  :     return frexp((double)_X, _Y);

  00003	ff 75 10	 push	 DWORD PTR __Y$[ebp]
  00006	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  0000b	83 ec 08	 sub	 esp, 8
  0000e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00013	e8 00 00 00 00	 call	 _frexp
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 851  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_frexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _fabsl
_TEXT	SEGMENT
tv68 = -8						; size = 8
__X$ = 8						; size = 8
_fabsl	PROC						; COMDAT

; 828  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 829  :     return fabs((double)_X);

  00006	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  0000b	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00012	f2 0f 11 45 f8	 movsd	 QWORD PTR tv68[ebp], xmm0
  00017	dd 45 f8	 fld	 QWORD PTR tv68[ebp]

; 830  : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_fabsl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\gstformat.c
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_e$2 = -24						; size = 4
$T3 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpszCommandLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 9579 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_WinMain@16
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 9580 : 	int status;
; 9581 : 	atexit (localcleanup);

  0002b	68 00 00 00 00	 push	 OFFSET _localcleanup
  00030	e8 00 00 00 00	 call	 _atexit

; 9582 : 
; 9583 : 	VirtualLock (&volumePassword, sizeof(volumePassword));

  00035	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualLock@8
  0003b	83 c4 04	 add	 esp, 4
  0003e	6a 48		 push	 72			; 00000048H
  00040	68 00 00 00 00	 push	 OFFSET ?volumePassword@@3UPassword@@A ; volumePassword
  00045	ff d6		 call	 esi

; 9584 : 	VirtualLock (szVerify, sizeof(szVerify));

  00047	6a 41		 push	 65			; 00000041H
  00049	68 00 00 00 00	 push	 OFFSET ?szVerify@@3PADA	; szVerify
  0004e	ff d6		 call	 esi

; 9585 : 	VirtualLock (szRawPassword, sizeof(szRawPassword));

  00050	6a 41		 push	 65			; 00000041H
  00052	68 00 00 00 00	 push	 OFFSET ?szRawPassword@@3PADA ; szRawPassword
  00057	ff d6		 call	 esi

; 9586 : 
; 9587 : 	VirtualLock (MasterKeyGUIView, sizeof(MasterKeyGUIView));

  00059	6a 40		 push	 64			; 00000040H
  0005b	68 00 00 00 00	 push	 OFFSET _MasterKeyGUIView
  00060	ff d6		 call	 esi

; 9588 : 	VirtualLock (HeaderKeyGUIView, sizeof(HeaderKeyGUIView));

  00062	6a 40		 push	 64			; 00000040H
  00064	68 00 00 00 00	 push	 OFFSET _HeaderKeyGUIView
  00069	ff d6		 call	 esi

; 9589 : 
; 9590 : 	VirtualLock (randPool, sizeof(randPool));

  0006b	6a 78		 push	 120			; 00000078H
  0006d	68 00 00 00 00	 push	 OFFSET ?randPool@@3PAEA	; randPool
  00072	ff d6		 call	 esi

; 9591 : 	VirtualLock (lastRandPool, sizeof(lastRandPool));

  00074	6a 78		 push	 120			; 00000078H
  00076	68 00 00 00 00	 push	 OFFSET ?lastRandPool@@3PAEA ; lastRandPool
  0007b	ff d6		 call	 esi

; 9592 : 	VirtualLock (outRandPoolDispBuffer, sizeof(outRandPoolDispBuffer));

  0007d	68 72 01 00 00	 push	 370			; 00000172H
  00082	68 00 00 00 00	 push	 OFFSET ?outRandPoolDispBuffer@@3PAEA ; outRandPoolDispBuffer
  00087	ff d6		 call	 esi

; 9593 : 
; 9594 : 	VirtualLock (&szFileName, sizeof(szFileName));

  00089	68 05 01 00 00	 push	 261			; 00000105H
  0008e	68 00 00 00 00	 push	 OFFSET ?szFileName@@3PADA ; szFileName
  00093	ff d6		 call	 esi

; 9595 : 	VirtualLock (&szDiskFile, sizeof(szDiskFile));

  00095	68 05 01 00 00	 push	 261			; 00000105H
  0009a	68 00 00 00 00	 push	 OFFSET ?szDiskFile@@3PADA ; szDiskFile
  0009f	ff d6		 call	 esi

; 9596 : 
; 9597 : 	try
; 9598 : 	{
; 9599 : 		BootEncObj = new BootEncryption (NULL);

  000a1	68 c8 05 00 00	 push	 1480			; 000005c8H
  000a6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000ad	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b2	83 c4 04	 add	 esp, 4
  000b5	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  000b8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000bc	85 c0		 test	 eax, eax
  000be	74 10		 je	 SHORT $LN11@WinMain
  000c0	6a 00		 push	 0
  000c2	8b c8		 mov	 ecx, eax
  000c4	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption
  000c9	a3 00 00 00 00	 mov	 DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A, eax ; BootEncObj
  000ce	eb 1d		 jmp	 SHORT $LN17@WinMain
$LN11@WinMain:
  000d0	33 c0		 xor	 eax, eax
  000d2	a3 00 00 00 00	 mov	 DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A, eax ; BootEncObj
  000d7	eb 14		 jmp	 SHORT $LN17@WinMain
__catch$_WinMain@16$0:

; 9600 : 	}
; 9601 : 	catch (Exception &e)
; 9602 : 	{
; 9603 : 		e.Show (NULL);

  000d9	8b 4d e8	 mov	 ecx, DWORD PTR _e$2[ebp]
  000dc	6a 00		 push	 0
  000de	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e0	ff 10		 call	 DWORD PTR [eax]

; 9604 : 	}

  000e2	b8 00 00 00 00	 mov	 eax, $LN18@WinMain
  000e7	c3		 ret	 0
$LN18@WinMain:
  000e8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BootEncObj@@3PAVBootEncryption@GostCrypt@@A ; BootEncObj
$LN17@WinMain:

; 9605 : 
; 9606 : 	if (BootEncObj == NULL)

  000ed	85 c0		 test	 eax, eax
  000ef	75 0d		 jne	 SHORT $LN3@WinMain

; 9607 : 		AbortProcess ("INIT_SYS_ENC");

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PDPHKHCO@INIT_SYS_ENC?$AA@
  000f6	e8 00 00 00 00	 call	 _AbortProcess
  000fb	83 c4 04	 add	 esp, 4
$LN3@WinMain:

; 9608 : 
; 9609 : 	InitCommonControls ();

  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitCommonControls@0

; 9610 : 	InitApp (hInstance, lpszCommandLine);

  00104	ff 75 10	 push	 DWORD PTR _lpszCommandLine$[ebp]
  00107	8b 75 08	 mov	 esi, DWORD PTR _hInstance$[ebp]
  0010a	56		 push	 esi
  0010b	e8 00 00 00 00	 call	 _InitApp

; 9611 : 
; 9612 : 	// Write block size greater than 64 KB causes a performance drop when writing to files on XP/Vista
; 9613 : 	if (!IsOSAtLeast (WIN_7))

  00110	6a 0d		 push	 13			; 0000000dH
  00112	e8 00 00 00 00	 call	 _IsOSAtLeast
  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _FormatWriteBufferSize
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00120	85 c0		 test	 eax, eax

; 9614 : 		FormatWriteBufferSize = 64 * 1024;
; 9615 : 
; 9616 : #if GST_MAX_VOLUME_SECTOR_SIZE > 64 * 1024
; 9617 : #error GST_MAX_VOLUME_SECTOR_SIZE > 64 * 1024
; 9618 : #endif
; 9619 : 
; 9620 : 	nPbar = IDC_PROGRESS_BAR;

  00122	c7 05 00 00 00
	00 f6 03 00 00	 mov	 DWORD PTR _nPbar, 1014	; 000003f6H
  0012c	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  00131	0f 44 ca	 cmove	 ecx, edx
  00134	89 0d 00 00 00
	00		 mov	 DWORD PTR _FormatWriteBufferSize, ecx

; 9621 : 
; 9622 : 	if (Randinit ())

  0013a	e8 00 00 00 00	 call	 _Randinit
  0013f	85 c0		 test	 eax, eax
  00141	74 0d		 je	 SHORT $LN5@WinMain

; 9623 : 		AbortProcess ("INIT_RAND");

  00143	68 00 00 00 00	 push	 OFFSET ??_C@_09PLHAEEAO@INIT_RAND?$AA@
  00148	e8 00 00 00 00	 call	 _AbortProcess
  0014d	83 c4 04	 add	 esp, 4
$LN5@WinMain:

; 9624 : 
; 9625 : 	RegisterRedTick(hInstance);

  00150	56		 push	 esi
  00151	e8 00 00 00 00	 call	 _RegisterRedTick

; 9626 : 
; 9627 : 	/* Allocate, dup, then store away the application title */
; 9628 : 	lpszTitle = GetString ("IDD_VOL_CREATION_WIZARD_DLG");

  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IHMEHMBJ@IDD_VOL_CREATION_WIZARD_DLG?$AA@
  0015b	e8 00 00 00 00	 call	 _GetString
  00160	83 c4 08	 add	 esp, 8
  00163	a3 00 00 00 00	 mov	 DWORD PTR _lpszTitle, eax

; 9629 : 
; 9630 : 	status = DriverAttach ();

  00168	e8 00 00 00 00	 call	 _DriverAttach

; 9631 : 	if (status != 0)

  0016d	85 c0		 test	 eax, eax
  0016f	74 29		 je	 SHORT $LN6@WinMain

; 9632 : 	{
; 9633 : 		if (status == ERR_OS_ERROR)

  00171	83 f8 01	 cmp	 eax, 1
  00174	75 0c		 jne	 SHORT $LN7@WinMain

; 9634 : 			handleWin32Error (NULL);

  00176	6a 00		 push	 0
  00178	e8 00 00 00 00	 call	 _handleWin32Error
  0017d	83 c4 04	 add	 esp, 4

; 9635 : 		else

  00180	eb 0b		 jmp	 SHORT $LN8@WinMain
$LN7@WinMain:

; 9636 : 			handleError (NULL, status);

  00182	50		 push	 eax
  00183	6a 00		 push	 0
  00185	e8 00 00 00 00	 call	 _handleError
  0018a	83 c4 08	 add	 esp, 8
$LN8@WinMain:

; 9637 : 
; 9638 : 		AbortProcess ("NODRIVER");

  0018d	68 00 00 00 00	 push	 OFFSET ??_C@_08ELEAABKI@NODRIVER?$AA@
  00192	e8 00 00 00 00	 call	 _AbortProcess
  00197	83 c4 04	 add	 esp, 4
$LN6@WinMain:

; 9639 : 	}
; 9640 : 
; 9641 : 	/* Use TestCRCs and this segment for various debugging tests. This code gets triggered every time the Format application is started */
; 9642 : 	/*{
; 9643 : 		char crc[STRIBOG_DIGESTSIZE];
; 9644 : 		int i;
; 9645 : 		TestCRCs(crc);
; 9646 : 		WCHAR buf[512];
; 9647 : 		for (i = 0; i < 64; i++)
; 9648 : 			btoc(crc[i], buf + (i*2));
; 9649 : 		buf[i*2] = '\0';
; 9650 : 		MessageBoxW (NULL, buf, L"CRC Test", NULL);
; 9651 : 	}*/
; 9652 : 
; 9653 : 
; 9654 : 	if (!AutoTestAlgorithms())

  0019a	e8 00 00 00 00	 call	 _AutoTestAlgorithms
  0019f	85 c0		 test	 eax, eax
  001a1	75 0d		 jne	 SHORT $LN9@WinMain

; 9655 : 		AbortProcess ("ERR_SELF_TESTS_FAILED");

  001a3	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DKEEGIEL@ERR_SELF_TESTS_FAILED?$AA@
  001a8	e8 00 00 00 00	 call	 _AbortProcess
  001ad	83 c4 04	 add	 esp, 4
$LN9@WinMain:

; 9656 : 
; 9657 : 
; 9658 : 	/* Create the main dialog box */
; 9659 : 	DialogBoxParamW (hInstance, MAKEINTRESOURCEW (IDD_VOL_CREATION_WIZARD_DLG), NULL, (DLGPROC) MainDialogProc, 

  001b0	ff 75 10	 push	 DWORD PTR _lpszCommandLine$[ebp]
  001b3	68 00 00 00 00	 push	 OFFSET _MainDialogProc@16
  001b8	6a 00		 push	 0
  001ba	6a 65		 push	 101			; 00000065H
  001bc	56		 push	 esi
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20

; 9660 : 		(LPARAM)lpszCommandLine);
; 9661 : 
; 9662 : 	return 0;

  001c3	33 c0		 xor	 eax, eax

; 9663 : }

  001c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001cf	59		 pop	 ecx
  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi
  001d2	5b		 pop	 ebx
  001d3	8b e5		 mov	 esp, ebp
  001d5	5d		 pop	 ebp
  001d6	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_WinMain@16$2:
  00000	68 c8 05 00 00	 push	 1480			; 000005c8H
  00005	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__ehhandler$_WinMain@16:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_WinMain@16
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_WinMain@16 ENDP
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__SubString$ = 12					; size = 4
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT

; 536  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 538  :     }

  00003	5d		 pop	 ebp

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00004	e9 00 00 00 00	 jmp	 _strstr
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
END
