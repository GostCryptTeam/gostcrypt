; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\Format.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_FormatWriteBufferSize
_DATA	SEGMENT
COMM	_FormatExResult:BYTE
_DATA	ENDS
_DATA	SEGMENT
_FormatWriteBufferSize DD 0100000H
_DATA	ENDS
PUBLIC	_GSTFormatVolume
PUBLIC	_FormatNtfs
PUBLIC	_GetVolumeDataAreaSize
PUBLIC	_FormatNoFs
PUBLIC	_WriteSector
PUBLIC	_FlushFormatWriteBuffer
PUBLIC	_FormatExCallback@12
PUBLIC	??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@	; `string'
PUBLIC	??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@ ; `string'
PUBLIC	??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@	; `string'
PUBLIC	??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@		; `string'
PUBLIC	??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@		; `string'
PUBLIC	??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@	; `string'
PUBLIC	??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@	; `string'
PUBLIC	??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@	; `string'
PUBLIC	??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@ ; `string'
PUBLIC	??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@	; `string'
PUBLIC	??_C@_09IFOENPLD@fmifs?4dll?$AA@		; `string'
PUBLIC	??_C@_08KDJACLKO@FormatEx?$AA@			; `string'
PUBLIC	??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@		; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@	; `string'
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__FlushFileBuffers@4:PROC
EXTRN	__imp__GetFileTime@16:PROC
EXTRN	__imp__SetEndOfFile@4:PROC
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__SetFileTime@16:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__SetThreadPriority@8:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	__imp__VirtualUnlock@8:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryExA@12:PROC
EXTRN	__imp__DefineDosDeviceA@12:PROC
EXTRN	__imp__SetVolumeMountPointA@8:PROC
EXTRN	__imp__DeleteVolumeMountPointA@4:PROC
EXTRN	__imp__GetVolumeNameForVolumeMountPointA@12:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__beginthread:PROC
EXTRN	__endthread:PROC
EXTRN	_crypto_close:PROC
EXTRN	_EAInit:PROC
EXTRN	_EAInitMode:PROC
EXTRN	_EAGetKeySize:PROC
EXTRN	_EncryptDataUnits:PROC
EXTRN	_GetFatParams:PROC
EXTRN	_FormatFat:PROC
EXTRN	_RandgetBytes:PROC
EXTRN	_CreateVolumeHeaderInMemory:PROC
EXTRN	_WriteEffectiveVolumeHeader:PROC
EXTRN	_WriteRandomDataToReservedHeaderAreas:PROC
EXTRN	_FakeDosNameForDevice:PROC
EXTRN	_RemoveFakeDosName:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	_ToUNICODE:PROC
EXTRN	_GetFirstAvailableDrive:PROC
EXTRN	_GetLastAvailableDrive:PROC
EXTRN	_IsDeviceMounted:PROC
EXTRN	_MountVolume:PROC
EXTRN	_UnmountVolume:PROC
EXTRN	_IsAdmin:PROC
EXTRN	_IsUacSupported:PROC
EXTRN	_GetDiskDeviceDriveLetter:PROC
EXTRN	_DismountDrive:PROC
EXTRN	_Error:PROC
EXTRN	_AskErrYesNo:PROC
EXTRN	_IsOSAtLeast:PROC
EXTRN	_DisableFileCompression:PROC
EXTRN	_GetString:PROC
EXTRN	_UpdateProgressBar:PROC
EXTRN	_UacFormatNtfs:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_bPreserveTimestamp:DWORD
EXTRN	_lpszTitle:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_FormatSectorSize DD 01H DUP (?)
?updateTime@?1??WriteSector@@9@9 DD 01H DUP (?)		; `WriteSector'::`2'::updateTime
_WriteThreadRunning DD 01H DUP (?)
_WriteThreadExitRequested DD 01H DUP (?)
_WriteThreadHandle DD 01H DUP (?)
_WriteThreadBuffer DD 01H DUP (?)
_WriteBufferEmptyEvent DD 01H DUP (?)
_WriteBufferFullEvent DD 01H DUP (?)
_WriteRequestHandle DD 01H DUP (?)
_WriteRequestSize DD 01H DUP (?)
_WriteRequestResult DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@ DB 'N', 00H, 'T', 00H, 'F', 00H
	DB	'S', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@ DB ':', 00H, '\', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDJACLKO@FormatEx?$AA@
CONST	SEGMENT
??_C@_08KDJACLKO@FormatEx?$AA@ DB 'FormatEx', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IFOENPLD@fmifs?4dll?$AA@
CONST	SEGMENT
??_C@_09IFOENPLD@fmifs?4dll?$AA@ DB 'fmifs.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@
CONST	SEGMENT
??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@ DB 'FORMAT_NTFS_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@
CONST	SEGMENT
??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@ DB 'FORMAT_NTFS_FAILED'
	DB	'_ASK_FAT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@
CONST	SEGMENT
??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@ DB 'CANT_DISMOUNT_VOLUME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@
CONST	SEGMENT
??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@ DB 'CANT_MOUNT_VOLUME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@
CONST	SEGMENT
??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@ DB 'FORMAT_NTFS_STOP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@
CONST	SEGMENT
??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@ DB 'NO_FREE_DRIVES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@ DB 'NO NAME    ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@
CONST	SEGMENT
??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@ DB 'CANT_ACCESS_VOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@
CONST	SEGMENT
??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@ DB 'DEVICE_IN_USE_FORMAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@
CONST	SEGMENT
??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@ DB 'FORMAT_CANT_DISM'
	DB	'OUNT_FILESYS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
CONST	SEGMENT
??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@ DB 'SECTOR_SIZE_UNSUPPORT'
	DB	'ED', 00H					; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\format.c
;	COMDAT _FormatWriteThreadProc
_TEXT	SEGMENT
_bytesWritten$ = -4					; size = 4
_arg$ = 8						; size = 4
_FormatWriteThreadProc PROC				; COMDAT

; 1006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1007 : 	DWORD bytesWritten;
; 1008 : 
; 1009 : 	SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

  00004	6a 02		 push	 2
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadPriority@8

; 1010 : 
; 1011 : 	while (!WriteThreadExitRequested)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _WriteThreadExitRequested, 0
  0001a	0f 85 86 00 00
	00		 jne	 $LN3@FormatWrit
  00020	53		 push	 ebx
  00021	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SetEvent@4
  00027	56		 push	 esi
  00028	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetLastError@0
  0002e	57		 push	 edi
  0002f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WaitForSingleObject@8
$LL2@FormatWrit:

; 1012 : 	{
; 1013 : 		if (WaitForSingleObject (WriteBufferFullEvent, INFINITE) == WAIT_FAILED)

  00035	6a ff		 push	 -1
  00037	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteBufferFullEvent
  0003d	ff d7		 call	 edi
  0003f	83 f8 ff	 cmp	 eax, -1
  00042	74 55		 je	 SHORT $LN11@FormatWrit

; 1016 : 			break;
; 1017 : 		}
; 1018 : 
; 1019 : 		if (WriteThreadExitRequested)

  00044	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _WriteThreadExitRequested, 0
  0004b	75 56		 jne	 SHORT $LN16@FormatWrit

; 1020 : 			break;
; 1021 : 
; 1022 : 		if (!WriteFile (WriteRequestHandle, WriteThreadBuffer, WriteRequestSize, &bytesWritten, NULL))

  0004d	6a 00		 push	 0
  0004f	8d 45 fc	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  00052	50		 push	 eax
  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteRequestSize
  00058	50		 push	 eax
  00059	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteThreadBuffer
  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteRequestHandle
  00064	50		 push	 eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0006b	85 c0		 test	 eax, eax
  0006d	75 09		 jne	 SHORT $LN6@FormatWrit

; 1023 : 			WriteRequestResult = GetLastError();

  0006f	ff d6		 call	 esi
  00071	a3 00 00 00 00	 mov	 DWORD PTR _WriteRequestResult, eax
  00076	eb 0a		 jmp	 SHORT $LN7@FormatWrit
$LN6@FormatWrit:

; 1024 : 		else		
; 1025 : 			WriteRequestResult = ERROR_SUCCESS;

  00078	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteRequestResult, 0
$LN7@FormatWrit:

; 1026 : 
; 1027 : 		if (!SetEvent (WriteBufferEmptyEvent))

  00082	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteBufferEmptyEvent
  00088	ff d3		 call	 ebx
  0008a	85 c0		 test	 eax, eax
  0008c	74 0b		 je	 SHORT $LN11@FormatWrit

; 1010 : 
; 1011 : 	while (!WriteThreadExitRequested)

  0008e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _WriteThreadExitRequested, 0
  00095	74 9e		 je	 SHORT $LL2@FormatWrit

; 1026 : 
; 1027 : 		if (!SetEvent (WriteBufferEmptyEvent))

  00097	eb 0a		 jmp	 SHORT $LN16@FormatWrit
$LN11@FormatWrit:

; 1014 : 		{
; 1015 : 			handleWin32Error (NULL);

  00099	6a 00		 push	 0
  0009b	e8 00 00 00 00	 call	 _handleWin32Error
  000a0	83 c4 04	 add	 esp, 4
$LN16@FormatWrit:
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
$LN3@FormatWrit:

; 1028 : 		{
; 1029 : 			handleWin32Error (NULL);
; 1030 : 			break;
; 1031 : 		}
; 1032 : 	}
; 1033 : 
; 1034 : 	WriteThreadRunning = FALSE;

  000a6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteThreadRunning, 0

; 1035 : 	_endthread();

  000b0	e8 00 00 00 00	 call	 __endthread

; 1036 : }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_FormatWriteThreadProc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\format.c
;	COMDAT _FormatExCallback@12
_TEXT	SEGMENT
_command$ = 8						; size = 4
_subCommand$ = 12					; size = 4
_parameter$ = 16					; size = 4
_FormatExCallback@12 PROC				; COMDAT

; 891  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 892  : 	if (command == FMIFS_DONE)

  00003	83 7d 08 0b	 cmp	 DWORD PTR _command$[ebp], 11 ; 0000000bH
  00007	75 0a		 jne	 SHORT $LN4@FormatExCa

; 893  : 		FormatExResult = *(BOOLEAN *) parameter;

  00009	8b 45 10	 mov	 eax, DWORD PTR _parameter$[ebp]
  0000c	8a 00		 mov	 al, BYTE PTR [eax]
  0000e	a2 00 00 00 00	 mov	 BYTE PTR _FormatExResult, al
$LN4@FormatExCa:

; 894  : 	return TRUE;

  00013	b0 01		 mov	 al, 1

; 895  : }

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
_FormatExCallback@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\format.c
;	COMDAT _StopFormatWriteThread
_TEXT	SEGMENT
_StopFormatWriteThread PROC				; COMDAT

; 1104 : 	if (WriteThreadRunning)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _WriteThreadRunning, 0
  00007	56		 push	 esi
  00008	74 30		 je	 SHORT $LN2@StopFormat

; 1105 : 	{
; 1106 : 		WaitForSingleObject (WriteBufferEmptyEvent, INFINITE);

  0000a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__WaitForSingleObject@8
  00010	6a ff		 push	 -1
  00012	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteBufferEmptyEvent
  00018	ff d6		 call	 esi

; 1107 : 
; 1108 : 		WriteThreadExitRequested = TRUE;
; 1109 : 		SetEvent (WriteBufferFullEvent);

  0001a	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteBufferFullEvent
  00020	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _WriteThreadExitRequested, 1
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 1110 : 
; 1111 : 		WaitForSingleObject (WriteThreadHandle, INFINITE);

  00030	6a ff		 push	 -1
  00032	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteThreadHandle
  00038	ff d6		 call	 esi
$LN2@StopFormat:

; 1112 : 	}
; 1113 : 
; 1114 : 	CloseHandle (WriteBufferEmptyEvent);

  0003a	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteBufferEmptyEvent
  00040	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00046	ff d6		 call	 esi

; 1115 : 	CloseHandle (WriteBufferFullEvent);

  00048	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteBufferFullEvent
  0004e	ff d6		 call	 esi

; 1116 : 	GSTfree (WriteThreadBuffer);

  00050	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteThreadBuffer
  00056	e8 00 00 00 00	 call	 _free
  0005b	83 c4 04	 add	 esp, 4
  0005e	5e		 pop	 esi

; 1117 : }

  0005f	c3		 ret	 0
_StopFormatWriteThread ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\format.c
;	COMDAT _StartFormatWriteThread
_TEXT	SEGMENT
_StartFormatWriteThread PROC				; COMDAT

; 1048 : {

  00000	56		 push	 esi

; 1049 : 	DWORD sysErr;
; 1050 : 
; 1051 : 	WriteBufferEmptyEvent = NULL;
; 1052 : 	WriteBufferFullEvent = NULL;
; 1053 : 	WriteThreadBuffer = NULL;
; 1054 : 
; 1055 : 	WriteBufferEmptyEvent = CreateEvent (NULL, FALSE, TRUE, NULL);

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateEventA@16
  00007	6a 00		 push	 0
  00009	6a 01		 push	 1
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteBufferEmptyEvent, 0
  00019	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteBufferFullEvent, 0
  00023	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteThreadBuffer, 0
  0002d	ff d6		 call	 esi
  0002f	a3 00 00 00 00	 mov	 DWORD PTR _WriteBufferEmptyEvent, eax

; 1056 : 	if (!WriteBufferEmptyEvent)

  00034	85 c0		 test	 eax, eax
  00036	74 32		 je	 SHORT $err$11

; 1057 : 		goto err;
; 1058 : 
; 1059 : 	WriteBufferFullEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	ff d6		 call	 esi
  00042	a3 00 00 00 00	 mov	 DWORD PTR _WriteBufferFullEvent, eax

; 1060 : 	if (!WriteBufferFullEvent)

  00047	85 c0		 test	 eax, eax
  00049	74 1f		 je	 SHORT $err$11

; 1061 : 		goto err;
; 1062 : 
; 1063 : 	WriteThreadBuffer = GSTalloc (FormatWriteBufferSize);

  0004b	ff 35 00 00 00
	00		 push	 DWORD PTR _FormatWriteBufferSize
  00051	e8 00 00 00 00	 call	 _malloc
  00056	83 c4 04	 add	 esp, 4
  00059	a3 00 00 00 00	 mov	 DWORD PTR _WriteThreadBuffer, eax

; 1064 : 	if (!WriteThreadBuffer)

  0005e	85 c0		 test	 eax, eax
  00060	75 4e		 jne	 SHORT $LN4@StartForma

; 1065 : 	{
; 1066 : 		SetLastError (ERROR_OUTOFMEMORY);

  00062	6a 0e		 push	 14			; 0000000eH
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$err$11:

; 1079 : 
; 1080 : err:
; 1081 : 	sysErr = GetLastError();

  0006a	53		 push	 ebx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1082 : 
; 1083 : 	if (WriteBufferEmptyEvent)

  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferEmptyEvent
  00077	8b d8		 mov	 ebx, eax
  00079	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  0007f	85 c9		 test	 ecx, ecx
  00081	74 03		 je	 SHORT $LN6@StartForma

; 1084 : 		CloseHandle (WriteBufferEmptyEvent);

  00083	51		 push	 ecx
  00084	ff d6		 call	 esi
$LN6@StartForma:

; 1085 : 	if (WriteBufferFullEvent)

  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteBufferFullEvent
  0008b	85 c0		 test	 eax, eax
  0008d	74 03		 je	 SHORT $LN7@StartForma

; 1086 : 		CloseHandle (WriteBufferFullEvent);

  0008f	50		 push	 eax
  00090	ff d6		 call	 esi
$LN7@StartForma:

; 1087 : 	if (WriteThreadBuffer)

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadBuffer
  00097	85 c0		 test	 eax, eax
  00099	74 09		 je	 SHORT $LN8@StartForma

; 1088 : 		GSTfree (WriteThreadBuffer);

  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _free
  000a1	83 c4 04	 add	 esp, 4
$LN8@StartForma:

; 1089 : 
; 1090 : 	SetLastError (sysErr);

  000a4	53		 push	 ebx
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  000ab	5b		 pop	 ebx

; 1091 : 	return FALSE;

  000ac	33 c0		 xor	 eax, eax
  000ae	5e		 pop	 esi

; 1092 : }

  000af	c3		 ret	 0
$LN4@StartForma:

; 1067 : 		goto err;
; 1068 : 	}
; 1069 : 
; 1070 : 	WriteThreadExitRequested = FALSE;
; 1071 : 	WriteRequestResult = ERROR_SUCCESS;
; 1072 : 
; 1073 : 	WriteThreadHandle = (HANDLE) _beginthread (FormatWriteThreadProc, 0, NULL);

  000b0	6a 00		 push	 0
  000b2	6a 00		 push	 0
  000b4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteThreadExitRequested, 0
  000be	68 00 00 00 00	 push	 OFFSET _FormatWriteThreadProc
  000c3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteRequestResult, 0
  000cd	e8 00 00 00 00	 call	 __beginthread
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d5	a3 00 00 00 00	 mov	 DWORD PTR _WriteThreadHandle, eax

; 1074 : 	if ((uintptr_t) WriteThreadHandle == -1L)

  000da	83 f8 ff	 cmp	 eax, -1
  000dd	74 8b		 je	 SHORT $err$11

; 1075 : 		goto err;
; 1076 : 
; 1077 : 	WriteThreadRunning = TRUE;

  000df	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _WriteThreadRunning, 1

; 1078 : 	return TRUE;

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	5e		 pop	 esi

; 1092 : }

  000ef	c3		 ret	 0
_StartFormatWriteThread ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\format.c
;	COMDAT _FlushFormatWriteBuffer
_TEXT	SEGMENT
_unitNo$ = -8						; size = 8
_dev$ = 8						; size = 4
_write_buf$ = 12					; size = 4
_bytesWritten$ = 16					; size = 4
_write_buf_cnt$ = 16					; size = 4
_nSecNo$ = 20						; size = 4
_cryptoInfo$ = 24					; size = 4
_FlushFormatWriteBuffer PROC				; COMDAT

; 1138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 1139 : 	UINT64_STRUCT unitNo;
; 1140 : 	DWORD bytesWritten;
; 1141 : 
; 1142 : 	if (*write_buf_cnt == 0)

  00008	8b 7d 10	 mov	 edi, DWORD PTR _write_buf_cnt$[ebp]
  0000b	8b 1f		 mov	 ebx, DWORD PTR [edi]
  0000d	85 db		 test	 ebx, ebx
  0000f	75 09		 jne	 SHORT $LN2@FlushForma

; 1143 : 		return TRUE;

  00011	5f		 pop	 edi
  00012	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00015	5b		 pop	 ebx

; 1176 : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN2@FlushForma:

; 1144 : 
; 1145 : 	unitNo.Value = (*nSecNo * FormatSectorSize - *write_buf_cnt) / ENCRYPTION_DATA_UNIT_SIZE;

  0001a	8b 45 14	 mov	 eax, DWORD PTR _nSecNo$[ebp]
  0001d	56		 push	 esi
  0001e	ff 70 04	 push	 DWORD PTR [eax+4]
  00021	ff 30		 push	 DWORD PTR [eax]
  00023	6a 00		 push	 0
  00025	ff 35 00 00 00
	00		 push	 DWORD PTR _FormatSectorSize
  0002b	e8 00 00 00 00	 call	 __allmul
  00030	8b f0		 mov	 esi, eax
  00032	8b ca		 mov	 ecx, edx
  00034	8b c3		 mov	 eax, ebx
  00036	99		 cdq
  00037	2b f0		 sub	 esi, eax
  00039	6a 00		 push	 0
  0003b	68 00 02 00 00	 push	 512			; 00000200H
  00040	1b ca		 sbb	 ecx, edx
  00042	51		 push	 ecx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 __alldiv

; 1146 : 
; 1147 : 	EncryptDataUnits (write_buf, &unitNo, *write_buf_cnt / ENCRYPTION_DATA_UNIT_SIZE, cryptoInfo);

  00049	ff 75 18	 push	 DWORD PTR _cryptoInfo$[ebp]
  0004c	8b 75 0c	 mov	 esi, DWORD PTR _write_buf$[ebp]
  0004f	89 45 f8	 mov	 DWORD PTR _unitNo$[ebp], eax
  00052	8b c3		 mov	 eax, ebx
  00054	89 55 fc	 mov	 DWORD PTR _unitNo$[ebp+4], edx
  00057	99		 cdq
  00058	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  0005e	03 c2		 add	 eax, edx
  00060	c1 f8 09	 sar	 eax, 9
  00063	50		 push	 eax
  00064	8d 45 f8	 lea	 eax, DWORD PTR _unitNo$[ebp]
  00067	50		 push	 eax
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 _EncryptDataUnits
  0006e	83 c4 10	 add	 esp, 16			; 00000010H

; 1148 : 
; 1149 : 	if (WriteThreadRunning)

  00071	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _WriteThreadRunning, 0
  00078	74 76		 je	 SHORT $LN3@FlushForma

; 1150 : 	{
; 1151 : 		if (WaitForSingleObject (WriteBufferEmptyEvent, INFINITE) == WAIT_FAILED)

  0007a	6a ff		 push	 -1
  0007c	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteBufferEmptyEvent
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  00088	83 f8 ff	 cmp	 eax, -1
  0008b	74 5a		 je	 SHORT $LN12@FlushForma

; 1152 : 			return FALSE;
; 1153 : 		
; 1154 : 		if (WriteRequestResult != ERROR_SUCCESS)

  0008d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _WriteRequestResult, 0
  00094	74 21		 je	 SHORT $LN6@FlushForma

; 1155 : 		{
; 1156 : 			SetEvent (WriteBufferEmptyEvent);

  00096	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteBufferEmptyEvent
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 1157 : 			SetLastError (WriteRequestResult);

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteRequestResult
  000a7	50		 push	 eax
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  000ae	5e		 pop	 esi
  000af	5f		 pop	 edi

; 1158 : 			return FALSE;

  000b0	33 c0		 xor	 eax, eax
  000b2	5b		 pop	 ebx

; 1176 : }

  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
$LN6@FlushForma:

; 1159 : 		}
; 1160 : 
; 1161 : 		memcpy (WriteThreadBuffer, write_buf, *write_buf_cnt);

  000b7	ff 37		 push	 DWORD PTR [edi]
  000b9	56		 push	 esi
  000ba	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteThreadBuffer
  000c0	e8 00 00 00 00	 call	 _memcpy

; 1162 : 		WriteRequestHandle = dev;

  000c5	8b 45 08	 mov	 eax, DWORD PTR _dev$[ebp]
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cb	a3 00 00 00 00	 mov	 DWORD PTR _WriteRequestHandle, eax

; 1163 : 		WriteRequestSize = *write_buf_cnt;

  000d0	8b 07		 mov	 eax, DWORD PTR [edi]
  000d2	a3 00 00 00 00	 mov	 DWORD PTR _WriteRequestSize, eax

; 1164 : 
; 1165 : 		if (!SetEvent (WriteBufferFullEvent))

  000d7	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteBufferFullEvent
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  000e3	85 c0		 test	 eax, eax
  000e5	75 1f		 jne	 SHORT $LN8@FlushForma
$LN12@FlushForma:
  000e7	5e		 pop	 esi
  000e8	5f		 pop	 edi

; 1166 : 			return FALSE;

  000e9	33 c0		 xor	 eax, eax
  000eb	5b		 pop	 ebx

; 1176 : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
$LN3@FlushForma:

; 1167 : 	}
; 1168 : 	else
; 1169 : 	{
; 1170 : 		if (!WriteFile ((HANDLE) dev, write_buf, *write_buf_cnt, &bytesWritten, NULL))

  000f0	6a 00		 push	 0
  000f2	8d 45 10	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  000f5	50		 push	 eax
  000f6	ff 37		 push	 DWORD PTR [edi]
  000f8	56		 push	 esi
  000f9	ff 75 08	 push	 DWORD PTR _dev$[ebp]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00102	85 c0		 test	 eax, eax
  00104	74 e1		 je	 SHORT $LN12@FlushForma
$LN8@FlushForma:
  00106	5e		 pop	 esi

; 1171 : 			return FALSE;
; 1172 : 	}
; 1173 : 
; 1174 : 	*write_buf_cnt = 0;

  00107	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1175 : 	return TRUE;

  0010d	b8 01 00 00 00	 mov	 eax, 1
  00112	5f		 pop	 edi
  00113	5b		 pop	 ebx

; 1176 : }

  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
_FlushFormatWriteBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\format.c
;	COMDAT _WriteSector
_TEXT	SEGMENT
_dev$ = 8						; size = 4
_sector$ = 12						; size = 4
_write_buf$ = 16					; size = 4
_write_buf_cnt$ = 20					; size = 4
_nSecNo$ = 24						; size = 4
_cryptoInfo$ = 28					; size = 4
_WriteSector PROC					; COMDAT

; 960  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 961  : 	static __int32 updateTime = 0;
; 962  : 
; 963  : 	(*nSecNo)++;
; 964  : 
; 965  : 	memcpy (write_buf + *write_buf_cnt, sector, FormatSectorSize);

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _write_buf_cnt$[ebp]
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _FormatSectorSize
  0000e	57		 push	 edi
  0000f	8b 7d 18	 mov	 edi, DWORD PTR _nSecNo$[ebp]
  00012	56		 push	 esi
  00013	ff 75 0c	 push	 DWORD PTR _sector$[ebp]
  00016	83 07 01	 add	 DWORD PTR [edi], 1
  00019	83 57 04 00	 adc	 DWORD PTR [edi+4], 0
  0001d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0001f	03 45 10	 add	 eax, DWORD PTR _write_buf$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _memcpy

; 966  : 	(*write_buf_cnt) += FormatSectorSize;

  00028	01 33		 add	 DWORD PTR [ebx], esi
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	8b 03		 mov	 eax, DWORD PTR [ebx]

; 967  : 
; 968  : 	if (*write_buf_cnt == FormatWriteBufferSize && !FlushFormatWriteBuffer (dev, write_buf, write_buf_cnt, nSecNo, cryptoInfo))

  0002f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _FormatWriteBufferSize
  00035	75 1e		 jne	 SHORT $LN2@WriteSecto
  00037	ff 75 1c	 push	 DWORD PTR _cryptoInfo$[ebp]
  0003a	57		 push	 edi
  0003b	53		 push	 ebx
  0003c	ff 75 10	 push	 DWORD PTR _write_buf$[ebp]
  0003f	ff 75 08	 push	 DWORD PTR _dev$[ebp]
  00042	e8 00 00 00 00	 call	 _FlushFormatWriteBuffer
  00047	83 c4 14	 add	 esp, 20			; 00000014H
  0004a	85 c0		 test	 eax, eax
  0004c	75 07		 jne	 SHORT $LN2@WriteSecto
$LN6@WriteSecto:
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi

; 969  : 		return FALSE;

  00050	33 c0		 xor	 eax, eax
  00052	5b		 pop	 ebx

; 980  : 
; 981  : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN2@WriteSecto:

; 970  : 	
; 971  : 	if (GetTickCount () - updateTime > 25)

  00055	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  0005b	ff d6		 call	 esi
  0005d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?updateTime@?1??WriteSector@@9@9
  00063	83 f8 19	 cmp	 eax, 25			; 00000019H
  00066	76 27		 jbe	 SHORT $LN3@WriteSecto

; 972  : 	{
; 973  : 		if (UpdateProgressBar (*nSecNo * FormatSectorSize))

  00068	ff 77 04	 push	 DWORD PTR [edi+4]
  0006b	ff 37		 push	 DWORD PTR [edi]
  0006d	6a 00		 push	 0
  0006f	ff 35 00 00 00
	00		 push	 DWORD PTR _FormatSectorSize
  00075	e8 00 00 00 00	 call	 __allmul
  0007a	52		 push	 edx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _UpdateProgressBar
  00081	83 c4 08	 add	 esp, 8
  00084	85 c0		 test	 eax, eax
  00086	75 c6		 jne	 SHORT $LN6@WriteSecto

; 974  : 			return FALSE;
; 975  : 
; 976  : 		updateTime = GetTickCount ();

  00088	ff d6		 call	 esi
  0008a	a3 00 00 00 00	 mov	 DWORD PTR ?updateTime@?1??WriteSector@@9@9, eax
$LN3@WriteSecto:

; 977  : 	}
; 978  : 
; 979  : 	return TRUE;

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	b8 01 00 00 00	 mov	 eax, 1
  00096	5b		 pop	 ebx

; 980  : 
; 981  : }

  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_WriteSector ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\format.c
;	COMDAT _FormatNoFs
_TEXT	SEGMENT
_sector$ = -4644					; size = 4096
_newOffset$ = -548					; size = 8
_write_buf_cnt$ = -540					; size = 4
_nSecNo$ = -536						; size = 8
_dev$GSCopy$1$ = -528					; size = 4
_err$1$ = -528						; size = 4
_retVal$1$ = -524					; size = 4
_startOffset$2$ = -520					; size = 4
_write_buf$1$ = -520					; size = 4
_originalK2$ = -516					; size = 256
_temporaryKey$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_startSector$ = 8					; size = 8
_num_sectors$ = 16					; size = 8
_dev$ = 24						; size = 4
_cryptoInfo$ = 28					; size = 4
_quickFormat$ = 32					; size = 4
_FormatNoFs PROC					; COMDAT

; 770  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 24 12 00 00	 mov	 eax, 4644		; 00001224H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 771  : 	int write_buf_cnt = 0;
; 772  : 	char sector[GST_MAX_VOLUME_SECTOR_SIZE], *write_buf;
; 773  : 	unsigned __int64 nSecNo = startSector;

  00017	8b 55 0c	 mov	 edx, DWORD PTR _startSector$[ebp+4]

; 774  : 	int retVal = 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _startSector$[ebp]
  0001f	53		 push	 ebx
  00020	8b 5d 1c	 mov	 ebx, DWORD PTR _cryptoInfo$[ebp]
  00023	56		 push	 esi
  00024	8b 75 18	 mov	 esi, DWORD PTR _dev$[ebp]
  00027	57		 push	 edi

; 775  : 	DWORD err;
; 776  : 	char temporaryKey[MASTER_KEYDATA_SIZE];
; 777  : 	char originalK2[MASTER_KEYDATA_SIZE];
; 778  : 
; 779  : 	LARGE_INTEGER startOffset;
; 780  : 	LARGE_INTEGER newOffset;
; 781  : 
; 782  : 	// Seek to start sector
; 783  : 	startOffset.QuadPart = startSector * FormatSectorSize;

  00028	52		 push	 edx
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	ff 35 00 00 00
	00		 push	 DWORD PTR _FormatSectorSize
  00031	89 b5 f0 fd ff
	ff		 mov	 DWORD PTR _dev$GSCopy$1$[ebp], esi
  00037	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _write_buf_cnt$[ebp], 0
  00041	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _nSecNo$[ebp], ecx
  00047	89 95 ec fd ff
	ff		 mov	 DWORD PTR _nSecNo$[ebp+4], edx
  0004d	e8 00 00 00 00	 call	 __allmul

; 784  : 	if (!SetFilePointerEx ((HANDLE) dev, startOffset, &newOffset, FILE_BEGIN)
; 785  : 		|| newOffset.QuadPart != startOffset.QuadPart)

  00052	6a 00		 push	 0
  00054	8b f8		 mov	 edi, eax
  00056	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _newOffset$[ebp]
  0005c	51		 push	 ecx
  0005d	8b c2		 mov	 eax, edx
  0005f	50		 push	 eax
  00060	57		 push	 edi
  00061	56		 push	 esi
  00062	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _startOffset$2$[ebp], eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0006e	85 c0		 test	 eax, eax
  00070	0f 84 86 03 00
	00		 je	 $LN25@FormatNoFs
  00076	39 bd dc fd ff
	ff		 cmp	 DWORD PTR _newOffset$[ebp], edi
  0007c	0f 85 7a 03 00
	00		 jne	 $LN25@FormatNoFs
  00082	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _startOffset$2$[ebp]
  00088	39 85 e0 fd ff
	ff		 cmp	 DWORD PTR _newOffset$[ebp+4], eax
  0008e	0f 85 68 03 00
	00		 jne	 $LN25@FormatNoFs

; 786  : 	{
; 787  : 		return ERR_OS_ERROR;
; 788  : 	}
; 789  : 
; 790  : 	write_buf = (char *)GSTalloc (FormatWriteBufferSize);

  00094	ff 35 00 00 00
	00		 push	 DWORD PTR _FormatWriteBufferSize
  0009a	e8 00 00 00 00	 call	 _malloc
  0009f	83 c4 04	 add	 esp, 4
  000a2	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _write_buf$1$[ebp], eax

; 791  : 	if (!write_buf)

  000a8	85 c0		 test	 eax, eax
  000aa	75 16		 jne	 SHORT $LN26@FormatNoFs

; 792  : 		return ERR_OUTOFMEMORY;

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	b8 02 00 00 00	 mov	 eax, 2
  000b3	5b		 pop	 ebx

; 875  : }

  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	33 cd		 xor	 ecx, ebp
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
$LN26@FormatNoFs:

; 793  : 
; 794  : 	VirtualLock (temporaryKey, sizeof (temporaryKey));

  000c2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualLock@8
  000c8	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  000ce	68 00 01 00 00	 push	 256			; 00000100H
  000d3	50		 push	 eax
  000d4	ff d6		 call	 esi

; 795  : 	VirtualLock (originalK2, sizeof (originalK2));

  000d6	68 00 01 00 00	 push	 256			; 00000100H
  000db	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _originalK2$[ebp]
  000e1	50		 push	 eax
  000e2	ff d6		 call	 esi

; 796  : 
; 797  : 	memset (sector, 0, sizeof (sector));

  000e4	68 00 10 00 00	 push	 4096			; 00001000H
  000e9	8d 85 dc ed ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  000ef	6a 00		 push	 0
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _memset
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 798  : 
; 799  : 	// Remember the original secondary key (XTS mode) before generating a temporary one
; 800  : 	memcpy (originalK2, cryptoInfo->k2, sizeof (cryptoInfo->k2));

  000fa	8d b3 50 1d 00
	00		 lea	 esi, DWORD PTR [ebx+7504]

; 801  : 
; 802  : 	/* Fill the rest of the data area with random data */
; 803  : 
; 804  : 	if(!quickFormat)

  00100	83 7d 20 00	 cmp	 DWORD PTR _quickFormat$[ebp], 0
  00104	8d bd fc fd ff
	ff		 lea	 edi, DWORD PTR _originalK2$[ebp]
  0010a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0010f	f3 a5		 rep movsd
  00111	0f 85 cb 01 00
	00		 jne	 $LN27@FormatNoFs

; 805  : 	{
; 806  : 		/* Generate a random temporary key set to be used for "dummy" encryption that will fill
; 807  : 		the free disk space (data area) with random data.  This is necessary for plausible
; 808  : 		deniability of hidden volumes. */
; 809  : 
; 810  : 		// Temporary master key
; 811  : 		if (!RandgetBytes (temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE))

  00117	6a 00		 push	 0
  00119	ff 33		 push	 DWORD PTR [ebx]
  0011b	e8 00 00 00 00	 call	 _EAGetKeySize
  00120	83 c4 04	 add	 esp, 4
  00123	50		 push	 eax
  00124	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _RandgetBytes
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
  00133	85 c0		 test	 eax, eax
  00135	0f 84 b3 02 00
	00		 je	 $LN130@FormatNoFs

; 812  : 			goto fail;
; 813  : 
; 814  : 		// Temporary secondary key (XTS mode)
; 815  : 		if (!RandgetBytes (cryptoInfo->k2, sizeof cryptoInfo->k2, FALSE))

  0013b	6a 00		 push	 0
  0013d	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  00143	68 00 01 00 00	 push	 256			; 00000100H
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _RandgetBytes
  0014e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00151	85 c0		 test	 eax, eax
  00153	0f 84 95 02 00
	00		 je	 $LN130@FormatNoFs

; 816  : 			goto fail;
; 817  : 
; 818  : 		retVal = EAInit (cryptoInfo->ea, temporaryKey, cryptoInfo->ks);

  00159	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  0015c	50		 push	 eax
  0015d	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  00163	50		 push	 eax
  00164	ff 33		 push	 DWORD PTR [ebx]
  00166	e8 00 00 00 00	 call	 _EAInit
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016e	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _retVal$1$[ebp], eax

; 819  : 		if (retVal != ERR_SUCCESS)

  00174	85 c0		 test	 eax, eax
  00176	0f 85 79 02 00
	00		 jne	 $LN132@FormatNoFs

; 820  : 			goto fail;
; 821  : 
; 822  : 		if (!EAInitMode (cryptoInfo))

  0017c	53		 push	 ebx
  0017d	e8 00 00 00 00	 call	 _EAInitMode
  00182	83 c4 04	 add	 esp, 4
  00185	85 c0		 test	 eax, eax
  00187	75 08		 jne	 SHORT $LN54@FormatNoFs

; 823  : 		{
; 824  : 			retVal = ERR_MODE_INIT_FAILED;

  00189	8d 58 1b	 lea	 ebx, DWORD PTR [eax+27]

; 825  : 			goto fail;

  0018c	e9 8e 00 00 00	 jmp	 $fail$146
$LN54@FormatNoFs:

; 826  : 		}
; 827  : 
; 828  : 		while (num_sectors--)

  00191	8b 75 10	 mov	 esi, DWORD PTR _num_sectors$[ebp]
  00194	8b c6		 mov	 eax, esi
  00196	8b 7d 14	 mov	 edi, DWORD PTR _num_sectors$[ebp+4]
  00199	0b c7		 or	 eax, edi
  0019b	74 4b		 je	 SHORT $LN136@FormatNoFs
  0019d	0f 1f 00	 npad	 3
$LL2@FormatNoFs:

; 829  : 		{
; 830  : 			if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 831  : 				cryptoInfo) == FALSE)

  001a0	53		 push	 ebx
  001a1	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  001a7	83 c6 ff	 add	 esi, -1
  001aa	50		 push	 eax
  001ab	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  001b1	83 d7 ff	 adc	 edi, -1
  001b4	50		 push	 eax
  001b5	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _write_buf$1$[ebp]
  001bb	8d 85 dc ed ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  001c1	50		 push	 eax
  001c2	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  001c8	e8 00 00 00 00	 call	 _WriteSector
  001cd	83 c4 18	 add	 esp, 24			; 00000018H
  001d0	85 c0		 test	 eax, eax
  001d2	74 45		 je	 SHORT $LN135@FormatNoFs

; 826  : 		}
; 827  : 
; 828  : 		while (num_sectors--)

  001d4	8b c6		 mov	 eax, esi
  001d6	0b c7		 or	 eax, edi
  001d8	75 c6		 jne	 SHORT $LL2@FormatNoFs
  001da	8b bd ec fd ff
	ff		 mov	 edi, DWORD PTR _nSecNo$[ebp+4]
  001e0	8b b5 e8 fd ff
	ff		 mov	 esi, DWORD PTR _nSecNo$[ebp]
  001e6	eb 06		 jmp	 SHORT $LN64@FormatNoFs
$LN136@FormatNoFs:
  001e8	8b 75 08	 mov	 esi, DWORD PTR _startSector$[ebp]
  001eb	8b 7d 0c	 mov	 edi, DWORD PTR _startSector$[ebp+4]
$LN64@FormatNoFs:

; 832  : 				goto fail;
; 833  : 		}
; 834  : 
; 835  : 		if (!FlushFormatWriteBuffer (dev, write_buf, &write_buf_cnt, &nSecNo, cryptoInfo))

  001ee	53		 push	 ebx
  001ef	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  001f5	50		 push	 eax
  001f6	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  001fc	50		 push	 eax
  001fd	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _write_buf$1$[ebp]
  00203	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  00209	e8 00 00 00 00	 call	 _FlushFormatWriteBuffer
  0020e	83 c4 14	 add	 esp, 20			; 00000014H
  00211	85 c0		 test	 eax, eax
  00213	0f 85 db 00 00
	00		 jne	 $LN28@FormatNoFs
$LN135@FormatNoFs:
  00219	8b 9d f4 fd ff
	ff		 mov	 ebx, DWORD PTR _retVal$1$[ebp]
$fail$146:

; 863  : 
; 864  : fail:
; 865  : 	err = GetLastError();

  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 866  : 
; 867  : 	burn (temporaryKey, sizeof(temporaryKey));

  00225	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _temporaryKey$[ebp]
  0022b	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _err$1$[ebp], eax
  00231	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00236	8b f1		 mov	 esi, ecx
  00238	8b fa		 mov	 edi, edx
  0023a	66 0f 1f 44 00
	00		 npad	 6
$LL47@FormatNoFs:
  00240	c6 06 00	 mov	 BYTE PTR [esi], 0
  00243	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00246	83 ef 01	 sub	 edi, 1
  00249	75 f5		 jne	 SHORT $LL47@FormatNoFs
  0024b	0f 1f 44 00 00	 npad	 5
$LL17@FormatNoFs:
  00250	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00253	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00256	83 ea 01	 sub	 edx, 1
  00259	75 f5		 jne	 SHORT $LL17@FormatNoFs

; 868  : 	burn (originalK2, sizeof(originalK2));

  0025b	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _originalK2$[ebp]
  00261	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00266	8b f1		 mov	 esi, ecx
  00268	8b d0		 mov	 edx, eax
  0026a	66 0f 1f 44 00
	00		 npad	 6
$LL51@FormatNoFs:
  00270	c6 02 00	 mov	 BYTE PTR [edx], 0
  00273	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00276	83 ee 01	 sub	 esi, 1
  00279	75 f5		 jne	 SHORT $LL51@FormatNoFs
  0027b	0f 1f 44 00 00	 npad	 5
$LL22@FormatNoFs:
  00280	c6 00 00	 mov	 BYTE PTR [eax], 0
  00283	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00286	83 e9 01	 sub	 ecx, 1
  00289	75 f5		 jne	 SHORT $LL22@FormatNoFs

; 869  : 	VirtualUnlock (temporaryKey, sizeof (temporaryKey));

  0028b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualUnlock@8
  00291	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  00297	68 00 01 00 00	 push	 256			; 00000100H
  0029c	50		 push	 eax
  0029d	ff d6		 call	 esi

; 870  : 	VirtualUnlock (originalK2, sizeof (originalK2));

  0029f	68 00 01 00 00	 push	 256			; 00000100H
  002a4	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _originalK2$[ebp]
  002aa	50		 push	 eax
  002ab	ff d6		 call	 esi

; 871  : 	GSTfree (write_buf);

  002ad	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _write_buf$1$[ebp]
  002b3	e8 00 00 00 00	 call	 _free
  002b8	83 c4 04	 add	 esp, 4

; 872  : 
; 873  : 	SetLastError (err);

  002bb	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _err$1$[ebp]
  002c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 874  : 	return (retVal ? retVal : ERR_OS_ERROR);

  002c7	85 db		 test	 ebx, ebx
  002c9	b8 01 00 00 00	 mov	 eax, 1
  002ce	5f		 pop	 edi
  002cf	5e		 pop	 esi
  002d0	0f 45 c3	 cmovne	 eax, ebx
  002d3	5b		 pop	 ebx

; 875  : }

  002d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d7	33 cd		 xor	 ecx, ebp
  002d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002de	8b e5		 mov	 esp, ebp
  002e0	5d		 pop	 ebp
  002e1	c3		 ret	 0
$LN27@FormatNoFs:

; 836  : 			goto fail;
; 837  : 	}
; 838  : 	else
; 839  : 		nSecNo = num_sectors;

  002e2	8b 75 10	 mov	 esi, DWORD PTR _num_sectors$[ebp]
  002e5	8b 7d 14	 mov	 edi, DWORD PTR _num_sectors$[ebp+4]
  002e8	89 b5 e8 fd ff
	ff		 mov	 DWORD PTR _nSecNo$[ebp], esi
  002ee	89 bd ec fd ff
	ff		 mov	 DWORD PTR _nSecNo$[ebp+4], edi
$LN28@FormatNoFs:

; 840  : 
; 841  : 	UpdateProgressBar (nSecNo * FormatSectorSize);

  002f4	57		 push	 edi
  002f5	56		 push	 esi
  002f6	6a 00		 push	 0
  002f8	ff 35 00 00 00
	00		 push	 DWORD PTR _FormatSectorSize
  002fe	e8 00 00 00 00	 call	 __allmul
  00303	52		 push	 edx
  00304	50		 push	 eax
  00305	e8 00 00 00 00	 call	 _UpdateProgressBar

; 842  : 
; 843  : 	// Restore the original secondary key (XTS mode) in case NTFS format fails and the user wants to try FAT immediately
; 844  : 	memcpy (cryptoInfo->k2, originalK2, sizeof (cryptoInfo->k2));
; 845  : 
; 846  : 	// Reinitialize the encryption algorithm and mode in case NTFS format fails and the user wants to try FAT immediately
; 847  : 	retVal = EAInit (cryptoInfo->ea, cryptoInfo->master_keydata, cryptoInfo->ks);

  0030a	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  0030d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00312	50		 push	 eax
  00313	8d 83 50 1c 00
	00		 lea	 eax, DWORD PTR [ebx+7248]
  00319	50		 push	 eax
  0031a	ff 33		 push	 DWORD PTR [ebx]
  0031c	8d b5 fc fd ff
	ff		 lea	 esi, DWORD PTR _originalK2$[ebp]
  00322	8d bb 50 1d 00
	00		 lea	 edi, DWORD PTR [ebx+7504]
  00328	f3 a5		 rep movsd
  0032a	e8 00 00 00 00	 call	 _EAInit
  0032f	83 c4 14	 add	 esp, 20			; 00000014H
  00332	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _retVal$1$[ebp], eax

; 848  : 	if (retVal != ERR_SUCCESS)

  00338	85 c0		 test	 eax, eax
  0033a	0f 85 d9 fe ff
	ff		 jne	 $LN135@FormatNoFs

; 849  : 		goto fail;
; 850  : 	if (!EAInitMode (cryptoInfo))

  00340	53		 push	 ebx
  00341	e8 00 00 00 00	 call	 _EAInitMode
  00346	83 c4 04	 add	 esp, 4
  00349	85 c0		 test	 eax, eax
  0034b	75 08		 jne	 SHORT $LN6@FormatNoFs

; 851  : 	{
; 852  : 		retVal = ERR_MODE_INIT_FAILED;

  0034d	8d 58 1b	 lea	 ebx, DWORD PTR [eax+27]
  00350	e9 ca fe ff ff	 jmp	 $fail$146
$LN6@FormatNoFs:

; 853  : 		goto fail;
; 854  : 	}
; 855  : 
; 856  : 	burn (temporaryKey, sizeof(temporaryKey));

  00355	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  0035b	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00360	8b f1		 mov	 esi, ecx
  00362	8b d0		 mov	 edx, eax
$LL39@FormatNoFs:
  00364	c6 02 00	 mov	 BYTE PTR [edx], 0
  00367	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0036a	83 ee 01	 sub	 esi, 1
  0036d	75 f5		 jne	 SHORT $LL39@FormatNoFs
  0036f	90		 npad	 1
$LL7@FormatNoFs:
  00370	c6 00 00	 mov	 BYTE PTR [eax], 0
  00373	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00376	83 e9 01	 sub	 ecx, 1
  00379	75 f5		 jne	 SHORT $LL7@FormatNoFs

; 857  : 	burn (originalK2, sizeof(originalK2));

  0037b	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _originalK2$[ebp]
  00381	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00386	8b f1		 mov	 esi, ecx
  00388	8b d0		 mov	 edx, eax
  0038a	66 0f 1f 44 00
	00		 npad	 6
$LL43@FormatNoFs:
  00390	c6 02 00	 mov	 BYTE PTR [edx], 0
  00393	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00396	83 ee 01	 sub	 esi, 1
  00399	75 f5		 jne	 SHORT $LL43@FormatNoFs
  0039b	0f 1f 44 00 00	 npad	 5
$LL12@FormatNoFs:
  003a0	c6 00 00	 mov	 BYTE PTR [eax], 0
  003a3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  003a6	83 e9 01	 sub	 ecx, 1
  003a9	75 f5		 jne	 SHORT $LL12@FormatNoFs

; 858  : 	VirtualUnlock (temporaryKey, sizeof (temporaryKey));

  003ab	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualUnlock@8
  003b1	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  003b7	68 00 01 00 00	 push	 256			; 00000100H
  003bc	50		 push	 eax
  003bd	ff d6		 call	 esi

; 859  : 	VirtualUnlock (originalK2, sizeof (originalK2));

  003bf	68 00 01 00 00	 push	 256			; 00000100H
  003c4	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _originalK2$[ebp]
  003ca	50		 push	 eax
  003cb	ff d6		 call	 esi

; 860  : 	GSTfree (write_buf);

  003cd	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _write_buf$1$[ebp]
  003d3	e8 00 00 00 00	 call	 _free
  003d8	83 c4 04	 add	 esp, 4

; 861  : 
; 862  : 	return 0;

  003db	33 c0		 xor	 eax, eax
  003dd	5f		 pop	 edi
  003de	5e		 pop	 esi
  003df	5b		 pop	 ebx

; 875  : }

  003e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e3	33 cd		 xor	 ecx, ebp
  003e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ea	8b e5		 mov	 esp, ebp
  003ec	5d		 pop	 ebp
  003ed	c3		 ret	 0
$LN130@FormatNoFs:
  003ee	33 db		 xor	 ebx, ebx
  003f0	e9 2a fe ff ff	 jmp	 $fail$146
$LN132@FormatNoFs:
  003f5	8b d8		 mov	 ebx, eax
  003f7	e9 23 fe ff ff	 jmp	 $fail$146
$LN25@FormatNoFs:
  003fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ff	b8 01 00 00 00	 mov	 eax, 1
  00404	5f		 pop	 edi
  00405	5e		 pop	 esi
  00406	33 cd		 xor	 ecx, ebp
  00408	5b		 pop	 ebx
  00409	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040e	8b e5		 mov	 esp, ebp
  00410	5d		 pop	 ebp
  00411	c3		 ret	 0
_FormatNoFs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\format.c
;	COMDAT _GetVolumeDataAreaSize
_TEXT	SEGMENT
_hiddenVolume$ = 8					; size = 4
_volumeSize$ = 12					; size = 8
_GetVolumeDataAreaSize PROC				; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	uint64 reservedSize;
; 61   : 
; 62   : 	if (hiddenVolume)

  00003	83 7d 08 00	 cmp	 DWORD PTR _hiddenVolume$[ebp], 0
  00007	8b 55 10	 mov	 edx, DWORD PTR _volumeSize$[ebp+4]
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _volumeSize$[ebp]
  0000d	74 1b		 je	 SHORT $LN2@GetVolumeD

; 63   : 	{
; 64   : 		// Reserve free space at the end of the host filesystem. FAT file system fills the last sector with
; 65   : 		// zeroes (marked as free; observed when quick format was performed using the OS format tool).
; 66   : 		// Therefore, when the outer volume is mounted with hidden volume protection, such write operations
; 67   : 		// (e.g. quick formatting the outer volume filesystem as FAT) would needlessly trigger hidden volume
; 68   : 		// protection.
; 69   : 
; 70   : #if GST_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE > 4096
; 71   : #	error	GST_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE too large for very small volumes. Revise the code.
; 72   : #endif
; 73   : 
; 74   : #if GST_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH < GST_MAX_VOLUME_SECTOR_SIZE
; 75   : #	error	GST_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH too small.
; 76   : #endif
; 77   : 		
; 78   : 		if (volumeSize < GST_VOLUME_SMALL_SIZE_THRESHOLD)

  0000f	85 d2		 test	 edx, edx
  00011	77 10		 ja	 SHORT $LN4@GetVolumeD
  00013	72 07		 jb	 SHORT $LN8@GetVolumeD
  00015	3d 00 00 20 00	 cmp	 eax, 2097152		; 00200000H
  0001a	73 07		 jae	 SHORT $LN4@GetVolumeD
$LN8@GetVolumeD:

; 79   : 			reservedSize = GST_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE;

  0001c	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00021	eb 0c		 jmp	 SHORT $LN3@GetVolumeD
$LN4@GetVolumeD:

; 80   : 		else
; 81   : 			reservedSize = GST_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH; // Ensure size of a hidden volume larger than GST_VOLUME_SMALL_SIZE_THRESHOLD is a multiple of the maximum supported sector size

  00023	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H

; 82   : 	}

  00028	eb 05		 jmp	 SHORT $LN3@GetVolumeD
$LN2@GetVolumeD:

; 83   : 	else
; 84   : 	{
; 85   : 		reservedSize = GST_TOTAL_VOLUME_HEADERS_SIZE;

  0002a	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
$LN3@GetVolumeD:

; 86   : 	}
; 87   : 
; 88   : 	if (volumeSize < reservedSize)

  0002f	85 d2		 test	 edx, edx
  00031	77 0c		 ja	 SHORT $LN6@GetVolumeD
  00033	72 04		 jb	 SHORT $LN9@GetVolumeD
  00035	3b c1		 cmp	 eax, ecx
  00037	73 06		 jae	 SHORT $LN6@GetVolumeD
$LN9@GetVolumeD:

; 89   : 		return 0;

  00039	33 c0		 xor	 eax, eax
  0003b	33 d2		 xor	 edx, edx

; 92   : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN6@GetVolumeD:

; 90   : 
; 91   : 	return volumeSize - reservedSize;

  0003f	2b c1		 sub	 eax, ecx
  00041	83 da 00	 sbb	 edx, 0

; 92   : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_GetVolumeDataAreaSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\format.c
;	COMDAT _FormatNtfs
_TEXT	SEGMENT
_hModule$1$ = -24					; size = 4
_dir$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_driveNo$ = 8						; size = 4
_clusterSize$ = 12					; size = 4
_FormatNtfs PROC					; COMDAT

; 909  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 910  : 	WCHAR dir[8] = { (WCHAR) driveNo + 'A', 0 };

  00010	8b 45 08	 mov	 eax, DWORD PTR _driveNo$[ebp]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	53		 push	 ebx
  00017	83 c0 41	 add	 eax, 65			; 00000041H
  0001a	66 0f d6 45 f0	 movq	 QWORD PTR _dir$[ebp+4], xmm0
  0001f	66 89 45 ec	 mov	 WORD PTR _dir$[ebp], ax
  00023	33 c0		 xor	 eax, eax

; 911  : 	PFORMATEX FormatEx;
; 912  : 	HMODULE hModule = LoadLibraryEx("fmifs.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);

  00025	68 00 08 00 00	 push	 2048			; 00000800H
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_09IFOENPLD@fmifs?4dll?$AA@
  00030	66 89 45 ee	 mov	 WORD PTR _dir$[ebp+2], ax
  00034	89 45 f8	 mov	 DWORD PTR _dir$[ebp+12], eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryExA@12
  0003d	8b d8		 mov	 ebx, eax
  0003f	89 5d e8	 mov	 DWORD PTR _hModule$1$[ebp], ebx

; 913  : 	int i;
; 914  : 
; 915  : 	if (hModule == NULL)

  00042	85 db		 test	 ebx, ebx
  00044	75 0f		 jne	 SHORT $LN5@FormatNtfs
  00046	5b		 pop	 ebx

; 940  : }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN5@FormatNtfs:
  00055	57		 push	 edi

; 916  : 		return FALSE;
; 917  : 
; 918  : 	if (!(FormatEx = (PFORMATEX) GetProcAddress (GetModuleHandle ("fmifs.dll"), "FormatEx")))

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_08KDJACLKO@FormatEx?$AA@
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_09IFOENPLD@fmifs?4dll?$AA@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00066	50		 push	 eax
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0006d	8b f8		 mov	 edi, eax
  0006f	85 ff		 test	 edi, edi
  00071	75 19		 jne	 SHORT $LN6@FormatNtfs

; 919  : 	{
; 920  : 		FreeLibrary (hModule);

  00073	53		 push	 ebx
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  0007a	5f		 pop	 edi

; 921  : 		return FALSE;

  0007b	33 c0		 xor	 eax, eax
  0007d	5b		 pop	 ebx

; 940  : }

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00081	33 cd		 xor	 ecx, ebp
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
$LN6@FormatNtfs:

; 922  : 	}
; 923  : 
; 924  : 	wcscat (dir, L":\\");

  0008c	8d 4d ec	 lea	 ecx, DWORD PTR _dir$[ebp]
  0008f	83 c1 fe	 add	 ecx, -2			; fffffffeH
$LL12@FormatNtfs:
  00092	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  00096	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00099	66 85 c0	 test	 ax, ax
  0009c	75 f4		 jne	 SHORT $LL12@FormatNtfs
  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@

; 925  : 
; 926  : 	FormatExResult = FALSE;
; 927  : 
; 928  : 	// Windows sometimes fails to format a volume (hosted on a removable medium) as NTFS.
; 929  : 	// It often helps to retry several times.
; 930  : 	for (i = 0; i < 50 && FormatExResult != TRUE; i++)

  000a3	8b 5d 0c	 mov	 ebx, DWORD PTR _clusterSize$[ebp]
  000a6	89 01		 mov	 DWORD PTR [ecx], eax
  000a8	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@+4
  000ae	56		 push	 esi
  000af	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  000b3	33 f6		 xor	 esi, esi
  000b5	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _FormatExResult, 0
  000bc	0f 1f 40 00	 npad	 4
$LL4@FormatNtfs:
  000c0	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR _FormatExResult, 1
  000c7	74 28		 je	 SHORT $LN3@FormatNtfs

; 931  : 	{
; 932  : 		FormatEx (dir, FMIFS_HARDDISK, L"NTFS", L"", TRUE, clusterSize * FormatSectorSize, FormatExCallback);

  000c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  000ce	68 00 00 00 00	 push	 OFFSET _FormatExCallback@12
  000d3	0f af c3	 imul	 eax, ebx
  000d6	50		 push	 eax
  000d7	6a 01		 push	 1
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@
  000e3	6a 0c		 push	 12			; 0000000cH
  000e5	8d 45 ec	 lea	 eax, DWORD PTR _dir$[ebp]
  000e8	50		 push	 eax
  000e9	ff d7		 call	 edi
  000eb	46		 inc	 esi
  000ec	83 fe 32	 cmp	 esi, 50			; 00000032H
  000ef	7c cf		 jl	 SHORT $LL4@FormatNtfs
$LN3@FormatNtfs:

; 933  : 	}
; 934  : 
; 935  : 	// The device may be referenced for some time after FormatEx() returns
; 936  : 	Sleep (2000);

  000f1	68 d0 07 00 00	 push	 2000			; 000007d0H
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 937  : 
; 938  : 	FreeLibrary (hModule);

  000fc	ff 75 e8	 push	 DWORD PTR _hModule$1$[ebp]
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 939  : 	return FormatExResult;

  00105	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _FormatExResult

; 940  : }

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010f	5e		 pop	 esi
  00110	5f		 pop	 edi
  00111	33 cd		 xor	 ecx, ebp
  00113	5b		 pop	 ebx
  00114	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
_FormatNtfs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\format.c
;	COMDAT _GSTFormatVolume
_TEXT	SEGMENT
_ftCreationTime$ = -140844				; size = 8
_ftLastAccessTime$ = -140836				; size = 8
_ftLastWriteTime$ = -140828				; size = 8
_tmp$1 = -140820					; size = 4
_bw$2 = -140816						; size = 4
_bytesWritten$3 = -140812				; size = 4
_bTimeStampValid$1$ = -140808				; size = 4
_num_sectors$1$ = -140804				; size = 4
_num_sectors$2$ = -140800				; size = 4
_dwResult$4 = -140796					; size = 4
_bFailedRequiredDASD$1$ = -140792			; size = 4
_driveLetter$1$ = -140788				; size = 4
_dataOffset$1$ = -140784				; size = 4
_dataOffset$2$ = -140780				; size = 4
tv615 = -140776						; size = 8
_startSector$2$ = -140772				; size = 4
_cnt$1$ = -140772					; size = 4
_bInstantRetryOtherFilesys$1$ = -140772			; size = 4
_cryptoInfo$ = -140768					; size = 4
_dataAreaSize$1$ = -140764				; size = 4
_rootPath$5 = -140760					; size = 4
_szDriveLetter$6 = -140756				; size = 3
tv162 = -140752						; size = 8
_volumeSize$2$ = -140748				; size = 4
_driveNo$1$ = -140748					; size = 4
_dwError$1$ = -140748					; size = 4
_nPass$1$ = -140748					; size = 4
_nStatus$1$ = -140748					; size = 4
_dataAreaSize$2$ = -140744				; size = 4
_mountOptions$7 = -140740				; size = 100
_ft$ = -140640						; size = 68
_buf$8 = -140572					; size = 130560
_buf$9 = -10012						; size = 8192
_deviceName$ = -1820					; size = 520
_uniqVolName$10 = -1300					; size = 261
_dosDev$ = -1036					; size = 260
_header$ = -776						; size = 512
_devName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_volParams$ = 8						; size = 4
_GSTFormatVolume PROC					; COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 2c 26 02 00	 mov	 eax, 140844		; 0002262cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _volParams$[ebp]
  0001b	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  00021	57		 push	 edi
  00022	68 04 01 00 00	 push	 260			; 00000104H
  00027	6a 00		 push	 0
  00029	50		 push	 eax

; 117  : 	int nStatus;
; 118  : 	PCRYPTO_INFO cryptoInfo = NULL;

  0002a	c7 85 20 da fd
	ff 00 00 00 00	 mov	 DWORD PTR _cryptoInfo$[ebp], 0

; 119  : 	HANDLE dev = INVALID_HANDLE_VALUE;

  00034	83 cf ff	 or	 edi, -1

; 120  : 	DWORD dwError;
; 121  : 	char header[GST_VOLUME_HEADER_EFFECTIVE_SIZE];
; 122  : 	unsigned __int64 num_sectors, startSector;
; 123  : 	fatparams ft;
; 124  : 	FILETIME ftCreationTime;
; 125  : 	FILETIME ftLastWriteTime;
; 126  : 	FILETIME ftLastAccessTime;
; 127  : 	BOOL bTimeStampValid = FALSE;

  00037	c7 85 f8 d9 fd
	ff 00 00 00 00	 mov	 DWORD PTR _bTimeStampValid$1$[ebp], 0

; 128  : 	BOOL bInstantRetryOtherFilesys = FALSE;

  00041	c7 85 1c da fd
	ff 00 00 00 00	 mov	 DWORD PTR _bInstantRetryOtherFilesys$1$[ebp], 0
  0004b	e8 00 00 00 00	 call	 _memset
  00050	68 04 01 00 00	 push	 260			; 00000104H
  00055	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  0005b	6a 00		 push	 0
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _memset

; 129  : 	char dosDev[GST_MAX_PATH] = { 0 };
; 130  : 	char devName[MAX_PATH] = { 0 };
; 131  : 	int driveLetter = -1;
; 132  : 	WCHAR deviceName[MAX_PATH];
; 133  : 	uint64 dataOffset, dataAreaSize;
; 134  : 	LARGE_INTEGER offset;
; 135  : 	BOOL bFailedRequiredDASD = FALSE;
; 136  : 	int dwModeOfOperatioID = FIRST_MODE_OF_OPERATION_ID;
; 137  : 
; 138  : 	FormatSectorSize = volParams->sectorSize;

  00063	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  00066	83 c4 18	 add	 esp, 24			; 00000018H

; 139  : 
; 140  : 	if (FormatSectorSize < GST_MIN_VOLUME_SECTOR_SIZE
; 141  : 		|| FormatSectorSize > GST_MAX_VOLUME_SECTOR_SIZE
; 142  : 		|| FormatSectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  00069	8b c8		 mov	 ecx, eax
  0006b	a3 00 00 00 00	 mov	 DWORD PTR _FormatSectorSize, eax
  00070	89 bd 0c da fd
	ff		 mov	 DWORD PTR _driveLetter$1$[ebp], edi
  00076	c7 85 08 da fd
	ff 00 00 00 00	 mov	 DWORD PTR _bFailedRequiredDASD$1$[ebp], 0
  00080	8d 81 00 fe ff
	ff		 lea	 eax, DWORD PTR [ecx-512]
  00086	3d 00 0e 00 00	 cmp	 eax, 3584		; 00000e00H
  0008b	0f 87 6d 0d 00
	00		 ja	 $LN24@GSTFormatV
  00091	f7 c1 ff 01 00
	00		 test	 ecx, 511		; 000001ffH
  00097	0f 85 61 0d 00
	00		 jne	 $LN24@GSTFormatV

; 145  : 		return ERR_DONT_REPORT; 
; 146  : 	}
; 147  : 
; 148  : 	/* WARNING: Note that if Windows fails to format the volume as NTFS and the volume size is
; 149  : 	less than the maximum FAT size, the user is asked within this function whether he wants to instantly
; 150  : 	retry FAT format instead (to avoid having to re-create the whole container again). If the user
; 151  : 	answers yes, some of the input parameters are modified, the code below 'begin_format' is re-executed 
; 152  : 	and some destructive operations that were performed during the first attempt must be (and are) skipped. 
; 153  : 	Therefore, whenever adding or modifying any potentially destructive operations below 'begin_format',
; 154  : 	determine whether they (or their portions) need to be skipped during such a second attempt; if so, 
; 155  : 	use the 'bInstantRetryOtherFilesys' flag to skip them. */
; 156  : 
; 157  : 	if (volParams->hiddenVol)

  0009d	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  000a1	56		 push	 esi
  000a2	74 29		 je	 SHORT $LN25@GSTFormatV

; 158  : 	{
; 159  : 		dataOffset = volParams->hiddenVolHostSize - GST_VOLUME_HEADER_GROUP_SIZE - volParams->size;

  000a4	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  000a7	ba 00 00 fe ff	 mov	 edx, -131072		; fffe0000H
  000ac	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  000af	2b d0		 sub	 edx, eax
  000b1	8b c7		 mov	 eax, edi
  000b3	1b c1		 sbb	 eax, ecx
  000b5	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  000b8	8b 73 1c	 mov	 esi, DWORD PTR [ebx+28]
  000bb	03 ca		 add	 ecx, edx
  000bd	89 8d 10 da fd
	ff		 mov	 DWORD PTR _dataOffset$1$[ebp], ecx
  000c3	13 f0		 adc	 esi, eax
  000c5	89 b5 14 da fd
	ff		 mov	 DWORD PTR _dataOffset$2$[ebp], esi

; 160  : 	}

  000cb	eb 3e		 jmp	 SHORT $LN26@GSTFormatV
$LN25@GSTFormatV:

; 161  : 	else
; 162  : 	{
; 163  : 		if (volParams->size <= GST_TOTAL_VOLUME_HEADERS_SIZE)

  000cd	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  000d0	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000d3	85 c0		 test	 eax, eax
  000d5	77 20		 ja	 SHORT $LN27@GSTFormatV
  000d7	72 08		 jb	 SHORT $LN198@GSTFormatV
  000d9	81 f9 00 00 04
	00		 cmp	 ecx, 262144		; 00040000H
  000df	77 16		 ja	 SHORT $LN27@GSTFormatV
$LN198@GSTFormatV:
  000e1	5e		 pop	 esi
  000e2	5f		 pop	 edi

; 164  : 			return ERR_VOL_SIZE_WRONG;

  000e3	b8 07 00 00 00	 mov	 eax, 7
  000e8	5b		 pop	 ebx

; 746  : }

  000e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ec	33 cd		 xor	 ecx, ebp
  000ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
$LN27@GSTFormatV:

; 165  : 
; 166  : 		dataOffset = GST_VOLUME_DATA_OFFSET;

  000f7	c7 85 10 da fd
	ff 00 00 02 00	 mov	 DWORD PTR _dataOffset$1$[ebp], 131072 ; 00020000H
  00101	c7 85 14 da fd
	ff 00 00 00 00	 mov	 DWORD PTR _dataOffset$2$[ebp], 0
$LN26@GSTFormatV:

; 167  : 	}
; 168  : 
; 169  : 	dataAreaSize = GetVolumeDataAreaSize (volParams->hiddenVol, volParams->size);

  0010b	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0010e	50		 push	 eax
  0010f	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00112	50		 push	 eax
  00113	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011f	8b f0		 mov	 esi, eax
  00121	8b c2		 mov	 eax, edx
  00123	89 b5 24 da fd
	ff		 mov	 DWORD PTR _dataAreaSize$1$[ebp], esi
  00129	89 85 38 da fd
	ff		 mov	 DWORD PTR _dataAreaSize$2$[ebp], eax

; 170  : 
; 171  : 	num_sectors = dataAreaSize / FormatSectorSize;

  0012f	6a 00		 push	 0
  00131	ff 35 00 00 00
	00		 push	 DWORD PTR _FormatSectorSize
  00137	50		 push	 eax
  00138	56		 push	 esi
  00139	e8 00 00 00 00	 call	 __aulldiv

; 172  : 
; 173  : 	if (volParams->bDevice)

  0013e	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00141	89 85 fc d9 fd
	ff		 mov	 DWORD PTR _num_sectors$1$[ebp], eax
  00147	89 95 00 da fd
	ff		 mov	 DWORD PTR _num_sectors$2$[ebp], edx
  0014d	74 45		 je	 SHORT $LN28@GSTFormatV

; 174  : 	{
; 175  : 		strcpy ((char *)deviceName, volParams->volumePath);

  0014f	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00152	8d b5 e4 f8 ff
	ff		 lea	 esi, DWORD PTR _deviceName$[ebp]
  00158	2b f1		 sub	 esi, ecx
  0015a	66 0f 1f 44 00
	00		 npad	 6
$LL112@GSTFormatV:
  00160	8a 01		 mov	 al, BYTE PTR [ecx]
  00162	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00165	88 44 0e ff	 mov	 BYTE PTR [esi+ecx-1], al
  00169	84 c0		 test	 al, al
  0016b	75 f3		 jne	 SHORT $LL112@GSTFormatV

; 176  : 		ToUNICODE ((char *)deviceName);

  0016d	8d 85 e4 f8 ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 _ToUNICODE

; 177  : 
; 178  : 		driveLetter = GetDiskDeviceDriveLetter (deviceName);

  00179	8d 85 e4 f8 ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  00185	8b b5 24 da fd
	ff		 mov	 esi, DWORD PTR _dataAreaSize$1$[ebp]
  0018b	83 c4 08	 add	 esp, 8
  0018e	89 85 0c da fd
	ff		 mov	 DWORD PTR _driveLetter$1$[ebp], eax
$LN28@GSTFormatV:

; 179  : 	}
; 180  : 
; 181  : 	VirtualLock (header, sizeof (header));

  00194	68 00 02 00 00	 push	 512			; 00000200H
  00199	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0019f	50		 push	 eax
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 182  : 
; 183  : 	/* Switch between mode of operations depending on the ea */
; 184  : 	switch (volParams->ea)

  001a6	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  001a9	83 e8 01	 sub	 eax, 1
  001ac	74 0a		 je	 SHORT $LN29@GSTFormatV
  001ae	83 e8 01	 sub	 eax, 1

; 188  : 		break;
; 189  : 	case GRASSHOPPER:
; 190  : 		dwModeOfOperatioID = XTS;
; 191  : 		break;
; 192  : 	default:
; 193  : 		dwModeOfOperatioID = FIRST_MODE_OF_OPERATION_ID;

  001b1	b9 01 00 00 00	 mov	 ecx, 1
  001b6	eb 05		 jmp	 SHORT $LN2@GSTFormatV
$LN29@GSTFormatV:

; 185  : 	{
; 186  : 	case GOST:
; 187  : 		dwModeOfOperatioID = XTS8;

  001b8	b9 02 00 00 00	 mov	 ecx, 2
$LN2@GSTFormatV:

; 194  : 		break;
; 195  : 	}
; 196  : 
; 197  : 	nStatus = CreateVolumeHeaderInMemory (FALSE,

  001bd	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  001c1	74 08		 je	 SHORT $LN113@GSTFormatV
  001c3	8b 95 38 da fd
	ff		 mov	 edx, DWORD PTR _dataAreaSize$2$[ebp]
  001c9	eb 17		 jmp	 SHORT $LN114@GSTFormatV
$LN113@GSTFormatV:
  001cb	0f 57 c0	 xorps	 xmm0, xmm0
  001ce	66 0f 13 85 30
	da fd ff	 movlpd	 QWORD PTR tv162[ebp], xmm0
  001d6	8b 95 34 da fd
	ff		 mov	 edx, DWORD PTR tv162[ebp+4]
  001dc	8b b5 30 da fd
	ff		 mov	 esi, DWORD PTR tv162[ebp]
$LN114@GSTFormatV:
  001e2	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  001e5	6a 00		 push	 0
  001e7	ff 35 00 00 00
	00		 push	 DWORD PTR _FormatSectorSize
  001ed	50		 push	 eax
  001ee	8b 85 24 da fd
	ff		 mov	 eax, DWORD PTR _dataAreaSize$1$[ebp]
  001f4	6a 00		 push	 0
  001f6	ff b5 38 da fd
	ff		 push	 DWORD PTR _dataAreaSize$2$[ebp]
  001fc	50		 push	 eax
  001fd	ff b5 14 da fd
	ff		 push	 DWORD PTR _dataOffset$2$[ebp]
  00203	ff b5 10 da fd
	ff		 push	 DWORD PTR _dataOffset$1$[ebp]
  00209	52		 push	 edx
  0020a	56		 push	 esi
  0020b	ff b5 38 da fd
	ff		 push	 DWORD PTR _dataAreaSize$2$[ebp]
  00211	50		 push	 eax
  00212	8d 85 20 da fd
	ff		 lea	 eax, DWORD PTR _cryptoInfo$[ebp]
  00218	50		 push	 eax
  00219	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0021c	6a 00		 push	 0
  0021e	50		 push	 eax
  0021f	8b 43 44	 mov	 eax, DWORD PTR [ebx+68]
  00222	50		 push	 eax
  00223	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00226	51		 push	 ecx
  00227	50		 push	 eax
  00228	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0022e	50		 push	 eax
  0022f	6a 00		 push	 0
  00231	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  00236	83 c4 50	 add	 esp, 80			; 00000050H
  00239	89 85 34 da fd
	ff		 mov	 DWORD PTR _nStatus$1$[ebp], eax

; 198  : 				     header,
; 199  : 				     volParams->ea,
; 200  : 					 dwModeOfOperatioID,
; 201  : 				     volParams->password,
; 202  : 				     volParams->pkcs5,
; 203  : 					 NULL,
; 204  : 				     &cryptoInfo,
; 205  : 					 dataAreaSize,
; 206  : 					 volParams->hiddenVol ? dataAreaSize : 0,
; 207  : 					 dataOffset,
; 208  : 					 dataAreaSize,
; 209  : 					 0,
; 210  : 					 volParams->headerFlags,
; 211  : 					 FormatSectorSize,
; 212  : 					 FALSE);
; 213  : 
; 214  : 	if (nStatus != 0)

  0023f	85 c0		 test	 eax, eax
  00241	74 51		 je	 SHORT $LN210@GSTFormatV

; 215  : 	{
; 216  : 		burn (header, sizeof (header));

  00243	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00249	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0024e	8b f1		 mov	 esi, ecx
  00250	8b d0		 mov	 edx, eax
$LL124@GSTFormatV:
  00252	c6 02 00	 mov	 BYTE PTR [edx], 0
  00255	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00258	83 ee 01	 sub	 esi, 1
  0025b	75 f5		 jne	 SHORT $LL124@GSTFormatV
  0025d	0f 1f 00	 npad	 3
$LL7@GSTFormatV:
  00260	c6 00 00	 mov	 BYTE PTR [eax], 0
  00263	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00266	83 e9 01	 sub	 ecx, 1
  00269	75 f5		 jne	 SHORT $LL7@GSTFormatV

; 217  : 		VirtualUnlock (header, sizeof (header));

  0026b	68 00 02 00 00	 push	 512			; 00000200H
  00270	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00276	50		 push	 eax
  00277	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 218  : 		return nStatus;

  0027d	8b 85 34 da fd
	ff		 mov	 eax, DWORD PTR _nStatus$1$[ebp]
  00283	5e		 pop	 esi
  00284	5f		 pop	 edi
  00285	5b		 pop	 ebx

; 746  : }

  00286	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00289	33 cd		 xor	 ecx, ebp
  0028b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00290	8b e5		 mov	 esp, ebp
  00292	5d		 pop	 ebp
  00293	c3		 ret	 0
$LN210@GSTFormatV:
  00294	33 f6		 xor	 esi, esi
$begin_format$241:

; 219  : 	}
; 220  : 
; 221  : begin_format:
; 222  : 
; 223  : 	if (volParams->bDevice)

  00296	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00299	0f 84 b1 03 00
	00		 je	 $LN33@GSTFormatV

; 224  : 	{
; 225  : 		/* Device-hosted volume */
; 226  : 
; 227  : 		DWORD dwResult;
; 228  : 		int nPass;
; 229  : 
; 230  : 		if (FakeDosNameForDevice (volParams->volumePath, dosDev, devName, FALSE) != 0)

  0029f	6a 00		 push	 0
  002a1	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  002a7	50		 push	 eax
  002a8	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  002ae	50		 push	 eax
  002af	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  002b2	50		 push	 eax
  002b3	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  002b8	83 c4 10	 add	 esp, 16			; 00000010H
  002bb	85 c0		 test	 eax, eax
  002bd	0f 85 f7 09 00
	00		 jne	 $LN142@GSTFormatV

; 232  : 
; 233  : 		if (IsDeviceMounted (devName))

  002c3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  002c9	50		 push	 eax
  002ca	e8 00 00 00 00	 call	 _IsDeviceMounted
  002cf	83 c4 04	 add	 esp, 4
  002d2	85 c0		 test	 eax, eax
  002d4	74 65		 je	 SHORT $LN36@GSTFormatV

; 234  : 		{
; 235  : 			if ((dev = DismountDrive (devName, volParams->volumePath)) == INVALID_HANDLE_VALUE)

  002d6	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  002d9	50		 push	 eax
  002da	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  002e0	50		 push	 eax
  002e1	e8 00 00 00 00	 call	 _DismountDrive
  002e6	8b f8		 mov	 edi, eax
  002e8	83 c4 08	 add	 esp, 8
  002eb	83 ff ff	 cmp	 edi, -1
  002ee	75 17		 jne	 SHORT $LN38@GSTFormatV
$LN237@GSTFormatV:

; 236  : 			{
; 237  : 				Error ("FORMAT_CANT_DISMOUNT_FILESYS");

  002f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@
  002f5	e8 00 00 00 00	 call	 _Error
  002fa	83 c4 04	 add	 esp, 4
$LN139@GSTFormatV:

; 238  : 				nStatus = ERR_DONT_REPORT; 

  002fd	be 1c 00 00 00	 mov	 esi, 28			; 0000001cH

; 239  : 				goto error;

  00302	e9 a4 07 00 00	 jmp	 $error$242
$LN38@GSTFormatV:

; 240  : 			}
; 241  : 
; 242  : 			/* Gain "raw" access to the partition (it contains a live filesystem and the filesystem driver 
; 243  : 			would otherwise prevent us from writing to hidden sectors). */
; 244  : 
; 245  : 			if (!DeviceIoControl (dev,

  00307	6a 00		 push	 0
  00309	8d 85 04 da fd
	ff		 lea	 eax, DWORD PTR _dwResult$4[ebp]
  0030f	50		 push	 eax
  00310	6a 00		 push	 0
  00312	6a 00		 push	 0
  00314	6a 00		 push	 0
  00316	6a 00		 push	 0
  00318	68 83 00 09 00	 push	 589955			; 00090083H
  0031d	57		 push	 edi
  0031e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00324	85 c0		 test	 eax, eax
  00326	0f 85 e2 00 00
	00		 jne	 $LN43@GSTFormatV

; 246  : 				FSCTL_ALLOW_EXTENDED_DASD_IO,
; 247  : 				NULL,
; 248  : 				0,   
; 249  : 				NULL,
; 250  : 				0,
; 251  : 				&dwResult,
; 252  : 				NULL))
; 253  : 			{
; 254  : 				bFailedRequiredDASD = TRUE;

  0032c	c7 85 08 da fd
	ff 01 00 00 00	 mov	 DWORD PTR _bFailedRequiredDASD$1$[ebp], 1

; 255  : 			}
; 256  : 		}

  00336	e9 d3 00 00 00	 jmp	 $LN43@GSTFormatV
$LN36@GSTFormatV:

; 257  : 		else if (IsOSAtLeast (WIN_VISTA) && driveLetter == -1)

  0033b	6a 0b		 push	 11			; 0000000bH
  0033d	e8 00 00 00 00	 call	 _IsOSAtLeast
  00342	83 c4 04	 add	 esp, 4
  00345	85 c0		 test	 eax, eax
  00347	0f 84 c1 00 00
	00		 je	 $LN43@GSTFormatV
  0034d	83 bd 0c da fd
	ff ff		 cmp	 DWORD PTR _driveLetter$1$[ebp], -1
  00354	0f 85 b4 00 00
	00		 jne	 $LN43@GSTFormatV

; 258  : 		{
; 259  : 			// Windows Vista doesn't allow overwriting sectors belonging to an unformatted partition 
; 260  : 			// to which no drive letter has been assigned under the system. This problem can be worked
; 261  : 			// around by assigning a drive letter to the partition temporarily.
; 262  : 
; 263  : 			char szDriveLetter[] = { 'A', ':', 0 };

  0035a	68 05 01 00 00	 push	 261			; 00000105H
  0035f	8d 85 ec fa ff
	ff		 lea	 eax, DWORD PTR _uniqVolName$10[ebp]
  00365	66 c7 85 2c da
	fd ff 41 3a	 mov	 WORD PTR _szDriveLetter$6[ebp], 14913 ; 00003a41H
  0036e	6a 00		 push	 0
  00370	50		 push	 eax
  00371	c6 85 2e da fd
	ff 00		 mov	 BYTE PTR _szDriveLetter$6[ebp+2], 0

; 264  : 			char rootPath[] = { 'A', ':', '\\', 0 };

  00378	c7 85 28 da fd
	ff 41 3a 5c 00	 mov	 DWORD PTR _rootPath$5[ebp], 6044225 ; 005c3a41H
  00382	e8 00 00 00 00	 call	 _memset
  00387	83 c4 0c	 add	 esp, 12			; 0000000cH

; 265  : 			char uniqVolName[MAX_PATH+1] = { 0 };
; 266  : 			int tmpDriveLetter = -1;
; 267  : 			BOOL bResult = FALSE;
; 268  : 
; 269  : 			tmpDriveLetter = GetFirstAvailableDrive ();

  0038a	e8 00 00 00 00	 call	 _GetFirstAvailableDrive

; 270  :  
; 271  : 			if (tmpDriveLetter != -1)

  0038f	83 f8 ff	 cmp	 eax, -1
  00392	74 7a		 je	 SHORT $LN43@GSTFormatV

; 272  : 			{
; 273  : 				rootPath[0] += (char) tmpDriveLetter;

  00394	00 85 28 da fd
	ff		 add	 BYTE PTR _rootPath$5[ebp], al

; 274  : 				szDriveLetter[0] += (char) tmpDriveLetter;

  0039a	00 85 2c da fd
	ff		 add	 BYTE PTR _szDriveLetter$6[ebp], al

; 275  : 
; 276  : 				if (DefineDosDevice (DDD_RAW_TARGET_PATH, szDriveLetter, volParams->volumePath))

  003a0	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  003a3	50		 push	 eax
  003a4	8d 85 2c da fd
	ff		 lea	 eax, DWORD PTR _szDriveLetter$6[ebp]
  003aa	50		 push	 eax
  003ab	6a 01		 push	 1
  003ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefineDosDeviceA@12
  003b3	85 c0		 test	 eax, eax
  003b5	74 57		 je	 SHORT $LN43@GSTFormatV

; 277  : 				{
; 278  : 					bResult = GetVolumeNameForVolumeMountPoint (rootPath, uniqVolName, MAX_PATH);

  003b7	68 04 01 00 00	 push	 260			; 00000104H
  003bc	8d 85 ec fa ff
	ff		 lea	 eax, DWORD PTR _uniqVolName$10[ebp]
  003c2	50		 push	 eax
  003c3	8d 85 28 da fd
	ff		 lea	 eax, DWORD PTR _rootPath$5[ebp]
  003c9	50		 push	 eax
  003ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeNameForVolumeMountPointA@12

; 279  : 
; 280  : 					DefineDosDevice (DDD_RAW_TARGET_PATH|DDD_REMOVE_DEFINITION|DDD_EXACT_MATCH_ON_REMOVE,

  003d0	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  003d3	8b f0		 mov	 esi, eax
  003d5	51		 push	 ecx
  003d6	8d 85 2c da fd
	ff		 lea	 eax, DWORD PTR _szDriveLetter$6[ebp]
  003dc	50		 push	 eax
  003dd	6a 07		 push	 7
  003df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefineDosDeviceA@12

; 281  : 						szDriveLetter,
; 282  : 						volParams->volumePath);
; 283  : 
; 284  : 					if (bResult 
; 285  : 						&& SetVolumeMountPoint (rootPath, uniqVolName))

  003e5	85 f6		 test	 esi, esi
  003e7	74 25		 je	 SHORT $LN43@GSTFormatV
  003e9	8d 85 ec fa ff
	ff		 lea	 eax, DWORD PTR _uniqVolName$10[ebp]
  003ef	50		 push	 eax
  003f0	8d 85 28 da fd
	ff		 lea	 eax, DWORD PTR _rootPath$5[ebp]
  003f6	50		 push	 eax
  003f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetVolumeMountPointA@8
  003fd	85 c0		 test	 eax, eax
  003ff	74 0d		 je	 SHORT $LN43@GSTFormatV

; 286  : 					{
; 287  : 						// The drive letter can be removed now
; 288  : 						DeleteVolumeMountPoint (rootPath);

  00401	8d 85 28 da fd
	ff		 lea	 eax, DWORD PTR _rootPath$5[ebp]
  00407	50		 push	 eax
  00408	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteVolumeMountPointA@4
$LN43@GSTFormatV:

; 289  : 					}
; 290  : 				}
; 291  : 			}
; 292  : 		}
; 293  : 
; 294  : 		// For extra safety, we will try to gain "raw" access to the partition. Note that this should actually be
; 295  : 		// redundant because if the filesystem was mounted, we already tried to obtain DASD above. If we failed,
; 296  : 		// bFailedRequiredDASD was set to TRUE and therefore we will perform pseudo "quick format" below. However, 
; 297  : 		// for extra safety, in case IsDeviceMounted() failed to detect a live filesystem, we will blindly
; 298  : 		// send FSCTL_ALLOW_EXTENDED_DASD_IO (possibly for a second time) without checking the result.
; 299  : 
; 300  : 		DeviceIoControl (dev,

  0040e	6a 00		 push	 0
  00410	8d 85 04 da fd
	ff		 lea	 eax, DWORD PTR _dwResult$4[ebp]
  00416	50		 push	 eax
  00417	6a 00		 push	 0
  00419	6a 00		 push	 0
  0041b	6a 00		 push	 0
  0041d	6a 00		 push	 0
  0041f	68 83 00 09 00	 push	 589955			; 00090083H
  00424	57		 push	 edi
  00425	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0042b	33 c0		 xor	 eax, eax
  0042d	39 85 08 da fd
	ff		 cmp	 DWORD PTR _bFailedRequiredDASD$1$[ebp], eax
  00433	0f 94 c0	 sete	 al
  00436	89 85 34 da fd
	ff		 mov	 DWORD PTR _nPass$1$[ebp], eax
  0043c	0f 1f 40 00	 npad	 4
$LL11@GSTFormatV:

; 313  : 		{
; 314  : 			int retryCount;
; 315  : 
; 316  : 			retryCount = 0;

  00440	33 f6		 xor	 esi, esi

; 317  : 
; 318  : 			// Try exclusive access mode first
; 319  : 			// Note that when exclusive access is denied, it is worth retrying (usually succeeds after a few tries).
; 320  : 			while (dev == INVALID_HANDLE_VALUE && retryCount++ < EXCL_ACCESS_MAX_AUTO_RETRIES)

  00442	83 ff ff	 cmp	 edi, -1
  00445	0f 85 9f 00 00
	00		 jne	 $LN48@GSTFormatV
  0044b	0f 1f 44 00 00	 npad	 5
$LL12@GSTFormatV:
  00450	8b c6		 mov	 eax, esi
  00452	46		 inc	 esi
  00453	3d f4 01 00 00	 cmp	 eax, 500		; 000001f4H
  00458	7d 32		 jge	 SHORT $LN13@GSTFormatV

; 321  : 			{
; 322  : 				dev = CreateFile (devName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

  0045a	6a 00		 push	 0
  0045c	6a 00		 push	 0
  0045e	6a 03		 push	 3
  00460	6a 00		 push	 0
  00462	6a 00		 push	 0
  00464	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00469	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  0046f	50		 push	 eax
  00470	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00476	8b f8		 mov	 edi, eax

; 323  : 
; 324  : 				if (retryCount > 1)

  00478	83 fe 01	 cmp	 esi, 1
  0047b	7e 08		 jle	 SHORT $LN44@GSTFormatV

; 325  : 					Sleep (EXCL_ACCESS_AUTO_RETRY_DELAY);

  0047d	6a 0a		 push	 10			; 0000000aH
  0047f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN44@GSTFormatV:

; 317  : 
; 318  : 			// Try exclusive access mode first
; 319  : 			// Note that when exclusive access is denied, it is worth retrying (usually succeeds after a few tries).
; 320  : 			while (dev == INVALID_HANDLE_VALUE && retryCount++ < EXCL_ACCESS_MAX_AUTO_RETRIES)

  00485	83 ff ff	 cmp	 edi, -1
  00488	74 c6		 je	 SHORT $LL12@GSTFormatV

; 326  : 			}
; 327  : 
; 328  : 			if (dev == INVALID_HANDLE_VALUE)

  0048a	eb 58		 jmp	 SHORT $LN223@GSTFormatV
$LN13@GSTFormatV:
  0048c	83 ff ff	 cmp	 edi, -1
  0048f	75 53		 jne	 SHORT $LN223@GSTFormatV

; 329  : 			{
; 330  : 				// Exclusive access denied -- retry in shared mode
; 331  : 				dev = CreateFile (devName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

  00491	6a 00		 push	 0
  00493	6a 00		 push	 0
  00495	6a 03		 push	 3
  00497	6a 00		 push	 0
  00499	6a 03		 push	 3
  0049b	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  004a0	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  004a6	50		 push	 eax
  004a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  004ad	8b f8		 mov	 edi, eax

; 332  : 				if (dev != INVALID_HANDLE_VALUE)

  004af	83 ff ff	 cmp	 edi, -1
  004b2	0f 84 78 01 00
	00		 je	 $LN46@GSTFormatV

; 333  : 				{
; 334  : 					if (IDNO == MessageBoxW (volParams->hwndDlg, GetString ("DEVICE_IN_USE_FORMAT"), lpszTitle, MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2))

  004b8	68 34 01 00 00	 push	 308			; 00000134H
  004bd	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  004c3	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@
  004c8	e8 00 00 00 00	 call	 _GetString
  004cd	83 c4 04	 add	 esp, 4
  004d0	50		 push	 eax
  004d1	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  004d4	50		 push	 eax
  004d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  004db	83 f8 07	 cmp	 eax, 7
  004de	0f 84 19 fe ff
	ff		 je	 $LN139@GSTFormatV
$LN223@GSTFormatV:
  004e4	8b 85 34 da fd
	ff		 mov	 eax, DWORD PTR _nPass$1$[ebp]
$LN48@GSTFormatV:

; 346  : 				}
; 347  : 			}
; 348  : 
; 349  : 			if (volParams->hiddenVol || bInstantRetryOtherFilesys)

  004ea	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  004ee	75 6d		 jne	 SHORT $LN197@GSTFormatV
  004f0	83 bd 1c da fd
	ff 00		 cmp	 DWORD PTR _bInstantRetryOtherFilesys$1$[ebp], 0
  004f7	75 64		 jne	 SHORT $LN197@GSTFormatV

; 350  : 				break;	// The following "quick format" operation would damage the outer volume
; 351  : 
; 352  : 			if (nPass == 0)

  004f9	85 c0		 test	 eax, eax
  004fb	75 50		 jne	 SHORT $LN9@GSTFormatV

; 353  : 			{
; 354  : 				char buf [2 * GST_MAX_VOLUME_SECTOR_SIZE];
; 355  : 				DWORD bw;
; 356  : 
; 357  : 				// Perform pseudo "quick format" so that the filesystem driver does not prevent us from 
; 358  : 				// formatting hidden sectors
; 359  : 				memset (buf, 0, sizeof (buf));

  004fd	68 00 20 00 00	 push	 8192			; 00002000H
  00502	50		 push	 eax
  00503	8d 85 e4 d8 ff
	ff		 lea	 eax, DWORD PTR _buf$9[ebp]
  00509	50		 push	 eax
  0050a	e8 00 00 00 00	 call	 _memset
  0050f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  : 
; 361  : 				if (!WriteFile (dev, buf, sizeof (buf), &bw, NULL))

  00512	8d 85 f0 d9 fd
	ff		 lea	 eax, DWORD PTR _bw$2[ebp]
  00518	6a 00		 push	 0
  0051a	50		 push	 eax
  0051b	68 00 20 00 00	 push	 8192			; 00002000H
  00520	8d 85 e4 d8 ff
	ff		 lea	 eax, DWORD PTR _buf$9[ebp]
  00526	50		 push	 eax
  00527	57		 push	 edi
  00528	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0052e	85 c0		 test	 eax, eax
  00530	0f 84 5f 01 00
	00		 je	 $LN141@GSTFormatV

; 362  : 				{
; 363  : 					nStatus = ERR_OS_ERROR; 
; 364  : 					goto error;
; 365  : 				}
; 366  : 
; 367  : 				FlushFileBuffers (dev);

  00536	57		 push	 edi
  00537	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FlushFileBuffers@4

; 368  : 				CloseHandle (dev);

  0053d	57		 push	 edi
  0053e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00544	8b 85 34 da fd
	ff		 mov	 eax, DWORD PTR _nPass$1$[ebp]

; 369  : 				dev = INVALID_HANDLE_VALUE;

  0054a	83 cf ff	 or	 edi, -1
$LN9@GSTFormatV:

; 301  : 			FSCTL_ALLOW_EXTENDED_DASD_IO,
; 302  : 			NULL,
; 303  : 			0,   
; 304  : 			NULL,
; 305  : 			0,
; 306  : 			&dwResult,
; 307  : 			NULL);
; 308  : 
; 309  : 
; 310  : 		// If DASD is needed but we failed to obtain it, perform open - 'quick format' - close - open 
; 311  : 		// so that the filesystem driver does not prevent us from formatting hidden sectors.
; 312  : 		for (nPass = (bFailedRequiredDASD ? 0 : 1); nPass < 2; nPass++)

  0054d	40		 inc	 eax
  0054e	89 85 34 da fd
	ff		 mov	 DWORD PTR _nPass$1$[ebp], eax
  00554	83 f8 02	 cmp	 eax, 2
  00557	0f 8c e3 fe ff
	ff		 jl	 $LL11@GSTFormatV
$LN197@GSTFormatV:

; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 		if (DeviceIoControl (dev, FSCTL_IS_VOLUME_MOUNTED, NULL, 0, NULL, 0, &dwResult, NULL))

  0055d	6a 00		 push	 0
  0055f	8d 85 04 da fd
	ff		 lea	 eax, DWORD PTR _dwResult$4[ebp]
  00565	50		 push	 eax
  00566	6a 00		 push	 0
  00568	6a 00		 push	 0
  0056a	6a 00		 push	 0
  0056c	6a 00		 push	 0
  0056e	68 28 00 09 00	 push	 589864			; 00090028H
  00573	57		 push	 edi
  00574	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0057a	85 c0		 test	 eax, eax
  0057c	0f 85 6e fd ff
	ff		 jne	 $LN237@GSTFormatV
$LN226@GSTFormatV:
  00582	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetFilePointerEx@20
$LN58@GSTFormatV:

; 419  : 			}
; 420  : 		}
; 421  : 	}
; 422  : 
; 423  : 	if (volParams->hiddenVol && !volParams->bDevice && bPreserveTimestamp)

  00588	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  0058c	74 36		 je	 SHORT $LN61@GSTFormatV
  0058e	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00591	75 31		 jne	 SHORT $LN61@GSTFormatV
  00593	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bPreserveTimestamp, 0
  0059a	74 28		 je	 SHORT $LN61@GSTFormatV

; 424  : 	{
; 425  : 		if (GetFileTime ((HANDLE) dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime) == 0)

  0059c	8d 85 e4 d9 fd
	ff		 lea	 eax, DWORD PTR _ftLastWriteTime$[ebp]
  005a2	50		 push	 eax
  005a3	8d 85 dc d9 fd
	ff		 lea	 eax, DWORD PTR _ftLastAccessTime$[ebp]
  005a9	50		 push	 eax
  005aa	8d 85 d4 d9 fd
	ff		 lea	 eax, DWORD PTR _ftCreationTime$[ebp]
  005b0	50		 push	 eax
  005b1	57		 push	 edi
  005b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileTime@16
  005b8	f7 d8		 neg	 eax
  005ba	1b c0		 sbb	 eax, eax
  005bc	f7 d8		 neg	 eax
  005be	89 85 f8 d9 fd
	ff		 mov	 DWORD PTR _bTimeStampValid$1$[ebp], eax
$LN61@GSTFormatV:

; 426  : 			bTimeStampValid = FALSE;
; 427  : 		else
; 428  : 			bTimeStampValid = TRUE;
; 429  : 	}
; 430  : 
; 431  : 	KillTimer (volParams->hwndDlg, TIMER_ID_RANDVIEW);

  005c4	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  005c7	68 ff 00 00 00	 push	 255			; 000000ffH
  005cc	51		 push	 ecx
  005cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 432  : 
; 433  : 	/* Volume header */
; 434  : 
; 435  : 	// Hidden volume setup
; 436  : 	if (volParams->hiddenVol)

  005d3	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  005d7	0f 84 78 01 00
	00		 je	 $LN63@GSTFormatV

; 437  : 	{
; 438  : 		LARGE_INTEGER headerOffset;
; 439  : 
; 440  : 		// Check hidden volume size
; 441  : 		if (volParams->hiddenVolHostSize < GST_MIN_HIDDEN_VOLUME_HOST_SIZE || volParams->hiddenVolHostSize > GST_MAX_HIDDEN_VOLUME_HOST_SIZE)

  005dd	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  005e0	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  005e3	85 c0		 test	 eax, eax
  005e5	75 0c		 jne	 SHORT $LN199@GSTFormatV
  005e7	81 f9 00 50 05
	00		 cmp	 ecx, 348160		; 00055000H
  005ed	0f 82 32 02 00
	00		 jb	 $LN66@GSTFormatV
$LN199@GSTFormatV:
  005f3	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  005f6	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  005f9	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  005fe	0f 87 21 02 00
	00		 ja	 $LN66@GSTFormatV
  00604	72 0c		 jb	 SHORT $LN200@GSTFormatV
  00606	81 f9 00 00 fc
	ff		 cmp	 ecx, -262144		; fffc0000H
  0060c	0f 87 13 02 00
	00		 ja	 $LN66@GSTFormatV
$LN200@GSTFormatV:

; 442  : 		{		
; 443  : 			nStatus = ERR_VOL_SIZE_WRONG;
; 444  : 			goto error;
; 445  : 		}
; 446  : 
; 447  : 		// Seek to hidden volume header location
; 448  : 		
; 449  : 		headerOffset.QuadPart = GST_HIDDEN_VOLUME_HEADER_OFFSET;
; 450  : 
; 451  : 		if (!SetFilePointerEx ((HANDLE) dev, headerOffset, NULL, FILE_BEGIN))

  00612	6a 00		 push	 0
  00614	6a 00		 push	 0
  00616	6a 00		 push	 0
  00618	68 00 00 01 00	 push	 65536			; 00010000H
$LN238@GSTFormatV:
  0061d	57		 push	 edi
  0061e	ff d6		 call	 esi
  00620	85 c0		 test	 eax, eax
  00622	0f 85 46 01 00
	00		 jne	 $LN69@GSTFormatV

; 452  : 		{
; 453  : 			nStatus = ERR_OS_ERROR;

  00628	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 454  : 			goto error;

  0062b	e9 7b 04 00 00	 jmp	 $error$242
$LN46@GSTFormatV:

; 335  : 					{
; 336  : 						nStatus = ERR_DONT_REPORT; 
; 337  : 						goto error;
; 338  : 					}
; 339  : 				}
; 340  : 				else
; 341  : 				{
; 342  : 					handleWin32Error (volParams->hwndDlg);

  00630	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00633	50		 push	 eax
  00634	e8 00 00 00 00	 call	 _handleWin32Error

; 343  : 					Error ("CANT_ACCESS_VOL");

  00639	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@
  0063e	e8 00 00 00 00	 call	 _Error
  00643	83 c4 08	 add	 esp, 8

; 344  : 					nStatus = ERR_DONT_REPORT; 

  00646	be 1c 00 00 00	 mov	 esi, 28			; 0000001cH

; 345  : 					goto error;

  0064b	e9 5b 04 00 00	 jmp	 $error$242
$LN33@GSTFormatV:

; 374  : 		{
; 375  : 			Error ("FORMAT_CANT_DISMOUNT_FILESYS");
; 376  : 			nStatus = ERR_DONT_REPORT; 
; 377  : 			goto error;
; 378  : 		}
; 379  : 	}
; 380  : 	else
; 381  : 	{
; 382  : 		/* File-hosted volume */
; 383  : 
; 384  : 		dev = CreateFile (volParams->volumePath, GENERIC_READ | GENERIC_WRITE,

  00650	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00654	75 09		 jne	 SHORT $LN115@GSTFormatV
  00656	b9 02 00 00 00	 mov	 ecx, 2
  0065b	85 f6		 test	 esi, esi
  0065d	74 05		 je	 SHORT $LN116@GSTFormatV
$LN115@GSTFormatV:
  0065f	b9 03 00 00 00	 mov	 ecx, 3
$LN116@GSTFormatV:
  00664	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00668	75 08		 jne	 SHORT $LN117@GSTFormatV
  0066a	85 f6		 test	 esi, esi
  0066c	75 04		 jne	 SHORT $LN117@GSTFormatV
  0066e	33 c0		 xor	 eax, eax
  00670	eb 05		 jmp	 SHORT $LN118@GSTFormatV
$LN117@GSTFormatV:
  00672	b8 03 00 00 00	 mov	 eax, 3
$LN118@GSTFormatV:
  00677	6a 00		 push	 0
  00679	6a 00		 push	 0
  0067b	51		 push	 ecx
  0067c	6a 00		 push	 0
  0067e	50		 push	 eax
  0067f	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00682	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00687	50		 push	 eax
  00688	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  0068e	8b f8		 mov	 edi, eax

; 385  : 			(volParams->hiddenVol || bInstantRetryOtherFilesys) ? (FILE_SHARE_READ | FILE_SHARE_WRITE) : 0,
; 386  : 			NULL, (volParams->hiddenVol || bInstantRetryOtherFilesys) ? OPEN_EXISTING : CREATE_ALWAYS, 0, NULL);
; 387  : 
; 388  : 		if (dev == INVALID_HANDLE_VALUE)

  00690	83 ff ff	 cmp	 edi, -1
  00693	75 0a		 jne	 SHORT $LN54@GSTFormatV
$LN141@GSTFormatV:

; 389  : 		{
; 390  : 			nStatus = ERR_OS_ERROR; 

  00695	be 01 00 00 00	 mov	 esi, 1

; 391  : 			goto error;

  0069a	e9 0c 04 00 00	 jmp	 $error$242
$LN54@GSTFormatV:

; 392  : 		}
; 393  : 
; 394  : 		DisableFileCompression (dev);

  0069f	57		 push	 edi
  006a0	e8 00 00 00 00	 call	 _DisableFileCompression
  006a5	83 c4 04	 add	 esp, 4

; 395  : 
; 396  : 		if (!volParams->hiddenVol && !bInstantRetryOtherFilesys)

  006a8	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  006ac	0f 85 d0 fe ff
	ff		 jne	 $LN226@GSTFormatV
  006b2	85 f6		 test	 esi, esi
  006b4	0f 85 c8 fe ff
	ff		 jne	 $LN226@GSTFormatV

; 397  : 		{
; 398  : 			LARGE_INTEGER volumeSize;
; 399  : 			volumeSize.QuadPart = dataAreaSize + GST_VOLUME_HEADER_GROUP_SIZE;

  006ba	8b b5 24 da fd
	ff		 mov	 esi, DWORD PTR _dataAreaSize$1$[ebp]
  006c0	8b 85 38 da fd
	ff		 mov	 eax, DWORD PTR _dataAreaSize$2$[ebp]
  006c6	81 c6 00 00 02
	00		 add	 esi, 131072		; 00020000H
  006cc	83 d0 00	 adc	 eax, 0

; 400  : 
; 401  : 			if (volParams->sparseFileSwitch && volParams->quickFormat)

  006cf	83 7b 34 00	 cmp	 DWORD PTR [ebx+52], 0
  006d3	89 85 34 da fd
	ff		 mov	 DWORD PTR _volumeSize$2$[ebp], eax
  006d9	74 35		 je	 SHORT $LN57@GSTFormatV
  006db	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  006df	74 2f		 je	 SHORT $LN57@GSTFormatV

; 402  : 			{
; 403  : 				// Create as sparse file container
; 404  : 				DWORD tmp;
; 405  : 				if (!DeviceIoControl (dev, FSCTL_SET_SPARSE, NULL, 0, NULL, 0, &tmp, NULL))

  006e1	6a 00		 push	 0
  006e3	8d 85 ec d9 fd
	ff		 lea	 eax, DWORD PTR _tmp$1[ebp]
  006e9	50		 push	 eax
  006ea	6a 00		 push	 0
  006ec	6a 00		 push	 0
  006ee	6a 00		 push	 0
  006f0	6a 00		 push	 0
  006f2	68 c4 00 09 00	 push	 590020			; 000900c4H
  006f7	57		 push	 edi
  006f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  006fe	85 c0		 test	 eax, eax
  00700	75 08		 jne	 SHORT $LN221@GSTFormatV

; 406  : 				{
; 407  : 					nStatus = ERR_OS_ERROR; 

  00702	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 408  : 					goto error;

  00705	e9 a1 03 00 00	 jmp	 $error$242
$LN221@GSTFormatV:
  0070a	8b 85 34 da fd
	ff		 mov	 eax, DWORD PTR _volumeSize$2$[ebp]
$LN57@GSTFormatV:

; 409  : 				}
; 410  : 			}
; 411  : 
; 412  : 			// Preallocate the file
; 413  : 			if (!SetFilePointerEx (dev, volumeSize, NULL, FILE_BEGIN)
; 414  : 				|| !SetEndOfFile (dev)
; 415  : 				|| SetFilePointer (dev, 0, NULL, FILE_BEGIN) != 0)

  00710	6a 00		 push	 0
  00712	6a 00		 push	 0
  00714	50		 push	 eax
  00715	56		 push	 esi
  00716	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetFilePointerEx@20
  0071c	57		 push	 edi
  0071d	ff d6		 call	 esi
  0071f	85 c0		 test	 eax, eax
  00721	0f 84 6e ff ff
	ff		 je	 $LN141@GSTFormatV
  00727	57		 push	 edi
  00728	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEndOfFile@4
  0072e	85 c0		 test	 eax, eax
  00730	0f 84 5f ff ff
	ff		 je	 $LN141@GSTFormatV
  00736	6a 00		 push	 0
  00738	6a 00		 push	 0
  0073a	6a 00		 push	 0
  0073c	57		 push	 edi
  0073d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  00743	85 c0		 test	 eax, eax
  00745	0f 84 3d fe ff
	ff		 je	 $LN58@GSTFormatV

; 416  : 			{
; 417  : 				nStatus = ERR_OS_ERROR;

  0074b	be 01 00 00 00	 mov	 esi, 1

; 418  : 				goto error;

  00750	e9 56 03 00 00	 jmp	 $error$242
$LN63@GSTFormatV:
  00755	83 bd 1c da fd
	ff 00		 cmp	 DWORD PTR _bInstantRetryOtherFilesys$1$[ebp], 0

; 455  : 		}
; 456  : 	}
; 457  : 	else if (bInstantRetryOtherFilesys)

  0075c	74 19		 je	 SHORT $LN184@GSTFormatV

; 458  : 	{
; 459  : 		// The previous file system format failed and the user wants to try again with a different file system.
; 460  : 		// The volume header had been written successfully so we need to seek to the byte after the header.
; 461  : 
; 462  : 		LARGE_INTEGER offset;
; 463  : 		offset.QuadPart = GST_VOLUME_DATA_OFFSET;
; 464  : 		if (!SetFilePointerEx ((HANDLE) dev, offset, NULL, FILE_BEGIN))

  0075e	6a 00		 push	 0
  00760	6a 00		 push	 0
  00762	6a 00		 push	 0
  00764	68 00 00 02 00	 push	 131072			; 00020000H

; 465  : 		{
; 466  : 			nStatus = ERR_OS_ERROR;
; 467  : 			goto error;

  00769	e9 af fe ff ff	 jmp	 $LN238@GSTFormatV
$LN69@GSTFormatV:
  0076e	83 bd 1c da fd
	ff 00		 cmp	 DWORD PTR _bInstantRetryOtherFilesys$1$[ebp], 0

; 468  : 		}
; 469  : 	}
; 470  : 
; 471  : 	if (!bInstantRetryOtherFilesys)

  00775	75 76		 jne	 SHORT $LN74@GSTFormatV
$LN184@GSTFormatV:

; 472  : 	{
; 473  : 		// Write the volume header
; 474  : 		if (!WriteEffectiveVolumeHeader (volParams->bDevice, dev, header))

  00777	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0077d	50		 push	 eax
  0077e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00780	57		 push	 edi
  00781	50		 push	 eax
  00782	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  00787	83 c4 0c	 add	 esp, 12			; 0000000cH
  0078a	85 c0		 test	 eax, eax
  0078c	0f 84 03 ff ff
	ff		 je	 $LN141@GSTFormatV

; 475  : 		{
; 476  : 			nStatus = ERR_OS_ERROR;
; 477  : 			goto error;
; 478  : 		}
; 479  : 
; 480  : 		// To prevent fragmentation, write zeroes to reserved header sectors which are going to be filled with random data
; 481  : 		if (!volParams->bDevice && !volParams->hiddenVol)

  00792	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00795	75 56		 jne	 SHORT $LN74@GSTFormatV
  00797	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  0079b	75 54		 jne	 SHORT $LN234@GSTFormatV

; 482  : 		{
; 483  : 			byte buf[GST_VOLUME_HEADER_GROUP_SIZE - GST_VOLUME_HEADER_EFFECTIVE_SIZE];
; 484  : 			DWORD bytesWritten;
; 485  : 			ZeroMemory (buf, sizeof (buf));

  0079d	68 00 fe 01 00	 push	 130560			; 0001fe00H
  007a2	8d 85 e4 da fd
	ff		 lea	 eax, DWORD PTR _buf$8[ebp]
  007a8	6a 00		 push	 0
  007aa	50		 push	 eax
  007ab	e8 00 00 00 00	 call	 _memset
  007b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 486  : 
; 487  : 			if (!WriteFile (dev, buf, sizeof (buf), &bytesWritten, NULL))

  007b3	8d 85 f4 d9 fd
	ff		 lea	 eax, DWORD PTR _bytesWritten$3[ebp]
  007b9	6a 00		 push	 0
  007bb	50		 push	 eax
  007bc	68 00 fe 01 00	 push	 130560			; 0001fe00H
  007c1	8d 85 e4 da fd
	ff		 lea	 eax, DWORD PTR _buf$8[ebp]
  007c7	50		 push	 eax
  007c8	57		 push	 edi
  007c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  007cf	85 c0		 test	 eax, eax
  007d1	0f 84 be fe ff
	ff		 je	 $LN141@GSTFormatV

; 488  : 			{
; 489  : 				nStatus = ERR_OS_ERROR;
; 490  : 				goto error;
; 491  : 			}
; 492  : 
; 493  : 			if (bytesWritten != sizeof (buf))

  007d7	81 bd f4 d9 fd
	ff 00 fe 01 00	 cmp	 DWORD PTR _bytesWritten$3[ebp], 130560 ; 0001fe00H
  007e1	74 0a		 je	 SHORT $LN74@GSTFormatV

; 494  : 			{
; 495  : 				nStatus = ERR_PARAMETER_INCORRECT;

  007e3	be 1e 00 00 00	 mov	 esi, 30			; 0000001eH

; 496  : 				goto error;

  007e8	e9 be 02 00 00	 jmp	 $error$242
$LN74@GSTFormatV:

; 497  : 			}
; 498  : 		}
; 499  : 	}
; 500  : 
; 501  : 	if (volParams->hiddenVol)

  007ed	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
$LN234@GSTFormatV:
  007f1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _FormatSectorSize
  007f7	74 3d		 je	 SHORT $LN75@GSTFormatV

; 502  : 	{
; 503  : 		// Calculate data area position of hidden volume
; 504  : 		cryptoInfo->hiddenVolumeOffset = dataOffset;

  007f9	8b 85 20 da fd
	ff		 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  007ff	8b 95 14 da fd
	ff		 mov	 edx, DWORD PTR _dataOffset$2$[ebp]
  00805	8b 8d 10 da fd
	ff		 mov	 ecx, DWORD PTR _dataOffset$1$[ebp]

; 505  : 
; 506  : 		// Validate the offset
; 507  : 		if (dataOffset % FormatSectorSize != 0)

  0080b	6a 00		 push	 0
  0080d	56		 push	 esi
  0080e	52		 push	 edx
  0080f	89 88 c0 1e 00
	00		 mov	 DWORD PTR [eax+7872], ecx
  00815	51		 push	 ecx
  00816	89 90 c4 1e 00
	00		 mov	 DWORD PTR [eax+7876], edx
  0081c	e8 00 00 00 00	 call	 __aullrem
  00821	0b c2		 or	 eax, edx
  00823	74 0a		 je	 SHORT $LN76@GSTFormatV
$LN66@GSTFormatV:

; 508  : 		{
; 509  : 			nStatus = ERR_VOL_SIZE_WRONG; 

  00825	be 07 00 00 00	 mov	 esi, 7

; 510  : 			goto error;

  0082a	e9 7c 02 00 00	 jmp	 $error$242
$LN76@GSTFormatV:

; 511  : 		}
; 512  : 
; 513  : 		volParams->quickFormat = TRUE;		// To entirely format a hidden volume would be redundant

  0082f	c7 43 38 01 00
	00 00		 mov	 DWORD PTR [ebx+56], 1
$LN75@GSTFormatV:

; 514  : 	}
; 515  : 
; 516  : 	/* Data area */
; 517  : 	startSector = dataOffset / FormatSectorSize;

  00836	6a 00		 push	 0
  00838	56		 push	 esi
  00839	ff b5 14 da fd
	ff		 push	 DWORD PTR _dataOffset$2$[ebp]
  0083f	ff b5 10 da fd
	ff		 push	 DWORD PTR _dataOffset$1$[ebp]
  00845	e8 00 00 00 00	 call	 __aulldiv

; 518  : 
; 519  : 	// Format filesystem
; 520  : 
; 521  : 	switch (volParams->fileSystem)

  0084a	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  0084d	8b f0		 mov	 esi, eax
  0084f	89 95 1c da fd
	ff		 mov	 DWORD PTR _startSector$2$[ebp], edx
  00855	83 e9 00	 sub	 ecx, 0
  00858	0f 84 c8 00 00
	00		 je	 $LN77@GSTFormatV
  0085e	83 e9 01	 sub	 ecx, 1
  00861	74 13		 je	 SHORT $LN80@GSTFormatV
  00863	83 e9 01	 sub	 ecx, 1
  00866	0f 84 ba 00 00
	00		 je	 $LN77@GSTFormatV

; 571  : 
; 572  : 	default:
; 573  : 		nStatus = ERR_PARAMETER_INCORRECT; 

  0086c	be 1e 00 00 00	 mov	 esi, 30			; 0000001eH

; 574  : 		goto error;

  00871	e9 35 02 00 00	 jmp	 $error$242
$LN80@GSTFormatV:

; 536  : 
; 537  : 		break;
; 538  : 		
; 539  : 	case FILESYS_FAT:
; 540  : 		if (num_sectors > 0xFFFFffff)

  00876	83 bd 00 da fd
	ff 00		 cmp	 DWORD PTR _num_sectors$2$[ebp], 0
  0087d	77 a6		 ja	 SHORT $LN66@GSTFormatV
  0087f	8b 85 fc d9 fd
	ff		 mov	 eax, DWORD PTR _num_sectors$1$[ebp]
  00885	83 f8 ff	 cmp	 eax, -1
  00888	77 9b		 ja	 SHORT $LN66@GSTFormatV

; 541  : 		{
; 542  : 			nStatus = ERR_VOL_SIZE_WRONG; 
; 543  : 			goto error;
; 544  : 		}
; 545  : 
; 546  : 		// Calculate the fats, root dir etc
; 547  : 		ft.num_sectors = (unsigned int) (num_sectors);

  0088a	89 85 b0 da fd
	ff		 mov	 DWORD PTR _ft$[ebp+16], eax

; 548  : 
; 549  : #if GST_MAX_VOLUME_SECTOR_SIZE > 0xFFFF
; 550  : #error GST_MAX_VOLUME_SECTOR_SIZE > 0xFFFF
; 551  : #endif
; 552  : 
; 553  : 		ft.sector_size = (uint16) FormatSectorSize;

  00890	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _FormatSectorSize
  00897	66 89 85 d2 da
	fd ff		 mov	 WORD PTR _ft$[ebp+50], ax

; 554  : 		ft.cluster_size = volParams->clusterSize;

  0089e	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]

; 555  : 		memcpy (ft.volume_name, "NO NAME    ", 11);

  008a1	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@
  008a9	89 85 c8 da fd
	ff		 mov	 DWORD PTR _ft$[ebp+40], eax
  008af	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@+8
  008b6	66 89 85 a8 da
	fd ff		 mov	 WORD PTR _ft$[ebp+8], ax
  008bd	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@+10
  008c2	88 85 aa da fd
	ff		 mov	 BYTE PTR _ft$[ebp+10], al

; 556  : 		GetFatParams (&ft); 

  008c8	8d 85 a0 da fd
	ff		 lea	 eax, DWORD PTR _ft$[ebp]
  008ce	50		 push	 eax
  008cf	66 0f d6 85 a0
	da fd ff	 movq	 QWORD PTR _ft$[ebp], xmm0
  008d7	e8 00 00 00 00	 call	 _GetFatParams

; 557  : 		*(volParams->realClusterSize) = ft.cluster_size * FormatSectorSize;

  008dc	8b 8d c8 da fd
	ff		 mov	 ecx, DWORD PTR _ft$[ebp+40]
  008e2	83 c4 04	 add	 esp, 4
  008e5	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _FormatSectorSize
  008ec	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  008ef	89 08		 mov	 DWORD PTR [eax], ecx

; 558  : 
; 559  : 		if (volParams->bDevice && !StartFormatWriteThread())

  008f1	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  008f4	74 0d		 je	 SHORT $LN82@GSTFormatV
  008f6	e8 00 00 00 00	 call	 _StartFormatWriteThread
  008fb	85 c0		 test	 eax, eax
  008fd	0f 84 92 fd ff
	ff		 je	 $LN141@GSTFormatV
$LN82@GSTFormatV:

; 560  : 		{
; 561  : 			nStatus = ERR_OS_ERROR; 
; 562  : 			goto error;
; 563  : 		}
; 564  : 
; 565  : 		nStatus = FormatFat (startSector, &ft, (void *) dev, cryptoInfo, volParams->quickFormat);

  00903	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00906	50		 push	 eax
  00907	ff b5 20 da fd
	ff		 push	 DWORD PTR _cryptoInfo$[ebp]
  0090d	8d 85 a0 da fd
	ff		 lea	 eax, DWORD PTR _ft$[ebp]
  00913	57		 push	 edi
  00914	50		 push	 eax
  00915	ff b5 1c da fd
	ff		 push	 DWORD PTR _startSector$2$[ebp]
  0091b	56		 push	 esi
  0091c	e8 00 00 00 00	 call	 _FormatFat
  00921	83 c4 18	 add	 esp, 24			; 00000018H

; 566  : 
; 567  : 		if (volParams->bDevice)
; 568  : 			StopFormatWriteThread();
; 569  : 
; 570  : 		break;

  00924	eb 38		 jmp	 SHORT $LN236@GSTFormatV
$LN77@GSTFormatV:

; 522  : 	{
; 523  : 	case FILESYS_NONE:
; 524  : 	case FILESYS_NTFS:
; 525  : 
; 526  : 		if (volParams->bDevice && !StartFormatWriteThread())

  00926	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00929	74 0d		 je	 SHORT $LN78@GSTFormatV
  0092b	e8 00 00 00 00	 call	 _StartFormatWriteThread
  00930	85 c0		 test	 eax, eax
  00932	0f 84 5d fd ff
	ff		 je	 $LN141@GSTFormatV
$LN78@GSTFormatV:

; 527  : 		{
; 528  : 			nStatus = ERR_OS_ERROR; 
; 529  : 			goto error;
; 530  : 		}
; 531  : 
; 532  : 		nStatus = FormatNoFs (startSector, num_sectors, dev, cryptoInfo, volParams->quickFormat);

  00938	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  0093b	50		 push	 eax
  0093c	ff b5 20 da fd
	ff		 push	 DWORD PTR _cryptoInfo$[ebp]
  00942	57		 push	 edi
  00943	ff b5 00 da fd
	ff		 push	 DWORD PTR _num_sectors$2$[ebp]
  00949	ff b5 fc d9 fd
	ff		 push	 DWORD PTR _num_sectors$1$[ebp]
  0094f	ff b5 1c da fd
	ff		 push	 DWORD PTR _startSector$2$[ebp]
  00955	56		 push	 esi
  00956	e8 00 00 00 00	 call	 _FormatNoFs
  0095b	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN236@GSTFormatV:

; 533  : 
; 534  : 		if (volParams->bDevice)

  0095e	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00961	8b f0		 mov	 esi, eax
  00963	74 05		 je	 SHORT $LN79@GSTFormatV

; 535  : 			StopFormatWriteThread();

  00965	e8 00 00 00 00	 call	 _StopFormatWriteThread
$LN79@GSTFormatV:

; 575  : 	}
; 576  : 
; 577  : 	if (nStatus != ERR_SUCCESS)

  0096a	85 f6		 test	 esi, esi
  0096c	0f 85 39 01 00
	00		 jne	 $error$242

; 578  : 		goto error;
; 579  : 
; 580  : 	// Write header backup
; 581  : 	offset.QuadPart = volParams->hiddenVol ? volParams->hiddenVolHostSize - GST_HIDDEN_VOLUME_HEADER_OFFSET : dataAreaSize + GST_VOLUME_HEADER_GROUP_SIZE;

  00972	39 73 04	 cmp	 DWORD PTR [ebx+4], esi
  00975	8b b5 24 da fd
	ff		 mov	 esi, DWORD PTR _dataAreaSize$1$[ebp]
  0097b	74 10		 je	 SHORT $LN119@GSTFormatV
  0097d	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00980	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00983	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  00988	83 d9 00	 sbb	 ecx, 0
  0098b	eb 10		 jmp	 SHORT $LN120@GSTFormatV
$LN119@GSTFormatV:
  0098d	8b 8d 38 da fd
	ff		 mov	 ecx, DWORD PTR _dataAreaSize$2$[ebp]
  00993	8b c6		 mov	 eax, esi
  00995	05 00 00 02 00	 add	 eax, 131072		; 00020000H
  0099a	83 d1 00	 adc	 ecx, 0
$LN120@GSTFormatV:

; 582  : 
; 583  : 	if (!SetFilePointerEx ((HANDLE) dev, offset, NULL, FILE_BEGIN))

  0099d	6a 00		 push	 0
  0099f	6a 00		 push	 0
  009a1	51		 push	 ecx
  009a2	50		 push	 eax
  009a3	57		 push	 edi
  009a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  009aa	85 c0		 test	 eax, eax
  009ac	0f 84 e3 fc ff
	ff		 je	 $LN141@GSTFormatV

; 584  : 	{
; 585  : 		nStatus = ERR_OS_ERROR;
; 586  : 		goto error;
; 587  : 	}
; 588  : 
; 589  : 	/* Switch between mode of operations */
; 590  : 	switch (volParams->ea)

  009b2	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  009b5	83 e8 01	 sub	 eax, 1
  009b8	74 0a		 je	 SHORT $LN87@GSTFormatV
  009ba	83 e8 01	 sub	 eax, 1

; 594  : 			break;
; 595  : 	case GRASSHOPPER:
; 596  : 		dwModeOfOperatioID = XTS;
; 597  : 		break;
; 598  : 	default:
; 599  : 		dwModeOfOperatioID = FIRST_MODE_OF_OPERATION_ID;

  009bd	b9 01 00 00 00	 mov	 ecx, 1
  009c2	eb 05		 jmp	 SHORT $LN16@GSTFormatV
$LN87@GSTFormatV:

; 591  : 	{
; 592  : 	case GOST:
; 593  : 		dwModeOfOperatioID = XTS8;

  009c4	b9 02 00 00 00	 mov	 ecx, 2
$LN16@GSTFormatV:

; 600  : 		break;
; 601  : 	}
; 602  : 
; 603  : 	nStatus = CreateVolumeHeaderInMemory (FALSE,

  009c9	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  009cd	74 08		 je	 SHORT $LN121@GSTFormatV
  009cf	8b 95 38 da fd
	ff		 mov	 edx, DWORD PTR _dataAreaSize$2$[ebp]
  009d5	eb 17		 jmp	 SHORT $LN122@GSTFormatV
$LN121@GSTFormatV:
  009d7	0f 57 c0	 xorps	 xmm0, xmm0
  009da	66 0f 13 85 18
	da fd ff	 movlpd	 QWORD PTR tv615[ebp], xmm0
  009e2	8b 95 1c da fd
	ff		 mov	 edx, DWORD PTR tv615[ebp+4]
  009e8	8b b5 18 da fd
	ff		 mov	 esi, DWORD PTR tv615[ebp]
$LN122@GSTFormatV:
  009ee	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  009f1	6a 00		 push	 0
  009f3	ff 35 00 00 00
	00		 push	 DWORD PTR _FormatSectorSize
  009f9	50		 push	 eax
  009fa	8b 85 24 da fd
	ff		 mov	 eax, DWORD PTR _dataAreaSize$1$[ebp]
  00a00	6a 00		 push	 0
  00a02	ff b5 38 da fd
	ff		 push	 DWORD PTR _dataAreaSize$2$[ebp]
  00a08	50		 push	 eax
  00a09	ff b5 14 da fd
	ff		 push	 DWORD PTR _dataOffset$2$[ebp]
  00a0f	ff b5 10 da fd
	ff		 push	 DWORD PTR _dataOffset$1$[ebp]
  00a15	52		 push	 edx
  00a16	56		 push	 esi
  00a17	ff b5 38 da fd
	ff		 push	 DWORD PTR _dataAreaSize$2$[ebp]
  00a1d	50		 push	 eax
  00a1e	8d 85 20 da fd
	ff		 lea	 eax, DWORD PTR _cryptoInfo$[ebp]
  00a24	50		 push	 eax
  00a25	8b 85 20 da fd
	ff		 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00a2b	05 50 1c 00 00	 add	 eax, 7248		; 00001c50H
  00a30	50		 push	 eax
  00a31	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00a34	50		 push	 eax
  00a35	8b 43 44	 mov	 eax, DWORD PTR [ebx+68]
  00a38	50		 push	 eax
  00a39	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00a3c	51		 push	 ecx
  00a3d	50		 push	 eax
  00a3e	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00a44	50		 push	 eax
  00a45	6a 00		 push	 0
  00a47	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  00a4c	8b f0		 mov	 esi, eax

; 604  : 		header,
; 605  : 		volParams->ea,
; 606  : 		dwModeOfOperatioID,
; 607  : 		volParams->password,
; 608  : 		volParams->pkcs5,
; 609  : 		cryptoInfo->master_keydata,
; 610  : 		&cryptoInfo,
; 611  : 		dataAreaSize,
; 612  : 		volParams->hiddenVol ? dataAreaSize : 0,
; 613  : 		dataOffset,
; 614  : 		dataAreaSize,
; 615  : 		0,
; 616  : 		volParams->headerFlags,
; 617  : 		FormatSectorSize,
; 618  : 		FALSE);
; 619  : 
; 620  : 	if (!WriteEffectiveVolumeHeader (volParams->bDevice, dev, header))

  00a4e	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00a54	50		 push	 eax
  00a55	8b 03		 mov	 eax, DWORD PTR [ebx]
  00a57	57		 push	 edi
  00a58	50		 push	 eax
  00a59	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  00a5e	83 c4 5c	 add	 esp, 92			; 0000005cH
  00a61	85 c0		 test	 eax, eax
  00a63	0f 84 2c fc ff
	ff		 je	 $LN141@GSTFormatV

; 621  : 	{
; 622  : 		nStatus = ERR_OS_ERROR;
; 623  : 		goto error;
; 624  : 	}
; 625  : 
; 626  : 	// Fill reserved header sectors (including the backup header area) with random data
; 627  : 	if (!volParams->hiddenVol)

  00a69	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00a6d	75 25		 jne	 SHORT $LN92@GSTFormatV

; 628  : 	{
; 629  : 		nStatus = WriteRandomDataToReservedHeaderAreas (dev, cryptoInfo, dataAreaSize, FALSE, FALSE);

  00a6f	6a 00		 push	 0
  00a71	6a 00		 push	 0
  00a73	ff b5 38 da fd
	ff		 push	 DWORD PTR _dataAreaSize$2$[ebp]
  00a79	ff b5 24 da fd
	ff		 push	 DWORD PTR _dataAreaSize$1$[ebp]
  00a7f	ff b5 20 da fd
	ff		 push	 DWORD PTR _cryptoInfo$[ebp]
  00a85	57		 push	 edi
  00a86	e8 00 00 00 00	 call	 _WriteRandomDataToReservedHeaderAreas
  00a8b	8b f0		 mov	 esi, eax
  00a8d	83 c4 18	 add	 esp, 24			; 00000018H

; 630  : 
; 631  : 		if (nStatus != ERR_SUCCESS)

  00a90	85 f6		 test	 esi, esi
  00a92	75 17		 jne	 SHORT $error$242
$LN92@GSTFormatV:

; 632  : 			goto error;
; 633  : 	}
; 634  : 
; 635  : #ifndef DEBUG
; 636  : 	if (volParams->quickFormat && volParams->fileSystem != FILESYS_NTFS)

  00a94	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00a98	74 11		 je	 SHORT $error$242
  00a9a	83 7b 2c 02	 cmp	 DWORD PTR [ebx+44], 2
  00a9e	74 0b		 je	 SHORT $error$242

; 637  : 		Sleep (500);	// User-friendly GUI

  00aa0	68 f4 01 00 00	 push	 500			; 000001f4H
  00aa5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$error$242:

; 638  : #endif
; 639  : 
; 640  : error:
; 641  : 	dwError = GetLastError();

  00aab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00ab1	89 85 34 da fd
	ff		 mov	 DWORD PTR _dwError$1$[ebp], eax

; 642  : 
; 643  : 	burn (header, sizeof (header));

  00ab7	8d 95 f8 fc ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  00abd	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00ac2	8b ca		 mov	 ecx, edx
  00ac4	89 85 1c da fd
	ff		 mov	 DWORD PTR _cnt$1$[ebp], eax
  00aca	66 0f 1f 44 00
	00		 npad	 6
$LL128@GSTFormatV:
  00ad0	83 ad 1c da fd
	ff 01		 sub	 DWORD PTR _cnt$1$[ebp], 1
  00ad7	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00ada	c6 41 ff 00	 mov	 BYTE PTR [ecx-1], 0
  00ade	75 f0		 jne	 SHORT $LL128@GSTFormatV
$LL21@GSTFormatV:
  00ae0	c6 02 00	 mov	 BYTE PTR [edx], 0
  00ae3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00ae6	83 e8 01	 sub	 eax, 1
  00ae9	75 f5		 jne	 SHORT $LL21@GSTFormatV

; 644  : 	VirtualUnlock (header, sizeof (header));

  00aeb	68 00 02 00 00	 push	 512			; 00000200H
  00af0	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00af6	50		 push	 eax
  00af7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 645  : 
; 646  : 	if (dev != INVALID_HANDLE_VALUE)

  00afd	83 ff ff	 cmp	 edi, -1
  00b00	74 5d		 je	 SHORT $LN94@GSTFormatV

; 647  : 	{
; 648  : 		if (!volParams->bDevice && !volParams->hiddenVol && nStatus != 0)

  00b02	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00b05	75 22		 jne	 SHORT $LN96@GSTFormatV
  00b07	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00b0b	75 1c		 jne	 SHORT $LN96@GSTFormatV
  00b0d	85 f6		 test	 esi, esi
  00b0f	74 18		 je	 SHORT $LN96@GSTFormatV

; 649  : 		{
; 650  : 			// Remove preallocated part before closing file handle if format failed
; 651  : 			if (SetFilePointer (dev, 0, NULL, FILE_BEGIN) == 0)

  00b11	6a 00		 push	 0
  00b13	6a 00		 push	 0
  00b15	6a 00		 push	 0
  00b17	57		 push	 edi
  00b18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  00b1e	85 c0		 test	 eax, eax
  00b20	75 07		 jne	 SHORT $LN96@GSTFormatV

; 652  : 				SetEndOfFile (dev);

  00b22	57		 push	 edi
  00b23	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEndOfFile@4
$LN96@GSTFormatV:

; 653  : 		}
; 654  : 
; 655  : 		FlushFileBuffers (dev);

  00b29	57		 push	 edi
  00b2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FlushFileBuffers@4

; 656  : 
; 657  : 		if (bTimeStampValid)

  00b30	83 bd f8 d9 fd
	ff 00		 cmp	 DWORD PTR _bTimeStampValid$1$[ebp], 0
  00b37	74 1c		 je	 SHORT $LN97@GSTFormatV

; 658  : 			SetFileTime (dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime);

  00b39	8d 85 e4 d9 fd
	ff		 lea	 eax, DWORD PTR _ftLastWriteTime$[ebp]
  00b3f	50		 push	 eax
  00b40	8d 85 dc d9 fd
	ff		 lea	 eax, DWORD PTR _ftLastAccessTime$[ebp]
  00b46	50		 push	 eax
  00b47	8d 85 d4 d9 fd
	ff		 lea	 eax, DWORD PTR _ftCreationTime$[ebp]
  00b4d	50		 push	 eax
  00b4e	57		 push	 edi
  00b4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFileTime@16
$LN97@GSTFormatV:

; 659  : 
; 660  : 		CloseHandle (dev);

  00b55	57		 push	 edi
  00b56	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 661  : 		dev = INVALID_HANDLE_VALUE;

  00b5c	83 cf ff	 or	 edi, -1
$LN94@GSTFormatV:

; 662  : 	}
; 663  : 
; 664  : 	if (nStatus != 0)

  00b5f	85 f6		 test	 esi, esi
  00b61	0f 85 3f 02 00
	00		 jne	 $LN143@GSTFormatV

; 667  : 		goto fv_end;
; 668  : 	}
; 669  : 
; 670  : 	if (volParams->fileSystem == FILESYS_NTFS)

  00b67	83 7b 2c 02	 cmp	 DWORD PTR [ebx+44], 2
  00b6b	0f 85 41 02 00
	00		 jne	 $fv_end$243

; 671  : 	{
; 672  : 		// Quick-format volume as NTFS
; 673  : 		int driveNo = GetLastAvailableDrive ();

  00b71	e8 00 00 00 00	 call	 _GetLastAvailableDrive

; 674  : 		MountOptions mountOptions;
; 675  : 		int retCode;
; 676  : 
; 677  : 		ZeroMemory (&mountOptions, sizeof (mountOptions));

  00b76	6a 64		 push	 100			; 00000064H
  00b78	89 85 34 da fd
	ff		 mov	 DWORD PTR _driveNo$1$[ebp], eax
  00b7e	8d 85 3c da fd
	ff		 lea	 eax, DWORD PTR _mountOptions$7[ebp]
  00b84	56		 push	 esi
  00b85	50		 push	 eax
  00b86	e8 00 00 00 00	 call	 _memset

; 678  : 
; 679  : 		if (driveNo == -1)

  00b8b	8b 8d 34 da fd
	ff		 mov	 ecx, DWORD PTR _driveNo$1$[ebp]
  00b91	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b94	83 f9 ff	 cmp	 ecx, -1
  00b97	0f 84 c4 01 00
	00		 je	 $LN144@GSTFormatV

; 686  : 		}
; 687  : 
; 688  : 		mountOptions.ReadOnly = FALSE;
; 689  : 		mountOptions.Removable = FALSE;
; 690  : 		mountOptions.ProtectHiddenVolume = FALSE;
; 691  : 		mountOptions.PreserveTimestamp = bPreserveTimestamp;

  00b9d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bPreserveTimestamp

; 692  : 		mountOptions.PartitionInInactiveSysEncScope = FALSE;
; 693  : 		mountOptions.UseBackupHeader = FALSE;
; 694  : 
; 695  : 		if (MountVolume (volParams->hwndDlg, driveNo, volParams->volumePath, volParams->password, FALSE, TRUE, &mountOptions, FALSE, TRUE) < 1)

  00ba2	6a 01		 push	 1
  00ba4	56		 push	 esi
  00ba5	89 85 48 da fd
	ff		 mov	 DWORD PTR _mountOptions$7[ebp+12], eax
  00bab	8d 85 3c da fd
	ff		 lea	 eax, DWORD PTR _mountOptions$7[ebp]
  00bb1	50		 push	 eax
  00bb2	8b 43 44	 mov	 eax, DWORD PTR [ebx+68]
  00bb5	6a 01		 push	 1
  00bb7	56		 push	 esi
  00bb8	50		 push	 eax
  00bb9	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00bbc	50		 push	 eax
  00bbd	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00bc0	51		 push	 ecx
  00bc1	50		 push	 eax
  00bc2	89 b5 3c da fd
	ff		 mov	 DWORD PTR _mountOptions$7[ebp], esi
  00bc8	89 b5 40 da fd
	ff		 mov	 DWORD PTR _mountOptions$7[ebp+4], esi
  00bce	89 b5 44 da fd
	ff		 mov	 DWORD PTR _mountOptions$7[ebp+8], esi
  00bd4	89 b5 4c da fd
	ff		 mov	 DWORD PTR _mountOptions$7[ebp+16], esi
  00bda	89 b5 98 da fd
	ff		 mov	 DWORD PTR _mountOptions$7[ebp+92], esi
  00be0	e8 00 00 00 00	 call	 _MountVolume
  00be5	83 c4 24	 add	 esp, 36			; 00000024H
  00be8	83 f8 01	 cmp	 eax, 1
  00beb	0f 8c 2b 01 00
	00		 jl	 $LN145@GSTFormatV

; 701  : 		}
; 702  : 
; 703  : 		if (!IsAdmin () && IsUacSupported ())

  00bf1	e8 00 00 00 00	 call	 _IsAdmin
  00bf6	85 c0		 test	 eax, eax
  00bf8	75 21		 jne	 SHORT $LN102@GSTFormatV
  00bfa	e8 00 00 00 00	 call	 _IsUacSupported
  00bff	85 c0		 test	 eax, eax
  00c01	74 18		 je	 SHORT $LN102@GSTFormatV

; 704  : 			retCode = UacFormatNtfs (volParams->hwndDlg, driveNo, volParams->clusterSize);

  00c03	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00c06	50		 push	 eax
  00c07	ff b5 34 da fd
	ff		 push	 DWORD PTR _driveNo$1$[ebp]
  00c0d	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00c10	50		 push	 eax
  00c11	e8 00 00 00 00	 call	 _UacFormatNtfs
  00c16	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c19	eb 12		 jmp	 SHORT $LN103@GSTFormatV
$LN102@GSTFormatV:

; 705  : 		else
; 706  : 			retCode = FormatNtfs (driveNo, volParams->clusterSize);

  00c1b	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00c1e	50		 push	 eax
  00c1f	ff b5 34 da fd
	ff		 push	 DWORD PTR _driveNo$1$[ebp]
  00c25	e8 00 00 00 00	 call	 _FormatNtfs
  00c2a	83 c4 08	 add	 esp, 8
$LN103@GSTFormatV:

; 707  : 
; 708  : 		if (retCode != TRUE)
; 709  : 		{
; 710  : 			if (!UnmountVolume (volParams->hwndDlg, driveNo, FALSE))

  00c2d	6a 00		 push	 0
  00c2f	ff b5 34 da fd
	ff		 push	 DWORD PTR _driveNo$1$[ebp]
  00c35	83 f8 01	 cmp	 eax, 1
  00c38	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00c3b	50		 push	 eax
  00c3c	0f 84 a5 00 00
	00		 je	 $LN104@GSTFormatV
  00c42	e8 00 00 00 00	 call	 _UnmountVolume
  00c47	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c4a	85 c0		 test	 eax, eax
  00c4c	75 20		 jne	 SHORT $LN105@GSTFormatV

; 711  : 				MessageBoxW (volParams->hwndDlg, GetString ("CANT_DISMOUNT_VOLUME"), lpszTitle, ICON_HAND);

  00c4e	6a 10		 push	 16			; 00000010H
  00c50	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00c56	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@
  00c5b	e8 00 00 00 00	 call	 _GetString
  00c60	83 c4 04	 add	 esp, 4
  00c63	50		 push	 eax
  00c64	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00c67	50		 push	 eax
  00c68	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$LN105@GSTFormatV:

; 712  : 
; 713  : 			if (dataAreaSize <= GST_MAX_FAT_SECTOR_COUNT * FormatSectorSize)

  00c6e	8b 85 38 da fd
	ff		 mov	 eax, DWORD PTR _dataAreaSize$2$[ebp]
  00c74	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _FormatSectorSize
  00c7a	77 54		 ja	 SHORT $LN106@GSTFormatV
  00c7c	72 09		 jb	 SHORT $LN202@GSTFormatV
  00c7e	83 bd 24 da fd
	ff 00		 cmp	 DWORD PTR _dataAreaSize$1$[ebp], 0
  00c85	77 49		 ja	 SHORT $LN106@GSTFormatV
$LN202@GSTFormatV:

; 714  : 			{
; 715  : 				if (AskErrYesNo ("FORMAT_NTFS_FAILED_ASK_FAT") == IDYES)

  00c87	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@
  00c8c	e8 00 00 00 00	 call	 _AskErrYesNo
  00c91	83 c4 04	 add	 esp, 4
  00c94	83 f8 06	 cmp	 eax, 6
  00c97	75 44		 jne	 SHORT $LN107@GSTFormatV

; 716  : 				{
; 717  : 					// NTFS format failed and the user wants to try FAT format immediately
; 718  : 					volParams->fileSystem = FILESYS_FAT;
; 719  : 					bInstantRetryOtherFilesys = TRUE;

  00c99	be 01 00 00 00	 mov	 esi, 1
  00c9e	c7 43 2c 01 00
	00 00		 mov	 DWORD PTR [ebx+44], 1

; 720  : 					volParams->quickFormat = TRUE;		// Volume has already been successfully GST-formatted

  00ca5	89 73 38	 mov	 DWORD PTR [ebx+56], esi
  00ca8	89 b5 1c da fd
	ff		 mov	 DWORD PTR _bInstantRetryOtherFilesys$1$[ebp], esi

; 721  : 					volParams->clusterSize = 0;		// Default cluster size

  00cae	c7 43 30 00 00
	00 00		 mov	 DWORD PTR [ebx+48], 0

; 722  : 					goto begin_format;

  00cb5	e9 dc f5 ff ff	 jmp	 $begin_format$241
$LN142@GSTFormatV:
  00cba	5e		 pop	 esi
  00cbb	5f		 pop	 edi

; 231  : 			return ERR_OS_ERROR;

  00cbc	b8 01 00 00 00	 mov	 eax, 1
  00cc1	5b		 pop	 ebx

; 746  : }

  00cc2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cc5	33 cd		 xor	 ecx, ebp
  00cc7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ccc	8b e5		 mov	 esp, ebp
  00cce	5d		 pop	 ebp
  00ccf	c3		 ret	 0
$LN106@GSTFormatV:

; 723  : 				}
; 724  : 			}
; 725  : 			else
; 726  : 				Error ("FORMAT_NTFS_FAILED");

  00cd0	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@
  00cd5	e8 00 00 00 00	 call	 _Error
  00cda	83 c4 04	 add	 esp, 4
$LN107@GSTFormatV:

; 727  : 
; 728  : 			nStatus = ERR_DONT_REPORT;

  00cdd	be 1c 00 00 00	 mov	 esi, 28			; 0000001cH

; 729  : 			goto fv_end;

  00ce2	e9 cb 00 00 00	 jmp	 $fv_end$243
$LN104@GSTFormatV:

; 730  : 		}
; 731  : 
; 732  : 		if (!UnmountVolume (volParams->hwndDlg, driveNo, FALSE))

  00ce7	e8 00 00 00 00	 call	 _UnmountVolume
  00cec	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cef	85 c0		 test	 eax, eax
  00cf1	0f 85 bb 00 00
	00		 jne	 $fv_end$243

; 733  : 			MessageBoxW (volParams->hwndDlg, GetString ("CANT_DISMOUNT_VOLUME"), lpszTitle, ICON_HAND);

  00cf7	6a 10		 push	 16			; 00000010H
  00cf9	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00cff	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@
  00d04	e8 00 00 00 00	 call	 _GetString
  00d09	83 c4 04	 add	 esp, 4
  00d0c	50		 push	 eax
  00d0d	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00d10	50		 push	 eax
  00d11	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00d17	e9 96 00 00 00	 jmp	 $fv_end$243
$LN145@GSTFormatV:

; 696  : 		{
; 697  : 			MessageBoxW (volParams->hwndDlg, GetString ("CANT_MOUNT_VOLUME"), lpszTitle, ICON_HAND);

  00d1c	6a 10		 push	 16			; 00000010H
  00d1e	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00d24	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@
  00d29	e8 00 00 00 00	 call	 _GetString
  00d2e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__MessageBoxW@16
  00d34	83 c4 04	 add	 esp, 4
  00d37	50		 push	 eax
  00d38	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00d3b	50		 push	 eax
  00d3c	ff d6		 call	 esi

; 698  : 			MessageBoxW (volParams->hwndDlg, GetString ("FORMAT_NTFS_STOP"), lpszTitle, ICON_HAND);

  00d3e	6a 10		 push	 16			; 00000010H
  00d40	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00d46	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@
  00d4b	e8 00 00 00 00	 call	 _GetString
  00d50	83 c4 04	 add	 esp, 4
  00d53	50		 push	 eax
  00d54	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00d57	50		 push	 eax
  00d58	ff d6		 call	 esi

; 699  : 			nStatus = ERR_VOL_MOUNT_FAILED;

  00d5a	be 18 00 00 00	 mov	 esi, 24			; 00000018H

; 700  : 			goto fv_end;

  00d5f	eb 51		 jmp	 SHORT $fv_end$243
$LN144@GSTFormatV:

; 680  : 		{
; 681  : 			MessageBoxW (volParams->hwndDlg, GetString ("NO_FREE_DRIVES"), lpszTitle, ICON_HAND);

  00d61	6a 10		 push	 16			; 00000010H
  00d63	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00d69	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@
  00d6e	e8 00 00 00 00	 call	 _GetString
  00d73	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__MessageBoxW@16
  00d79	83 c4 04	 add	 esp, 4
  00d7c	50		 push	 eax
  00d7d	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00d80	50		 push	 eax
  00d81	ff d6		 call	 esi

; 682  : 			MessageBoxW (volParams->hwndDlg, GetString ("FORMAT_NTFS_STOP"), lpszTitle, ICON_HAND);

  00d83	6a 10		 push	 16			; 00000010H
  00d85	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00d8b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@
  00d90	e8 00 00 00 00	 call	 _GetString
  00d95	83 c4 04	 add	 esp, 4
  00d98	50		 push	 eax
  00d99	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00d9c	50		 push	 eax
  00d9d	ff d6		 call	 esi

; 683  : 
; 684  : 			nStatus = ERR_NO_FREE_DRIVES;

  00d9f	be 16 00 00 00	 mov	 esi, 22			; 00000016H

; 685  : 			goto fv_end;

  00da4	eb 0c		 jmp	 SHORT $fv_end$243
$LN143@GSTFormatV:

; 665  : 	{
; 666  : 		SetLastError(dwError);

  00da6	ff b5 34 da fd
	ff		 push	 DWORD PTR _dwError$1$[ebp]
  00dac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$fv_end$243:

; 734  : 	}
; 735  : 
; 736  : fv_end:
; 737  : 	dwError = GetLastError();

  00db2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 738  : 
; 739  : 	if (dosDev[0])

  00db8	80 bd f4 fb ff
	ff 00		 cmp	 BYTE PTR _dosDev$[ebp], 0
  00dbf	8b f8		 mov	 edi, eax
  00dc1	74 13		 je	 SHORT $LN110@GSTFormatV

; 740  : 		RemoveFakeDosName (volParams->volumePath, dosDev);

  00dc3	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00dc6	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  00dcc	50		 push	 eax
  00dcd	51		 push	 ecx
  00dce	e8 00 00 00 00	 call	 _RemoveFakeDosName
  00dd3	83 c4 08	 add	 esp, 8
$LN110@GSTFormatV:

; 741  : 
; 742  : 	crypto_close (cryptoInfo);

  00dd6	ff b5 20 da fd
	ff		 push	 DWORD PTR _cryptoInfo$[ebp]
  00ddc	e8 00 00 00 00	 call	 _crypto_close
  00de1	83 c4 04	 add	 esp, 4

; 743  : 
; 744  : 	SetLastError (dwError);

  00de4	57		 push	 edi
  00de5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 745  : 	return nStatus;

  00deb	8b c6		 mov	 eax, esi
  00ded	5e		 pop	 esi
  00dee	5f		 pop	 edi
  00def	5b		 pop	 ebx

; 746  : }

  00df0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00df3	33 cd		 xor	 ecx, ebp
  00df5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00dfa	8b e5		 mov	 esp, ebp
  00dfc	5d		 pop	 ebp
  00dfd	c3		 ret	 0
$LN24@GSTFormatV:

; 143  : 	{
; 144  : 		Error ("SECTOR_SIZE_UNSUPPORTED");

  00dfe	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
  00e03	e8 00 00 00 00	 call	 _Error

; 746  : }

  00e08	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e0b	83 c4 04	 add	 esp, 4
  00e0e	33 cd		 xor	 ecx, ebp
  00e10	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  00e15	5f		 pop	 edi
  00e16	5b		 pop	 ebx
  00e17	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e1c	8b e5		 mov	 esp, ebp
  00e1e	5d		 pop	 ebp
  00e1f	c3		 ret	 0
_GSTFormatVolume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
