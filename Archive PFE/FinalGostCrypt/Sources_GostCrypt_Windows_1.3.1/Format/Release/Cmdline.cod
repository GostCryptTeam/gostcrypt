; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\Cmdline.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	_CommandHelpDlgProc@16
PUBLIC	_Win32CommandLine
PUBLIC	_GetArgSepPosOffset
PUBLIC	_GetArgumentID
PUBLIC	_GetArgumentValue
PUBLIC	??_C@_0BE@GKKPACCB@IDD_COMMANDHELP_DLG?$AA@	; `string'
PUBLIC	??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@ ; `string'
PUBLIC	??_C@_06EEAEEKCL@?$CFs?7?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@		; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_tolower:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__GetCommandLineW@0:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__CommandLineToArgvW@8:PROC
EXTRN	_malloc:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_AbortProcess:PROC
EXTRN	_AbortProcessSilent:PROC
EXTRN	_err_malloc:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	_LocalizeDialog:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@
CONST	SEGMENT
??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@ DB 'OUTOFMEMORY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EEAEEKCL@?$CFs?7?$CFs?6?$AA@
CONST	SEGMENT
??_C@_06EEAEEKCL@?$CFs?7?$CFs?6?$AA@ DB '%s', 09H, '%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@
CONST	SEGMENT
??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@ DB 'Command line opt'
	DB	'ions:', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GKKPACCB@IDD_COMMANDHELP_DLG?$AA@
CONST	SEGMENT
??_C@_0BE@GKKPACCB@IDD_COMMANDHELP_DLG?$AA@ DB 'IDD_COMMANDHELP_DLG', 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\cmdline.c
;	COMDAT _GetArgumentValue
_TEXT	SEGMENT
_lpszCommandLineArgs$ = 8				; size = 4
_nArgPos$ = 12						; size = 4
_nArgIdx$ = 16						; size = 4
_nNoCommandLineArgs$ = 20				; size = 4
_lpszValue$ = 24					; size = 4
_nValueSize$ = 28					; size = 4
_GetArgumentValue PROC					; COMDAT

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 285  : 	*lpszValue = 0;
; 286  : 
; 287  : 	if (nArgPos)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _nArgPos$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7d 18	 mov	 edi, DWORD PTR _lpszValue$[ebp]
  0000b	c6 07 00	 mov	 BYTE PTR [edi], 0
  0000e	85 d2		 test	 edx, edx
  00010	74 29		 je	 SHORT $LN2@GetArgumen

; 288  : 	{
; 289  : 		/* Handles the case of no space between parameter code and
; 290  : 		   value */
; 291  : 		strncpy (lpszValue, &lpszCommandLineArgs[*nArgIdx][nArgPos], nValueSize);

  00012	8b 45 10	 mov	 eax, DWORD PTR _nArgIdx$[ebp]
  00015	8b 75 1c	 mov	 esi, DWORD PTR _nValueSize$[ebp]
  00018	56		 push	 esi
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpszCommandLineArgs$[ebp]
  0001e	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00021	03 c2		 add	 eax, edx
  00023	50		 push	 eax
  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 _strncpy
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 292  : 		lpszValue[nValueSize - 1] = 0;

  0002d	c6 44 37 ff 00	 mov	 BYTE PTR [edi+esi-1], 0

; 293  : 		return HAS_ARGUMENT;

  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 310  : }

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN2@GetArgumen:
  0003b	53		 push	 ebx

; 294  : 	}
; 295  : 	else if (*nArgIdx + 1 < nNoCommandLineArgs)

  0003c	8b 5d 10	 mov	 ebx, DWORD PTR _nArgIdx$[ebp]
  0003f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00041	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00044	3b 45 14	 cmp	 eax, DWORD PTR _nNoCommandLineArgs$[ebp]
  00047	7d 2b		 jge	 SHORT $LN5@GetArgumen

; 296  : 	{
; 297  : 		int x = GetArgSepPosOffset (lpszCommandLineArgs[*nArgIdx + 1]);

  00049	8b 45 08	 mov	 eax, DWORD PTR _lpszCommandLineArgs$[ebp]
  0004c	8b 44 88 04	 mov	 eax, DWORD PTR [eax+ecx*4+4]
  00050	80 38 2f	 cmp	 BYTE PTR [eax], 47	; 0000002fH

; 298  : 		if (x == 0)

  00053	74 1f		 je	 SHORT $LN5@GetArgumen

; 299  : 		{
; 300  : 			/* Handles the case of space between parameter code
; 301  : 			   and value */
; 302  : 			strncpy (lpszValue, &lpszCommandLineArgs[*nArgIdx + 1][x], nValueSize);

  00055	8b 75 1c	 mov	 esi, DWORD PTR _nValueSize$[ebp]
  00058	56		 push	 esi
  00059	50		 push	 eax
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 _strncpy
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 303  : 			lpszValue[nValueSize - 1] = 0;

  00063	c6 44 37 ff 00	 mov	 BYTE PTR [edi+esi-1], 0

; 304  : 			(*nArgIdx)++;

  00068	ff 03		 inc	 DWORD PTR [ebx]

; 305  : 			return HAS_ARGUMENT;

  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	5b		 pop	 ebx
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi

; 310  : }

  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN5@GetArgumen:
  00074	5b		 pop	 ebx
  00075	5f		 pop	 edi

; 306  : 		}
; 307  : 	}
; 308  : 
; 309  : 	return HAS_NO_ARGUMENT;

  00076	33 c0		 xor	 eax, eax
  00078	5e		 pop	 esi

; 310  : }

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_GetArgumentValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\cmdline.c
;	COMDAT _GetArgumentID
_TEXT	SEGMENT
_nArgPos$GSCopy$1$ = -556				; size = 4
_lpszArgument$GSCopy$1$ = -552				; size = 4
tv365 = -548						; size = 4
_k$1$ = -548						; size = 4
tv383 = -544						; size = 4
_k$1$ = -544						; size = 4
tv367 = -540						; size = 4
_i$2$ = -540						; size = 4
tv384 = -536						; size = 4
_i$3$ = -536						; size = 4
tv394 = -532						; size = 4
tv375 = -532						; size = 4
$T1 = -528						; size = 4
_szTmp$ = -524						; size = 520
__$ArrayPad$ = -4					; size = 4
_as$ = 8						; size = 4
_lpszArgument$ = 12					; size = 4
_nArgPos$ = 16						; size = 4
_GetArgumentID PROC					; COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 02 00
	00		 sub	 esp, 556		; 0000022cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 10	 mov	 eax, DWORD PTR _nArgPos$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR _lpszArgument$[ebp]

; 187  : 	char szTmp[MAX_PATH * 2];
; 188  : 	int i;
; 189  : 
; 190  : 	i = strlen (lpszArgument);

  0001c	8b f7		 mov	 esi, edi
  0001e	89 bd d8 fd ff
	ff		 mov	 DWORD PTR _lpszArgument$GSCopy$1$[ebp], edi
  00024	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _nArgPos$GSCopy$1$[ebp], eax
  0002a	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0002d	0f 1f 00	 npad	 3
$LL57@GetArgumen:
  00030	8a 06		 mov	 al, BYTE PTR [esi]
  00032	46		 inc	 esi
  00033	84 c0		 test	 al, al
  00035	75 f9		 jne	 SHORT $LL57@GetArgumen
  00037	2b f1		 sub	 esi, ecx

; 191  : 	szTmp[i] = 0;

  00039	81 fe 08 02 00
	00		 cmp	 esi, 520		; 00000208H
  0003f	0f 83 10 04 00
	00		 jae	 $LN100@GetArgumen
  00045	88 84 35 f4 fd
	ff ff		 mov	 BYTE PTR _szTmp$[ebp+esi], al

; 192  : 	while (--i >= 0)

  0004c	83 ee 01	 sub	 esi, 1
  0004f	78 2f		 js	 SHORT $LN3@GetArgumen
  00051	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00057	2b f8		 sub	 edi, eax
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@GetArgumen:
  00060	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]

; 193  : 	{
; 194  : 		szTmp[i] = (char) tolower (lpszArgument[i]);

  00063	0f be 84 05 f4
	fd ff ff	 movsx	 eax, BYTE PTR _szTmp$[ebp+eax]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _tolower
  00071	83 c4 04	 add	 esp, 4
  00074	88 84 35 f4 fd
	ff ff		 mov	 BYTE PTR _szTmp$[ebp+esi], al
  0007b	83 ee 01	 sub	 esi, 1
  0007e	79 e0		 jns	 SHORT $LL2@GetArgumen
$LN3@GetArgumen:
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _as$[ebp]

; 195  : 	}
; 196  : 
; 197  : 	for (i = 0; i < as->arg_cnt; i++)

  00083	33 c0		 xor	 eax, eax
  00085	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _i$2$[ebp], eax
  0008b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0008e	89 85 f0 fd ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00094	85 c0		 test	 eax, eax
  00096	0f 8e 89 01 00
	00		 jle	 $LN55@GetArgumen

; 198  : 	{
; 199  : 		size_t k;
; 200  : 
; 201  : 		k = strlen (as->args[i].long_name);

  0009c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0009e	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000a3	bb 01 00 00 00	 mov	 ebx, 1
  000a8	2b c1		 sub	 eax, ecx
  000aa	89 9d ec fd ff
	ff		 mov	 DWORD PTR tv394[ebp], ebx
  000b0	89 85 e0 fd ff
	ff		 mov	 DWORD PTR tv383[ebp], eax
  000b6	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  000b9	89 95 e8 fd ff
	ff		 mov	 DWORD PTR tv384[ebp], edx
  000bf	90		 npad	 1
$LL6@GetArgumen:
  000c0	8b fa		 mov	 edi, edx
  000c2	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL58@GetArgumen:
  000c5	8a 07		 mov	 al, BYTE PTR [edi]
  000c7	47		 inc	 edi
  000c8	84 c0		 test	 al, al
  000ca	75 f9		 jne	 SHORT $LL58@GetArgumen
  000cc	2b f9		 sub	 edi, ecx

; 202  : 		if (memcmp (as->args[i].long_name, szTmp, k * sizeof (char)) == 0)

  000ce	8b ca		 mov	 ecx, edx
  000d0	8b f7		 mov	 esi, edi
  000d2	89 bd dc fd ff
	ff		 mov	 DWORD PTR _k$1$[ebp], edi
  000d8	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _szTmp$[ebp]
  000de	83 ee 04	 sub	 esi, 4
  000e1	72 11		 jb	 SHORT $LN61@GetArgumen
$LL62@GetArgumen:
  000e3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e5	3b 02		 cmp	 eax, DWORD PTR [edx]
  000e7	75 10		 jne	 SHORT $LN60@GetArgumen
  000e9	83 c1 04	 add	 ecx, 4
  000ec	83 c2 04	 add	 edx, 4
  000ef	83 ee 04	 sub	 esi, 4
  000f2	73 ef		 jae	 SHORT $LL62@GetArgumen
$LN61@GetArgumen:
  000f4	83 fe fc	 cmp	 esi, -4			; fffffffcH
  000f7	74 3d		 je	 SHORT $LN59@GetArgumen
$LN60@GetArgumen:
  000f9	8a 01		 mov	 al, BYTE PTR [ecx]
  000fb	3a 02		 cmp	 al, BYTE PTR [edx]
  000fd	0f 85 ea 00 00
	00		 jne	 $LN4@GetArgumen
  00103	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00106	74 2e		 je	 SHORT $LN59@GetArgumen
  00108	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  0010b	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  0010e	0f 85 d9 00 00
	00		 jne	 $LN4@GetArgumen
  00114	83 fe fe	 cmp	 esi, -2			; fffffffeH
  00117	74 1d		 je	 SHORT $LN59@GetArgumen
  00119	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  0011c	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  0011f	0f 85 c8 00 00
	00		 jne	 $LN4@GetArgumen
  00125	83 fe ff	 cmp	 esi, -1
  00128	74 0c		 je	 SHORT $LN59@GetArgumen
  0012a	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0012d	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00130	0f 85 b7 00 00
	00		 jne	 $LN4@GetArgumen
$LN59@GetArgumen:

; 203  : 		{
; 204  : 			int x;
; 205  : 			for (x = i + 1; x < as->arg_cnt; x++)

  00136	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  0013c	39 85 ec fd ff
	ff		 cmp	 DWORD PTR tv394[ebp], eax
  00142	0f 8d 97 00 00
	00		 jge	 $LN64@GetArgumen

; 206  : 			{
; 207  : 				size_t m;
; 208  : 
; 209  : 				m = strlen (as->args[x].long_name);

  00148	8b 55 08	 mov	 edx, DWORD PTR _as$[ebp]
  0014b	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR tv384[ebp]
  00151	03 85 e0 fd ff
	ff		 add	 eax, DWORD PTR tv383[ebp]
  00157	8b 3a		 mov	 edi, DWORD PTR [edx]
  00159	83 c7 04	 add	 edi, 4
  0015c	03 f8		 add	 edi, eax
  0015e	66 90		 npad	 2
$LL9@GetArgumen:
  00160	8b cf		 mov	 ecx, edi
  00162	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL63@GetArgumen:
  00165	8a 01		 mov	 al, BYTE PTR [ecx]
  00167	41		 inc	 ecx
  00168	84 c0		 test	 al, al
  0016a	75 f9		 jne	 SHORT $LL63@GetArgumen
  0016c	2b ca		 sub	 ecx, edx

; 210  : 				if (memcmp (as->args[x].long_name, szTmp, m * sizeof (char)) == 0)

  0016e	8d b5 f4 fd ff
	ff		 lea	 esi, DWORD PTR _szTmp$[ebp]
  00174	8b d7		 mov	 edx, edi
  00176	83 e9 04	 sub	 ecx, 4
  00179	72 16		 jb	 SHORT $LN66@GetArgumen
  0017b	0f 1f 44 00 00	 npad	 5
$LL67@GetArgumen:
  00180	8b 02		 mov	 eax, DWORD PTR [edx]
  00182	3b 06		 cmp	 eax, DWORD PTR [esi]
  00184	75 10		 jne	 SHORT $LN65@GetArgumen
  00186	83 c2 04	 add	 edx, 4
  00189	83 c6 04	 add	 esi, 4
  0018c	83 e9 04	 sub	 ecx, 4
  0018f	73 ef		 jae	 SHORT $LL67@GetArgumen
$LN66@GetArgumen:
  00191	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00194	74 3d		 je	 SHORT $LN92@GetArgumen
$LN65@GetArgumen:
  00196	8a 02		 mov	 al, BYTE PTR [edx]
  00198	3a 06		 cmp	 al, BYTE PTR [esi]
  0019a	75 27		 jne	 SHORT $LN68@GetArgumen
  0019c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0019f	74 32		 je	 SHORT $LN92@GetArgumen
  001a1	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  001a4	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  001a7	75 1a		 jne	 SHORT $LN68@GetArgumen
  001a9	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  001ac	74 25		 je	 SHORT $LN92@GetArgumen
  001ae	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  001b1	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  001b4	75 0d		 jne	 SHORT $LN68@GetArgumen
  001b6	83 f9 ff	 cmp	 ecx, -1
  001b9	74 18		 je	 SHORT $LN92@GetArgumen
  001bb	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  001be	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  001c1	74 10		 je	 SHORT $LN92@GetArgumen
$LN68@GetArgumen:

; 203  : 		{
; 204  : 			int x;
; 205  : 			for (x = i + 1; x < as->arg_cnt; x++)

  001c3	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  001c9	43		 inc	 ebx
  001ca	83 c7 30	 add	 edi, 48			; 00000030H
  001cd	3b d8		 cmp	 ebx, eax
  001cf	7c 8f		 jl	 SHORT $LL9@GetArgumen
  001d1	eb 06		 jmp	 SHORT $LN82@GetArgumen
$LN92@GetArgumen:
  001d3	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
$LN82@GetArgumen:
  001d9	8b bd dc fd ff
	ff		 mov	 edi, DWORD PTR _k$1$[ebp]
$LN64@GetArgumen:

; 211  : 				{
; 212  : 					break;
; 213  : 				}
; 214  : 			}
; 215  : 
; 216  : 			if (x == as->arg_cnt)

  001df	3b d8		 cmp	 ebx, eax
  001e1	0f 84 fb 01 00
	00		 je	 $LN37@GetArgumen
  001e7	8b 9d ec fd ff
	ff		 mov	 ebx, DWORD PTR tv394[ebp]
$LN4@GetArgumen:

; 195  : 	}
; 196  : 
; 197  : 	for (i = 0; i < as->arg_cnt; i++)

  001ed	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _i$2$[ebp]
  001f3	43		 inc	 ebx
  001f4	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR tv384[ebp]
  001fa	40		 inc	 eax
  001fb	83 c2 30	 add	 edx, 48			; 00000030H
  001fe	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _i$2$[ebp], eax
  00204	89 95 e8 fd ff
	ff		 mov	 DWORD PTR tv384[ebp], edx
  0020a	89 9d ec fd ff
	ff		 mov	 DWORD PTR tv394[ebp], ebx
  00210	3b 85 f0 fd ff
	ff		 cmp	 eax, DWORD PTR $T1[ebp]
  00216	0f 8c a4 fe ff
	ff		 jl	 $LL6@GetArgumen
  0021c	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00222	8b 4d 08	 mov	 ecx, DWORD PTR _as$[ebp]
$LN55@GetArgumen:

; 223  : 			}
; 224  : 		}
; 225  : 	}
; 226  : 
; 227  : 	for (i = 0; i < as->arg_cnt; i++)

  00225	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$3$[ebp], 0
  0022f	85 c0		 test	 eax, eax
  00231	0f 8e 97 01 00
	00		 jle	 $LN56@GetArgumen

; 228  : 	{
; 229  : 		size_t k;
; 230  : 
; 231  : 		if (as->args[i].short_name[0] == 0)

  00237	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00239	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0023e	8b 55 08	 mov	 edx, DWORD PTR _as$[ebp]
  00241	2b c1		 sub	 eax, ecx
  00243	89 85 dc fd ff
	ff		 mov	 DWORD PTR tv365[ebp], eax
  00249	b8 01 00 00 00	 mov	 eax, 1
  0024e	c7 85 ec fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv375[ebp], 1
  00258	8d 59 24	 lea	 ebx, DWORD PTR [ecx+36]
  0025b	33 c9		 xor	 ecx, ecx
  0025d	89 9d e4 fd ff
	ff		 mov	 DWORD PTR tv367[ebp], ebx
$LL12@GetArgumen:
  00263	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00266	0f 84 42 01 00
	00		 je	 $LN10@GetArgumen

; 232  : 			continue;
; 233  : 
; 234  : 		k = strlen (as->args[i].short_name);

  0026c	8b fb		 mov	 edi, ebx
  0026e	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL70@GetArgumen:
  00271	8a 07		 mov	 al, BYTE PTR [edi]
  00273	47		 inc	 edi
  00274	84 c0		 test	 al, al
  00276	75 f9		 jne	 SHORT $LL70@GetArgumen
  00278	2b f9		 sub	 edi, ecx

; 235  : 		if (memcmp (as->args[i].short_name, szTmp, k * sizeof (char)) == 0)

  0027a	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _szTmp$[ebp]
  00280	8b f7		 mov	 esi, edi
  00282	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _k$1$[ebp], edi
  00288	8b cb		 mov	 ecx, ebx
  0028a	83 ee 04	 sub	 esi, 4
  0028d	72 12		 jb	 SHORT $LN73@GetArgumen
  0028f	90		 npad	 1
$LL74@GetArgumen:
  00290	8b 01		 mov	 eax, DWORD PTR [ecx]
  00292	3b 02		 cmp	 eax, DWORD PTR [edx]
  00294	75 10		 jne	 SHORT $LN72@GetArgumen
  00296	83 c1 04	 add	 ecx, 4
  00299	83 c2 04	 add	 edx, 4
  0029c	83 ee 04	 sub	 esi, 4
  0029f	73 ef		 jae	 SHORT $LL74@GetArgumen
$LN73@GetArgumen:
  002a1	83 fe fc	 cmp	 esi, -4			; fffffffcH
  002a4	74 3d		 je	 SHORT $LN71@GetArgumen
$LN72@GetArgumen:
  002a6	8a 01		 mov	 al, BYTE PTR [ecx]
  002a8	3a 02		 cmp	 al, BYTE PTR [edx]
  002aa	0f 85 ef 00 00
	00		 jne	 $LN87@GetArgumen
  002b0	83 fe fd	 cmp	 esi, -3			; fffffffdH
  002b3	74 2e		 je	 SHORT $LN71@GetArgumen
  002b5	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  002b8	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  002bb	0f 85 de 00 00
	00		 jne	 $LN87@GetArgumen
  002c1	83 fe fe	 cmp	 esi, -2			; fffffffeH
  002c4	74 1d		 je	 SHORT $LN71@GetArgumen
  002c6	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  002c9	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  002cc	0f 85 cd 00 00
	00		 jne	 $LN87@GetArgumen
  002d2	83 fe ff	 cmp	 esi, -1
  002d5	74 0c		 je	 SHORT $LN71@GetArgumen
  002d7	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  002da	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  002dd	0f 85 bc 00 00
	00		 jne	 $LN87@GetArgumen
$LN71@GetArgumen:

; 236  : 		{
; 237  : 			int x;
; 238  : 			for (x = i + 1; x < as->arg_cnt; x++)

  002e3	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR tv375[ebp]
  002e9	8b d8		 mov	 ebx, eax
  002eb	3b 85 f0 fd ff
	ff		 cmp	 eax, DWORD PTR $T1[ebp]
  002f1	0f 8d 96 00 00
	00		 jge	 $LN76@GetArgumen

; 239  : 			{
; 240  : 				size_t m;
; 241  : 
; 242  : 				if (as->args[x].short_name[0] == 0)

  002f7	8b 55 08	 mov	 edx, DWORD PTR _as$[ebp]
  002fa	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR tv367[ebp]
  00300	83 c0 24	 add	 eax, 36			; 00000024H
  00303	03 85 dc fd ff
	ff		 add	 eax, DWORD PTR tv365[ebp]
  00309	8b 3a		 mov	 edi, DWORD PTR [edx]
  0030b	03 f8		 add	 edi, eax
  0030d	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
$LL15@GetArgumen:
  00313	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00316	74 67		 je	 SHORT $LN13@GetArgumen

; 243  : 					continue;
; 244  : 
; 245  : 				m = strlen (as->args[x].short_name);

  00318	8b c7		 mov	 eax, edi
  0031a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0031d	0f 1f 00	 npad	 3
$LL75@GetArgumen:
  00320	8a 08		 mov	 cl, BYTE PTR [eax]
  00322	40		 inc	 eax
  00323	84 c9		 test	 cl, cl
  00325	75 f9		 jne	 SHORT $LL75@GetArgumen
  00327	2b c2		 sub	 eax, edx

; 246  : 				if (memcmp (as->args[x].short_name, szTmp, m * sizeof (char)) == 0)

  00329	8d b5 f4 fd ff
	ff		 lea	 esi, DWORD PTR _szTmp$[ebp]
  0032f	8b d7		 mov	 edx, edi
  00331	83 e8 04	 sub	 eax, 4
  00334	72 11		 jb	 SHORT $LN78@GetArgumen
$LL79@GetArgumen:
  00336	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00338	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  0033a	75 10		 jne	 SHORT $LN77@GetArgumen
  0033c	83 c2 04	 add	 edx, 4
  0033f	83 c6 04	 add	 esi, 4
  00342	83 e8 04	 sub	 eax, 4
  00345	73 ef		 jae	 SHORT $LL79@GetArgumen
$LN78@GetArgumen:
  00347	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  0034a	74 3b		 je	 SHORT $LN83@GetArgumen
$LN77@GetArgumen:
  0034c	8a 0a		 mov	 cl, BYTE PTR [edx]
  0034e	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00350	75 27		 jne	 SHORT $LN95@GetArgumen
  00352	83 f8 fd	 cmp	 eax, -3			; fffffffdH
  00355	74 30		 je	 SHORT $LN83@GetArgumen
  00357	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  0035a	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0035d	75 1a		 jne	 SHORT $LN95@GetArgumen
  0035f	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  00362	74 23		 je	 SHORT $LN83@GetArgumen
  00364	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  00367	3a 4e 02	 cmp	 cl, BYTE PTR [esi+2]
  0036a	75 0d		 jne	 SHORT $LN95@GetArgumen
  0036c	83 f8 ff	 cmp	 eax, -1
  0036f	74 16		 je	 SHORT $LN83@GetArgumen
  00371	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  00374	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00377	74 0e		 je	 SHORT $LN83@GetArgumen
$LN95@GetArgumen:
  00379	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
$LN13@GetArgumen:

; 236  : 		{
; 237  : 			int x;
; 238  : 			for (x = i + 1; x < as->arg_cnt; x++)

  0037f	43		 inc	 ebx
  00380	83 c7 30	 add	 edi, 48			; 00000030H
  00383	3b d8		 cmp	 ebx, eax
  00385	7c 8c		 jl	 SHORT $LL15@GetArgumen
$LN83@GetArgumen:
  00387	8b bd e0 fd ff
	ff		 mov	 edi, DWORD PTR _k$1$[ebp]
$LN76@GetArgumen:

; 247  : 				{
; 248  : 					break;
; 249  : 				}
; 250  : 			}
; 251  : 
; 252  : 			if (x == as->arg_cnt)

  0038d	3b 9d f0 fd ff
	ff		 cmp	 ebx, DWORD PTR $T1[ebp]
  00393	0f 84 93 00 00
	00		 je	 $LN39@GetArgumen
  00399	8b 9d e4 fd ff
	ff		 mov	 ebx, DWORD PTR tv367[ebp]
$LN87@GetArgumen:
  0039f	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR tv375[ebp]
  003a5	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _i$3$[ebp]
  003ab	8b 55 08	 mov	 edx, DWORD PTR _as$[ebp]
$LN10@GetArgumen:

; 223  : 			}
; 224  : 		}
; 225  : 	}
; 226  : 
; 227  : 	for (i = 0; i < as->arg_cnt; i++)

  003ae	41		 inc	 ecx
  003af	83 c3 30	 add	 ebx, 48			; 00000030H
  003b2	40		 inc	 eax
  003b3	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _i$3$[ebp], ecx
  003b9	89 9d e4 fd ff
	ff		 mov	 DWORD PTR tv367[ebp], ebx
  003bf	89 85 ec fd ff
	ff		 mov	 DWORD PTR tv375[ebp], eax
  003c5	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  003c8	0f 8c 95 fe ff
	ff		 jl	 $LL12@GetArgumen
$LN56@GetArgumen:
  003ce	5f		 pop	 edi
  003cf	5e		 pop	 esi

; 259  : 			}
; 260  : 		}
; 261  : 	}
; 262  : 
; 263  : 	return -1;

  003d0	83 c8 ff	 or	 eax, -1
  003d3	5b		 pop	 ebx

; 264  : 
; 265  : }

  003d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d7	33 cd		 xor	 ecx, ebp
  003d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003de	8b e5		 mov	 esp, ebp
  003e0	5d		 pop	 ebp
  003e1	c3		 ret	 0
$LN37@GetArgumen:

; 217  : 			{
; 218  : 				if (strlen (lpszArgument) != k)

  003e2	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _lpszArgument$GSCopy$1$[ebp]
  003e8	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  003eb	0f 1f 44 00 00	 npad	 5
$LL69@GetArgumen:
  003f0	8a 02		 mov	 al, BYTE PTR [edx]
  003f2	42		 inc	 edx
  003f3	84 c0		 test	 al, al
  003f5	75 f9		 jne	 SHORT $LL69@GetArgumen
  003f7	2b d1		 sub	 edx, ecx
  003f9	33 c0		 xor	 eax, eax
  003fb	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _nArgPos$GSCopy$1$[ebp]
  00401	3b d7		 cmp	 edx, edi
  00403	0f 45 c7	 cmovne	 eax, edi
  00406	89 01		 mov	 DWORD PTR [ecx], eax

; 219  : 					*nArgPos = k;
; 220  : 				else
; 221  : 					*nArgPos = 0;
; 222  : 				return as->args[i].Id;

  00408	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _i$2$[ebp]
$LN99@GetArgumen:

; 255  : 					*nArgPos = k;
; 256  : 				else
; 257  : 					*nArgPos = 0;
; 258  : 				return as->args[i].Id;

  0040e	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00411	8b 45 08	 mov	 eax, DWORD PTR _as$[ebp]
  00414	03 c9		 add	 ecx, ecx
  00416	5f		 pop	 edi
  00417	5e		 pop	 esi
  00418	8b 00		 mov	 eax, DWORD PTR [eax]
  0041a	5b		 pop	 ebx
  0041b	8b 04 c8	 mov	 eax, DWORD PTR [eax+ecx*8]

; 264  : 
; 265  : }

  0041e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00421	33 cd		 xor	 ecx, ebp
  00423	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00428	8b e5		 mov	 esp, ebp
  0042a	5d		 pop	 ebp
  0042b	c3		 ret	 0
$LN39@GetArgumen:

; 253  : 			{
; 254  : 				if (strlen (lpszArgument) != k)

  0042c	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _lpszArgument$GSCopy$1$[ebp]
  00432	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL81@GetArgumen:
  00435	8a 02		 mov	 al, BYTE PTR [edx]
  00437	42		 inc	 edx
  00438	84 c0		 test	 al, al
  0043a	75 f9		 jne	 SHORT $LL81@GetArgumen
  0043c	2b d1		 sub	 edx, ecx
  0043e	33 c0		 xor	 eax, eax
  00440	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _nArgPos$GSCopy$1$[ebp]
  00446	3b d7		 cmp	 edx, edi
  00448	0f 45 c7	 cmovne	 eax, edi
  0044b	89 01		 mov	 DWORD PTR [ecx], eax

; 255  : 					*nArgPos = k;
; 256  : 				else
; 257  : 					*nArgPos = 0;
; 258  : 				return as->args[i].Id;

  0044d	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _i$3$[ebp]
  00453	eb b9		 jmp	 SHORT $LN99@GetArgumen
$LN100@GetArgumen:

; 191  : 	szTmp[i] = 0;

  00455	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN101@GetArgumen:
$LN97@GetArgumen:
  0045a	cc		 int	 3
_GetArgumentID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\cmdline.c
;	COMDAT _GetArgSepPosOffset
_TEXT	SEGMENT
_lpszArgument$ = 8					; size = 4
_GetArgSepPosOffset PROC				; COMDAT

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 168  : 	if (lpszArgument[0] == '/')

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpszArgument$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	80 39 2f	 cmp	 BYTE PTR [ecx], 47	; 0000002fH
  0000b	0f 94 c0	 sete	 al

; 169  : 		return 1;
; 170  : 
; 171  : 	return 0;
; 172  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_GetArgSepPosOffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\cmdline.c
;	COMDAT _Win32CommandLine
_TEXT	SEGMENT
_arguments$1$ = -16					; size = 4
tv207 = -12						; size = 4
_i$1$ = -8						; size = 4
_argumentCount$ = -4					; size = 4
_lpszCommandLine$ = 8					; size = 4
_lpszArgs$ = 12						; size = 4
_Win32CommandLine PROC					; COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 109  : 	int argumentCount;
; 110  : 	int i;
; 111  : 
; 112  : 	LPWSTR *arguments = CommandLineToArgvW (GetCommandLineW(), &argumentCount);

  00007	8d 45 fc	 lea	 eax, DWORD PTR _argumentCount$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCommandLineW@0
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CommandLineToArgvW@8
  00018	8b f0		 mov	 esi, eax
  0001a	89 75 f0	 mov	 DWORD PTR _arguments$1$[ebp], esi

; 113  : 	if (!arguments)

  0001d	85 f6		 test	 esi, esi
  0001f	75 10		 jne	 SHORT $LN5@Win32Comma

; 114  : 	{
; 115  : 		handleWin32Error (NULL);

  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _handleWin32Error
  00027	83 c4 04	 add	 esp, 4

; 116  : 		return 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	5e		 pop	 esi

; 155  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN5@Win32Comma:

; 117  : 	}
; 118  : 
; 119  : 	--argumentCount;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _argumentCount$[ebp]
  00034	48		 dec	 eax
  00035	89 45 fc	 mov	 DWORD PTR _argumentCount$[ebp], eax

; 120  : 	if (argumentCount < 1)

  00038	83 f8 01	 cmp	 eax, 1
  0003b	7d 0e		 jge	 SHORT $LN6@Win32Comma

; 121  : 	{
; 122  : 		LocalFree (arguments);

  0003d	56		 push	 esi
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 123  : 		return 0;

  00044	33 c0		 xor	 eax, eax
  00046	5e		 pop	 esi

; 155  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN6@Win32Comma:

; 124  : 	}
; 125  : 
; 126  : 	*lpszArgs = malloc (sizeof (char *) * argumentCount);

  0004b	c1 e0 02	 shl	 eax, 2
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _malloc
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _lpszArgs$[ebp]
  00057	83 c4 04	 add	 esp, 4
  0005a	89 01		 mov	 DWORD PTR [ecx], eax

; 127  : 	if (!*lpszArgs)

  0005c	85 c0		 test	 eax, eax
  0005e	75 0d		 jne	 SHORT $LN7@Win32Comma

; 128  : 		AbortProcess ("OUTOFMEMORY");

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@
  00065	e8 00 00 00 00	 call	 _AbortProcess
  0006a	83 c4 04	 add	 esp, 4
$LN7@Win32Comma:

; 129  : 
; 130  : 	for (i = 0; i < argumentCount; ++i)

  0006d	83 7d fc 00	 cmp	 DWORD PTR _argumentCount$[ebp], 0
  00071	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  00078	0f 8e 9c 00 00
	00		 jle	 $LN3@Win32Comma
  0007e	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00083	53		 push	 ebx
  00084	2b c6		 sub	 eax, esi
  00086	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00089	57		 push	 edi
  0008a	89 45 f4	 mov	 DWORD PTR tv207[ebp], eax
  0008d	0f 1f 00	 npad	 3
$LL4@Win32Comma:

; 131  : 	{
; 132  : 		size_t argLen = wcslen (arguments[i + 1]);

  00090	8b 33		 mov	 esi, DWORD PTR [ebx]
  00092	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
$LL17@Win32Comma:
  00095	66 8b 06	 mov	 ax, WORD PTR [esi]
  00098	83 c6 02	 add	 esi, 2
  0009b	66 85 c0	 test	 ax, ax
  0009e	75 f5		 jne	 SHORT $LL17@Win32Comma
  000a0	2b f1		 sub	 esi, ecx
  000a2	d1 fe		 sar	 esi, 1

; 133  : 
; 134  : 		char *arg = malloc (argLen + 1);

  000a4	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _malloc
  000ad	8b f8		 mov	 edi, eax
  000af	83 c4 04	 add	 esp, 4

; 135  : 		if (!arg)

  000b2	85 ff		 test	 edi, edi
  000b4	75 0d		 jne	 SHORT $LN8@Win32Comma

; 136  : 			AbortProcess ("OUTOFMEMORY");

  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@
  000bb	e8 00 00 00 00	 call	 _AbortProcess
  000c0	83 c4 04	 add	 esp, 4
$LN8@Win32Comma:

; 137  : 
; 138  : 		if (argLen > 0)

  000c3	85 f6		 test	 esi, esi
  000c5	74 2b		 je	 SHORT $LN9@Win32Comma

; 139  : 		{
; 140  : 			int len = WideCharToMultiByte (CP_ACP, 0, arguments[i + 1], -1, arg, argLen + 1, NULL, NULL);

  000c7	6a 00		 push	 0
  000c9	6a 00		 push	 0
  000cb	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000ce	50		 push	 eax
  000cf	57		 push	 edi
  000d0	6a ff		 push	 -1
  000d2	ff 33		 push	 DWORD PTR [ebx]
  000d4	6a 00		 push	 0
  000d6	6a 00		 push	 0
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 141  : 			if (len == 0)

  000de	85 c0		 test	 eax, eax
  000e0	75 13		 jne	 SHORT $LN10@Win32Comma

; 142  : 			{
; 143  : 				handleWin32Error (NULL);

  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 _handleWin32Error
  000e8	83 c4 04	 add	 esp, 4

; 144  : 				AbortProcessSilent();

  000eb	e8 00 00 00 00	 call	 _AbortProcessSilent

; 145  : 			}
; 146  : 		}

  000f0	eb 03		 jmp	 SHORT $LN10@Win32Comma
$LN9@Win32Comma:

; 147  : 		else
; 148  : 			arg[0] = 0;

  000f2	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN10@Win32Comma:

; 149  : 
; 150  : 		(*lpszArgs)[i] = arg;

  000f5	8b 45 0c	 mov	 eax, DWORD PTR _lpszArgs$[ebp]
  000f8	8b 4d f4	 mov	 ecx, DWORD PTR tv207[ebp]
  000fb	03 cb		 add	 ecx, ebx
  000fd	83 c3 04	 add	 ebx, 4
  00100	8b 00		 mov	 eax, DWORD PTR [eax]
  00102	89 3c 01	 mov	 DWORD PTR [ecx+eax], edi
  00105	8b 45 f8	 mov	 eax, DWORD PTR _i$1$[ebp]
  00108	40		 inc	 eax
  00109	89 45 f8	 mov	 DWORD PTR _i$1$[ebp], eax
  0010c	3b 45 fc	 cmp	 eax, DWORD PTR _argumentCount$[ebp]
  0010f	0f 8c 7b ff ff
	ff		 jl	 $LL4@Win32Comma
  00115	8b 75 f0	 mov	 esi, DWORD PTR _arguments$1$[ebp]
  00118	5f		 pop	 edi
  00119	5b		 pop	 ebx
$LN3@Win32Comma:

; 151  : 	}
; 152  : 
; 153  : 	LocalFree (arguments);

  0011a	56		 push	 esi
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 154  : 	return argumentCount;

  00121	8b 45 fc	 mov	 eax, DWORD PTR _argumentCount$[ebp]
  00124	5e		 pop	 esi

; 155  : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
_Win32CommandLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\cmdline.c
;	COMDAT _CommandHelpDlgProc@16
_TEXT	SEGMENT
_hwndDlg$GSCopy$1$ = -540				; size = 4
_tmp$1$ = -536						; size = 4
_lParam$GSCopy$1$ = -532				; size = 4
tv192 = -528						; size = 4
_tmp2$1 = -524						; size = 520
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_msg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_CommandHelpDlgProc@16 PROC				; COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 53   : 	if (lParam);		/* remove warning */
; 54   : 	if (wParam);		/* remove warning */
; 55   : 
; 56   : 	switch (msg)

  00013	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  0001a	89 9d e4 fd ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], ebx
  00020	56		 push	 esi
  00021	8b 75 14	 mov	 esi, DWORD PTR _lParam$[ebp]
  00024	89 b5 ec fd ff
	ff		 mov	 DWORD PTR _lParam$GSCopy$1$[ebp], esi
  0002a	83 e8 10	 sub	 eax, 16			; 00000010H
  0002d	0f 84 00 01 00
	00		 je	 $LN12@CommandHel
  00033	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  00038	74 20		 je	 SHORT $LN9@CommandHel
  0003a	83 e8 01	 sub	 eax, 1
  0003d	74 14		 je	 SHORT $LN11@CommandHel

; 90   : 		return 1;
; 91   : 	}
; 92   : 
; 93   : 	return 0;

  0003f	5e		 pop	 esi
  00040	33 c0		 xor	 eax, eax
  00042	5b		 pop	 ebx

; 94   : }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	33 cd		 xor	 ecx, ebp
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 10 00	 ret	 16			; 00000010H
$LN11@CommandHel:

; 83   : 		}
; 84   : 
; 85   : 	case WM_COMMAND:
; 86   : 		EndDialog (hwndDlg, IDOK);

  00053	6a 01		 push	 1

; 87   : 		return 1;

  00055	e9 db 00 00 00	 jmp	 $LN20@CommandHel
$LN9@CommandHel:
  0005a	57		 push	 edi

; 57   : 	{
; 58   : 	case WM_INITDIALOG:
; 59   : 		{
; 60   : 		char * tmp = err_malloc(8192);

  0005b	68 00 20 00 00	 push	 8192			; 00002000H
  00060	e8 00 00 00 00	 call	 _err_malloc
  00065	8b f8		 mov	 edi, eax

; 61   : 		char tmp2[MAX_PATH * 2];
; 62   : 		argumentspec *as;
; 63   : 		int i;
; 64   : 
; 65   : 		LocalizeDialog (hwndDlg, "IDD_COMMANDHELP_DLG");

  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GKKPACCB@IDD_COMMANDHELP_DLG?$AA@
  0006c	53		 push	 ebx
  0006d	89 bd e8 fd ff
	ff		 mov	 DWORD PTR _tmp$1$[ebp], edi
  00073	e8 00 00 00 00	 call	 _LocalizeDialog

; 66   : 
; 67   : 		as = (argumentspec*) lParam;
; 68   : 
; 69   : 		*tmp = 0;

  00078	c6 07 00	 mov	 BYTE PTR [edi], 0

; 70   : 
; 71   : 		strcpy (tmp, "Command line options:\n\n");
; 72   : 		for (i = 0; i < as->arg_cnt; i ++)

  0007b	33 db		 xor	 ebx, ebx
  0007d	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
  00087	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0008a	f3 0f 7e 05 10
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@+16
  00092	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
  00097	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0009a	0f 8e 77 00 00
	00		 jle	 $LN5@CommandHel

; 57   : 	{
; 58   : 	case WM_INITDIALOG:
; 59   : 		{
; 60   : 		char * tmp = err_malloc(8192);

  000a0	33 c9		 xor	 ecx, ecx
  000a2	89 8d f0 fd ff
	ff		 mov	 DWORD PTR tv192[ebp], ecx
$LL6@CommandHel:

; 73   : 		{
; 74   : 			if (!as->args[i].Internal)

  000a8	03 0e		 add	 ecx, DWORD PTR [esi]
  000aa	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  000ae	75 52		 jne	 SHORT $LN4@CommandHel

; 75   : 			{
; 76   : 				sprintf(tmp2, "%s\t%s\n", as->args[i].short_name, as->args[i].long_name);

  000b0	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  000b3	50		 push	 eax
  000b4	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  000b7	50		 push	 eax
  000b8	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _tmp2$1[ebp]
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_06EEAEEKCL@?$CFs?7?$CFs?6?$AA@
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _sprintf

; 77   : 				strcat(tmp,tmp2);

  000c9	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _tmp2$1[ebp]
  000cf	83 c4 10	 add	 esp, 16			; 00000010H
  000d2	8b f0		 mov	 esi, eax
$LL18@CommandHel:
  000d4	8a 08		 mov	 cl, BYTE PTR [eax]
  000d6	40		 inc	 eax
  000d7	84 c9		 test	 cl, cl
  000d9	75 f9		 jne	 SHORT $LL18@CommandHel
  000db	2b c6		 sub	 eax, esi
  000dd	4f		 dec	 edi
  000de	66 90		 npad	 2
$LL19@CommandHel:
  000e0	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000e3	47		 inc	 edi
  000e4	84 c9		 test	 cl, cl
  000e6	75 f8		 jne	 SHORT $LL19@CommandHel
  000e8	8b c8		 mov	 ecx, eax
  000ea	c1 e9 02	 shr	 ecx, 2
  000ed	f3 a5		 rep movsd
  000ef	8b c8		 mov	 ecx, eax
  000f1	83 e1 03	 and	 ecx, 3
  000f4	f3 a4		 rep movsb
  000f6	8b b5 ec fd ff
	ff		 mov	 esi, DWORD PTR _lParam$GSCopy$1$[ebp]
  000fc	8b bd e8 fd ff
	ff		 mov	 edi, DWORD PTR _tmp$1$[ebp]
$LN4@CommandHel:

; 70   : 
; 71   : 		strcpy (tmp, "Command line options:\n\n");
; 72   : 		for (i = 0; i < as->arg_cnt; i ++)

  00102	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR tv192[ebp]
  00108	43		 inc	 ebx
  00109	83 c1 30	 add	 ecx, 48			; 00000030H
  0010c	89 8d f0 fd ff
	ff		 mov	 DWORD PTR tv192[ebp], ecx
  00112	3b 5e 04	 cmp	 ebx, DWORD PTR [esi+4]
  00115	7c 91		 jl	 SHORT $LL6@CommandHel
$LN5@CommandHel:

; 78   : 			}
; 79   : 		}
; 80   : 
; 81   : 		SetWindowText (GetDlgItem (hwndDlg, IDC_COMMANDHELP_TEXT), (char*) tmp);

  00117	57		 push	 edi
  00118	68 bd 13 00 00	 push	 5053			; 000013bdH
  0011d	ff b5 e4 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00129	50		 push	 eax
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
  00130	5f		 pop	 edi

; 82   : 		return 1;

  00131	eb 09		 jmp	 SHORT $LN21@CommandHel
$LN12@CommandHel:

; 88   : 	case WM_CLOSE:
; 89   : 		EndDialog (hwndDlg, 0);

  00133	6a 00		 push	 0
$LN20@CommandHel:
  00135	53		 push	 ebx
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8
$LN21@CommandHel:

; 94   : }

  0013c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	5e		 pop	 esi
  00145	33 cd		 xor	 ecx, ebp
  00147	5b		 pop	 ebx
  00148	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 10 00	 ret	 16			; 00000010H
_CommandHelpDlgProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
