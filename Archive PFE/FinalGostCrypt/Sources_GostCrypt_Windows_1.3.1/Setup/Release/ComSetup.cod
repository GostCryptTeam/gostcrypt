; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Desktop\Sources_GostCrypt_Windows_1.3.1_COMMENTED\Sources_GostCrypt_Windows_1.3.1é\Sources_GostCrypt_Windows_1.3.1\Setup\ComSetup.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@PGMFNIFA@atlTraceException?$AA@	; `string'
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	??_C@_0N@BNNILHBE@atlTraceTime?$AA@		; `string'
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	??_C@_0O@MEOJAOKK@atlTraceCache?$AA@		; `string'
PUBLIC	??_C@_0BA@IDBKCKK@atlTraceStencil?$AA@		; `string'
PUBLIC	??_C@_0P@MBNHGHMI@atlTraceString?$AA@		; `string'
PUBLIC	??_C@_0M@IOBBMAHG@atlTraceMap?$AA@		; `string'
PUBLIC	??_C@_0N@FEAAACHD@atlTraceUtil?$AA@		; `string'
PUBLIC	_LIBID_ATLLib
PUBLIC	??_C@_0BB@DNJDADMG@atlTraceSecurity?$AA@	; `string'
PUBLIC	??_C@_0N@KLPNCFEE@atlTraceSync?$AA@		; `string'
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	??_C@_0O@KHOBHOBJ@atlTraceISAPI?$AA@		; `string'
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	??_C@_0BA@MKMIKKJB@atlTraceGeneral?$AA@		; `string'
PUBLIC	_IID_IInternalConnection
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	??_C@_0M@DGPFJEBB@atlTraceCOM?$AA@		; `string'
PUBLIC	??_C@_0L@LHELAKBP@atlTraceQI?$AA@		; `string'
PUBLIC	??_C@_0BC@MALHFBAO@atlTraceRegistrar?$AA@	; `string'
PUBLIC	_CLSID_Registrar
PUBLIC	??_C@_0BB@ILPPDKFL@atlTraceRefcount?$AA@	; `string'
PUBLIC	_IID_IRegistrar
PUBLIC	??_C@_0BC@DGHHNKDC@atlTraceWindowing?$AA@	; `string'
PUBLIC	?chDirSep@ATL@@3DB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3DB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3DB				; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3DB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3DB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QBDB				; ATL::szStringVal
PUBLIC	??_C@_01CPLAODJH@S?$AA@				; `string'
PUBLIC	?multiszStringVal@ATL@@3QBDB			; ATL::multiszStringVal
PUBLIC	??_C@_0BB@GHKJKKIE@atlTraceControls?$AA@	; `string'
PUBLIC	??_C@_01PLPBNMEI@M?$AA@				; `string'
PUBLIC	?szDwordVal@ATL@@3QBDB				; ATL::szDwordVal
PUBLIC	??_C@_01CKDDGHAB@D?$AA@				; `string'
PUBLIC	?szBinaryVal@ATL@@3QBDB				; ATL::szBinaryVal
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	?szValToken@ATL@@3QBDB				; ATL::szValToken
PUBLIC	??_C@_03LAIAPFCB@Val?$AA@			; `string'
PUBLIC	?szForceRemove@ATL@@3QBDB			; ATL::szForceRemove
PUBLIC	??_C@_0M@DBGDLGLL@ForceRemove?$AA@		; `string'
PUBLIC	?szNoRemove@ATL@@3QBDB				; ATL::szNoRemove
PUBLIC	??_C@_08KAAPDIAN@NoRemove?$AA@			; `string'
PUBLIC	?szDelete@ATL@@3QBDB				; ATL::szDelete
PUBLIC	??_C@_06JBKGCNBB@Delete?$AA@			; `string'
PUBLIC	??_C@_0BA@DKOAAGGM@atlTraceHosting?$AA@		; `string'
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	??_C@_0BB@BEBMGMDO@atlTraceDBClient?$AA@	; `string'
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	??_C@_0BD@KOADKDIA@atlTraceDBProvider?$AA@	; `string'
PUBLIC	??_C@_0P@LNEGBOLO@atlTraceSnapin?$AA@		; `string'
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	??_C@_0BA@MCBFIDIC@atlTraceNotImpl?$AA@		; `string'
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	??_C@_0BD@PJPCCAKP@atlTraceAllocation?$AA@	; `string'
EXTRN	___ImageBase:BYTE
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ??_C@_0BD@PJPCCAKP@atlTraceAllocation?$AA@
CONST	SEGMENT
??_C@_0BD@PJPCCAKP@atlTraceAllocation?$AA@ DB 'atlTraceAllocation', 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ??_C@_0BA@MCBFIDIC@atlTraceNotImpl?$AA@
CONST	SEGMENT
??_C@_0BA@MCBFIDIC@atlTraceNotImpl?$AA@ DB 'atlTraceNotImpl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LNEGBOLO@atlTraceSnapin?$AA@
CONST	SEGMENT
??_C@_0P@LNEGBOLO@atlTraceSnapin?$AA@ DB 'atlTraceSnapin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KOADKDIA@atlTraceDBProvider?$AA@
CONST	SEGMENT
??_C@_0BD@KOADKDIA@atlTraceDBProvider?$AA@ DB 'atlTraceDBProvider', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BEBMGMDO@atlTraceDBClient?$AA@
CONST	SEGMENT
??_C@_0BB@BEBMGMDO@atlTraceDBClient?$AA@ DB 'atlTraceDBClient', 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ??_C@_0BA@DKOAAGGM@atlTraceHosting?$AA@
CONST	SEGMENT
??_C@_0BA@DKOAAGGM@atlTraceHosting?$AA@ DB 'atlTraceHosting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JBKGCNBB@Delete?$AA@
CONST	SEGMENT
??_C@_06JBKGCNBB@Delete?$AA@ DB 'Delete', 00H		; `string'
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QBDB
CONST	SEGMENT
?szDelete@ATL@@3QBDB DD FLAT:??_C@_06JBKGCNBB@Delete?$AA@ ; ATL::szDelete
CONST	ENDS
;	COMDAT ??_C@_08KAAPDIAN@NoRemove?$AA@
CONST	SEGMENT
??_C@_08KAAPDIAN@NoRemove?$AA@ DB 'NoRemove', 00H	; `string'
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QBDB
CONST	SEGMENT
?szNoRemove@ATL@@3QBDB DD FLAT:??_C@_08KAAPDIAN@NoRemove?$AA@ ; ATL::szNoRemove
CONST	ENDS
;	COMDAT ??_C@_0M@DBGDLGLL@ForceRemove?$AA@
CONST	SEGMENT
??_C@_0M@DBGDLGLL@ForceRemove?$AA@ DB 'ForceRemove', 00H ; `string'
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QBDB
CONST	SEGMENT
?szForceRemove@ATL@@3QBDB DD FLAT:??_C@_0M@DBGDLGLL@ForceRemove?$AA@ ; ATL::szForceRemove
CONST	ENDS
;	COMDAT ??_C@_03LAIAPFCB@Val?$AA@
CONST	SEGMENT
??_C@_03LAIAPFCB@Val?$AA@ DB 'Val', 00H			; `string'
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QBDB
CONST	SEGMENT
?szValToken@ATL@@3QBDB DD FLAT:??_C@_03LAIAPFCB@Val?$AA@ ; ATL::szValToken
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QBDB
CONST	SEGMENT
?szBinaryVal@ATL@@3QBDB DD FLAT:??_C@_01HMGJMAIH@B?$AA@	; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ??_C@_01CKDDGHAB@D?$AA@
CONST	SEGMENT
??_C@_01CKDDGHAB@D?$AA@ DB 'D', 00H			; `string'
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QBDB
CONST	SEGMENT
?szDwordVal@ATL@@3QBDB DD FLAT:??_C@_01CKDDGHAB@D?$AA@	; ATL::szDwordVal
CONST	ENDS
;	COMDAT ??_C@_01PLPBNMEI@M?$AA@
CONST	SEGMENT
??_C@_01PLPBNMEI@M?$AA@ DB 'M', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHKJKKIE@atlTraceControls?$AA@
CONST	SEGMENT
??_C@_0BB@GHKJKKIE@atlTraceControls?$AA@ DB 'atlTraceControls', 00H ; `string'
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QBDB
CONST	SEGMENT
?multiszStringVal@ATL@@3QBDB DD FLAT:??_C@_01PLPBNMEI@M?$AA@ ; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S?$AA@
CONST	SEGMENT
??_C@_01CPLAODJH@S?$AA@ DB 'S', 00H			; `string'
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QBDB
CONST	SEGMENT
?szStringVal@ATL@@3QBDB DD FLAT:??_C@_01CPLAODJH@S?$AA@	; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3DB
CONST	SEGMENT
?chEquals@ATL@@3DB DB 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3DB
CONST	SEGMENT
?chQuote@ATL@@3DB DB 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3DB
CONST	SEGMENT
?chLeftBracket@ATL@@3DB DB 07bH				; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3DB
CONST	SEGMENT
?chRightBracket@ATL@@3DB DB 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3DB
CONST	SEGMENT
?chDirSep@ATL@@3DB DB 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT ??_C@_0BC@DGHHNKDC@atlTraceWindowing?$AA@
CONST	SEGMENT
??_C@_0BC@DGHHNKDC@atlTraceWindowing?$AA@ DB 'atlTraceWindowing', 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ??_C@_0BB@ILPPDKFL@atlTraceRefcount?$AA@
CONST	SEGMENT
??_C@_0BB@ILPPDKFL@atlTraceRefcount?$AA@ DB 'atlTraceRefcount', 00H ; `string'
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ??_C@_0BC@MALHFBAO@atlTraceRegistrar?$AA@
CONST	SEGMENT
??_C@_0BC@MALHFBAO@atlTraceRegistrar?$AA@ DB 'atlTraceRegistrar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LHELAKBP@atlTraceQI?$AA@
CONST	SEGMENT
??_C@_0L@LHELAKBP@atlTraceQI?$AA@ DB 'atlTraceQI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGPFJEBB@atlTraceCOM?$AA@
CONST	SEGMENT
??_C@_0M@DGPFJEBB@atlTraceCOM?$AA@ DB 'atlTraceCOM', 00H ; `string'
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT ??_C@_0BA@MKMIKKJB@atlTraceGeneral?$AA@
CONST	SEGMENT
??_C@_0BA@MKMIKKJB@atlTraceGeneral?$AA@ DB 'atlTraceGeneral', 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT ??_C@_0O@KHOBHOBJ@atlTraceISAPI?$AA@
CONST	SEGMENT
??_C@_0O@KHOBHOBJ@atlTraceISAPI?$AA@ DB 'atlTraceISAPI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KLPNCFEE@atlTraceSync?$AA@
CONST	SEGMENT
??_C@_0N@KLPNCFEE@atlTraceSync?$AA@ DB 'atlTraceSync', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DNJDADMG@atlTraceSecurity?$AA@
CONST	SEGMENT
??_C@_0BB@DNJDADMG@atlTraceSecurity?$AA@ DB 'atlTraceSecurity', 00H ; `string'
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ??_C@_0N@FEAAACHD@atlTraceUtil?$AA@
CONST	SEGMENT
??_C@_0N@FEAAACHD@atlTraceUtil?$AA@ DB 'atlTraceUtil', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IOBBMAHG@atlTraceMap?$AA@
CONST	SEGMENT
??_C@_0M@IOBBMAHG@atlTraceMap?$AA@ DB 'atlTraceMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MBNHGHMI@atlTraceString?$AA@
CONST	SEGMENT
??_C@_0P@MBNHGHMI@atlTraceString?$AA@ DB 'atlTraceString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDBKCKK@atlTraceStencil?$AA@
CONST	SEGMENT
??_C@_0BA@IDBKCKK@atlTraceStencil?$AA@ DB 'atlTraceStencil', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEOJAOKK@atlTraceCache?$AA@
CONST	SEGMENT
??_C@_0O@MEOJAOKK@atlTraceCache?$AA@ DB 'atlTraceCache', 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ??_C@_0N@BNNILHBE@atlTraceTime?$AA@
CONST	SEGMENT
??_C@_0N@BNNILHBE@atlTraceTime?$AA@ DB 'atlTraceTime', 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT ??_C@_0BC@PGMFNIFA@atlTraceException?$AA@
CONST	SEGMENT
??_C@_0BC@PGMFNIFA@atlTraceException?$AA@ DB 'atlTraceException', 00H ; `string'
CONST	ENDS
CONST	SEGMENT
_LIBID_GostCryptMainCom DD 01770f56cH
	DW	07881H
	DW	04591H
	DB	0a1H
	DB	079H
	DB	079H
	DB	0b8H
	DB	00H
	DB	01cH
	DB	07dH
	DB	042H
_LIBID_GostCryptFormatCom DD 0a7df958cH
	DW	0716H
	DW	049e9H
	DB	08cH
	DB	03eH
	DB	053H
	DB	0a7H
	DB	075H
	DB	079H
	DB	075H
	DB	076H
CONST	ENDS
PUBLIC	??$AtlMultiply@H@ATL@@YAJPAHHH@Z		; ATL::AtlMultiply<int>
PUBLIC	?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z		; ATL::Checked::memcpy_s
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
PUBLIC	??$AtlAdd@K@ATL@@YAJPAKKK@Z			; ATL::AtlAdd<unsigned long>
PUBLIC	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z		; AtlA2WHelper
PUBLIC	?AtlW2AHelper@@YGPADPADPB_WHI@Z			; AtlW2AHelper
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf_s
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?AtlCrtErrorCheck@ATL@@YAHH@Z			; ATL::AtlCrtErrorCheck
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	?AtlHresultFromLastError@ATL@@YAJXZ		; ATL::AtlHresultFromLastError
PUBLIC	?AtlHresultFromWin32@ATL@@YAJK@Z		; ATL::AtlHresultFromWin32
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CRegKey@ATL@@QAE@XZ				; ATL::CRegKey::~CRegKey
PUBLIC	?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z		; ATL::CRegKey::SetDWORDValue
PUBLIC	?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z	; ATL::CRegKey::SetStringValue
PUBLIC	?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z	; ATL::CRegKey::SetMultiStringValue
PUBLIC	?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z ; ATL::CRegKey::Create
PUBLIC	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z	; ATL::CRegKey::Open
PUBLIC	?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z		; ATL::CRegKey::DeleteSubKey
PUBLIC	?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z	; ATL::CRegKey::RecurseDeleteKey
PUBLIC	?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add
PUBLIC	?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup
PUBLIC	?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z	; ATL::CExpansionVector::Add
PUBLIC	?ClearReplacements@CExpansionVector@ATL@@QAEJXZ	; ATL::CExpansionVector::ClearReplacements
PUBLIC	??1?$CAutoVectorPtr@D@ATL@@QAE@XZ		; ATL::CAutoVectorPtr<char>::~CAutoVectorPtr<char>
PUBLIC	??1?$CAutoVectorPtr@_W@ATL@@QAE@XZ		; ATL::CAutoVectorPtr<wchar_t>::~CAutoVectorPtr<wchar_t>
PUBLIC	?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z ; ATL::CRegParser::PreProcessBuffer
PUBLIC	?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z	; ATL::CRegParser::RegisterBuffer
PUBLIC	?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ		; ATL::CRegParser::SkipWhiteSpace
PUBLIC	?NextToken@CRegParser@ATL@@IAEJPAD@Z		; ATL::CRegParser::NextToken
PUBLIC	?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ; ATL::CRegParser::AddValue
PUBLIC	?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z	; ATL::CRegParser::CanForceRemoveKey
PUBLIC	?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z	; ATL::CRegParser::HasSubKeys
PUBLIC	?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
PUBLIC	?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::SkipAssignment
PUBLIC	?StrChrA@CRegParser@ATL@@KAPADPADD@Z		; ATL::CRegParser::StrChrA
PUBLIC	?ChToByte@CRegParser@ATL@@KAED@Z		; ATL::CRegParser::ChToByte
PUBLIC	?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z	; ATL::CRegParser::VTFromRegType
PUBLIC	??1CParseBuffer@CRegParser@ATL@@QAE@XZ		; ATL::CRegParser::CParseBuffer::~CParseBuffer
PUBLIC	?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z	; ATL::CRegParser::CParseBuffer::Append
PUBLIC	?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
PUBLIC	?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CRegObject::QueryInterface
PUBLIC	?AddRef@CRegObject@ATL@@UAGKXZ			; ATL::CRegObject::AddRef
PUBLIC	?Release@CRegObject@ATL@@UAGKXZ			; ATL::CRegObject::Release
PUBLIC	??1CRegObject@ATL@@UAE@XZ			; ATL::CRegObject::~CRegObject
PUBLIC	?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z	; ATL::CRegObject::AddReplacement
PUBLIC	?ClearReplacements@CRegObject@ATL@@UAGJXZ	; ATL::CRegObject::ClearReplacements
PUBLIC	?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z	; ATL::CRegObject::ResourceRegister
PUBLIC	?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z ; ATL::CRegObject::ResourceUnregister
PUBLIC	?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z ; ATL::CRegObject::RegisterFromResource
PUBLIC	??_GCRegObject@ATL@@UAEPAXI@Z			; ATL::CRegObject::`scalar deleting destructor'
PUBLIC	??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap
PUBLIC	?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
PUBLIC	??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap
PUBLIC	?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap
PUBLIC	??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
PUBLIC	?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
PUBLIC	?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
PUBLIC	??1_com_error@@UAE@XZ				; _com_error::~_com_error
PUBLIC	?ErrorMessage@_com_error@@QBEPBDXZ		; _com_error::ErrorMessage
PUBLIC	??_G_com_error@@UAEPAXI@Z			; _com_error::`scalar deleting destructor'
PUBLIC	_RegisterComServers
PUBLIC	_UnregisterComServers
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
PUBLIC	??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@		; `string'
PUBLIC	??_C@_0BG@FGMNHMFJ@RegOpenKeyTransactedA?$AA@	; `string'
PUBLIC	??_C@_0BI@NBLNJKIN@RegCreateKeyTransactedA?$AA@	; `string'
PUBLIC	??_C@_0BI@GMDDFLLI@RegDeleteKeyTransactedA?$AA@	; `string'
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA ; `ATL::CRegKey::DeleteSubKey'::`2'::pfnRegDeleteKeyEx
PUBLIC	?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA ; `ATL::CRegKey::DeleteSubKey'::`2'::bInitialized
PUBLIC	??_C@_0BA@KECIECLD@RegDeleteKeyExA?$AA@		; `string'
PUBLIC	??_C@_05GIBEAPNE@CLSID?$AA@			; `string'
PUBLIC	??_C@_05PDIKPLII@AppID?$AA@			; `string'
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQBDB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	??_7CRegObject@ATL@@6B@				; ATL::CRegObject::`vftable'
PUBLIC	??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@	; `string'
PUBLIC	??_C@_08PICKODJL@FileType?$AA@			; `string'
PUBLIC	??_C@_09JKPGEJCH@Interface?$AA@			; `string'
PUBLIC	??_C@_08PPIOJEA@Hardware?$AA@			; `string'
PUBLIC	??_C@_04IHBFOLAC@Mime?$AA@			; `string'
PUBLIC	??_C@_03DDIMFGBA@SAM?$AA@			; `string'
PUBLIC	??_C@_08LOPHEHKG@SECURITY?$AA@			; `string'
PUBLIC	??_C@_06FDHFNJBJ@SYSTEM?$AA@			; `string'
PUBLIC	??_C@_08KEKAJNJI@Software?$AA@			; `string'
PUBLIC	??_C@_07KJLOKDKB@TypeLib?$AA@			; `string'
PUBLIC	?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B ; `ATL::CRegParser::VTFromRegType'::`2'::map
PUBLIC	?$TSS0@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4HA ; TSS0<`template-parameter-2',ATL::CRegParser::TFromRegType,unsigned long,int,char const *,unsigned short &>
PUBLIC	?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B ; `ATL::CRegParser::HKeyFromString'::`2'::map
PUBLIC	??_C@_04OHBKMIBJ@HKCR?$AA@			; `string'
PUBLIC	??_C@_04KIFLFONO@HKCU?$AA@			; `string'
PUBLIC	??_C@_04CBBMIBLK@HKLM?$AA@			; `string'
PUBLIC	??_C@_03DLBIJLAB@HKU?$AA@			; `string'
PUBLIC	??_C@_04OFOCGAOH@HKPD?$AA@			; `string'
PUBLIC	??_C@_04POMNGLEL@HKDD?$AA@			; `string'
PUBLIC	??_C@_04LEMDOLAJ@HKCC?$AA@			; `string'
PUBLIC	??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@	; `string'
PUBLIC	??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@	; `string'
PUBLIC	??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@	; `string'
PUBLIC	??_C@_0L@OEMMANAM@HKEY_USERS?$AA@		; `string'
PUBLIC	??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@	; `string'
PUBLIC	??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@		; `string'
PUBLIC	??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@	; `string'
PUBLIC	??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AN?$AA?6?$AA?7?$AA?$HL?$AA?$AN?$AA?6?$AA?7?$AA?7?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_7_com_error@@6B@				; _com_error::`vftable'
PUBLIC	??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@ ; `string'
PUBLIC	??_C@_1CC@HOFAEMLD@?$AA?$CF?$AAh?$AAs?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@NKIHIBKI@?$AA?$CF?$AAh?$AAs?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAF?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@FPIOFILF@?$AAM?$AAA?$AAI?$AAN?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@IFKNBDBK@?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_09NKHKFHLH@GostCrypt?$AA@			; `string'
PUBLIC	??_R0?AUIUnknown@@@8				; IUnknown `RTTI Type Descriptor'
PUBLIC	??_R3IUnknown@@8				; IUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IUnknown@@8				; IUnknown::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUIRegistrarBase@@@8			; IRegistrarBase `RTTI Type Descriptor'
PUBLIC	??_R3IRegistrarBase@@8				; IRegistrarBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IRegistrarBase@@8				; IRegistrarBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IRegistrarBase@@8			; IRegistrarBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CRegObject@ATL@@6B@			; ATL::CRegObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCRegObject@ATL@@@8			; ATL::CRegObject `RTTI Type Descriptor'
PUBLIC	??_R3CRegObject@ATL@@8				; ATL::CRegObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRegObject@ATL@@8				; ATL::CRegObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CRegObject@ATL@@8			; ATL::CRegObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_com_error@@6B@				; _com_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_com_error@@@8				; _com_error `RTTI Type Descriptor'
PUBLIC	??_R3_com_error@@8				; _com_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_com_error@@8				; _com_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_com_error@@8			; _com_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo:PROC
EXTRN	__errno:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__recalloc:PROC
EXTRN	??_U@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new[]
EXTRN	__resetstkoflw:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetModuleFileNameW@12:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryExA@12:PROC
EXTRN	__imp__LoadResource@8:PROC
EXTRN	__imp__SizeofResource@8:PROC
EXTRN	__imp__LocalAlloc@8:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__lstrcmpiA@8:PROC
EXTRN	__imp__FindResourceA@12:PROC
EXTRN	__imp__wsprintfW:PROC
EXTRN	__imp__UnregisterClassA@8:PROC
EXTRN	__imp__CharNextA@4:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__IsDBCSLeadByte@4:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegCreateKeyExA@36:PROC
EXTRN	__imp__RegDeleteKeyA@8:PROC
EXTRN	__imp__RegDeleteValueA@8:PROC
EXTRN	__imp__RegEnumKeyExA@32:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryInfoKeyW@48:PROC
EXTRN	__imp__RegSetValueExA@24:PROC
EXTRN	__imp__CoTaskMemAlloc@4:PROC
EXTRN	__imp__CoTaskMemRealloc@8:PROC
EXTRN	__imp__CoTaskMemFree@4:PROC
EXTRN	__imp__VarUI4FromStr@16:PROC
EXTRN	__imp__LoadTypeLib@8:PROC
EXTRN	__imp__RegisterTypeLib@12:PROC
EXTRN	__imp__UnRegisterTypeLib@20:PROC
EXTRN	__mbsnbcpy_s:PROC
EXTRN	__mbsstr:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	??_ECRegObject@ATL@@UAEPAXI@Z:PROC		; ATL::CRegObject::`vector deleting destructor'
EXTRN	??_E_com_error@@UAEPAXI@Z:PROC			; _com_error::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	__chkstk:PROC
EXTRN	__except_handler4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_MainDlg:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT ?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA
_BSS	SEGMENT
?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA DD 01H DUP (?) ; `ATL::CRegKey::DeleteSubKey'::`2'::pfnRegDeleteKeyEx
_BSS	ENDS
;	COMDAT ?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA
_BSS	SEGMENT
?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA DB 01H DUP (?) ; `ATL::CRegKey::DeleteSubKey'::`2'::bInitialized
_BSS	ENDS
;	COMDAT ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B
_BSS	SEGMENT
?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B DQ 04H DUP (?) ; `ATL::CRegParser::VTFromRegType'::`2'::map
_BSS	ENDS
;	COMDAT ?$TSS0@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',ATL::CRegParser::TFromRegType,unsigned long,int,char const *,unsigned short &>
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@_com_error@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_com_error@@8 DD FLAT:??_R0?AV_com_error@@@8 ; _com_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R2_com_error@@8
rdata$r	SEGMENT
??_R2_com_error@@8 DD FLAT:??_R1A@?0A@EA@_com_error@@8	; _com_error::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_com_error@@8
rdata$r	SEGMENT
??_R3_com_error@@8 DD 00H				; _com_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_com_error@@@8
data$r	SEGMENT
??_R0?AV_com_error@@@8 DD FLAT:??_7type_info@@6B@	; _com_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_com_error@@', 00H
data$r	ENDS
;	COMDAT ??_R4_com_error@@6B@
rdata$r	SEGMENT
??_R4_com_error@@6B@ DD 00H				; _com_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_com_error@@@8
	DD	FLAT:??_R3_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CRegObject@ATL@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRegObject@ATL@@8 DD FLAT:??_R0?AVCRegObject@ATL@@@8 ; ATL::CRegObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRegObject@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R2CRegObject@ATL@@8
rdata$r	SEGMENT
??_R2CRegObject@ATL@@8 DD FLAT:??_R1A@?0A@EA@CRegObject@ATL@@8 ; ATL::CRegObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IRegistrarBase@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3CRegObject@ATL@@8
rdata$r	SEGMENT
??_R3CRegObject@ATL@@8 DD 00H				; ATL::CRegObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CRegObject@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRegObject@ATL@@@8
data$r	SEGMENT
??_R0?AVCRegObject@ATL@@@8 DD FLAT:??_7type_info@@6B@	; ATL::CRegObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRegObject@ATL@@', 00H
data$r	ENDS
;	COMDAT ??_R4CRegObject@ATL@@6B@
rdata$r	SEGMENT
??_R4CRegObject@ATL@@6B@ DD 00H				; ATL::CRegObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRegObject@ATL@@@8
	DD	FLAT:??_R3CRegObject@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IRegistrarBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IRegistrarBase@@8 DD FLAT:??_R0?AUIRegistrarBase@@@8 ; IRegistrarBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRegistrarBase@@8
rdata$r	ENDS
;	COMDAT ??_R2IRegistrarBase@@8
rdata$r	SEGMENT
??_R2IRegistrarBase@@8 DD FLAT:??_R1A@?0A@EA@IRegistrarBase@@8 ; IRegistrarBase::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3IRegistrarBase@@8
rdata$r	SEGMENT
??_R3IRegistrarBase@@8 DD 00H				; IRegistrarBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IRegistrarBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIRegistrarBase@@@8
data$r	SEGMENT
??_R0?AUIRegistrarBase@@@8 DD FLAT:??_7type_info@@6B@	; IRegistrarBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIRegistrarBase@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2IUnknown@@8
rdata$r	SEGMENT
??_R2IUnknown@@8 DD FLAT:??_R1A@?0A@EA@IUnknown@@8	; IUnknown::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IUnknown@@8
rdata$r	SEGMENT
??_R3IUnknown@@8 DD 00H					; IUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
data$r	SEGMENT
??_R0?AUIUnknown@@@8 DD FLAT:??_7type_info@@6B@		; IUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknown@@', 00H
data$r	ENDS
;	COMDAT ??_C@_09NKHKFHLH@GostCrypt?$AA@
CONST	SEGMENT
??_C@_09NKHKFHLH@GostCrypt?$AA@ DB 'GostCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@IFKNBDBK@?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@IFKNBDBK@?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@ DB 'F'
	DB	00H, 'O', 00H, 'R', 00H, 'M', 00H, 'A', 00H, 'T', 00H, '_', 00H
	DB	'M', 00H, 'O', 00H, 'D', 00H, 'U', 00H, 'L', 00H, 'E', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@FPIOFILF@?$AAM?$AAA?$AAI?$AAN?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@FPIOFILF@?$AAM?$AAA?$AAI?$AAN?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@ DB 'M'
	DB	00H, 'A', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'M', 00H, 'O', 00H
	DB	'D', 00H, 'U', 00H, 'L', 00H, 'E', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@NKIHIBKI@?$AA?$CF?$AAh?$AAs?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAF?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@NKIHIBKI@?$AA?$CF?$AAh?$AAs?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAF?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@ DB '%'
	DB	00H, 'h', 00H, 's', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H
	DB	'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'F'
	DB	00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, '.', 00H
	DB	'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@HOFAEMLD@?$AA?$CF?$AAh?$AAs?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@HOFAEMLD@?$AA?$CF?$AAh?$AAs?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@ DB '%'
	DB	00H, 'h', 00H, 's', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H
	DB	'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H, 't', 00H, '.', 00H, 'e'
	DB	00H, 'x', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@
CONST	SEGMENT
??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@ DB 'Unknown error 0x%0l'
	DB	'X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@ DB 'IDispatch error #%'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_7_com_error@@6B@
CONST	SEGMENT
??_7_com_error@@6B@ DD FLAT:??_R4_com_error@@6B@	; _com_error::`vftable'
	DD	FLAT:??_E_com_error@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@ DB 'R'
	DB	00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H, 'R', 00H
	DB	'Y', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, 09H, 00H, '}', 00H, 0dH, 00H, 0aH, 00H, '}', 00H
	DB	0dH, 00H, 0aH, 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AN?$AA?6?$AA?7?$AA?$HL?$AA?$AN?$AA?6?$AA?7?$AA?7?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AN?$AA?6?$AA?7?$AA?$HL?$AA?$AN?$AA?6?$AA?7?$AA?7?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe?$AAs?$AA?$AA@ DB 'H'
	DB	00H, 'K', 00H, 'C', 00H, 'U', 00H, 0dH, 00H, 0aH, 00H, '{', 00H
	DB	09H, 00H, 'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a'
	DB	00H, 'r', 00H, 'e', 00H, 0dH, 00H, 0aH, 00H, 09H, 00H, '{', 00H
	DB	0dH, 00H, 0aH, 00H, 09H, 00H, 09H, 00H, 'C', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, 'e', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@
CONST	SEGMENT
??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@ DB 'HKEY_CURRENT_CONFIG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@
CONST	SEGMENT
??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@ DB 'HKEY_DYN_DATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@
CONST	SEGMENT
??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@ DB 'HKEY_PERFORMANCE_DATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OEMMANAM@HKEY_USERS?$AA@
CONST	SEGMENT
??_C@_0L@OEMMANAM@HKEY_USERS?$AA@ DB 'HKEY_USERS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@
CONST	SEGMENT
??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@ DB 'HKEY_LOCAL_MACHINE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@
CONST	SEGMENT
??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@ DB 'HKEY_CURRENT_USER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@
CONST	SEGMENT
??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@ DB 'HKEY_CLASSES_ROOT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LEMDOLAJ@HKCC?$AA@
CONST	SEGMENT
??_C@_04LEMDOLAJ@HKCC?$AA@ DB 'HKCC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POMNGLEL@HKDD?$AA@
CONST	SEGMENT
??_C@_04POMNGLEL@HKDD?$AA@ DB 'HKDD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFOCGAOH@HKPD?$AA@
CONST	SEGMENT
??_C@_04OFOCGAOH@HKPD?$AA@ DB 'HKPD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLBIJLAB@HKU?$AA@
CONST	SEGMENT
??_C@_03DLBIJLAB@HKU?$AA@ DB 'HKU', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CBBMIBLK@HKLM?$AA@
CONST	SEGMENT
??_C@_04CBBMIBLK@HKLM?$AA@ DB 'HKLM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KIFLFONO@HKCU?$AA@
CONST	SEGMENT
??_C@_04KIFLFONO@HKCU?$AA@ DB 'HKCU', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHBKMIBJ@HKCR?$AA@
CONST	SEGMENT
??_C@_04OHBKMIBJ@HKCR?$AA@ DB 'HKCR', 00H		; `string'
CONST	ENDS
;	COMDAT ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B
CONST	SEGMENT
?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B DD FLAT:??_C@_04OHBKMIBJ@HKCR?$AA@ ; `ATL::CRegParser::HKeyFromString'::`2'::map
	DD	080000000H
	DD	FLAT:??_C@_04KIFLFONO@HKCU?$AA@
	DD	080000001H
	DD	FLAT:??_C@_04CBBMIBLK@HKLM?$AA@
	DD	080000002H
	DD	FLAT:??_C@_03DLBIJLAB@HKU?$AA@
	DD	080000003H
	DD	FLAT:??_C@_04OFOCGAOH@HKPD?$AA@
	DD	080000004H
	DD	FLAT:??_C@_04POMNGLEL@HKDD?$AA@
	DD	080000006H
	DD	FLAT:??_C@_04LEMDOLAJ@HKCC?$AA@
	DD	080000005H
	DD	FLAT:??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@
	DD	080000000H
	DD	FLAT:??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@
	DD	080000001H
	DD	FLAT:??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@
	DD	080000002H
	DD	FLAT:??_C@_0L@OEMMANAM@HKEY_USERS?$AA@
	DD	080000003H
	DD	FLAT:??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@
	DD	080000004H
	DD	FLAT:??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@
	DD	080000006H
	DD	FLAT:??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@
	DD	080000005H
CONST	ENDS
;	COMDAT ??_C@_07KJLOKDKB@TypeLib?$AA@
CONST	SEGMENT
??_C@_07KJLOKDKB@TypeLib?$AA@ DB 'TypeLib', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEKAJNJI@Software?$AA@
CONST	SEGMENT
??_C@_08KEKAJNJI@Software?$AA@ DB 'Software', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDHFNJBJ@SYSTEM?$AA@
CONST	SEGMENT
??_C@_06FDHFNJBJ@SYSTEM?$AA@ DB 'SYSTEM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LOPHEHKG@SECURITY?$AA@
CONST	SEGMENT
??_C@_08LOPHEHKG@SECURITY?$AA@ DB 'SECURITY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DDIMFGBA@SAM?$AA@
CONST	SEGMENT
??_C@_03DDIMFGBA@SAM?$AA@ DB 'SAM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHBFOLAC@Mime?$AA@
CONST	SEGMENT
??_C@_04IHBFOLAC@Mime?$AA@ DB 'Mime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPIOJEA@Hardware?$AA@
CONST	SEGMENT
??_C@_08PPIOJEA@Hardware?$AA@ DB 'Hardware', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKPGEJCH@Interface?$AA@
CONST	SEGMENT
??_C@_09JKPGEJCH@Interface?$AA@ DB 'Interface', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PICKODJL@FileType?$AA@
CONST	SEGMENT
??_C@_08PICKODJL@FileType?$AA@ DB 'FileType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@
CONST	SEGMENT
??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@ DB 'Component Categories', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CRegObject@ATL@@6B@
CONST	SEGMENT
??_7CRegObject@ATL@@6B@ DD FLAT:??_R4CRegObject@ATL@@6B@ ; ATL::CRegObject::`vftable'
	DD	FLAT:?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CRegObject@ATL@@UAGKXZ
	DD	FLAT:?Release@CRegObject@ATL@@UAGKXZ
	DD	FLAT:?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
	DD	FLAT:?ClearReplacements@CRegObject@ATL@@UAGJXZ
	DD	FLAT:??_ECRegObject@ATL@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQBDB DD FLAT:??_C@_05PDIKPLII@AppID?$AA@ ; ATL::CRegParser::rgszNeverDelete
	DD	FLAT:??_C@_05GIBEAPNE@CLSID?$AA@
	DD	FLAT:??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@
	DD	FLAT:??_C@_08PICKODJL@FileType?$AA@
	DD	FLAT:??_C@_09JKPGEJCH@Interface?$AA@
	DD	FLAT:??_C@_08PPIOJEA@Hardware?$AA@
	DD	FLAT:??_C@_04IHBFOLAC@Mime?$AA@
	DD	FLAT:??_C@_03DDIMFGBA@SAM?$AA@
	DD	FLAT:??_C@_08LOPHEHKG@SECURITY?$AA@
	DD	FLAT:??_C@_06FDHFNJBJ@SYSTEM?$AA@
	DD	FLAT:??_C@_08KEKAJNJI@Software?$AA@
	DD	FLAT:??_C@_07KJLOKDKB@TypeLib?$AA@
CONST	ENDS
;	COMDAT ??_C@_05PDIKPLII@AppID?$AA@
CONST	SEGMENT
??_C@_05PDIKPLII@AppID?$AA@ DB 'AppID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GIBEAPNE@CLSID?$AA@
CONST	SEGMENT
??_C@_05GIBEAPNE@CLSID?$AA@ DB 'CLSID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KECIECLD@RegDeleteKeyExA?$AA@
CONST	SEGMENT
??_C@_0BA@KECIECLD@RegDeleteKeyExA?$AA@ DB 'RegDeleteKeyExA', 00H ; `string'
CONST	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_DATA	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 04H DUP (?)
	DD	FLAT:___ImageBase			; ATL::_AtlComModule
	DD	FLAT:___pobjMapEntryFirst+4
	DD	FLAT:___pobjMapEntryLast
_DATA	ENDS
;	COMDAT ??_C@_0BI@GMDDFLLI@RegDeleteKeyTransactedA?$AA@
CONST	SEGMENT
??_C@_0BI@GMDDFLLI@RegDeleteKeyTransactedA?$AA@ DB 'RegDeleteKeyTransacte'
	DB	'dA', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NBLNJKIN@RegCreateKeyTransactedA?$AA@
CONST	SEGMENT
??_C@_0BI@NBLNJKIN@RegCreateKeyTransactedA?$AA@ DB 'RegCreateKeyTransacte'
	DB	'dA', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FGMNHMFJ@RegOpenKeyTransactedA?$AA@
CONST	SEGMENT
??_C@_0BG@FGMNHMFJ@RegOpenKeyTransactedA?$AA@ DB 'RegOpenKeyTransactedA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@ DB 'Advapi32.dll', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
data$r	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
data$r	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$4
__tryblocktable$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$11
__unwindtable$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$8
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
	DD	01H
	DD	FLAT:__tryblocktable$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z$0
__ehfuncinfo$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z$0
__ehfuncinfo$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z$0
__ehfuncinfo$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z$0
__ehfuncinfo$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z$4
__ehfuncinfo$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$2
__catchsym$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$0
__ehfuncinfo$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
	DD	02H
	DD	FLAT:__tryblocktable$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$7
	DD	05H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$8
__unwindtable$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$4
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$6
	DD	04H
	DD	00H
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z$0
__ehfuncinfo$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$1
__ehfuncinfo$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__F_AtlComModule@ATL@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__F_AtlComModule@ATL@@YAXXZ$0
__ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__F_AtlComModule@ATL@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffffccH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN7@AtlVerifyS
	DD	FLAT:$LN8@AtlVerifyS
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??$?3PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPA_W@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?3PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPA_W@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::operator delete<wchar_t *>, COMDAT

; 506  : 		}

  00000	c3		 ret	 0
??$?3PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPA_W@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::operator delete<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??$?2PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPA_W@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_p$ = 12						; size = 4
??$?2PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPA_W@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::operator new<wchar_t *>, COMDAT

; 498  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 499  : 			return p;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]

; 500  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$?2PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPA_W@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::operator new<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQA_W@Z
_TEXT	SEGMENT
__t$ = 8						; size = 4
??0?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQA_W@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::Wrapper<wchar_t *>, COMDAT
; _this$ = ecx

; 492  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 491  : 		Wrapper(_In_ const T& _t) : t(_t)

  00003	8b 45 08	 mov	 eax, DWORD PTR __t$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 493  : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQA_W@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::Wrapper<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator delete<char *>, COMDAT

; 506  : 		}

  00000	c3		 ret	 0
??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator delete<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_p$ = 12						; size = 4
??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator new<char *>, COMDAT

; 498  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 499  : 			return p;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]

; 500  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator new<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z
_TEXT	SEGMENT
__t$ = 8						; size = 4
??0?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::Wrapper<char *>, COMDAT
; _this$ = ecx

; 492  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 491  : 		Wrapper(_In_ const T& _t) : t(_t)

  00003	8b 45 08	 mov	 eax, DWORD PTR __t$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 493  : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::Wrapper<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAddThrow@K@ATL@@YAKKK@Z
_TEXT	SEGMENT
_tLeft$ = 8						; size = 4
_tRight$ = 12						; size = 4
??$AtlAddThrow@K@ATL@@YAKKK@Z PROC			; ATL::AtlAddThrow<unsigned long>, COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 209  : 	T tResult;
; 210  : 	HRESULT hr=AtlAdd(&tResult, tLeft, tRight);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 55 0c	 mov	 edx, DWORD PTR _tRight$[ebp]
  0000b	f7 d0		 not	 eax
  0000d	3b c2		 cmp	 eax, edx
  0000f	72 05		 jb	 SHORT $LN13@AtlAddThro
  00011	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 214  : 	}
; 215  : 	return tResult;
; 216  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN13@AtlAddThro:

; 211  : 	if(FAILED(hr))
; 212  : 	{
; 213  : 		AtlThrow(hr);

  00016	68 16 02 07 80	 push	 -2147024362		; 80070216H
  0001b	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN14@AtlAddThro:
$LN12@AtlAddThro:
  00020	cc		 int	 3
??$AtlAddThrow@K@ATL@@YAKKK@Z ENDP			; ATL::AtlAddThrow<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 689  : 			return (this + 1);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 690  : 		}

  00003	c3		 ret	 0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiplyThrow@I@ATL@@YAIII@Z
_TEXT	SEGMENT
_tLeft$ = 8						; size = 4
_tRight$ = 12						; size = 4
??$AtlMultiplyThrow@I@ATL@@YAIII@Z PROC			; ATL::AtlMultiplyThrow<unsigned int>, COMDAT

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 195  : 	T tResult;
; 196  : 	HRESULT hr=AtlMultiply(&tResult, tLeft, tRight);

  00003	8b 45 08	 mov	 eax, DWORD PTR _tLeft$[ebp]
  00006	f7 65 0c	 mul	 DWORD PTR _tRight$[ebp]
  00009	85 d2		 test	 edx, edx
  0000b	75 07		 jne	 SHORT $LN14@AtlMultipl
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 02		 ja	 SHORT $LN14@AtlMultipl

; 200  : 	}
; 201  : 	return tResult;
; 202  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
$LN14@AtlMultipl:

; 197  : 	if(FAILED(hr))
; 198  : 	{
; 199  : 		AtlThrow(hr);

  00014	68 16 02 07 80	 push	 -2147024362		; 80070216H
  00019	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN16@AtlMultipl:
$LN13@AtlMultipl:
  0001e	cc		 int	 3
??$AtlMultiplyThrow@I@ATL@@YAIII@Z ENDP			; ATL::AtlMultiplyThrow<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\comsetup.cpp
;	COMDAT _UnregisterComServers
_TEXT	SEGMENT
_ro$ = -2616						; size = 44
_module$ = -2572					; size = 2048
_setupModule$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_modulePath$ = 8					; size = 4
_UnregisterComServers PROC				; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 0a 00
	00		 sub	 esp, 2616		; 00000a38H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 89   : 	BOOL ret;
; 90   : 
; 91   : 	if (UnRegisterTypeLib (LIBID_GostCryptMainCom, GST_MAIN_COM_VERSION_MAJOR, GST_MAIN_COM_VERSION_MINOR, 0, SYS_WIN32) != S_OK)

  00014	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__UnRegisterTypeLib@20
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _modulePath$[ebp]
  0001e	6a 01		 push	 1
  00020	6a 00		 push	 0
  00022	6a 04		 push	 4
  00024	6a 02		 push	 2
  00026	68 00 00 00 00	 push	 OFFSET _LIBID_GostCryptMainCom
  0002b	ff d6		 call	 esi
  0002d	85 c0		 test	 eax, eax
  0002f	74 12		 je	 SHORT $LN2@Unregister
$LN35@Unregister:
  00031	5f		 pop	 edi

; 92   : 		return FALSE;

  00032	33 c0		 xor	 eax, eax
  00034	5e		 pop	 esi

; 113  : }

  00035	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00038	33 cd		 xor	 ecx, ebp
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN2@Unregister:

; 93   : 	if (UnRegisterTypeLib (LIBID_GostCryptFormatCom, GST_FORMAT_COM_VERSION_MAJOR, GST_FORMAT_COM_VERSION_MINOR, 0, SYS_WIN32) != S_OK)

  00043	6a 01		 push	 1
  00045	6a 00		 push	 0
  00047	6a 04		 push	 4
  00049	6a 02		 push	 2
  0004b	68 00 00 00 00	 push	 OFFSET _LIBID_GostCryptFormatCom
  00050	ff d6		 call	 esi
  00052	85 c0		 test	 eax, eax
  00054	75 db		 jne	 SHORT $LN35@Unregister

; 94   : 		return FALSE;
; 95   : 
; 96   : 	wchar_t module[1024];
; 97   : 	CRegObject ro;
; 98   : 	ro.FinalConstruct ();

  00056	50		 push	 eax
  00057	50		 push	 eax
  00058	89 85 cc f5 ff
	ff		 mov	 DWORD PTR _ro$[ebp+4], eax
  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	89 85 d0 f5 ff
	ff		 mov	 DWORD PTR _ro$[ebp+8], eax
  00067	89 85 d4 f5 ff
	ff		 mov	 DWORD PTR _ro$[ebp+12], eax
  0006d	88 85 f0 f5 ff
	ff		 mov	 BYTE PTR _ro$[ebp+40], al
  00073	8d 85 d8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp+16]
  00079	50		 push	 eax
  0007a	c7 85 c8 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ro$[ebp], OFFSET ??_7CRegObject@ATL@@6B@
  00084	0f 11 85 d8 f5
	ff ff		 movups	 XMMWORD PTR _ro$[ebp+16], xmm0
  0008b	66 0f d6 85 e8
	f5 ff ff	 movq	 QWORD PTR _ro$[ebp+32], xmm0
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
  00099	85 c0		 test	 eax, eax
  0009b	75 16		 jne	 SHORT $LN33@Unregister
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000a3	85 c0		 test	 eax, eax
  000a5	7e 0a		 jle	 SHORT $LN34@Unregister
  000a7	0f b7 c0	 movzx	 eax, ax
  000aa	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
  000af	85 c0		 test	 eax, eax
$LN34@Unregister:
  000b1	78 07		 js	 SHORT $LN20@Unregister
$LN33@Unregister:
  000b3	c6 85 f0 f5 ff
	ff 01		 mov	 BYTE PTR _ro$[ebp+40], 1
$LN20@Unregister:

; 99   : 
; 100  : 	wsprintfW (module, L"%hsGostCrypt.exe", modulePath);

  000ba	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfW
  000c0	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _module$[ebp]
  000c6	57		 push	 edi
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@HOFAEMLD@?$AA?$CF?$AAh?$AAs?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
  000cc	50		 push	 eax
  000cd	ff d6		 call	 esi
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 101  : 	ro.AddReplacement (L"MAIN_MODULE", module);

  000d2	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _module$[ebp]
  000d8	50		 push	 eax
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@FPIOFILF@?$AAM?$AAA?$AAI?$AAN?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
  000de	8d 85 c8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement

; 102  : 
; 103  : 	wsprintfW (module, L"%hsGostCrypt Format.exe", modulePath);

  000ea	57		 push	 edi
  000eb	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _module$[ebp]
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_1DA@NKIHIBKI@?$AA?$CF?$AAh?$AAs?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAF?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
  000f6	50		 push	 eax
  000f7	ff d6		 call	 esi
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 104  : 	ro.AddReplacement (L"FORMAT_MODULE", module);

  000fc	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _module$[ebp]
  00102	50		 push	 eax
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@IFKNBDBK@?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
  00108	8d 85 c8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement

; 105  : 
; 106  : 	wchar_t setupModule[MAX_PATH];
; 107  : 	GetModuleFileNameW (NULL, setupModule, sizeof (setupModule) / sizeof (setupModule[0]));

  00114	68 04 01 00 00	 push	 260			; 00000104H
  00119	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _setupModule$[ebp]
  0011f	50		 push	 eax
  00120	6a 00		 push	 0
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameW@12

; 108  : 
; 109  : 	ret = ro.ResourceUnregister (setupModule, IDR_COMREG, L"REGISTRY") == S_OK;

  00128	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@
  0012d	6a 0a		 push	 10			; 0000000aH
  0012f	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _setupModule$[ebp]
  00135	50		 push	 eax
  00136	8d 85 c8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 ?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z ; ATL::CRegObject::ResourceUnregister
  00142	f7 d8		 neg	 eax

; 110  : 
; 111  : 	ro.FinalRelease ();
; 112  : 	return ret;

  00144	8d 8d c8 f5 ff
	ff		 lea	 ecx, DWORD PTR _ro$[ebp]
  0014a	1b f6		 sbb	 esi, esi
  0014c	e8 00 00 00 00	 call	 ??1CRegObject@ATL@@UAE@XZ ; ATL::CRegObject::~CRegObject

; 113  : }

  00151	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00154	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00157	5f		 pop	 edi
  00158	33 cd		 xor	 ecx, ebp
  0015a	5e		 pop	 esi
  0015b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
_UnregisterComServers ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\comsetup.cpp
;	COMDAT _RegisterComServers
_TEXT	SEGMENT
_ro$ = -4688						; size = 44
$T1 = -4644						; size = 16
_tl$ = -4628						; size = 4
_tl2$ = -4624						; size = 4
_formatModule$ = -4620					; size = 2048
_mainModule$ = -2572					; size = 2048
_setupModule$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_modulePath$ = 8					; size = 4
_RegisterComServers PROC				; COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 50 12 00 00	 mov	 eax, 4688		; 00001250H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi

; 45   : 	BOOL ret = TRUE;
; 46   : 	wchar_t mainModule[1024], formatModule[1024];
; 47   : 	CComPtr<ITypeLib> tl, tl2;
; 48   : 
; 49   : 	wsprintfW (mainModule, L"%hsGostCrypt.exe", modulePath);

  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfW
  0001f	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _mainModule$[ebp]
  00025	57		 push	 edi
  00026	8b 7d 08	 mov	 edi, DWORD PTR _modulePath$[ebp]
  00029	bb 01 00 00 00	 mov	 ebx, 1
  0002e	57		 push	 edi
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@HOFAEMLD@?$AA?$CF?$AAh?$AAs?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
  00034	50		 push	 eax
  00035	c7 85 ec ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _tl$[ebp], 0
  0003f	c7 85 f0 ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _tl2$[ebp], 0
  00049	ff d6		 call	 esi

; 50   : 	wsprintfW (formatModule, L"%hsGostCrypt Format.exe", modulePath);

  0004b	57		 push	 edi
  0004c	8d 85 f4 ed ff
	ff		 lea	 eax, DWORD PTR _formatModule$[ebp]
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_1DA@NKIHIBKI@?$AA?$CF?$AAh?$AAs?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAF?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
  00057	50		 push	 eax
  00058	ff d6		 call	 esi

; 51   : 
; 52   : 	UnRegisterTypeLib (LIBID_GostCryptMainCom, GST_MAIN_COM_VERSION_MAJOR, GST_MAIN_COM_VERSION_MINOR, 0, SYS_WIN32);

  0005a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__UnRegisterTypeLib@20
  00060	83 c4 18	 add	 esp, 24			; 00000018H
  00063	53		 push	 ebx
  00064	6a 00		 push	 0
  00066	6a 04		 push	 4
  00068	6a 02		 push	 2
  0006a	68 00 00 00 00	 push	 OFFSET _LIBID_GostCryptMainCom
  0006f	ff d6		 call	 esi

; 53   : 	UnRegisterTypeLib (LIBID_GostCryptFormatCom, GST_FORMAT_COM_VERSION_MAJOR, GST_FORMAT_COM_VERSION_MINOR, 0, SYS_WIN32);

  00071	53		 push	 ebx
  00072	6a 00		 push	 0
  00074	6a 04		 push	 4
  00076	6a 02		 push	 2
  00078	68 00 00 00 00	 push	 OFFSET _LIBID_GostCryptFormatCom
  0007d	ff d6		 call	 esi

; 54   : 
; 55   : 	wchar_t setupModule[MAX_PATH];
; 56   : 	GetModuleFileNameW (NULL, setupModule, sizeof (setupModule) / sizeof (setupModule[0]));

  0007f	68 04 01 00 00	 push	 260			; 00000104H
  00084	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _setupModule$[ebp]
  0008a	50		 push	 eax
  0008b	6a 00		 push	 0
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameW@12

; 57   : 
; 58   : 	CRegObject ro;
; 59   : 	HRESULT r;
; 60   : 
; 61   : 	if (!SUCCEEDED (r = ro.FinalConstruct ())
; 62   : 		|| !SUCCEEDED (r = ro.AddReplacement (L"MAIN_MODULE", mainModule))
; 63   : 		|| !SUCCEEDED (r = ro.AddReplacement (L"FORMAT_MODULE", formatModule))
; 64   : 		|| !SUCCEEDED (r = ro.ResourceRegister (setupModule, IDR_COMREG, L"REGISTRY"))
; 65   : 		|| !SUCCEEDED (r = LoadTypeLib (mainModule, &tl))
; 66   : 		|| !SUCCEEDED (r = RegisterTypeLib (tl, mainModule, 0))
; 67   : 		|| !SUCCEEDED (r = LoadTypeLib (formatModule, &tl2))
; 68   : 		|| !SUCCEEDED (r = RegisterTypeLib (tl2, formatModule, 0)))

  00093	33 f6		 xor	 esi, esi
  00095	c7 85 b0 ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _ro$[ebp], OFFSET ??_7CRegObject@ATL@@6B@
  0009f	56		 push	 esi
  000a0	0f 57 c0	 xorps	 xmm0, xmm0
  000a3	c7 85 b4 ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _ro$[ebp+4], 0
  000ad	56		 push	 esi
  000ae	8d 85 c0 ed ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp+16]
  000b4	c7 85 b8 ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _ro$[ebp+8], 0
  000be	50		 push	 eax
  000bf	c7 85 bc ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _ro$[ebp+12], 0
  000c9	0f 11 85 c0 ed
	ff ff		 movups	 XMMWORD PTR _ro$[ebp+16], xmm0
  000d0	c6 85 d8 ed ff
	ff 00		 mov	 BYTE PTR _ro$[ebp+40], 0
  000d7	66 0f d6 85 d0
	ed ff ff	 movq	 QWORD PTR _ro$[ebp+32], xmm0
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
  000e5	85 c0		 test	 eax, eax
  000e7	75 19		 jne	 SHORT $LN68@RegisterCo
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000ef	8b f0		 mov	 esi, eax
  000f1	85 f6		 test	 esi, esi
  000f3	7e 0b		 jle	 SHORT $LN70@RegisterCo
  000f5	0f b7 f6	 movzx	 esi, si
  000f8	81 ce 00 00 07
	80		 or	 esi, -2147024896	; 80070000H
  000fe	85 f6		 test	 esi, esi
$LN70@RegisterCo:
  00100	78 06		 js	 SHORT $LN28@RegisterCo
$LN68@RegisterCo:
  00102	88 9d d8 ed ff
	ff		 mov	 BYTE PTR _ro$[ebp+40], bl
$LN28@RegisterCo:
  00108	85 f6		 test	 esi, esi
  0010a	0f 88 cc 00 00
	00		 js	 $LN3@RegisterCo
  00110	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _mainModule$[ebp]
  00116	50		 push	 eax
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@FPIOFILF@?$AAM?$AAA?$AAI?$AAN?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
  0011c	8d 85 b0 ed ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement
  00128	8b f0		 mov	 esi, eax
  0012a	85 f6		 test	 esi, esi
  0012c	0f 88 aa 00 00
	00		 js	 $LN3@RegisterCo
  00132	8d 85 f4 ed ff
	ff		 lea	 eax, DWORD PTR _formatModule$[ebp]
  00138	50		 push	 eax
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@IFKNBDBK@?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
  0013e	8d 85 b0 ed ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement
  0014a	8b f0		 mov	 esi, eax
  0014c	85 f6		 test	 esi, esi
  0014e	0f 88 88 00 00
	00		 js	 $LN3@RegisterCo
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@
  00159	6a 0a		 push	 10			; 0000000aH
  0015b	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _setupModule$[ebp]
  00161	50		 push	 eax
  00162	8d 85 b0 ed ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  00168	50		 push	 eax
  00169	e8 00 00 00 00	 call	 ?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z ; ATL::CRegObject::ResourceRegister
  0016e	8b f0		 mov	 esi, eax
  00170	85 f6		 test	 esi, esi
  00172	78 68		 js	 SHORT $LN3@RegisterCo
  00174	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__LoadTypeLib@8
  0017a	8d 85 ec ed ff
	ff		 lea	 eax, DWORD PTR _tl$[ebp]
  00180	50		 push	 eax
  00181	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _mainModule$[ebp]
  00187	50		 push	 eax
  00188	ff d7		 call	 edi
  0018a	8b f0		 mov	 esi, eax
  0018c	85 f6		 test	 esi, esi
  0018e	78 4c		 js	 SHORT $LN3@RegisterCo
  00190	6a 00		 push	 0
  00192	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _mainModule$[ebp]
  00198	50		 push	 eax
  00199	ff b5 ec ed ff
	ff		 push	 DWORD PTR _tl$[ebp]
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterTypeLib@12
  001a5	8b f0		 mov	 esi, eax
  001a7	85 f6		 test	 esi, esi
  001a9	78 31		 js	 SHORT $LN3@RegisterCo
  001ab	8d 85 f0 ed ff
	ff		 lea	 eax, DWORD PTR _tl2$[ebp]
  001b1	50		 push	 eax
  001b2	8d 85 f4 ed ff
	ff		 lea	 eax, DWORD PTR _formatModule$[ebp]
  001b8	50		 push	 eax
  001b9	ff d7		 call	 edi
  001bb	8b f0		 mov	 esi, eax
  001bd	85 f6		 test	 esi, esi
  001bf	78 1b		 js	 SHORT $LN3@RegisterCo
  001c1	6a 00		 push	 0
  001c3	8d 85 f4 ed ff
	ff		 lea	 eax, DWORD PTR _formatModule$[ebp]
  001c9	50		 push	 eax
  001ca	ff b5 f0 ed ff
	ff		 push	 DWORD PTR _tl2$[ebp]
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterTypeLib@12
  001d6	8b f0		 mov	 esi, eax
  001d8	85 f6		 test	 esi, esi
  001da	79 70		 jns	 SHORT $LN2@RegisterCo
$LN3@RegisterCo:

; 69   : 	{
; 70   : 		MessageBox (MainDlg, _com_error (r).ErrorMessage(), GST_APP_NAME, MB_ICONERROR);

  001dc	6a 10		 push	 16			; 00000010H
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  001e3	8d 8d dc ed ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001e9	c7 85 dc ed ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], OFFSET ??_7_com_error@@6B@
  001f3	89 b5 e0 ed ff
	ff		 mov	 DWORD PTR $T1[ebp+4], esi
  001f9	c7 85 e4 ed ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp+8], 0
  00203	c7 85 e8 ed ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp+12], 0
  0020d	e8 00 00 00 00	 call	 ?ErrorMessage@_com_error@@QBEPBDXZ ; _com_error::ErrorMessage
  00212	50		 push	 eax
  00213	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00219	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  0021f	8b 8d e4 ed ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp+8]
  00225	c7 85 dc ed ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], OFFSET ??_7_com_error@@6B@
  0022f	85 c9		 test	 ecx, ecx
  00231	74 06		 je	 SHORT $LN51@RegisterCo
  00233	8b 01		 mov	 eax, DWORD PTR [ecx]
  00235	51		 push	 ecx
  00236	ff 50 08	 call	 DWORD PTR [eax+8]
$LN51@RegisterCo:
  00239	8b 85 e8 ed ff
	ff		 mov	 eax, DWORD PTR $T1[ebp+12]
  0023f	85 c0		 test	 eax, eax
  00241	74 07		 je	 SHORT $LN52@RegisterCo
  00243	50		 push	 eax
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
$LN52@RegisterCo:

; 71   : 		ret = FALSE;

  0024a	33 db		 xor	 ebx, ebx
$LN2@RegisterCo:

; 72   : 	}
; 73   : 
; 74   : 	ro.FinalRelease ();
; 75   : 	return ret;

  0024c	8d 8d b0 ed ff
	ff		 lea	 ecx, DWORD PTR _ro$[ebp]
  00252	e8 00 00 00 00	 call	 ??1CRegObject@ATL@@UAE@XZ ; ATL::CRegObject::~CRegObject
  00257	8b 85 f0 ed ff
	ff		 mov	 eax, DWORD PTR _tl2$[ebp]
  0025d	85 c0		 test	 eax, eax
  0025f	74 06		 je	 SHORT $LN60@RegisterCo
  00261	8b 08		 mov	 ecx, DWORD PTR [eax]
  00263	50		 push	 eax
  00264	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN60@RegisterCo:
  00267	8b 8d ec ed ff
	ff		 mov	 ecx, DWORD PTR _tl$[ebp]
  0026d	85 c9		 test	 ecx, ecx
  0026f	74 06		 je	 SHORT $LN69@RegisterCo
  00271	8b 11		 mov	 edx, DWORD PTR [ecx]
  00273	51		 push	 ecx
  00274	ff 52 08	 call	 DWORD PTR [edx+8]
$LN69@RegisterCo:

; 76   : }

  00277	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027a	8b c3		 mov	 eax, ebx
  0027c	5f		 pop	 edi
  0027d	5e		 pop	 esi
  0027e	33 cd		 xor	 ecx, ebp
  00280	5b		 pop	 ebx
  00281	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00286	8b e5		 mov	 esp, ebp
  00288	5d		 pop	 ebp
  00289	c3		 ret	 0
_RegisterComServers ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_com_error@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_com_error@@UAEPAXI@Z PROC				; _com_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
  0000f	85 c9		 test	 ecx, ecx
  00011	74 06		 je	 SHORT $LN5@scalar
  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	51		 push	 ecx
  00016	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@scalar:
  00019	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001c	85 c0		 test	 eax, eax
  0001e	74 07		 je	 SHORT $LN6@scalar
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
$LN6@scalar:
  00027	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0002b	74 0b		 je	 SHORT $LN8@scalar
  0002d	6a 10		 push	 16			; 00000010H
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_G_com_error@@UAEPAXI@Z ENDP				; _com_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\comdef.h
;	COMDAT ?HRESULTToWCode@_com_error@@SAGJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?HRESULTToWCode@_com_error@@SAGJ@Z PROC			; _com_error::HRESULTToWCode, COMDAT

; 454  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _hr$[ebp]
  00006	8d 81 00 fe fb
	7f		 lea	 eax, DWORD PTR [ecx+2147220992]
  0000c	3d ff fd 00 00	 cmp	 eax, 65023		; 0000fdffH
  00011	77 0b		 ja	 SHORT $LN3@HRESULTToW
  00013	8d 81 00 fe ff
	ff		 lea	 eax, DWORD PTR [ecx-512]
  00019	0f b7 c0	 movzx	 eax, ax

; 456  :         ? WORD(hr - WCODE_HRESULT_FIRST)
; 457  :         : 0;
; 458  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN3@HRESULTToW:

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

  0001e	33 c0		 xor	 eax, eax

; 456  :         ? WORD(hr - WCODE_HRESULT_FIRST)
; 457  :         : 0;
; 458  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?HRESULTToWCode@_com_error@@SAGJ@Z ENDP			; _com_error::HRESULTToWCode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\comdef.h
;	COMDAT ?ErrorMessage@_com_error@@QBEPBDXZ
_TEXT	SEGMENT
?ErrorMessage@_com_error@@QBEPBDXZ PROC			; _com_error::ErrorMessage, COMDAT
; _this$ = ecx

; 408  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 409  :     if (m_pszMsg == NULL) {

  00004	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  00008	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
  0000b	0f 85 ad 00 00
	00		 jne	 $LN19@ErrorMessa

; 410  :         FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|

  00011	6a 00		 push	 0
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	68 00 04 00 00	 push	 1024			; 00000400H
  0001b	ff 77 04	 push	 DWORD PTR [edi+4]
  0001e	6a 00		 push	 0
  00020	68 00 13 00 00	 push	 4864			; 00001300H
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 411  :                           FORMAT_MESSAGE_FROM_SYSTEM|
; 412  :                           FORMAT_MESSAGE_IGNORE_INSERTS,
; 413  :                       NULL,
; 414  :                       m_hresult,
; 415  :                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
; 416  :                       (LPTSTR)&m_pszMsg,
; 417  :                       0,
; 418  :                       NULL);
; 419  :         if (m_pszMsg != NULL) {

  0002b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 35		 je	 SHORT $LN3@ErrorMessa

; 420  :             #ifdef UNICODE
; 421  :             size_t const nLen = wcslen(m_pszMsg);
; 422  :             #else
; 423  :             size_t const nLen = strlen(m_pszMsg);

  00031	8b d1		 mov	 edx, ecx
  00033	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL17@ErrorMessa:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	42		 inc	 edx
  00039	84 c0		 test	 al, al
  0003b	75 f9		 jne	 SHORT $LL17@ErrorMessa
  0003d	2b d7		 sub	 edx, edi

; 424  :             #endif
; 425  :             if (nLen > 1 && m_pszMsg[nLen - 1] == '\n') {

  0003f	83 fa 01	 cmp	 edx, 1
  00042	76 1d		 jbe	 SHORT $LN20@ErrorMessa
  00044	80 7c 11 ff 0a	 cmp	 BYTE PTR [ecx+edx-1], 10 ; 0000000aH
  00049	75 16		 jne	 SHORT $LN20@ErrorMessa

; 426  :                 m_pszMsg[nLen - 1] = 0;

  0004b	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al

; 427  :                 if (m_pszMsg[nLen - 2] == '\r') {

  0004f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00051	80 7c 0a fe 0d	 cmp	 BYTE PTR [edx+ecx-2], 13 ; 0000000dH
  00056	75 09		 jne	 SHORT $LN20@ErrorMessa

; 428  :                         m_pszMsg[nLen - 2] = 0;

  00058	88 44 0a fe	 mov	 BYTE PTR [edx+ecx-2], al

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 446  : }

  00060	c3		 ret	 0
$LN20@ErrorMessa:
  00061	5f		 pop	 edi

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

  00062	8b c1		 mov	 eax, ecx
  00064	5e		 pop	 esi

; 446  : }

  00065	c3		 ret	 0
$LN3@ErrorMessa:

; 429  :                 }
; 430  :             }
; 431  :         } 
; 432  :         else {
; 433  :             m_pszMsg = (LPTSTR)LocalAlloc(0, 32 * sizeof(TCHAR));

  00066	6a 20		 push	 32			; 00000020H
  00068	6a 00		 push	 0
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalAlloc@8
  00070	8b d0		 mov	 edx, eax
  00072	89 16		 mov	 DWORD PTR [esi], edx

; 434  :             if (m_pszMsg != NULL) {

  00074	85 d2		 test	 edx, edx
  00076	74 48		 je	 SHORT $LN9@ErrorMessa

; 435  :                 WORD wCode = WCode();

  00078	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  0007b	8d 8f 00 fe fb
	7f		 lea	 ecx, DWORD PTR [edi+2147220992]
  00081	81 f9 ff fd 00
	00		 cmp	 ecx, 65023		; 0000fdffH
  00087	77 24		 ja	 SHORT $LN8@ErrorMessa
  00089	8d 87 00 fe ff
	ff		 lea	 eax, DWORD PTR [edi-512]
  0008f	0f b7 c0	 movzx	 eax, ax

; 436  :                 if (wCode != 0) {

  00092	66 85 c0	 test	 ax, ax
  00095	74 16		 je	 SHORT $LN8@ErrorMessa

; 437  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("IDispatch error #%d"), (int)wCode);

  00097	50		 push	 eax
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@

; 438  :                 } 
; 439  :                 else {
; 440  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("Unknown error 0x%0lX"), m_hresult);

  0009d	6a 20		 push	 32			; 00000020H
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 _sprintf_s

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	83 c4 10	 add	 esp, 16			; 00000010H
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi

; 446  : }

  000ac	c3		 ret	 0
$LN8@ErrorMessa:

; 438  :                 } 
; 439  :                 else {
; 440  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("Unknown error 0x%0lX"), m_hresult);

  000ad	57		 push	 edi
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@
  000b3	6a 20		 push	 32			; 00000020H
  000b5	52		 push	 edx
  000b6	e8 00 00 00 00	 call	 _sprintf_s
  000bb	83 c4 10	 add	 esp, 16			; 00000010H
$LN19@ErrorMessa:

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

  000be	8b 06		 mov	 eax, DWORD PTR [esi]
$LN9@ErrorMessa:
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi

; 446  : }

  000c2	c3		 ret	 0
?ErrorMessage@_com_error@@QBEPBDXZ ENDP			; _com_error::ErrorMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\comdef.h
;	COMDAT ?WCode@_com_error@@QBEGXZ
_TEXT	SEGMENT
?WCode@_com_error@@QBEGXZ PROC				; _com_error::WCode, COMDAT
; _this$ = ecx

; 341  :     return HRESULTToWCode(m_hresult);

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8d 81 00 fe fb
	7f		 lea	 eax, DWORD PTR [ecx+2147220992]
  00009	3d ff fd 00 00	 cmp	 eax, 65023		; 0000fdffH
  0000e	77 0a		 ja	 SHORT $LN5@WCode
  00010	8d 81 00 fe ff
	ff		 lea	 eax, DWORD PTR [ecx-512]
  00016	0f b7 c0	 movzx	 eax, ax

; 342  : }

  00019	c3		 ret	 0

; 341  :     return HRESULTToWCode(m_hresult);

$LN5@WCode:
  0001a	33 c0		 xor	 eax, eax

; 342  : }

  0001c	c3		 ret	 0
?WCode@_com_error@@QBEGXZ ENDP				; _com_error::WCode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\comdef.h
;	COMDAT ??1_com_error@@UAE@XZ
_TEXT	SEGMENT
??1_com_error@@UAE@XZ PROC				; _com_error::~_com_error, COMDAT
; _this$ = ecx

; 316  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 317  :     if (m_perrinfo != NULL) {

  00003	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 06		 je	 SHORT $LN2@com_error

; 318  :         m_perrinfo->Release();

  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	51		 push	 ecx
  00013	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@com_error:

; 319  :     }
; 320  :     if (m_pszMsg != NULL) {

  00016	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00019	5e		 pop	 esi
  0001a	85 c0		 test	 eax, eax
  0001c	74 07		 je	 SHORT $LN3@com_error

; 321  :         LocalFree((HLOCAL)m_pszMsg);

  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
$LN3@com_error:

; 322  :     }
; 323  : }

  00025	c3		 ret	 0
??1_com_error@@UAE@XZ ENDP				; _com_error::~_com_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\comdef.h
;	COMDAT ??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
_perrinfo$ = 12						; size = 4
_fAddRef$ = 16						; size = 1
??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z PROC		; _com_error::_com_error, COMDAT
; _this$ = ecx

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 300  :     : m_hresult(hr), m_perrinfo(perrinfo), m_pszMsg(NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _perrinfo$[ebp]
  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
  00012	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00015	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00018	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 302  :     if (m_perrinfo != NULL && fAddRef) {

  0001f	85 c9		 test	 ecx, ecx
  00021	74 0c		 je	 SHORT $LN4@com_error
  00023	80 7d 10 00	 cmp	 BYTE PTR _fAddRef$[ebp], 0
  00027	74 06		 je	 SHORT $LN4@com_error

; 303  :         m_perrinfo->AddRef();

  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	51		 push	 ecx
  0002c	ff 50 04	 call	 DWORD PTR [eax+4]
$LN4@com_error:

; 304  :     }
; 305  : }

  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z ENDP		; _com_error::_com_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ITypeLib>::~CComPtr<ITypeLib>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN4@CComPtr
  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	51		 push	 ecx
  0002b	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@CComPtr:
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ITypeLib>::~CComPtr<ITypeLib>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>, COMDAT
; _this$ = ecx

; 320  :     {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 321  :     }

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ PROC ; ATL::CComPtrBase<ITypeLib>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

  00000	8b c1		 mov	 eax, ecx

; 194  :     }

  00002	c3		 ret	 0
??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ ENDP ; ATL::CComPtrBase<ITypeLib>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ PROC ; ATL::CComPtrBase<ITypeLib>::operator ITypeLib *, COMDAT
; _this$ = ecx

; 181  :         return p;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 182  :     }

  00002	c3		 ret	 0
??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ ENDP ; ATL::CComPtrBase<ITypeLib>::operator ITypeLib *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ PROC		; ATL::CComPtrBase<ITypeLib>::~CComPtrBase<ITypeLib>, COMDAT
; _this$ = ecx

; 176  :         if (p)

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 06		 je	 SHORT $LN2@CComPtrBas

; 177  :             p->Release();

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	51		 push	 ecx
  00009	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

  0000c	c3		 ret	 0
??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ ENDP		; ATL::CComPtrBase<ITypeLib>::~CComPtrBase<ITypeLib>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ PROC		; ATL::CComPtrBase<ITypeLib>::CComPtrBase<ITypeLib>, COMDAT
; _this$ = ecx

; 157  :     {
; 158  :         p = NULL;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 159  :     }

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ ENDP		; ATL::CComPtrBase<ITypeLib>::CComPtrBase<ITypeLib>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 604  : 		Allocator::Free( m_p );

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 _free
  00007	59		 pop	 ecx

; 605  : 	}

  00008	c3		 ret	 0
?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 583  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 584  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00004	ff 75 08	 push	 DWORD PTR _nBytes$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 _malloc
  0000e	83 c4 04	 add	 esp, 4

; 585  : 		if( p == NULL )

  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN7@AllocateHe

; 588  : 		}
; 589  : 		m_p = p;

  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	5e		 pop	 esi

; 590  : 	}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN7@AllocateHe:

; 586  : 		{
; 587  : 			AtlThrow( E_OUTOFMEMORY );

  0001c	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00021	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN9@AllocateHe:
$LN6@AllocateHe:
  00026	cc		 int	 3
?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 567  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 568  : 		ATLASSERT( m_p == NULL );
; 569  : 		if( nBytes > t_nFixedBytes )

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0000e	76 0d		 jbe	 SHORT $LN2@AllocateBy

; 570  : 		{
; 571  : 			AllocateHeap( nBytes );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap

; 576  : 		}
; 577  : 
; 578  : 		return( m_p );

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	5e		 pop	 esi

; 579  : 	}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN2@AllocateBy:

; 572  : 		}
; 573  : 		else
; 574  : 		{
; 575  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001d	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00020	89 06		 mov	 DWORD PTR [esi], eax
  00022	5e		 pop	 esi

; 579  : 	}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 527  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 528  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00003	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	33 c9		 xor	 ecx, ecx
  0000b	77 25		 ja	 SHORT $LN21@Allocate
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 20		 ja	 SHORT $LN21@Allocate
  00012	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00017	76 0f		 jbe	 SHORT $LN15@Allocate
  00019	50		 push	 eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	5e		 pop	 esi

; 529  : 	}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4

; 528  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

$LN15@Allocate:
  00028	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0002b	89 06		 mov	 DWORD PTR [esi], eax
  0002d	5e		 pop	 esi

; 529  : 	}

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN21@Allocate:

; 528  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00032	68 16 02 07 80	 push	 -2147024362		; 80070216H
  00037	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@Allocate:
$LN20@Allocate:
  0003c	cc		 int	 3
?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ
_TEXT	SEGMENT
??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *, COMDAT
; _this$ = ecx

; 517  : 		return( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 518  : 	}

  00002	c3		 ret	 0
??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 509  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	39 01		 cmp	 DWORD PTR [ecx], eax
  00005	0f 85 00 00 00
	00		 jne	 ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap

; 510  : 		{
; 511  : 			FreeHeap();
; 512  : 		}
; 513  : 	}

  0000b	c3		 ret	 0
??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 496  : 		m_p( NULL )

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 498  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 604  : 		Allocator::Free( m_p );

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 _free
  00007	59		 pop	 ecx

; 605  : 	}

  00008	c3		 ret	 0
?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 583  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 584  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00004	ff 75 08	 push	 DWORD PTR _nBytes$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 _malloc
  0000e	83 c4 04	 add	 esp, 4

; 585  : 		if( p == NULL )

  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN7@AllocateHe

; 588  : 		}
; 589  : 		m_p = p;

  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	5e		 pop	 esi

; 590  : 	}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN7@AllocateHe:

; 586  : 		{
; 587  : 			AtlThrow( E_OUTOFMEMORY );

  0001c	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00021	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN9@AllocateHe:
$LN6@AllocateHe:
  00026	cc		 int	 3
?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 567  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 568  : 		ATLASSERT( m_p == NULL );
; 569  : 		if( nBytes > t_nFixedBytes )

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0000e	76 0d		 jbe	 SHORT $LN2@AllocateBy

; 570  : 		{
; 571  : 			AllocateHeap( nBytes );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap

; 576  : 		}
; 577  : 
; 578  : 		return( m_p );

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	5e		 pop	 esi

; 579  : 	}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN2@AllocateBy:

; 572  : 		}
; 573  : 		else
; 574  : 		{
; 575  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001d	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00020	89 06		 mov	 DWORD PTR [esi], eax
  00022	5e		 pop	 esi

; 579  : 	}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 527  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 528  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00003	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	33 c9		 xor	 ecx, ecx
  0000b	77 25		 ja	 SHORT $LN21@Allocate
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 20		 ja	 SHORT $LN21@Allocate
  00012	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00017	76 0f		 jbe	 SHORT $LN15@Allocate
  00019	50		 push	 eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap
  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	5e		 pop	 esi

; 529  : 	}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4

; 528  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

$LN15@Allocate:
  00028	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0002b	89 06		 mov	 DWORD PTR [esi], eax
  0002d	5e		 pop	 esi

; 529  : 	}

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN21@Allocate:

; 528  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00032	68 16 02 07 80	 push	 -2147024362		; 80070216H
  00037	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@Allocate:
$LN20@Allocate:
  0003c	cc		 int	 3
?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 517  : 		return( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 518  : 	}

  00002	c3		 ret	 0
??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 509  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	39 01		 cmp	 DWORD PTR [ecx], eax
  00005	0f 85 00 00 00
	00		 jne	 ?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap

; 510  : 		{
; 511  : 			FreeHeap();
; 512  : 		}
; 513  : 	}

  0000b	c3		 ret	 0
??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::CTempBuffer<char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 496  : 		m_p( NULL )

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 498  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::CTempBuffer<char,256,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 604  : 		Allocator::Free( m_p );

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 _free
  00007	59		 pop	 ecx

; 605  : 	}

  00008	c3		 ret	 0
?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 583  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 584  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00004	ff 75 08	 push	 DWORD PTR _nBytes$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 _malloc
  0000e	83 c4 04	 add	 esp, 4

; 585  : 		if( p == NULL )

  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN7@AllocateHe

; 588  : 		}
; 589  : 		m_p = p;

  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	5e		 pop	 esi

; 590  : 	}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN7@AllocateHe:

; 586  : 		{
; 587  : 			AtlThrow( E_OUTOFMEMORY );

  0001c	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00021	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN9@AllocateHe:
$LN6@AllocateHe:
  00026	cc		 int	 3
?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 567  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 568  : 		ATLASSERT( m_p == NULL );
; 569  : 		if( nBytes > t_nFixedBytes )

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0000e	76 0d		 jbe	 SHORT $LN2@AllocateBy

; 570  : 		{
; 571  : 			AllocateHeap( nBytes );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap

; 576  : 		}
; 577  : 
; 578  : 		return( m_p );

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	5e		 pop	 esi

; 579  : 	}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN2@AllocateBy:

; 572  : 		}
; 573  : 		else
; 574  : 		{
; 575  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001d	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00020	89 06		 mov	 DWORD PTR [esi], eax
  00022	5e		 pop	 esi

; 579  : 	}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 527  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 528  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00003	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	33 c9		 xor	 ecx, ecx
  0000b	77 25		 ja	 SHORT $LN21@Allocate
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 20		 ja	 SHORT $LN21@Allocate
  00012	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  00017	76 0f		 jbe	 SHORT $LN15@Allocate
  00019	50		 push	 eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap
  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	5e		 pop	 esi

; 529  : 	}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4

; 528  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

$LN15@Allocate:
  00028	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0002b	89 06		 mov	 DWORD PTR [esi], eax
  0002d	5e		 pop	 esi

; 529  : 	}

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN21@Allocate:

; 528  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00032	68 16 02 07 80	 push	 -2147024362		; 80070216H
  00037	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@Allocate:
$LN20@Allocate:
  0003c	cc		 int	 3
?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 517  : 		return( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 518  : 	}

  00002	c3		 ret	 0
??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 509  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	39 01		 cmp	 DWORD PTR [ecx], eax
  00005	0f 85 00 00 00
	00		 jne	 ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap

; 510  : 		{
; 511  : 			FreeHeap();
; 512  : 		}
; 513  : 	}

  0000b	c3		 ret	 0
??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::CTempBuffer<char,1024,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 496  : 		m_p( NULL )

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 498  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::CTempBuffer<char,1024,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCRegObject@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCRegObject@ATL@@UAEPAXI@Z PROC			; ATL::CRegObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CRegObject@ATL@@UAE@XZ ; ATL::CRegObject::~CRegObject
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 2c		 push	 44			; 0000002cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCRegObject@ATL@@UAEPAXI@Z ENDP			; ATL::CRegObject::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CRegObject@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRegObject@ATL@@QAE@XZ PROC				; ATL::CRegObject::CRegObject, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CRegObject@ATL@@6B@
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00014	8b c1		 mov	 eax, ecx
  00016	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00024	0f 11 41 10	 movups	 XMMWORD PTR [ecx+16], xmm0
  00028	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	66 0f d6 41 20	 movq	 QWORD PTR [ecx+32], xmm0
  00030	c6 41 28 00	 mov	 BYTE PTR [ecx+40], 0
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??0CRegObject@ATL@@QAE@XZ ENDP				; ATL::CRegObject::CRegObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
_TEXT	SEGMENT
tv437 = -1080						; size = 8
_parser$ = -1072					; size = 8
__AtlSafeAllocaManager$ = -1064				; size = 4
_szID$GSCopy$1$ = -1060					; size = 4
_dwSize$ = -1060					; size = 4
_szType$GSCopy$1$ = -1056				; size = 4
_hReg$ = -1056						; size = 4
_bstrFileName$GSCopy$1$ = -1052				; size = 4
_hInstResDll$ = -1052					; size = 4
_szReg$ = -1048						; size = 1028
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_bstrFileName$ = 8					; size = 4
_szID$ = 12						; size = 4
_szType$ = 16						; size = 4
_bRegister$ = 20					; size = 4
?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z PROC ; ATL::CRegObject::RegisterFromResource, COMDAT
; _this$ = ecx

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 2c 04 00
	00		 sub	 esp, 1068		; 0000042cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 55 0c	 mov	 edx, DWORD PTR _szID$[ebp]

; 444  : 	USES_CONVERSION_EX;

  00034	33 f6		 xor	 esi, esi
  00036	8b 45 08	 mov	 eax, DWORD PTR _bstrFileName$[ebp]
  00039	89 95 dc fb ff
	ff		 mov	 DWORD PTR _szID$GSCopy$1$[ebp], edx
  0003f	8b 55 10	 mov	 edx, DWORD PTR _szType$[ebp]
  00042	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _bstrFileName$GSCopy$1$[ebp], eax
  00048	89 95 e0 fb ff
	ff		 mov	 DWORD PTR _szType$GSCopy$1$[ebp], edx
  0004e	89 b5 d8 fb ff
	ff		 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi
  00054	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], esi

; 445  : 
; 446  : 	HRESULT     hr;
; 447  : 	CRegParser  parser(this);

  00057	89 8d d4 fb ff
	ff		 mov	 DWORD PTR _parser$[ebp+4], ecx
  0005d	89 b5 d0 fb ff
	ff		 mov	 DWORD PTR _parser$[ebp], esi

; 448  : 	HINSTANCE   hInstResDll;
; 449  : 	HRSRC       hrscReg;
; 450  : 	HGLOBAL     hReg;
; 451  : 	DWORD       dwSize;
; 452  : 	LPSTR       szRegA;
; 453  : 	CTempBuffer<TCHAR, 1024> szReg;

  00063	89 b5 e8 fb ff
	ff		 mov	 DWORD PTR _szReg$[ebp], esi
  00069	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 454  : 
; 455  : 	LPCTSTR lpszBSTRFileName = OLE2CT_EX(bstrFileName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  0006d	85 c0		 test	 eax, eax
  0006f	0f 84 10 02 00
	00		 je	 $LN105@RegisterFr
  00075	8b c8		 mov	 ecx, eax
  00077	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL108@RegisterFr:
  00080	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00083	83 c1 02	 add	 ecx, 2
  00086	66 85 c0	 test	 ax, ax
  00089	75 f5		 jne	 SHORT $LL108@RegisterFr
  0008b	2b ca		 sub	 ecx, edx
  0008d	d1 f9		 sar	 ecx, 1
  0008f	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00092	b9 02 00 00 00	 mov	 ecx, 2
  00097	f7 e9		 imul	 ecx
  00099	8b f8		 mov	 edi, eax
  0009b	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  000a0	83 d2 00	 adc	 edx, 0
  000a3	89 95 cc fb ff
	ff		 mov	 DWORD PTR tv437[ebp+4], edx
  000a9	0f 85 84 00 00
	00		 jne	 $LN109@RegisterFr
  000af	83 f8 ff	 cmp	 eax, -1
  000b2	77 7f		 ja	 SHORT $LN109@RegisterFr
  000b4	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  000ba	7f 1b		 jg	 SHORT $LN17@RegisterFr
  000bc	57		 push	 edi
  000bd	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  000c2	83 c4 04	 add	 esp, 4
  000c5	84 c0		 test	 al, al
  000c7	74 0e		 je	 SHORT $LN17@RegisterFr
  000c9	8b c7		 mov	 eax, edi
  000cb	e8 00 00 00 00	 call	 __alloca_probe_16
  000d0	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000d3	8b dc		 mov	 ebx, esp
  000d5	eb 2a		 jmp	 SHORT $LN45@RegisterFr
$LN17@RegisterFr:
  000d7	8b c7		 mov	 eax, edi
  000d9	f7 d0		 not	 eax
  000db	83 f8 08	 cmp	 eax, 8
  000de	72 49		 jb	 SHORT $LN106@RegisterFr
  000e0	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _malloc
  000e9	83 c4 04	 add	 esp, 4
  000ec	85 c0		 test	 eax, eax
  000ee	74 43		 je	 SHORT $LN109@RegisterFr
  000f0	8b f0		 mov	 esi, eax
  000f2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000f8	89 b5 d8 fb ff
	ff		 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi
  000fe	8d 58 08	 lea	 ebx, DWORD PTR [eax+8]
$LN45@RegisterFr:
  00101	85 db		 test	 ebx, ebx
  00103	74 2e		 je	 SHORT $LN109@RegisterFr
  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	57		 push	 edi
  0010a	53		 push	 ebx
  0010b	6a ff		 push	 -1
  0010d	ff b5 e4 fb ff
	ff		 push	 DWORD PTR _bstrFileName$GSCopy$1$[ebp]
  00113	c6 03 00	 mov	 BYTE PTR [ebx], 0
  00116	6a 00		 push	 0
  00118	6a 03		 push	 3
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00120	33 c9		 xor	 ecx, ecx
  00122	85 c0		 test	 eax, eax
  00124	0f 44 d9	 cmove	 ebx, ecx
  00127	eb 0c		 jmp	 SHORT $LN64@RegisterFr
$LN106@RegisterFr:
  00129	68 16 02 07 80	 push	 -2147024362		; 80070216H
  0012e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN114@RegisterFr:
$LN109@RegisterFr:
  00133	33 db		 xor	 ebx, ebx
$LN64@RegisterFr:

; 456  : #ifndef _UNICODE
; 457  : 	if (lpszBSTRFileName == NULL)

  00135	85 db		 test	 ebx, ebx
  00137	0f 84 48 01 00
	00		 je	 $LN105@RegisterFr

; 460  : 	}
; 461  : #endif // _UNICODE
; 462  : 
; 463  : 	hInstResDll = LoadLibraryEx(lpszBSTRFileName, NULL, LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE | LOAD_LIBRARY_AS_IMAGE_RESOURCE);

  0013d	6a 60		 push	 96			; 00000060H
  0013f	6a 00		 push	 0
  00141	53		 push	 ebx
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryExA@12
  00148	8b f8		 mov	 edi, eax
  0014a	89 bd e4 fb ff
	ff		 mov	 DWORD PTR _hInstResDll$[ebp], edi

; 464  : 
; 465  : 	if (NULL == hInstResDll)

  00150	85 ff		 test	 edi, edi
  00152	75 22		 jne	 SHORT $LN4@RegisterFr

; 466  : 	{
; 467  : 		// if library load failed using flags only valid on Vista+, fall back to using flags valid on XP
; 468  : 		hInstResDll = LoadLibraryEx(lpszBSTRFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);

  00154	6a 02		 push	 2
  00156	50		 push	 eax
  00157	53		 push	 ebx
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryExA@12
  0015e	8b f8		 mov	 edi, eax
  00160	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _hInstResDll$[ebp], eax

; 469  : 	}
; 470  : 
; 471  : 	if (NULL == hInstResDll)

  00166	85 ff		 test	 edi, edi
  00168	75 0c		 jne	 SHORT $LN4@RegisterFr

; 472  : 	{
; 473  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadLibrary on %Ts\n"), bstrFileName);
; 474  : 		hr = AtlHresultFromLastError();

  0016a	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError
  0016f	8b d8		 mov	 ebx, eax

; 475  : 		goto ReturnHR;

  00171	e9 df 00 00 00	 jmp	 $LN15@RegisterFr
$LN4@RegisterFr:

; 476  : 	}
; 477  : 
; 478  : 	hrscReg =FindResource((HMODULE)hInstResDll, szID, szType);

  00176	ff b5 e0 fb ff
	ff		 push	 DWORD PTR _szType$GSCopy$1$[ebp]
  0017c	ff b5 dc fb ff
	ff		 push	 DWORD PTR _szID$GSCopy$1$[ebp]
  00182	57		 push	 edi
  00183	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  00189	8b d8		 mov	 ebx, eax

; 479  : 
; 480  : 	if (NULL == hrscReg)

  0018b	85 db		 test	 ebx, ebx
  0018d	75 0a		 jne	 SHORT $LN6@RegisterFr

; 481  : 	{
; 482  : 		ATLTRACE(atlTraceRegistrar, 0, (HIWORD(szID) == 0) ?
; 483  : 			_T("Failed to FindResource on ID:%d TYPE:%Ts\n") :
; 484  : 			_T("Failed to FindResource on ID:%Ts TYPE:%Ts\n"),
; 485  : 			szID, szType);
; 486  : 		hr = AtlHresultFromLastError();

  0018f	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError

; 487  : 		goto ReturnHR;

  00194	e9 af 00 00 00	 jmp	 $LN112@RegisterFr
$LN6@RegisterFr:

; 488  : 	}
; 489  : 	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

  00199	53		 push	 ebx
  0019a	57		 push	 edi
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8
  001a1	89 85 e0 fb ff
	ff		 mov	 DWORD PTR _hReg$[ebp], eax

; 490  : 
; 491  : 	if (NULL == hReg)

  001a7	85 c0		 test	 eax, eax
  001a9	75 0a		 jne	 SHORT $LN8@RegisterFr

; 492  : 	{
; 493  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadResource\n"));
; 494  : 		hr = AtlHresultFromLastError();

  001ab	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError

; 495  : 		goto ReturnHR;

  001b0	e9 93 00 00 00	 jmp	 $LN112@RegisterFr
$LN8@RegisterFr:

; 496  : 	}
; 497  : 
; 498  : 	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);

  001b5	53		 push	 ebx
  001b6	57		 push	 edi
  001b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8
  001bd	8b d8		 mov	 ebx, eax
  001bf	89 9d dc fb ff
	ff		 mov	 DWORD PTR _dwSize$[ebp], ebx

; 499  : 	szRegA = (LPSTR)hReg;
; 500  : 
; 501  : 	// Allocate extra space for NULL.
; 502  : 	if (dwSize + 1 < dwSize)

  001c5	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  001c8	3b c3		 cmp	 eax, ebx
  001ca	73 07		 jae	 SHORT $LN10@RegisterFr

; 503  : 	{
; 504  : 		hr = E_OUTOFMEMORY;

  001cc	bb 0e 00 07 80	 mov	 ebx, -2147024882	; 8007000eH

; 505  : 		goto ReturnHR;

  001d1	eb 77		 jmp	 SHORT $ReturnHR$115
$LN10@RegisterFr:

; 506  : 	}
; 507  : 
; 508  : 	ATLTRY(szReg.Allocate(dwSize + 1));

  001d3	50		 push	 eax
  001d4	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _szReg$[ebp]
  001da	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  001de	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate
  001e3	eb 18		 jmp	 SHORT $LN113@RegisterFr
__catch$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$4:
  001e5	b8 00 00 00 00	 mov	 eax, $LN28@RegisterFr
  001ea	c3		 ret	 0
$LN28@RegisterFr:
  001eb	8b b5 d8 fb ff
	ff		 mov	 esi, DWORD PTR __AtlSafeAllocaManager$[ebp]
  001f1	8b bd e4 fb ff
	ff		 mov	 edi, DWORD PTR _hInstResDll$[ebp]
  001f7	8b 9d dc fb ff
	ff		 mov	 ebx, DWORD PTR _dwSize$[ebp]
$LN113@RegisterFr:

; 509  : 	if (szReg == NULL)

  001fd	83 bd e8 fb ff
	ff 00		 cmp	 DWORD PTR _szReg$[ebp], 0
  00204	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0020b	75 07		 jne	 SHORT $LN13@RegisterFr

; 510  : 	{
; 511  : 		hr = E_OUTOFMEMORY;

  0020d	bb 0e 00 07 80	 mov	 ebx, -2147024882	; 8007000eH

; 512  : 		goto ReturnHR;

  00212	eb 36		 jmp	 SHORT $ReturnHR$115
$LN13@RegisterFr:

; 513  : 	}
; 514  : 
; 515  : #ifdef _UNICODE
; 516  : 	DWORD uniSize = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, szRegA, dwSize, szReg, dwSize);
; 517  : 	if (uniSize == 0)
; 518  : 	{
; 519  : 		hr = AtlHresultFromLastError();
; 520  : 		goto ReturnHR;
; 521  : 	}
; 522  : 	// Append a NULL at the end.
; 523  : 	szReg[uniSize] = _T('\0');
; 524  : #else
; 525  : 	Checked::memcpy_s(szReg, dwSize, szRegA, dwSize);

  00214	53		 push	 ebx
  00215	ff b5 e0 fb ff
	ff		 push	 DWORD PTR _hReg$[ebp]
  0021b	53		 push	 ebx
  0021c	ff b5 e8 fb ff
	ff		 push	 DWORD PTR _szReg$[ebp]
  00222	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s

; 526  : 	// Append a NULL at the end.
; 527  :    	szReg[dwSize] = _T('\0');

  00227	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _szReg$[ebp]

; 528  : #endif
; 529  : 
; 530  : 	hr = parser.RegisterBuffer(szReg, bRegister);

  0022d	8d 8d d0 fb ff
	ff		 lea	 ecx, DWORD PTR _parser$[ebp]
  00233	83 c4 10	 add	 esp, 16			; 00000010H
  00236	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0
  0023a	ff 75 14	 push	 DWORD PTR _bRegister$[ebp]
  0023d	ff b5 e8 fb ff
	ff		 push	 DWORD PTR _szReg$[ebp]
  00243	e8 00 00 00 00	 call	 ?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z ; ATL::CRegParser::RegisterBuffer
$LN112@RegisterFr:
  00248	8b d8		 mov	 ebx, eax
$ReturnHR$115:

; 531  : 
; 532  : ReturnHR:
; 533  : 
; 534  : 	if (NULL != hInstResDll)

  0024a	85 ff		 test	 edi, edi
  0024c	74 07		 je	 SHORT $LN15@RegisterFr

; 535  : 		FreeLibrary((HMODULE)hInstResDll);

  0024e	57		 push	 edi
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
$LN15@RegisterFr:

; 536  : 	return hr;

  00255	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szReg$[ebp+4]
  0025b	39 85 e8 fb ff
	ff		 cmp	 DWORD PTR _szReg$[ebp], eax
  00261	74 0b		 je	 SHORT $LN88@RegisterFr
  00263	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _szReg$[ebp]
  00269	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
$LN88@RegisterFr:
  0026e	85 f6		 test	 esi, esi
  00270	74 0f		 je	 SHORT $LN92@RegisterFr
$LL91@RegisterFr:
  00272	56		 push	 esi
  00273	8b 36		 mov	 esi, DWORD PTR [esi]
  00275	e8 00 00 00 00	 call	 _free
  0027a	83 c4 04	 add	 esp, 4
  0027d	85 f6		 test	 esi, esi
  0027f	75 f1		 jne	 SHORT $LL91@RegisterFr
$LN92@RegisterFr:
  00281	8b c3		 mov	 eax, ebx
  00283	eb 31		 jmp	 SHORT $LN1@RegisterFr
$LN105@RegisterFr:

; 458  : 	{
; 459  : 		return E_OUTOFMEMORY;

  00285	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szReg$[ebp+4]
  0028b	39 85 e8 fb ff
	ff		 cmp	 DWORD PTR _szReg$[ebp], eax
  00291	74 0b		 je	 SHORT $LN70@RegisterFr
  00293	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _szReg$[ebp]
  00299	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
$LN70@RegisterFr:
  0029e	85 f6		 test	 esi, esi
  002a0	74 0f		 je	 SHORT $LN74@RegisterFr
$LL73@RegisterFr:
  002a2	56		 push	 esi
  002a3	8b 36		 mov	 esi, DWORD PTR [esi]
  002a5	e8 00 00 00 00	 call	 _free
  002aa	83 c4 04	 add	 esp, 4
  002ad	85 f6		 test	 esi, esi
  002af	75 f1		 jne	 SHORT $LL73@RegisterFr
$LN74@RegisterFr:
  002b1	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
$LN1@RegisterFr:

; 537  : }

  002b6	8d a5 b8 fb ff
	ff		 lea	 esp, DWORD PTR [ebp-1096]
  002bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002c6	59		 pop	 ecx
  002c7	5f		 pop	 edi
  002c8	5e		 pop	 esi
  002c9	5b		 pop	 ebx
  002ca	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002cd	33 cd		 xor	 ecx, ebp
  002cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d4	8b e5		 mov	 esp, ebp
  002d6	5d		 pop	 ebp
  002d7	c2 10 00	 ret	 16			; 00000010H
$LN111@RegisterFr:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$7:
  00000	8d 8d d8 fb ff
	ff		 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__unwindfunclet$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$8:
  0000b	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _szReg$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
__ehhandler$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a c4 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1084]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z ENDP ; ATL::CRegObject::RegisterFromResource
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z
_TEXT	SEGMENT
tv262 = -28						; size = 8
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_nID$ = 16						; size = 4
_szType$ = 20						; size = 4
?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z PROC	; ATL::CRegObject::ResourceUnregister, COMDAT

; 581  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 582  : 	USES_CONVERSION_EX;

  0002b	33 f6		 xor	 esi, esi
  0002d	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi

; 583  : 
; 584  : 	LPCTSTR lpszT = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00030	8b 45 14	 mov	 eax, DWORD PTR _szType$[ebp]
  00033	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00036	85 c0		 test	 eax, eax
  00038	0f 84 c4 00 00
	00		 je	 $LN59@ResourceUn
  0003e	8b c8		 mov	 ecx, eax
  00040	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL62@ResourceUn:
  00043	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00046	83 c1 02	 add	 ecx, 2
  00049	66 85 c0	 test	 ax, ax
  0004c	75 f5		 jne	 SHORT $LL62@ResourceUn
  0004e	2b ca		 sub	 ecx, edx
  00050	d1 f9		 sar	 ecx, 1
  00052	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00055	b9 02 00 00 00	 mov	 ecx, 2
  0005a	f7 e9		 imul	 ecx
  0005c	8b f8		 mov	 edi, eax
  0005e	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  00063	83 d2 00	 adc	 edx, 0
  00066	89 55 e8	 mov	 DWORD PTR tv262[ebp+4], edx
  00069	75 7a		 jne	 SHORT $LN63@ResourceUn
  0006b	83 f8 ff	 cmp	 eax, -1
  0006e	77 75		 ja	 SHORT $LN63@ResourceUn
  00070	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  00076	7f 18		 jg	 SHORT $LN4@ResourceUn
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0007e	83 c4 04	 add	 esp, 4
  00081	84 c0		 test	 al, al
  00083	74 0b		 je	 SHORT $LN4@ResourceUn
  00085	8b c7		 mov	 eax, edi
  00087	e8 00 00 00 00	 call	 __alloca_probe_16
  0008c	8b dc		 mov	 ebx, esp
  0008e	eb 27		 jmp	 SHORT $LN24@ResourceUn
$LN4@ResourceUn:
  00090	8b c7		 mov	 eax, edi
  00092	f7 d0		 not	 eax
  00094	83 f8 08	 cmp	 eax, 8
  00097	72 42		 jb	 SHORT $LN60@ResourceUn
  00099	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _malloc
  000a2	83 c4 04	 add	 esp, 4
  000a5	85 c0		 test	 eax, eax
  000a7	74 3c		 je	 SHORT $LN63@ResourceUn
  000a9	8b f0		 mov	 esi, eax
  000ab	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000b1	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi
  000b4	8d 58 08	 lea	 ebx, DWORD PTR [eax+8]
$LN24@ResourceUn:
  000b7	85 db		 test	 ebx, ebx
  000b9	74 2a		 je	 SHORT $LN63@ResourceUn
  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	57		 push	 edi
  000c0	53		 push	 ebx
  000c1	6a ff		 push	 -1
  000c3	ff 75 14	 push	 DWORD PTR _szType$[ebp]
  000c6	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000c9	6a 00		 push	 0
  000cb	6a 03		 push	 3
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  000d3	f7 d8		 neg	 eax
  000d5	1b c0		 sbb	 eax, eax
  000d7	23 c3		 and	 eax, ebx
  000d9	eb 0c		 jmp	 SHORT $LN43@ResourceUn
$LN60@ResourceUn:
  000db	68 16 02 07 80	 push	 -2147024362		; 80070216H
  000e0	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN66@ResourceUn:
$LN63@ResourceUn:
  000e5	33 c0		 xor	 eax, eax
$LN43@ResourceUn:

; 585  : #ifndef _UNICODE
; 586  : 	if (lpszT == NULL)

  000e7	85 c0		 test	 eax, eax
  000e9	74 17		 je	 SHORT $LN59@ResourceUn

; 587  : 	{
; 588  : 		return E_OUTOFMEMORY;
; 589  : 	}
; 590  : #endif // _UNICODE
; 591  : 	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), lpszT, FALSE);

  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	6a 00		 push	 0
  000f0	50		 push	 eax
  000f1	0f b7 45 10	 movzx	 eax, WORD PTR _nID$[ebp]
  000f5	50		 push	 eax
  000f6	ff 75 0c	 push	 DWORD PTR _szFileName$[ebp]
  000f9	e8 00 00 00 00	 call	 ?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z ; ATL::CRegObject::RegisterFromResource
  000fe	8b f8		 mov	 edi, eax
  00100	eb 05		 jmp	 SHORT $LN11@ResourceUn
$LN59@ResourceUn:
  00102	bf 0e 00 07 80	 mov	 edi, -2147024882	; 8007000eH
$LN11@ResourceUn:
  00107	85 f6		 test	 esi, esi
  00109	74 14		 je	 SHORT $LN50@ResourceUn
  0010b	0f 1f 44 00 00	 npad	 5
$LL49@ResourceUn:
  00110	56		 push	 esi
  00111	8b 36		 mov	 esi, DWORD PTR [esi]
  00113	e8 00 00 00 00	 call	 _free
  00118	83 c4 04	 add	 esp, 4
  0011b	85 f6		 test	 esi, esi
  0011d	75 f1		 jne	 SHORT $LL49@ResourceUn
$LN50@ResourceUn:
  0011f	8b c7		 mov	 eax, edi

; 592  : }

  00121	8d 65 d4	 lea	 esp, DWORD PTR [ebp-44]
  00124	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00127	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012e	59		 pop	 ecx
  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 10 00	 ret	 16			; 00000010H
$LN65@ResourceUn:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z ENDP	; ATL::CRegObject::ResourceUnregister
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z
_TEXT	SEGMENT
tv262 = -28						; size = 8
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_nID$ = 16						; size = 4
_szType$ = 20						; size = 4
?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z PROC	; ATL::CRegObject::ResourceRegister, COMDAT

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 544  : 	USES_CONVERSION_EX;

  0002b	33 f6		 xor	 esi, esi
  0002d	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi

; 545  : 
; 546  : 	LPCTSTR lpszT = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00030	8b 45 14	 mov	 eax, DWORD PTR _szType$[ebp]
  00033	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00036	85 c0		 test	 eax, eax
  00038	0f 84 c4 00 00
	00		 je	 $LN59@ResourceRe
  0003e	8b c8		 mov	 ecx, eax
  00040	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL62@ResourceRe:
  00043	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00046	83 c1 02	 add	 ecx, 2
  00049	66 85 c0	 test	 ax, ax
  0004c	75 f5		 jne	 SHORT $LL62@ResourceRe
  0004e	2b ca		 sub	 ecx, edx
  00050	d1 f9		 sar	 ecx, 1
  00052	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00055	b9 02 00 00 00	 mov	 ecx, 2
  0005a	f7 e9		 imul	 ecx
  0005c	8b f8		 mov	 edi, eax
  0005e	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  00063	83 d2 00	 adc	 edx, 0
  00066	89 55 e8	 mov	 DWORD PTR tv262[ebp+4], edx
  00069	75 7a		 jne	 SHORT $LN63@ResourceRe
  0006b	83 f8 ff	 cmp	 eax, -1
  0006e	77 75		 ja	 SHORT $LN63@ResourceRe
  00070	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  00076	7f 18		 jg	 SHORT $LN4@ResourceRe
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0007e	83 c4 04	 add	 esp, 4
  00081	84 c0		 test	 al, al
  00083	74 0b		 je	 SHORT $LN4@ResourceRe
  00085	8b c7		 mov	 eax, edi
  00087	e8 00 00 00 00	 call	 __alloca_probe_16
  0008c	8b dc		 mov	 ebx, esp
  0008e	eb 27		 jmp	 SHORT $LN24@ResourceRe
$LN4@ResourceRe:
  00090	8b c7		 mov	 eax, edi
  00092	f7 d0		 not	 eax
  00094	83 f8 08	 cmp	 eax, 8
  00097	72 42		 jb	 SHORT $LN60@ResourceRe
  00099	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _malloc
  000a2	83 c4 04	 add	 esp, 4
  000a5	85 c0		 test	 eax, eax
  000a7	74 3c		 je	 SHORT $LN63@ResourceRe
  000a9	8b f0		 mov	 esi, eax
  000ab	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000b1	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi
  000b4	8d 58 08	 lea	 ebx, DWORD PTR [eax+8]
$LN24@ResourceRe:
  000b7	85 db		 test	 ebx, ebx
  000b9	74 2a		 je	 SHORT $LN63@ResourceRe
  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	57		 push	 edi
  000c0	53		 push	 ebx
  000c1	6a ff		 push	 -1
  000c3	ff 75 14	 push	 DWORD PTR _szType$[ebp]
  000c6	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000c9	6a 00		 push	 0
  000cb	6a 03		 push	 3
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  000d3	f7 d8		 neg	 eax
  000d5	1b c0		 sbb	 eax, eax
  000d7	23 c3		 and	 eax, ebx
  000d9	eb 0c		 jmp	 SHORT $LN43@ResourceRe
$LN60@ResourceRe:
  000db	68 16 02 07 80	 push	 -2147024362		; 80070216H
  000e0	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN66@ResourceRe:
$LN63@ResourceRe:
  000e5	33 c0		 xor	 eax, eax
$LN43@ResourceRe:

; 547  : #ifndef _UNICODE
; 548  : 	if (lpszT == NULL)

  000e7	85 c0		 test	 eax, eax
  000e9	74 17		 je	 SHORT $LN59@ResourceRe

; 549  : 	{
; 550  : 		return E_OUTOFMEMORY;
; 551  : 	}
; 552  : #endif // _UNICODE
; 553  : 
; 554  : 	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), lpszT, TRUE);

  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	6a 01		 push	 1
  000f0	50		 push	 eax
  000f1	0f b7 45 10	 movzx	 eax, WORD PTR _nID$[ebp]
  000f5	50		 push	 eax
  000f6	ff 75 0c	 push	 DWORD PTR _szFileName$[ebp]
  000f9	e8 00 00 00 00	 call	 ?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z ; ATL::CRegObject::RegisterFromResource
  000fe	8b f8		 mov	 edi, eax
  00100	eb 05		 jmp	 SHORT $LN11@ResourceRe
$LN59@ResourceRe:
  00102	bf 0e 00 07 80	 mov	 edi, -2147024882	; 8007000eH
$LN11@ResourceRe:
  00107	85 f6		 test	 esi, esi
  00109	74 14		 je	 SHORT $LN50@ResourceRe
  0010b	0f 1f 44 00 00	 npad	 5
$LL49@ResourceRe:
  00110	56		 push	 esi
  00111	8b 36		 mov	 esi, DWORD PTR [esi]
  00113	e8 00 00 00 00	 call	 _free
  00118	83 c4 04	 add	 esp, 4
  0011b	85 f6		 test	 esi, esi
  0011d	75 f1		 jne	 SHORT $LL49@ResourceRe
$LN50@ResourceRe:
  0011f	8b c7		 mov	 eax, edi

; 555  : }

  00121	8d 65 d4	 lea	 esp, DWORD PTR [ebp-44]
  00124	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00127	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012e	59		 pop	 ecx
  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 10 00	 ret	 16			; 00000010H
$LN65@ResourceRe:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z ENDP	; ATL::CRegObject::ResourceRegister
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?StrFromMap@CRegObject@ATL@@QAEPB_WPAD@Z
_TEXT	SEGMENT
_lpszKey$ = 8						; size = 4
?StrFromMap@CRegObject@ATL@@QAEPB_WPAD@Z PROC		; ATL::CRegObject::StrFromMap, COMDAT
; _this$ = ecx

; 645  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 646  : 	m_csMap.Lock();

  00007	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  0000a	57		 push	 edi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 647  : 	LPCOLESTR lpsz = m_RepMap.Lookup(lpszKey);

  00011	8d 45 08	 lea	 eax, DWORD PTR _lpszKey$[ebp]
  00014	50		 push	 eax
  00015	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00018	e8 00 00 00 00	 call	 ?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup

; 648  : 	if (lpsz == NULL) // not found!!
; 649  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Map Entry not found\n"));
; 650  : 	m_csMap.Unlock();

  0001d	57		 push	 edi
  0001e	8b f0		 mov	 esi, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00026	5f		 pop	 edi

; 651  : 	return lpsz;

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi

; 652  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?StrFromMap@CRegObject@ATL@@QAEPB_WPAD@Z ENDP		; ATL::CRegObject::StrFromMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?ClearReplacements@CRegObject@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?ClearReplacements@CRegObject@ATL@@UAGJXZ PROC		; ATL::CRegObject::ClearReplacements, COMDAT

; 636  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 637  : 	m_csMap.Lock();

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	57		 push	 edi
  00008	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  0000b	57		 push	 edi
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 638  : 	HRESULT hr = m_RepMap.ClearReplacements();

  00012	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00015	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements

; 639  : 	m_csMap.Unlock();

  0001a	57		 push	 edi
  0001b	8b f0		 mov	 esi, eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00023	5f		 pop	 edi

; 640  : 	return hr;

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi

; 641  : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?ClearReplacements@CRegObject@ATL@@UAGJXZ ENDP		; ATL::CRegObject::ClearReplacements
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
_TEXT	SEGMENT
tv200 = -24						; size = 4
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszKey$ = 12						; size = 4
_lpszItem$ = 16						; size = 4
?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z PROC	; ATL::CRegObject::AddReplacement, COMDAT

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 420  : 	if (lpszKey == NULL || lpszItem == NULL)

  0002b	8b 5d 0c	 mov	 ebx, DWORD PTR _lpszKey$[ebp]
  0002e	85 db		 test	 ebx, ebx
  00030	0f 84 dd 00 00
	00		 je	 $LN3@AddReplace
  00036	83 7d 10 00	 cmp	 DWORD PTR _lpszItem$[ebp], 0
  0003a	0f 84 d3 00 00
	00		 je	 $LN3@AddReplace

; 422  : 	m_csMap.Lock();

  00040	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 c0 10	 add	 eax, 16			; 00000010H
  00046	50		 push	 eax
  00047	89 45 e8	 mov	 DWORD PTR tv200[ebp], eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 423  : 	USES_CONVERSION_EX;

  00050	33 f6		 xor	 esi, esi
  00052	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi

; 424  : 
; 425  : 	LPCTSTR lpszT = OLE2CT_EX(lpszKey, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00055	8b cb		 mov	 ecx, ebx
  00057	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  0005a	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0005d	0f 1f 00	 npad	 3
$LL48@AddReplace:
  00060	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00063	83 c1 02	 add	 ecx, 2
  00066	66 85 c0	 test	 ax, ax
  00069	75 f5		 jne	 SHORT $LL48@AddReplace
  0006b	2b ca		 sub	 ecx, edx
  0006d	d1 f9		 sar	 ecx, 1
  0006f	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00072	b9 02 00 00 00	 mov	 ecx, 2
  00077	f7 e9		 imul	 ecx
  00079	8b f8		 mov	 edi, eax
  0007b	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  00080	83 d2 00	 adc	 edx, 0
  00083	85 d2		 test	 edx, edx
  00085	77 69		 ja	 SHORT $LN47@AddReplace
  00087	72 05		 jb	 SHORT $LN49@AddReplace
  00089	83 f8 ff	 cmp	 eax, -1
  0008c	77 62		 ja	 SHORT $LN47@AddReplace
$LN49@AddReplace:
  0008e	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  00094	7f 18		 jg	 SHORT $LN6@AddReplace
  00096	57		 push	 edi
  00097	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0009c	83 c4 04	 add	 esp, 4
  0009f	84 c0		 test	 al, al
  000a1	74 0b		 je	 SHORT $LN6@AddReplace
  000a3	8b c7		 mov	 eax, edi
  000a5	e8 00 00 00 00	 call	 __alloca_probe_16
  000aa	8b c4		 mov	 eax, esp
  000ac	eb 0c		 jmp	 SHORT $LN7@AddReplace
$LN6@AddReplace:
  000ae	57		 push	 edi
  000af	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000b2	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  000b7	8b 75 ec	 mov	 esi, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN7@AddReplace:
  000ba	6a 03		 push	 3
  000bc	57		 push	 edi
  000bd	53		 push	 ebx
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper

; 426  : 
; 427  : #ifndef _UNICODE
; 428  : 	if(lpszT == NULL)

  000c4	85 c0		 test	 eax, eax
  000c6	74 28		 je	 SHORT $LN47@AddReplace

; 429  : 		return E_OUTOFMEMORY;
; 430  : #endif
; 431  : 
; 432  : 	BOOL bRet = m_RepMap.Add(lpszT, lpszItem);

  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	ff 75 10	 push	 DWORD PTR _lpszItem$[ebp]
  000ce	50		 push	 eax
  000cf	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  000d2	e8 00 00 00 00	 call	 ?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z ; ATL::CExpansionVector::Add

; 433  : 	m_csMap.Unlock();

  000d7	ff 75 e8	 push	 DWORD PTR tv200[ebp]
  000da	8b f8		 mov	 edi, eax
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 434  : 	return bRet ? S_OK : E_OUTOFMEMORY;

  000e2	33 c0		 xor	 eax, eax
  000e4	bb 0e 00 07 80	 mov	 ebx, -2147024882	; 8007000eH
  000e9	85 ff		 test	 edi, edi
  000eb	0f 45 d8	 cmovne	 ebx, eax
  000ee	eb 05		 jmp	 SHORT $LN13@AddReplace
$LN47@AddReplace:
  000f0	bb 0e 00 07 80	 mov	 ebx, -2147024882	; 8007000eH
$LN13@AddReplace:
  000f5	85 f6		 test	 esi, esi
  000f7	74 16		 je	 SHORT $LN37@AddReplace
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL36@AddReplace:
  00100	56		 push	 esi
  00101	8b 36		 mov	 esi, DWORD PTR [esi]
  00103	e8 00 00 00 00	 call	 _free
  00108	83 c4 04	 add	 esp, 4
  0010b	85 f6		 test	 esi, esi
  0010d	75 f1		 jne	 SHORT $LL36@AddReplace
$LN37@AddReplace:
  0010f	8b c3		 mov	 eax, ebx
  00111	eb 05		 jmp	 SHORT $LN1@AddReplace
$LN3@AddReplace:

; 421  : 		return E_INVALIDARG;

  00113	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN1@AddReplace:

; 435  : }

  00118	8d 65 d8	 lea	 esp, DWORD PTR [ebp-40]
  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00125	59		 pop	 ecx
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx
  00129	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012c	33 cd		 xor	 ecx, ebp
  0012e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ENDP	; ATL::CRegObject::AddReplacement
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?FinalRelease@CRegObject@ATL@@QAEXXZ
_TEXT	SEGMENT
?FinalRelease@CRegObject@ATL@@QAEXXZ PROC		; ATL::CRegObject::FinalRelease, COMDAT
; _this$ = ecx

; 343  : 	void FinalRelease() {}

  00000	c3		 ret	 0
?FinalRelease@CRegObject@ATL@@QAEXXZ ENDP		; ATL::CRegObject::FinalRelease
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?FinalConstruct@CRegObject@ATL@@QAEJXZ
_TEXT	SEGMENT
?FinalConstruct@CRegObject@ATL@@QAEJXZ PROC		; ATL::CRegObject::FinalConstruct, COMDAT
; _this$ = ecx

; 340  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 341  : 		return m_csMap.Init();

  00002	33 f6		 xor	 esi, esi
  00004	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
  00007	56		 push	 esi
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
  00010	85 c0		 test	 eax, eax
  00012	75 19		 jne	 SHORT $LN15@FinalConst
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0001a	8b f0		 mov	 esi, eax
  0001c	85 f6		 test	 esi, esi
  0001e	7e 0b		 jle	 SHORT $LN17@FinalConst
  00020	0f b7 f6	 movzx	 esi, si
  00023	81 ce 00 00 07
	80		 or	 esi, -2147024896	; 80070000H
  00029	85 f6		 test	 esi, esi
$LN17@FinalConst:
  0002b	78 04		 js	 SHORT $LN18@FinalConst
$LN15@FinalConst:
  0002d	c6 47 18 01	 mov	 BYTE PTR [edi+24], 1
$LN18@FinalConst:
  00031	5f		 pop	 edi
  00032	8b c6		 mov	 eax, esi
  00034	5e		 pop	 esi

; 342  : 	}

  00035	c3		 ret	 0
?FinalConstruct@CRegObject@ATL@@QAEJXZ ENDP		; ATL::CRegObject::FinalConstruct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ??1CRegObject@ATL@@UAE@XZ
_TEXT	SEGMENT
??1CRegObject@ATL@@UAE@XZ PROC				; ATL::CRegObject::~CRegObject, COMDAT
; _this$ = ecx

; 336  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 337  : 		ClearReplacements();

  00004	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CRegObject@ATL@@6B@
  0000d	57		 push	 edi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00014	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements
  0001c	57		 push	 edi
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 338  : 	}

  00023	80 7f 18 00	 cmp	 BYTE PTR [edi+24], 0
  00027	74 0b		 je	 SHORT $LN17@CRegObject
  00029	57		 push	 edi
  0002a	c6 47 18 00	 mov	 BYTE PTR [edi+24], 0
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
$LN17@CRegObject:
  00034	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00037	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements
  0003c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003f	85 c0		 test	 eax, eax
  00041	74 10		 je	 SHORT $LN35@CRegObject
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _free
  00049	83 c4 04	 add	 esp, 4
  0004c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN35@CRegObject:
  00053	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00056	85 c0		 test	 eax, eax
  00058	74 10		 je	 SHORT $LN42@CRegObject
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _free
  00060	83 c4 04	 add	 esp, 4
  00063	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN42@CRegObject:
  0006a	5f		 pop	 edi
  0006b	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00072	5e		 pop	 esi
  00073	c3		 ret	 0
??1CRegObject@ATL@@UAE@XZ ENDP				; ATL::CRegObject::~CRegObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?Release@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CRegObject@ATL@@UAGKXZ PROC			; ATL::CRegObject::Release, COMDAT

; 331  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
; 332  : 		return 0;

  00000	33 c0		 xor	 eax, eax

; 333  : 	}

  00002	c2 04 00	 ret	 4
?Release@CRegObject@ATL@@UAGKXZ ENDP			; ATL::CRegObject::Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?AddRef@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CRegObject@ATL@@UAGKXZ PROC			; ATL::CRegObject::AddRef, COMDAT

; 326  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
; 327  : 		return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 328  : 	}

  00005	c2 04 00	 ret	 4
?AddRef@CRegObject@ATL@@UAGKXZ ENDP			; ATL::CRegObject::AddRef
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::CRegObject::QueryInterface, COMDAT

; 320  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
; 321  : 		return E_NOTIMPL;

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 322  : 	}

  00005	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CRegObject::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ
_TEXT	SEGMENT
?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ PROC	; ATL::CRegParser::CParseBuffer::Detach, COMDAT
; _this$ = ecx

; 303  : 			LPTSTR lp = p;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 304  : 			p = NULL;

  00003	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 305  : 			nSize = nPos = 0;

  0000a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00010	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 306  : 			return lp;
; 307  : 		}

  00017	c3		 ret	 0
?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ ENDP	; ATL::CRegParser::CParseBuffer::Detach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpsz$ = 8						; size = 4
?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z PROC	; ATL::CRegParser::CParseBuffer::AddString, COMDAT
; _this$ = ecx

; 288  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d e8	 mov	 DWORD PTR _this$1$[ebp], ecx

; 289  : 			if (lpsz == NULL)

  0002e	8b 5d 08	 mov	 ebx, DWORD PTR _lpsz$[ebp]
  00031	85 db		 test	 ebx, ebx
  00033	75 07		 jne	 SHORT $LN2@AddString

; 290  : 			{
; 291  : 				return FALSE;

  00035	33 c0		 xor	 eax, eax
  00037	e9 b5 00 00 00	 jmp	 $LN1@AddString
$LN2@AddString:

; 292  : 			}
; 293  : 			USES_CONVERSION_EX;

  0003c	33 f6		 xor	 esi, esi
  0003e	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi

; 294  : 			LPCTSTR lpszT = OLE2CT_EX(lpsz, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00041	8b cb		 mov	 ecx, ebx
  00043	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00046	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL38@AddString:
  00050	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00053	83 c1 02	 add	 ecx, 2
  00056	66 85 c0	 test	 ax, ax
  00059	75 f5		 jne	 SHORT $LL38@AddString
  0005b	2b ca		 sub	 ecx, edx
  0005d	d1 f9		 sar	 ecx, 1
  0005f	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00062	b9 02 00 00 00	 mov	 ecx, 2
  00067	f7 e9		 imul	 ecx
  00069	8b f8		 mov	 edi, eax
  0006b	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  00070	83 d2 00	 adc	 edx, 0
  00073	85 d2		 test	 edx, edx
  00075	77 60		 ja	 SHORT $LN37@AddString
  00077	72 05		 jb	 SHORT $LN39@AddString
  00079	83 f8 ff	 cmp	 eax, -1
  0007c	77 59		 ja	 SHORT $LN37@AddString
$LN39@AddString:
  0007e	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  00084	7f 18		 jg	 SHORT $LN5@AddString
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0008c	83 c4 04	 add	 esp, 4
  0008f	84 c0		 test	 al, al
  00091	74 0b		 je	 SHORT $LN5@AddString
  00093	8b c7		 mov	 eax, edi
  00095	e8 00 00 00 00	 call	 __alloca_probe_16
  0009a	8b c4		 mov	 eax, esp
  0009c	eb 0c		 jmp	 SHORT $LN6@AddString
$LN5@AddString:
  0009e	57		 push	 edi
  0009f	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000a2	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  000a7	8b 75 ec	 mov	 esi, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN6@AddString:
  000aa	6a 03		 push	 3
  000ac	57		 push	 edi
  000ad	53		 push	 ebx
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000b4	8b d0		 mov	 edx, eax

; 295  : 			if (lpszT == NULL)

  000b6	85 d2		 test	 edx, edx
  000b8	74 1d		 je	 SHORT $LN37@AddString

; 296  : 			{
; 297  : 				return FALSE;
; 298  : 			}
; 299  : 			return Append(lpszT, (int)_tcslen(lpszT));

  000ba	8b ca		 mov	 ecx, edx
  000bc	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  000bf	90		 npad	 1
$LL40@AddString:
  000c0	8a 01		 mov	 al, BYTE PTR [ecx]
  000c2	41		 inc	 ecx
  000c3	84 c0		 test	 al, al
  000c5	75 f9		 jne	 SHORT $LL40@AddString
  000c7	2b cf		 sub	 ecx, edi
  000c9	51		 push	 ecx
  000ca	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ; ATL::CRegParser::CParseBuffer::Append
  000d3	8b f8		 mov	 edi, eax
  000d5	eb 02		 jmp	 SHORT $LN12@AddString
$LN37@AddString:
  000d7	33 ff		 xor	 edi, edi
$LN12@AddString:
  000d9	85 f6		 test	 esi, esi
  000db	74 12		 je	 SHORT $LN27@AddString
  000dd	0f 1f 00	 npad	 3
$LL26@AddString:
  000e0	56		 push	 esi
  000e1	8b 36		 mov	 esi, DWORD PTR [esi]
  000e3	e8 00 00 00 00	 call	 _free
  000e8	83 c4 04	 add	 esp, 4
  000eb	85 f6		 test	 esi, esi
  000ed	75 f1		 jne	 SHORT $LL26@AddString
$LN27@AddString:
  000ef	8b c7		 mov	 eax, edi
$LN1@AddString:

; 300  : 		}

  000f1	8d 65 d8	 lea	 esp, DWORD PTR [ebp-40]
  000f4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fe	59		 pop	 ecx
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx
  00102	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00105	33 cd		 xor	 ecx, ebp
  00107	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ENDP	; ATL::CRegParser::CParseBuffer::AddString
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z
_TEXT	SEGMENT
_pch$ = 8						; size = 4
?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z PROC	; ATL::CRegParser::CParseBuffer::AddChar, COMDAT
; _this$ = ecx

; 278  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 279  : #ifndef _UNICODE
; 280  : 			int nChars = int(CharNext(pch) - pch);

  00004	8b 75 08	 mov	 esi, DWORD PTR _pch$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4
  00011	2b c6		 sub	 eax, esi

; 281  : #else
; 282  : 			int nChars = 1;
; 283  : #endif
; 284  : 			return Append(pch, nChars);

  00013	8b cf		 mov	 ecx, edi
  00015	50		 push	 eax
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ; ATL::CRegParser::CParseBuffer::Append
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 285  : 
; 286  : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z ENDP	; ATL::CRegParser::CParseBuffer::AddChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z
_TEXT	SEGMENT
_pch$ = 8						; size = 4
_nChars$ = 12						; size = 4
?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z PROC	; ATL::CRegParser::CParseBuffer::Append, COMDAT
; _this$ = ecx

; 245  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 246  : 			ATLASSERT(p != NULL);
; 247  : 			ATLASSUME(p != NULL);
; 248  : 			int newSize = nPos + nChars + 1;

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _nChars$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000d	03 0e		 add	 ecx, DWORD PTR [esi]

; 249  : 			if ((newSize <= nPos) || (newSize <= nChars))

  0000f	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00011	7e 7a		 jle	 SHORT $LN8@Append
  00013	3b cf		 cmp	 ecx, edi
  00015	7e 76		 jle	 SHORT $LN8@Append

; 251  : 
; 252  : 			if (newSize >= nSize)

  00017	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  0001a	7c 33		 jl	 SHORT $LN9@Append
  0001c	0f 1f 40 00	 npad	 4
$LL5@Append:

; 253  : 			{
; 254  : 				while (newSize >= nSize) {
; 255  : 					if (nSize > INT_MAX / 2)

  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00028	7f 63		 jg	 SHORT $LN8@Append

; 256  : 					return FALSE;
; 257  : 					nSize *= 2;

  0002a	03 c0		 add	 eax, eax
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002f	3b c8		 cmp	 ecx, eax
  00031	7d ed		 jge	 SHORT $LL5@Append

; 258  : 				}
; 259  : 				LPTSTR pTemp = (LPTSTR)::ATL::AtlCoTaskMemRecalloc(p, nSize, sizeof(TCHAR));

  00033	33 c9		 xor	 ecx, ecx
  00035	77 56		 ja	 SHORT $LN8@Append
  00037	72 05		 jb	 SHORT $LN32@Append
  00039	83 f8 ff	 cmp	 eax, -1
  0003c	77 4f		 ja	 SHORT $LN8@Append
$LN32@Append:
  0003e	50		 push	 eax
  0003f	ff 76 08	 push	 DWORD PTR [esi+8]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemRealloc@8

; 260  : 				if (pTemp == NULL)

  00048	85 c0		 test	 eax, eax
  0004a	74 41		 je	 SHORT $LN8@Append

; 261  : 					return FALSE;
; 262  : 				p = pTemp;

  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN9@Append:

; 263  : 			}
; 264  : 			if ((nPos < 0) || (nPos >= nSize) || nSize - nPos > nSize)

  0004f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00051	85 c9		 test	 ecx, ecx
  00053	78 38		 js	 SHORT $LN8@Append
  00055	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00058	3b ca		 cmp	 ecx, edx
  0005a	7d 31		 jge	 SHORT $LN8@Append
  0005c	8b c2		 mov	 eax, edx
  0005e	2b c1		 sub	 eax, ecx
  00060	3b c2		 cmp	 eax, edx
  00062	7f 29		 jg	 SHORT $LN8@Append

; 265  : 				return FALSE;
; 266  : 
; 267  : #pragma warning(push)
; 268  : #pragma warning(disable: 22008)
; 269  : 			/* Prefast false warning is fired here despite the all above checks */
; 270  : 			Checked::memcpy_s(p + nPos, (nSize-nPos) * sizeof(TCHAR), pch, nChars * sizeof(TCHAR));

  00064	57		 push	 edi
  00065	ff 75 08	 push	 DWORD PTR _pch$[ebp]
  00068	50		 push	 eax
  00069	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006c	03 c1		 add	 eax, ecx
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s

; 271  : 			nPos += nChars;
; 272  : 			*(p + nPos) = _T('\0');

  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00077	83 c4 10	 add	 esp, 16			; 00000010H
  0007a	01 3e		 add	 DWORD PTR [esi], edi
  0007c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 273  : #pragma warning(pop)
; 274  : 			return TRUE;

  00084	b8 01 00 00 00	 mov	 eax, 1

; 275  : 		}

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8
$LN8@Append:
  0008d	5f		 pop	 edi

; 250  : 				return FALSE;

  0008e	33 c0		 xor	 eax, eax
  00090	5e		 pop	 esi

; 275  : 		}

  00091	5d		 pop	 ebp
  00092	c2 08 00	 ret	 8
?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ENDP	; ATL::CRegParser::CParseBuffer::Append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ??1CParseBuffer@CRegParser@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CParseBuffer@CRegParser@ATL@@QAE@XZ PROC		; ATL::CRegParser::CParseBuffer::~CParseBuffer, COMDAT
; _this$ = ecx

; 240  : 			CoTaskMemFree(p);

  00000	ff 71 08	 push	 DWORD PTR [ecx+8]
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4

; 241  : 		}

  00009	c3		 ret	 0
??1CParseBuffer@CRegParser@ATL@@QAE@XZ ENDP		; ATL::CRegParser::CParseBuffer::~CParseBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ??0CParseBuffer@CRegParser@ATL@@QAE@H@Z
_TEXT	SEGMENT
_nInitial$ = 8						; size = 4
??0CParseBuffer@CRegParser@ATL@@QAE@H@Z PROC		; ATL::CRegParser::CParseBuffer::CParseBuffer, COMDAT
; _this$ = ecx

; 228  : 		CParseBuffer(_In_ int nInitial)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 7d 08 64	 cmp	 DWORD PTR _nInitial$[ebp], 100 ; 00000064H
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0000f	0f 4d 4d 08	 cmovge	 ecx, DWORD PTR _nInitial$[ebp]

; 229  : 		{
; 230  : 			if (nInitial < 100)
; 231  : 				nInitial = 1000;
; 232  : 			nPos = 0;
; 233  : 			nSize = nInitial;
; 234  : 			p = (LPTSTR) ::ATL::AtlCoTaskMemCAlloc(nSize,static_cast<ULONG>(sizeof(TCHAR)));

  00013	33 c0		 xor	 eax, eax
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0001b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0001e	77 0e		 ja	 SHORT $LN16@CParseBuff
  00020	83 f9 ff	 cmp	 ecx, -1
  00023	77 09		 ja	 SHORT $LN16@CParseBuff
  00025	51		 push	 ecx
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemAlloc@4
  0002c	eb 02		 jmp	 SHORT $LN5@CParseBuff
$LN16@CParseBuff:
  0002e	33 c0		 xor	 eax, eax
$LN5@CParseBuff:
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 235  : 			if (p != NULL)

  00033	85 c0		 test	 eax, eax
  00035	74 03		 je	 SHORT $LN17@CParseBuff

; 236  : 				*p = _T('\0');

  00037	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN17@CParseBuff:

; 237  : 		}

  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??0CParseBuffer@CRegParser@ATL@@QAE@H@Z ENDP		; ATL::CRegParser::CParseBuffer::CParseBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z
_TEXT	SEGMENT
_szValueType$ = 8					; size = 4
_vt$ = 12						; size = 4
?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z PROC		; ATL::CRegParser::VTFromRegType, COMDAT

; 754  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 755  : 	struct typemap
; 756  : 	{
; 757  : 		LPCTSTR lpsz;
; 758  : 		VARTYPE vt;
; 759  : 	};
; 760  : #pragma warning (push)
; 761  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 762  : 
; 763  : 	static const typemap map[] = {

  00003	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  0000f	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4HA ; TSS0<`template-parameter-2',ATL::CRegParser::TFromRegType,unsigned long,int,char const *,unsigned short &>
  00017	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  0001d	7f 44		 jg	 SHORT $LN13@VTFromRegT
$LN2@VTFromRegT:
  0001f	53		 push	 ebx

; 768  : 	};
; 769  : 
; 770  : #pragma warning (pop)
; 771  : 
; 772  : 	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)

  00020	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__lstrcmpiA@8
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	8b 7d 08	 mov	 edi, DWORD PTR _szValueType$[ebp]
  0002b	33 f6		 xor	 esi, esi
  0002d	0f 1f 00	 npad	 3
$LL5@VTFromRegT:

; 773  : 	{
; 774  : 		if (!lstrcmpi(szValueType, map[i].lpsz))

  00030	ff 34 f5 00 00
	00 00		 push	 DWORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B[esi*8]
  00037	57		 push	 edi
  00038	ff d3		 call	 ebx
  0003a	85 c0		 test	 eax, eax
  0003c	74 0d		 je	 SHORT $LN9@VTFromRegT

; 768  : 	};
; 769  : 
; 770  : #pragma warning (pop)
; 771  : 
; 772  : 	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)

  0003e	46		 inc	 esi
  0003f	83 fe 04	 cmp	 esi, 4
  00042	72 ec		 jb	 SHORT $LL5@VTFromRegT

; 778  : 		}
; 779  : 	}
; 780  : 
; 781  : 	return FALSE;

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	33 c0		 xor	 eax, eax
  00048	5b		 pop	 ebx

; 782  : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN9@VTFromRegT:

; 775  : 		{
; 776  : 			vt = map[i].vt;

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _vt$[ebp]
  0004e	66 8b 0c f5 04
	00 00 00	 mov	 cx, WORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B[esi*8+4]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	66 89 08	 mov	 WORD PTR [eax], cx

; 777  : 			return TRUE;

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	5b		 pop	 ebx

; 782  : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
$LN13@VTFromRegT:

; 755  : 	struct typemap
; 756  : 	{
; 757  : 		LPCTSTR lpsz;
; 758  : 		VARTYPE vt;
; 759  : 	};
; 760  : #pragma warning (push)
; 761  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 762  : 
; 763  : 	static const typemap map[] = {

  00063	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4HA ; TSS0<`template-parameter-2',ATL::CRegParser::TFromRegType,unsigned long,int,char const *,unsigned short &>
  00068	e8 00 00 00 00	 call	 __Init_thread_header
  0006d	83 c4 04	 add	 esp, 4
  00070	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4HA, -1 ; TSS0<`template-parameter-2',ATL::CRegParser::TFromRegType,unsigned long,int,char const *,unsigned short &>
  00077	75 a6		 jne	 SHORT $LN2@VTFromRegT

; 764  : 		{szStringVal, VT_BSTR},

  00079	b8 08 00 00 00	 mov	 eax, 8
  0007e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B, OFFSET ??_C@_01CPLAODJH@S?$AA@
  00088	66 a3 04 00 00
	00		 mov	 WORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+4, ax

; 765  : 		{multiszStringVal, VT_BSTR | VT_BYREF},

  0008e	b8 08 40 00 00	 mov	 eax, 16392		; 00004008H
  00093	66 a3 0c 00 00
	00		 mov	 WORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+12, ax

; 766  : 		{szDwordVal,  VT_UI4},

  00099	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  0009e	66 a3 14 00 00
	00		 mov	 WORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+20, ax

; 767  : 		{szBinaryVal, VT_UI1}

  000a4	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  000a9	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4HA ; TSS0<`template-parameter-2',ATL::CRegParser::TFromRegType,unsigned long,int,char const *,unsigned short &>
  000ae	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+8, OFFSET ??_C@_01PLPBNMEI@M?$AA@
  000b8	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+16, OFFSET ??_C@_01CKDDGHAB@D?$AA@
  000c2	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+24, OFFSET ??_C@_01HMGJMAIH@B?$AA@
  000cc	66 a3 1c 00 00
	00		 mov	 WORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+28, ax
  000d2	e8 00 00 00 00	 call	 __Init_thread_footer
  000d7	83 c4 04	 add	 esp, 4
  000da	e9 40 ff ff ff	 jmp	 $LN2@VTFromRegT
?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z ENDP		; ATL::CRegParser::VTFromRegType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?ChToByte@CRegParser@ATL@@KAED@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 1
?ChToByte@CRegParser@ATL@@KAED@Z PROC			; ATL::CRegParser::ChToByte, COMDAT

; 785  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 786  : 	switch (ch)

  00003	8a 55 08	 mov	 dl, BYTE PTR _ch$[ebp]
  00006	0f be c2	 movsx	 eax, dl
  00009	83 c0 d0	 add	 eax, -48		; ffffffd0H
  0000c	83 f8 36	 cmp	 eax, 54			; 00000036H
  0000f	77 1d		 ja	 SHORT $LN7@ChToByte
  00011	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN9@ChToByte[eax]
  00018	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN11@ChToByte[ecx*4]
$LN4@ChToByte:

; 787  : 	{
; 788  : 		case '0':
; 789  : 		case '1':
; 790  : 		case '2':
; 791  : 		case '3':
; 792  : 		case '4':
; 793  : 		case '5':
; 794  : 		case '6':
; 795  : 		case '7':
; 796  : 		case '8':
; 797  : 		case '9':
; 798  : 				return (BYTE) (ch - '0');

  0001f	8d 42 d0	 lea	 eax, DWORD PTR [edx-48]

; 817  : 	}
; 818  : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
$LN5@ChToByte:

; 799  : 		case 'A':
; 800  : 		case 'B':
; 801  : 		case 'C':
; 802  : 		case 'D':
; 803  : 		case 'E':
; 804  : 		case 'F':
; 805  : 				return (BYTE) (10 + (ch - 'A'));

  00024	8d 42 c9	 lea	 eax, DWORD PTR [edx-55]

; 817  : 	}
; 818  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN6@ChToByte:

; 806  : 		case 'a':
; 807  : 		case 'b':
; 808  : 		case 'c':
; 809  : 		case 'd':
; 810  : 		case 'e':
; 811  : 		case 'f':
; 812  : 				return (BYTE) (10 + (ch - 'a'));

  00029	8d 42 a9	 lea	 eax, DWORD PTR [edx-87]

; 817  : 	}
; 818  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN7@ChToByte:

; 813  : 		default:
; 814  : 				ATLASSERT(FALSE);
; 815  : 				ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %Tc passed as binary Hex value\n"), ch);
; 816  : 				return 0;

  0002e	32 c0		 xor	 al, al

; 817  : 	}
; 818  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
  00032	66 90		 npad	 2
$LN11@ChToByte:
  00034	00 00 00 00	 DD	 $LN4@ChToByte
  00038	00 00 00 00	 DD	 $LN5@ChToByte
  0003c	00 00 00 00	 DD	 $LN6@ChToByte
  00040	00 00 00 00	 DD	 $LN7@ChToByte
$LN9@ChToByte:
  00044	00		 DB	 0
  00045	00		 DB	 0
  00046	00		 DB	 0
  00047	00		 DB	 0
  00048	00		 DB	 0
  00049	00		 DB	 0
  0004a	00		 DB	 0
  0004b	00		 DB	 0
  0004c	00		 DB	 0
  0004d	00		 DB	 0
  0004e	03		 DB	 3
  0004f	03		 DB	 3
  00050	03		 DB	 3
  00051	03		 DB	 3
  00052	03		 DB	 3
  00053	03		 DB	 3
  00054	03		 DB	 3
  00055	01		 DB	 1
  00056	01		 DB	 1
  00057	01		 DB	 1
  00058	01		 DB	 1
  00059	01		 DB	 1
  0005a	01		 DB	 1
  0005b	03		 DB	 3
  0005c	03		 DB	 3
  0005d	03		 DB	 3
  0005e	03		 DB	 3
  0005f	03		 DB	 3
  00060	03		 DB	 3
  00061	03		 DB	 3
  00062	03		 DB	 3
  00063	03		 DB	 3
  00064	03		 DB	 3
  00065	03		 DB	 3
  00066	03		 DB	 3
  00067	03		 DB	 3
  00068	03		 DB	 3
  00069	03		 DB	 3
  0006a	03		 DB	 3
  0006b	03		 DB	 3
  0006c	03		 DB	 3
  0006d	03		 DB	 3
  0006e	03		 DB	 3
  0006f	03		 DB	 3
  00070	03		 DB	 3
  00071	03		 DB	 3
  00072	03		 DB	 3
  00073	03		 DB	 3
  00074	03		 DB	 3
  00075	02		 DB	 2
  00076	02		 DB	 2
  00077	02		 DB	 2
  00078	02		 DB	 2
  00079	02		 DB	 2
  0007a	02		 DB	 2
?ChToByte@CRegParser@ATL@@KAED@Z ENDP			; ATL::CRegParser::ChToByte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z
_TEXT	SEGMENT
_szToken$ = 8						; size = 4
?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z PROC	; ATL::CRegParser::HKeyFromString, COMDAT

; 821  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 822  : 	struct keymap
; 823  : 	{
; 824  : 		LPCTSTR lpsz;
; 825  : 		HKEY hkey;
; 826  : 	};
; 827  : 	static const keymap map[] = {
; 828  : 		{_T("HKCR"), HKEY_CLASSES_ROOT},
; 829  : 		{_T("HKCU"), HKEY_CURRENT_USER},
; 830  : 		{_T("HKLM"), HKEY_LOCAL_MACHINE},
; 831  : 		{_T("HKU"),  HKEY_USERS},
; 832  : 		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
; 833  : 		{_T("HKDD"), HKEY_DYN_DATA},
; 834  : 		{_T("HKCC"), HKEY_CURRENT_CONFIG},
; 835  : 		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
; 836  : 		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
; 837  : 		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
; 838  : 		{_T("HKEY_USERS"), HKEY_USERS},
; 839  : 		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
; 840  : 		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
; 841  : 		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
; 842  : 	};
; 843  : 
; 844  : 	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__lstrcmpiA@8
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _szToken$[ebp]
  0000f	33 f6		 xor	 esi, esi
$LL4@HKeyFromSt:

; 845  : 	{
; 846  : 		if (!lstrcmpi(szToken, map[i].lpsz))

  00011	ff 34 f5 00 00
	00 00		 push	 DWORD PTR ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B[esi*8]
  00018	57		 push	 edi
  00019	ff d3		 call	 ebx
  0001b	85 c0		 test	 eax, eax
  0001d	74 0d		 je	 SHORT $LN8@HKeyFromSt

; 822  : 	struct keymap
; 823  : 	{
; 824  : 		LPCTSTR lpsz;
; 825  : 		HKEY hkey;
; 826  : 	};
; 827  : 	static const keymap map[] = {
; 828  : 		{_T("HKCR"), HKEY_CLASSES_ROOT},
; 829  : 		{_T("HKCU"), HKEY_CURRENT_USER},
; 830  : 		{_T("HKLM"), HKEY_LOCAL_MACHINE},
; 831  : 		{_T("HKU"),  HKEY_USERS},
; 832  : 		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
; 833  : 		{_T("HKDD"), HKEY_DYN_DATA},
; 834  : 		{_T("HKCC"), HKEY_CURRENT_CONFIG},
; 835  : 		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
; 836  : 		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
; 837  : 		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
; 838  : 		{_T("HKEY_USERS"), HKEY_USERS},
; 839  : 		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
; 840  : 		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
; 841  : 		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
; 842  : 	};
; 843  : 
; 844  : 	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)

  0001f	46		 inc	 esi
  00020	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00023	72 ec		 jb	 SHORT $LL4@HKeyFromSt

; 848  : 	}
; 849  : 	return NULL;

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	33 c0		 xor	 eax, eax
  00029	5b		 pop	 ebx

; 850  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN8@HKeyFromSt:

; 847  : 			return map[i].hkey;

  0002c	8b 04 f5 04 00
	00 00		 mov	 eax, DWORD PTR ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B[esi*8+4]
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 850  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z ENDP	; ATL::CRegParser::HKeyFromString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?StrChrA@CRegParser@ATL@@KAPADPADD@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
_ch$ = 12						; size = 1
?StrChrA@CRegParser@ATL@@KAPADPADD@Z PROC		; ATL::CRegParser::StrChrA, COMDAT

; 855  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 856  : 	LPTSTR p = NULL;
; 857  : 
; 858  : 	if (lpsz == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpsz$[ebp]
  00006	56		 push	 esi
  00007	33 f6		 xor	 esi, esi
  00009	85 c0		 test	 eax, eax
  0000b	75 03		 jne	 SHORT $LN7@StrChrA
  0000d	5e		 pop	 esi

; 871  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN7@StrChrA:

; 859  : 		return NULL;
; 860  : 
; 861  : 	while (*lpsz)

  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	84 c9		 test	 cl, cl
  00014	74 23		 je	 SHORT $LN3@StrChrA
  00016	53		 push	 ebx
  00017	8a 5d 0c	 mov	 bl, BYTE PTR _ch$[ebp]
  0001a	57		 push	 edi
  0001b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CharNextA@4
$LL2@StrChrA:

; 862  : 	{
; 863  : 		if (*lpsz == ch)

  00021	3a cb		 cmp	 cl, bl
  00023	74 10		 je	 SHORT $LN8@StrChrA

; 866  : 			break;
; 867  : 		}
; 868  : 		lpsz = CharNext(lpsz);

  00025	50		 push	 eax
  00026	ff d7		 call	 edi
  00028	8a 08		 mov	 cl, BYTE PTR [eax]
  0002a	84 c9		 test	 cl, cl
  0002c	75 f3		 jne	 SHORT $LL2@StrChrA

; 869  : 	}
; 870  : 	return p;

  0002e	5f		 pop	 edi
  0002f	5b		 pop	 ebx
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi

; 871  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN8@StrChrA:
  00035	5f		 pop	 edi

; 864  : 		{
; 865  : 			p = lpsz;

  00036	8b f0		 mov	 esi, eax
  00038	5b		 pop	 ebx
$LN3@StrChrA:

; 869  : 	}
; 870  : 	return p;

  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi

; 871  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?StrChrA@CRegParser@ATL@@KAPADPADD@Z ENDP		; ATL::CRegParser::StrChrA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?EndOfVar@CRegParser@ATL@@IAEHXZ
_TEXT	SEGMENT
?EndOfVar@CRegParser@ATL@@IAEHXZ PROC			; ATL::CRegParser::EndOfVar, COMDAT
; _this$ = ecx

; 210  : 		return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  00005	75 12		 jne	 SHORT $LN3@EndOfVar
  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4
  0000e	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  00011	74 06		 je	 SHORT $LN3@EndOfVar
  00013	b8 01 00 00 00	 mov	 eax, 1

; 211  : 	}

  00018	c3		 ret	 0
$LN3@EndOfVar:

; 210  : 		return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur);

  00019	33 c0		 xor	 eax, eax

; 211  : 	}

  0001b	c3		 ret	 0
?EndOfVar@CRegParser@ATL@@IAEHXZ ENDP			; ATL::CRegParser::EndOfVar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z
_TEXT	SEGMENT
_szValue$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_szToken$ = 8						; size = 4
?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z PROC		; ATL::CRegParser::SkipAssignment, COMDAT
; _this$ = ecx

; 1151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 10 00 00	 mov	 eax, 4100		; 00001004H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _szToken$[ebp]
  0001c	8b f1		 mov	 esi, ecx

; 1152 : 	HRESULT hr;
; 1153 : 	TCHAR szValue[MAX_VALUE];
; 1154 : 
; 1155 : 	if (*szToken == chEquals)

  0001e	80 3f 3d	 cmp	 BYTE PTR [edi], 61	; 0000003dH
  00021	75 2f		 jne	 SHORT $LN5@SkipAssign

; 1156 : 	{
; 1157 : 		if (FAILED(hr = NextToken(szToken)))

  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00029	85 c0		 test	 eax, eax
  0002b	78 27		 js	 SHORT $LN1@SkipAssign

; 1158 : 			return hr;
; 1159 : 		// Skip assignment
; 1160 : 		SkipWhiteSpace();

  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace

; 1161 : 		if (FAILED(hr = NextToken(szValue)))

  00034	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  0003a	8b ce		 mov	 ecx, esi
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00042	85 c0		 test	 eax, eax
  00044	78 0e		 js	 SHORT $LN1@SkipAssign

; 1162 : 			return hr;
; 1163 : 		if (FAILED(hr = NextToken(szToken)))

  00046	57		 push	 edi
  00047	8b ce		 mov	 ecx, esi
  00049	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  0004e	85 c0		 test	 eax, eax
  00050	78 02		 js	 SHORT $LN1@SkipAssign
$LN5@SkipAssign:

; 1164 : 			return hr;
; 1165 : 	}
; 1166 : 
; 1167 : 	return S_OK;

  00052	33 c0		 xor	 eax, eax
$LN1@SkipAssign:

; 1168 : }

  00054	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00057	5f		 pop	 edi
  00058	33 cd		 xor	 ecx, ebp
  0005a	5e		 pop	 esi
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ENDP		; ATL::CRegParser::SkipAssignment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?GenerateError@CRegParser@ATL@@IAEJI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?GenerateError@CRegParser@ATL@@IAEJI@Z PROC		; ATL::CRegParser::GenerateError, COMDAT
; _this$ = ecx

; 203  : 		return DISP_E_EXCEPTION;

  00000	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H

; 204  : 	}

  00005	c2 04 00	 ret	 4
?GenerateError@CRegParser@ATL@@IAEJI@Z ENDP		; ATL::CRegParser::GenerateError
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?IsSpace@CRegParser@ATL@@IAEHD@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 1
?IsSpace@CRegParser@ATL@@IAEHD@Z PROC			; ATL::CRegParser::IsSpace, COMDAT
; _this$ = ecx

; 880  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 881  : 	switch (ch)

  00003	0f be 45 08	 movsx	 eax, BYTE PTR _ch$[ebp]
  00007	83 c0 f7	 add	 eax, -9			; fffffff7H
  0000a	83 f8 17	 cmp	 eax, 23			; 00000017H
  0000d	77 17		 ja	 SHORT $LN2@IsSpace
  0000f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN6@IsSpace[eax]
  00016	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN8@IsSpace[eax*4]
$LN4@IsSpace:

; 882  : 	{
; 883  : 		case _T(' '):
; 884  : 		case _T('\t'):
; 885  : 		case _T('\r'):
; 886  : 		case _T('\n'):
; 887  : 				return TRUE;

  0001d	b8 01 00 00 00	 mov	 eax, 1

; 891  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN2@IsSpace:

; 888  : 	}
; 889  : 
; 890  : 	return FALSE;

  00026	33 c0		 xor	 eax, eax

; 891  : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN8@IsSpace:
  0002c	00 00 00 00	 DD	 $LN4@IsSpace
  00030	00 00 00 00	 DD	 $LN2@IsSpace
$LN6@IsSpace:
  00034	00		 DB	 0
  00035	00		 DB	 0
  00036	01		 DB	 1
  00037	01		 DB	 1
  00038	00		 DB	 0
  00039	01		 DB	 1
  0003a	01		 DB	 1
  0003b	01		 DB	 1
  0003c	01		 DB	 1
  0003d	01		 DB	 1
  0003e	01		 DB	 1
  0003f	01		 DB	 1
  00040	01		 DB	 1
  00041	01		 DB	 1
  00042	01		 DB	 1
  00043	01		 DB	 1
  00044	01		 DB	 1
  00045	01		 DB	 1
  00046	01		 DB	 1
  00047	01		 DB	 1
  00048	01		 DB	 1
  00049	01		 DB	 1
  0004a	01		 DB	 1
  0004b	00		 DB	 0
?IsSpace@CRegParser@ATL@@IAEHD@Z ENDP			; ATL::CRegParser::IsSpace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
_TEXT	SEGMENT
_rkParent$2 = -4448					; size = 12
_rkParent$3 = -4436					; size = 12
_rk$4 = -4424						; size = 12
_bRecover$3$ = -4412					; size = 4
_rkForceRemove$5 = -4408				; size = 12
_bDelete$1$ = -4396					; size = 4
_keyCur$ = -4392					; size = 12
_hkParent$GSCopy$1$ = -4380				; size = 4
_this$GSCopy$1$ = -4376					; size = 4
_szValueName$6 = -4372					; size = 4096
_szKey$ = -276						; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_szToken$ = 8						; size = 4
_hkParent$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_bRecover$ = 20						; size = 4
?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z PROC ; ATL::CRegParser::RegisterSubkeys, COMDAT
; _this$ = ecx

; 1411 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 54 11 00 00	 mov	 eax, 4436		; 00001154H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 85 e8 ee ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _hkParent$[ebp]
  0003d	8b 7d 08	 mov	 edi, DWORD PTR _szToken$[ebp]
  00040	89 8d e4 ee ff
	ff		 mov	 DWORD PTR _hkParent$GSCopy$1$[ebp], ecx

; 1412 : 	CRegKey keyCur;

  00046	c7 85 d8 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _keyCur$[ebp], 0
  00050	c7 85 dc ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _keyCur$[ebp+4], 0
  0005a	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _keyCur$[ebp+8], 0

; 1413 : 	LONG    lRes;
; 1414 : 	TCHAR  szKey[_MAX_PATH];
; 1415 : 	BOOL    bDelete = TRUE;
; 1416 : 	BOOL    bInRecovery = bRecover;
; 1417 : 	HRESULT hr = S_OK;
; 1418 : 
; 1419 : 	ATLTRACE(atlTraceRegistrar, 2, _T("Num Els = %d\n"), cbNeverDelete);
; 1420 : 	if (FAILED(hr = NextToken(szToken)))

  00064	57		 push	 edi
  00065	8b c8		 mov	 ecx, eax
  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006e	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00073	8b f0		 mov	 esi, eax
  00075	85 f6		 test	 esi, esi
  00077	0f 88 72 06 00
	00		 js	 $LN167@RegisterSu

; 1421 : 		return hr;
; 1422 : 
; 1423 : 	while (*szToken != chRightBracket) // Continue till we see a }

  0007d	80 3f 7d	 cmp	 BYTE PTR [edi], 125	; 0000007dH
  00080	0f 84 56 06 00
	00		 je	 $LN217@RegisterSu
  00086	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@RegisterSu:

; 1424 : 	{
; 1425 : 		bDelete = TRUE;
; 1426 : 		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_06JBKGCNBB@Delete?$AA@
  00095	57		 push	 edi
  00096	c7 85 d4 ee ff
	ff 01 00 00 00	 mov	 DWORD PTR _bDelete$1$[ebp], 1
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  000a6	f7 d8		 neg	 eax

; 1427 : 
; 1428 : 		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)

  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DBGDLGLL@ForceRemove?$AA@
  000ad	1b db		 sbb	 ebx, ebx
  000af	57		 push	 edi
  000b0	43		 inc	 ebx
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  000b7	85 c0		 test	 eax, eax
  000b9	74 08		 je	 SHORT $LN6@RegisterSu
  000bb	85 db		 test	 ebx, ebx
  000bd	0f 84 18 01 00
	00		 je	 $LN8@RegisterSu
$LN6@RegisterSu:

; 1429 : 		{
; 1430 : 			if (FAILED(hr = NextToken(szToken)))

  000c3	8b 8d e8 ee ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000c9	57		 push	 edi
  000ca	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  000cf	8b f0		 mov	 esi, eax
  000d1	85 f6		 test	 esi, esi
  000d3	0f 88 03 06 00
	00		 js	 $LN217@RegisterSu

; 1431 : 				break;
; 1432 : 
; 1433 : 			if (bRegister)

  000d9	83 7d 10 00	 cmp	 DWORD PTR _bRegister$[ebp], 0
  000dd	0f 84 f8 00 00
	00		 je	 $LN8@RegisterSu

; 1434 : 			{
; 1435 : 				CRegKey rkForceRemove;
; 1436 : 
; 1437 : 				if (StrChr(szToken, chDirSep) != NULL)

  000e3	8a 07		 mov	 al, BYTE PTR [edi]
  000e5	8b cf		 mov	 ecx, edi
  000e7	c7 85 c8 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkForceRemove$5[ebp], 0
  000f1	c7 85 cc ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkForceRemove$5[ebp+4], 0
  000fb	c7 85 d0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkForceRemove$5[ebp+8], 0
  00105	84 c0		 test	 al, al
  00107	74 24		 je	 SHORT $LN214@RegisterSu
  00109	0f 1f 80 00 00
	00 00		 npad	 7
$LL78@RegisterSu:
  00110	3c 5c		 cmp	 al, 92			; 0000005cH
  00112	74 11		 je	 SHORT $LN177@RegisterSu
  00114	51		 push	 ecx
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4
  0011b	8b c8		 mov	 ecx, eax
  0011d	8a 01		 mov	 al, BYTE PTR [ecx]
  0011f	84 c0		 test	 al, al
  00121	75 ed		 jne	 SHORT $LL78@RegisterSu

; 1655 : 					break;
; 1656 : 				if (FAILED(hr = NextToken(szToken)))

  00123	eb 08		 jmp	 SHORT $LN214@RegisterSu
$LN177@RegisterSu:

; 1434 : 			{
; 1435 : 				CRegKey rkForceRemove;
; 1436 : 
; 1437 : 				if (StrChr(szToken, chDirSep) != NULL)

  00125	85 c9		 test	 ecx, ecx
  00127	0f 85 48 05 00
	00		 jne	 $LN181@RegisterSu
$LN214@RegisterSu:

; 1439 : 
; 1440 : 				if (CanForceRemoveKey(szToken))

  0012d	be 00 00 00 00	 mov	 esi, OFFSET ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB ; ATL::CRegParser::rgszNeverDelete
$LL88@RegisterSu:
  00132	ff 36		 push	 DWORD PTR [esi]
  00134	57		 push	 edi
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  0013b	85 c0		 test	 eax, eax
  0013d	74 55		 je	 SHORT $LN10@RegisterSu
  0013f	83 c6 04	 add	 esi, 4
  00142	81 fe 30 00 00
	00		 cmp	 esi, OFFSET ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB+48
  00148	7c e8		 jl	 SHORT $LL88@RegisterSu

; 1441 : 				{
; 1442 : 					rkForceRemove.Attach(hkParent);

  0014a	8b 85 e4 ee ff
	ff		 mov	 eax, DWORD PTR _hkParent$GSCopy$1$[ebp]

; 1443 : 					// Error not returned. We will overwrite the values any way.
; 1444 : 					rkForceRemove.RecurseDeleteKey(szToken);

  00150	8d 8d c8 ee ff
	ff		 lea	 ecx, DWORD PTR _rkForceRemove$5[ebp]
  00156	57		 push	 edi
  00157	89 85 c8 ee ff
	ff		 mov	 DWORD PTR _rkForceRemove$5[ebp], eax
  0015d	c7 85 cc ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkForceRemove$5[ebp+4], 0
  00167	c7 85 d0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkForceRemove$5[ebp+8], 0
  00171	e8 00 00 00 00	 call	 ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::RecurseDeleteKey

; 1445 : 					rkForceRemove.Detach();

  00176	c7 85 c8 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkForceRemove$5[ebp], 0
  00180	c7 85 cc ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkForceRemove$5[ebp+4], 0
  0018a	c7 85 d0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkForceRemove$5[ebp+8], 0
$LN10@RegisterSu:
  00194	85 db		 test	 ebx, ebx

; 1446 : 				}
; 1447 : 				if (bTokenDelete)

  00196	74 39		 je	 SHORT $LN106@RegisterSu

; 1448 : 				{
; 1449 : 					if (FAILED(hr = NextToken(szToken)))

  00198	8b 9d e8 ee ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  0019e	8b cb		 mov	 ecx, ebx
  001a0	57		 push	 edi
  001a1	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  001a6	8b f0		 mov	 esi, eax
  001a8	85 f6		 test	 esi, esi
  001aa	0f 88 d7 04 00
	00		 js	 $LN183@RegisterSu

; 1450 : 						break;
; 1451 : 					if (FAILED(hr = SkipAssignment(szToken)))

  001b0	57		 push	 edi
  001b1	8b cb		 mov	 ecx, ebx
  001b3	e8 00 00 00 00	 call	 ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::SkipAssignment
  001b8	8b f0		 mov	 esi, eax
  001ba	85 f6		 test	 esi, esi
  001bc	0f 88 c5 04 00
	00		 js	 $LN183@RegisterSu

; 1646 : 		}
; 1647 : 
; 1648 : EndCheck:

  001c2	c7 85 cc ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkForceRemove$5[ebp+4], 0

; 1453 : 					goto EndCheck;

  001cc	e9 5c 02 00 00	 jmp	 $EndCheck$228

; 1454 : 				}
; 1455 : 			}

$LN106@RegisterSu:
  001d1	c7 85 cc ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkForceRemove$5[ebp+4], 0
$LN8@RegisterSu:

; 1456 : 		}
; 1457 : 
; 1458 : 		if (!lstrcmpi(szToken, szNoRemove))

  001db	68 00 00 00 00	 push	 OFFSET ??_C@_08KAAPDIAN@NoRemove?$AA@
  001e0	57		 push	 edi
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8

; 1459 : 		{
; 1460 : 			bDelete = FALSE;    // set even for register
; 1461 : 			if (FAILED(hr = NextToken(szToken)))

  001e7	8b 9d e8 ee ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  001ed	85 c0		 test	 eax, eax
  001ef	75 18		 jne	 SHORT $LN16@RegisterSu
  001f1	57		 push	 edi
  001f2	8b cb		 mov	 ecx, ebx
  001f4	89 85 d4 ee ff
	ff		 mov	 DWORD PTR _bDelete$1$[ebp], eax
  001fa	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  001ff	8b f0		 mov	 esi, eax
  00201	85 f6		 test	 esi, esi
  00203	0f 88 d3 04 00
	00		 js	 $LN217@RegisterSu
$LN16@RegisterSu:

; 1462 : 				break;
; 1463 : 		}
; 1464 : 
; 1465 : 		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent

  00209	68 00 00 00 00	 push	 OFFSET ??_C@_03LAIAPFCB@Val?$AA@
  0020e	57		 push	 edi
  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  00215	85 c0		 test	 eax, eax
  00217	0f 85 56 01 00
	00		 jne	 $LN22@RegisterSu

; 1466 : 		{
; 1467 : 			TCHAR  szValueName[MAX_VALUE];
; 1468 : 
; 1469 : 			if (FAILED(hr = NextToken(szValueName)))

  0021d	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _szValueName$6[ebp]
  00223	8b cb		 mov	 ecx, ebx
  00225	50		 push	 eax
  00226	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  0022b	8b f0		 mov	 esi, eax
  0022d	85 f6		 test	 esi, esi
  0022f	0f 88 a7 04 00
	00		 js	 $LN217@RegisterSu

; 1470 : 				break;
; 1471 : 			if (FAILED(hr = NextToken(szToken)))

  00235	57		 push	 edi
  00236	8b cb		 mov	 ecx, ebx
  00238	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  0023d	8b f0		 mov	 esi, eax
  0023f	85 f6		 test	 esi, esi
  00241	0f 88 95 04 00
	00		 js	 $LN217@RegisterSu

; 1472 : 				break;
; 1473 : 
; 1474 : 			if (*szToken != chEquals)

  00247	80 3f 3d	 cmp	 BYTE PTR [edi], 61	; 0000003dH
  0024a	0f 85 30 04 00
	00		 jne	 $LN187@RegisterSu

; 1475 : 				return GenerateError(E_ATL_EXPECTING_EQUAL);
; 1476 : 
; 1477 : 			if (bRegister)

  00250	83 7d 10 00	 cmp	 DWORD PTR _bRegister$[ebp], 0
  00254	74 75		 je	 SHORT $LN21@RegisterSu

; 1478 : 			{
; 1479 : 				CRegKey rk;
; 1480 : 
; 1481 : 				rk.Attach(hkParent);

  00256	8b 85 e4 ee ff
	ff		 mov	 eax, DWORD PTR _hkParent$GSCopy$1$[ebp]

; 1482 : 				hr = AddValue(rk, szValueName, szToken);

  0025c	8b cb		 mov	 ecx, ebx
  0025e	89 85 b8 ee ff
	ff		 mov	 DWORD PTR _rk$4[ebp], eax
  00264	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _szValueName$6[ebp]
  0026a	57		 push	 edi
  0026b	50		 push	 eax
  0026c	8d 85 b8 ee ff
	ff		 lea	 eax, DWORD PTR _rk$4[ebp]
  00272	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00276	50		 push	 eax
  00277	c7 85 bc ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rk$4[ebp+4], 0
  00281	c7 85 c0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rk$4[ebp+8], 0
  0028b	e8 00 00 00 00	 call	 ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ; ATL::CRegParser::AddValue
  00290	8b f0		 mov	 esi, eax

; 1483 : 				rk.Detach();

  00292	c7 85 b8 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rk$4[ebp], 0
  0029c	c7 85 bc ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rk$4[ebp+4], 0
  002a6	c7 85 c0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rk$4[ebp+8], 0

; 1484 : 
; 1485 : 				if (FAILED(hr))

  002b0	85 f6		 test	 esi, esi
  002b2	0f 88 dc 03 00
	00		 js	 $LN188@RegisterSu

; 1646 : 		}
; 1647 : 
; 1648 : EndCheck:

  002b8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002bc	c7 85 bc ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rk$4[ebp+4], 0
  002c6	e9 62 01 00 00	 jmp	 $EndCheck$228
$LN21@RegisterSu:

; 1487 : 
; 1488 : 				goto EndCheck;
; 1489 : 			}
; 1490 : 			else
; 1491 : 			{
; 1492 : 				if (!bRecover && bDelete)

  002cb	83 7d 14 00	 cmp	 DWORD PTR _bRecover$[ebp], 0
  002cf	0f 85 87 00 00
	00		 jne	 $LN25@RegisterSu
  002d5	83 bd d4 ee ff
	ff 00		 cmp	 DWORD PTR _bDelete$1$[ebp], 0
  002dc	74 7e		 je	 SHORT $LN25@RegisterSu

; 1493 : 				{
; 1494 : 					ATLTRACE(atlTraceRegistrar, 1, _T("Deleting %Ts\n"), szValueName);
; 1495 : 					// We have to open the key for write to be able to delete.
; 1496 : 					CRegKey rkParent;
; 1497 : 					lRes = rkParent.Open(hkParent, NULL, KEY_WRITE);

  002de	68 06 00 02 00	 push	 131078			; 00020006H
  002e3	6a 00		 push	 0
  002e5	ff b5 e4 ee ff
	ff		 push	 DWORD PTR _hkParent$GSCopy$1$[ebp]
  002eb	8d 8d ac ee ff
	ff		 lea	 ecx, DWORD PTR _rkParent$3[ebp]
  002f1	c7 85 ac ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkParent$3[ebp], 0
  002fb	c7 85 b0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkParent$3[ebp+4], 0
  00305	c7 85 b4 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkParent$3[ebp+8], 0
  0030f	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open

; 1498 : 					if (lRes == ERROR_SUCCESS)

  00314	85 c0		 test	 eax, eax
  00316	0f 85 85 03 00
	00		 jne	 $LN26@RegisterSu

; 1499 : 					{
; 1500 : 						lRes = rkParent.DeleteValue(szValueName);

  0031c	8b b5 ac ee ff
	ff		 mov	 esi, DWORD PTR _rkParent$3[ebp]
  00322	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _szValueName$6[ebp]
  00328	50		 push	 eax
  00329	56		 push	 esi
  0032a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueA@8

; 1501 : 						if (lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)

  00330	85 c0		 test	 eax, eax
  00332	74 09		 je	 SHORT $LN28@RegisterSu
  00334	83 f8 02	 cmp	 eax, 2
  00337	0f 85 64 03 00
	00		 jne	 $LN26@RegisterSu
$LN28@RegisterSu:

; 1512 : 					}
; 1513 : 				}

  0033d	85 f6		 test	 esi, esi
  0033f	74 11		 je	 SHORT $LN134@RegisterSu
  00341	56		 push	 esi
  00342	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00348	c7 85 ac ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkParent$3[ebp], 0
$LN134@RegisterSu:
  00352	c7 85 b0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rkParent$3[ebp+4], 0
$LN25@RegisterSu:

; 1514 : 				if (FAILED(hr = SkipAssignment(szToken)))

  0035c	57		 push	 edi
  0035d	8b cb		 mov	 ecx, ebx
  0035f	e8 00 00 00 00	 call	 ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::SkipAssignment
  00364	8b f0		 mov	 esi, eax
  00366	85 f6		 test	 esi, esi
  00368	0f 88 6e 03 00
	00		 js	 $LN217@RegisterSu

; 1515 : 					break;
; 1516 : 				continue;  // can never have a subkey

  0036e	e9 f7 02 00 00	 jmp	 $LN59@RegisterSu
$LN22@RegisterSu:

; 1517 : 			}
; 1518 : 		}
; 1519 : 
; 1520 : 		if (StrChr(szToken, chDirSep) != NULL)

  00373	8a 07		 mov	 al, BYTE PTR [edi]
  00375	8b cf		 mov	 ecx, edi
  00377	84 c0		 test	 al, al
  00379	74 22		 je	 SHORT $LN216@RegisterSu
  0037b	0f 1f 44 00 00	 npad	 5
$LL137@RegisterSu:
  00380	3c 5c		 cmp	 al, 92			; 0000005cH
  00382	74 11		 je	 SHORT $LN179@RegisterSu
  00384	51		 push	 ecx
  00385	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4
  0038b	8b c8		 mov	 ecx, eax
  0038d	8a 01		 mov	 al, BYTE PTR [ecx]
  0038f	84 c0		 test	 al, al
  00391	75 ed		 jne	 SHORT $LL137@RegisterSu

; 1655 : 					break;
; 1656 : 				if (FAILED(hr = NextToken(szToken)))

  00393	eb 08		 jmp	 SHORT $LN216@RegisterSu
$LN179@RegisterSu:

; 1517 : 			}
; 1518 : 		}
; 1519 : 
; 1520 : 		if (StrChr(szToken, chDirSep) != NULL)

  00395	85 c9		 test	 ecx, ecx
  00397	0f 85 e3 02 00
	00		 jne	 $LN187@RegisterSu
$LN216@RegisterSu:

; 1521 : 			return GenerateError(E_ATL_COMPOUND_KEY);
; 1522 : 
; 1523 : 		if (bRegister)

  0039d	83 7d 10 00	 cmp	 DWORD PTR _bRegister$[ebp], 0
  003a1	0f 84 df 00 00
	00		 je	 $LN31@RegisterSu

; 1524 : 		{
; 1525 : 			lRes = keyCur.Open(hkParent, szToken, KEY_READ | KEY_WRITE);

  003a7	8b b5 e4 ee ff
	ff		 mov	 esi, DWORD PTR _hkParent$GSCopy$1$[ebp]
  003ad	8d 8d d8 ee ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  003b3	68 1f 00 02 00	 push	 131103			; 0002001fH
  003b8	57		 push	 edi
  003b9	56		 push	 esi
  003ba	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open

; 1526 : 			if (ERROR_SUCCESS != lRes)

  003bf	85 c0		 test	 eax, eax
  003c1	74 38		 je	 SHORT $LN35@RegisterSu

; 1527 : 			{
; 1528 : 				// Failed all access try read only
; 1529 : 				lRes = keyCur.Open(hkParent, szToken, KEY_READ);

  003c3	68 19 00 02 00	 push	 131097			; 00020019H
  003c8	57		 push	 edi
  003c9	56		 push	 esi
  003ca	8d 8d d8 ee ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  003d0	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open

; 1530 : 				if (ERROR_SUCCESS != lRes)

  003d5	85 c0		 test	 eax, eax
  003d7	74 22		 je	 SHORT $LN35@RegisterSu

; 1531 : 				{
; 1532 : 					// Finally try creating it
; 1533 : 					ATLTRACE(atlTraceRegistrar, 2, _T("Creating key %Ts\n"), szToken);
; 1534 : 					lRes = keyCur.Create(hkParent, szToken, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);

  003d9	6a 00		 push	 0
  003db	6a 00		 push	 0
  003dd	68 1f 00 02 00	 push	 131103			; 0002001fH
  003e2	6a 00		 push	 0
  003e4	6a 00		 push	 0
  003e6	57		 push	 edi
  003e7	56		 push	 esi
  003e8	8d 8d d8 ee ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  003ee	e8 00 00 00 00	 call	 ?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z ; ATL::CRegKey::Create

; 1535 : 					if (lRes != ERROR_SUCCESS)

  003f3	85 c0		 test	 eax, eax
  003f5	0f 85 d6 02 00
	00		 jne	 $LN199@RegisterSu
$LN35@RegisterSu:

; 1536 : 						return AtlHresultFromWin32(lRes);
; 1537 : 				}
; 1538 : 			}
; 1539 : 
; 1540 : 			if (FAILED(hr = NextToken(szToken)))

  003fb	57		 push	 edi
  003fc	8b cb		 mov	 ecx, ebx
  003fe	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00403	8b f0		 mov	 esi, eax
  00405	85 f6		 test	 esi, esi
  00407	0f 88 cf 02 00
	00		 js	 $LN217@RegisterSu

; 1541 : 				break;
; 1542 : 
; 1543 : 
; 1544 : 			if (*szToken == chEquals)

  0040d	80 3f 3d	 cmp	 BYTE PTR [edi], 61	; 0000003dH
  00410	75 1b		 jne	 SHORT $EndCheck$228

; 1545 : 			{
; 1546 : 				if (FAILED(hr = AddValue(keyCur, NULL, szToken))) // NULL == default

  00412	57		 push	 edi
  00413	6a 00		 push	 0
  00415	8d 85 d8 ee ff
	ff		 lea	 eax, DWORD PTR _keyCur$[ebp]
  0041b	8b cb		 mov	 ecx, ebx
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ; ATL::CRegParser::AddValue
  00423	8b f0		 mov	 esi, eax
  00425	85 f6		 test	 esi, esi
  00427	0f 88 af 02 00
	00		 js	 $LN217@RegisterSu
$EndCheck$228:

; 1649 : 
; 1650 : 		if (bRegister)
; 1651 : 		{
; 1652 : 			if (*szToken == chLeftBracket && _tcslen(szToken) == 1)

  0042d	80 3f 7b	 cmp	 BYTE PTR [edi], 123	; 0000007bH
  00430	0f 85 34 02 00
	00		 jne	 $LN59@RegisterSu
  00436	8b cf		 mov	 ecx, edi
  00438	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0043b	0f 1f 44 00 00	 npad	 5
$LL218@RegisterSu:
  00440	8a 01		 mov	 al, BYTE PTR [ecx]
  00442	41		 inc	 ecx
  00443	84 c0		 test	 al, al
  00445	75 f9		 jne	 SHORT $LL218@RegisterSu
  00447	2b ca		 sub	 ecx, edx
  00449	83 f9 01	 cmp	 ecx, 1
  0044c	0f 85 18 02 00
	00		 jne	 $LN59@RegisterSu

; 1653 : 			{
; 1654 : 				if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))

  00452	6a 00		 push	 0
  00454	ff 75 10	 push	 DWORD PTR _bRegister$[ebp]
  00457	8b cb		 mov	 ecx, ebx
  00459	ff b5 d8 ee ff
	ff		 push	 DWORD PTR _keyCur$[ebp]
  0045f	57		 push	 edi
  00460	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  00465	8b f0		 mov	 esi, eax
  00467	85 f6		 test	 esi, esi
  00469	0f 88 6d 02 00
	00		 js	 $LN217@RegisterSu

; 1655 : 					break;
; 1656 : 				if (FAILED(hr = NextToken(szToken)))

  0046f	57		 push	 edi
  00470	8b cb		 mov	 ecx, ebx
  00472	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00477	8b f0		 mov	 esi, eax
  00479	85 f6		 test	 esi, esi
  0047b	0f 88 5b 02 00
	00		 js	 $LN217@RegisterSu
  00481	e9 e4 01 00 00	 jmp	 $LN59@RegisterSu
$LN31@RegisterSu:

; 1547 : 					break;
; 1548 : 			}
; 1549 : 		}
; 1550 : 		else //Unregister
; 1551 : 		{
; 1552 : 			if (!bRecover)

  00486	8b 75 14	 mov	 esi, DWORD PTR _bRecover$[ebp]
  00489	85 f6		 test	 esi, esi
  0048b	75 1b		 jne	 SHORT $LN39@RegisterSu

; 1553 : 			{
; 1554 :  				lRes = keyCur.Open(hkParent, szToken, KEY_READ);

  0048d	68 19 00 02 00	 push	 131097			; 00020019H
  00492	57		 push	 edi
  00493	ff b5 e4 ee ff
	ff		 push	 DWORD PTR _hkParent$GSCopy$1$[ebp]
  00499	8d 8d d8 ee ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  0049f	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open
  004a4	8b d8		 mov	 ebx, eax

; 1555 : 
; 1556 : 			}
; 1557 : 			else

  004a6	eb 05		 jmp	 SHORT $LN40@RegisterSu
$LN39@RegisterSu:

; 1558 : 				lRes = ERROR_FILE_NOT_FOUND;

  004a8	bb 02 00 00 00	 mov	 ebx, 2
$LN40@RegisterSu:

; 1559 : 
; 1560 : 
; 1561 : 			// Open failed set recovery mode
; 1562 : 			if (lRes != ERROR_SUCCESS)

  004ad	85 db		 test	 ebx, ebx
  004af	b9 01 00 00 00	 mov	 ecx, 1

; 1563 : 				bRecover = true;
; 1564 : 
; 1565 : 			// TRACE out Key open status and if in recovery mode
; 1566 : #ifdef _DEBUG
; 1567 : 			if (!bRecover)
; 1568 : 				ATLTRACE(atlTraceRegistrar, 1, _T("Opened Key %Ts\n"), szToken);
; 1569 : 			else
; 1570 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Ignoring Open key on %Ts : In Recovery mode\n"), szToken);
; 1571 : #endif //_DEBUG
; 1572 : 
; 1573 : 			// Remember Subkey
; 1574 : 			Checked::tcsncpy_s(szKey, _countof(szKey), szToken, _TRUNCATE);

  004b4	6a ff		 push	 -1
  004b6	8b c6		 mov	 eax, esi
  004b8	0f 45 c1	 cmovne	 eax, ecx
  004bb	57		 push	 edi
  004bc	89 85 c4 ee ff
	ff		 mov	 DWORD PTR _bRecover$3$[ebp], eax
  004c2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  004c8	68 04 01 00 00	 push	 260			; 00000104H
  004cd	50		 push	 eax
  004ce	e8 00 00 00 00	 call	 __mbsnbcpy_s
  004d3	50		 push	 eax
  004d4	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck

; 1575 : 
; 1576 : 			if (FAILED(hr = NextToken(szToken)))

  004d9	8b 8d e8 ee ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  004df	83 c4 14	 add	 esp, 20			; 00000014H
  004e2	57		 push	 edi
  004e3	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  004e8	8b f0		 mov	 esi, eax
  004ea	85 f6		 test	 esi, esi
  004ec	0f 88 ea 01 00
	00		 js	 $LN217@RegisterSu

; 1577 : 				break;
; 1578 : 			if (FAILED(hr = SkipAssignment(szToken)))

  004f2	8b 8d e8 ee ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  004f8	57		 push	 edi
  004f9	e8 00 00 00 00	 call	 ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::SkipAssignment
  004fe	8b f0		 mov	 esi, eax
  00500	85 f6		 test	 esi, esi
  00502	0f 88 d4 01 00
	00		 js	 $LN217@RegisterSu

; 1579 : 				break;
; 1580 : 
; 1581 : 			if (*szToken == chLeftBracket && _tcslen(szToken) == 1)

  00508	80 3f 7b	 cmp	 BYTE PTR [edi], 123	; 0000007bH
  0050b	75 56		 jne	 SHORT $LN46@RegisterSu
  0050d	8b cf		 mov	 ecx, edi
  0050f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL219@RegisterSu:
  00512	8a 01		 mov	 al, BYTE PTR [ecx]
  00514	41		 inc	 ecx
  00515	84 c0		 test	 al, al
  00517	75 f9		 jne	 SHORT $LL219@RegisterSu
  00519	2b ca		 sub	 ecx, edx
  0051b	83 f9 01	 cmp	 ecx, 1
  0051e	75 43		 jne	 SHORT $LN46@RegisterSu

; 1582 : 			{
; 1583 : 				hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover);

  00520	ff b5 c4 ee ff
	ff		 push	 DWORD PTR _bRecover$3$[ebp]
  00526	8b 8d e8 ee ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0052c	6a 00		 push	 0
  0052e	ff b5 d8 ee ff
	ff		 push	 DWORD PTR _keyCur$[ebp]
  00534	57		 push	 edi
  00535	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  0053a	8b f0		 mov	 esi, eax

; 1584 : 				// In recover mode ignore error
; 1585 : 				if (FAILED(hr) && !bRecover)

  0053c	85 f6		 test	 esi, esi
  0053e	79 0d		 jns	 SHORT $LN45@RegisterSu
  00540	83 bd c4 ee ff
	ff 00		 cmp	 DWORD PTR _bRecover$3$[ebp], 0
  00547	0f 84 8f 01 00
	00		 je	 $LN217@RegisterSu
$LN45@RegisterSu:

; 1586 : 					break;
; 1587 : 				// Skip the }
; 1588 : 				if (FAILED(hr = NextToken(szToken)))

  0054d	8b 8d e8 ee ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00553	57		 push	 edi
  00554	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00559	8b f0		 mov	 esi, eax
  0055b	85 f6		 test	 esi, esi
  0055d	0f 88 79 01 00
	00		 js	 $LN217@RegisterSu
$LN46@RegisterSu:

; 1589 : 					break;
; 1590 : 			}
; 1591 : 
; 1592 : #ifdef _DEBUG
; 1593 : 			if (bRecover != bInRecovery)
; 1594 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Ending Recovery Mode\n"));
; 1595 : #endif
; 1596 : 			bRecover = bInRecovery;
; 1597 : 
; 1598 : 			if (lRes == ERROR_FILE_NOT_FOUND)

  00563	83 fb 02	 cmp	 ebx, 2
  00566	0f 84 fe 00 00
	00		 je	 $LN59@RegisterSu

; 1599 : 				// Key already not present so not an error.
; 1600 : 				continue;
; 1601 : 
; 1602 : 			if (lRes != ERROR_SUCCESS)

  0056c	85 db		 test	 ebx, ebx
  0056e	74 10		 je	 SHORT $LN50@RegisterSu

; 1603 : 			{
; 1604 : 				// We are recovery mode continue on errors else break
; 1605 : 				if (bRecover)

  00570	83 7d 14 00	 cmp	 DWORD PTR _bRecover$[ebp], 0
  00574	0f 85 f0 00 00
	00		 jne	 $LN59@RegisterSu

; 1606 : 					continue;
; 1607 : 				else
; 1608 : 				{
; 1609 : 					hr = AtlHresultFromWin32(lRes);

  0057a	53		 push	 ebx

; 1610 : 					break;

  0057b	e9 52 01 00 00	 jmp	 $LN227@RegisterSu
$LN50@RegisterSu:

; 1611 : 				}
; 1612 : 			}
; 1613 : 
; 1614 : 			// If in recovery mode
; 1615 : 			if (bRecover && HasSubKeys(keyCur))

  00580	83 7d 14 00	 cmp	 DWORD PTR _bRecover$[ebp], 0
  00584	8b 9d e8 ee ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  0058a	74 4b		 je	 SHORT $LN51@RegisterSu
  0058c	ff b5 d8 ee ff
	ff		 push	 DWORD PTR _keyCur$[ebp]
  00592	8b cb		 mov	 ecx, ebx
  00594	e8 00 00 00 00	 call	 ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ; ATL::CRegParser::HasSubKeys
  00599	85 c0		 test	 eax, eax
  0059b	74 3a		 je	 SHORT $LN51@RegisterSu

; 1616 : 			{
; 1617 : 				// See if the KEY is in the NeverDelete list and if so, don't
; 1618 : 				if (CanForceRemoveKey(szKey) && bDelete)

  0059d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  005a3	8b cb		 mov	 ecx, ebx
  005a5	50		 push	 eax
  005a6	e8 00 00 00 00	 call	 ?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z ; ATL::CRegParser::CanForceRemoveKey
  005ab	85 c0		 test	 eax, eax
  005ad	0f 84 b7 00 00
	00		 je	 $LN59@RegisterSu
  005b3	83 bd d4 ee ff
	ff 00		 cmp	 DWORD PTR _bDelete$1$[ebp], 0
  005ba	0f 84 aa 00 00
	00		 je	 $LN59@RegisterSu

; 1619 : 				{
; 1620 : 					ATLTRACE(atlTraceRegistrar, 0, _T("Deleting non-empty subkey %Ts by force\n"), szKey);
; 1621 : 					// Error not returned since we are in recovery mode. The error that caused recovery mode is returned
; 1622 : 					keyCur.RecurseDeleteKey(szKey);

  005c0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  005c6	50		 push	 eax
  005c7	8d 8d d8 ee ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  005cd	e8 00 00 00 00	 call	 ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::RecurseDeleteKey

; 1623 : 				}
; 1624 : 				continue;

  005d2	e9 93 00 00 00	 jmp	 $LN59@RegisterSu
$LN51@RegisterSu:

; 1625 : 			}
; 1626 : 
; 1627 : 			BOOL bHasSubKeys=HasSubKeys(keyCur);

  005d7	ff b5 d8 ee ff
	ff		 push	 DWORD PTR _keyCur$[ebp]
  005dd	8b cb		 mov	 ecx, ebx
  005df	e8 00 00 00 00	 call	 ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ; ATL::CRegParser::HasSubKeys

; 1628 : 			lRes = keyCur.Close();

  005e4	8b 8d d8 ee ff
	ff		 mov	 ecx, DWORD PTR _keyCur$[ebp]
  005ea	8b d8		 mov	 ebx, eax
  005ec	33 c0		 xor	 eax, eax
  005ee	85 c9		 test	 ecx, ecx
  005f0	74 0f		 je	 SHORT $LN153@RegisterSu
  005f2	51		 push	 ecx
  005f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  005f9	33 c9		 xor	 ecx, ecx
  005fb	89 8d d8 ee ff
	ff		 mov	 DWORD PTR _keyCur$[ebp], ecx
$LN153@RegisterSu:
  00601	c7 85 dc ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _keyCur$[ebp+4], 0

; 1629 : 			if (lRes != ERROR_SUCCESS)

  0060b	85 c0		 test	 eax, eax
  0060d	0f 85 be 00 00
	00		 jne	 $LN199@RegisterSu
  00613	39 85 d4 ee ff
	ff		 cmp	 DWORD PTR _bDelete$1$[ebp], eax

; 1631 : 
; 1632 : 			if (bDelete&& !bHasSubKeys)

  00619	74 4f		 je	 SHORT $LN59@RegisterSu
  0061b	85 db		 test	 ebx, ebx
  0061d	75 4b		 jne	 SHORT $LN59@RegisterSu

; 1633 : 			{
; 1634 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Deleting Key %Ts\n"), szKey);
; 1635 : 				CRegKey rkParent;
; 1636 : 				rkParent.Attach(hkParent);

  0061f	8b 85 e4 ee ff
	ff		 mov	 eax, DWORD PTR _hkParent$GSCopy$1$[ebp]

; 1637 : 				lRes = rkParent.DeleteSubKey(szKey);

  00625	8d 8d a0 ee ff
	ff		 lea	 ecx, DWORD PTR _rkParent$2[ebp]
  0062b	89 85 a0 ee ff
	ff		 mov	 DWORD PTR _rkParent$2[ebp], eax
  00631	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00637	50		 push	 eax
  00638	89 9d a4 ee ff
	ff		 mov	 DWORD PTR _rkParent$2[ebp+4], ebx
  0063e	89 9d a8 ee ff
	ff		 mov	 DWORD PTR _rkParent$2[ebp+8], ebx
  00644	e8 00 00 00 00	 call	 ?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::DeleteSubKey

; 1638 : 				rkParent.Detach();

  00649	89 9d a0 ee ff
	ff		 mov	 DWORD PTR _rkParent$2[ebp], ebx
  0064f	89 9d a4 ee ff
	ff		 mov	 DWORD PTR _rkParent$2[ebp+4], ebx
  00655	89 9d a8 ee ff
	ff		 mov	 DWORD PTR _rkParent$2[ebp+8], ebx

; 1639 : 				if (lRes != ERROR_SUCCESS)

  0065b	85 c0		 test	 eax, eax
  0065d	75 5a		 jne	 SHORT $LN200@RegisterSu

; 1644 : 				}
; 1645 : 			}

  0065f	8d 8d a0 ee ff
	ff		 lea	 ecx, DWORD PTR _rkParent$2[ebp]
  00665	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
$LN59@RegisterSu:

; 1421 : 		return hr;
; 1422 : 
; 1423 : 	while (*szToken != chRightBracket) // Continue till we see a }

  0066a	80 3f 7d	 cmp	 BYTE PTR [edi], 125	; 0000007dH
  0066d	0f 85 1d fa ff
	ff		 jne	 $LL2@RegisterSu
  00673	eb 67		 jmp	 SHORT $LN217@RegisterSu
$LN181@RegisterSu:

; 1438 : 					return GenerateError(E_ATL_COMPOUND_KEY);

  00675	8d 8d c8 ee ff
	ff		 lea	 ecx, DWORD PTR _rkForceRemove$5[ebp]
  0067b	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
$LN187@RegisterSu:
  00680	be 09 00 02 80	 mov	 esi, -2147352567	; 80020009H
  00685	eb 55		 jmp	 SHORT $LN217@RegisterSu
$LN183@RegisterSu:

; 1452 : 						break;

  00687	8d 8d c8 ee ff
	ff		 lea	 ecx, DWORD PTR _rkForceRemove$5[ebp]
  0068d	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
  00692	eb 48		 jmp	 SHORT $LN217@RegisterSu
$LN188@RegisterSu:

; 1486 : 					return hr;

  00694	8d 8d b8 ee ff
	ff		 lea	 ecx, DWORD PTR _rk$4[ebp]
  0069a	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
  0069f	eb 3b		 jmp	 SHORT $LN217@RegisterSu
$LN26@RegisterSu:

; 1502 : 						{
; 1503 : 							// Key not present is not an error
; 1504 : 							hr = AtlHresultFromWin32(lRes);
; 1505 : 							break;
; 1506 : 						}
; 1507 : 					}
; 1508 : 					else
; 1509 : 					{
; 1510 : 						hr = AtlHresultFromWin32(lRes);

  006a1	50		 push	 eax
  006a2	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  006a7	83 c4 04	 add	 esp, 4

; 1511 : 						break;

  006aa	8d 8d ac ee ff
	ff		 lea	 ecx, DWORD PTR _rkParent$3[ebp]
  006b0	8b f0		 mov	 esi, eax
  006b2	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
  006b7	eb 23		 jmp	 SHORT $LN217@RegisterSu
$LN200@RegisterSu:

; 1640 : 				{
; 1641 : 
; 1642 : 					hr = AtlHresultFromWin32(lRes);

  006b9	50		 push	 eax
  006ba	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  006bf	83 c4 04	 add	 esp, 4

; 1643 : 					break;

  006c2	8d 8d a0 ee ff
	ff		 lea	 ecx, DWORD PTR _rkParent$2[ebp]
  006c8	8b f0		 mov	 esi, eax
  006ca	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
  006cf	eb 0b		 jmp	 SHORT $LN217@RegisterSu
$LN199@RegisterSu:

; 1630 : 			return AtlHresultFromWin32(lRes);

  006d1	50		 push	 eax
$LN227@RegisterSu:
  006d2	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  006d7	83 c4 04	 add	 esp, 4
  006da	8b f0		 mov	 esi, eax
$LN217@RegisterSu:

; 1657 : 					break;
; 1658 : 			}
; 1659 : 		}
; 1660 : 	}
; 1661 : 
; 1662 : 	return hr;

  006dc	8b 85 d8 ee ff
	ff		 mov	 eax, DWORD PTR _keyCur$[ebp]
  006e2	85 c0		 test	 eax, eax
  006e4	74 07		 je	 SHORT $LN220@RegisterSu
  006e6	50		 push	 eax
  006e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN220@RegisterSu:
  006ed	8b c6		 mov	 eax, esi
$LN167@RegisterSu:

; 1663 : }

  006ef	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006f2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006f9	59		 pop	 ecx
  006fa	5f		 pop	 edi
  006fb	5e		 pop	 esi
  006fc	5b		 pop	 ebx
  006fd	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00700	33 cd		 xor	 ecx, ebp
  00702	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00707	8b e5		 mov	 esp, ebp
  00709	5d		 pop	 ebp
  0070a	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z$2:
  00000	8d 8d d8 ee ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
__unwindfunclet$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z$4:
  0000b	8d 8d b8 ee ff
	ff		 lea	 ecx, DWORD PTR _rk$4[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
__ehhandler$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 9c ee ff
	ff		 mov	 ecx, DWORD PTR [edx-4452]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ENDP ; ATL::CRegParser::RegisterSubkeys
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z
_TEXT	SEGMENT
_cSubKeys$ = -4						; size = 4
_hkey$ = 8						; size = 4
?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z PROC	; ATL::CRegParser::HasSubKeys, COMDAT
; _this$ = ecx

; 1111 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1112 : 	DWORD cSubKeys = 0;
; 1113 : 
; 1114 : 	if (RegQueryInfoKeyW(hkey, NULL, NULL, NULL,
; 1115 : 							   &cSubKeys, NULL, NULL,
; 1116 : 							   NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)

  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	8d 45 fc	 lea	 eax, DWORD PTR _cSubKeys$[ebp]
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cSubKeys$[ebp], 0
  0001c	50		 push	 eax
  0001d	6a 00		 push	 0
  0001f	6a 00		 push	 0
  00021	6a 00		 push	 0
  00023	ff 75 08	 push	 DWORD PTR _hkey$[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryInfoKeyW@48
  0002c	85 c0		 test	 eax, eax
  0002e	74 08		 je	 SHORT $LN2@HasSubKeys

; 1117 : 	{
; 1118 : 		ATLTRACE(atlTraceRegistrar, 0, _T("Should not be here!!\n"));
; 1119 : 		ATLASSERT(FALSE);
; 1120 : 		return FALSE;

  00030	33 c0		 xor	 eax, eax

; 1124 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN2@HasSubKeys:

; 1121 : 	}
; 1122 : 
; 1123 : 	return cSubKeys > 0;

  00038	33 c0		 xor	 eax, eax
  0003a	3b 45 fc	 cmp	 eax, DWORD PTR _cSubKeys$[ebp]
  0003d	1b c0		 sbb	 eax, eax
  0003f	f7 d8		 neg	 eax

; 1124 : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ENDP	; ATL::CRegParser::HasSubKeys
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z
_TEXT	SEGMENT
_szKey$ = 8						; size = 4
?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z PROC	; ATL::CRegParser::CanForceRemoveKey, COMDAT
; _this$ = ecx

; 1102 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1103 : 	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__lstrcmpiA@8
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _szKey$[ebp]
  0000f	be 00 00 00 00	 mov	 esi, OFFSET ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB ; ATL::CRegParser::rgszNeverDelete
$LL4@CanForceRe:

; 1104 : 		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))

  00014	ff 36		 push	 DWORD PTR [esi]
  00016	57		 push	 edi
  00017	ff d3		 call	 ebx
  00019	85 c0		 test	 eax, eax
  0001b	74 17		 je	 SHORT $LN8@CanForceRe

; 1103 : 	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)

  0001d	83 c6 04	 add	 esi, 4
  00020	81 fe 30 00 00
	00		 cmp	 esi, OFFSET ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB+48
  00026	7c ec		 jl	 SHORT $LL4@CanForceRe

; 1106 : 
; 1107 : 	return TRUE;

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	5b		 pop	 ebx

; 1108 : }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN8@CanForceRe:
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 1105 : 			 return FALSE;                       // We cannot delete it

  00036	33 c0		 xor	 eax, eax
  00038	5b		 pop	 ebx

; 1108 : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z ENDP	; ATL::CRegParser::CanForceRemoveKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
_TEXT	SEGMENT
_szToken$GSCopy$ = -4404				; size = 4
_this$GSCopy$ = -4400					; size = 4
_cbValue$2 = -4396					; size = 4
_ulVal$3 = -4396					; size = 4
_this$GSCopy$1$ = -4392					; size = 4
_rkParent$GSCopy$ = -4388				; size = 4
_vt$ = -4384						; size = 2
_cbValDiv2$4 = -4384					; size = 4
__convert_ex$5 = -4384					; size = 4
_szValueName$GSCopy$ = -4380				; size = 4
__AtlSafeAllocaManager$6 = -4380			; size = 4
_rgBinary$7 = -4376					; size = 260
_pszDestValue$8 = -4376					; size = 260
_szValue$ = -4116					; size = 4096
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_rkParent$ = 8						; size = 4
_szValueName$ = 12					; size = 4
_szToken$ = 16						; size = 4
?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z PROC ; ATL::CRegParser::AddValue, COMDAT
; _this$ = ecx

; 970  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	b8 24 11 00 00	 mov	 eax, 4388		; 00001124H
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00036	8b f1		 mov	 esi, ecx
  00038	89 b5 d8 ee ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  0003e	8b 45 10	 mov	 eax, DWORD PTR _szToken$[ebp]
  00041	8b 5d 08	 mov	 ebx, DWORD PTR _rkParent$[ebp]
  00044	8b 7d 0c	 mov	 edi, DWORD PTR _szValueName$[ebp]
  00047	89 85 cc ee ff
	ff		 mov	 DWORD PTR _szToken$GSCopy$[ebp], eax

; 971  : 	HRESULT hr;
; 972  : 
; 973  : 	TCHAR		szValue[MAX_VALUE];
; 974  : 	VARTYPE     vt = VT_EMPTY;
; 975  : 	LONG        lRes = ERROR_SUCCESS;
; 976  : 	UINT        nIDRes = 0;
; 977  : 
; 978  : 	if (FAILED(hr = NextToken(szValue)))

  0004d	8d 85 ec ef ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  00053	50		 push	 eax
  00054	89 b5 d0 ee ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  0005a	89 9d dc ee ff
	ff		 mov	 DWORD PTR _rkParent$GSCopy$[ebp], ebx
  00060	89 bd e4 ee ff
	ff		 mov	 DWORD PTR _szValueName$GSCopy$[ebp], edi
  00066	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _vt$[ebp], 0
  00070	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00075	85 c0		 test	 eax, eax
  00077	0f 88 b9 03 00
	00		 js	 $LN29@AddValue

; 979  : 		return hr;
; 980  : 	if (!VTFromRegType(szValue, vt))

  0007d	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _vt$[ebp]
  00083	50		 push	 eax
  00084	8d 85 ec ef ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z ; ATL::CRegParser::VTFromRegType
  00090	83 c4 08	 add	 esp, 8
  00093	85 c0		 test	 eax, eax
  00095	75 0a		 jne	 SHORT $LN10@AddValue

; 981  : 	{
; 982  : 		ATLTRACE(atlTraceRegistrar, 0, _T("%Ts Type not supported\n"), szValue);
; 983  : 		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);

  00097	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H
  0009c	e9 95 03 00 00	 jmp	 $LN29@AddValue
$LN10@AddValue:

; 984  : 	}
; 985  : 
; 986  : 	SkipWhiteSpace();

  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace

; 987  : 	if (FAILED(hr = NextToken(szValue)))

  000a8	8d 85 ec ef ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  000ae	8b ce		 mov	 ecx, esi
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  000b6	85 c0		 test	 eax, eax
  000b8	0f 88 78 03 00
	00		 js	 $LN29@AddValue

; 988  : 		return hr;
; 989  : 
; 990  : 	switch (vt)

  000be	0f b7 85 e0 ee
	ff ff		 movzx	 eax, WORD PTR _vt$[ebp]
  000c5	83 f8 13	 cmp	 eax, 19			; 00000013H
  000c8	0f 87 48 02 00
	00		 ja	 $LN37@AddValue
  000ce	0f 84 50 01 00
	00		 je	 $LN21@AddValue
  000d4	83 f8 08	 cmp	 eax, 8
  000d7	0f 84 2f 01 00
	00		 je	 $LN12@AddValue
  000dd	83 f8 11	 cmp	 eax, 17			; 00000011H
  000e0	0f 85 3a 03 00
	00		 jne	 $LN28@AddValue

; 1066 : 		}
; 1067 : 	case VT_UI1:
; 1068 : 		{
; 1069 : 			int cbValue = static_cast<int>(_tcslen(szValue));

  000e6	8d 9d ec ef ff
	ff		 lea	 ebx, DWORD PTR _szValue$[ebp]
  000ec	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  000ef	90		 npad	 1
$LL97@AddValue:
  000f0	8a 03		 mov	 al, BYTE PTR [ebx]
  000f2	43		 inc	 ebx
  000f3	84 c0		 test	 al, al
  000f5	75 f9		 jne	 SHORT $LL97@AddValue
  000f7	2b d9		 sub	 ebx, ecx
  000f9	89 9d d4 ee ff
	ff		 mov	 DWORD PTR _cbValue$2[ebp], ebx

; 1070 : 			if (cbValue & 0x00000001)

  000ff	f6 c3 01	 test	 bl, 1
  00102	75 6f		 jne	 SHORT $LN71@AddValue

; 1071 : 			{
; 1072 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
; 1073 : 				return E_FAIL;
; 1074 : 			}
; 1075 : 			int cbValDiv2 = cbValue/2;

  00104	8b c3		 mov	 eax, ebx

; 1076 : 			CTempBuffer<BYTE, 256> rgBinary;

  00106	c7 85 e8 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _rgBinary$7[ebp], 0
  00110	99		 cdq
  00111	2b c2		 sub	 eax, edx
  00113	8b f0		 mov	 esi, eax
  00115	d1 fe		 sar	 esi, 1
  00117	89 b5 e0 ee ff
	ff		 mov	 DWORD PTR _cbValDiv2$4[ebp], esi
  0011d	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 1077 : 			ATLTRY(rgBinary.Allocate(cbValDiv2));

  00124	8d 8d e8 ee ff
	ff		 lea	 ecx, DWORD PTR _rgBinary$7[ebp]
  0012a	56		 push	 esi
  0012b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  0012f	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
  00134	eb 1e		 jmp	 SHORT $LN48@AddValue
__catch$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$2:
  00136	b8 00 00 00 00	 mov	 eax, $LN100@AddValue
  0013b	c3		 ret	 0
$LN100@AddValue:
  0013c	8b 85 d0 ee ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  00142	8b 9d d4 ee ff
	ff		 mov	 ebx, DWORD PTR _cbValue$2[ebp]
  00148	8b b5 e0 ee ff
	ff		 mov	 esi, DWORD PTR _cbValDiv2$4[ebp]
  0014e	89 85 d8 ee ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
$LN48@AddValue:

; 1078 : 			if (rgBinary == NULL)

  00154	8b 85 e8 ee ff
	ff		 mov	 eax, DWORD PTR _rgBinary$7[ebp]
  0015a	85 c0		 test	 eax, eax
  0015c	75 1f		 jne	 SHORT $LN27@AddValue

; 1079 : 				return E_FAIL;

  0015e	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _rgBinary$7[ebp+4]
  00164	85 c0		 test	 eax, eax
  00166	74 0b		 je	 SHORT $LN71@AddValue
  00168	8d 8d e8 ee ff
	ff		 lea	 ecx, DWORD PTR _rgBinary$7[ebp]
  0016e	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
$LN71@AddValue:
  00173	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00178	e9 b9 02 00 00	 jmp	 $LN29@AddValue
$LN27@AddValue:

; 1080 : 			memset(rgBinary, 0, cbValDiv2);

  0017d	56		 push	 esi
  0017e	6a 00		 push	 0
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 _memset
  00186	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1081 : 			for (int irg = 0; irg < cbValue; irg++)

  00189	33 ff		 xor	 edi, edi
  0018b	85 db		 test	 ebx, ebx
  0018d	7e 3a		 jle	 SHORT $LN7@AddValue
  0018f	90		 npad	 1
$LL8@AddValue:

; 1082 : 				rgBinary[(irg/2)] |= (ChToByte(szValue[irg])) << (4*(1 - (irg & 0x00000001)));

  00190	0f b6 84 3d ec
	ef ff ff	 movzx	 eax, BYTE PTR _szValue$[ebp+edi]
  00198	8b f7		 mov	 esi, edi
  0019a	d1 ee		 shr	 esi, 1
  0019c	03 b5 e8 ee ff
	ff		 add	 esi, DWORD PTR _rgBinary$7[ebp]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 ?ChToByte@CRegParser@ATL@@KAED@Z ; ATL::CRegParser::ChToByte
  001a8	8b d7		 mov	 edx, edi
  001aa	b9 04 00 00 00	 mov	 ecx, 4
  001af	83 e2 01	 and	 edx, 1
  001b2	47		 inc	 edi
  001b3	c1 e2 02	 shl	 edx, 2
  001b6	83 c4 04	 add	 esp, 4
  001b9	2b ca		 sub	 ecx, edx
  001bb	d2 e0		 shl	 al, cl
  001bd	08 06		 or	 BYTE PTR [esi], al
  001bf	3b fb		 cmp	 edi, ebx
  001c1	7c cd		 jl	 SHORT $LL8@AddValue
  001c3	8b b5 e0 ee ff
	ff		 mov	 esi, DWORD PTR _cbValDiv2$4[ebp]
$LN7@AddValue:

; 1083 : 			lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);

  001c9	8b 8d dc ee ff
	ff		 mov	 ecx, DWORD PTR _rkParent$GSCopy$[ebp]
  001cf	56		 push	 esi
  001d0	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _rgBinary$7[ebp]
  001d6	6a 03		 push	 3
  001d8	6a 00		 push	 0
  001da	ff b5 e4 ee ff
	ff		 push	 DWORD PTR _szValueName$GSCopy$[ebp]
  001e0	ff 31		 push	 DWORD PTR [ecx]
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  001e8	8b f0		 mov	 esi, eax

; 1084 : 			break;

  001ea	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _rgBinary$7[ebp+4]
  001f0	39 85 e8 ee ff
	ff		 cmp	 DWORD PTR _rgBinary$7[ebp], eax
  001f6	0f 84 0f 02 00
	00		 je	 $LN60@AddValue
  001fc	8d 8d e8 ee ff
	ff		 lea	 ecx, DWORD PTR _rgBinary$7[ebp]
  00202	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
  00207	e9 ff 01 00 00	 jmp	 $LN60@AddValue
$LN12@AddValue:

; 991  : 	{
; 992  : 	case VT_BSTR:
; 993  : 		{
; 994  : 			lRes = rkParent.SetStringValue(szValueName, szValue);

  0020c	6a 01		 push	 1
  0020e	8d 85 ec ef ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  00214	8b cb		 mov	 ecx, ebx
  00216	50		 push	 eax
  00217	57		 push	 edi
  00218	e8 00 00 00 00	 call	 ?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z ; ATL::CRegKey::SetStringValue
  0021d	8b f0		 mov	 esi, eax

; 995  : 			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %Ts at %Ts\n"), szValue, !szValueName ? _T("default") : szValueName);
; 996  : 			break;

  0021f	e9 e7 01 00 00	 jmp	 $LN60@AddValue
$LN21@AddValue:

; 1047 : 		break;
; 1048 : 	case VT_UI4:
; 1049 : 		{
; 1050 : 			ULONG ulVal;
; 1051 : 			USES_CONVERSION_EX;

  00224	c7 85 e4 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR __AtlSafeAllocaManager$6[ebp], 0

; 1052 : 
; 1053 : 			LPOLESTR lpszV = T2OLE_EX(szValue, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  0022e	8d 8d ec ef ff
	ff		 lea	 ecx, DWORD PTR _szValue$[ebp]
  00234	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  0023b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0023e	66 90		 npad	 2
$LL98@AddValue:
  00240	8a 01		 mov	 al, BYTE PTR [ecx]
  00242	41		 inc	 ecx
  00243	84 c0		 test	 al, al
  00245	75 f9		 jne	 SHORT $LL98@AddValue
  00247	2b ca		 sub	 ecx, edx
  00249	6a 02		 push	 2
  0024b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0024e	50		 push	 eax
  0024f	89 85 e0 ee ff
	ff		 mov	 DWORD PTR __convert_ex$5[ebp], eax
  00255	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR __convert_ex$5[ebp]
  0025b	50		 push	 eax
  0025c	e8 00 00 00 00	 call	 ??$AtlMultiply@H@ATL@@YAJPAHHH@Z ; ATL::AtlMultiply<int>
  00261	83 c4 0c	 add	 esp, 12			; 0000000cH
  00264	85 c0		 test	 eax, eax
  00266	0f 88 95 00 00
	00		 js	 $LN96@AddValue
  0026c	8b b5 e0 ee ff
	ff		 mov	 esi, DWORD PTR __convert_ex$5[ebp]
  00272	81 fe 00 04 00
	00		 cmp	 esi, 1024		; 00000400H
  00278	7f 1b		 jg	 SHORT $LN31@AddValue
  0027a	56		 push	 esi
  0027b	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  00280	83 c4 04	 add	 esp, 4
  00283	84 c0		 test	 al, al
  00285	74 0e		 je	 SHORT $LN31@AddValue
  00287	8b c6		 mov	 eax, esi
  00289	e8 00 00 00 00	 call	 __alloca_probe_16
  0028e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00291	8b c4		 mov	 eax, esp
  00293	eb 0c		 jmp	 SHORT $LN32@AddValue
$LN31@AddValue:
  00295	56		 push	 esi
  00296	8d 8d e4 ee ff
	ff		 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$6[ebp]
  0029c	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
$LN32@AddValue:
  002a1	6a 03		 push	 3
  002a3	d1 ee		 shr	 esi, 1
  002a5	8d 8d ec ef ff
	ff		 lea	 ecx, DWORD PTR _szValue$[ebp]
  002ab	56		 push	 esi
  002ac	51		 push	 ecx
  002ad	50		 push	 eax
  002ae	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper

; 1054 : 	#ifndef _UNICODE
; 1055 : 			if(lpszV == NULL)

  002b3	85 c0		 test	 eax, eax
  002b5	74 4a		 je	 SHORT $LN96@AddValue

; 1057 : 	#endif
; 1058 : 
; 1059 : 			hr = VarUI4FromStr(lpszV, 0, 0, &ulVal);

  002b7	8d 8d d4 ee ff
	ff		 lea	 ecx, DWORD PTR _ulVal$3[ebp]
  002bd	51		 push	 ecx
  002be	6a 00		 push	 0
  002c0	6a 00		 push	 0
  002c2	50		 push	 eax
  002c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VarUI4FromStr@16
  002c9	8b f0		 mov	 esi, eax

; 1060 :             if (FAILED(hr))

  002cb	85 f6		 test	 esi, esi
  002cd	79 12		 jns	 SHORT $LN23@AddValue

; 1061 :                 return hr;

  002cf	8d 8d e4 ee ff
	ff		 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$6[ebp]
  002d5	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  002da	8b c6		 mov	 eax, esi
  002dc	e9 55 01 00 00	 jmp	 $LN29@AddValue
$LN23@AddValue:

; 1062 : 
; 1063 : 			lRes = rkParent.SetDWORDValue(szValueName, ulVal);

  002e1	ff b5 d4 ee ff
	ff		 push	 DWORD PTR _ulVal$3[ebp]
  002e7	8b cb		 mov	 ecx, ebx
  002e9	57		 push	 edi
  002ea	e8 00 00 00 00	 call	 ?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z ; ATL::CRegKey::SetDWORDValue

; 1064 : 			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %d at %Ts\n"), ulVal, !szValueName ? _T("default") : szValueName);
; 1065 : 			break;

  002ef	8d 8d e4 ee ff
	ff		 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$6[ebp]
  002f5	8b f0		 mov	 esi, eax
  002f7	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  002fc	e9 0a 01 00 00	 jmp	 $LN60@AddValue
$LN96@AddValue:

; 1056 : 				return E_OUTOFMEMORY;

  00301	8d 8d e4 ee ff
	ff		 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$6[ebp]
  00307	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  0030c	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00311	e9 20 01 00 00	 jmp	 $LN29@AddValue
$LN37@AddValue:
  00316	3d 08 40 00 00	 cmp	 eax, 16392		; 00004008H

; 988  : 		return hr;
; 989  : 
; 990  : 	switch (vt)

  0031b	0f 85 ff 00 00
	00		 jne	 $LN28@AddValue

; 997  : 		}
; 998  : 	case VT_BSTR | VT_BYREF:
; 999  : 		{
; 1000 : 			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %Ts at %Ts\n"), szValue, !szValueName ? _T("default") : szValueName);
; 1001 : 			int nLen = static_cast<int>(_tcslen(szValue) + 2); //Allocate space for double null termination.

  00321	8d 8d ec ef ff
	ff		 lea	 ecx, DWORD PTR _szValue$[ebp]
  00327	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0032a	66 0f 1f 44 00
	00		 npad	 6
$LL99@AddValue:
  00330	8a 01		 mov	 al, BYTE PTR [ecx]
  00332	41		 inc	 ecx
  00333	84 c0		 test	 al, al
  00335	75 f9		 jne	 SHORT $LL99@AddValue
  00337	2b ca		 sub	 ecx, edx

; 1002 : 			CTempBuffer<TCHAR, 256> pszDestValue;

  00339	c7 85 e8 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _pszDestValue$8[ebp], 0
  00343	83 c1 02	 add	 ecx, 2

; 1003 : 			//nLen should be >= the max size of the target buffer.
; 1004 : 			ATLTRY(pszDestValue.Allocate(nLen));

  00346	51		 push	 ecx
  00347	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0034e	8d 8d e8 ee ff
	ff		 lea	 ecx, DWORD PTR _pszDestValue$8[ebp]
  00354	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00358	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate
  0035d	eb 12		 jmp	 SHORT $LN46@AddValue
__catch$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$0:
  0035f	b8 00 00 00 00	 mov	 eax, $LN101@AddValue
  00364	c3		 ret	 0
$LN101@AddValue:
  00365	8b 85 d0 ee ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  0036b	89 85 d8 ee ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
$LN46@AddValue:

; 1005 : 			if (pszDestValue != NULL)

  00371	8b bd e8 ee ff
	ff		 mov	 edi, DWORD PTR _pszDestValue$8[ebp]
  00377	85 ff		 test	 edi, edi
  00379	74 76		 je	 SHORT $LN15@AddValue

; 1006 : 			{
; 1007 : 				TCHAR* p = pszDestValue;
; 1008 : 				TCHAR* q = szValue;
; 1009 : 				nLen = 0;
; 1010 : 				while (*q != _T('\0'))

  0037b	80 bd ec ef ff
	ff 00		 cmp	 BYTE PTR _szValue$[ebp], 0
  00382	8d b5 ec ef ff
	ff		 lea	 esi, DWORD PTR _szValue$[ebp]
  00388	74 41		 je	 SHORT $LN89@AddValue
  0038a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CharNextA@4
$LL4@AddValue:

; 1011 : 				{
; 1012 : 					TCHAR* r = CharNext(q);

  00390	56		 push	 esi
  00391	ff d3		 call	 ebx

; 1013 : 					if (*q == _T('\\') && *r == _T('0'))

  00393	8a 0e		 mov	 cl, BYTE PTR [esi]
  00395	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  00398	75 0f		 jne	 SHORT $LN17@AddValue
  0039a	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  0039d	75 0a		 jne	 SHORT $LN17@AddValue

; 1014 : 					{
; 1015 : 						*p++ = _T('\0');
; 1016 : 						q = CharNext(r);

  0039f	50		 push	 eax
  003a0	c6 07 00	 mov	 BYTE PTR [edi], 0
  003a3	ff d3		 call	 ebx
  003a5	8b f0		 mov	 esi, eax

; 1017 : 					}
; 1018 : 					else

  003a7	eb 1c		 jmp	 SHORT $LN18@AddValue
$LN17@AddValue:

; 1019 : 					{
; 1020 : 						*p = *q;

  003a9	88 0f		 mov	 BYTE PTR [edi], cl

; 1021 : #ifndef _UNICODE
; 1022 : 						if (IsDBCSLeadByte(*q))

  003ab	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  003ae	50		 push	 eax
  003af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4
  003b5	85 c0		 test	 eax, eax
  003b7	74 0b		 je	 SHORT $LN19@AddValue

; 1023 : 						{
; 1024 : 							p++;
; 1025 : 							q++;
; 1026 : 							//Protect from Lead byte followed by the zero terminator.May skip beyond the end of the string.
; 1027 : 							if (*q == _T('\0')) { break; }

  003b9	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  003bc	46		 inc	 esi
  003bd	47		 inc	 edi
  003be	84 c0		 test	 al, al
  003c0	74 09		 je	 SHORT $LN89@AddValue

; 1028 : 							*p = *q;

  003c2	88 07		 mov	 BYTE PTR [edi], al
$LN19@AddValue:

; 1029 : 						}
; 1030 : #endif
; 1031 : 						p++;
; 1032 : 						q++;

  003c4	46		 inc	 esi
$LN18@AddValue:

; 1006 : 			{
; 1007 : 				TCHAR* p = pszDestValue;
; 1008 : 				TCHAR* q = szValue;
; 1009 : 				nLen = 0;
; 1010 : 				while (*q != _T('\0'))

  003c5	47		 inc	 edi
  003c6	80 3e 00	 cmp	 BYTE PTR [esi], 0
  003c9	75 c5		 jne	 SHORT $LL4@AddValue
$LN89@AddValue:

; 1033 : 					}
; 1034 : 					nLen ++;
; 1035 : 				}
; 1036 : 			   //Always terminate with 2 null characters.
; 1037 : 				*p = _T('\0');
; 1038 : 				p++;
; 1039 : 			    *p = _T('\0');
; 1040 : 				lRes = rkParent.SetMultiStringValue(szValueName, pszDestValue);

  003cb	8b 8d dc ee ff
	ff		 mov	 ecx, DWORD PTR _rkParent$GSCopy$[ebp]
  003d1	66 c7 07 00 00	 mov	 WORD PTR [edi], 0
  003d6	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _pszDestValue$8[ebp]
  003dc	ff b5 e4 ee ff
	ff		 push	 DWORD PTR _szValueName$GSCopy$[ebp]
  003e2	e8 00 00 00 00	 call	 ?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z ; ATL::CRegKey::SetMultiStringValue

; 1041 : 			}
; 1042 : 			else

  003e7	8b bd e8 ee ff
	ff		 mov	 edi, DWORD PTR _pszDestValue$8[ebp]
  003ed	8b f0		 mov	 esi, eax
  003ef	eb 05		 jmp	 SHORT $LN16@AddValue
$LN15@AddValue:

; 1043 : 			{
; 1044 : 				lRes = ERROR_OUTOFMEMORY;

  003f1	be 0e 00 00 00	 mov	 esi, 14			; 0000000eH
$LN16@AddValue:

; 1045 : 			}
; 1046 : 		}

  003f6	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _pszDestValue$8[ebp+4]
  003fc	3b f8		 cmp	 edi, eax
  003fe	74 0b		 je	 SHORT $LN60@AddValue
  00400	8d 8d e8 ee ff
	ff		 lea	 ecx, DWORD PTR _pszDestValue$8[ebp]
  00406	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap
$LN60@AddValue:

; 1085 : 		}
; 1086 : 	}
; 1087 : 
; 1088 : 	if (ERROR_SUCCESS != lRes)

  0040b	85 f6		 test	 esi, esi
  0040d	74 0b		 je	 SHORT $LN103@AddValue

; 1089 : 	{
; 1090 : 		nIDRes = E_ATL_VALUE_SET_FAILED;
; 1091 : 		return AtlHresultFromWin32(lRes);

  0040f	56		 push	 esi
  00410	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  00415	83 c4 04	 add	 esp, 4
  00418	eb 1c		 jmp	 SHORT $LN29@AddValue
$LN103@AddValue:
  0041a	8b b5 d8 ee ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
$LN28@AddValue:

; 1092 : 	}
; 1093 : 
; 1094 : 	if (FAILED(hr = NextToken(szToken)))

  00420	ff b5 cc ee ff
	ff		 push	 DWORD PTR _szToken$GSCopy$[ebp]
  00426	8b ce		 mov	 ecx, esi
  00428	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  0042d	33 c9		 xor	 ecx, ecx
  0042f	85 c0		 test	 eax, eax
  00431	0f 48 c8	 cmovs	 ecx, eax
  00434	8b c1		 mov	 eax, ecx
$LN29@AddValue:

; 1095 : 		return hr;
; 1096 : 
; 1097 : 	return S_OK;
; 1098 : }

  00436	8d a5 bc ee ff
	ff		 lea	 esp, DWORD PTR [ebp-4420]
  0043c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0043f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00446	59		 pop	 ecx
  00447	5f		 pop	 edi
  00448	5e		 pop	 esi
  00449	5b		 pop	 ebx
  0044a	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044d	33 cd		 xor	 ecx, ebp
  0044f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00454	8b e5		 mov	 esp, ebp
  00456	5d		 pop	 ebp
  00457	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$6:
  00000	8d 8d e8 ee ff
	ff		 lea	 ecx, DWORD PTR _rgBinary$7[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$5:
  0000b	8d 8d e4 ee ff
	ff		 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$6[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$4:
  00016	8d 8d e8 ee ff
	ff		 lea	 ecx, DWORD PTR _pszDestValue$8[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>
__ehhandler$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a c8 ee ff
	ff		 mov	 ecx, DWORD PTR [edx-4408]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ENDP ; ATL::CRegParser::AddValue
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?NextToken@CRegParser@ATL@@IAEJPAD@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_szOrig$1$ = -4						; size = 4
_pchPrev$1$ = 8						; size = 4
_pchPrev$1$ = 8						; size = 4
_szToken$ = 8						; size = 4
?NextToken@CRegParser@ATL@@IAEJPAD@Z PROC		; ATL::CRegParser::NextToken, COMDAT
; _this$ = ecx

; 901  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	89 5d f8	 mov	 DWORD PTR _this$1$[ebp], ebx

; 902  : 	SkipWhiteSpace();

  0000c	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace

; 903  : 
; 904  : 	// NextToken cannot be called at EOS
; 905  : 	if (_T('\0') == *m_pchCur)

  00011	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00013	8a 01		 mov	 al, BYTE PTR [ecx]
  00015	84 c0		 test	 al, al
  00017	75 0c		 jne	 SHORT $LN12@NextToken

; 906  : 		return GenerateError(E_ATL_UNEXPECTED_EOS);

  00019	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H
  0001e	5b		 pop	 ebx

; 963  : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN12@NextToken:
  00025	56		 push	 esi

; 907  : 
; 908  : 	LPCTSTR szOrig = szToken;

  00026	8b 75 08	 mov	 esi, DWORD PTR _szToken$[ebp]
  00029	89 75 fc	 mov	 DWORD PTR _szOrig$1$[ebp], esi
  0002c	57		 push	 edi

; 909  : 	// handle quoted value / key
; 910  : 	if (chQuote == *m_pchCur)

  0002d	3c 27		 cmp	 al, 39			; 00000027H
  0002f	0f 85 92 00 00
	00		 jne	 $LL7@NextToken

; 911  : 	{
; 912  : 		m_pchCur = CharNext(m_pchCur);

  00035	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CharNextA@4
  0003b	51		 push	 ecx
  0003c	ff d7		 call	 edi
  0003e	89 03		 mov	 DWORD PTR [ebx], eax
$LN75@NextToken:

; 913  : 
; 914  : 		while (_T('\0') != *m_pchCur && !EndOfVar())

  00040	80 38 00	 cmp	 BYTE PTR [eax], 0
  00043	74 63		 je	 SHORT $LN3@NextToken
  00045	8b 03		 mov	 eax, DWORD PTR [ebx]
  00047	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  0004a	75 08		 jne	 SHORT $LN24@NextToken
  0004c	50		 push	 eax
  0004d	ff d7		 call	 edi
  0004f	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  00052	75 54		 jne	 SHORT $LN3@NextToken
$LN24@NextToken:

; 915  : 		{
; 916  : 			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it

  00054	8b 03		 mov	 eax, DWORD PTR [ebx]
  00056	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  00059	75 05		 jne	 SHORT $LN15@NextToken

; 917  : 				m_pchCur = CharNext(m_pchCur);

  0005b	50		 push	 eax
  0005c	ff d7		 call	 edi
  0005e	89 03		 mov	 DWORD PTR [ebx], eax
$LN15@NextToken:

; 918  : 
; 919  : 			LPTSTR pchPrev = m_pchCur;

  00060	8b 03		 mov	 eax, DWORD PTR [ebx]

; 920  : 			m_pchCur = CharNext(m_pchCur);

  00062	50		 push	 eax
  00063	89 45 08	 mov	 DWORD PTR _pchPrev$1$[ebp], eax
  00066	ff d7		 call	 edi

; 921  : 
; 922  : 			INT_PTR nChars = m_pchCur - pchPrev;
; 923  : 
; 924  : 			// Make sure we have room for nChars plus terminating NULL
; 925  : 			if ((szToken + nChars + 1) >= szOrig + MAX_VALUE)

  00068	8b 4d fc	 mov	 ecx, DWORD PTR _szOrig$1$[ebp]
  0006b	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  0006e	8b f8		 mov	 edi, eax
  00070	81 c1 00 10 00
	00		 add	 ecx, 4096		; 00001000H
  00076	89 3b		 mov	 DWORD PTR [ebx], edi
  00078	2b 7d 08	 sub	 edi, DWORD PTR _pchPrev$1$[ebp]
  0007b	03 d7		 add	 edx, edi
  0007d	3b d1		 cmp	 edx, ecx
  0007f	0f 83 ae 00 00
	00		 jae	 $LN42@NextToken

; 926  : 				return GenerateError(E_ATL_VALUE_TOO_LARGE);
; 927  : 
; 928  : 			for (int i = 0; i < (int)nChars; i++, szToken++, pchPrev++)

  00085	85 ff		 test	 edi, edi
  00087	7e 15		 jle	 SHORT $LN5@NextToken
  00089	8b 5d 08	 mov	 ebx, DWORD PTR _pchPrev$1$[ebp]
  0008c	2b de		 sub	 ebx, esi
  0008e	66 90		 npad	 2
$LL45@NextToken:

; 929  : 				*szToken = *pchPrev;

  00090	8a 04 33	 mov	 al, BYTE PTR [ebx+esi]
  00093	88 06		 mov	 BYTE PTR [esi], al
  00095	46		 inc	 esi
  00096	83 ef 01	 sub	 edi, 1
  00099	75 f5		 jne	 SHORT $LL45@NextToken
  0009b	8b 5d f8	 mov	 ebx, DWORD PTR _this$1$[ebp]
$LN5@NextToken:

; 913  : 
; 914  : 		while (_T('\0') != *m_pchCur && !EndOfVar())

  0009e	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CharNextA@4
  000a6	eb 98		 jmp	 SHORT $LN75@NextToken
$LN3@NextToken:

; 930  : 		}
; 931  : 
; 932  : 		if (_T('\0') == *m_pchCur)

  000a8	8b 03		 mov	 eax, DWORD PTR [ebx]
  000aa	80 38 00	 cmp	 BYTE PTR [eax], 0
  000ad	0f 84 80 00 00
	00		 je	 $LN42@NextToken

; 933  : 		{
; 934  : 			ATLTRACE(atlTraceRegistrar, 0, _T("NextToken : Unexpected End of File\n"));
; 935  : 			return GenerateError(E_ATL_UNEXPECTED_EOS);
; 936  : 		}
; 937  : 
; 938  : 		*szToken = _T('\0');

  000b3	c6 06 00	 mov	 BYTE PTR [esi], 0

; 939  : 		m_pchCur = CharNext(m_pchCur);

  000b6	ff 33		 push	 DWORD PTR [ebx]
  000b8	ff d7		 call	 edi
  000ba	5f		 pop	 edi
  000bb	89 03		 mov	 DWORD PTR [ebx], eax

; 961  : 	}
; 962  : 	return S_OK;

  000bd	33 c0		 xor	 eax, eax
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx

; 963  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
$LL7@NextToken:

; 940  : 	}
; 941  : 
; 942  : 	else
; 943  : 	{
; 944  : 		// Handle non-quoted ie parse up till first "White Space"
; 945  : 		while (_T('\0') != *m_pchCur && !IsSpace(*m_pchCur))

  000c7	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c9	89 4d 08	 mov	 DWORD PTR _pchPrev$1$[ebp], ecx
  000cc	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  000cf	83 c0 f7	 add	 eax, -9			; fffffff7H
  000d2	83 f8 17	 cmp	 eax, 23			; 00000017H
  000d5	77 0e		 ja	 SHORT $LN31@NextToken
  000d7	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN64@NextToken[eax]
  000de	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN77@NextToken[eax*4]
$LN31@NextToken:

; 946  : 		{
; 947  : 			LPTSTR pchPrev = m_pchCur;
; 948  : 			m_pchCur = CharNext(m_pchCur);

  000e5	51		 push	 ecx
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4

; 949  : 
; 950  : 			INT_PTR nChars = m_pchCur - pchPrev;
; 951  : 
; 952  : 			// Make sure we have room for nChars plus terminating NULL
; 953  : 			if ((szToken + nChars + 1) >= szOrig + MAX_VALUE)

  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _szOrig$1$[ebp]
  000ef	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  000f2	8b f8		 mov	 edi, eax
  000f4	81 c1 00 10 00
	00		 add	 ecx, 4096		; 00001000H
  000fa	89 3b		 mov	 DWORD PTR [ebx], edi
  000fc	2b 7d 08	 sub	 edi, DWORD PTR _pchPrev$1$[ebp]
  000ff	03 d7		 add	 edx, edi
  00101	3b d1		 cmp	 edx, ecx
  00103	73 2e		 jae	 SHORT $LN42@NextToken

; 955  : 
; 956  : 			for (int i = 0; i < (int)nChars; i++, szToken++, pchPrev++)

  00105	85 ff		 test	 edi, edi
  00107	7e 15		 jle	 SHORT $LN10@NextToken
  00109	8b 5d 08	 mov	 ebx, DWORD PTR _pchPrev$1$[ebp]
  0010c	2b de		 sub	 ebx, esi
  0010e	66 90		 npad	 2
$LL47@NextToken:

; 957  : 				*szToken = *pchPrev;

  00110	8a 04 33	 mov	 al, BYTE PTR [ebx+esi]
  00113	88 06		 mov	 BYTE PTR [esi], al
  00115	46		 inc	 esi
  00116	83 ef 01	 sub	 edi, 1
  00119	75 f5		 jne	 SHORT $LL47@NextToken
  0011b	8b 5d f8	 mov	 ebx, DWORD PTR _this$1$[ebp]
$LN10@NextToken:

; 940  : 	}
; 941  : 
; 942  : 	else
; 943  : 	{
; 944  : 		// Handle non-quoted ie parse up till first "White Space"
; 945  : 		while (_T('\0') != *m_pchCur && !IsSpace(*m_pchCur))

  0011e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00120	80 38 00	 cmp	 BYTE PTR [eax], 0
  00123	75 a2		 jne	 SHORT $LL7@NextToken
$LN8@NextToken:
  00125	5f		 pop	 edi

; 958  : 		}
; 959  : 
; 960  : 		*szToken = _T('\0');

  00126	c6 06 00	 mov	 BYTE PTR [esi], 0

; 961  : 	}
; 962  : 	return S_OK;

  00129	33 c0		 xor	 eax, eax
  0012b	5e		 pop	 esi
  0012c	5b		 pop	 ebx

; 963  : }

  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 04 00	 ret	 4
$LN42@NextToken:
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi

; 954  : 				return GenerateError(E_ATL_VALUE_TOO_LARGE);

  00135	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H
  0013a	5b		 pop	 ebx

; 963  : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 04 00	 ret	 4
  00141	0f 1f 00	 npad	 3
$LN77@NextToken:
  00144	00 00 00 00	 DD	 $LN8@NextToken
  00148	00 00 00 00	 DD	 $LN31@NextToken
$LN64@NextToken:
  0014c	00		 DB	 0
  0014d	00		 DB	 0
  0014e	01		 DB	 1
  0014f	01		 DB	 1
  00150	00		 DB	 0
  00151	01		 DB	 1
  00152	01		 DB	 1
  00153	01		 DB	 1
  00154	01		 DB	 1
  00155	01		 DB	 1
  00156	01		 DB	 1
  00157	01		 DB	 1
  00158	01		 DB	 1
  00159	01		 DB	 1
  0015a	01		 DB	 1
  0015b	01		 DB	 1
  0015c	01		 DB	 1
  0015d	01		 DB	 1
  0015e	01		 DB	 1
  0015f	01		 DB	 1
  00160	01		 DB	 1
  00161	01		 DB	 1
  00162	01		 DB	 1
  00163	00		 DB	 0
?NextToken@CRegParser@ATL@@IAEJPAD@Z ENDP		; ATL::CRegParser::NextToken
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ
_TEXT	SEGMENT
?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ PROC		; ATL::CRegParser::SkipWhiteSpace, COMDAT
; _this$ = ecx

; 894  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
$LL2@SkipWhiteS:

; 895  : 	while(IsSpace(*m_pchCur))

  00003	8b 16		 mov	 edx, DWORD PTR [esi]
  00005	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00008	83 c0 f7	 add	 eax, -9			; fffffff7H
  0000b	83 f8 17	 cmp	 eax, 23			; 00000017H
  0000e	77 19		 ja	 SHORT $LN6@SkipWhiteS
  00010	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN14@SkipWhiteS[eax]
  00017	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN16@SkipWhiteS[eax*4]
$LN8@SkipWhiteS:

; 896  : 		m_pchCur = CharNext(m_pchCur);

  0001e	52		 push	 edx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4
  00025	89 06		 mov	 DWORD PTR [esi], eax
  00027	eb da		 jmp	 SHORT $LL2@SkipWhiteS

; 895  : 	while(IsSpace(*m_pchCur))

$LN6@SkipWhiteS:
  00029	5e		 pop	 esi

; 897  : }

  0002a	c3		 ret	 0
  0002b	90		 npad	 1
$LN16@SkipWhiteS:
  0002c	00 00 00 00	 DD	 $LN8@SkipWhiteS
  00030	00 00 00 00	 DD	 $LN6@SkipWhiteS
$LN14@SkipWhiteS:
  00034	00		 DB	 0
  00035	00		 DB	 0
  00036	01		 DB	 1
  00037	01		 DB	 1
  00038	00		 DB	 0
  00039	01		 DB	 1
  0003a	01		 DB	 1
  0003b	01		 DB	 1
  0003c	01		 DB	 1
  0003d	01		 DB	 1
  0003e	01		 DB	 1
  0003f	01		 DB	 1
  00040	01		 DB	 1
  00041	01		 DB	 1
  00042	01		 DB	 1
  00043	01		 DB	 1
  00044	01		 DB	 1
  00045	01		 DB	 1
  00046	01		 DB	 1
  00047	01		 DB	 1
  00048	01		 DB	 1
  00049	01		 DB	 1
  0004a	01		 DB	 1
  0004b	00		 DB	 0
?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ENDP		; ATL::CRegParser::SkipWhiteSpace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z
_TEXT	SEGMENT
_szRegAtRegister$1$ = -4108				; size = 4
_szReg$ = -4104						; size = 4
_szToken$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_szBuffer$ = 8						; size = 4
_bRegister$ = 12					; size = 4
?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z PROC		; ATL::CRegParser::RegisterBuffer, COMDAT
; _this$ = ecx

; 1345 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 0c 10 00 00	 mov	 eax, 4108		; 0000100cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _szBuffer$[ebp]
  0001a	53		 push	 ebx
  0001b	8b d9		 mov	 ebx, ecx

; 1346 : 	TCHAR   szToken[MAX_VALUE];
; 1347 : 	HRESULT hr = S_OK;
; 1348 : 
; 1349 : 	LPTSTR szReg = NULL;

  0001d	c7 85 f8 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _szReg$[ebp], 0
  00027	56		 push	 esi

; 1350 : 	hr = PreProcessBuffer(szBuffer, &szReg);

  00028	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _szReg$[ebp]
  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 ?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z ; ATL::CRegParser::PreProcessBuffer
  00037	8b f0		 mov	 esi, eax

; 1351 : 	if (FAILED(hr))

  00039	85 f6		 test	 esi, esi
  0003b	78 67		 js	 SHORT $LN1@RegisterBu

; 1352 : 		return hr;
; 1353 : 
; 1354 : 	ATLTRACE(atlTraceRegistrar, 0, _T("%Ts\n"), szReg);
; 1355 : 
; 1356 : 	m_pchCur = szReg;

  0003d	8b 85 f8 ef ff
	ff		 mov	 eax, DWORD PTR _szReg$[ebp]
  00043	89 03		 mov	 DWORD PTR [ebx], eax

; 1357 : 
; 1358 : 	// Preprocess szReg
; 1359 : 
; 1360 : 	while (_T('\0') != *m_pchCur)

  00045	80 38 00	 cmp	 BYTE PTR [eax], 0
  00048	74 4c		 je	 SHORT $LN32@RegisterBu
  0004a	57		 push	 edi
  0004b	0f 1f 44 00 00	 npad	 5
$LL2@RegisterBu:

; 1361 : 	{
; 1362 : 		if (FAILED(hr = NextToken(szToken)))

  00050	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  00056	8b cb		 mov	 ecx, ebx
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  0005e	8b f0		 mov	 esi, eax
  00060	85 f6		 test	 esi, esi
  00062	78 31		 js	 SHORT $LN41@RegisterBu

; 1363 : 			break;
; 1364 : 		HKEY hkBase;
; 1365 : 		if ((hkBase = HKeyFromString(szToken)) == NULL)

  00064	33 ff		 xor	 edi, edi
  00066	33 f6		 xor	 esi, esi
  00068	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL17@RegisterBu:
  00070	ff b6 00 00 00
	00		 push	 DWORD PTR ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B[esi]
  00076	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  0007c	50		 push	 eax
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  00083	85 c0		 test	 eax, eax
  00085	74 2f		 je	 SHORT $LN26@RegisterBu
  00087	83 c6 08	 add	 esi, 8
  0008a	47		 inc	 edi
  0008b	83 fe 70	 cmp	 esi, 112		; 00000070H
  0008e	72 e0		 jb	 SHORT $LL17@RegisterBu
$LN28@RegisterBu:

; 1366 : 		{
; 1367 : 			ATLTRACE(atlTraceRegistrar, 0, _T("HKeyFromString failed on %Ts\n"), szToken);
; 1368 : 			hr = GenerateError(E_ATL_BAD_HKEY);

  00090	be 09 00 02 80	 mov	 esi, -2147352567	; 80020009H
$LN41@RegisterBu:
  00095	5f		 pop	 edi
$LN32@RegisterBu:

; 1400 : 	}
; 1401 : 	CoTaskMemFree(szReg);

  00096	ff b5 f8 ef ff
	ff		 push	 DWORD PTR _szReg$[ebp]
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4

; 1402 : 	return hr;

  000a2	8b c6		 mov	 eax, esi
$LN1@RegisterBu:

; 1403 : }

  000a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a7	5e		 pop	 esi
  000a8	33 cd		 xor	 ecx, ebp
  000aa	5b		 pop	 ebx
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
$LN26@RegisterBu:

; 1363 : 			break;
; 1364 : 		HKEY hkBase;
; 1365 : 		if ((hkBase = HKeyFromString(szToken)) == NULL)

  000b6	8b 3c fd 04 00
	00 00		 mov	 edi, DWORD PTR ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B[edi*8+4]
  000bd	85 ff		 test	 edi, edi
  000bf	74 cf		 je	 SHORT $LN28@RegisterBu

; 1369 : 			break;
; 1370 : 		}
; 1371 : 
; 1372 : 		if (FAILED(hr = NextToken(szToken)))

  000c1	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  000c7	8b cb		 mov	 ecx, ebx
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  000cf	8b f0		 mov	 esi, eax
  000d1	85 f6		 test	 esi, esi
  000d3	78 c0		 js	 SHORT $LN41@RegisterBu

; 1373 : 			break;
; 1374 : 
; 1375 : 		if (chLeftBracket != *szToken)

  000d5	80 bd fc ef ff
	ff 7b		 cmp	 BYTE PTR _szToken$[ebp], 123 ; 0000007bH
  000dc	75 b2		 jne	 SHORT $LN28@RegisterBu

; 1376 : 		{
; 1377 : 			ATLTRACE(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %Ts\n"), szToken);
; 1378 : 			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
; 1379 : 			break;
; 1380 : 		}
; 1381 : 		if (bRegister)

  000de	8b 4d 0c	 mov	 ecx, DWORD PTR _bRegister$[ebp]

; 1382 : 		{
; 1383 : 			LPTSTR szRegAtRegister = m_pchCur;
; 1384 : 			hr = RegisterSubkeys(szToken, hkBase, bRegister);

  000e1	6a 00		 push	 0
  000e3	85 c9		 test	 ecx, ecx
  000e5	74 3e		 je	 SHORT $LN9@RegisterBu
  000e7	8b 03		 mov	 eax, DWORD PTR [ebx]
  000e9	51		 push	 ecx
  000ea	89 85 f4 ef ff
	ff		 mov	 DWORD PTR _szRegAtRegister$1$[ebp], eax
  000f0	8b cb		 mov	 ecx, ebx
  000f2	57		 push	 edi
  000f3	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  000ff	8b f0		 mov	 esi, eax

; 1385 : 			if (FAILED(hr))

  00101	85 f6		 test	 esi, esi
  00103	79 3b		 jns	 SHORT $LN12@RegisterBu

; 1386 : 			{
; 1387 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Failed to register, cleaning up!\n"));
; 1388 : 				m_pchCur = szRegAtRegister;

  00105	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _szRegAtRegister$1$[ebp]

; 1389 : 				RegisterSubkeys(szToken, hkBase, FALSE);

  0010b	8b cb		 mov	 ecx, ebx
  0010d	6a 00		 push	 0
  0010f	6a 00		 push	 0
  00111	89 03		 mov	 DWORD PTR [ebx], eax
  00113	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  00119	57		 push	 edi
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  00120	e9 70 ff ff ff	 jmp	 $LN41@RegisterBu
$LN9@RegisterBu:

; 1390 : 				break;
; 1391 : 			}
; 1392 : 		}
; 1393 : 		else
; 1394 : 		{
; 1395 : 			if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))

  00125	6a 00		 push	 0
  00127	57		 push	 edi
  00128	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  0012e	8b cb		 mov	 ecx, ebx
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  00136	8b f0		 mov	 esi, eax
  00138	85 f6		 test	 esi, esi
  0013a	0f 88 55 ff ff
	ff		 js	 $LN41@RegisterBu
$LN12@RegisterBu:

; 1396 : 				break;
; 1397 : 		}
; 1398 : 
; 1399 : 		SkipWhiteSpace();

  00140	8b cb		 mov	 ecx, ebx
  00142	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace
  00147	8b 03		 mov	 eax, DWORD PTR [ebx]
  00149	80 38 00	 cmp	 BYTE PTR [eax], 0
  0014c	0f 85 fe fe ff
	ff		 jne	 $LL2@RegisterBu

; 1357 : 
; 1358 : 	// Preprocess szReg
; 1359 : 
; 1360 : 	while (_T('\0') != *m_pchCur)

  00152	e9 3e ff ff ff	 jmp	 $LN41@RegisterBu
?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z ENDP		; ATL::CRegParser::RegisterBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
_TEXT	SEGMENT
_ppszReg$GSCopy$1$ = -80				; size = 4
_lpszNext$1$ = -76					; size = 4
_lpszKey$ = -72						; size = 4
_pb$ = -68						; size = 12
_nNestingLevel$1$ = -56					; size = 4
_bRedirectionEnabled$1$ = -51				; size = 1
_bRedirectionPresent$1$ = -50				; size = 1
_bInsideQuotes$1$ = -49					; size = 1
_buf$2 = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpszReg$ = 8						; size = 4
_ppszReg$ = 12						; size = 4
?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z PROC	; ATL::CRegParser::PreProcessBuffer, COMDAT
; _this$ = ecx

; 1174 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx

; 1175 : 	ATLASSERT(lpszReg != NULL);
; 1176 : 	ATLASSERT(ppszReg != NULL);
; 1177 : 
; 1178 : 	if (lpszReg == NULL || ppszReg == NULL)

  0002d	8b 5d 08	 mov	 ebx, DWORD PTR _lpszReg$[ebp]
  00030	8b 45 0c	 mov	 eax, DWORD PTR _ppszReg$[ebp]
  00033	89 45 b0	 mov	 DWORD PTR _ppszReg$GSCopy$1$[ebp], eax
  00036	85 db		 test	 ebx, ebx
  00038	0f 84 95 02 00
	00		 je	 $LN7@PreProcess
  0003e	85 c0		 test	 eax, eax
  00040	0f 84 8d 02 00
	00		 je	 $LN7@PreProcess

; 1180 : 
; 1181 : 	*ppszReg = NULL;
; 1182 : 	int nSize = static_cast<int>(_tcslen(lpszReg))*2;

  00046	8b cb		 mov	 ecx, ebx
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL124@PreProcess:
  00051	8a 01		 mov	 al, BYTE PTR [ecx]
  00053	41		 inc	 ecx
  00054	84 c0		 test	 al, al
  00056	75 f9		 jne	 SHORT $LL124@PreProcess
  00058	2b ca		 sub	 ecx, edx

; 1183 : 	CParseBuffer pb(nSize);

  0005a	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _pb$[ebp], 0
  00061	03 c9		 add	 ecx, ecx
  00063	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00068	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0006b	0f 4c c8	 cmovl	 ecx, eax
  0006e	33 c0		 xor	 eax, eax
  00070	89 4d c0	 mov	 DWORD PTR _pb$[ebp+4], ecx
  00073	77 18		 ja	 SHORT $LN125@PreProcess
  00075	83 f9 ff	 cmp	 ecx, -1
  00078	77 13		 ja	 SHORT $LN125@PreProcess
  0007a	51		 push	 ecx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemAlloc@4
  00081	89 45 c4	 mov	 DWORD PTR _pb$[ebp+8], eax
  00084	85 c0		 test	 eax, eax
  00086	74 0a		 je	 SHORT $LN41@PreProcess
  00088	c6 00 00	 mov	 BYTE PTR [eax], 0
  0008b	eb 05		 jmp	 SHORT $LN41@PreProcess
$LN125@PreProcess:
  0008d	33 c0		 xor	 eax, eax
  0008f	89 45 c4	 mov	 DWORD PTR _pb$[ebp+8], eax
$LN41@PreProcess:
  00092	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1184 : 	if (pb.p == NULL)

  00099	85 c0		 test	 eax, eax
  0009b	0f 84 20 02 00
	00		 je	 $LN37@PreProcess

; 1185 : 		return E_OUTOFMEMORY;
; 1186 : 	m_pchCur = lpszReg;

  000a1	89 1e		 mov	 DWORD PTR [esi], ebx

; 1187 : 	HRESULT hr = S_OK;
; 1188 : 
; 1189 : 	bool bRedirectionEnabled = false;
; 1190 : 	hr = AtlGetPerUserRegistration(&bRedirectionEnabled);
; 1191 : 	if( FAILED(hr) )
; 1192 : 	{
; 1193 : 		return hr;
; 1194 : 	}
; 1195 : 
; 1196 : 	// nNestingLevel is used to avoid checking for unnecessary root key replacements
; 1197 : 	// since all of them are expected to be at the top level.
; 1198 : 	int nNestingLevel = 0;
; 1199 : 	bool bRedirectionPresent = false;
; 1200 : 	bool bInsideQuotes = false;

  000a3	32 c9		 xor	 cl, cl
  000a5	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?_AtlRegisterPerUser@ATL@@3_NA ; ATL::_AtlRegisterPerUser
  000ab	32 c0		 xor	 al, al

; 1201 : 
; 1202 : 	while (*m_pchCur != _T('\0')) // look for end

  000ad	33 ff		 xor	 edi, edi
  000af	88 55 cd	 mov	 BYTE PTR _bRedirectionEnabled$1$[ebp], dl
  000b2	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _nNestingLevel$1$[ebp], 0
  000b9	88 45 ce	 mov	 BYTE PTR _bRedirectionPresent$1$[ebp], al
  000bc	88 4d cf	 mov	 BYTE PTR _bInsideQuotes$1$[ebp], cl
  000bf	38 0b		 cmp	 BYTE PTR [ebx], cl
  000c1	0f 84 de 01 00
	00		 je	 $LN119@PreProcess
  000c7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CharNextA@4
  000cd	0f 1f 00	 npad	 3
$LL2@PreProcess:

; 1203 : 	{
; 1204 : 		if ( true == bRedirectionEnabled )

  000d0	80 fa 01	 cmp	 dl, 1
  000d3	0f 85 d1 00 00
	00		 jne	 $LN22@PreProcess

; 1205 : 		{
; 1206 : 			LPCOLESTR szStartHKCU = L"HKCU\r\n{\tSoftware\r\n\t{\r\n\t\tClasses";
; 1207 : 			LPCOLESTR szEndHKCU = L"\r\n\t}\r\n}\r\n";
; 1208 : 
; 1209 : 			if ( 0 == nNestingLevel )

  000d9	8b 7d c8	 mov	 edi, DWORD PTR _nNestingLevel$1$[ebp]
  000dc	85 ff		 test	 edi, edi
  000de	75 49		 jne	 SHORT $LN12@PreProcess

; 1210 : 			{
; 1211 : 				// Then we should be reading a root key. HKCR, HKCU, etc
; 1212 : 				TCHAR* szRootKey = NULL;
; 1213 : 				if( NULL != ( szRootKey = _tcsstr(m_pchCur, _T("HKCR")) ) &&	// if HKCR is found.

  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_04OHBKMIBJ@HKCR?$AA@
  000e5	ff 36		 push	 DWORD PTR [esi]
  000e7	e8 00 00 00 00	 call	 __mbsstr
  000ec	83 c4 08	 add	 esp, 8
  000ef	85 c0		 test	 eax, eax
  000f1	74 33		 je	 SHORT $LN128@PreProcess
  000f3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f5	3b c1		 cmp	 eax, ecx
  000f7	75 2d		 jne	 SHORT $LN128@PreProcess

; 1214 : 					(szRootKey == m_pchCur) )	// if HKCR is the first token.
; 1215 : 				{
; 1216 : 					// Skip HKCR
; 1217 : 					m_pchCur = CharNext(m_pchCur);

  000f9	51		 push	 ecx
  000fa	ff d3		 call	 ebx

; 1218 : 					m_pchCur = CharNext(m_pchCur);

  000fc	50		 push	 eax
  000fd	89 06		 mov	 DWORD PTR [esi], eax
  000ff	ff d3		 call	 ebx

; 1219 : 					m_pchCur = CharNext(m_pchCur);

  00101	50		 push	 eax
  00102	89 06		 mov	 DWORD PTR [esi], eax
  00104	ff d3		 call	 ebx

; 1220 : 					m_pchCur = CharNext(m_pchCur);

  00106	50		 push	 eax
  00107	89 06		 mov	 DWORD PTR [esi], eax
  00109	ff d3		 call	 ebx

; 1221 : 
; 1222 : 					// Add HKCU
; 1223 : 					if (!pb.AddString(szStartHKCU))

  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AN?$AA?6?$AA?7?$AA?$HL?$AA?$AN?$AA?6?$AA?7?$AA?7?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe?$AAs?$AA?$AA@
  00110	8d 4d bc	 lea	 ecx, DWORD PTR _pb$[ebp]
  00113	89 06		 mov	 DWORD PTR [esi], eax
  00115	e8 00 00 00 00	 call	 ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
  0011a	85 c0		 test	 eax, eax
  0011c	0f 84 9f 01 00
	00		 je	 $LN37@PreProcess

; 1224 : 					{
; 1225 : 						hr = E_OUTOFMEMORY;
; 1226 : 						break;
; 1227 : 					}
; 1228 : 
; 1229 : 					bRedirectionPresent = true;

  00122	c6 45 ce 01	 mov	 BYTE PTR _bRedirectionPresent$1$[ebp], 1
$LN128@PreProcess:
  00126	8a 4d cf	 mov	 cl, BYTE PTR _bInsideQuotes$1$[ebp]
$LN12@PreProcess:

; 1230 : 				}
; 1231 : 			}
; 1232 : 
; 1233 : 			if ( chQuote == *m_pchCur )

  00129	8b 06		 mov	 eax, DWORD PTR [esi]
  0012b	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  0012e	75 3e		 jne	 SHORT $LN19@PreProcess

; 1234 : 			{
; 1235 : 				if( false == bInsideQuotes )

  00130	84 c9		 test	 cl, cl
  00132	75 06		 jne	 SHORT $LN15@PreProcess

; 1236 : 				{
; 1237 : 					bInsideQuotes = true;

  00134	c6 45 cf 01	 mov	 BYTE PTR _bInsideQuotes$1$[ebp], 1

; 1238 : 				}
; 1239 : 				else

  00138	eb 70		 jmp	 SHORT $LN22@PreProcess
$LN15@PreProcess:

; 1240 : 				{
; 1241 : 					// Make sure it is not an escaped sequence.
; 1242 : 					if( EndOfVar() )

  0013a	50		 push	 eax
  0013b	ff d3		 call	 ebx
  0013d	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  00140	74 07		 je	 SHORT $LN17@PreProcess

; 1243 : 					{
; 1244 : 						bInsideQuotes = false;

  00142	32 c0		 xor	 al, al
  00144	88 45 cf	 mov	 BYTE PTR _bInsideQuotes$1$[ebp], al

; 1245 : 					}
; 1246 : 					else

  00147	eb 29		 jmp	 SHORT $LN120@PreProcess
$LN17@PreProcess:

; 1247 : 					{
; 1248 : 						// An escaped single quote...
; 1249 : 						m_pchCur = CharNext(m_pchCur);

  00149	ff 36		 push	 DWORD PTR [esi]
  0014b	ff d3		 call	 ebx
  0014d	8b f8		 mov	 edi, eax

; 1250 : 						if (!pb.AddChar(m_pchCur))

  0014f	57		 push	 edi
  00150	89 3e		 mov	 DWORD PTR [esi], edi
  00152	ff d3		 call	 ebx
  00154	2b c7		 sub	 eax, edi
  00156	8d 4d bc	 lea	 ecx, DWORD PTR _pb$[ebp]
  00159	50		 push	 eax
  0015a	57		 push	 edi
  0015b	e8 00 00 00 00	 call	 ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ; ATL::CRegParser::CParseBuffer::Append
  00160	85 c0		 test	 eax, eax
  00162	0f 84 59 01 00
	00		 je	 $LN37@PreProcess
  00168	8b 7d c8	 mov	 edi, DWORD PTR _nNestingLevel$1$[ebp]
  0016b	8a 4d cf	 mov	 cl, BYTE PTR _bInsideQuotes$1$[ebp]
$LN19@PreProcess:

; 1251 : 						{
; 1252 : 							hr = E_OUTOFMEMORY;
; 1253 : 							break;
; 1254 : 						}
; 1255 : 					}
; 1256 : 				}
; 1257 : 			}
; 1258 : 
; 1259 : 			if ( (false == bInsideQuotes) && (*m_pchCur == _T('{')) )

  0016e	84 c9		 test	 cl, cl
  00170	75 38		 jne	 SHORT $LN22@PreProcess
$LN120@PreProcess:
  00172	8b 06		 mov	 eax, DWORD PTR [esi]
  00174	8a 00		 mov	 al, BYTE PTR [eax]
  00176	3c 7b		 cmp	 al, 123			; 0000007bH
  00178	75 04		 jne	 SHORT $LN121@PreProcess

; 1260 : 			{
; 1261 : 				++nNestingLevel;

  0017a	47		 inc	 edi
  0017b	89 7d c8	 mov	 DWORD PTR _nNestingLevel$1$[ebp], edi
$LN121@PreProcess:

; 1262 : 			}
; 1263 : 
; 1264 : 			if ( (false == bInsideQuotes) && (*m_pchCur == _T('}')) )

  0017e	3c 7d		 cmp	 al, 125			; 0000007dH
  00180	75 28		 jne	 SHORT $LN22@PreProcess

; 1265 : 			{
; 1266 : 				--nNestingLevel;

  00182	83 ef 01	 sub	 edi, 1
  00185	89 7d c8	 mov	 DWORD PTR _nNestingLevel$1$[ebp], edi

; 1267 : 				if ( (0 == nNestingLevel) && (true == bRedirectionPresent) )

  00188	75 20		 jne	 SHORT $LN22@PreProcess
  0018a	80 7d ce 01	 cmp	 BYTE PTR _bRedirectionPresent$1$[ebp], 1
  0018e	75 1a		 jne	 SHORT $LN22@PreProcess

; 1268 : 				{
; 1269 : 					if (!pb.AddString(szEndHKCU))

  00190	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6?$AA?$AA@
  00195	8d 4d bc	 lea	 ecx, DWORD PTR _pb$[ebp]
  00198	e8 00 00 00 00	 call	 ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
  0019d	85 c0		 test	 eax, eax
  0019f	0f 84 1c 01 00
	00		 je	 $LN37@PreProcess

; 1270 : 					{
; 1271 : 						hr = E_OUTOFMEMORY;
; 1272 : 						break;
; 1273 : 					}
; 1274 : 
; 1275 : 					bRedirectionPresent = false;

  001a5	32 c0		 xor	 al, al
  001a7	88 45 ce	 mov	 BYTE PTR _bRedirectionPresent$1$[ebp], al
$LN22@PreProcess:

; 1276 : 				}
; 1277 : 			}
; 1278 : 		}
; 1279 : 
; 1280 : 		if (*m_pchCur == _T('%'))

  001aa	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1281 : 		{
; 1282 : 			m_pchCur = CharNext(m_pchCur);

  001ac	57		 push	 edi
  001ad	80 3f 25	 cmp	 BYTE PTR [edi], 37	; 00000025H
  001b0	75 0c		 jne	 SHORT $LN24@PreProcess
  001b2	ff d3		 call	 ebx
  001b4	8b f8		 mov	 edi, eax
  001b6	89 3e		 mov	 DWORD PTR [esi], edi

; 1283 : 			if (*m_pchCur == _T('%'))

  001b8	80 3f 25	 cmp	 BYTE PTR [edi], 37	; 00000025H
  001bb	75 31		 jne	 SHORT $LN26@PreProcess

; 1284 : 			{
; 1285 : 				if (!pb.AddChar(m_pchCur))

  001bd	57		 push	 edi
$LN24@PreProcess:

; 1325 : 		{
; 1326 : 			if (!pb.AddChar(m_pchCur))

  001be	ff d3		 call	 ebx
  001c0	2b c7		 sub	 eax, edi
  001c2	8d 4d bc	 lea	 ecx, DWORD PTR _pb$[ebp]
  001c5	50		 push	 eax
  001c6	57		 push	 edi
  001c7	e8 00 00 00 00	 call	 ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ; ATL::CRegParser::CParseBuffer::Append
  001cc	85 c0		 test	 eax, eax
  001ce	0f 84 ed 00 00
	00		 je	 $LN37@PreProcess
$LN33@PreProcess:

; 1327 : 			{
; 1328 : 				hr = E_OUTOFMEMORY;
; 1329 : 				break;
; 1330 : 			}
; 1331 : 		}
; 1332 : 
; 1333 : 		m_pchCur = CharNext(m_pchCur);

  001d4	ff 36		 push	 DWORD PTR [esi]
  001d6	ff d3		 call	 ebx
  001d8	89 06		 mov	 DWORD PTR [esi], eax
  001da	80 38 00	 cmp	 BYTE PTR [eax], 0
  001dd	0f 84 c0 00 00
	00		 je	 $LN123@PreProcess

; 1201 : 
; 1202 : 	while (*m_pchCur != _T('\0')) // look for end

  001e3	8a 4d cf	 mov	 cl, BYTE PTR _bInsideQuotes$1$[ebp]
  001e6	8a 55 cd	 mov	 dl, BYTE PTR _bRedirectionEnabled$1$[ebp]
  001e9	e9 e2 fe ff ff	 jmp	 $LL2@PreProcess
$LN26@PreProcess:

; 1286 : 				{
; 1287 : 					hr = E_OUTOFMEMORY;
; 1288 : 					break;
; 1289 : 				}
; 1290 : 			}
; 1291 : 			else
; 1292 : 			{
; 1293 : 				LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));

  001ee	6a 25		 push	 37			; 00000025H
  001f0	57		 push	 edi
  001f1	e8 00 00 00 00	 call	 ?StrChrA@CRegParser@ATL@@KAPADPADD@Z ; ATL::CRegParser::StrChrA
  001f6	83 c4 08	 add	 esp, 8
  001f9	89 45 b4	 mov	 DWORD PTR _lpszNext$1$[ebp], eax

; 1294 : 				if (lpszNext == NULL)

  001fc	85 c0		 test	 eax, eax
  001fe	0f 84 8d 00 00
	00		 je	 $LN107@PreProcess

; 1295 : 				{
; 1296 : 					ATLTRACE(atlTraceRegistrar, 0, _T("Error no closing %% found\n"));
; 1297 : 					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
; 1298 : 					break;
; 1299 : 				}
; 1300 : 				if ((lpszNext-m_pchCur) > 31)

  00204	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00206	2b c1		 sub	 eax, ecx
  00208	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0020b	7f 72		 jg	 SHORT $LN108@PreProcess

; 1301 : 				{
; 1302 : 					hr = E_FAIL;
; 1303 : 					break;
; 1304 : 				}
; 1305 : 				int nLength = int(lpszNext - m_pchCur);
; 1306 : 				TCHAR buf[32];
; 1307 : 				Checked::tcsncpy_s(buf, _countof(buf), m_pchCur, nLength);

  0020d	50		 push	 eax
  0020e	51		 push	 ecx
  0020f	8d 45 d0	 lea	 eax, DWORD PTR _buf$2[ebp]
  00212	6a 20		 push	 32			; 00000020H
  00214	50		 push	 eax
  00215	e8 00 00 00 00	 call	 __mbsnbcpy_s
  0021a	50		 push	 eax
  0021b	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck

; 1308 : 				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);

  00220	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00223	8d 45 d0	 lea	 eax, DWORD PTR _buf$2[ebp]
  00226	83 c4 14	 add	 esp, 20			; 00000014H
  00229	89 45 b8	 mov	 DWORD PTR _lpszKey$[ebp], eax
  0022c	8d 5f 10	 lea	 ebx, DWORD PTR [edi+16]
  0022f	53		 push	 ebx
  00230	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00236	8d 45 b8	 lea	 eax, DWORD PTR _lpszKey$[ebp]
  00239	50		 push	 eax
  0023a	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0023d	e8 00 00 00 00	 call	 ?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup
  00242	53		 push	 ebx
  00243	8b f8		 mov	 edi, eax
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1309 : 				if (lpszVar == NULL)

  0024b	85 ff		 test	 edi, edi
  0024d	74 42		 je	 SHORT $LN107@PreProcess

; 1310 : 				{
; 1311 : 					hr = GenerateError(E_ATL_NOT_IN_MAP);
; 1312 : 					break;
; 1313 : 				}
; 1314 : 				if (!pb.AddString(lpszVar))

  0024f	57		 push	 edi
  00250	8d 4d bc	 lea	 ecx, DWORD PTR _pb$[ebp]
  00253	e8 00 00 00 00	 call	 ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
  00258	85 c0		 test	 eax, eax
  0025a	74 65		 je	 SHORT $LN37@PreProcess

; 1315 : 				{
; 1316 : 					hr = E_OUTOFMEMORY;
; 1317 : 					break;
; 1318 : 				}
; 1319 : 
; 1320 : 				while (m_pchCur != lpszNext)

  0025c	8b 7d b4	 mov	 edi, DWORD PTR _lpszNext$1$[ebp]
  0025f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CharNextA@4
  00265	39 3e		 cmp	 DWORD PTR [esi], edi
  00267	0f 84 67 ff ff
	ff		 je	 $LN33@PreProcess
  0026d	0f 1f 00	 npad	 3
$LL4@PreProcess:

; 1321 : 					m_pchCur = CharNext(m_pchCur);

  00270	ff 36		 push	 DWORD PTR [esi]
  00272	ff d3		 call	 ebx
  00274	89 06		 mov	 DWORD PTR [esi], eax
  00276	3b c7		 cmp	 eax, edi
  00278	75 f6		 jne	 SHORT $LL4@PreProcess

; 1322 : 			}
; 1323 : 		}
; 1324 : 		else

  0027a	e9 55 ff ff ff	 jmp	 $LN33@PreProcess
$LN108@PreProcess:

; 1337 : 	return hr;

  0027f	ff 75 c4	 push	 DWORD PTR _pb$[ebp+8]
  00282	bf 05 40 00 80	 mov	 edi, -2147467259	; 80004005H
  00287	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4
  0028d	8b c7		 mov	 eax, edi
  0028f	eb 47		 jmp	 SHORT $LN1@PreProcess
$LN107@PreProcess:
  00291	ff 75 c4	 push	 DWORD PTR _pb$[ebp+8]
  00294	bf 09 00 02 80	 mov	 edi, -2147352567	; 80020009H
  00299	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4
  0029f	8b c7		 mov	 eax, edi
  002a1	eb 35		 jmp	 SHORT $LN1@PreProcess
$LN123@PreProcess:
  002a3	33 ff		 xor	 edi, edi
$LN119@PreProcess:

; 1334 : 	}
; 1335 : 	if (SUCCEEDED(hr))
; 1336 : 		*ppszReg = pb.Detach();

  002a5	8b 45 c4	 mov	 eax, DWORD PTR _pb$[ebp+8]
  002a8	8b 4d b0	 mov	 ecx, DWORD PTR _ppszReg$GSCopy$1$[ebp]
  002ab	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _pb$[ebp+8], 0

; 1337 : 	return hr;

  002b2	ff 75 c4	 push	 DWORD PTR _pb$[ebp+8]
  002b5	89 01		 mov	 DWORD PTR [ecx], eax
  002b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4
  002bd	8b c7		 mov	 eax, edi
  002bf	eb 17		 jmp	 SHORT $LN1@PreProcess
$LN37@PreProcess:
  002c1	ff 75 c4	 push	 DWORD PTR _pb$[ebp+8]
  002c4	bf 0e 00 07 80	 mov	 edi, -2147024882	; 8007000eH
  002c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4
  002cf	8b c7		 mov	 eax, edi
  002d1	eb 05		 jmp	 SHORT $LN1@PreProcess
$LN7@PreProcess:

; 1179 : 		return E_POINTER;

  002d3	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@PreProcess:

; 1338 : }

  002d8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002db	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002e2	59		 pop	 ecx
  002e3	5f		 pop	 edi
  002e4	5e		 pop	 esi
  002e5	5b		 pop	 ebx
  002e6	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e9	33 cd		 xor	 ecx, ebp
  002eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f0	8b e5		 mov	 esp, ebp
  002f2	5d		 pop	 ebp
  002f3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z$0:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR _pb$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CParseBuffer@CRegParser@ATL@@QAE@XZ ; ATL::CRegParser::CParseBuffer::~CParseBuffer
__ehhandler$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z ENDP	; ATL::CRegParser::PreProcessBuffer
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z
_TEXT	SEGMENT
_pRegObj$ = 8						; size = 4
??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z PROC		; ATL::CRegParser::CRegParser, COMDAT
; _this$ = ecx

; 874  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 	m_pRegObj = pRegObj;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pRegObj$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 876  : 	m_pchCur = NULL;
; 877  : }

  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z ENDP		; ATL::CRegParser::CRegParser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Free@?$CAutoVectorPtr@_W@ATL@@QAEXXZ
_TEXT	SEGMENT
?Free@?$CAutoVectorPtr@_W@ATL@@QAEXXZ PROC		; ATL::CAutoVectorPtr<wchar_t>::Free, COMDAT
; _this$ = ecx

; 834  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 835  : 		delete[] m_p;

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000a	83 c4 04	 add	 esp, 4

; 836  : 		m_p = NULL;

  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00013	5e		 pop	 esi

; 837  : 	}

  00014	c3		 ret	 0
?Free@?$CAutoVectorPtr@_W@ATL@@QAEXXZ ENDP		; ATL::CAutoVectorPtr<wchar_t>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Detach@?$CAutoVectorPtr@_W@ATL@@QAEPA_WXZ
_TEXT	SEGMENT
?Detach@?$CAutoVectorPtr@_W@ATL@@QAEPA_WXZ PROC		; ATL::CAutoVectorPtr<wchar_t>::Detach, COMDAT
; _this$ = ecx

; 825  : 		T* p;
; 826  : 
; 827  : 		p = m_p;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 828  : 		m_p = NULL;

  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 829  : 
; 830  : 		return( p );
; 831  : 	}

  00008	c3		 ret	 0
?Detach@?$CAutoVectorPtr@_W@ATL@@QAEPA_WXZ ENDP		; ATL::CAutoVectorPtr<wchar_t>::Detach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Attach@?$CAutoVectorPtr@_W@ATL@@QAEXPA_W@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Attach@?$CAutoVectorPtr@_W@ATL@@QAEXPA_W@Z PROC	; ATL::CAutoVectorPtr<wchar_t>::Attach, COMDAT
; _this$ = ecx

; 818  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 819  : 		ATLASSUME( m_p == NULL );
; 820  : 		m_p = p;

  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 821  : 	}

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?Attach@?$CAutoVectorPtr@_W@ATL@@QAEXPA_W@Z ENDP	; ATL::CAutoVectorPtr<wchar_t>::Attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1?$CAutoVectorPtr@_W@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CAutoVectorPtr@_W@ATL@@QAE@XZ PROC			; ATL::CAutoVectorPtr<wchar_t>::~CAutoVectorPtr<wchar_t>, COMDAT
; _this$ = ecx

; 749  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 750  : 		Free();

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000a	83 c4 04	 add	 esp, 4
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00013	5e		 pop	 esi

; 751  : 	}

  00014	c3		 ret	 0
??1?$CAutoVectorPtr@_W@ATL@@QAE@XZ ENDP			; ATL::CAutoVectorPtr<wchar_t>::~CAutoVectorPtr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0?$CAutoVectorPtr@_W@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CAutoVectorPtr@_W@ATL@@QAE@XZ PROC			; ATL::CAutoVectorPtr<wchar_t>::CAutoVectorPtr<wchar_t>, COMDAT
; _this$ = ecx

; 737  : 		m_p( NULL )

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 739  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CAutoVectorPtr@_W@ATL@@QAE@XZ ENDP			; ATL::CAutoVectorPtr<wchar_t>::CAutoVectorPtr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Free@?$CAutoVectorPtr@D@ATL@@QAEXXZ
_TEXT	SEGMENT
?Free@?$CAutoVectorPtr@D@ATL@@QAEXXZ PROC		; ATL::CAutoVectorPtr<char>::Free, COMDAT
; _this$ = ecx

; 834  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 835  : 		delete[] m_p;

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000a	83 c4 04	 add	 esp, 4

; 836  : 		m_p = NULL;

  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00013	5e		 pop	 esi

; 837  : 	}

  00014	c3		 ret	 0
?Free@?$CAutoVectorPtr@D@ATL@@QAEXXZ ENDP		; ATL::CAutoVectorPtr<char>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Detach@?$CAutoVectorPtr@D@ATL@@QAEPADXZ
_TEXT	SEGMENT
?Detach@?$CAutoVectorPtr@D@ATL@@QAEPADXZ PROC		; ATL::CAutoVectorPtr<char>::Detach, COMDAT
; _this$ = ecx

; 825  : 		T* p;
; 826  : 
; 827  : 		p = m_p;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 828  : 		m_p = NULL;

  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 829  : 
; 830  : 		return( p );
; 831  : 	}

  00008	c3		 ret	 0
?Detach@?$CAutoVectorPtr@D@ATL@@QAEPADXZ ENDP		; ATL::CAutoVectorPtr<char>::Detach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Attach@?$CAutoVectorPtr@D@ATL@@QAEXPAD@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Attach@?$CAutoVectorPtr@D@ATL@@QAEXPAD@Z PROC		; ATL::CAutoVectorPtr<char>::Attach, COMDAT
; _this$ = ecx

; 818  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 819  : 		ATLASSUME( m_p == NULL );
; 820  : 		m_p = p;

  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 821  : 	}

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?Attach@?$CAutoVectorPtr@D@ATL@@QAEXPAD@Z ENDP		; ATL::CAutoVectorPtr<char>::Attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1?$CAutoVectorPtr@D@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CAutoVectorPtr@D@ATL@@QAE@XZ PROC			; ATL::CAutoVectorPtr<char>::~CAutoVectorPtr<char>, COMDAT
; _this$ = ecx

; 749  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 750  : 		Free();

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000a	83 c4 04	 add	 esp, 4
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00013	5e		 pop	 esi

; 751  : 	}

  00014	c3		 ret	 0
??1?$CAutoVectorPtr@D@ATL@@QAE@XZ ENDP			; ATL::CAutoVectorPtr<char>::~CAutoVectorPtr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0?$CAutoVectorPtr@D@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CAutoVectorPtr@D@ATL@@QAE@XZ PROC			; ATL::CAutoVectorPtr<char>::CAutoVectorPtr<char>, COMDAT
; _this$ = ecx

; 737  : 		m_p( NULL )

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 739  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CAutoVectorPtr@D@ATL@@QAE@XZ ENDP			; ATL::CAutoVectorPtr<char>::CAutoVectorPtr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CExpansionVector@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CExpansionVector@ATL@@QAE@XZ PROC			; ATL::CExpansionVector::CExpansionVector, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b c1		 mov	 eax, ecx
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0000f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00016	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CExpansionVector@ATL@@QAE@XZ ENDP			; ATL::CExpansionVector::CExpansionVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ
_TEXT	SEGMENT
?ClearReplacements@CExpansionVector@ATL@@QAEJXZ PROC	; ATL::CExpansionVector::ClearReplacements, COMDAT
; _this$ = ecx

; 152  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 153  : 		for (int i = 0; i < GetSize(); i++)

  00004	33 f6		 xor	 esi, esi
  00006	39 77 08	 cmp	 DWORD PTR [edi+8], esi
  00009	7e 34		 jle	 SHORT $LN3@ClearRepla
  0000b	0f 1f 44 00 00	 npad	 5
$LL4@ClearRepla:

; 154  : 		{
; 155  : 			delete []GetKeyAt(i);

  00010	85 f6		 test	 esi, esi
  00012	78 63		 js	 SHORT $LN31@ClearRepla
  00014	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00017	7d 5e		 jge	 SHORT $LN31@ClearRepla
  00019	8b 07		 mov	 eax, DWORD PTR [edi]
  0001b	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  0001e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00023	83 c4 04	 add	 esp, 4

; 156  : 			delete []GetValueAt(i);

  00026	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00029	7d 4c		 jge	 SHORT $LN31@ClearRepla
  0002b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002e	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  00031	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00036	46		 inc	 esi
  00037	83 c4 04	 add	 esp, 4
  0003a	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  0003d	7c d1		 jl	 SHORT $LL4@ClearRepla
$LN3@ClearRepla:

; 157  : 		}
; 158  : 		RemoveAll();

  0003f	8b 07		 mov	 eax, DWORD PTR [edi]
  00041	85 c0		 test	 eax, eax
  00043	74 0f		 je	 SHORT $LN25@ClearRepla
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _free
  0004b	83 c4 04	 add	 esp, 4
  0004e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN25@ClearRepla:
  00054	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00057	85 c0		 test	 eax, eax
  00059	74 10		 je	 SHORT $LN26@ClearRepla
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _free
  00061	83 c4 04	 add	 esp, 4
  00064	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$LN26@ClearRepla:
  0006b	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 159  : 		return S_OK;

  00072	33 c0		 xor	 eax, eax
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi

; 160  : 	}

  00076	c3		 ret	 0
$LN31@ClearRepla:

; 156  : 			delete []GetValueAt(i);

  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	6a 01		 push	 1
  0007d	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN40@ClearRepla:
$LN39@ClearRepla:
  00088	cc		 int	 3
?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ENDP	; ATL::CExpansionVector::ClearReplacements
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z
_TEXT	SEGMENT
_spValue$ = -40						; size = 4
_spKey$ = -36						; size = 4
_this$1$ = -32						; size = 4
_szKey$ = -28						; size = 4
_szValue$ = -24						; size = 4
_cbValue$1$ = -20					; size = 4
_cbKey$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lpszKey$ = 8						; size = 4
_lpszValue$ = 12					; size = 4
?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z PROC		; ATL::CExpansionVector::Add, COMDAT
; _this$ = ecx

; 111  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d e0	 mov	 DWORD PTR _this$1$[ebp], ecx

; 112  : 		ATLASSERT(lpszKey != NULL && lpszValue != NULL);
; 113  : 		if (lpszKey == NULL || lpszValue == NULL)

  0002b	8b 45 08	 mov	 eax, DWORD PTR _lpszKey$[ebp]
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 09 01 00
	00		 je	 $LN9@Add
  00036	8b 75 0c	 mov	 esi, DWORD PTR _lpszValue$[ebp]
  00039	85 f6		 test	 esi, esi
  0003b	0f 84 fe 00 00
	00		 je	 $LN9@Add

; 115  : 
; 116  : 		HRESULT hRes = S_OK;
; 117  : 
; 118  : 		size_t cbKey = (_tcslen(lpszKey)+1)*sizeof(TCHAR);

  00041	8b c8		 mov	 ecx, eax
  00043	33 db		 xor	 ebx, ebx
  00045	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL52@Add:
  00048	8a 01		 mov	 al, BYTE PTR [ecx]
  0004a	41		 inc	 ecx
  0004b	84 c0		 test	 al, al
  0004d	75 f9		 jne	 SHORT $LL52@Add
  0004f	2b ca		 sub	 ecx, edx

; 119  : 		TCHAR* szKey = NULL;
; 120  : 
; 121  : 		szKey = _ATL_NEW TCHAR[cbKey];

  00051	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00056	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00059	50		 push	 eax
  0005a	89 45 f0	 mov	 DWORD PTR _cbKey$1$[ebp], eax
  0005d	e8 00 00 00 00	 call	 ??_U@YAPAXIABUnothrow_t@std@@@Z ; operator new[]
  00062	8b f8		 mov	 edi, eax
  00064	83 c4 08	 add	 esp, 8
  00067	89 7d e4	 mov	 DWORD PTR _szKey$[ebp], edi

; 122  : 		CAutoVectorPtr<TCHAR> spKey;
; 123  : 		ATLASSUME(szKey != NULL);
; 124  : 		spKey.Attach(szKey);
; 125  : 
; 126  : 		size_t cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR);

  0006a	8b ce		 mov	 ecx, esi
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00073	89 7d dc	 mov	 DWORD PTR _spKey$[ebp], edi
  00076	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL53@Add:
  00080	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00083	83 c1 02	 add	 ecx, 2
  00086	66 85 c0	 test	 ax, ax
  00089	75 f5		 jne	 SHORT $LL53@Add
  0008b	2b ca		 sub	 ecx, edx

; 127  : 		LPOLESTR szValue = NULL;
; 128  : 		szValue = _ATL_NEW OLECHAR[cbValue];

  0008d	ba 02 00 00 00	 mov	 edx, 2
  00092	d1 f9		 sar	 ecx, 1
  00094	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00099	8d 04 4d 02 00
	00 00		 lea	 eax, DWORD PTR [ecx*2+2]
  000a0	33 c9		 xor	 ecx, ecx
  000a2	89 45 ec	 mov	 DWORD PTR _cbValue$1$[ebp], eax
  000a5	f7 e2		 mul	 edx
  000a7	0f 90 c1	 seto	 cl
  000aa	f7 d9		 neg	 ecx
  000ac	0b c8		 or	 ecx, eax
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 ??_U@YAPAXIABUnothrow_t@std@@@Z ; operator new[]
  000b4	8b f0		 mov	 esi, eax
  000b6	83 c4 08	 add	 esp, 8
  000b9	89 75 e8	 mov	 DWORD PTR _szValue$[ebp], esi

; 129  : 		CAutoVectorPtr<OLECHAR> spValue;

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 130  : 		ATLASSUME(szValue != NULL);
; 131  : 		spValue.Attach(szValue);

  000c0	89 75 d8	 mov	 DWORD PTR _spValue$[ebp], esi

; 132  : 
; 133  : 		if (szKey == NULL || szValue == NULL)

  000c3	85 ff		 test	 edi, edi
  000c5	74 49		 je	 SHORT $LN12@Add
  000c7	85 f6		 test	 esi, esi
  000c9	74 45		 je	 SHORT $LN12@Add

; 135  : 		else
; 136  : 		{
; 137  : 			Checked::memcpy_s(szKey, cbKey, lpszKey, cbKey);

  000cb	8b 45 f0	 mov	 eax, DWORD PTR _cbKey$1$[ebp]
  000ce	50		 push	 eax
  000cf	ff 75 08	 push	 DWORD PTR _lpszKey$[ebp]
  000d2	50		 push	 eax
  000d3	57		 push	 edi
  000d4	e8 00 00 00 00	 call	 _memcpy_s
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck

; 138  : 			Checked::memcpy_s(szValue, cbValue, lpszValue, cbValue);

  000df	8b 45 ec	 mov	 eax, DWORD PTR _cbValue$1$[ebp]
  000e2	50		 push	 eax
  000e3	ff 75 0c	 push	 DWORD PTR _lpszValue$[ebp]
  000e6	50		 push	 eax
  000e7	56		 push	 esi
  000e8	e8 00 00 00 00	 call	 _memcpy_s
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck

; 139  : 			if (!CSimpleMap<LPTSTR, LPOLESTR, CExpansionVectorEqualHelper>::Add(szKey, szValue))

  000f3	8b 4d e0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000f6	8d 45 e8	 lea	 eax, DWORD PTR _szValue$[ebp]
  000f9	83 c4 28	 add	 esp, 40			; 00000028H
  000fc	50		 push	 eax
  000fd	8d 45 e4	 lea	 eax, DWORD PTR _szKey$[ebp]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add
  00106	85 c0		 test	 eax, eax
  00108	74 06		 je	 SHORT $LN12@Add

; 140  : 				hRes = E_OUTOFMEMORY;
; 141  : 		}
; 142  : 		if (SUCCEEDED(hRes))
; 143  : 		{
; 144  : 			spKey.Detach();

  0010a	33 ff		 xor	 edi, edi

; 145  : 			spValue.Detach();

  0010c	33 f6		 xor	 esi, esi
  0010e	eb 05		 jmp	 SHORT $LN14@Add
$LN12@Add:

; 134  : 			hRes = E_OUTOFMEMORY;

  00110	bb 0e 00 07 80	 mov	 ebx, -2147024882	; 8007000eH
$LN14@Add:

; 146  : 		}
; 147  : 		return SUCCEEDED(hRes);

  00115	56		 push	 esi
  00116	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0011b	57		 push	 edi
  0011c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00121	f7 d3		 not	 ebx
  00123	83 c4 08	 add	 esp, 8
  00126	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00129	8b c3		 mov	 eax, ebx

; 148  : 	}

  0012b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00135	59		 pop	 ecx
  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c2 08 00	 ret	 8
$LN9@Add:

; 114  : 			return FALSE;

  0013f	33 c0		 xor	 eax, eax

; 148  : 	}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014b	59		 pop	 ecx
  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _spKey$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAutoVectorPtr@D@ATL@@QAE@XZ ; ATL::CAutoVectorPtr<char>::~CAutoVectorPtr<char>
__unwindfunclet$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR _spValue$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CAutoVectorPtr@_W@ATL@@QAE@XZ ; ATL::CAutoVectorPtr<wchar_t>::~CAutoVectorPtr<wchar_t>
__ehhandler$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z ENDP		; ATL::CExpansionVector::Add
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ??1CExpansionVector@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CExpansionVector@ATL@@QAE@XZ PROC			; ATL::CExpansionVector::~CExpansionVector, COMDAT
; _this$ = ecx

; 103  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 104  : 		 ClearReplacements();

  00003	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements

; 105  : 	}

  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 0f		 je	 SHORT $LN10@CExpansion
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _free
  00014	83 c4 04	 add	 esp, 4
  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN10@CExpansion:
  0001d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00020	85 c0		 test	 eax, eax
  00022	74 10		 je	 SHORT $LN17@CExpansion
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _free
  0002a	83 c4 04	 add	 esp, 4
  0002d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN17@CExpansion:
  00034	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0003b	5e		 pop	 esi
  0003c	c3		 ret	 0
??1CExpansionVector@ATL@@QAE@XZ ENDP			; ATL::CExpansionVector::~CExpansionVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?InternalSetAtIndex@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQA_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
$T1 = 8							; size = 4
$T2 = 8							; size = 4
_nIndex$ = 8						; size = 4
_key$ = 12						; size = 4
_val$ = 16						; size = 4
?InternalSetAtIndex@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQA_W@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex, COMDAT
; _this$ = ecx

; 513  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 514  : 		new(m_aKey + nIndex) Wrapper<TKey>(key);

  00004	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	56		 push	 esi
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00014	03 d6		 add	 edx, esi
  00016	89 55 08	 mov	 DWORD PTR $T2[ebp], edx
  00019	74 07		 je	 SHORT $LN3@InternalSe
  0001b	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 02		 mov	 DWORD PTR [edx], eax
$LN3@InternalSe:

; 515  : 		new(m_aVal + nIndex) Wrapper<TVal>(val);

  00022	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00025	03 ce		 add	 ecx, esi
  00027	89 4d 08	 mov	 DWORD PTR $T1[ebp], ecx
  0002a	5e		 pop	 esi
  0002b	74 07		 je	 SHORT $LN5@InternalSe
  0002d	8b 45 10	 mov	 eax, DWORD PTR _val$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 01		 mov	 DWORD PTR [ecx], eax
$LN5@InternalSe:

; 516  : 	}

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 0c 00	 ret	 12			; 0000000cH
?InternalSetAtIndex@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQA_W@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?FindKey@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?FindKey@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey, COMDAT
; _this$ = ecx

; 455  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 456  : 		for(int i = 0; i < m_nSize; i++)

  00008	33 f6		 xor	 esi, esi
  0000a	39 77 08	 cmp	 DWORD PTR [edi+8], esi
  0000d	7e 1a		 jle	 SHORT $LN3@FindKey
  0000f	8b 5d 08	 mov	 ebx, DWORD PTR _key$[ebp]
$LL4@FindKey:

; 457  : 		{
; 458  : 			if(TEqual::IsEqualKey(m_aKey[i], key))

  00012	8b 07		 mov	 eax, DWORD PTR [edi]
  00014	ff 33		 push	 DWORD PTR [ebx]
  00016	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  0001f	85 c0		 test	 eax, eax
  00021	74 10		 je	 SHORT $LN11@FindKey

; 456  : 		for(int i = 0; i < m_nSize; i++)

  00023	46		 inc	 esi
  00024	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00027	7c e9		 jl	 SHORT $LL4@FindKey
$LN3@FindKey:
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 460  : 		}
; 461  : 		return -1;  // not found

  0002b	83 c8 ff	 or	 eax, -1
  0002e	5b		 pop	 ebx

; 462  : 	}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN11@FindKey:
  00033	5f		 pop	 edi

; 459  : 				return i;

  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 462  : 	}

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?FindKey@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetValueAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetValueAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetValueAt, COMDAT
; _this$ = ecx

; 446  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 448  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0f		 js	 SHORT $LN3@GetValueAt
  0000a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0000d	7d 0a		 jge	 SHORT $LN3@GetValueAt

; 450  : 
; 451  : 		return m_aVal[nIndex];

  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00012	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 452  : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN3@GetValueAt:

; 449  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	6a 01		 push	 1
  0001f	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN9@GetValueAt:
$LN8@GetValueAt:
  0002a	cc		 int	 3
?GetValueAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetValueAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetKeyAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetKeyAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetKeyAt, COMDAT
; _this$ = ecx

; 438  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 440  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0e		 js	 SHORT $LN3@GetKeyAt
  0000a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0000d	7d 09		 jge	 SHORT $LN3@GetKeyAt

; 442  : 
; 443  : 		return m_aKey[nIndex];

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 444  : 	}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@GetKeyAt:

; 441  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 01		 push	 1
  0001e	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN9@GetKeyAt:
$LN8@GetKeyAt:
  00029	cc		 int	 3
?GetKeyAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetKeyAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup, COMDAT
; _this$ = ecx

; 424  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 425  : 		int nIndex = FindKey(key);

  00008	33 f6		 xor	 esi, esi
  0000a	39 77 08	 cmp	 DWORD PTR [edi+8], esi
  0000d	7e 1a		 jle	 SHORT $LN26@Lookup
  0000f	8b 5d 08	 mov	 ebx, DWORD PTR _key$[ebp]
$LL7@Lookup:
  00012	8b 07		 mov	 eax, DWORD PTR [edi]
  00014	ff 33		 push	 DWORD PTR [ebx]
  00016	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  0001f	85 c0		 test	 eax, eax
  00021	74 0f		 je	 SHORT $LN4@Lookup
  00023	46		 inc	 esi
  00024	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00027	7c e9		 jl	 SHORT $LL7@Lookup
$LN26@Lookup:
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 427  : 			return NULL;    // must be able to convert

  0002b	33 c0		 xor	 eax, eax
  0002d	5b		 pop	 ebx

; 429  : 	}

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4

; 425  : 		int nIndex = FindKey(key);

$LN4@Lookup:

; 426  : 		if(nIndex == -1)

  00032	83 fe ff	 cmp	 esi, -1
  00035	74 f2		 je	 SHORT $LN26@Lookup

; 428  : 		return GetValueAt(nIndex);

  00037	85 f6		 test	 esi, esi
  00039	78 12		 js	 SHORT $LN15@Lookup
  0003b	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  0003e	7d 0d		 jge	 SHORT $LN15@Lookup
  00040	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00043	5f		 pop	 edi
  00044	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx

; 429  : 	}

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4

; 428  : 		return GetValueAt(nIndex);

$LN15@Lookup:
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	6a 01		 push	 1
  00053	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN31@Lookup:
$LN30@Lookup:
  0005e	cc		 int	 3
?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::RemoveAll, COMDAT
; _this$ = ecx

; 391  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 392  : 		if(m_aKey != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN5@RemoveAll

; 393  : 		{
; 394  : 			for(int i = 0; i < m_nSize; i++)
; 395  : 			{
; 396  : 				m_aKey[i].~TKey();
; 397  : 				m_aVal[i].~TVal();
; 398  : 			}
; 399  : 			free(m_aKey);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4

; 400  : 			m_aKey = NULL;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN5@RemoveAll:

; 401  : 		}
; 402  : 		if(m_aVal != NULL)

  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 10		 je	 SHORT $LN12@RemoveAll

; 403  : 		{
; 404  : 			free(m_aVal);

  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _free
  00025	83 c4 04	 add	 esp, 4

; 405  : 			m_aVal = NULL;

  00028	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN12@RemoveAll:

; 406  : 		}
; 407  : 
; 408  : 		m_nSize = 0;

  0002f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00036	5e		 pop	 esi

; 409  : 	}

  00037	c3		 ret	 0
?RemoveAll@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_val$ = 12						; size = 4
?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add, COMDAT
; _this$ = ecx

; 345  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 346  : 		TKey* pKey;
; 347  : 		pKey = (TKey*)_recalloc(m_aKey, (m_nSize + 1), sizeof(TKey));

  00006	6a 04		 push	 4
  00008	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 __recalloc
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  : 		if(pKey == NULL)

  00017	85 c0		 test	 eax, eax
  00019	75 07		 jne	 SHORT $LN2@Add
$LN19@Add:

; 349  : 			return FALSE;

  0001b	33 c0		 xor	 eax, eax
  0001d	5e		 pop	 esi

; 359  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
$LN2@Add:

; 350  : 		m_aKey = pKey;

  00022	89 06		 mov	 DWORD PTR [esi], eax

; 351  : 		TVal* pVal;
; 352  : 		pVal = (TVal*)_recalloc(m_aVal, (m_nSize + 1), sizeof(TVal));

  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	6a 04		 push	 4
  00029	40		 inc	 eax
  0002a	50		 push	 eax
  0002b	ff 76 04	 push	 DWORD PTR [esi+4]
  0002e	e8 00 00 00 00	 call	 __recalloc
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 353  : 		if(pVal == NULL)

  00036	85 c0		 test	 eax, eax
  00038	74 e1		 je	 SHORT $LN19@Add

; 354  : 			return FALSE;
; 355  : 		m_aVal = pVal;
; 356  : 		InternalSetAtIndex(m_nSize, key, val);

  0003a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0003f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00042	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  00049	03 ca		 add	 ecx, edx
  0004b	74 07		 je	 SHORT $LN7@Add
  0004d	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@Add:
  00054	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00057	03 ca		 add	 ecx, edx
  00059	74 07		 je	 SHORT $LN9@Add
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _val$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Add:

; 357  : 		m_nSize++;

  00062	ff 46 08	 inc	 DWORD PTR [esi+8]

; 358  : 		return TRUE;

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	5e		 pop	 esi

; 359  : 	}

  0006b	5d		 pop	 ebp
  0006c	c2 08 00	 ret	 8
?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetSize, COMDAT
; _this$ = ecx

; 340  : 		return m_nSize;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 341  : 	}

  00003	c3		 ret	 0
?GetSize@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::~CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>, COMDAT
; _this$ = ecx

; 333  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 334  : 		RemoveAll();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN7@CSimpleMap
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN7@CSimpleMap:
  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 10		 je	 SHORT $LN14@CSimpleMap
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _free
  00025	83 c4 04	 add	 esp, 4
  00028	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN14@CSimpleMap:
  0002f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00036	5e		 pop	 esi

; 335  : 	}

  00037	c3		 ret	 0
??1?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::~CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>, COMDAT
; _this$ = ecx

; 328  : 		m_aKey(NULL), m_aVal(NULL), m_nSize(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 330  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\statreg.h
;	COMDAT ?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z
_TEXT	SEGMENT
_k1$ = 8						; size = 4
_k2$ = 12						; size = 4
?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z PROC ; ATL::CExpansionVectorEqualHelper::IsEqualKey, COMDAT

; 82   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 83   : 		if (lstrcmpi(k1, k2) == 0)

  00003	ff 75 0c	 push	 DWORD PTR _k2$[ebp]
  00006	ff 75 08	 push	 DWORD PTR _k1$[ebp]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  0000f	85 c0		 test	 eax, eax
  00011	0f 94 c0	 sete	 al

; 84   : 			return true;
; 85   : 		return false;
; 86   : 	}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z ENDP ; ATL::CExpansionVectorEqualHelper::IsEqualKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?DeleteValue@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT
_lpszValue$ = 8						; size = 4
?DeleteValue@CRegKey@ATL@@QAEJPBD@Z PROC		; ATL::CRegKey::DeleteValue, COMDAT
; _this$ = ecx

; 5793 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5794 : 	ATLASSUME(m_hKey != NULL);
; 5795 : 	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);

  00003	ff 75 08	 push	 DWORD PTR _lpszValue$[ebp]
  00006	ff 31		 push	 DWORD PTR [ecx]
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueA@8

; 5796 : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?DeleteValue@CRegKey@ATL@@QAEJPBD@Z ENDP		; ATL::CRegKey::DeleteValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT
_time$ = -292						; size = 8
_this$GSCopy$1$ = -284					; size = 4
_lpszKey$GSCopy$1$ = -280				; size = 4
_key$ = -276						; size = 12
_dwSize$ = -264						; size = 4
_szBuffer$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpszKey$ = 8						; size = 4
?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z PROC		; ATL::CRegKey::RecurseDeleteKey, COMDAT
; _this$ = ecx

; 6335 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6336 : 	CRegKey key;
; 6337 : 	LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE | m_samWOW64);

  00013	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00016	8b 55 08	 mov	 edx, DWORD PTR _lpszKey$[ebp]
  00019	0d 1f 00 02 00	 or	 eax, 131103		; 0002001fH
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	52		 push	 edx
  00021	ff 31		 push	 DWORD PTR [ecx]
  00023	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00029	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  0002f	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _lpszKey$GSCopy$1$[ebp], edx
  00035	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _key$[ebp], 0
  0003f	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _key$[ebp+4], 0
  00049	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _key$[ebp+8], 0
  00053	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open
  00058	8b f0		 mov	 esi, eax

; 6338 : 	if (lRes != ERROR_SUCCESS)

  0005a	85 f6		 test	 esi, esi
  0005c	0f 85 be 00 00
	00		 jne	 $LN21@RecurseDel

; 6339 : 	{
; 6340 : 		if (lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
; 6341 : 		{
; 6342 : 			ATLTRACE(atlTraceCOM, 0, _T("CRegKey::RecurseDeleteKey : Failed to Open Key %Ts(Error = %d)\n"), lpszKey, lRes);
; 6343 : 		}
; 6344 : 		return lRes;
; 6345 : 	}
; 6346 : 	FILETIME time;
; 6347 : 	DWORD dwSize = 256;
; 6348 : 	TCHAR szBuffer[256];
; 6349 : 	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
; 6350 : 		&time)==ERROR_SUCCESS)

  00062	57		 push	 edi
  00063	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__RegEnumKeyExA@32
  00069	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _time$[ebp]
  0006f	50		 push	 eax
  00070	56		 push	 esi
  00071	56		 push	 esi
  00072	56		 push	 esi
  00073	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _dwSize$[ebp]
  00079	c7 85 f8 fe ff
	ff 00 01 00 00	 mov	 DWORD PTR _dwSize$[ebp], 256 ; 00000100H
  00083	50		 push	 eax
  00084	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0008a	50		 push	 eax
  0008b	56		 push	 esi
  0008c	ff b5 ec fe ff
	ff		 push	 DWORD PTR _key$[ebp]
  00092	ff d7		 call	 edi
  00094	85 c0		 test	 eax, eax
  00096	75 4f		 jne	 SHORT $LN3@RecurseDel
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@RecurseDel:

; 6351 : 	{
; 6352 : 		lRes = key.RecurseDeleteKey(szBuffer);

  000a0	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  000a6	50		 push	 eax
  000a7	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  000ad	e8 00 00 00 00	 call	 ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::RecurseDeleteKey
  000b2	8b f0		 mov	 esi, eax

; 6353 : 		if (lRes != ERROR_SUCCESS)

  000b4	85 f6		 test	 esi, esi
  000b6	75 67		 jne	 SHORT $LN26@RecurseDel

; 6354 : 			return lRes;
; 6355 : 		dwSize = 256;

  000b8	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _time$[ebp]
  000be	c7 85 f8 fe ff
	ff 00 01 00 00	 mov	 DWORD PTR _dwSize$[ebp], 256 ; 00000100H
  000c8	50		 push	 eax
  000c9	56		 push	 esi
  000ca	56		 push	 esi
  000cb	56		 push	 esi
  000cc	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _dwSize$[ebp]
  000d2	50		 push	 eax
  000d3	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  000d9	50		 push	 eax
  000da	56		 push	 esi
  000db	ff b5 ec fe ff
	ff		 push	 DWORD PTR _key$[ebp]
  000e1	ff d7		 call	 edi
  000e3	85 c0		 test	 eax, eax
  000e5	74 b9		 je	 SHORT $LL2@RecurseDel
$LN3@RecurseDel:

; 6356 : 	}
; 6357 : 	key.Close();

  000e7	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _key$[ebp]
  000ed	85 c0		 test	 eax, eax
  000ef	74 11		 je	 SHORT $LN13@RecurseDel
  000f1	50		 push	 eax
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  000f8	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _key$[ebp], 0
$LN13@RecurseDel:

; 6358 : 	return DeleteSubKey(lpszKey);

  00102	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _lpszKey$GSCopy$1$[ebp]
  00108	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0010e	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _key$[ebp+4], 0
  00118	e8 00 00 00 00	 call	 ?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::DeleteSubKey
  0011d	8b f0		 mov	 esi, eax
$LN26@RecurseDel:
  0011f	5f		 pop	 edi
$LN21@RecurseDel:
  00120	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _key$[ebp]
  00126	85 c0		 test	 eax, eax
  00128	74 07		 je	 SHORT $LN25@RecurseDel
  0012a	50		 push	 eax
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN25@RecurseDel:

; 6359 : }

  00131	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00134	8b c6		 mov	 eax, esi
  00136	33 cd		 xor	 ecx, ebp
  00138	5e		 pop	 esi
  00139	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 04 00	 ret	 4
?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ENDP		; ATL::CRegKey::RecurseDeleteKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT
_lpszSubKey$ = 8					; size = 4
?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z PROC		; ATL::CRegKey::DeleteSubKey, COMDAT
; _this$ = ecx

; 5752 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 5753 : 	ATLASSUME(m_hKey != NULL);
; 5754 : 
; 5755 : 	if (m_pTM != NULL)

  00007	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0000a	85 ff		 test	 edi, edi
  0000c	74 5b		 je	 SHORT $LN5@DeleteSubK

; 5756 : 	{
; 5757 : 		return m_pTM->RegDeleteKey(m_hKey, lpszSubKey);

  0000e	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00011	8b 36		 mov	 esi, DWORD PTR [esi]
  00013	74 33		 je	 SHORT $LN11@DeleteSubK
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00020	85 c0		 test	 eax, eax
  00022	74 3a		 je	 SHORT $LN15@DeleteSubK
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GMDDFLLI@RegDeleteKeyTransactedA?$AA@
  00029	50		 push	 eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00030	85 c0		 test	 eax, eax
  00032	74 2a		 je	 SHORT $LN15@DeleteSubK
  00034	6a 00		 push	 0
  00036	ff 37		 push	 DWORD PTR [edi]
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	ff 75 08	 push	 DWORD PTR _lpszSubKey$[ebp]
  0003f	56		 push	 esi
  00040	ff d0		 call	 eax
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 5790 : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4

; 5756 : 	{
; 5757 : 		return m_pTM->RegDeleteKey(m_hKey, lpszSubKey);

$LN11@DeleteSubK:
  00048	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0004c	74 10		 je	 SHORT $LN15@DeleteSubK
  0004e	ff 75 08	 push	 DWORD PTR _lpszSubKey$[ebp]
  00051	56		 push	 esi

; 5785 : 	}
; 5786 : 
; 5787 : #endif	// WINVER
; 5788 : 
; 5789 : 	return RegDeleteKey(m_hKey, lpszSubKey);

  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyA@8
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi

; 5790 : }

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4

; 5756 : 	{
; 5757 : 		return m_pTM->RegDeleteKey(m_hKey, lpszSubKey);

$LN15@DeleteSubK:
  0005e	5f		 pop	 edi
  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	5e		 pop	 esi

; 5790 : }

  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
$LN5@DeleteSubK:

; 5758 : 	}
; 5759 : 
; 5760 : #if WINVER >= 0x0501
; 5761 : #ifdef _UNICODE
; 5762 : 	static decltype(RegDeleteKeyExW) *pfnRegDeleteKeyEx = NULL;
; 5763 : #else
; 5764 : 	static decltype(RegDeleteKeyExA) *pfnRegDeleteKeyEx = NULL;
; 5765 : #endif	// _UNICODE
; 5766 : 	static bool bInitialized = false;
; 5767 : 
; 5768 : 	if (!bInitialized)

  00069	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA, 0 ; `ATL::CRegKey::DeleteSubKey'::`2'::bInitialized
  00070	75 37		 jne	 SHORT $LN18@DeleteSubK

; 5769 : 	{
; 5770 : 		HMODULE hAdvapi32 = GetModuleHandle(_T("Advapi32.dll"));

  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4

; 5771 : 		if (hAdvapi32 != NULL)

  0007d	85 c0		 test	 eax, eax
  0007f	74 1a		 je	 SHORT $LN17@DeleteSubK

; 5772 : 		{
; 5773 : #ifdef _UNICODE
; 5774 : 			pfnRegDeleteKeyEx = (decltype(RegDeleteKeyExW) *)GetProcAddress(hAdvapi32, "RegDeleteKeyExW");
; 5775 : #else
; 5776 : 			pfnRegDeleteKeyEx = (decltype(RegDeleteKeyExA) *)GetProcAddress(hAdvapi32, "RegDeleteKeyExA");

  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KECIECLD@RegDeleteKeyExA?$AA@
  00086	50		 push	 eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0008d	a3 00 00 00 00	 mov	 DWORD PTR ?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA, eax ; `ATL::CRegKey::DeleteSubKey'::`2'::pfnRegDeleteKeyEx

; 5777 : #endif	// _UNICODE
; 5778 : 		}
; 5779 : 		bInitialized = true;

  00092	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA, 1 ; `ATL::CRegKey::DeleteSubKey'::`2'::bInitialized
  00099	eb 13		 jmp	 SHORT $LN6@DeleteSubK
$LN17@DeleteSubK:

; 5772 : 		{
; 5773 : #ifdef _UNICODE
; 5774 : 			pfnRegDeleteKeyEx = (decltype(RegDeleteKeyExW) *)GetProcAddress(hAdvapi32, "RegDeleteKeyExW");
; 5775 : #else
; 5776 : 			pfnRegDeleteKeyEx = (decltype(RegDeleteKeyExA) *)GetProcAddress(hAdvapi32, "RegDeleteKeyExA");

  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA ; `ATL::CRegKey::DeleteSubKey'::`2'::pfnRegDeleteKeyEx

; 5777 : #endif	// _UNICODE
; 5778 : 		}
; 5779 : 		bInitialized = true;

  000a0	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA, 1 ; `ATL::CRegKey::DeleteSubKey'::`2'::bInitialized
  000a7	eb 05		 jmp	 SHORT $LN6@DeleteSubK
$LN18@DeleteSubK:
  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA ; `ATL::CRegKey::DeleteSubKey'::`2'::pfnRegDeleteKeyEx
$LN6@DeleteSubK:

; 5780 : 	}
; 5781 : 
; 5782 : 	if (pfnRegDeleteKeyEx != NULL)

  000ae	85 c0		 test	 eax, eax
  000b0	74 12		 je	 SHORT $LN8@DeleteSubK

; 5783 : 	{
; 5784 : 		return pfnRegDeleteKeyEx(m_hKey, lpszSubKey, m_samWOW64, 0);

  000b2	6a 00		 push	 0
  000b4	ff 76 04	 push	 DWORD PTR [esi+4]
  000b7	ff 75 08	 push	 DWORD PTR _lpszSubKey$[ebp]
  000ba	ff 36		 push	 DWORD PTR [esi]
  000bc	ff d0		 call	 eax
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi

; 5790 : }

  000c0	5d		 pop	 ebp
  000c1	c2 04 00	 ret	 4
$LN8@DeleteSubK:

; 5785 : 	}
; 5786 : 
; 5787 : #endif	// WINVER
; 5788 : 
; 5789 : 	return RegDeleteKey(m_hKey, lpszSubKey);

  000c4	ff 75 08	 push	 DWORD PTR _lpszSubKey$[ebp]
  000c7	ff 36		 push	 DWORD PTR [esi]
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyA@8
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi

; 5790 : }

  000d1	5d		 pop	 ebp
  000d2	c2 04 00	 ret	 4
?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z ENDP		; ATL::CRegKey::DeleteSubKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z PROC		; ATL::CRegKey::Attach, COMDAT
; _this$ = ecx

; 5744 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5745 : 	ATLASSUME(m_hKey == NULL);
; 5746 : 	m_hKey = hKey;

  00003	8b 45 08	 mov	 eax, DWORD PTR _hKey$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 5747 : 	m_samWOW64 = 0;

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 5748 : 	m_pTM = NULL;

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 5749 : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z ENDP		; ATL::CRegKey::Attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ
_TEXT	SEGMENT
?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ PROC		; ATL::CRegKey::Detach, COMDAT
; _this$ = ecx

; 5736 : 	HKEY hKey = m_hKey;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 5737 : 	m_hKey = NULL;

  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 5738 : 	m_samWOW64 = 0;

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 5739 : 	m_pTM = NULL;

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 5740 : 	return hKey;
; 5741 : }

  00016	c3		 ret	 0
?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ ENDP		; ATL::CRegKey::Detach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Close@CRegKey@ATL@@QAEJXZ
_TEXT	SEGMENT
?Close@CRegKey@ATL@@QAEJXZ PROC				; ATL::CRegKey::Close, COMDAT
; _this$ = ecx

; 5799 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 5800 : 	LONG lRes = ERROR_SUCCESS;
; 5801 : 	if (m_hKey != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 16		 je	 SHORT $LN4@Close

; 5802 : 	{
; 5803 : 		lRes = RegCloseKey(m_hKey);

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 5804 : 		m_hKey = NULL;

  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 5805 : 	}
; 5806 : 	m_samWOW64 = 0;

  00016	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001d	5e		 pop	 esi

; 5808 : }

  0001e	c3		 ret	 0
$LN4@Close:

; 5807 : 	return lRes;

  0001f	33 c0		 xor	 eax, eax
  00021	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00024	5e		 pop	 esi

; 5808 : }

  00025	c3		 ret	 0
?Close@CRegKey@ATL@@QAEJXZ ENDP				; ATL::CRegKey::Close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z
_TEXT	SEGMENT
_hKey$ = -4						; size = 4
_hKeyParent$ = 8					; size = 4
_lpszKeyName$ = 12					; size = 4
_samDesired$ = 16					; size = 4
?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z PROC		; ATL::CRegKey::Open, COMDAT
; _this$ = ecx

; 5879 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 5880 : 	ATLASSUME(hKeyParent != NULL);
; 5881 : 	HKEY hKey = NULL;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hKey$[ebp], 0
  0000f	57		 push	 edi

; 5882 : 	LONG lRes = m_pTM != NULL ?

  00010	8b 7d 10	 mov	 edi, DWORD PTR _samDesired$[ebp]
  00013	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00016	85 db		 test	 ebx, ebx
  00018	74 4d		 je	 SHORT $LN7@Open
  0001a	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0001d	74 3b		 je	 SHORT $LN10@Open
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN12@Open
  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	eb 45		 jmp	 SHORT $LN8@Open
$LN12@Open:
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGMNHMFJ@RegOpenKeyTransactedA?$AA@
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00041	85 c0		 test	 eax, eax
  00043	74 1b		 je	 SHORT $LN14@Open
  00045	6a 00		 push	 0
  00047	ff 33		 push	 DWORD PTR [ebx]
  00049	8d 4d fc	 lea	 ecx, DWORD PTR _hKey$[ebp]
  0004c	51		 push	 ecx
  0004d	57		 push	 edi
  0004e	6a 00		 push	 0
  00050	ff 75 0c	 push	 DWORD PTR _lpszKeyName$[ebp]
  00053	ff 75 08	 push	 DWORD PTR _hKeyParent$[ebp]
  00056	ff d0		 call	 eax
  00058	eb 20		 jmp	 SHORT $LN8@Open
$LN10@Open:
  0005a	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  0005e	75 07		 jne	 SHORT $LN7@Open
$LN14@Open:
  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	eb 13		 jmp	 SHORT $LN8@Open
$LN7@Open:
  00067	8d 45 fc	 lea	 eax, DWORD PTR _hKey$[ebp]
  0006a	50		 push	 eax
  0006b	57		 push	 edi
  0006c	6a 00		 push	 0
  0006e	ff 75 0c	 push	 DWORD PTR _lpszKeyName$[ebp]
  00071	ff 75 08	 push	 DWORD PTR _hKeyParent$[ebp]
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
$LN8@Open:

; 5883 : 		m_pTM->RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey) :
; 5884 : 		RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
; 5885 : 	if (lRes == ERROR_SUCCESS)

  0007a	85 c0		 test	 eax, eax
  0007c	75 27		 jne	 SHORT $LN5@Open

; 5886 : 	{
; 5887 : 		lRes = Close();

  0007e	8b 06		 mov	 eax, DWORD PTR [esi]
  00080	33 d2		 xor	 edx, edx
  00082	85 c0		 test	 eax, eax
  00084	74 0f		 je	 SHORT $LN17@Open
  00086	50		 push	 eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  0008d	8b d0		 mov	 edx, eax
  0008f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN17@Open:

; 5888 : 		ATLASSERT(lRes == ERROR_SUCCESS);
; 5889 : 		m_hKey = hKey;

  00095	8b 4d fc	 mov	 ecx, DWORD PTR _hKey$[ebp]

; 5890 : #if WINVER >= 0x0501
; 5891 : 		m_samWOW64 = samDesired & (KEY_WOW64_32KEY | KEY_WOW64_64KEY);

  00098	81 e7 00 03 00
	00		 and	 edi, 768		; 00000300H
  0009e	89 0e		 mov	 DWORD PTR [esi], ecx

; 5892 : #endif
; 5893 : 	}
; 5894 : 	return lRes;

  000a0	8b c2		 mov	 eax, edx
  000a2	89 7e 04	 mov	 DWORD PTR [esi+4], edi
$LN5@Open:
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 5895 : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 0c 00	 ret	 12			; 0000000cH
?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ENDP		; ATL::CRegKey::Open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z
_TEXT	SEGMENT
_hKey$ = -4						; size = 4
_hKeyParent$ = 8					; size = 4
_lpszKeyName$ = 12					; size = 4
_lpszClass$ = 16					; size = 4
_dwOptions$ = 20					; size = 4
_dw$ = 24						; size = 4
_samDesired$ = 24					; size = 4
_lpSecAttr$ = 28					; size = 4
_lpdwDisposition$ = 32					; size = 4
?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z PROC ; ATL::CRegKey::Create, COMDAT
; _this$ = ecx

; 5854 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 5855 : 	ATLASSERT(hKeyParent != NULL);
; 5856 : 	DWORD dw;
; 5857 : 	HKEY hKey = NULL;
; 5858 : 	LONG lRes = m_pTM != NULL ?

  00005	8b 5d 18	 mov	 ebx, DWORD PTR _samDesired$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hKey$[ebp], 0
  00012	57		 push	 edi
  00013	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00016	85 ff		 test	 edi, edi
  00018	74 5a		 je	 SHORT $LN5@Create
  0001a	83 3f 00	 cmp	 DWORD PTR [edi], 0
  0001d	74 48		 je	 SHORT $LN8@Create
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN10@Create
  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	eb 5f		 jmp	 SHORT $LN6@Create
$LN10@Create:
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NBLNJKIN@RegCreateKeyTransactedA?$AA@
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00041	85 c0		 test	 eax, eax
  00043	74 28		 je	 SHORT $LN12@Create
  00045	6a 00		 push	 0
  00047	ff 37		 push	 DWORD PTR [edi]
  00049	8d 4d 18	 lea	 ecx, DWORD PTR _dw$[ebp]
  0004c	51		 push	 ecx
  0004d	8d 4d fc	 lea	 ecx, DWORD PTR _hKey$[ebp]
  00050	51		 push	 ecx
  00051	ff 75 1c	 push	 DWORD PTR _lpSecAttr$[ebp]
  00054	53		 push	 ebx
  00055	ff 75 14	 push	 DWORD PTR _dwOptions$[ebp]
  00058	ff 75 10	 push	 DWORD PTR _lpszClass$[ebp]
  0005b	6a 00		 push	 0
  0005d	ff 75 0c	 push	 DWORD PTR _lpszKeyName$[ebp]
  00060	ff 75 08	 push	 DWORD PTR _hKeyParent$[ebp]
  00063	ff d0		 call	 eax
  00065	eb 2d		 jmp	 SHORT $LN6@Create
$LN8@Create:
  00067	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0006b	75 07		 jne	 SHORT $LN5@Create
$LN12@Create:
  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	eb 20		 jmp	 SHORT $LN6@Create
$LN5@Create:
  00074	8d 45 18	 lea	 eax, DWORD PTR _dw$[ebp]
  00077	50		 push	 eax
  00078	8d 45 fc	 lea	 eax, DWORD PTR _hKey$[ebp]
  0007b	50		 push	 eax
  0007c	ff 75 1c	 push	 DWORD PTR _lpSecAttr$[ebp]
  0007f	53		 push	 ebx
  00080	ff 75 14	 push	 DWORD PTR _dwOptions$[ebp]
  00083	ff 75 10	 push	 DWORD PTR _lpszClass$[ebp]
  00086	6a 00		 push	 0
  00088	ff 75 0c	 push	 DWORD PTR _lpszKeyName$[ebp]
  0008b	ff 75 08	 push	 DWORD PTR _hKeyParent$[ebp]
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
$LN6@Create:

; 5859 : 		m_pTM->RegCreateKeyEx(hKeyParent, lpszKeyName, 0, lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw) :
; 5860 : 		RegCreateKeyEx(hKeyParent, lpszKeyName, 0, lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
; 5861 : 	if (lRes == ERROR_SUCCESS)

  00094	85 c0		 test	 eax, eax
  00096	75 33		 jne	 SHORT $LN2@Create

; 5862 : 	{
; 5863 :     	if (lpdwDisposition != NULL)

  00098	8b 4d 20	 mov	 ecx, DWORD PTR _lpdwDisposition$[ebp]
  0009b	85 c9		 test	 ecx, ecx
  0009d	74 05		 je	 SHORT $LN3@Create

; 5864 : 		    *lpdwDisposition = dw;

  0009f	8b 45 18	 mov	 eax, DWORD PTR _dw$[ebp]
  000a2	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@Create:

; 5865 : 
; 5866 :         lRes = Close();

  000a4	8b 06		 mov	 eax, DWORD PTR [esi]
  000a6	33 d2		 xor	 edx, edx
  000a8	85 c0		 test	 eax, eax
  000aa	74 0f		 je	 SHORT $LN15@Create
  000ac	50		 push	 eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  000b3	8b d0		 mov	 edx, eax
  000b5	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN15@Create:

; 5867 : 		m_hKey = hKey;

  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _hKey$[ebp]

; 5868 : #if WINVER >= 0x0501
; 5869 : 		m_samWOW64 = samDesired & (KEY_WOW64_32KEY | KEY_WOW64_64KEY);

  000be	81 e3 00 03 00
	00		 and	 ebx, 768		; 00000300H
  000c4	89 0e		 mov	 DWORD PTR [esi], ecx

; 5870 : #endif
; 5871 : 	}
; 5872 : 	return lRes;

  000c6	8b c2		 mov	 eax, edx
  000c8	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
$LN2@Create:
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx

; 5873 : }

  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 1c 00	 ret	 28			; 0000001cH
?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z ENDP ; ATL::CRegKey::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_pszValueName$ = 8					; size = 4
_pszValue$ = 12						; size = 4
?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z PROC	; ATL::CRegKey::SetMultiStringValue, COMDAT
; _this$ = ecx

; 6270 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 6271 : 	LPCTSTR pszTemp;
; 6272 : 	ULONG nBytes;
; 6273 : 	ULONG nLength;
; 6274 : 
; 6275 : 	ATLASSUME(m_hKey != NULL);
; 6276 : 	ATLENSURE_RETURN_VAL(pszValue != NULL, ERROR_INVALID_DATA);

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _pszValue$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	75 0a		 jne	 SHORT $LN5@SetMultiSt
  0000f	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  00012	5b		 pop	 ebx

; 6291 : 		nBytes);
; 6292 : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
$LN5@SetMultiSt:
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 6277 : 
; 6278 : 	// Find the total length (in bytes) of all of the strings, including the
; 6279 : 	// terminating '\0' of each string, and the second '\0' that terminates
; 6280 : 	// the list.
; 6281 : 	nBytes = 0;

  0001b	33 f6		 xor	 esi, esi

; 6282 : 	pszTemp = pszValue;

  0001d	8b d3		 mov	 edx, ebx
  0001f	90		 npad	 1
$LL10@SetMultiSt:

; 6283 : 	do
; 6284 : 	{
; 6285 : 		nLength = static_cast<ULONG>(_tcslen(pszTemp))+1;

  00020	8b c2		 mov	 eax, edx
  00022	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$LL16@SetMultiSt:
  00025	8a 08		 mov	 cl, BYTE PTR [eax]
  00027	40		 inc	 eax
  00028	84 c9		 test	 cl, cl
  0002a	75 f9		 jne	 SHORT $LL16@SetMultiSt
  0002c	2b c7		 sub	 eax, edi
  0002e	40		 inc	 eax

; 6286 : 		pszTemp += nLength;

  0002f	03 d0		 add	 edx, eax

; 6287 : 		nBytes += nLength*sizeof(TCHAR);

  00031	03 f0		 add	 esi, eax

; 6288 : 	} while (nLength != 1);

  00033	83 f8 01	 cmp	 eax, 1
  00036	75 e8		 jne	 SHORT $LL10@SetMultiSt

; 6289 : 
; 6290 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_MULTI_SZ, reinterpret_cast<const BYTE*>(pszValue),

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0003b	56		 push	 esi
  0003c	53		 push	 ebx
  0003d	6a 07		 push	 7
  0003f	6a 00		 push	 0
  00041	ff 75 08	 push	 DWORD PTR _pszValueName$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx

; 6291 : 		nBytes);
; 6292 : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z ENDP	; ATL::CRegKey::SetMultiStringValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z
_TEXT	SEGMENT
_pszValueName$ = 8					; size = 4
_pszValue$ = 12						; size = 4
_dwType$ = 16						; size = 4
?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z PROC		; ATL::CRegKey::SetStringValue, COMDAT
; _this$ = ecx

; 6259 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6260 : 	ATLASSUME(m_hKey != NULL);
; 6261 : 	ATLENSURE_RETURN_VAL(pszValue != NULL, ERROR_INVALID_DATA);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _pszValue$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	75 08		 jne	 SHORT $LN5@SetStringV
  0000d	8d 42 0d	 lea	 eax, DWORD PTR [edx+13]
  00010	5e		 pop	 esi

; 6265 : }

  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
$LN5@SetStringV:

; 6262 : 	ATLASSERT((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ));
; 6263 : 
; 6264 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, dwType, reinterpret_cast<const BYTE*>(pszValue), (static_cast<DWORD>(_tcslen(pszValue))+1)*sizeof(TCHAR));

  00015	8b c2		 mov	 eax, edx
  00017	57		 push	 edi
  00018	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001b	0f 1f 44 00 00	 npad	 5
$LL10@SetStringV:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL10@SetStringV
  00027	2b c7		 sub	 eax, edi
  00029	40		 inc	 eax
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 75 10	 push	 DWORD PTR _dwType$[ebp]
  0002f	6a 00		 push	 0
  00031	ff 75 08	 push	 DWORD PTR _pszValueName$[ebp]
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 6265 : }

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z ENDP		; ATL::CRegKey::SetStringValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z
_TEXT	SEGMENT
_pszValueName$ = 8					; size = 4
_dwValue$ = 12						; size = 4
?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z PROC		; ATL::CRegKey::SetDWORDValue, COMDAT
; _this$ = ecx

; 6242 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6243 : 	ATLASSUME(m_hKey != NULL);
; 6244 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_DWORD, reinterpret_cast<const BYTE*>(&dwValue), sizeof(DWORD));

  00003	6a 04		 push	 4
  00005	8d 45 0c	 lea	 eax, DWORD PTR _dwValue$[ebp]
  00008	50		 push	 eax
  00009	6a 04		 push	 4
  0000b	6a 00		 push	 0
  0000d	ff 75 08	 push	 DWORD PTR _pszValueName$[ebp]
  00010	ff 31		 push	 DWORD PTR [ecx]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24

; 6245 : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z ENDP		; ATL::CRegKey::SetDWORDValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??BCRegKey@ATL@@QBEPAUHKEY__@@XZ
_TEXT	SEGMENT
??BCRegKey@ATL@@QBEPAUHKEY__@@XZ PROC			; ATL::CRegKey::operator HKEY__ *, COMDAT
; _this$ = ecx

; 5731 : 	return m_hKey;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 5732 : }

  00002	c3		 ret	 0
??BCRegKey@ATL@@QBEPAUHKEY__@@XZ ENDP			; ATL::CRegKey::operator HKEY__ *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CRegKey@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CRegKey@ATL@@QAE@XZ PROC				; ATL::CRegKey::~CRegKey, COMDAT
; _this$ = ecx

; 5713 : {Close();}

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0d		 je	 SHORT $LN6@CRegKey
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@CRegKey:
  00016	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??1CRegKey@ATL@@QAE@XZ ENDP				; ATL::CRegKey::~CRegKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CRegKey@ATL@@QAE@PAVCAtlTransactionManager@1@@Z
_TEXT	SEGMENT
_pTM$ = 8						; size = 4
??0CRegKey@ATL@@QAE@PAVCAtlTransactionManager@1@@Z PROC	; ATL::CRegKey::CRegKey, COMDAT
; _this$ = ecx

; 5694 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5693 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pTM$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 5695 : }

  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00011	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0CRegKey@ATL@@QAE@PAVCAtlTransactionManager@1@@Z ENDP	; ATL::CRegKey::CRegKey
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
  00000	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00006	68 00 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  0000b	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
  00010	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  00015	85 c0		 test	 eax, eax
  00017	74 13		 je	 SHORT $LN29@dynamic
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _free
  0001f	83 c4 04	 add	 esp, 4
  00022	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN29@dynamic:
  0002c	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
  00036	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0
  00040	c3		 ret	 0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2815 : __declspec(selectany) CAtlWinModule _AtlWinModule;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00005	e8 00 00 00 00	 call	 ??0CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::CAtlWinModule
  0000a	68 00 00 00 00	 push	 OFFSET ??__F_AtlWinModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlWinModule''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2800 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

  00000	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00006	51		 push	 ecx
  00007	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2801 : 	}

  0000c	c3		 ret	 0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2794 : 	{

  00000	56		 push	 esi

; 2795 : 		Term();

  00001	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00007	8b f1		 mov	 esi, ecx
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2796 : 	}

  0000f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00012	85 c0		 test	 eax, eax
  00014	74 10		 je	 SHORT $LN26@CAtlWinMod
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _free
  0001c	83 c4 04	 add	 esp, 4
  0001f	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN26@CAtlWinMod:
  00026	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  0002d	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00034	5e		 pop	 esi
  00035	c3		 ret	 0
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2780 : 	CAtlWinModule()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	0f 57 c0	 xorps	 xmm0, xmm0

; 2781 : 	{

  0000a	0f 11 46 04	 movups	 XMMWORD PTR [esi+4], xmm0
  0000e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00011	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00014	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0

; 2782 : 		cbSize = sizeof(_ATL_WIN_MODULE);
; 2783 : 		HRESULT hr = AtlWinModuleInit(this);

  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00024	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  0002b	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00032	50		 push	 eax
  00033	c7 06 2c 00 00
	00		 mov	 DWORD PTR [esi], 44	; 0000002cH
  00039	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
  00046	85 c0		 test	 eax, eax
  00048	75 2a		 jne	 SHORT $LN26@CAtlWinMod
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00050	85 c0		 test	 eax, eax
  00052	7e 0a		 jle	 SHORT $LN27@CAtlWinMod
  00054	0f b7 c0	 movzx	 eax, ax
  00057	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H

; 2784 : 		if (FAILED(hr))

  0005c	85 c0		 test	 eax, eax
$LN27@CAtlWinMod:

; 2789 : 			return;
; 2790 : 		}
; 2791 : 	}

  0005e	8b c6		 mov	 eax, esi

; 2784 : 		if (FAILED(hr))

  00060	79 14		 jns	 SHORT $LN2@CAtlWinMod

; 2785 : 		{
; 2786 : 			ATLASSERT(0);
; 2787 : 			CAtlBaseModule::m_bInitFailed = true;

  00062	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2788 : 			cbSize = 0;

  00069	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0006f	5e		 pop	 esi

; 2789 : 			return;
; 2790 : 		}
; 2791 : 	}

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN26@CAtlWinMod:
  00074	8b c6		 mov	 eax, esi
$LN2@CAtlWinMod:
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??__F_AtlComModule@ATL@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002e	e8 00 00 00 00	 call	 ?Term@CAtlComModule@ATL@@QAEXXZ ; ATL::CAtlComModule::Term
  00033	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00038	e8 00 00 00 00	 call	 ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__F_AtlComModule@ATL@@YAXXZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??__F_AtlComModule@ATL@@YAXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT

; 2559 : __declspec(selectany) CAtlComModule _AtlComModule;

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	68 10 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
  0000f	85 c0		 test	 eax, eax
  00011	75 29		 jne	 SHORT $LN4@dynamic
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00019	85 c0		 test	 eax, eax
  0001b	7e 0a		 jle	 SHORT $LN20@dynamic
  0001d	0f b7 c0	 movzx	 eax, ax
  00020	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
  00025	85 c0		 test	 eax, eax
$LN20@dynamic:
  00027	79 13		 jns	 SHORT $LN4@dynamic
  00029	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''
  0002e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
  00035	e8 00 00 00 00	 call	 _atexit
  0003a	59		 pop	 ecx
  0003b	c3		 ret	 0
$LN4@dynamic:
  0003c	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''
  00041	c7 05 00 00 00
	00 28 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 40 ; 00000028H
  0004b	e8 00 00 00 00	 call	 _atexit
  00050	59		 pop	 ecx
  00051	c3		 ret	 0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2456 : 	{

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 2457 : 		if (cbSize == 0)

  00003	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00006	74 46		 je	 SHORT $LN1@Term

; 2458 : 			return;
; 2459 : 
; 2460 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00008	56		 push	 esi
  00009	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0000c	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
  0000f	73 2c		 jae	 SHORT $LN3@Term
  00011	53		 push	 ebx
$LL4@Term:

; 2461 : 		{
; 2462 : 			if (*ppEntry != NULL)

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	85 c0		 test	 eax, eax
  00016	74 1c		 je	 SHORT $LN2@Term

; 2463 : 			{
; 2464 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

  00018	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 2465 : 				
; 2466 : 				if (pCache->pCF != NULL)

  0001b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0001d	85 c0		 test	 eax, eax
  0001f	74 13		 je	 SHORT $LN2@Term

; 2467 : 				{
; 2468 : 					// Decode factory pointer if it's not null
; 2469 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4

; 2470 : 					_Analysis_assume_(factory != nullptr);
; 2471 : 					factory->Release();					

  00028	50		 push	 eax
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	ff 51 08	 call	 DWORD PTR [ecx+8]

; 2472 : 					pCache->pCF = NULL;

  0002e	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN2@Term:

; 2458 : 			return;
; 2459 : 
; 2460 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00034	83 c6 04	 add	 esi, 4
  00037	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
  0003a	72 d6		 jb	 SHORT $LL4@Term
  0003c	5b		 pop	 ebx
$LN3@Term:

; 2473 : 				}				
; 2474 : 			}
; 2475 : 		}
; 2476 : 		m_csObjMap.Term();

  0003d	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00040	50		 push	 eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 2477 : 		// Set to 0 to indicate that this function has been called
; 2478 : 		// At this point no one should be concerned about cbsize
; 2479 : 		// having the correct value
; 2480 : 		cbSize = 0;

  00047	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0004d	5e		 pop	 esi
$LN1@Term:
  0004e	5f		 pop	 edi

; 2481 : 	}

  0004f	c3		 ret	 0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2450 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlComModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2451 : 		Term();

  00022	e8 00 00 00 00	 call	 ?Term@CAtlComModule@ATL@@QAEXXZ ; ATL::CAtlComModule::Term

; 2452 : 	}

  00027	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0002a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00031	59		 pop	 ecx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2429 : 	CAtlComModule() throw()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	0f 57 c0	 xorps	 xmm0, xmm0

; 2430 : 	{

  00006	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00009	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 2431 : 		cbSize = 0;
; 2432 : 
; 2433 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);
; 2434 : 
; 2435 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;
; 2436 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;
; 2437 : 
; 2438 : 		if (FAILED(m_csObjMap.Init()))

  0000c	6a 00		 push	 0
  0000e	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  00013	6a 00		 push	 0
  00015	50		 push	 eax
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0001c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], OFFSET ___ImageBase
  00023	c7 46 08 04 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ___pobjMapEntryFirst+4
  0002a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], OFFSET ___pobjMapEntryLast
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
  00037	85 c0		 test	 eax, eax
  00039	75 21		 jne	 SHORT $LN2@CAtlComMod
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00041	85 c0		 test	 eax, eax
  00043	7e 0a		 jle	 SHORT $LN18@CAtlComMod
  00045	0f b7 c0	 movzx	 eax, ax
  00048	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
  0004d	85 c0		 test	 eax, eax
$LN18@CAtlComMod:
  0004f	79 0b		 jns	 SHORT $LN2@CAtlComMod

; 2447 : 	}

  00051	8b c6		 mov	 eax, esi
  00053	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
  0005a	5e		 pop	 esi
  0005b	c3		 ret	 0
$LN2@CAtlComMod:

; 2439 : 		{
; 2440 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2441 : 			ATLASSERT(0);
; 2442 : 			CAtlBaseModule::m_bInitFailed = true;
; 2443 : 			return;
; 2444 : 		}
; 2445 : 		// Set cbSize on success.
; 2446 : 		cbSize = sizeof(_ATL_COM_MODULE);

  0005c	c7 06 28 00 00
	00		 mov	 DWORD PTR [esi], 40	; 00000028H

; 2447 : 	}

  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi
  00065	c3		 ret	 0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7649 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7650 : 	if (pWinModule == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWinModule$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 0a		 jne	 SHORT $LN5@AtlWinModu
$LN37@AtlWinModu:

; 7651 : 		return E_INVALIDARG;

  0000b	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00010	5e		 pop	 esi

; 7663 : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
$LN5@AtlWinModu:

; 7652 : 	if (pWinModule->cbSize == 0)

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	85 c0		 test	 eax, eax
  00019	74 6a		 je	 SHORT $LN36@AtlWinModu

; 7653 : 		return S_OK;
; 7654 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0001b	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  0001e	75 eb		 jne	 SHORT $LN37@AtlWinModu

; 7655 : 		return E_INVALIDARG;
; 7656 : 
; 7657 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  00020	57		 push	 edi
  00021	33 ff		 xor	 edi, edi
  00023	39 7e 24	 cmp	 DWORD PTR [esi+36], edi
  00026	7e 27		 jle	 SHORT $LN3@AtlWinModu

; 7658 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  00028	53		 push	 ebx
  00029	8b 5d 0c	 mov	 ebx, DWORD PTR _hInst$[ebp]
  0002c	0f 1f 40 00	 npad	 4
$LL4@AtlWinModu:
  00030	85 ff		 test	 edi, edi
  00032	78 58		 js	 SHORT $LN28@AtlWinModu
  00034	3b 7e 24	 cmp	 edi, DWORD PTR [esi+36]
  00037	7d 53		 jge	 SHORT $LN28@AtlWinModu
  00039	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0003c	53		 push	 ebx
  0003d	0f b7 04 78	 movzx	 eax, WORD PTR [eax+edi*2]
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  00048	47		 inc	 edi
  00049	3b 7e 24	 cmp	 edi, DWORD PTR [esi+36]
  0004c	7c e2		 jl	 SHORT $LL4@AtlWinModu
  0004e	5b		 pop	 ebx
$LN3@AtlWinModu:

; 7659 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

  0004f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00052	5f		 pop	 edi
  00053	85 c0		 test	 eax, eax
  00055	74 10		 je	 SHORT $LN22@AtlWinModu
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _free
  0005d	83 c4 04	 add	 esp, 4
  00060	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN22@AtlWinModu:

; 7660 : 	pWinModule->m_csWindowCreate.Term();

  00067	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0006a	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00071	50		 push	 eax
  00072	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 7661 : 	pWinModule->cbSize = 0;

  0007f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN36@AtlWinModu:

; 7662 : 	return S_OK;

  00085	33 c0		 xor	 eax, eax
  00087	5e		 pop	 esi

; 7663 : }

  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
$LN28@AtlWinModu:

; 7658 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  0008c	6a 00		 push	 0
  0008e	6a 00		 push	 0
  00090	6a 01		 push	 1
  00092	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN39@AtlWinModu:
$LN38@AtlWinModu:
  0009d	cc		 int	 3
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8394 : 	if (pWinModule == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 09		 jne	 SHORT $LN2@AtlWinModu
$LN15@AtlWinModu:

; 8395 : 		return E_INVALIDARG;

  0000a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H

; 8410 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
$LN2@AtlWinModu:

; 8396 : 
; 8397 : 	// check only in the DLL
; 8398 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  00013	83 38 2c	 cmp	 DWORD PTR [eax], 44	; 0000002cH
  00016	75 f2		 jne	 SHORT $LN15@AtlWinModu

; 8399 : 		return E_INVALIDARG;
; 8400 : 
; 8401 : 	pWinModule->m_pCreateWndList = NULL;
; 8402 : 
; 8403 : 	HRESULT hr = pWinModule->m_csWindowCreate.Init();

  00018	56		 push	 esi
  00019	33 f6		 xor	 esi, esi
  0001b	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00022	56		 push	 esi
  00023	56		 push	 esi
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
  0002e	85 c0		 test	 eax, eax
  00030	75 15		 jne	 SHORT $LN14@AtlWinModu
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00038	8b f0		 mov	 esi, eax
  0003a	85 f6		 test	 esi, esi
  0003c	7e 09		 jle	 SHORT $LN14@AtlWinModu
  0003e	0f b7 f6	 movzx	 esi, si
  00041	81 ce 00 00 07
	80		 or	 esi, -2147024896	; 80070000H
$LN14@AtlWinModu:

; 8404 : 	if (FAILED(hr))
; 8405 : 	{
; 8406 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));
; 8407 : 		ATLASSERT(0);
; 8408 : 	}
; 8409 : 	return hr;

  00047	8b c6		 mov	 eax, esi
  00049	5e		 pop	 esi

; 8410 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlGetPerUserRegistration@ATL@@YGJPA_N@Z
_TEXT	SEGMENT
_pbEnabled$ = 8						; size = 4
?AtlGetPerUserRegistration@ATL@@YGJPA_N@Z PROC		; ATL::AtlGetPerUserRegistration, COMDAT

; 7093 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7094 : 	if (pbEnabled == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pbEnabled$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 09		 jne	 SHORT $LN2@AtlGetPerU

; 7095 : 		return E_POINTER;

  0000a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H

; 7099 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
$LN2@AtlGetPerU:

; 7096 : 
; 7097 : 	*pbEnabled = _AtlRegisterPerUser;

  00013	a0 00 00 00 00	 mov	 al, BYTE PTR ?_AtlRegisterPerUser@ATL@@3_NA ; ATL::_AtlRegisterPerUser
  00018	88 01		 mov	 BYTE PTR [ecx], al

; 7098 : 	return S_OK;

  0001a	33 c0		 xor	 eax, eax

; 7099 : }

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?AtlGetPerUserRegistration@ATL@@YGJPA_N@Z ENDP		; ATL::AtlGetPerUserRegistration
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00006	85 c0		 test	 eax, eax
  00008	74 10		 je	 SHORT $LN19@ATL_WIN_MO
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _free
  00010	83 c4 04	 add	 esp, 4
  00013	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN19@ATL_WIN_MO:
  0001a	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00021	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00028	5e		 pop	 esi
  00029	c3		 ret	 0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	0f 57 c0	 xorps	 xmm0, xmm0
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	0f 11 41 04	 movups	 XMMWORD PTR [ecx+4], xmm0
  0000e	8b c1		 mov	 eax, ecx
  00010	66 0f d6 41 14	 movq	 QWORD PTR [ecx+20], xmm0
  00015	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  0001c	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  00023	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0e		 js	 SHORT $LN3@operator
  0000a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0000d	7d 09		 jge	 SHORT $LN3@operator

; 241  : 		}
; 242  : 		return m_aT[nIndex];

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 243  : 	}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 01		 push	 1
  0001e	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN9@operator:
$LN8@operator:
  00029	cc		 int	 3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 216  : 		if(m_aT != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN11@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN11@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

  00018	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00026	5e		 pop	 esi

; 225  :     }

  00027	c3		 ret	 0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 161  : 		return m_nSize;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 162  : 	}

  00003	c3		 ret	 0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 310  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 311  : 	RemoveAll();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN13@CSimpleArr
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN13@CSimpleArr:
  00018	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00026	5e		 pop	 esi

; 312  : }

  00027	c3		 ret	 0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 121  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	8b c1		 mov	 eax, ecx
  00005	0f 11 41 10	 movups	 XMMWORD PTR [ecx+16], xmm0
  00009	66 0f d6 41 20	 movq	 QWORD PTR [ecx+32], xmm0
  0000e	c3		 ret	 0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltransactionmanager.h
;	COMDAT ?RegDeleteKeyA@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PBD@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_lpSubKey$ = 12						; size = 4
?RegDeleteKeyA@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PBD@Z PROC ; ATL::CAtlTransactionManager::RegDeleteKeyA, COMDAT
; _this$ = ecx

; 664  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 665  : 	if (m_hTransaction != NULL)

  00006	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00009	74 34		 je	 SHORT $LN2@RegDeleteK

; 666  : 	{
; 667  : 		HMODULE hAdvAPI32 = ::GetModuleHandle(_T("Advapi32.dll"));

  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4

; 668  : 		ATLASSERT(hAdvAPI32 != NULL);
; 669  : 		if (hAdvAPI32 == NULL)

  00016	85 c0		 test	 eax, eax
  00018	74 33		 je	 SHORT $LN6@RegDeleteK

; 670  : 		{
; 671  : 			return ERROR_INVALID_FUNCTION;
; 672  : 		}
; 673  : 
; 674  : #ifdef _UNICODE
; 675  : 		typedef LSTATUS (WINAPI* PFNREGDELETEKEYTRANSACTED)(HKEY, LPCWSTR, REGSAM, DWORD, HANDLE, PVOID);
; 676  : 		PFNREGDELETEKEYTRANSACTED pfRegDeleteKeyTransacted = (PFNREGDELETEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegDeleteKeyTransactedW");
; 677  : #else
; 678  : 		typedef LSTATUS (WINAPI* PFNREGDELETEKEYTRANSACTED)(HKEY, LPCSTR, REGSAM, DWORD, HANDLE, PVOID);
; 679  : 		PFNREGDELETEKEYTRANSACTED pfRegDeleteKeyTransacted = (PFNREGDELETEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegDeleteKeyTransactedA");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GMDDFLLI@RegDeleteKeyTransactedA?$AA@
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 680  : #endif
; 681  : 		if (pfRegDeleteKeyTransacted != NULL)

  00026	85 c0		 test	 eax, eax
  00028	74 23		 je	 SHORT $LN6@RegDeleteK

; 682  : 		{
; 683  : 			return (*pfRegDeleteKeyTransacted)(hKey, lpSubKey, 0, 0, m_hTransaction, NULL);

  0002a	6a 00		 push	 0
  0002c	ff 36		 push	 DWORD PTR [esi]
  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	ff 75 0c	 push	 DWORD PTR _lpSubKey$[ebp]
  00035	ff 75 08	 push	 DWORD PTR _hKey$[ebp]
  00038	ff d0		 call	 eax
  0003a	5e		 pop	 esi

; 692  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@RegDeleteK:

; 684  : 		}
; 685  : 	}
; 686  : 	else if (m_bFallback)

  0003f	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00043	74 08		 je	 SHORT $LN6@RegDeleteK
  00045	5e		 pop	 esi

; 692  : }

  00046	5d		 pop	 ebp

; 687  : 	{
; 688  : 		return ::RegDeleteKey(hKey, lpSubKey);

  00047	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__RegDeleteKeyA@8
$LN6@RegDeleteK:

; 689  : 	}
; 690  : 
; 691  : 	return ERROR_INVALID_FUNCTION;

  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	5e		 pop	 esi

; 692  : }

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?RegDeleteKeyA@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PBD@Z ENDP ; ATL::CAtlTransactionManager::RegDeleteKeyA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltransactionmanager.h
;	COMDAT ?RegOpenKeyExA@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PBDKKPAPAU3@@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_lpSubKey$ = 12						; size = 4
_ulOptions$ = 16					; size = 4
_samDesired$ = 20					; size = 4
_phkResult$ = 24					; size = 4
?RegOpenKeyExA@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PBDKKPAPAU3@@Z PROC ; ATL::CAtlTransactionManager::RegOpenKeyExA, COMDAT
; _this$ = ecx

; 593  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 594  : 	if (m_hTransaction != NULL)

  00006	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00009	74 39		 je	 SHORT $LN2@RegOpenKey

; 595  : 	{
; 596  : 		HMODULE hAdvAPI32 = ::GetModuleHandle(_T("Advapi32.dll"));

  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4

; 597  : 		ATLASSERT(hAdvAPI32 != NULL);
; 598  : 		if (hAdvAPI32 == NULL)

  00016	85 c0		 test	 eax, eax
  00018	74 38		 je	 SHORT $LN6@RegOpenKey

; 599  : 		{
; 600  : 			return ERROR_INVALID_FUNCTION;
; 601  : 		}
; 602  : 
; 603  : #ifdef _UNICODE
; 604  : 		typedef LSTATUS (WINAPI* PFNREGOPENKEYTRANSACTED)(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY, HANDLE, PVOID);
; 605  : 		PFNREGOPENKEYTRANSACTED pfRegOpenKeyTransacted = (PFNREGOPENKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegOpenKeyTransactedW");
; 606  : #else
; 607  : 		typedef LSTATUS (WINAPI* PFNREGOPENKEYTRANSACTED)(HKEY, LPCSTR, DWORD, REGSAM, PHKEY, HANDLE, PVOID);
; 608  : 		PFNREGOPENKEYTRANSACTED pfRegOpenKeyTransacted = (PFNREGOPENKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegOpenKeyTransactedA");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGMNHMFJ@RegOpenKeyTransactedA?$AA@
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 609  : #endif
; 610  : 		if (pfRegOpenKeyTransacted != NULL)

  00026	85 c0		 test	 eax, eax
  00028	74 28		 je	 SHORT $LN6@RegOpenKey

; 611  : 		{
; 612  : 			return (*pfRegOpenKeyTransacted)(hKey, lpSubKey, ulOptions, samDesired, phkResult, m_hTransaction, NULL);

  0002a	6a 00		 push	 0
  0002c	ff 36		 push	 DWORD PTR [esi]
  0002e	ff 75 18	 push	 DWORD PTR _phkResult$[ebp]
  00031	ff 75 14	 push	 DWORD PTR _samDesired$[ebp]
  00034	ff 75 10	 push	 DWORD PTR _ulOptions$[ebp]
  00037	ff 75 0c	 push	 DWORD PTR _lpSubKey$[ebp]
  0003a	ff 75 08	 push	 DWORD PTR _hKey$[ebp]
  0003d	ff d0		 call	 eax
  0003f	5e		 pop	 esi

; 621  : }

  00040	5d		 pop	 ebp
  00041	c2 14 00	 ret	 20			; 00000014H
$LN2@RegOpenKey:

; 613  : 		}
; 614  : 	}
; 615  : 	else if (m_bFallback)

  00044	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00048	74 08		 je	 SHORT $LN6@RegOpenKey
  0004a	5e		 pop	 esi

; 621  : }

  0004b	5d		 pop	 ebp

; 616  : 	{
; 617  : 		return ::RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

  0004c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__RegOpenKeyExA@20
$LN6@RegOpenKey:

; 618  : 	}
; 619  : 
; 620  : 	return ERROR_INVALID_FUNCTION;

  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	5e		 pop	 esi

; 621  : }

  00058	5d		 pop	 ebp
  00059	c2 14 00	 ret	 20			; 00000014H
?RegOpenKeyExA@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PBDKKPAPAU3@@Z ENDP ; ATL::CAtlTransactionManager::RegOpenKeyExA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltransactionmanager.h
;	COMDAT ?RegCreateKeyExA@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PBDKPADKKQAU_SECURITY_ATTRIBUTES@@PAPAU3@PAK@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_lpSubKey$ = 12						; size = 4
_dwReserved$ = 16					; size = 4
_lpClass$ = 20						; size = 4
_dwOptions$ = 24					; size = 4
_samDesired$ = 28					; size = 4
_lpSecurityAttributes$ = 32				; size = 4
_phkResult$ = 36					; size = 4
_lpdwDisposition$ = 40					; size = 4
?RegCreateKeyExA@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PBDKPADKKQAU_SECURITY_ATTRIBUTES@@PAPAU3@PAK@Z PROC ; ATL::CAtlTransactionManager::RegCreateKeyExA, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 634  : 	if (m_hTransaction != NULL)

  00006	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00009	74 45		 je	 SHORT $LN2@RegCreateK

; 635  : 	{
; 636  : 		HMODULE hAdvAPI32 = ::GetModuleHandle(_T("Advapi32.dll"));

  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4

; 637  : 		ATLASSERT(hAdvAPI32 != NULL);
; 638  : 		if (hAdvAPI32 == NULL)

  00016	85 c0		 test	 eax, eax
  00018	74 44		 je	 SHORT $LN6@RegCreateK

; 639  : 		{
; 640  : 			return ERROR_INVALID_FUNCTION;
; 641  : 		}
; 642  : 
; 643  : #ifdef _UNICODE
; 644  : 		typedef LSTATUS (WINAPI* PFNREGCREATEKEYTRANSACTED)(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, CONST LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD, HANDLE, PVOID);
; 645  : 		PFNREGCREATEKEYTRANSACTED pfRegCreateKeyTransacted = (PFNREGCREATEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegCreateKeyTransactedW");
; 646  : #else
; 647  : 		typedef LSTATUS (WINAPI* PFNREGCREATEKEYTRANSACTED)(HKEY, LPCSTR, DWORD, LPSTR, DWORD, REGSAM, CONST LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD, HANDLE, PVOID);
; 648  : 		PFNREGCREATEKEYTRANSACTED pfRegCreateKeyTransacted = (PFNREGCREATEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegCreateKeyTransactedA");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NBLNJKIN@RegCreateKeyTransactedA?$AA@
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 649  : #endif
; 650  : 		if (pfRegCreateKeyTransacted != NULL)

  00026	85 c0		 test	 eax, eax
  00028	74 34		 je	 SHORT $LN6@RegCreateK

; 651  : 		{
; 652  : 			return (*pfRegCreateKeyTransacted)(hKey, lpSubKey, dwReserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, m_hTransaction, NULL);

  0002a	6a 00		 push	 0
  0002c	ff 36		 push	 DWORD PTR [esi]
  0002e	ff 75 28	 push	 DWORD PTR _lpdwDisposition$[ebp]
  00031	ff 75 24	 push	 DWORD PTR _phkResult$[ebp]
  00034	ff 75 20	 push	 DWORD PTR _lpSecurityAttributes$[ebp]
  00037	ff 75 1c	 push	 DWORD PTR _samDesired$[ebp]
  0003a	ff 75 18	 push	 DWORD PTR _dwOptions$[ebp]
  0003d	ff 75 14	 push	 DWORD PTR _lpClass$[ebp]
  00040	ff 75 10	 push	 DWORD PTR _dwReserved$[ebp]
  00043	ff 75 0c	 push	 DWORD PTR _lpSubKey$[ebp]
  00046	ff 75 08	 push	 DWORD PTR _hKey$[ebp]
  00049	ff d0		 call	 eax
  0004b	5e		 pop	 esi

; 661  : }

  0004c	5d		 pop	 ebp
  0004d	c2 24 00	 ret	 36			; 00000024H
$LN2@RegCreateK:

; 653  : 		}
; 654  : 	}
; 655  : 	else if (m_bFallback)

  00050	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00054	74 08		 je	 SHORT $LN6@RegCreateK
  00056	5e		 pop	 esi

; 661  : }

  00057	5d		 pop	 ebp

; 656  : 	{
; 657  : 		return ::RegCreateKeyEx(hKey, lpSubKey, dwReserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

  00058	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__RegCreateKeyExA@36
$LN6@RegCreateK:

; 658  : 	}
; 659  : 
; 660  : 	return ERROR_INVALID_FUNCTION;

  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	5e		 pop	 esi

; 661  : }

  00064	5d		 pop	 ebp
  00065	c2 24 00	 ret	 36			; 00000024H
?RegCreateKeyExA@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PBDKPADKKQAU_SECURITY_ATTRIBUTES@@PAPAU3@PAK@Z ENDP ; ATL::CAtlTransactionManager::RegCreateKeyExA
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0IRegistrarBase@@QAE@XZ
_TEXT	SEGMENT
??0IRegistrarBase@@QAE@XZ PROC				; IRegistrarBase::IRegistrarBase, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0IRegistrarBase@@QAE@XZ ENDP				; IRegistrarBase::IRegistrarBase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ?AtlHresultFromWin32@ATL@@YAJK@Z
_TEXT	SEGMENT
_nError$ = 8						; size = 4
?AtlHresultFromWin32@ATL@@YAJK@Z PROC			; ATL::AtlHresultFromWin32, COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   :     return( HRESULT_FROM_WIN32( nError ) );

  00003	8b 45 08	 mov	 eax, DWORD PTR _nError$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	7e 08		 jle	 SHORT $LN6@AtlHresult
  0000a	0f b7 c0	 movzx	 eax, ax
  0000d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN6@AtlHresult:

; 46   : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?AtlHresultFromWin32@ATL@@YAJK@Z ENDP			; ATL::AtlHresultFromWin32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ?AtlHresultFromLastError@ATL@@YAJXZ
_TEXT	SEGMENT
?AtlHresultFromLastError@ATL@@YAJXZ PROC		; ATL::AtlHresultFromLastError, COMDAT

; 37   :     DWORD dwErr = ::GetLastError();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 38   :     return HRESULT_FROM_WIN32(dwErr);

  00006	85 c0		 test	 eax, eax
  00008	7e 08		 jle	 SHORT $LN6@AtlHresult
  0000a	0f b7 c0	 movzx	 eax, ax
  0000d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN6@AtlHresult:

; 39   : }

  00012	c3		 ret	 0
?AtlHresultFromLastError@ATL@@YAJXZ ENDP		; ATL::AtlHresultFromLastError
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 275  : 		return m_hInst;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 276  : 	}

  00003	c3		 ret	 0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1CComAutoDeleteCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComAutoDeleteCriticalSection@ATL@@QAE@XZ PROC	; ATL::CComAutoDeleteCriticalSection::~CComAutoDeleteCriticalSection, COMDAT
; _this$ = ecx
  00000	80 79 18 00	 cmp	 BYTE PTR [ecx+24], 0
  00004	74 0b		 je	 SHORT $LN3@CComAutoDe
  00006	51		 push	 ecx
  00007	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
$LN3@CComAutoDe:
  00011	c3		 ret	 0
??1CComAutoDeleteCriticalSection@ATL@@QAE@XZ ENDP	; ATL::CComAutoDeleteCriticalSection::~CComAutoDeleteCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CComAutoDeleteCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComAutoDeleteCriticalSection@ATL@@QAE@XZ PROC	; ATL::CComAutoDeleteCriticalSection::CComAutoDeleteCriticalSection, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	0f 57 c0	 xorps	 xmm0, xmm0
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0000d	8b c1		 mov	 eax, ecx
  0000f	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  00014	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??0CComAutoDeleteCriticalSection@ATL@@QAE@XZ ENDP	; ATL::CComAutoDeleteCriticalSection::CComAutoDeleteCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Lock@CComSafeDeleteCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Lock@CComSafeDeleteCriticalSection@ATL@@QAEJXZ PROC	; ATL::CComSafeDeleteCriticalSection::Lock, COMDAT
; _this$ = ecx

; 207  : 		// CComSafeDeleteCriticalSection::Init or CComAutoDeleteCriticalSection::Init
; 208  : 		// not called or failed.
; 209  : 		// m_critsec member of CComObjectRootEx is now of type
; 210  : 		// CComAutoDeleteCriticalSection. It has to be initialized
; 211  : 		// by calling CComObjectRootEx::_AtlInitialConstruct
; 212  : 		ATLASSUME(m_bInitialized);
; 213  : 		return CComCriticalSection::Lock();

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00007	33 c0		 xor	 eax, eax

; 214  : 	}

  00009	c3		 ret	 0
?Lock@CComSafeDeleteCriticalSection@ATL@@QAEJXZ ENDP	; ATL::CComSafeDeleteCriticalSection::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComSafeDeleteCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComSafeDeleteCriticalSection@ATL@@QAEJXZ PROC	; ATL::CComSafeDeleteCriticalSection::Init, COMDAT
; _this$ = ecx

; 184  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 185  : 		ATLASSERT( !m_bInitialized );
; 186  : 		HRESULT hr = CComCriticalSection::Init();

  00002	33 f6		 xor	 esi, esi
  00004	8b f9		 mov	 edi, ecx
  00006	56		 push	 esi
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
  0000f	85 c0		 test	 eax, eax
  00011	75 19		 jne	 SHORT $LN13@Init
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00019	8b f0		 mov	 esi, eax
  0001b	85 f6		 test	 esi, esi
  0001d	7e 0b		 jle	 SHORT $LN15@Init
  0001f	0f b7 f6	 movzx	 esi, si
  00022	81 ce 00 00 07
	80		 or	 esi, -2147024896	; 80070000H

; 187  : 		if (SUCCEEDED(hr))

  00028	85 f6		 test	 esi, esi
$LN15@Init:
  0002a	78 04		 js	 SHORT $LN16@Init
$LN13@Init:

; 188  : 		{
; 189  : 			m_bInitialized = true;

  0002c	c6 47 18 01	 mov	 BYTE PTR [edi+24], 1
$LN16@Init:
  00030	5f		 pop	 edi

; 190  : 		}
; 191  : 		return hr;

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi

; 192  : 	}

  00034	c3		 ret	 0
?Init@CComSafeDeleteCriticalSection@ATL@@QAEJXZ ENDP	; ATL::CComSafeDeleteCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??1CComSafeDeleteCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComSafeDeleteCriticalSection@ATL@@QAE@XZ PROC	; ATL::CComSafeDeleteCriticalSection::~CComSafeDeleteCriticalSection, COMDAT
; _this$ = ecx

; 175  : 		if (!m_bInitialized)

  00000	80 79 18 00	 cmp	 BYTE PTR [ecx+24], 0
  00004	74 0b		 je	 SHORT $LN1@CComSafeDe

; 176  : 		{
; 177  : 			return;
; 178  : 		}
; 179  : 		m_bInitialized = false;
; 180  : 		CComCriticalSection::Term();

  00006	51		 push	 ecx
  00007	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
$LN1@CComSafeDe:

; 181  : 	}

  00011	c3		 ret	 0
??1CComSafeDeleteCriticalSection@ATL@@QAE@XZ ENDP	; ATL::CComSafeDeleteCriticalSection::~CComSafeDeleteCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0CComSafeDeleteCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComSafeDeleteCriticalSection@ATL@@QAE@XZ PROC	; ATL::CComSafeDeleteCriticalSection::CComSafeDeleteCriticalSection, COMDAT
; _this$ = ecx

; 170  : 	{

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 171  : 	}

  00003	8b c1		 mov	 eax, ecx
  00005	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00008	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0000d	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0
  00011	c3		 ret	 0
??0CComSafeDeleteCriticalSection@ATL@@QAE@XZ ENDP	; ATL::CComSafeDeleteCriticalSection::CComSafeDeleteCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 140  : 		DeleteCriticalSection(&m_sec);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 141  : 		return S_OK;

  00007	33 c0		 xor	 eax, eax

; 142  : 	}

  00009	c3		 ret	 0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 129  : 		HRESULT hRes = S_OK;
; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	51		 push	 ecx
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
  0000b	85 c0		 test	 eax, eax
  0000d	75 13		 jne	 SHORT $LN10@Init

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00015	85 c0		 test	 eax, eax
  00017	7e 0b		 jle	 SHORT $LN9@Init
  00019	0f b7 c0	 movzx	 eax, ax
  0001c	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H

; 136  : 	}

  00021	c3		 ret	 0
$LN10@Init:

; 133  : 		}
; 134  : 
; 135  : 		return hRes;

  00022	33 c0		 xor	 eax, eax

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

$LN9@Init:

; 136  : 	}

  00024	c3		 ret	 0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Unlock@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Unlock, COMDAT
; _this$ = ecx

; 124  : 		LeaveCriticalSection(&m_sec);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 125  : 		return S_OK;

  00007	33 c0		 xor	 eax, eax

; 126  : 	}

  00009	c3		 ret	 0
?Unlock@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Lock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Lock@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Lock, COMDAT
; _this$ = ecx

; 119  : 		EnterCriticalSection(&m_sec);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 120  : 		return S_OK;

  00007	33 c0		 xor	 eax, eax

; 121  : 	}

  00009	c3		 ret	 0
?Lock@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 115  : 	}

  00000	c3		 ret	 0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 108  : 	CComCriticalSection() throw()

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 109  : 	{
; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
; 111  : 	}

  00003	8b c1		 mov	 eax, ecx
  00005	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00008	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0000d	c3		 ret	 0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00003	ff 75 10	 push	 DWORD PTR _Flags$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _dwSpinCount$[ebp]
  00009	ff 75 08	 push	 DWORD PTR _lpCriticalSection$[ebp]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12

; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 736  : #endif
; 737  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlchecked.h
;	COMDAT ?tcsncpy_s@Checked@ATL@@YAHPADIPBDI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__SizeInChars$ = 12					; size = 4
__Source$ = 16						; size = 4
__Count$ = 20						; size = 4
?tcsncpy_s@Checked@ATL@@YAHPADIPBDI@Z PROC		; ATL::Checked::tcsncpy_s, COMDAT

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 138  : 	return ATLMFC_CRT_ERRORCHECK(::_tcsncpy_s(_Dest, _SizeInChars, _Source,_Count));

  00003	ff 75 14	 push	 DWORD PTR __Count$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Source$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __SizeInChars$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  0000f	e8 00 00 00 00	 call	 __mbsnbcpy_s
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 139  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?tcsncpy_s@Checked@ATL@@YAHPADIPBDI@Z ENDP		; ATL::Checked::tcsncpy_s
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlchecked.h
;	COMDAT ?AtlCrtErrorCheck@ATL@@YAHH@Z
_TEXT	SEGMENT
_nError$ = 8						; size = 4
?AtlCrtErrorCheck@ATL@@YAHH@Z PROC			; ATL::AtlCrtErrorCheck, COMDAT

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 32   : 	switch(nError)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _nError$[ebp]
  00006	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00009	77 26		 ja	 SHORT $LN7@AtlCrtErro
  0000b	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR $LN9@AtlCrtErro[ecx]
  00012	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN12@AtlCrtErro[eax*4]
$LN6@AtlCrtErro:

; 46   : 		break;
; 47   : 	}
; 48   : 	return nError;

  00019	8b c1		 mov	 eax, ecx

; 49   : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN11@AtlCrtErro:

; 33   : 	{
; 34   : 	case ENOMEM:
; 35   : 		AtlThrow(E_OUTOFMEMORY);

  0001d	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00022	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@AtlCrtErro:
$LN5@AtlCrtErro:

; 36   : 		break;
; 37   : 	case EINVAL:
; 38   : 	case ERANGE:
; 39   : 		AtlThrow(E_INVALIDARG);

  00027	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0002c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN14@AtlCrtErro:
$LN7@AtlCrtErro:

; 40   : 		break;
; 41   : 	case 0:
; 42   : 	case STRUNCATE:
; 43   : 		break;
; 44   : 	default:
; 45   : 		AtlThrow(E_FAIL);

  00031	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00036	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN15@AtlCrtErro:
$LN10@AtlCrtErro:
  0003b	90		 npad	 1
$LN12@AtlCrtErro:

; 49   : }

  0003c	00 00 00 00	 DD	 $LN6@AtlCrtErro
  00040	00 00 00 00	 DD	 $LN11@AtlCrtErro
  00044	00 00 00 00	 DD	 $LN5@AtlCrtErro
  00048	00 00 00 00	 DD	 $LN7@AtlCrtErro
$LN9@AtlCrtErro:
  0004c	00		 DB	 0
  0004d	03		 DB	 3
  0004e	03		 DB	 3
  0004f	03		 DB	 3
  00050	03		 DB	 3
  00051	03		 DB	 3
  00052	03		 DB	 3
  00053	03		 DB	 3
  00054	03		 DB	 3
  00055	03		 DB	 3
  00056	03		 DB	 3
  00057	03		 DB	 3
  00058	01		 DB	 1
  00059	03		 DB	 3
  0005a	03		 DB	 3
  0005b	03		 DB	 3
  0005c	03		 DB	 3
  0005d	03		 DB	 3
  0005e	03		 DB	 3
  0005f	03		 DB	 3
  00060	03		 DB	 3
  00061	03		 DB	 3
  00062	02		 DB	 2
  00063	03		 DB	 3
  00064	03		 DB	 3
  00065	03		 DB	 3
  00066	03		 DB	 3
  00067	03		 DB	 3
  00068	03		 DB	 3
  00069	03		 DB	 3
  0006a	03		 DB	 3
  0006b	03		 DB	 3
  0006c	03		 DB	 3
  0006d	03		 DB	 3
  0006e	02		 DB	 2
  0006f	03		 DB	 3
  00070	03		 DB	 3
  00071	03		 DB	 3
  00072	03		 DB	 3
  00073	03		 DB	 3
  00074	03		 DB	 3
  00075	03		 DB	 3
  00076	03		 DB	 3
  00077	03		 DB	 3
  00078	03		 DB	 3
  00079	03		 DB	 3
  0007a	03		 DB	 3
  0007b	03		 DB	 3
  0007c	03		 DB	 3
  0007d	03		 DB	 3
  0007e	03		 DB	 3
  0007f	03		 DB	 3
  00080	03		 DB	 3
  00081	03		 DB	 3
  00082	03		 DB	 3
  00083	03		 DB	 3
  00084	03		 DB	 3
  00085	03		 DB	 3
  00086	03		 DB	 3
  00087	03		 DB	 3
  00088	03		 DB	 3
  00089	03		 DB	 3
  0008a	03		 DB	 3
  0008b	03		 DB	 3
  0008c	03		 DB	 3
  0008d	03		 DB	 3
  0008e	03		 DB	 3
  0008f	03		 DB	 3
  00090	03		 DB	 3
  00091	03		 DB	 3
  00092	03		 DB	 3
  00093	03		 DB	 3
  00094	03		 DB	 3
  00095	03		 DB	 3
  00096	03		 DB	 3
  00097	03		 DB	 3
  00098	03		 DB	 3
  00099	03		 DB	 3
  0009a	03		 DB	 3
  0009b	03		 DB	 3
  0009c	00		 DB	 0
?AtlCrtErrorCheck@ATL@@YAHH@Z ENDP			; ATL::AtlCrtErrorCheck
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )
; 69   : 	{
; 70   : 		AfxThrowMemoryException();
; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );
; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	89 45 08	 mov	 DWORD PTR $T1[ebp], eax
  00009	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	68 00 00 00 00	 push	 OFFSET __TI1?AVCAtlException@ATL@@
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN6@AtlThrowIm:
$LN5@AtlThrowIm:
  00017	cc		 int	 3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 44   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		m_hr( hr )

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 	}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	ff 75 0c	 push	 DWORD PTR _dwExceptionFlags$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _dwExceptionCode$[ebp]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16

; 32   : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1834 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);
; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s
  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1839 :         __crt_va_end(_ArgList);
; 1840 :         return _Result;
; 1841 :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1493 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1499 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 712  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 713  : 		// Walk the list and free the buffers
; 714  : 		while (m_pHead != NULL)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 14		 je	 SHORT $LN3@CAtlSafeAl
$LL2@CAtlSafeAl:

; 715  : 		{
; 716  : 			CAtlSafeAllocBufferNode* p = m_pHead;

  00008	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 717  : 			m_pHead = m_pHead->m_pNext;
; 718  : 			Allocator::Free(p);

  0000a	51		 push	 ecx
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	89 06		 mov	 DWORD PTR [esi], eax
  0000f	e8 00 00 00 00	 call	 _free
  00014	83 c4 04	 add	 esp, 4
  00017	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0001a	75 ec		 jne	 SHORT $LL2@CAtlSafeAl
$LN3@CAtlSafeAl:
  0001c	5e		 pop	 esi

; 719  : 		}
; 720  : 	}

  0001d	c3		 ret	 0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 700  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 701  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(::ATL::AtlAddThrow(nRequestedSize, static_cast<SIZE_T>(sizeof(CAtlSafeAllocBufferNode))));

  00003	8b 55 08	 mov	 edx, DWORD PTR _nRequestedSize$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	f7 d0		 not	 eax
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	83 f8 08	 cmp	 eax, 8
  00010	72 25		 jb	 SHORT $LN21@Allocate
  00012	8d 42 08	 lea	 eax, DWORD PTR [edx+8]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _malloc
  0001b	8b c8		 mov	 ecx, eax
  0001d	83 c4 04	 add	 esp, 4

; 702  : 		if (p == NULL)

  00020	85 c9		 test	 ecx, ecx
  00022	75 05		 jne	 SHORT $LN2@Allocate
  00024	5e		 pop	 esi

; 710  : 	}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN2@Allocate:

; 703  : 			return NULL;
; 704  : 
; 705  : 		// Add buffer to the list
; 706  : 		p->m_pNext = m_pHead;

  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax

; 707  : 		m_pHead = p;
; 708  : 
; 709  : 		return p->GetData();

  0002d	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00030	89 0e		 mov	 DWORD PTR [esi], ecx
  00032	5e		 pop	 esi

; 710  : 	}

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN21@Allocate:

; 701  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(::ATL::AtlAddThrow(nRequestedSize, static_cast<SIZE_T>(sizeof(CAtlSafeAllocBufferNode))));

  00037	68 16 02 07 80	 push	 -2147024362		; 80070216H
  0003c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@Allocate:
$LN20@Allocate:
  00041	cc		 int	 3
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 696  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 698  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?ocslen@@YAHPB_W@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ocslen@@YAHPB_W@Z PROC					; ocslen, COMDAT

; 738  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 739  : 	if (x == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN2@ocslen

; 745  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN2@ocslen:

; 740  : 	{
; 741  : 		return 0;
; 742  : 	}
; 743  : 
; 744  : 	return static_cast<int>(wcslen(x));

  0000c	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  0000f	90		 npad	 1
$LL4@ocslen:
  00010	66 8b 08	 mov	 cx, WORD PTR [eax]
  00013	83 c0 02	 add	 eax, 2
  00016	66 85 c9	 test	 cx, cx
  00019	75 f5		 jne	 SHORT $LL4@ocslen
  0001b	2b c2		 sub	 eax, edx
  0001d	d1 f8		 sar	 eax, 1

; 745  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?ocslen@@YAHPB_W@Z ENDP					; ocslen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPB_WHI@Z PROC			; AtlW2AHelper, COMDAT

; 595  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 596  : 	ATLASSERT(lpw != NULL);
; 597  : 	ATLASSERT(lpa != NULL);
; 598  : 	if (lpa == NULL || lpw == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpa$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 2b		 je	 SHORT $LN3@AtlW2AHelp
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _lpw$[ebp]
  0000e	85 c0		 test	 eax, eax
  00010	74 24		 je	 SHORT $LN3@AtlW2AHelp

; 600  : 	// verify that no illegal character present
; 601  : 	// since lpa was allocated based on the size of lpw
; 602  : 	// don't worry about the number of chars
; 603  : 	*lpa = '\0';
; 604  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	ff 75 10	 push	 DWORD PTR _nChars$[ebp]
  00019	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001c	56		 push	 esi
  0001d	6a ff		 push	 -1
  0001f	50		 push	 eax
  00020	6a 00		 push	 0
  00022	ff 75 14	 push	 DWORD PTR _acp$[ebp]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 605  : 	if(ret == 0)

  0002b	f7 d8		 neg	 eax
  0002d	1b c0		 sbb	 eax, eax
  0002f	23 c6		 and	 eax, esi
  00031	5e		 pop	 esi

; 606  : 	{
; 607  : 		ATLASSERT(FALSE);
; 608  : 		return NULL;
; 609  : 	}
; 610  : 	return lpa;
; 611  : }

  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H
$LN3@AtlW2AHelp:

; 599  : 		return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	5e		 pop	 esi

; 606  : 	{
; 607  : 		ATLASSERT(FALSE);
; 608  : 		return NULL;
; 609  : 	}
; 610  : 	return lpa;
; 611  : }

  00039	5d		 pop	 ebp
  0003a	c2 10 00	 ret	 16			; 00000010H
?AtlW2AHelper@@YGPADPADPB_WHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z PROC			; AtlA2WHelper, COMDAT

; 570  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 571  : 	ATLASSERT(lpa != NULL);
; 572  : 	ATLASSERT(lpw != NULL);
; 573  : 	if (lpw == NULL || lpa == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpw$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN3@AtlA2WHelp
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _lpa$[ebp]
  0000e	85 c0		 test	 eax, eax
  00010	74 21		 je	 SHORT $LN3@AtlA2WHelp

; 575  : 	// verify that no illegal character present
; 576  : 	// since lpw was allocated based on the size of lpa
; 577  : 	// don't worry about the number of chars
; 578  : 	*lpw = '\0';
; 579  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

  00012	ff 75 10	 push	 DWORD PTR _nChars$[ebp]
  00015	33 c9		 xor	 ecx, ecx
  00017	56		 push	 esi
  00018	6a ff		 push	 -1
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	ff 75 14	 push	 DWORD PTR _acp$[ebp]
  0001f	66 89 0e	 mov	 WORD PTR [esi], cx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 580  : 	if(ret == 0)

  00028	f7 d8		 neg	 eax
  0002a	1b c0		 sbb	 eax, eax
  0002c	23 c6		 and	 eax, esi
  0002e	5e		 pop	 esi

; 581  : 	{
; 582  : 		ATLASSERT(FALSE);
; 583  : 		return NULL;
; 584  : 	}		
; 585  : 	return lpw;
; 586  : }

  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
$LN3@AtlA2WHelp:

; 574  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 581  : 	{
; 582  : 		ATLASSERT(FALSE);
; 583  : 		return NULL;
; 584  : 	}		
; 585  : 	return lpw;
; 586  : }

  00036	5d		 pop	 ebp
  00037	c2 10 00	 ret	 16			; 00000010H
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC			; ATL::_AtlGetConversionACP, COMDAT

; 106  : #ifdef _CONVERSION_DONT_USE_THREAD_LOCALE
; 107  : 	return CP_ACP;
; 108  : #else
; 109  : 	return CP_THREAD_ACP;

  00000	b8 03 00 00 00	 mov	 eax, 3

; 110  : #endif
; 111  : }

  00005	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlAdd<unsigned long>, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 55 10	 mov	 edx, DWORD PTR _tRight$[ebp]
  0000b	f7 d0		 not	 eax
  0000d	3b c2		 cmp	 eax, edx
  0000f	73 07		 jae	 SHORT $LN2@AtlAdd

; 101  : 	{
; 102  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  00011	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H

; 106  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN2@AtlAdd:

; 103  : 	}
; 104  : 	*ptResult= tLeft + tRight;

  00018	8b 45 08	 mov	 eax, DWORD PTR _ptResult$[ebp]
  0001b	03 ca		 add	 ecx, edx
  0001d	89 08		 mov	 DWORD PTR [eax], ecx

; 105  : 	return S_OK;

  0001f	33 c0		 xor	 eax, eax

; 106  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??$AtlAdd@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlAdd<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
_size$2 = -36						; size = 4
_bStackAvailable$ = -29					; size = 1
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 635  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 14	 sub	 esp, 20			; 00000014H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 636  :     bool bStackAvailable = true;

  00036	b3 01		 mov	 bl, 1

; 637  : 
; 638  :     __try

  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 639  :     {
; 640  : 		SIZE_T size=0;

  0003f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _size$2[ebp], 0

; 641  : 		HRESULT hrAdd=::ATL::AtlAdd(&size, Size, static_cast<SIZE_T>(_ATL_STACK_MARGIN));

  00046	68 00 20 00 00	 push	 8192			; 00002000H
  0004b	ff 75 08	 push	 DWORD PTR _Size$[ebp]
  0004e	8d 45 dc	 lea	 eax, DWORD PTR _size$2[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$AtlAdd@K@ATL@@YAJPAKKK@Z ; ATL::AtlAdd<unsigned long>
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 642  : 		if(FAILED(hrAdd))

  0005a	85 c0		 test	 eax, eax
  0005c	79 07		 jns	 SHORT $LN3@AtlVerifyS

; 643  : 		{
; 644  : 			ATLASSERT(FALSE);
; 645  : 			bStackAvailable = false;

  0005e	32 db		 xor	 bl, bl
  00060	88 5d e3	 mov	 BYTE PTR _bStackAvailable$[ebp], bl

; 646  : 		}
; 647  : 		else

  00063	eb 2d		 jmp	 SHORT $LN4@AtlVerifyS
$LN3@AtlVerifyS:

; 648  : 		{
; 649  : 			PVOID p = _alloca(size);

  00065	8b 45 dc	 mov	 eax, DWORD PTR _size$2[ebp]
  00068	e8 00 00 00 00	 call	 __alloca_probe_16
  0006d	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 650  : 			(p);
; 651  : 		}
; 652  :     }

  00070	eb 20		 jmp	 SHORT $LN4@AtlVerifyS
$LN7@AtlVerifyS:

; 653  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?

  00072	8b 45 ec	 mov	 eax, DWORD PTR __$SEHRec$[ebp+4]
  00075	8b 00		 mov	 eax, DWORD PTR [eax]
  00077	33 c9		 xor	 ecx, ecx
  00079	81 38 fd 00 00
	c0		 cmp	 DWORD PTR [eax], -1073741571 ; c00000fdH
  0007f	0f 94 c1	 sete	 cl
  00082	8b c1		 mov	 eax, ecx
$LN9@AtlVerifyS:
  00084	c3		 ret	 0
$LN8@AtlVerifyS:
  00085	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 654  :                    EXCEPTION_EXECUTE_HANDLER :
; 655  :                    EXCEPTION_CONTINUE_SEARCH)
; 656  :     {
; 657  :         bStackAvailable = false;

  00088	32 db		 xor	 bl, bl
  0008a	88 5d e3	 mov	 BYTE PTR _bStackAvailable$[ebp], bl

; 658  : #if defined( _ATL_USE_WINAPI_FAMILY_DESKTOP_APP)
; 659  :         _resetstkoflw();

  0008d	e8 00 00 00 00	 call	 __resetstkoflw
$LN4@AtlVerifyS:

; 650  : 			(p);
; 651  : 		}
; 652  :     }

  00092	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH

; 660  : #endif
; 661  :     }
; 662  :     return bStackAvailable;

  00099	8a c3		 mov	 al, bl

; 663  : }

  0009b	8d 65 cc	 lea	 esp, DWORD PTR [ebp-52]
  0009e	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000af	33 cd		 xor	 ecx, ebp
  000b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC			; ATL::CCRTAllocator::Free, COMDAT

; 282  : 		free(p);

  00000	e9 00 00 00 00	 jmp	 _free
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC		; ATL::CCRTAllocator::Allocate, COMDAT

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 278  : 	}

  00003	5d		 pop	 ebp

; 277  : 		return malloc(nBytes);

  00004	e9 00 00 00 00	 jmp	 _malloc
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlchecked.h
;	COMDAT ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S1max$ = 12						; size = 4
__S2$ = 16						; size = 4
__N$ = 20						; size = 4
?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z PROC		; ATL::Checked::memcpy_s, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  00003	ff 75 14	 push	 DWORD PTR __N$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __S2$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __S1max$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __S1$[ebp]
  0000f	e8 00 00 00 00	 call	 _memcpy_s
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 70   : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ENDP		; ATL::Checked::memcpy_s
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z
_TEXT	SEGMENT
_pvMemory$ = 8						; size = 4
_nCount$ = 12						; size = 4
_nSize$ = 16						; size = 4
?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z PROC		; ATL::AtlCoTaskMemRecalloc, COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 236  : 	HRESULT hr;
; 237  : 	ULONG nBytes=0;
; 238  : 	if( FAILED(hr=::ATL::AtlMultiply(&nBytes, nCount, nSize)))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _nCount$[ebp]
  00006	f7 65 10	 mul	 DWORD PTR _nSize$[ebp]
  00009	85 d2		 test	 edx, edx
  0000b	75 11		 jne	 SHORT $LN12@AtlCoTaskM
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 0c		 ja	 SHORT $LN12@AtlCoTaskM

; 241  : 	}
; 242  : 	return ::CoTaskMemRealloc(pvMemory, nBytes);

  00012	50		 push	 eax
  00013	ff 75 08	 push	 DWORD PTR _pvMemory$[ebp]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemRealloc@8

; 243  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN12@AtlCoTaskM:

; 239  : 	{
; 240  : 		return NULL;

  0001e	33 c0		 xor	 eax, eax

; 243  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z ENDP		; ATL::AtlCoTaskMemRecalloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z
_TEXT	SEGMENT
_nCount$ = 8						; size = 4
_nSize$ = 12						; size = 4
?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z PROC			; ATL::AtlCoTaskMemCAlloc, COMDAT

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 222  : 	HRESULT hr;
; 223  : 	ULONG nBytes=0;
; 224  : 	if( FAILED(hr=::ATL::AtlMultiply(&nBytes, nCount, nSize)))

  00003	8b 45 08	 mov	 eax, DWORD PTR _nCount$[ebp]
  00006	f7 65 0c	 mul	 DWORD PTR _nSize$[ebp]
  00009	85 d2		 test	 edx, edx
  0000b	75 0e		 jne	 SHORT $LN12@AtlCoTaskM
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 09		 ja	 SHORT $LN12@AtlCoTaskM

; 227  : 	}
; 228  : 	return ::CoTaskMemAlloc(nBytes);

  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemAlloc@4

; 229  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN12@AtlCoTaskM:

; 225  : 	{
; 226  : 		return NULL;

  0001b	33 c0		 xor	 eax, eax

; 229  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z ENDP			; ATL::AtlCoTaskMemCAlloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlMultiply<unsigned long>, COMDAT

; 180  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 181  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00006	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]

; 182  : 	if(i64Result>ULONG_MAX)

  00009	85 d2		 test	 edx, edx
  0000b	75 0e		 jne	 SHORT $LN8@AtlMultipl
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 09		 ja	 SHORT $LN8@AtlMultipl

; 185  : 	}
; 186  : 	*piResult=static_cast<unsigned long _ATL_W64>(i64Result);

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 187  : 	return S_OK;

  00017	33 c0		 xor	 eax, eax

; 188  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN8@AtlMultipl:

; 183  : 	{
; 184  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0001b	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H

; 188  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$AtlMultiply@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlMultiply<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00006	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]

; 152  : 	if(i64Result>UINT_MAX)

  00009	85 d2		 test	 edx, edx
  0000b	75 0e		 jne	 SHORT $LN8@AtlMultipl
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 09		 ja	 SHORT $LN8@AtlMultipl

; 155  : 	}
; 156  : 	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 157  : 	return S_OK;

  00017	33 c0		 xor	 eax, eax

; 158  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN8@AtlMultipl:

; 153  : 	{
; 154  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0001b	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H

; 158  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@H@ATL@@YAJPAHHH@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@H@ATL@@YAJPAHHH@Z PROC			; ATL::AtlMultiply<int>, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  : 	__int64 i64Result=static_cast<__int64>(iLeft) * static_cast<__int64>(iRight);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00006	f7 6d 10	 imul	 DWORD PTR _iRight$[ebp]
  00009	56		 push	 esi
  0000a	8b f0		 mov	 esi, eax

; 137  : 	if(i64Result>INT_MAX || i64Result < INT_MIN)

  0000c	8b ce		 mov	 ecx, esi
  0000e	81 c1 00 00 00
	80		 add	 ecx, -2147483648	; 80000000H
  00014	83 d2 00	 adc	 edx, 0
  00017	85 d2		 test	 edx, edx
  00019	77 11		 ja	 SHORT $LN3@AtlMultipl
  0001b	72 05		 jb	 SHORT $LN9@AtlMultipl
  0001d	83 f9 ff	 cmp	 ecx, -1
  00020	77 0a		 ja	 SHORT $LN3@AtlMultipl
$LN9@AtlMultipl:

; 140  : 	}
; 141  : 	*piResult=static_cast<int _ATL_W64>(i64Result);

  00022	8b 45 08	 mov	 eax, DWORD PTR _piResult$[ebp]
  00025	89 30		 mov	 DWORD PTR [eax], esi

; 142  : 	return S_OK;

  00027	33 c0		 xor	 eax, eax
  00029	5e		 pop	 esi

; 143  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN3@AtlMultipl:

; 138  : 	{
; 139  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0002c	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H
  00031	5e		 pop	 esi

; 143  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$AtlMultiply@H@ATL@@YAJPAHHH@Z ENDP			; ATL::AtlMultiply<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT ?_tcsstr@@YAPADPADPBD@Z
_TEXT	SEGMENT
__S$ = 8						; size = 4
__P$ = 12						; size = 4
?_tcsstr@@YAPADPADPBD@Z PROC				; _tcsstr, COMDAT

; 2029 :         {return ((char *)_tcsstr((const char *)_S, _P)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	e9 00 00 00 00	 jmp	 __mbsstr
?_tcsstr@@YAPADPADPBD@Z ENDP				; _tcsstr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsstr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcsstr PROC						; COMDAT

; 1571 : _Check_return_ __inline _CRPC _tcsstr(_In_ _CPC _s1,_In_ _CPC _s2) {return (_CRPC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	e9 00 00 00 00	 jmp	 __mbsstr
__tcsstr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsncpy_s
_TEXT	SEGMENT
__Destination$ = 8					; size = 4
__Destination_size_chars$ = 12				; size = 4
__Source$ = 16						; size = 4
__Count$ = 20						; size = 4
__tcsncpy_s PROC					; COMDAT

; 1535 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1537 : }

  00003	5d		 pop	 ebp

; 1536 :     return _mbsnbcpy_s((unsigned char *)_Destination, _Destination_size_chars, (const unsigned char *)_Source,_Count);

  00004	e9 00 00 00 00	 jmp	 __mbsnbcpy_s
__tcsncpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
??0IUnknown@@QAE@XZ PROC				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	7e 08		 jle	 SHORT $LN4@HRESULT_FR
  0000a	0f b7 c0	 movzx	 eax, ax
  0000d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN4@HRESULT_FR:
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_memcpy_s.h
;	COMDAT _memcpy_s
_TEXT	SEGMENT
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memcpy_s PROC						; COMDAT

; 41   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 42   :         if (_SourceSize == 0)

  00004	8b 75 14	 mov	 esi, DWORD PTR __SourceSize$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 05		 jne	 SHORT $LN2@memcpy_s

; 43   :         {
; 44   :             return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 61   :     }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN2@memcpy_s:

; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Destination$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	75 18		 jne	 SHORT $LN3@memcpy_s
  00017	e8 00 00 00 00	 call	 __errno
  0001c	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00022	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00027	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0002c	5e		 pop	 esi

; 61   :     }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN3@memcpy_s:
  0002f	53		 push	 ebx

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00030	8b 5d 10	 mov	 ebx, DWORD PTR __Source$[ebp]
  00033	57		 push	 edi
  00034	8b 7d 0c	 mov	 edi, DWORD PTR __DestinationSize$[ebp]
  00037	85 db		 test	 ebx, ebx
  00039	74 16		 je	 SHORT $LN5@memcpy_s
  0003b	3b fe		 cmp	 edi, esi
  0003d	72 12		 jb	 SHORT $LN5@memcpy_s

; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  0003f	56		 push	 esi
  00040	53		 push	 ebx
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _memcpy
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   :         return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	5f		 pop	 edi
  0004d	5b		 pop	 ebx
  0004e	5e		 pop	 esi

; 61   :     }

  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00051	57		 push	 edi
  00052	6a 00		 push	 0
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _memset
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  0005d	85 db		 test	 ebx, ebx
  0005f	75 1a		 jne	 SHORT $LN6@memcpy_s
  00061	e8 00 00 00 00	 call	 __errno
  00066	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  0006c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@memcpy_s:

; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;

  00071	5f		 pop	 edi
  00072	5b		 pop	 ebx
  00073	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00078	5e		 pop	 esi

; 61   :     }

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN6@memcpy_s:

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  0007b	3b fe		 cmp	 edi, esi
  0007d	73 f2		 jae	 SHORT $LN7@memcpy_s
  0007f	e8 00 00 00 00	 call	 __errno
  00084	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  0008a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0008f	5f		 pop	 edi
  00090	5b		 pop	 ebx
  00091	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  00096	5e		 pop	 esi

; 61   :     }

  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_memcpy_s ENDP
_TEXT	ENDS
END
