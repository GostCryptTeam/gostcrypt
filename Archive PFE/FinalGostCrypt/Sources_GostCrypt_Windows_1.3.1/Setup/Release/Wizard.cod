; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Desktop\Sources_GostCrypt_Windows_1.3.1_COMMENTED\Sources_GostCrypt_Windows_1.3.1é\Sources_GostCrypt_Windows_1.3.1\Setup\Wizard.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?hCurPage@@3PAUHWND__@@A			; hCurPage
PUBLIC	?nCurPageNo@@3HA				; nCurPageNo
PUBLIC	?WizardDestInstallPath@@3PADA			; WizardDestInstallPath
PUBLIC	?WizardDestExtractPath@@3PADA			; WizardDestExtractPath
PUBLIC	?SelfFile@@3PADA				; SelfFile
PUBLIC	?hbmWizardBitmapRescaled@@3PAUHBITMAP__@@A	; hbmWizardBitmapRescaled
PUBLIC	?bExtractOnly@@3HA				; bExtractOnly
PUBLIC	?bLicenseAccepted@@3HA				; bLicenseAccepted
PUBLIC	?bOpenContainingFolder@@3HA			; bOpenContainingFolder
PUBLIC	?bExtractionSuccessful@@3HA			; bExtractionSuccessful
PUBLIC	?bStartInstall@@3HA				; bStartInstall
PUBLIC	?bStartExtraction@@3HA				; bStartExtraction
PUBLIC	?bInProgress@@3HA				; bInProgress
PUBLIC	?nPbar@@3HA					; nPbar
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	_bPromptTutorial
PUBLIC	_bPromptReleaseNotes
_BSS	SEGMENT
?hCurPage@@3PAUHWND__@@A DD 01H DUP (?)			; hCurPage
?WizardDestInstallPath@@3PADA DB 0104H DUP (?)		; WizardDestInstallPath
?WizardDestExtractPath@@3PADA DB 0104H DUP (?)		; WizardDestExtractPath
?SelfFile@@3PADA DB 0104H DUP (?)			; SelfFile
?hbmWizardBitmapRescaled@@3PAUHBITMAP__@@A DD 01H DUP (?) ; hbmWizardBitmapRescaled
?bExtractOnly@@3HA DD 01H DUP (?)			; bExtractOnly
?bLicenseAccepted@@3HA DD 01H DUP (?)			; bLicenseAccepted
?bExtractionSuccessful@@3HA DD 01H DUP (?)		; bExtractionSuccessful
?bStartInstall@@3HA DD 01H DUP (?)			; bStartInstall
?bStartExtraction@@3HA DD 01H DUP (?)			; bStartExtraction
?bInProgress@@3HA DD 01H DUP (?)			; bInProgress
?nPbar@@3HA DD	01H DUP (?)				; nPbar
_bPromptTutorial DD 01H DUP (?)
_bPromptReleaseNotes DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?nCurPageNo@@3HA DD 0ffffffffH				; nCurPageNo
?bOpenContainingFolder@@3HA DD 01H			; bOpenContainingFolder
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	_InitProgressBar
PUBLIC	_UpdateProgressBarProc
PUBLIC	_RefreshUIGFX
PUBLIC	_localcleanupwiz
PUBLIC	_PageDialogProc@16
PUBLIC	_MainDialogProc@16
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	?LoadPage@@YAXPAUHWND__@@H@Z			; LoadPage
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; DonText
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_0O@MGHONKG@IDD_INSTL_DLG?$AA@		; `string'
PUBLIC	??_C@_0BF@EOKBACHI@SETUP_WIZARD_PAGE_?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BH@MFJOAEDC@CANNOT_DISPLAY_LICENSE?$AA@	; `string'
PUBLIC	??_C@_1DM@EGEEIDAI@?$AAP?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KO@PHMNFEJ@?$AAY?$AAo?$AAu?$AA?5?$AAm?$AAu?$AAs?$AAt?$AA?5?$AAa?$AAc?$AAc?$AAe?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAe?$AAs?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe@ ; `string'
PUBLIC	??_C@_1BIA@MJJKLEKE@?$AAI?$AAM?$AAP?$AAO?$AAR?$AAT?$AAA?$AAN?$AAT?$AA?3?$AA?5?$AAB?$AAy?$AA?5?$AAc?$AAh?$AAe?$AAc?$AAk?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAc?$AAh?$AAe?$AAc?$AAk@ ; `string'
PUBLIC	??_C@_1DI@FKGEFKMH@?$AAI?$AA?5?$AA?$CG?$AAa?$AAc?$AAc?$AAe?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_04MOKMKBJN@NEXT?$AA@			; `string'
PUBLIC	??_C@_04PKHKLFPJ@PREV?$AA@			; `string'
PUBLIC	??_C@_06JHILMIHF@CANCEL?$AA@			; `string'
PUBLIC	??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@	; `string'
PUBLIC	??_C@_07CNHFDDPI@UPGRADE?$AA@			; `string'
PUBLIC	??_C@_0BB@KMHMHMNP@SETUP_MODE_TITLE?$AA@	; `string'
PUBLIC	??_C@_0BA@PHBLGFGD@SETUP_MODE_INFO?$AA@		; `string'
PUBLIC	??_C@_0BI@KCCOCEA@SETUP_MODE_HELP_EXTRACT?$AA@	; `string'
PUBLIC	??_C@_0BI@JGKCNIKM@SETUP_MODE_HELP_UPGRADE?$AA@	; `string'
PUBLIC	??_C@_0BI@ECIBEEIH@SETUP_MODE_HELP_INSTALL?$AA@	; `string'
PUBLIC	??_C@_0L@EDNBEOCA@GostCrypt?2?$AA@		; `string'
PUBLIC	??_C@_0BJ@PDGEILOG@EXTRACTION_OPTIONS_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BI@OKGEFEFK@EXTRACTION_OPTIONS_INFO?$AA@	; `string'
PUBLIC	??_C@_0BF@HFEALDNI@AUTO_FOLDER_CREATION?$AA@	; `string'
PUBLIC	??_C@_07LBPFAJBE@EXTRACT?$AA@			; `string'
PUBLIC	??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@		; `string'
PUBLIC	??_C@_0BJ@LJFMAAFG@EXTRACTION_PROGRESS_INFO?$AA@ ; `string'
PUBLIC	??_C@_0BH@PEMNLIII@EXTRACTION_IN_PROGRESS?$AA@	; `string'
PUBLIC	??_C@_0BE@EDFPLLMN@SETUP_OPTIONS_TITLE?$AA@	; `string'
PUBLIC	??_C@_0BD@BMMFNCA@SETUP_OPTIONS_INFO?$AA@	; `string'
PUBLIC	??_C@_0BK@GJOJHDCA@SETUP_UPGRADE_DESTINATION?$AA@ ; `string'
PUBLIC	??_C@_0L@CANDMBMO@?2GostCrypt?$AA@		; `string'
PUBLIC	??_C@_07PJFGKPND@INSTALL?$AA@			; `string'
PUBLIC	??_C@_0BF@FGINDNOJ@SETUP_PROGRESS_TITLE?$AA@	; `string'
PUBLIC	??_C@_0BE@JGHDAHN@SETUP_PROGRESS_INFO?$AA@	; `string'
PUBLIC	??_C@_0BE@FMNDIKAG@INSTALL_IN_PROGRESS?$AA@	; `string'
PUBLIC	??_C@_0BO@CCIEODIN@EXTRACTION_FINISHED_TITLE_DON?$AA@ ; `string'
PUBLIC	??_C@_0CB@HFOJNJFM@SETUP_FINISHED_UPGRADE_TITLE_DON@ ; `string'
PUBLIC	??_C@_0BJ@KIEFKBPA@SETUP_FINISHED_TITLE_DON?$AA@ ; `string'
PUBLIC	??_C@_0BI@CKIDBLFB@SETUP_FINISHED_INFO_DON?$AA@	; `string'
PUBLIC	??_C@_1GG@BHNAKINK@?$AAI?$AAf?$AA?5?$AAy?$AAo?$AAu?$AA?5?$AAw?$AAa?$AAn?$AAt?$AA?5?$AAt?$AAo?$AA?5?$AAm?$AAa?$AAk?$AAe?$AA?5?$AAa?$AA?5?$AAd?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?0?$AA?5@ ; `string'
PUBLIC	??_C@_1CA@MBPOLHGL@?$AAT?$AAi?$AAm?$AAe?$AAs?$AA?5?$AAN?$AAe?$AAw?$AA?5?$AAR?$AAo?$AAm?$AAa?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@DJBAGGGN@SELECT_DEST_DIR?$AA@		; `string'
PUBLIC	??_C@_07KNCOJMJF@?$CGref?$DN?$CFd?$AA@		; `string'
PUBLIC	??_C@_0CK@KPOBPAGF@http?3?1?1www?4gostcrypt?4org?1redirec@ ; `string'
PUBLIC	??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@ ; `string'
PUBLIC	??_C@_0BG@GJBFCKEH@GostCrypt?5Setup?51?43?41?$AA@ ; `string'
PUBLIC	??_C@_1DIO@DJBHAIAH@?$AAW?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAP?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAn?$AAo?$AAt?$AAe?$AA?5?$AAt?$AAh?$AAa?$AAt?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AAm@ ; `string'
PUBLIC	??_C@_0DM@BHNBHIPG@SOFTWARE?2Microsoft?2Updates?2Windo@ ; `string'
PUBLIC	??_C@_1BBG@NBLOJHJE@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAs?$AA?5?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?5?$AAR?$AAo?$AAl?$AAl?$AAu?$AAp@ ; `string'
PUBLIC	??_C@_0BK@HICKIHM@TRAVELER_LIMITATIONS_NOTE?$AA@ ; `string'
PUBLIC	??_C@_0BC@NKLIMG@TRAVELER_UAC_NOTE?$AA@		; `string'
PUBLIC	??_C@_08MFKGCNCO@FINALIZE?$AA@			; `string'
PUBLIC	??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@		; `string'
PUBLIC	??_C@_07CIAHAGHC@IDCLOSE?$AA@			; `string'
PUBLIC	??_C@_0BJ@LLBBBPBJ@EXTRACTION_FINISHED_INFO?$AA@ ; `string'
PUBLIC	??_C@_0BC@GODHAKFG@EXTRACTION_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@	; `string'
PUBLIC	??_C@_04PMOCAHAA@open?$AA@			; `string'
PUBLIC	??_C@_0BM@PEPDOHPE@AFTER_UPGRADE_RELEASE_NOTES?$AA@ ; `string'
PUBLIC	??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@ ; `string'
PUBLIC	??_C@_0BH@JALPBIFE@AFTER_INSTALL_TUTORIAL?$AA@	; `string'
PUBLIC	??_C@_0BL@OMDAGJAA@UPGRADE_OK_REBOOT_REQUIRED?$AA@ ; `string'
PUBLIC	??_C@_0BA@ICICKJJH@CONFIRM_RESTART?$AA@		; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	__real@4059000000000000
PUBLIC	__real@bef0000000000000
PUBLIC	__real@bf00000000000000
PUBLIC	__xmm@00000000000000000000002d0000000f
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	_wcsncpy:PROC
EXTRN	_strncat:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__CreateFontIndirectW@4:PROC
EXTRN	__imp__CreateSolidBrush@4:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__SetBkColor@8:PROC
EXTRN	__imp__SetBkMode@8:PROC
EXTRN	__imp__SetTextColor@8:PROC
EXTRN	__imp__SetTextAlign@8:PROC
EXTRN	__imp__TextOutW@20:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__MoveWindow@24:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__CreateDialogParamW@20:PROC
EXTRN	__imp__DialogBoxParamW@20:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__SetDlgItemTextA@12:PROC
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__SetWindowTextW@8:PROC
EXTRN	__imp__GetWindowTextA@12:PROC
EXTRN	__imp__GetWindowTextLengthA@4:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__GetWindowRect@8:PROC
EXTRN	__imp__FillRect@12:PROC
EXTRN	__imp__GetParent@4:PROC
EXTRN	__imp__MapDialogRect@8:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__ShellExecuteA@24:PROC
EXTRN	__imp__CryptAcquireContextA@20:PROC
EXTRN	__imp__CryptReleaseContext@8:PROC
EXTRN	__imp__CryptGenRandom@12:PROC
EXTRN	_free:PROC
EXTRN	_exit:PROC
EXTRN	_srand:PROC
EXTRN	_rand:PROC
EXTRN	__beginthread:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	__imp__SHGetSpecialFolderPathA@16:PROC
EXTRN	__access:PROC
EXTRN	__time64:PROC
EXTRN	_localcleanup:PROC
EXTRN	_StatusMessage:PROC
EXTRN	_DetermineUpgradeDowngradeStatus:PROC
EXTRN	_DoInstall:PROC
EXTRN	_ExtractAllFilesThread:PROC
EXTRN	_AbortProcess:PROC
EXTRN	_AbortProcessSilent:PROC
EXTRN	_AboutDlgProc@16:PROC
EXTRN	_IsButtonChecked:PROC
EXTRN	_CheckButton:PROC
EXTRN	_InitDialog:PROC
EXTRN	_RenderBitmap:PROC
EXTRN	_WaitCursor:PROC
EXTRN	_NormalCursor:PROC
EXTRN	_CreateAppSetupMutex:PROC
EXTRN	_GetLegalNotices:PROC
EXTRN	_BrowseDirectories:PROC
EXTRN	_LocalizeDialog:PROC
EXTRN	_IsUacSupported:PROC
EXTRN	_SetCheckBox:PROC
EXTRN	_OpenPageHelp:PROC
EXTRN	_Info:PROC
EXTRN	_WarningDirect:PROC
EXTRN	_Error:PROC
EXTRN	_ErrorDirect:PROC
EXTRN	_AskYesNo:PROC
EXTRN	_AskNoYes:PROC
EXTRN	_AskWarnYesNo:PROC
EXTRN	_RestartComputer:PROC
EXTRN	_Extlink:PROC
EXTRN	_CompensateXDPI:PROC
EXTRN	_CompensateYDPI:PROC
EXTRN	_CompensateDPIFont:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	_GetString:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_bDevm:DWORD
EXTRN	_bUpgrade:DWORD
EXTRN	_bRepairMode:DWORD
EXTRN	_bSystemRestore:DWORD
EXTRN	_bForAllUsers:DWORD
EXTRN	_bRegisterFileExt:DWORD
EXTRN	_bAddToStartMenu:DWORD
EXTRN	_bDesktopIcon:DWORD
EXTRN	_bDesktopIconStatusDetermined:DWORD
EXTRN	_bRestartRequired:DWORD
EXTRN	_SystemRestoreDll:DWORD
EXTRN	_InstallationPath:BYTE
EXTRN	_SetupFilesDir:BYTE
EXTRN	_DestExtractPath:BYTE
EXTRN	_LastDialogId:DWORD
EXTRN	_hUserBoldFont:DWORD
EXTRN	_ScreenDPI:DWORD
EXTRN	_MainDlg:DWORD
EXTRN	_nCurrentOS:DWORD
EXTRN	_hInst:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?hDonTextFont@@3PAUHFONT__@@A DD 01H DUP (?)		; hDonTextFont
?OsPrngAvailable@@3HA DD 01H DUP (?)			; OsPrngAvailable
?hCryptProv@@3KA DD 01H DUP (?)				; hCryptProv
?DonColorSchemeId@@3HA DD 01H DUP (?)			; DonColorSchemeId
?DonTextColor@@3KA DD 01H DUP (?)			; DonTextColor
?DonBkgColor@@3KA DD 01H DUP (?)			; DonBkgColor
?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A DB 018H DUP (?) ; DonText
_BSS	ENDS
;	COMDAT ?prngInitialized@?1??GetDonVal@@YAHHH@Z@4HA
_BSS	SEGMENT
?prngInitialized@?1??GetDonVal@@YAHHH@Z@4HA DD 01H DUP (?) ; `GetDonVal'::`2'::prngInitialized
_BSS	ENDS
;	COMDAT ?buffer@?1??GetDonVal@@YAHHH@Z@4PAEA
_BSS	SEGMENT
?buffer@?1??GetDonVal@@YAHHH@Z@4PAEA DB 02H DUP (?)	; `GetDonVal'::`2'::buffer
_BSS	ENDS
;	COMDAT ?PageDebugId@?1??PageDialogProc@@9@16@4PADA
_BSS	SEGMENT
?PageDebugId@?1??PageDialogProc@@9@16@4PADA DB 080H DUP (?) ; `PageDialogProc'::`2'::PageDebugId
_BSS	ENDS
CRT$XCU	SEGMENT
?DonText$initializer$@@3P6AXXZA DD FLAT:??__EDonText@@YAXXZ ; DonText$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@00000000000000000000002d0000000f
CONST	SEGMENT
__xmm@00000000000000000000002d0000000f DB 0fH, 00H, 00H, 00H, '-', 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@bf00000000000000
CONST	SEGMENT
__real@bf00000000000000 DQ 0bf00000000000000r	; -3.05176e-05
CONST	ENDS
;	COMDAT __real@bef0000000000000
CONST	SEGMENT
__real@bef0000000000000 DQ 0bef0000000000000r	; -1.52588e-05
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ICICKJJH@CONFIRM_RESTART?$AA@
CONST	SEGMENT
??_C@_0BA@ICICKJJH@CONFIRM_RESTART?$AA@ DB 'CONFIRM_RESTART', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OMDAGJAA@UPGRADE_OK_REBOOT_REQUIRED?$AA@
CONST	SEGMENT
??_C@_0BL@OMDAGJAA@UPGRADE_OK_REBOOT_REQUIRED?$AA@ DB 'UPGRADE_OK_REBOOT_'
	DB	'REQUIRED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JALPBIFE@AFTER_INSTALL_TUTORIAL?$AA@
CONST	SEGMENT
??_C@_0BH@JALPBIFE@AFTER_INSTALL_TUTORIAL?$AA@ DB 'AFTER_INSTALL_TUTORIAL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@
CONST	SEGMENT
??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@ DB 'http://www'
	DB	'.gostcrypt.org/redirect.php?a=2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PEPDOHPE@AFTER_UPGRADE_RELEASE_NOTES?$AA@
CONST	SEGMENT
??_C@_0BM@PEPDOHPE@AFTER_UPGRADE_RELEASE_NOTES?$AA@ DB 'AFTER_UPGRADE_REL'
	DB	'EASE_NOTES', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open?$AA@
CONST	SEGMENT
??_C@_04PMOCAHAA@open?$AA@ DB 'open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@
CONST	SEGMENT
??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@ DB 'CONFIRM_EXIT_UNIVERSAL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GODHAKFG@EXTRACTION_FAILED?$AA@
CONST	SEGMENT
??_C@_0BC@GODHAKFG@EXTRACTION_FAILED?$AA@ DB 'EXTRACTION_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LLBBBPBJ@EXTRACTION_FINISHED_INFO?$AA@
CONST	SEGMENT
??_C@_0BJ@LLBBBPBJ@EXTRACTION_FINISHED_INFO?$AA@ DB 'EXTRACTION_FINISHED_'
	DB	'INFO', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIAHAGHC@IDCLOSE?$AA@
CONST	SEGMENT
??_C@_07CIAHAGHC@IDCLOSE?$AA@ DB 'IDCLOSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@
CONST	SEGMENT
??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@ DB 'INSTALL_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MFKGCNCO@FINALIZE?$AA@
CONST	SEGMENT
??_C@_08MFKGCNCO@FINALIZE?$AA@ DB 'FINALIZE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NKLIMG@TRAVELER_UAC_NOTE?$AA@
CONST	SEGMENT
??_C@_0BC@NKLIMG@TRAVELER_UAC_NOTE?$AA@ DB 'TRAVELER_UAC_NOTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HICKIHM@TRAVELER_LIMITATIONS_NOTE?$AA@
CONST	SEGMENT
??_C@_0BK@HICKIHM@TRAVELER_LIMITATIONS_NOTE?$AA@ DB 'TRAVELER_LIMITATIONS'
	DB	'_NOTE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BBG@NBLOJHJE@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAs?$AA?5?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?5?$AAR?$AAo?$AAl?$AAl?$AAu?$AAp@
CONST	SEGMENT
??_C@_1BBG@NBLOJHJE@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAs?$AA?5?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?5?$AAR?$AAo?$AAl?$AAl?$AAu?$AAp@ DB 'G'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'i', 00H, 'r', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'U', 00H
	DB	'p', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'R'
	DB	00H, 'o', 00H, 'l', 00H, 'l', 00H, 'u', 00H, 'p', 00H, ' ', 00H
	DB	'1', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 's', 00H
	DB	' ', 00H, '2', 00H, '0', 00H, '0', 00H, '0', 00H, ' ', 00H, 'S'
	DB	00H, 'P', 00H, '4', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'b', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '.', 00H
	DB	0aH, 00H, 0aH, 00H, 'F', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'm'
	DB	00H, 'o', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, ',', 00H, ' ', 00H, 's', 00H, 'e', 00H
	DB	'e', 00H, ' ', 00H, 'h', 00H, 't', 00H, 't', 00H, 'p', 00H, ':'
	DB	00H, '/', 00H, '/', 00H, 's', 00H, 'u', 00H, 'p', 00H, 'p', 00H
	DB	'o', 00H, 'r', 00H, 't', 00H, '.', 00H, 'm', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	'.', 00H, 'c', 00H, 'o', 00H, 'm', 00H, '/', 00H, 'k', 00H, 'b'
	DB	00H, '/', 00H, '8', 00H, '9', 00H, '1', 00H, '8', 00H, '6', 00H
	DB	'1', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BHNBHIPG@SOFTWARE?2Microsoft?2Updates?2Windo@
CONST	SEGMENT
??_C@_0DM@BHNBHIPG@SOFTWARE?2Microsoft?2Updates?2Windo@ DB 'SOFTWARE\Micr'
	DB	'osoft\Updates\Windows 2000\SP5\Update Rollup 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DIO@DJBHAIAH@?$AAW?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAP?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAn?$AAo?$AAt?$AAe?$AA?5?$AAt?$AAh?$AAa?$AAt?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AAm@
CONST	SEGMENT
??_C@_1DIO@DJBHAIAH@?$AAW?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAP?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAn?$AAo?$AAt?$AAe?$AA?5?$AAt?$AAh?$AAa?$AAt?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AAm@ DB 'W'
	DB	00H, 'a', 00H, 'r', 00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	':', 00H, ' ', 00H, 'P', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's'
	DB	00H, 'e', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'a', 00H, 't', 00H, ' ', 00H, 't'
	DB	00H, 'h', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'm', 00H, 'a', 00H
	DB	'y', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h'
	DB	00H, 'e', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'G', 00H
	DB	'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p'
	DB	00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'a', 00H, 't', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'p', 00H, 'p', 00H, 'o', 00H, 'r'
	DB	00H, 't', 00H, 's', 00H, ' ', 00H, 'W', 00H, 'i', 00H, 'n', 00H
	DB	'd', 00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, '2', 00H, '0'
	DB	00H, '0', 00H, '0', 00H, '.', 00H, ' ', 00H, 'I', 00H, 'f', 00H
	DB	' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H, ' ', 00H, 'w', 00H, 'a'
	DB	00H, 'n', 00H, 't', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'b', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'u', 00H, 'p', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, 'f', 00H, 'u', 00H, 't', 00H, 'u', 00H
	DB	'r', 00H, 'e', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 's', 00H, ' ', 00H, 'o', 00H
	DB	'f', 00H, ' ', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H, 'C'
	DB	00H, 'r', 00H, 'y', 00H, 'p', 00H, 't', 00H, ' ', 00H, '(', 00H
	DB	'w', 00H, 'h', 00H, 'i', 00H, 'c', 00H, 'h', 00H, ' ', 00H, 'i'
	DB	00H, 's', 00H, ' ', 00H, 'h', 00H, 'i', 00H, 'g', 00H, 'h', 00H
	DB	'l', 00H, 'y', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 'o'
	DB	00H, 'm', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'd', 00H, ')', 00H, ',', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u'
	DB	00H, ' ', 00H, 'w', 00H, 'i', 00H, 'l', 00H, 'l', 00H, ' ', 00H
	DB	'n', 00H, 'e', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, 'u', 00H, 'p', 00H, 'g', 00H, 'r', 00H, 'a', 00H
	DB	'd', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 's', 00H
	DB	' ', 00H, 'X', 00H, 'P', 00H, ' ', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, 'a', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 's'
	DB	00H, '.', 00H, 0aH, 00H, 0aH, 00H, 'N', 00H, 'o', 00H, 't', 00H
	DB	'e', 00H, ':', 00H, ' ', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'o', 00H, 'p', 00H, 'p', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, 'i', 00H, 's', 00H, 's', 00H, 'u', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'c', 00H, 'u'
	DB	00H, 'r', 00H, 'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, 'u', 00H
	DB	'p', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, 's', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, '2'
	DB	00H, '0', 00H, '0', 00H, '0', 00H, ' ', 00H, 't', 00H, 'o', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'g', 00H, 'e'
	DB	00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'p', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 'c', 00H, ' '
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, '7', 00H, '/', 00H, '1', 00H
	DB	'3', 00H, '/', 00H, '2', 00H, '0', 00H, '1', 00H, '0', 00H, ' '
	DB	00H, '(', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'l', 00H
	DB	'a', 00H, 's', 00H, 't', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n'
	DB	00H, '-', 00H, 's', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, 'u', 00H, 'p', 00H, 'd'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 's', 00H, ' ', 00H, '2', 00H, '0', 00H, '0', 00H
	DB	'0', 00H, ' ', 00H, 'w', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'i'
	DB	00H, 's', 00H, 's', 00H, 'u', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, 'g', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, ' ', 00H, 'p', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i'
	DB	00H, 'c', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, '2', 00H
	DB	'0', 00H, '0', 00H, '5', 00H, ')', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GJBFCKEH@GostCrypt?5Setup?51?43?41?$AA@
CONST	SEGMENT
??_C@_0BG@GJBFCKEH@GostCrypt?5Setup?51?43?41?$AA@ DB 'GostCrypt Setup 1.3'
	DB	'.1', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@
CONST	SEGMENT
??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@ DB 'GST_INSTALLER_IS_RUN'
	DB	'NING', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KPOBPAGF@http?3?1?1www?4gostcrypt?4org?1redirec@
CONST	SEGMENT
??_C@_0CK@KPOBPAGF@http?3?1?1www?4gostcrypt?4org?1redirec@ DB 'http://www'
	DB	'.gostcrypt.org/redirect.php?a=7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KNCOJMJF@?$CGref?$DN?$CFd?$AA@
CONST	SEGMENT
??_C@_07KNCOJMJF@?$CGref?$DN?$CFd?$AA@ DB '&ref=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DJBAGGGN@SELECT_DEST_DIR?$AA@
CONST	SEGMENT
??_C@_0BA@DJBAGGGN@SELECT_DEST_DIR?$AA@ DB 'SELECT_DEST_DIR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@MBPOLHGL@?$AAT?$AAi?$AAm?$AAe?$AAs?$AA?5?$AAN?$AAe?$AAw?$AA?5?$AAR?$AAo?$AAm?$AAa?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@MBPOLHGL@?$AAT?$AAi?$AAm?$AAe?$AAs?$AA?5?$AAN?$AAe?$AAw?$AA?5?$AAR?$AAo?$AAm?$AAa?$AAn?$AA?$AA@ DB 'T'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'N', 00H
	DB	'e', 00H, 'w', 00H, ' ', 00H, 'R', 00H, 'o', 00H, 'm', 00H, 'a'
	DB	00H, 'n', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@BHNAKINK@?$AAI?$AAf?$AA?5?$AAy?$AAo?$AAu?$AA?5?$AAw?$AAa?$AAn?$AAt?$AA?5?$AAt?$AAo?$AA?5?$AAm?$AAa?$AAk?$AAe?$AA?5?$AAa?$AA?5?$AAd?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?0?$AA?5@
CONST	SEGMENT
??_C@_1GG@BHNAKINK@?$AAI?$AAf?$AA?5?$AAy?$AAo?$AAu?$AA?5?$AAw?$AAa?$AAn?$AAt?$AA?5?$AAt?$AAo?$AA?5?$AAm?$AAa?$AAk?$AAe?$AA?5?$AAa?$AA?5?$AAd?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?0?$AA?5@ DB 'I'
	DB	00H, 'f', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H, ' ', 00H
	DB	'w', 00H, 'a', 00H, 'n', 00H, 't', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, 'm', 00H, 'a', 00H, 'k', 00H, 'e', 00H, ' ', 00H
	DB	'a', 00H, ' ', 00H, 'd', 00H, 'o', 00H, 'n', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, ',', 00H, ' ', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'c', 00H, 't', 00H
	DB	' ', 00H, 'u', 00H, 's', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CKIDBLFB@SETUP_FINISHED_INFO_DON?$AA@
CONST	SEGMENT
??_C@_0BI@CKIDBLFB@SETUP_FINISHED_INFO_DON?$AA@ DB 'SETUP_FINISHED_INFO_D'
	DB	'ON', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KIEFKBPA@SETUP_FINISHED_TITLE_DON?$AA@
CONST	SEGMENT
??_C@_0BJ@KIEFKBPA@SETUP_FINISHED_TITLE_DON?$AA@ DB 'SETUP_FINISHED_TITLE'
	DB	'_DON', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HFOJNJFM@SETUP_FINISHED_UPGRADE_TITLE_DON@
CONST	SEGMENT
??_C@_0CB@HFOJNJFM@SETUP_FINISHED_UPGRADE_TITLE_DON@ DB 'SETUP_FINISHED_U'
	DB	'PGRADE_TITLE_DON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CCIEODIN@EXTRACTION_FINISHED_TITLE_DON?$AA@
CONST	SEGMENT
??_C@_0BO@CCIEODIN@EXTRACTION_FINISHED_TITLE_DON?$AA@ DB 'EXTRACTION_FINI'
	DB	'SHED_TITLE_DON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FMNDIKAG@INSTALL_IN_PROGRESS?$AA@
CONST	SEGMENT
??_C@_0BE@FMNDIKAG@INSTALL_IN_PROGRESS?$AA@ DB 'INSTALL_IN_PROGRESS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JGHDAHN@SETUP_PROGRESS_INFO?$AA@
CONST	SEGMENT
??_C@_0BE@JGHDAHN@SETUP_PROGRESS_INFO?$AA@ DB 'SETUP_PROGRESS_INFO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FGINDNOJ@SETUP_PROGRESS_TITLE?$AA@
CONST	SEGMENT
??_C@_0BF@FGINDNOJ@SETUP_PROGRESS_TITLE?$AA@ DB 'SETUP_PROGRESS_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PJFGKPND@INSTALL?$AA@
CONST	SEGMENT
??_C@_07PJFGKPND@INSTALL?$AA@ DB 'INSTALL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@
CONST	SEGMENT
??_C@_0L@CANDMBMO@?2GostCrypt?$AA@ DB '\GostCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GJOJHDCA@SETUP_UPGRADE_DESTINATION?$AA@
CONST	SEGMENT
??_C@_0BK@GJOJHDCA@SETUP_UPGRADE_DESTINATION?$AA@ DB 'SETUP_UPGRADE_DESTI'
	DB	'NATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BMMFNCA@SETUP_OPTIONS_INFO?$AA@
CONST	SEGMENT
??_C@_0BD@BMMFNCA@SETUP_OPTIONS_INFO?$AA@ DB 'SETUP_OPTIONS_INFO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EDFPLLMN@SETUP_OPTIONS_TITLE?$AA@
CONST	SEGMENT
??_C@_0BE@EDFPLLMN@SETUP_OPTIONS_TITLE?$AA@ DB 'SETUP_OPTIONS_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PEMNLIII@EXTRACTION_IN_PROGRESS?$AA@
CONST	SEGMENT
??_C@_0BH@PEMNLIII@EXTRACTION_IN_PROGRESS?$AA@ DB 'EXTRACTION_IN_PROGRESS'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LJFMAAFG@EXTRACTION_PROGRESS_INFO?$AA@
CONST	SEGMENT
??_C@_0BJ@LJFMAAFG@EXTRACTION_PROGRESS_INFO?$AA@ DB 'EXTRACTION_PROGRESS_'
	DB	'INFO', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@
CONST	SEGMENT
??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@ DB 'EXTRACTING_VERB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBPFAJBE@EXTRACT?$AA@
CONST	SEGMENT
??_C@_07LBPFAJBE@EXTRACT?$AA@ DB 'EXTRACT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HFEALDNI@AUTO_FOLDER_CREATION?$AA@
CONST	SEGMENT
??_C@_0BF@HFEALDNI@AUTO_FOLDER_CREATION?$AA@ DB 'AUTO_FOLDER_CREATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OKGEFEFK@EXTRACTION_OPTIONS_INFO?$AA@
CONST	SEGMENT
??_C@_0BI@OKGEFEFK@EXTRACTION_OPTIONS_INFO?$AA@ DB 'EXTRACTION_OPTIONS_IN'
	DB	'FO', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PDGEILOG@EXTRACTION_OPTIONS_TITLE?$AA@
CONST	SEGMENT
??_C@_0BJ@PDGEILOG@EXTRACTION_OPTIONS_TITLE?$AA@ DB 'EXTRACTION_OPTIONS_T'
	DB	'ITLE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EDNBEOCA@GostCrypt?2?$AA@
CONST	SEGMENT
??_C@_0L@EDNBEOCA@GostCrypt?2?$AA@ DB 'GostCrypt\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ECIBEEIH@SETUP_MODE_HELP_INSTALL?$AA@
CONST	SEGMENT
??_C@_0BI@ECIBEEIH@SETUP_MODE_HELP_INSTALL?$AA@ DB 'SETUP_MODE_HELP_INSTA'
	DB	'LL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JGKCNIKM@SETUP_MODE_HELP_UPGRADE?$AA@
CONST	SEGMENT
??_C@_0BI@JGKCNIKM@SETUP_MODE_HELP_UPGRADE?$AA@ DB 'SETUP_MODE_HELP_UPGRA'
	DB	'DE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KCCOCEA@SETUP_MODE_HELP_EXTRACT?$AA@
CONST	SEGMENT
??_C@_0BI@KCCOCEA@SETUP_MODE_HELP_EXTRACT?$AA@ DB 'SETUP_MODE_HELP_EXTRAC'
	DB	'T', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PHBLGFGD@SETUP_MODE_INFO?$AA@
CONST	SEGMENT
??_C@_0BA@PHBLGFGD@SETUP_MODE_INFO?$AA@ DB 'SETUP_MODE_INFO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KMHMHMNP@SETUP_MODE_TITLE?$AA@
CONST	SEGMENT
??_C@_0BB@KMHMHMNP@SETUP_MODE_TITLE?$AA@ DB 'SETUP_MODE_TITLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNHFDDPI@UPGRADE?$AA@
CONST	SEGMENT
??_C@_07CNHFDDPI@UPGRADE?$AA@ DB 'UPGRADE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@
CONST	SEGMENT
??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@ DB 'REPAIR_REINSTALL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHILMIHF@CANCEL?$AA@
CONST	SEGMENT
??_C@_06JHILMIHF@CANCEL?$AA@ DB 'CANCEL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKHKLFPJ@PREV?$AA@
CONST	SEGMENT
??_C@_04PKHKLFPJ@PREV?$AA@ DB 'PREV', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MOKMKBJN@NEXT?$AA@
CONST	SEGMENT
??_C@_04MOKMKBJN@NEXT?$AA@ DB 'NEXT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@FKGEFKMH@?$AAI?$AA?5?$AA?$CG?$AAa?$AAc?$AAc?$AAe?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@FKGEFKMH@?$AAI?$AA?5?$AA?$CG?$AAa?$AAc?$AAc?$AAe?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAs?$AA?$AA@ DB 'I'
	DB	00H, ' ', 00H, '&', 00H, 'a', 00H, 'c', 00H, 'c', 00H, 'e', 00H
	DB	'p', 00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, 'l', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 's', 00H
	DB	'e', 00H, ' ', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'm', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BIA@MJJKLEKE@?$AAI?$AAM?$AAP?$AAO?$AAR?$AAT?$AAA?$AAN?$AAT?$AA?3?$AA?5?$AAB?$AAy?$AA?5?$AAc?$AAh?$AAe?$AAc?$AAk?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAc?$AAh?$AAe?$AAc?$AAk@
CONST	SEGMENT
??_C@_1BIA@MJJKLEKE@?$AAI?$AAM?$AAP?$AAO?$AAR?$AAT?$AAA?$AAN?$AAT?$AA?3?$AA?5?$AAB?$AAy?$AA?5?$AAc?$AAh?$AAe?$AAc?$AAk?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAc?$AAh?$AAe?$AAc?$AAk@ DB 'I'
	DB	00H, 'M', 00H, 'P', 00H, 'O', 00H, 'R', 00H, 'T', 00H, 'A', 00H
	DB	'N', 00H, 'T', 00H, ':', 00H, ' ', 00H, 'B', 00H, 'y', 00H, ' '
	DB	00H, 'c', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, 'c', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'b', 00H
	DB	'o', 00H, 'x', 00H, ' ', 00H, 'b', 00H, 'e', 00H, 'l', 00H, 'o'
	DB	00H, 'w', 00H, ',', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H
	DB	' ', 00H, 'a', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't'
	DB	00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, 's', 00H, 'e', 00H
	DB	' ', 00H, 'l', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 's'
	DB	00H, 'e', 00H, ' ', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'm', 00H
	DB	's', 00H, ' ', 00H, 'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 's'
	DB	00H, 'i', 00H, 'g', 00H, 'n', 00H, 'i', 00H, 'f', 00H, 'y', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'y'
	DB	00H, 'o', 00H, 'u', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'd', 00H
	DB	'e', 00H, 'r', 00H, 's', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd'
	DB	00H, ' ', 00H, 'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'a', 00H
	DB	'g', 00H, 'r', 00H, 'e', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'm', 00H, '.', 00H
	DB	' ', 00H, 'P', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e'
	DB	00H, ' ', 00H, 'c', 00H, 'l', 00H, 'i', 00H, 'c', 00H, 'k', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, '''', 00H, 'a'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'w', 00H, ' ', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 'n', 00H, '''', 00H, ' ', 00H, 'i', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	'o', 00H, 'f', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, 'l', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 's', 00H
	DB	'e', 00H, '.', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1KO@PHMNFEJ@?$AAY?$AAo?$AAu?$AA?5?$AAm?$AAu?$AAs?$AAt?$AA?5?$AAa?$AAc?$AAc?$AAe?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAe?$AAs?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe@
CONST	SEGMENT
??_C@_1KO@PHMNFEJ@?$AAY?$AAo?$AAu?$AA?5?$AAm?$AAu?$AAs?$AAt?$AA?5?$AAa?$AAc?$AAc?$AAe?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAe?$AAs?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe@ DB 'Y'
	DB	00H, 'o', 00H, 'u', 00H, ' ', 00H, 'm', 00H, 'u', 00H, 's', 00H
	DB	't', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, 's', 00H
	DB	'e', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'n'
	DB	00H, 's', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'm', 00H, 's', 00H, ' ', 00H, 'b', 00H, 'e', 00H, 'f', 00H, 'o'
	DB	00H, 'r', 00H, 'e', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H
	DB	' ', 00H, 'c', 00H, 'a', 00H, 'n', 00H, ' ', 00H, 'u', 00H, 's'
	DB	00H, 'e', 00H, ',', 00H, ' ', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 'c', 00H, 't', 00H, ',', 00H, ' ', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'G', 00H, 'o', 00H, 's'
	DB	00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H, 't', 00H
	DB	'.', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@EGEEIDAI@?$AAP?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@EGEEIDAI@?$AAP?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAs?$AA?$AA@ DB 'P'
	DB	00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'h'
	DB	00H, 'e', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'n', 00H, 's', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 'm', 00H, 's', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MFJOAEDC@CANNOT_DISPLAY_LICENSE?$AA@
CONST	SEGMENT
??_C@_0BH@MFJOAEDC@CANNOT_DISPLAY_LICENSE?$AA@ DB 'CANNOT_DISPLAY_LICENSE'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EOKBACHI@SETUP_WIZARD_PAGE_?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@EOKBACHI@SETUP_WIZARD_PAGE_?$CFd?$AA@ DB 'SETUP_WIZARD_PAGE_%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGHONKG@IDD_INSTL_DLG?$AA@
CONST	SEGMENT
??_C@_0O@MGHONKG@IDD_INSTL_DLG?$AA@ DB 'IDD_INSTL_DLG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2439 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2440 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00012	75 04		 jne	 SHORT $LN9@operator
  00014	33 c0		 xor	 eax, eax
  00016	eb 11		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00018	8b c2		 mov	 eax, edx
  0001a	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0001d	0f 1f 00	 npad	 3
$LL139@operator:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL139@operator
  00027	2b c6		 sub	 eax, esi
$LN10@operator:
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002c	50		 push	 eax
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00033	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00036	8b ce		 mov	 ecx, esi
  00038	50		 push	 eax
  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00040	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00047	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi

; 2441 : 	}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\wizard.c
;	COMDAT ?GetDonVal@@YAHHH@Z
_TEXT	SEGMENT
_minVal$ = 8						; size = 4
_maxVal$ = 12						; size = 4
?GetDonVal@@YAHHH@Z PROC				; GetDonVal, COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 215  : 	static BOOL prngInitialized = FALSE;
; 216  : 	static unsigned __int8 buffer [2];
; 217  : 
; 218  : 	if (!prngInitialized)

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?prngInitialized@?1??GetDonVal@@YAHHH@Z@4HA, 0
  0000a	75 5f		 jne	 SHORT $LN2@GetDonVal

; 219  : 	{
; 220  : 		if (!CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL, 0)
; 221  : 			&& !CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))

  0000c	6a 00		 push	 0
  0000e	6a 01		 push	 1
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	68 00 00 00 00	 push	 OFFSET ?hCryptProv@@3KA
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptAcquireContextA@20
  0001f	85 c0		 test	 eax, eax
  00021	75 1f		 jne	 SHORT $LN3@GetDonVal
  00023	6a 08		 push	 8
  00025	6a 01		 push	 1
  00027	50		 push	 eax
  00028	50		 push	 eax
  00029	68 00 00 00 00	 push	 OFFSET ?hCryptProv@@3KA
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptAcquireContextA@20

; 222  : 			OsPrngAvailable = FALSE;

  00034	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?OsPrngAvailable@@3HA, 0
  0003e	85 c0		 test	 eax, eax
  00040	74 0a		 je	 SHORT $LN4@GetDonVal
$LN3@GetDonVal:

; 223  : 		else
; 224  : 			OsPrngAvailable = TRUE;

  00042	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?OsPrngAvailable@@3HA, 1
$LN4@GetDonVal:

; 225  : 
; 226  : 		srand ((unsigned int) time (NULL));

  0004c	6a 00		 push	 0
  0004e	e8 00 00 00 00	 call	 __time64
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _srand
  00059	83 c4 08	 add	 esp, 8

; 227  : 		rand(); // Generate and discard the inital value, as it always appears to be somewhat non-random.

  0005c	e8 00 00 00 00	 call	 _rand

; 228  : 
; 229  : 		prngInitialized = TRUE;

  00061	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?prngInitialized@?1??GetDonVal@@YAHHH@Z@4HA, 1
$LN2@GetDonVal:

; 230  : 	}
; 231  : 
; 232  : 	if (OsPrngAvailable && CryptGenRandom (hCryptProv, sizeof (buffer), buffer) != 0) 

  0006b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?OsPrngAvailable@@3HA, 0
  00072	74 4b		 je	 SHORT $LN5@GetDonVal
  00074	68 00 00 00 00	 push	 OFFSET ?buffer@?1??GetDonVal@@YAHHH@Z@4PAEA
  00079	6a 02		 push	 2
  0007b	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCryptProv@@3KA
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGenRandom@12
  00087	85 c0		 test	 eax, eax
  00089	74 34		 je	 SHORT $LN5@GetDonVal

; 233  : 	{
; 234  : 		return  ((int) ((double) *((uint16 *) buffer) / (0xFFFF+1) * (maxVal + 1 - minVal)) + minVal);

  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR _maxVal$[ebp]
  0008e	8b 45 08	 mov	 eax, DWORD PTR _minVal$[ebp]
  00091	2b c8		 sub	 ecx, eax
  00093	41		 inc	 ecx
  00094	66 0f 6e c9	 movd	 xmm1, ecx
  00098	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?buffer@?1??GetDonVal@@YAHHH@Z@4PAEA
  0009f	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  000a3	66 0f 6e c1	 movd	 xmm0, ecx
  000a7	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000ab	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@bef0000000000000

; 235  : 	}
; 236  : 	else
; 237  : 		return  ((int) ((double) rand() / (RAND_MAX+1) * (maxVal + 1 - minVal)) + minVal);

  000b3	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000b7	f2 0f 2c c9	 cvttsd2si ecx, xmm1
  000bb	2b c1		 sub	 eax, ecx

; 238  : }

  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
$LN5@GetDonVal:

; 235  : 	}
; 236  : 	else
; 237  : 		return  ((int) ((double) rand() / (RAND_MAX+1) * (maxVal + 1 - minVal)) + minVal);

  000bf	e8 00 00 00 00	 call	 _rand
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR _maxVal$[ebp]
  000c7	66 0f 6e c8	 movd	 xmm1, eax
  000cb	8b 45 08	 mov	 eax, DWORD PTR _minVal$[ebp]
  000ce	2b c8		 sub	 ecx, eax
  000d0	41		 inc	 ecx
  000d1	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  000d5	66 0f 6e c1	 movd	 xmm0, ecx
  000d9	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@bf00000000000000
  000e1	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000e5	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000e9	f2 0f 2c c9	 cvttsd2si ecx, xmm1
  000ed	2b c1		 sub	 eax, ecx

; 238  : }

  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
?GetDonVal@@YAHHH@Z ENDP				; GetDonVal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\wizard.c
;	COMDAT ?LoadPage@@YAXPAUHWND__@@H@Z
_TEXT	SEGMENT
_rD$ = -36						; size = 16
_rW$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_nPageNo$ = 12						; size = 4
?LoadPage@@YAXPAUHWND__@@H@Z PROC			; LoadPage, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 136  : 	RECT rD, rW;
; 137  : 
; 138  : 	if (hCurPage != NULL)

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN4@LoadPage

; 139  : 	{
; 140  : 		DestroyWindow (hCurPage);

  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$LN4@LoadPage:

; 141  : 	}
; 142  : 
; 143  : 	InvalidateRect (GetDlgItem (MainDlg, IDC_MAIN_CONTENT_CANVAS), NULL, TRUE);

  00024	6a 01		 push	 1
  00026	6a 00		 push	 0
  00028	68 07 04 00 00	 push	 1031			; 00000407H
  0002d	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00039	50		 push	 eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 144  : 
; 145  : 	GetWindowRect (GetDlgItem (hwndDlg, IDC_POS_BOX), &rW);

  00040	8d 45 ec	 lea	 eax, DWORD PTR _rW$[ebp]
  00043	50		 push	 eax
  00044	68 05 04 00 00	 push	 1029			; 00000405H
  00049	57		 push	 edi
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00050	50		 push	 eax
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 146  : 
; 147  : 	nCurPageNo = nPageNo;

  00057	8b 45 0c	 mov	 eax, DWORD PTR _nPageNo$[ebp]
  0005a	a3 00 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, eax ; nCurPageNo

; 148  : 
; 149  : 	switch (nPageNo)

  0005f	83 f8 06	 cmp	 eax, 6
  00062	77 5e		 ja	 SHORT $LN2@LoadPage
  00064	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN16@LoadPage[eax*4]
$LN5@LoadPage:

; 150  : 	{
; 151  : 	case INTRO_PAGE:
; 152  : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INTRO_PAGE_DLG), hwndDlg,

  0006b	6a 00		 push	 0
  0006d	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00072	57		 push	 edi
  00073	6a 6c		 push	 108			; 0000006cH

; 153  : 					 (DLGPROC) PageDialogProc);
; 154  : 		break;

  00075	eb 3a		 jmp	 SHORT $LN14@LoadPage
$LN6@LoadPage:

; 155  : 
; 156  : 	case WIZARD_MODE_PAGE:
; 157  : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_WIZARD_MODE_PAGE_DLG), hwndDlg,

  00077	6a 00		 push	 0
  00079	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  0007e	57		 push	 edi
  0007f	6a 70		 push	 112			; 00000070H

; 158  : 					 (DLGPROC) PageDialogProc);
; 159  : 		break;

  00081	eb 2e		 jmp	 SHORT $LN14@LoadPage
$LN7@LoadPage:

; 160  : 
; 161  : 	case INSTALL_OPTIONS_PAGE:
; 162  : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_INSTALL_OPTIONS_PAGE_DLG), hwndDlg,

  00083	6a 00		 push	 0
  00085	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  0008a	57		 push	 edi
  0008b	6a 66		 push	 102			; 00000066H

; 163  : 					 (DLGPROC) PageDialogProc);
; 164  : 		break;

  0008d	eb 22		 jmp	 SHORT $LN14@LoadPage
$LN8@LoadPage:

; 165  : 
; 166  : 	case INSTALL_PROGRESS_PAGE:
; 167  : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_PROGRESS_PAGE_DLG), hwndDlg,

  0008f	6a 00		 push	 0
  00091	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00096	57		 push	 edi
  00097	6a 71		 push	 113			; 00000071H

; 168  : 					 (DLGPROC) PageDialogProc);
; 169  : 		break;

  00099	eb 16		 jmp	 SHORT $LN14@LoadPage
$LN9@LoadPage:

; 170  : 
; 171  : 	case EXTRACTION_OPTIONS_PAGE:
; 172  : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_EXTRACTION_OPTIONS_PAGE_DLG), hwndDlg,

  0009b	6a 00		 push	 0
  0009d	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  000a2	57		 push	 edi
  000a3	6a 6a		 push	 106			; 0000006aH

; 173  : 					 (DLGPROC) PageDialogProc);
; 174  : 		break;

  000a5	eb 0a		 jmp	 SHORT $LN14@LoadPage
$LN11@LoadPage:

; 175  : 
; 176  : 	case EXTRACTION_PROGRESS_PAGE:
; 177  : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_PROGRESS_PAGE_DLG), hwndDlg,
; 178  : 					 (DLGPROC) PageDialogProc);
; 179  : 		break;
; 180  : 
; 181  : 	case DONATIONS_PAGE:
; 182  : 		hCurPage = CreateDialogW (hInst, MAKEINTRESOURCEW (IDD_DONATIONS_PAGE_DLG), hwndDlg,

  000a7	6a 00		 push	 0
  000a9	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  000ae	57		 push	 edi
  000af	6a 72		 push	 114			; 00000072H
$LN14@LoadPage:
  000b1	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  000bd	a3 00 00 00 00	 mov	 DWORD PTR ?hCurPage@@3PAUHWND__@@A, eax ; hCurPage
$LN2@LoadPage:

; 183  : 					 (DLGPROC) PageDialogProc);
; 184  : 		break;
; 185  : 	}
; 186  : 
; 187  : 	rD.left = 15;
; 188  : 	rD.top = 45;
; 189  : 	rD.right = 0;
; 190  : 	rD.bottom = 0;
; 191  : 	MapDialogRect (hwndDlg, &rD);

  000c2	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000000000000000000002d0000000f
  000c9	8d 45 dc	 lea	 eax, DWORD PTR _rD$[ebp]
  000cc	50		 push	 eax
  000cd	57		 push	 edi
  000ce	0f 11 45 dc	 movups	 XMMWORD PTR _rD$[ebp], xmm0
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8

; 192  : 
; 193  : 	if (hCurPage != NULL)

  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  000de	5f		 pop	 edi
  000df	85 c9		 test	 ecx, ecx
  000e1	74 2b		 je	 SHORT $LN12@LoadPage

; 194  : 	{
; 195  : 		MoveWindow (hCurPage, rD.left, rD.top, rW.right - rW.left, rW.bottom - rW.top, TRUE);

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _rW$[ebp+12]
  000e6	2b 45 f0	 sub	 eax, DWORD PTR _rW$[ebp+4]
  000e9	6a 01		 push	 1
  000eb	50		 push	 eax
  000ec	8b 45 f4	 mov	 eax, DWORD PTR _rW$[ebp+8]
  000ef	2b 45 ec	 sub	 eax, DWORD PTR _rW$[ebp]
  000f2	50		 push	 eax
  000f3	ff 75 e0	 push	 DWORD PTR _rD$[ebp+4]
  000f6	ff 75 dc	 push	 DWORD PTR _rD$[ebp]
  000f9	51		 push	 ecx
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24

; 196  : 		ShowWindow (hCurPage, SW_SHOWNORMAL);

  00100	6a 01		 push	 1
  00102	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN12@LoadPage:

; 197  : 	}
; 198  : 
; 199  : 	/* Refresh the graphics (white background of some texts, etc.) */
; 200  : 	RefreshUIGFX ();

  0010e	e8 00 00 00 00	 call	 _RefreshUIGFX

; 201  : }

  00113	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00116	33 cd		 xor	 ecx, ebp
  00118	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
  00121	0f 1f 00	 npad	 3
$LN16@LoadPage:
  00124	00 00 00 00	 DD	 $LN5@LoadPage
  00128	00 00 00 00	 DD	 $LN6@LoadPage
  0012c	00 00 00 00	 DD	 $LN7@LoadPage
  00130	00 00 00 00	 DD	 $LN8@LoadPage
  00134	00 00 00 00	 DD	 $LN9@LoadPage
  00138	00 00 00 00	 DD	 $LN8@LoadPage
  0013c	00 00 00 00	 DD	 $LN11@LoadPage
?LoadPage@@YAXPAUHWND__@@H@Z ENDP			; LoadPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\wizard.c
;	COMDAT ?InitWizardDestInstallPath@@YAXXZ
_TEXT	SEGMENT
?InitWizardDestInstallPath@@YAXXZ PROC			; InitWizardDestInstallPath, COMDAT

; 115  : 	if (strlen (WizardDestInstallPath) < 2)

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  00005	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL9@InitWizard:
  00008	8a 01		 mov	 al, BYTE PTR [ecx]
  0000a	41		 inc	 ecx
  0000b	84 c0		 test	 al, al
  0000d	75 f9		 jne	 SHORT $LL9@InitWizard
  0000f	2b ca		 sub	 ecx, edx
  00011	83 f9 02	 cmp	 ecx, 2
  00014	73 5e		 jae	 SHORT $LN3@InitWizard

; 116  : 	{
; 117  : 		strcpy (WizardDestInstallPath, InstallationPath);

  00016	33 c9		 xor	 ecx, ecx
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@InitWizard:
  00020	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _InstallationPath[ecx]
  00026	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00029	88 81 ff ff ff
	ff		 mov	 BYTE PTR ?WizardDestInstallPath@@3PADA[ecx-1], al
  0002f	84 c0		 test	 al, al
  00031	75 ed		 jne	 SHORT $LL5@InitWizard

; 118  : 		if (WizardDestInstallPath [strlen (WizardDestInstallPath) - 1] != '\\')

  00033	b9 00 00 00 00	 mov	 ecx, OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  00038	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0003b	0f 1f 44 00 00	 npad	 5
$LL10@InitWizard:
  00040	8a 01		 mov	 al, BYTE PTR [ecx]
  00042	41		 inc	 ecx
  00043	84 c0		 test	 al, al
  00045	75 f9		 jne	 SHORT $LL10@InitWizard
  00047	2b ca		 sub	 ecx, edx
  00049	80 b9 ff ff ff
	ff 5c		 cmp	 BYTE PTR ?WizardDestInstallPath@@3PADA[ecx-1], 92 ; 0000005cH
  00050	74 22		 je	 SHORT $LN3@InitWizard

; 119  : 		{
; 120  : 			strcat (WizardDestInstallPath, "\\");

  00052	57		 push	 edi
  00053	bf 00 00 00 00	 mov	 edi, OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  00058	4f		 dec	 edi
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL11@InitWizard:
  00060	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00063	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00066	84 c0		 test	 al, al
  00068	75 f6		 jne	 SHORT $LL11@InitWizard
  0006a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  00070	66 89 07	 mov	 WORD PTR [edi], ax
  00073	5f		 pop	 edi
$LN3@InitWizard:

; 121  : 		}
; 122  : 	}
; 123  : }

  00074	c3		 ret	 0
?InitWizardDestInstallPath@@YAXXZ ENDP			; InitWizardDestInstallPath
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FDonText@@YAXXZ
text$yd	SEGMENT
??__FDonText@@YAXXZ PROC				; `dynamic atexit destructor for 'DonText'', COMDAT
  00000	83 3d 14 00 00
	00 08		 cmp	 DWORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+20, 8
  00007	72 29		 jb	 SHORT $LN9@dynamic
  00009	56		 push	 esi
  0000a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  00010	b9 00 00 00 00	 mov	 ecx, OFFSET ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; DonText
  00015	68 00 00 00 00	 push	 OFFSET ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; DonText
  0001a	e8 00 00 00 00	 call	 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
  0001f	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+20
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; DonText
  00029	40		 inc	 eax
  0002a	50		 push	 eax
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  00031	5e		 pop	 esi
$LN9@dynamic:
  00032	33 c0		 xor	 eax, eax
  00034	c7 05 14 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+20, 7
  0003e	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16, 0
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; DonText
  0004d	66 a3 00 00 00
	00		 mov	 WORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A, ax
  00053	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
??__FDonText@@YAXXZ ENDP				; `dynamic atexit destructor for 'DonText''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\wizard.c
;	COMDAT ??__EDonText@@YAXXZ
text$di	SEGMENT
??__EDonText@@YAXXZ PROC				; `dynamic initializer for 'DonText'', COMDAT

; 74   : wstring DonText = L"";

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; DonText
  00005	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
  0000a	33 c0		 xor	 eax, eax
  0000c	c7 05 14 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+20, 7
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; DonText
  00021	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16, 0
  0002b	66 a3 00 00 00
	00		 mov	 WORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A, ax
  00031	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00036	68 00 00 00 00	 push	 OFFSET ??__FDonText@@YAXXZ ; `dynamic atexit destructor for 'DonText''
  0003b	e8 00 00 00 00	 call	 _atexit
  00040	59		 pop	 ecx
  00041	c3		 ret	 0
??__EDonText@@YAXXZ ENDP				; `dynamic initializer for 'DonText''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 29		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00014	72 23		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0e		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00020	50		 push	 eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 _memcpy
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0002b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002e	8b ce		 mov	 ecx, esi
  00030	40		 inc	 eax
  00031	50		 push	 eax
  00032	53		 push	 ebx
  00033	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  00038	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00039	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7

; 2261 : 		_Eos(_Newsize);

  00040	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00044	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00047	72 0e		 jb	 SHORT $LN94@Tidy
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	33 c9		 xor	 ecx, ecx
  0004d	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 2262 : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN94@Tidy:
  00057	33 c0		 xor	 eax, eax
  00059	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 2262 : 		}

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2e		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 08	 cmp	 eax, 8
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1c		 jb	 SHORT $LN4@Inside
  0001d	83 f8 08	 cmp	 eax, 8
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  0002e	3b c2		 cmp	 eax, edx
  00030	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00032	b0 01		 mov	 al, 1
  00034	5e		 pop	 esi

; 2244 : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 2244 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0000d	77 5b		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000f	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  00012	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00014	ff 71 10	 push	 DWORD PTR [ecx+16]
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0001d	85 f6		 test	 esi, esi
  0001f	5e		 pop	 esi
  00020	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00027	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0002b	74 1f		 je	 SHORT $LN5@Grow
  0002d	83 fe 08	 cmp	 esi, 8
  00030	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  00032	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00035	3b f0		 cmp	 esi, eax
  00037	0f 42 c6	 cmovb	 eax, esi
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00042	85 f6		 test	 esi, esi
  00044	5e		 pop	 esi
  00045	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  0004c	85 f6		 test	 esi, esi
  0004e	75 12		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  00050	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00054	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00057	72 02		 jb	 SHORT $LN80@Grow
  00059	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 f6		 test	 esi, esi
  0005f	66 89 01	 mov	 WORD PTR [ecx], ax
$LN88@Grow:
  00062	0f 95 c0	 setne	 al
  00065	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  00074	cc		 int	 3
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0c		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	33 c9		 xor	 ecx, ecx
  00013	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 2220 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  0001b	33 c0		 xor	 eax, eax
  0001d	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 2220 : 		}

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 07	 or	 edi, 7

; 2184 : 		if (max_size() < _Newres)

  00038	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  0003e	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  00040	8b f8		 mov	 edi, eax
  00042	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00044	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00047	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0004c	f7 e7		 mul	 edi
  0004e	8b cb		 mov	 ecx, ebx
  00050	d1 e9		 shr	 ecx, 1
  00052	d1 ea		 shr	 edx, 1
  00054	3b ca		 cmp	 ecx, edx
  00056	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00058	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005d	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  00060	2b c1		 sub	 eax, ecx
  00062	3b d8		 cmp	 ebx, eax
  00064	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00066	bf fe ff ff 7f	 mov	 edi, 2147483646		; 7ffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  0006b	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00075	50		 push	 eax
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  0007d	8b d0		 mov	 edx, eax
  0007f	eb 29		 jmp	 SHORT $LN429@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00081	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  0008a	40		 inc	 eax
  0008b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0008e	50		 push	 eax
  0008f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00093	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  00098	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  0009b	b8 00 00 00 00	 mov	 eax, $LN426@Copy
  000a0	c3		 ret	 0
$LN426@Copy:
  000a1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000a4	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000a7	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN429@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000aa	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000ad	89 55 e8	 mov	 DWORD PTR __Ptr$1$[ebp], edx
  000b0	85 db		 test	 ebx, ebx
  000b2	74 1e		 je	 SHORT $LN260@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000b4	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b8	72 04		 jb	 SHORT $LN251@Copy
  000ba	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000bc	eb 02		 jmp	 SHORT $LN252@Copy
$LN251@Copy:
  000be	8b ce		 mov	 ecx, esi
$LN252@Copy:
  000c0	85 db		 test	 ebx, ebx
  000c2	74 0e		 je	 SHORT $LN260@Copy
  000c4	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  000c7	50		 push	 eax
  000c8	51		 push	 ecx
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _memcpy
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN260@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  000d2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000d5	83 f8 08	 cmp	 eax, 8
  000d8	72 0b		 jb	 SHORT $LN266@Copy
  000da	40		 inc	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	50		 push	 eax
  000de	ff 36		 push	 DWORD PTR [esi]
  000e0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN266@Copy:
  000e5	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  000ec	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000f0	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000f7	72 04		 jb	 SHORT $LN356@Copy
  000f9	8b 06		 mov	 eax, DWORD PTR [esi]
  000fb	eb 02		 jmp	 SHORT $LN357@Copy
$LN356@Copy:
  000fd	8b c6		 mov	 eax, esi
$LN357@Copy:
  000ff	33 c9		 xor	 ecx, ecx
  00101	66 89 08	 mov	 WORD PTR [eax], cx

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);

  00104	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00107	89 06		 mov	 DWORD PTR [esi], eax

; 2212 : 		this->_Myres() = _Newres;

  00109	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 2213 : 		_Eos(_Oldlen);

  0010c	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00110	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00113	72 02		 jb	 SHORT $LN420@Copy
  00115	8b f0		 mov	 esi, eax
$LN420@Copy:
  00117	33 c0		 xor	 eax, eax
  00119	66 89 04 5e	 mov	 WORD PTR [esi+ebx*2], ax

; 2214 : 		}

  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00120	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00127	59		 pop	 ecx
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00131	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00134	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00137	83 f8 08	 cmp	 eax, 8
  0013a	72 0b		 jb	 SHORT $LN144@Copy
  0013c	40		 inc	 eax
  0013d	8b ce		 mov	 ecx, esi
  0013f	50		 push	 eax
  00140	ff 36		 push	 DWORD PTR [esi]
  00142	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN144@Copy:
  00147	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0014e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00152	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00159	72 02		 jb	 SHORT $LN235@Copy
  0015b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN235@Copy:
  0015d	33 c0		 xor	 eax, eax

; 2203 : 			_RERAISE;

  0015f	50		 push	 eax
  00160	50		 push	 eax
  00161	66 89 06	 mov	 WORD PTR [esi], ax
  00164	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN430@Copy:
$LN428@Copy:
  00169	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length, COMDAT
; _this$ = ecx

; 1760 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1761 : 		}

  00003	c3		 ret	 0
?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	0f 82 88 00 00
	00		 jb	 $LN95@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00018	8b c7		 mov	 eax, edi
  0001a	2b c1		 sub	 eax, ecx
  0001c	3b c2		 cmp	 eax, edx
  0001e	77 27		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00027	72 10		 jb	 SHORT $LN41@erase
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	33 d2		 xor	 edx, edx
  0002d	5f		 pop	 edi
  0002e	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1357 : 			}
; 1358 : 		return (*this);

  00032	8b c6		 mov	 eax, esi
  00034	5e		 pop	 esi

; 1359 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00039	8b c6		 mov	 eax, esi
  0003b	33 d2		 xor	 edx, edx
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1359 : 		}

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  00047	85 d2		 test	 edx, edx
  00049	74 4a		 je	 SHORT $LN92@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  0004b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004f	72 04		 jb	 SHORT $LN58@erase
  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  00055	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  00057	2b fa		 sub	 edi, edx
  00059	53		 push	 ebx
  0005a	8d 1c 48	 lea	 ebx, DWORD PTR [eax+ecx*2]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  0005d	8b c7		 mov	 eax, edi
  0005f	2b c1		 sub	 eax, ecx
  00061	74 10		 je	 SHORT $LN74@erase
  00063	03 c0		 add	 eax, eax
  00065	50		 push	 eax
  00066	8d 04 53	 lea	 eax, DWORD PTR [ebx+edx*2]
  00069	50		 push	 eax
  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _memmove
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00073	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	5b		 pop	 ebx
  0007b	72 10		 jb	 SHORT $LN87@erase
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	33 c9		 xor	 ecx, ecx
  00081	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1357 : 			}
; 1358 : 		return (*this);

  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 1359 : 		}

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN87@erase:
  0008d	8b c6		 mov	 eax, esi
  0008f	33 c9		 xor	 ecx, ecx
  00091	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN92@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00095	5f		 pop	 edi
  00096	8b c6		 mov	 eax, esi
  00098	5e		 pop	 esi

; 1359 : 		}

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
$LN95@erase:

; 1348 : 		_Check_offset(_Off);

  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000a2	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN97@erase:
$LN94@erase:
  000a7	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 29		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00012	72 10		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	56		 push	 esi
  00017	33 f6		 xor	 esi, esi
  00019	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0001d	8b c1		 mov	 eax, ecx
  0001f	5e		 pop	 esi

; 1344 : 		}

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00024	8b d1		 mov	 edx, ecx
  00026	56		 push	 esi
  00027	33 f6		 xor	 esi, esi
  00029	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0002d	8b c1		 mov	 eax, ecx
  0002f	5e		 pop	 esi

; 1344 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00039	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  0003e	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN5@assign
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00018	5e		 pop	 esi

; 1183 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL7@assign:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL7@assign
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003c	5e		 pop	 esi

; 1183 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 48		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 08	 cmp	 ecx, 8
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 36		 jb	 SHORT $LN2@assign
  00020	83 f9 08	 cmp	 ecx, 8
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00031	3b c3		 cmp	 eax, ebx
  00033	76 21		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00035	83 f9 08	 cmp	 ecx, 8
  00038	72 04		 jb	 SHORT $LN57@assign
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN58@assign
$LN57@assign:
  0003e	8b c6		 mov	 eax, esi
$LN58@assign:
  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	2b d8		 sub	 ebx, eax
  00045	8b ce		 mov	 ecx, esi
  00047	d1 fb		 sar	 ebx, 1
  00049	53		 push	 ebx
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 1177 : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN2@assign:
  00056	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00057	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 88 00 00
	00		 ja	 $LN189@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 19		 jae	 SHORT $LN63@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	85 ff		 test	 edi, edi
  00078	74 6b		 je	 SHORT $LN183@assign
$LN188@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 2f		 jb	 SHORT $LN158@assign
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	eb 2d		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  00084	85 ff		 test	 edi, edi
  00086	75 f2		 jne	 SHORT $LN188@assign
  00088	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0008c	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0008f	72 10		 jb	 SHORT $LN140@assign
  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	33 c9		 xor	 ecx, ecx
  00095	5f		 pop	 edi
  00096	66 89 08	 mov	 WORD PTR [eax], cx

; 1175 : 			}
; 1176 : 		return (*this);

  00099	8b c6		 mov	 eax, esi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx

; 1177 : 		}

  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a1	8b c6		 mov	 eax, esi
  000a3	33 c9		 xor	 ecx, ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	66 89 08	 mov	 WORD PTR [eax], cx

; 1177 : 		}

  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000af	8b ce		 mov	 ecx, esi
$LN159@assign:
  000b1	85 ff		 test	 edi, edi
  000b3	74 0e		 je	 SHORT $LN165@assign
  000b5	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000b8	50		 push	 eax
  000b9	53		 push	 ebx
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c3	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c7	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ca	72 11		 jb	 SHORT $LN178@assign
  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
  000ce	33 c9		 xor	 ecx, ecx
  000d0	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1175 : 			}
; 1176 : 		return (*this);

  000d4	8b c6		 mov	 eax, esi
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 1177 : 		}

  000d9	5d		 pop	 ebp
  000da	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN178@assign:
  000dd	8b c6		 mov	 eax, esi
  000df	33 c9		 xor	 ecx, ecx
  000e1	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN183@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e5	5f		 pop	 edi
  000e6	8b c6		 mov	 eax, esi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 1177 : 		}

  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
$LN189@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN191@assign:
$LN186@assign:
  000f8	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e3 00 00
	00		 jb	 $LN210@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 33		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d3 00 00
	00		 jb	 $LN212@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0003a	72 04		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	eb 02		 jmp	 SHORT $LN64@assign
$LN63@assign:
  00040	8b d6		 mov	 edx, esi
$LN64@assign:
  00042	33 ff		 xor	 edi, edi
  00044	51		 push	 ecx
  00045	57		 push	 edi
  00046	8b ce		 mov	 ecx, esi
  00048	66 89 3c 42	 mov	 WORD PTR [edx+eax*2], di
  0004c	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
  00051	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00052	8b c6		 mov	 eax, esi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 1162 : 		}

  00056	5d		 pop	 ebp
  00057	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 aa 00 00
	00		 ja	 $LN213@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 24		 jae	 SHORT $LN72@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00079	85 ff		 test	 edi, edi
  0007b	74 76		 je	 SHORT $LN205@assign
$LN209@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0007d	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00081	72 02		 jb	 SHORT $LN166@assign
  00083	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00085	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00089	72 2f		 jb	 SHORT $LN180@assign
  0008b	8b 16		 mov	 edx, DWORD PTR [esi]
  0008d	eb 2d		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  0008f	85 ff		 test	 edi, edi
  00091	75 ea		 jne	 SHORT $LN209@assign
  00093	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00097	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0009a	72 10		 jb	 SHORT $LN149@assign
  0009c	8b 06		 mov	 eax, DWORD PTR [esi]
  0009e	33 c9		 xor	 ecx, ecx
  000a0	5f		 pop	 edi
  000a1	66 89 08	 mov	 WORD PTR [eax], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 1162 : 		}

  000a8	5d		 pop	 ebp
  000a9	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000ac	8b c6		 mov	 eax, esi
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	66 89 08	 mov	 WORD PTR [eax], cx

; 1162 : 		}

  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000ba	8b d6		 mov	 edx, esi
$LN181@assign:
  000bc	85 ff		 test	 edi, edi
  000be	74 11		 je	 SHORT $LN187@assign
  000c0	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000c3	50		 push	 eax
  000c4	8d 04 4b	 lea	 eax, DWORD PTR [ebx+ecx*2]
  000c7	50		 push	 eax
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _memcpy
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000d1	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d8	72 11		 jb	 SHORT $LN200@assign
  000da	8b 06		 mov	 eax, DWORD PTR [esi]
  000dc	33 c9		 xor	 ecx, ecx
  000de	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000e2	8b c6		 mov	 eax, esi
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1162 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN200@assign:
  000eb	8b c6		 mov	 eax, esi
  000ed	33 c9		 xor	 ecx, ecx
  000ef	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN205@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f3	5f		 pop	 edi
  000f4	8b c6		 mov	 eax, esi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx

; 1162 : 		}

  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
$LN210@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00101	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN214@assign:
$LN212@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0010b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN215@assign:
$LN213@assign:

; 1155 : 		else if (_Grow(_Count))

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00115	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN216@assign:
$LN207@assign:
  0011a	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 1039 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1040 : 		return (assign(_Ptr));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN7@operator
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00018	5e		 pop	 esi

; 1041 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1040 : 		return (assign(_Ptr));

$LN7@operator:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL9@operator:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL9@operator
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003c	5e		 pop	 esi

; 1041 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 08	 cmp	 eax, 8
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 09		 jb	 SHORT $LN96@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	5e		 pop	 esi
  0002d	66 89 08	 mov	 WORD PTR [eax], cx

; 1018 : 		}

  00030	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN96@basic_stri:
  00031	33 c0		 xor	 eax, eax
  00033	66 89 06	 mov	 WORD PTR [esi], ax
  00036	5e		 pop	 esi

; 1018 : 		}

  00037	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	66 39 02	 cmp	 WORD PTR [edx], ax
  0001f	75 12		 jne	 SHORT $LN113@basic_stri
  00021	33 c9		 xor	 ecx, ecx
  00023	51		 push	 ecx
  00024	52		 push	 edx
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN113@basic_stri:
  00033	8b ca		 mov	 ecx, edx
  00035	57		 push	 edi
  00036	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL115@basic_stri:
  00040	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00043	83 c1 02	 add	 ecx, 2
  00046	66 85 c0	 test	 ax, ax
  00049	75 f5		 jne	 SHORT $LL115@basic_stri
  0004b	2b cf		 sub	 ecx, edi
  0004d	d1 f9		 sar	 ecx, 1
  0004f	5f		 pop	 edi
  00050	51		 push	 ecx
  00051	52		 push	 edx
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN16@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN7@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN18@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN19@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN20@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN21@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  00059	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00013	77 3b		 ja	 SHORT $LN14@allocate
  00015	03 c0		 add	 eax, eax
  00017	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001c	72 23		 jb	 SHORT $LN6@allocate
  0001e	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00021	3b c8		 cmp	 ecx, eax
  00023	76 30		 jbe	 SHORT $LN16@allocate
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	8b c8		 mov	 ecx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c9		 test	 ecx, ecx
  00032	74 26		 je	 SHORT $LN17@allocate
  00034	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00037	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003a	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00047	83 c4 04	 add	 esp, 4
  0004a	85 c0		 test	 eax, eax
  0004c	75 bc		 jne	 SHORT $LN12@allocate
  0004e	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00050	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00055	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN13@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN5@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN15@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN16@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN17@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN18@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00059	cc		 int	 3
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 26		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 20		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	8b ce		 mov	 ecx, esi
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00035	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2261 : 		_Eos(_Newsize);

  0003d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00041	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00044	72 0c		 jb	 SHORT $LN92@Tidy
  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 2262 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN92@Tidy:
  00052	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 2262 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2d		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1b		 jb	 SHORT $LN4@Inside
  0001d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	03 c6		 add	 eax, esi
  0002d	3b c2		 cmp	 eax, edx
  0002f	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2244 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2244 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	77 59		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000c	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  0000f	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00011	ff 71 10	 push	 DWORD PTR [ecx+16]
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0001a	85 f6		 test	 esi, esi
  0001c	5e		 pop	 esi
  0001d	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00024	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  00028	74 1f		 je	 SHORT $LN5@Grow
  0002a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0002d	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  0002f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00032	3b f0		 cmp	 esi, eax
  00034	0f 42 c6	 cmovb	 eax, esi
  00037	50		 push	 eax
  00038	6a 01		 push	 1
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0003f	85 f6		 test	 esi, esi
  00041	5e		 pop	 esi
  00042	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  00049	85 f6		 test	 esi, esi
  0004b	75 10		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  0004d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00051	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00054	72 02		 jb	 SHORT $LN80@Grow
  00056	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  00058	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0005b	85 f6		 test	 esi, esi
$LN88@Grow:
  0005d	0f 95 c0	 setne	 al
  00060	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  0006f	cc		 int	 3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0a		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 2220 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0

; 2220 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 0f	 or	 edi, 15			; 0000000fH

; 2184 : 		if (max_size() < _Newres)

  00038	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f8		 mov	 edi, eax
  0003f	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00041	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e7		 mul	 edi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005a	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00063	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  00068	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00072	85 c0		 test	 eax, eax
  00074	75 04		 jne	 SHORT $LN136@Copy
  00076	33 db		 xor	 ebx, ebx
  00078	eb 6d		 jmp	 SHORT $LN19@Copy
$LN136@Copy:
  0007a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007f	72 29		 jb	 SHORT $LN138@Copy
  00081	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00084	3b c8		 cmp	 ecx, eax
  00086	77 05		 ja	 SHORT $LN140@Copy
  00088	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN435@Copy:
$LN140@Copy:
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00093	83 c4 04	 add	 esp, 4
  00096	85 c0		 test	 eax, eax
  00098	75 05		 jne	 SHORT $LN141@Copy
  0009a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN436@Copy:
$LN141@Copy:
  0009f	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000a2	83 e3 e0	 and	 ebx, -32		; ffffffe0H
  000a5	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  000a8	eb 3d		 jmp	 SHORT $LN19@Copy
$LN138@Copy:
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b0	8b d8		 mov	 ebx, eax
  000b2	83 c4 04	 add	 esp, 4
  000b5	85 db		 test	 ebx, ebx
  000b7	75 2e		 jne	 SHORT $LN19@Copy
  000b9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN437@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000be	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  000c7	40		 inc	 eax
  000c8	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000cb	50		 push	 eax
  000cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000d0	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000d5	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  000d8	b8 00 00 00 00	 mov	 eax, $LN432@Copy
  000dd	c3		 ret	 0
$LN432@Copy:
  000de	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000e1	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000e4	8b 5d e8	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000e7	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  000ea	85 c0		 test	 eax, eax
  000ec	74 1b		 je	 SHORT $LN270@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000ee	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000f2	72 04		 jb	 SHORT $LN261@Copy
  000f4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f6	eb 02		 jmp	 SHORT $LN262@Copy
$LN261@Copy:
  000f8	8b ce		 mov	 ecx, esi
$LN262@Copy:
  000fa	85 c0		 test	 eax, eax
  000fc	74 0b		 je	 SHORT $LN270@Copy
  000fe	50		 push	 eax
  000ff	51		 push	 ecx
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _memcpy
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN270@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  00109	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0010c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010f	72 0b		 jb	 SHORT $LN274@Copy
  00111	40		 inc	 eax
  00112	8b ce		 mov	 ecx, esi
  00114	50		 push	 eax
  00115	ff 36		 push	 DWORD PTR [esi]
  00117	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN274@Copy:
  0011c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00123	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00127	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0012e	72 04		 jb	 SHORT $LN362@Copy
  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	eb 02		 jmp	 SHORT $LN363@Copy
$LN362@Copy:
  00134	8b c6		 mov	 eax, esi
$LN363@Copy:
  00136	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);
; 2212 : 		this->_Myres() = _Newres;
; 2213 : 		_Eos(_Oldlen);

  00139	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  0013c	89 1e		 mov	 DWORD PTR [esi], ebx
  0013e	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00141	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00145	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00148	72 02		 jb	 SHORT $LN426@Copy
  0014a	8b f3		 mov	 esi, ebx
$LN426@Copy:
  0014c	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 2214 : 		}

  00150	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00153	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015a	59		 pop	 ecx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00164	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00167	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0016a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0016d	72 0b		 jb	 SHORT $LN156@Copy
  0016f	40		 inc	 eax
  00170	8b ce		 mov	 ecx, esi
  00172	50		 push	 eax
  00173	ff 36		 push	 DWORD PTR [esi]
  00175	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN156@Copy:
  0017a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00181	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00185	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0018c	72 02		 jb	 SHORT $LN245@Copy
  0018e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN245@Copy:

; 2203 : 			_RERAISE;

  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	c6 06 00	 mov	 BYTE PTR [esi], 0
  00197	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN438@Copy:
$LN434@Copy:
  0019c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	72 7e		 jb	 SHORT $LN93@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00014	8b c7		 mov	 eax, edi
  00016	2b c1		 sub	 eax, ecx
  00018	3b c2		 cmp	 eax, edx
  0001a	77 23		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  0001c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0001f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00023	72 0e		 jb	 SHORT $LN41@erase
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5f		 pop	 edi
  00028	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1357 : 			}
; 1358 : 		return (*this);

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 1359 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1359 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  0003f	85 d2		 test	 edx, edx
  00041	74 44		 je	 SHORT $LN90@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  00043	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00047	72 04		 jb	 SHORT $LN58@erase
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  0004d	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  0004f	2b fa		 sub	 edi, edx
  00051	53		 push	 ebx
  00052	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00055	8b c7		 mov	 eax, edi
  00057	2b c1		 sub	 eax, ecx
  00059	74 0e		 je	 SHORT $LN74@erase
  0005b	50		 push	 eax
  0005c	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0005f	50		 push	 eax
  00060	53		 push	 ebx
  00061	e8 00 00 00 00	 call	 _memmove
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00069	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00070	5b		 pop	 ebx
  00071	72 0e		 jb	 SHORT $LN85@erase
  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1357 : 			}
; 1358 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1359 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN85@erase:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN90@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi

; 1359 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN93@erase:

; 1348 : 		_Check_offset(_Off);

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00094	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN95@erase:
$LN92@erase:
  00099	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 21		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00012	72 0c		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 1344 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00020	8b d1		 mov	 edx, ecx
  00022	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  00026	8b c1		 mov	 eax, ecx

; 1344 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  00036	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@assign
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1183 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@assign:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@assign
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1183 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@assign
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN57@assign
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1177 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1168 : 			return (assign(*this,

$LN57@assign:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1177 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@assign:
  00065	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00066	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00069	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006c	77 7d		 ja	 SHORT $LN187@assign
  0006e	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00071	73 19		 jae	 SHORT $LN63@assign
  00073	ff 76 10	 push	 DWORD PTR [esi+16]
  00076	8b ce		 mov	 ecx, esi
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0007e	85 ff		 test	 edi, edi
  00080	74 60		 je	 SHORT $LN181@assign
$LN186@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  00082	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00086	72 2b		 jb	 SHORT $LN158@assign
  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	eb 29		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  0008c	85 ff		 test	 edi, edi
  0008e	75 f2		 jne	 SHORT $LN186@assign
  00090	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00094	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00097	72 0e		 jb	 SHORT $LN140@assign
  00099	8b 06		 mov	 eax, DWORD PTR [esi]
  0009b	5f		 pop	 edi
  0009c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1175 : 			}
; 1176 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 1177 : 		}

  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a7	8b c6		 mov	 eax, esi
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1177 : 		}

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000b3	8b c6		 mov	 eax, esi
$LN159@assign:
  000b5	85 ff		 test	 edi, edi
  000b7	74 0b		 je	 SHORT $LN165@assign
  000b9	57		 push	 edi
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000cb	72 0f		 jb	 SHORT $LN176@assign
  000cd	8b 06		 mov	 eax, DWORD PTR [esi]
  000cf	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1175 : 			}
; 1176 : 		return (*this);

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 1177 : 		}

  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN176@assign:
  000dc	8b c6		 mov	 eax, esi
  000de	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN181@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e2	5f		 pop	 edi
  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1177 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN187@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f0	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN189@assign:
$LN184@assign:
  000f5	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e9 00 00
	00		 jb	 $LN208@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 47		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d9 00 00
	00		 jb	 $LN210@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0003a	72 19		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	51		 push	 ecx
  0003f	6a 00		 push	 0
  00041	8b ce		 mov	 ecx, esi
  00043	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00047	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0004c	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 1162 : 		}

  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

$LN63@assign:
  00055	8b d6		 mov	 edx, esi
  00057	51		 push	 ecx
  00058	6a 00		 push	 0
  0005a	8b ce		 mov	 ecx, esi
  0005c	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00060	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00065	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00066	8b c6		 mov	 eax, esi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 1162 : 		}

  0006a	5d		 pop	 ebp
  0006b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0006e	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00071	0f 87 9f 00 00
	00		 ja	 $LN211@assign
  00077	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0007a	73 24		 jae	 SHORT $LN72@assign
  0007c	ff 76 10	 push	 DWORD PTR [esi+16]
  0007f	8b ce		 mov	 ecx, esi
  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0008a	85 ff		 test	 edi, edi
  0008c	74 6b		 je	 SHORT $LN203@assign
$LN207@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0008e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00092	72 02		 jb	 SHORT $LN166@assign
  00094	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00096	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0009a	72 2b		 jb	 SHORT $LN180@assign
  0009c	8b 16		 mov	 edx, DWORD PTR [esi]
  0009e	eb 29		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  000a0	85 ff		 test	 edi, edi
  000a2	75 ea		 jne	 SHORT $LN207@assign
  000a4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ab	72 0e		 jb	 SHORT $LN149@assign
  000ad	8b 06		 mov	 eax, DWORD PTR [esi]
  000af	5f		 pop	 edi
  000b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000b3	8b c6		 mov	 eax, esi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 1162 : 		}

  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000bb	8b c6		 mov	 eax, esi
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1162 : 		}

  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000c7	8b d6		 mov	 edx, esi
$LN181@assign:
  000c9	85 ff		 test	 edi, edi
  000cb	74 0e		 je	 SHORT $LN187@assign
  000cd	57		 push	 edi
  000ce	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000d1	50		 push	 eax
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000db	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000df	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000e2	72 0f		 jb	 SHORT $LN198@assign
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000ea	8b c6		 mov	 eax, esi
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx

; 1162 : 		}

  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN198@assign:
  000f3	8b c6		 mov	 eax, esi
  000f5	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN203@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f9	5f		 pop	 edi
  000fa	8b c6		 mov	 eax, esi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 1162 : 		}

  000fe	5d		 pop	 ebp
  000ff	c2 0c 00	 ret	 12			; 0000000cH
$LN208@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00107	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN212@assign:
$LN210@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00111	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN213@assign:
$LN211@assign:

; 1155 : 		else if (_Grow(_Count))

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN214@assign:
$LN205@assign:
  00120	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@append
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00015	5e		 pop	 esi

; 1108 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

$LN5@append:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@append:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@append
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00031	5e		 pop	 esi

; 1108 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1088 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1089 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@append
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN21@append
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN22@append
$LN21@append:
  0001a	8b c6		 mov	 eax, esi
$LN22@append:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@append
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN35@append
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN36@append
$LN35@append:
  00029	8b d6		 mov	 edx, esi
$LN36@append:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@append

; 1090 : 			return (append(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN58@append
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1102 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1090 : 			return (append(*this,

$LN58@append:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1102 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

  00065	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00068	8b c2		 mov	 eax, edx
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0006d	f7 d0		 not	 eax
  0006f	3b c1		 cmp	 eax, ecx
  00071	0f 86 98 00 00
	00		 jbe	 $LN217@append

; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

  00077	57		 push	 edi
  00078	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

  0007b	85 c9		 test	 ecx, ecx
  0007d	0f 84 83 00 00
	00		 je	 $LN211@append
  00083	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00086	0f 87 8d 00 00
	00		 ja	 $LN219@append
  0008c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0008f	73 1a		 jae	 SHORT $LN85@append
  00091	52		 push	 edx
  00092	57		 push	 edi
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0009d	85 ff		 test	 edi, edi
  0009f	74 65		 je	 SHORT $LN211@append
$LN216@append:

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

  000a1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a5	72 2b		 jb	 SHORT $LN179@append
  000a7	8b 16		 mov	 edx, DWORD PTR [esi]
  000a9	eb 29		 jmp	 SHORT $LN180@append

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN85@append:
  000ab	85 ff		 test	 edi, edi
  000ad	75 f2		 jne	 SHORT $LN216@append
  000af	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b6	72 0e		 jb	 SHORT $LN162@append
  000b8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ba	5f		 pop	 edi
  000bb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1100 : 			}
; 1101 : 		return (*this);

  000be	8b c6		 mov	 eax, esi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx

; 1102 : 		}

  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN162@append:
  000c6	8b c6		 mov	 eax, esi
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1102 : 		}

  000ce	5d		 pop	 ebp
  000cf	c2 08 00	 ret	 8

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

$LN179@append:
  000d2	8b d6		 mov	 edx, esi
$LN180@append:
  000d4	85 c9		 test	 ecx, ecx
  000d6	74 10		 je	 SHORT $LN195@append
  000d8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000db	51		 push	 ecx
  000dc	03 c2		 add	 eax, edx
  000de	53		 push	 ebx
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _memcpy
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN195@append:

; 1099 : 			_Eos(_Num);

  000e8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000ec	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ef	72 0f		 jb	 SHORT $LN206@append
  000f1	8b 06		 mov	 eax, DWORD PTR [esi]
  000f3	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1100 : 			}
; 1101 : 		return (*this);

  000f7	8b c6		 mov	 eax, esi
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx

; 1102 : 		}

  000fc	5d		 pop	 ebp
  000fd	c2 08 00	 ret	 8

; 1099 : 			_Eos(_Num);

$LN206@append:
  00100	8b c6		 mov	 eax, esi
  00102	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN211@append:

; 1100 : 			}
; 1101 : 		return (*this);

  00106	5f		 pop	 edi
  00107	8b c6		 mov	 eax, esi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx

; 1102 : 		}

  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
$LN217@append:

; 1093 : 			_Xlen();	// result too long

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00114	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN220@append:
$LN219@append:

; 1096 : 		if (0 < _Count && _Grow(_Num))

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN221@append:
$LN214@append:
  00123	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1071 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 c0 00 00
	00		 jb	 $LN201@append

; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

  00019	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	3b c8		 cmp	 ecx, eax
  00023	0f 47 c8	 cmova	 ecx, eax
  00026	8b c2		 mov	 eax, edx
  00028	f7 d0		 not	 eax
  0002a	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx
  0002d	3b c1		 cmp	 eax, ecx
  0002f	0f 86 ae 00 00
	00		 jbe	 $LN203@append

; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

  00035	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

  00038	85 c9		 test	 ecx, ecx
  0003a	0f 84 90 00 00
	00		 je	 $LN196@append
  00040	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00043	0f 87 a4 00 00
	00		 ja	 $LN204@append
  00049	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0004c	73 22		 jae	 SHORT $LN56@append
  0004e	52		 push	 edx
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00057	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005a	85 ff		 test	 edi, edi
  0005c	74 72		 je	 SHORT $LN196@append
$LN200@append:

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

  0005e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00062	72 02		 jb	 SHORT $LN150@append
  00064	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN150@append:
  00066	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006a	72 2b		 jb	 SHORT $LN164@append
  0006c	8b 16		 mov	 edx, DWORD PTR [esi]
  0006e	eb 29		 jmp	 SHORT $LN165@append

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN56@append:
  00070	85 ff		 test	 edi, edi
  00072	75 ea		 jne	 SHORT $LN200@append
  00074	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00077	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0007b	72 0e		 jb	 SHORT $LN133@append
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	5f		 pop	 edi
  00080	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1082 : 			}
; 1083 : 		return (*this);

  00083	8b c6		 mov	 eax, esi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 1084 : 		}

  00087	5d		 pop	 ebp
  00088	c2 0c 00	 ret	 12			; 0000000cH

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN133@append:
  0008b	8b c6		 mov	 eax, esi
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1084 : 		}

  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

$LN164@append:
  00097	8b d6		 mov	 edx, esi
$LN165@append:
  00099	85 c9		 test	 ecx, ecx
  0009b	74 15		 je	 SHORT $LN180@append
  0009d	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000a0	03 c3		 add	 eax, ebx
  000a2	51		 push	 ecx
  000a3	50		 push	 eax
  000a4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000a7	03 c2		 add	 eax, edx
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memcpy
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@append:

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b6	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b9	72 0f		 jb	 SHORT $LN191@append
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1082 : 			}
; 1083 : 		return (*this);

  000c1	8b c6		 mov	 eax, esi
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx

; 1084 : 		}

  000c6	5d		 pop	 ebp
  000c7	c2 0c 00	 ret	 12			; 0000000cH

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

$LN191@append:
  000ca	8b c6		 mov	 eax, esi
  000cc	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN196@append:

; 1082 : 			}
; 1083 : 		return (*this);

  000d0	5f		 pop	 edi
  000d1	8b c6		 mov	 eax, esi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx

; 1084 : 		}

  000d5	5d		 pop	 ebp
  000d6	c2 0c 00	 ret	 12			; 0000000cH
$LN201@append:

; 1071 : 		_Right._Check_offset(_Roff);

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000de	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN205@append:
$LN203@append:

; 1074 : 			_Xlen();	// result too long

  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000e8	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN206@append:
$LN204@append:

; 1077 : 		if (0 < _Count && _Grow(_Num))

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f2	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN207@append:
$LN198@append:
  000f7	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 07		 jb	 SHORT $LN94@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	5e		 pop	 esi
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1018 : 		}

  0002e	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN94@basic_stri:
  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	5e		 pop	 esi

; 1018 : 		}

  00033	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000e	73 15		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1b		 je	 SHORT $LN3@Assign_rv
  00018	50		 push	 eax
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00023	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00025	85 ff		 test	 edi, edi
  00027	74 04		 je	 SHORT $LN84@Assign_rv
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 07		 mov	 DWORD PTR [edi], eax
$LN84@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  00039	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003c	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  0003f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00046	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0004a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00051	72 0b		 jb	 SHORT $LN227@Assign_rv
  00053	8b 06		 mov	 eax, DWORD PTR [esi]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	c6 00 00	 mov	 BYTE PTR [eax], 0

; 973  : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN227@Assign_rv:
  0005e	5f		 pop	 edi
  0005f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00062	5e		 pop	 esi

; 973  : 		}

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 914  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0001d	75 12		 jne	 SHORT $LN111@basic_stri
  0001f	33 d2		 xor	 edx, edx
  00021	52		 push	 edx
  00022	51		 push	 ecx
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN111@basic_stri:
  00031	8b d1		 mov	 edx, ecx
  00033	57		 push	 edi
  00034	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL113@basic_stri:
  00037	8a 02		 mov	 al, BYTE PTR [edx]
  00039	42		 inc	 edx
  0003a	84 c0		 test	 al, al
  0003c	75 f9		 jne	 SHORT $LL113@basic_stri
  0003e	2b d7		 sub	 edx, edi
  00040	5f		 pop	 edi
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 1009 : 		}

  00003	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN7@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN16@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN18@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN19@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN20@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN7@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 988  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN18@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN19@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN20@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN15@deallocate:
  00049	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 976  : 		return (_Mybase::allocate(_Count));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN6@allocate
$LN15@allocate:

; 977  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN6@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN8@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN17@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN19@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 977  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN8@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN15@allocate
  00045	eb 0a		 jmp	 SHORT $LN20@allocate
$LN17@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN21@allocate:
$LN19@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN20@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@allocate:
$LN16@allocate:
  00056	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 870  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 750  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN6@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN14@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN16@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN12@allocate
  00045	eb 0a		 jmp	 SHORT $LN17@allocate
$LN14@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN18@allocate:
$LN16@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN17@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN13@allocate:
  00056	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN5@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN13@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN15@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN16@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN17@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN5@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 721  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN15@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN16@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN17@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN12@deallocate:
  00049	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 95   : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 133  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 67   : 			_Xbad_alloc();	// report no memory
; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00012	5d		 pop	 ebp

; 553  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 530  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00012	5d		 pop	 ebp

; 530  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 04		 jne	 SHORT $LN3@length
  0000b	33 c0		 xor	 eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

  0000f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL5@length:
  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	40		 inc	 eax
  00015	84 c9		 test	 cl, cl
  00017	75 f9		 jne	 SHORT $LL5@length
  00019	2b c2		 sub	 eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 344  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 345  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	66 89 08	 mov	 WORD PTR [eax], cx

; 346  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 332  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 333  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  00014	5d		 pop	 ebp

; 333  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 309  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 310  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  00014	5d		 pop	 ebp

; 310  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIPB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 302  : 		{	// find length of null-terminated sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 303  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0000a	75 04		 jne	 SHORT $LN3@length
  0000c	33 c0		 xor	 eax, eax

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN3@length:

; 303  : 		return (*_First == 0 ? 0

  00010	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL5@length:
  00013	66 8b 08	 mov	 cx, WORD PTR [eax]
  00016	83 c0 02	 add	 eax, 2
  00019	66 85 c9	 test	 cx, cx
  0001c	75 f5		 jne	 SHORT $LL5@length
  0001e	2b c2		 sub	 eax, edx
  00020	d1 f8		 sar	 eax, 1

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?length@?$char_traits@_W@std@@SAIPB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC						; COMDAT

; 244  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 248  :         #pragma warning(pop)
; 249  :     }

  0000b	5d		 pop	 ebp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memmove
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 231  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 235  :         #pragma warning(pop)
; 236  :     }

  0000b	5d		 pop	 ebp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memcpy
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\wizard.c
;	COMDAT _MainDialogProc@16
_TEXT	SEGMENT
_hkey$1 = -120						; size = 4
_tmpPaintStruct$2 = -116				; size = 64
_rec$3 = -52						; size = 16
_rD$4 = -36						; size = 16
_rD$5 = -36						; size = 16
_rD$6 = -36						; size = 16
_rW$7 = -20						; size = 16
_rW$8 = -20						; size = 16
_rW$9 = -20						; size = 16
_rW$10 = -20						; size = 16
_trect$11 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_MainDialogProc@16 PROC					; COMDAT

; 892  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 893  : 	WORD lw = LOWORD (wParam);
; 894  : 
; 895  : 	switch (uMsg)

  00010	8b 45 0c	 mov	 eax, DWORD PTR _uMsg$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  00017	56		 push	 esi
  00018	8b 75 10	 mov	 esi, DWORD PTR _wParam$[ebp]
  0001b	57		 push	 edi
  0001c	3d 10 01 00 00	 cmp	 eax, 272		; 00000110H
  00021	0f 87 5d 04 00
	00		 ja	 $LN63@MainDialog
  00027	0f 84 0e 02 00
	00		 je	 $LN4@MainDialog
  0002d	83 c0 f1	 add	 eax, -15		; fffffff1H
  00030	83 f8 44	 cmp	 eax, 68			; 00000044H
  00033	0f 87 36 04 00
	00		 ja	 $LN10@MainDialog
  00039	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN117@MainDialog[eax]
  00040	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN125@MainDialog[eax*4]
$LN12@MainDialog:

; 955  : 		}
; 956  : 		return 0;
; 957  : 
; 958  : 	case WM_HELP:
; 959  : 		if (bLicenseAccepted)

  00047	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bLicenseAccepted@@3HA, 0 ; bLicenseAccepted
  0004e	0f 84 14 0b 00
	00		 je	 $LN13@MainDialog

; 960  : 			OpenPageHelp (hwndDlg, nCurPageNo);

  00054	ff 35 00 00 00
	00		 push	 DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  0005a	53		 push	 ebx
  0005b	e8 00 00 00 00	 call	 _OpenPageHelp
  00060	83 c4 08	 add	 esp, 8

; 961  : 
; 962  : 		return 1;

  00063	e9 00 0b 00 00	 jmp	 $LN13@MainDialog
$LN43@MainDialog:

; 1133 : 		}
; 1134 : 
; 1135 : 		return 0;
; 1136 : 
; 1137 : 
; 1138 : 
; 1139 : 	case WM_PAINT:
; 1140 : 
; 1141 : 		if (nCurPageNo == DONATIONS_PAGE && DonColorSchemeId != 2)

  00068	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR ?nCurPageNo@@3HA, 6 ; nCurPageNo
  0006f	0f 85 fa 03 00
	00		 jne	 $LN10@MainDialog
  00075	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?DonColorSchemeId@@3HA, 2
  0007c	0f 84 ed 03 00
	00		 je	 $LN10@MainDialog

; 1142 : 		{
; 1143 : 			HWND hwndItem = GetDlgItem (MainDlg, IDC_MAIN_CONTENT_CANVAS);

  00082	68 07 04 00 00	 push	 1031			; 00000407H
  00087	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00093	8b f8		 mov	 edi, eax

; 1144 : 
; 1145 : 			PAINTSTRUCT tmpPaintStruct;
; 1146 : 			HDC hdc = BeginPaint (hwndItem, &tmpPaintStruct); 

  00095	8d 45 8c	 lea	 eax, DWORD PTR _tmpPaintStruct$2[ebp]
  00098	50		 push	 eax
  00099	57		 push	 edi
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BeginPaint@8

; 1147 : 
; 1148 : 			if (DonColorSchemeId != 2)

  000a0	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?DonColorSchemeId@@3HA, 2
  000a7	8b d8		 mov	 ebx, eax
  000a9	74 5b		 je	 SHORT $LN45@MainDialog

; 1149 : 			{
; 1150 : 				HBRUSH tmpBrush = CreateSolidBrush (DonBkgColor);

  000ab	ff 35 00 00 00
	00		 push	 DWORD PTR ?DonBkgColor@@3KA
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4

; 1151 : 				
; 1152 : 				RECT trect;
; 1153 : 
; 1154 : 				trect.left = CompensateXDPI (1);

  000b7	6a 01		 push	 1
  000b9	8b f0		 mov	 esi, eax
  000bb	e8 00 00 00 00	 call	 _CompensateXDPI

; 1155 : 				trect.right = CompensateXDPI (560);

  000c0	68 30 02 00 00	 push	 560			; 00000230H
  000c5	89 45 ec	 mov	 DWORD PTR _trect$11[ebp], eax
  000c8	e8 00 00 00 00	 call	 _CompensateXDPI

; 1156 : 				trect.top  = CompensateYDPI (DonColorSchemeId == 7 ? 11 : 0);

  000cd	33 c9		 xor	 ecx, ecx
  000cf	89 45 f4	 mov	 DWORD PTR _trect$11[ebp+8], eax
  000d2	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR ?DonColorSchemeId@@3HA, 7
  000d9	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000de	0f 44 c8	 cmove	 ecx, eax
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 _CompensateYDPI

; 1157 : 				trect.bottom = CompensateYDPI (260);

  000e7	68 04 01 00 00	 push	 260			; 00000104H
  000ec	89 45 f0	 mov	 DWORD PTR _trect$11[ebp+4], eax
  000ef	e8 00 00 00 00	 call	 _CompensateYDPI
  000f4	83 c4 10	 add	 esp, 16			; 00000010H
  000f7	89 45 f8	 mov	 DWORD PTR _trect$11[ebp+12], eax

; 1158 : 
; 1159 : 				FillRect (hdc, &trect, tmpBrush);

  000fa	8d 45 ec	 lea	 eax, DWORD PTR _trect$11[ebp]
  000fd	56		 push	 esi
  000fe	50		 push	 eax
  000ff	53		 push	 ebx
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12
$LN45@MainDialog:

; 1160 : 			}
; 1161 : 					
; 1162 : 			EndPaint(hwndItem, &tmpPaintStruct); 

  00106	8d 45 8c	 lea	 eax, DWORD PTR _tmpPaintStruct$2[ebp]
  00109	50		 push	 eax
  0010a	57		 push	 edi
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndPaint@8

; 1163 : 			ReleaseDC (hwndItem, hdc);

  00111	53		 push	 ebx
  00112	57		 push	 edi
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi

; 1164 : 		}
; 1165 : 		return 0; 

  0011b	33 c0		 xor	 eax, eax
  0011d	5b		 pop	 ebx

; 1334 : 	}
; 1335 : 
; 1336 : 	return 0;
; 1337 : }

  0011e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00121	33 cd		 xor	 ecx, ebp
  00123	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c2 10 00	 ret	 16			; 00000010H
$LN53@MainDialog:

; 1285 : 
; 1286 : 	case WM_CLOSE:
; 1287 : 
; 1288 : 		if (!bDevm)

  0012e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  00135	0f 85 f2 00 00
	00		 jne	 $LN61@MainDialog

; 1289 : 		{
; 1290 : 			if (bInProgress)

  0013b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bInProgress@@3HA, 0 ; bInProgress
  00142	74 20		 je	 SHORT $LN55@MainDialog

; 1291 : 			{
; 1292 : 				NormalCursor();

  00144	e8 00 00 00 00	 call	 _NormalCursor

; 1293 : 				if (AskNoYes("CONFIRM_EXIT_UNIVERSAL") == IDNO)

  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@
  0014e	e8 00 00 00 00	 call	 _AskNoYes
  00153	83 c4 04	 add	 esp, 4
  00156	83 f8 07	 cmp	 eax, 7
  00159	0f 84 09 0a 00
	00		 je	 $LN13@MainDialog

; 1294 : 				{
; 1295 : 					return 1;
; 1296 : 				}
; 1297 : 				WaitCursor ();

  0015f	e8 00 00 00 00	 call	 _WaitCursor
$LN55@MainDialog:

; 1298 : 			}
; 1299 : 
; 1300 : 			if (bOpenContainingFolder && bExtractOnly && bExtractionSuccessful)

  00164	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bOpenContainingFolder@@3HA, 0 ; bOpenContainingFolder
  0016b	74 2c		 je	 SHORT $LN57@MainDialog
  0016d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bExtractOnly@@3HA, 0 ; bExtractOnly
  00174	74 23		 je	 SHORT $LN57@MainDialog
  00176	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bExtractionSuccessful@@3HA, 0 ; bExtractionSuccessful
  0017d	74 1a		 je	 SHORT $LN57@MainDialog

; 1301 : 			{
; 1302 : 				ShellExecute (NULL, "open", WizardDestExtractPath, NULL, NULL, SW_SHOWNORMAL);

  0017f	6a 01		 push	 1
  00181	6a 00		 push	 0
  00183	6a 00		 push	 0
  00185	68 00 00 00 00	 push	 OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_04PMOCAHAA@open?$AA@
  0018f	6a 00		 push	 0
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShellExecuteA@24

; 1303 : 			}
; 1304 : 			else

  00197	eb 64		 jmp	 SHORT $LN58@MainDialog
$LN57@MainDialog:

; 1305 : 			{
; 1306 : 				if (bPromptReleaseNotes
; 1307 : 					&& AskYesNo ("AFTER_UPGRADE_RELEASE_NOTES") == IDYES)

  00199	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bPromptReleaseNotes, 0
  001a0	74 1f		 je	 SHORT $LN59@MainDialog
  001a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PEPDOHPE@AFTER_UPGRADE_RELEASE_NOTES?$AA@
  001a7	e8 00 00 00 00	 call	 _AskYesNo
  001ac	83 c4 04	 add	 esp, 4
  001af	83 f8 06	 cmp	 eax, 6
  001b2	75 0d		 jne	 SHORT $LN59@MainDialog

; 1308 : 				{
; 1309 : 					//Applink ("releasenotes", TRUE, "");
; 1310 : 					Extlink("http://www.gostcrypt.org/redirect.php?a=2");

  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@
  001b9	e8 00 00 00 00	 call	 _Extlink
  001be	83 c4 04	 add	 esp, 4
$LN59@MainDialog:

; 1311 : 				}
; 1312 : 
; 1313 : 				bPromptReleaseNotes = FALSE;
; 1314 : 
; 1315 : 				if (bPromptTutorial
; 1316 : 					&& AskYesNo ("AFTER_INSTALL_TUTORIAL") == IDYES)

  001c1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bPromptTutorial, 0
  001c8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bPromptReleaseNotes, 0
  001d2	74 1f		 je	 SHORT $LN60@MainDialog
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JALPBIFE@AFTER_INSTALL_TUTORIAL?$AA@
  001d9	e8 00 00 00 00	 call	 _AskYesNo
  001de	83 c4 04	 add	 esp, 4
  001e1	83 f8 06	 cmp	 eax, 6
  001e4	75 0d		 jne	 SHORT $LN60@MainDialog

; 1317 : 				{
; 1318 : 					//Applink ("beginnerstutorial", TRUE, "");
; 1319 : 					Extlink("http://www.gostcrypt.org/redirect.php?a=2");

  001e6	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NCJGAECA@http?3?1?1www?4gostcrypt?4org?1redirec@
  001eb	e8 00 00 00 00	 call	 _Extlink
  001f0	83 c4 04	 add	 esp, 4
$LN60@MainDialog:

; 1320 : 				}
; 1321 : 
; 1322 : 				bPromptTutorial = FALSE;

  001f3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bPromptTutorial, 0
$LN58@MainDialog:

; 1323 : 			}
; 1324 : 
; 1325 : 			if (bRestartRequired
; 1326 : 				&& AskYesNo (bUpgrade ? "UPGRADE_OK_REBOOT_REQUIRED" : "CONFIRM_RESTART") == IDYES)

  001fd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRestartRequired, 0
  00204	74 27		 je	 SHORT $LN61@MainDialog
  00206	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  0020d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BA@ICICKJJH@CONFIRM_RESTART?$AA@
  00212	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BL@OMDAGJAA@UPGRADE_OK_REBOOT_REQUIRED?$AA@
  00217	0f 44 c1	 cmove	 eax, ecx
  0021a	50		 push	 eax
  0021b	e8 00 00 00 00	 call	 _AskYesNo
  00220	83 c4 04	 add	 esp, 4
  00223	83 f8 06	 cmp	 eax, 6
  00226	75 05		 jne	 SHORT $LN61@MainDialog

; 1327 : 			{
; 1328 : 				RestartComputer();

  00228	e8 00 00 00 00	 call	 _RestartComputer
$LN61@MainDialog:

; 1329 : 			}
; 1330 : 		}
; 1331 : 
; 1332 : 		EndDialog (hwndDlg, IDCANCEL);

  0022d	6a 02		 push	 2
  0022f	53		 push	 ebx
  00230	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 1333 : 		return 1;

  00236	e9 2d 09 00 00	 jmp	 $LN13@MainDialog
$LN4@MainDialog:

; 896  : 	{
; 897  : 	case WM_INITDIALOG:
; 898  : 		{
; 899  : 			RECT rec;
; 900  : 
; 901  : 			GetModuleFileName (NULL, SelfFile, sizeof (SelfFile));

  0023b	68 04 01 00 00	 push	 260			; 00000104H
  00240	68 00 00 00 00	 push	 OFFSET ?SelfFile@@3PADA	; SelfFile
  00245	6a 00		 push	 0
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 902  : 
; 903  : 			MainDlg = hwndDlg;

  0024d	89 1d 00 00 00
	00		 mov	 DWORD PTR _MainDlg, ebx

; 904  : 
; 905  : 			if (!CreateAppSetupMutex ())

  00253	e8 00 00 00 00	 call	 _CreateAppSetupMutex
  00258	85 c0		 test	 eax, eax
  0025a	75 0d		 jne	 SHORT $LN5@MainDialog

; 906  : 				AbortProcess ("GST_INSTALLER_IS_RUNNING");

  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@
  00261	e8 00 00 00 00	 call	 _AbortProcess
  00266	83 c4 04	 add	 esp, 4
$LN5@MainDialog:

; 907  : 
; 908  : 			InitDialog (hwndDlg);

  00269	53		 push	 ebx
  0026a	e8 00 00 00 00	 call	 _InitDialog

; 909  : 			LocalizeDialog (hwndDlg, "IDD_INSTL_DLG");

  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MGHONKG@IDD_INSTL_DLG?$AA@
  00274	53		 push	 ebx
  00275	e8 00 00 00 00	 call	 _LocalizeDialog

; 910  : 			
; 911  : 			// Resize the bitmap if the user has a non-default DPI 
; 912  : 			if (ScreenDPI != USER_DEFAULT_SCREEN_DPI)

  0027a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00280	83 c4 0c	 add	 esp, 12			; 0000000cH
  00283	83 3d 00 00 00
	00 60		 cmp	 DWORD PTR _ScreenDPI, 96 ; 00000060H
  0028a	74 24		 je	 SHORT $LN6@MainDialog

; 913  : 			{
; 914  : 				hbmWizardBitmapRescaled = RenderBitmap (MAKEINTRESOURCE (IDB_SETUP_WIZARD),

  0028c	6a 01		 push	 1
  0028e	6a 00		 push	 0
  00290	6a 00		 push	 0
  00292	6a 00		 push	 0
  00294	6a 00		 push	 0
  00296	6a 00		 push	 0
  00298	68 06 04 00 00	 push	 1030			; 00000406H
  0029d	53		 push	 ebx
  0029e	ff d6		 call	 esi
  002a0	50		 push	 eax
  002a1	6a 6b		 push	 107			; 0000006bH
  002a3	e8 00 00 00 00	 call	 _RenderBitmap
  002a8	83 c4 20	 add	 esp, 32			; 00000020H
  002ab	a3 00 00 00 00	 mov	 DWORD PTR ?hbmWizardBitmapRescaled@@3PAUHBITMAP__@@A, eax ; hbmWizardBitmapRescaled
$LN6@MainDialog:

; 915  : 					GetDlgItem (hwndDlg, IDC_BITMAP_SETUP_WIZARD),
; 916  : 					0, 0, 0, 0, FALSE, TRUE);
; 917  : 			}
; 918  : 
; 919  : 			// Gfx area background (must not keep aspect ratio; must retain Windows-imposed distortion)
; 920  : 			GetClientRect (GetDlgItem (hwndDlg, IDC_SETUP_WIZARD_GFX_AREA), &rec);

  002b0	8d 45 cc	 lea	 eax, DWORD PTR _rec$3[ebp]
  002b3	50		 push	 eax
  002b4	68 fb 03 00 00	 push	 1019			; 000003fbH
  002b9	53		 push	 ebx
  002ba	ff d6		 call	 esi
  002bc	50		 push	 eax
  002bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 921  : 			SetWindowPos (GetDlgItem (hwndDlg, IDC_SETUP_WIZARD_BKG), HWND_TOP, 0, 0, rec.right, rec.bottom, SWP_NOMOVE);

  002c3	6a 02		 push	 2
  002c5	ff 75 d8	 push	 DWORD PTR _rec$3[ebp+12]
  002c8	ff 75 d4	 push	 DWORD PTR _rec$3[ebp+8]
  002cb	6a 00		 push	 0
  002cd	6a 00		 push	 0
  002cf	6a 00		 push	 0
  002d1	68 fa 03 00 00	 push	 1018			; 000003faH
  002d6	53		 push	 ebx
  002d7	ff d6		 call	 esi
  002d9	50		 push	 eax
  002da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 922  : 
; 923  : 			nPbar = IDC_PROGRESS_BAR;
; 924  : 
; 925  : 			SendMessage (GetDlgItem (hwndDlg, IDC_BOX_TITLE), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  002e0	6a 01		 push	 1
  002e2	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  002e8	c7 05 00 00 00
	00 f8 03 00 00	 mov	 DWORD PTR ?nPbar@@3HA, 1016 ; nPbar, 000003f8H
  002f2	6a 30		 push	 48			; 00000030H
  002f4	68 e9 03 00 00	 push	 1001			; 000003e9H
  002f9	53		 push	 ebx
  002fa	ff d6		 call	 esi
  002fc	50		 push	 eax
  002fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 926  : 
; 927  : 			SetWindowText (hwndDlg, "GostCrypt Setup " VERSION_STRING);

  00303	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GJBFCKEH@GostCrypt?5Setup?51?43?41?$AA@
  00308	53		 push	 ebx
  00309	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 928  : 
; 929  : 			DonColorSchemeId = GetDonVal (2, 9);

  0030f	6a 09		 push	 9
  00311	6a 02		 push	 2
  00313	e8 00 00 00 00	 call	 ?GetDonVal@@YAHHH@Z	; GetDonVal
  00318	83 c4 08	 add	 esp, 8
  0031b	a3 00 00 00 00	 mov	 DWORD PTR ?DonColorSchemeId@@3HA, eax

; 930  : 
; 931  : 			if (bDevm)

  00320	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  00327	0f 84 92 00 00
	00		 je	 $LN7@MainDialog

; 932  : 			{
; 933  : 				InitWizardDestInstallPath ();

  0032d	e8 00 00 00 00	 call	 ?InitWizardDestInstallPath@@YAXXZ ; InitWizardDestInstallPath

; 934  : 				bSystemRestore = FALSE;
; 935  : 				bRegisterFileExt = FALSE;
; 936  : 				bAddToStartMenu = FALSE;
; 937  : 				bDesktopIcon = TRUE;
; 938  : 				bLicenseAccepted = TRUE;
; 939  : 				bStartInstall = TRUE;
; 940  : 				LoadPage (hwndDlg, INSTALL_PROGRESS_PAGE);

  00332	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00337	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bSystemRestore, 0
  00341	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bRegisterFileExt, 0
  0034b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bAddToStartMenu, 0
  00355	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bDesktopIcon, 1
  0035f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bLicenseAccepted@@3HA, 1 ; bLicenseAccepted
  00369	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bStartInstall@@3HA, 1 ; bStartInstall
  00373	85 c0		 test	 eax, eax
  00375	74 07		 je	 SHORT $LN68@MainDialog
  00377	50		 push	 eax
  00378	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$LN68@MainDialog:
  0037e	6a 01		 push	 1
  00380	6a 00		 push	 0
  00382	68 07 04 00 00	 push	 1031			; 00000407H
  00387	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0038d	ff d6		 call	 esi
  0038f	50		 push	 eax
  00390	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
  00396	8d 45 ec	 lea	 eax, DWORD PTR _rW$10[ebp]
  00399	50		 push	 eax
  0039a	68 05 04 00 00	 push	 1029			; 00000405H
  0039f	53		 push	 ebx
  003a0	ff d6		 call	 esi
  003a2	50		 push	 eax
  003a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  003a9	6a 00		 push	 0
  003ab	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  003b0	53		 push	 ebx
  003b1	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 3 ; nCurPageNo
  003bb	6a 71		 push	 113			; 00000071H

; 941  : 			}
; 942  : 			else

  003bd	eb 4f		 jmp	 SHORT $LN121@MainDialog
$LN7@MainDialog:

; 943  : 				LoadPage (hwndDlg, INTRO_PAGE);

  003bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  003c4	85 c0		 test	 eax, eax
  003c6	74 07		 je	 SHORT $LN81@MainDialog
  003c8	50		 push	 eax
  003c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$LN81@MainDialog:
  003cf	6a 01		 push	 1
  003d1	6a 00		 push	 0
  003d3	68 07 04 00 00	 push	 1031			; 00000407H
  003d8	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  003de	ff d6		 call	 esi
  003e0	50		 push	 eax
  003e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
  003e7	8d 45 ec	 lea	 eax, DWORD PTR _rW$9[ebp]
  003ea	50		 push	 eax
  003eb	68 05 04 00 00	 push	 1029			; 00000405H
  003f0	53		 push	 ebx
  003f1	ff d6		 call	 esi
  003f3	50		 push	 eax
  003f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  003fa	6a 00		 push	 0
  003fc	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00401	53		 push	 ebx
  00402	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 0 ; nCurPageNo
  0040c	6a 6c		 push	 108			; 0000006cH
$LN121@MainDialog:
  0040e	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00414	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  0041a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000000000000000000002d0000000f
  00421	a3 00 00 00 00	 mov	 DWORD PTR ?hCurPage@@3PAUHWND__@@A, eax ; hCurPage
  00426	8d 45 dc	 lea	 eax, DWORD PTR _rD$6[ebp]
  00429	50		 push	 eax
  0042a	53		 push	 ebx
  0042b	0f 11 45 dc	 movups	 XMMWORD PTR _rD$6[ebp], xmm0
  0042f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00435	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  0043b	85 c9		 test	 ecx, ecx
  0043d	74 2b		 je	 SHORT $LN89@MainDialog
  0043f	8b 45 f8	 mov	 eax, DWORD PTR _rW$9[ebp+12]
  00442	2b 45 f0	 sub	 eax, DWORD PTR _rW$9[ebp+4]
  00445	6a 01		 push	 1
  00447	50		 push	 eax
  00448	8b 45 f4	 mov	 eax, DWORD PTR _rW$9[ebp+8]
  0044b	2b 45 ec	 sub	 eax, DWORD PTR _rW$9[ebp]
  0044e	50		 push	 eax
  0044f	ff 75 e0	 push	 DWORD PTR _rD$6[ebp+4]
  00452	ff 75 dc	 push	 DWORD PTR _rD$6[ebp]
  00455	51		 push	 ecx
  00456	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  0045c	6a 01		 push	 1
  0045e	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00464	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN89@MainDialog:
  0046a	e8 00 00 00 00	 call	 _RefreshUIGFX
$LN10@MainDialog:
  0046f	5f		 pop	 edi
  00470	5e		 pop	 esi

; 944  : 
; 945  : 		}
; 946  : 		return 0;

  00471	33 c0		 xor	 eax, eax
  00473	5b		 pop	 ebx

; 1334 : 	}
; 1335 : 
; 1336 : 	return 0;
; 1337 : }

  00474	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00477	33 cd		 xor	 ecx, ebp
  00479	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0047e	8b e5		 mov	 esp, ebp
  00480	5d		 pop	 ebp
  00481	c2 10 00	 ret	 16			; 00000010H
$LN63@MainDialog:

; 893  : 	WORD lw = LOWORD (wParam);
; 894  : 
; 895  : 	switch (uMsg)

  00484	3d 91 81 00 00	 cmp	 eax, 33169		; 00008191H
  00489	0f 87 1f 04 00
	00		 ja	 $LN64@MainDialog
  0048f	0f 84 f4 02 00
	00		 je	 $LN49@MainDialog
  00495	2d 11 01 00 00	 sub	 eax, 273		; 00000111H
  0049a	74 79		 je	 SHORT $LN14@MainDialog
  0049c	83 e8 01	 sub	 eax, 1
  0049f	74 3f		 je	 SHORT $LN9@MainDialog
  004a1	83 e8 26	 sub	 eax, 38			; 00000026H
  004a4	75 c9		 jne	 SHORT $LN10@MainDialog

; 1166 : 
; 1167 : 
; 1168 : 
; 1169 : 	case WM_CTLCOLORSTATIC:
; 1170 : 
; 1171 : 		if ((HWND) lParam != GetDlgItem (MainDlg, IDC_MAIN_CONTENT_CANVAS))

  004a6	68 07 04 00 00	 push	 1031			; 00000407H
  004ab	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  004b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  004b7	39 45 14	 cmp	 DWORD PTR _lParam$[ebp], eax
  004ba	74 b3		 je	 SHORT $LN10@MainDialog

; 1172 : 		{
; 1173 : 			/* This maintains the background under the transparent-backround texts. The above 'if' statement allows
; 1174 : 			colored background to be erased automatically when leaving a page that uses it. */
; 1175 : 
; 1176 : 			SetBkMode ((HDC) wParam, TRANSPARENT);

  004bc	6a 01		 push	 1
  004be	56		 push	 esi
  004bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkMode@8

; 1177 : 			return ((LONG) (HBRUSH) (GetStockObject (NULL_BRUSH)));

  004c5	6a 05		 push	 5
  004c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStockObject@4
  004cd	5f		 pop	 edi
  004ce	5e		 pop	 esi
  004cf	5b		 pop	 ebx

; 1334 : 	}
; 1335 : 
; 1336 : 	return 0;
; 1337 : }

  004d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d3	33 cd		 xor	 ecx, ebp
  004d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004da	8b e5		 mov	 esp, ebp
  004dc	5d		 pop	 ebp
  004dd	c2 10 00	 ret	 16			; 00000010H
$LN9@MainDialog:

; 947  : 
; 948  : 	case WM_SYSCOMMAND:
; 949  : 		if (lw == IDC_ABOUT)

  004e0	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  004e5	66 3b f0	 cmp	 si, ax
  004e8	75 85		 jne	 SHORT $LN10@MainDialog

; 950  : 		{
; 951  : 			if (bLicenseAccepted)

  004ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bLicenseAccepted@@3HA, 0 ; bLicenseAccepted
  004f1	0f 84 71 06 00
	00		 je	 $LN13@MainDialog

; 952  : 				DialogBoxW (hInst, MAKEINTRESOURCEW (IDD_ABOUT_DLG), hwndDlg, (DLGPROC) AboutDlgProc);

  004f7	6a 00		 push	 0
  004f9	68 00 00 00 00	 push	 OFFSET _AboutDlgProc@16
  004fe	53		 push	 ebx
  004ff	68 fc 01 00 00	 push	 508			; 000001fcH
  00504	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  0050a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20

; 953  : 
; 954  : 			return 1;

  00510	e9 53 06 00 00	 jmp	 $LN13@MainDialog
$LN14@MainDialog:

; 963  : 
; 964  : 
; 965  : 	case WM_COMMAND:
; 966  : 		if (lw == IDHELP)

  00515	66 83 fe 09	 cmp	 si, 9
  00519	0f 84 28 fb ff
	ff		 je	 $LN12@MainDialog

; 967  : 		{
; 968  : 			if (bLicenseAccepted)
; 969  : 				OpenPageHelp (hwndDlg, nCurPageNo);
; 970  : 
; 971  : 			return 1;
; 972  : 		}
; 973  : 		if (lw == IDCANCEL)

  0051f	66 83 fe 02	 cmp	 si, 2
  00523	0f 84 a6 01 00
	00		 je	 $LN123@MainDialog

; 974  : 		{
; 975  : 			PostMessage (hwndDlg, WM_CLOSE, 0, 0);
; 976  : 			return 1;
; 977  : 		}
; 978  : 		if (lw == IDC_NEXT)

  00529	b8 02 04 00 00	 mov	 eax, 1026		; 00000402H
  0052e	66 3b f0	 cmp	 si, ax
  00531	0f 85 aa 01 00
	00		 jne	 $LN18@MainDialog

; 979  : 		{
; 980  : 			if (nCurPageNo == INTRO_PAGE)

  00537	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  0053c	85 c0		 test	 eax, eax
  0053e	0f 85 ac 00 00
	00		 jne	 $LN19@MainDialog

; 981  : 			{
; 982  : 				if (!IsButtonChecked (GetDlgItem (hCurPage, IDC_AGREE)))

  00544	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  0054a	68 fe 03 00 00	 push	 1022			; 000003feH
  0054f	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00555	ff d6		 call	 esi
  00557	50		 push	 eax
  00558	e8 00 00 00 00	 call	 _IsButtonChecked
  0055d	83 c4 04	 add	 esp, 4
  00560	85 c0		 test	 eax, eax
  00562	75 0a		 jne	 SHORT $LN21@MainDialog

; 983  : 				{
; 984  : 					bLicenseAccepted = FALSE;

  00564	a3 00 00 00 00	 mov	 DWORD PTR ?bLicenseAccepted@@3HA, eax ; bLicenseAccepted

; 985  : 					return 1;

  00569	e9 fa 05 00 00	 jmp	 $LN13@MainDialog
$LN21@MainDialog:

; 986  : 				}
; 987  : 				bLicenseAccepted = TRUE;
; 988  : 				EnableWindow (GetDlgItem (hwndDlg, IDHELP), TRUE);

  0056e	6a 01		 push	 1
  00570	6a 09		 push	 9
  00572	53		 push	 ebx
  00573	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bLicenseAccepted@@3HA, 1 ; bLicenseAccepted
  0057d	ff d6		 call	 esi
  0057f	50		 push	 eax
  00580	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 989  : 
; 990  : 				if (nCurrentOS == WIN_2000)

  00586	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _nCurrentOS, 7
  0058d	75 47		 jne	 SHORT $LN118@MainDialog

; 991  : 				{
; 992  : 					WarningDirect (L"Warning: Please note that this may be the last version of GostCrypt that supports Windows 2000. If you want to be able to upgrade to future versions of GostCrypt (which is highly recommended), you will need to upgrade to Windows XP or a later version of Windows.\n\nNote: Microsoft stopped issuing security updates for Windows 2000 to the general public on 7/13/2010 (the last non-security update for Windows 2000 was issued to the general public in 2005).");

  0058f	68 00 00 00 00	 push	 OFFSET ??_C@_1DIO@DJBHAIAH@?$AAW?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAP?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAn?$AAo?$AAt?$AAe?$AA?5?$AAt?$AAh?$AAa?$AAt?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AAm@
  00594	e8 00 00 00 00	 call	 _WarningDirect
  00599	83 c4 04	 add	 esp, 4

; 993  : 
; 994  : 
; 995  : 					HKEY hkey;
; 996  : 
; 997  : 					if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Updates\\Windows 2000\\SP5\\Update Rollup 1", 0, KEY_READ, &hkey) != ERROR_SUCCESS)

  0059c	8d 45 88	 lea	 eax, DWORD PTR _hkey$1[ebp]
  0059f	50		 push	 eax
  005a0	68 19 00 02 00	 push	 131097			; 00020019H
  005a5	6a 00		 push	 0
  005a7	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BHNBHIPG@SOFTWARE?2Microsoft?2Updates?2Windo@
  005ac	68 02 00 00 80	 push	 -2147483646		; 80000002H
  005b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  005b7	85 c0		 test	 eax, eax
  005b9	74 12		 je	 SHORT $LN23@MainDialog

; 998  : 					{
; 999  : 						ErrorDirect (L"GostCrypt requires Update Rollup 1 for Windows 2000 SP4 to be installed.\n\nFor more information, see http://support.microsoft.com/kb/891861");

  005bb	68 00 00 00 00	 push	 OFFSET ??_C@_1BBG@NBLOJHJE@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAs?$AA?5?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?5?$AAR?$AAo?$AAl?$AAl?$AAu?$AAp@
  005c0	e8 00 00 00 00	 call	 _ErrorDirect
  005c5	83 c4 04	 add	 esp, 4

; 1000 : 						AbortProcessSilent ();

  005c8	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN23@MainDialog:

; 1001 : 					}
; 1002 : 
; 1003 : 					RegCloseKey (hkey);

  005cd	ff 75 88	 push	 DWORD PTR _hkey$1[ebp]
  005d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN118@MainDialog:

; 1043 : 
; 1044 : 				bStartExtraction = TRUE;

  005d6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
$LN36@MainDialog:

; 1105 : 			}
; 1106 : 
; 1107 : 			LoadPage (hwndDlg, ++nCurPageNo);

  005db	40		 inc	 eax
  005dc	50		 push	 eax
  005dd	53		 push	 ebx
  005de	a3 00 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, eax ; nCurPageNo
  005e3	e8 00 00 00 00	 call	 ?LoadPage@@YAXPAUHWND__@@H@Z ; LoadPage
  005e8	83 c4 08	 add	 esp, 8

; 1108 : 
; 1109 : 			return 1;

  005eb	e9 78 05 00 00	 jmp	 $LN13@MainDialog
$LN19@MainDialog:

; 1004 : 				}
; 1005 : 			}
; 1006 : 
; 1007 : /**
; 1008 :  *
; 1009 :  *	\fn else if (nCurPageNo == WIZARD_MODE_PAGE)
; 1010 :  *	\brief
; 1011 :  *	\param[in] nCurPageNo ==
; 1012 :  *	\return
; 1013 :  *
; 1014 :  */
; 1015 : 			else if (nCurPageNo == WIZARD_MODE_PAGE)

  005f0	83 f8 01	 cmp	 eax, 1
  005f3	75 5b		 jne	 SHORT $LN24@MainDialog

; 1016 : 			{
; 1017 : 				if (IsButtonChecked (GetDlgItem (hCurPage, IDC_WIZARD_MODE_EXTRACT_ONLY)))

  005f5	68 01 04 00 00	 push	 1025			; 00000401H
  005fa	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00600	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00606	50		 push	 eax
  00607	e8 00 00 00 00	 call	 _IsButtonChecked
  0060c	83 c4 04	 add	 esp, 4
  0060f	85 c0		 test	 eax, eax
  00611	74 c3		 je	 SHORT $LN118@MainDialog

; 1018 : 				{
; 1019 : 					Info ("TRAVELER_LIMITATIONS_NOTE");

  00613	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HICKIHM@TRAVELER_LIMITATIONS_NOTE?$AA@
  00618	e8 00 00 00 00	 call	 _Info
  0061d	83 c4 04	 add	 esp, 4

; 1020 : 
; 1021 : 					if (IsUacSupported() 
; 1022 : 						&& AskWarnYesNo ("TRAVELER_UAC_NOTE") == IDNO)

  00620	e8 00 00 00 00	 call	 _IsUacSupported
  00625	85 c0		 test	 eax, eax
  00627	74 16		 je	 SHORT $LN27@MainDialog
  00629	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NKLIMG@TRAVELER_UAC_NOTE?$AA@
  0062e	e8 00 00 00 00	 call	 _AskWarnYesNo
  00633	83 c4 04	 add	 esp, 4
  00636	83 f8 07	 cmp	 eax, 7
  00639	0f 84 29 05 00
	00		 je	 $LN13@MainDialog
$LN27@MainDialog:

; 1023 : 					{
; 1024 : 						return 1;
; 1025 : 					}
; 1026 : 
; 1027 : 					bExtractOnly = TRUE;

  0063f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bExtractOnly@@3HA, 1 ; bExtractOnly

; 1028 : 					nCurPageNo = EXTRACTION_OPTIONS_PAGE - 1;

  00649	b8 03 00 00 00	 mov	 eax, 3

; 1029 : 				}
; 1030 : 			}

  0064e	eb 8b		 jmp	 SHORT $LN36@MainDialog
$LN24@MainDialog:

; 1031 : 
; 1032 : /**
; 1033 :  *
; 1034 :  *	\fn else if (nCurPageNo == EXTRACTION_OPTIONS_PAGE)
; 1035 :  *	\brief
; 1036 :  *	\param[in] nCurPageNo ==
; 1037 :  *	\return
; 1038 :  *
; 1039 :  */
; 1040 : 			else if (nCurPageNo == EXTRACTION_OPTIONS_PAGE)

  00650	83 f8 04	 cmp	 eax, 4
  00653	75 31		 jne	 SHORT $LN28@MainDialog

; 1041 : 			{
; 1042 : 				GetWindowText (GetDlgItem (hCurPage, IDC_DESTINATION), WizardDestExtractPath, sizeof (WizardDestExtractPath));

  00655	68 04 01 00 00	 push	 260			; 00000104H
  0065a	68 00 00 00 00	 push	 OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  0065f	68 e8 03 00 00	 push	 1000			; 000003e8H
  00664	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  0066a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00670	50		 push	 eax
  00671	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 1043 : 
; 1044 : 				bStartExtraction = TRUE;

  00677	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bStartExtraction@@3HA, 1 ; bStartExtraction
  00681	e9 50 ff ff ff	 jmp	 $LN118@MainDialog
$LN28@MainDialog:

; 1045 : 			}
; 1046 : 
; 1047 : /**
; 1048 :  *
; 1049 :  *	\fn else if (nCurPageNo == INSTALL_OPTIONS_PAGE)
; 1050 :  *	\brief
; 1051 :  *	\param[in] nCurPageNo ==
; 1052 :  *	\return
; 1053 :  *
; 1054 :  */
; 1055 : 			else if (nCurPageNo == INSTALL_OPTIONS_PAGE)

  00686	83 f8 02	 cmp	 eax, 2
  00689	75 31		 jne	 SHORT $LN30@MainDialog

; 1056 : 			{
; 1057 : 				GetWindowText (GetDlgItem (hCurPage, IDC_DESTINATION), WizardDestInstallPath, sizeof (WizardDestInstallPath));

  0068b	68 04 01 00 00	 push	 260			; 00000104H
  00690	68 00 00 00 00	 push	 OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  00695	68 e8 03 00 00	 push	 1000			; 000003e8H
  0069a	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  006a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  006a6	50		 push	 eax
  006a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 1058 : 
; 1059 : 				bStartInstall = TRUE;

  006ad	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bStartInstall@@3HA, 1 ; bStartInstall
  006b7	e9 1a ff ff ff	 jmp	 $LN118@MainDialog
$LN30@MainDialog:

; 1060 : 			}
; 1061 : 
; 1062 : /**
; 1063 :  *
; 1064 :  *	\fn else if (nCurPageNo == INSTALL_PROGRESS_PAGE)
; 1065 :  *	\brief
; 1066 :  *	\param[in] nCurPageNo ==
; 1067 :  *	\return
; 1068 :  *
; 1069 :  */
; 1070 : 			else if (nCurPageNo == INSTALL_PROGRESS_PAGE)

  006bc	83 f8 03	 cmp	 eax, 3
  006bf	74 0e		 je	 SHORT $LN123@MainDialog

; 1071 : 			{
; 1072 : 				PostMessage (hwndDlg, WM_CLOSE, 0, 0);
; 1073 : 				return 1;
; 1074 : 			}
; 1075 : 
; 1076 : /**
; 1077 :  *
; 1078 :  *	\fn else if (nCurPageNo == EXTRACTION_PROGRESS_PAGE)
; 1079 :  *	\brief
; 1080 :  *	\param[in] nCurPageNo ==
; 1081 :  *	\return
; 1082 :  *
; 1083 :  */
; 1084 : 			else if (nCurPageNo == EXTRACTION_PROGRESS_PAGE)

  006c1	83 f8 05	 cmp	 eax, 5
  006c4	74 09		 je	 SHORT $LN123@MainDialog

; 1085 : 			{
; 1086 : 				PostMessage (hwndDlg, WM_CLOSE, 0, 0);
; 1087 : 				return 1;
; 1088 : 			}
; 1089 : 
; 1090 : /**
; 1091 :  *
; 1092 :  *	\fn else if (nCurPageNo == DONATIONS_PAGE)
; 1093 :  *	\brief
; 1094 :  *	\param[in] nCurPageNo ==
; 1095 :  *	\return
; 1096 :  *
; 1097 :  */
; 1098 : 			else if (nCurPageNo == DONATIONS_PAGE)

  006c6	83 f8 06	 cmp	 eax, 6
  006c9	0f 85 0c ff ff
	ff		 jne	 $LN36@MainDialog
$LN123@MainDialog:

; 1099 : 			{
; 1100 : 				// 'Finish' button clicked
; 1101 : 
; 1102 : 				PostMessage (hwndDlg, WM_CLOSE, 0, 0);

  006cf	6a 00		 push	 0
  006d1	6a 00		 push	 0
  006d3	6a 10		 push	 16			; 00000010H
  006d5	53		 push	 ebx
  006d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 1103 : 
; 1104 : 				return 1;

  006dc	e9 87 04 00 00	 jmp	 $LN13@MainDialog
$LN18@MainDialog:

; 1110 : 		}
; 1111 : 
; 1112 : 		if (lw == IDC_PREV)

  006e1	b8 03 04 00 00	 mov	 eax, 1027		; 00000403H
  006e6	66 3b f0	 cmp	 si, ax
  006e9	0f 85 80 fd ff
	ff		 jne	 $LN10@MainDialog

; 1113 : 		{
; 1114 : 			if (nCurPageNo == WIZARD_MODE_PAGE)

  006ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  006f4	83 f8 01	 cmp	 eax, 1
  006f7	75 21		 jne	 SHORT $LN38@MainDialog

; 1115 : 			{
; 1116 : 				bExtractOnly = IsButtonChecked (GetDlgItem (hCurPage, IDC_WIZARD_MODE_EXTRACT_ONLY));

  006f9	68 01 04 00 00	 push	 1025			; 00000401H
  006fe	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00704	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0070a	50		 push	 eax
  0070b	e8 00 00 00 00	 call	 _IsButtonChecked
  00710	83 c4 04	 add	 esp, 4
  00713	a3 00 00 00 00	 mov	 DWORD PTR ?bExtractOnly@@3HA, eax ; bExtractOnly
  00718	eb 55		 jmp	 SHORT $LN122@MainDialog
$LN38@MainDialog:

; 1117 : 			}
; 1118 : 
; 1119 : 			else if (nCurPageNo == EXTRACTION_OPTIONS_PAGE)

  0071a	83 f8 04	 cmp	 eax, 4
  0071d	75 29		 jne	 SHORT $LN40@MainDialog

; 1120 : 			{
; 1121 : 				GetWindowText (GetDlgItem (hCurPage, IDC_DESTINATION), WizardDestExtractPath, sizeof (WizardDestExtractPath));

  0071f	68 04 01 00 00	 push	 260			; 00000104H
  00724	68 00 00 00 00	 push	 OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  00729	68 e8 03 00 00	 push	 1000			; 000003e8H
  0072e	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00734	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0073a	50		 push	 eax
  0073b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12

; 1122 : 				nCurPageNo = WIZARD_MODE_PAGE + 1;

  00741	b8 02 00 00 00	 mov	 eax, 2
  00746	eb 2c		 jmp	 SHORT $LN42@MainDialog
$LN40@MainDialog:

; 1123 : 			}
; 1124 : 
; 1125 : 			else if (nCurPageNo == INSTALL_OPTIONS_PAGE)

  00748	83 f8 02	 cmp	 eax, 2
  0074b	75 27		 jne	 SHORT $LN42@MainDialog

; 1126 : 			{
; 1127 : 				GetWindowText (GetDlgItem (hCurPage, IDC_DESTINATION), WizardDestInstallPath, sizeof (WizardDestInstallPath));

  0074d	68 04 01 00 00	 push	 260			; 00000104H
  00752	68 00 00 00 00	 push	 OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  00757	68 e8 03 00 00	 push	 1000			; 000003e8H
  0075c	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00762	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00768	50		 push	 eax
  00769	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextA@12
$LN122@MainDialog:
  0076f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
$LN42@MainDialog:

; 1128 : 			}
; 1129 : 
; 1130 : 			LoadPage (hwndDlg, --nCurPageNo);

  00774	48		 dec	 eax
  00775	50		 push	 eax
  00776	53		 push	 ebx
  00777	a3 00 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, eax ; nCurPageNo
  0077c	e8 00 00 00 00	 call	 ?LoadPage@@YAXPAUHWND__@@H@Z ; LoadPage
  00781	83 c4 08	 add	 esp, 8

; 1131 : 
; 1132 : 			return 1;

  00784	e9 df 03 00 00	 jmp	 $LN13@MainDialog
$LN49@MainDialog:

; 1178 : 		}
; 1179 : 
; 1180 : 
; 1181 : 	case WM_ERASEBKGND:
; 1182 : 
; 1183 : 		return 0;
; 1184 : 
; 1185 : 
; 1186 : 
; 1187 : 	case GST_APPMSG_INSTALL_SUCCESS:
; 1188 : 		
; 1189 : 		/* Installation completed successfully */
; 1190 : 		
; 1191 : 		bInProgress = FALSE;
; 1192 : 
; 1193 : 		nCurPageNo = DONATIONS_PAGE;
; 1194 : 		LoadPage (hwndDlg, DONATIONS_PAGE);

  00789	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  0078e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bInProgress@@3HA, 0 ; bInProgress
  00798	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 6 ; nCurPageNo
  007a2	85 c0		 test	 eax, eax
  007a4	74 07		 je	 SHORT $LN94@MainDialog
  007a6	50		 push	 eax
  007a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$LN94@MainDialog:
  007ad	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  007b3	6a 01		 push	 1
  007b5	6a 00		 push	 0
  007b7	68 07 04 00 00	 push	 1031			; 00000407H
  007bc	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  007c2	ff d7		 call	 edi
  007c4	50		 push	 eax
  007c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
  007cb	8d 45 ec	 lea	 eax, DWORD PTR _rW$8[ebp]
  007ce	50		 push	 eax
  007cf	68 05 04 00 00	 push	 1029			; 00000405H
  007d4	53		 push	 ebx
  007d5	ff d7		 call	 edi
  007d7	50		 push	 eax
  007d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  007de	6a 00		 push	 0
  007e0	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  007e5	53		 push	 ebx
  007e6	6a 72		 push	 114			; 00000072H
  007e8	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  007ee	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 6 ; nCurPageNo
  007f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  007fe	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000000000000000000002d0000000f
  00805	a3 00 00 00 00	 mov	 DWORD PTR ?hCurPage@@3PAUHWND__@@A, eax ; hCurPage
  0080a	8d 45 dc	 lea	 eax, DWORD PTR _rD$5[ebp]
  0080d	50		 push	 eax
  0080e	53		 push	 ebx
  0080f	0f 11 45 dc	 movups	 XMMWORD PTR _rD$5[ebp], xmm0
  00813	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00819	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  0081f	85 c9		 test	 ecx, ecx
  00821	74 2b		 je	 SHORT $LN102@MainDialog
  00823	8b 45 f8	 mov	 eax, DWORD PTR _rW$8[ebp+12]
  00826	2b 45 f0	 sub	 eax, DWORD PTR _rW$8[ebp+4]
  00829	6a 01		 push	 1
  0082b	50		 push	 eax
  0082c	8b 45 f4	 mov	 eax, DWORD PTR _rW$8[ebp+8]
  0082f	2b 45 ec	 sub	 eax, DWORD PTR _rW$8[ebp]
  00832	50		 push	 eax
  00833	ff 75 e0	 push	 DWORD PTR _rD$5[ebp+4]
  00836	ff 75 dc	 push	 DWORD PTR _rD$5[ebp]
  00839	51		 push	 ecx
  0083a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  00840	6a 01		 push	 1
  00842	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00848	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN102@MainDialog:
  0084e	e8 00 00 00 00	 call	 _RefreshUIGFX

; 1195 : 
; 1196 : 		NormalCursor ();

  00853	e8 00 00 00 00	 call	 _NormalCursor

; 1197 : 
; 1198 : 		SetWindowTextW (GetDlgItem (hwndDlg, IDC_NEXT), GetString ("FINALIZE"));

  00858	68 00 00 00 00	 push	 OFFSET ??_C@_08MFKGCNCO@FINALIZE?$AA@
  0085d	e8 00 00 00 00	 call	 _GetString
  00862	83 c4 04	 add	 esp, 4
  00865	50		 push	 eax
  00866	68 02 04 00 00	 push	 1026			; 00000402H
  0086b	53		 push	 ebx
  0086c	ff d7		 call	 edi
  0086e	50		 push	 eax
  0086f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 1199 : 
; 1200 : 		EnableWindow (GetDlgItem (hwndDlg, IDC_PREV), FALSE);

  00875	6a 00		 push	 0
  00877	68 03 04 00 00	 push	 1027			; 00000403H
  0087c	53		 push	 ebx
  0087d	ff d7		 call	 edi
  0087f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00885	50		 push	 eax
  00886	ff d6		 call	 esi

; 1201 : 		EnableWindow (GetDlgItem (hwndDlg, IDC_NEXT), TRUE);

  00888	6a 01		 push	 1
  0088a	68 02 04 00 00	 push	 1026			; 00000402H
  0088f	53		 push	 ebx
  00890	ff d7		 call	 edi
  00892	50		 push	 eax
  00893	ff d6		 call	 esi

; 1202 : 		EnableWindow (GetDlgItem (hwndDlg, IDHELP), FALSE);

  00895	6a 00		 push	 0
  00897	6a 09		 push	 9
  00899	53		 push	 ebx
  0089a	ff d7		 call	 edi
  0089c	50		 push	 eax
  0089d	ff d6		 call	 esi

; 1203 : 		EnableWindow (GetDlgItem (hwndDlg, IDCANCEL), FALSE);

  0089f	6a 00		 push	 0
  008a1	6a 02		 push	 2
  008a3	53		 push	 ebx
  008a4	ff d7		 call	 edi
  008a6	50		 push	 eax
  008a7	ff d6		 call	 esi

; 1204 : 
; 1205 : 
; 1206 : 		RefreshUIGFX ();
; 1207 : 		return 1;

  008a9	e9 b5 02 00 00	 jmp	 $LN115@MainDialog
$LN64@MainDialog:

; 893  : 	WORD lw = LOWORD (wParam);
; 894  : 
; 895  : 	switch (uMsg)

  008ae	2d 93 81 00 00	 sub	 eax, 33171		; 00008193H
  008b3	0f 84 5c 01 00
	00		 je	 $LN51@MainDialog
  008b9	83 e8 01	 sub	 eax, 1
  008bc	0f 84 c0 00 00
	00		 je	 $LN50@MainDialog
  008c2	83 e8 02	 sub	 eax, 2
  008c5	0f 85 a4 fb ff
	ff		 jne	 $LN10@MainDialog

; 1256 : 
; 1257 : 		return 1;
; 1258 : 
; 1259 : 	case GST_APPMSG_EXTRACTION_FAILURE:
; 1260 : 		
; 1261 : 		/* Extraction failed */
; 1262 : 
; 1263 : 		bInProgress = FALSE;

  008cb	a3 00 00 00 00	 mov	 DWORD PTR ?bInProgress@@3HA, eax ; bInProgress

; 1264 : 
; 1265 : 		NormalCursor ();

  008d0	e8 00 00 00 00	 call	 _NormalCursor

; 1266 : 
; 1267 : 		StatusMessage (hCurPage, "EXTRACTION_FAILED");

  008d5	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GODHAKFG@EXTRACTION_FAILED?$AA@
  008da	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  008e0	e8 00 00 00 00	 call	 _StatusMessage

; 1268 : 
; 1269 : 		UpdateProgressBarProc(0);

  008e5	6a 00		 push	 0
  008e7	e8 00 00 00 00	 call	 _UpdateProgressBarProc

; 1270 : 
; 1271 : 		SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_TITLE), GetString ("EXTRACTION_FAILED"));

  008ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GODHAKFG@EXTRACTION_FAILED?$AA@
  008f1	e8 00 00 00 00	 call	 _GetString
  008f6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  008fc	83 c4 10	 add	 esp, 16			; 00000010H
  008ff	50		 push	 eax
  00900	68 e9 03 00 00	 push	 1001			; 000003e9H
  00905	53		 push	 ebx
  00906	ff d7		 call	 edi
  00908	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  0090e	50		 push	 eax
  0090f	ff d6		 call	 esi

; 1272 : 		SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_INFO), L"");

  00911	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  00916	68 eb 03 00 00	 push	 1003			; 000003ebH
  0091b	53		 push	 ebx
  0091c	ff d7		 call	 edi
  0091e	50		 push	 eax
  0091f	ff d6		 call	 esi

; 1273 : 
; 1274 : 		SetWindowTextW (GetDlgItem (hwndDlg, IDCANCEL), GetString ("IDCLOSE"));

  00921	68 00 00 00 00	 push	 OFFSET ??_C@_07CIAHAGHC@IDCLOSE?$AA@
  00926	e8 00 00 00 00	 call	 _GetString
  0092b	83 c4 04	 add	 esp, 4
  0092e	50		 push	 eax
  0092f	6a 02		 push	 2
  00931	53		 push	 ebx
  00932	ff d7		 call	 edi
  00934	50		 push	 eax
  00935	ff d6		 call	 esi

; 1275 : 		EnableWindow (GetDlgItem (hwndDlg, IDHELP), TRUE);

  00937	6a 01		 push	 1
  00939	6a 09		 push	 9
  0093b	53		 push	 ebx
  0093c	ff d7		 call	 edi
  0093e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00944	50		 push	 eax
  00945	ff d6		 call	 esi

; 1276 : 		EnableWindow (GetDlgItem (hwndDlg, IDC_PREV), FALSE);

  00947	6a 00		 push	 0
  00949	68 03 04 00 00	 push	 1027			; 00000403H
  0094e	53		 push	 ebx
  0094f	ff d7		 call	 edi
  00951	50		 push	 eax
  00952	ff d6		 call	 esi

; 1277 : 		EnableWindow (GetDlgItem (hwndDlg, IDC_NEXT), FALSE);

  00954	6a 00		 push	 0
  00956	68 02 04 00 00	 push	 1026			; 00000402H
  0095b	53		 push	 ebx
  0095c	ff d7		 call	 edi
  0095e	50		 push	 eax
  0095f	ff d6		 call	 esi

; 1278 : 		EnableWindow (GetDlgItem (hwndDlg, IDCANCEL), TRUE);

  00961	6a 01		 push	 1
  00963	6a 02		 push	 2
  00965	53		 push	 ebx
  00966	ff d7		 call	 edi
  00968	50		 push	 eax
  00969	ff d6		 call	 esi

; 1279 : 
; 1280 : 		RefreshUIGFX();

  0096b	e8 00 00 00 00	 call	 _RefreshUIGFX

; 1281 : 
; 1282 : 		Error ("EXTRACTION_FAILED");

  00970	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GODHAKFG@EXTRACTION_FAILED?$AA@
  00975	e8 00 00 00 00	 call	 _Error
  0097a	83 c4 04	 add	 esp, 4

; 1283 : 
; 1284 : 		return 1;

  0097d	e9 e6 01 00 00	 jmp	 $LN13@MainDialog
$LN50@MainDialog:

; 1208 : 
; 1209 : 	case GST_APPMSG_INSTALL_FAILURE:
; 1210 : 		
; 1211 : 		/* Installation failed */
; 1212 : 
; 1213 : 		bInProgress = FALSE;

  00982	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bInProgress@@3HA, 0 ; bInProgress

; 1214 : 
; 1215 : 		NormalCursor ();

  0098c	e8 00 00 00 00	 call	 _NormalCursor

; 1216 : 
; 1217 : 		SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_TITLE), GetString ("INSTALL_FAILED"));

  00991	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@
  00996	e8 00 00 00 00	 call	 _GetString
  0099b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  009a1	83 c4 04	 add	 esp, 4
  009a4	50		 push	 eax
  009a5	68 e9 03 00 00	 push	 1001			; 000003e9H
  009aa	53		 push	 ebx
  009ab	ff d7		 call	 edi
  009ad	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  009b3	50		 push	 eax
  009b4	ff d6		 call	 esi

; 1218 : 		SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_INFO), L"");

  009b6	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  009bb	68 eb 03 00 00	 push	 1003			; 000003ebH
  009c0	53		 push	 ebx
  009c1	ff d7		 call	 edi
  009c3	50		 push	 eax
  009c4	ff d6		 call	 esi

; 1219 : 
; 1220 : 		SetWindowTextW (GetDlgItem (hwndDlg, IDCANCEL), GetString ("IDCLOSE"));

  009c6	68 00 00 00 00	 push	 OFFSET ??_C@_07CIAHAGHC@IDCLOSE?$AA@
  009cb	e8 00 00 00 00	 call	 _GetString
  009d0	83 c4 04	 add	 esp, 4
  009d3	50		 push	 eax
  009d4	6a 02		 push	 2
  009d6	53		 push	 ebx
  009d7	ff d7		 call	 edi
  009d9	50		 push	 eax
  009da	ff d6		 call	 esi

; 1221 : 		EnableWindow (GetDlgItem (hwndDlg, IDHELP), TRUE);

  009dc	6a 01		 push	 1
  009de	6a 09		 push	 9
  009e0	53		 push	 ebx
  009e1	ff d7		 call	 edi
  009e3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  009e9	50		 push	 eax
  009ea	ff d6		 call	 esi

; 1222 : 		EnableWindow (GetDlgItem (hwndDlg, IDC_PREV), FALSE);

  009ec	6a 00		 push	 0
  009ee	68 03 04 00 00	 push	 1027			; 00000403H
  009f3	53		 push	 ebx
  009f4	ff d7		 call	 edi
  009f6	50		 push	 eax
  009f7	ff d6		 call	 esi

; 1223 : 		EnableWindow (GetDlgItem (hwndDlg, IDC_NEXT), FALSE);

  009f9	6a 00		 push	 0
  009fb	68 02 04 00 00	 push	 1026			; 00000402H
  00a00	53		 push	 ebx
  00a01	ff d7		 call	 edi
  00a03	50		 push	 eax
  00a04	ff d6		 call	 esi

; 1224 : 		EnableWindow (GetDlgItem (hwndDlg, IDCANCEL), TRUE);

  00a06	6a 01		 push	 1
  00a08	6a 02		 push	 2
  00a0a	53		 push	 ebx
  00a0b	ff d7		 call	 edi
  00a0d	50		 push	 eax
  00a0e	ff d6		 call	 esi

; 1225 : 
; 1226 : 		RefreshUIGFX();
; 1227 : 
; 1228 : 		return 1;

  00a10	e9 4e 01 00 00	 jmp	 $LN115@MainDialog
$LN51@MainDialog:

; 1229 : 
; 1230 : 	case GST_APPMSG_EXTRACTION_SUCCESS:
; 1231 : 		
; 1232 : 		/* Extraction completed successfully */
; 1233 : 
; 1234 : 		UpdateProgressBarProc(100);

  00a15	6a 64		 push	 100			; 00000064H
  00a17	e8 00 00 00 00	 call	 _UpdateProgressBarProc

; 1235 : 
; 1236 : 		bInProgress = FALSE;

  00a1c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bInProgress@@3HA, 0 ; bInProgress

; 1237 : 		bExtractionSuccessful = TRUE;

  00a26	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bExtractionSuccessful@@3HA, 1 ; bExtractionSuccessful

; 1238 : 
; 1239 : 		NormalCursor ();

  00a30	e8 00 00 00 00	 call	 _NormalCursor

; 1240 : 
; 1241 : 		StatusMessage (hCurPage, "EXTRACTION_FINISHED_INFO");

  00a35	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LLBBBPBJ@EXTRACTION_FINISHED_INFO?$AA@
  00a3a	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00a40	e8 00 00 00 00	 call	 _StatusMessage

; 1242 : 
; 1243 : 		EnableWindow (GetDlgItem (hwndDlg, IDC_PREV), FALSE);

  00a45	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00a4b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a4e	6a 00		 push	 0
  00a50	68 03 04 00 00	 push	 1027			; 00000403H
  00a55	53		 push	 ebx
  00a56	ff d7		 call	 edi
  00a58	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00a5e	50		 push	 eax
  00a5f	ff d6		 call	 esi

; 1244 : 		EnableWindow (GetDlgItem (hwndDlg, IDC_NEXT), TRUE);

  00a61	6a 01		 push	 1
  00a63	68 02 04 00 00	 push	 1026			; 00000402H
  00a68	53		 push	 ebx
  00a69	ff d7		 call	 edi
  00a6b	50		 push	 eax
  00a6c	ff d6		 call	 esi

; 1245 : 		EnableWindow (GetDlgItem (hwndDlg, IDHELP), FALSE);

  00a6e	6a 00		 push	 0
  00a70	6a 09		 push	 9
  00a72	53		 push	 ebx
  00a73	ff d7		 call	 edi
  00a75	50		 push	 eax
  00a76	ff d6		 call	 esi

; 1246 : 		EnableWindow (GetDlgItem (hwndDlg, IDCANCEL), FALSE);

  00a78	6a 00		 push	 0
  00a7a	6a 02		 push	 2
  00a7c	53		 push	 ebx
  00a7d	ff d7		 call	 edi
  00a7f	50		 push	 eax
  00a80	ff d6		 call	 esi

; 1247 : 
; 1248 : 		RefreshUIGFX ();

  00a82	e8 00 00 00 00	 call	 _RefreshUIGFX

; 1249 : 
; 1250 : 		Info ("EXTRACTION_FINISHED_INFO");

  00a87	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LLBBBPBJ@EXTRACTION_FINISHED_INFO?$AA@
  00a8c	e8 00 00 00 00	 call	 _Info

; 1251 : 
; 1252 : 		SetWindowTextW (GetDlgItem (hwndDlg, IDC_NEXT), GetString ("FINALIZE"));

  00a91	68 00 00 00 00	 push	 OFFSET ??_C@_08MFKGCNCO@FINALIZE?$AA@
  00a96	e8 00 00 00 00	 call	 _GetString
  00a9b	83 c4 08	 add	 esp, 8
  00a9e	50		 push	 eax
  00a9f	68 02 04 00 00	 push	 1026			; 00000402H
  00aa4	53		 push	 ebx
  00aa5	ff d7		 call	 edi
  00aa7	50		 push	 eax
  00aa8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 1253 : 
; 1254 : 		nCurPageNo = DONATIONS_PAGE;
; 1255 : 		LoadPage (hwndDlg, DONATIONS_PAGE);

  00aae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00ab3	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 6 ; nCurPageNo
  00abd	85 c0		 test	 eax, eax
  00abf	74 07		 je	 SHORT $LN107@MainDialog
  00ac1	50		 push	 eax
  00ac2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$LN107@MainDialog:
  00ac8	6a 01		 push	 1
  00aca	6a 00		 push	 0
  00acc	68 07 04 00 00	 push	 1031			; 00000407H
  00ad1	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00ad7	ff d7		 call	 edi
  00ad9	50		 push	 eax
  00ada	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
  00ae0	8d 45 ec	 lea	 eax, DWORD PTR _rW$7[ebp]
  00ae3	50		 push	 eax
  00ae4	68 05 04 00 00	 push	 1029			; 00000405H
  00ae9	53		 push	 ebx
  00aea	ff d7		 call	 edi
  00aec	50		 push	 eax
  00aed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00af3	6a 00		 push	 0
  00af5	68 00 00 00 00	 push	 OFFSET _PageDialogProc@16
  00afa	53		 push	 ebx
  00afb	6a 72		 push	 114			; 00000072H
  00afd	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00b03	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?nCurPageNo@@3HA, 6 ; nCurPageNo
  00b0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamW@20
  00b13	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000000000000000000002d0000000f
  00b1a	a3 00 00 00 00	 mov	 DWORD PTR ?hCurPage@@3PAUHWND__@@A, eax ; hCurPage
  00b1f	8d 45 dc	 lea	 eax, DWORD PTR _rD$4[ebp]
  00b22	50		 push	 eax
  00b23	53		 push	 ebx
  00b24	0f 11 45 dc	 movups	 XMMWORD PTR _rD$4[ebp], xmm0
  00b28	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapDialogRect@8
  00b2e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00b34	85 c9		 test	 ecx, ecx
  00b36	74 2b		 je	 SHORT $LN115@MainDialog
  00b38	8b 45 f8	 mov	 eax, DWORD PTR _rW$7[ebp+12]
  00b3b	2b 45 f0	 sub	 eax, DWORD PTR _rW$7[ebp+4]
  00b3e	6a 01		 push	 1
  00b40	50		 push	 eax
  00b41	8b 45 f4	 mov	 eax, DWORD PTR _rW$7[ebp+8]
  00b44	2b 45 ec	 sub	 eax, DWORD PTR _rW$7[ebp]
  00b47	50		 push	 eax
  00b48	ff 75 e0	 push	 DWORD PTR _rD$4[ebp+4]
  00b4b	ff 75 dc	 push	 DWORD PTR _rD$4[ebp]
  00b4e	51		 push	 ecx
  00b4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  00b55	6a 01		 push	 1
  00b57	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00b5d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN115@MainDialog:
  00b63	e8 00 00 00 00	 call	 _RefreshUIGFX
$LN13@MainDialog:

; 1334 : 	}
; 1335 : 
; 1336 : 	return 0;
; 1337 : }

  00b68	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b6b	b8 01 00 00 00	 mov	 eax, 1
  00b70	5f		 pop	 edi
  00b71	5e		 pop	 esi
  00b72	33 cd		 xor	 ecx, ebp
  00b74	5b		 pop	 ebx
  00b75	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b7a	8b e5		 mov	 esp, ebp
  00b7c	5d		 pop	 ebp
  00b7d	c2 10 00	 ret	 16			; 00000010H
$LN125@MainDialog:
  00b80	00 00 00 00	 DD	 $LN43@MainDialog
  00b84	00 00 00 00	 DD	 $LN53@MainDialog
  00b88	00 00 00 00	 DD	 $LN10@MainDialog
  00b8c	00 00 00 00	 DD	 $LN12@MainDialog
  00b90	00 00 00 00	 DD	 $LN10@MainDialog
$LN117@MainDialog:
  00b94	00		 DB	 0
  00b95	01		 DB	 1
  00b96	04		 DB	 4
  00b97	04		 DB	 4
  00b98	04		 DB	 4
  00b99	02		 DB	 2
  00b9a	04		 DB	 4
  00b9b	04		 DB	 4
  00b9c	04		 DB	 4
  00b9d	04		 DB	 4
  00b9e	04		 DB	 4
  00b9f	04		 DB	 4
  00ba0	04		 DB	 4
  00ba1	04		 DB	 4
  00ba2	04		 DB	 4
  00ba3	04		 DB	 4
  00ba4	04		 DB	 4
  00ba5	04		 DB	 4
  00ba6	04		 DB	 4
  00ba7	04		 DB	 4
  00ba8	04		 DB	 4
  00ba9	04		 DB	 4
  00baa	04		 DB	 4
  00bab	04		 DB	 4
  00bac	04		 DB	 4
  00bad	04		 DB	 4
  00bae	04		 DB	 4
  00baf	04		 DB	 4
  00bb0	04		 DB	 4
  00bb1	04		 DB	 4
  00bb2	04		 DB	 4
  00bb3	04		 DB	 4
  00bb4	04		 DB	 4
  00bb5	04		 DB	 4
  00bb6	04		 DB	 4
  00bb7	04		 DB	 4
  00bb8	04		 DB	 4
  00bb9	04		 DB	 4
  00bba	04		 DB	 4
  00bbb	04		 DB	 4
  00bbc	04		 DB	 4
  00bbd	04		 DB	 4
  00bbe	04		 DB	 4
  00bbf	04		 DB	 4
  00bc0	04		 DB	 4
  00bc1	04		 DB	 4
  00bc2	04		 DB	 4
  00bc3	04		 DB	 4
  00bc4	04		 DB	 4
  00bc5	04		 DB	 4
  00bc6	04		 DB	 4
  00bc7	04		 DB	 4
  00bc8	04		 DB	 4
  00bc9	04		 DB	 4
  00bca	04		 DB	 4
  00bcb	04		 DB	 4
  00bcc	04		 DB	 4
  00bcd	04		 DB	 4
  00bce	04		 DB	 4
  00bcf	04		 DB	 4
  00bd0	04		 DB	 4
  00bd1	04		 DB	 4
  00bd2	04		 DB	 4
  00bd3	04		 DB	 4
  00bd4	04		 DB	 4
  00bd5	04		 DB	 4
  00bd6	04		 DB	 4
  00bd7	04		 DB	 4
  00bd8	03		 DB	 3
_MainDialogProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\wizard.c
;	COMDAT _PageDialogProc@16
_TEXT	SEGMENT
_driverVersion$1 = -692					; size = 4
_hwndDlg$GSCopy$1$ = -688				; size = 4
_driverVersion$2 = -688					; size = 4
_tmpPaintStruct$3 = -684				; size = 64
$T4 = -620						; size = 24
$T5 = -596						; size = 24
_lf$6 = -572						; size = 92
_trect$7 = -480						; size = 16
_tmpstr$8 = -464					; size = 200
_path$9 = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_PageDialogProc@16 PROC					; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 02 00
	00		 sub	 esp, 692		; 000002b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]

; 257  : 	static char PageDebugId[128];
; 258  : 	WORD lw = LOWORD (wParam);
; 259  : 	WORD hw = HIWORD (wParam);

  00016	8b d1		 mov	 edx, ecx

; 260  : 
; 261  : 	hCurPage = hwndDlg;
; 262  : 
; 263  : 	switch (uMsg)

  00018	8b 45 0c	 mov	 eax, DWORD PTR _uMsg$[ebp]
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  00020	c1 ea 10	 shr	 edx, 16			; 00000010H
  00023	89 bd 50 fd ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], edi
  00029	89 3d 00 00 00
	00		 mov	 DWORD PTR ?hCurPage@@3PAUHWND__@@A, edi ; hCurPage
  0002f	83 f8 53	 cmp	 eax, 83			; 00000053H
  00032	0f 87 a1 01 00
	00		 ja	 $LN85@PageDialog
  00038	0f 84 65 01 00
	00		 je	 $LN47@PageDialog
  0003e	83 e8 0f	 sub	 eax, 15			; 0000000fH
  00041	74 3a		 je	 SHORT $LN72@PageDialog
  00043	83 e8 05	 sub	 eax, 5
  00046	74 21		 je	 SHORT $LN12@PageDialog
  00048	83 e8 02	 sub	 eax, 2
  0004b	75 1c		 jne	 SHORT $LN12@PageDialog

; 629  : 
; 630  : 	case WM_ENDSESSION:
; 631  : 
; 632  : 		bPromptTutorial = FALSE;
; 633  : 		bPromptReleaseNotes = FALSE;
; 634  : 
; 635  : 		EndDialog (MainDlg, 0);

  0004d	50		 push	 eax
  0004e	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00054	a3 00 00 00 00	 mov	 DWORD PTR _bPromptTutorial, eax
  00059	a3 00 00 00 00	 mov	 DWORD PTR _bPromptReleaseNotes, eax
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 636  : 		localcleanup ();

  00064	e8 00 00 00 00	 call	 _localcleanup
$LN12@PageDialog:

; 637  : 		return 0;

  00069	5f		 pop	 edi
  0006a	33 c0		 xor	 eax, eax
  0006c	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 10 00	 ret	 16			; 00000010H
$LN72@PageDialog:

; 745  : 			}
; 746  : 		}
; 747  : 
; 748  : 		return 0;
; 749  : 
; 750  : 
; 751  : 	case WM_PAINT:
; 752  : 
; 753  : 		if (nCurPageNo == DONATIONS_PAGE)

  0007d	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR ?nCurPageNo@@3HA, 6 ; nCurPageNo
  00084	75 e3		 jne	 SHORT $LN12@PageDialog

; 754  : 		{
; 755  : 			PAINTSTRUCT tmpPaintStruct;
; 756  : 			HDC hdc = BeginPaint (hCurPage, &tmpPaintStruct); 

  00086	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR _tmpPaintStruct$3[ebp]
  0008c	50		 push	 eax
  0008d	57		 push	 edi
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BeginPaint@8
  00094	8b f0		 mov	 esi, eax

; 757  : 
; 758  : 			if (hdc == NULL)

  00096	85 f6		 test	 esi, esi
  00098	75 05		 jne	 SHORT $LN74@PageDialog

; 759  : 				AbortProcessSilent ();

  0009a	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN74@PageDialog:

; 760  : 
; 761  : 			SelectObject (hdc, hDonTextFont);

  0009f	ff 35 00 00 00
	00		 push	 DWORD PTR ?hDonTextFont@@3PAUHFONT__@@A
  000a5	56		 push	 esi
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 762  : 
; 763  : 			if (DonColorSchemeId != 2)

  000ac	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?DonColorSchemeId@@3HA, 2
  000b3	74 77		 je	 SHORT $LN75@PageDialog

; 764  : 			{
; 765  : 				HBRUSH tmpBrush = CreateSolidBrush (DonBkgColor);

  000b5	ff 35 00 00 00
	00		 push	 DWORD PTR ?DonBkgColor@@3KA
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  000c1	8b f8		 mov	 edi, eax

; 766  : 
; 767  : 				if (tmpBrush == NULL)

  000c3	85 ff		 test	 edi, edi
  000c5	75 05		 jne	 SHORT $LN76@PageDialog

; 768  : 					AbortProcessSilent ();

  000c7	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN76@PageDialog:

; 769  : 
; 770  : 				RECT trect;
; 771  : 
; 772  : 				trect.left = 0;
; 773  : 				trect.right = CompensateXDPI (526);

  000cc	68 0e 02 00 00	 push	 526			; 0000020eH
  000d1	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _trect$7[ebp], 0
  000db	e8 00 00 00 00	 call	 _CompensateXDPI

; 774  : 				trect.top  = 0;
; 775  : 				trect.bottom = CompensateYDPI (246);

  000e0	68 f6 00 00 00	 push	 246			; 000000f6H
  000e5	89 85 28 fe ff
	ff		 mov	 DWORD PTR _trect$7[ebp+8], eax
  000eb	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _trect$7[ebp+4], 0
  000f5	e8 00 00 00 00	 call	 _CompensateYDPI
  000fa	83 c4 08	 add	 esp, 8
  000fd	89 85 2c fe ff
	ff		 mov	 DWORD PTR _trect$7[ebp+12], eax

; 776  : 
; 777  : 				FillRect (hdc, &trect, tmpBrush);

  00103	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR _trect$7[ebp]
  00109	57		 push	 edi
  0010a	50		 push	 eax
  0010b	56		 push	 esi
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 778  : 
; 779  : 				SetTextColor (hdc, DonTextColor);

  00112	ff 35 00 00 00
	00		 push	 DWORD PTR ?DonTextColor@@3KA
  00118	56		 push	 esi
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 780  : 				SetBkColor (hdc, DonBkgColor);

  0011f	ff 35 00 00 00
	00		 push	 DWORD PTR ?DonBkgColor@@3KA
  00125	56		 push	 esi
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
$LN75@PageDialog:

; 781  : 			}
; 782  : 
; 783  : 			SetTextAlign(hdc, TA_CENTER);

  0012c	6a 06		 push	 6
  0012e	56		 push	 esi
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextAlign@8

; 784  : 
; 785  : 			TextOutW (hdc,

  00135	83 3d 14 00 00
	00 08		 cmp	 DWORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+20, 8
  0013c	b8 00 00 00 00	 mov	 eax, OFFSET ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; DonText
  00141	ff 35 10 00 00
	00		 push	 DWORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16
  00147	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  0014e	50		 push	 eax
  0014f	6a 46		 push	 70			; 00000046H
  00151	e8 00 00 00 00	 call	 _CompensateYDPI
  00156	83 c4 04	 add	 esp, 4
  00159	50		 push	 eax
  0015a	68 02 01 00 00	 push	 258			; 00000102H
  0015f	e8 00 00 00 00	 call	 _CompensateXDPI
  00164	83 c4 04	 add	 esp, 4
  00167	50		 push	 eax
  00168	56		 push	 esi
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TextOutW@20

; 786  : 				CompensateXDPI (258),
; 787  : 				CompensateYDPI (70),
; 788  : 				DonText.c_str(), 
; 789  : 				DonText.length()); 
; 790  : 			
; 791  : 			EndPaint (hCurPage, &tmpPaintStruct); 

  0016f	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR _tmpPaintStruct$3[ebp]
  00175	50		 push	 eax
  00176	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndPaint@8

; 792  : 			ReleaseDC (hCurPage, hdc);

  00182	56		 push	 esi
  00183	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  0018f	5f		 pop	 edi

; 793  : 		}
; 794  : 		return 0; 

  00190	33 c0		 xor	 eax, eax
  00192	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  00193	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00196	33 cd		 xor	 ecx, ebp
  00198	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c2 10 00	 ret	 16			; 00000010H
$LN47@PageDialog:

; 620  : 		}
; 621  : 
; 622  : 		return 0;
; 623  : 
; 624  : 	case WM_HELP:
; 625  : 		if (bLicenseAccepted)

  001a3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bLicenseAccepted@@3HA, 0 ; bLicenseAccepted
  001aa	74 16		 je	 SHORT $LN48@PageDialog

; 626  : 			OpenPageHelp (GetParent (hwndDlg), nCurPageNo);

  001ac	ff 35 00 00 00
	00		 push	 DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  001b2	57		 push	 edi
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 _OpenPageHelp
  001bf	83 c4 08	 add	 esp, 8
$LN48@PageDialog:

; 627  : 
; 628  : 		return 1;

  001c2	5f		 pop	 edi
  001c3	b8 01 00 00 00	 mov	 eax, 1
  001c8	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  001c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cc	33 cd		 xor	 ecx, ebp
  001ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d3	8b e5		 mov	 esp, ebp
  001d5	5d		 pop	 ebp
  001d6	c2 10 00	 ret	 16			; 00000010H
$LN85@PageDialog:

; 260  : 
; 261  : 	hCurPage = hwndDlg;
; 262  : 
; 263  : 	switch (uMsg)

  001d9	2d 10 01 00 00	 sub	 eax, 272		; 00000110H
  001de	0f 84 6a 03 00
	00		 je	 $LN14@PageDialog
  001e4	83 e8 01	 sub	 eax, 1
  001e7	74 2c		 je	 SHORT $LN50@PageDialog
  001e9	83 e8 27	 sub	 eax, 39			; 00000027H
  001ec	0f 85 77 fe ff
	ff		 jne	 $LN12@PageDialog

; 795  : 
; 796  : 
; 797  : 	case WM_CTLCOLORSTATIC:
; 798  : 
; 799  : 		/* This maintains the background under the transparent-backround texts */
; 800  : 
; 801  : 		SetBkMode ((HDC) wParam, TRANSPARENT);

  001f2	6a 01		 push	 1
  001f4	51		 push	 ecx
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkMode@8

; 802  : 		return ((LONG) (HBRUSH) (GetStockObject (NULL_BRUSH)));

  001fb	6a 05		 push	 5
  001fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStockObject@4
  00203	5f		 pop	 edi
  00204	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  00205	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00208	33 cd		 xor	 ecx, ebp
  0020a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020f	8b e5		 mov	 esp, ebp
  00211	5d		 pop	 ebp
  00212	c2 10 00	 ret	 16			; 00000010H
$LN50@PageDialog:

; 638  : 
; 639  : 
; 640  : 	case WM_COMMAND:
; 641  : 
; 642  : 		if (lw == IDC_AGREE && nCurPageNo == INTRO_PAGE)

  00215	b8 fe 03 00 00	 mov	 eax, 1022		; 000003feH
  0021a	66 3b c8	 cmp	 cx, ax
  0021d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  00222	75 4d		 jne	 SHORT $LN51@PageDialog
  00224	85 c0		 test	 eax, eax
  00226	0f 85 96 00 00
	00		 jne	 $LN53@PageDialog

; 643  : 		{
; 644  : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), IsButtonChecked (GetDlgItem (hwndDlg, IDC_AGREE)));

  0022c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00232	68 fe 03 00 00	 push	 1022			; 000003feH
  00237	57		 push	 edi
  00238	ff d6		 call	 esi
  0023a	50		 push	 eax
  0023b	e8 00 00 00 00	 call	 _IsButtonChecked
  00240	83 c4 04	 add	 esp, 4
  00243	50		 push	 eax
  00244	68 02 04 00 00	 push	 1026			; 00000402H
  00249	57		 push	 edi
  0024a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00250	50		 push	 eax
  00251	ff d6		 call	 esi
  00253	50		 push	 eax
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  0025a	5f		 pop	 edi

; 645  : 			return 1;

  0025b	b8 01 00 00 00	 mov	 eax, 1
  00260	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  00261	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00264	33 cd		 xor	 ecx, ebp
  00266	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026b	8b e5		 mov	 esp, ebp
  0026d	5d		 pop	 ebp
  0026e	c2 10 00	 ret	 16			; 00000010H
$LN51@PageDialog:

; 646  : 		}
; 647  : 
; 648  : 		if (lw == IDC_WIZARD_MODE_EXTRACT_ONLY && nCurPageNo == WIZARD_MODE_PAGE)

  00271	be 01 04 00 00	 mov	 esi, 1025		; 00000401H
  00276	66 3b ce	 cmp	 cx, si
  00279	75 1c		 jne	 SHORT $LN52@PageDialog
  0027b	83 f8 01	 cmp	 eax, 1
  0027e	75 42		 jne	 SHORT $LN53@PageDialog

; 649  : 		{
; 650  : 			bExtractOnly = TRUE;

  00280	5f		 pop	 edi
  00281	a3 00 00 00 00	 mov	 DWORD PTR ?bExtractOnly@@3HA, eax ; bExtractOnly
  00286	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  00287	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028a	33 cd		 xor	 ecx, ebp
  0028c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00291	8b e5		 mov	 esp, ebp
  00293	5d		 pop	 ebp
  00294	c2 10 00	 ret	 16			; 00000010H
$LN52@PageDialog:

; 651  : 			return 1;
; 652  : 		}
; 653  : 
; 654  : 		if (lw == IDC_WIZARD_MODE_INSTALL && nCurPageNo == WIZARD_MODE_PAGE)

  00297	be 00 04 00 00	 mov	 esi, 1024		; 00000400H
  0029c	66 3b ce	 cmp	 cx, si
  0029f	75 21		 jne	 SHORT $LN53@PageDialog
  002a1	83 f8 01	 cmp	 eax, 1
  002a4	75 1c		 jne	 SHORT $LN53@PageDialog

; 655  : 		{
; 656  : 			bExtractOnly = FALSE;

  002a6	5f		 pop	 edi
  002a7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bExtractOnly@@3HA, 0 ; bExtractOnly
  002b1	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  002b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b5	33 cd		 xor	 ecx, ebp
  002b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bc	8b e5		 mov	 esp, ebp
  002be	5d		 pop	 ebp
  002bf	c2 10 00	 ret	 16			; 00000010H
$LN53@PageDialog:

; 657  : 			return 1;
; 658  : 		}
; 659  : 
; 660  : 		if ( nCurPageNo == EXTRACTION_OPTIONS_PAGE && hw == EN_CHANGE )

  002c2	83 f8 04	 cmp	 eax, 4
  002c5	0f 85 16 01 00
	00		 jne	 $LN54@PageDialog
  002cb	b8 00 03 00 00	 mov	 eax, 768		; 00000300H
  002d0	66 3b d0	 cmp	 dx, ax
  002d3	75 49		 jne	 SHORT $LN141@PageDialog
$LN156@PageDialog:

; 661  : 		{
; 662  : 			EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), (GetWindowTextLength (GetDlgItem (hCurPage, IDC_DESTINATION)) > 1));

  002d5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  002db	68 e8 03 00 00	 push	 1000			; 000003e8H
  002e0	57		 push	 edi
  002e1	ff d6		 call	 esi
  002e3	50		 push	 eax
  002e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  002ea	33 c9		 xor	 ecx, ecx
  002ec	83 f8 01	 cmp	 eax, 1
  002ef	0f 9f c1	 setg	 cl
  002f2	51		 push	 ecx
  002f3	68 02 04 00 00	 push	 1026			; 00000402H
  002f8	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  002fe	ff d6		 call	 esi
  00300	50		 push	 eax
  00301	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  00307	5f		 pop	 edi

; 663  : 			return 1;

  00308	b8 01 00 00 00	 mov	 eax, 1
  0030d	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  0030e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00311	33 cd		 xor	 ecx, ebp
  00313	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00318	8b e5		 mov	 esp, ebp
  0031a	5d		 pop	 ebp
  0031b	c2 10 00	 ret	 16			; 00000010H
$LN141@PageDialog:

; 667  : 		{
; 668  : 			EnableWindow (GetDlgItem (MainDlg, IDC_NEXT), (GetWindowTextLength (GetDlgItem (hCurPage, IDC_DESTINATION)) > 1));
; 669  : 			return 1;
; 670  : 		}
; 671  : 
; 672  : 		if ( nCurPageNo == EXTRACTION_OPTIONS_PAGE )
; 673  : 		{
; 674  : 			switch (lw)

  0031e	0f b7 c1	 movzx	 eax, cx
  00321	2d ea 03 00 00	 sub	 eax, 1002		; 000003eaH
  00326	74 3a		 je	 SHORT $LN57@PageDialog
  00328	83 e8 13	 sub	 eax, 19			; 00000013H
  0032b	0f 85 38 fd ff
	ff		 jne	 $LN12@PageDialog

; 686  : 
; 687  : 			case IDC_OPEN_CONTAINING_FOLDER:
; 688  : 				bOpenContainingFolder = IsButtonChecked (GetDlgItem (hCurPage, IDC_OPEN_CONTAINING_FOLDER));

  00331	68 fd 03 00 00	 push	 1021			; 000003fdH
  00336	57		 push	 edi
  00337	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 _IsButtonChecked
  00343	83 c4 04	 add	 esp, 4
  00346	a3 00 00 00 00	 mov	 DWORD PTR ?bOpenContainingFolder@@3HA, eax ; bOpenContainingFolder

; 689  : 				return 1;

  0034b	b8 01 00 00 00	 mov	 eax, 1
  00350	5f		 pop	 edi
  00351	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  00352	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00355	33 cd		 xor	 ecx, ebp
  00357	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035c	8b e5		 mov	 esp, ebp
  0035e	5d		 pop	 ebp
  0035f	c2 10 00	 ret	 16			; 00000010H
$LN57@PageDialog:

; 675  : 			{
; 676  : 			case IDC_BROWSE:
; 677  : 				if (BrowseDirectories (hwndDlg, "SELECT_DEST_DIR", WizardDestExtractPath))

  00362	68 00 00 00 00	 push	 OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  00367	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DJBAGGGN@SELECT_DEST_DIR?$AA@
  0036c	57		 push	 edi
  0036d	e8 00 00 00 00	 call	 _BrowseDirectories
  00372	83 c4 0c	 add	 esp, 12			; 0000000cH
  00375	85 c0		 test	 eax, eax
  00377	0f 84 45 fe ff
	ff		 je	 $LN48@PageDialog

; 678  : 				{
; 679  : 					if (WizardDestExtractPath [strlen(WizardDestExtractPath)-1] != '\\')

  0037d	b9 00 00 00 00	 mov	 ecx, OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  00382	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL143@PageDialog:
  00385	8a 01		 mov	 al, BYTE PTR [ecx]
  00387	41		 inc	 ecx
  00388	84 c0		 test	 al, al
  0038a	75 f9		 jne	 SHORT $LL143@PageDialog
  0038c	2b ca		 sub	 ecx, edx
  0038e	80 b9 ff ff ff
	ff 5c		 cmp	 BYTE PTR ?WizardDestExtractPath@@3PADA[ecx-1], 92 ; 0000005cH
  00395	74 22		 je	 SHORT $LN59@PageDialog

; 680  : 					{
; 681  : 						strcat (WizardDestExtractPath, "\\");

  00397	bf 00 00 00 00	 mov	 edi, OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  0039c	4f		 dec	 edi
  0039d	0f 1f 00	 npad	 3
$LL144@PageDialog:
  003a0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  003a3	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  003a6	84 c0		 test	 al, al
  003a8	75 f6		 jne	 SHORT $LL144@PageDialog
  003aa	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  003b0	66 89 07	 mov	 WORD PTR [edi], ax
  003b3	8b bd 50 fd ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
$LN59@PageDialog:

; 682  : 					}
; 683  : 					SetDlgItemText (hwndDlg, IDC_DESTINATION, WizardDestExtractPath);

  003b9	68 00 00 00 00	 push	 OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
$LN157@PageDialog:
  003be	68 e8 03 00 00	 push	 1000			; 000003e8H
  003c3	57		 push	 edi
  003c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextA@12
  003ca	5f		 pop	 edi

; 684  : 				}
; 685  : 				return 1;

  003cb	b8 01 00 00 00	 mov	 eax, 1
  003d0	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  003d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d4	33 cd		 xor	 ecx, ebp
  003d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003db	8b e5		 mov	 esp, ebp
  003dd	5d		 pop	 ebp
  003de	c2 10 00	 ret	 16			; 00000010H
$LN54@PageDialog:

; 664  : 		}
; 665  : 
; 666  : 		if ( nCurPageNo == INSTALL_OPTIONS_PAGE && hw == EN_CHANGE )

  003e1	83 f8 02	 cmp	 eax, 2
  003e4	0f 85 24 01 00
	00		 jne	 $LN10@PageDialog
  003ea	b8 00 03 00 00	 mov	 eax, 768		; 00000300H
  003ef	66 3b d0	 cmp	 dx, ax
  003f2	0f 84 dd fe ff
	ff		 je	 $LN156@PageDialog

; 690  : 			}
; 691  : 		}
; 692  : 
; 693  : 		if ( nCurPageNo == INSTALL_OPTIONS_PAGE )
; 694  : 		{
; 695  : 			switch (lw)

  003f8	0f b7 c1	 movzx	 eax, cx
  003fb	05 16 fc ff ff	 add	 eax, -1002		; fffffc16H
  00400	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00403	0f 87 60 fc ff
	ff		 ja	 $LN12@PageDialog
  00409	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN160@PageDialog[eax*4]
$LN62@PageDialog:

; 696  : 			{
; 697  : 			case IDC_BROWSE:
; 698  : 				if (BrowseDirectories (hwndDlg, "SELECT_DEST_DIR", WizardDestInstallPath))

  00410	68 00 00 00 00	 push	 OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  00415	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DJBAGGGN@SELECT_DEST_DIR?$AA@
  0041a	57		 push	 edi
  0041b	e8 00 00 00 00	 call	 _BrowseDirectories
  00420	83 c4 0c	 add	 esp, 12			; 0000000cH
  00423	85 c0		 test	 eax, eax
  00425	0f 84 97 fd ff
	ff		 je	 $LN48@PageDialog

; 699  : 				{
; 700  : 					if (WizardDestInstallPath [strlen(WizardDestInstallPath)-1] != '\\')

  0042b	b9 00 00 00 00	 mov	 ecx, OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  00430	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL145@PageDialog:
  00433	8a 01		 mov	 al, BYTE PTR [ecx]
  00435	41		 inc	 ecx
  00436	84 c0		 test	 al, al
  00438	75 f9		 jne	 SHORT $LL145@PageDialog
  0043a	2b ca		 sub	 ecx, edx
  0043c	80 b9 ff ff ff
	ff 5c		 cmp	 BYTE PTR ?WizardDestInstallPath@@3PADA[ecx-1], 92 ; 0000005cH
  00443	74 24		 je	 SHORT $LN64@PageDialog

; 701  : 					{
; 702  : 						strcat (WizardDestInstallPath, "\\");

  00445	bf 00 00 00 00	 mov	 edi, OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  0044a	4f		 dec	 edi
  0044b	0f 1f 44 00 00	 npad	 5
$LL146@PageDialog:
  00450	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00453	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00456	84 c0		 test	 al, al
  00458	75 f6		 jne	 SHORT $LL146@PageDialog
  0045a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  00460	66 89 07	 mov	 WORD PTR [edi], ax
  00463	8b bd 50 fd ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
$LN64@PageDialog:

; 703  : 					}
; 704  : 					SetDlgItemText (hwndDlg, IDC_DESTINATION, WizardDestInstallPath);

  00469	68 00 00 00 00	 push	 OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath

; 705  : 				}
; 706  : 				return 1;

  0046e	e9 4b ff ff ff	 jmp	 $LN157@PageDialog
$LN65@PageDialog:

; 707  : 
; 708  : 			case IDC_SYSTEM_RESTORE:
; 709  : 				bSystemRestore = IsButtonChecked (GetDlgItem (hCurPage, IDC_SYSTEM_RESTORE));

  00473	68 f3 03 00 00	 push	 1011			; 000003f3H
  00478	57		 push	 edi
  00479	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0047f	50		 push	 eax
  00480	e8 00 00 00 00	 call	 _IsButtonChecked
  00485	83 c4 04	 add	 esp, 4
  00488	a3 00 00 00 00	 mov	 DWORD PTR _bSystemRestore, eax

; 710  : 				return 1;

  0048d	e9 30 fd ff ff	 jmp	 $LN48@PageDialog
$LN66@PageDialog:

; 711  : 
; 712  : 			case IDC_ALL_USERS:
; 713  : 				bForAllUsers = IsButtonChecked (GetDlgItem (hCurPage, IDC_ALL_USERS));

  00492	68 f5 03 00 00	 push	 1013			; 000003f5H
  00497	57		 push	 edi
  00498	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0049e	50		 push	 eax
  0049f	e8 00 00 00 00	 call	 _IsButtonChecked
  004a4	83 c4 04	 add	 esp, 4
  004a7	a3 00 00 00 00	 mov	 DWORD PTR _bForAllUsers, eax

; 714  : 				return 1;

  004ac	e9 11 fd ff ff	 jmp	 $LN48@PageDialog
$LN67@PageDialog:

; 715  : 
; 716  : 			case IDC_FILE_TYPE:
; 717  : 				bRegisterFileExt = IsButtonChecked (GetDlgItem (hCurPage, IDC_FILE_TYPE));

  004b1	68 f0 03 00 00	 push	 1008			; 000003f0H
  004b6	57		 push	 edi
  004b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  004bd	50		 push	 eax
  004be	e8 00 00 00 00	 call	 _IsButtonChecked
  004c3	83 c4 04	 add	 esp, 4
  004c6	a3 00 00 00 00	 mov	 DWORD PTR _bRegisterFileExt, eax

; 718  : 				return 1;

  004cb	e9 f2 fc ff ff	 jmp	 $LN48@PageDialog
$LN68@PageDialog:

; 719  : 
; 720  : 			case IDC_PROG_GROUP:
; 721  : 				bAddToStartMenu = IsButtonChecked (GetDlgItem (hCurPage, IDC_PROG_GROUP));

  004d0	68 f2 03 00 00	 push	 1010			; 000003f2H
  004d5	57		 push	 edi
  004d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  004dc	50		 push	 eax
  004dd	e8 00 00 00 00	 call	 _IsButtonChecked
  004e2	83 c4 04	 add	 esp, 4
  004e5	a3 00 00 00 00	 mov	 DWORD PTR _bAddToStartMenu, eax

; 722  : 				return 1;

  004ea	e9 d3 fc ff ff	 jmp	 $LN48@PageDialog
$LN69@PageDialog:

; 723  : 
; 724  : 			case IDC_DESKTOP_ICON:
; 725  : 				bDesktopIcon = IsButtonChecked (GetDlgItem (hCurPage, IDC_DESKTOP_ICON));

  004ef	68 f4 03 00 00	 push	 1012			; 000003f4H
  004f4	57		 push	 edi
  004f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  004fb	50		 push	 eax
  004fc	e8 00 00 00 00	 call	 _IsButtonChecked
  00501	83 c4 04	 add	 esp, 4
  00504	a3 00 00 00 00	 mov	 DWORD PTR _bDesktopIcon, eax

; 726  : 				return 1;

  00509	e9 b4 fc ff ff	 jmp	 $LN48@PageDialog
$LN10@PageDialog:

; 727  : 
; 728  : 			}
; 729  : 		}
; 730  : 
; 731  : 		if (nCurPageNo == DONATIONS_PAGE)

  0050e	83 f8 06	 cmp	 eax, 6
  00511	0f 85 52 fb ff
	ff		 jne	 $LN12@PageDialog

; 732  : 		{
; 733  : 			switch (lw)

  00517	b8 08 04 00 00	 mov	 eax, 1032		; 00000408H
  0051c	66 3b c8	 cmp	 cx, ax
  0051f	0f 85 44 fb ff
	ff		 jne	 $LN12@PageDialog

; 734  : 			{
; 735  : 			case IDC_DONATE:
; 736  : 				{
; 737  : 					char tmpstr [200];
; 738  : 
; 739  : 					sprintf (tmpstr, "&ref=%d", DonColorSchemeId);

  00525	ff 35 00 00 00
	00		 push	 DWORD PTR ?DonColorSchemeId@@3HA
  0052b	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _tmpstr$8[ebp]
  00531	68 00 00 00 00	 push	 OFFSET ??_C@_07KNCOJMJF@?$CGref?$DN?$CFd?$AA@
  00536	50		 push	 eax
  00537	e8 00 00 00 00	 call	 _sprintf

; 740  : 
; 741  : 					//Applink ("donate", FALSE, tmpstr);
; 742  : 					Extlink("http://www.gostcrypt.org/redirect.php?a=7");

  0053c	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KPOBPAGF@http?3?1?1www?4gostcrypt?4org?1redirec@
  00541	e8 00 00 00 00	 call	 _Extlink
  00546	83 c4 10	 add	 esp, 16			; 00000010H

; 743  : 				}
; 744  : 				return 1;

  00549	e9 74 fc ff ff	 jmp	 $LN48@PageDialog
$LN14@PageDialog:
  0054e	53		 push	 ebx

; 264  : 	{
; 265  : 	case WM_INITDIALOG:
; 266  : 		LocalizeDialog (hwndDlg, "IDD_INSTL_DLG");

  0054f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MGHONKG@IDD_INSTL_DLG?$AA@
  00554	57		 push	 edi
  00555	e8 00 00 00 00	 call	 _LocalizeDialog

; 267  : 
; 268  : 		sprintf (PageDebugId, "SETUP_WIZARD_PAGE_%d", nCurPageNo);

  0055a	ff 35 00 00 00
	00		 push	 DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  00560	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EOKBACHI@SETUP_WIZARD_PAGE_?$CFd?$AA@
  00565	68 00 00 00 00	 push	 OFFSET ?PageDebugId@?1??PageDialogProc@@9@16@4PADA
  0056a	e8 00 00 00 00	 call	 _sprintf

; 269  : 		LastDialogId = PageDebugId;
; 270  : 
; 271  : 		switch (nCurPageNo)

  0056f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nCurPageNo@@3HA ; nCurPageNo
  00574	83 c4 14	 add	 esp, 20			; 00000014H
  00577	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LastDialogId, OFFSET ?PageDebugId@?1??PageDialogProc@@9@16@4PADA
  00581	83 f8 06	 cmp	 eax, 6
  00584	0f 87 07 0e 00
	00		 ja	 $LN4@PageDialog
  0058a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN161@PageDialog[eax*4]
$LN15@PageDialog:

; 272  : 		{
; 273  : 		case INTRO_PAGE:
; 274  : 			{
; 275  : 				char *licenseText = NULL;
; 276  : 
; 277  : 				licenseText = GetLegalNotices ();

  00591	e8 00 00 00 00	 call	 _GetLegalNotices
  00596	8b d8		 mov	 ebx, eax

; 278  : 				if (licenseText != NULL)

  00598	85 db		 test	 ebx, ebx
  0059a	0f 84 06 0e 00
	00		 je	 $LN159@PageDialog

; 279  : 				{
; 280  : 					SetWindowText (GetDlgItem (hwndDlg, IDC_LICENSE_TEXT), licenseText);

  005a0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  005a6	53		 push	 ebx
  005a7	68 ee 03 00 00	 push	 1006			; 000003eeH
  005ac	57		 push	 edi
  005ad	ff d6		 call	 esi
  005af	50		 push	 eax
  005b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 281  : 					free (licenseText);

  005b6	53		 push	 ebx
  005b7	e8 00 00 00 00	 call	 _free

; 287  : 				}
; 288  : 
; 289  : 				/* For legal reasons, some of the following texts cannot be localized by third parties. */
; 290  : 
; 291  : 				SetCheckBox (hwndDlg, IDC_AGREE, bLicenseAccepted);

  005bc	ff 35 00 00 00
	00		 push	 DWORD PTR ?bLicenseAccepted@@3HA ; bLicenseAccepted
  005c2	68 fe 03 00 00	 push	 1022			; 000003feH
  005c7	57		 push	 edi
  005c8	e8 00 00 00 00	 call	 _SetCheckBox

; 292  : 
; 293  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), L"Please read the license terms");

  005cd	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  005d3	83 c4 10	 add	 esp, 16			; 00000010H
  005d6	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@EGEEIDAI@?$AAP?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAr?$AAe?$AAa?$AAd?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAs?$AA?$AA@
  005db	68 e9 03 00 00	 push	 1001			; 000003e9H
  005e0	57		 push	 edi
  005e1	ff d3		 call	 ebx
  005e3	50		 push	 eax
  005e4	ff d6		 call	 esi
  005e6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetWindowTextW@8
  005ec	50		 push	 eax
  005ed	ff d7		 call	 edi

; 294  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_INFO), L"You must accept these license terms before you can use, extract, or install GostCrypt.");

  005ef	68 00 00 00 00	 push	 OFFSET ??_C@_1KO@PHMNFEJ@?$AAY?$AAo?$AAu?$AA?5?$AAm?$AAu?$AAs?$AAt?$AA?5?$AAa?$AAc?$AAc?$AAe?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAe?$AAs?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe@
  005f4	68 eb 03 00 00	 push	 1003			; 000003ebH
  005f9	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  005ff	ff d3		 call	 ebx
  00601	50		 push	 eax
  00602	ff d6		 call	 esi
  00604	50		 push	 eax
  00605	ff d7		 call	 edi

; 295  : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), L"IMPORTANT: By checking the checkbox below, you accept these license terms and signify that you understand and agree to them. Please click the 'arrow down' icon to see the rest of the license.");	// Cannot be localized by third parties (for legal reasons).

  00607	68 00 00 00 00	 push	 OFFSET ??_C@_1BIA@MJJKLEKE@?$AAI?$AAM?$AAP?$AAO?$AAR?$AAT?$AAA?$AAN?$AAT?$AA?3?$AA?5?$AAB?$AAy?$AA?5?$AAc?$AAh?$AAe?$AAc?$AAk?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAc?$AAh?$AAe?$AAc?$AAk@
  0060c	68 ed 03 00 00	 push	 1005			; 000003edH
  00611	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00617	ff d6		 call	 esi
  00619	50		 push	 eax
  0061a	ff d7		 call	 edi

; 296  : 				//SendMessage (GetDlgItem (hwndDlg, IDC_BOX_HELP), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);
; 297  : 
; 298  : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_AGREE), L"I &accept the license terms");	// Cannot be localized by third parties (for legal reasons).

  0061c	68 00 00 00 00	 push	 OFFSET ??_C@_1DI@FKGEFKMH@?$AAI?$AA?5?$AA?$CG?$AAa?$AAc?$AAc?$AAe?$AAp?$AAt?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAl?$AAi?$AAc?$AAe?$AAn?$AAs?$AAe?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAs?$AA?$AA@
  00621	68 fe 03 00 00	 push	 1022			; 000003feH
  00626	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0062c	ff d6		 call	 esi
  0062e	50		 push	 eax
  0062f	ff d7		 call	 edi

; 299  : 				//SetWindowTextW (GetDlgItem (hwndDlg, IDC_DISAGREE), L"I &do not accept the license terms");
; 300  : 
; 301  : 				//SendMessage (GetDlgItem (hwndDlg, IDC_AGREE), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);
; 302  : 				//SendMessage (GetDlgItem (hwndDlg, IDC_DISAGREE), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);
; 303  : 
; 304  : 				EnableWindow (GetDlgItem (hwndDlg, IDC_AGREE), TRUE);

  00631	6a 01		 push	 1
  00633	68 fe 03 00 00	 push	 1022			; 000003feH
  00638	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0063e	ff d6		 call	 esi
  00640	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00646	50		 push	 eax
  00647	ff d6		 call	 esi

; 305  : 
; 306  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  00649	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  0064e	e8 00 00 00 00	 call	 _GetString
  00653	83 c4 04	 add	 esp, 4
  00656	50		 push	 eax
  00657	68 02 04 00 00	 push	 1026			; 00000402H
  0065c	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00662	ff d3		 call	 ebx
  00664	50		 push	 eax
  00665	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0066b	50		 push	 eax
  0066c	ff d7		 call	 edi

; 307  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  0066e	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  00673	e8 00 00 00 00	 call	 _GetString
  00678	83 c4 04	 add	 esp, 4
  0067b	50		 push	 eax
  0067c	68 03 04 00 00	 push	 1027			; 00000403H
  00681	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00687	ff d3		 call	 ebx
  00689	50		 push	 eax
  0068a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00690	50		 push	 eax
  00691	ff d7		 call	 edi

; 308  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("CANCEL"));

  00693	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  00698	e8 00 00 00 00	 call	 _GetString
  0069d	83 c4 04	 add	 esp, 4
  006a0	50		 push	 eax
  006a1	6a 02		 push	 2
  006a3	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  006a9	ff d3		 call	 ebx
  006ab	50		 push	 eax
  006ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  006b2	50		 push	 eax
  006b3	ff d7		 call	 edi

; 309  : 
; 310  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), bLicenseAccepted);

  006b5	ff 35 00 00 00
	00		 push	 DWORD PTR ?bLicenseAccepted@@3HA ; bLicenseAccepted
  006bb	68 02 04 00 00	 push	 1026			; 00000402H
  006c0	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  006c6	ff d3		 call	 ebx
  006c8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  006ce	50		 push	 eax
  006cf	ff d7		 call	 edi
  006d1	50		 push	 eax
  006d2	ff d6		 call	 esi

; 311  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  006d4	6a 00		 push	 0
  006d6	68 03 04 00 00	 push	 1027			; 00000403H
  006db	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  006e1	ff d3		 call	 ebx
  006e3	50		 push	 eax
  006e4	ff d7		 call	 edi
  006e6	50		 push	 eax
  006e7	ff d6		 call	 esi

; 312  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDHELP), bLicenseAccepted);

  006e9	ff 35 00 00 00
	00		 push	 DWORD PTR ?bLicenseAccepted@@3HA ; bLicenseAccepted
  006ef	6a 09		 push	 9
  006f1	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  006f7	ff d3		 call	 ebx
  006f9	50		 push	 eax
  006fa	ff d7		 call	 edi
  006fc	50		 push	 eax
  006fd	ff d6		 call	 esi

; 313  : 
; 314  : 				// Left margin for license text
; 315  : 				SendMessage (GetDlgItem (hwndDlg, IDC_LICENSE_TEXT), EM_SETMARGINS, (WPARAM) EC_LEFTMARGIN, (LPARAM) CompensateXDPI (4));

  006ff	6a 04		 push	 4
  00701	e8 00 00 00 00	 call	 _CompensateXDPI
  00706	83 c4 04	 add	 esp, 4
  00709	50		 push	 eax
  0070a	6a 01		 push	 1
  0070c	68 d3 00 00 00	 push	 211			; 000000d3H
  00711	68 ee 03 00 00	 push	 1006			; 000003eeH
  00716	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0071c	ff d7		 call	 edi
  0071e	50		 push	 eax
  0071f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  00725	5b		 pop	 ebx
  00726	5f		 pop	 edi

; 316  : 			}
; 317  : 			return 1;

  00727	b8 01 00 00 00	 mov	 eax, 1
  0072c	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  0072d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00730	33 cd		 xor	 ecx, ebp
  00732	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00737	8b e5		 mov	 esp, ebp
  00739	5d		 pop	 ebp
  0073a	c2 10 00	 ret	 16			; 00000010H
$LN18@PageDialog:

; 318  : 
; 319  : 		case WIZARD_MODE_PAGE:
; 320  : 			{
; 321  : 				LONG driverVersion;
; 322  : 
; 323  : 				DetermineUpgradeDowngradeStatus (TRUE, &driverVersion);

  0073d	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR _driverVersion$2[ebp]
  00743	50		 push	 eax
  00744	6a 01		 push	 1
  00746	e8 00 00 00 00	 call	 _DetermineUpgradeDowngradeStatus

; 324  : 
; 325  : 				if (bRepairMode)

  0074b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  00751	83 c4 08	 add	 esp, 8
  00754	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRepairMode, 0
  0075b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00761	74 25		 je	 SHORT $LN19@PageDialog

; 326  : 				{
; 327  : 					SetWindowTextW (GetDlgItem (hwndDlg, IDC_WIZARD_MODE_INSTALL), GetString ("REPAIR_REINSTALL"));

  00763	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@
  00768	e8 00 00 00 00	 call	 _GetString
  0076d	83 c4 04	 add	 esp, 4
  00770	50		 push	 eax
  00771	68 00 04 00 00	 push	 1024			; 00000400H
  00776	57		 push	 edi
  00777	ff d3		 call	 ebx
  00779	50		 push	 eax
  0077a	ff d6		 call	 esi

; 328  : 					bExtractOnly = FALSE;

  0077c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bExtractOnly@@3HA, 0 ; bExtractOnly
  00786	eb 22		 jmp	 SHORT $LN21@PageDialog
$LN19@PageDialog:

; 329  : 				}
; 330  : 				else if (bUpgrade)

  00788	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  0078f	74 19		 je	 SHORT $LN21@PageDialog

; 331  : 					SetWindowTextW (GetDlgItem (hwndDlg, IDC_WIZARD_MODE_INSTALL), GetString ("UPGRADE"));

  00791	68 00 00 00 00	 push	 OFFSET ??_C@_07CNHFDDPI@UPGRADE?$AA@
  00796	e8 00 00 00 00	 call	 _GetString
  0079b	83 c4 04	 add	 esp, 4
  0079e	50		 push	 eax
  0079f	68 00 04 00 00	 push	 1024			; 00000400H
  007a4	57		 push	 edi
  007a5	ff d3		 call	 ebx
  007a7	50		 push	 eax
  007a8	ff d6		 call	 esi
$LN21@PageDialog:

; 332  : 
; 333  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SETUP_MODE_TITLE"));

  007aa	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KMHMHMNP@SETUP_MODE_TITLE?$AA@
  007af	e8 00 00 00 00	 call	 _GetString
  007b4	83 c4 04	 add	 esp, 4
  007b7	50		 push	 eax
  007b8	68 e9 03 00 00	 push	 1001			; 000003e9H
  007bd	57		 push	 edi
  007be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  007c4	50		 push	 eax
  007c5	ff d3		 call	 ebx
  007c7	50		 push	 eax
  007c8	ff d6		 call	 esi

; 334  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_INFO), GetString ("SETUP_MODE_INFO"));

  007ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PHBLGFGD@SETUP_MODE_INFO?$AA@
  007cf	e8 00 00 00 00	 call	 _GetString
  007d4	83 c4 04	 add	 esp, 4
  007d7	50		 push	 eax
  007d8	68 eb 03 00 00	 push	 1003			; 000003ebH
  007dd	57		 push	 edi
  007de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  007e4	50		 push	 eax
  007e5	ff d3		 call	 ebx
  007e7	50		 push	 eax
  007e8	ff d6		 call	 esi

; 335  : 
; 336  : 				SendMessage (GetDlgItem (hwndDlg, IDC_WIZARD_MODE_INSTALL), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  007ea	6a 01		 push	 1
  007ec	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  007f2	6a 30		 push	 48			; 00000030H
  007f4	68 00 04 00 00	 push	 1024			; 00000400H
  007f9	57		 push	 edi
  007fa	ff d3		 call	 ebx
  007fc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  00802	50		 push	 eax
  00803	ff d6		 call	 esi

; 337  : 				SendMessage (GetDlgItem (hwndDlg, IDC_WIZARD_MODE_EXTRACT_ONLY), WM_SETFONT, (WPARAM) hUserBoldFont, (LPARAM) TRUE);

  00805	6a 01		 push	 1
  00807	ff 35 00 00 00
	00		 push	 DWORD PTR _hUserBoldFont
  0080d	6a 30		 push	 48			; 00000030H
  0080f	68 01 04 00 00	 push	 1025			; 00000401H
  00814	57		 push	 edi
  00815	ff d3		 call	 ebx
  00817	50		 push	 eax
  00818	ff d6		 call	 esi

; 338  : 
; 339  : 				CheckButton (GetDlgItem (hwndDlg, bExtractOnly ? IDC_WIZARD_MODE_EXTRACT_ONLY : IDC_WIZARD_MODE_INSTALL));

  0081a	33 c0		 xor	 eax, eax
  0081c	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bExtractOnly@@3HA, eax ; bExtractOnly
  00822	0f 95 c0	 setne	 al
  00825	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  0082a	50		 push	 eax
  0082b	57		 push	 edi
  0082c	ff d3		 call	 ebx
  0082e	50		 push	 eax
  0082f	e8 00 00 00 00	 call	 _CheckButton

; 340  : 
; 341  : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("SETUP_MODE_HELP_EXTRACT"));

  00834	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KCCOCEA@SETUP_MODE_HELP_EXTRACT?$AA@
  00839	e8 00 00 00 00	 call	 _GetString
  0083e	83 c4 08	 add	 esp, 8
  00841	50		 push	 eax
  00842	68 ed 03 00 00	 push	 1005			; 000003edH
  00847	57		 push	 edi
  00848	ff d3		 call	 ebx
  0084a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00850	50		 push	 eax
  00851	ff d6		 call	 esi

; 342  : 
; 343  : 				if (!bRepairMode)

  00853	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bRepairMode
  00859	85 c9		 test	 ecx, ecx
  0085b	75 2f		 jne	 SHORT $LN22@PageDialog

; 344  : 					SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP2), GetString (bUpgrade ? "SETUP_MODE_HELP_UPGRADE" : "SETUP_MODE_HELP_INSTALL"));

  0085d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  00864	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BI@ECIBEEIH@SETUP_MODE_HELP_INSTALL?$AA@
  00869	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BI@JGKCNIKM@SETUP_MODE_HELP_UPGRADE?$AA@
  0086e	0f 44 c1	 cmove	 eax, ecx
  00871	50		 push	 eax
  00872	e8 00 00 00 00	 call	 _GetString
  00877	83 c4 04	 add	 esp, 4
  0087a	50		 push	 eax
  0087b	68 ef 03 00 00	 push	 1007			; 000003efH
  00880	57		 push	 edi
  00881	ff d3		 call	 ebx
  00883	50		 push	 eax
  00884	ff d6		 call	 esi
  00886	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bRepairMode
$LN22@PageDialog:

; 345  : 
; 346  : 				EnableWindow (GetDlgItem (hwndDlg, IDC_WIZARD_MODE_EXTRACT_ONLY), !bRepairMode);

  0088c	33 c0		 xor	 eax, eax
  0088e	85 c9		 test	 ecx, ecx
  00890	0f 94 c0	 sete	 al
  00893	50		 push	 eax
  00894	68 01 04 00 00	 push	 1025			; 00000401H
  00899	57		 push	 edi
  0089a	ff d3		 call	 ebx
  0089c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  008a2	50		 push	 eax
  008a3	ff d6		 call	 esi

; 347  : 				EnableWindow (GetDlgItem (hwndDlg, IDC_BOX_HELP), !bRepairMode);

  008a5	33 c0		 xor	 eax, eax
  008a7	39 05 00 00 00
	00		 cmp	 DWORD PTR _bRepairMode, eax
  008ad	0f 94 c0	 sete	 al
  008b0	50		 push	 eax
  008b1	68 ed 03 00 00	 push	 1005			; 000003edH
  008b6	57		 push	 edi
  008b7	ff d3		 call	 ebx
  008b9	50		 push	 eax
  008ba	ff d6		 call	 esi

; 348  : 				EnableWindow (GetDlgItem (hwndDlg, IDC_WIZARD_MODE_INSTALL), TRUE);

  008bc	6a 01		 push	 1
  008be	68 00 04 00 00	 push	 1024			; 00000400H
  008c3	57		 push	 edi
  008c4	ff d3		 call	 ebx
  008c6	50		 push	 eax
  008c7	ff d6		 call	 esi

; 349  : 
; 350  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  008c9	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  008ce	e8 00 00 00 00	 call	 _GetString
  008d3	83 c4 04	 add	 esp, 4
  008d6	50		 push	 eax
  008d7	68 02 04 00 00	 push	 1026			; 00000402H
  008dc	57		 push	 edi
  008dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  008e3	50		 push	 eax
  008e4	ff d3		 call	 ebx
  008e6	50		 push	 eax
  008e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 351  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  008ed	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  008f2	e8 00 00 00 00	 call	 _GetString
  008f7	83 c4 04	 add	 esp, 4
  008fa	50		 push	 eax
  008fb	68 03 04 00 00	 push	 1027			; 00000403H
  00900	57		 push	 edi
  00901	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00907	50		 push	 eax
  00908	ff d3		 call	 ebx
  0090a	50		 push	 eax
  0090b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 352  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDCANCEL), GetString ("CANCEL"));

  00911	68 00 00 00 00	 push	 OFFSET ??_C@_06JHILMIHF@CANCEL?$AA@
  00916	e8 00 00 00 00	 call	 _GetString
  0091b	83 c4 04	 add	 esp, 4
  0091e	50		 push	 eax
  0091f	6a 02		 push	 2
  00921	57		 push	 edi
  00922	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00928	50		 push	 eax
  00929	ff d3		 call	 ebx
  0092b	50		 push	 eax
  0092c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 353  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  00932	6a 01		 push	 1
  00934	68 02 04 00 00	 push	 1026			; 00000402H
  00939	57		 push	 edi
  0093a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00940	50		 push	 eax
  00941	ff d3		 call	 ebx
  00943	50		 push	 eax
  00944	ff d6		 call	 esi

; 354  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00946	6a 01		 push	 1
  00948	68 03 04 00 00	 push	 1027			; 00000403H
  0094d	57		 push	 edi
  0094e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00954	50		 push	 eax
  00955	ff d3		 call	 ebx
  00957	50		 push	 eax
  00958	ff d6		 call	 esi
  0095a	5b		 pop	 ebx
  0095b	5f		 pop	 edi

; 355  : 			}
; 356  : 			return 1;

  0095c	b8 01 00 00 00	 mov	 eax, 1
  00961	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  00962	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00965	33 cd		 xor	 ecx, ebp
  00967	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0096c	8b e5		 mov	 esp, ebp
  0096e	5d		 pop	 ebp
  0096f	c2 10 00	 ret	 16			; 00000010H
$LN23@PageDialog:

; 357  : 
; 358  : 		case EXTRACTION_OPTIONS_PAGE:
; 359  : 
; 360  : 			if (strlen(WizardDestExtractPath) < 2)

  00972	b9 00 00 00 00	 mov	 ecx, OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  00977	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0097a	66 0f 1f 44 00
	00		 npad	 6
$LL147@PageDialog:
  00980	8a 01		 mov	 al, BYTE PTR [ecx]
  00982	41		 inc	 ecx
  00983	84 c0		 test	 al, al
  00985	75 f9		 jne	 SHORT $LL147@PageDialog
  00987	2b ca		 sub	 ecx, edx
  00989	83 f9 02	 cmp	 ecx, 2
  0098c	73 45		 jae	 SHORT $LN24@PageDialog

; 361  : 			{ 
; 362  : 				strcpy (WizardDestExtractPath, SetupFilesDir);

  0098e	33 c9		 xor	 ecx, ecx
$LL80@PageDialog:
  00990	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _SetupFilesDir[ecx]
  00996	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00999	88 81 ff ff ff
	ff		 mov	 BYTE PTR ?WizardDestExtractPath@@3PADA[ecx-1], al
  0099f	84 c0		 test	 al, al
  009a1	75 ed		 jne	 SHORT $LL80@PageDialog

; 363  : 				strncat (WizardDestExtractPath, "GostCrypt\\", sizeof (WizardDestExtractPath) - strlen (WizardDestExtractPath) - 1);

  009a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  009a8	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  009ab	0f 1f 44 00 00	 npad	 5
$LL148@PageDialog:
  009b0	8a 01		 mov	 al, BYTE PTR [ecx]
  009b2	41		 inc	 ecx
  009b3	84 c0		 test	 al, al
  009b5	75 f9		 jne	 SHORT $LL148@PageDialog
  009b7	2b ca		 sub	 ecx, edx
  009b9	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  009be	2b c1		 sub	 eax, ecx
  009c0	50		 push	 eax
  009c1	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EDNBEOCA@GostCrypt?2?$AA@
  009c6	68 00 00 00 00	 push	 OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  009cb	e8 00 00 00 00	 call	 _strncat
  009d0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@PageDialog:

; 364  : 			}
; 365  : 
; 366  : 			SendMessage (GetDlgItem (hwndDlg, IDC_DESTINATION), EM_LIMITTEXT, GST_MAX_PATH - 1, 0);

  009d3	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  009d9	6a 00		 push	 0
  009db	68 03 01 00 00	 push	 259			; 00000103H
  009e0	68 c5 00 00 00	 push	 197			; 000000c5H
  009e5	68 e8 03 00 00	 push	 1000			; 000003e8H
  009ea	57		 push	 edi
  009eb	ff d3		 call	 ebx
  009ed	50		 push	 eax
  009ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 367  : 
; 368  : 			SetDlgItemText (hwndDlg, IDC_DESTINATION, WizardDestExtractPath);

  009f4	68 00 00 00 00	 push	 OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  009f9	68 e8 03 00 00	 push	 1000			; 000003e8H
  009fe	57		 push	 edi
  009ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextA@12

; 369  : 
; 370  : 			SetCheckBox (hwndDlg, IDC_OPEN_CONTAINING_FOLDER, bOpenContainingFolder);

  00a05	ff 35 00 00 00
	00		 push	 DWORD PTR ?bOpenContainingFolder@@3HA ; bOpenContainingFolder
  00a0b	68 fd 03 00 00	 push	 1021			; 000003fdH
  00a10	57		 push	 edi
  00a11	e8 00 00 00 00	 call	 _SetCheckBox

; 371  : 
; 372  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("EXTRACTION_OPTIONS_TITLE"));

  00a16	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PDGEILOG@EXTRACTION_OPTIONS_TITLE?$AA@
  00a1b	e8 00 00 00 00	 call	 _GetString
  00a20	83 c4 10	 add	 esp, 16			; 00000010H
  00a23	50		 push	 eax
  00a24	68 e9 03 00 00	 push	 1001			; 000003e9H
  00a29	57		 push	 edi
  00a2a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetParent@4
  00a30	ff d7		 call	 edi
  00a32	50		 push	 eax
  00a33	ff d3		 call	 ebx
  00a35	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00a3b	50		 push	 eax
  00a3c	ff d6		 call	 esi

; 373  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_INFO), GetString ("EXTRACTION_OPTIONS_INFO"));

  00a3e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OKGEFEFK@EXTRACTION_OPTIONS_INFO?$AA@
  00a43	e8 00 00 00 00	 call	 _GetString
  00a48	83 c4 04	 add	 esp, 4
  00a4b	50		 push	 eax
  00a4c	68 eb 03 00 00	 push	 1003			; 000003ebH
  00a51	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00a57	ff d7		 call	 edi
  00a59	50		 push	 eax
  00a5a	ff d3		 call	 ebx
  00a5c	50		 push	 eax
  00a5d	ff d6		 call	 esi

; 374  : 			SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("AUTO_FOLDER_CREATION"));

  00a5f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@HFEALDNI@AUTO_FOLDER_CREATION?$AA@
  00a64	e8 00 00 00 00	 call	 _GetString
  00a69	83 c4 04	 add	 esp, 4
  00a6c	50		 push	 eax
  00a6d	68 ed 03 00 00	 push	 1005			; 000003edH
  00a72	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00a78	ff d3		 call	 ebx
  00a7a	50		 push	 eax
  00a7b	ff d6		 call	 esi

; 375  : 
; 376  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("EXTRACT"));

  00a7d	68 00 00 00 00	 push	 OFFSET ??_C@_07LBPFAJBE@EXTRACT?$AA@
  00a82	e8 00 00 00 00	 call	 _GetString
  00a87	83 c4 04	 add	 esp, 4
  00a8a	50		 push	 eax
  00a8b	68 02 04 00 00	 push	 1026			; 00000402H
  00a90	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00a96	ff d7		 call	 edi
  00a98	50		 push	 eax
  00a99	ff d3		 call	 ebx
  00a9b	50		 push	 eax
  00a9c	ff d6		 call	 esi

; 377  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  00a9e	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  00aa3	e8 00 00 00 00	 call	 _GetString
  00aa8	83 c4 04	 add	 esp, 4
  00aab	50		 push	 eax
  00aac	68 03 04 00 00	 push	 1027			; 00000403H
  00ab1	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00ab7	ff d7		 call	 edi
  00ab9	50		 push	 eax
  00aba	ff d3		 call	 ebx
  00abc	50		 push	 eax
  00abd	ff d6		 call	 esi

; 378  : 
; 379  : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDHELP), TRUE);

  00abf	6a 01		 push	 1
  00ac1	6a 09		 push	 9
  00ac3	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00ac9	ff d7		 call	 edi
  00acb	50		 push	 eax
  00acc	ff d3		 call	 ebx
  00ace	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00ad4	50		 push	 eax
  00ad5	ff d6		 call	 esi

; 380  : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00ad7	6a 01		 push	 1
  00ad9	68 03 04 00 00	 push	 1027			; 00000403H
  00ade	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00ae4	ff d7		 call	 edi
  00ae6	50		 push	 eax
  00ae7	ff d3		 call	 ebx
  00ae9	50		 push	 eax
  00aea	ff d6		 call	 esi

; 381  : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  00aec	6a 01		 push	 1
  00aee	68 02 04 00 00	 push	 1026			; 00000402H
  00af3	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00af9	ff d7		 call	 edi
  00afb	50		 push	 eax
  00afc	ff d3		 call	 ebx
  00afe	50		 push	 eax
  00aff	ff d6		 call	 esi

; 382  : 			EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  00b01	6a 01		 push	 1
  00b03	6a 02		 push	 2
  00b05	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00b0b	ff d7		 call	 edi
  00b0d	50		 push	 eax
  00b0e	ff d3		 call	 ebx
  00b10	50		 push	 eax
  00b11	ff d6		 call	 esi
  00b13	5b		 pop	 ebx
  00b14	5f		 pop	 edi

; 383  : 
; 384  : 			return 1;

  00b15	b8 01 00 00 00	 mov	 eax, 1
  00b1a	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  00b1b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b1e	33 cd		 xor	 ecx, ebp
  00b20	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b25	8b e5		 mov	 esp, ebp
  00b27	5d		 pop	 ebp
  00b28	c2 10 00	 ret	 16			; 00000010H
$LN25@PageDialog:

; 385  : 
; 386  : 		case EXTRACTION_PROGRESS_PAGE:
; 387  : 
; 388  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("EXTRACTING_VERB"));

  00b2b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@
  00b30	e8 00 00 00 00	 call	 _GetString
  00b35	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  00b3b	83 c4 04	 add	 esp, 4
  00b3e	50		 push	 eax
  00b3f	68 e9 03 00 00	 push	 1001			; 000003e9H
  00b44	57		 push	 edi
  00b45	ff d3		 call	 ebx
  00b47	50		 push	 eax
  00b48	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00b4e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00b54	50		 push	 eax
  00b55	ff d6		 call	 esi

; 389  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_INFO), GetString ("EXTRACTION_PROGRESS_INFO"));

  00b57	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LJFMAAFG@EXTRACTION_PROGRESS_INFO?$AA@
  00b5c	e8 00 00 00 00	 call	 _GetString
  00b61	83 c4 04	 add	 esp, 4
  00b64	50		 push	 eax
  00b65	68 eb 03 00 00	 push	 1003			; 000003ebH
  00b6a	57		 push	 edi
  00b6b	ff d3		 call	 ebx
  00b6d	50		 push	 eax
  00b6e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00b74	50		 push	 eax
  00b75	ff d6		 call	 esi

; 390  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  00b77	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00b7c	e8 00 00 00 00	 call	 _GetString
  00b81	83 c4 04	 add	 esp, 4
  00b84	50		 push	 eax
  00b85	68 02 04 00 00	 push	 1026			; 00000402H
  00b8a	57		 push	 edi
  00b8b	ff d3		 call	 ebx
  00b8d	50		 push	 eax
  00b8e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00b94	50		 push	 eax
  00b95	ff d6		 call	 esi

; 391  : 
; 392  : 			if (bStartExtraction)

  00b97	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bStartExtraction@@3HA, 0 ; bStartExtraction
  00b9e	0f 84 00 01 00
	00		 je	 $LN26@PageDialog

; 393  : 			{
; 394  : 				/* Start extraction */
; 395  : 
; 396  : 				LastDialogId = "EXTRACTION_IN_PROGRESS";

  00ba4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LastDialogId, OFFSET ??_C@_0BH@PEMNLIII@EXTRACTION_IN_PROGRESS?$AA@

; 397  : 
; 398  : 				WaitCursor ();

  00bae	e8 00 00 00 00	 call	 _WaitCursor

; 399  : 
; 400  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  00bb3	6a 00		 push	 0
  00bb5	68 03 04 00 00	 push	 1027			; 00000403H
  00bba	57		 push	 edi
  00bbb	ff d3		 call	 ebx
  00bbd	50		 push	 eax
  00bbe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00bc4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00bca	50		 push	 eax
  00bcb	ff d6		 call	 esi

; 401  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), FALSE);

  00bcd	6a 00		 push	 0
  00bcf	68 02 04 00 00	 push	 1026			; 00000402H
  00bd4	57		 push	 edi
  00bd5	ff d3		 call	 ebx
  00bd7	50		 push	 eax
  00bd8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00bde	50		 push	 eax
  00bdf	ff d6		 call	 esi

; 402  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDHELP), FALSE);

  00be1	6a 00		 push	 0
  00be3	6a 09		 push	 9
  00be5	57		 push	 edi
  00be6	ff d3		 call	 ebx
  00be8	50		 push	 eax
  00be9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00bef	50		 push	 eax
  00bf0	ff d6		 call	 esi

; 403  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), FALSE);

  00bf2	6a 00		 push	 0
  00bf4	6a 02		 push	 2
  00bf6	57		 push	 edi
  00bf7	ff d3		 call	 ebx
  00bf9	50		 push	 eax
  00bfa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00c00	50		 push	 eax
  00c01	ff d6		 call	 esi

; 404  : 
; 405  : 				if (WizardDestExtractPath [strlen(WizardDestExtractPath)-1] != '\\')

  00c03	b9 00 00 00 00	 mov	 ecx, OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  00c08	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00c0b	0f 1f 44 00 00	 npad	 5
$LL149@PageDialog:
  00c10	8a 01		 mov	 al, BYTE PTR [ecx]
  00c12	41		 inc	 ecx
  00c13	84 c0		 test	 al, al
  00c15	75 f9		 jne	 SHORT $LL149@PageDialog
  00c17	2b ca		 sub	 ecx, edx
  00c19	80 b9 ff ff ff
	ff 5c		 cmp	 BYTE PTR ?WizardDestExtractPath@@3PADA[ecx-1], 92 ; 0000005cH
  00c20	74 1f		 je	 SHORT $LN28@PageDialog

; 406  : 					strcat (WizardDestExtractPath, "\\");

  00c22	bf 00 00 00 00	 mov	 edi, OFFSET ?WizardDestExtractPath@@3PADA ; WizardDestExtractPath
  00c27	4f		 dec	 edi
$LL150@PageDialog:
  00c28	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00c2b	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00c2e	84 c0		 test	 al, al
  00c30	75 f6		 jne	 SHORT $LL150@PageDialog
  00c32	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  00c38	66 89 07	 mov	 WORD PTR [edi], ax
  00c3b	8b bd 50 fd ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
$LN28@PageDialog:

; 407  : 
; 408  : 				strcpy (DestExtractPath, WizardDestExtractPath);

  00c41	33 c9		 xor	 ecx, ecx
  00c43	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL81@PageDialog:
  00c50	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?WizardDestExtractPath@@3PADA[ecx]
  00c56	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00c59	88 81 ff ff ff
	ff		 mov	 BYTE PTR _DestExtractPath[ecx-1], al
  00c5f	84 c0		 test	 al, al
  00c61	75 ed		 jne	 SHORT $LL81@PageDialog

; 409  : 
; 410  : 				InitProgressBar ();

  00c63	e8 00 00 00 00	 call	 _InitProgressBar

; 411  : 
; 412  : 				bInProgress = TRUE;
; 413  : 				bStartExtraction = FALSE;
; 414  : 
; 415  : 				_beginthread (ExtractAllFilesThread, 0, (void *) hwndDlg);

  00c68	57		 push	 edi
  00c69	6a 00		 push	 0
  00c6b	68 00 00 00 00	 push	 OFFSET _ExtractAllFilesThread
  00c70	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bInProgress@@3HA, 1 ; bInProgress
  00c7a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bStartExtraction@@3HA, 0 ; bStartExtraction
  00c84	e8 00 00 00 00	 call	 __beginthread
  00c89	83 c4 0c	 add	 esp, 12			; 0000000cH

; 617  : 			}
; 618  : 
; 619  : 			return 1;

  00c8c	b8 01 00 00 00	 mov	 eax, 1
  00c91	5b		 pop	 ebx
  00c92	5f		 pop	 edi
  00c93	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  00c94	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c97	33 cd		 xor	 ecx, ebp
  00c99	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c9e	8b e5		 mov	 esp, ebp
  00ca0	5d		 pop	 ebp
  00ca1	c2 10 00	 ret	 16			; 00000010H
$LN26@PageDialog:

; 416  : 			}
; 417  : 			else
; 418  : 			{
; 419  : 				NormalCursor ();

  00ca4	e8 00 00 00 00	 call	 _NormalCursor

; 420  : 
; 421  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00ca9	6a 01		 push	 1
  00cab	68 03 04 00 00	 push	 1027			; 00000403H
  00cb0	57		 push	 edi
  00cb1	ff d3		 call	 ebx
  00cb3	50		 push	 eax
  00cb4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00cba	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  00cc0	50		 push	 eax
  00cc1	ff d6		 call	 esi

; 422  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  00cc3	6a 01		 push	 1
  00cc5	68 02 04 00 00	 push	 1026			; 00000402H
  00cca	57		 push	 edi
  00ccb	ff d3		 call	 ebx
  00ccd	50		 push	 eax
  00cce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00cd4	50		 push	 eax
  00cd5	ff d6		 call	 esi

; 423  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDHELP), TRUE);

  00cd7	6a 01		 push	 1
  00cd9	6a 09		 push	 9
  00cdb	57		 push	 edi
  00cdc	ff d3		 call	 ebx
  00cde	50		 push	 eax
  00cdf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00ce5	50		 push	 eax
  00ce6	ff d6		 call	 esi

; 424  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  00ce8	6a 01		 push	 1
  00cea	6a 02		 push	 2
  00cec	57		 push	 edi
  00ced	ff d3		 call	 ebx
  00cef	50		 push	 eax
  00cf0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00cf6	50		 push	 eax
  00cf7	ff d6		 call	 esi
  00cf9	5b		 pop	 ebx
  00cfa	5f		 pop	 edi

; 425  : 			}
; 426  : 
; 427  : 			return 1;

  00cfb	b8 01 00 00 00	 mov	 eax, 1
  00d00	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  00d01	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d04	33 cd		 xor	 ecx, ebp
  00d06	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d0b	8b e5		 mov	 esp, ebp
  00d0d	5d		 pop	 ebp
  00d0e	c2 10 00	 ret	 16			; 00000010H
$LN29@PageDialog:

; 428  : 
; 429  : 		case INSTALL_OPTIONS_PAGE:
; 430  : 			{
; 431  : 				LONG driverVersion;
; 432  : 
; 433  : 				DetermineUpgradeDowngradeStatus (TRUE, &driverVersion);

  00d11	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _driverVersion$1[ebp]
  00d17	50		 push	 eax
  00d18	6a 01		 push	 1
  00d1a	e8 00 00 00 00	 call	 _DetermineUpgradeDowngradeStatus
  00d1f	83 c4 08	 add	 esp, 8

; 434  : 
; 435  : 				if (!bDesktopIconStatusDetermined)

  00d22	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDesktopIconStatusDetermined, 0
  00d29	75 1a		 jne	 SHORT $LN30@PageDialog

; 436  : 				{
; 437  : 					bDesktopIcon = !bUpgrade;

  00d2b	33 c0		 xor	 eax, eax

; 438  : 					bDesktopIconStatusDetermined = TRUE;

  00d2d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bDesktopIconStatusDetermined, 1
  00d37	39 05 00 00 00
	00		 cmp	 DWORD PTR _bUpgrade, eax
  00d3d	0f 94 c0	 sete	 al
  00d40	a3 00 00 00 00	 mov	 DWORD PTR _bDesktopIcon, eax
$LN30@PageDialog:

; 439  : 				}
; 440  : 
; 441  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SETUP_OPTIONS_TITLE"));

  00d45	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@EDFPLLMN@SETUP_OPTIONS_TITLE?$AA@
  00d4a	e8 00 00 00 00	 call	 _GetString
  00d4f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  00d55	83 c4 04	 add	 esp, 4
  00d58	50		 push	 eax
  00d59	68 e9 03 00 00	 push	 1001			; 000003e9H
  00d5e	57		 push	 edi
  00d5f	ff d3		 call	 ebx
  00d61	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00d67	50		 push	 eax
  00d68	ff d6		 call	 esi
  00d6a	50		 push	 eax
  00d6b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 442  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_INFO), GetString ("SETUP_OPTIONS_INFO"));

  00d71	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BMMFNCA@SETUP_OPTIONS_INFO?$AA@
  00d76	e8 00 00 00 00	 call	 _GetString
  00d7b	83 c4 04	 add	 esp, 4
  00d7e	50		 push	 eax
  00d7f	68 eb 03 00 00	 push	 1003			; 000003ebH
  00d84	57		 push	 edi
  00d85	ff d3		 call	 ebx
  00d87	50		 push	 eax
  00d88	ff d6		 call	 esi
  00d8a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SetWindowTextW@8
  00d90	50		 push	 eax
  00d91	ff d3		 call	 ebx

; 443  : 				SetWindowTextW (GetDlgItem (hwndDlg, IDC_BOX_HELP), GetString ("AUTO_FOLDER_CREATION"));

  00d93	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@HFEALDNI@AUTO_FOLDER_CREATION?$AA@
  00d98	e8 00 00 00 00	 call	 _GetString
  00d9d	83 c4 04	 add	 esp, 4
  00da0	50		 push	 eax
  00da1	68 ed 03 00 00	 push	 1005			; 000003edH
  00da6	57		 push	 edi
  00da7	ff d6		 call	 esi
  00da9	50		 push	 eax
  00daa	ff d3		 call	 ebx

; 444  : 
; 445  : 				InitWizardDestInstallPath ();

  00dac	e8 00 00 00 00	 call	 ?InitWizardDestInstallPath@@YAXXZ ; InitWizardDestInstallPath

; 446  : 
; 447  : 				SendMessage (GetDlgItem (hwndDlg, IDC_DESTINATION), EM_LIMITTEXT, GST_MAX_PATH - 1, 0);

  00db1	6a 00		 push	 0
  00db3	68 03 01 00 00	 push	 259			; 00000103H
  00db8	68 c5 00 00 00	 push	 197			; 000000c5H
  00dbd	68 e8 03 00 00	 push	 1000			; 000003e8H
  00dc2	57		 push	 edi
  00dc3	ff d6		 call	 esi
  00dc5	50		 push	 eax
  00dc6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 448  : 
; 449  : 				SetDlgItemText (hwndDlg, IDC_DESTINATION, WizardDestInstallPath);

  00dcc	68 00 00 00 00	 push	 OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  00dd1	68 e8 03 00 00	 push	 1000			; 000003e8H
  00dd6	57		 push	 edi
  00dd7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextA@12

; 450  : 
; 451  : 				if (bUpgrade)

  00ddd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  00de4	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__EnableWindow@8
  00dea	0f 84 b0 00 00
	00		 je	 $LN31@PageDialog

; 452  : 				{
; 453  : 					SetWindowTextW (GetDlgItem (hwndDlg, IDT_INSTALL_DESTINATION), GetString ("SETUP_UPGRADE_DESTINATION"));

  00df0	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@GJOJHDCA@SETUP_UPGRADE_DESTINATION?$AA@
  00df5	e8 00 00 00 00	 call	 _GetString
  00dfa	83 c4 04	 add	 esp, 4
  00dfd	50		 push	 eax
  00dfe	68 f6 03 00 00	 push	 1014			; 000003f6H
  00e03	57		 push	 edi
  00e04	ff d6		 call	 esi
  00e06	50		 push	 eax
  00e07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 454  : 					EnableWindow (GetDlgItem (hwndDlg, IDC_DESTINATION), FALSE);

  00e0d	6a 00		 push	 0
  00e0f	68 e8 03 00 00	 push	 1000			; 000003e8H
  00e14	57		 push	 edi
  00e15	ff d6		 call	 esi
  00e17	50		 push	 eax
  00e18	ff d3		 call	 ebx

; 455  : 					EnableWindow (GetDlgItem (hwndDlg, IDC_BROWSE), FALSE);

  00e1a	6a 00		 push	 0
  00e1c	68 ea 03 00 00	 push	 1002			; 000003eaH
  00e21	57		 push	 edi
  00e22	ff d6		 call	 esi
  00e24	50		 push	 eax
  00e25	ff d3		 call	 ebx

; 456  : 					EnableWindow (GetDlgItem (hwndDlg, IDC_ALL_USERS), FALSE);

  00e27	6a 00		 push	 0
  00e29	68 f5 03 00 00	 push	 1013			; 000003f5H
  00e2e	57		 push	 edi
  00e2f	ff d6		 call	 esi
  00e31	50		 push	 eax
  00e32	ff d3		 call	 ebx

; 457  : 
; 458  : 					char path[MAX_PATH];
; 459  : 					SHGetSpecialFolderPath (hwndDlg, path, CSIDL_COMMON_PROGRAMS, 0);

  00e34	6a 00		 push	 0
  00e36	6a 17		 push	 23			; 00000017H
  00e38	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path$9[ebp]
  00e3e	50		 push	 eax
  00e3f	57		 push	 edi
  00e40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetSpecialFolderPathA@16

; 460  : 					bForAllUsers = (_access ((string (path) + "\\" GST_APP_NAME).c_str(), 0) == 0);

  00e46	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@
  00e4b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path$9[ebp]
  00e51	50		 push	 eax
  00e52	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00e58	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e5d	50		 push	 eax
  00e5e	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00e64	50		 push	 eax
  00e65	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00e6a	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e6d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00e71	72 02		 jb	 SHORT $LN99@PageDialog
  00e73	8b 00		 mov	 eax, DWORD PTR [eax]
$LN99@PageDialog:
  00e75	6a 00		 push	 0
  00e77	50		 push	 eax
  00e78	e8 00 00 00 00	 call	 __access
  00e7d	83 c4 08	 add	 esp, 8
  00e80	8d 8d ac fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00e86	f7 d8		 neg	 eax
  00e88	1b c0		 sbb	 eax, eax
  00e8a	40		 inc	 eax
  00e8b	a3 00 00 00 00	 mov	 DWORD PTR _bForAllUsers, eax
  00e90	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e95	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00e9b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN31@PageDialog:

; 461  : 				}
; 462  : 
; 463  : 				// System Restore
; 464  : 				SetCheckBox (hwndDlg, IDC_SYSTEM_RESTORE, bSystemRestore);

  00ea0	ff 35 00 00 00
	00		 push	 DWORD PTR _bSystemRestore
  00ea6	68 f3 03 00 00	 push	 1011			; 000003f3H
  00eab	57		 push	 edi
  00eac	e8 00 00 00 00	 call	 _SetCheckBox
  00eb1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 465  : 				if (SystemRestoreDll == 0)

  00eb4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemRestoreDll, 0
  00ebb	75 1d		 jne	 SHORT $LN32@PageDialog

; 466  : 				{
; 467  : 					SetCheckBox (hwndDlg, IDC_SYSTEM_RESTORE, FALSE);

  00ebd	6a 00		 push	 0
  00ebf	68 f3 03 00 00	 push	 1011			; 000003f3H
  00ec4	57		 push	 edi
  00ec5	e8 00 00 00 00	 call	 _SetCheckBox
  00eca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 468  : 					EnableWindow (GetDlgItem (hwndDlg, IDC_SYSTEM_RESTORE), FALSE);

  00ecd	6a 00		 push	 0
  00ecf	68 f3 03 00 00	 push	 1011			; 000003f3H
  00ed4	57		 push	 edi
  00ed5	ff d6		 call	 esi
  00ed7	50		 push	 eax
  00ed8	ff d3		 call	 ebx
$LN32@PageDialog:

; 469  : 				}
; 470  : 
; 471  : 				SetCheckBox (hwndDlg, IDC_ALL_USERS, bForAllUsers);

  00eda	ff 35 00 00 00
	00		 push	 DWORD PTR _bForAllUsers
  00ee0	68 f5 03 00 00	 push	 1013			; 000003f5H
  00ee5	57		 push	 edi
  00ee6	e8 00 00 00 00	 call	 _SetCheckBox

; 472  : 				SetCheckBox (hwndDlg, IDC_FILE_TYPE, bRegisterFileExt);

  00eeb	ff 35 00 00 00
	00		 push	 DWORD PTR _bRegisterFileExt
  00ef1	68 f0 03 00 00	 push	 1008			; 000003f0H
  00ef6	57		 push	 edi
  00ef7	e8 00 00 00 00	 call	 _SetCheckBox

; 473  : 				SetCheckBox (hwndDlg, IDC_PROG_GROUP, bAddToStartMenu);

  00efc	ff 35 00 00 00
	00		 push	 DWORD PTR _bAddToStartMenu
  00f02	68 f2 03 00 00	 push	 1010			; 000003f2H
  00f07	57		 push	 edi
  00f08	e8 00 00 00 00	 call	 _SetCheckBox

; 474  : 				SetCheckBox (hwndDlg, IDC_DESKTOP_ICON, bDesktopIcon);

  00f0d	ff 35 00 00 00
	00		 push	 DWORD PTR _bDesktopIcon
  00f13	68 f4 03 00 00	 push	 1012			; 000003f4H
  00f18	57		 push	 edi
  00f19	e8 00 00 00 00	 call	 _SetCheckBox

; 475  : 
; 476  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString (bUpgrade ? "UPGRADE" : "INSTALL"));

  00f1e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  00f25	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07PJFGKPND@INSTALL?$AA@
  00f2a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07CNHFDDPI@UPGRADE?$AA@
  00f2f	0f 44 c1	 cmove	 eax, ecx
  00f32	50		 push	 eax
  00f33	e8 00 00 00 00	 call	 _GetString
  00f38	83 c4 34	 add	 esp, 52			; 00000034H
  00f3b	50		 push	 eax
  00f3c	68 02 04 00 00	 push	 1026			; 00000402H
  00f41	57		 push	 edi
  00f42	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00f48	50		 push	 eax
  00f49	ff d6		 call	 esi
  00f4b	50		 push	 eax
  00f4c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 477  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  00f52	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  00f57	e8 00 00 00 00	 call	 _GetString
  00f5c	83 c4 04	 add	 esp, 4
  00f5f	50		 push	 eax
  00f60	68 03 04 00 00	 push	 1027			; 00000403H
  00f65	57		 push	 edi
  00f66	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00f6c	50		 push	 eax
  00f6d	ff d6		 call	 esi
  00f6f	50		 push	 eax
  00f70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 478  : 
; 479  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDHELP), TRUE);

  00f76	6a 01		 push	 1
  00f78	6a 09		 push	 9
  00f7a	57		 push	 edi
  00f7b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00f81	50		 push	 eax
  00f82	ff d6		 call	 esi
  00f84	50		 push	 eax
  00f85	ff d3		 call	 ebx

; 480  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  00f87	6a 01		 push	 1
  00f89	68 03 04 00 00	 push	 1027			; 00000403H
  00f8e	57		 push	 edi
  00f8f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00f95	50		 push	 eax
  00f96	ff d6		 call	 esi
  00f98	50		 push	 eax
  00f99	ff d3		 call	 ebx

; 481  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  00f9b	6a 01		 push	 1
  00f9d	68 02 04 00 00	 push	 1026			; 00000402H
  00fa2	57		 push	 edi
  00fa3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00fa9	50		 push	 eax
  00faa	ff d6		 call	 esi
  00fac	50		 push	 eax
  00fad	ff d3		 call	 ebx

; 482  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  00faf	6a 01		 push	 1
  00fb1	6a 02		 push	 2
  00fb3	57		 push	 edi
  00fb4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00fba	50		 push	 eax
  00fbb	ff d6		 call	 esi
  00fbd	50		 push	 eax
  00fbe	ff d3		 call	 ebx
  00fc0	5b		 pop	 ebx
  00fc1	5f		 pop	 edi

; 483  : 			}
; 484  : 			return 1;

  00fc2	b8 01 00 00 00	 mov	 eax, 1
  00fc7	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  00fc8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00fcb	33 cd		 xor	 ecx, ebp
  00fcd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fd2	8b e5		 mov	 esp, ebp
  00fd4	5d		 pop	 ebp
  00fd5	c2 10 00	 ret	 16			; 00000010H
$LN33@PageDialog:

; 485  : 
; 486  : 		case INSTALL_PROGRESS_PAGE:
; 487  : 
; 488  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString ("SETUP_PROGRESS_TITLE"));

  00fd8	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FGINDNOJ@SETUP_PROGRESS_TITLE?$AA@
  00fdd	e8 00 00 00 00	 call	 _GetString
  00fe2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  00fe8	83 c4 04	 add	 esp, 4
  00feb	50		 push	 eax
  00fec	68 e9 03 00 00	 push	 1001			; 000003e9H
  00ff1	57		 push	 edi
  00ff2	ff d3		 call	 ebx
  00ff4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00ffa	50		 push	 eax
  00ffb	ff d6		 call	 esi
  00ffd	50		 push	 eax
  00ffe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 489  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_INFO), GetString ("SETUP_PROGRESS_INFO"));

  01004	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JGHDAHN@SETUP_PROGRESS_INFO?$AA@
  01009	e8 00 00 00 00	 call	 _GetString
  0100e	83 c4 04	 add	 esp, 4
  01011	50		 push	 eax
  01012	68 eb 03 00 00	 push	 1003			; 000003ebH
  01017	57		 push	 edi
  01018	ff d3		 call	 ebx
  0101a	50		 push	 eax
  0101b	ff d6		 call	 esi
  0101d	50		 push	 eax
  0101e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 490  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  01024	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  01029	e8 00 00 00 00	 call	 _GetString
  0102e	83 c4 04	 add	 esp, 4
  01031	50		 push	 eax
  01032	68 02 04 00 00	 push	 1026			; 00000402H
  01037	57		 push	 edi
  01038	ff d3		 call	 ebx
  0103a	50		 push	 eax
  0103b	ff d6		 call	 esi
  0103d	50		 push	 eax
  0103e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 491  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_PREV), GetString ("PREV"));

  01044	68 00 00 00 00	 push	 OFFSET ??_C@_04PKHKLFPJ@PREV?$AA@
  01049	e8 00 00 00 00	 call	 _GetString
  0104e	83 c4 04	 add	 esp, 4
  01051	50		 push	 eax
  01052	68 03 04 00 00	 push	 1027			; 00000403H
  01057	57		 push	 edi
  01058	ff d3		 call	 ebx
  0105a	50		 push	 eax
  0105b	ff d6		 call	 esi
  0105d	50		 push	 eax
  0105e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 492  : 
; 493  : 			if (bStartInstall)

  01064	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bStartInstall@@3HA, 0 ; bStartInstall
  0106b	0f 84 13 01 00
	00		 je	 $LN34@PageDialog

; 494  : 			{
; 495  : 				/* Start install */
; 496  : 
; 497  : 				LastDialogId = "INSTALL_IN_PROGRESS";
; 498  : 
; 499  : 				SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), GetString ("NEXT"));

  01071	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  01076	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LastDialogId, OFFSET ??_C@_0BE@FMNDIKAG@INSTALL_IN_PROGRESS?$AA@
  01080	e8 00 00 00 00	 call	 _GetString
  01085	83 c4 04	 add	 esp, 4
  01088	50		 push	 eax
  01089	68 02 04 00 00	 push	 1026			; 00000402H
  0108e	57		 push	 edi
  0108f	ff d3		 call	 ebx
  01091	50		 push	 eax
  01092	ff d6		 call	 esi
  01094	50		 push	 eax
  01095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 500  : 
; 501  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), FALSE);

  0109b	6a 00		 push	 0
  0109d	68 03 04 00 00	 push	 1027			; 00000403H
  010a2	57		 push	 edi
  010a3	ff d3		 call	 ebx
  010a5	50		 push	 eax
  010a6	ff d6		 call	 esi
  010a8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  010ae	50		 push	 eax
  010af	ff d6		 call	 esi

; 502  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), FALSE);

  010b1	6a 00		 push	 0
  010b3	68 02 04 00 00	 push	 1026			; 00000402H
  010b8	57		 push	 edi
  010b9	ff d3		 call	 ebx
  010bb	50		 push	 eax
  010bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  010c2	50		 push	 eax
  010c3	ff d6		 call	 esi

; 503  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDHELP), FALSE);

  010c5	6a 00		 push	 0
  010c7	6a 09		 push	 9
  010c9	57		 push	 edi
  010ca	ff d3		 call	 ebx
  010cc	50		 push	 eax
  010cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  010d3	50		 push	 eax
  010d4	ff d6		 call	 esi

; 504  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), FALSE);

  010d6	6a 00		 push	 0
  010d8	6a 02		 push	 2
  010da	57		 push	 edi
  010db	ff d3		 call	 ebx
  010dd	50		 push	 eax
  010de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  010e4	50		 push	 eax
  010e5	ff d6		 call	 esi

; 505  : 
; 506  : 				InitProgressBar ();

  010e7	e8 00 00 00 00	 call	 _InitProgressBar

; 507  : 
; 508  : 				if (WizardDestInstallPath [strlen(WizardDestInstallPath)-1] != '\\')

  010ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  010f1	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL151@PageDialog:
  010f4	8a 01		 mov	 al, BYTE PTR [ecx]
  010f6	41		 inc	 ecx
  010f7	84 c0		 test	 al, al
  010f9	75 f9		 jne	 SHORT $LL151@PageDialog
  010fb	2b ca		 sub	 ecx, edx
  010fd	80 b9 ff ff ff
	ff 5c		 cmp	 BYTE PTR ?WizardDestInstallPath@@3PADA[ecx-1], 92 ; 0000005cH
  01104	74 23		 je	 SHORT $LN36@PageDialog

; 509  : 					strcat (WizardDestInstallPath, "\\");

  01106	bf 00 00 00 00	 mov	 edi, OFFSET ?WizardDestInstallPath@@3PADA ; WizardDestInstallPath
  0110b	4f		 dec	 edi
  0110c	0f 1f 40 00	 npad	 4
$LL152@PageDialog:
  01110	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  01113	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  01116	84 c0		 test	 al, al
  01118	75 f6		 jne	 SHORT $LL152@PageDialog
  0111a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  01120	66 89 07	 mov	 WORD PTR [edi], ax
  01123	8b bd 50 fd ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
$LN36@PageDialog:

; 510  : 
; 511  : 				strcpy (InstallationPath, WizardDestInstallPath);

  01129	33 c9		 xor	 ecx, ecx
  0112b	0f 1f 44 00 00	 npad	 5
$LL82@PageDialog:
  01130	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?WizardDestInstallPath@@3PADA[ecx]
  01136	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01139	88 81 ff ff ff
	ff		 mov	 BYTE PTR _InstallationPath[ecx-1], al
  0113f	84 c0		 test	 al, al
  01141	75 ed		 jne	 SHORT $LL82@PageDialog

; 512  : 
; 513  : 				WaitCursor ();

  01143	e8 00 00 00 00	 call	 _WaitCursor

; 514  : 
; 515  : 				bInProgress = TRUE;
; 516  : 				bStartInstall = FALSE;
; 517  : 
; 518  : 				_beginthread (DoInstall, 0, (void *) hwndDlg);

  01148	57		 push	 edi
  01149	6a 00		 push	 0
  0114b	68 00 00 00 00	 push	 OFFSET _DoInstall
  01150	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bInProgress@@3HA, 1 ; bInProgress
  0115a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bStartInstall@@3HA, 0 ; bStartInstall
  01164	e8 00 00 00 00	 call	 __beginthread
  01169	83 c4 0c	 add	 esp, 12			; 0000000cH

; 617  : 			}
; 618  : 
; 619  : 			return 1;

  0116c	b8 01 00 00 00	 mov	 eax, 1
  01171	5b		 pop	 ebx
  01172	5f		 pop	 edi
  01173	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  01174	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01177	33 cd		 xor	 ecx, ebp
  01179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0117e	8b e5		 mov	 esp, ebp
  01180	5d		 pop	 ebp
  01181	c2 10 00	 ret	 16			; 00000010H
$LN34@PageDialog:

; 519  : 			}
; 520  : 			else
; 521  : 			{
; 522  : 				NormalCursor ();

  01184	e8 00 00 00 00	 call	 _NormalCursor

; 523  : 
; 524  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_PREV), TRUE);

  01189	6a 01		 push	 1
  0118b	68 03 04 00 00	 push	 1027			; 00000403H
  01190	57		 push	 edi
  01191	ff d3		 call	 ebx
  01193	50		 push	 eax
  01194	ff d6		 call	 esi
  01196	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EnableWindow@8
  0119c	50		 push	 eax
  0119d	ff d6		 call	 esi

; 525  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDC_NEXT), TRUE);

  0119f	6a 01		 push	 1
  011a1	68 02 04 00 00	 push	 1026			; 00000402H
  011a6	57		 push	 edi
  011a7	ff d3		 call	 ebx
  011a9	50		 push	 eax
  011aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  011b0	50		 push	 eax
  011b1	ff d6		 call	 esi

; 526  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDHELP), TRUE);

  011b3	6a 01		 push	 1
  011b5	6a 09		 push	 9
  011b7	57		 push	 edi
  011b8	ff d3		 call	 ebx
  011ba	50		 push	 eax
  011bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  011c1	50		 push	 eax
  011c2	ff d6		 call	 esi

; 527  : 				EnableWindow (GetDlgItem (GetParent (hwndDlg), IDCANCEL), TRUE);

  011c4	6a 01		 push	 1
  011c6	6a 02		 push	 2
  011c8	57		 push	 edi
  011c9	ff d3		 call	 ebx
  011cb	50		 push	 eax
  011cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  011d2	50		 push	 eax
  011d3	ff d6		 call	 esi
  011d5	5b		 pop	 ebx
  011d6	5f		 pop	 edi

; 528  : 
; 529  : 			}
; 530  : 
; 531  : 			return 1;

  011d7	b8 01 00 00 00	 mov	 eax, 1
  011dc	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  011dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011e0	33 cd		 xor	 ecx, ebp
  011e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011e7	8b e5		 mov	 esp, ebp
  011e9	5d		 pop	 ebp
  011ea	c2 10 00	 ret	 16			; 00000010H
$LN37@PageDialog:

; 532  : 
; 533  : 		case DONATIONS_PAGE:
; 534  : 
; 535  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_TITLE), GetString (bExtractOnly ? "EXTRACTION_FINISHED_TITLE_DON" : (bUpgrade ? "SETUP_FINISHED_UPGRADE_TITLE_DON" : "SETUP_FINISHED_TITLE_DON")));

  011ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bExtractOnly@@3HA, 0 ; bExtractOnly
  011f4	74 07		 je	 SHORT $LN83@PageDialog
  011f6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BO@CCIEODIN@EXTRACTION_FINISHED_TITLE_DON?$AA@
  011fb	eb 14		 jmp	 SHORT $LN84@PageDialog
$LN83@PageDialog:
  011fd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  01204	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CB@HFOJNJFM@SETUP_FINISHED_UPGRADE_TITLE_DON@
  01209	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BJ@KIEFKBPA@SETUP_FINISHED_TITLE_DON?$AA@
  0120e	0f 44 c1	 cmove	 eax, ecx
$LN84@PageDialog:
  01211	50		 push	 eax
  01212	e8 00 00 00 00	 call	 _GetString
  01217	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetParent@4
  0121d	83 c4 04	 add	 esp, 4
  01220	50		 push	 eax
  01221	68 e9 03 00 00	 push	 1001			; 000003e9H
  01226	57		 push	 edi
  01227	ff d3		 call	 ebx
  01229	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  0122f	50		 push	 eax
  01230	ff d7		 call	 edi
  01232	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  01238	50		 push	 eax
  01239	ff d6		 call	 esi

; 536  : 			SetWindowTextW (GetDlgItem (GetParent (hwndDlg), IDC_BOX_INFO), GetString ("SETUP_FINISHED_INFO_DON"));

  0123b	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CKIDBLFB@SETUP_FINISHED_INFO_DON?$AA@
  01240	e8 00 00 00 00	 call	 _GetString
  01245	83 c4 04	 add	 esp, 4
  01248	50		 push	 eax
  01249	68 eb 03 00 00	 push	 1003			; 000003ebH
  0124e	ff b5 50 fd ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  01254	ff d3		 call	 ebx
  01256	50		 push	 eax
  01257	ff d7		 call	 edi
  01259	50		 push	 eax
  0125a	ff d6		 call	 esi

; 537  : 
; 538  : 			DonText = L"If you want to make a donation, please contact us.";

  0125c	68 00 00 00 00	 push	 OFFSET ??_C@_1GG@BHNAKINK@?$AAI?$AAf?$AA?5?$AAy?$AAo?$AAu?$AA?5?$AAw?$AAa?$AAn?$AAt?$AA?5?$AAt?$AAo?$AA?5?$AAm?$AAa?$AAk?$AAe?$AA?5?$AAa?$AA?5?$AAd?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?0?$AA?5@
  01261	b9 00 00 00 00	 mov	 ecx, OFFSET ?DonText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; DonText
  01266	e8 00 00 00 00	 call	 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=

; 539  : 
; 540  : 
; 541  : 			// Colors
; 542  : 
; 543  : 			switch (DonColorSchemeId)

  0126b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DonColorSchemeId@@3HA
  01270	83 c0 fd	 add	 eax, -3			; fffffffdH
  01273	83 f8 06	 cmp	 eax, 6
  01276	77 77		 ja	 SHORT $LN6@PageDialog
  01278	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN162@PageDialog[eax*4]
$LN39@PageDialog:

; 544  : 			{
; 545  : 			case 2:
; 546  : 				// NOP - Default OS colors (foreground and background)
; 547  : 				break;
; 548  : 
; 549  : 			case 3:
; 550  : 				// Red
; 551  : 				DonTextColor = RGB (255, 255, 255);
; 552  : 				DonBkgColor = RGB (255, 0, 0);

  0127f	c7 05 00 00 00
	00 ff 00 00 00	 mov	 DWORD PTR ?DonBkgColor@@3KA, 255 ; 000000ffH

; 553  : 				break;

  01289	eb 5a		 jmp	 SHORT $LN155@PageDialog
$LN40@PageDialog:

; 554  : 
; 555  : 			case 4:
; 556  : 				// Yellow
; 557  : 				DonTextColor = RGB (255, 15, 49);

  0128b	c7 05 00 00 00
	00 ff 0f 31 00	 mov	 DWORD PTR ?DonTextColor@@3KA, 3215359 ; 00310fffH

; 558  : 				DonBkgColor = RGB (255, 255, 0);

  01295	c7 05 00 00 00
	00 ff ff 00 00	 mov	 DWORD PTR ?DonBkgColor@@3KA, 65535 ; 0000ffffH

; 559  : 				break;

  0129f	eb 4e		 jmp	 SHORT $LN6@PageDialog
$LN41@PageDialog:

; 560  : 
; 561  : 			case 5:
; 562  : 				// Light red
; 563  : 				DonTextColor = RGB (255, 255, 255);
; 564  : 				DonBkgColor = RGB (255, 141, 144);

  012a1	c7 05 00 00 00
	00 ff 8d 90 00	 mov	 DWORD PTR ?DonBkgColor@@3KA, 9473535 ; 00908dffH

; 565  : 				break;

  012ab	eb 38		 jmp	 SHORT $LN155@PageDialog
$LN42@PageDialog:

; 566  : 
; 567  : 			case 6:
; 568  : 				// Pink
; 569  : 				DonTextColor = RGB (255, 255, 255);
; 570  : 				DonBkgColor = RGB (248, 148, 207);

  012ad	c7 05 00 00 00
	00 f8 94 cf 00	 mov	 DWORD PTR ?DonBkgColor@@3KA, 13604088 ; 00cf94f8H

; 571  : 				break;

  012b7	eb 2c		 jmp	 SHORT $LN155@PageDialog
$LN43@PageDialog:

; 572  : 
; 573  : 			case 7:
; 574  : 				// White + red text
; 575  : 				DonTextColor = RGB (255, 15, 49);

  012b9	c7 05 00 00 00
	00 ff 0f 31 00	 mov	 DWORD PTR ?DonTextColor@@3KA, 3215359 ; 00310fffH

; 576  : 				DonBkgColor = RGB (255, 255, 255);

  012c3	c7 05 00 00 00
	00 ff ff ff 00	 mov	 DWORD PTR ?DonBkgColor@@3KA, 16777215 ; 00ffffffH

; 577  : 				break;

  012cd	eb 20		 jmp	 SHORT $LN6@PageDialog
$LN44@PageDialog:

; 578  : 
; 579  : 			case 8:
; 580  : 				// Blue
; 581  : 				DonTextColor = RGB (255, 255, 255);
; 582  : 				DonBkgColor = RGB (54, 140, 255);

  012cf	c7 05 00 00 00
	00 36 8c ff 00	 mov	 DWORD PTR ?DonBkgColor@@3KA, 16747574 ; 00ff8c36H

; 583  : 				break;

  012d9	eb 0a		 jmp	 SHORT $LN155@PageDialog
$LN45@PageDialog:

; 588  : 				DonBkgColor = RGB (70, 180, 80);

  012db	c7 05 00 00 00
	00 46 b4 50 00	 mov	 DWORD PTR ?DonBkgColor@@3KA, 5289030 ; 0050b446H
$LN155@PageDialog:

; 584  : 
; 585  : 			case 9:
; 586  : 				// Green
; 587  : 				DonTextColor = RGB (255, 255, 255);

  012e5	c7 05 00 00 00
	00 ff ff ff 00	 mov	 DWORD PTR ?DonTextColor@@3KA, 16777215 ; 00ffffffH
$LN6@PageDialog:

; 589  : 				break;
; 590  : 			}
; 591  : 
; 592  : 			{
; 593  : 				// Font
; 594  : 
; 595  : 				LOGFONTW lf;
; 596  : 				memset (&lf, 0, sizeof(lf));

  012ef	6a 5c		 push	 92			; 0000005cH
  012f1	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _lf$6[ebp]
  012f7	6a 00		 push	 0
  012f9	50		 push	 eax
  012fa	e8 00 00 00 00	 call	 _memset

; 597  : 
; 598  : 				// Main font
; 599  : 				wcsncpy (lf.lfFaceName, L"Times New Roman", sizeof (lf.lfFaceName)/2);

  012ff	6a 20		 push	 32			; 00000020H
  01301	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _lf$6[ebp+28]
  01307	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@MBPOLHGL@?$AAT?$AAi?$AAm?$AAe?$AAs?$AA?5?$AAN?$AAe?$AAw?$AA?5?$AAR?$AAo?$AAm?$AAa?$AAn?$AA?$AA@
  0130c	50		 push	 eax
  0130d	e8 00 00 00 00	 call	 _wcsncpy

; 600  : 				lf.lfHeight = CompensateDPIFont (-21);

  01312	6a eb		 push	 -21			; ffffffebH
  01314	e8 00 00 00 00	 call	 _CompensateDPIFont
  01319	83 c4 1c	 add	 esp, 28			; 0000001cH
  0131c	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _lf$6[ebp], eax

; 601  : 				lf.lfWeight = FW_NORMAL;
; 602  : 				lf.lfWidth = 0;
; 603  : 				lf.lfEscapement = 0;
; 604  : 				lf.lfOrientation = 0;
; 605  : 				lf.lfItalic = FALSE;
; 606  : 				lf.lfUnderline = FALSE;
; 607  : 				lf.lfStrikeOut = FALSE;
; 608  : 				lf.lfCharSet = DEFAULT_CHARSET;
; 609  : 				lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
; 610  : 				lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
; 611  : 				lf.lfQuality = PROOF_QUALITY;
; 612  : 				lf.lfPitchAndFamily = FF_DONTCARE;
; 613  : 				hDonTextFont = CreateFontIndirectW (&lf);

  01322	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _lf$6[ebp]
  01328	c7 85 d4 fd ff
	ff 90 01 00 00	 mov	 DWORD PTR _lf$6[ebp+16], 400 ; 00000190H
  01332	c7 85 c8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _lf$6[ebp+4], 0
  0133c	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _lf$6[ebp+8], 0
  01346	50		 push	 eax
  01347	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _lf$6[ebp+12], 0
  01351	c7 85 d8 fd ff
	ff 00 00 00 01	 mov	 DWORD PTR _lf$6[ebp+20], 16777216 ; 01000000H
  0135b	c7 85 dc fd ff
	ff 00 00 02 00	 mov	 DWORD PTR _lf$6[ebp+24], 131072 ; 00020000H
  01365	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFontIndirectW@4
  0136b	a3 00 00 00 00	 mov	 DWORD PTR ?hDonTextFont@@3PAUHFONT__@@A, eax

; 614  : 
; 615  : 				if (hDonTextFont == NULL)

  01370	85 c0		 test	 eax, eax
  01372	75 05		 jne	 SHORT $LN46@PageDialog

; 616  : 					AbortProcessSilent ();

  01374	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN46@PageDialog:
  01379	5b		 pop	 ebx
  0137a	5f		 pop	 edi

; 617  : 			}
; 618  : 
; 619  : 			return 1;

  0137b	b8 01 00 00 00	 mov	 eax, 1
  01380	5e		 pop	 esi

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  01381	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01384	33 cd		 xor	 ecx, ebp
  01386	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0138b	8b e5		 mov	 esp, ebp
  0138d	5d		 pop	 ebp
  0138e	c2 10 00	 ret	 16			; 00000010H
$LN4@PageDialog:
  01391	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01394	33 c0		 xor	 eax, eax
  01396	5b		 pop	 ebx
  01397	5f		 pop	 edi
  01398	33 cd		 xor	 ecx, ebp
  0139a	5e		 pop	 esi
  0139b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  013a0	8b e5		 mov	 esp, ebp
  013a2	5d		 pop	 ebp
  013a3	c2 10 00	 ret	 16			; 00000010H
$LN159@PageDialog:

; 282  : 				}
; 283  : 				else
; 284  : 				{
; 285  : 					Error("CANNOT_DISPLAY_LICENSE");

  013a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MFJOAEDC@CANNOT_DISPLAY_LICENSE?$AA@
  013ab	e8 00 00 00 00	 call	 _Error
  013b0	83 c4 04	 add	 esp, 4

; 286  : 					exit (1);

  013b3	6a 01		 push	 1
  013b5	e8 00 00 00 00	 call	 _exit
$LN163@PageDialog:
$LN154@PageDialog:
  013ba	66 90		 npad	 2
$LN160@PageDialog:

; 803  : 
; 804  : 
; 805  : 	case WM_ERASEBKGND:
; 806  : 
; 807  : 		return 0;
; 808  : 	}
; 809  : 
; 810  : 	return 0;
; 811  : }

  013bc	00 00 00 00	 DD	 $LN62@PageDialog
  013c0	00 00 00 00	 DD	 $LN12@PageDialog
  013c4	00 00 00 00	 DD	 $LN12@PageDialog
  013c8	00 00 00 00	 DD	 $LN12@PageDialog
  013cc	00 00 00 00	 DD	 $LN12@PageDialog
  013d0	00 00 00 00	 DD	 $LN12@PageDialog
  013d4	00 00 00 00	 DD	 $LN67@PageDialog
  013d8	00 00 00 00	 DD	 $LN12@PageDialog
  013dc	00 00 00 00	 DD	 $LN68@PageDialog
  013e0	00 00 00 00	 DD	 $LN65@PageDialog
  013e4	00 00 00 00	 DD	 $LN69@PageDialog
  013e8	00 00 00 00	 DD	 $LN66@PageDialog
$LN161@PageDialog:
  013ec	00 00 00 00	 DD	 $LN15@PageDialog
  013f0	00 00 00 00	 DD	 $LN18@PageDialog
  013f4	00 00 00 00	 DD	 $LN29@PageDialog
  013f8	00 00 00 00	 DD	 $LN33@PageDialog
  013fc	00 00 00 00	 DD	 $LN23@PageDialog
  01400	00 00 00 00	 DD	 $LN25@PageDialog
  01404	00 00 00 00	 DD	 $LN37@PageDialog
$LN162@PageDialog:
  01408	00 00 00 00	 DD	 $LN39@PageDialog
  0140c	00 00 00 00	 DD	 $LN40@PageDialog
  01410	00 00 00 00	 DD	 $LN41@PageDialog
  01414	00 00 00 00	 DD	 $LN42@PageDialog
  01418	00 00 00 00	 DD	 $LN43@PageDialog
  0141c	00 00 00 00	 DD	 $LN44@PageDialog
  01420	00 00 00 00	 DD	 $LN45@PageDialog
_PageDialogProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\wizard.c
;	COMDAT _localcleanupwiz
_TEXT	SEGMENT
_localcleanupwiz PROC					; COMDAT

; 85   : 	/* Delete buffered bitmaps (if any) */
; 86   : 	if (hbmWizardBitmapRescaled != NULL)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hbmWizardBitmapRescaled@@3PAUHBITMAP__@@A ; hbmWizardBitmapRescaled
  00005	85 c0		 test	 eax, eax
  00007	74 11		 je	 SHORT $LN2@localclean

; 87   : 	{
; 88   : 		DeleteObject ((HGDIOBJ) hbmWizardBitmapRescaled);

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 89   : 		hbmWizardBitmapRescaled = NULL;

  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hbmWizardBitmapRescaled@@3PAUHBITMAP__@@A, 0 ; hbmWizardBitmapRescaled
$LN2@localclean:

; 90   : 	}
; 91   : 
; 92   : 	if (hCryptProv != 0)

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hCryptProv@@3KA
  0001f	85 c0		 test	 eax, eax
  00021	74 1d		 je	 SHORT $LN3@localclean

; 93   : 	{
; 94   : 		OsPrngAvailable = FALSE;
; 95   : 		CryptReleaseContext (hCryptProv, 0);

  00023	6a 00		 push	 0
  00025	50		 push	 eax
  00026	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?OsPrngAvailable@@3HA, 0
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptReleaseContext@8

; 96   : 		hCryptProv = 0;

  00036	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hCryptProv@@3KA, 0
$LN3@localclean:

; 97   : 	}
; 98   : 
; 99   : 	if (hDonTextFont != NULL)

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hDonTextFont@@3PAUHFONT__@@A
  00045	85 c0		 test	 eax, eax
  00047	74 11		 je	 SHORT $LN4@localclean

; 100  : 	{
; 101  : 		DeleteObject (hDonTextFont);

  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 102  : 		hDonTextFont = NULL;

  00050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hDonTextFont@@3PAUHFONT__@@A, 0
$LN4@localclean:

; 103  : 	}
; 104  : }

  0005a	c3		 ret	 0
_localcleanupwiz ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\wizard.c
;	COMDAT _RefreshUIGFX
_TEXT	SEGMENT
_RefreshUIGFX PROC					; COMDAT

; 859  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 860  : 	InvalidateRect (GetDlgItem (MainDlg, IDC_SETUP_WIZARD_BKG), NULL, TRUE);

  00002	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00008	6a 01		 push	 1
  0000a	6a 00		 push	 0
  0000c	68 fa 03 00 00	 push	 1018			; 000003faH
  00011	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00017	ff d7		 call	 edi
  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__InvalidateRect@12
  0001f	50		 push	 eax
  00020	ff d6		 call	 esi

; 861  : 	InvalidateRect (GetDlgItem (MainDlg, IDC_BOX_TITLE), NULL, TRUE);

  00022	6a 01		 push	 1
  00024	6a 00		 push	 0
  00026	68 e9 03 00 00	 push	 1001			; 000003e9H
  0002b	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00031	ff d7		 call	 edi
  00033	50		 push	 eax
  00034	ff d6		 call	 esi

; 862  : 	InvalidateRect (GetDlgItem (MainDlg, IDC_BOX_INFO), NULL, TRUE);

  00036	6a 01		 push	 1
  00038	6a 00		 push	 0
  0003a	68 eb 03 00 00	 push	 1003			; 000003ebH
  0003f	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00045	ff d7		 call	 edi
  00047	50		 push	 eax
  00048	ff d6		 call	 esi

; 863  : 	InvalidateRect (GetDlgItem (MainDlg, IDC_BITMAP_SETUP_WIZARD), NULL, TRUE);

  0004a	6a 01		 push	 1
  0004c	6a 00		 push	 0
  0004e	68 06 04 00 00	 push	 1030			; 00000406H
  00053	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00059	ff d7		 call	 edi
  0005b	50		 push	 eax
  0005c	ff d6		 call	 esi

; 864  : 	InvalidateRect (GetDlgItem (MainDlg, IDC_HR), NULL, TRUE);

  0005e	6a 01		 push	 1
  00060	6a 00		 push	 0
  00062	68 fc 03 00 00	 push	 1020			; 000003fcH
  00067	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0006d	ff d7		 call	 edi
  0006f	50		 push	 eax
  00070	ff d6		 call	 esi

; 865  : 	// Prevent these items from disappearing at higher DPIs
; 866  : 	ShowWindow(GetDlgItem(MainDlg, IDC_HR), SW_HIDE);

  00072	6a 00		 push	 0
  00074	68 fc 03 00 00	 push	 1020			; 000003fcH
  00079	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0007f	ff d7		 call	 edi
  00081	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ShowWindow@8
  00087	50		 push	 eax
  00088	ff d6		 call	 esi

; 867  : 	ShowWindow(GetDlgItem(MainDlg, IDC_HR), SW_SHOW);

  0008a	6a 05		 push	 5
  0008c	68 fc 03 00 00	 push	 1020			; 000003fcH
  00091	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00097	ff d7		 call	 edi
  00099	50		 push	 eax
  0009a	ff d6		 call	 esi

; 868  : 	ShowWindow(GetDlgItem(MainDlg, IDC_HR_BOTTOM), SW_HIDE);

  0009c	6a 00		 push	 0
  0009e	68 ff 03 00 00	 push	 1023			; 000003ffH
  000a3	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000a9	ff d7		 call	 edi
  000ab	50		 push	 eax
  000ac	ff d6		 call	 esi

; 869  : 	ShowWindow(GetDlgItem(MainDlg, IDC_HR_BOTTOM), SW_SHOW);

  000ae	6a 05		 push	 5
  000b0	68 ff 03 00 00	 push	 1023			; 000003ffH
  000b5	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000bb	ff d7		 call	 edi
  000bd	50		 push	 eax
  000be	ff d6		 call	 esi

; 870  : 	ShowWindow(GetDlgItem(MainDlg, IDC_BOX_INFO), SW_HIDE);

  000c0	6a 00		 push	 0
  000c2	68 eb 03 00 00	 push	 1003			; 000003ebH
  000c7	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000cd	ff d7		 call	 edi
  000cf	50		 push	 eax
  000d0	ff d6		 call	 esi

; 871  : 	ShowWindow(GetDlgItem(MainDlg, IDC_BOX_INFO), SW_SHOW);

  000d2	6a 05		 push	 5
  000d4	68 eb 03 00 00	 push	 1003			; 000003ebH
  000d9	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000df	ff d7		 call	 edi
  000e1	50		 push	 eax
  000e2	ff d6		 call	 esi

; 872  : 	ShowWindow(GetDlgItem(MainDlg, IDC_BOX_TITLE), SW_HIDE);

  000e4	6a 00		 push	 0
  000e6	68 e9 03 00 00	 push	 1001			; 000003e9H
  000eb	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  000f1	ff d7		 call	 edi
  000f3	50		 push	 eax
  000f4	ff d6		 call	 esi

; 873  : 	ShowWindow(GetDlgItem(MainDlg, IDC_BOX_TITLE), SW_SHOW);

  000f6	6a 05		 push	 5
  000f8	68 e9 03 00 00	 push	 1001			; 000003e9H
  000fd	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00103	ff d7		 call	 edi
  00105	50		 push	 eax
  00106	ff d6		 call	 esi
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi

; 874  : }

  0010a	c3		 ret	 0
_RefreshUIGFX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\wizard.c
;	COMDAT _UpdateProgressBarProc
_TEXT	SEGMENT
_nPercent$ = 8						; size = 4
_UpdateProgressBarProc PROC				; COMDAT

; 838  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 839  : 	HWND hProgressBar = GetDlgItem (hCurPage, nPbar);

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	ff 35 00 00 00
	00		 push	 DWORD PTR ?nPbar@@3HA	; nPbar
  00012	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00018	ff d3		 call	 ebx
  0001a	66 0f 6e 4d 08	 movd	 xmm1, DWORD PTR _nPercent$[ebp]
  0001f	8b f8		 mov	 edi, eax

; 840  : 	SendMessage (hProgressBar, PBM_SETPOS, (int) (100.0 * nPercent / 100), 0);

  00021	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00025	6a 00		 push	 0
  00027	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@4059000000000000
  0002f	f2 0f 5e 0d 00
	00 00 00	 divsd	 xmm1, QWORD PTR __real@4059000000000000
  00037	f2 0f 2c c9	 cvttsd2si ecx, xmm1
  0003b	51		 push	 ecx
  0003c	68 02 04 00 00	 push	 1026			; 00000402H
  00041	57		 push	 edi
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 841  : 	InvalidateRect (hProgressBar, NULL, TRUE);

  00048	6a 01		 push	 1
  0004a	6a 00		 push	 0
  0004c	57		 push	 edi
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 842  : 	ShowWindow(hProgressBar, SW_HIDE);

  00053	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ShowWindow@8
  00059	6a 00		 push	 0
  0005b	57		 push	 edi
  0005c	ff d6		 call	 esi

; 843  : 	ShowWindow(hProgressBar, SW_SHOW);

  0005e	6a 05		 push	 5
  00060	57		 push	 edi
  00061	ff d6		 call	 esi

; 844  : 	// Prevent the IDC_LOG_WINDOW item from partially disappearing at higher DPIs
; 845  : 	ShowWindow(GetDlgItem (hCurPage, IDC_LOG_WINDOW), SW_HIDE);

  00063	6a 00		 push	 0
  00065	68 f9 03 00 00	 push	 1017			; 000003f9H
  0006a	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00070	ff d3		 call	 ebx
  00072	50		 push	 eax
  00073	ff d6		 call	 esi

; 846  : 	ShowWindow(GetDlgItem (hCurPage, IDC_LOG_WINDOW), SW_SHOW);

  00075	6a 05		 push	 5
  00077	68 f9 03 00 00	 push	 1017			; 000003f9H
  0007c	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  00082	ff d3		 call	 ebx
  00084	50		 push	 eax
  00085	ff d6		 call	 esi

; 847  : 	RefreshUIGFX();

  00087	e8 00 00 00 00	 call	 _RefreshUIGFX
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi

; 848  : 	return TRUE;

  0008e	b8 01 00 00 00	 mov	 eax, 1
  00093	5b		 pop	 ebx

; 849  : }

  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_UpdateProgressBarProc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\wizard.c
;	COMDAT _InitProgressBar
_TEXT	SEGMENT
_InitProgressBar PROC					; COMDAT

; 821  : {

  00000	57		 push	 edi

; 822  : 	HWND hProgressBar = GetDlgItem (hCurPage, nPbar);

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?nPbar@@3HA	; nPbar
  00007	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCurPage@@3PAUHWND__@@A ; hCurPage
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8

; 823  : 	SendMessage (hProgressBar, PBM_SETRANGE32, 0, 100);

  00013	6a 64		 push	 100			; 00000064H
  00015	6a 00		 push	 0
  00017	8b f8		 mov	 edi, eax
  00019	68 06 04 00 00	 push	 1030			; 00000406H
  0001e	57		 push	 edi
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 824  : 	SendMessage (hProgressBar, PBM_SETSTEP, 1, 0);

  00025	6a 00		 push	 0
  00027	6a 01		 push	 1
  00029	68 04 04 00 00	 push	 1028			; 00000404H
  0002e	57		 push	 edi
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 825  : 	InvalidateRect (hProgressBar, NULL, TRUE);

  00035	6a 01		 push	 1
  00037	6a 00		 push	 0
  00039	57		 push	 edi
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
  00040	5f		 pop	 edi

; 826  : }

  00041	c3		 ret	 0
_InitProgressBar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 534  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  :         }

  00003	5d		 pop	 ebp

; 535  :             return _time64(_Time);

  00004	e9 00 00 00 00	 jmp	 __time64
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
