; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Desktop\Sources_GostCrypt_Windows_1.3.1_COMMENTED\Sources_GostCrypt_Windows_1.3.1é\Sources_GostCrypt_Windows_1.3.1\Common\Language.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_LocalizationActive:DWORD
COMM	_LocalizationSerialNo:DWORD
COMM	_UnknownString:WORD:0400H
_DATA	ENDS
PUBLIC	_LanguageDlgProc@16
PUBLIC	_GetString
PUBLIC	_GetFont
PUBLIC	_LoadLanguageFile
PUBLIC	_GetPreferredLangId
PUBLIC	_SetPreferredLangId
PUBLIC	_GetActiveLangPackVersion
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	__swprintf
PUBLIC	_sprintf
PUBLIC	_sscanf
PUBLIC	??_C@_03FJEFHLHG@Xml?$AA@			; `string'
PUBLIC	??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_02LFNMGJAP@en?$AA@			; `string'
PUBLIC	??_C@_07MMBOFDEG@control?$AA@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string?$AA@			; `string'
PUBLIC	??_C@_0N@MFNNBINO@localization?$AA@		; `string'
PUBLIC	??_C@_0N@LEFFHNKM@prog?9version?$AA@		; `string'
PUBLIC	??_C@_05OJPKCACG@1?43?41?$AA@			; `string'
PUBLIC	??_C@_05KOLFGEDA@DEBUG?$AA@			; `string'
PUBLIC	??_C@_1EAG@FAENFIFC@?$AAT?$AAh?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?5?$AAl?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?5?$AAp?$AAa?$AAc?$AAk?$AA?5?$AAi?$AAs?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_1BE@NJGOLFGO@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_08JGCCIMAA@language?$AA@			; `string'
PUBLIC	??_C@_06CLEJICHF@langid?$AA@			; `string'
PUBLIC	??_C@_07CPCPJPKL@version?$AA@			; `string'
PUBLIC	??_C@_04EFPADHIC@font?$AA@			; `string'
PUBLIC	??_C@_04IOHABJIC@lang?$AA@			; `string'
PUBLIC	??_C@_04POCOPAPC@face?$AA@			; `string'
PUBLIC	??_C@_04IAGNFIBA@size?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_05DONAFDKA@font_?$AA@			; `string'
PUBLIC	??_C@_05ENKANFLO@class?$AA@			; `string'
PUBLIC	??_C@_03ICHNJLJF@key?$AA@			; `string'
PUBLIC	??_C@_0DB@KHINFMBF@GostCrypt?3?5Unknown?5?8?2?8?5escape?5se@ ; `string'
PUBLIC	??_C@_0CN@GDBBBHBL@GostCrypt?3?5Error?5while?5decoding?5@ ; `string'
PUBLIC	??_C@_04BAADKBID@IDOK?$AA@			; `string'
PUBLIC	??_C@_08DDAIHKOO@IDCANCEL?$AA@			; `string'
PUBLIC	??_C@_07CIAHAGHC@IDCLOSE?$AA@			; `string'
PUBLIC	??_C@_06CALLMKCG@IDHELP?$AA@			; `string'
PUBLIC	??_C@_06OENKJGA@Header?$AA@			; `string'
PUBLIC	??_C@_0O@MBEIEFFD@?$CDdefine?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0N@CHAAEAGP@IDD_LANGUAGE?$AA@		; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_1BA@CLLEDPIF@?$AAE?$AAn?$AAg?$AAl?$AAi?$AAs?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_15KHFHDPFH@?$AA?9?$AA?9?$AA?$AA@		; `string'
PUBLIC	??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@	; `string'
PUBLIC	??_C@_0M@DOLNAGBN@translators?$AA@		; `string'
PUBLIC	??_C@_0BM@OECEHKD@?$CGlangpackversion?$DN?$CFs?$CGlang?$DN?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CK@MLINDFGB@http?3?1?1www?4gostcrypt?4org?1redirec@ ; `string'
PUBLIC	??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@ ; `string'
EXTRN	_strchr:PROC
EXTRN	_wcsrchr:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileW@8:PROC
EXTRN	__imp__FindNextFileW@8:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetModuleFileNameW@12:PROC
EXTRN	__imp__wsprintfW:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__SendDlgItemMessageA@20:PROC
EXTRN	__imp__SendDlgItemMessageW@20:PROC
EXTRN	__imp__SetWindowTextW@8:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	___stdio_common_vswprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___stdio_common_vsscanf:PROC
EXTRN	_LocalizeDialog:PROC
EXTRN	_Extlink:PROC
EXTRN	_MapResource:PROC
EXTRN	_ToHyperlink:PROC
EXTRN	_AddDictionaryEntry:PROC
EXTRN	_GetDictionaryValue:PROC
EXTRN	_AddPoolData:PROC
EXTRN	_ClearDictionaryPool:PROC
EXTRN	_XmlFindElement:PROC
EXTRN	_XmlGetAttributeText:PROC
EXTRN	_XmlGetNodeText:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_LanguageFileBuffer DD 01H DUP (?)
_PreferredLangId DB 06H DUP (?)
	ALIGN	4

_LanguageResource DD 01H DUP (?)
_HeaderResource DD 02H DUP (?)
_ActiveLangPackVersion DB 06H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@ DB '['
	DB	00H, '?', 00H, ']', 00H, '%', 00H, 'h', 00H, 's', 00H, '[', 00H
	DB	'?', 00H, ']', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MLINDFGB@http?3?1?1www?4gostcrypt?4org?1redirec@
CONST	SEGMENT
??_C@_0CK@MLINDFGB@http?3?1?1www?4gostcrypt?4org?1redirec@ DB 'http://www'
	DB	'.gostcrypt.org/redirect.php?a=3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OECEHKD@?$CGlangpackversion?$DN?$CFs?$CGlang?$DN?$CFs?$AA@
CONST	SEGMENT
??_C@_0BM@OECEHKD@?$CGlangpackversion?$DN?$CFs?$CGlang?$DN?$CFs?$AA@ DB '&'
	DB	'langpackversion=%s&lang=%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DOLNAGBN@translators?$AA@
CONST	SEGMENT
??_C@_0M@DOLNAGBN@translators?$AA@ DB 'translators', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@
CONST	SEGMENT
??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@ DB 'LANG_PACK_VERSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15KHFHDPFH@?$AA?9?$AA?9?$AA?$AA@
CONST	SEGMENT
??_C@_15KHFHDPFH@?$AA?9?$AA?9?$AA?$AA@ DB '-', 00H, '-', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@CLLEDPIF@?$AAE?$AAn?$AAg?$AAl?$AAi?$AAs?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@CLLEDPIF@?$AAE?$AAn?$AAg?$AAl?$AAi?$AAs?$AAh?$AA?$AA@ DB 'E', 00H
	DB	'n', 00H, 'g', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CHAAEAGP@IDD_LANGUAGE?$AA@
CONST	SEGMENT
??_C@_0N@CHAAEAGP@IDD_LANGUAGE?$AA@ DB 'IDD_LANGUAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MBEIEFFD@?$CDdefine?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@MBEIEFFD@?$CDdefine?5?$CFs?5?$CFd?$AA@ DB '#define %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OENKJGA@Header?$AA@
CONST	SEGMENT
??_C@_06OENKJGA@Header?$AA@ DB 'Header', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CALLMKCG@IDHELP?$AA@
CONST	SEGMENT
??_C@_06CALLMKCG@IDHELP?$AA@ DB 'IDHELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIAHAGHC@IDCLOSE?$AA@
CONST	SEGMENT
??_C@_07CIAHAGHC@IDCLOSE?$AA@ DB 'IDCLOSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DDAIHKOO@IDCANCEL?$AA@
CONST	SEGMENT
??_C@_08DDAIHKOO@IDCANCEL?$AA@ DB 'IDCANCEL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BAADKBID@IDOK?$AA@
CONST	SEGMENT
??_C@_04BAADKBID@IDOK?$AA@ DB 'IDOK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GDBBBHBL@GostCrypt?3?5Error?5while?5decoding?5@
CONST	SEGMENT
??_C@_0CN@GDBBBHBL@GostCrypt?3?5Error?5while?5decoding?5@ DB 'GostCrypt: '
	DB	'Error while decoding UTF-8 string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KHINFMBF@GostCrypt?3?5Unknown?5?8?2?8?5escape?5se@
CONST	SEGMENT
??_C@_0DB@KHINFMBF@GostCrypt?3?5Unknown?5?8?2?8?5escape?5se@ DB 'GostCryp'
	DB	't: Unknown ''\'' escape sequence in string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICHNJLJF@key?$AA@
CONST	SEGMENT
??_C@_03ICHNJLJF@key?$AA@ DB 'key', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05ENKANFLO@class?$AA@
CONST	SEGMENT
??_C@_05ENKANFLO@class?$AA@ DB 'class', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DONAFDKA@font_?$AA@
CONST	SEGMENT
??_C@_05DONAFDKA@font_?$AA@ DB 'font_', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAGNFIBA@size?$AA@
CONST	SEGMENT
??_C@_04IAGNFIBA@size?$AA@ DB 'size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POCOPAPC@face?$AA@
CONST	SEGMENT
??_C@_04POCOPAPC@face?$AA@ DB 'face', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang?$AA@
CONST	SEGMENT
??_C@_04IOHABJIC@lang?$AA@ DB 'lang', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFPADHIC@font?$AA@
CONST	SEGMENT
??_C@_04EFPADHIC@font?$AA@ DB 'font', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPCPJPKL@version?$AA@
CONST	SEGMENT
??_C@_07CPCPJPKL@version?$AA@ DB 'version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLEJICHF@langid?$AA@
CONST	SEGMENT
??_C@_06CLEJICHF@langid?$AA@ DB 'langid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JGCCIMAA@language?$AA@
CONST	SEGMENT
??_C@_08JGCCIMAA@language?$AA@ DB 'language', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@NJGOLFGO@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@NJGOLFGO@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@ DB 'G'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EAG@FAENFIFC@?$AAT?$AAh?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?5?$AAl?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?5?$AAp?$AAa?$AAc?$AAk?$AA?5?$AAi?$AAs?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1EAG@FAENFIFC@?$AAT?$AAh?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?5?$AAl?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?5?$AAp?$AAa?$AAc?$AAk?$AA?5?$AAi?$AAs?$AA?5?$AAi@ DB 'T'
	DB	00H, 'h', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'l', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'u', 00H, 'a', 00H
	DB	'g', 00H, 'e', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'c', 00H, 'k'
	DB	00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's'
	DB	00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'G'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, ' ', 00H, '(', 00H, 't', 00H, 'h', 00H, 'e'
	DB	00H, ' ', 00H, 'l', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'u', 00H
	DB	'a', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'c'
	DB	00H, 'k', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'f', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't'
	DB	00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H, 't', 00H, ' ', 00H
	DB	'%', 00H, 'h', 00H, 's', 00H, ')', 00H, '.', 00H, ' ', 00H, 'A'
	DB	00H, ' ', 00H, 'n', 00H, 'e', 00H, 'w', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'y', 00H, ' ', 00H
	DB	'b', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'v', 00H, 'a', 00H, 'i'
	DB	00H, 'l', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H
	DB	'a', 00H, 't', 00H, ' ', 00H, 'w', 00H, 'w', 00H, 'w', 00H, '.'
	DB	00H, 'g', 00H, 'o', 00H, 's', 00H, 't', 00H, 'c', 00H, 'r', 00H
	DB	'y', 00H, 'p', 00H, 't', 00H, '.', 00H, 'o', 00H, 'r', 00H, 'g'
	DB	00H, '.', 00H, 0aH, 00H, 0aH, 00H, 'T', 00H, 'o', 00H, ' ', 00H
	DB	'p', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'm', 00H, 'e', 00H, 's', 00H, 's', 00H, 'a', 00H, 'g', 00H, 'e'
	DB	00H, ' ', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H
	DB	'b', 00H, 'e', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'd'
	DB	00H, 'i', 00H, 's', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H
	DB	'e', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'd', 00H, 'o', 00H, ' '
	DB	00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'o'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'w', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ':', 00H, 0aH, 00H, 0aH, 00H, '-', 00H, ' ', 00H, 'S'
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'c', 00H, 't', 00H, ' ', 00H
	DB	'''', 00H, 'S', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 's', 00H, '''', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'''', 00H, 'L', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'u', 00H, 'a'
	DB	00H, 'g', 00H, 'e', 00H, '''', 00H, ';', 00H, ' ', 00H, 't', 00H
	DB	'h', 00H, 'e', 00H, 'n', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'l'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, ' ', 00H, '''', 00H, 'E', 00H
	DB	'n', 00H, 'g', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, ''''
	DB	00H, ' ', 00H, 'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'c', 00H
	DB	'l', 00H, 'i', 00H, 'c', 00H, 'k', 00H, ' ', 00H, '''', 00H, 'O'
	DB	00H, 'K', 00H, '''', 00H, '.', 00H, 0aH, 00H, 0aH, 00H, '-', 00H
	DB	' ', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e'
	DB	00H, ' ', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'p', 00H, 'l', 00H, 'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 't'
	DB	00H, 'h', 00H, 'e', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'u', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'p'
	DB	00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'c', 00H, 'o'
	DB	00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, '(', 00H, 't', 00H
	DB	'h', 00H, 'e', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 'n', 00H, 'g'
	DB	00H, 'u', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'y'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, 'e', 00H, '.', 00H, 'g', 00H, '.', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, ' ', 00H, '''', 00H, 'C', 00H, ':', 00H
	DB	'\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H, 'a'
	DB	00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	's', 00H, '\', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H, 'C'
	DB	00H, 'r', 00H, 'y', 00H, 'p', 00H, 't', 00H, '''', 00H, ' ', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, '''', 00H, '%', 00H, '%', 00H, 'L'
	DB	00H, 'O', 00H, 'C', 00H, 'A', 00H, 'L', 00H, 'A', 00H, 'P', 00H
	DB	'P', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H, '%', 00H, '%'
	DB	00H, '\', 00H, 'V', 00H, 'i', 00H, 'r', 00H, 't', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'S', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'e'
	DB	00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, 's', 00H, '\', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H
	DB	'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H, 't', 00H, '''', 00H, ','
	DB	00H, ' ', 00H, 'e', 00H, 't', 00H, 'c', 00H, '.', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05KOLFGEDA@DEBUG?$AA@
CONST	SEGMENT
??_C@_05KOLFGEDA@DEBUG?$AA@ DB 'DEBUG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OJPKCACG@1?43?41?$AA@
CONST	SEGMENT
??_C@_05OJPKCACG@1?43?41?$AA@ DB '1.3.1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LEFFHNKM@prog?9version?$AA@
CONST	SEGMENT
??_C@_0N@LEFFHNKM@prog?9version?$AA@ DB 'prog-version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MFNNBINO@localization?$AA@
CONST	SEGMENT
??_C@_0N@MFNNBINO@localization?$AA@ DB 'localization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string?$AA@
CONST	SEGMENT
??_C@_06ICGJLFIM@string?$AA@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MMBOFDEG@control?$AA@
CONST	SEGMENT
??_C@_07MMBOFDEG@control?$AA@ DB 'control', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFNMGJAP@en?$AA@
CONST	SEGMENT
??_C@_02LFNMGJAP@en?$AA@ DB 'en', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@ DB '\'
	DB	00H, 'L', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'u', 00H, 'a', 00H
	DB	'g', 00H, 'e', 00H, '*', 00H, '.', 00H, 'x', 00H, 'm', 00H, 'l'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03FJEFHLHG@Xml?$AA@
CONST	SEGMENT
??_C@_03FJEFHLHG@Xml?$AA@ DB 'Xml', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_LanguageFileFindHandle DD 0ffffffffH
_DATA	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\language.c
;	COMDAT _MapNextLanguageFile
_TEXT	SEGMENT
_read$ = -1640						; size = 4
_find$ = -1636						; size = 592
_f$ = -1044						; size = 1040
__$ArrayPad$ = -4					; size = 4
_MapNextLanguageFile PROC				; COMDAT

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 06 00
	00		 sub	 esp, 1640		; 00000668H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 84   : 	wchar_t f[GST_MAX_PATH*2], *t;
; 85   : 	WIN32_FIND_DATAW find;
; 86   : 	HANDLE file;
; 87   : 	DWORD read;
; 88   : 
; 89   : 	if (LanguageFileFindHandle == INVALID_HANDLE_VALUE)

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageFileFindHandle
  00018	56		 push	 esi
  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetModuleFileNameW@12
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	0f 85 53 01 00
	00		 jne	 $LN2@MapNextLan

; 90   : 	{
; 91   : 		GetModuleFileNameW (NULL, f, sizeof (f) / sizeof (f[0]));

  00028	68 08 02 00 00	 push	 520			; 00000208H
  0002d	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _f$[ebp]
  00033	50		 push	 eax
  00034	6a 00		 push	 0
  00036	ff d6		 call	 esi

; 92   : 		t = wcsrchr (f, L'\\');

  00038	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _f$[ebp]
  0003e	6a 5c		 push	 92			; 0000005cH
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _wcsrchr
  00046	8b c8		 mov	 ecx, eax
  00048	83 c4 08	 add	 esp, 8

; 93   : 		if (t == NULL) return NULL;

  0004b	85 c9		 test	 ecx, ecx
  0004d	0f 84 54 01 00
	00		 je	 $LN16@MapNextLan

; 94   : 
; 95   : 		wcscpy (t, L"\\Language*.xml");

  00053	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@
  0005a	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0005d	f3 0f 7e 05 10
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@+16
  00065	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0006a	a1 18 00 00 00	 mov	 eax, DWORD PTR ??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@+24
  0006f	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00072	66 a1 1c 00 00
	00		 mov	 ax, WORD PTR ??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@+28
  00078	66 89 41 1c	 mov	 WORD PTR [ecx+28], ax

; 96   : 
; 97   : 		LanguageFileFindHandle = FindFirstFileW (f, &find);

  0007c	8d 85 9c f9 ff
	ff		 lea	 eax, DWORD PTR _find$[ebp]
  00082	50		 push	 eax
  00083	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _f$[ebp]
  00089	50		 push	 eax
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileW@8
  00090	a3 00 00 00 00	 mov	 DWORD PTR _LanguageFileFindHandle, eax
$LN5@MapNextLan:

; 103  : 		return NULL;
; 104  : 	}
; 105  : 
; 106  : 	if (find.nFileSizeHigh != 0) return NULL;

  00095	83 bd b8 f9 ff
	ff 00		 cmp	 DWORD PTR _find$[ebp+28], 0
  0009c	0f 85 05 01 00
	00		 jne	 $LN16@MapNextLan

; 107  : 
; 108  : 	if (LanguageFileBuffer != NULL) free (LanguageFileBuffer);

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageFileBuffer
  000a7	85 c0		 test	 eax, eax
  000a9	74 09		 je	 SHORT $LN7@MapNextLan
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _free
  000b1	83 c4 04	 add	 esp, 4
$LN7@MapNextLan:

; 109  : 	LanguageFileBuffer = malloc(find.nFileSizeLow);

  000b4	ff b5 bc f9 ff
	ff		 push	 DWORD PTR _find$[ebp+32]
  000ba	e8 00 00 00 00	 call	 _malloc
  000bf	83 c4 04	 add	 esp, 4
  000c2	a3 00 00 00 00	 mov	 DWORD PTR _LanguageFileBuffer, eax

; 110  : 	if (LanguageFileBuffer == NULL) return NULL;

  000c7	85 c0		 test	 eax, eax
  000c9	0f 84 d8 00 00
	00		 je	 $LN16@MapNextLan

; 111  : 
; 112  : 	GetModuleFileNameW (NULL, f, sizeof (f) / sizeof(f[0]));

  000cf	68 08 02 00 00	 push	 520			; 00000208H
  000d4	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _f$[ebp]
  000da	50		 push	 eax
  000db	6a 00		 push	 0
  000dd	ff d6		 call	 esi

; 113  : 	t = wcsrchr (f, L'\\');

  000df	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _f$[ebp]
  000e5	6a 5c		 push	 92			; 0000005cH
  000e7	50		 push	 eax

; 114  : 	wcscpy (t + 1, find.cFileName);

  000e8	8d b5 c8 f9 ff
	ff		 lea	 esi, DWORD PTR _find$[ebp+44]
  000ee	e8 00 00 00 00	 call	 _wcsrchr
  000f3	83 c4 08	 add	 esp, 8
  000f6	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  000f9	8b c6		 mov	 eax, esi
  000fb	2b c8		 sub	 ecx, eax
  000fd	0f 1f 00	 npad	 3
$LL12@MapNextLan:
  00100	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00103	8d 76 02	 lea	 esi, DWORD PTR [esi+2]
  00106	66 89 44 31 fe	 mov	 WORD PTR [ecx+esi-2], ax
  0010b	66 85 c0	 test	 ax, ax
  0010e	75 f0		 jne	 SHORT $LL12@MapNextLan

; 115  : 
; 116  : 	file = CreateFileW (f, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

  00110	6a 00		 push	 0
  00112	6a 00		 push	 0
  00114	6a 03		 push	 3
  00116	6a 00		 push	 0
  00118	6a 00		 push	 0
  0011a	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0011f	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _f$[ebp]
  00125	50		 push	 eax
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileW@28
  0012c	8b f0		 mov	 esi, eax

; 117  : 	if (file == INVALID_HANDLE_VALUE) return NULL;

  0012e	83 fe ff	 cmp	 esi, -1
  00131	74 74		 je	 SHORT $LN16@MapNextLan

; 118  : 
; 119  : 	ReadFile (file, LanguageFileBuffer, find.nFileSizeLow, &read, NULL);

  00133	6a 00		 push	 0
  00135	8d 85 98 f9 ff
	ff		 lea	 eax, DWORD PTR _read$[ebp]
  0013b	50		 push	 eax
  0013c	ff b5 bc f9 ff
	ff		 push	 DWORD PTR _find$[ebp+32]
  00142	ff 35 00 00 00
	00		 push	 DWORD PTR _LanguageFileBuffer
  00148	56		 push	 esi
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20

; 120  : 	CloseHandle (file);

  0014f	56		 push	 esi
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 121  : 	if (read != find.nFileSizeLow) return NULL;

  00156	8b 8d 98 f9 ff
	ff		 mov	 ecx, DWORD PTR _read$[ebp]
  0015c	33 d2		 xor	 edx, edx
  0015e	3b 8d bc f9 ff
	ff		 cmp	 ecx, DWORD PTR _find$[ebp+32]
  00164	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageFileBuffer
  00169	0f 45 c2	 cmovne	 eax, edx
  0016c	5e		 pop	 esi

; 122  : 
; 123  : 	return LanguageFileBuffer;
; 124  : }

  0016d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00170	33 cd		 xor	 ecx, ebp
  00172	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
$LN2@MapNextLan:

; 98   : 	}
; 99   : 	else if (!FindNextFileW (LanguageFileFindHandle, &find))

  0017b	8d 8d 9c f9 ff
	ff		 lea	 ecx, DWORD PTR _find$[ebp]
  00181	51		 push	 ecx
  00182	50		 push	 eax
  00183	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileW@8
  00189	85 c0		 test	 eax, eax
  0018b	0f 85 04 ff ff
	ff		 jne	 $LN5@MapNextLan

; 100  : 	{
; 101  : 		FindClose (LanguageFileFindHandle);

  00191	ff 35 00 00 00
	00		 push	 DWORD PTR _LanguageFileFindHandle
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4

; 102  : 		LanguageFileFindHandle = INVALID_HANDLE_VALUE;

  0019d	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _LanguageFileFindHandle, -1
$LN16@MapNextLan:

; 122  : 
; 123  : 	return LanguageFileBuffer;
; 124  : }

  001a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001aa	33 c0		 xor	 eax, eax
  001ac	33 cd		 xor	 ecx, ebp
  001ae	5e		 pop	 esi
  001af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c3		 ret	 0
_MapNextLanguageFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\language.c
;	COMDAT _MapFirstLanguageFile
_TEXT	SEGMENT
_size$1 = -4						; size = 4
_MapFirstLanguageFile PROC				; COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 58   : 	if (LanguageFileFindHandle != INVALID_HANDLE_VALUE)

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageFileFindHandle
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	74 11		 je	 SHORT $LN2@MapFirstLa

; 59   : 	{
; 60   : 		FindClose (LanguageFileFindHandle);

  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4

; 61   : 		LanguageFileFindHandle = INVALID_HANDLE_VALUE;

  00015	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _LanguageFileFindHandle, -1
$LN2@MapFirstLa:

; 62   : 	}
; 63   : 
; 64   : 	if (LanguageResource == NULL)

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageResource
  00024	85 c0		 test	 eax, eax
  00026	75 1b		 jne	 SHORT $LN3@MapFirstLa

; 65   : 	{
; 66   : 		DWORD size;
; 67   : 		LanguageResource = MapResource ("Xml", IDR_LANGUAGE, &size);

  00028	8d 45 fc	 lea	 eax, DWORD PTR _size$1[ebp]
  0002b	50		 push	 eax
  0002c	68 fa 01 00 00	 push	 506			; 000001faH
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_03FJEFHLHG@Xml?$AA@
  00036	e8 00 00 00 00	 call	 _MapResource
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	a3 00 00 00 00	 mov	 DWORD PTR _LanguageResource, eax
$LN3@MapFirstLa:

; 68   : 		//LanguageResource[size - 1] = 0;
; 69   : 	}
; 70   : 
; 71   : 	return LanguageResource;
; 72   : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_MapFirstLanguageFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2262 :     int _Result;
; 2263 :     va_list _ArgList;
; 2264 :     __crt_va_start(_ArgList, _Format);
; 2265 :     _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vsscanf
  00020	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2266 :     __crt_va_end(_ArgList);
; 2267 :     return _Result;
; 2268 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2166 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2167 :     return __stdio_common_vsscanf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vsscanf
  00020	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2168 :         _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2169 :         _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2170 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __swprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__swprintf PROC						; COMDAT

; 1451 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1452 :     int _Result;
; 1453 :     va_list _ArgList;
; 1454 :     __crt_va_start(_ArgList, _Format);
; 1455 :     _Result = __vswprintf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vswprintf
  00020	83 c9 ff	 or	 ecx, -1
  00023	83 c4 1c	 add	 esp, 28			; 0000001cH
  00026	85 c0		 test	 eax, eax
  00028	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     __crt_va_end(_ArgList);
; 1457 :     return _Result;
; 1458 : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
__swprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT ___vswprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
___vswprintf_l PROC					; COMDAT

; 1214 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1215 :     return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vswprintf
  00020	83 c9 ff	 or	 ecx, -1
  00023	83 c4 1c	 add	 esp, 28			; 0000001cH
  00026	85 c0		 test	 eax, eax
  00028	0f 48 c1	 cmovs	 eax, ecx

; 1216 : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
___vswprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_l PROC					; COMDAT

; 1195 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1196 :     #pragma warning(push)
; 1197 :     #pragma warning(disable: 4996) // Deprecation
; 1198 :     return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vswprintf
  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1199 :     #pragma warning(pop)
; 1200 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vswprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_c_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_c_l PROC					; COMDAT

; 1158 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1159 :     int const _Result = __stdio_common_vswprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vswprintf

; 1160 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1161 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1162 : 
; 1163 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1164 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vswprintf_c_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 83   :     static unsigned __int64 _OptionsStorage;
; 84   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 85   : }

  00005	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\language.c
;	COMDAT _GetActiveLangPackVersion
_TEXT	SEGMENT
_GetActiveLangPackVersion PROC				; COMDAT

; 561  : 	return ActiveLangPackVersion;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET _ActiveLangPackVersion

; 562  : }

  00005	c3		 ret	 0
_GetActiveLangPackVersion ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\language.c
;	COMDAT _SetPreferredLangId
_TEXT	SEGMENT
_langId$ = 8						; size = 4
_SetPreferredLangId PROC				; COMDAT

; 547  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 548  : 	strncpy (PreferredLangId, langId, 5);

  00003	6a 05		 push	 5
  00005	ff 75 08	 push	 DWORD PTR _langId$[ebp]
  00008	68 00 00 00 00	 push	 OFFSET _PreferredLangId
  0000d	e8 00 00 00 00	 call	 _strncpy
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 549  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_SetPreferredLangId ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\language.c
;	COMDAT _GetPreferredLangId
_TEXT	SEGMENT
_GetPreferredLangId PROC				; COMDAT

; 534  : 	return PreferredLangId;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET _PreferredLangId

; 535  : }

  00005	c3		 ret	 0
_GetPreferredLangId ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\language.c
;	COMDAT _LoadLanguageFile
_TEXT	SEGMENT
_size$ = -102596					; size = 4
_size$1 = -102592					; size = 4
_intKey$ = -102588					; size = 4
_langFound$1$ = -102584					; size = 4
_font$2 = -102580					; size = 8
_i$1$ = -102576						; size = 4
_res$1$ = -102572					; size = 4
_defaultLangParsed$1$ = -102568				; size = 4
_xmlElements$ = -102564					; size = 12
_headers$ = -102552					; size = 12
_wattr$ = -102540					; size = 65536
_attr$ = -37004						; size = 32768
_m$3 = -4236						; size = 4096
_key$ = -140						; size = 128
_langId$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_LoadLanguageFile PROC					; COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 c4 90 01 00	 mov	 eax, 102596		; 000190c4H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 136  : 	DWORD size;
; 137  : 	BYTE *res;
; 138  : 	char *xml, *header;
; 139  : 	char langId[6] = "en", attr[32768], key[128];

  00017	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02LFNMGJAP@en?$AA@
  0001d	66 89 45 f4	 mov	 WORD PTR _langId$[ebp], ax
  00021	a0 02 00 00 00	 mov	 al, BYTE PTR ??_C@_02LFNMGJAP@en?$AA@+2
  00026	53		 push	 ebx
  00027	88 45 f6	 mov	 BYTE PTR _langId$[ebp+2], al

; 140  : 	BOOL defaultLangParsed = FALSE, langFound = FALSE;

  0002a	33 db		 xor	 ebx, ebx
  0002c	33 c0		 xor	 eax, eax
  0002e	89 9d 58 6f fe
	ff		 mov	 DWORD PTR _defaultLangParsed$1$[ebp], ebx
  00034	56		 push	 esi
  00035	57		 push	 edi
  00036	66 89 45 f7	 mov	 WORD PTR _langId$[ebp+3], ax
  0003a	88 45 f9	 mov	 BYTE PTR _langId$[ebp+5], al
  0003d	89 85 48 6f fe
	ff		 mov	 DWORD PTR _langFound$1$[ebp], eax

; 141  : 	WCHAR wattr[32768];
; 142  : 	int i, intKey, len;
; 143  : 
; 144  : 	char *xmlElements[] = {"control", "string", 0};

  00043	c7 85 5c 6f fe
	ff 00 00 00 00	 mov	 DWORD PTR _xmlElements$[ebp], OFFSET ??_C@_07MMBOFDEG@control?$AA@
  0004d	c7 85 60 6f fe
	ff 00 00 00 00	 mov	 DWORD PTR _xmlElements$[ebp+4], OFFSET ??_C@_06ICGJLFIM@string?$AA@
  00057	89 85 64 6f fe
	ff		 mov	 DWORD PTR _xmlElements$[ebp+8], eax

; 145  : 
; 146  : #ifdef GSTMOUNT
; 147  : 	int headers[] = { IDR_COMMON_RSRC_HEADER, IDR_MOUNT_RSRC_HEADER, 0 };
; 148  : #endif
; 149  : 
; 150  : #ifdef VOLFORMAT
; 151  : 	int headers[] = { IDR_COMMON_RSRC_HEADER, IDR_FORMAT_RSRC_HEADER, 0 };
; 152  : #endif
; 153  : 
; 154  : #ifdef SETUP
; 155  : 	int headers[] = { IDR_COMMON_RSRC_HEADER, IDR_SETUP_RSRC_HEADER, 0 };

  0005d	c7 85 68 6f fe
	ff 00 02 00 00	 mov	 DWORD PTR _headers$[ebp], 512 ; 00000200H
  00067	c7 85 6c 6f fe
	ff 69 00 00 00	 mov	 DWORD PTR _headers$[ebp+4], 105 ; 00000069H
  00071	89 85 70 6f fe
	ff		 mov	 DWORD PTR _headers$[ebp+8], eax

; 156  : #endif
; 157  : 
; 158  : 	LocalizationActive = FALSE;

  00077	a3 00 00 00 00	 mov	 DWORD PTR _LocalizationActive, eax

; 159  : 	ActiveLangPackVersion[0] = 0;

  0007c	a2 00 00 00 00	 mov	 BYTE PTR _ActiveLangPackVersion, al

; 160  : 	ClearDictionaryPool ();

  00081	e8 00 00 00 00	 call	 _ClearDictionaryPool

; 161  : 
; 162  : 	if (PreferredLangId[0] != 0)

  00086	38 1d 00 00 00
	00		 cmp	 BYTE PTR _PreferredLangId, bl
  0008c	74 13		 je	 SHORT $LN24@LoadLangua

; 163  : 		strcpy (langId, PreferredLangId);

  0008e	33 c9		 xor	 ecx, ecx
$LL56@LoadLangua:
  00090	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _PreferredLangId[ecx]
  00096	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00099	88 44 0d f3	 mov	 BYTE PTR _langId$[ebp+ecx-1], al
  0009d	84 c0		 test	 al, al
  0009f	75 ef		 jne	 SHORT $LL56@LoadLangua
$LN24@LoadLangua:

; 164  : 
; 165  : 	// Parse all available language files until preferred language is found
; 166  : 	for (res = MapFirstLanguageFile (); res != NULL; res = MapNextLanguageFile ())

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageFileFindHandle
  000a6	83 f8 ff	 cmp	 eax, -1
  000a9	74 11		 je	 SHORT $LN60@LoadLangua
  000ab	50		 push	 eax
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  000b2	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _LanguageFileFindHandle, -1
$LN60@LoadLangua:
  000bc	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _LanguageResource
  000c2	89 bd 54 6f fe
	ff		 mov	 DWORD PTR _res$1$[ebp], edi
  000c8	85 ff		 test	 edi, edi
  000ca	75 34		 jne	 SHORT $LL4@LoadLangua
  000cc	8d 85 40 6f fe
	ff		 lea	 eax, DWORD PTR _size$1[ebp]
  000d2	50		 push	 eax
  000d3	68 fa 01 00 00	 push	 506			; 000001faH
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_03FJEFHLHG@Xml?$AA@
  000dd	e8 00 00 00 00	 call	 _MapResource
  000e2	8b f8		 mov	 edi, eax
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e7	89 bd 54 6f fe
	ff		 mov	 DWORD PTR _res$1$[ebp], edi
  000ed	89 3d 00 00 00
	00		 mov	 DWORD PTR _LanguageResource, edi
  000f3	85 ff		 test	 edi, edi
  000f5	0f 84 bf 05 00
	00		 je	 $LN120@LoadLangua
  000fb	0f 1f 44 00 00	 npad	 5
$LL4@LoadLangua:

; 167  : 	{
; 168  : 		xml = (char *) res;
; 169  : 		xml = XmlFindElement (xml, "localization");

  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MFNNBINO@localization?$AA@
  00105	57		 push	 edi
  00106	e8 00 00 00 00	 call	 _XmlFindElement
  0010b	8b f0		 mov	 esi, eax
  0010d	83 c4 08	 add	 esp, 8

; 170  : 		if (!xml)

  00110	85 f6		 test	 esi, esi
  00112	0f 84 24 05 00
	00		 je	 $LN2@LoadLangua

; 171  : 			continue;
; 172  : 
; 173  : 		// Required GostCrypt version
; 174  : 		XmlGetAttributeText (xml, "prog-version", attr, sizeof (attr));

  00118	68 00 80 00 00	 push	 32768			; 00008000H
  0011d	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  00123	50		 push	 eax
  00124	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LEFFHNKM@prog?9version?$AA@
  00129	56		 push	 esi
  0012a	e8 00 00 00 00	 call	 _XmlGetAttributeText
  0012f	83 c4 10	 add	 esp, 16			; 00000010H

; 175  : 
; 176  : 		// Check version of external language file
; 177  : 		if (defaultLangParsed && strcmp (attr, VERSION_STRING) && strcmp (attr, "DEBUG"))

  00132	85 db		 test	 ebx, ebx
  00134	0f 84 4d 01 00
	00		 je	 $LN29@LoadLangua
  0013a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05OJPKCACG@1?43?41?$AA@
  0013f	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
$LL121@LoadLangua:
  00145	8a 10		 mov	 dl, BYTE PTR [eax]
  00147	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00149	75 1a		 jne	 SHORT $LN122@LoadLangua
  0014b	84 d2		 test	 dl, dl
  0014d	74 12		 je	 SHORT $LN123@LoadLangua
  0014f	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00152	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00155	75 0e		 jne	 SHORT $LN122@LoadLangua
  00157	83 c0 02	 add	 eax, 2
  0015a	83 c1 02	 add	 ecx, 2
  0015d	84 d2		 test	 dl, dl
  0015f	75 e4		 jne	 SHORT $LL121@LoadLangua
$LN123@LoadLangua:
  00161	33 c0		 xor	 eax, eax
  00163	eb 05		 jmp	 SHORT $LN124@LoadLangua
$LN122@LoadLangua:
  00165	1b c0		 sbb	 eax, eax
  00167	83 c8 01	 or	 eax, 1
$LN124@LoadLangua:
  0016a	85 c0		 test	 eax, eax
  0016c	74 71		 je	 SHORT $LN26@LoadLangua
  0016e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05KOLFGEDA@DEBUG?$AA@
  00173	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  00179	0f 1f 80 00 00
	00 00		 npad	 7
$LL125@LoadLangua:
  00180	8a 10		 mov	 dl, BYTE PTR [eax]
  00182	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00184	75 1a		 jne	 SHORT $LN126@LoadLangua
  00186	84 d2		 test	 dl, dl
  00188	74 12		 je	 SHORT $LN127@LoadLangua
  0018a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0018d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00190	75 0e		 jne	 SHORT $LN126@LoadLangua
  00192	83 c0 02	 add	 eax, 2
  00195	83 c1 02	 add	 ecx, 2
  00198	84 d2		 test	 dl, dl
  0019a	75 e4		 jne	 SHORT $LL125@LoadLangua
$LN127@LoadLangua:
  0019c	33 c0		 xor	 eax, eax
  0019e	eb 05		 jmp	 SHORT $LN128@LoadLangua
$LN126@LoadLangua:
  001a0	1b c0		 sbb	 eax, eax
  001a2	83 c8 01	 or	 eax, 1
$LN128@LoadLangua:
  001a5	85 c0		 test	 eax, eax
  001a7	74 36		 je	 SHORT $LN26@LoadLangua

; 178  : 		{
; 179  : 			wchar_t m[2048];
; 180  : 			swprintf (m, L"The installed language pack is incompatible with this version of GostCrypt (the language pack is for GostCrypt %hs). A newer version may be available at www.gostcrypt.org.\n\nTo prevent this message from being displayed, do any of the following:\n\n- Select 'Settings' > 'Language'; then select 'English' and click 'OK'.\n\n- Remove or replace the language pack with a compatible version (the language pack may reside e.g. in 'C:\\Program Files\\GostCrypt' or '%%LOCALAPPDATA%%\\VirtualStore\\Program Files\\GostCrypt', etc.)", attr);

  001a9	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  001af	50		 push	 eax
  001b0	8d 85 74 ef ff
	ff		 lea	 eax, DWORD PTR _m$3[ebp]
  001b6	68 00 00 00 00	 push	 OFFSET ??_C@_1EAG@FAENFIFC@?$AAT?$AAh?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?5?$AAl?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?5?$AAp?$AAa?$AAc?$AAk?$AA?5?$AAi?$AAs?$AA?5?$AAi@
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 __swprintf
  001c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 181  : 			MessageBoxW (NULL, m, L"GostCrypt", MB_ICONERROR);

  001c4	8d 85 74 ef ff
	ff		 lea	 eax, DWORD PTR _m$3[ebp]
  001ca	6a 10		 push	 16			; 00000010H
  001cc	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@NJGOLFGO@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@
  001d1	50		 push	 eax
  001d2	6a 00		 push	 0
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 182  : 			continue;

  001da	e9 5d 04 00 00	 jmp	 $LN2@LoadLangua
$LN26@LoadLangua:

; 183  : 		}
; 184  : 
; 185  : 		// Search language id in language file
; 186  : 		if (defaultLangParsed)
; 187  : 		{
; 188  : 			while (xml = XmlFindElement (xml, "language"))

  001df	68 00 00 00 00	 push	 OFFSET ??_C@_08JGCCIMAA@language?$AA@
  001e4	56		 push	 esi
  001e5	e8 00 00 00 00	 call	 _XmlFindElement
  001ea	8b f0		 mov	 esi, eax
  001ec	83 c4 08	 add	 esp, 8
  001ef	85 f6		 test	 esi, esi
  001f1	0f 84 45 04 00
	00		 je	 $LN2@LoadLangua
  001f7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL5@LoadLangua:

; 189  : 			{
; 190  : 				XmlGetAttributeText (xml, "langid", attr, sizeof (attr));

  00200	68 00 80 00 00	 push	 32768			; 00008000H
  00205	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  0020b	50		 push	 eax
  0020c	68 00 00 00 00	 push	 OFFSET ??_C@_06CLEJICHF@langid?$AA@
  00211	56		 push	 esi
  00212	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00217	83 c4 10	 add	 esp, 16			; 00000010H

; 191  : 				if (strcmp (attr, langId) == 0)

  0021a	8d 4d f4	 lea	 ecx, DWORD PTR _langId$[ebp]
  0021d	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
$LL129@LoadLangua:
  00223	8a 10		 mov	 dl, BYTE PTR [eax]
  00225	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00227	75 1a		 jne	 SHORT $LN130@LoadLangua
  00229	84 d2		 test	 dl, dl
  0022b	74 12		 je	 SHORT $LN131@LoadLangua
  0022d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00230	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00233	75 0e		 jne	 SHORT $LN130@LoadLangua
  00235	83 c0 02	 add	 eax, 2
  00238	83 c1 02	 add	 ecx, 2
  0023b	84 d2		 test	 dl, dl
  0023d	75 e4		 jne	 SHORT $LL129@LoadLangua
$LN131@LoadLangua:
  0023f	33 c0		 xor	 eax, eax
  00241	eb 05		 jmp	 SHORT $LN132@LoadLangua
$LN130@LoadLangua:
  00243	1b c0		 sbb	 eax, eax
  00245	83 c8 01	 or	 eax, 1
$LN132@LoadLangua:
  00248	85 c0		 test	 eax, eax
  0024a	74 1c		 je	 SHORT $LN87@LoadLangua

; 195  : 					break;
; 196  : 				}
; 197  : 				xml++;

  0024c	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_08JGCCIMAA@language?$AA@
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 _XmlFindElement
  0025a	8b f0		 mov	 esi, eax
  0025c	83 c4 08	 add	 esp, 8
  0025f	85 f6		 test	 esi, esi
  00261	75 9d		 jne	 SHORT $LL5@LoadLangua

; 327  : 		if (header == NULL) return FALSE;

  00263	e9 d4 03 00 00	 jmp	 $LN2@LoadLangua
$LN87@LoadLangua:

; 192  : 				{
; 193  : 					XmlGetAttributeText (xml++, "version", ActiveLangPackVersion, sizeof (ActiveLangPackVersion));

  00268	6a 06		 push	 6
  0026a	68 00 00 00 00	 push	 OFFSET _ActiveLangPackVersion
  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_07CPCPJPKL@version?$AA@
  00274	56		 push	 esi
  00275	e8 00 00 00 00	 call	 _XmlGetAttributeText
  0027a	83 c4 10	 add	 esp, 16			; 00000010H

; 194  : 					langFound = TRUE;

  0027d	c7 85 48 6f fe
	ff 01 00 00 00	 mov	 DWORD PTR _langFound$1$[ebp], 1
$LN29@LoadLangua:

; 198  : 			}
; 199  : 
; 200  : 			if (!langFound) continue;
; 201  : 		}
; 202  : 
; 203  : 		// Create font dictionary
; 204  : 		xml = (char *) res;
; 205  : 		while (xml = XmlFindElement (xml, "font"))

  00287	68 00 00 00 00	 push	 OFFSET ??_C@_04EFPADHIC@font?$AA@
  0028c	57		 push	 edi
  0028d	e8 00 00 00 00	 call	 _XmlFindElement
  00292	8b f8		 mov	 edi, eax
  00294	83 c4 08	 add	 esp, 8
  00297	85 ff		 test	 edi, edi
  00299	0f 84 75 01 00
	00		 je	 $LN8@LoadLangua
  0029f	90		 npad	 1
$LL7@LoadLangua:

; 206  : 		{
; 207  : 			XmlGetAttributeText (xml, "lang", attr, sizeof (attr));

  002a0	68 00 80 00 00	 push	 32768			; 00008000H
  002a5	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  002ab	50		 push	 eax
  002ac	68 00 00 00 00	 push	 OFFSET ??_C@_04IOHABJIC@lang?$AA@
  002b1	57		 push	 edi
  002b2	e8 00 00 00 00	 call	 _XmlGetAttributeText
  002b7	83 c4 10	 add	 esp, 16			; 00000010H

; 208  : 			if (!defaultLangParsed
; 209  : 				|| strcmp (attr, langId) == 0)

  002ba	85 db		 test	 ebx, ebx
  002bc	74 36		 je	 SHORT $LN31@LoadLangua
  002be	8d 4d f4	 lea	 ecx, DWORD PTR _langId$[ebp]
  002c1	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
$LL133@LoadLangua:
  002c7	8a 10		 mov	 dl, BYTE PTR [eax]
  002c9	3a 11		 cmp	 dl, BYTE PTR [ecx]
  002cb	75 1a		 jne	 SHORT $LN134@LoadLangua
  002cd	84 d2		 test	 dl, dl
  002cf	74 12		 je	 SHORT $LN135@LoadLangua
  002d1	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  002d4	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002d7	75 0e		 jne	 SHORT $LN134@LoadLangua
  002d9	83 c0 02	 add	 eax, 2
  002dc	83 c1 02	 add	 ecx, 2
  002df	84 d2		 test	 dl, dl
  002e1	75 e4		 jne	 SHORT $LL133@LoadLangua
$LN135@LoadLangua:
  002e3	33 c0		 xor	 eax, eax
  002e5	eb 05		 jmp	 SHORT $LN136@LoadLangua
$LN134@LoadLangua:
  002e7	1b c0		 sbb	 eax, eax
  002e9	83 c8 01	 or	 eax, 1
$LN136@LoadLangua:
  002ec	85 c0		 test	 eax, eax
  002ee	0f 85 05 01 00
	00		 jne	 $LN30@LoadLangua
$LN31@LoadLangua:

; 210  : 			{
; 211  : 				Font font;
; 212  : 				memset (&font, 0, sizeof (font));
; 213  : 
; 214  : 				XmlGetAttributeText (xml, "face", attr, sizeof (attr));

  002f4	68 00 80 00 00	 push	 32768			; 00008000H
  002f9	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  002ff	0f 57 c0	 xorps	 xmm0, xmm0
  00302	50		 push	 eax
  00303	68 00 00 00 00	 push	 OFFSET ??_C@_04POCOPAPC@face?$AA@
  00308	57		 push	 edi
  00309	66 0f d6 85 4c
	6f fe ff	 movq	 QWORD PTR _font$2[ebp], xmm0
  00311	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00316	83 c4 10	 add	 esp, 16			; 00000010H

; 215  : 			
; 216  : 				len = MultiByteToWideChar (CP_UTF8, 0, attr, -1, wattr, sizeof (wattr) / sizeof(wattr[0]));

  00319	8d 85 74 6f fe
	ff		 lea	 eax, DWORD PTR _wattr$[ebp]
  0031f	68 00 80 00 00	 push	 32768			; 00008000H
  00324	50		 push	 eax
  00325	6a ff		 push	 -1
  00327	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  0032d	50		 push	 eax
  0032e	6a 00		 push	 0
  00330	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 217  : 				font.FaceName = AddPoolData ((void *) wattr, len * 2);

  0033b	03 c0		 add	 eax, eax
  0033d	50		 push	 eax
  0033e	8d 85 74 6f fe
	ff		 lea	 eax, DWORD PTR _wattr$[ebp]
  00344	50		 push	 eax
  00345	e8 00 00 00 00	 call	 _AddPoolData
  0034a	89 85 4c 6f fe
	ff		 mov	 DWORD PTR _font$2[ebp], eax

; 218  : 				
; 219  : 				XmlGetAttributeText (xml, "size", attr, sizeof (attr));

  00350	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  00356	68 00 80 00 00	 push	 32768			; 00008000H
  0035b	50		 push	 eax
  0035c	68 00 00 00 00	 push	 OFFSET ??_C@_04IAGNFIBA@size?$AA@
  00361	57		 push	 edi
  00362	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 220  : 				sscanf (attr, "%d", &font.Size);

  00367	8d 85 50 6f fe
	ff		 lea	 eax, DWORD PTR _font$2[ebp+4]
  0036d	50		 push	 eax
  0036e	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  00374	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00379	50		 push	 eax
  0037a	e8 00 00 00 00	 call	 _sscanf

; 221  : 
; 222  : 				strcpy (attr, "font_");

  0037f	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05DONAFDKA@font_?$AA@
  00384	89 85 74 6f ff
	ff		 mov	 DWORD PTR _attr$[ebp], eax
  0038a	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_05DONAFDKA@font_?$AA@+4
  00390	66 89 85 78 6f
	ff ff		 mov	 WORD PTR _attr$[ebp+4], ax

; 223  : 				XmlGetAttributeText (xml, "class", attr + 5, sizeof (attr) - 5);

  00397	8d 85 79 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp+5]
  0039d	68 fb 7f 00 00	 push	 32763			; 00007ffbH
  003a2	50		 push	 eax
  003a3	68 00 00 00 00	 push	 OFFSET ??_C@_05ENKANFLO@class?$AA@
  003a8	57		 push	 edi
  003a9	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 224  : 				AddDictionaryEntry (

  003ae	8d b5 74 6f ff
	ff		 lea	 esi, DWORD PTR _attr$[ebp]
  003b4	83 c4 34	 add	 esp, 52			; 00000034H
  003b7	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  003ba	66 0f 1f 44 00
	00		 npad	 6
$LL137@LoadLangua:
  003c0	8a 06		 mov	 al, BYTE PTR [esi]
  003c2	46		 inc	 esi
  003c3	84 c0		 test	 al, al
  003c5	75 f9		 jne	 SHORT $LL137@LoadLangua
  003c7	8d 85 4c 6f fe
	ff		 lea	 eax, DWORD PTR _font$2[ebp]
  003cd	2b f1		 sub	 esi, ecx
  003cf	6a 08		 push	 8
  003d1	50		 push	 eax
  003d2	e8 00 00 00 00	 call	 _AddPoolData
  003d7	83 c4 08	 add	 esp, 8
  003da	50		 push	 eax
  003db	6a 00		 push	 0
  003dd	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  003e0	50		 push	 eax
  003e1	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  003e7	50		 push	 eax
  003e8	e8 00 00 00 00	 call	 _AddPoolData
  003ed	83 c4 08	 add	 esp, 8
  003f0	50		 push	 eax
  003f1	e8 00 00 00 00	 call	 _AddDictionaryEntry
  003f6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN30@LoadLangua:

; 225  : 					AddPoolData ((void *) attr, strlen (attr) + 1), 0,
; 226  : 					AddPoolData ((void *) &font, sizeof(font)));
; 227  : 			}
; 228  : 
; 229  : 			xml++;

  003f9	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  003fc	68 00 00 00 00	 push	 OFFSET ??_C@_04EFPADHIC@font?$AA@
  00401	50		 push	 eax
  00402	e8 00 00 00 00	 call	 _XmlFindElement
  00407	8b f8		 mov	 edi, eax
  00409	83 c4 08	 add	 esp, 8
  0040c	85 ff		 test	 edi, edi
  0040e	0f 85 8c fe ff
	ff		 jne	 $LL7@LoadLangua
$LN8@LoadLangua:

; 230  : 		}
; 231  : 
; 232  : 		// Create string and control dictionaries
; 233  : 		for (i = 0; xmlElements[i] != 0; i++)

  00414	33 ff		 xor	 edi, edi
  00416	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_07MMBOFDEG@control?$AA@
  0041b	89 bd 50 6f fe
	ff		 mov	 DWORD PTR _i$1$[ebp], edi
$LL11@LoadLangua:

; 234  : 		{
; 235  : 			xml = (char *) res;
; 236  : 			while (xml = XmlFindElement (xml, xmlElements[i]))

  00421	53		 push	 ebx
  00422	ff b5 54 6f fe
	ff		 push	 DWORD PTR _res$1$[ebp]
  00428	e8 00 00 00 00	 call	 _XmlFindElement
  0042d	8b f0		 mov	 esi, eax
  0042f	83 c4 08	 add	 esp, 8
  00432	85 f6		 test	 esi, esi
  00434	0f 84 90 01 00
	00		 je	 $LN9@LoadLangua
  0043a	66 0f 1f 44 00
	00		 npad	 6
$LL12@LoadLangua:

; 237  : 			{
; 238  : 				void *key;
; 239  : 				void *text;
; 240  : 
; 241  : 				XmlGetAttributeText (xml, "lang", attr, sizeof (attr));

  00440	68 00 80 00 00	 push	 32768			; 00008000H
  00445	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  0044b	50		 push	 eax
  0044c	68 00 00 00 00	 push	 OFFSET ??_C@_04IOHABJIC@lang?$AA@
  00451	56		 push	 esi
  00452	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00457	83 c4 10	 add	 esp, 16			; 00000010H

; 242  : 				if (!defaultLangParsed
; 243  : 					|| strcmp (attr, langId) == 0)

  0045a	83 bd 58 6f fe
	ff 00		 cmp	 DWORD PTR _defaultLangParsed$1$[ebp], 0
  00461	74 3a		 je	 SHORT $LN33@LoadLangua
  00463	8d 4d f4	 lea	 ecx, DWORD PTR _langId$[ebp]
  00466	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  0046c	0f 1f 40 00	 npad	 4
$LL138@LoadLangua:
  00470	8a 10		 mov	 dl, BYTE PTR [eax]
  00472	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00474	75 1a		 jne	 SHORT $LN139@LoadLangua
  00476	84 d2		 test	 dl, dl
  00478	74 12		 je	 SHORT $LN140@LoadLangua
  0047a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0047d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00480	75 0e		 jne	 SHORT $LN139@LoadLangua
  00482	83 c0 02	 add	 eax, 2
  00485	83 c1 02	 add	 ecx, 2
  00488	84 d2		 test	 dl, dl
  0048a	75 e4		 jne	 SHORT $LL138@LoadLangua
$LN140@LoadLangua:
  0048c	33 c0		 xor	 eax, eax
  0048e	eb 05		 jmp	 SHORT $LN141@LoadLangua
$LN139@LoadLangua:
  00490	1b c0		 sbb	 eax, eax
  00492	83 c8 01	 or	 eax, 1
$LN141@LoadLangua:
  00495	85 c0		 test	 eax, eax
  00497	0f 85 10 01 00
	00		 jne	 $LN34@LoadLangua
$LN33@LoadLangua:

; 244  : 				{
; 245  : 					if (XmlGetAttributeText (xml, "key", attr, sizeof (attr)))

  0049d	68 00 80 00 00	 push	 32768			; 00008000H
  004a2	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  004a8	50		 push	 eax
  004a9	68 00 00 00 00	 push	 OFFSET ??_C@_03ICHNJLJF@key?$AA@
  004ae	56		 push	 esi
  004af	e8 00 00 00 00	 call	 _XmlGetAttributeText
  004b4	83 c4 10	 add	 esp, 16			; 00000010H
  004b7	85 c0		 test	 eax, eax
  004b9	0f 84 ee 00 00
	00		 je	 $LN34@LoadLangua

; 246  : 					{
; 247  : 						key = AddPoolData (attr, strlen (attr) + 1);

  004bf	8d 8d 74 6f ff
	ff		 lea	 ecx, DWORD PTR _attr$[ebp]
  004c5	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL142@LoadLangua:
  004c8	8a 01		 mov	 al, BYTE PTR [ecx]
  004ca	41		 inc	 ecx
  004cb	84 c0		 test	 al, al
  004cd	75 f9		 jne	 SHORT $LL142@LoadLangua
  004cf	2b ca		 sub	 ecx, edx
  004d1	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  004d4	50		 push	 eax
  004d5	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  004db	50		 push	 eax
  004dc	e8 00 00 00 00	 call	 _AddPoolData
  004e1	8b f8		 mov	 edi, eax
  004e3	83 c4 08	 add	 esp, 8

; 248  : 						if (key == NULL) return FALSE;

  004e6	85 ff		 test	 edi, edi
  004e8	0f 84 75 01 00
	00		 je	 $LN93@LoadLangua

; 249  : 
; 250  : 						XmlGetNodeText (xml, attr, sizeof (attr));

  004ee	68 00 80 00 00	 push	 32768			; 00008000H
  004f3	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  004f9	50		 push	 eax
  004fa	56		 push	 esi
  004fb	e8 00 00 00 00	 call	 _XmlGetNodeText
  00500	83 c4 0c	 add	 esp, 12			; 0000000cH

; 251  : 
; 252  : 						// Parse \ escape sequences
; 253  : 						{
; 254  : 							char *in = attr, *out = attr;

  00503	8d 8d 74 6f ff
	ff		 lea	 ecx, DWORD PTR _attr$[ebp]

; 255  : 							while (*in)

  00509	80 bd 74 6f ff
	ff 00		 cmp	 BYTE PTR _attr$[ebp], 0
  00510	8b c1		 mov	 eax, ecx
  00512	74 3b		 je	 SHORT $LN15@LoadLangua
$LL14@LoadLangua:

; 256  : 							{
; 257  : 								if (*in == '\\')

  00514	8a 11		 mov	 dl, BYTE PTR [ecx]
  00516	80 fa 5c	 cmp	 dl, 92			; 0000005cH
  00519	75 2b		 jne	 SHORT $LN36@LoadLangua

; 258  : 								{
; 259  : 									in++;
; 260  : 									switch (*in++)

  0051b	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  0051f	41		 inc	 ecx
  00520	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  00523	74 1c		 je	 SHORT $LN38@LoadLangua
  00525	83 fa 6e	 cmp	 edx, 110		; 0000006eH
  00528	74 0e		 je	 SHORT $LN40@LoadLangua
  0052a	83 fa 74	 cmp	 edx, 116		; 00000074H
  0052d	0f 85 20 01 00
	00		 jne	 $LN88@LoadLangua

; 263  : 									case 't': *out++ = '\t'; break;

  00533	c6 00 09	 mov	 BYTE PTR [eax], 9
  00536	eb 10		 jmp	 SHORT $LN37@LoadLangua
$LN40@LoadLangua:

; 264  : 									case 'n': *out++ = 13; *out++ = 10; break;

  00538	c6 00 0d	 mov	 BYTE PTR [eax], 13	; 0000000dH
  0053b	40		 inc	 eax
  0053c	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH
  0053f	eb 07		 jmp	 SHORT $LN37@LoadLangua
$LN38@LoadLangua:

; 261  : 									{
; 262  : 									case '\\': *out++ = '\\'; break;

  00541	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH

; 267  : 										return FALSE;
; 268  : 									}
; 269  : 								}

  00544	eb 02		 jmp	 SHORT $LN37@LoadLangua
$LN36@LoadLangua:

; 270  : 								else
; 271  : 									*out++ = *in++;

  00546	88 10		 mov	 BYTE PTR [eax], dl
$LN37@LoadLangua:

; 255  : 							while (*in)

  00548	41		 inc	 ecx
  00549	40		 inc	 eax
  0054a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0054d	75 c5		 jne	 SHORT $LL14@LoadLangua
$LN15@LoadLangua:

; 272  : 							}
; 273  : 							*out = 0;
; 274  : 						}
; 275  : 
; 276  : 						// UTF8 => wide char
; 277  : 						len = MultiByteToWideChar (CP_UTF8, 0, attr, -1, wattr, sizeof (wattr) / sizeof(wattr[0]));

  0054f	68 00 80 00 00	 push	 32768			; 00008000H
  00554	c6 00 00	 mov	 BYTE PTR [eax], 0
  00557	8d 85 74 6f fe
	ff		 lea	 eax, DWORD PTR _wattr$[ebp]
  0055d	50		 push	 eax
  0055e	6a ff		 push	 -1
  00560	8d 85 74 6f ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  00566	50		 push	 eax
  00567	6a 00		 push	 0
  00569	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  0056e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 278  : 						if (len == 0 || len == ERROR_NO_UNICODE_TRANSLATION)

  00574	85 c0		 test	 eax, eax
  00576	0f 84 fa 00 00
	00		 je	 $LN43@LoadLangua
  0057c	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  00581	0f 84 ef 00 00
	00		 je	 $LN43@LoadLangua

; 282  : 						}
; 283  : 
; 284  : 						// Add to dictionary
; 285  : 						text = AddPoolData ((void *) wattr, len * 2);

  00587	03 c0		 add	 eax, eax
  00589	50		 push	 eax
  0058a	8d 85 74 6f fe
	ff		 lea	 eax, DWORD PTR _wattr$[ebp]
  00590	50		 push	 eax
  00591	e8 00 00 00 00	 call	 _AddPoolData
  00596	83 c4 08	 add	 esp, 8

; 286  : 						if (text == NULL) return FALSE;

  00599	85 c0		 test	 eax, eax
  0059b	0f 84 c2 00 00
	00		 je	 $LN93@LoadLangua

; 287  : 
; 288  : 						AddDictionaryEntry ((char *) key, 0, text);

  005a1	50		 push	 eax
  005a2	6a 00		 push	 0
  005a4	57		 push	 edi
  005a5	e8 00 00 00 00	 call	 _AddDictionaryEntry
  005aa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@LoadLangua:

; 289  : 					}
; 290  : 				}
; 291  : 
; 292  : 				xml++;

  005ad	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  005b0	53		 push	 ebx
  005b1	50		 push	 eax
  005b2	e8 00 00 00 00	 call	 _XmlFindElement
  005b7	8b f0		 mov	 esi, eax
  005b9	83 c4 08	 add	 esp, 8
  005bc	85 f6		 test	 esi, esi
  005be	0f 85 7c fe ff
	ff		 jne	 $LL12@LoadLangua
  005c4	8b bd 50 6f fe
	ff		 mov	 edi, DWORD PTR _i$1$[ebp]
$LN9@LoadLangua:

; 230  : 		}
; 231  : 
; 232  : 		// Create string and control dictionaries
; 233  : 		for (i = 0; xmlElements[i] != 0; i++)

  005ca	8b 9c bd 60 6f
	fe ff		 mov	 ebx, DWORD PTR _xmlElements$[ebp+edi*4+4]
  005d1	47		 inc	 edi
  005d2	89 bd 50 6f fe
	ff		 mov	 DWORD PTR _i$1$[ebp], edi
  005d8	85 db		 test	 ebx, ebx
  005da	0f 85 41 fe ff
	ff		 jne	 $LL11@LoadLangua

; 293  : 			}
; 294  : 		}
; 295  : 
; 296  : 		if (langFound)

  005e0	39 9d 48 6f fe
	ff		 cmp	 DWORD PTR _langFound$1$[ebp], ebx
  005e6	0f 85 93 00 00
	00		 jne	 $LN118@LoadLangua

; 297  : 			break;
; 298  : 
; 299  : 		if (!defaultLangParsed)

  005ec	8b 9d 58 6f fe
	ff		 mov	 ebx, DWORD PTR _defaultLangParsed$1$[ebp]
  005f2	85 db		 test	 ebx, ebx
  005f4	75 46		 jne	 SHORT $LN2@LoadLangua

; 300  : 		{
; 301  : 			defaultLangParsed = TRUE;
; 302  : 			if (langId[0] == 0 || strcmp (langId, "en") == 0)

  005f6	80 7d f4 00	 cmp	 BYTE PTR _langId$[ebp], 0
  005fa	bb 01 00 00 00	 mov	 ebx, 1
  005ff	89 9d 58 6f fe
	ff		 mov	 DWORD PTR _defaultLangParsed$1$[ebp], ebx
  00605	0f 84 af 00 00
	00		 je	 $LN120@LoadLangua
  0060b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02LFNMGJAP@en?$AA@
  00610	8d 45 f4	 lea	 eax, DWORD PTR _langId$[ebp]
$LL143@LoadLangua:
  00613	8a 10		 mov	 dl, BYTE PTR [eax]
  00615	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00617	75 1a		 jne	 SHORT $LN144@LoadLangua
  00619	84 d2		 test	 dl, dl
  0061b	74 12		 je	 SHORT $LN145@LoadLangua
  0061d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00620	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00623	75 0e		 jne	 SHORT $LN144@LoadLangua
  00625	83 c0 02	 add	 eax, 2
  00628	83 c1 02	 add	 ecx, 2
  0062b	84 d2		 test	 dl, dl
  0062d	75 e4		 jne	 SHORT $LL143@LoadLangua
$LN145@LoadLangua:
  0062f	33 c0		 xor	 eax, eax
  00631	eb 05		 jmp	 SHORT $LN146@LoadLangua
$LN144@LoadLangua:
  00633	1b c0		 sbb	 eax, eax
  00635	83 c8 01	 or	 eax, 1
$LN146@LoadLangua:
  00638	85 c0		 test	 eax, eax
  0063a	74 7e		 je	 SHORT $LN120@LoadLangua
$LN2@LoadLangua:

; 164  : 
; 165  : 	// Parse all available language files until preferred language is found
; 166  : 	for (res = MapFirstLanguageFile (); res != NULL; res = MapNextLanguageFile ())

  0063c	e8 00 00 00 00	 call	 _MapNextLanguageFile
  00641	8b f8		 mov	 edi, eax
  00643	89 bd 54 6f fe
	ff		 mov	 DWORD PTR _res$1$[ebp], edi
  00649	85 ff		 test	 edi, edi
  0064b	0f 85 af fa ff
	ff		 jne	 $LL4@LoadLangua
  00651	eb 67		 jmp	 SHORT $LN120@LoadLangua
$LN88@LoadLangua:

; 265  : 									default:
; 266  : 										MessageBox (0, key, "GostCrypt: Unknown '\\' escape sequence in string", MB_ICONERROR);

  00653	6a 10		 push	 16			; 00000010H
  00655	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@KHINFMBF@GostCrypt?3?5Unknown?5?8?2?8?5escape?5se@
$LN155@LoadLangua:

; 279  : 						{
; 280  : 							MessageBox (0, key, "GostCrypt: Error while decoding UTF-8 string", MB_ICONERROR);

  0065a	57		 push	 edi
  0065b	6a 00		 push	 0
  0065d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN93@LoadLangua:

; 327  : 		if (header == NULL) return FALSE;

  00663	5f		 pop	 edi
  00664	5e		 pop	 esi
  00665	33 c0		 xor	 eax, eax
  00667	5b		 pop	 ebx

; 340  : 	}
; 341  : 
; 342  : 	return TRUE;
; 343  : }

  00668	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0066b	33 cd		 xor	 ecx, ebp
  0066d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00672	8b e5		 mov	 esp, ebp
  00674	5d		 pop	 ebp
  00675	c3		 ret	 0
$LN43@LoadLangua:

; 279  : 						{
; 280  : 							MessageBox (0, key, "GostCrypt: Error while decoding UTF-8 string", MB_ICONERROR);

  00676	6a 10		 push	 16			; 00000010H
  00678	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@GDBBBHBL@GostCrypt?3?5Error?5while?5decoding?5@

; 281  : 							return FALSE;

  0067d	eb db		 jmp	 SHORT $LN155@LoadLangua
$LN118@LoadLangua:

; 303  : 				break;
; 304  : 		}
; 305  : 	}
; 306  : 
; 307  : 	LocalizationActive = langFound && strcmp (langId, "en") != 0;

  0067f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02LFNMGJAP@en?$AA@
  00684	8d 45 f4	 lea	 eax, DWORD PTR _langId$[ebp]
$LL147@LoadLangua:
  00687	8a 10		 mov	 dl, BYTE PTR [eax]
  00689	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0068b	75 1a		 jne	 SHORT $LN148@LoadLangua
  0068d	84 d2		 test	 dl, dl
  0068f	74 12		 je	 SHORT $LN149@LoadLangua
  00691	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00694	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00697	75 0e		 jne	 SHORT $LN148@LoadLangua
  00699	83 c0 02	 add	 eax, 2
  0069c	83 c1 02	 add	 ecx, 2
  0069f	84 d2		 test	 dl, dl
  006a1	75 e4		 jne	 SHORT $LL147@LoadLangua
$LN149@LoadLangua:
  006a3	33 c0		 xor	 eax, eax
  006a5	eb 05		 jmp	 SHORT $LN150@LoadLangua
$LN148@LoadLangua:
  006a7	1b c0		 sbb	 eax, eax
  006a9	83 c8 01	 or	 eax, 1
$LN150@LoadLangua:
  006ac	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _LocalizationActive, 1
  006b6	85 c0		 test	 eax, eax
  006b8	75 0a		 jne	 SHORT $LN58@LoadLangua
$LN120@LoadLangua:
  006ba	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LocalizationActive, 0
$LN58@LoadLangua:

; 308  : 	LocalizationSerialNo++;

  006c4	ff 05 00 00 00
	00		 inc	 DWORD PTR _LocalizationSerialNo

; 309  : 
; 310  : 	// Create control ID dictionary
; 311  : 	
; 312  : 	// Default controls
; 313  : 	AddDictionaryEntry (NULL, 1, GetString ("IDOK"));

  006ca	68 00 00 00 00	 push	 OFFSET ??_C@_04BAADKBID@IDOK?$AA@
  006cf	e8 00 00 00 00	 call	 _GetDictionaryValue
  006d4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__wsprintfW
  006da	83 c4 04	 add	 esp, 4
  006dd	85 c0		 test	 eax, eax
  006df	75 19		 jne	 SHORT $LN63@LoadLangua
  006e1	68 00 00 00 00	 push	 OFFSET ??_C@_04BAADKBID@IDOK?$AA@
  006e6	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  006eb	68 00 00 00 00	 push	 OFFSET _UnknownString
  006f0	ff d7		 call	 edi
  006f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  006f5	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN63@LoadLangua:
  006fa	50		 push	 eax
  006fb	6a 01		 push	 1
  006fd	6a 00		 push	 0
  006ff	e8 00 00 00 00	 call	 _AddDictionaryEntry

; 314  : 	AddDictionaryEntry (NULL, 2, GetString ("IDCANCEL"));

  00704	68 00 00 00 00	 push	 OFFSET ??_C@_08DDAIHKOO@IDCANCEL?$AA@
  00709	e8 00 00 00 00	 call	 _GetDictionaryValue
  0070e	83 c4 10	 add	 esp, 16			; 00000010H
  00711	85 c0		 test	 eax, eax
  00713	75 19		 jne	 SHORT $LN66@LoadLangua
  00715	68 00 00 00 00	 push	 OFFSET ??_C@_08DDAIHKOO@IDCANCEL?$AA@
  0071a	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  0071f	68 00 00 00 00	 push	 OFFSET _UnknownString
  00724	ff d7		 call	 edi
  00726	83 c4 0c	 add	 esp, 12			; 0000000cH
  00729	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN66@LoadLangua:
  0072e	50		 push	 eax
  0072f	6a 02		 push	 2
  00731	6a 00		 push	 0
  00733	e8 00 00 00 00	 call	 _AddDictionaryEntry

; 315  : 	AddDictionaryEntry (NULL, 8, GetString ("IDCLOSE"));

  00738	68 00 00 00 00	 push	 OFFSET ??_C@_07CIAHAGHC@IDCLOSE?$AA@
  0073d	e8 00 00 00 00	 call	 _GetDictionaryValue
  00742	83 c4 10	 add	 esp, 16			; 00000010H
  00745	85 c0		 test	 eax, eax
  00747	75 19		 jne	 SHORT $LN69@LoadLangua
  00749	68 00 00 00 00	 push	 OFFSET ??_C@_07CIAHAGHC@IDCLOSE?$AA@
  0074e	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  00753	68 00 00 00 00	 push	 OFFSET _UnknownString
  00758	ff d7		 call	 edi
  0075a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0075d	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN69@LoadLangua:
  00762	50		 push	 eax
  00763	6a 08		 push	 8
  00765	6a 00		 push	 0
  00767	e8 00 00 00 00	 call	 _AddDictionaryEntry

; 316  : 	AddDictionaryEntry (NULL, 9, GetString ("IDHELP"));

  0076c	68 00 00 00 00	 push	 OFFSET ??_C@_06CALLMKCG@IDHELP?$AA@
  00771	e8 00 00 00 00	 call	 _GetDictionaryValue
  00776	83 c4 10	 add	 esp, 16			; 00000010H
  00779	85 c0		 test	 eax, eax
  0077b	75 19		 jne	 SHORT $LN72@LoadLangua
  0077d	68 00 00 00 00	 push	 OFFSET ??_C@_06CALLMKCG@IDHELP?$AA@
  00782	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  00787	68 00 00 00 00	 push	 OFFSET _UnknownString
  0078c	ff d7		 call	 edi
  0078e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00791	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN72@LoadLangua:
  00796	50		 push	 eax
  00797	6a 09		 push	 9
  00799	6a 00		 push	 0
  0079b	e8 00 00 00 00	 call	 _AddDictionaryEntry
  007a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 317  : 
; 318  : 	for (i = 0; headers[i] != 0; i++)

  007a3	33 db		 xor	 ebx, ebx
  007a5	33 f6		 xor	 esi, esi
$LL20@LoadLangua:

; 319  : 	{
; 320  : 		if (HeaderResource[i] == NULL)

  007a7	83 be 00 00 00
	00 00		 cmp	 DWORD PTR _HeaderResource[esi], 0
  007ae	75 21		 jne	 SHORT $LN49@LoadLangua

; 321  : 		{
; 322  : 			HeaderResource[i] = MapResource ("Header", headers[i], &size);

  007b0	8d 85 3c 6f fe
	ff		 lea	 eax, DWORD PTR _size$[ebp]
  007b6	50		 push	 eax
  007b7	ff b4 35 68 6f
	fe ff		 push	 DWORD PTR _headers$[ebp+esi]
  007be	68 00 00 00 00	 push	 OFFSET ??_C@_06OENKJGA@Header?$AA@
  007c3	e8 00 00 00 00	 call	 _MapResource
  007c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  007cb	89 86 00 00 00
	00		 mov	 DWORD PTR _HeaderResource[esi], eax
$LN49@LoadLangua:

; 323  : 			//*(HeaderResource[i] + size - 1) = 0;
; 324  : 		}
; 325  : 
; 326  : 		header = HeaderResource[i];

  007d1	8b b6 00 00 00
	00		 mov	 esi, DWORD PTR _HeaderResource[esi]

; 327  : 		if (header == NULL) return FALSE;

  007d7	85 f6		 test	 esi, esi
  007d9	0f 84 84 fe ff
	ff		 je	 $LN93@LoadLangua
  007df	90		 npad	 1
$LL23@LoadLangua:

; 328  : 
; 329  : 		do
; 330  : 		{
; 331  : 			if (sscanf (header, "#define %s %d", key, &intKey) == 2)

  007e0	8d 85 44 6f fe
	ff		 lea	 eax, DWORD PTR _intKey$[ebp]
  007e6	50		 push	 eax
  007e7	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  007ed	50		 push	 eax
  007ee	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MBEIEFFD@?$CDdefine?5?$CFs?5?$CFd?$AA@
  007f3	56		 push	 esi
  007f4	e8 00 00 00 00	 call	 _sscanf
  007f9	83 c4 10	 add	 esp, 16			; 00000010H
  007fc	83 f8 02	 cmp	 eax, 2
  007ff	75 40		 jne	 SHORT $LN21@LoadLangua

; 332  : 			{
; 333  : 				WCHAR *str = GetString (key);

  00801	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  00807	50		 push	 eax
  00808	e8 00 00 00 00	 call	 _GetDictionaryValue
  0080d	83 c4 04	 add	 esp, 4
  00810	85 c0		 test	 eax, eax
  00812	75 15		 jne	 SHORT $LN75@LoadLangua
  00814	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  0081a	50		 push	 eax
  0081b	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  00820	68 00 00 00 00	 push	 OFFSET _UnknownString
  00825	ff d7		 call	 edi

; 334  : 
; 335  : 				if (str != UnknownString)

  00827	eb 15		 jmp	 SHORT $LN154@LoadLangua

; 332  : 			{
; 333  : 				WCHAR *str = GetString (key);

$LN75@LoadLangua:

; 334  : 
; 335  : 				if (str != UnknownString)

  00829	3d 00 00 00 00	 cmp	 eax, OFFSET _UnknownString
  0082e	74 11		 je	 SHORT $LN21@LoadLangua

; 336  : 					AddDictionaryEntry (NULL, intKey, str);

  00830	50		 push	 eax
  00831	ff b5 44 6f fe
	ff		 push	 DWORD PTR _intKey$[ebp]
  00837	6a 00		 push	 0
  00839	e8 00 00 00 00	 call	 _AddDictionaryEntry
$LN154@LoadLangua:
  0083e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@LoadLangua:

; 337  : 			}
; 338  : 
; 339  : 		} while ((header = strchr (header, '\n') + 1) != (char *) 1);

  00841	6a 0a		 push	 10			; 0000000aH
  00843	56		 push	 esi
  00844	e8 00 00 00 00	 call	 _strchr
  00849	83 c4 08	 add	 esp, 8
  0084c	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0084f	83 fe 01	 cmp	 esi, 1
  00852	75 8c		 jne	 SHORT $LL23@LoadLangua

; 317  : 
; 318  : 	for (i = 0; headers[i] != 0; i++)

  00854	43		 inc	 ebx
  00855	8d 34 9d 00 00
	00 00		 lea	 esi, DWORD PTR [ebx*4]
  0085c	83 bc 35 68 6f
	fe ff 00	 cmp	 DWORD PTR _headers$[ebp+esi], 0
  00864	0f 85 3d ff ff
	ff		 jne	 $LL20@LoadLangua

; 340  : 	}
; 341  : 
; 342  : 	return TRUE;
; 343  : }

  0086a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0086d	b8 01 00 00 00	 mov	 eax, 1
  00872	5f		 pop	 edi
  00873	5e		 pop	 esi
  00874	33 cd		 xor	 ecx, ebp
  00876	5b		 pop	 ebx
  00877	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0087c	8b e5		 mov	 esp, ebp
  0087e	5d		 pop	 ebp
  0087f	c3		 ret	 0
_LoadLanguageFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\language.c
;	COMDAT _GetFont
_TEXT	SEGMENT
_fontType$ = 8						; size = 4
_GetFont PROC						; COMDAT

; 592  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 594  : 
; 595  : }

  00003	5d		 pop	 ebp

; 593  : 	return (Font *) GetDictionaryValue (fontType);

  00004	e9 00 00 00 00	 jmp	 _GetDictionaryValue
_GetFont ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\language.c
;	COMDAT _GetString
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_GetString PROC						; COMDAT

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 575  : 	WCHAR *str = (WCHAR *) GetDictionaryValue (stringId);

  00003	ff 75 08	 push	 DWORD PTR _stringId$[ebp]
  00006	e8 00 00 00 00	 call	 _GetDictionaryValue
  0000b	83 c4 04	 add	 esp, 4

; 576  : 	if (str != NULL) return str;

  0000e	85 c0		 test	 eax, eax
  00010	75 1b		 jne	 SHORT $LN1@GetString

; 577  : 
; 578  : 	wsprintfW (UnknownString, UNKNOWN_STRING_ID L"%hs" UNKNOWN_STRING_ID, stringId);

  00012	ff 75 08	 push	 DWORD PTR _stringId$[ebp]
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  0001a	68 00 00 00 00	 push	 OFFSET _UnknownString
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 579  : 	return UnknownString;

  00028	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN1@GetString:

; 580  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_GetString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\language.c
;	COMDAT _LanguageDlgProc@16
_TEXT	SEGMENT
_size$1 = -36612					; size = 4
_defaultLangFound$1$ = -36608				; size = 4
tv456 = -36604						; size = 4
tv454 = -36604						; size = 4
_langCount$1$ = -36604					; size = 4
_wcredits$2 = -36600					; size = 20000
_credits$3 = -16600					; size = 10000
_wattr$4 = -6600					; size = 4096
_attr$5 = -2504						; size = 2048
_szVers$6 = -456					; size = 400
_tmpstr$7 = -312					; size = 256
_wversion$8 = -56					; size = 40
_l$9 = -16						; size = 6
_lastLangId$10 = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_msg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_LanguageDlgProc@16 PROC				; COMDAT

; 359  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 8f 00 00	 mov	 eax, 36612		; 00008f04H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 362  : 
; 363  : 	switch (msg)

  00017	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  0001a	53		 push	 ebx
  0001b	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  0001e	56		 push	 esi
  0001f	2d 10 01 00 00	 sub	 eax, 272		; 00000110H
  00024	0f 84 65 01 00
	00		 je	 $LN11@LanguageDl
  0002a	83 e8 01	 sub	 eax, 1
  0002d	0f 85 a8 00 00
	00		 jne	 $LN36@LanguageDl

; 457  : 			}
; 458  : 
; 459  : 			return 1;
; 460  : 		}
; 461  : 
; 462  : 	case WM_COMMAND:
; 463  : 
; 464  : 		if (lw == IDOK || hw == LBN_DBLCLK)

  00033	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00036	66 83 f9 01	 cmp	 cx, 1
  0003a	0f 84 af 00 00
	00		 je	 $LN30@LanguageDl

; 360  : 	WORD lw = LOWORD (wParam);
; 361  : 	WORD hw = HIWORD (wParam);

  00040	8b c1		 mov	 eax, ecx
  00042	c1 e8 10	 shr	 eax, 16			; 00000010H

; 457  : 			}
; 458  : 
; 459  : 			return 1;
; 460  : 		}
; 461  : 
; 462  : 	case WM_COMMAND:
; 463  : 
; 464  : 		if (lw == IDOK || hw == LBN_DBLCLK)

  00045	83 f8 02	 cmp	 eax, 2
  00048	0f 84 a1 00 00
	00		 je	 $LN30@LanguageDl

; 496  : 		}
; 497  : 
; 498  : 		if (lw == IDCANCEL)

  0004e	66 83 f9 02	 cmp	 cx, 2
  00052	75 0e		 jne	 SHORT $LN35@LanguageDl

; 499  : 		{
; 500  : 			EndDialog (hwndDlg, lw);

  00054	6a 02		 push	 2
  00056	53		 push	 ebx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 501  : 			return 1;

  0005d	e9 f5 04 00 00	 jmp	 $LN90@LanguageDl
$LN35@LanguageDl:

; 502  : 		}
; 503  : 
; 504  : 		if (lw == IDC_GET_LANG_PACKS)

  00062	b8 d5 13 00 00	 mov	 eax, 5077		; 000013d5H
  00067	66 3b c8	 cmp	 cx, ax
  0006a	75 6f		 jne	 SHORT $LN36@LanguageDl

; 505  : 		{
; 506  : 			char tmpstr [256];
; 507  : 
; 508  : 			if (strlen (ActiveLangPackVersion) > 0 && strlen (GetPreferredLangId()) > 0)

  0006c	b9 00 00 00 00	 mov	 ecx, OFFSET _ActiveLangPackVersion
  00071	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL78@LanguageDl:
  00074	8a 01		 mov	 al, BYTE PTR [ecx]
  00076	41		 inc	 ecx
  00077	84 c0		 test	 al, al
  00079	75 f9		 jne	 SHORT $LL78@LanguageDl
  0007b	2b ca		 sub	 ecx, edx
  0007d	74 43		 je	 SHORT $LN37@LanguageDl
  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET _PreferredLangId
  00084	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL79@LanguageDl:
  00087	8a 01		 mov	 al, BYTE PTR [ecx]
  00089	41		 inc	 ecx
  0008a	84 c0		 test	 al, al
  0008c	75 f9		 jne	 SHORT $LL79@LanguageDl
  0008e	2b ca		 sub	 ecx, edx
  00090	74 30		 je	 SHORT $LN37@LanguageDl

; 509  : 				sprintf (tmpstr, "&langpackversion=%s&lang=%s", ActiveLangPackVersion, GetPreferredLangId());

  00092	68 00 00 00 00	 push	 OFFSET _PreferredLangId
  00097	68 00 00 00 00	 push	 OFFSET _ActiveLangPackVersion
  0009c	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _tmpstr$7[ebp]
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OECEHKD@?$CGlangpackversion?$DN?$CFs?$CGlang?$DN?$CFs?$AA@
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _sprintf
  000ad	83 c4 10	 add	 esp, 16			; 00000010H

; 510  : 			else
; 511  : 				tmpstr[0] = 0;
; 512  : 
; 513  : 			//Applink ("localizations", TRUE, tmpstr);
; 514  : 			Extlink("http://www.gostcrypt.org/redirect.php?a=3");

  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@MLINDFGB@http?3?1?1www?4gostcrypt?4org?1redirec@
  000b5	e8 00 00 00 00	 call	 _Extlink
  000ba	83 c4 04	 add	 esp, 4

; 515  : 
; 516  : 			return 1;

  000bd	e9 95 04 00 00	 jmp	 $LN90@LanguageDl
$LN37@LanguageDl:

; 510  : 			else
; 511  : 				tmpstr[0] = 0;
; 512  : 
; 513  : 			//Applink ("localizations", TRUE, tmpstr);
; 514  : 			Extlink("http://www.gostcrypt.org/redirect.php?a=3");

  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@MLINDFGB@http?3?1?1www?4gostcrypt?4org?1redirec@
  000c7	c6 85 c8 fe ff
	ff 00		 mov	 BYTE PTR _tmpstr$7[ebp], 0
  000ce	e8 00 00 00 00	 call	 _Extlink
  000d3	83 c4 04	 add	 esp, 4

; 515  : 
; 516  : 			return 1;

  000d6	e9 7c 04 00 00	 jmp	 $LN90@LanguageDl
$LN36@LanguageDl:
  000db	5e		 pop	 esi

; 517  : 		}
; 518  : 		return 0;

  000dc	33 c0		 xor	 eax, eax
  000de	5b		 pop	 ebx

; 519  : 	}
; 520  : 
; 521  : 	return 0;
; 522  : }

  000df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 10 00	 ret	 16			; 00000010H
$LN30@LanguageDl:

; 465  : 		{
; 466  : 			int i = SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_GETCURSEL, 0, 0);

  000ef	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendDlgItemMessageA@20
  000f5	6a 00		 push	 0
  000f7	6a 00		 push	 0
  000f9	68 88 01 00 00	 push	 392			; 00000188H
  000fe	68 ce 13 00 00	 push	 5070			; 000013ceH
  00103	53		 push	 ebx
  00104	ff d6		 call	 esi

; 467  : 
; 468  : 			if (i >= 0)

  00106	85 c0		 test	 eax, eax
  00108	78 77		 js	 SHORT $LN34@LanguageDl

; 469  : 			{
; 470  : 				int id = SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_GETITEMDATA, i, 0);

  0010a	6a 00		 push	 0
  0010c	50		 push	 eax
  0010d	68 99 01 00 00	 push	 409			; 00000199H
  00112	68 ce 13 00 00	 push	 5070			; 000013ceH
  00117	53		 push	 ebx
  00118	ff d6		 call	 esi
  0011a	8b d0		 mov	 edx, eax

; 471  : 
; 472  : 				if (id != LB_ERR)

  0011c	83 fa ff	 cmp	 edx, -1
  0011f	74 60		 je	 SHORT $LN34@LanguageDl

; 473  : 				{
; 474  : 					char l[6];
; 475  : 
; 476  : 					// Decode language id from LPARAM
; 477  : 					l[0] = (char) id;
; 478  : 					l[1] = (char) (id >> 8);

  00121	8b ca		 mov	 ecx, edx
  00123	88 55 f0	 mov	 BYTE PTR _l$9[ebp], dl
  00126	c1 f9 08	 sar	 ecx, 8
  00129	88 4d f1	 mov	 BYTE PTR _l$9[ebp+1], cl

; 479  : 					l[2] = 0;

  0012c	c6 45 f2 00	 mov	 BYTE PTR _l$9[ebp+2], 0

; 480  : 
; 481  : 					if ((id & 0xffff0000) != 0)

  00130	f7 c2 00 00 ff
	ff		 test	 edx, -65536		; ffff0000H
  00136	74 14		 je	 SHORT $LN33@LanguageDl

; 482  : 					{
; 483  : 						l[2] = '-';
; 484  : 						l[3] = (char) (id >> 16);

  00138	c1 f8 10	 sar	 eax, 16			; 00000010H

; 485  : 						l[4] = id >> 24;

  0013b	c1 fa 18	 sar	 edx, 24			; 00000018H
  0013e	c6 45 f2 2d	 mov	 BYTE PTR _l$9[ebp+2], 45 ; 0000002dH
  00142	88 45 f3	 mov	 BYTE PTR _l$9[ebp+3], al
  00145	88 55 f4	 mov	 BYTE PTR _l$9[ebp+4], dl

; 486  : 						l[5] = 0;

  00148	c6 45 f5 00	 mov	 BYTE PTR _l$9[ebp+5], 0
$LN33@LanguageDl:

; 487  : 					}	
; 488  : 		
; 489  : 					if (SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_GETCOUNT, 0, 0) > 1)

  0014c	6a 00		 push	 0
  0014e	6a 00		 push	 0
  00150	68 8b 01 00 00	 push	 395			; 0000018bH
  00155	68 ce 13 00 00	 push	 5070			; 000013ceH
  0015a	53		 push	 ebx
  0015b	ff d6		 call	 esi
  0015d	83 f8 01	 cmp	 eax, 1
  00160	7e 1f		 jle	 SHORT $LN34@LanguageDl

; 490  : 						strcpy (PreferredLangId, l);

  00162	33 c9		 xor	 ecx, ecx
  00164	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL46@LanguageDl:
  00170	8a 44 0d f0	 mov	 al, BYTE PTR _l$9[ebp+ecx]
  00174	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00177	88 81 ff ff ff
	ff		 mov	 BYTE PTR _PreferredLangId[ecx-1], al
  0017d	84 c0		 test	 al, al
  0017f	75 ef		 jne	 SHORT $LL46@LanguageDl
$LN34@LanguageDl:

; 491  : 				}
; 492  : 			}
; 493  : 
; 494  : 			EndDialog (hwndDlg, IDOK);

  00181	6a 01		 push	 1
  00183	53		 push	 ebx
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 495  : 			return 1;

  0018a	e9 c8 03 00 00	 jmp	 $LN90@LanguageDl
$LN11@LanguageDl:
  0018f	57		 push	 edi

; 364  : 	{
; 365  : 	case WM_INITDIALOG:
; 366  : 		{
; 367  : 			char *xml;
; 368  : 			char attr[2048], lastLangId[10];
; 369  : 			WCHAR wattr[2048];
; 370  : 			int len;
; 371  : 			int langCount = 0;
; 372  : 			BOOL defaultLangFound = FALSE;
; 373  : 
; 374  : 			LocalizeDialog (hwndDlg, "IDD_LANGUAGE");

  00190	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CHAAEAGP@IDD_LANGUAGE?$AA@
  00195	33 ff		 xor	 edi, edi
  00197	33 f6		 xor	 esi, esi
  00199	53		 push	 ebx
  0019a	89 bd 04 71 ff
	ff		 mov	 DWORD PTR _langCount$1$[ebp], edi
  001a0	89 b5 00 71 ff
	ff		 mov	 DWORD PTR _defaultLangFound$1$[ebp], esi
  001a6	e8 00 00 00 00	 call	 _LocalizeDialog

; 375  : 			ToHyperlink (hwndDlg, IDC_GET_LANG_PACKS);

  001ab	68 d5 13 00 00	 push	 5077			; 000013d5H
  001b0	53		 push	 ebx
  001b1	e8 00 00 00 00	 call	 _ToHyperlink

; 376  : 
; 377  : 			for (xml = MapFirstLanguageFile (); xml != NULL; xml = MapNextLanguageFile ())

  001b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageFileFindHandle
  001bb	83 c4 10	 add	 esp, 16			; 00000010H
  001be	83 f8 ff	 cmp	 eax, -1
  001c1	74 11		 je	 SHORT $LN50@LanguageDl
  001c3	50		 push	 eax
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  001ca	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _LanguageFileFindHandle, -1
$LN50@LanguageDl:
  001d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageResource
  001d9	85 c0		 test	 eax, eax
  001db	75 26		 jne	 SHORT $LL6@LanguageDl
  001dd	8d 85 fc 70 ff
	ff		 lea	 eax, DWORD PTR _size$1[ebp]
  001e3	50		 push	 eax
  001e4	68 fa 01 00 00	 push	 506			; 000001faH
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_03FJEFHLHG@Xml?$AA@
  001ee	e8 00 00 00 00	 call	 _MapResource
  001f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f6	a3 00 00 00 00	 mov	 DWORD PTR _LanguageResource, eax
  001fb	85 c0		 test	 eax, eax
  001fd	0f 84 19 03 00
	00		 je	 $LN5@LanguageDl
$LL6@LanguageDl:

; 378  : 			{
; 379  : 				while (xml = XmlFindElement (xml, "language"))

  00203	68 00 00 00 00	 push	 OFFSET ??_C@_08JGCCIMAA@language?$AA@
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 _XmlFindElement
  0020e	8b f8		 mov	 edi, eax
  00210	83 c4 08	 add	 esp, 8
  00213	85 ff		 test	 edi, edi
  00215	0f 84 ee 02 00
	00		 je	 $LN4@LanguageDl
  0021b	0f 1f 44 00 00	 npad	 5
$LL7@LanguageDl:

; 380  : 				{
; 381  : 					XmlGetAttributeText (xml, "name", attr, sizeof (attr));

  00220	68 00 08 00 00	 push	 2048			; 00000800H
  00225	8d 85 38 f6 ff
	ff		 lea	 eax, DWORD PTR _attr$5[ebp]
  0022b	50		 push	 eax
  0022c	68 00 00 00 00	 push	 OFFSET ??_C@_04MEMAJGDJ@name?$AA@
  00231	57		 push	 edi
  00232	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00237	83 c4 10	 add	 esp, 16			; 00000010H

; 382  : 					len = MultiByteToWideChar (CP_UTF8, 0, attr, -1, wattr, sizeof (wattr) / sizeof(wattr[0]));

  0023a	8d 85 38 e6 ff
	ff		 lea	 eax, DWORD PTR _wattr$4[ebp]
  00240	68 00 08 00 00	 push	 2048			; 00000800H
  00245	50		 push	 eax
  00246	6a ff		 push	 -1
  00248	8d 85 38 f6 ff
	ff		 lea	 eax, DWORD PTR _attr$5[ebp]
  0024e	50		 push	 eax
  0024f	6a 00		 push	 0
  00251	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  00256	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 383  : 
; 384  : 					if (len != 0 && len != ERROR_NO_UNICODE_TRANSLATION
; 385  : 						&& (!defaultLangFound || wcscmp (wattr, L"English") != 0))

  0025c	85 c0		 test	 eax, eax
  0025e	0f 84 86 02 00
	00		 je	 $LN14@LanguageDl
  00264	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  00269	0f 84 7b 02 00
	00		 je	 $LN14@LanguageDl
  0026f	85 f6		 test	 esi, esi
  00271	74 40		 je	 SHORT $LN13@LanguageDl
  00273	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_1BA@CLLEDPIF@?$AAE?$AAn?$AAg?$AAl?$AAi?$AAs?$AAh?$AA?$AA@
  00278	8d 85 38 e6 ff
	ff		 lea	 eax, DWORD PTR _wattr$4[ebp]
  0027e	66 90		 npad	 2
$LL80@LanguageDl:
  00280	66 8b 10	 mov	 dx, WORD PTR [eax]
  00283	66 3b 11	 cmp	 dx, WORD PTR [ecx]
  00286	75 1e		 jne	 SHORT $LN81@LanguageDl
  00288	66 85 d2	 test	 dx, dx
  0028b	74 15		 je	 SHORT $LN82@LanguageDl
  0028d	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  00291	66 3b 51 02	 cmp	 dx, WORD PTR [ecx+2]
  00295	75 0f		 jne	 SHORT $LN81@LanguageDl
  00297	83 c0 04	 add	 eax, 4
  0029a	83 c1 04	 add	 ecx, 4
  0029d	66 85 d2	 test	 dx, dx
  002a0	75 de		 jne	 SHORT $LL80@LanguageDl
$LN82@LanguageDl:
  002a2	33 c0		 xor	 eax, eax
  002a4	eb 05		 jmp	 SHORT $LN83@LanguageDl
$LN81@LanguageDl:
  002a6	1b c0		 sbb	 eax, eax
  002a8	83 c8 01	 or	 eax, 1
$LN83@LanguageDl:
  002ab	85 c0		 test	 eax, eax
  002ad	0f 84 37 02 00
	00		 je	 $LN14@LanguageDl
$LN13@LanguageDl:

; 386  : 					{
; 387  : 						int i = SendDlgItemMessageW (hwndDlg, IDC_LANGLIST, LB_ADDSTRING, 0, (LPARAM)wattr);

  002b3	8d 85 38 e6 ff
	ff		 lea	 eax, DWORD PTR _wattr$4[ebp]
  002b9	50		 push	 eax
  002ba	6a 00		 push	 0
  002bc	68 80 01 00 00	 push	 384			; 00000180H
  002c1	68 ce 13 00 00	 push	 5070			; 000013ceH
  002c6	53		 push	 ebx
  002c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageW@20
  002cd	8b f0		 mov	 esi, eax

; 388  : 						if (i >= 0)

  002cf	85 f6		 test	 esi, esi
  002d1	0f 88 13 02 00
	00		 js	 $LN14@LanguageDl

; 389  : 						{
; 390  : 							int id;
; 391  : 
; 392  : 							// Encode language id in LPARAM
; 393  : 							XmlGetAttributeText (xml, "langid", attr, sizeof (attr));

  002d7	68 00 08 00 00	 push	 2048			; 00000800H
  002dc	8d 85 38 f6 ff
	ff		 lea	 eax, DWORD PTR _attr$5[ebp]
  002e2	50		 push	 eax
  002e3	68 00 00 00 00	 push	 OFFSET ??_C@_06CLEJICHF@langid?$AA@
  002e8	57		 push	 edi
  002e9	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 394  : 							switch (strlen (attr))

  002ee	8d 8d 38 f6 ff
	ff		 lea	 ecx, DWORD PTR _attr$5[ebp]
  002f4	83 c4 10	 add	 esp, 16			; 00000010H
  002f7	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  002fa	66 0f 1f 44 00
	00		 npad	 6
$LL84@LanguageDl:
  00300	8a 01		 mov	 al, BYTE PTR [ecx]
  00302	41		 inc	 ecx
  00303	84 c0		 test	 al, al
  00305	75 f9		 jne	 SHORT $LL84@LanguageDl
  00307	2b ca		 sub	 ecx, edx
  00309	83 e9 02	 sub	 ecx, 2
  0030c	74 2a		 je	 SHORT $LN15@LanguageDl
  0030e	83 e9 03	 sub	 ecx, 3
  00311	0f 85 d4 01 00
	00		 jne	 $LN66@LanguageDl

; 397  : 							case 5: id = attr[0] | attr[1] << 8 | attr[3] << 16 | attr[4] << 24; break;

  00317	0f be 8d 3c f6
	ff ff		 movsx	 ecx, BYTE PTR _attr$5[ebp+4]
  0031e	0f be 85 3b f6
	ff ff		 movsx	 eax, BYTE PTR _attr$5[ebp+3]
  00325	c1 e1 08	 shl	 ecx, 8
  00328	0b c8		 or	 ecx, eax
  0032a	0f be 85 39 f6
	ff ff		 movsx	 eax, BYTE PTR _attr$5[ebp+1]
  00331	c1 e1 08	 shl	 ecx, 8
  00334	0b c8		 or	 ecx, eax
  00336	eb 07		 jmp	 SHORT $LN92@LanguageDl
$LN15@LanguageDl:

; 395  : 							{
; 396  : 							case 2: id = attr[0] | attr[1] << 8; break;

  00338	0f be 8d 39 f6
	ff ff		 movsx	 ecx, BYTE PTR _attr$5[ebp+1]
$LN92@LanguageDl:
  0033f	0f be 85 38 f6
	ff ff		 movsx	 eax, BYTE PTR _attr$5[ebp]

; 398  : 							default: continue;
; 399  : 							}
; 400  : 
; 401  : 							if (!defaultLangFound)

  00346	ba 01 00 00 00	 mov	 edx, 1
  0034b	c1 e1 08	 shl	 ecx, 8
  0034e	0b c8		 or	 ecx, eax
  00350	8b 85 00 71 ff
	ff		 mov	 eax, DWORD PTR _defaultLangFound$1$[ebp]

; 402  : 								defaultLangFound = TRUE;
; 403  : 
; 404  : 							SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_SETITEMDATA, i, (LPARAM) id);

  00356	51		 push	 ecx
  00357	56		 push	 esi
  00358	68 9a 01 00 00	 push	 410			; 0000019aH
  0035d	85 c0		 test	 eax, eax
  0035f	68 ce 13 00 00	 push	 5070			; 000013ceH
  00364	0f 44 c2	 cmove	 eax, edx
  00367	53		 push	 ebx
  00368	89 85 00 71 ff
	ff		 mov	 DWORD PTR _defaultLangFound$1$[ebp], eax
  0036e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 405  : 
; 406  : 							if (strcmp (attr, PreferredLangId) == 0)

  00374	b9 00 00 00 00	 mov	 ecx, OFFSET _PreferredLangId
  00379	8d 85 38 f6 ff
	ff		 lea	 eax, DWORD PTR _attr$5[ebp]
  0037f	90		 npad	 1
$LL85@LanguageDl:
  00380	8a 10		 mov	 dl, BYTE PTR [eax]
  00382	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00384	75 1a		 jne	 SHORT $LN86@LanguageDl
  00386	84 d2		 test	 dl, dl
  00388	74 12		 je	 SHORT $LN87@LanguageDl
  0038a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0038d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00390	75 0e		 jne	 SHORT $LN86@LanguageDl
  00392	83 c0 02	 add	 eax, 2
  00395	83 c1 02	 add	 ecx, 2
  00398	84 d2		 test	 dl, dl
  0039a	75 e4		 jne	 SHORT $LL85@LanguageDl
$LN87@LanguageDl:
  0039c	33 c0		 xor	 eax, eax
  0039e	eb 05		 jmp	 SHORT $LN88@LanguageDl
$LN86@LanguageDl:
  003a0	1b c0		 sbb	 eax, eax
  003a2	83 c8 01	 or	 eax, 1
$LN88@LanguageDl:
  003a5	85 c0		 test	 eax, eax
  003a7	0f 85 23 01 00
	00		 jne	 $LN24@LanguageDl

; 407  : 							{
; 408  : 								char credits [10000];
; 409  : 								WCHAR wcredits [10000];
; 410  : 								WCHAR wversion [20];
; 411  : 								wchar_t szVers [200];
; 412  : 								int nLen;
; 413  : 
; 414  : 								SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_SETCURSEL, i, 0);

  003ad	50		 push	 eax
  003ae	56		 push	 esi
  003af	68 86 01 00 00	 push	 390			; 00000186H
  003b4	68 ce 13 00 00	 push	 5070			; 000013ceH
  003b9	53		 push	 ebx
  003ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 415  : 
; 416  : 								// Language pack version 
; 417  : 								if (!ActiveLangPackVersion[0] || memcmp (ActiveLangPackVersion, "0.0.0", 5) == 0)

  003c0	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _ActiveLangPackVersion, 0
  003c7	74 4b		 je	 SHORT $LN22@LanguageDl
  003c9	b8 00 00 00 00	 mov	 eax, OFFSET _ActiveLangPackVersion
  003ce	81 38 30 2e 30
	2e		 cmp	 DWORD PTR [eax], 774909488 ; 2e302e30H
  003d4	75 06		 jne	 SHORT $LN89@LanguageDl
  003d6	80 78 04 30	 cmp	 BYTE PTR [eax+4], 48	; 00000030H
  003da	74 38		 je	 SHORT $LN22@LanguageDl
$LN89@LanguageDl:

; 420  : 								}
; 421  : 								else
; 422  : 								{
; 423  : 									nLen = MultiByteToWideChar (CP_UTF8, 0, ActiveLangPackVersion, -1, wversion, sizeof (wversion) / sizeof(wversion[0]));

  003dc	6a 14		 push	 20			; 00000014H
  003de	8d 45 c8	 lea	 eax, DWORD PTR _wversion$8[ebp]
  003e1	50		 push	 eax
  003e2	6a ff		 push	 -1
  003e4	68 00 00 00 00	 push	 OFFSET _ActiveLangPackVersion
  003e9	6a 00		 push	 0
  003eb	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  003f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 424  : 									if (nLen != 0 && nLen != ERROR_NO_UNICODE_TRANSLATION)

  003f6	85 c0		 test	 eax, eax
  003f8	74 5d		 je	 SHORT $LN23@LanguageDl
  003fa	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  003ff	74 56		 je	 SHORT $LN23@LanguageDl

; 425  : 										swprintf (szVers, GetString("LANG_PACK_VERSION"), wversion);

  00401	8d 45 c8	 lea	 eax, DWORD PTR _wversion$8[ebp]
  00404	50		 push	 eax
  00405	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@
  0040a	e8 00 00 00 00	 call	 _GetString
  0040f	83 c4 04	 add	 esp, 4
  00412	eb 33		 jmp	 SHORT $LN93@LanguageDl
$LN22@LanguageDl:

; 418  : 								{
; 419  : 									swprintf (szVers, GetString("LANG_PACK_VERSION"), L"--");

  00414	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@
  00419	e8 00 00 00 00	 call	 _GetDictionaryValue
  0041e	83 c4 04	 add	 esp, 4
  00421	85 c0		 test	 eax, eax
  00423	75 1d		 jne	 SHORT $LN53@LanguageDl
  00425	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@
  0042a	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  0042f	68 00 00 00 00	 push	 OFFSET _UnknownString
  00434	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  0043a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0043d	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN53@LanguageDl:
  00442	68 00 00 00 00	 push	 OFFSET ??_C@_15KHFHDPFH@?$AA?9?$AA?9?$AA?$AA@
$LN93@LanguageDl:
  00447	50		 push	 eax
  00448	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _szVers$6[ebp]
  0044e	50		 push	 eax
  0044f	e8 00 00 00 00	 call	 __swprintf
  00454	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN23@LanguageDl:

; 426  : 								}
; 427  : 								SetWindowTextW (GetDlgItem (hwndDlg, IDC_LANGPACK_VERSION), szVers);

  00457	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _szVers$6[ebp]
  0045d	50		 push	 eax
  0045e	68 d8 13 00 00	 push	 5080			; 000013d8H
  00463	53		 push	 ebx
  00464	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0046a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00470	50		 push	 eax
  00471	ff d6		 call	 esi

; 428  : 
; 429  : 								// Translator credits
; 430  : 								XmlGetAttributeText (xml, "translators", credits, sizeof (credits));

  00473	68 10 27 00 00	 push	 10000			; 00002710H
  00478	8d 85 28 bf ff
	ff		 lea	 eax, DWORD PTR _credits$3[ebp]
  0047e	50		 push	 eax
  0047f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DOLNAGBN@translators?$AA@
  00484	57		 push	 edi
  00485	e8 00 00 00 00	 call	 _XmlGetAttributeText
  0048a	83 c4 10	 add	 esp, 16			; 00000010H

; 431  : 								nLen = MultiByteToWideChar (CP_UTF8, 0, credits, -1, wcredits, sizeof (wcredits) / sizeof(wcredits[0]));

  0048d	8d 85 08 71 ff
	ff		 lea	 eax, DWORD PTR _wcredits$2[ebp]
  00493	68 10 27 00 00	 push	 10000			; 00002710H
  00498	50		 push	 eax
  00499	6a ff		 push	 -1
  0049b	8d 85 28 bf ff
	ff		 lea	 eax, DWORD PTR _credits$3[ebp]
  004a1	50		 push	 eax
  004a2	6a 00		 push	 0
  004a4	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  004a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 432  : 								if (nLen != 0 && nLen != ERROR_NO_UNICODE_TRANSLATION)

  004af	85 c0		 test	 eax, eax
  004b1	74 1d		 je	 SHORT $LN24@LanguageDl
  004b3	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  004b8	74 16		 je	 SHORT $LN24@LanguageDl

; 433  : 								{
; 434  : 									SetWindowTextW (GetDlgItem (hwndDlg, IDC_LANGPACK_CREDITS), wcredits);

  004ba	8d 85 08 71 ff
	ff		 lea	 eax, DWORD PTR _wcredits$2[ebp]
  004c0	50		 push	 eax
  004c1	68 d7 13 00 00	 push	 5079			; 000013d7H
  004c6	53		 push	 ebx
  004c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  004cd	50		 push	 eax
  004ce	ff d6		 call	 esi
$LN24@LanguageDl:

; 435  : 								}
; 436  : 							}
; 437  : 
; 438  : 							strcpy (lastLangId, attr);

  004d0	33 c0		 xor	 eax, eax
$LL40@LanguageDl:
  004d2	8a 8c 05 38 f6
	ff ff		 mov	 cl, BYTE PTR _attr$5[ebp+eax]
  004d9	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  004dc	88 4c 05 ef	 mov	 BYTE PTR _lastLangId$10[ebp+eax-1], cl
  004e0	84 c9		 test	 cl, cl
  004e2	75 ee		 jne	 SHORT $LL40@LanguageDl

; 439  : 							langCount++;

  004e4	ff 85 04 71 ff
	ff		 inc	 DWORD PTR _langCount$1$[ebp]
$LN14@LanguageDl:

; 440  : 						}
; 441  : 					}
; 442  : 
; 443  : 					xml++;

  004ea	47		 inc	 edi
$LN66@LanguageDl:

; 378  : 			{
; 379  : 				while (xml = XmlFindElement (xml, "language"))

  004eb	68 00 00 00 00	 push	 OFFSET ??_C@_08JGCCIMAA@language?$AA@
  004f0	57		 push	 edi
  004f1	e8 00 00 00 00	 call	 _XmlFindElement
  004f6	8b b5 00 71 ff
	ff		 mov	 esi, DWORD PTR _defaultLangFound$1$[ebp]
  004fc	8b f8		 mov	 edi, eax
  004fe	83 c4 08	 add	 esp, 8
  00501	85 ff		 test	 edi, edi
  00503	0f 85 17 fd ff
	ff		 jne	 $LL7@LanguageDl
$LN4@LanguageDl:

; 376  : 
; 377  : 			for (xml = MapFirstLanguageFile (); xml != NULL; xml = MapNextLanguageFile ())

  00509	e8 00 00 00 00	 call	 _MapNextLanguageFile
  0050e	85 c0		 test	 eax, eax
  00510	0f 85 ed fc ff
	ff		 jne	 $LL6@LanguageDl
  00516	8b bd 04 71 ff
	ff		 mov	 edi, DWORD PTR _langCount$1$[ebp]
$LN5@LanguageDl:

; 444  : 				}
; 445  : 			}
; 446  : 
; 447  : 			if (lParam == 1)

  0051c	83 7d 14 01	 cmp	 DWORD PTR _lParam$[ebp], 1
  00520	75 34		 jne	 SHORT $LN25@LanguageDl

; 448  : 			{
; 449  : 				// Auto mode
; 450  : 				if (langCount < 2) 

  00522	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EndDialog@8
  00528	83 ff 02	 cmp	 edi, 2
  0052b	7d 08		 jge	 SHORT $LN94@LanguageDl

; 451  : 					EndDialog (hwndDlg, IDCANCEL);

  0052d	6a 02		 push	 2
  0052f	53		 push	 ebx
  00530	ff d6		 call	 esi

; 452  : 
; 453  : 				if (langCount == 2)

  00532	83 ff 02	 cmp	 edi, 2
$LN94@LanguageDl:
  00535	75 1a		 jne	 SHORT $LN27@LanguageDl

; 454  : 					strcpy (PreferredLangId, lastLangId);

  00537	33 c9		 xor	 ecx, ecx
  00539	0f 1f 80 00 00
	00 00		 npad	 7
$LL41@LanguageDl:
  00540	8a 44 0d f0	 mov	 al, BYTE PTR _lastLangId$10[ebp+ecx]
  00544	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00547	88 81 ff ff ff
	ff		 mov	 BYTE PTR _PreferredLangId[ecx-1], al
  0054d	84 c0		 test	 al, al
  0054f	75 ef		 jne	 SHORT $LL41@LanguageDl
$LN27@LanguageDl:

; 455  : 				
; 456  : 				EndDialog (hwndDlg, IDOK);

  00551	6a 01		 push	 1
  00553	53		 push	 ebx
  00554	ff d6		 call	 esi
$LN25@LanguageDl:
  00556	5f		 pop	 edi
$LN90@LanguageDl:

; 519  : 	}
; 520  : 
; 521  : 	return 0;
; 522  : }

  00557	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0055a	b8 01 00 00 00	 mov	 eax, 1
  0055f	5e		 pop	 esi
  00560	33 cd		 xor	 ecx, ebp
  00562	5b		 pop	 ebx
  00563	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00568	8b e5		 mov	 esp, ebp
  0056a	5d		 pop	 ebp
  0056b	c2 10 00	 ret	 16			; 00000010H
_LanguageDlgProc@16 ENDP
_TEXT	ENDS
END
