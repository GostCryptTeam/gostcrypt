; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Desktop\Sources_GostCrypt_Windows_1.3.1_COMMENTED\Sources_GostCrypt_Windows_1.3.1é\Sources_GostCrypt_Windows_1.3.1\Setup\Setup.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?UninstallBatch@@3PADA				; UninstallBatch
PUBLIC	?InstalledVersion@@3JA				; InstalledVersion
PUBLIC	?bUninstall@@3HA				; bUninstall
PUBLIC	?bMakePackage@@3HA				; bMakePackage
PUBLIC	?bDone@@3HA					; bDone
PUBLIC	?bDowngrade@@3HA				; bDowngrade
PUBLIC	?PortableMode@@3HA				; PortableMode
PUBLIC	?bChangeMode@@3HA				; bChangeMode
PUBLIC	?bUninstallInProgress@@3HA			; bUninstallInProgress
PUBLIC	?UnloadDriver@@3HA				; UnloadDriver
PUBLIC	_bDevm
PUBLIC	_Rollback
PUBLIC	_bUpgrade
PUBLIC	_bPossiblyFirstTimeInstall
PUBLIC	_bRepairMode
PUBLIC	_bSystemRestore
PUBLIC	_bDisableSwapFiles
PUBLIC	_bForAllUsers
PUBLIC	_bRegisterFileExt
PUBLIC	_bAddToStartMenu
PUBLIC	_bDesktopIcon
PUBLIC	_bDesktopIconStatusDetermined
PUBLIC	_SystemEncryptionUpdate
PUBLIC	_bRestartRequired
PUBLIC	_SystemRestoreDll
PUBLIC	_InstallationPath
PUBLIC	_SetupFilesDir
_BSS	SEGMENT
?UninstallBatch@@3PADA DB 0104H DUP (?)			; UninstallBatch
?InstalledVersion@@3JA DD 01H DUP (?)			; InstalledVersion
?bUninstall@@3HA DD 01H DUP (?)				; bUninstall
?bMakePackage@@3HA DD 01H DUP (?)			; bMakePackage
?bDone@@3HA DD	01H DUP (?)				; bDone
?bDowngrade@@3HA DD 01H DUP (?)				; bDowngrade
?PortableMode@@3HA DD 01H DUP (?)			; PortableMode
?bChangeMode@@3HA DD 01H DUP (?)			; bChangeMode
?bUninstallInProgress@@3HA DD 01H DUP (?)		; bUninstallInProgress
_bDevm	DD	01H DUP (?)
_Rollback DD	01H DUP (?)
_bUpgrade DD	01H DUP (?)
_bPossiblyFirstTimeInstall DD 01H DUP (?)
_bRepairMode DD	01H DUP (?)
_bDisableSwapFiles DD 01H DUP (?)
_bDesktopIconStatusDetermined DD 01H DUP (?)
_SystemEncryptionUpdate DD 01H DUP (?)
_bRestartRequired DD 01H DUP (?)
_SystemRestoreDll DD 01H DUP (?)
_InstallationPath DB 0104H DUP (?)
_SetupFilesDir DB 0104H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?UnloadDriver@@3HA DD 01H				; UnloadDriver
_bSystemRestore DD 01H
_bForAllUsers DD 01H
_bRegisterFileExt DD 01H
_bAddToStartMenu DD 01H
_bDesktopIcon DD 01H
_DATA	ENDS
PUBLIC	_WinMain@16
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
PUBLIC	?swprintf@@YAHQA_WQB_WZZ			; swprintf
PUBLIC	_fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	__snprintf
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	_localcleanup
PUBLIC	_StatDeleteFile
PUBLIC	_StatRemoveDirectory
PUBLIC	_CreateLink
PUBLIC	_GetProgramPath
PUBLIC	_StatusMessage
PUBLIC	_StatusMessageParam
PUBLIC	_ClearLogWindow
PUBLIC	_RegMessage
PUBLIC	_CopyMessage
PUBLIC	_RemoveMessage
PUBLIC	_IconMessage
PUBLIC	_DetermineUpgradeDowngradeStatus
PUBLIC	_DoFilesInstall
PUBLIC	_DoRegInstall
PUBLIC	_DoRegUninstall
PUBLIC	_DoServiceUninstall
PUBLIC	_DoDriverUnload
PUBLIC	_DoShortcutsInstall
PUBLIC	_DoShortcutsUninstall
PUBLIC	_OutcomePrompt
PUBLIC	_DoUninstall
PUBLIC	_DoInstall
PUBLIC	_SetInstallationPath
PUBLIC	_UpgradeBootLoader
PUBLIC	??$IID_PPV_ARGS_Helper@UIPropertyStore@@@@YAPAPAXPAPAUIPropertyStore@@@Z ; IID_PPV_ARGS_Helper<IPropertyStore>
PUBLIC	?DoApplicationDataUninstall@@YAHPAUHWND__@@@Z	; DoApplicationDataUninstall
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?UninstallDlgProc@@YGHPAUHWND__@@IIJ@Z		; UninstallDlgProc
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_09NKHKFHLH@GostCrypt?$AA@			; `string'
PUBLIC	??_C@_0BK@COLMIOEI@AGostCrypt?5User?5Guide?4pdf?$AA@ ; `string'
PUBLIC	??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@		; `string'
PUBLIC	??_C@_0P@BPIJAOEL@AGostCrypt?4exe?$AA@		; `string'
PUBLIC	??_C@_0BG@PFOLNHIK@AGostCrypt?5Format?4exe?$AA@	; `string'
PUBLIC	??_C@_0P@PFJIKCOA@Agostcrypt?4sys?$AA@		; `string'
PUBLIC	??_C@_0BD@OEHMDGJN@Agostcrypt?9x64?4sys?$AA@	; `string'
PUBLIC	??_C@_0P@MGBPBMGL@Dgostcrypt?4sys?$AA@		; `string'
PUBLIC	??_C@_0BF@CJCNGML@AGostCrypt?5Setup?4exe?$AA@	; `string'
PUBLIC	??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@		; `string'
PUBLIC	??_C@_0BF@MBKAOEOG@GostCrypt?5Format?4exe?$AA@	; `string'
PUBLIC	??_C@_0BC@MDIFFMMP@gostcrypt?9x64?4sys?$AA@	; `string'
PUBLIC	__GUID_886d8eeb_8cf2_4446_8d02_cdba1dbdcf99
PUBLIC	??_C@_1DM@PACGJHBK@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAF?$AAo?$AAu?$AAn?$AAd?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@FHLBCOCO@?$AA?$CF?$AAs?$AA?5?$AA?$CF?$AAh?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_0L@LFAEJJAB@ADDING_REG?$AA@		; `string'
PUBLIC	??_C@_0L@HHILBMI@INSTALLING?$AA@		; `string'
PUBLIC	??_C@_08GLIOLGPM@REMOVING?$AA@			; `string'
PUBLIC	??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@		; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_0BA@IEENJPHG@GostCrypt?5Setup?$AA@	; `string'
PUBLIC	??_C@_08GHPFJMCG@Drivers?2?$AA@			; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BP@KPLJJAIG@System32?2drivers?2gostcrypt?4sys?$AA@ ; `string'
PUBLIC	??_C@_09JMMKOPDJ@ImagePath?$AA@			; `string'
PUBLIC	??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@ ; `string'
PUBLIC	??_C@_0BC@MNFHJDAJ@INSTALL_OF_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BE@ICFIOGFL@UNINSTALL_OF_FAILED?$AA@	; `string'
PUBLIC	??_C@_0P@GPPOMBKF@Language?4?$CK?4xml?$AA@	; `string'
PUBLIC	??_C@_0M@LJEGBCFM@Setup?5files?$AA@		; `string'
PUBLIC	??_C@_0BL@HCDNBGHG@GostCrypt?5User?5Guide?4?$CK?4pdf?$AA@ ; `string'
PUBLIC	??_C@_0DO@MNMIDBOE@Software?2Microsoft?2Windows?2Curre@ ; `string'
PUBLIC	??_C@_05OJPKCACG@1?43?41?$AA@			; `string'
PUBLIC	??_C@_0P@BNDLMAIF@DisplayVersion?$AA@		; `string'
PUBLIC	??_C@_0BK@EMBCECD@http?3?1?1www?4gostcrypt?4org?1?$AA@ ; `string'
PUBLIC	??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@		; `string'
PUBLIC	??_C@_0CB@HIFIENIE@Software?2Classes?2GostCryptVolume@ ; `string'
PUBLIC	??_C@_0BB@BGKFOGNF@GostCrypt?5Volume?$AA@	; `string'
PUBLIC	??_C@_03BMPLCLAP@?$CFws?$AA@			; `string'
PUBLIC	??_C@_0P@LGELIEHB@AppUserModelID?$AA@		; `string'
PUBLIC	??_C@_0CN@HFACCAPK@Software?2Classes?2GostCryptVolume@ ; `string'
PUBLIC	??_C@_0BC@PJLJMABB@?$CFsGostCrypt?4exe?01?$AA@	; `string'
PUBLIC	??_C@_0DE@GDKMHJIK@Software?2Classes?2GostCryptVolume@ ; `string'
PUBLIC	??_C@_0BL@OEOIONON@?$CC?$CFsGostCrypt?4exe?$CC?5?1v?5?$CC?$CF?$CF1?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BG@HDBIFFFP@Software?2Classes?2?4gst?$AA@ ; `string'
PUBLIC	??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@		; `string'
PUBLIC	??_C@_0BL@FHBMAFAG@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?5?1u?$AA@ ; `string'
PUBLIC	??_C@_0BA@OJMJCMCH@UninstallString?$AA@		; `string'
PUBLIC	??_C@_0BL@ELIELANB@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?5?1c?$AA@ ; `string'
PUBLIC	??_C@_0L@OGHNHFGG@ModifyPath?$AA@		; `string'
PUBLIC	??_C@_0BI@BBPBNAKG@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?$AA@ ; `string'
PUBLIC	??_C@_0M@DDCGOGKB@DisplayIcon?$AA@		; `string'
PUBLIC	??_C@_0M@MLHPPPJP@DisplayName?$AA@		; `string'
PUBLIC	??_C@_0BF@JOANFFGE@GostCrypt?5Developers?$AA@	; `string'
PUBLIC	??_C@_09PNIDBPNC@Publisher?$AA@			; `string'
PUBLIC	??_C@_0BD@HFNFAFOP@REG_INSTALL_FAILED?$AA@	; `string'
PUBLIC	??_C@_0P@LLMHDMAL@COM_REG_FAILED?$AA@		; `string'
PUBLIC	??_C@_0BB@EKLCNMAG@REMOVING_APPDATA?$AA@	; `string'
PUBLIC	??_C@_0M@GKPCCOCO@?2GostCrypt?2?$AA@		; `string'
PUBLIC	??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@	; `string'
PUBLIC	??_C@_0BF@CEDLNBLM@Default?5Keyfiles?4xml?$AA@	; `string'
PUBLIC	??_C@_0M@COMBLGLD@History?4xml?$AA@		; `string'
PUBLIC	??_C@_0BC@FNANDAA@Configuration?4xml?$AA@	; `string'
PUBLIC	??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@	; `string'
PUBLIC	??_C@_0L@CANDMBMO@?2GostCrypt?$AA@		; `string'
PUBLIC	??_C@_0BB@OBMIEKIN@COM_DEREG_FAILED?$AA@	; `string'
PUBLIC	??_C@_0N@GACNCPHC@REMOVING_REG?$AA@		; `string'
PUBLIC	??_C@_0CM@GDILNLIK@Software?2Classes?2GostCryptVolume@ ; `string'
PUBLIC	??_C@_0CH@DCEJAAFL@Software?2Classes?2GostCryptVolume@ ; `string'
PUBLIC	??_C@_0BD@EEKEPCFI@Software?2GostCrypt?$AA@	; `string'
PUBLIC	??_C@_09JCILFBFB@gostcrypt?$AA@			; `string'
PUBLIC	??_C@_0BA@HLDEBKOH@STOPPING_DRIVER?$AA@		; `string'
PUBLIC	??_C@_08CGLLMHMN@STOPPING?$AA@			; `string'
PUBLIC	??_C@_0BA@LFOBNNHD@REMOVING_DRIVER?$AA@		; `string'
PUBLIC	??_C@_0BH@BJNFCLGM@DRIVER_UINSTALL_FAILED?$AA@	; `string'
PUBLIC	??_C@_08ELEAABKI@NODRIVER?$AA@			; `string'
PUBLIC	??_C@_0BN@CJLOPMOH@UPDATE_GST_IN_DECOY_OS_FIRST?$AA@ ; `string'
PUBLIC	??_C@_0CM@LPOONFIE@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@ ; `string'
PUBLIC	??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@ ; `string'
PUBLIC	??_C@_0DA@EDIMDHJI@SYS_ENCRYPTION_UPGRADE_UNSUPPORT@ ; `string'
PUBLIC	??_C@_0BD@OMJBKKEL@DISMOUNT_ALL_FIRST?$AA@	; `string'
PUBLIC	??_C@_0BA@BFJEMMFA@CLOSE_GST_FIRST?$AA@		; `string'
PUBLIC	??_C@_0BP@LJKCMEDG@INSTALLER_UPDATING_BOOT_LOADER?$AA@ ; `string'
PUBLIC	??_C@_0CB@JHJCAANH@BOOT_LOADER_UPGRADE_OK_HIDDEN_OS@ ; `string'
PUBLIC	??_C@_0BH@FCKJHOEL@BOOT_LOADER_UPGRADE_OK?$AA@	; `string'
PUBLIC	??_R0?AUException@GostCrypt@@@8			; GostCrypt::Exception `RTTI Type Descriptor'
PUBLIC	??_C@_0BL@LKLMNDDM@BOOT_LOADER_UPGRADE_FAILED?$AA@ ; `string'
PUBLIC	??_C@_0P@FMMFFOMO@?2GostCrypt?4lnk?$AA@		; `string'
PUBLIC	??_C@_0BH@BKNACPBJ@?2GostCrypt?5Website?4url?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JDKCCNOL@?2Uninstall?5GostCrypt?4lnk?$AA@ ; `string'
PUBLIC	??_C@_0BM@PHNJDCEJ@?2GostCrypt?5User?8s?5Guide?4lnk?$AA@ ; `string'
PUBLIC	??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@	; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BL@MKLFJBBF@?$FLInternetShortcut?$FN?6URL?$DN?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@CHHIEGKC@GostCrypt?5Setup?4exe?$AA@	; `string'
PUBLIC	??_C@_02GBOHKKID@?1u?$AA@			; `string'
PUBLIC	??_C@_0L@NPHNJMLA@INSTALL_OK?$AA@		; `string'
PUBLIC	??_C@_0BA@GIHLNOHP@SETUP_UPDATE_OK?$AA@		; `string'
PUBLIC	??_C@_0N@HGHJILFC@UNINSTALL_OK?$AA@		; `string'
PUBLIC	??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@		; `string'
PUBLIC	??_C@_0BB@JJJJFLNM@UNINSTALL_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BD@BOLGBJDG@SRSetRestorePointA?$AA@	; `string'
PUBLIC	??_C@_0BF@DPJDLMKG@CREATING_SYS_RESTORE?$AA@	; `string'
PUBLIC	??_C@_0BJ@GJGJKNIO@GostCrypt?5uninstallation?$AA@ ; `string'
PUBLIC	??_C@_0BH@GKFFIALD@GostCrypt?5installation?$AA@	; `string'
PUBLIC	??_C@_0BD@EKOFOABK@FAILED_SYS_RESTORE?$AA@	; `string'
PUBLIC	??_C@_0BB@CILIJECC@GostCryptService?$AA@	; `string'
PUBLIC	??_C@_0BL@NBOCNBBF@?$CFs?2GostCrypt?9Uninstall?4bat?$AA@ ; `string'
PUBLIC	??_C@_0DP@MNNFDDNO@?3loop?6del?5?$CC?$CFs?$CFs?$CC?6if?5exist?5?$CC?$CFs?$CFs?$CC@ ; `string'
PUBLIC	??_C@_0BP@JGNDMOPD@FAILED_TO_DISABLE_PAGING_FILES?$AA@ ; `string'
PUBLIC	??_C@_07LMLHFMEG@Service?$AA@			; `string'
PUBLIC	??_C@_0EL@MKLMKGDH@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0EL@ELDIGJGM@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0BG@IDCDKCEI@MountFavoritesOnLogon?$AA@	; `string'
PUBLIC	??_C@_0BN@JJNCGBDA@OpenExplorerWindowAfterMount?$AA@ ; `string'
PUBLIC	??_C@_08JKOCNOKF@?$DMvolume?5?$AA@		; `string'
PUBLIC	??_C@_0BC@JBHLDJCD@mountOnLogOn?$DN?$CC1?$CC?5?$AA@ ; `string'
PUBLIC	??_C@_0BI@DLANKHNO@openExplorerWindow?$DN?$CC1?$CC?5?$AA@ ; `string'
PUBLIC	??_C@_09OAMOHPIB@favorites?$AA@			; `string'
PUBLIC	??_C@_09KHMMGKKB@?5?1a?5logon?$AA@		; `string'
PUBLIC	??_C@_0BF@OBKHEKHE@?2GostCrypt?5Setup?4exe?$AA@	; `string'
PUBLIC	??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@ ; `string'
PUBLIC	??_C@_0BM@IAAIJFIC@System?5Favorite?5Volumes?4xml?$AA@ ; `string'
PUBLIC	??_C@_0BC@KNJLNLNB@INSTALL_COMPLETED?$AA@	; `string'
PUBLIC	??_C@_08COBEBGNM@ROLLBACK?$AA@			; `string'
PUBLIC	??_C@_0BH@FAKCOHIL@SYS_ENC_UPGRADE_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BM@IFDMFKIM@UNINSTALL_OLD_VERSION_FIRST?$AA@ ; `string'
PUBLIC	??_C@_04PMOCAHAA@open?$AA@			; `string'
PUBLIC	??_C@_06NOEMODMP@?5?$CIx86?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@ ; `string'
PUBLIC	??_C@_08MFKGCNCO@FINALIZE?$AA@			; `string'
PUBLIC	??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@	; `string'
PUBLIC	??_C@_1CA@DBLADCOC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AA?$AA@ ; `string'
PUBLIC	??_C@_0M@HBOJDPDG@SETUP_ADMIN?$AA@		; `string'
PUBLIC	??_C@_0LE@HOLFPDAN@Error?3?5This?5installer?5file?5does?5@ ; `string'
PUBLIC	??_C@_0BB@FLPPPJPG@SELECT_AN_ACTION?$AA@	; `string'
PUBLIC	??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@	; `string'
PUBLIC	??_C@_09DGJDINFF@UNINSTALL?$AA@			; `string'
PUBLIC	??_C@_04GOLNGIJ@EXIT?$AA@			; `string'
PUBLIC	??_C@_0N@FMOIKEAK@srclient?4dll?$AA@		; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memchr:PROC
EXTRN	_memmove:PROC
EXTRN	_strrchr:PROC
EXTRN	_strstr:PROC
EXTRN	_strcpy_s:PROC
EXTRN	_strcat_s:PROC
EXTRN	_strncat:PROC
EXTRN	_strncmp:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__SetCurrentDirectoryA@4:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__RemoveDirectoryA@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__CreateProcessA@40:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	__imp__GetWindowsDirectoryA@8:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryExA@12:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__GetTempPathA@8:PROC
EXTRN	__imp__CopyFileA@12:PROC
EXTRN	__imp__MoveFileA@8:PROC
EXTRN	__imp__wsprintfW:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__SendMessageW@16:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__DialogBoxParamW@20:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__SendDlgItemMessageA@20:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__SetWindowTextW@8:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__imp__EnumWindows@8:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegCreateKeyExA@36:PROC
EXTRN	__imp__RegDeleteKeyA@8:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__RegSetValueExA@24:PROC
EXTRN	__imp__ShellExecuteA@24:PROC
EXTRN	_free:PROC
EXTRN	_exit:PROC
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	__imp__PropVariantClear@4:PROC
EXTRN	__imp__OleInitialize@4:PROC
EXTRN	__imp__OleUninitialize@0:PROC
EXTRN	__imp__CloseServiceHandle@4:PROC
EXTRN	__imp__ControlService@12:PROC
EXTRN	__imp__DeleteService@4:PROC
EXTRN	__imp__OpenSCManagerA@12:PROC
EXTRN	__imp__OpenServiceA@12:PROC
EXTRN	__imp__QueryServiceStatus@8:PROC
EXTRN	__imp__InitCommonControls@0:PROC
EXTRN	__beginthread:PROC
EXTRN	___stdio_common_vswprintf:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	__access:PROC
EXTRN	__imp__SHStrDupW@8:PROC
EXTRN	__stat64i32:PROC
EXTRN	__stat64:PROC
EXTRN	_cleanup:PROC
EXTRN	_AbortProcess:PROC
EXTRN	_AbortProcessSilent:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	_AboutDlgProc@16:PROC
EXTRN	_IsButtonChecked:PROC
EXTRN	_InitDialog:PROC
EXTRN	_WaitCursor:PROC
EXTRN	_NormalCursor:PROC
EXTRN	_CreateAppSetupMutex:PROC
EXTRN	_CloseAppSetupMutex:PROC
EXTRN	_ReadDriverConfigurationFlags:PROC
EXTRN	_SavePostInstallTasksSettings:PROC
EXTRN	_InitApp:PROC
EXTRN	_DriverAttach:PROC
EXTRN	_handleError:PROC
EXTRN	_CheckFileStreamWriteErrors:PROC
EXTRN	_LocalizeDialog:PROC
EXTRN	_IsAdmin:PROC
EXTRN	_FileExists:PROC
EXTRN	_GSTCopyFile:PROC
EXTRN	_SaveBufferToFile:PROC
EXTRN	_IsNonInstallMode:PROC
EXTRN	_SetCheckBox:PROC
EXTRN	_LoadFile:PROC
EXTRN	_GetConfigPath:PROC
EXTRN	_GetProgramConfigPath:PROC
EXTRN	_Info:PROC
EXTRN	_Warning:PROC
EXTRN	_Error:PROC
EXTRN	_AskNoYes:PROC
EXTRN	_AskWarnNoYes:PROC
EXTRN	_AskMultiChoice:PROC
EXTRN	_ConfigReadInt:PROC
EXTRN	_IsOSAtLeast:PROC
EXTRN	_Is64BitOs:PROC
EXTRN	_IsHiddenOSRunning:PROC
EXTRN	_EnableWow64FsRedirection:PROC
EXTRN	_CloseGSTWindowsEnum@8:PROC
EXTRN	_DoDriverInstall:PROC
EXTRN	_IsPagingFileActive:PROC
EXTRN	_DisablePagingFile:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; GetServiceConfigPath
EXTRN	??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z:PROC ; GostCrypt::BootEncryption::BootEncryption
EXTRN	??1BootEncryption@GostCrypt@@QAE@XZ:PROC	; GostCrypt::BootEncryption::~BootEncryption
EXTRN	?GetDriverServiceStartType@BootEncryption@GostCrypt@@QAEKXZ:PROC ; GostCrypt::BootEncryption::GetDriverServiceStartType
EXTRN	?GetInstalledBootLoaderVersion@BootEncryption@GostCrypt@@QAEGXZ:PROC ; GostCrypt::BootEncryption::GetInstalledBootLoaderVersion
EXTRN	?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ:PROC ; GostCrypt::BootEncryption::GetStatus
EXTRN	?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z:PROC ; GostCrypt::BootEncryption::InstallBootLoader
EXTRN	?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z:PROC ; GostCrypt::BootEncryption::RegisterFilterDriver
EXTRN	?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ:PROC ; GostCrypt::BootEncryption::RenameDeprecatedSystemLoaderBackup
EXTRN	?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z:PROC ; GostCrypt::BootEncryption::SetDriverServiceStartType
EXTRN	_RegisterComServers:PROC
EXTRN	_UnregisterComServers:PROC
EXTRN	_GetString:PROC
EXTRN	_ReadLocalMachineRegistryString:PROC
EXTRN	_ReadRegistryString:PROC
EXTRN	_WriteLocalMachineRegistryString:PROC
EXTRN	_WriteRegistryString:PROC
EXTRN	_DeleteRegistryValue:PROC
EXTRN	_GetStartupRegKeyName:PROC
EXTRN	_mkfulldir:PROC
EXTRN	_SelfExtractStartupInit:PROC
EXTRN	_SelfExtractInMemory:PROC
EXTRN	_MakeSelfExtractingPackage:PROC
EXTRN	_VerifyPackageIntegrity:PROC
EXTRN	_IsSelfExtractingPackage:PROC
EXTRN	_UpdateProgressBarProc:PROC
EXTRN	_localcleanupwiz:PROC
EXTRN	_MainDialogProc@16:PROC
EXTRN	__imp__SHGetPathFromIDListA@8:PROC
EXTRN	__imp__SHGetSpecialFolderLocation@12:PROC
EXTRN	__imp__SHGetSpecialFolderPathA@16:PROC
EXTRN	__imp__SHGetFolderPathA@20:PROC
EXTRN	__imp__SHChangeNotify@16:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_IID_IPersistFile:BYTE
EXTRN	_PKEY_AppUserModel_ID:BYTE
EXTRN	_MainDlg:DWORD
EXTRN	_Silent:DWORD
EXTRN	_lpszTitle:DWORD
EXTRN	_CurrentOSMajor:DWORD
EXTRN	_CurrentOSMinor:DWORD
EXTRN	_CurrentOSServicePack:DWORD
EXTRN	_hDriver:DWORD
EXTRN	_hInst:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_Decompressed_Files:BYTE
EXTRN	_bPromptTutorial:DWORD
EXTRN	_bPromptReleaseNotes:DWORD
EXTRN	_IID_IShellLinkA:BYTE
EXTRN	_CLSID_ShellLink:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A
_BSS	SEGMENT
?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A DB 050H DUP (?) ; `SetSystemRestorePoint'::`2'::RestPtInfo
_BSS	ENDS
;	COMDAT ?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A
_BSS	SEGMENT
?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A DB 0cH DUP (?) ; `SetSystemRestorePoint'::`2'::SMgrStatus
_BSS	ENDS
;	COMDAT ?failed@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4HA
_BSS	SEGMENT
?failed@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4HA DD 01H DUP (?) ; `SetSystemRestorePoint'::`2'::failed
_BSS	ENDS
;	COMDAT ?_SRSetRestorePoint@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4P6GHPAU_RESTOREPTINFOA@@PAU_SMGRSTATUS@@@ZA
_BSS	SEGMENT
?_SRSetRestorePoint@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4P6GHPAU_RESTOREPTINFOA@@PAU_SMGRSTATUS@@@ZA DD 01H DUP (?) ; `SetSystemRestorePoint'::`2'::_SRSetRestorePoint
_BSS	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMOIKEAK@srclient?4dll?$AA@
CONST	SEGMENT
??_C@_0N@FMOIKEAK@srclient?4dll?$AA@ DB 'srclient.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOLNGIJ@EXIT?$AA@
CONST	SEGMENT
??_C@_04GOLNGIJ@EXIT?$AA@ DB 'EXIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DGJDINFF@UNINSTALL?$AA@
CONST	SEGMENT
??_C@_09DGJDINFF@UNINSTALL?$AA@ DB 'UNINSTALL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@
CONST	SEGMENT
??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@ DB 'REPAIR_REINSTALL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FLPPPJPG@SELECT_AN_ACTION?$AA@
CONST	SEGMENT
??_C@_0BB@FLPPPJPG@SELECT_AN_ACTION?$AA@ DB 'SELECT_AN_ACTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LE@HOLFPDAN@Error?3?5This?5installer?5file?5does?5@
CONST	SEGMENT
??_C@_0LE@HOLFPDAN@Error?3?5This?5installer?5file?5does?5@ DB 'Error: Thi'
	DB	's installer file does not contain any compressed files.', 0aH
	DB	0aH, 'To create a self-extracting installation package (with e'
	DB	'mbedded compressed files), run:', 0aH, '"GostCrypt Setup.exe"'
	DB	' /p', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBOJDPDG@SETUP_ADMIN?$AA@
CONST	SEGMENT
??_C@_0M@HBOJDPDG@SETUP_ADMIN?$AA@ DB 'SETUP_ADMIN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@DBLADCOC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@DBLADCOC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AA?$AA@ DB 'G'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, ' ', 00H, 'S', 00H, 'e', 00H, 't', 00H, 'u'
	DB	00H, 'p', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@
CONST	SEGMENT
??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@ DB 'CONFIRM_EXIT_UNIVERSAL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08MFKGCNCO@FINALIZE?$AA@
CONST	SEGMENT
??_C@_08MFKGCNCO@FINALIZE?$AA@ DB 'FINALIZE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@
CONST	SEGMENT
??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@ DB 'GST_INSTALLER_IS_RUN'
	DB	'NING', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOEMODMP@?5?$CIx86?$CJ?$AA@
CONST	SEGMENT
??_C@_06NOEMODMP@?5?$CIx86?$CJ?$AA@ DB ' (x86)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open?$AA@
CONST	SEGMENT
??_C@_04PMOCAHAA@open?$AA@ DB 'open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IFDMFKIM@UNINSTALL_OLD_VERSION_FIRST?$AA@
CONST	SEGMENT
??_C@_0BM@IFDMFKIM@UNINSTALL_OLD_VERSION_FIRST?$AA@ DB 'UNINSTALL_OLD_VER'
	DB	'SION_FIRST', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FAKCOHIL@SYS_ENC_UPGRADE_FAILED?$AA@
CONST	SEGMENT
??_C@_0BH@FAKCOHIL@SYS_ENC_UPGRADE_FAILED?$AA@ DB 'SYS_ENC_UPGRADE_FAILED'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08COBEBGNM@ROLLBACK?$AA@
CONST	SEGMENT
??_C@_08COBEBGNM@ROLLBACK?$AA@ DB 'ROLLBACK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KNJLNLNB@INSTALL_COMPLETED?$AA@
CONST	SEGMENT
??_C@_0BC@KNJLNLNB@INSTALL_COMPLETED?$AA@ DB 'INSTALL_COMPLETED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IAAIJFIC@System?5Favorite?5Volumes?4xml?$AA@
CONST	SEGMENT
??_C@_0BM@IAAIJFIC@System?5Favorite?5Volumes?4xml?$AA@ DB 'System Favorit'
	DB	'e Volumes.xml', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
CONST	SEGMENT
??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@ DB 'GostCrypt Sys'
	DB	'tem Favorite Volumes.xml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OBKHEKHE@?2GostCrypt?5Setup?4exe?$AA@
CONST	SEGMENT
??_C@_0BF@OBKHEKHE@?2GostCrypt?5Setup?4exe?$AA@ DB '\GostCrypt Setup.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KHMMGKKB@?5?1a?5logon?$AA@
CONST	SEGMENT
??_C@_09KHMMGKKB@?5?1a?5logon?$AA@ DB ' /a logon', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAMOHPIB@favorites?$AA@
CONST	SEGMENT
??_C@_09OAMOHPIB@favorites?$AA@ DB 'favorites', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DLANKHNO@openExplorerWindow?$DN?$CC1?$CC?5?$AA@
CONST	SEGMENT
??_C@_0BI@DLANKHNO@openExplorerWindow?$DN?$CC1?$CC?5?$AA@ DB 'openExplore'
	DB	'rWindow="1" ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBHLDJCD@mountOnLogOn?$DN?$CC1?$CC?5?$AA@
CONST	SEGMENT
??_C@_0BC@JBHLDJCD@mountOnLogOn?$DN?$CC1?$CC?5?$AA@ DB 'mountOnLogOn="1" '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08JKOCNOKF@?$DMvolume?5?$AA@
CONST	SEGMENT
??_C@_08JKOCNOKF@?$DMvolume?5?$AA@ DB '<volume ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JJNCGBDA@OpenExplorerWindowAfterMount?$AA@
CONST	SEGMENT
??_C@_0BN@JJNCGBDA@OpenExplorerWindowAfterMount?$AA@ DB 'OpenExplorerWind'
	DB	'owAfterMount', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IDCDKCEI@MountFavoritesOnLogon?$AA@
CONST	SEGMENT
??_C@_0BG@IDCDKCEI@MountFavoritesOnLogon?$AA@ DB 'MountFavoritesOnLogon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@ELDIGJGM@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0EL@ELDIGJGM@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\SafeBoot\Network\GostCryptSystemFavorites', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@MKLMKGDH@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0EL@MKLMKGDH@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\SafeBoot\Minimal\GostCryptSystemFavorites', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LMLHFMEG@Service?$AA@
CONST	SEGMENT
??_C@_07LMLHFMEG@Service?$AA@ DB 'Service', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JGNDMOPD@FAILED_TO_DISABLE_PAGING_FILES?$AA@
CONST	SEGMENT
??_C@_0BP@JGNDMOPD@FAILED_TO_DISABLE_PAGING_FILES?$AA@ DB 'FAILED_TO_DISA'
	DB	'BLE_PAGING_FILES', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@MNNFDDNO@?3loop?6del?5?$CC?$CFs?$CFs?$CC?6if?5exist?5?$CC?$CFs?$CFs?$CC@
CONST	SEGMENT
??_C@_0DP@MNNFDDNO@?3loop?6del?5?$CC?$CFs?$CFs?$CC?6if?5exist?5?$CC?$CFs?$CFs?$CC@ DB ':'
	DB	'loop', 0aH, 'del "%s%s"', 0aH, 'if exist "%s%s" goto loop', 0aH
	DB	'rmdir "%s"', 0aH, 'del "%s"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NBOCNBBF@?$CFs?2GostCrypt?9Uninstall?4bat?$AA@
CONST	SEGMENT
??_C@_0BL@NBOCNBBF@?$CFs?2GostCrypt?9Uninstall?4bat?$AA@ DB '%s\GostCrypt'
	DB	'-Uninstall.bat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CILIJECC@GostCryptService?$AA@
CONST	SEGMENT
??_C@_0BB@CILIJECC@GostCryptService?$AA@ DB 'GostCryptService', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EKOFOABK@FAILED_SYS_RESTORE?$AA@
CONST	SEGMENT
??_C@_0BD@EKOFOABK@FAILED_SYS_RESTORE?$AA@ DB 'FAILED_SYS_RESTORE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GKFFIALD@GostCrypt?5installation?$AA@
CONST	SEGMENT
??_C@_0BH@GKFFIALD@GostCrypt?5installation?$AA@ DB 'GostCrypt installatio'
	DB	'n', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GJGJKNIO@GostCrypt?5uninstallation?$AA@
CONST	SEGMENT
??_C@_0BJ@GJGJKNIO@GostCrypt?5uninstallation?$AA@ DB 'GostCrypt uninstall'
	DB	'ation', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DPJDLMKG@CREATING_SYS_RESTORE?$AA@
CONST	SEGMENT
??_C@_0BF@DPJDLMKG@CREATING_SYS_RESTORE?$AA@ DB 'CREATING_SYS_RESTORE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BOLGBJDG@SRSetRestorePointA?$AA@
CONST	SEGMENT
??_C@_0BD@BOLGBJDG@SRSetRestorePointA?$AA@ DB 'SRSetRestorePointA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JJJJFLNM@UNINSTALL_FAILED?$AA@
CONST	SEGMENT
??_C@_0BB@JJJJFLNM@UNINSTALL_FAILED?$AA@ DB 'UNINSTALL_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@
CONST	SEGMENT
??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@ DB 'INSTALL_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HGHJILFC@UNINSTALL_OK?$AA@
CONST	SEGMENT
??_C@_0N@HGHJILFC@UNINSTALL_OK?$AA@ DB 'UNINSTALL_OK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GIHLNOHP@SETUP_UPDATE_OK?$AA@
CONST	SEGMENT
??_C@_0BA@GIHLNOHP@SETUP_UPDATE_OK?$AA@ DB 'SETUP_UPDATE_OK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NPHNJMLA@INSTALL_OK?$AA@
CONST	SEGMENT
??_C@_0L@NPHNJMLA@INSTALL_OK?$AA@ DB 'INSTALL_OK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GBOHKKID@?1u?$AA@
CONST	SEGMENT
??_C@_02GBOHKKID@?1u?$AA@ DB '/u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CHHIEGKC@GostCrypt?5Setup?4exe?$AA@
CONST	SEGMENT
??_C@_0BE@CHHIEGKC@GostCrypt?5Setup?4exe?$AA@ DB 'GostCrypt Setup.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MKLFJBBF@?$FLInternetShortcut?$FN?6URL?$DN?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BL@MKLFJBBF@?$FLInternetShortcut?$FN?6URL?$DN?$CFs?6?$AA@ DB '[Int'
	DB	'ernetShortcut]', 0aH, 'URL=%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@
CONST	SEGMENT
??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@ DB 'CANT_CREATE_FOLDER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PHNJDCEJ@?2GostCrypt?5User?8s?5Guide?4lnk?$AA@
CONST	SEGMENT
??_C@_0BM@PHNJDCEJ@?2GostCrypt?5User?8s?5Guide?4lnk?$AA@ DB '\GostCrypt U'
	DB	'ser''s Guide.lnk', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JDKCCNOL@?2Uninstall?5GostCrypt?4lnk?$AA@
CONST	SEGMENT
??_C@_0BJ@JDKCCNOL@?2Uninstall?5GostCrypt?4lnk?$AA@ DB '\Uninstall GostCr'
	DB	'ypt.lnk', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BKNACPBJ@?2GostCrypt?5Website?4url?$AA@
CONST	SEGMENT
??_C@_0BH@BKNACPBJ@?2GostCrypt?5Website?4url?$AA@ DB '\GostCrypt Website.'
	DB	'url', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FMMFFOMO@?2GostCrypt?4lnk?$AA@
CONST	SEGMENT
??_C@_0P@FMMFFOMO@?2GostCrypt?4lnk?$AA@ DB '\GostCrypt.lnk', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LKLMNDDM@BOOT_LOADER_UPGRADE_FAILED?$AA@
CONST	SEGMENT
??_C@_0BL@LKLMNDDM@BOOT_LOADER_UPGRADE_FAILED?$AA@ DB 'BOOT_LOADER_UPGRAD'
	DB	'E_FAILED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_R0?AUException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::Exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BH@FCKJHOEL@BOOT_LOADER_UPGRADE_OK?$AA@
CONST	SEGMENT
??_C@_0BH@FCKJHOEL@BOOT_LOADER_UPGRADE_OK?$AA@ DB 'BOOT_LOADER_UPGRADE_OK'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JHJCAANH@BOOT_LOADER_UPGRADE_OK_HIDDEN_OS@
CONST	SEGMENT
??_C@_0CB@JHJCAANH@BOOT_LOADER_UPGRADE_OK_HIDDEN_OS@ DB 'BOOT_LOADER_UPGR'
	DB	'ADE_OK_HIDDEN_OS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LJKCMEDG@INSTALLER_UPDATING_BOOT_LOADER?$AA@
CONST	SEGMENT
??_C@_0BP@LJKCMEDG@INSTALLER_UPDATING_BOOT_LOADER?$AA@ DB 'INSTALLER_UPDA'
	DB	'TING_BOOT_LOADER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BFJEMMFA@CLOSE_GST_FIRST?$AA@
CONST	SEGMENT
??_C@_0BA@BFJEMMFA@CLOSE_GST_FIRST?$AA@ DB 'CLOSE_GST_FIRST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OMJBKKEL@DISMOUNT_ALL_FIRST?$AA@
CONST	SEGMENT
??_C@_0BD@OMJBKKEL@DISMOUNT_ALL_FIRST?$AA@ DB 'DISMOUNT_ALL_FIRST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EDIMDHJI@SYS_ENCRYPTION_UPGRADE_UNSUPPORT@
CONST	SEGMENT
??_C@_0DA@EDIMDHJI@SYS_ENCRYPTION_UPGRADE_UNSUPPORT@ DB 'SYS_ENCRYPTION_U'
	DB	'PGRADE_UNSUPPORTED_ON_VISTA_SP0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@
CONST	SEGMENT
??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@ DB 'SETUP_FAILED_BOO'
	DB	'T_DRIVE_ENCRYPTED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LPOONFIE@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@
CONST	SEGMENT
??_C@_0CM@LPOONFIE@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@ DB 'SETUP_FAILED_BOO'
	DB	'T_DRIVE_ENCRYPTED_DOWNGRADE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CJLOPMOH@UPDATE_GST_IN_DECOY_OS_FIRST?$AA@
CONST	SEGMENT
??_C@_0BN@CJLOPMOH@UPDATE_GST_IN_DECOY_OS_FIRST?$AA@ DB 'UPDATE_GST_IN_DE'
	DB	'COY_OS_FIRST', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08ELEAABKI@NODRIVER?$AA@
CONST	SEGMENT
??_C@_08ELEAABKI@NODRIVER?$AA@ DB 'NODRIVER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BJNFCLGM@DRIVER_UINSTALL_FAILED?$AA@
CONST	SEGMENT
??_C@_0BH@BJNFCLGM@DRIVER_UINSTALL_FAILED?$AA@ DB 'DRIVER_UINSTALL_FAILED'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LFOBNNHD@REMOVING_DRIVER?$AA@
CONST	SEGMENT
??_C@_0BA@LFOBNNHD@REMOVING_DRIVER?$AA@ DB 'REMOVING_DRIVER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CGLLMHMN@STOPPING?$AA@
CONST	SEGMENT
??_C@_08CGLLMHMN@STOPPING?$AA@ DB 'STOPPING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HLDEBKOH@STOPPING_DRIVER?$AA@
CONST	SEGMENT
??_C@_0BA@HLDEBKOH@STOPPING_DRIVER?$AA@ DB 'STOPPING_DRIVER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCILFBFB@gostcrypt?$AA@
CONST	SEGMENT
??_C@_09JCILFBFB@gostcrypt?$AA@ DB 'gostcrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EEKEPCFI@Software?2GostCrypt?$AA@
CONST	SEGMENT
??_C@_0BD@EEKEPCFI@Software?2GostCrypt?$AA@ DB 'Software\GostCrypt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DCEJAAFL@Software?2Classes?2GostCryptVolume@
CONST	SEGMENT
??_C@_0CH@DCEJAAFL@Software?2Classes?2GostCryptVolume@ DB 'Software\Class'
	DB	'es\GostCryptVolume\Shell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@GDILNLIK@Software?2Classes?2GostCryptVolume@
CONST	SEGMENT
??_C@_0CM@GDILNLIK@Software?2Classes?2GostCryptVolume@ DB 'Software\Class'
	DB	'es\GostCryptVolume\Shell\open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GACNCPHC@REMOVING_REG?$AA@
CONST	SEGMENT
??_C@_0N@GACNCPHC@REMOVING_REG?$AA@ DB 'REMOVING_REG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OBMIEKIN@COM_DEREG_FAILED?$AA@
CONST	SEGMENT
??_C@_0BB@OBMIEKIN@COM_DEREG_FAILED?$AA@ DB 'COM_DEREG_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@
CONST	SEGMENT
??_C@_0L@CANDMBMO@?2GostCrypt?$AA@ DB '\GostCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@
CONST	SEGMENT
??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@ DB 'System Encryption.xml'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FNANDAA@Configuration?4xml?$AA@
CONST	SEGMENT
??_C@_0BC@FNANDAA@Configuration?4xml?$AA@ DB 'Configuration.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COMBLGLD@History?4xml?$AA@
CONST	SEGMENT
??_C@_0M@COMBLGLD@History?4xml?$AA@ DB 'History.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CEDLNBLM@Default?5Keyfiles?4xml?$AA@
CONST	SEGMENT
??_C@_0BF@CEDLNBLM@Default?5Keyfiles?4xml?$AA@ DB 'Default Keyfiles.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@
CONST	SEGMENT
??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@ DB 'Favorite Volumes.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GKPCCOCO@?2GostCrypt?2?$AA@
CONST	SEGMENT
??_C@_0M@GKPCCOCO@?2GostCrypt?2?$AA@ DB '\GostCrypt\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EKLCNMAG@REMOVING_APPDATA?$AA@
CONST	SEGMENT
??_C@_0BB@EKLCNMAG@REMOVING_APPDATA?$AA@ DB 'REMOVING_APPDATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LLMHDMAL@COM_REG_FAILED?$AA@
CONST	SEGMENT
??_C@_0P@LLMHDMAL@COM_REG_FAILED?$AA@ DB 'COM_REG_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HFNFAFOP@REG_INSTALL_FAILED?$AA@
CONST	SEGMENT
??_C@_0BD@HFNFAFOP@REG_INSTALL_FAILED?$AA@ DB 'REG_INSTALL_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PNIDBPNC@Publisher?$AA@
CONST	SEGMENT
??_C@_09PNIDBPNC@Publisher?$AA@ DB 'Publisher', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JOANFFGE@GostCrypt?5Developers?$AA@
CONST	SEGMENT
??_C@_0BF@JOANFFGE@GostCrypt?5Developers?$AA@ DB 'GostCrypt Developers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MLHPPPJP@DisplayName?$AA@
CONST	SEGMENT
??_C@_0M@MLHPPPJP@DisplayName?$AA@ DB 'DisplayName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DDCGOGKB@DisplayIcon?$AA@
CONST	SEGMENT
??_C@_0M@DDCGOGKB@DisplayIcon?$AA@ DB 'DisplayIcon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BBPBNAKG@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?$AA@
CONST	SEGMENT
??_C@_0BI@BBPBNAKG@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?$AA@ DB '"%sGostCry'
	DB	'pt Setup.exe"', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OGHNHFGG@ModifyPath?$AA@
CONST	SEGMENT
??_C@_0L@OGHNHFGG@ModifyPath?$AA@ DB 'ModifyPath', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ELIELANB@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?5?1c?$AA@
CONST	SEGMENT
??_C@_0BL@ELIELANB@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?5?1c?$AA@ DB '"%sGo'
	DB	'stCrypt Setup.exe" /c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OJMJCMCH@UninstallString?$AA@
CONST	SEGMENT
??_C@_0BA@OJMJCMCH@UninstallString?$AA@ DB 'UninstallString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FHBMAFAG@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?5?1u?$AA@
CONST	SEGMENT
??_C@_0BL@FHBMAFAG@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?5?1u?$AA@ DB '"%sGo'
	DB	'stCrypt Setup.exe" /u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@
CONST	SEGMENT
??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@ DB 'GostCryptVolume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HDBIFFFP@Software?2Classes?2?4gst?$AA@
CONST	SEGMENT
??_C@_0BG@HDBIFFFP@Software?2Classes?2?4gst?$AA@ DB 'Software\Classes\.gs'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OEOIONON@?$CC?$CFsGostCrypt?4exe?$CC?5?1v?5?$CC?$CF?$CF1?$CC?$AA@
CONST	SEGMENT
??_C@_0BL@OEOIONON@?$CC?$CFsGostCrypt?4exe?$CC?5?1v?5?$CC?$CF?$CF1?$CC?$AA@ DB '"'
	DB	'%sGostCrypt.exe" /v "%%1"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GDKMHJIK@Software?2Classes?2GostCryptVolume@
CONST	SEGMENT
??_C@_0DE@GDKMHJIK@Software?2Classes?2GostCryptVolume@ DB 'Software\Class'
	DB	'es\GostCryptVolume\Shell\open\command', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PJLJMABB@?$CFsGostCrypt?4exe?01?$AA@
CONST	SEGMENT
??_C@_0BC@PJLJMABB@?$CFsGostCrypt?4exe?01?$AA@ DB '%sGostCrypt.exe,1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HFACCAPK@Software?2Classes?2GostCryptVolume@
CONST	SEGMENT
??_C@_0CN@HFACCAPK@Software?2Classes?2GostCryptVolume@ DB 'Software\Class'
	DB	'es\GostCryptVolume\DefaultIcon', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LGELIEHB@AppUserModelID?$AA@
CONST	SEGMENT
??_C@_0P@LGELIEHB@AppUserModelID?$AA@ DB 'AppUserModelID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BMPLCLAP@?$CFws?$AA@
CONST	SEGMENT
??_C@_03BMPLCLAP@?$CFws?$AA@ DB '%ws', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BGKFOGNF@GostCrypt?5Volume?$AA@
CONST	SEGMENT
??_C@_0BB@BGKFOGNF@GostCrypt?5Volume?$AA@ DB 'GostCrypt Volume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HIFIENIE@Software?2Classes?2GostCryptVolume@
CONST	SEGMENT
??_C@_0CB@HIFIENIE@Software?2Classes?2GostCryptVolume@ DB 'Software\Class'
	DB	'es\GostCryptVolume', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@
CONST	SEGMENT
??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@ DB 'URLInfoAbout', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EMBCECD@http?3?1?1www?4gostcrypt?4org?1?$AA@
CONST	SEGMENT
??_C@_0BK@EMBCECD@http?3?1?1www?4gostcrypt?4org?1?$AA@ DB 'http://www.gos'
	DB	'tcrypt.org/', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BNDLMAIF@DisplayVersion?$AA@
CONST	SEGMENT
??_C@_0P@BNDLMAIF@DisplayVersion?$AA@ DB 'DisplayVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OJPKCACG@1?43?41?$AA@
CONST	SEGMENT
??_C@_05OJPKCACG@1?43?41?$AA@ DB '1.3.1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@MNMIDBOE@Software?2Microsoft?2Windows?2Curre@
CONST	SEGMENT
??_C@_0DO@MNMIDBOE@Software?2Microsoft?2Windows?2Curre@ DB 'Software\Micr'
	DB	'osoft\Windows\CurrentVersion\Uninstall\GostCrypt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HCDNBGHG@GostCrypt?5User?5Guide?4?$CK?4pdf?$AA@
CONST	SEGMENT
??_C@_0BL@HCDNBGHG@GostCrypt?5User?5Guide?4?$CK?4pdf?$AA@ DB 'GostCrypt U'
	DB	'ser Guide.*.pdf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJEGBCFM@Setup?5files?$AA@
CONST	SEGMENT
??_C@_0M@LJEGBCFM@Setup?5files?$AA@ DB 'Setup files', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GPPOMBKF@Language?4?$CK?4xml?$AA@
CONST	SEGMENT
??_C@_0P@GPPOMBKF@Language?4?$CK?4xml?$AA@ DB 'Language.*.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ICFIOGFL@UNINSTALL_OF_FAILED?$AA@
CONST	SEGMENT
??_C@_0BE@ICFIOGFL@UNINSTALL_OF_FAILED?$AA@ DB 'UNINSTALL_OF_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MNFHJDAJ@INSTALL_OF_FAILED?$AA@
CONST	SEGMENT
??_C@_0BC@MNFHJDAJ@INSTALL_OF_FAILED?$AA@ DB 'INSTALL_OF_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@
CONST	SEGMENT
??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@ DB 'SYSTEM\Current'
	DB	'ControlSet\Services\gostcrypt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JMMKOPDJ@ImagePath?$AA@
CONST	SEGMENT
??_C@_09JMMKOPDJ@ImagePath?$AA@ DB 'ImagePath', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KPLJJAIG@System32?2drivers?2gostcrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0BP@KPLJJAIG@System32?2drivers?2gostcrypt?4sys?$AA@ DB 'System32\dr'
	DB	'ivers\gostcrypt.sys', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHPFJMCG@Drivers?2?$AA@
CONST	SEGMENT
??_C@_08GHPFJMCG@Drivers?2?$AA@ DB 'Drivers\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IEENJPHG@GostCrypt?5Setup?$AA@
CONST	SEGMENT
??_C@_0BA@IEENJPHG@GostCrypt?5Setup?$AA@ DB 'GostCrypt Setup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
CONST	SEGMENT
??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@ DB 'ADDING_ICON', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GLIOLGPM@REMOVING?$AA@
CONST	SEGMENT
??_C@_08GLIOLGPM@REMOVING?$AA@ DB 'REMOVING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HHILBMI@INSTALLING?$AA@
CONST	SEGMENT
??_C@_0L@HHILBMI@INSTALLING?$AA@ DB 'INSTALLING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LFAEJJAB@ADDING_REG?$AA@
CONST	SEGMENT
??_C@_0L@LFAEJJAB@ADDING_REG?$AA@ DB 'ADDING_REG', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@FHLBCOCO@?$AA?$CF?$AAs?$AA?5?$AA?$CF?$AAh?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1O@FHLBCOCO@?$AA?$CF?$AAs?$AA?5?$AA?$CF?$AAh?$AAs?$AA?$AA@ DB '%', 00H
	DB	's', 00H, ' ', 00H, '%', 00H, 'h', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@PACGJHBK@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAF?$AAo?$AAu?$AAn?$AAd?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@PACGJHBK@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAF?$AAo?$AAu?$AAn?$AAd?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@ DB 'G'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'F', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H
	DB	'G', 00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y'
	DB	00H, 'p', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT __GUID_886d8eeb_8cf2_4446_8d02_cdba1dbdcf99
CONST	SEGMENT
__GUID_886d8eeb_8cf2_4446_8d02_cdba1dbdcf99 DD 0886d8eebH
	DW	08cf2H
	DW	04446H
	DB	08dH
	DB	02H
	DB	0cdH
	DB	0baH
	DB	01dH
	DB	0bdH
	DB	0cfH
	DB	099H
CONST	ENDS
;	COMDAT ??_C@_0BC@MDIFFMMP@gostcrypt?9x64?4sys?$AA@
CONST	SEGMENT
??_C@_0BC@MDIFFMMP@gostcrypt?9x64?4sys?$AA@ DB 'gostcrypt-x64.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MBKAOEOG@GostCrypt?5Format?4exe?$AA@
CONST	SEGMENT
??_C@_0BF@MBKAOEOG@GostCrypt?5Format?4exe?$AA@ DB 'GostCrypt Format.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@
CONST	SEGMENT
??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@ DB 'GostCrypt.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CJCNGML@AGostCrypt?5Setup?4exe?$AA@
CONST	SEGMENT
??_C@_0BF@CJCNGML@AGostCrypt?5Setup?4exe?$AA@ DB 'AGostCrypt Setup.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MGBPBMGL@Dgostcrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0P@MGBPBMGL@Dgostcrypt?4sys?$AA@ DB 'Dgostcrypt.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OEHMDGJN@Agostcrypt?9x64?4sys?$AA@
CONST	SEGMENT
??_C@_0BD@OEHMDGJN@Agostcrypt?9x64?4sys?$AA@ DB 'Agostcrypt-x64.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PFJIKCOA@Agostcrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0P@PFJIKCOA@Agostcrypt?4sys?$AA@ DB 'Agostcrypt.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PFOLNHIK@AGostCrypt?5Format?4exe?$AA@
CONST	SEGMENT
??_C@_0BG@PFOLNHIK@AGostCrypt?5Format?4exe?$AA@ DB 'AGostCrypt Format.exe'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BPIJAOEL@AGostCrypt?4exe?$AA@
CONST	SEGMENT
??_C@_0P@BPIJAOEL@AGostCrypt?4exe?$AA@ DB 'AGostCrypt.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@
CONST	SEGMENT
??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@ DB 'ALicense.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@COLMIOEI@AGostCrypt?5User?5Guide?4pdf?$AA@
CONST	SEGMENT
??_C@_0BK@COLMIOEI@AGostCrypt?5User?5Guide?4pdf?$AA@ DB 'AGostCrypt User '
	DB	'Guide.pdf', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_szFiles DD	FLAT:??_C@_0BK@COLMIOEI@AGostCrypt?5User?5Guide?4pdf?$AA@
	DD	FLAT:??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@
	DD	FLAT:??_C@_0P@BPIJAOEL@AGostCrypt?4exe?$AA@
	DD	FLAT:??_C@_0BG@PFOLNHIK@AGostCrypt?5Format?4exe?$AA@
	DD	FLAT:??_C@_0P@PFJIKCOA@Agostcrypt?4sys?$AA@
	DD	FLAT:??_C@_0BD@OEHMDGJN@Agostcrypt?9x64?4sys?$AA@
	DD	FLAT:??_C@_0P@MGBPBMGL@Dgostcrypt?4sys?$AA@
	DD	FLAT:??_C@_0BF@CJCNGML@AGostCrypt?5Setup?4exe?$AA@
_DATA	ENDS
;	COMDAT ??_C@_09NKHKFHLH@GostCrypt?$AA@
CONST	SEGMENT
??_C@_09NKHKFHLH@GostCrypt?$AA@ DB 'GostCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$_UpgradeBootLoader DD 00H
	DD	01H
	DD	02H
	DD	02H
	DD	FLAT:__catchsym$_UpgradeBootLoader$4
__unwindtable$_UpgradeBootLoader DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_UpgradeBootLoader$3
	DD	0ffffffffH
	DD	00H
__catchsym$_UpgradeBootLoader$4 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffa1cH
	DD	FLAT:__catch$_UpgradeBootLoader$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_UpgradeBootLoader$1
__ehfuncinfo$_UpgradeBootLoader DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$_UpgradeBootLoader
	DD	01H
	DD	FLAT:__tryblocktable$_UpgradeBootLoader
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_DoInstall$314 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoInstall$7
__catchsym$_DoInstall$313 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffff5e4H
	DD	FLAT:__catch$_DoInstall$2
__catchsym$_DoInstall$312 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoInstall$3
__catchsym$_DoInstall$311 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoInstall$0
__ehfuncinfo$_DoInstall DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$_DoInstall
	DD	04H
	DD	FLAT:__tryblocktable$_DoInstall
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$_DoInstall DD 09H
	DD	09H
	DD	0aH
	DD	01H
	DD	FLAT:__catchsym$_DoInstall$311
	DD	0dH
	DD	0dH
	DD	0eH
	DD	01H
	DD	FLAT:__catchsym$_DoInstall$312
	DD	0bH
	DD	0bH
	DD	0eH
	DD	01H
	DD	FLAT:__catchsym$_DoInstall$313
	DD	010H
	DD	010H
	DD	011H
	DD	01H
	DD	FLAT:__catchsym$_DoInstall$314
__unwindtable$_DoInstall DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_DoInstall$9
	DD	00H
	DD	FLAT:__unwindfunclet$_DoInstall$10
	DD	01H
	DD	FLAT:__unwindfunclet$_DoInstall$11
	DD	02H
	DD	FLAT:__unwindfunclet$_DoInstall$12
	DD	03H
	DD	FLAT:__unwindfunclet$_DoInstall$13
	DD	04H
	DD	FLAT:__unwindfunclet$_DoInstall$14
	DD	05H
	DD	FLAT:__unwindfunclet$_DoInstall$15
	DD	06H
	DD	FLAT:__unwindfunclet$_DoInstall$16
	DD	07H
	DD	FLAT:__unwindfunclet$_DoInstall$17
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0cH
	DD	00H
	DD	0cH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_DoInstall$19
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_DoInstall$20
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_DoDriverUnload$15 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoDriverUnload$8
__catchsym$_DoDriverUnload$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoDriverUnload$6
__catchsym$_DoDriverUnload$13 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoDriverUnload$4
__catchsym$_DoDriverUnload$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoDriverUnload$2
__catchsym$_DoDriverUnload$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoDriverUnload$0
__ehfuncinfo$_DoDriverUnload DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$_DoDriverUnload
	DD	05H
	DD	FLAT:__tryblocktable$_DoDriverUnload
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_DoDriverUnload DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_DoDriverUnload$10
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_DoDriverUnload DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$_DoDriverUnload$11
	DD	04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$_DoDriverUnload$12
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$_DoDriverUnload$13
	DD	08H
	DD	08H
	DD	09H
	DD	01H
	DD	FLAT:__catchsym$_DoDriverUnload$14
	DD	00H
	DD	09H
	DD	0aH
	DD	01H
	DD	FLAT:__catchsym$_DoDriverUnload$15
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_DoServiceUninstall$21 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoServiceUninstall$8
__catchsym$_DoServiceUninstall$20 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoServiceUninstall$6
__catchsym$_DoServiceUninstall$19 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoServiceUninstall$4
__catchsym$_DoServiceUninstall$18 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoServiceUninstall$2
__ehfuncinfo$_DoServiceUninstall DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$_DoServiceUninstall
	DD	04H
	DD	FLAT:__tryblocktable$_DoServiceUninstall
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_DoServiceUninstall DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_DoServiceUninstall$17
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_DoServiceUninstall DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$_DoServiceUninstall$18
	DD	04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$_DoServiceUninstall$19
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$_DoServiceUninstall$20
	DD	00H
	DD	07H
	DD	08H
	DD	01H
	DD	FLAT:__catchsym$_DoServiceUninstall$21
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT
; _this$ = ecx

; 1202 : 		{	// assign [_First, _Last), input iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1203 : 		return (replace(begin(), end(), _First, _Last));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	72 04		 jb	 SHORT $LN14@assign
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	eb 02		 jmp	 SHORT $LN15@assign
$LN14@assign:
  0000d	8b d1		 mov	 edx, ecx
$LN15@assign:
  0000f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00012	03 c2		 add	 eax, edx
  00014	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00018	72 13		 jb	 SHORT $LN48@assign
  0001a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00022	50		 push	 eax
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1204 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8

; 1203 : 		return (replace(begin(), end(), _First, _Last));

$LN48@assign:
  0002d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00030	8b d1		 mov	 edx, ecx
  00032	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1204 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 398  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 399  : 		return (*(_Mybase *)this - _Right);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 400  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 340  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 341  : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 322  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 321  : 		: _Mybase(_Parg, _Pstring)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 323  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT ?UninstallDlgProc@@YGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_msg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?UninstallDlgProc@@YGHPAUHWND__@@IIJ@Z PROC		; UninstallDlgProc, COMDAT

; 2195 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2196 : 	WORD lw = LOWORD (wParam);
; 2197 : 
; 2198 : 	switch (msg)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  00006	3d 11 01 00 00	 cmp	 eax, 273		; 00000111H
  0000b	0f 87 ac 01 00
	00		 ja	 $LN20@UninstallD
  00011	0f 84 ee 00 00
	00		 je	 $LN9@UninstallD
  00017	83 f8 10	 cmp	 eax, 16			; 00000010H
  0001a	0f 84 a8 00 00
	00		 je	 $LN16@UninstallD
  00020	3d 10 01 00 00	 cmp	 eax, 272		; 00000110H
  00025	0f 85 00 02 00
	00		 jne	 $LN8@UninstallD

; 2199 : 	{
; 2200 : 	case WM_INITDIALOG:
; 2201 : 
; 2202 : 		MainDlg = hwndDlg;

  0002b	56		 push	 esi
  0002c	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]
  0002f	89 35 00 00 00
	00		 mov	 DWORD PTR _MainDlg, esi

; 2203 : 
; 2204 : 		if (!CreateAppSetupMutex ())

  00035	e8 00 00 00 00	 call	 _CreateAppSetupMutex
  0003a	85 c0		 test	 eax, eax
  0003c	75 0d		 jne	 SHORT $LN5@UninstallD

; 2205 : 			AbortProcess ("GST_INSTALLER_IS_RUNNING");

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CCHDLBFE@GST_INSTALLER_IS_RUNNING?$AA@
  00043	e8 00 00 00 00	 call	 _AbortProcess
  00048	83 c4 04	 add	 esp, 4
$LN5@UninstallD:

; 2206 : 
; 2207 : 		InitDialog (hwndDlg);

  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 _InitDialog

; 2208 : 		LocalizeDialog (hwndDlg, NULL);

  00051	6a 00		 push	 0
  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 _LocalizeDialog
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2209 : 
; 2210 : 		SetWindowTextW (hwndDlg, lpszTitle);

  0005c	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00062	56		 push	 esi
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 2211 : 
; 2212 : 		// System Restore
; 2213 : 		SetCheckBox (hwndDlg, IDC_SYSTEM_RESTORE, bSystemRestore);

  00069	ff 35 00 00 00
	00		 push	 DWORD PTR _bSystemRestore
  0006f	68 f3 03 00 00	 push	 1011			; 000003f3H
  00074	56		 push	 esi
  00075	e8 00 00 00 00	 call	 _SetCheckBox
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2214 : 		if (SystemRestoreDll == 0)

  0007d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemRestoreDll, 0
  00084	75 25		 jne	 SHORT $LN6@UninstallD

; 2215 : 		{
; 2216 : 			SetCheckBox (hwndDlg, IDC_SYSTEM_RESTORE, FALSE);

  00086	6a 00		 push	 0
  00088	68 f3 03 00 00	 push	 1011			; 000003f3H
  0008d	56		 push	 esi
  0008e	e8 00 00 00 00	 call	 _SetCheckBox
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2217 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_SYSTEM_RESTORE), FALSE);

  00096	6a 00		 push	 0
  00098	68 f3 03 00 00	 push	 1011			; 000003f3H
  0009d	56		 push	 esi
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  000a4	50		 push	 eax
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
$LN6@UninstallD:

; 2218 : 		}
; 2219 : 
; 2220 : 		SetFocus (GetDlgItem (hwndDlg, IDC_UNINSTALL));

  000ab	68 f7 03 00 00	 push	 1015			; 000003f7H
  000b0	56		 push	 esi
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 2221 : 
; 2222 : 		return 1;

  000be	b8 01 00 00 00	 mov	 eax, 1
  000c3	5e		 pop	 esi

; 2283 : 	}
; 2284 : 
; 2285 : 	return 0;
; 2286 : }

  000c4	5d		 pop	 ebp
  000c5	c2 10 00	 ret	 16			; 00000010H
$LN16@UninstallD:

; 2270 : 
; 2271 : 	case WM_CLOSE:
; 2272 : 		if (bUninstallInProgress)

  000c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstallInProgress@@3HA, 0 ; bUninstallInProgress
  000cf	74 20		 je	 SHORT $LN17@UninstallD

; 2273 : 		{
; 2274 : 			NormalCursor();

  000d1	e8 00 00 00 00	 call	 _NormalCursor

; 2275 : 			if (AskNoYes("CONFIRM_EXIT_UNIVERSAL") == IDNO)

  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@
  000db	e8 00 00 00 00	 call	 _AskNoYes
  000e0	83 c4 04	 add	 esp, 4
  000e3	83 f8 07	 cmp	 eax, 7
  000e6	0f 84 36 01 00
	00		 je	 $LN21@UninstallD

; 2276 : 			{
; 2277 : 				return 1;
; 2278 : 			}
; 2279 : 			WaitCursor ();

  000ec	e8 00 00 00 00	 call	 _WaitCursor
$LN17@UninstallD:

; 2280 : 		}
; 2281 : 		EndDialog (hwndDlg, IDCANCEL);

  000f1	6a 02		 push	 2
  000f3	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 2282 : 		return 1;

  000fc	b8 01 00 00 00	 mov	 eax, 1

; 2283 : 	}
; 2284 : 
; 2285 : 	return 0;
; 2286 : }

  00101	5d		 pop	 ebp
  00102	c2 10 00	 ret	 16			; 00000010H
$LN9@UninstallD:

; 2231 : 
; 2232 : 	case WM_COMMAND:
; 2233 : 		if (lw == IDC_UNINSTALL)

  00105	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00108	b9 f7 03 00 00	 mov	 ecx, 1015		; 000003f7H
  0010d	66 3b c1	 cmp	 ax, cx
  00110	75 5e		 jne	 SHORT $LN10@UninstallD

; 2234 : 		{
; 2235 : 			if (bDone)

  00112	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDone@@3HA, 0 ; bDone
  00119	74 22		 je	 SHORT $LN11@UninstallD

; 2236 : 			{
; 2237 : 				bUninstallInProgress = FALSE;
; 2238 : 				PostMessage (hwndDlg, WM_CLOSE, 0, 0);

  0011b	6a 00		 push	 0
  0011d	6a 00		 push	 0
  0011f	6a 10		 push	 16			; 00000010H
  00121	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00124	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bUninstallInProgress@@3HA, 0 ; bUninstallInProgress
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 2239 : 				return 1;

  00134	b8 01 00 00 00	 mov	 eax, 1

; 2283 : 	}
; 2284 : 
; 2285 : 	return 0;
; 2286 : }

  00139	5d		 pop	 ebp
  0013a	c2 10 00	 ret	 16			; 00000010H
$LN11@UninstallD:

; 2240 : 			}
; 2241 : 
; 2242 : 			bUninstallInProgress = TRUE;

  0013d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bUninstallInProgress@@3HA, 1 ; bUninstallInProgress

; 2243 : 
; 2244 : 			WaitCursor ();

  00147	e8 00 00 00 00	 call	 _WaitCursor

; 2245 : 
; 2246 : 			if (bUninstall)

  0014c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00153	74 12		 je	 SHORT $LN12@UninstallD

; 2247 : 				_beginthread (DoUninstall, 0, (void *) hwndDlg);

  00155	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00158	6a 00		 push	 0
  0015a	68 00 00 00 00	 push	 OFFSET _DoUninstall
  0015f	e8 00 00 00 00	 call	 __beginthread
  00164	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@UninstallD:

; 2248 : 
; 2249 : 			return 1;

  00167	b8 01 00 00 00	 mov	 eax, 1

; 2283 : 	}
; 2284 : 
; 2285 : 	return 0;
; 2286 : }

  0016c	5d		 pop	 ebp
  0016d	c2 10 00	 ret	 16			; 00000010H
$LN10@UninstallD:

; 2250 : 		}
; 2251 : 
; 2252 : 		if (lw == IDC_SYSTEM_RESTORE)

  00170	b9 f3 03 00 00	 mov	 ecx, 1011		; 000003f3H
  00175	66 3b c1	 cmp	 ax, cx
  00178	75 21		 jne	 SHORT $LN13@UninstallD

; 2253 : 		{
; 2254 : 			bSystemRestore = IsButtonChecked (GetDlgItem (hwndDlg, IDC_SYSTEM_RESTORE));

  0017a	51		 push	 ecx
  0017b	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _IsButtonChecked
  0018a	a3 00 00 00 00	 mov	 DWORD PTR _bSystemRestore, eax
  0018f	83 c4 04	 add	 esp, 4

; 2255 : 			return 1;

  00192	b8 01 00 00 00	 mov	 eax, 1

; 2283 : 	}
; 2284 : 
; 2285 : 	return 0;
; 2286 : }

  00197	5d		 pop	 ebp
  00198	c2 10 00	 ret	 16			; 00000010H
$LN13@UninstallD:

; 2256 : 		}
; 2257 : 
; 2258 : 		if (lw == IDCANCEL)

  0019b	66 83 f8 02	 cmp	 ax, 2
  0019f	0f 85 86 00 00
	00		 jne	 $LN8@UninstallD

; 2259 : 		{
; 2260 : 			PostMessage (hwndDlg, WM_CLOSE, 0, 0);

  001a5	6a 00		 push	 0
  001a7	6a 00		 push	 0
  001a9	6a 10		 push	 16			; 00000010H
  001ab	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
  001b4	b8 01 00 00 00	 mov	 eax, 1

; 2283 : 	}
; 2284 : 
; 2285 : 	return 0;
; 2286 : }

  001b9	5d		 pop	 ebp
  001ba	c2 10 00	 ret	 16			; 00000010H
$LN20@UninstallD:

; 2196 : 	WORD lw = LOWORD (wParam);
; 2197 : 
; 2198 : 	switch (msg)

  001bd	3d 12 01 00 00	 cmp	 eax, 274		; 00000112H
  001c2	74 38		 je	 SHORT $LN7@UninstallD
  001c4	3d 92 81 00 00	 cmp	 eax, 33170		; 00008192H
  001c9	75 60		 jne	 SHORT $LN8@UninstallD

; 2261 : 			return 1;
; 2262 : 		}
; 2263 : 
; 2264 : 		return 0;
; 2265 : 
; 2266 : 	case GST_APPMSG_UNINSTALL_SUCCESS:
; 2267 : 		SetWindowTextW (GetDlgItem ((HWND) hwndDlg, IDC_UNINSTALL), GetString ("FINALIZE"));

  001cb	68 00 00 00 00	 push	 OFFSET ??_C@_08MFKGCNCO@FINALIZE?$AA@
  001d0	e8 00 00 00 00	 call	 _GetString
  001d5	83 c4 04	 add	 esp, 4
  001d8	50		 push	 eax
  001d9	68 f7 03 00 00	 push	 1015			; 000003f7H
  001de	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001e7	50		 push	 eax
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 2268 : 		NormalCursor ();

  001ee	e8 00 00 00 00	 call	 _NormalCursor

; 2269 : 		return 1;

  001f3	b8 01 00 00 00	 mov	 eax, 1

; 2283 : 	}
; 2284 : 
; 2285 : 	return 0;
; 2286 : }

  001f8	5d		 pop	 ebp
  001f9	c2 10 00	 ret	 16			; 00000010H
$LN7@UninstallD:

; 2223 : 
; 2224 : 	case WM_SYSCOMMAND:
; 2225 : 		if (lw == IDC_ABOUT)

  001fc	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00201	66 39 45 10	 cmp	 WORD PTR _wParam$[ebp], ax
  00205	75 24		 jne	 SHORT $LN8@UninstallD

; 2226 : 		{
; 2227 : 			DialogBoxW (hInst, MAKEINTRESOURCEW (IDD_ABOUT_DLG), hwndDlg, (DLGPROC) AboutDlgProc);

  00207	6a 00		 push	 0
  00209	68 00 00 00 00	 push	 OFFSET _AboutDlgProc@16
  0020e	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00211	68 fc 01 00 00	 push	 508			; 000001fcH
  00216	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20
$LN21@UninstallD:

; 2228 : 			return 1;

  00222	b8 01 00 00 00	 mov	 eax, 1

; 2283 : 	}
; 2284 : 
; 2285 : 	return 0;
; 2286 : }

  00227	5d		 pop	 ebp
  00228	c2 10 00	 ret	 16			; 00000010H
$LN8@UninstallD:

; 2229 : 		}
; 2230 : 		return 0;

  0022b	33 c0		 xor	 eax, eax

; 2283 : 	}
; 2284 : 
; 2285 : 	return 0;
; 2286 : }

  0022d	5d		 pop	 ebp
  0022e	c2 10 00	 ret	 16			; 00000010H
?UninstallDlgProc@@YGHPAUHWND__@@IIJ@Z ENDP		; UninstallDlgProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat, COMDAT
; _this$ = ecx

; 270  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==, COMDAT
; _this$ = ecx

; 220  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 221  : 		_Compat(_Right);
; 222  : 		return (_Ptr == _Right._Ptr);
; 223  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 209  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 210  : 		_Compat(_Right);
; 211  : 		return (_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 212  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 68   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 69   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 70   : 		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
; 71   : 		if (_Mycont == 0
; 72   : 			|| _Ptr == nullptr_t{}
; 73   : 			|| _Unfancy(_Ptr) < _Contptr
; 74   : 			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))
; 75   : 			{	// report error
; 76   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 77   : 			_SCL_SECURE_OUT_OF_RANGE;
; 78   : 			}
; 79   : 
; 80   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 81   : 		_SCL_SECURE_VALIDATE(_Ptr != nullptr_t{});
; 82   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 83   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 84   : 		const auto _Contptr = _Mycont->_Myptr();
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(_Contptr <= _Unfancy(_Ptr) && _Unfancy(_Ptr) < _Contptr + _Mycont->_Mysize);
; 86   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 87   : 
; 88   : 		_Analysis_assume_(_Ptr != nullptr_t{});
; 89   : 
; 90   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 91   : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 49   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 50   : 		this->_Adopt(_Pstring);
; 51   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2449 : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2450 : 	return (_STD move(_Left.append(1, _Right)));

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00007	56		 push	 esi
  00008	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	6a 01		 push	 1
  00014	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00019	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b ce		 mov	 ecx, esi
  0001e	50		 push	 eax
  0001f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00026	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002d	c6 06 00	 mov	 BYTE PTR [esi], 0
  00030	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 2451 : 	}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT ?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_finalize$ = 12						; size = 4
?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z PROC		; SetSystemRestorePoint, COMDAT

; 1585 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1586 : 	static RESTOREPOINTINFO RestPtInfo;
; 1587 : 	static STATEMGRSTATUS SMgrStatus;
; 1588 : 	static BOOL failed = FALSE;
; 1589 : 	static BOOL (__stdcall *_SRSetRestorePoint)(PRESTOREPOINTINFO, PSTATEMGRSTATUS);
; 1590 : 	
; 1591 : 	if (!SystemRestoreDll) return;

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemRestoreDll, 0
  0000a	74 33		 je	 SHORT $LN8@SetSystemR

; 1592 : 
; 1593 : 	_SRSetRestorePoint = (BOOL (__stdcall *)(PRESTOREPOINTINFO, PSTATEMGRSTATUS))GetProcAddress (SystemRestoreDll,"SRSetRestorePointA");

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemRestoreDll
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BOLGBJDG@SRSetRestorePointA?$AA@
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0001d	8b c8		 mov	 ecx, eax
  0001f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?_SRSetRestorePoint@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4P6GHPAU_RESTOREPTINFOA@@PAU_SMGRSTATUS@@@ZA, ecx

; 1594 : 	if (_SRSetRestorePoint == 0)

  00025	85 c9		 test	 ecx, ecx
  00027	75 18		 jne	 SHORT $LN3@SetSystemR

; 1595 : 	{
; 1596 : 		FreeLibrary (SystemRestoreDll);

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemRestoreDll
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 1597 : 		SystemRestoreDll = 0;

  00035	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SystemRestoreDll, 0
$LN8@SetSystemR:

; 1625 : 		}
; 1626 : 	}
; 1627 : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN3@SetSystemR:

; 1598 : 		return;
; 1599 : 	}
; 1600 : 
; 1601 : 	if (!finalize)

  00041	83 7d 0c 00	 cmp	 DWORD PTR _finalize$[ebp], 0
  00045	0f 85 96 00 00
	00		 jne	 $LN4@SetSystemR

; 1602 : 	{
; 1603 : 		StatusMessage (hwndDlg, "CREATING_SYS_RESTORE");

  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DPJDLMKG@CREATING_SYS_RESTORE?$AA@
  00050	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00053	e8 00 00 00 00	 call	 _StatusMessage

; 1604 : 
; 1605 : 		RestPtInfo.dwEventType = BEGIN_SYSTEM_CHANGE;
; 1606 : 		RestPtInfo.dwRestorePtType = bUninstall ? APPLICATION_UNINSTALL : APPLICATION_INSTALL | DEVICE_DRIVER_INSTALL;

  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bUninstall@@3HA ; bUninstall
  0005e	83 c4 08	 add	 esp, 8
  00061	85 c9		 test	 ecx, ecx
  00063	c7 05 00 00 00
	00 64 00 00 00	 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A, 100 ; 00000064H
  0006d	ba 01 00 00 00	 mov	 edx, 1
  00072	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00077	0f 45 c2	 cmovne	 eax, edx
  0007a	0f 57 c0	 xorps	 xmm0, xmm0
  0007d	a3 04 00 00 00	 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+4, eax

; 1607 : 		RestPtInfo.llSequenceNumber = 0;
; 1608 : 		strcpy (RestPtInfo.szDescription, bUninstall ? "GostCrypt uninstallation" : "GostCrypt installation");

  00082	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@GJGJKNIO@GostCrypt?5uninstallation?$AA@
  00087	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BH@GKFFIALD@GostCrypt?5installation?$AA@
  0008c	66 0f 13 05 08
	00 00 00	 movlpd	 QWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+8, xmm0
  00094	0f 44 d0	 cmove	 edx, eax
  00097	b9 10 00 00 00	 mov	 ecx, OFFSET ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+16
  0009c	2b ca		 sub	 ecx, edx
  0009e	66 90		 npad	 2
$LL10@SetSystemR:
  000a0	8a 02		 mov	 al, BYTE PTR [edx]
  000a2	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000a5	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
  000a9	84 c0		 test	 al, al
  000ab	75 f3		 jne	 SHORT $LL10@SetSystemR

; 1609 : 
; 1610 : 		if(!_SRSetRestorePoint (&RestPtInfo, &SMgrStatus)) 

  000ad	68 00 00 00 00	 push	 OFFSET ?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A
  000b2	68 00 00 00 00	 push	 OFFSET ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR ?_SRSetRestorePoint@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4P6GHPAU_RESTOREPTINFOA@@PAU_SMGRSTATUS@@@ZA
  000bd	85 c0		 test	 eax, eax
  000bf	0f 85 7a ff ff
	ff		 jne	 $LN8@SetSystemR

; 1611 : 		{
; 1612 : 			StatusMessage (hwndDlg, "FAILED_SYS_RESTORE");

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EKOFOABK@FAILED_SYS_RESTORE?$AA@
  000ca	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  000cd	e8 00 00 00 00	 call	 _StatusMessage
  000d2	83 c4 08	 add	 esp, 8

; 1613 : 			failed = TRUE;

  000d5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?failed@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4HA, 1

; 1625 : 		}
; 1626 : 	}
; 1627 : }

  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
$LN4@SetSystemR:

; 1614 : 		}
; 1615 : 	}
; 1616 : 
; 1617 : 	else if (!failed)

  000e1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?failed@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4HA, 0
  000e8	0f 85 51 ff ff
	ff		 jne	 $LN8@SetSystemR

; 1618 : 	{
; 1619 : 		RestPtInfo.dwEventType = END_SYSTEM_CHANGE;
; 1620 : 		RestPtInfo.llSequenceNumber = SMgrStatus.llSequenceNumber;

  000ee	a1 04 00 00 00	 mov	 eax, DWORD PTR ?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A+4

; 1621 : 
; 1622 : 		if(!_SRSetRestorePoint(&RestPtInfo, &SMgrStatus)) 

  000f3	68 00 00 00 00	 push	 OFFSET ?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A
  000f8	a3 08 00 00 00	 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+8, eax
  000fd	a1 08 00 00 00	 mov	 eax, DWORD PTR ?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A+8
  00102	68 00 00 00 00	 push	 OFFSET ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A
  00107	c7 05 00 00 00
	00 65 00 00 00	 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A, 101 ; 00000065H
  00111	a3 0c 00 00 00	 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+12, eax
  00116	ff d1		 call	 ecx
  00118	85 c0		 test	 eax, eax
  0011a	0f 85 1f ff ff
	ff		 jne	 $LN8@SetSystemR

; 1623 : 		{
; 1624 : 			StatusMessage (hwndDlg, "FAILED_SYS_RESTORE");

  00120	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _finalize$[ebp], OFFSET ??_C@_0BD@EKOFOABK@FAILED_SYS_RESTORE?$AA@

; 1625 : 		}
; 1626 : 	}
; 1627 : }

  00127	5d		 pop	 ebp

; 1623 : 		{
; 1624 : 			StatusMessage (hwndDlg, "FAILED_SYS_RESTORE");

  00128	e9 00 00 00 00	 jmp	 _StatusMessage
?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z ENDP		; SetSystemRestorePoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT ?DoApplicationDataUninstall@@YAHPAUHWND__@@@Z
_TEXT	SEGMENT
_st$1 = -580						; size = 56
_st$2 = -580						; size = 56
_st$3 = -580						; size = 56
_st$4 = -580						; size = 56
_st$5 = -580						; size = 56
_st$6 = -580						; size = 56
_path$ = -524						; size = 260
_path2$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
?DoApplicationDataUninstall@@YAHPAUHWND__@@@Z PROC	; DoApplicationDataUninstall, COMDAT

; 847  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 02 00
	00		 sub	 esp, 580		; 00000244H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]

; 848  : 	char path[MAX_PATH];
; 849  : 	char path2[MAX_PATH];
; 850  : 	BOOL bOK = TRUE;
; 851  : 
; 852  : 	StatusMessage (hwndDlg, "REMOVING_APPDATA");

  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EKLCNMAG@REMOVING_APPDATA?$AA@
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _StatusMessage
  00022	83 c4 08	 add	 esp, 8

; 853  : 
; 854  : 	SHGetFolderPath (NULL, CSIDL_APPDATA, NULL, 0, path);

  00025	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	6a 1a		 push	 26			; 0000001aH
  00032	6a 00		 push	 0
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetFolderPathA@20

; 855  : 	strcat (path, "\\GostCrypt\\");

  0003a	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00040	49		 dec	 ecx
$LL46@DoApplicat:
  00041	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00044	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00047	84 c0		 test	 al, al
  00049	75 f6		 jne	 SHORT $LL46@DoApplicat
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0M@GKPCCOCO@?2GostCrypt?2?$AA@
  00050	89 01		 mov	 DWORD PTR [ecx], eax
  00052	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0M@GKPCCOCO@?2GostCrypt?2?$AA@+4
  00057	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0005a	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0M@GKPCCOCO@?2GostCrypt?2?$AA@+8
  0005f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 856  : 
; 857  : 	// Delete favorite volumes file
; 858  : 	sprintf (path2, "%s%s", path, GST_APPD_FILENAME_FAVORITE_VOLUMES);

  00062	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@
  0006d	50		 push	 eax
  0006e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _sprintf
  0007f	83 c4 10	 add	 esp, 16			; 00000010H

; 859  : 	RemoveMessage (hwndDlg, path2);

  00082	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00089	75 15		 jne	 SHORT $LN5@DoApplicat
  0008b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  00091	50		 push	 eax
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 _StatusMessageParam
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@DoApplicat:

; 860  : 	StatDeleteFile (path2);

  000a0	57		 push	 edi
  000a1	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _st$6[ebp]
  000a7	50		 push	 eax
  000a8	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 __stat64
  000b4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__DeleteFileA@4
  000ba	83 c4 08	 add	 esp, 8
  000bd	85 c0		 test	 eax, eax
  000bf	75 09		 jne	 SHORT $LN8@DoApplicat
  000c1	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  000c7	50		 push	 eax
  000c8	ff d7		 call	 edi
$LN8@DoApplicat:

; 861  : 
; 862  : 	// Delete keyfile defaults
; 863  : 	sprintf (path2, "%s%s", path, GST_APPD_FILENAME_DEFAULT_KEYFILES);

  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CEDLNBLM@Default?5Keyfiles?4xml?$AA@
  000cf	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  000d5	50		 push	 eax
  000d6	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _sprintf
  000e7	83 c4 10	 add	 esp, 16			; 00000010H

; 864  : 	RemoveMessage (hwndDlg, path2);

  000ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  000f1	75 15		 jne	 SHORT $LN12@DoApplicat
  000f3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  000f9	50		 push	 eax
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  000ff	56		 push	 esi
  00100	e8 00 00 00 00	 call	 _StatusMessageParam
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@DoApplicat:

; 865  : 	StatDeleteFile (path2);

  00108	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _st$5[ebp]
  0010e	50		 push	 eax
  0010f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 __stat64
  0011b	83 c4 08	 add	 esp, 8
  0011e	85 c0		 test	 eax, eax
  00120	75 09		 jne	 SHORT $LN15@DoApplicat
  00122	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  00128	50		 push	 eax
  00129	ff d7		 call	 edi
$LN15@DoApplicat:

; 866  : 
; 867  : 	// Delete history file
; 868  : 	sprintf (path2, "%s%s", path, GST_APPD_FILENAME_HISTORY);

  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COMBLGLD@History?4xml?$AA@
  00130	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00136	50		 push	 eax
  00137	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _sprintf
  00148	83 c4 10	 add	 esp, 16			; 00000010H

; 869  : 	RemoveMessage (hwndDlg, path2);

  0014b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00152	75 15		 jne	 SHORT $LN19@DoApplicat
  00154	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  0015a	50		 push	 eax
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00160	56		 push	 esi
  00161	e8 00 00 00 00	 call	 _StatusMessageParam
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@DoApplicat:

; 870  : 	StatDeleteFile (path2);

  00169	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _st$4[ebp]
  0016f	50		 push	 eax
  00170	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 __stat64
  0017c	83 c4 08	 add	 esp, 8
  0017f	85 c0		 test	 eax, eax
  00181	75 09		 jne	 SHORT $LN22@DoApplicat
  00183	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  00189	50		 push	 eax
  0018a	ff d7		 call	 edi
$LN22@DoApplicat:

; 871  : 	
; 872  : 	// Delete configuration file
; 873  : 	sprintf (path2, "%s%s", path, GST_APPD_FILENAME_CONFIGURATION);

  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FNANDAA@Configuration?4xml?$AA@
  00191	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00197	50		 push	 eax
  00198	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 _sprintf
  001a9	83 c4 10	 add	 esp, 16			; 00000010H

; 874  : 	RemoveMessage (hwndDlg, path2);

  001ac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  001b3	75 15		 jne	 SHORT $LN26@DoApplicat
  001b5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  001bb	50		 push	 eax
  001bc	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  001c1	56		 push	 esi
  001c2	e8 00 00 00 00	 call	 _StatusMessageParam
  001c7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@DoApplicat:

; 875  : 	StatDeleteFile (path2);

  001ca	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _st$3[ebp]
  001d0	50		 push	 eax
  001d1	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 __stat64
  001dd	83 c4 08	 add	 esp, 8
  001e0	85 c0		 test	 eax, eax
  001e2	75 09		 jne	 SHORT $LN29@DoApplicat
  001e4	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  001ea	50		 push	 eax
  001eb	ff d7		 call	 edi
$LN29@DoApplicat:

; 876  : 
; 877  : 	// Delete system encryption configuration file
; 878  : 	sprintf (path2, "%s%s", path, GST_APPD_FILENAME_SYSTEM_ENCRYPTION);

  001ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@
  001f2	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  001f8	50		 push	 eax
  001f9	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  001ff	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00204	50		 push	 eax
  00205	e8 00 00 00 00	 call	 _sprintf
  0020a	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 	RemoveMessage (hwndDlg, path2);

  0020d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00214	75 15		 jne	 SHORT $LN33@DoApplicat
  00216	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  0021c	50		 push	 eax
  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00222	56		 push	 esi
  00223	e8 00 00 00 00	 call	 _StatusMessageParam
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@DoApplicat:

; 880  : 	StatDeleteFile (path2);

  0022b	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _st$2[ebp]
  00231	50		 push	 eax
  00232	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 __stat64
  0023e	83 c4 08	 add	 esp, 8
  00241	85 c0		 test	 eax, eax
  00243	75 09		 jne	 SHORT $LN36@DoApplicat
  00245	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path2$[ebp]
  0024b	50		 push	 eax
  0024c	ff d7		 call	 edi
$LN36@DoApplicat:

; 881  : 
; 882  : 	SHGetFolderPath (NULL, CSIDL_APPDATA, NULL, 0, path);

  0024e	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00254	50		 push	 eax
  00255	6a 00		 push	 0
  00257	6a 00		 push	 0
  00259	6a 1a		 push	 26			; 0000001aH
  0025b	6a 00		 push	 0
  0025d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetFolderPathA@20

; 883  : 	strcat (path, "\\GostCrypt");

  00263	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00269	49		 dec	 ecx
  0026a	5f		 pop	 edi
  0026b	0f 1f 44 00 00	 npad	 5
$LL47@DoApplicat:
  00270	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00273	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00276	84 c0		 test	 al, al
  00278	75 f6		 jne	 SHORT $LL47@DoApplicat

; 884  : 	RemoveMessage (hwndDlg, path);

  0027a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00281	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@
  00286	89 01		 mov	 DWORD PTR [ecx], eax
  00288	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@+4
  0028d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00290	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@+8
  00296	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  0029a	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@+10
  0029f	88 41 0a	 mov	 BYTE PTR [ecx+10], al
  002a2	75 15		 jne	 SHORT $LN40@DoApplicat
  002a4	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  002aa	50		 push	 eax
  002ab	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  002b0	56		 push	 esi
  002b1	e8 00 00 00 00	 call	 _StatusMessageParam
  002b6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN40@DoApplicat:

; 885  : 	if (!StatRemoveDirectory (path))

  002b9	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _st$1[ebp]
  002bf	50		 push	 eax
  002c0	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  002c6	50		 push	 eax
  002c7	e8 00 00 00 00	 call	 __stat64
  002cc	83 c4 08	 add	 esp, 8
  002cf	85 c0		 test	 eax, eax
  002d1	75 2b		 jne	 SHORT $LN49@DoApplicat
  002d3	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  002d9	50		 push	 eax
  002da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RemoveDirectoryA@4
  002e0	85 c0		 test	 eax, eax
  002e2	75 1a		 jne	 SHORT $LN49@DoApplicat

; 886  : 	{
; 887  : 		handleWin32Error (hwndDlg);

  002e4	56		 push	 esi
  002e5	e8 00 00 00 00	 call	 _handleWin32Error
  002ea	83 c4 04	 add	 esp, 4

; 888  : 		bOK = FALSE;
; 889  : 	}
; 890  : 
; 891  : 	return bOK;

  002ed	33 c0		 xor	 eax, eax
  002ef	5e		 pop	 esi

; 892  : }

  002f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f3	33 cd		 xor	 ecx, ebp
  002f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002fa	8b e5		 mov	 esp, ebp
  002fc	5d		 pop	 ebp
  002fd	c3		 ret	 0
$LN49@DoApplicat:
  002fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00301	b8 01 00 00 00	 mov	 eax, 1
  00306	33 cd		 xor	 ecx, ebp
  00308	5e		 pop	 esi
  00309	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030e	8b e5		 mov	 esp, ebp
  00310	5d		 pop	 ebp
  00311	c3		 ret	 0
?DoApplicationDataUninstall@@YAHPAUHWND__@@@Z ENDP	; DoApplicationDataUninstall
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_filePath$ = 8						; size = 4
?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IsFileInUse, COMDAT

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 388  : 	HANDLE useTestHandle = CreateFile (filePath.c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

  00003	8b 45 08	 mov	 eax, DWORD PTR _filePath$[ebp]
  00006	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0000a	72 02		 jb	 SHORT $LN20@IsFileInUs
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN20@IsFileInUs:
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	6a 03		 push	 3
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28

; 389  : 
; 390  : 	if (useTestHandle != INVALID_HANDLE_VALUE)

  00024	83 f8 ff	 cmp	 eax, -1
  00027	74 0b		 je	 SHORT $LN2@IsFileInUs

; 391  : 		CloseHandle (useTestHandle);

  00029	50		 push	 eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN4@IsFileInUs:

; 394  : 
; 395  : 	return FALSE;

  00030	33 c0		 xor	 eax, eax

; 396  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN2@IsFileInUs:

; 392  : 	else if (GetLastError() == ERROR_SHARING_VIOLATION)

  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0003a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0003d	75 f1		 jne	 SHORT $LN4@IsFileInUs

; 393  : 		return TRUE;

  0003f	b8 01 00 00 00	 mov	 eax, 1

; 396  : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IsFileInUse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\combaseapi.h
;	COMDAT ??$IID_PPV_ARGS_Helper@UIPropertyStore@@@@YAPAPAXPAPAUIPropertyStore@@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
??$IID_PPV_ARGS_Helper@UIPropertyStore@@@@YAPAPAXPAPAUIPropertyStore@@@Z PROC ; IID_PPV_ARGS_Helper<IPropertyStore>, COMDAT

; 227  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 228  : #pragma prefast(suppress: 6269, "Tool issue with unused static_cast")
; 229  :         static_cast<IUnknown*>(*pp);    // make sure everyone derives from IUnknown
; 230  :         return reinterpret_cast<void**>(pp);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pp$[ebp]

; 231  :     }    

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$IID_PPV_ARGS_Helper@UIPropertyStore@@@@YAPAPAXPAPAUIPropertyStore@@@Z ENDP ; IID_PPV_ARGS_Helper<IPropertyStore>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _UpgradeBootLoader
_TEXT	SEGMENT
_e$2 = -1508						; size = 4
_hwndDlg$GSCopy$ = -1504				; size = 4
_bootEnc$3 = -1500					; size = 1480
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_hwndDlg$ = 8						; size = 4
_UpgradeBootLoader PROC					; COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_UpgradeBootLoader
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 05 00
	00		 sub	 esp, 1496		; 000005d8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1280 : 	if (!SystemEncryptionUpdate)

  00031	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  00038	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]
  0003b	89 b5 20 fa ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$[ebp], esi
  00041	0f 84 8c 00 00
	00		 je	 $LN16@UpgradeBoo

; 1281 : 		return TRUE;
; 1282 : 
; 1283 : 	try
; 1284 : 	{
; 1285 : 		BootEncryption bootEnc (hwndDlg);

  00047	56		 push	 esi
  00048	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$3[ebp]
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00055	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 1286 : 		if (bootEnc.GetInstalledBootLoaderVersion() < VERSION_NUM)

  0005a	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$3[ebp]
  00060	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00064	e8 00 00 00 00	 call	 ?GetInstalledBootLoaderVersion@BootEncryption@GostCrypt@@QAEGXZ ; GostCrypt::BootEncryption::GetInstalledBootLoaderVersion
  00069	0f b7 c0	 movzx	 eax, ax
  0006c	b9 00 13 00 00	 mov	 ecx, 4864		; 00001300H
  00071	66 3b c1	 cmp	 ax, cx
  00074	73 52		 jae	 SHORT $LN5@UpgradeBoo

; 1287 : 		{
; 1288 : 			StatusMessage (hwndDlg, "INSTALLER_UPDATING_BOOT_LOADER");

  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LJKCMEDG@INSTALLER_UPDATING_BOOT_LOADER?$AA@
  0007b	56		 push	 esi
  0007c	e8 00 00 00 00	 call	 _StatusMessage
  00081	83 c4 08	 add	 esp, 8

; 1289 : 
; 1290 : 			bootEnc.InstallBootLoader (true);

  00084	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$3[ebp]
  0008a	6a 00		 push	 0
  0008c	6a 01		 push	 1
  0008e	e8 00 00 00 00	 call	 ?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z ; GostCrypt::BootEncryption::InstallBootLoader

; 1291 : 
; 1292 : 			if (bootEnc.GetInstalledBootLoaderVersion() <= GST_RESCUE_DISK_UPGRADE_NOTICE_MAX_VERSION)

  00093	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$3[ebp]
  00099	e8 00 00 00 00	 call	 ?GetInstalledBootLoaderVersion@BootEncryption@GostCrypt@@QAEGXZ ; GostCrypt::BootEncryption::GetInstalledBootLoaderVersion
  0009e	0f b7 c0	 movzx	 eax, ax
  000a1	b9 0a 06 00 00	 mov	 ecx, 1546		; 0000060aH
  000a6	66 3b c1	 cmp	 ax, cx
  000a9	77 1d		 ja	 SHORT $LN5@UpgradeBoo

; 1293 : 				Info (IsHiddenOSRunning() ? "BOOT_LOADER_UPGRADE_OK_HIDDEN_OS" : "BOOT_LOADER_UPGRADE_OK");

  000ab	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  000b0	85 c0		 test	 eax, eax
  000b2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BH@FCKJHOEL@BOOT_LOADER_UPGRADE_OK?$AA@
  000b7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CB@JHJCAANH@BOOT_LOADER_UPGRADE_OK_HIDDEN_OS@
  000bc	0f 44 ca	 cmove	 ecx, edx
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 _Info
  000c5	83 c4 04	 add	 esp, 4
$LN5@UpgradeBoo:

; 1294 : 		}
; 1295 : 		return TRUE;

  000c8	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$3[ebp]
  000ce	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
$LN16@UpgradeBoo:
  000d3	b8 01 00 00 00	 mov	 eax, 1
  000d8	eb 25		 jmp	 SHORT $LN1@UpgradeBoo
__catch$_UpgradeBootLoader$0:

; 1296 : 	}
; 1297 : 	catch (Exception &e)
; 1298 : 	{
; 1299 : 		e.Show (hwndDlg);

  000da	8b 8d 1c fa ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  000e0	ff b5 20 fa ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  000e6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e8	ff 10		 call	 DWORD PTR [eax]

; 1300 : 	}

  000ea	b8 00 00 00 00	 mov	 eax, $LN14@UpgradeBoo
  000ef	c3		 ret	 0
$LN14@UpgradeBoo:

; 1302 : 
; 1303 : 	Error ("BOOT_LOADER_UPGRADE_FAILED");

  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LKLMNDDM@BOOT_LOADER_UPGRADE_FAILED?$AA@
  000f5	e8 00 00 00 00	 call	 _Error
  000fa	83 c4 04	 add	 esp, 4

; 1304 : 	return FALSE;

  000fd	33 c0		 xor	 eax, eax
$LN1@UpgradeBoo:

; 1305 : }

  000ff	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00102	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00109	59		 pop	 ecx
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00110	33 cd		 xor	 ecx, ebp
  00112	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
__catch$_UpgradeBootLoader$1:

; 1301 : 	catch (...) { }

  0011b	b8 00 00 00 00	 mov	 eax, $LN14@UpgradeBoo
  00120	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_UpgradeBootLoader$3:
  00000	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__ehhandler$_UpgradeBootLoader:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 18 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1512]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_UpgradeBootLoader
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_UpgradeBootLoader ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _SetInstallationPath
_TEXT	SEGMENT
_itemList$ = -1644					; size = 4
_size$1 = -1640						; size = 4
_hkey$ = -1636						; size = 4
$T2 = -1632						; size = 24
_s$3 = -1608						; size = 24
_mp$4 = -1584						; size = 260
_rv$5 = -1324						; size = 1040
_path$ = -284						; size = 280
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_SetInstallationPath PROC				; COMDAT

; 2042 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 06 00
	00		 sub	 esp, 1644		; 0000066cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]

; 2043 : 	HKEY hkey;
; 2044 : 	BOOL bInstallPathDetermined = FALSE;

  00018	33 f6		 xor	 esi, esi

; 2045 : 	char path[MAX_PATH+20];
; 2046 : 	ITEMIDLIST *itemList;
; 2047 : 
; 2048 : 	memset (InstallationPath, 0, sizeof (InstallationPath));

  0001a	68 04 01 00 00	 push	 260			; 00000104H
  0001f	56		 push	 esi
  00020	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00025	e8 00 00 00 00	 call	 _memset
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2049 : 
; 2050 : 	// Determine if GostCrypt is already installed and try to determine its "Program Files" location
; 2051 : 	if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\GostCrypt", 0, KEY_READ, &hkey) == ERROR_SUCCESS)

  0002d	8d 85 9c f9 ff
	ff		 lea	 eax, DWORD PTR _hkey$[ebp]
  00033	50		 push	 eax
  00034	68 19 00 02 00	 push	 131097			; 00020019H
  00039	56		 push	 esi
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@MNMIDBOE@Software?2Microsoft?2Windows?2Curre@
  0003f	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0004a	85 c0		 test	 eax, eax
  0004c	0f 85 41 02 00
	00		 jne	 $LN9@SetInstall

; 2052 : 	{
; 2053 : 		/* Default 'UninstallString' registry strings written by past versions of GostCrypt:
; 2054 : 		------------------------------------------------------------------------------------
; 2055 : 		1.0		C:\WINDOWS\GostCrypt Setup.exe /u			[optional]
; 2056 : 		1.0a	C:\WINDOWS\GostCrypt Setup.exe /u			[optional]
; 2057 : 		2.0		C:\WINDOWS\GostCrypt Setup.exe /u			[optional]
; 2058 : 		2.1		C:\WINDOWS\GostCrypt Setup.exe /u			[optional]
; 2059 : 		2.1a	C:\WINDOWS\GostCrypt Setup.exe /u			[optional]
; 2060 : 		3.0		C:\WINDOWS\GostCrypt Setup.exe /u			[optional]
; 2061 : 		3.0a	C:\WINDOWS\GostCrypt Setup.exe /u			[optional]
; 2062 : 		3.1		The UninstallString was NEVER written (fortunately, 3.1a replaced 3.1 after 2 weeks)
; 2063 : 		3.1a	C:\WINDOWS\GostCrypt Setup.exe /u
; 2064 : 		4.0		C:\WINDOWS\GostCrypt Setup.exe /u C:\Program Files\GostCrypt
; 2065 : 		4.1		C:\WINDOWS\GostCrypt Setup.exe /u C:\Program Files\GostCrypt
; 2066 : 		4.2		C:\WINDOWS\GostCrypt Setup.exe /u C:\Program Files\GostCrypt
; 2067 : 		4.2a	C:\WINDOWS\GostCrypt Setup.exe /u C:\Program Files\GostCrypt
; 2068 : 		4.3		"C:\Program Files\GostCrypt\GostCrypt Setup.exe" /u C:\Program Files\GostCrypt\
; 2069 : 		4.3a	"C:\Program Files\GostCrypt\GostCrypt Setup.exe" /u C:\Program Files\GostCrypt\
; 2070 : 		5.0+	"C:\Program Files\GostCrypt\GostCrypt Setup.exe" /u
; 2071 : 
; 2072 : 		Note: In versions 1.0-3.0a the user was able to choose whether to install the uninstaller.
; 2073 : 			  The default was to install it. If it wasn't installed, there was no UninstallString.
; 2074 : 		*/
; 2075 : 
; 2076 : 		char rv[MAX_PATH*4];
; 2077 : 		DWORD size = sizeof (rv);
; 2078 : 		if (RegQueryValueEx (hkey, "UninstallString", 0, 0, (LPBYTE) &rv, &size) == ERROR_SUCCESS && strrchr (rv, '/'))

  00052	8d 85 98 f9 ff
	ff		 lea	 eax, DWORD PTR _size$1[ebp]
  00058	c7 85 98 f9 ff
	ff 10 04 00 00	 mov	 DWORD PTR _size$1[ebp], 1040 ; 00000410H
  00062	50		 push	 eax
  00063	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _rv$5[ebp]
  00069	50		 push	 eax
  0006a	56		 push	 esi
  0006b	56		 push	 esi
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OJMJCMCH@UninstallString?$AA@
  00071	ff b5 9c f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  0007d	85 c0		 test	 eax, eax
  0007f	0f 85 b3 00 00
	00		 jne	 $LN8@SetInstall
  00085	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _rv$5[ebp]
  0008b	6a 2f		 push	 47			; 0000002fH
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _strrchr
  00093	83 c4 08	 add	 esp, 8
  00096	85 c0		 test	 eax, eax
  00098	0f 84 9a 00 00
	00		 je	 $LN8@SetInstall

; 2079 : 		{
; 2080 : 			size_t len = 0;
; 2081 : 
; 2082 : 			// Cut and paste the location (path) where GostCrypt is installed to InstallationPath
; 2083 : 			if (rv[0] == '"')

  0009e	80 bd d4 fa ff
	ff 22		 cmp	 BYTE PTR _rv$5[ebp], 34	; 00000022H

; 2084 : 			{
; 2085 : 				// 4.3 or later
; 2086 : 
; 2087 : 				len = strrchr (rv, '/') - rv - 2;

  000a5	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _rv$5[ebp]
  000ab	6a 2f		 push	 47			; 0000002fH
  000ad	50		 push	 eax
  000ae	0f 85 1f 01 00
	00		 jne	 $LN4@SetInstall
  000b4	e8 00 00 00 00	 call	 _strrchr
  000b9	8b f0		 mov	 esi, eax
  000bb	b9 fe ff ff ff	 mov	 ecx, -2			; fffffffeH
  000c0	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _rv$5[ebp]
  000c6	2b c8		 sub	 ecx, eax

; 2088 : 				strncpy (InstallationPath, rv + 1, len);

  000c8	8d 85 d5 fa ff
	ff		 lea	 eax, DWORD PTR _rv$5[ebp+1]
  000ce	03 f1		 add	 esi, ecx
  000d0	56		 push	 esi
  000d1	50		 push	 eax
  000d2	68 00 00 00 00	 push	 OFFSET _InstallationPath
  000d7	e8 00 00 00 00	 call	 _strncpy
  000dc	83 c4 14	 add	 esp, 20			; 00000014H

; 2089 : 				InstallationPath [len] = 0;

  000df	81 fe 04 01 00
	00		 cmp	 esi, 260		; 00000104H
  000e5	0f 83 30 03 00
	00		 jae	 $LN190@SetInstall

; 2090 : 				bInstallPathDetermined = TRUE;
; 2091 : 
; 2092 : 				if (InstallationPath [strlen (InstallationPath) - 1] != '\\')

  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET _InstallationPath
  000f0	c6 86 00 00 00
	00 00		 mov	 BYTE PTR _InstallationPath[esi], 0
  000f7	be 01 00 00 00	 mov	 esi, 1
  000fc	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000ff	90		 npad	 1
$LL181@SetInstall:
  00100	8a 01		 mov	 al, BYTE PTR [ecx]
  00102	41		 inc	 ecx
  00103	84 c0		 test	 al, al
  00105	75 f9		 jne	 SHORT $LL181@SetInstall
  00107	2b ca		 sub	 ecx, edx
  00109	80 b9 ff ff ff
	ff 5c		 cmp	 BYTE PTR _InstallationPath[ecx-1], 92 ; 0000005cH
  00110	74 26		 je	 SHORT $LN8@SetInstall

; 2093 : 				{
; 2094 : 					len = strrchr (InstallationPath, '\\') - InstallationPath;

  00112	6a 5c		 push	 92			; 0000005cH
  00114	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00119	e8 00 00 00 00	 call	 _strrchr
  0011e	2d 00 00 00 00	 sub	 eax, OFFSET _InstallationPath
  00123	83 c4 08	 add	 esp, 8

; 2095 : 					InstallationPath [len] = 0;

  00126	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  0012b	0f 83 ea 02 00
	00		 jae	 $LN190@SetInstall
  00131	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _InstallationPath[eax], 0
$LN8@SetInstall:

; 2128 : 				}
; 2129 : 			}
; 2130 : 
; 2131 : 		}
; 2132 : 		RegCloseKey (hkey);

  00138	ff b5 9c f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00144	85 f6		 test	 esi, esi

; 2133 : 	}
; 2134 : 
; 2135 : 	if (bInstallPathDetermined)

  00146	0f 84 47 01 00
	00		 je	 $LN9@SetInstall

; 2136 : 	{
; 2137 : 		char mp[MAX_PATH];
; 2138 : 
; 2139 : 		// Determine whether we were launched from the folder where GostCrypt is installed
; 2140 : 		GetModuleFileName (NULL, mp, sizeof (mp));

  0014c	68 04 01 00 00	 push	 260			; 00000104H
  00151	8d 85 d0 f9 ff
	ff		 lea	 eax, DWORD PTR _mp$4[ebp]
  00157	50		 push	 eax
  00158	6a 00		 push	 0
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 2141 : 		if (strncmp (InstallationPath, mp, min (strlen(InstallationPath), strlen(mp))) == 0)

  00160	ba 00 00 00 00	 mov	 edx, OFFSET _InstallationPath
  00165	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL184@SetInstall:
  00168	8a 02		 mov	 al, BYTE PTR [edx]
  0016a	42		 inc	 edx
  0016b	84 c0		 test	 al, al
  0016d	75 f9		 jne	 SHORT $LL184@SetInstall
  0016f	2b d1		 sub	 edx, ecx
  00171	8d 8d d0 f9 ff
	ff		 lea	 ecx, DWORD PTR _mp$4[ebp]
  00177	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0017a	66 0f 1f 44 00
	00		 npad	 6
$LL185@SetInstall:
  00180	8a 01		 mov	 al, BYTE PTR [ecx]
  00182	41		 inc	 ecx
  00183	84 c0		 test	 al, al
  00185	75 f9		 jne	 SHORT $LL185@SetInstall
  00187	2b ce		 sub	 ecx, esi
  00189	8d 85 d0 f9 ff
	ff		 lea	 eax, DWORD PTR _mp$4[ebp]
  0018f	3b d1		 cmp	 edx, ecx
  00191	0f 42 ca	 cmovb	 ecx, edx
  00194	51		 push	 ecx
  00195	50		 push	 eax
  00196	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0019b	e8 00 00 00 00	 call	 _strncmp
  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a3	85 c0		 test	 eax, eax
  001a5	0f 85 2a 02 00
	00		 jne	 $LN10@SetInstall

; 2142 : 		{
; 2143 : 			// We were launched from the folder where GostCrypt is installed
; 2144 : 
; 2145 : 			if (!IsNonInstallMode() && !bDevm)

  001ab	e8 00 00 00 00	 call	 _IsNonInstallMode
  001b0	85 c0		 test	 eax, eax
  001b2	0f 85 1d 02 00
	00		 jne	 $LN10@SetInstall
  001b8	39 05 00 00 00
	00		 cmp	 DWORD PTR _bDevm, eax
  001be	0f 85 11 02 00
	00		 jne	 $LN10@SetInstall

; 2146 : 				bChangeMode = TRUE;

  001c4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bChangeMode@@3HA, 1 ; bChangeMode

; 2147 : 		}
; 2148 : 	}
; 2149 : 	else

  001ce	e9 02 02 00 00	 jmp	 $LN10@SetInstall
$LN4@SetInstall:

; 2096 : 				}
; 2097 : 			}
; 2098 : 			else
; 2099 : 			{
; 2100 : 				// 1.0-4.2a (except 3.1)
; 2101 : 
; 2102 : 				len = strrchr (rv, '/') - rv;

  001d3	e8 00 00 00 00	 call	 _strrchr
  001d8	8b f0		 mov	 esi, eax
  001da	83 c4 08	 add	 esp, 8
  001dd	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _rv$5[ebp]
  001e3	2b f0		 sub	 esi, eax

; 2103 : 				if (rv[len+2] == ' ')

  001e5	80 bc 35 d6 fa
	ff ff 20	 cmp	 BYTE PTR _rv$5[ebp+esi+2], 32 ; 00000020H
  001ed	75 5d		 jne	 SHORT $LN7@SetInstall

; 2104 : 				{
; 2105 : 					// 4.0-4.2a
; 2106 : 
; 2107 : 					strncpy (InstallationPath, rv + len + 3, strlen (rv) - len - 3);

  001ef	8b c8		 mov	 ecx, eax
  001f1	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL182@SetInstall:
  001f4	8a 01		 mov	 al, BYTE PTR [ecx]
  001f6	41		 inc	 ecx
  001f7	84 c0		 test	 al, al
  001f9	75 f9		 jne	 SHORT $LL182@SetInstall
  001fb	2b ca		 sub	 ecx, edx
  001fd	2b ce		 sub	 ecx, esi
  001ff	8d 41 fd	 lea	 eax, DWORD PTR [ecx-3]
  00202	50		 push	 eax
  00203	8d 85 d7 fa ff
	ff		 lea	 eax, DWORD PTR _rv$5[ebp+3]
  00209	03 c6		 add	 eax, esi
  0020b	50		 push	 eax
  0020c	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00211	e8 00 00 00 00	 call	 _strncpy

; 2108 : 					InstallationPath [strlen (rv) - len - 3] = 0;

  00216	8d 8d d4 fa ff
	ff		 lea	 ecx, DWORD PTR _rv$5[ebp]
  0021c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL183@SetInstall:
  00222	8a 01		 mov	 al, BYTE PTR [ecx]
  00224	41		 inc	 ecx
  00225	84 c0		 test	 al, al
  00227	75 f9		 jne	 SHORT $LL183@SetInstall
  00229	2b ca		 sub	 ecx, edx
  0022b	2b ce		 sub	 ecx, esi
  0022d	83 c1 fd	 add	 ecx, -3			; fffffffdH
  00230	81 f9 04 01 00
	00		 cmp	 ecx, 260		; 00000104H
  00236	0f 83 df 01 00
	00		 jae	 $LN190@SetInstall
  0023c	88 81 00 00 00
	00		 mov	 BYTE PTR _InstallationPath[ecx], al

; 2109 : 					bInstallPathDetermined = TRUE;

  00242	be 01 00 00 00	 mov	 esi, 1

; 2110 : 				}
; 2111 : 				else

  00247	e9 ec fe ff ff	 jmp	 $LN8@SetInstall
$LN7@SetInstall:

; 2112 : 				{
; 2113 : 					// 1.0-3.1a (except 3.1)
; 2114 : 
; 2115 : 					// We know that GostCrypt is installed but don't know where. It's not safe to continue installing
; 2116 : 					// over the old version.
; 2117 : 
; 2118 : 					Error ("UNINSTALL_OLD_VERSION_FIRST");

  0024c	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IFDMFKIM@UNINSTALL_OLD_VERSION_FIRST?$AA@
  00251	e8 00 00 00 00	 call	 _Error

; 2119 : 
; 2120 : 					len = strrchr (rv, '/') - rv - 1;

  00256	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _rv$5[ebp]
  0025c	6a 2f		 push	 47			; 0000002fH
  0025e	50		 push	 eax
  0025f	e8 00 00 00 00	 call	 _strrchr
  00264	8b f0		 mov	 esi, eax
  00266	83 c9 ff	 or	 ecx, -1
  00269	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _rv$5[ebp]
  0026f	2b c8		 sub	 ecx, eax
  00271	03 f1		 add	 esi, ecx

; 2121 : 					strncpy (InstallationPath, rv, len);	// Path and filename of the uninstaller

  00273	56		 push	 esi
  00274	50		 push	 eax
  00275	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0027a	e8 00 00 00 00	 call	 _strncpy
  0027f	83 c4 18	 add	 esp, 24			; 00000018H

; 2122 : 					InstallationPath [len] = 0;

  00282	81 fe 04 01 00
	00		 cmp	 esi, 260		; 00000104H
  00288	0f 83 8d 01 00
	00		 jae	 $LN190@SetInstall
  0028e	e9 8d 01 00 00	 jmp	 $LN191@SetInstall
$LN9@SetInstall:

; 2150 : 	{
; 2151 : 		/* TrueCypt is not installed or it wasn't possible to determine where it is installed. */
; 2152 : 
; 2153 : 		// Default "Program Files" path. 
; 2154 : 		SHGetSpecialFolderLocation (hwndDlg, CSIDL_PROGRAM_FILES, &itemList);

  00293	8d 85 94 f9 ff
	ff		 lea	 eax, DWORD PTR _itemList$[ebp]
  00299	50		 push	 eax
  0029a	6a 26		 push	 38			; 00000026H
  0029c	57		 push	 edi
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetSpecialFolderLocation@12

; 2155 : 		SHGetPathFromIDList (itemList, path);

  002a3	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  002a9	50		 push	 eax
  002aa	ff b5 94 f9 ff
	ff		 push	 DWORD PTR _itemList$[ebp]
  002b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetPathFromIDListA@8

; 2156 : 
; 2157 : 		if (Is64BitOs())

  002b6	e8 00 00 00 00	 call	 _Is64BitOs
  002bb	85 c0		 test	 eax, eax
  002bd	0f 84 c2 00 00
	00		 je	 $LN86@SetInstall

; 2158 : 		{
; 2159 : 			// Use a unified default installation path (registry redirection of %ProgramFiles% does not work if the installation path is user-selectable)
; 2160 : 			string s = path;

  002c3	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  002c9	50		 push	 eax
  002ca	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp]
  002d0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 2161 : 			size_t p = s.find (" (x86)");

  002d5	6a 06		 push	 6
  002d7	6a 00		 push	 0
  002d9	68 00 00 00 00	 push	 OFFSET ??_C@_06NOEMODMP@?5?$CIx86?$CJ?$AA@
  002de	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp]
  002e4	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find

; 2162 : 			if (p != string::npos)

  002e9	83 f8 ff	 cmp	 eax, -1
  002ec	74 79		 je	 SHORT $LN15@SetInstall

; 2163 : 			{
; 2164 : 				s = s.substr (0, p);

  002ee	50		 push	 eax
  002ef	6a 00		 push	 0
  002f1	8d 85 a0 f9 ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  002f7	50		 push	 eax
  002f8	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp]
  002fe	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  00303	50		 push	 eax
  00304	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp]
  0030a	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  0030f	8d 8d a0 f9 ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00315	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 2165 : 				if (_access (s.c_str(), 0) != -1)

  0031a	83 bd cc f9 ff
	ff 10		 cmp	 DWORD PTR _s$3[ebp+20], 16 ; 00000010H
  00321	8d 85 b8 f9 ff
	ff		 lea	 eax, DWORD PTR _s$3[ebp]
  00327	6a 00		 push	 0
  00329	0f 43 85 b8 f9
	ff ff		 cmovae	 eax, DWORD PTR _s$3[ebp]
  00330	50		 push	 eax
  00331	e8 00 00 00 00	 call	 __access
  00336	83 c4 08	 add	 esp, 8
  00339	83 f8 ff	 cmp	 eax, -1
  0033c	74 29		 je	 SHORT $LN15@SetInstall

; 2166 : 					strcpy_s (path, sizeof (path), s.c_str());

  0033e	83 bd cc f9 ff
	ff 10		 cmp	 DWORD PTR _s$3[ebp+20], 16 ; 00000010H
  00345	8d 85 b8 f9 ff
	ff		 lea	 eax, DWORD PTR _s$3[ebp]
  0034b	0f 43 85 b8 f9
	ff ff		 cmovae	 eax, DWORD PTR _s$3[ebp]
  00352	50		 push	 eax
  00353	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00359	68 18 01 00 00	 push	 280			; 00000118H
  0035e	50		 push	 eax
  0035f	e8 00 00 00 00	 call	 _strcpy_s
  00364	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@SetInstall:

; 2167 : 			}
; 2168 : 		}

  00367	8b 85 cc f9 ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp+20]
  0036d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00370	72 13		 jb	 SHORT $LN86@SetInstall
  00372	40		 inc	 eax
  00373	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp]
  00379	50		 push	 eax
  0037a	ff b5 b8 f9 ff
	ff		 push	 DWORD PTR _s$3[ebp]
  00380	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN86@SetInstall:

; 2169 : 
; 2170 : 		strncat (path, "\\GostCrypt\\", min (strlen("\\GostCrypt\\"), sizeof(path)-strlen(path)-1));

  00385	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  0038b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0038e	66 90		 npad	 2
$LL186@SetInstall:
  00390	8a 01		 mov	 al, BYTE PTR [ecx]
  00392	41		 inc	 ecx
  00393	84 c0		 test	 al, al
  00395	75 f9		 jne	 SHORT $LL186@SetInstall
  00397	2b ca		 sub	 ecx, edx
  00399	b8 17 01 00 00	 mov	 eax, 279		; 00000117H
  0039e	2b c1		 sub	 eax, ecx
  003a0	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  003a5	3b c1		 cmp	 eax, ecx
  003a7	0f 47 c1	 cmova	 eax, ecx
  003aa	50		 push	 eax
  003ab	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  003b1	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GKPCCOCO@?2GostCrypt?2?$AA@
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 _strncat

; 2171 : 		strncpy (InstallationPath, path, sizeof(InstallationPath)-1);

  003bc	68 03 01 00 00	 push	 259			; 00000103H
  003c1	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  003c7	50		 push	 eax
  003c8	68 00 00 00 00	 push	 OFFSET _InstallationPath
  003cd	e8 00 00 00 00	 call	 _strncpy
  003d2	83 c4 18	 add	 esp, 24			; 00000018H
$LN10@SetInstall:

; 2172 : 	}
; 2173 : 
; 2174 : 	// Make sure the path ends with a backslash
; 2175 : 	if (InstallationPath [strlen (InstallationPath) - 1] != '\\')

  003d5	b9 00 00 00 00	 mov	 ecx, OFFSET _InstallationPath
  003da	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  003dd	0f 1f 00	 npad	 3
$LL187@SetInstall:
  003e0	8a 01		 mov	 al, BYTE PTR [ecx]
  003e2	41		 inc	 ecx
  003e3	84 c0		 test	 al, al
  003e5	75 f9		 jne	 SHORT $LL187@SetInstall
  003e7	2b ca		 sub	 ecx, edx
  003e9	80 b9 ff ff ff
	ff 5c		 cmp	 BYTE PTR _InstallationPath[ecx-1], 92 ; 0000005cH
  003f0	74 19		 je	 SHORT $LN16@SetInstall

; 2176 : 	{
; 2177 : 		strcat (InstallationPath, "\\");

  003f2	bf 00 00 00 00	 mov	 edi, OFFSET _InstallationPath
  003f7	4f		 dec	 edi
$LL188@SetInstall:
  003f8	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  003fb	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  003fe	84 c0		 test	 al, al
  00400	75 f6		 jne	 SHORT $LL188@SetInstall
  00402	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  00408	66 89 07	 mov	 WORD PTR [edi], ax
$LN16@SetInstall:

; 2178 : 	}
; 2179 : }

  0040b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040e	5f		 pop	 edi
  0040f	33 cd		 xor	 ecx, ebp
  00411	5e		 pop	 esi
  00412	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00417	8b e5		 mov	 esp, ebp
  00419	5d		 pop	 ebp
  0041a	c3		 ret	 0
$LN190@SetInstall:

; 2095 : 					InstallationPath [len] = 0;

  0041b	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN192@SetInstall:
$LN191@SetInstall:

; 2123 : 					bInstallPathDetermined = FALSE;
; 2124 : 
; 2125 : 					ShellExecute (NULL, "open", InstallationPath, "/u", NULL, SW_SHOWNORMAL);

  00420	6a 01		 push	 1
  00422	6a 00		 push	 0
  00424	68 00 00 00 00	 push	 OFFSET ??_C@_02GBOHKKID@?1u?$AA@
  00429	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0042e	68 00 00 00 00	 push	 OFFSET ??_C@_04PMOCAHAA@open?$AA@
  00433	6a 00		 push	 0
  00435	c6 86 00 00 00
	00 00		 mov	 BYTE PTR _InstallationPath[esi], 0
  0043c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShellExecuteA@24

; 2126 : 					RegCloseKey (hkey);

  00442	ff b5 9c f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00448	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 2127 : 					exit (1);

  0044e	6a 01		 push	 1
  00450	e8 00 00 00 00	 call	 _exit
$LN193@SetInstall:
$LN189@SetInstall:
  00455	cc		 int	 3
_SetInstallationPath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _DoInstall
_TEXT	SEGMENT
_e$2 = -2588						; size = 4
_favoritesXml$1$ = -2584				; size = 4
_favoritesFilename$1$ = -2580				; size = 4
_arg$GSCopy$ = -2576					; size = 4
$T3 = -2572						; size = 4
_size$4 = -2572						; size = 4
_bOK$ = -2568						; size = 4
$T5 = -2561						; size = 1
_bootEnc$ = -2560					; size = 1480
$T6 = -1080						; size = 24
$T7 = -1056						; size = 24
$T8 = -1032						; size = 24
$T9 = -1008						; size = 24
$T10 = -984						; size = 24
$T11 = -960						; size = 24
$T12 = -936						; size = 24
_sysFavorites$13 = -912					; size = 24
$T14 = -912						; size = 24
_legacySysFavorites$15 = -888				; size = 24
_favorites$16 = -888					; size = 24
$T17 = -888						; size = 24
_regVal$18 = -864					; size = 520
_szTmp$19 = -864					; size = 520
_path$ = -344						; size = 260
_regk$20 = -84						; size = 64
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_arg$ = 8						; size = 4
_DoInstall PROC						; COMDAT

; 1745 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_DoInstall
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 10 0a 00
	00		 sub	 esp, 2576		; 00000a10H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 7d 08	 mov	 edi, DWORD PTR _arg$[ebp]

; 1746 : 	HWND hwndDlg = (HWND) arg;
; 1747 : 	BOOL bOK = TRUE;
; 1748 : 	char path[MAX_PATH];
; 1749 : 
; 1750 : 	BootEncryption bootEnc (hwndDlg);

  00034	8d 8d 00 f6 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  0003a	33 db		 xor	 ebx, ebx
  0003c	89 bd f0 f5 ff
	ff		 mov	 DWORD PTR _arg$GSCopy$[ebp], edi
  00042	57		 push	 edi
  00043	89 9d f4 f5 ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  00049	c7 85 f8 f5 ff
	ff 01 00 00 00	 mov	 DWORD PTR _bOK$[ebp], 1
  00053	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 1751 : 
; 1752 : 	// Refresh the main GUI (wizard thread)
; 1753 : 	InvalidateRect (MainDlg, NULL, TRUE);

  00058	6a 01		 push	 1
  0005a	53		 push	 ebx
  0005b	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00061	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 1754 : 
; 1755 : 	ClearLogWindow (hwndDlg);

  0006a	53		 push	 ebx
  0006b	53		 push	 ebx
  0006c	68 84 01 00 00	 push	 388			; 00000184H
  00071	68 f9 03 00 00	 push	 1017			; 000003f9H
  00076	57		 push	 edi
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0007d	50		 push	 eax
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 1756 : 
; 1757 : 	if (mkfulldir (InstallationPath, TRUE) != 0)

  00084	6a 01		 push	 1
  00086	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0008b	e8 00 00 00 00	 call	 _mkfulldir
  00090	83 c4 08	 add	 esp, 8
  00093	85 c0		 test	 eax, eax
  00095	74 6f		 je	 SHORT $LN5@DoInstall

; 1758 : 	{
; 1759 : 		if (mkfulldir (InstallationPath, FALSE) != 0)

  00097	53		 push	 ebx
  00098	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0009d	e8 00 00 00 00	 call	 _mkfulldir
  000a2	83 c4 08	 add	 esp, 8
  000a5	85 c0		 test	 eax, eax
  000a7	74 5d		 je	 SHORT $LN5@DoInstall

; 1760 : 		{
; 1761 : 			wchar_t szTmp[GST_MAX_PATH];
; 1762 : 
; 1763 : 			handleWin32Error (hwndDlg);

  000a9	57		 push	 edi
  000aa	e8 00 00 00 00	 call	 _handleWin32Error
  000af	83 c4 04	 add	 esp, 4

; 1764 : 			wsprintfW (szTmp, GetString ("CANT_CREATE_FOLDER"), InstallationPath);

  000b2	68 00 00 00 00	 push	 OFFSET _InstallationPath
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@
  000bc	e8 00 00 00 00	 call	 _GetString
  000c1	83 c4 04	 add	 esp, 4
  000c4	50		 push	 eax
  000c5	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _szTmp$19[ebp]
  000cb	50		 push	 eax
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1765 : 			MessageBoxW (hwndDlg, szTmp, lpszTitle, MB_ICONHAND);

  000d5	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _szTmp$19[ebp]
  000db	6a 10		 push	 16			; 00000010H
  000dd	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  000e3	50		 push	 eax
  000e4	57		 push	 edi
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 1766 : 			Error ("INSTALL_FAILED");

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@
$LN1250@DoInstall:
  000f0	e8 00 00 00 00	 call	 _Error
  000f5	83 c4 04	 add	 esp, 4

; 1767 : 			PostMessage (MainDlg, GST_APPMSG_INSTALL_FAILURE, 0, 0);

  000f8	6a 00		 push	 0
  000fa	6a 00		 push	 0
  000fc	68 94 81 00 00	 push	 33172			; 00008194H

; 1768 : 			return;

  00101	e9 56 0b 00 00	 jmp	 $LN1246@DoInstall
$LN5@DoInstall:

; 1769 : 		}
; 1770 : 	}
; 1771 : 
; 1772 : 	UpdateProgressBarProc(2);

  00106	6a 02		 push	 2
  00108	e8 00 00 00 00	 call	 _UpdateProgressBarProc

; 1773 : 
; 1774 : 	if (DoDriverUnload (hwndDlg) == FALSE)

  0010d	57		 push	 edi
  0010e	e8 00 00 00 00	 call	 _DoDriverUnload
  00113	83 c4 08	 add	 esp, 8
  00116	85 c0		 test	 eax, eax
  00118	75 13		 jne	 SHORT $LN6@DoInstall

; 1775 : 	{
; 1776 : 		NormalCursor ();

  0011a	e8 00 00 00 00	 call	 _NormalCursor

; 1777 : 		PostMessage (MainDlg, GST_APPMSG_INSTALL_FAILURE, 0, 0);

  0011f	6a 00		 push	 0
  00121	6a 00		 push	 0
  00123	68 94 81 00 00	 push	 33172			; 00008194H

; 1778 : 		return;

  00128	e9 2f 0b 00 00	 jmp	 $LN1246@DoInstall
$LN6@DoInstall:

; 1779 : 	}
; 1780 : 
; 1781 : 	if (bUpgrade
; 1782 : 		&& (IsFileInUse (string (InstallationPath) + '\\' + GST_APP_NAME ".exe")

  0012d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  00134	0f 84 53 01 00
	00		 je	 $LN62@DoInstall
  0013a	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0013f	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00145	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0014a	6a 5c		 push	 92			; 0000005cH
  0014c	50		 push	 eax
  0014d	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00153	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00157	50		 push	 eax
  00158	c7 85 f4 f5 ff
	ff 01 00 00 00	 mov	 DWORD PTR $T3[ebp], 1
  00162	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00167	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@
  0016c	50		 push	 eax
  0016d	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00173	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0017a	50		 push	 eax
  0017b	c7 85 f4 f5 ff
	ff 03 00 00 00	 mov	 DWORD PTR $T3[ebp], 3
  00185	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0018a	bb 07 00 00 00	 mov	 ebx, 7
  0018f	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  00196	50		 push	 eax
  00197	89 9d f4 f5 ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  0019d	e8 00 00 00 00	 call	 ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IsFileInUse
  001a2	83 c4 1c	 add	 esp, 28			; 0000001cH
  001a5	85 c0		 test	 eax, eax
  001a7	0f 85 d7 00 00
	00		 jne	 $LN61@DoInstall
  001ad	68 00 00 00 00	 push	 OFFSET _InstallationPath
  001b2	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  001b8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001bd	6a 5c		 push	 92			; 0000005cH
  001bf	50		 push	 eax
  001c0	8d 85 28 fc ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  001c6	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  001cd	50		 push	 eax
  001ce	c7 85 f4 f5 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T3[ebp], 15	; 0000000fH
  001d8	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MBKAOEOG@GostCrypt?5Format?4exe?$AA@
  001e2	50		 push	 eax
  001e3	8d 85 40 fc ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  001e9	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 5
  001f0	50		 push	 eax
  001f1	c7 85 f4 f5 ff
	ff 1f 00 00 00	 mov	 DWORD PTR $T3[ebp], 31	; 0000001fH
  001fb	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00200	bb 3f 00 00 00	 mov	 ebx, 63			; 0000003fH
  00205	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  0020c	50		 push	 eax
  0020d	89 9d f4 f5 ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  00213	e8 00 00 00 00	 call	 ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IsFileInUse
  00218	83 c4 1c	 add	 esp, 28			; 0000001cH
  0021b	85 c0		 test	 eax, eax
  0021d	75 65		 jne	 SHORT $LN61@DoInstall
  0021f	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00224	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  0022a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0022f	6a 5c		 push	 92			; 0000005cH
  00231	50		 push	 eax
  00232	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  00238	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 7
  0023f	50		 push	 eax
  00240	c7 85 f4 f5 ff
	ff 7f 00 00 00	 mov	 DWORD PTR $T3[ebp], 127	; 0000007fH
  0024a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CHHIEGKC@GostCrypt?5Setup?4exe?$AA@
  00254	50		 push	 eax
  00255	8d 85 70 fc ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  0025b	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 8
  00262	50		 push	 eax
  00263	c7 85 f4 f5 ff
	ff ff 00 00 00	 mov	 DWORD PTR $T3[ebp], 255	; 000000ffH
  0026d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00272	50		 push	 eax
  00273	bb ff 01 00 00	 mov	 ebx, 511		; 000001ffH
  00278	e8 00 00 00 00	 call	 ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IsFileInUse
  0027d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00280	85 c0		 test	 eax, eax
  00282	74 09		 je	 SHORT $LN62@DoInstall
$LN61@DoInstall:
  00284	c6 85 ff f5 ff
	ff 01		 mov	 BYTE PTR $T5[ebp], 1
  0028b	eb 07		 jmp	 SHORT $LN63@DoInstall
$LN62@DoInstall:
  0028d	c6 85 ff f5 ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
$LN63@DoInstall:
  00294	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  0029a	74 3f		 je	 SHORT $LN118@DoInstall
  0029c	8b 85 84 fc ff
	ff		 mov	 eax, DWORD PTR $T14[ebp+20]
  002a2	81 e3 ff fe ff
	ff		 and	 ebx, -257		; fffffeffH
  002a8	83 f8 10	 cmp	 eax, 16			; 00000010H
  002ab	72 13		 jb	 SHORT $LN123@DoInstall
  002ad	40		 inc	 eax
  002ae	8d 8d 70 fc ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  002b4	50		 push	 eax
  002b5	ff b5 70 fc ff
	ff		 push	 DWORD PTR $T14[ebp]
  002bb	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN123@DoInstall:
  002c0	c7 85 84 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 15 ; 0000000fH
  002ca	c7 85 80 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 0
  002d4	c6 85 70 fc ff
	ff 00		 mov	 BYTE PTR $T14[ebp], 0
$LN118@DoInstall:
  002db	84 db		 test	 bl, bl
  002dd	79 3f		 jns	 SHORT $LN219@DoInstall
  002df	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR $T17[ebp+20]
  002e5	81 e3 7f ff ff
	ff		 and	 ebx, -129		; ffffff7fH
  002eb	83 f8 10	 cmp	 eax, 16			; 00000010H
  002ee	72 13		 jb	 SHORT $LN224@DoInstall
  002f0	40		 inc	 eax
  002f1	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  002f7	50		 push	 eax
  002f8	ff b5 88 fc ff
	ff		 push	 DWORD PTR $T17[ebp]
  002fe	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN224@DoInstall:
  00303	c7 85 9c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+20], 15 ; 0000000fH
  0030d	c7 85 98 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+16], 0
  00317	c6 85 88 fc ff
	ff 00		 mov	 BYTE PTR $T17[ebp], 0
$LN219@DoInstall:
  0031e	f6 c3 40	 test	 bl, 64			; 00000040H
  00321	74 3c		 je	 SHORT $LN320@DoInstall
  00323	8b 85 6c fc ff
	ff		 mov	 eax, DWORD PTR $T12[ebp+20]
  00329	83 e3 bf	 and	 ebx, -65		; ffffffbfH
  0032c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0032f	72 13		 jb	 SHORT $LN325@DoInstall
  00331	40		 inc	 eax
  00332	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00338	50		 push	 eax
  00339	ff b5 58 fc ff
	ff		 push	 DWORD PTR $T12[ebp]
  0033f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN325@DoInstall:
  00344	c7 85 6c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T12[ebp+20], 15 ; 0000000fH
  0034e	c7 85 68 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+16], 0
  00358	c6 85 58 fc ff
	ff 00		 mov	 BYTE PTR $T12[ebp], 0
$LN320@DoInstall:
  0035f	f6 c3 20	 test	 bl, 32			; 00000020H
  00362	74 3c		 je	 SHORT $LN421@DoInstall
  00364	8b 85 54 fc ff
	ff		 mov	 eax, DWORD PTR $T11[ebp+20]
  0036a	83 e3 df	 and	 ebx, -33		; ffffffdfH
  0036d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00370	72 13		 jb	 SHORT $LN426@DoInstall
  00372	40		 inc	 eax
  00373	8d 8d 40 fc ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00379	50		 push	 eax
  0037a	ff b5 40 fc ff
	ff		 push	 DWORD PTR $T11[ebp]
  00380	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN426@DoInstall:
  00385	c7 85 54 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T11[ebp+20], 15 ; 0000000fH
  0038f	c7 85 50 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+16], 0
  00399	c6 85 40 fc ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
$LN421@DoInstall:
  003a0	f6 c3 10	 test	 bl, 16			; 00000010H
  003a3	74 3c		 je	 SHORT $LN522@DoInstall
  003a5	8b 85 3c fc ff
	ff		 mov	 eax, DWORD PTR $T10[ebp+20]
  003ab	83 e3 ef	 and	 ebx, -17		; ffffffefH
  003ae	83 f8 10	 cmp	 eax, 16			; 00000010H
  003b1	72 13		 jb	 SHORT $LN527@DoInstall
  003b3	40		 inc	 eax
  003b4	8d 8d 28 fc ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  003ba	50		 push	 eax
  003bb	ff b5 28 fc ff
	ff		 push	 DWORD PTR $T10[ebp]
  003c1	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN527@DoInstall:
  003c6	c7 85 3c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T10[ebp+20], 15 ; 0000000fH
  003d0	c7 85 38 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+16], 0
  003da	c6 85 28 fc ff
	ff 00		 mov	 BYTE PTR $T10[ebp], 0
$LN522@DoInstall:
  003e1	f6 c3 08	 test	 bl, 8
  003e4	74 3c		 je	 SHORT $LN623@DoInstall
  003e6	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR $T9[ebp+20]
  003ec	83 e3 f7	 and	 ebx, -9			; fffffff7H
  003ef	83 f8 10	 cmp	 eax, 16			; 00000010H
  003f2	72 13		 jb	 SHORT $LN628@DoInstall
  003f4	40		 inc	 eax
  003f5	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  003fb	50		 push	 eax
  003fc	ff b5 10 fc ff
	ff		 push	 DWORD PTR $T9[ebp]
  00402	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN628@DoInstall:
  00407	c7 85 24 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T9[ebp+20], 15 ; 0000000fH
  00411	c7 85 20 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+16], 0
  0041b	c6 85 10 fc ff
	ff 00		 mov	 BYTE PTR $T9[ebp], 0
$LN623@DoInstall:
  00422	f6 c3 04	 test	 bl, 4
  00425	74 3c		 je	 SHORT $LN724@DoInstall
  00427	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR $T8[ebp+20]
  0042d	83 e3 fb	 and	 ebx, -5			; fffffffbH
  00430	83 f8 10	 cmp	 eax, 16			; 00000010H
  00433	72 13		 jb	 SHORT $LN729@DoInstall
  00435	40		 inc	 eax
  00436	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0043c	50		 push	 eax
  0043d	ff b5 f8 fb ff
	ff		 push	 DWORD PTR $T8[ebp]
  00443	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN729@DoInstall:
  00448	c7 85 0c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T8[ebp+20], 15 ; 0000000fH
  00452	c7 85 08 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 0
  0045c	c6 85 f8 fb ff
	ff 00		 mov	 BYTE PTR $T8[ebp], 0
$LN724@DoInstall:
  00463	f6 c3 02	 test	 bl, 2
  00466	74 3c		 je	 SHORT $LN825@DoInstall
  00468	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR $T7[ebp+20]
  0046e	83 e3 fd	 and	 ebx, -3			; fffffffdH
  00471	83 f8 10	 cmp	 eax, 16			; 00000010H
  00474	72 13		 jb	 SHORT $LN830@DoInstall
  00476	40		 inc	 eax
  00477	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0047d	50		 push	 eax
  0047e	ff b5 e0 fb ff
	ff		 push	 DWORD PTR $T7[ebp]
  00484	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN830@DoInstall:
  00489	c7 85 f4 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH
  00493	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0
  0049d	c6 85 e0 fb ff
	ff 00		 mov	 BYTE PTR $T7[ebp], 0
$LN825@DoInstall:
  004a4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  004ab	f6 c3 01	 test	 bl, 1
  004ae	74 1e		 je	 SHORT $LN931@DoInstall
  004b0	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR $T6[ebp+20]
  004b6	83 f8 10	 cmp	 eax, 16			; 00000010H
  004b9	72 13		 jb	 SHORT $LN931@DoInstall
  004bb	40		 inc	 eax
  004bc	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  004c2	50		 push	 eax
  004c3	ff b5 c8 fb ff
	ff		 push	 DWORD PTR $T6[ebp]
  004c9	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN931@DoInstall:
  004ce	80 bd ff f5 ff
	ff 00		 cmp	 BYTE PTR $T5[ebp], 0
  004d5	74 0f		 je	 SHORT $LN7@DoInstall

; 1783 : 			|| IsFileInUse (string (InstallationPath) + '\\' + GST_APP_NAME " Format.exe")
; 1784 : 			|| IsFileInUse (string (InstallationPath) + '\\' + GST_APP_NAME " Setup.exe")
; 1785 : 			)
; 1786 : 		)
; 1787 : 	{
; 1788 : 		NormalCursor ();

  004d7	e8 00 00 00 00	 call	 _NormalCursor

; 1789 : 		Error ("CLOSE_GST_FIRST");

  004dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BFJEMMFA@CLOSE_GST_FIRST?$AA@

; 1790 : 		PostMessage (MainDlg, GST_APPMSG_INSTALL_FAILURE, 0, 0);
; 1791 : 		return;

  004e1	e9 0a fc ff ff	 jmp	 $LN1250@DoInstall
$LN7@DoInstall:

; 1792 : 	}
; 1793 : 
; 1794 : 	UpdateProgressBarProc(12);

  004e6	6a 0c		 push	 12			; 0000000cH
  004e8	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  004ed	83 c4 04	 add	 esp, 4

; 1795 : 	
; 1796 : 	if (bSystemRestore)

  004f0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bSystemRestore, 0
  004f7	74 0b		 je	 SHORT $LN8@DoInstall

; 1797 : 		SetSystemRestorePoint (hwndDlg, FALSE);

  004f9	6a 00		 push	 0
  004fb	57		 push	 edi
  004fc	e8 00 00 00 00	 call	 ?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z ; SetSystemRestorePoint
  00501	83 c4 08	 add	 esp, 8
$LN8@DoInstall:

; 1798 : 
; 1799 : 	UpdateProgressBarProc(48);

  00504	6a 30		 push	 48			; 00000030H
  00506	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  0050b	83 c4 04	 add	 esp, 4

; 1800 : 	
; 1801 : 	if (bDisableSwapFiles
; 1802 : 		&& IsPagingFileActive (FALSE))

  0050e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDisableSwapFiles, 0
  00515	74 36		 je	 SHORT $LN11@DoInstall
  00517	6a 00		 push	 0
  00519	e8 00 00 00 00	 call	 _IsPagingFileActive
  0051e	83 c4 04	 add	 esp, 4
  00521	85 c0		 test	 eax, eax
  00523	74 28		 je	 SHORT $LN11@DoInstall

; 1803 : 	{
; 1804 : 		if (!DisablePagingFile())

  00525	e8 00 00 00 00	 call	 _DisablePagingFile
  0052a	85 c0		 test	 eax, eax
  0052c	75 15		 jne	 SHORT $LN10@DoInstall

; 1805 : 		{
; 1806 : 			handleWin32Error (hwndDlg);

  0052e	57		 push	 edi
  0052f	e8 00 00 00 00	 call	 _handleWin32Error

; 1807 : 			Error ("FAILED_TO_DISABLE_PAGING_FILES");

  00534	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@JGNDMOPD@FAILED_TO_DISABLE_PAGING_FILES?$AA@
  00539	e8 00 00 00 00	 call	 _Error
  0053e	83 c4 08	 add	 esp, 8

; 1808 : 		}
; 1809 : 		else

  00541	eb 0a		 jmp	 SHORT $LN11@DoInstall
$LN10@DoInstall:

; 1810 : 			bRestartRequired = TRUE;

  00543	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bRestartRequired, 1
$LN11@DoInstall:

; 1811 : 	}
; 1812 : 
; 1813 : 	UpdateProgressBarProc(50);

  0054d	6a 32		 push	 50			; 00000032H
  0054f	e8 00 00 00 00	 call	 _UpdateProgressBarProc

; 1814 : 
; 1815 : 	// Remove deprecated
; 1816 : 	DoServiceUninstall (hwndDlg, "GostCryptService");

  00554	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CILIJECC@GostCryptService?$AA@
  00559	57		 push	 edi
  0055a	e8 00 00 00 00	 call	 _DoServiceUninstall

; 1817 : 	
; 1818 : 	UpdateProgressBarProc(55);

  0055f	6a 37		 push	 55			; 00000037H
  00561	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00566	83 c4 10	 add	 esp, 16			; 00000010H

; 1819 : 
; 1820 : 	if (!SystemEncryptionUpdate)

  00569	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  00570	75 67		 jne	 SHORT $LN1244@DoInstall

; 1821 : 		DoRegUninstall ((HWND) hwndDlg, TRUE);

  00572	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegDeleteKeyA@8
  00578	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@MNMIDBOE@Software?2Microsoft?2Windows?2Curre@
  0057d	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00582	ff d6		 call	 esi
  00584	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@GDKMHJIK@Software?2Classes?2GostCryptVolume@
  00589	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0058e	ff d6		 call	 esi
  00590	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@GDILNLIK@Software?2Classes?2GostCryptVolume@
  00595	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0059a	ff d6		 call	 esi
  0059c	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DCEJAAFL@Software?2Classes?2GostCryptVolume@
  005a1	68 02 00 00 80	 push	 -2147483646		; 80000002H
  005a6	ff d6		 call	 esi
  005a8	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HFACCAPK@Software?2Classes?2GostCryptVolume@
  005ad	68 02 00 00 80	 push	 -2147483646		; 80000002H
  005b2	ff d6		 call	 esi
  005b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HIFIENIE@Software?2Classes?2GostCryptVolume@
  005b9	68 02 00 00 80	 push	 -2147483646		; 80000002H
  005be	ff d6		 call	 esi
  005c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EEKEPCFI@Software?2GostCrypt?$AA@
  005c5	68 01 00 00 80	 push	 -2147483647		; 80000001H
  005ca	ff d6		 call	 esi

; 1822 : 
; 1823 : 	if (SystemEncryptionUpdate && InstalledVersion < 0x700)

  005cc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  005d3	0f 84 80 00 00
	00		 je	 $LN18@DoInstall
$LN1244@DoInstall:
  005d9	81 3d 00 00 00
	00 00 07 00 00	 cmp	 DWORD PTR ?InstalledVersion@@3JA, 1792 ; InstalledVersion, 00000700H
  005e3	7d 74		 jge	 SHORT $LN18@DoInstall

; 1824 : 	{
; 1825 : 		try
; 1826 : 		{
; 1827 : 			bootEnc.RegisterFilterDriver (false, BootEncryption::DumpFilter);

  005e5	6a 02		 push	 2
  005e7	6a 00		 push	 0
  005e9	8d 8d 00 f6 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  005ef	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  005f3	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
  005f8	eb 0c		 jmp	 SHORT $LN1247@DoInstall
__catch$_DoInstall$0:

; 1828 : 		}
; 1829 : 		catch (...) { }

  005fa	b8 00 00 00 00	 mov	 eax, $LN106@DoInstall
  005ff	c3		 ret	 0
$LN106@DoInstall:
  00600	8b bd f0 f5 ff
	ff		 mov	 edi, DWORD PTR _arg$GSCopy$[ebp]
$LN1247@DoInstall:

; 1830 : 
; 1831 : 		try
; 1832 : 		{
; 1833 : 			bootEnc.RegisterFilterDriver (true, BootEncryption::DumpFilter);

  00606	6a 02		 push	 2
  00608	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0060f	8d 8d 00 f6 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00615	6a 01		 push	 1
  00617	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH
  0061b	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
  00620	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00627	e8 00 00 00 00	 call	 _ReadDriverConfigurationFlags
  0062c	a8 02		 test	 al, 2
  0062e	74 29		 je	 SHORT $LN18@DoInstall

; 1847 : 		}
; 1848 : 
; 1849 : 		if (ReadDriverConfigurationFlags() & GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES)
; 1850 : 		{
; 1851 : 			WriteLocalMachineRegistryString ("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Minimal\\" GST_SYSTEM_FAVORITES_SERVICE_NAME, NULL, "Service", FALSE);

  00630	6a 00		 push	 0
  00632	68 00 00 00 00	 push	 OFFSET ??_C@_07LMLHFMEG@Service?$AA@
  00637	6a 00		 push	 0
  00639	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@MKLMKGDH@SYSTEM?2CurrentControlSet?2Control@
  0063e	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryString

; 1852 : 			WriteLocalMachineRegistryString ("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Network\\" GST_SYSTEM_FAVORITES_SERVICE_NAME, NULL, "Service", FALSE);

  00643	6a 00		 push	 0
  00645	68 00 00 00 00	 push	 OFFSET ??_C@_07LMLHFMEG@Service?$AA@
  0064a	6a 00		 push	 0
  0064c	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@ELDIGJGM@SYSTEM?2CurrentControlSet?2Control@
  00651	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryString
  00656	83 c4 20	 add	 esp, 32			; 00000020H
$LN18@DoInstall:

; 1853 : 		}
; 1854 : 	}
; 1855 : 
; 1856 : 	UpdateProgressBarProc(61);

  00659	6a 3d		 push	 61			; 0000003dH
  0065b	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00660	83 c4 04	 add	 esp, 4

; 1857 : 
; 1858 : 	if (bUpgrade && InstalledVersion < 0x700)

  00663	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  0066a	0f 84 c6 01 00
	00		 je	 $LN27@DoInstall
  00670	81 3d 00 00 00
	00 00 07 00 00	 cmp	 DWORD PTR ?InstalledVersion@@3JA, 1792 ; InstalledVersion, 00000700H
  0067a	0f 8d b6 01 00
	00		 jge	 $LN27@DoInstall

; 1859 : 	{
; 1860 : 		bool bMountFavoritesOnLogon = ConfigReadInt ("MountFavoritesOnLogon", FALSE) != 0;

  00680	6a 00		 push	 0
  00682	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IDCDKCEI@MountFavoritesOnLogon?$AA@
  00687	e8 00 00 00 00	 call	 _ConfigReadInt
  0068c	85 c0		 test	 eax, eax

; 1861 : 		bool bOpenExplorerWindowAfterMount = ConfigReadInt ("OpenExplorerWindowAfterMount", FALSE) != 0;

  0068e	6a 00		 push	 0
  00690	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JJNCGBDA@OpenExplorerWindowAfterMount?$AA@
  00695	0f 95 c3	 setne	 bl
  00698	e8 00 00 00 00	 call	 _ConfigReadInt
  0069d	83 c4 10	 add	 esp, 16			; 00000010H
  006a0	85 c0		 test	 eax, eax
  006a2	0f 95 c7	 setne	 bh

; 1862 : 
; 1863 : 		if (bMountFavoritesOnLogon || bOpenExplorerWindowAfterMount)

  006a5	84 db		 test	 bl, bl
  006a7	75 08		 jne	 SHORT $LN21@DoInstall
  006a9	84 ff		 test	 bh, bh
  006ab	0f 84 85 01 00
	00		 je	 $LN27@DoInstall
$LN21@DoInstall:

; 1864 : 		{
; 1865 : 			char *favoritesFilename = GetConfigPath (GST_APPD_FILENAME_FAVORITE_VOLUMES);

  006b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@
  006b6	e8 00 00 00 00	 call	 _GetConfigPath

; 1866 : 			DWORD size;
; 1867 : 			char *favoritesXml = LoadFile (favoritesFilename, &size);

  006bb	8d 8d f4 f5 ff
	ff		 lea	 ecx, DWORD PTR _size$4[ebp]
  006c1	89 85 ec f5 ff
	ff		 mov	 DWORD PTR _favoritesFilename$1$[ebp], eax
  006c7	51		 push	 ecx
  006c8	50		 push	 eax
  006c9	e8 00 00 00 00	 call	 _LoadFile
  006ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  006d1	89 85 e8 f5 ff
	ff		 mov	 DWORD PTR _favoritesXml$1$[ebp], eax

; 1868 : 
; 1869 : 			if (favoritesXml && size != 0)

  006d7	85 c0		 test	 eax, eax
  006d9	0f 84 57 01 00
	00		 je	 $LN27@DoInstall
  006df	8b 8d f4 f5 ff
	ff		 mov	 ecx, DWORD PTR _size$4[ebp]
  006e5	85 c9		 test	 ecx, ecx
  006e7	0f 84 40 01 00
	00		 je	 $LN22@DoInstall

; 1870 : 			{
; 1871 : 				string favorites;

  006ed	c7 85 9c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favorites$16[ebp+20], 15 ; 0000000fH
  006f7	c7 85 98 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _favorites$16[ebp+16], 0
  00701	c6 85 88 fc ff
	ff 00		 mov	 BYTE PTR _favorites$16[ebp], 0

; 1872 : 				favorites.insert (0, favoritesXml, size);

  00708	51		 push	 ecx
  00709	50		 push	 eax
  0070a	6a 00		 push	 0
  0070c	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR _favorites$16[ebp]
  00712	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+12], 15 ; 0000000fH
  00716	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1873 : 
; 1874 : 				size_t p = favorites.find ("<volume ");

  0071b	6a 00		 push	 0
  0071d	68 00 00 00 00	 push	 OFFSET ??_C@_08JKOCNOKF@?$DMvolume?5?$AA@
  00722	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR _favorites$16[ebp]
  00728	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0072d	8b f0		 mov	 esi, eax

; 1875 : 				while (p != string::npos)

  0072f	83 fe ff	 cmp	 esi, -1
  00732	74 4b		 je	 SHORT $LN3@DoInstall
$LL2@DoInstall:

; 1876 : 				{
; 1877 : 					if (bMountFavoritesOnLogon)

  00734	84 db		 test	 bl, bl
  00736	74 14		 je	 SHORT $LN23@DoInstall

; 1878 : 						favorites.insert (p + 8, "mountOnLogOn=\"1\" ");

  00738	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JBHLDJCD@mountOnLogOn?$DN?$CC1?$CC?5?$AA@
  0073d	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00740	50		 push	 eax
  00741	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR _favorites$16[ebp]
  00747	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
$LN23@DoInstall:

; 1879 : 
; 1880 : 					if (bOpenExplorerWindowAfterMount)

  0074c	84 ff		 test	 bh, bh
  0074e	74 14		 je	 SHORT $LN24@DoInstall

; 1881 : 						favorites.insert (p + 8, "openExplorerWindow=\"1\" ");

  00750	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DLANKHNO@openExplorerWindow?$DN?$CC1?$CC?5?$AA@
  00755	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00758	50		 push	 eax
  00759	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR _favorites$16[ebp]
  0075f	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
$LN24@DoInstall:

; 1882 : 
; 1883 : 					p = favorites.find ("<volume ", p + 1);

  00764	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00767	50		 push	 eax
  00768	68 00 00 00 00	 push	 OFFSET ??_C@_08JKOCNOKF@?$DMvolume?5?$AA@
  0076d	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR _favorites$16[ebp]
  00773	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00778	8b f0		 mov	 esi, eax
  0077a	83 fe ff	 cmp	 esi, -1
  0077d	75 b5		 jne	 SHORT $LL2@DoInstall
$LN3@DoInstall:

; 1884 : 				}
; 1885 : 
; 1886 : 				SaveBufferToFile (favorites.c_str(), favoritesFilename, favorites.size(), FALSE);

  0077f	83 bd 9c fc ff
	ff 10		 cmp	 DWORD PTR _favorites$16[ebp+20], 16 ; 00000010H
  00786	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _favorites$16[ebp]
  0078c	6a 00		 push	 0
  0078e	ff b5 98 fc ff
	ff		 push	 DWORD PTR _favorites$16[ebp+16]
  00794	0f 43 85 88 fc
	ff ff		 cmovae	 eax, DWORD PTR _favorites$16[ebp]
  0079b	ff b5 ec f5 ff
	ff		 push	 DWORD PTR _favoritesFilename$1$[ebp]
  007a1	50		 push	 eax
  007a2	e8 00 00 00 00	 call	 _SaveBufferToFile
  007a7	83 c4 10	 add	 esp, 16			; 00000010H

; 1887 : 
; 1888 : 				if (bMountFavoritesOnLogon)

  007aa	84 db		 test	 bl, bl
  007ac	74 6e		 je	 SHORT $LN26@DoInstall

; 1889 : 				{
; 1890 : 					char regk[64];
; 1891 : 					char regVal[MAX_PATH * 2];
; 1892 : 
; 1893 : 					GetStartupRegKeyName (regk);

  007ae	8d 45 ac	 lea	 eax, DWORD PTR _regk$20[ebp]
  007b1	50		 push	 eax
  007b2	e8 00 00 00 00	 call	 _GetStartupRegKeyName

; 1894 : 
; 1895 : 					ReadRegistryString (regk, "GostCrypt", "", regVal, sizeof (regVal));

  007b7	68 08 02 00 00	 push	 520			; 00000208H
  007bc	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _regVal$18[ebp]
  007c2	50		 push	 eax
  007c3	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  007c8	8d 45 ac	 lea	 eax, DWORD PTR _regk$20[ebp]
  007cb	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  007d0	50		 push	 eax
  007d1	e8 00 00 00 00	 call	 _ReadRegistryString

; 1896 : 
; 1897 : 					if (strstr (regVal, "favorites"))

  007d6	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _regVal$18[ebp]
  007dc	68 00 00 00 00	 push	 OFFSET ??_C@_09OAMOHPIB@favorites?$AA@
  007e1	50		 push	 eax
  007e2	e8 00 00 00 00	 call	 _strstr
  007e7	83 c4 20	 add	 esp, 32			; 00000020H
  007ea	85 c0		 test	 eax, eax
  007ec	74 2e		 je	 SHORT $LN26@DoInstall

; 1898 : 					{
; 1899 : 						strcat_s (regVal, sizeof (regVal), " /a logon");

  007ee	68 00 00 00 00	 push	 OFFSET ??_C@_09KHMMGKKB@?5?1a?5logon?$AA@
  007f3	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _regVal$18[ebp]
  007f9	68 08 02 00 00	 push	 520			; 00000208H
  007fe	50		 push	 eax
  007ff	e8 00 00 00 00	 call	 _strcat_s

; 1900 : 						WriteRegistryString (regk, "GostCrypt", regVal);

  00804	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _regVal$18[ebp]
  0080a	50		 push	 eax
  0080b	8d 45 ac	 lea	 eax, DWORD PTR _regk$20[ebp]
  0080e	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  00813	50		 push	 eax
  00814	e8 00 00 00 00	 call	 _WriteRegistryString
  00819	83 c4 18	 add	 esp, 24			; 00000018H
$LN26@DoInstall:

; 1901 : 					}
; 1902 : 				}
; 1903 : 			}

  0081c	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR _favorites$16[ebp]
  00822	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00827	8b 85 e8 f5 ff
	ff		 mov	 eax, DWORD PTR _favoritesXml$1$[ebp]
$LN22@DoInstall:

; 1904 : 
; 1905 : 			if (favoritesXml)
; 1906 : 				free (favoritesXml);

  0082d	50		 push	 eax
  0082e	e8 00 00 00 00	 call	 _free
  00833	83 c4 04	 add	 esp, 4
$LN27@DoInstall:

; 1907 : 		}
; 1908 : 	}
; 1909 : 
; 1910 : 	GetWindowsDirectory (path, sizeof (path));

  00836	68 04 01 00 00	 push	 260			; 00000104H
  0083b	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00841	50		 push	 eax
  00842	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowsDirectoryA@8

; 1911 : 	strcat_s (path, sizeof (path), "\\GostCrypt Setup.exe");

  00848	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OBKHEKHE@?2GostCrypt?5Setup?4exe?$AA@
  0084d	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00853	68 04 01 00 00	 push	 260			; 00000104H
  00858	50		 push	 eax
  00859	e8 00 00 00 00	 call	 _strcat_s
  0085e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1912 : 	DeleteFile (path);

  00861	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00867	50		 push	 eax
  00868	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4

; 1913 : 
; 1914 : 	if (UpdateProgressBarProc(63) && UnloadDriver && DoServiceUninstall (hwndDlg, "gostcrypt") == FALSE)

  0086e	6a 3f		 push	 63			; 0000003fH
  00870	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00875	83 c4 04	 add	 esp, 4
  00878	85 c0		 test	 eax, eax
  0087a	74 7a		 je	 SHORT $LN28@DoInstall
  0087c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
  00883	74 71		 je	 SHORT $LN28@DoInstall
  00885	68 00 00 00 00	 push	 OFFSET ??_C@_09JCILFBFB@gostcrypt?$AA@
  0088a	57		 push	 edi
  0088b	e8 00 00 00 00	 call	 _DoServiceUninstall
  00890	83 c4 08	 add	 esp, 8
  00893	85 c0		 test	 eax, eax
  00895	75 5f		 jne	 SHORT $LN28@DoInstall

; 1915 : 	{
; 1916 : 		bOK = FALSE;

  00897	89 85 f8 f5 ff
	ff		 mov	 DWORD PTR _bOK$[ebp], eax
  0089d	e9 3a 01 00 00	 jmp	 $LN38@DoInstall
__catch$_DoInstall$2:

; 1834 : 		}
; 1835 : 		catch (Exception &e)
; 1836 : 		{

  008a2	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1837 : 			try
; 1838 : 			{
; 1839 : 				bootEnc.RegisterFilterDriver (false, BootEncryption::DumpFilter);

  008a5	8d 8d 00 f6 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  008ab	6a 02		 push	 2
  008ad	6a 00		 push	 0
  008af	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+12], 13 ; 0000000dH
  008b3	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
$LN108@DoInstall:

; 1842 : 
; 1843 : 			e.Show (hwndDlg);

  008b8	8b 8d e4 f5 ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  008be	ff b5 f0 f5 ff
	ff		 push	 DWORD PTR _arg$GSCopy$[ebp]
  008c4	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  008cb	8b 01		 mov	 eax, DWORD PTR [ecx]
  008cd	ff 10		 call	 DWORD PTR [eax]
  008cf	c7 85 f8 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _bOK$[ebp], 0
  008d9	b8 00 00 00 00	 mov	 eax, $LN110@DoInstall
  008de	c3		 ret	 0
__catch$_DoInstall$3:

; 1840 : 			}
; 1841 : 			catch (...) { }

  008df	b8 00 00 00 00	 mov	 eax, $LN108@DoInstall
  008e4	c3		 ret	 0
$LN110@DoInstall:

; 1844 : 
; 1845 : 			bOK = FALSE;
; 1846 : 			goto outcome;

  008e5	8b bd f0 f5 ff
	ff		 mov	 edi, DWORD PTR _arg$GSCopy$[ebp]
  008eb	8b 9d f8 f5 ff
	ff		 mov	 ebx, DWORD PTR _bOK$[ebp]
  008f1	e9 b6 02 00 00	 jmp	 $outcome$1251
$LN28@DoInstall:

; 1917 : 	}
; 1918 : 	else if (UpdateProgressBarProc(72) && DoFilesInstall ((HWND) hwndDlg, InstallationPath) == FALSE)

  008f6	6a 48		 push	 72			; 00000048H
  008f8	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  008fd	83 c4 04	 add	 esp, 4
  00900	85 c0		 test	 eax, eax
  00902	74 1d		 je	 SHORT $LN30@DoInstall
  00904	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00909	57		 push	 edi
  0090a	e8 00 00 00 00	 call	 _DoFilesInstall
  0090f	83 c4 08	 add	 esp, 8
  00912	85 c0		 test	 eax, eax
  00914	75 0b		 jne	 SHORT $LN30@DoInstall

; 1919 : 	{
; 1920 : 		bOK = FALSE;

  00916	89 85 f8 f5 ff
	ff		 mov	 DWORD PTR _bOK$[ebp], eax
  0091c	e9 bb 00 00 00	 jmp	 $LN38@DoInstall
$LN30@DoInstall:

; 1921 : 	}
; 1922 : 	else if (UpdateProgressBarProc(80) && DoRegInstall ((HWND) hwndDlg, InstallationPath, bRegisterFileExt) == FALSE)

  00921	6a 50		 push	 80			; 00000050H
  00923	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00928	83 c4 04	 add	 esp, 4
  0092b	85 c0		 test	 eax, eax
  0092d	74 23		 je	 SHORT $LN32@DoInstall
  0092f	ff 35 00 00 00
	00		 push	 DWORD PTR _bRegisterFileExt
  00935	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0093a	57		 push	 edi
  0093b	e8 00 00 00 00	 call	 _DoRegInstall
  00940	83 c4 0c	 add	 esp, 12			; 0000000cH
  00943	85 c0		 test	 eax, eax
  00945	75 0b		 jne	 SHORT $LN32@DoInstall

; 1923 : 	{
; 1924 : 		bOK = FALSE;

  00947	89 85 f8 f5 ff
	ff		 mov	 DWORD PTR _bOK$[ebp], eax
  0094d	e9 8a 00 00 00	 jmp	 $LN38@DoInstall
$LN32@DoInstall:

; 1925 : 	}
; 1926 : 	else if (UpdateProgressBarProc(85) && UnloadDriver && DoDriverInstall (hwndDlg) == FALSE)

  00952	6a 55		 push	 85			; 00000055H
  00954	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00959	83 c4 04	 add	 esp, 4
  0095c	85 c0		 test	 eax, eax
  0095e	74 1e		 je	 SHORT $LN34@DoInstall
  00960	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
  00967	74 15		 je	 SHORT $LN34@DoInstall
  00969	57		 push	 edi
  0096a	e8 00 00 00 00	 call	 _DoDriverInstall
  0096f	83 c4 04	 add	 esp, 4
  00972	85 c0		 test	 eax, eax
  00974	75 08		 jne	 SHORT $LN34@DoInstall

; 1927 : 	{
; 1928 : 		bOK = FALSE;

  00976	89 85 f8 f5 ff
	ff		 mov	 DWORD PTR _bOK$[ebp], eax
  0097c	eb 5e		 jmp	 SHORT $LN38@DoInstall
$LN34@DoInstall:

; 1929 : 	}
; 1930 : 	else if (UpdateProgressBarProc(90) && SystemEncryptionUpdate && UpgradeBootLoader (hwndDlg) == FALSE)

  0097e	6a 5a		 push	 90			; 0000005aH
  00980	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00985	83 c4 04	 add	 esp, 4
  00988	85 c0		 test	 eax, eax
  0098a	74 1e		 je	 SHORT $LN36@DoInstall
  0098c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  00993	74 15		 je	 SHORT $LN36@DoInstall
  00995	57		 push	 edi
  00996	e8 00 00 00 00	 call	 _UpgradeBootLoader
  0099b	83 c4 04	 add	 esp, 4
  0099e	85 c0		 test	 eax, eax
  009a0	75 08		 jne	 SHORT $LN36@DoInstall

; 1931 : 	{
; 1932 : 		bOK = FALSE;

  009a2	89 85 f8 f5 ff
	ff		 mov	 DWORD PTR _bOK$[ebp], eax
  009a8	eb 32		 jmp	 SHORT $LN38@DoInstall
$LN36@DoInstall:

; 1933 : 	}
; 1934 : 	else if (UpdateProgressBarProc(93) && DoShortcutsInstall (hwndDlg, InstallationPath, bAddToStartMenu, bDesktopIcon) == FALSE)

  009aa	6a 5d		 push	 93			; 0000005dH
  009ac	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  009b1	83 c4 04	 add	 esp, 4
  009b4	85 c0		 test	 eax, eax
  009b6	74 24		 je	 SHORT $LN38@DoInstall
  009b8	ff 35 00 00 00
	00		 push	 DWORD PTR _bDesktopIcon
  009be	ff 35 00 00 00
	00		 push	 DWORD PTR _bAddToStartMenu
  009c4	68 00 00 00 00	 push	 OFFSET _InstallationPath
  009c9	57		 push	 edi
  009ca	e8 00 00 00 00	 call	 _DoShortcutsInstall
  009cf	83 c4 10	 add	 esp, 16			; 00000010H
  009d2	f7 d8		 neg	 eax
  009d4	1b c0		 sbb	 eax, eax
  009d6	21 85 f8 f5 ff
	ff		 and	 DWORD PTR _bOK$[ebp], eax
$LN38@DoInstall:

; 1935 : 	{
; 1936 : 		bOK = FALSE;
; 1937 : 	}
; 1938 : 
; 1939 : 	if (!UnloadDriver)

  009dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _bRestartRequired
  009e1	b9 01 00 00 00	 mov	 ecx, 1
  009e6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver

; 1940 : 		bRestartRequired = TRUE;
; 1941 : 
; 1942 : 	try

  009ed	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
  009f1	0f 44 c1	 cmove	 eax, ecx

; 1943 : 	{
; 1944 : 		bootEnc.RenameDeprecatedSystemLoaderBackup();

  009f4	8d 8d 00 f6 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  009fa	a3 00 00 00 00	 mov	 DWORD PTR _bRestartRequired, eax
  009ff	e8 00 00 00 00	 call	 ?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::RenameDeprecatedSystemLoaderBackup
  00a04	eb 0c		 jmp	 SHORT $LN1248@DoInstall
__catch$_DoInstall$7:

; 1945 : 	}
; 1946 : 	catch (...)	{ }

  00a06	b8 00 00 00 00	 mov	 eax, $LN114@DoInstall
  00a0b	c3		 ret	 0
$LN114@DoInstall:
  00a0c	8b bd f0 f5 ff
	ff		 mov	 edi, DWORD PTR _arg$GSCopy$[ebp]
$LN1248@DoInstall:

; 1947 : 
; 1948 : 	if (SystemEncryptionUpdate && InstalledVersion == 0x630)

  00a12	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  00a19	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00a20	0f 84 ca 00 00
	00		 je	 $LN41@DoInstall
  00a26	81 3d 00 00 00
	00 30 06 00 00	 cmp	 DWORD PTR ?InstalledVersion@@3JA, 1584 ; InstalledVersion, 00000630H
  00a30	0f 85 ba 00 00
	00		 jne	 $LN41@DoInstall

; 1949 : 	{
; 1950 : 		string sysFavorites = GetServiceConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES);

  00a36	8d 85 70 fc ff
	ff		 lea	 eax, DWORD PTR _sysFavorites$13[ebp]
  00a3c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  00a41	50		 push	 eax
  00a42	e8 00 00 00 00	 call	 ?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GetServiceConfigPath

; 1951 : 		string legacySysFavorites = GetProgramConfigPath ("System Favorite Volumes.xml");

  00a47	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IAAIJFIC@System?5Favorite?5Volumes?4xml?$AA@
  00a4c	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+12], 18 ; 00000012H
  00a50	e8 00 00 00 00	 call	 _GetProgramConfigPath
  00a55	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a58	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR _legacySysFavorites$15[ebp]
  00a5e	50		 push	 eax
  00a5f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1952 : 
; 1953 : 		if (FileExists (legacySysFavorites.c_str()) && !FileExists (sysFavorites.c_str()))

  00a64	83 bd 9c fc ff
	ff 10		 cmp	 DWORD PTR _legacySysFavorites$15[ebp+20], 16 ; 00000010H
  00a6b	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _legacySysFavorites$15[ebp]
  00a71	0f 43 85 88 fc
	ff ff		 cmovae	 eax, DWORD PTR _legacySysFavorites$15[ebp]
  00a78	50		 push	 eax
  00a79	e8 00 00 00 00	 call	 _FileExists
  00a7e	83 c4 04	 add	 esp, 4
  00a81	85 c0		 test	 eax, eax
  00a83	74 51		 je	 SHORT $LN42@DoInstall
  00a85	83 bd 84 fc ff
	ff 10		 cmp	 DWORD PTR _sysFavorites$13[ebp+20], 16 ; 00000010H
  00a8c	8d 85 70 fc ff
	ff		 lea	 eax, DWORD PTR _sysFavorites$13[ebp]
  00a92	0f 43 85 70 fc
	ff ff		 cmovae	 eax, DWORD PTR _sysFavorites$13[ebp]
  00a99	50		 push	 eax
  00a9a	e8 00 00 00 00	 call	 _FileExists
  00a9f	83 c4 04	 add	 esp, 4
  00aa2	85 c0		 test	 eax, eax
  00aa4	75 30		 jne	 SHORT $LN42@DoInstall

; 1954 : 			MoveFile (legacySysFavorites.c_str(), sysFavorites.c_str());

  00aa6	83 bd 84 fc ff
	ff 10		 cmp	 DWORD PTR _sysFavorites$13[ebp+20], 16 ; 00000010H
  00aad	8d 8d 70 fc ff
	ff		 lea	 ecx, DWORD PTR _sysFavorites$13[ebp]
  00ab3	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _legacySysFavorites$15[ebp]
  00ab9	0f 43 8d 70 fc
	ff ff		 cmovae	 ecx, DWORD PTR _sysFavorites$13[ebp]
  00ac0	83 bd 9c fc ff
	ff 10		 cmp	 DWORD PTR _legacySysFavorites$15[ebp+20], 16 ; 00000010H
  00ac7	51		 push	 ecx
  00ac8	0f 43 85 88 fc
	ff ff		 cmovae	 eax, DWORD PTR _legacySysFavorites$15[ebp]
  00acf	50		 push	 eax
  00ad0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8
$LN42@DoInstall:

; 1955 : 	}

  00ad6	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR _legacySysFavorites$15[ebp]
  00adc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ae1	8d 8d 70 fc ff
	ff		 lea	 ecx, DWORD PTR _sysFavorites$13[ebp]
  00ae7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00aeb	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN41@DoInstall:

; 1956 : 
; 1957 : 	if (bOK)

  00af0	8b 9d f8 f5 ff
	ff		 mov	 ebx, DWORD PTR _bOK$[ebp]
  00af6	85 db		 test	 ebx, ebx
  00af8	74 0a		 je	 SHORT $LN43@DoInstall

; 1958 : 		UpdateProgressBarProc(97);

  00afa	6a 61		 push	 97			; 00000061H
  00afc	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00b01	83 c4 04	 add	 esp, 4
$LN43@DoInstall:

; 1959 : 
; 1960 : 	if (bSystemRestore)

  00b04	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bSystemRestore, 0
  00b0b	74 0b		 je	 SHORT $LN44@DoInstall

; 1961 : 		SetSystemRestorePoint (hwndDlg, TRUE);

  00b0d	6a 01		 push	 1
  00b0f	57		 push	 edi
  00b10	e8 00 00 00 00	 call	 ?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z ; SetSystemRestorePoint
  00b15	83 c4 08	 add	 esp, 8
$LN44@DoInstall:
  00b18	85 db		 test	 ebx, ebx

; 1962 : 
; 1963 : 	if (bOK)

  00b1a	74 1e		 je	 SHORT $LN45@DoInstall

; 1964 : 	{
; 1965 : 		UpdateProgressBarProc(100);

  00b1c	6a 64		 push	 100			; 00000064H
  00b1e	e8 00 00 00 00	 call	 _UpdateProgressBarProc

; 1966 : 		UninstallBatch[0] = 0;
; 1967 : 		StatusMessage (hwndDlg, "INSTALL_COMPLETED");

  00b23	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KNJLNLNB@INSTALL_COMPLETED?$AA@
  00b28	57		 push	 edi
  00b29	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?UninstallBatch@@3PADA, 0
  00b30	e8 00 00 00 00	 call	 _StatusMessage
  00b35	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1968 : 	}
; 1969 : 	else

  00b38	eb 72		 jmp	 SHORT $outcome$1251
$LN45@DoInstall:

; 1970 : 	{
; 1971 : 		UpdateProgressBarProc(0);

  00b3a	6a 00		 push	 0
  00b3c	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00b41	83 c4 04	 add	 esp, 4

; 1972 : 
; 1973 : 		if (!SystemEncryptionUpdate)

  00b44	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  00b4b	75 52		 jne	 SHORT $LN47@DoInstall

; 1974 : 		{
; 1975 : 			bUninstall = TRUE;
; 1976 : 			Rollback = TRUE;
; 1977 : 			Silent = TRUE;
; 1978 : 
; 1979 : 			DoUninstall (hwndDlg);

  00b4d	57		 push	 edi
  00b4e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bUninstall@@3HA, 1 ; bUninstall
  00b58	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Rollback, 1
  00b62	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Silent, 1
  00b6c	e8 00 00 00 00	 call	 _DoUninstall

; 1980 : 
; 1981 : 			bUninstall = FALSE;
; 1982 : 			Rollback = FALSE;
; 1983 : 			Silent = FALSE;
; 1984 : 
; 1985 : 			StatusMessage (hwndDlg, "ROLLBACK");

  00b71	68 00 00 00 00	 push	 OFFSET ??_C@_08COBEBGNM@ROLLBACK?$AA@
  00b76	57		 push	 edi
  00b77	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00b81	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Rollback, 0
  00b8b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Silent, 0
  00b95	e8 00 00 00 00	 call	 _StatusMessage
  00b9a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1986 : 		}
; 1987 : 		else

  00b9d	eb 0d		 jmp	 SHORT $outcome$1251
$LN47@DoInstall:

; 1988 : 		{
; 1989 : 			Warning ("SYS_ENC_UPGRADE_FAILED");

  00b9f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FAKCOHIL@SYS_ENC_UPGRADE_FAILED?$AA@
  00ba4	e8 00 00 00 00	 call	 _Warning
  00ba9	83 c4 04	 add	 esp, 4
$outcome$1251:

; 1990 : 		}
; 1991 : 	}
; 1992 : 
; 1993 : outcome:
; 1994 : 	OutcomePrompt (hwndDlg, bOK);

  00bac	53		 push	 ebx
  00bad	57		 push	 edi
  00bae	e8 00 00 00 00	 call	 _OutcomePrompt
  00bb3	83 c4 08	 add	 esp, 8

; 1995 : 
; 1996 : 	if (bOK && !bUninstall && !bDowngrade && !bRepairMode && !bDevm)

  00bb6	85 db		 test	 ebx, ebx
  00bb8	0f 84 8a 00 00
	00		 je	 $LN56@DoInstall
  00bbe	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00bc5	0f 85 7d 00 00
	00		 jne	 $LN56@DoInstall
  00bcb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDowngrade@@3HA, 0 ; bDowngrade
  00bd2	75 74		 jne	 SHORT $LN56@DoInstall
  00bd4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRepairMode, 0
  00bdb	75 6b		 jne	 SHORT $LN56@DoInstall
  00bdd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  00be4	75 62		 jne	 SHORT $LN56@DoInstall

; 1997 : 	{
; 1998 : 		if (!IsHiddenOSRunning())	// A hidden OS user should not see the post-install notes twice (on decoy OS and then on hidden OS).

  00be6	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  00beb	85 c0		 test	 eax, eax
  00bed	75 59		 jne	 SHORT $LN56@DoInstall

; 1999 : 		{
; 2000 : 			if (bRestartRequired || SystemEncryptionUpdate)

  00bef	39 05 00 00 00
	00		 cmp	 DWORD PTR _bRestartRequired, eax
  00bf5	75 31		 jne	 SHORT $LN53@DoInstall
  00bf7	39 05 00 00 00
	00		 cmp	 DWORD PTR _SystemEncryptionUpdate, eax
  00bfd	75 29		 jne	 SHORT $LN53@DoInstall

; 2011 : 				}
; 2012 : 			}
; 2013 : 			else
; 2014 : 			{
; 2015 : 				// No restart will be required
; 2016 : 
; 2017 : 				if (bUpgrade)

  00bff	39 05 00 00 00
	00		 cmp	 DWORD PTR _bUpgrade, eax
  00c05	74 0c		 je	 SHORT $LN57@DoInstall

; 2018 : 				{
; 2019 : 					bPromptReleaseNotes = TRUE;

  00c07	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bPromptReleaseNotes, 1
  00c11	eb 35		 jmp	 SHORT $LN56@DoInstall
$LN57@DoInstall:

; 2020 : 				}
; 2021 : 				else if (bPossiblyFirstTimeInstall)

  00c13	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bPossiblyFirstTimeInstall, 0
  00c1a	74 2c		 je	 SHORT $LN56@DoInstall

; 2022 : 				{
; 2023 : 					bPromptTutorial = TRUE;

  00c1c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bPromptTutorial, 1
  00c26	eb 20		 jmp	 SHORT $LN56@DoInstall
$LN53@DoInstall:

; 2001 : 			{
; 2002 : 				// Restart required
; 2003 : 
; 2004 : 				if (bUpgrade)

  00c28	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  00c2f	74 04		 je	 SHORT $LN54@DoInstall

; 2005 : 				{
; 2006 : 					SavePostInstallTasksSettings (GST_POST_INSTALL_CFG_RELEASE_NOTES);

  00c31	6a 02		 push	 2
  00c33	eb 0b		 jmp	 SHORT $LN1249@DoInstall
$LN54@DoInstall:

; 2007 : 				}
; 2008 : 				else if (bPossiblyFirstTimeInstall)

  00c35	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bPossiblyFirstTimeInstall, 0
  00c3c	74 0a		 je	 SHORT $LN56@DoInstall

; 2009 : 				{
; 2010 : 					SavePostInstallTasksSettings (GST_POST_INSTALL_CFG_TUTORIAL);

  00c3e	6a 01		 push	 1
$LN1249@DoInstall:
  00c40	e8 00 00 00 00	 call	 _SavePostInstallTasksSettings
  00c45	83 c4 04	 add	 esp, 4
$LN56@DoInstall:

; 2024 : 				}
; 2025 : 			}
; 2026 : 		}
; 2027 : 	}
; 2028 : 
; 2029 : 	PostMessage (MainDlg, bOK ? GST_APPMSG_INSTALL_SUCCESS : GST_APPMSG_INSTALL_FAILURE, 0, 0);

  00c48	6a 00		 push	 0
  00c4a	85 db		 test	 ebx, ebx
  00c4c	b8 94 81 00 00	 mov	 eax, 33172		; 00008194H
  00c51	b9 91 81 00 00	 mov	 ecx, 33169		; 00008191H
  00c56	6a 00		 push	 0
  00c58	0f 45 c1	 cmovne	 eax, ecx
  00c5b	50		 push	 eax
$LN1246@DoInstall:
  00c5c	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00c62	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 2030 : }

  00c68	8d 8d 00 f6 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00c6e	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  00c73	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00c76	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00c7d	59		 pop	 ecx
  00c7e	5f		 pop	 edi
  00c7f	5e		 pop	 esi
  00c80	5b		 pop	 ebx
  00c81	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c84	33 cd		 xor	 ecx, ebp
  00c86	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c8b	8b e5		 mov	 esp, ebp
  00c8d	5d		 pop	 ebp
  00c8e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_DoInstall$9:
  00000	8d 8d 00 f6 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__unwindfunclet$_DoInstall$10:
  0000b	8b 85 f4 f5 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00011	83 e0 01	 and	 eax, 1
  00014	0f 84 12 00 00
	00		 je	 $LN76@DoInstall
  0001a	83 a5 f4 f5 ff
	ff fe		 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00021	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN76@DoInstall:
  0002c	c3		 ret	 0
__unwindfunclet$_DoInstall$11:
  0002d	8b 85 f4 f5 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00033	83 e0 02	 and	 eax, 2
  00036	0f 84 12 00 00
	00		 je	 $LN78@DoInstall
  0003c	83 a5 f4 f5 ff
	ff fd		 and	 DWORD PTR $T3[ebp], -3	; fffffffdH
  00043	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00049	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN78@DoInstall:
  0004e	c3		 ret	 0
__unwindfunclet$_DoInstall$12:
  0004f	8b 85 f4 f5 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00055	83 e0 04	 and	 eax, 4
  00058	0f 84 12 00 00
	00		 je	 $LN80@DoInstall
  0005e	83 a5 f4 f5 ff
	ff fb		 and	 DWORD PTR $T3[ebp], -5	; fffffffbH
  00065	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0006b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN80@DoInstall:
  00070	c3		 ret	 0
__unwindfunclet$_DoInstall$13:
  00071	8b 85 f4 f5 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00077	83 e0 08	 and	 eax, 8
  0007a	0f 84 12 00 00
	00		 je	 $LN82@DoInstall
  00080	83 a5 f4 f5 ff
	ff f7		 and	 DWORD PTR $T3[ebp], -9	; fffffff7H
  00087	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0008d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN82@DoInstall:
  00092	c3		 ret	 0
__unwindfunclet$_DoInstall$14:
  00093	8b 85 f4 f5 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00099	83 e0 10	 and	 eax, 16			; 00000010H
  0009c	0f 84 12 00 00
	00		 je	 $LN84@DoInstall
  000a2	83 a5 f4 f5 ff
	ff ef		 and	 DWORD PTR $T3[ebp], -17	; ffffffefH
  000a9	8d 8d 28 fc ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  000af	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN84@DoInstall:
  000b4	c3		 ret	 0
__unwindfunclet$_DoInstall$15:
  000b5	8b 85 f4 f5 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  000bb	83 e0 20	 and	 eax, 32			; 00000020H
  000be	0f 84 12 00 00
	00		 je	 $LN86@DoInstall
  000c4	83 a5 f4 f5 ff
	ff df		 and	 DWORD PTR $T3[ebp], -33	; ffffffdfH
  000cb	8d 8d 40 fc ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  000d1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN86@DoInstall:
  000d6	c3		 ret	 0
__unwindfunclet$_DoInstall$16:
  000d7	8b 85 f4 f5 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  000dd	83 e0 40	 and	 eax, 64			; 00000040H
  000e0	0f 84 12 00 00
	00		 je	 $LN88@DoInstall
  000e6	83 a5 f4 f5 ff
	ff bf		 and	 DWORD PTR $T3[ebp], -65	; ffffffbfH
  000ed	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  000f3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN88@DoInstall:
  000f8	c3		 ret	 0
__unwindfunclet$_DoInstall$17:
  000f9	8b 85 f4 f5 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  000ff	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00104	0f 84 15 00 00
	00		 je	 $LN90@DoInstall
  0010a	81 a5 f4 f5 ff
	ff 7f ff ff ff	 and	 DWORD PTR $T3[ebp], -129 ; ffffff7fH
  00114	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  0011a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN90@DoInstall:
  0011f	c3		 ret	 0
__unwindfunclet$_DoInstall$19:
  00120	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR _favorites$16[ebp]
  00126	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_DoInstall$20:
  0012b	8d 8d 70 fc ff
	ff		 lea	 ecx, DWORD PTR _sysFavorites$13[ebp]
  00131	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$_DoInstall:
  00136	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0013a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0013d	8b 8a e0 f5 ff
	ff		 mov	 ecx, DWORD PTR [edx-2592]
  00143	33 c8		 xor	 ecx, eax
  00145	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0014d	33 c8		 xor	 ecx, eax
  0014f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00154	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_DoInstall
  00159	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_DoInstall ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _DoUninstall
_TEXT	SEGMENT
_bTempSkipSysRestore$1$ = -268				; size = 4
_temp$1 = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_arg$ = 8						; size = 4
_DoUninstall PROC					; COMDAT

; 1638 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1639 : 	HWND hwndDlg = (HWND) arg;
; 1640 : 	BOOL bOK = TRUE;
; 1641 : 	BOOL bTempSkipSysRestore = FALSE;
; 1642 : 
; 1643 : 	if (!Rollback)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0001a	53		 push	 ebx
  0001b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _arg$[ebp]
  00025	57		 push	 edi
  00026	bf 01 00 00 00	 mov	 edi, 1
  0002b	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bTempSkipSysRestore$1$[ebp], 0
  00035	75 11		 jne	 SHORT $LN2@DoUninstal

; 1644 : 		EnableWindow (GetDlgItem ((HWND) hwndDlg, IDC_UNINSTALL), FALSE);

  00037	6a 00		 push	 0
  00039	68 f7 03 00 00	 push	 1015			; 000003f7H
  0003e	56		 push	 esi
  0003f	ff d3		 call	 ebx
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
$LN2@DoUninstal:

; 1645 : 
; 1646 : 	WaitCursor ();

  00048	e8 00 00 00 00	 call	 _WaitCursor

; 1647 : 
; 1648 : 	if (!Rollback)

  0004d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00054	75 18		 jne	 SHORT $LN3@DoUninstal

; 1649 : 	{
; 1650 : 		ClearLogWindow (hwndDlg);

  00056	6a 00		 push	 0
  00058	6a 00		 push	 0
  0005a	68 84 01 00 00	 push	 388			; 00000184H
  0005f	68 f9 03 00 00	 push	 1017			; 000003f9H
  00064	56		 push	 esi
  00065	ff d3		 call	 ebx
  00067	50		 push	 eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN3@DoUninstal:

; 1651 : 	}
; 1652 : 
; 1653 : 	if (DoDriverUnload (hwndDlg) == FALSE)

  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 _DoDriverUnload
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 11		 jne	 SHORT $LN4@DoUninstal

; 1654 : 	{
; 1655 : 		bOK = FALSE;

  0007b	33 ff		 xor	 edi, edi

; 1656 : 		bTempSkipSysRestore = TRUE;		// Volumes are possibly mounted; defer System Restore point creation for this uninstall attempt.

  0007d	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _bTempSkipSysRestore$1$[ebp], 1

; 1657 : 	}
; 1658 : 	else

  00087	e9 33 01 00 00	 jmp	 $LN18@DoUninstal
$LN4@DoUninstal:

; 1659 : 	{
; 1660 : 		if (!Rollback && bSystemRestore && !bTempSkipSysRestore)

  0008c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00093	75 14		 jne	 SHORT $LN6@DoUninstal
  00095	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bSystemRestore, 0
  0009c	74 0b		 je	 SHORT $LN6@DoUninstal

; 1661 : 			SetSystemRestorePoint (hwndDlg, FALSE);

  0009e	6a 00		 push	 0
  000a0	56		 push	 esi
  000a1	e8 00 00 00 00	 call	 ?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z ; SetSystemRestorePoint
  000a6	83 c4 08	 add	 esp, 8
$LN6@DoUninstal:

; 1662 : 
; 1663 : 		if (DoServiceUninstall (hwndDlg, "gostcrypt") == FALSE)

  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_09JCILFBFB@gostcrypt?$AA@
  000ae	56		 push	 esi
  000af	e8 00 00 00 00	 call	 _DoServiceUninstall
  000b4	83 c4 08	 add	 esp, 8
  000b7	85 c0		 test	 eax, eax
  000b9	75 07		 jne	 SHORT $LN7@DoUninstal

; 1664 : 		{
; 1665 : 			bOK = FALSE;

  000bb	33 ff		 xor	 edi, edi
  000bd	e9 fd 00 00 00	 jmp	 $LN18@DoUninstal
$LN7@DoUninstal:

; 1666 : 		}
; 1667 : 		else if (DoRegUninstall ((HWND) hwndDlg, FALSE) == FALSE)

  000c2	6a 00		 push	 0
  000c4	56		 push	 esi
  000c5	e8 00 00 00 00	 call	 _DoRegUninstall
  000ca	83 c4 08	 add	 esp, 8
  000cd	85 c0		 test	 eax, eax
  000cf	75 07		 jne	 SHORT $LN9@DoUninstal

; 1668 : 		{
; 1669 : 			bOK = FALSE;

  000d1	33 ff		 xor	 edi, edi
  000d3	e9 e7 00 00 00	 jmp	 $LN18@DoUninstal
$LN9@DoUninstal:

; 1670 : 		}
; 1671 : 		else if (DoFilesInstall ((HWND) hwndDlg, InstallationPath) == FALSE)

  000d8	68 00 00 00 00	 push	 OFFSET _InstallationPath
  000dd	56		 push	 esi
  000de	e8 00 00 00 00	 call	 _DoFilesInstall
  000e3	83 c4 08	 add	 esp, 8
  000e6	85 c0		 test	 eax, eax
  000e8	75 07		 jne	 SHORT $LN11@DoUninstal

; 1672 : 		{
; 1673 : 			bOK = FALSE;

  000ea	33 ff		 xor	 edi, edi
  000ec	e9 ce 00 00 00	 jmp	 $LN18@DoUninstal
$LN11@DoUninstal:

; 1674 : 		}
; 1675 : 		else if (DoShortcutsUninstall (hwndDlg, InstallationPath) == FALSE)

  000f1	68 00 00 00 00	 push	 OFFSET _InstallationPath
  000f6	56		 push	 esi
  000f7	e8 00 00 00 00	 call	 _DoShortcutsUninstall
  000fc	83 c4 08	 add	 esp, 8
  000ff	85 c0		 test	 eax, eax
  00101	75 07		 jne	 SHORT $LN13@DoUninstal

; 1676 : 		{
; 1677 : 			bOK = FALSE;

  00103	33 ff		 xor	 edi, edi
  00105	e9 b5 00 00 00	 jmp	 $LN18@DoUninstal
$LN13@DoUninstal:

; 1678 : 		}
; 1679 : 		else if (!DoApplicationDataUninstall (hwndDlg))

  0010a	56		 push	 esi
  0010b	e8 00 00 00 00	 call	 ?DoApplicationDataUninstall@@YAHPAUHWND__@@@Z ; DoApplicationDataUninstall
  00110	83 c4 04	 add	 esp, 4
  00113	85 c0		 test	 eax, eax
  00115	75 07		 jne	 SHORT $LN15@DoUninstal

; 1680 : 		{
; 1681 : 			bOK = FALSE;

  00117	33 ff		 xor	 edi, edi

; 1682 : 		}
; 1683 : 		else

  00119	e9 a1 00 00 00	 jmp	 $LN18@DoUninstal
$LN15@DoUninstal:

; 1684 : 		{
; 1685 : 			char temp[MAX_PATH];
; 1686 : 			FILE *f;
; 1687 : 
; 1688 : 			// Deprecated service
; 1689 : 			DoServiceUninstall (hwndDlg, "GostCryptService");

  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CILIJECC@GostCryptService?$AA@
  00123	56		 push	 esi
  00124	e8 00 00 00 00	 call	 _DoServiceUninstall
  00129	83 c4 08	 add	 esp, 8

; 1690 : 
; 1691 : 			GetTempPath (sizeof (temp), temp);

  0012c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$1[ebp]
  00132	50		 push	 eax
  00133	68 04 01 00 00	 push	 260			; 00000104H
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTempPathA@8

; 1692 : 			_snprintf (UninstallBatch, sizeof (UninstallBatch), "%s\\GostCrypt-Uninstall.bat", temp);

  0013e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$1[ebp]
  00144	50		 push	 eax
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NBOCNBBF@?$CFs?2GostCrypt?9Uninstall?4bat?$AA@
  0014a	68 04 01 00 00	 push	 260			; 00000104H
  0014f	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA
  00154	e8 00 00 00 00	 call	 __snprintf

; 1693 : 
; 1694 : 			UninstallBatch [sizeof(UninstallBatch)-1] = 0;
; 1695 : 
; 1696 : 			// Create uninstall batch
; 1697 : 			f = fopen (UninstallBatch, "w");

  00159	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  0015e	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA
  00163	c6 05 03 01 00
	00 00		 mov	 BYTE PTR ?UninstallBatch@@3PADA+259, 0
  0016a	e8 00 00 00 00	 call	 _fopen
  0016f	8b d8		 mov	 ebx, eax
  00171	83 c4 18	 add	 esp, 24			; 00000018H

; 1698 : 			if (!f)

  00174	85 db		 test	 ebx, ebx
  00176	75 04		 jne	 SHORT $LN17@DoUninstal

; 1699 : 				bOK = FALSE;

  00178	33 ff		 xor	 edi, edi

; 1700 : 			else

  0017a	eb 3d		 jmp	 SHORT $LN28@DoUninstal
$LN17@DoUninstal:

; 1701 : 			{
; 1702 : 				fprintf (f, ":loop\n"

  0017c	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA
  00181	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CHHIEGKC@GostCrypt?5Setup?4exe?$AA@
  0018b	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00190	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CHHIEGKC@GostCrypt?5Setup?4exe?$AA@
  00195	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@MNNFDDNO@?3loop?6del?5?$CC?$CFs?$CFs?$CC?6if?5exist?5?$CC?$CFs?$CFs?$CC@
  0019f	53		 push	 ebx
  001a0	e8 00 00 00 00	 call	 _fprintf

; 1703 : 					"del \"%s%s\"\n"
; 1704 : 					"if exist \"%s%s\" goto loop\n"
; 1705 : 					"rmdir \"%s\"\n"
; 1706 : 					"del \"%s\"",
; 1707 : 					InstallationPath, "GostCrypt Setup.exe",
; 1708 : 					InstallationPath, "GostCrypt Setup.exe",
; 1709 : 					InstallationPath,
; 1710 : 					UninstallBatch
; 1711 : 					);
; 1712 : 
; 1713 : 				CheckFileStreamWriteErrors (f, UninstallBatch);

  001a5	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA
  001aa	53		 push	 ebx
  001ab	e8 00 00 00 00	 call	 _CheckFileStreamWriteErrors

; 1714 : 				fclose (f);

  001b0	53		 push	 ebx
  001b1	e8 00 00 00 00	 call	 _fclose
  001b6	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN28@DoUninstal:
  001b9	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetDlgItem@8
$LN18@DoUninstal:

; 1715 : 			}
; 1716 : 		}
; 1717 : 	}
; 1718 : 
; 1719 : 	NormalCursor ();

  001bf	e8 00 00 00 00	 call	 _NormalCursor

; 1720 : 
; 1721 : 	if (Rollback)

  001c4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  001cb	75 58		 jne	 SHORT $LN1@DoUninstal

; 1722 : 		return;
; 1723 : 
; 1724 : 	if (bSystemRestore && !bTempSkipSysRestore)

  001cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bSystemRestore, 0
  001d4	74 14		 je	 SHORT $LN20@DoUninstal
  001d6	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _bTempSkipSysRestore$1$[ebp], 0
  001dd	75 0b		 jne	 SHORT $LN20@DoUninstal

; 1725 : 		SetSystemRestorePoint (hwndDlg, TRUE);

  001df	6a 01		 push	 1
  001e1	56		 push	 esi
  001e2	e8 00 00 00 00	 call	 ?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z ; SetSystemRestorePoint
  001e7	83 c4 08	 add	 esp, 8
$LN20@DoUninstal:
  001ea	85 ff		 test	 edi, edi

; 1726 : 
; 1727 : 	if (bOK)

  001ec	74 12		 je	 SHORT $LN21@DoUninstal

; 1728 : 		PostMessage (hwndDlg, GST_APPMSG_UNINSTALL_SUCCESS, 0, 0);

  001ee	6a 00		 push	 0
  001f0	6a 00		 push	 0
  001f2	68 92 81 00 00	 push	 33170			; 00008192H
  001f7	56		 push	 esi
  001f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 1729 : 	else

  001fe	eb 0a		 jmp	 SHORT $LN22@DoUninstal
$LN21@DoUninstal:

; 1730 : 		bUninstallInProgress = FALSE;

  00200	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bUninstallInProgress@@3HA, 0 ; bUninstallInProgress
$LN22@DoUninstal:

; 1731 : 
; 1732 : 	EnableWindow (GetDlgItem ((HWND) hwndDlg, IDC_UNINSTALL), TRUE);

  0020a	6a 01		 push	 1
  0020c	68 f7 03 00 00	 push	 1015			; 000003f7H
  00211	56		 push	 esi
  00212	ff d3		 call	 ebx
  00214	50		 push	 eax
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1733 : 	OutcomePrompt (hwndDlg, bOK);

  0021b	57		 push	 edi
  0021c	56		 push	 esi
  0021d	e8 00 00 00 00	 call	 _OutcomePrompt
  00222	83 c4 08	 add	 esp, 8
$LN1@DoUninstal:

; 1734 : }

  00225	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00228	5f		 pop	 edi
  00229	5e		 pop	 esi
  0022a	33 cd		 xor	 ecx, ebp
  0022c	5b		 pop	 ebx
  0022d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00232	8b e5		 mov	 esp, ebp
  00234	5d		 pop	 ebp
  00235	c3		 ret	 0
_DoUninstall ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _OutcomePrompt
_TEXT	SEGMENT
_str$1 = -8196						; size = 8192
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_bOK$ = 12						; size = 4
_OutcomePrompt PROC					; COMDAT

; 1542 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 20 00 00	 mov	 eax, 8196		; 00002004H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1543 : 	if (bOK)

  00017	83 7d 0c 00	 cmp	 DWORD PTR _bOK$[ebp], 0
  0001b	56		 push	 esi
  0001c	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]
  0001f	0f 84 f6 00 00
	00		 je	 $LN2@OutcomePro

; 1544 : 	{
; 1545 : 		EnableWindow (GetDlgItem ((HWND) hwndDlg, IDCANCEL), FALSE);

  00025	6a 00		 push	 0
  00027	6a 02		 push	 2
  00029	56		 push	 esi
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1546 : 
; 1547 : 		bDone = TRUE;
; 1548 : 
; 1549 : 		if (bUninstall == FALSE)

  00037	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  0003e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDone@@3HA, 1 ; bDone
  00048	0f 85 86 00 00
	00		 jne	 $LN4@OutcomePro

; 1550 : 		{
; 1551 : 			if (bDevm)

  0004e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  00055	74 21		 je	 SHORT $LN6@OutcomePro

; 1552 : 				PostMessage (MainDlg, WM_CLOSE, 0, 0);

  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	6a 10		 push	 16			; 00000010H
  0005d	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
  00069	5e		 pop	 esi

; 1572 : 	}
; 1573 : }

  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
$LN6@OutcomePro:

; 1553 : 			else if (bPossiblyFirstTimeInstall || bRepairMode || (!bUpgrade && !bDowngrade))

  00078	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bPossiblyFirstTimeInstall, 0
  0007f	75 37		 jne	 SHORT $LN10@OutcomePro
  00081	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRepairMode, 0
  00088	75 2e		 jne	 SHORT $LN10@OutcomePro
  0008a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  00091	75 09		 jne	 SHORT $LN8@OutcomePro
  00093	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDowngrade@@3HA, 0 ; bDowngrade
  0009a	74 1c		 je	 SHORT $LN10@OutcomePro
$LN8@OutcomePro:

; 1555 : 			else
; 1556 : 				Info ("SETUP_UPDATE_OK");

  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GIHLNOHP@SETUP_UPDATE_OK?$AA@
  000a1	e8 00 00 00 00	 call	 _Info

; 1571 : 			Error ("UNINSTALL_FAILED");

  000a6	83 c4 04	 add	 esp, 4
  000a9	5e		 pop	 esi

; 1572 : 	}
; 1573 : }

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	33 cd		 xor	 ecx, ebp
  000af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
$LN10@OutcomePro:

; 1554 : 				Info ("INSTALL_OK");

  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NPHNJMLA@INSTALL_OK?$AA@
  000bd	e8 00 00 00 00	 call	 _Info

; 1571 : 			Error ("UNINSTALL_FAILED");

  000c2	83 c4 04	 add	 esp, 4
  000c5	5e		 pop	 esi

; 1572 : 	}
; 1573 : }

  000c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c9	33 cd		 xor	 ecx, ebp
  000cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN4@OutcomePro:

; 1557 : 		}
; 1558 : 		else
; 1559 : 		{
; 1560 : 			wchar_t str[4096];
; 1561 : 
; 1562 : 			swprintf (str, GetString ("UNINSTALL_OK"), InstallationPath);

  000d4	68 00 00 00 00	 push	 OFFSET _InstallationPath
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HGHJILFC@UNINSTALL_OK?$AA@
  000de	e8 00 00 00 00	 call	 _GetString
  000e3	83 c4 04	 add	 esp, 4
  000e6	50		 push	 eax
  000e7	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _str$1[ebp]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ?swprintf@@YAHQA_WQB_WZZ ; swprintf
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1563 : 			MessageBoxW (hwndDlg, str, lpszTitle, MB_ICONASTERISK);

  000f6	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _str$1[ebp]
  000fc	6a 40		 push	 64			; 00000040H
  000fe	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00104	50		 push	 eax
  00105	56		 push	 esi
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  0010c	5e		 pop	 esi

; 1572 : 	}
; 1573 : }

  0010d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00110	33 cd		 xor	 ecx, ebp
  00112	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
$LN2@OutcomePro:

; 1564 : 		}
; 1565 : 	}
; 1566 : 	else
; 1567 : 	{
; 1568 : 		if (bUninstall == FALSE)

  0011b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00122	75 07		 jne	 SHORT $LN11@OutcomePro

; 1569 : 			Error ("INSTALL_FAILED");

  00124	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@

; 1570 : 		else

  00129	eb 05		 jmp	 SHORT $LN15@OutcomePro
$LN11@OutcomePro:

; 1571 : 			Error ("UNINSTALL_FAILED");

  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JJJJFLNM@UNINSTALL_FAILED?$AA@
$LN15@OutcomePro:
  00130	e8 00 00 00 00	 call	 _Error

; 1572 : 	}
; 1573 : }

  00135	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00138	83 c4 04	 add	 esp, 4
  0013b	33 cd		 xor	 ecx, ebp
  0013d	5e		 pop	 esi
  0013e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c3		 ret	 0
_OutcomePrompt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _DoShortcutsUninstall
_TEXT	SEGMENT
_bOK$1$ = -848						; size = 4
_allUsers$1$ = -844					; size = 4
_st$1 = -840						; size = 56
_st$2 = -840						; size = 56
_st$3 = -840						; size = 56
_st$4 = -840						; size = 56
_st$5 = -840						; size = 56
_st$6 = -832						; size = 48
_path$7 = -784						; size = 260
_szLinkDir$ = -524					; size = 260
_szTmp2$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_DoShortcutsUninstall PROC				; COMDAT

; 1318 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 03 00
	00		 sub	 esp, 848		; 00000350H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]
  00018	57		 push	 edi

; 1319 : 	char szLinkDir[GST_MAX_PATH];
; 1320 : 	char szTmp2[GST_MAX_PATH];
; 1321 : 	BOOL bSlash, bOK = FALSE;
; 1322 : 	HRESULT hOle;
; 1323 : 	int x;
; 1324 : 	BOOL allUsers = FALSE;
; 1325 : 
; 1326 : 	hOle = OleInitialize (NULL);

  00019	6a 00		 push	 0
  0001b	c7 85 b0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _bOK$1$[ebp], 0
  00025	c7 85 b4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _allUsers$1$[ebp], 0
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleInitialize@4

; 1327 : 
; 1328 : 	// User start menu
; 1329 :     SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_PROGRAMS, 0);

  00035	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SHGetSpecialFolderPathA@16
  0003b	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  00041	6a 00		 push	 0
  00043	6a 02		 push	 2
  00045	50		 push	 eax
  00046	56		 push	 esi
  00047	ff d3		 call	 ebx

; 1330 : 	x = strlen (szLinkDir);

  00049	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _szLinkDir$[ebp]
  0004f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL61@DoShortcut:
  00052	8a 01		 mov	 al, BYTE PTR [ecx]
  00054	41		 inc	 ecx
  00055	84 c0		 test	 al, al
  00057	75 f9		 jne	 SHORT $LL61@DoShortcut
  00059	2b ca		 sub	 ecx, edx
  0005b	80 bc 0d f3 fd
	ff ff 5c	 cmp	 BYTE PTR _szLinkDir$[ebp+ecx-1], 92 ; 0000005cH

; 1331 : 	if (szLinkDir[x - 1] == '\\')
; 1332 : 		bSlash = TRUE;
; 1333 : 	else
; 1334 : 		bSlash = FALSE;
; 1335 : 
; 1336 : 	if (bSlash == FALSE)

  00063	74 1e		 je	 SHORT $LN4@DoShortcut

; 1337 : 		strcat (szLinkDir, "\\");

  00065	8d bd f4 fd ff
	ff		 lea	 edi, DWORD PTR _szLinkDir$[ebp]
  0006b	4f		 dec	 edi
  0006c	0f 1f 40 00	 npad	 4
$LL62@DoShortcut:
  00070	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00073	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00076	84 c0		 test	 al, al
  00078	75 f6		 jne	 SHORT $LL62@DoShortcut
  0007a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  00080	66 89 07	 mov	 WORD PTR [edi], ax
$LN4@DoShortcut:

; 1338 : 
; 1339 : 	strcat (szLinkDir, "GostCrypt");

  00083	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _szLinkDir$[ebp]
  00089	49		 dec	 ecx
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL63@DoShortcut:
  00090	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00093	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00096	84 c0		 test	 al, al
  00098	75 f6		 jne	 SHORT $LL63@DoShortcut
  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@
  0009f	89 01		 mov	 DWORD PTR [ecx], eax
  000a1	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@+4
  000a6	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000a9	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@+8

; 1340 : 
; 1341 : 	// Global start menu
; 1342 : 	{
; 1343 : 		struct _stat st;
; 1344 : 		char path[GST_MAX_PATH];
; 1345 : 
; 1346 : 		SHGetSpecialFolderPath (hwndDlg, path, CSIDL_COMMON_PROGRAMS, 0);

  000af	6a 00		 push	 0
  000b1	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  000b5	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _path$7[ebp]
  000bb	6a 17		 push	 23			; 00000017H
  000bd	50		 push	 eax
  000be	56		 push	 esi
  000bf	ff d3		 call	 ebx

; 1347 : 		strcat (path, "\\GostCrypt");

  000c1	8d 8d f0 fc ff
	ff		 lea	 ecx, DWORD PTR _path$7[ebp]
  000c7	49		 dec	 ecx
$LL64@DoShortcut:
  000c8	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000cb	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000ce	84 c0		 test	 al, al
  000d0	75 f6		 jne	 SHORT $LL64@DoShortcut
  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@
  000d7	89 01		 mov	 DWORD PTR [ecx], eax
  000d9	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@+4
  000de	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000e1	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@+8
  000e7	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  000eb	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@+10
  000f0	88 41 0a	 mov	 BYTE PTR [ecx+10], al

; 1348 : 
; 1349 : 		if (_stat (path, &st) == 0)

  000f3	8d 85 c0 fc ff
	ff		 lea	 eax, DWORD PTR _st$6[ebp]
  000f9	50		 push	 eax
  000fa	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _path$7[ebp]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 __stat64i32
  00106	83 c4 08	 add	 esp, 8
  00109	85 c0		 test	 eax, eax
  0010b	75 22		 jne	 SHORT $LN5@DoShortcut

; 1350 : 		{
; 1351 : 			strcpy (szLinkDir, path);

  0010d	33 c9		 xor	 ecx, ecx
  0010f	90		 npad	 1
$LL18@DoShortcut:
  00110	8a 84 0d f0 fc
	ff ff		 mov	 al, BYTE PTR _path$7[ebp+ecx]
  00117	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0011a	88 84 0d f3 fd
	ff ff		 mov	 BYTE PTR _szLinkDir$[ebp+ecx-1], al
  00121	84 c0		 test	 al, al
  00123	75 eb		 jne	 SHORT $LL18@DoShortcut

; 1352 : 			allUsers = TRUE;

  00125	c7 85 b4 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _allUsers$1$[ebp], 1
$LN5@DoShortcut:

; 1353 : 		}
; 1354 : 	}
; 1355 : 
; 1356 : 	// Start menu entries
; 1357 : 	sprintf (szTmp2, "%s%s", szLinkDir, "\\GostCrypt.lnk");

  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FMMFFOMO@?2GostCrypt?4lnk?$AA@
  00134	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  0013a	50		 push	 eax
  0013b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 _sprintf
  0014c	83 c4 10	 add	 esp, 16			; 00000010H

; 1358 : 	RemoveMessage (hwndDlg, szTmp2);

  0014f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00156	75 15		 jne	 SHORT $LN20@DoShortcut
  00158	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  0015e	50		 push	 eax
  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00164	56		 push	 esi
  00165	e8 00 00 00 00	 call	 _StatusMessageParam
  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@DoShortcut:

; 1359 : 	if (StatDeleteFile (szTmp2) == FALSE)

  0016d	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _st$5[ebp]
  00173	50		 push	 eax
  00174	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 __stat64
  00180	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__DeleteFileA@4
  00186	83 c4 08	 add	 esp, 8
  00189	85 c0		 test	 eax, eax
  0018b	75 11		 jne	 SHORT $LN57@DoShortcut
  0018d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00193	50		 push	 eax
  00194	ff d7		 call	 edi
  00196	85 c0		 test	 eax, eax
  00198	0f 84 d7 01 00
	00		 je	 $error$67
$LN57@DoShortcut:

; 1360 : 		goto error;
; 1361 : 
; 1362 : 	sprintf (szTmp2, "%s%s", szLinkDir, "\\GostCrypt Website.url");

  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BKNACPBJ@?2GostCrypt?5Website?4url?$AA@
  001a3	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  001a9	50		 push	 eax
  001aa	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 _sprintf
  001bb	83 c4 10	 add	 esp, 16			; 00000010H

; 1363 : 	RemoveMessage (hwndDlg, szTmp2);

  001be	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  001c5	75 15		 jne	 SHORT $LN27@DoShortcut
  001c7	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  001cd	50		 push	 eax
  001ce	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  001d3	56		 push	 esi
  001d4	e8 00 00 00 00	 call	 _StatusMessageParam
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@DoShortcut:

; 1364 : 	if (StatDeleteFile (szTmp2) == FALSE)

  001dc	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _st$4[ebp]
  001e2	50		 push	 eax
  001e3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 __stat64
  001ef	83 c4 08	 add	 esp, 8
  001f2	85 c0		 test	 eax, eax
  001f4	75 11		 jne	 SHORT $LN58@DoShortcut
  001f6	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  001fc	50		 push	 eax
  001fd	ff d7		 call	 edi
  001ff	85 c0		 test	 eax, eax
  00201	0f 84 6e 01 00
	00		 je	 $error$67
$LN58@DoShortcut:

; 1365 : 		goto error;
; 1366 : 
; 1367 : 	sprintf (szTmp2, "%s%s", szLinkDir, "\\Uninstall GostCrypt.lnk");

  00207	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JDKCCNOL@?2Uninstall?5GostCrypt?4lnk?$AA@
  0020c	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  00212	50		 push	 eax
  00213	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00219	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _sprintf
  00224	83 c4 10	 add	 esp, 16			; 00000010H

; 1368 : 	RemoveMessage (hwndDlg, szTmp2);

  00227	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0022e	75 15		 jne	 SHORT $LN34@DoShortcut
  00230	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00236	50		 push	 eax
  00237	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  0023c	56		 push	 esi
  0023d	e8 00 00 00 00	 call	 _StatusMessageParam
  00242	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@DoShortcut:

; 1369 : 	if (StatDeleteFile (szTmp2) == FALSE)

  00245	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _st$3[ebp]
  0024b	50		 push	 eax
  0024c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 __stat64
  00258	83 c4 08	 add	 esp, 8
  0025b	85 c0		 test	 eax, eax
  0025d	75 11		 jne	 SHORT $LN59@DoShortcut
  0025f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00265	50		 push	 eax
  00266	ff d7		 call	 edi
  00268	85 c0		 test	 eax, eax
  0026a	0f 84 05 01 00
	00		 je	 $error$67
$LN59@DoShortcut:

; 1370 : 		goto error;
; 1371 : 	
; 1372 : 	sprintf (szTmp2, "%s%s", szLinkDir, "\\GostCrypt User's Guide.lnk");

  00270	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PHNJDCEJ@?2GostCrypt?5User?8s?5Guide?4lnk?$AA@
  00275	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  0027b	50		 push	 eax
  0027c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00282	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00287	50		 push	 eax
  00288	e8 00 00 00 00	 call	 _sprintf
  0028d	83 c4 10	 add	 esp, 16			; 00000010H

; 1373 : 	DeleteFile (szTmp2);

  00290	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00296	50		 push	 eax
  00297	ff d7		 call	 edi

; 1374 : 
; 1375 : 	// Start menu group
; 1376 : 	RemoveMessage ((HWND) hwndDlg, szLinkDir);

  00299	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  002a0	75 15		 jne	 SHORT $LN41@DoShortcut
  002a2	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  002a8	50		 push	 eax
  002a9	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  002ae	56		 push	 esi
  002af	e8 00 00 00 00	 call	 _StatusMessageParam
  002b4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@DoShortcut:

; 1377 : 	if (StatRemoveDirectory (szLinkDir) == FALSE)

  002b7	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _st$2[ebp]
  002bd	50		 push	 eax
  002be	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  002c4	50		 push	 eax
  002c5	e8 00 00 00 00	 call	 __stat64
  002ca	83 c4 08	 add	 esp, 8
  002cd	85 c0		 test	 eax, eax
  002cf	75 1a		 jne	 SHORT $LN12@DoShortcut
  002d1	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  002d7	50		 push	 eax
  002d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RemoveDirectoryA@4
  002de	85 c0		 test	 eax, eax
  002e0	75 09		 jne	 SHORT $LN12@DoShortcut

; 1378 : 		handleWin32Error ((HWND) hwndDlg);

  002e2	56		 push	 esi
  002e3	e8 00 00 00 00	 call	 _handleWin32Error
  002e8	83 c4 04	 add	 esp, 4
$LN12@DoShortcut:

; 1379 : 
; 1380 : 	// Desktop icon
; 1381 : 
; 1382 : 	if (allUsers)
; 1383 : 		SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_COMMON_DESKTOPDIRECTORY, 0);

  002eb	83 bd b4 fc ff
	ff 00		 cmp	 DWORD PTR _allUsers$1$[ebp], 0
  002f2	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  002f8	6a 00		 push	 0
  002fa	74 04		 je	 SHORT $LN13@DoShortcut
  002fc	6a 19		 push	 25			; 00000019H

; 1384 : 	else

  002fe	eb 02		 jmp	 SHORT $LN65@DoShortcut
$LN13@DoShortcut:

; 1385 : 		SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_DESKTOPDIRECTORY, 0);

  00300	6a 10		 push	 16			; 00000010H
$LN65@DoShortcut:
  00302	50		 push	 eax
  00303	56		 push	 esi
  00304	ff d3		 call	 ebx

; 1386 : 
; 1387 : 	sprintf (szTmp2, "%s%s", szLinkDir, "\\GostCrypt.lnk");

  00306	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FMMFFOMO@?2GostCrypt?4lnk?$AA@
  0030b	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  00311	50		 push	 eax
  00312	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00318	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0031d	50		 push	 eax
  0031e	e8 00 00 00 00	 call	 _sprintf
  00323	83 c4 10	 add	 esp, 16			; 00000010H

; 1388 : 
; 1389 : 	RemoveMessage (hwndDlg, szTmp2);

  00326	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0032d	75 15		 jne	 SHORT $LN48@DoShortcut
  0032f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00335	50		 push	 eax
  00336	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  0033b	56		 push	 esi
  0033c	e8 00 00 00 00	 call	 _StatusMessageParam
  00341	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN48@DoShortcut:

; 1390 : 	if (StatDeleteFile (szTmp2) == FALSE)

  00344	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _st$1[ebp]
  0034a	50		 push	 eax
  0034b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00351	50		 push	 eax
  00352	e8 00 00 00 00	 call	 __stat64
  00357	83 c4 08	 add	 esp, 8
  0035a	85 c0		 test	 eax, eax
  0035c	75 0d		 jne	 SHORT $LN60@DoShortcut
  0035e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00364	50		 push	 eax
  00365	ff d7		 call	 edi
  00367	85 c0		 test	 eax, eax
  00369	74 0a		 je	 SHORT $error$67
$LN60@DoShortcut:

; 1391 : 		goto error;
; 1392 : 
; 1393 : 	bOK = TRUE;

  0036b	c7 85 b0 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _bOK$1$[ebp], 1
$error$67:

; 1394 : 
; 1395 : error:
; 1396 : 	OleUninitialize ();

  00375	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleUninitialize@0

; 1397 : 
; 1398 : 	return bOK;
; 1399 : }

  0037b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0037e	8b 85 b0 fc ff
	ff		 mov	 eax, DWORD PTR _bOK$1$[ebp]
  00384	33 cd		 xor	 ecx, ebp
  00386	5f		 pop	 edi
  00387	5e		 pop	 esi
  00388	5b		 pop	 ebx
  00389	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038e	8b e5		 mov	 esp, ebp
  00390	5d		 pop	 ebp
  00391	c3		 ret	 0
_DoShortcutsUninstall ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _DoShortcutsInstall
_TEXT	SEGMENT
_bOK$1$ = -1832						; size = 4
tv292 = -1828						; size = 4
_f$1$ = -1828						; size = 4
_i$1 = -1828						; size = 4
_szTmp$2 = -1824					; size = 520
_szTmp3$ = -1304					; size = 260
_szTmp$ = -1044						; size = 260
_szDir$ = -784						; size = 260
_szTmp2$ = -524						; size = 260
_szLinkDir$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_bProgGroup$ = 16					; size = 4
_bDesktopIcon$ = 20					; size = 4
_DoShortcutsInstall PROC				; COMDAT

; 1413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 07 00
	00		 sub	 esp, 1832		; 00000728H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1414 : 	char szLinkDir[GST_MAX_PATH], szDir[GST_MAX_PATH];
; 1415 : 	char szTmp[GST_MAX_PATH], szTmp2[GST_MAX_PATH], szTmp3[GST_MAX_PATH];
; 1416 : 	BOOL bSlash, bOK = FALSE;
; 1417 : 	HRESULT hOle;
; 1418 : 	int x;
; 1419 : 
; 1420 : 	if (bProgGroup == FALSE && bDesktopIcon == FALSE)

  00013	83 7d 10 00	 cmp	 DWORD PTR _bProgGroup$[ebp], 0
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  0001b	c7 85 d8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _bOK$1$[ebp], 0
  00025	75 1a		 jne	 SHORT $LN2@DoShortcut
  00027	83 7d 14 00	 cmp	 DWORD PTR _bDesktopIcon$[ebp], 0
  0002b	75 14		 jne	 SHORT $LN2@DoShortcut

; 1421 : 		return TRUE;

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	5b		 pop	 ebx

; 1527 : 
; 1528 : 	return bOK;
; 1529 : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN2@DoShortcut:

; 1422 : 
; 1423 : 	hOle = OleInitialize (NULL);

  00041	6a 00		 push	 0
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleInitialize@4

; 1424 : 
; 1425 : 	GetProgramPath (hwndDlg, szLinkDir);

  00049	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bForAllUsers, 0
  00050	8d 85 dc f8 ff
	ff		 lea	 eax, DWORD PTR _i$1[ebp]
  00056	50		 push	 eax
  00057	74 04		 je	 SHORT $LN32@DoShortcut
  00059	6a 17		 push	 23			; 00000017H
  0005b	eb 02		 jmp	 SHORT $LN56@DoShortcut
$LN32@DoShortcut:
  0005d	6a 02		 push	 2
$LN56@DoShortcut:
  0005f	53		 push	 ebx
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetSpecialFolderLocation@12
  00066	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  0006c	50		 push	 eax
  0006d	ff b5 dc f8 ff
	ff		 push	 DWORD PTR _i$1[ebp]
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetPathFromIDListA@8

; 1426 : 
; 1427 : 	x = strlen (szLinkDir);

  00079	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szLinkDir$[ebp]
  0007f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL49@DoShortcut:
  00082	8a 01		 mov	 al, BYTE PTR [ecx]
  00084	41		 inc	 ecx
  00085	84 c0		 test	 al, al
  00087	75 f9		 jne	 SHORT $LL49@DoShortcut

; 1428 : 	if (szLinkDir[x - 1] == '\\')
; 1429 : 		bSlash = TRUE;
; 1430 : 	else
; 1431 : 		bSlash = FALSE;
; 1432 : 
; 1433 : 	if (bSlash == FALSE)

  00089	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  0008f	2b ca		 sub	 ecx, edx
  00091	56		 push	 esi
  00092	57		 push	 edi
  00093	80 bc 0d f7 fe
	ff ff 5c	 cmp	 BYTE PTR _szLinkDir$[ebp+ecx-1], 92 ; 0000005cH
  0009b	74 14		 je	 SHORT $LN5@DoShortcut

; 1434 : 		strcat (szLinkDir, "\\");

  0009d	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _szLinkDir$[ebp]
  000a3	4f		 dec	 edi
$LL50@DoShortcut:
  000a4	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000a7	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  000aa	84 c9		 test	 cl, cl
  000ac	75 f6		 jne	 SHORT $LL50@DoShortcut
  000ae	66 89 07	 mov	 WORD PTR [edi], ax
$LN5@DoShortcut:

; 1435 : 
; 1436 : 	strcat (szLinkDir, "GostCrypt");

  000b1	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szLinkDir$[ebp]
  000b7	4a		 dec	 edx
$LL51@DoShortcut:
  000b8	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  000bb	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000be	84 c9		 test	 cl, cl
  000c0	75 f6		 jne	 SHORT $LL51@DoShortcut
  000c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@

; 1437 : 
; 1438 : 	strcpy (szDir, szDestDir);

  000c8	8d b5 f0 fc ff
	ff		 lea	 esi, DWORD PTR _szDir$[ebp]
  000ce	8b 7d 0c	 mov	 edi, DWORD PTR _szDestDir$[ebp]
  000d1	2b f7		 sub	 esi, edi
  000d3	89 0a		 mov	 DWORD PTR [edx], ecx
  000d5	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@+4
  000db	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000de	66 8b 0d 08 00
	00 00		 mov	 cx, WORD PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@+8
  000e5	66 89 4a 08	 mov	 WORD PTR [edx+8], cx
  000e9	8b d7		 mov	 edx, edi
  000eb	0f 1f 44 00 00	 npad	 5
$LL29@DoShortcut:
  000f0	8a 0a		 mov	 cl, BYTE PTR [edx]
  000f2	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000f5	88 4c 16 ff	 mov	 BYTE PTR [esi+edx-1], cl
  000f9	84 c9		 test	 cl, cl
  000fb	75 f3		 jne	 SHORT $LL29@DoShortcut

; 1439 : 	x = strlen (szDestDir);

  000fd	8b d7		 mov	 edx, edi
  000ff	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  00102	89 8d dc f8 ff
	ff		 mov	 DWORD PTR tv292[ebp], ecx
$LL52@DoShortcut:
  00108	8a 0a		 mov	 cl, BYTE PTR [edx]
  0010a	42		 inc	 edx
  0010b	84 c9		 test	 cl, cl
  0010d	75 f9		 jne	 SHORT $LL52@DoShortcut
  0010f	2b 95 dc f8 ff
	ff		 sub	 edx, DWORD PTR tv292[ebp]
  00115	80 7c 3a ff 5c	 cmp	 BYTE PTR [edx+edi-1], 92 ; 0000005cH

; 1440 : 	if (szDestDir[x - 1] == '\\')
; 1441 : 		bSlash = TRUE;
; 1442 : 	else
; 1443 : 		bSlash = FALSE;
; 1444 : 
; 1445 : 	if (bSlash == FALSE)

  0011a	74 17		 je	 SHORT $LN8@DoShortcut

; 1446 : 		strcat (szDir, "\\");

  0011c	8d bd f0 fc ff
	ff		 lea	 edi, DWORD PTR _szDir$[ebp]
  00122	4f		 dec	 edi
$LL53@DoShortcut:
  00123	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00126	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00129	84 c9		 test	 cl, cl
  0012b	75 f6		 jne	 SHORT $LL53@DoShortcut
  0012d	66 89 07	 mov	 WORD PTR [edi], ax
  00130	8b 7d 0c	 mov	 edi, DWORD PTR _szDestDir$[ebp]
$LN8@DoShortcut:

; 1447 : 
; 1448 : 	if (bProgGroup)

  00133	83 7d 10 00	 cmp	 DWORD PTR _bProgGroup$[ebp], 0
  00137	0f 84 1f 02 00
	00		 je	 $LN9@DoShortcut

; 1449 : 	{
; 1450 : 		FILE *f;
; 1451 : 
; 1452 : 		if (mkfulldir (szLinkDir, TRUE) != 0)

  0013d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  00143	6a 01		 push	 1
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 _mkfulldir
  0014b	83 c4 08	 add	 esp, 8
  0014e	85 c0		 test	 eax, eax
  00150	74 5e		 je	 SHORT $LN11@DoShortcut

; 1453 : 		{
; 1454 : 			if (mkfulldir (szLinkDir, FALSE) != 0)

  00152	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  00158	6a 00		 push	 0
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 _mkfulldir
  00160	83 c4 08	 add	 esp, 8
  00163	85 c0		 test	 eax, eax
  00165	74 49		 je	 SHORT $LN11@DoShortcut

; 1455 : 			{
; 1456 : 				wchar_t szTmp[GST_MAX_PATH];
; 1457 : 
; 1458 : 				handleWin32Error (hwndDlg);

  00167	53		 push	 ebx
  00168	e8 00 00 00 00	 call	 _handleWin32Error
  0016d	83 c4 04	 add	 esp, 4

; 1459 : 				wsprintfW (szTmp, GetString ("CANT_CREATE_FOLDER"), szLinkDir);

  00170	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  00176	50		 push	 eax
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@
  0017c	e8 00 00 00 00	 call	 _GetString
  00181	83 c4 04	 add	 esp, 4
  00184	50		 push	 eax
  00185	8d 85 e0 f8 ff
	ff		 lea	 eax, DWORD PTR _szTmp$2[ebp]
  0018b	50		 push	 eax
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1460 : 				MessageBoxW (hwndDlg, szTmp, lpszTitle, MB_ICONHAND);

  00195	8d 85 e0 f8 ff
	ff		 lea	 eax, DWORD PTR _szTmp$2[ebp]
  0019b	6a 10		 push	 16			; 00000010H
  0019d	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  001a3	50		 push	 eax
  001a4	53		 push	 ebx
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 1524 : 
; 1525 : error:

  001ab	e9 91 02 00 00	 jmp	 $error$59
$LN11@DoShortcut:

; 1461 : 				goto error;
; 1462 : 			}
; 1463 : 		}
; 1464 : 
; 1465 : 		sprintf (szTmp, "%s%s", szDir, "GostCrypt.exe");

  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@
  001b5	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  001bb	50		 push	 eax
  001bc	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 _sprintf

; 1466 : 		sprintf (szTmp2, "%s%s", szLinkDir, "\\GostCrypt.lnk");

  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FMMFFOMO@?2GostCrypt?4lnk?$AA@
  001d2	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  001d8	50		 push	 eax
  001d9	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  001df	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 _sprintf

; 1467 : 
; 1468 : 		IconMessage (hwndDlg, szTmp2);

  001ea	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  001f0	50		 push	 eax
  001f1	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
  001f6	53		 push	 ebx
  001f7	e8 00 00 00 00	 call	 _StatusMessageParam

; 1469 : 		if (CreateLink (szTmp, "", szTmp2) != S_OK)

  001fc	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00202	50		 push	 eax
  00203	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0020e	50		 push	 eax
  0020f	e8 00 00 00 00	 call	 _CreateLink
  00214	83 c4 38	 add	 esp, 56			; 00000038H
  00217	85 c0		 test	 eax, eax
  00219	0f 85 22 02 00
	00		 jne	 $error$59

; 1470 : 			goto error;
; 1471 : 
; 1472 : 		sprintf (szTmp2, "%s%s", szLinkDir, "\\GostCrypt Website.url");

  0021f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BKNACPBJ@?2GostCrypt?5Website?4url?$AA@
  00224	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  0022a	50		 push	 eax
  0022b	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 _sprintf

; 1473 : 		IconMessage (hwndDlg, szTmp2);

  0023c	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00242	50		 push	 eax
  00243	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
  00248	53		 push	 ebx
  00249	e8 00 00 00 00	 call	 _StatusMessageParam

; 1474 : 		f = fopen (szTmp2, "w");

  0024e	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00254	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 _fopen
  0025f	83 c4 24	 add	 esp, 36			; 00000024H
  00262	89 85 dc f8 ff
	ff		 mov	 DWORD PTR _f$1$[ebp], eax

; 1475 : 		if (f)

  00268	85 c0		 test	 eax, eax
  0026a	0f 84 d1 01 00
	00		 je	 $error$59

; 1476 : 		{
; 1477 : 			fprintf (f, "[InternetShortcut]\nURL=%s\n", GST_HOMEPAGE);

  00270	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@EMBCECD@http?3?1?1www?4gostcrypt?4org?1?$AA@
  00275	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MKLFJBBF@?$FLInternetShortcut?$FN?6URL?$DN?$CFs?6?$AA@
  0027a	50		 push	 eax
  0027b	e8 00 00 00 00	 call	 _fprintf

; 1478 : 
; 1479 : 			CheckFileStreamWriteErrors (f, szTmp2);

  00280	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00286	50		 push	 eax
  00287	ff b5 dc f8 ff
	ff		 push	 DWORD PTR _f$1$[ebp]
  0028d	e8 00 00 00 00	 call	 _CheckFileStreamWriteErrors

; 1480 : 			fclose (f);

  00292	ff b5 dc f8 ff
	ff		 push	 DWORD PTR _f$1$[ebp]
  00298	e8 00 00 00 00	 call	 _fclose

; 1481 : 		}
; 1482 : 		else
; 1483 : 			goto error;
; 1484 : 
; 1485 : 		sprintf (szTmp, "%s%s", szDir, "GostCrypt Setup.exe");

  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CHHIEGKC@GostCrypt?5Setup?4exe?$AA@
  002a2	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  002a8	50		 push	 eax
  002a9	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  002af	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 _sprintf

; 1486 : 		sprintf (szTmp2, "%s%s", szLinkDir, "\\Uninstall GostCrypt.lnk");

  002ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JDKCCNOL@?2Uninstall?5GostCrypt?4lnk?$AA@
  002bf	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  002c5	50		 push	 eax
  002c6	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  002cc	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  002d1	50		 push	 eax
  002d2	e8 00 00 00 00	 call	 _sprintf

; 1487 : 		strcpy (szTmp3, "/u");

  002d7	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02GBOHKKID@?1u?$AA@
  002dd	66 89 85 e8 fa
	ff ff		 mov	 WORD PTR _szTmp3$[ebp], ax
  002e4	a0 02 00 00 00	 mov	 al, BYTE PTR ??_C@_02GBOHKKID@?1u?$AA@+2
  002e9	88 85 ea fa ff
	ff		 mov	 BYTE PTR _szTmp3$[ebp+2], al

; 1488 : 
; 1489 : 		IconMessage (hwndDlg, szTmp2);

  002ef	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  002f5	50		 push	 eax
  002f6	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
  002fb	53		 push	 ebx
  002fc	e8 00 00 00 00	 call	 _StatusMessageParam
  00301	83 c4 44	 add	 esp, 68			; 00000044H

; 1490 : 		if (CreateLink (szTmp, szTmp3, szTmp2) != S_OK)

  00304	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  0030a	50		 push	 eax
  0030b	8d 85 e8 fa ff
	ff		 lea	 eax, DWORD PTR _szTmp3$[ebp]
  00311	50		 push	 eax
  00312	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00318	50		 push	 eax
  00319	e8 00 00 00 00	 call	 _CreateLink
  0031e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00321	85 c0		 test	 eax, eax
  00323	0f 85 18 01 00
	00		 jne	 $error$59

; 1491 : 			goto error;
; 1492 : 
; 1493 : 		sprintf (szTmp2, "%s%s", szLinkDir, "\\GostCrypt User's Guide.lnk");

  00329	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PHNJDCEJ@?2GostCrypt?5User?8s?5Guide?4lnk?$AA@
  0032e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  00334	50		 push	 eax
  00335	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  0033b	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00340	50		 push	 eax
  00341	e8 00 00 00 00	 call	 _sprintf
  00346	83 c4 10	 add	 esp, 16			; 00000010H

; 1494 : 		DeleteFile (szTmp2);

  00349	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  0034f	50		 push	 eax
  00350	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
  00356	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
$LN9@DoShortcut:

; 1495 : 	}
; 1496 : 
; 1497 : 	if (bDesktopIcon)

  0035c	83 7d 14 00	 cmp	 DWORD PTR _bDesktopIcon$[ebp], 0
  00360	0f 84 d1 00 00
	00		 je	 $LN26@DoShortcut

; 1498 : 	{
; 1499 : 		strcpy (szDir, szDestDir);

  00366	8b d7		 mov	 edx, edi
  00368	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL30@DoShortcut:
  00370	8a 0a		 mov	 cl, BYTE PTR [edx]
  00372	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00375	88 4c 16 ff	 mov	 BYTE PTR [esi+edx-1], cl
  00379	84 c9		 test	 cl, cl
  0037b	75 f3		 jne	 SHORT $LL30@DoShortcut

; 1500 : 		x = strlen (szDestDir);

  0037d	8b d7		 mov	 edx, edi
  0037f	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$LL54@DoShortcut:
  00382	8a 0a		 mov	 cl, BYTE PTR [edx]
  00384	42		 inc	 edx
  00385	84 c9		 test	 cl, cl
  00387	75 f9		 jne	 SHORT $LL54@DoShortcut
  00389	2b d6		 sub	 edx, esi
  0038b	80 7c 3a ff 5c	 cmp	 BYTE PTR [edx+edi-1], 92 ; 0000005cH

; 1501 : 		if (szDestDir[x - 1] == '\\')
; 1502 : 			bSlash = TRUE;
; 1503 : 		else
; 1504 : 			bSlash = FALSE;
; 1505 : 
; 1506 : 		if (bSlash == FALSE)

  00390	74 1b		 je	 SHORT $LN23@DoShortcut

; 1507 : 			strcat (szDir, "\\");

  00392	8d bd f0 fc ff
	ff		 lea	 edi, DWORD PTR _szDir$[ebp]
  00398	4f		 dec	 edi
  00399	0f 1f 80 00 00
	00 00		 npad	 7
$LL55@DoShortcut:
  003a0	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  003a3	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  003a6	84 c9		 test	 cl, cl
  003a8	75 f6		 jne	 SHORT $LL55@DoShortcut
  003aa	66 89 07	 mov	 WORD PTR [edi], ax
$LN23@DoShortcut:

; 1508 : 
; 1509 : 		if (bForAllUsers)

  003ad	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bForAllUsers, 0

; 1510 : 			SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_COMMON_DESKTOPDIRECTORY, 0);

  003b4	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  003ba	6a 00		 push	 0
  003bc	74 04		 je	 SHORT $LN24@DoShortcut
  003be	6a 19		 push	 25			; 00000019H

; 1511 : 		else

  003c0	eb 02		 jmp	 SHORT $LN57@DoShortcut
$LN24@DoShortcut:

; 1512 : 			SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_DESKTOPDIRECTORY, 0);

  003c2	6a 10		 push	 16			; 00000010H
$LN57@DoShortcut:
  003c4	50		 push	 eax
  003c5	53		 push	 ebx
  003c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetSpecialFolderPathA@16

; 1513 : 
; 1514 : 		sprintf (szTmp, "%s%s", szDir, "GostCrypt.exe");

  003cc	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@
  003d1	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  003d7	50		 push	 eax
  003d8	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  003de	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  003e3	50		 push	 eax
  003e4	e8 00 00 00 00	 call	 _sprintf

; 1515 : 		sprintf (szTmp2, "%s%s", szLinkDir, "\\GostCrypt.lnk");

  003e9	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FMMFFOMO@?2GostCrypt?4lnk?$AA@
  003ee	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLinkDir$[ebp]
  003f4	50		 push	 eax
  003f5	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  003fb	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00400	50		 push	 eax
  00401	e8 00 00 00 00	 call	 _sprintf

; 1516 : 
; 1517 : 		IconMessage (hwndDlg, szTmp2);

  00406	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  0040c	50		 push	 eax
  0040d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
  00412	53		 push	 ebx
  00413	e8 00 00 00 00	 call	 _StatusMessageParam

; 1518 : 
; 1519 : 		if (CreateLink (szTmp, "", szTmp2) != S_OK)

  00418	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  0041e	50		 push	 eax
  0041f	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00425	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0042a	50		 push	 eax
  0042b	e8 00 00 00 00	 call	 _CreateLink
  00430	83 c4 38	 add	 esp, 56			; 00000038H
  00433	85 c0		 test	 eax, eax
  00435	75 0a		 jne	 SHORT $error$59
$LN26@DoShortcut:

; 1520 : 			goto error;
; 1521 : 	}
; 1522 : 
; 1523 : 	bOK = TRUE;

  00437	c7 85 d8 f8 ff
	ff 01 00 00 00	 mov	 DWORD PTR _bOK$1$[ebp], 1
$error$59:

; 1526 : 	OleUninitialize ();

  00441	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleUninitialize@0

; 1527 : 
; 1528 : 	return bOK;
; 1529 : }

  00447	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044a	8b 85 d8 f8 ff
	ff		 mov	 eax, DWORD PTR _bOK$1$[ebp]
  00450	33 cd		 xor	 ecx, ebp
  00452	5f		 pop	 edi
  00453	5e		 pop	 esi
  00454	5b		 pop	 ebx
  00455	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045a	8b e5		 mov	 esp, ebp
  0045c	5d		 pop	 ebp
  0045d	c3		 ret	 0
_DoShortcutsInstall ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _DoDriverUnload
_TEXT	SEGMENT
_refCount$2 = -15556					; size = 4
_dwResult$3 = -15552					; size = 4
_GSTWindowClosed$4 = -15548				; size = 4
_driverVersion$5 = -15548				; size = 4
_bOK$ = -15544						; size = 4
_hwndDlg$GSCopy$ = -15540				; size = 4
_volumesMounted$6 = -15540				; size = 4
_driver$7 = -15536					; size = 13940
_bootEnc$8 = -1596					; size = 1480
$T9 = -116						; size = 94
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_hwndDlg$ = 8						; size = 4
_DoDriverUnload PROC					; COMDAT

; 1106 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_DoDriverUnload
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	b8 b4 3c 00 00	 mov	 eax, 15540		; 00003cb4H
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00036	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]

; 1107 : 	BOOL bOK = TRUE;

  00039	be 01 00 00 00	 mov	 esi, 1
  0003e	89 bd 4c c3 ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$[ebp], edi
  00044	89 b5 48 c3 ff
	ff		 mov	 DWORD PTR _bOK$[ebp], esi

; 1108 : 	int status;
; 1109 : 
; 1110 : 	status = DriverAttach ();

  0004a	e8 00 00 00 00	 call	 _DriverAttach

; 1111 : 	if (status != 0)

  0004f	85 c0		 test	 eax, eax
  00051	74 39		 je	 SHORT $LN4@DoDriverUn

; 1112 : 	{
; 1113 : 		if (status == ERR_OS_ERROR && GetLastError () != ERROR_FILE_NOT_FOUND)

  00053	3b c6		 cmp	 eax, esi
  00055	75 20		 jne	 SHORT $LN62@DoDriverUn
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0005d	83 f8 02	 cmp	 eax, 2
  00060	74 2a		 je	 SHORT $LN4@DoDriverUn

; 1114 : 		{
; 1115 : 			handleWin32Error (hwndDlg);

  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 _handleWin32Error

; 1116 : 			AbortProcess ("NODRIVER");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_08ELEAABKI@NODRIVER?$AA@
  0006d	e8 00 00 00 00	 call	 _AbortProcess
  00072	83 c4 08	 add	 esp, 8

; 1117 : 		}
; 1118 : 
; 1119 : 		if (status != ERR_OS_ERROR)

  00075	eb 15		 jmp	 SHORT $LN4@DoDriverUn
$LN62@DoDriverUn:

; 1120 : 		{
; 1121 : 			handleError (NULL, status);

  00077	50		 push	 eax
  00078	6a 00		 push	 0
  0007a	e8 00 00 00 00	 call	 _handleError

; 1122 : 			AbortProcess ("NODRIVER");

  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_08ELEAABKI@NODRIVER?$AA@
  00084	e8 00 00 00 00	 call	 _AbortProcess
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@DoDriverUn:

; 1123 : 		}
; 1124 : 	}
; 1125 : 
; 1126 : 	if (hDriver != INVALID_HANDLE_VALUE)

  0008c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _hDriver, -1
  00093	0f 84 d0 03 00
	00		 je	 $LN5@DoDriverUn

; 1127 : 	{
; 1128 : 		MOUNT_LIST_STRUCT driver;
; 1129 : 		LONG driverVersion = VERSION_NUM;
; 1130 : 		int refCount;
; 1131 : 		DWORD dwResult;
; 1132 : 		BOOL bResult;
; 1133 : 
; 1134 : 		// Try to determine if it's upgrade (and not reinstall, downgrade, or first-time install).
; 1135 : 		DetermineUpgradeDowngradeStatus (FALSE, &driverVersion);

  00099	8d 85 44 c3 ff
	ff		 lea	 eax, DWORD PTR _driverVersion$5[ebp]
  0009f	c7 85 44 c3 ff
	ff 00 13 00 00	 mov	 DWORD PTR _driverVersion$5[ebp], 4864 ; 00001300H
  000a9	50		 push	 eax
  000aa	6a 00		 push	 0
  000ac	e8 00 00 00 00	 call	 _DetermineUpgradeDowngradeStatus
  000b1	83 c4 08	 add	 esp, 8

; 1136 : 
; 1137 : 		// Test for encrypted boot drive
; 1138 : 		try

  000b4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1139 : 		{
; 1140 : 			BootEncryption bootEnc (hwndDlg);

  000bb	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  000c1	57		 push	 edi
  000c2	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 1141 : 			if (bootEnc.GetDriverServiceStartType() == SERVICE_BOOT_START)

  000c7	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  000cd	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000d1	e8 00 00 00 00	 call	 ?GetDriverServiceStartType@BootEncryption@GostCrypt@@QAEKXZ ; GostCrypt::BootEncryption::GetDriverServiceStartType
  000d6	85 c0		 test	 eax, eax
  000d8	0f 85 24 01 00
	00		 jne	 $LN19@DoDriverUn

; 1142 : 			{
; 1143 : 				try

  000de	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 1144 : 				{
; 1145 : 					// Check hidden OS update consistency
; 1146 : 					if (IsHiddenOSRunning())

  000e2	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  000e7	85 c0		 test	 eax, eax
  000e9	74 43		 je	 SHORT $LN12@DoDriverUn

; 1147 : 					{
; 1148 : 						if (bootEnc.GetInstalledBootLoaderVersion() != VERSION_NUM)

  000eb	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  000f1	e8 00 00 00 00	 call	 ?GetInstalledBootLoaderVersion@BootEncryption@GostCrypt@@QAEGXZ ; GostCrypt::BootEncryption::GetInstalledBootLoaderVersion
  000f6	0f b7 c0	 movzx	 eax, ax
  000f9	b9 00 13 00 00	 mov	 ecx, 4864		; 00001300H
  000fe	66 3b c1	 cmp	 ax, cx
  00101	74 2b		 je	 SHORT $LN12@DoDriverUn

; 1149 : 						{
; 1150 : 							if (AskWarnNoYes ("UPDATE_GST_IN_DECOY_OS_FIRST") == IDNO)

  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@CJLOPMOH@UPDATE_GST_IN_DECOY_OS_FIRST?$AA@
  00108	e8 00 00 00 00	 call	 _AskWarnNoYes
  0010d	83 c4 04	 add	 esp, 4
  00110	83 f8 07	 cmp	 eax, 7
  00113	75 19		 jne	 SHORT $LN12@DoDriverUn

; 1151 : 								AbortProcessSilent ();

  00115	e8 00 00 00 00	 call	 _AbortProcessSilent
  0011a	eb 12		 jmp	 SHORT $LN12@DoDriverUn
__catch$_DoDriverUnload$0:

; 1152 : 						}
; 1153 : 					}
; 1154 : 				}
; 1155 : 				catch (...) { }

  0011c	b8 00 00 00 00	 mov	 eax, $LN51@DoDriverUn
  00121	c3		 ret	 0
$LN51@DoDriverUn:
  00122	8b b5 48 c3 ff
	ff		 mov	 esi, DWORD PTR _bOK$[ebp]
  00128	8b bd 4c c3 ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN12@DoDriverUn:

; 1156 : 
; 1157 : 				if (bUninstallInProgress && driverVersion >= 0x500 && !bootEnc.GetStatus().DriveMounted)

  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bUninstallInProgress@@3HA ; bUninstallInProgress
  00133	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0013a	85 c0		 test	 eax, eax
  0013c	0f 84 09 01 00
	00		 je	 $LN61@DoDriverUn
  00142	81 bd 44 c3 ff
	ff 00 05 00 00	 cmp	 DWORD PTR _driverVersion$5[ebp], 1280 ; 00000500H
  0014c	0f 8c c5 00 00
	00		 jl	 $LN13@DoDriverUn
  00152	8d 45 8c	 lea	 eax, DWORD PTR $T9[ebp]
  00155	50		 push	 eax
  00156	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  0015c	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00161	83 78 06 00	 cmp	 DWORD PTR [eax+6], 0
  00165	0f 85 a7 00 00
	00		 jne	 $LN64@DoDriverUn

; 1158 : 				{
; 1159 : 					try { bootEnc.RegisterFilterDriver (false, BootEncryption::DriveFilter); } catch (...) { }

  0016b	6a 00		 push	 0
  0016d	6a 00		 push	 0
  0016f	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  00175	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  00179	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
  0017e	eb 12		 jmp	 SHORT $LN77@DoDriverUn
__catch$_DoDriverUnload$2:
  00180	b8 00 00 00 00	 mov	 eax, $LN53@DoDriverUn
  00185	c3		 ret	 0
$LN53@DoDriverUn:
  00186	8b b5 48 c3 ff
	ff		 mov	 esi, DWORD PTR _bOK$[ebp]
  0018c	8b bd 4c c3 ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN77@DoDriverUn:

; 1160 : 					try { bootEnc.RegisterFilterDriver (false, BootEncryption::VolumeFilter); } catch (...) { }

  00192	6a 01		 push	 1
  00194	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0019b	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  001a1	6a 00		 push	 0
  001a3	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  001a7	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
  001ac	eb 12		 jmp	 SHORT $LN78@DoDriverUn
__catch$_DoDriverUnload$4:
  001ae	b8 00 00 00 00	 mov	 eax, $LN55@DoDriverUn
  001b3	c3		 ret	 0
$LN55@DoDriverUn:
  001b4	8b b5 48 c3 ff
	ff		 mov	 esi, DWORD PTR _bOK$[ebp]
  001ba	8b bd 4c c3 ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN78@DoDriverUn:

; 1161 : 					try { bootEnc.RegisterFilterDriver (false, BootEncryption::DumpFilter); } catch (...) { }

  001c0	6a 02		 push	 2
  001c2	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  001c9	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  001cf	6a 00		 push	 0
  001d1	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
  001d5	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
  001da	eb 12		 jmp	 SHORT $LN79@DoDriverUn
__catch$_DoDriverUnload$6:
  001dc	b8 00 00 00 00	 mov	 eax, $LN57@DoDriverUn
  001e1	c3		 ret	 0
$LN57@DoDriverUn:
  001e2	8b b5 48 c3 ff
	ff		 mov	 esi, DWORD PTR _bOK$[ebp]
  001e8	8b bd 4c c3 ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN79@DoDriverUn:

; 1162 : 					bootEnc.SetDriverServiceStartType (SERVICE_SYSTEM_START);

  001ee	6a 01		 push	 1
  001f0	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  001f6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  001fd	e8 00 00 00 00	 call	 ?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z ; GostCrypt::BootEncryption::SetDriverServiceStartType
$LN19@DoDriverUn:

; 1184 : 				}
; 1185 : 			}
; 1186 : 		}

  00202	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  00208	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  0020d	e9 9d 00 00 00	 jmp	 $LN59@DoDriverUn
$LN64@DoDriverUn:

; 1162 : 					bootEnc.SetDriverServiceStartType (SERVICE_SYSTEM_START);

  00212	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bUninstallInProgress@@3HA ; bUninstallInProgress
$LN13@DoDriverUn:

; 1163 : 				}
; 1164 : /**
; 1165 :  *
; 1166 :  *	\fn else if (bUninstallInProgress || bDowngrade)
; 1167 :  *	\brief
; 1168 :  *	\param[in] bUninstallInProgress ||
; 1169 :  *	\return
; 1170 :  *
; 1171 :  */
; 1172 : 				else if (bUninstallInProgress || bDowngrade)

  00217	85 c0		 test	 eax, eax
  00219	74 30		 je	 SHORT $LN61@DoDriverUn

; 1181 : 
; 1182 : 					SystemEncryptionUpdate = TRUE;
; 1183 : 					PortableMode = FALSE;

  0021b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bDowngrade@@3HA ; bDowngrade
$LN20@DoDriverUn:

; 1173 : 				{
; 1174 : 					Error (bDowngrade ? "SETUP_FAILED_BOOT_DRIVE_ENCRYPTED_DOWNGRADE" : "SETUP_FAILED_BOOT_DRIVE_ENCRYPTED");

  00221	85 c9		 test	 ecx, ecx
  00223	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@
  00228	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CM@LPOONFIE@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@
  0022d	0f 44 c2	 cmove	 eax, edx
  00230	50		 push	 eax
  00231	e8 00 00 00 00	 call	 _Error
  00236	83 c4 04	 add	 esp, 4

; 1175 : 					return FALSE;

  00239	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  0023f	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  00244	33 c0		 xor	 eax, eax
  00246	e9 26 02 00 00	 jmp	 $LN1@DoDriverUn
$LN61@DoDriverUn:

; 1163 : 				}
; 1164 : /**
; 1165 :  *
; 1166 :  *	\fn else if (bUninstallInProgress || bDowngrade)
; 1167 :  *	\brief
; 1168 :  *	\param[in] bUninstallInProgress ||
; 1169 :  *	\return
; 1170 :  *
; 1171 :  */
; 1172 : 				else if (bUninstallInProgress || bDowngrade)

  0024b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bDowngrade@@3HA ; bDowngrade
  00251	85 c9		 test	 ecx, ecx
  00253	75 cc		 jne	 SHORT $LN20@DoDriverUn

; 1176 : 				}
; 1177 : 				else
; 1178 : 				{
; 1179 : 					if (CurrentOSMajor == 6 && CurrentOSMinor == 0 && CurrentOSServicePack < 1)

  00255	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _CurrentOSMajor, 6
  0025c	75 1e		 jne	 SHORT $LN21@DoDriverUn
  0025e	39 0d 00 00 00
	00		 cmp	 DWORD PTR _CurrentOSMinor, ecx
  00264	75 16		 jne	 SHORT $LN21@DoDriverUn
  00266	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _CurrentOSServicePack, 1
  0026d	7d 0d		 jge	 SHORT $LN21@DoDriverUn

; 1180 : 						AbortProcess ("SYS_ENCRYPTION_UPGRADE_UNSUPPORTED_ON_VISTA_SP0");

  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@EDIMDHJI@SYS_ENCRYPTION_UPGRADE_UNSUPPORT@
  00274	e8 00 00 00 00	 call	 _AbortProcess
  00279	83 c4 04	 add	 esp, 4
$LN21@DoDriverUn:

; 1184 : 				}
; 1185 : 			}
; 1186 : 		}

  0027c	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  00282	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _SystemEncryptionUpdate, 1
  0028c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PortableMode@@3HA, 0 ; PortableMode
  00296	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  0029b	eb 12		 jmp	 SHORT $LN59@DoDriverUn
__catch$_DoDriverUnload$8:

; 1187 : 		catch (...)	{ }

  0029d	b8 00 00 00 00	 mov	 eax, $LN66@DoDriverUn
  002a2	c3		 ret	 0
$LN66@DoDriverUn:
  002a3	8b b5 48 c3 ff
	ff		 mov	 esi, DWORD PTR _bOK$[ebp]
  002a9	8b bd 4c c3 ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN59@DoDriverUn:

; 1188 : 
; 1189 : 		if (!bUninstall
; 1190 : 			&& (bUpgrade || SystemEncryptionUpdate)
; 1191 : 			&& (!bDevm || SystemEncryptionUpdate))

  002af	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  002b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemEncryptionUpdate
  002bb	75 24		 jne	 SHORT $LN22@DoDriverUn
  002bd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  002c4	75 04		 jne	 SHORT $LN23@DoDriverUn
  002c6	85 c0		 test	 eax, eax
  002c8	74 17		 je	 SHORT $LN22@DoDriverUn
$LN23@DoDriverUn:
  002ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  002d1	74 04		 je	 SHORT $LN24@DoDriverUn
  002d3	85 c0		 test	 eax, eax
  002d5	74 0a		 je	 SHORT $LN22@DoDriverUn
$LN24@DoDriverUn:

; 1192 : 		{
; 1193 : 			UnloadDriver = FALSE;

  002d7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
$LN22@DoDriverUn:

; 1194 : 		}
; 1195 : 
; 1196 : 		if (PortableMode && !SystemEncryptionUpdate)

  002e1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PortableMode@@3HA, 0 ; PortableMode
  002e8	74 10		 je	 SHORT $LN25@DoDriverUn
  002ea	85 c0		 test	 eax, eax
  002ec	75 0c		 jne	 SHORT $LN25@DoDriverUn

; 1197 : 			UnloadDriver = TRUE;

  002ee	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?UnloadDriver@@3HA, 1 ; UnloadDriver

; 1198 : 
; 1199 : 		if (UnloadDriver)

  002f8	eb 0d		 jmp	 SHORT $LN63@DoDriverUn
$LN25@DoDriverUn:
  002fa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
  00301	0f 84 a6 00 00
	00		 je	 $LN71@DoDriverUn
$LN63@DoDriverUn:

; 1200 : 		{
; 1201 : 			int volumesMounted = 0;
; 1202 : 
; 1203 : 			// Check mounted volumes
; 1204 : 			bResult = DeviceIoControl (hDriver, GST_IOCTL_IS_ANY_VOLUME_MOUNTED, NULL, 0, &volumesMounted, sizeof (volumesMounted), &dwResult, NULL);

  00307	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DeviceIoControl@32
  0030d	8d 85 40 c3 ff
	ff		 lea	 eax, DWORD PTR _dwResult$3[ebp]
  00313	6a 00		 push	 0
  00315	50		 push	 eax
  00316	6a 04		 push	 4
  00318	8d 85 4c c3 ff
	ff		 lea	 eax, DWORD PTR _volumesMounted$6[ebp]
  0031e	c7 85 4c c3 ff
	ff 00 00 00 00	 mov	 DWORD PTR _volumesMounted$6[ebp], 0
  00328	50		 push	 eax
  00329	6a 00		 push	 0
  0032b	6a 00		 push	 0
  0032d	68 28 20 22 00	 push	 2236456			; 00222028H
  00332	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  00338	ff d3		 call	 ebx

; 1205 : 
; 1206 : 			if (!bResult)

  0033a	85 c0		 test	 eax, eax
  0033c	75 44		 jne	 SHORT $LN70@DoDriverUn

; 1207 : 			{
; 1208 : 				bResult = DeviceIoControl (hDriver, GST_IOCTL_LEGACY_GET_MOUNTED_VOLUMES, NULL, 0, &driver, sizeof (driver), &dwResult, NULL);

  0033e	50		 push	 eax
  0033f	8d 85 40 c3 ff
	ff		 lea	 eax, DWORD PTR _dwResult$3[ebp]
  00345	50		 push	 eax
  00346	68 74 36 00 00	 push	 13940			; 00003674H
  0034b	8d 85 50 c3 ff
	ff		 lea	 eax, DWORD PTR _driver$7[ebp]
  00351	50		 push	 eax
  00352	6a 00		 push	 0
  00354	6a 00		 push	 0
  00356	68 04 20 07 00	 push	 466948			; 00072004H
  0035b	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  00361	ff d3		 call	 ebx

; 1209 : 				if (bResult)

  00363	85 c0		 test	 eax, eax
  00365	74 0e		 je	 SHORT $LN29@DoDriverUn

; 1210 : 					volumesMounted = driver.ulMountedDrives;

  00367	8b 85 50 c3 ff
	ff		 mov	 eax, DWORD PTR _driver$7[ebp]
  0036d	89 85 4c c3 ff
	ff		 mov	 DWORD PTR _volumesMounted$6[ebp], eax
  00373	eb 13		 jmp	 SHORT $LN60@DoDriverUn
$LN29@DoDriverUn:

; 1222 : 			{
; 1223 : 				bOK = FALSE;
; 1224 : 				handleWin32Error (hwndDlg);

  00375	57		 push	 edi
  00376	33 f6		 xor	 esi, esi
  00378	e8 00 00 00 00	 call	 _handleWin32Error
  0037d	83 c4 04	 add	 esp, 4
  00380	eb 65		 jmp	 SHORT $LN73@DoDriverUn
$LN70@DoDriverUn:
  00382	8b 85 4c c3 ff
	ff		 mov	 eax, DWORD PTR _volumesMounted$6[ebp]
$LN60@DoDriverUn:

; 1211 : 			}
; 1212 : 
; 1213 : 			if (bResult)
; 1214 : 			{
; 1215 : 				if (volumesMounted != 0)

  00388	85 c0		 test	 eax, eax
  0038a	74 27		 je	 SHORT $LN30@DoDriverUn

; 1216 : 				{
; 1217 : 					bOK = FALSE;
; 1218 : 					MessageBoxW (hwndDlg, GetString ("DISMOUNT_ALL_FIRST"), lpszTitle, MB_ICONHAND);

  0038c	6a 10		 push	 16			; 00000010H
  0038e	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00394	33 f6		 xor	 esi, esi
  00396	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OMJBKKEL@DISMOUNT_ALL_FIRST?$AA@
  0039b	e8 00 00 00 00	 call	 _GetString
  003a0	83 c4 04	 add	 esp, 4
  003a3	50		 push	 eax
  003a4	57		 push	 edi
  003a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 1219 : 				}
; 1220 : 			}
; 1221 : 			else

  003ab	eb 3a		 jmp	 SHORT $LN73@DoDriverUn
$LN71@DoDriverUn:
  003ad	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DeviceIoControl@32
$LN30@DoDriverUn:
  003b3	85 f6		 test	 esi, esi

; 1225 : 			}
; 1226 : 		}
; 1227 : 
; 1228 : 		// Try to close all open GST windows
; 1229 : 		if (bOK)

  003b5	74 30		 je	 SHORT $LN73@DoDriverUn

; 1230 : 		{
; 1231 : 			BOOL GSTWindowClosed = FALSE;
; 1232 : 
; 1233 : 			EnumWindows (CloseGSTWindowsEnum, (LPARAM) &GSTWindowClosed);

  003b7	8d 85 44 c3 ff
	ff		 lea	 eax, DWORD PTR _GSTWindowClosed$4[ebp]
  003bd	c7 85 44 c3 ff
	ff 00 00 00 00	 mov	 DWORD PTR _GSTWindowClosed$4[ebp], 0
  003c7	50		 push	 eax
  003c8	68 00 00 00 00	 push	 OFFSET _CloseGSTWindowsEnum@8
  003cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnumWindows@8

; 1234 : 
; 1235 : 			if (GSTWindowClosed) 

  003d3	83 bd 44 c3 ff
	ff 00		 cmp	 DWORD PTR _GSTWindowClosed$4[ebp], 0
  003da	74 0b		 je	 SHORT $LN73@DoDriverUn

; 1236 : 				Sleep (2000);

  003dc	68 d0 07 00 00	 push	 2000			; 000007d0H
  003e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN73@DoDriverUn:

; 1237 : 		}
; 1238 : 
; 1239 : 		// Test for any applications attached to driver
; 1240 : 		if (!bUpgrade)

  003e7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  003ee	75 54		 jne	 SHORT $LN75@DoDriverUn

; 1241 : 		{
; 1242 : 			bResult = DeviceIoControl (hDriver, GST_IOCTL_GET_DEVICE_REFCOUNT, &refCount, sizeof (refCount), &refCount,

  003f0	6a 00		 push	 0
  003f2	8d 85 40 c3 ff
	ff		 lea	 eax, DWORD PTR _dwResult$3[ebp]
  003f8	50		 push	 eax
  003f9	6a 04		 push	 4
  003fb	8d 85 3c c3 ff
	ff		 lea	 eax, DWORD PTR _refCount$2[ebp]
  00401	50		 push	 eax
  00402	6a 04		 push	 4
  00404	50		 push	 eax
  00405	68 20 20 22 00	 push	 2236448			; 00222020H
  0040a	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  00410	ff d3		 call	 ebx
  00412	85 f6		 test	 esi, esi

; 1243 : 				sizeof (refCount), &dwResult, NULL);
; 1244 : 
; 1245 : 			if (bOK && bResult && refCount > 1)

  00414	74 3b		 je	 SHORT $LN37@DoDriverUn
  00416	85 c0		 test	 eax, eax
  00418	74 2a		 je	 SHORT $LN75@DoDriverUn
  0041a	83 bd 3c c3 ff
	ff 01		 cmp	 DWORD PTR _refCount$2[ebp], 1
  00421	7e 21		 jle	 SHORT $LN75@DoDriverUn

; 1246 : 			{
; 1247 : 				MessageBoxW (hwndDlg, GetString ("CLOSE_GST_FIRST"), lpszTitle, MB_ICONSTOP);

  00423	6a 10		 push	 16			; 00000010H
  00425	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  0042b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BFJEMMFA@CLOSE_GST_FIRST?$AA@
  00430	e8 00 00 00 00	 call	 _GetString
  00435	83 c4 04	 add	 esp, 4
  00438	50		 push	 eax
  00439	57		 push	 edi
  0043a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 1248 : 				bOK = FALSE;

  00440	33 f6		 xor	 esi, esi
  00442	eb 0d		 jmp	 SHORT $LN37@DoDriverUn
$LN75@DoDriverUn:
  00444	85 f6		 test	 esi, esi

; 1249 : 			}
; 1250 : 		}
; 1251 : 
; 1252 : 		if (!bOK || UnloadDriver)

  00446	74 09		 je	 SHORT $LN37@DoDriverUn
  00448	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
  0044f	74 1e		 je	 SHORT $LN6@DoDriverUn
$LN37@DoDriverUn:

; 1253 : 		{
; 1254 : 			CloseHandle (hDriver);

  00451	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  00457	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 1255 : 			hDriver = INVALID_HANDLE_VALUE;

  0045d	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _hDriver, -1

; 1256 : 		}
; 1257 : 	}
; 1258 : 	else

  00467	eb 06		 jmp	 SHORT $LN6@DoDriverUn
$LN5@DoDriverUn:

; 1259 : 	{
; 1260 : 		// Note that the driver may have already been unloaded during this session (e.g. retry after an error, etc.) so it is not 
; 1261 : 		// guaranteed that the user is installing GostCrypt for the first time now (we also cannot know if the user has already
; 1262 : 		// installed and used GostCrypt on another system before).
; 1263 : 		bPossiblyFirstTimeInstall = TRUE;

  00469	89 35 00 00 00
	00		 mov	 DWORD PTR _bPossiblyFirstTimeInstall, esi
$LN6@DoDriverUn:

; 1264 : 	}
; 1265 : 
; 1266 : 	return bOK;

  0046f	8b c6		 mov	 eax, esi
$LN1@DoDriverUn:

; 1267 : }

  00471	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00474	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0047b	59		 pop	 ecx
  0047c	5f		 pop	 edi
  0047d	5e		 pop	 esi
  0047e	5b		 pop	 ebx
  0047f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00482	33 cd		 xor	 ecx, ebp
  00484	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00489	8b e5		 mov	 esp, ebp
  0048b	5d		 pop	 ebp
  0048c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_DoDriverUnload$10:
  00000	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$8[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__ehhandler$_DoDriverUnload:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 38 c3 ff
	ff		 mov	 ecx, DWORD PTR [edx-15560]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_DoDriverUnload
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_DoDriverUnload ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _DoServiceUninstall
_TEXT	SEGMENT
_firstTry$ = -3600					; size = 4
_bOK$ = -3596						; size = 4
_hService$ = -3592					; size = 4
_hManager$ = -3588					; size = 4
_lpszService$GSCopy$ = -3584				; size = 4
_hwndDlg$GSCopy$ = -3580				; size = 4
_bootEnc$2 = -3576					; size = 1480
_status$ = -2096					; size = 28
_szTmp$3 = -2068					; size = 2048
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_hwndDlg$ = 8						; size = 4
_lpszService$ = 12					; size = 4
_DoServiceUninstall PROC				; COMDAT

; 959  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_DoServiceUninstall
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 04 0e 00
	00		 sub	 esp, 3588		; 00000e04H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 45 08	 mov	 eax, DWORD PTR _hwndDlg$[ebp]

; 960  : 	SC_HANDLE hManager, hService = NULL;

  00034	33 ff		 xor	 edi, edi
  00036	0f 57 c0	 xorps	 xmm0, xmm0
  00039	89 85 04 f2 ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$[ebp], eax
  0003f	8b 45 0c	 mov	 eax, DWORD PTR _lpszService$[ebp]
  00042	89 85 00 f2 ff
	ff		 mov	 DWORD PTR _lpszService$GSCopy$[ebp], eax

; 961  : 	BOOL bOK = FALSE, bRet;

  00048	89 bd f4 f1 ff
	ff		 mov	 DWORD PTR _bOK$[ebp], edi

; 962  : 	SERVICE_STATUS status;
; 963  : 	BOOL firstTry = TRUE;

  0004e	c7 85 f0 f1 ff
	ff 01 00 00 00	 mov	 DWORD PTR _firstTry$[ebp], 1

; 964  : 	int x;
; 965  : 
; 966  : 	memset (&status, 0, sizeof (status));	/* Keep VC6 quiet */

  00058	0f 11 85 d0 f7
	ff ff		 movups	 XMMWORD PTR _status$[ebp], xmm0
  0005f	89 bd e8 f7 ff
	ff		 mov	 DWORD PTR _status$[ebp+24], edi
  00065	66 0f d6 85 e0
	f7 ff ff	 movq	 QWORD PTR _status$[ebp+16], xmm0
  0006d	0f 1f 00	 npad	 3
$retry$106:

; 967  : 
; 968  : retry:
; 969  : 
; 970  : 	hManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);

  00070	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00075	6a 00		 push	 0
  00077	6a 00		 push	 0
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenSCManagerA@12
  0007f	8b f0		 mov	 esi, eax
  00081	89 b5 fc f1 ff
	ff		 mov	 DWORD PTR _hManager$[ebp], esi

; 971  : 	if (hManager == NULL)

  00087	85 f6		 test	 esi, esi
  00089	0f 84 c3 03 00
	00		 je	 $error$107

; 972  : 		goto error;
; 973  : 
; 974  : 	hService = OpenService (hManager, lpszService, SERVICE_ALL_ACCESS);

  0008f	68 ff 01 0f 00	 push	 983551			; 000f01ffH
  00094	ff b5 00 f2 ff
	ff		 push	 DWORD PTR _lpszService$GSCopy$[ebp]
  0009a	56		 push	 esi
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenServiceA@12
  000a1	8b f8		 mov	 edi, eax
  000a3	89 bd f8 f1 ff
	ff		 mov	 DWORD PTR _hService$[ebp], edi

; 975  : 	if (hService == NULL)

  000a9	85 ff		 test	 edi, edi
  000ab	0f 84 a1 03 00
	00		 je	 $error$107

; 976  : 		goto error;
; 977  : 
; 978  : 	if (strcmp ("gostcrypt", lpszService) == 0)

  000b1	8b b5 00 f2 ff
	ff		 mov	 esi, DWORD PTR _lpszService$GSCopy$[ebp]
  000b7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09JCILFBFB@gostcrypt?$AA@
  000bc	8b d6		 mov	 edx, esi
  000be	66 90		 npad	 2
$LL87@DoServiceU:
  000c0	8a 01		 mov	 al, BYTE PTR [ecx]
  000c2	3a 02		 cmp	 al, BYTE PTR [edx]
  000c4	75 1a		 jne	 SHORT $LN88@DoServiceU
  000c6	84 c0		 test	 al, al
  000c8	74 12		 je	 SHORT $LN89@DoServiceU
  000ca	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000cd	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  000d0	75 0e		 jne	 SHORT $LN88@DoServiceU
  000d2	83 c1 02	 add	 ecx, 2
  000d5	83 c2 02	 add	 edx, 2
  000d8	84 c0		 test	 al, al
  000da	75 e4		 jne	 SHORT $LL87@DoServiceU
$LN89@DoServiceU:
  000dc	33 c0		 xor	 eax, eax
  000de	eb 05		 jmp	 SHORT $LN90@DoServiceU
$LN88@DoServiceU:
  000e0	1b c0		 sbb	 eax, eax
  000e2	83 c8 01	 or	 eax, 1
$LN90@DoServiceU:
  000e5	85 c0		 test	 eax, eax
  000e7	0f 85 3b 01 00
	00		 jne	 $LN12@DoServiceU

; 979  : 	{
; 980  : 		try
; 981  : 		{
; 982  : 			BootEncryption bootEnc (hwndDlg);

  000ed	8b b5 04 f2 ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[ebp]
  000f3	8d 8d 08 f2 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$2[ebp]
  000f9	56		 push	 esi
  000fa	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  000fd	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 983  : 			if (bootEnc.GetDriverServiceStartType() == SERVICE_BOOT_START)

  00102	8d 8d 08 f2 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$2[ebp]
  00108	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0010c	e8 00 00 00 00	 call	 ?GetDriverServiceStartType@BootEncryption@GostCrypt@@QAEKXZ ; GostCrypt::BootEncryption::GetDriverServiceStartType
  00111	85 c0		 test	 eax, eax
  00113	0f 85 8c 00 00
	00		 jne	 $LN60@DoServiceU

; 984  : 			{
; 985  : 				try { bootEnc.RegisterFilterDriver (false, BootEncryption::DriveFilter); } catch (...) { }

  00119	50		 push	 eax
  0011a	50		 push	 eax
  0011b	8d 8d 08 f2 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$2[ebp]
  00121	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00125	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
  0012a	eb 12		 jmp	 SHORT $LN102@DoServiceU
__catch$_DoServiceUninstall$2:
  0012c	b8 00 00 00 00	 mov	 eax, $LN56@DoServiceU
  00131	c3		 ret	 0
$LN56@DoServiceU:
  00132	8b bd f8 f1 ff
	ff		 mov	 edi, DWORD PTR _hService$[ebp]
  00138	8b b5 04 f2 ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN102@DoServiceU:

; 986  : 				try { bootEnc.RegisterFilterDriver (false, BootEncryption::VolumeFilter); } catch (...) { }

  0013e	6a 01		 push	 1
  00140	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00147	8d 8d 08 f2 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$2[ebp]
  0014d	6a 00		 push	 0
  0014f	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  00153	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
  00158	eb 12		 jmp	 SHORT $LN103@DoServiceU
__catch$_DoServiceUninstall$4:
  0015a	b8 00 00 00 00	 mov	 eax, $LN58@DoServiceU
  0015f	c3		 ret	 0
$LN58@DoServiceU:
  00160	8b bd f8 f1 ff
	ff		 mov	 edi, DWORD PTR _hService$[ebp]
  00166	8b b5 04 f2 ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN103@DoServiceU:

; 987  : 				try { bootEnc.RegisterFilterDriver (false, BootEncryption::DumpFilter); } catch (...) { }

  0016c	6a 02		 push	 2
  0016e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00175	8d 8d 08 f2 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$2[ebp]
  0017b	6a 00		 push	 0
  0017d	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  00181	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
  00186	8d 8d 08 f2 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$2[ebp]
  0018c	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  00191	eb 31		 jmp	 SHORT $LN104@DoServiceU
__catch$_DoServiceUninstall$6:
  00193	b8 00 00 00 00	 mov	 eax, $LN96@DoServiceU
  00198	c3		 ret	 0
$LN96@DoServiceU:
  00199	8b bd f8 f1 ff
	ff		 mov	 edi, DWORD PTR _hService$[ebp]
  0019f	8b b5 04 f2 ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN60@DoServiceU:

; 988  : 			}
; 989  : 		}

  001a5	8d 8d 08 f2 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$2[ebp]
  001ab	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  001b0	eb 12		 jmp	 SHORT $LN104@DoServiceU
__catch$_DoServiceUninstall$8:

; 990  : 		catch (...) { }

  001b2	b8 00 00 00 00	 mov	 eax, $LN62@DoServiceU
  001b7	c3		 ret	 0
$LN62@DoServiceU:
  001b8	8b bd f8 f1 ff
	ff		 mov	 edi, DWORD PTR _hService$[ebp]
  001be	8b b5 04 f2 ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN104@DoServiceU:

; 991  : 
; 992  : 		StatusMessage (hwndDlg, "STOPPING_DRIVER");

  001c4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  001cb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001d2	75 68		 jne	 SHORT $LN13@DoServiceU
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HLDEBKOH@STOPPING_DRIVER?$AA@
  001d9	e8 00 00 00 00	 call	 _GetString
  001de	83 c4 04	 add	 esp, 4
  001e1	50		 push	 eax
  001e2	6a 00		 push	 0
  001e4	68 80 01 00 00	 push	 384			; 00000180H
  001e9	68 f9 03 00 00	 push	 1017			; 000003f9H
  001ee	56		 push	 esi
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001f5	50		 push	 eax
  001f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageW@16
  001fc	6a 00		 push	 0
  001fe	6a 00		 push	 0
  00200	6a 00		 push	 0
  00202	68 8b 01 00 00	 push	 395			; 0000018bH
  00207	68 f9 03 00 00	 push	 1017			; 000003f9H
  0020c	56		 push	 esi
  0020d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
  00213	48		 dec	 eax
  00214	50		 push	 eax
  00215	68 97 01 00 00	 push	 407			; 00000197H
  0021a	68 f9 03 00 00	 push	 1017			; 000003f9H
  0021f	56		 push	 esi
  00220	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 993  : 	}
; 994  : 	else

  00226	eb 14		 jmp	 SHORT $LN13@DoServiceU
$LN12@DoServiceU:

; 995  : 		StatusMessageParam (hwndDlg, "STOPPING", lpszService);

  00228	56		 push	 esi
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_08CGLLMHMN@STOPPING?$AA@
  0022e	ff b5 04 f2 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00234	e8 00 00 00 00	 call	 _StatusMessageParam
  00239	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@DoServiceU:

; 996  : 
; 997  : #define WAIT_PERIOD 3
; 998  : 
; 999  : 	for (x = 0; x < WAIT_PERIOD; x++)

  0023c	33 f6		 xor	 esi, esi
  0023e	66 90		 npad	 2
$LL4@DoServiceU:

; 1000 : 	{
; 1001 : 		bRet = QueryServiceStatus (hService, &status);

  00240	8d 85 d0 f7 ff
	ff		 lea	 eax, DWORD PTR _status$[ebp]
  00246	50		 push	 eax
  00247	57		 push	 edi
  00248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryServiceStatus@8

; 1002 : 		if (bRet != TRUE)

  0024e	83 f8 01	 cmp	 eax, 1
  00251	0f 85 f5 01 00
	00		 jne	 $LN99@DoServiceU

; 1003 : 			goto error;
; 1004 : 
; 1005 : 		if (status.dwCurrentState != SERVICE_START_PENDING &&
; 1006 : 		    status.dwCurrentState != SERVICE_STOP_PENDING &&

  00257	8b 85 d4 f7 ff
	ff		 mov	 eax, DWORD PTR _status$[ebp+4]
  0025d	83 f8 02	 cmp	 eax, 2
  00260	74 0a		 je	 SHORT $LN21@DoServiceU
  00262	83 f8 03	 cmp	 eax, 3
  00265	74 05		 je	 SHORT $LN21@DoServiceU
  00267	83 f8 05	 cmp	 eax, 5
  0026a	75 17		 jne	 SHORT $LN76@DoServiceU
$LN21@DoServiceU:

; 1007 : 		    status.dwCurrentState != SERVICE_CONTINUE_PENDING)
; 1008 : 			break;
; 1009 : 
; 1010 : 		Sleep (1000);

  0026c	68 e8 03 00 00	 push	 1000			; 000003e8H
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  00277	46		 inc	 esi
  00278	83 fe 03	 cmp	 esi, 3
  0027b	7c c3		 jl	 SHORT $LL4@DoServiceU

; 996  : 
; 997  : #define WAIT_PERIOD 3
; 998  : 
; 999  : 	for (x = 0; x < WAIT_PERIOD; x++)

  0027d	8b 85 d4 f7 ff
	ff		 mov	 eax, DWORD PTR _status$[ebp+4]
$LN76@DoServiceU:

; 1011 : 	}
; 1012 : 
; 1013 : 	if (status.dwCurrentState != SERVICE_STOPPED)

  00283	83 f8 01	 cmp	 eax, 1
  00286	74 69		 je	 SHORT $try_delete$108

; 1014 : 	{
; 1015 : 		bRet = ControlService (hService, SERVICE_CONTROL_STOP, &status);

  00288	8d 85 d0 f7 ff
	ff		 lea	 eax, DWORD PTR _status$[ebp]
  0028e	50		 push	 eax
  0028f	6a 01		 push	 1
  00291	57		 push	 edi
  00292	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ControlService@12

; 1016 : 		if (bRet == FALSE)

  00298	85 c0		 test	 eax, eax
  0029a	74 55		 je	 SHORT $try_delete$108

; 1017 : 			goto try_delete;
; 1018 : 
; 1019 : 		for (x = 0; x < WAIT_PERIOD; x++)

  0029c	33 f6		 xor	 esi, esi
  0029e	66 90		 npad	 2
$LL7@DoServiceU:

; 1020 : 		{
; 1021 : 			bRet = QueryServiceStatus (hService, &status);

  002a0	8d 85 d0 f7 ff
	ff		 lea	 eax, DWORD PTR _status$[ebp]
  002a6	50		 push	 eax
  002a7	57		 push	 edi
  002a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryServiceStatus@8

; 1022 : 			if (bRet != TRUE)

  002ae	83 f8 01	 cmp	 eax, 1
  002b1	0f 85 95 01 00
	00		 jne	 $LN99@DoServiceU

; 1023 : 				goto error;
; 1024 : 
; 1025 : 			if (status.dwCurrentState != SERVICE_START_PENDING &&
; 1026 : 			    status.dwCurrentState != SERVICE_STOP_PENDING &&

  002b7	8b 85 d4 f7 ff
	ff		 mov	 eax, DWORD PTR _status$[ebp+4]
  002bd	83 f8 02	 cmp	 eax, 2
  002c0	74 0a		 je	 SHORT $LN27@DoServiceU
  002c2	83 f8 03	 cmp	 eax, 3
  002c5	74 05		 je	 SHORT $LN27@DoServiceU
  002c7	83 f8 05	 cmp	 eax, 5
  002ca	75 17		 jne	 SHORT $LN78@DoServiceU
$LN27@DoServiceU:

; 1027 : 			  status.dwCurrentState != SERVICE_CONTINUE_PENDING)
; 1028 : 				break;
; 1029 : 
; 1030 : 			Sleep (1000);

  002cc	68 e8 03 00 00	 push	 1000			; 000003e8H
  002d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  002d7	46		 inc	 esi
  002d8	83 fe 03	 cmp	 esi, 3
  002db	7c c3		 jl	 SHORT $LL7@DoServiceU

; 1017 : 			goto try_delete;
; 1018 : 
; 1019 : 		for (x = 0; x < WAIT_PERIOD; x++)

  002dd	8b 85 d4 f7 ff
	ff		 mov	 eax, DWORD PTR _status$[ebp+4]
$LN78@DoServiceU:

; 1031 : 		}
; 1032 : 
; 1033 : 		if (status.dwCurrentState != SERVICE_STOPPED && status.dwCurrentState != SERVICE_STOP_PENDING)

  002e3	83 f8 01	 cmp	 eax, 1
  002e6	74 09		 je	 SHORT $try_delete$108
  002e8	83 f8 03	 cmp	 eax, 3
  002eb	0f 85 5b 01 00
	00		 jne	 $LN99@DoServiceU
$try_delete$108:

; 1034 : 			goto error;
; 1035 : 	}
; 1036 : 
; 1037 : try_delete:
; 1038 : 
; 1039 : 	if (strcmp ("gostcrypt", lpszService) == 0)

  002f1	8b b5 00 f2 ff
	ff		 mov	 esi, DWORD PTR _lpszService$GSCopy$[ebp]
  002f7	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09JCILFBFB@gostcrypt?$AA@
  002fc	8b ce		 mov	 ecx, esi
  002fe	66 90		 npad	 2
$LL91@DoServiceU:
  00300	8a 10		 mov	 dl, BYTE PTR [eax]
  00302	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00304	75 1a		 jne	 SHORT $LN92@DoServiceU
  00306	84 d2		 test	 dl, dl
  00308	74 12		 je	 SHORT $LN93@DoServiceU
  0030a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0030d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00310	75 0e		 jne	 SHORT $LN92@DoServiceU
  00312	83 c0 02	 add	 eax, 2
  00315	83 c1 02	 add	 ecx, 2
  00318	84 d2		 test	 dl, dl
  0031a	75 e4		 jne	 SHORT $LL91@DoServiceU
$LN93@DoServiceU:
  0031c	33 c0		 xor	 eax, eax
  0031e	eb 05		 jmp	 SHORT $LN94@DoServiceU
$LN92@DoServiceU:
  00320	1b c0		 sbb	 eax, eax
  00322	83 c8 01	 or	 eax, 1
$LN94@DoServiceU:
  00325	85 c0		 test	 eax, eax
  00327	75 1b		 jne	 SHORT $LN30@DoServiceU

; 1040 : 		StatusMessage (hwndDlg, "REMOVING_DRIVER");

  00329	39 05 00 00 00
	00		 cmp	 DWORD PTR _Rollback, eax
  0032f	0f 85 8d 00 00
	00		 jne	 $LN69@DoServiceU
  00335	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LFOBNNHD@REMOVING_DRIVER?$AA@
  0033a	e8 00 00 00 00	 call	 _GetString
  0033f	83 c4 04	 add	 esp, 4

; 1041 : 	else

  00342	eb 33		 jmp	 SHORT $LN105@DoServiceU
$LN30@DoServiceU:

; 1042 : 		StatusMessageParam (hwndDlg, "REMOVING", lpszService);

  00344	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0034b	75 75		 jne	 SHORT $LN69@DoServiceU
  0034d	56		 push	 esi
  0034e	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00353	e8 00 00 00 00	 call	 _GetString
  00358	83 c4 04	 add	 esp, 4
  0035b	50		 push	 eax
  0035c	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$3[ebp]
  00362	68 00 00 00 00	 push	 OFFSET ??_C@_1O@FHLBCOCO@?$AA?$CF?$AAs?$AA?5?$AA?$CF?$AAh?$AAs?$AA?$AA@
  00367	50		 push	 eax
  00368	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  0036e	83 c4 10	 add	 esp, 16			; 00000010H
  00371	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$3[ebp]
$LN105@DoServiceU:
  00377	8b b5 04 f2 ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[ebp]
  0037d	50		 push	 eax
  0037e	6a 00		 push	 0
  00380	68 80 01 00 00	 push	 384			; 00000180H
  00385	68 f9 03 00 00	 push	 1017			; 000003f9H
  0038a	56		 push	 esi
  0038b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00391	50		 push	 eax
  00392	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageW@16
  00398	6a 00		 push	 0
  0039a	6a 00		 push	 0
  0039c	6a 00		 push	 0
  0039e	68 8b 01 00 00	 push	 395			; 0000018bH
  003a3	68 f9 03 00 00	 push	 1017			; 000003f9H
  003a8	56		 push	 esi
  003a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
  003af	48		 dec	 eax
  003b0	50		 push	 eax
  003b1	68 97 01 00 00	 push	 407			; 00000197H
  003b6	68 f9 03 00 00	 push	 1017			; 000003f9H
  003bb	56		 push	 esi
  003bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
$LN69@DoServiceU:

; 1043 : 
; 1044 : 	if (hService != NULL)
; 1045 : 		CloseServiceHandle (hService);

  003c2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseServiceHandle@4
  003c8	57		 push	 edi
  003c9	ff d6		 call	 esi

; 1046 : 
; 1047 : 	if (hManager != NULL)
; 1048 : 		CloseServiceHandle (hManager);

  003cb	ff b5 fc f1 ff
	ff		 push	 DWORD PTR _hManager$[ebp]
  003d1	ff d6		 call	 esi

; 1049 : 
; 1050 : 	hManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);

  003d3	68 3f 00 0f 00	 push	 983103			; 000f003fH
  003d8	6a 00		 push	 0
  003da	6a 00		 push	 0
  003dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenSCManagerA@12
  003e2	8b f0		 mov	 esi, eax

; 1051 : 	if (hManager == NULL)

  003e4	85 f6		 test	 esi, esi
  003e6	74 6a		 je	 SHORT $error$107

; 1052 : 		goto error;
; 1053 : 
; 1054 : 	hService = OpenService (hManager, lpszService, SERVICE_ALL_ACCESS);

  003e8	68 ff 01 0f 00	 push	 983551			; 000f01ffH
  003ed	ff b5 00 f2 ff
	ff		 push	 DWORD PTR _lpszService$GSCopy$[ebp]
  003f3	56		 push	 esi
  003f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenServiceA@12
  003fa	8b f8		 mov	 edi, eax

; 1055 : 	if (hService == NULL)

  003fc	85 ff		 test	 edi, edi
  003fe	74 52		 je	 SHORT $error$107

; 1056 : 		goto error;
; 1057 : 
; 1058 : 	bRet = DeleteService (hService);

  00400	57		 push	 edi
  00401	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteService@4

; 1059 : 	if (bRet == FALSE)

  00407	85 c0		 test	 eax, eax
  00409	0f 85 8b 00 00
	00		 jne	 $LN41@DoServiceU
  0040f	39 85 f0 f1 ff
	ff		 cmp	 DWORD PTR _firstTry$[ebp], eax

; 1060 : 	{
; 1061 : 		if (firstTry && GetLastError () == ERROR_SERVICE_MARKED_FOR_DELETE)

  00415	74 3b		 je	 SHORT $error$107
  00417	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0041d	3d 30 04 00 00	 cmp	 eax, 1072		; 00000430H
  00422	75 2e		 jne	 SHORT $error$107

; 1062 : 		{
; 1063 : 			// Second try for an eventual no-install driver instance
; 1064 : 			CloseServiceHandle (hService);

  00424	57		 push	 edi
  00425	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseServiceHandle@4

; 1065 : 			CloseServiceHandle (hManager);

  0042b	56		 push	 esi
  0042c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseServiceHandle@4

; 1066 : 
; 1067 : 			Sleep(1000);

  00432	68 e8 03 00 00	 push	 1000			; 000003e8H
  00437	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 1068 : 			firstTry = FALSE;

  0043d	c7 85 f0 f1 ff
	ff 00 00 00 00	 mov	 DWORD PTR _firstTry$[ebp], 0

; 1069 : 			goto retry;

  00447	e9 24 fc ff ff	 jmp	 $retry$106
$LN99@DoServiceU:
  0044c	8b b5 fc f1 ff
	ff		 mov	 esi, DWORD PTR _hManager$[ebp]
$error$107:
  00452	83 bd f4 f1 ff
	ff 00		 cmp	 DWORD PTR _bOK$[ebp], 0

; 1070 : 		}
; 1071 : 
; 1072 : 		goto error;
; 1073 : 	}
; 1074 : 
; 1075 : 	bOK = TRUE;
; 1076 : 
; 1077 : error:
; 1078 : 
; 1079 : 	if (bOK == FALSE && GetLastError ()!= ERROR_SERVICE_DOES_NOT_EXIST)

  00459	75 3f		 jne	 SHORT $LN41@DoServiceU
  0045b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00461	3d 24 04 00 00	 cmp	 eax, 1060		; 00000424H
  00466	74 32		 je	 SHORT $LN41@DoServiceU

; 1080 : 	{
; 1081 : 		handleWin32Error (hwndDlg);

  00468	ff b5 04 f2 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  0046e	e8 00 00 00 00	 call	 _handleWin32Error
  00473	83 c4 04	 add	 esp, 4

; 1082 : 		MessageBoxW (hwndDlg, GetString ("DRIVER_UINSTALL_FAILED"), lpszTitle, MB_ICONHAND);

  00476	6a 10		 push	 16			; 00000010H
  00478	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  0047e	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BJNFCLGM@DRIVER_UINSTALL_FAILED?$AA@
  00483	e8 00 00 00 00	 call	 _GetString
  00488	83 c4 04	 add	 esp, 4
  0048b	50		 push	 eax
  0048c	ff b5 04 f2 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00492	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 1083 : 	}
; 1084 : 	else

  00498	eb 0a		 jmp	 SHORT $LN42@DoServiceU
$LN41@DoServiceU:

; 1085 : 		bOK = TRUE;

  0049a	c7 85 f4 f1 ff
	ff 01 00 00 00	 mov	 DWORD PTR _bOK$[ebp], 1
$LN42@DoServiceU:

; 1086 : 
; 1087 : 	if (hService != NULL)

  004a4	85 ff		 test	 edi, edi
  004a6	74 0b		 je	 SHORT $LN100@DoServiceU

; 1088 : 		CloseServiceHandle (hService);

  004a8	57		 push	 edi
  004a9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseServiceHandle@4
  004af	ff d7		 call	 edi
  004b1	eb 06		 jmp	 SHORT $LN43@DoServiceU
$LN100@DoServiceU:
  004b3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseServiceHandle@4
$LN43@DoServiceU:

; 1089 : 
; 1090 : 	if (hManager != NULL)

  004b9	85 f6		 test	 esi, esi
  004bb	74 03		 je	 SHORT $LN95@DoServiceU

; 1091 : 		CloseServiceHandle (hManager);

  004bd	56		 push	 esi
  004be	ff d7		 call	 edi
$LN95@DoServiceU:

; 1092 : 
; 1093 : 	return bOK;

  004c0	8b 85 f4 f1 ff
	ff		 mov	 eax, DWORD PTR _bOK$[ebp]

; 1094 : }

  004c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  004c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004d0	59		 pop	 ecx
  004d1	5f		 pop	 edi
  004d2	5e		 pop	 esi
  004d3	5b		 pop	 ebx
  004d4	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d7	33 cd		 xor	 ecx, ebp
  004d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004de	8b e5		 mov	 esp, ebp
  004e0	5d		 pop	 ebp
  004e1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_DoServiceUninstall$17:
  00000	8d 8d 08 f2 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__ehhandler$_DoServiceUninstall:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a ec f1 ff
	ff		 mov	 ecx, DWORD PTR [edx-3604]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_DoServiceUninstall
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_DoServiceUninstall ENDP
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _DoRegUninstall
_TEXT	SEGMENT
_regk$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_bRemoveDeprecated$ = 12				; size = 4
_DoRegUninstall PROC					; COMDAT

; 904  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 905  : 	BOOL bOK = FALSE;
; 906  : 	char regk [64];
; 907  : 
; 908  : 	// Unregister COM servers
; 909  : 	if (!bRemoveDeprecated && IsOSAtLeast (WIN_VISTA))

  00010	83 7d 0c 00	 cmp	 DWORD PTR _bRemoveDeprecated$[ebp], 0
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]
  00018	75 3b		 jne	 SHORT $LN4@DoRegUnins
  0001a	6a 0b		 push	 11			; 0000000bH
  0001c	e8 00 00 00 00	 call	 _IsOSAtLeast
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	74 1f		 je	 SHORT $LN9@DoRegUnins

; 910  : 	{
; 911  : 		if (!UnregisterComServers (InstallationPath))

  00028	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0002d	e8 00 00 00 00	 call	 _UnregisterComServers
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	75 0e		 jne	 SHORT $LN9@DoRegUnins

; 912  : 			StatusMessage (hwndDlg, "COM_DEREG_FAILED");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OBMIEKIN@COM_DEREG_FAILED?$AA@
  0003e	56		 push	 esi
  0003f	e8 00 00 00 00	 call	 _StatusMessage
  00044	83 c4 08	 add	 esp, 8
$LN9@DoRegUnins:

; 913  : 	}
; 914  : 
; 915  : 	if (!bRemoveDeprecated)
; 916  : 		StatusMessage (hwndDlg, "REMOVING_REG");

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GACNCPHC@REMOVING_REG?$AA@
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 _StatusMessage
  00052	83 c4 08	 add	 esp, 8
$LN4@DoRegUnins:

; 917  : 
; 918  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\GostCrypt");

  00055	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegDeleteKeyA@8
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@MNMIDBOE@Software?2Microsoft?2Windows?2Curre@
  00060	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00065	ff d6		 call	 esi

; 919  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\GostCryptVolume\\Shell\\open\\command");

  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@GDKMHJIK@Software?2Classes?2GostCryptVolume@
  0006c	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00071	ff d6		 call	 esi

; 920  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\GostCryptVolume\\Shell\\open");

  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@GDILNLIK@Software?2Classes?2GostCryptVolume@
  00078	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0007d	ff d6		 call	 esi

; 921  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\GostCryptVolume\\Shell");

  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DCEJAAFL@Software?2Classes?2GostCryptVolume@
  00084	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00089	ff d6		 call	 esi

; 922  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\GostCryptVolume\\DefaultIcon");

  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HFACCAPK@Software?2Classes?2GostCryptVolume@
  00090	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00095	ff d6		 call	 esi

; 923  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\GostCryptVolume");

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HIFIENIE@Software?2Classes?2GostCryptVolume@
  0009c	68 02 00 00 80	 push	 -2147483646		; 80000002H
  000a1	ff d6		 call	 esi

; 924  : 	RegDeleteKey (HKEY_CURRENT_USER, "Software\\GostCrypt");

  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EEKEPCFI@Software?2GostCrypt?$AA@
  000a8	68 01 00 00 80	 push	 -2147483647		; 80000001H
  000ad	ff d6		 call	 esi

; 925  : 
; 926  : 	if (!bRemoveDeprecated)

  000af	83 7d 0c 00	 cmp	 DWORD PTR _bRemoveDeprecated$[ebp], 0
  000b3	75 37		 jne	 SHORT $LN10@DoRegUnins

; 927  : 	{
; 928  : 		GetStartupRegKeyName (regk);

  000b5	8d 45 bc	 lea	 eax, DWORD PTR _regk$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _GetStartupRegKeyName

; 929  : 		DeleteRegistryValue (regk, "GostCrypt");

  000be	8d 45 bc	 lea	 eax, DWORD PTR _regk$[ebp]
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _DeleteRegistryValue
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 930  : 
; 931  : 		RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\.gst");

  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HDBIFFFP@Software?2Classes?2?4gst?$AA@
  000d4	68 02 00 00 80	 push	 -2147483646		; 80000002H
  000d9	ff d6		 call	 esi

; 932  : 		SHChangeNotify (SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

  000db	6a 00		 push	 0
  000dd	6a 00		 push	 0
  000df	6a 00		 push	 0
  000e1	68 00 00 00 08	 push	 134217728		; 08000000H
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHChangeNotify@16
$LN10@DoRegUnins:

; 933  : 	}
; 934  : 
; 935  : 	bOK = TRUE;
; 936  : 
; 937  : 	if (bOK == FALSE && GetLastError ()!= ERROR_NO_TOKEN && GetLastError ()!= ERROR_FILE_NOT_FOUND
; 938  : 	    && GetLastError ()!= ERROR_PATH_NOT_FOUND)
; 939  : 	{
; 940  : 		handleWin32Error (hwndDlg);
; 941  : 	}
; 942  : 	else
; 943  : 		bOK = TRUE;
; 944  : 
; 945  : 	return bOK;
; 946  : }

  000ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ef	b8 01 00 00 00	 mov	 eax, 1
  000f4	33 cd		 xor	 ecx, ebp
  000f6	5e		 pop	 esi
  000f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
_DoRegUninstall ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _DoRegInstall
_TEXT	SEGMENT
_typeClassSize$1 = -1576				; size = 4
_hwndDlg$GSCopy$1$ = -1572				; size = 4
_dw$ = -1568						; size = 4
_hkey$ = -1564						; size = 4
_typeClass$2 = -1560					; size = 256
_szDir$ = -1304						; size = 260
_szTmp$ = -1044						; size = 1040
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_bInstallType$ = 16					; size = 4
_DoRegInstall PROC					; COMDAT

; 668  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 06 00
	00		 sub	 esp, 1576		; 00000628H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 669  : 	char szDir[GST_MAX_PATH], *key;
; 670  : 	char szTmp[GST_MAX_PATH*4];
; 671  : 	HKEY hkey = 0;
; 672  : 	BOOL bSlash, bOK = FALSE;
; 673  : 	DWORD dw;
; 674  : 	int x;
; 675  : 
; 676  : 	if (SystemEncryptionUpdate)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  0001a	8b 45 08	 mov	 eax, DWORD PTR _hwndDlg$[ebp]
  0001d	56		 push	 esi
  0001e	89 85 dc f9 ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], eax
  00024	c7 85 e4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _hkey$[ebp], 0
  0002e	0f 84 f8 00 00
	00		 je	 $LN2@DoRegInsta

; 677  : 	{
; 678  : 		if (RegCreateKeyEx (HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\GostCrypt",
; 679  : 			0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) == ERROR_SUCCESS)

  00034	8d 85 e0 f9 ff
	ff		 lea	 eax, DWORD PTR _dw$[ebp]
  0003a	50		 push	 eax
  0003b	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR _hkey$[ebp]
  00041	50		 push	 eax
  00042	6a 00		 push	 0
  00044	68 06 00 02 00	 push	 131078			; 00020006H
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@MNMIDBOE@Software?2Microsoft?2Windows?2Curre@
  00054	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  0005f	85 c0		 test	 eax, eax
  00061	0f 85 b1 00 00
	00		 jne	 $LN3@DoRegInsta

; 680  : 		{
; 681  : 			strcpy (szTmp, VERSION_STRING);

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05OJPKCACG@1?43?41?$AA@

; 682  : 			RegSetValueEx (hkey, "DisplayVersion", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1);

  0006c	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  00072	89 85 ec fb ff
	ff		 mov	 DWORD PTR _szTmp$[ebp], eax
  00078	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0007b	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_05OJPKCACG@1?43?41?$AA@+4
  00081	66 89 85 f0 fb
	ff ff		 mov	 WORD PTR _szTmp$[ebp+4], ax
$LL59@DoRegInsta:
  00088	8a 01		 mov	 al, BYTE PTR [ecx]
  0008a	41		 inc	 ecx
  0008b	84 c0		 test	 al, al
  0008d	75 f9		 jne	 SHORT $LL59@DoRegInsta
  0008f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegSetValueExA@24
  00095	2b ca		 sub	 ecx, edx
  00097	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0009a	50		 push	 eax
  0009b	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  000a1	50		 push	 eax
  000a2	6a 01		 push	 1
  000a4	6a 00		 push	 0
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BNDLMAIF@DisplayVersion?$AA@
  000ab	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  000b1	ff d6		 call	 esi

; 683  : 
; 684  : 			strcpy (szTmp, GST_HOMEPAGE);

  000b3	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BK@EMBCECD@http?3?1?1www?4gostcrypt?4org?1?$AA@
  000ba	66 a1 18 00 00
	00		 mov	 ax, WORD PTR ??_C@_0BK@EMBCECD@http?3?1?1www?4gostcrypt?4org?1?$AA@+24

; 685  : 			RegSetValueEx (hkey, "URLInfoAbout", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1);

  000c0	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  000c6	66 89 85 04 fc
	ff ff		 mov	 WORD PTR _szTmp$[ebp+24], ax
  000cd	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000d0	0f 11 85 ec fb
	ff ff		 movups	 XMMWORD PTR _szTmp$[ebp], xmm0
  000d7	f3 0f 7e 05 10
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0BK@EMBCECD@http?3?1?1www?4gostcrypt?4org?1?$AA@+16
  000df	66 0f d6 85 fc
	fb ff ff	 movq	 QWORD PTR _szTmp$[ebp+16], xmm0
$LL60@DoRegInsta:
  000e7	8a 01		 mov	 al, BYTE PTR [ecx]
  000e9	41		 inc	 ecx
  000ea	84 c0		 test	 al, al
  000ec	75 f9		 jne	 SHORT $LL60@DoRegInsta
  000ee	2b ca		 sub	 ecx, edx
  000f0	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000f3	50		 push	 eax
  000f4	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  000fa	50		 push	 eax
  000fb	6a 01		 push	 1
  000fd	6a 00		 push	 0
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@
  00104	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  0010a	ff d6		 call	 esi

; 686  : 
; 687  : 			RegCloseKey (hkey);

  0010c	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN3@DoRegInsta:

; 688  : 		}
; 689  : 
; 690  : 		return TRUE;

  00118	b8 01 00 00 00	 mov	 eax, 1
  0011d	5e		 pop	 esi

; 832  : 		}
; 833  : 	}
; 834  : 
; 835  : 	return bOK;
; 836  : }

  0011e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00121	33 cd		 xor	 ecx, ebp
  00123	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c3		 ret	 0
$LN2@DoRegInsta:

; 691  : 	}
; 692  : 
; 693  : 	strcpy (szDir, szDestDir);

  0012c	8b 75 0c	 mov	 esi, DWORD PTR _szDestDir$[ebp]
  0012f	8d 95 e8 fa ff
	ff		 lea	 edx, DWORD PTR _szDir$[ebp]
  00135	8b ce		 mov	 ecx, esi
  00137	2b d6		 sub	 edx, esi
  00139	0f 1f 80 00 00
	00 00		 npad	 7
$LL49@DoRegInsta:
  00140	8a 01		 mov	 al, BYTE PTR [ecx]
  00142	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00145	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00149	84 c0		 test	 al, al
  0014b	75 f3		 jne	 SHORT $LL49@DoRegInsta

; 694  : 	x = strlen (szDestDir);

  0014d	8b ce		 mov	 ecx, esi
  0014f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL61@DoRegInsta:
  00152	8a 01		 mov	 al, BYTE PTR [ecx]
  00154	41		 inc	 ecx
  00155	84 c0		 test	 al, al
  00157	75 f9		 jne	 SHORT $LL61@DoRegInsta
  00159	2b ca		 sub	 ecx, edx
  0015b	53		 push	 ebx
  0015c	57		 push	 edi
  0015d	80 7c 31 ff 5c	 cmp	 BYTE PTR [ecx+esi-1], 92 ; 0000005cH

; 695  : 	if (szDestDir[x - 1] == '\\')
; 696  : 		bSlash = TRUE;
; 697  : 	else
; 698  : 		bSlash = FALSE;
; 699  : 
; 700  : 	if (bSlash == FALSE)

  00162	74 1f		 je	 SHORT $LN6@DoRegInsta

; 701  : 		strcat (szDir, "\\");

  00164	8d bd e8 fa ff
	ff		 lea	 edi, DWORD PTR _szDir$[ebp]
  0016a	4f		 dec	 edi
  0016b	0f 1f 44 00 00	 npad	 5
$LL62@DoRegInsta:
  00170	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00173	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00176	84 c0		 test	 al, al
  00178	75 f6		 jne	 SHORT $LL62@DoRegInsta
  0017a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  00180	66 89 07	 mov	 WORD PTR [edi], ax
$LN6@DoRegInsta:

; 702  : 
; 703  : 	if (bInstallType)

  00183	83 7d 10 00	 cmp	 DWORD PTR _bInstallType$[ebp], 0
  00187	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__RegCreateKeyExA@36
  0018d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__RegSetValueExA@24
  00193	0f 84 75 03 00
	00		 je	 $LN27@DoRegInsta

; 704  : 	{
; 705  : 
; 706  : 		key = "Software\\Classes\\GostCryptVolume";
; 707  : 		RegMessage (hwndDlg, key);

  00199	8b b5 dc f9 ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HIFIENIE@Software?2Classes?2GostCryptVolume@
  001a4	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LFAEJJAB@ADDING_REG?$AA@
  001a9	56		 push	 esi
  001aa	e8 00 00 00 00	 call	 _StatusMessageParam
  001af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 708  : 		if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 709  : 				    key,
; 710  : 				    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  001b2	8d 85 e0 f9 ff
	ff		 lea	 eax, DWORD PTR _dw$[ebp]
  001b8	50		 push	 eax
  001b9	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR _hkey$[ebp]
  001bf	50		 push	 eax
  001c0	6a 00		 push	 0
  001c2	68 06 00 02 00	 push	 131078			; 00020006H
  001c7	6a 00		 push	 0
  001c9	6a 00		 push	 0
  001cb	6a 00		 push	 0
  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HIFIENIE@Software?2Classes?2GostCryptVolume@
  001d2	68 02 00 00 80	 push	 -2147483646		; 80000002H
  001d7	ff d7		 call	 edi
  001d9	85 c0		 test	 eax, eax
  001db	0f 85 d8 05 00
	00		 jne	 $LN94@DoRegInsta

; 711  : 			goto error;
; 712  : 
; 713  : 		strcpy (szTmp, "GostCrypt Volume");

  001e1	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BB@BGKFOGNF@GostCrypt?5Volume?$AA@
  001e8	a0 10 00 00 00	 mov	 al, BYTE PTR ??_C@_0BB@BGKFOGNF@GostCrypt?5Volume?$AA@+16

; 714  : 		if (RegSetValueEx (hkey, "", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  001ed	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  001f3	88 85 fc fb ff
	ff		 mov	 BYTE PTR _szTmp$[ebp+16], al
  001f9	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  001fc	0f 11 85 ec fb
	ff ff		 movups	 XMMWORD PTR _szTmp$[ebp], xmm0
$LL63@DoRegInsta:
  00203	8a 01		 mov	 al, BYTE PTR [ecx]
  00205	41		 inc	 ecx
  00206	84 c0		 test	 al, al
  00208	75 f9		 jne	 SHORT $LL63@DoRegInsta
  0020a	2b ca		 sub	 ecx, edx
  0020c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0020f	50		 push	 eax
  00210	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00216	50		 push	 eax
  00217	6a 01		 push	 1
  00219	6a 00		 push	 0
  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00220	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00226	ff d3		 call	 ebx
  00228	85 c0		 test	 eax, eax
  0022a	0f 85 89 05 00
	00		 jne	 $LN94@DoRegInsta

; 715  : 			goto error;
; 716  : 
; 717  : 		sprintf (szTmp, "%ws", GST_APPLICATION_ID);

  00230	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@PACGJHBK@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAF?$AAo?$AAu?$AAn?$AAd?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@
  00235	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0023b	68 00 00 00 00	 push	 OFFSET ??_C@_03BMPLCLAP@?$CFws?$AA@
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 _sprintf

; 718  : 		if (RegSetValueEx (hkey, "AppUserModelID", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00246	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  0024c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0024f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL64@DoRegInsta:
  00252	8a 01		 mov	 al, BYTE PTR [ecx]
  00254	41		 inc	 ecx
  00255	84 c0		 test	 al, al
  00257	75 f9		 jne	 SHORT $LL64@DoRegInsta
  00259	2b ca		 sub	 ecx, edx
  0025b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0025e	50		 push	 eax
  0025f	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00265	50		 push	 eax
  00266	6a 01		 push	 1
  00268	6a 00		 push	 0
  0026a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LGELIEHB@AppUserModelID?$AA@
  0026f	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00275	ff d3		 call	 ebx
  00277	85 c0		 test	 eax, eax
  00279	0f 85 3a 05 00
	00		 jne	 $LN94@DoRegInsta

; 719  : 			goto error;
; 720  : 
; 721  : 		RegCloseKey (hkey);

  0027f	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00285	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 722  : 		hkey = 0;
; 723  : 
; 724  : 		key = "Software\\Classes\\GostCryptVolume\\DefaultIcon";
; 725  : 		RegMessage (hwndDlg, key);

  0028b	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HFACCAPK@Software?2Classes?2GostCryptVolume@
  00290	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LFAEJJAB@ADDING_REG?$AA@
  00295	56		 push	 esi
  00296	c7 85 e4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _hkey$[ebp], 0
  002a0	e8 00 00 00 00	 call	 _StatusMessageParam
  002a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 726  : 		if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 727  : 				    key,
; 728  : 				    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  002a8	8d 85 e0 f9 ff
	ff		 lea	 eax, DWORD PTR _dw$[ebp]
  002ae	50		 push	 eax
  002af	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR _hkey$[ebp]
  002b5	50		 push	 eax
  002b6	6a 00		 push	 0
  002b8	68 06 00 02 00	 push	 131078			; 00020006H
  002bd	6a 00		 push	 0
  002bf	6a 00		 push	 0
  002c1	6a 00		 push	 0
  002c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HFACCAPK@Software?2Classes?2GostCryptVolume@
  002c8	68 02 00 00 80	 push	 -2147483646		; 80000002H
  002cd	ff d7		 call	 edi
  002cf	85 c0		 test	 eax, eax
  002d1	0f 85 e2 04 00
	00		 jne	 $LN94@DoRegInsta

; 729  : 			goto error;
; 730  : 
; 731  : 		sprintf (szTmp, "%sGostCrypt.exe,1", szDir);

  002d7	8d 85 e8 fa ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  002dd	50		 push	 eax
  002de	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  002e4	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PJLJMABB@?$CFsGostCrypt?4exe?01?$AA@
  002e9	50		 push	 eax
  002ea	e8 00 00 00 00	 call	 _sprintf

; 732  : 		if (RegSetValueEx (hkey, "", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  002ef	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  002f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f8	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  002fb	0f 1f 44 00 00	 npad	 5
$LL65@DoRegInsta:
  00300	8a 01		 mov	 al, BYTE PTR [ecx]
  00302	41		 inc	 ecx
  00303	84 c0		 test	 al, al
  00305	75 f9		 jne	 SHORT $LL65@DoRegInsta
  00307	2b ca		 sub	 ecx, edx
  00309	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0030c	50		 push	 eax
  0030d	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00313	50		 push	 eax
  00314	6a 01		 push	 1
  00316	6a 00		 push	 0
  00318	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0031d	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00323	ff d3		 call	 ebx
  00325	85 c0		 test	 eax, eax
  00327	0f 85 8c 04 00
	00		 jne	 $LN94@DoRegInsta

; 733  : 			goto error;
; 734  : 
; 735  : 		RegCloseKey (hkey);

  0032d	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00333	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 736  : 		hkey = 0;
; 737  : 
; 738  : 		key = "Software\\Classes\\GostCryptVolume\\Shell\\open\\command";
; 739  : 		RegMessage (hwndDlg, key);

  00339	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@GDKMHJIK@Software?2Classes?2GostCryptVolume@
  0033e	56		 push	 esi
  0033f	c7 85 e4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _hkey$[ebp], 0
  00349	e8 00 00 00 00	 call	 _RegMessage
  0034e	83 c4 08	 add	 esp, 8

; 740  : 		if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 741  : 				    key,
; 742  : 				    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  00351	8d 85 e0 f9 ff
	ff		 lea	 eax, DWORD PTR _dw$[ebp]
  00357	50		 push	 eax
  00358	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR _hkey$[ebp]
  0035e	50		 push	 eax
  0035f	6a 00		 push	 0
  00361	68 06 00 02 00	 push	 131078			; 00020006H
  00366	6a 00		 push	 0
  00368	6a 00		 push	 0
  0036a	6a 00		 push	 0
  0036c	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@GDKMHJIK@Software?2Classes?2GostCryptVolume@
  00371	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00376	ff d7		 call	 edi
  00378	85 c0		 test	 eax, eax
  0037a	0f 85 39 04 00
	00		 jne	 $LN94@DoRegInsta

; 743  : 			goto error;
; 744  : 
; 745  : 		sprintf (szTmp, "\"%sGostCrypt.exe\" /v \"%%1\"", szDir );

  00380	8d 85 e8 fa ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  00386	50		 push	 eax
  00387	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0038d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OEOIONON@?$CC?$CFsGostCrypt?4exe?$CC?5?1v?5?$CC?$CF?$CF1?$CC?$AA@
  00392	50		 push	 eax
  00393	e8 00 00 00 00	 call	 _sprintf

; 746  : 		if (RegSetValueEx (hkey, "", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00398	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  0039e	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a1	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL66@DoRegInsta:
  003a4	8a 01		 mov	 al, BYTE PTR [ecx]
  003a6	41		 inc	 ecx
  003a7	84 c0		 test	 al, al
  003a9	75 f9		 jne	 SHORT $LL66@DoRegInsta
  003ab	2b ca		 sub	 ecx, edx
  003ad	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  003b0	50		 push	 eax
  003b1	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  003b7	50		 push	 eax
  003b8	6a 01		 push	 1
  003ba	6a 00		 push	 0
  003bc	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  003c1	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  003c7	ff d3		 call	 ebx
  003c9	85 c0		 test	 eax, eax
  003cb	0f 85 e8 03 00
	00		 jne	 $LN94@DoRegInsta

; 747  : 			goto error;
; 748  : 
; 749  : 		RegCloseKey (hkey);

  003d1	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  003d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 750  : 		hkey = 0;
; 751  : 
; 752  : 		key = "Software\\Classes\\.gst";
; 753  : 		BOOL typeClassChanged = TRUE;
; 754  : 		char typeClass[256];
; 755  : 		DWORD typeClassSize = sizeof (typeClass);
; 756  : 
; 757  : 		if (ReadLocalMachineRegistryString (key, "", typeClass, &typeClassSize) && typeClassSize > 0 && strcmp (typeClass, "GostCryptVolume") == 0)

  003dd	8d 85 d8 f9 ff
	ff		 lea	 eax, DWORD PTR _typeClassSize$1[ebp]
  003e3	c7 85 e4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _hkey$[ebp], 0
  003ed	50		 push	 eax
  003ee	8d 85 e8 f9 ff
	ff		 lea	 eax, DWORD PTR _typeClass$2[ebp]
  003f4	c7 85 d8 f9 ff
	ff 00 01 00 00	 mov	 DWORD PTR _typeClassSize$1[ebp], 256 ; 00000100H
  003fe	50		 push	 eax
  003ff	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00404	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HDBIFFFP@Software?2Classes?2?4gst?$AA@
  00409	be 01 00 00 00	 mov	 esi, 1
  0040e	e8 00 00 00 00	 call	 _ReadLocalMachineRegistryString
  00413	83 c4 10	 add	 esp, 16			; 00000010H
  00416	85 c0		 test	 eax, eax
  00418	74 42		 je	 SHORT $LN22@DoRegInsta
  0041a	83 bd d8 f9 ff
	ff 00		 cmp	 DWORD PTR _typeClassSize$1[ebp], 0
  00421	76 39		 jbe	 SHORT $LN22@DoRegInsta
  00423	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@
  00428	8d 85 e8 f9 ff
	ff		 lea	 eax, DWORD PTR _typeClass$2[ebp]
  0042e	66 90		 npad	 2
$LL67@DoRegInsta:
  00430	8a 10		 mov	 dl, BYTE PTR [eax]
  00432	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00434	75 1a		 jne	 SHORT $LN68@DoRegInsta
  00436	84 d2		 test	 dl, dl
  00438	74 12		 je	 SHORT $LN69@DoRegInsta
  0043a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0043d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00440	75 0e		 jne	 SHORT $LN68@DoRegInsta
  00442	83 c0 02	 add	 eax, 2
  00445	83 c1 02	 add	 ecx, 2
  00448	84 d2		 test	 dl, dl
  0044a	75 e4		 jne	 SHORT $LL67@DoRegInsta
$LN69@DoRegInsta:
  0044c	33 c0		 xor	 eax, eax
  0044e	eb 05		 jmp	 SHORT $LN70@DoRegInsta
$LN68@DoRegInsta:
  00450	1b c0		 sbb	 eax, eax
  00452	83 c8 01	 or	 eax, 1
$LN70@DoRegInsta:
  00455	33 c9		 xor	 ecx, ecx
  00457	85 c0		 test	 eax, eax
  00459	0f 44 f1	 cmove	 esi, ecx
$LN22@DoRegInsta:

; 758  : 			typeClassChanged = FALSE;
; 759  : 
; 760  : 		RegMessage (hwndDlg, key);

  0045c	8b 85 dc f9 ff
	ff		 mov	 eax, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00462	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HDBIFFFP@Software?2Classes?2?4gst?$AA@
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 _RegMessage
  0046d	83 c4 08	 add	 esp, 8

; 761  : 		if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 762  : 				    key,
; 763  : 				    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  00470	8d 85 e0 f9 ff
	ff		 lea	 eax, DWORD PTR _dw$[ebp]
  00476	50		 push	 eax
  00477	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR _hkey$[ebp]
  0047d	50		 push	 eax
  0047e	6a 00		 push	 0
  00480	68 06 00 02 00	 push	 131078			; 00020006H
  00485	6a 00		 push	 0
  00487	6a 00		 push	 0
  00489	6a 00		 push	 0
  0048b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HDBIFFFP@Software?2Classes?2?4gst?$AA@
  00490	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00495	ff d7		 call	 edi
  00497	85 c0		 test	 eax, eax
  00499	0f 85 14 03 00
	00		 jne	 $LN80@DoRegInsta

; 764  : 			goto error;
; 765  : 
; 766  : 		strcpy (szTmp, "GostCryptVolume");

  0049f	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@

; 767  : 		if (RegSetValueEx (hkey, "", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  004a6	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  004ac	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  004af	0f 11 85 ec fb
	ff ff		 movups	 XMMWORD PTR _szTmp$[ebp], xmm0
$LL71@DoRegInsta:
  004b6	8a 01		 mov	 al, BYTE PTR [ecx]
  004b8	41		 inc	 ecx
  004b9	84 c0		 test	 al, al
  004bb	75 f9		 jne	 SHORT $LL71@DoRegInsta
  004bd	2b ca		 sub	 ecx, edx
  004bf	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  004c2	50		 push	 eax
  004c3	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  004c9	50		 push	 eax
  004ca	6a 01		 push	 1
  004cc	6a 00		 push	 0
  004ce	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  004d3	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  004d9	ff d3		 call	 ebx
  004db	85 c0		 test	 eax, eax
  004dd	0f 85 d0 02 00
	00		 jne	 $LN80@DoRegInsta

; 768  : 			goto error;
; 769  : 		
; 770  : 		RegCloseKey (hkey);

  004e3	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  004e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 771  : 		hkey = 0;

  004ef	c7 85 e4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _hkey$[ebp], 0
  004f9	85 f6		 test	 esi, esi

; 772  : 
; 773  : 		if (typeClassChanged)

  004fb	74 11		 je	 SHORT $LN27@DoRegInsta

; 774  : 			SHChangeNotify (SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

  004fd	6a 00		 push	 0
  004ff	6a 00		 push	 0
  00501	6a 00		 push	 0
  00503	68 00 00 00 08	 push	 134217728		; 08000000H
  00508	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHChangeNotify@16
$LN27@DoRegInsta:

; 775  : 	}
; 776  : 
; 777  : 	key = "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\GostCrypt";
; 778  : 	RegMessage (hwndDlg, key);

  0050e	8b b5 dc f9 ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00514	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@MNMIDBOE@Software?2Microsoft?2Windows?2Curre@
  00519	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LFAEJJAB@ADDING_REG?$AA@
  0051e	56		 push	 esi
  0051f	e8 00 00 00 00	 call	 _StatusMessageParam
  00524	83 c4 0c	 add	 esp, 12			; 0000000cH

; 779  : 	if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 780  : 		key,
; 781  : 		0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  00527	8d 85 e0 f9 ff
	ff		 lea	 eax, DWORD PTR _dw$[ebp]
  0052d	50		 push	 eax
  0052e	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR _hkey$[ebp]
  00534	50		 push	 eax
  00535	6a 00		 push	 0
  00537	68 06 00 02 00	 push	 131078			; 00020006H
  0053c	6a 00		 push	 0
  0053e	6a 00		 push	 0
  00540	6a 00		 push	 0
  00542	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@MNMIDBOE@Software?2Microsoft?2Windows?2Curre@
  00547	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0054c	ff d7		 call	 edi
  0054e	85 c0		 test	 eax, eax
  00550	0f 85 63 02 00
	00		 jne	 $LN94@DoRegInsta

; 782  : 		goto error;
; 783  : 
; 784  : 	/* IMPORTANT: IF YOU CHANGE THIS IN ANY WAY, REVISE AND UPDATE SetInstallationPath() ACCORDINGLY! */ 
; 785  : 	sprintf (szTmp, "\"%sGostCrypt Setup.exe\" /u", szDir);

  00556	8d 85 e8 fa ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  0055c	50		 push	 eax
  0055d	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00563	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FHBMAFAG@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?5?1u?$AA@
  00568	50		 push	 eax
  00569	e8 00 00 00 00	 call	 _sprintf

; 786  : 	if (RegSetValueEx (hkey, "UninstallString", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  0056e	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  00574	83 c4 0c	 add	 esp, 12			; 0000000cH
  00577	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0057a	66 0f 1f 44 00
	00		 npad	 6
$LL72@DoRegInsta:
  00580	8a 01		 mov	 al, BYTE PTR [ecx]
  00582	41		 inc	 ecx
  00583	84 c0		 test	 al, al
  00585	75 f9		 jne	 SHORT $LL72@DoRegInsta
  00587	2b ca		 sub	 ecx, edx
  00589	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0058c	50		 push	 eax
  0058d	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00593	50		 push	 eax
  00594	6a 01		 push	 1
  00596	6a 00		 push	 0
  00598	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OJMJCMCH@UninstallString?$AA@
  0059d	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  005a3	ff d3		 call	 ebx
  005a5	85 c0		 test	 eax, eax
  005a7	0f 85 0c 02 00
	00		 jne	 $LN94@DoRegInsta

; 787  : 		goto error;
; 788  : 
; 789  : 	sprintf (szTmp, "\"%sGostCrypt Setup.exe\" /c", szDir);

  005ad	8d 85 e8 fa ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  005b3	50		 push	 eax
  005b4	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  005ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@ELIELANB@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?5?1c?$AA@
  005bf	50		 push	 eax
  005c0	e8 00 00 00 00	 call	 _sprintf

; 790  : 	if (RegSetValueEx (hkey, "ModifyPath", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  005c5	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  005cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  005ce	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL73@DoRegInsta:
  005d1	8a 01		 mov	 al, BYTE PTR [ecx]
  005d3	41		 inc	 ecx
  005d4	84 c0		 test	 al, al
  005d6	75 f9		 jne	 SHORT $LL73@DoRegInsta
  005d8	2b ca		 sub	 ecx, edx
  005da	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  005dd	50		 push	 eax
  005de	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  005e4	50		 push	 eax
  005e5	6a 01		 push	 1
  005e7	6a 00		 push	 0
  005e9	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OGHNHFGG@ModifyPath?$AA@
  005ee	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  005f4	ff d3		 call	 ebx
  005f6	85 c0		 test	 eax, eax
  005f8	0f 85 bb 01 00
	00		 jne	 $LN94@DoRegInsta

; 791  : 		goto error;
; 792  : 
; 793  : 	sprintf (szTmp, "\"%sGostCrypt Setup.exe\"", szDir);

  005fe	8d 85 e8 fa ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  00604	50		 push	 eax
  00605	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0060b	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BBPBNAKG@?$CC?$CFsGostCrypt?5Setup?4exe?$CC?$AA@
  00610	50		 push	 eax
  00611	e8 00 00 00 00	 call	 _sprintf

; 794  : 	if (RegSetValueEx (hkey, "DisplayIcon", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00616	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  0061c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0061f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL74@DoRegInsta:
  00622	8a 01		 mov	 al, BYTE PTR [ecx]
  00624	41		 inc	 ecx
  00625	84 c0		 test	 al, al
  00627	75 f9		 jne	 SHORT $LL74@DoRegInsta
  00629	2b ca		 sub	 ecx, edx
  0062b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0062e	50		 push	 eax
  0062f	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00635	50		 push	 eax
  00636	6a 01		 push	 1
  00638	6a 00		 push	 0
  0063a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DDCGOGKB@DisplayIcon?$AA@
  0063f	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00645	ff d3		 call	 ebx
  00647	85 c0		 test	 eax, eax
  00649	0f 85 6a 01 00
	00		 jne	 $LN94@DoRegInsta

; 795  : 		goto error;
; 796  : 
; 797  : 	strcpy (szTmp, VERSION_STRING);

  0064f	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05OJPKCACG@1?43?41?$AA@

; 798  : 	if (RegSetValueEx (hkey, "DisplayVersion", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00654	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  0065a	89 85 ec fb ff
	ff		 mov	 DWORD PTR _szTmp$[ebp], eax
  00660	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00663	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_05OJPKCACG@1?43?41?$AA@+4
  00669	66 89 85 f0 fb
	ff ff		 mov	 WORD PTR _szTmp$[ebp+4], ax
$LL75@DoRegInsta:
  00670	8a 01		 mov	 al, BYTE PTR [ecx]
  00672	41		 inc	 ecx
  00673	84 c0		 test	 al, al
  00675	75 f9		 jne	 SHORT $LL75@DoRegInsta
  00677	2b ca		 sub	 ecx, edx
  00679	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0067c	50		 push	 eax
  0067d	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00683	50		 push	 eax
  00684	6a 01		 push	 1
  00686	6a 00		 push	 0
  00688	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BNDLMAIF@DisplayVersion?$AA@
  0068d	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00693	ff d3		 call	 ebx
  00695	85 c0		 test	 eax, eax
  00697	0f 85 1c 01 00
	00		 jne	 $LN94@DoRegInsta

; 799  : 		goto error;
; 800  : 		
; 801  : 	strcpy (szTmp, "GostCrypt");

  0069d	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@

; 802  : 	if (RegSetValueEx (hkey, "DisplayName", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  006a5	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  006ab	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_09NKHKFHLH@GostCrypt?$AA@+8
  006b1	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  006b4	66 0f d6 85 ec
	fb ff ff	 movq	 QWORD PTR _szTmp$[ebp], xmm0
  006bc	66 89 85 f4 fb
	ff ff		 mov	 WORD PTR _szTmp$[ebp+8], ax
$LL76@DoRegInsta:
  006c3	8a 01		 mov	 al, BYTE PTR [ecx]
  006c5	41		 inc	 ecx
  006c6	84 c0		 test	 al, al
  006c8	75 f9		 jne	 SHORT $LL76@DoRegInsta
  006ca	2b ca		 sub	 ecx, edx
  006cc	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  006cf	50		 push	 eax
  006d0	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  006d6	50		 push	 eax
  006d7	6a 01		 push	 1
  006d9	6a 00		 push	 0
  006db	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MLHPPPJP@DisplayName?$AA@
  006e0	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  006e6	ff d3		 call	 ebx
  006e8	85 c0		 test	 eax, eax
  006ea	0f 85 c9 00 00
	00		 jne	 $LN94@DoRegInsta

; 803  : 		goto error;
; 804  : 
; 805  : 	strcpy (szTmp, "GostCrypt Developers");

  006f0	a1 10 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BF@JOANFFGE@GostCrypt?5Developers?$AA@+16

; 806  : 	if (RegSetValueEx (hkey, "Publisher", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  006f5	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  006fb	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BF@JOANFFGE@GostCrypt?5Developers?$AA@
  00702	89 85 fc fb ff
	ff		 mov	 DWORD PTR _szTmp$[ebp+16], eax
  00708	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0070b	a0 14 00 00 00	 mov	 al, BYTE PTR ??_C@_0BF@JOANFFGE@GostCrypt?5Developers?$AA@+20
  00710	0f 11 85 ec fb
	ff ff		 movups	 XMMWORD PTR _szTmp$[ebp], xmm0
  00717	88 85 00 fc ff
	ff		 mov	 BYTE PTR _szTmp$[ebp+20], al
  0071d	0f 1f 00	 npad	 3
$LL77@DoRegInsta:
  00720	8a 01		 mov	 al, BYTE PTR [ecx]
  00722	41		 inc	 ecx
  00723	84 c0		 test	 al, al
  00725	75 f9		 jne	 SHORT $LL77@DoRegInsta
  00727	2b ca		 sub	 ecx, edx
  00729	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0072c	50		 push	 eax
  0072d	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00733	50		 push	 eax
  00734	6a 01		 push	 1
  00736	6a 00		 push	 0
  00738	68 00 00 00 00	 push	 OFFSET ??_C@_09PNIDBPNC@Publisher?$AA@
  0073d	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  00743	ff d3		 call	 ebx
  00745	85 c0		 test	 eax, eax
  00747	75 70		 jne	 SHORT $LN94@DoRegInsta

; 807  : 		goto error;
; 808  : 
; 809  : 	strcpy (szTmp, GST_HOMEPAGE);

  00749	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BK@EMBCECD@http?3?1?1www?4gostcrypt?4org?1?$AA@
  00750	66 a1 18 00 00
	00		 mov	 ax, WORD PTR ??_C@_0BK@EMBCECD@http?3?1?1www?4gostcrypt?4org?1?$AA@+24

; 810  : 	if (RegSetValueEx (hkey, "URLInfoAbout", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00756	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  0075c	66 89 85 04 fc
	ff ff		 mov	 WORD PTR _szTmp$[ebp+24], ax
  00763	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00766	0f 11 85 ec fb
	ff ff		 movups	 XMMWORD PTR _szTmp$[ebp], xmm0
  0076d	f3 0f 7e 05 10
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0BK@EMBCECD@http?3?1?1www?4gostcrypt?4org?1?$AA@+16
  00775	66 0f d6 85 fc
	fb ff ff	 movq	 QWORD PTR _szTmp$[ebp+16], xmm0
  0077d	0f 1f 00	 npad	 3
$LL78@DoRegInsta:
  00780	8a 01		 mov	 al, BYTE PTR [ecx]
  00782	41		 inc	 ecx
  00783	84 c0		 test	 al, al
  00785	75 f9		 jne	 SHORT $LL78@DoRegInsta
  00787	2b ca		 sub	 ecx, edx
  00789	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0078c	50		 push	 eax
  0078d	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00793	50		 push	 eax
  00794	6a 01		 push	 1
  00796	6a 00		 push	 0
  00798	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@
  0079d	ff b5 e4 f9 ff
	ff		 push	 DWORD PTR _hkey$[ebp]
  007a3	ff d3		 call	 ebx
  007a5	33 db		 xor	 ebx, ebx
  007a7	b9 01 00 00 00	 mov	 ecx, 1
  007ac	85 c0		 test	 eax, eax
  007ae	0f 44 d9	 cmove	 ebx, ecx
  007b1	eb 08		 jmp	 SHORT $error$97
$LN80@DoRegInsta:
  007b3	8b b5 dc f9 ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
$LN94@DoRegInsta:
  007b9	33 db		 xor	 ebx, ebx
$error$97:

; 811  : 		goto error;
; 812  : 
; 813  : 	bOK = TRUE;
; 814  : 
; 815  : error:
; 816  : 	if (hkey != 0)

  007bb	8b 85 e4 f9 ff
	ff		 mov	 eax, DWORD PTR _hkey$[ebp]
  007c1	85 c0		 test	 eax, eax
  007c3	74 07		 je	 SHORT $LN44@DoRegInsta

; 817  : 		RegCloseKey (hkey);

  007c5	50		 push	 eax
  007c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN44@DoRegInsta:

; 818  : 
; 819  : 	if (bOK == FALSE)

  007cc	85 db		 test	 ebx, ebx
  007ce	75 13		 jne	 SHORT $LN45@DoRegInsta

; 820  : 	{
; 821  : 		handleWin32Error (hwndDlg);

  007d0	56		 push	 esi
  007d1	e8 00 00 00 00	 call	 _handleWin32Error

; 822  : 		Error ("REG_INSTALL_FAILED");

  007d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HFNFAFOP@REG_INSTALL_FAILED?$AA@
  007db	e8 00 00 00 00	 call	 _Error
  007e0	83 c4 08	 add	 esp, 8
$LN45@DoRegInsta:

; 823  : 	}
; 824  : 	
; 825  : 	// Register COM servers for UAC
; 826  : 	if (IsOSAtLeast (WIN_VISTA))

  007e3	6a 0b		 push	 11			; 0000000bH
  007e5	e8 00 00 00 00	 call	 _IsOSAtLeast
  007ea	83 c4 04	 add	 esp, 4
  007ed	85 c0		 test	 eax, eax
  007ef	74 33		 je	 SHORT $LN47@DoRegInsta

; 827  : 	{
; 828  : 		if (!RegisterComServers (szDir))

  007f1	8d 85 e8 fa ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  007f7	50		 push	 eax
  007f8	e8 00 00 00 00	 call	 _RegisterComServers
  007fd	83 c4 04	 add	 esp, 4
  00800	85 c0		 test	 eax, eax
  00802	75 20		 jne	 SHORT $LN47@DoRegInsta

; 829  : 		{
; 830  : 			Error ("COM_REG_FAILED");

  00804	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LLMHDMAL@COM_REG_FAILED?$AA@
  00809	e8 00 00 00 00	 call	 _Error
  0080e	83 c4 04	 add	 esp, 4

; 831  : 			return FALSE;

  00811	33 c0		 xor	 eax, eax
  00813	5f		 pop	 edi
  00814	5b		 pop	 ebx
  00815	5e		 pop	 esi

; 832  : 		}
; 833  : 	}
; 834  : 
; 835  : 	return bOK;
; 836  : }

  00816	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00819	33 cd		 xor	 ecx, ebp
  0081b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00820	8b e5		 mov	 esp, ebp
  00822	5d		 pop	 ebp
  00823	c3		 ret	 0
$LN47@DoRegInsta:
  00824	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00827	8b c3		 mov	 eax, ebx
  00829	5f		 pop	 edi
  0082a	5b		 pop	 ebx
  0082b	33 cd		 xor	 ecx, ebp
  0082d	5e		 pop	 esi
  0082e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00833	8b e5		 mov	 esp, ebp
  00835	5d		 pop	 ebp
  00836	c3		 ret	 0
_DoRegInstall ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _DoFilesInstall
_TEXT	SEGMENT
_driver64$1$ = -2872					; size = 4
_lpMsgBuf$1 = -2868					; size = 4
_fileNo$1$ = -2864					; size = 4
_szDestDir$GSCopy$1$ = -2860				; size = 4
_bResult$1$ = -2856					; size = 4
tv475 = -2852						; size = 4
_hwndDlg$GSCopy$1$ = -2848				; size = 4
_st$2 = -2844						; size = 56
_f$3 = -2788						; size = 320
_mp$4 = -2728						; size = 260
_servicePath$5 = -2468					; size = 24
_szTmp2$6 = -2444					; size = 1400
_curFileName$ = -1044					; size = 260
_d$7 = -784						; size = 520
_d$8 = -784						; size = 520
_szDir$9 = -524						; size = 260
_szTmp$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_DoFilesInstall PROC					; COMDAT

; 409  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 0b 00
	00		 sub	 esp, 2872		; 00000b38H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  00017	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _curFileName$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 0c	 mov	 esi, DWORD PTR _szDestDir$[ebp]
  00021	68 04 01 00 00	 push	 260			; 00000104H
  00026	6a 00		 push	 0
  00028	50		 push	 eax
  00029	89 9d e0 f4 ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], ebx
  0002f	89 b5 d4 f4 ff
	ff		 mov	 DWORD PTR _szDestDir$GSCopy$1$[ebp], esi
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 410  : 	/* WARNING: Note that, despite its name, this function is used during UNinstallation as well. */
; 411  : 
; 412  : 	char szTmp[GST_MAX_PATH];
; 413  : 	BOOL bOK = TRUE;
; 414  : 	int i, x, fileNo;
; 415  : 	char curFileName [GST_MAX_PATH] = {0};
; 416  : 
; 417  : 	if (!bUninstall && !bDevm)

  0003d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00044	75 42		 jne	 SHORT $LN9@DoFilesIns
  00046	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  0004d	75 39		 jne	 SHORT $LN9@DoFilesIns

; 418  : 	{
; 419  : 		// Self-extract all files to memory
; 420  : 
; 421  : 		GetModuleFileName (NULL, szTmp, sizeof (szTmp));

  0004f	68 04 01 00 00	 push	 260			; 00000104H
  00054	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0005a	50		 push	 eax
  0005b	6a 00		 push	 0
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 422  : 
; 423  : 		if (!SelfExtractInMemory (szTmp))

  00063	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _SelfExtractInMemory
  0006f	83 c4 04	 add	 esp, 4
  00072	85 c0		 test	 eax, eax
  00074	75 12		 jne	 SHORT $LN9@DoFilesIns
$LN182@DoFilesIns:
  00076	5e		 pop	 esi

; 424  : 			return FALSE;

  00077	33 c0		 xor	 eax, eax
  00079	5b		 pop	 ebx

; 655  : }

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	33 cd		 xor	 ecx, ebp
  0007f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN9@DoFilesIns:

; 425  : 	}
; 426  : 
; 427  : 	x = strlen (szDestDir);

  00088	8b ce		 mov	 ecx, esi
  0008a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0008d	0f 1f 00	 npad	 3
$LL143@DoFilesIns:
  00090	8a 01		 mov	 al, BYTE PTR [ecx]
  00092	41		 inc	 ecx
  00093	84 c0		 test	 al, al
  00095	75 f9		 jne	 SHORT $LL143@DoFilesIns
  00097	2b ca		 sub	 ecx, edx

; 428  : 	if (x < 2)

  00099	83 f9 02	 cmp	 ecx, 2
  0009c	7c d8		 jl	 SHORT $LN182@DoFilesIns

; 429  : 		return FALSE;
; 430  : 
; 431  : 	if (szDestDir[x - 1] != '\\')

  0009e	80 7c 0e ff 5c	 cmp	 BYTE PTR [esi+ecx-1], 92 ; 0000005cH
  000a3	57		 push	 edi
  000a4	74 1d		 je	 SHORT $LN11@DoFilesIns

; 432  : 		strcat (szDestDir, "\\");

  000a6	8d 7e ff	 lea	 edi, DWORD PTR [esi-1]
  000a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL144@DoFilesIns:
  000b0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000b3	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  000b6	84 c0		 test	 al, al
  000b8	75 f6		 jne	 SHORT $LL144@DoFilesIns
  000ba	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  000c0	66 89 07	 mov	 WORD PTR [edi], ax
$LN11@DoFilesIns:

; 433  : 
; 434  : 	for (i = 0; i < sizeof (szFiles) / sizeof (szFiles[0]); i++)

  000c3	33 ff		 xor	 edi, edi
  000c5	89 bd dc f4 ff
	ff		 mov	 DWORD PTR tv475[ebp], edi
  000cb	0f 1f 44 00 00	 npad	 5
$LL4@DoFilesIns:

; 435  : 	{
; 436  : 		BOOL bResult;
; 437  : 		char szDir[GST_MAX_PATH];
; 438  : 
; 439  : 		if (strstr (szFiles[i], "GostCrypt Setup") != 0)

  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IEENJPHG@GostCrypt?5Setup?$AA@
  000d5	ff b7 00 00 00
	00		 push	 DWORD PTR _szFiles[edi]
  000db	e8 00 00 00 00	 call	 _strstr
  000e0	83 c4 08	 add	 esp, 8
  000e3	85 c0		 test	 eax, eax
  000e5	74 1a		 je	 SHORT $LN14@DoFilesIns

; 440  : 		{
; 441  : 			if (bUninstall)

  000e7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  000ee	0f 85 f4 05 00
	00		 jne	 $LN2@DoFilesIns

; 442  : 				continue;	// Prevent 'access denied' error
; 443  : 
; 444  : 			if (bRepairMode)

  000f4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRepairMode, 0
  000fb	0f 85 e7 05 00
	00		 jne	 $LN2@DoFilesIns
$LN14@DoFilesIns:

; 445  : 				continue;	// Destination = target
; 446  : 		}
; 447  : 
; 448  : 		if (*szFiles[i] == 'A')

  00101	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edi]
  00107	8a 00		 mov	 al, BYTE PTR [eax]
  00109	3c 41		 cmp	 al, 65			; 00000041H
  0010b	75 1c		 jne	 SHORT $LN15@DoFilesIns

; 449  : 			strcpy (szDir, szDestDir);

  0010d	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _szDir$9[ebp]
  00113	8b ce		 mov	 ecx, esi
  00115	2b d6		 sub	 edx, esi
$LL54@DoFilesIns:
  00117	8a 01		 mov	 al, BYTE PTR [ecx]
  00119	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0011c	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00120	84 c0		 test	 al, al
  00122	75 f3		 jne	 SHORT $LL54@DoFilesIns
  00124	e9 a0 00 00 00	 jmp	 $LN20@DoFilesIns
$LN15@DoFilesIns:

; 450  : /**
; 451  :  *
; 452  :  *	\fn else if (*szFiles[i] == 'D')
; 453  :  *	\brief
; 454  :  *	\param[in] *szFiles[i] ==
; 455  :  *	\return
; 456  :  *
; 457  :  */
; 458  : 		else if (*szFiles[i] == 'D')

  00129	3c 44		 cmp	 al, 68			; 00000044H
  0012b	0f 85 82 00 00
	00		 jne	 $LN17@DoFilesIns

; 459  : 		{
; 460  : 			GetSystemDirectory (szDir, sizeof (szDir));

  00131	68 04 01 00 00	 push	 260			; 00000104H
  00136	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szDir$9[ebp]
  0013c	50		 push	 eax
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemDirectoryA@8

; 461  : 
; 462  : 			x = strlen (szDir);

  00143	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _szDir$9[ebp]
  00149	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0014c	0f 1f 40 00	 npad	 4
$LL145@DoFilesIns:
  00150	8a 01		 mov	 al, BYTE PTR [ecx]
  00152	41		 inc	 ecx
  00153	84 c0		 test	 al, al
  00155	75 f9		 jne	 SHORT $LL145@DoFilesIns
  00157	2b ca		 sub	 ecx, edx

; 463  : 			if (szDir[x - 1] != '\\')

  00159	80 bc 0d f3 fd
	ff ff 5c	 cmp	 BYTE PTR _szDir$9[ebp+ecx-1], 92 ; 0000005cH
  00161	74 26		 je	 SHORT $LN19@DoFilesIns

; 464  : 				strcat (szDir, "\\");

  00163	8d bd f4 fd ff
	ff		 lea	 edi, DWORD PTR _szDir$9[ebp]
  00169	4f		 dec	 edi
  0016a	66 0f 1f 44 00
	00		 npad	 6
$LL146@DoFilesIns:
  00170	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00173	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00176	84 c0		 test	 al, al
  00178	75 f6		 jne	 SHORT $LL146@DoFilesIns
  0017a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  00180	66 89 07	 mov	 WORD PTR [edi], ax
  00183	8b bd dc f4 ff
	ff		 mov	 edi, DWORD PTR tv475[ebp]
$LN19@DoFilesIns:

; 465  : 
; 466  : 			strcat (szDir, "Drivers\\");

  00189	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _szDir$9[ebp]
  0018f	49		 dec	 ecx
$LL147@DoFilesIns:
  00190	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00193	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00196	84 c0		 test	 al, al
  00198	75 f6		 jne	 SHORT $LL147@DoFilesIns
  0019a	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_08GHPFJMCG@Drivers?2?$AA@
  0019f	89 01		 mov	 DWORD PTR [ecx], eax
  001a1	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_08GHPFJMCG@Drivers?2?$AA@+4
  001a6	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001a9	a0 08 00 00 00	 mov	 al, BYTE PTR ??_C@_08GHPFJMCG@Drivers?2?$AA@+8
  001ae	88 41 08	 mov	 BYTE PTR [ecx+8], al
  001b1	eb 16		 jmp	 SHORT $LN20@DoFilesIns
$LN17@DoFilesIns:

; 467  : 		}
; 468  : 		else if (*szFiles[i] == 'W')

  001b3	3c 57		 cmp	 al, 87			; 00000057H
  001b5	75 12		 jne	 SHORT $LN20@DoFilesIns

; 469  : 			GetWindowsDirectory (szDir, sizeof (szDir));

  001b7	68 04 01 00 00	 push	 260			; 00000104H
  001bc	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szDir$9[ebp]
  001c2	50		 push	 eax
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowsDirectoryA@8
$LN20@DoFilesIns:

; 470  : 
; 471  : 		if (*szFiles[i] == 'I')

  001c9	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edi]
  001cf	80 38 49	 cmp	 BYTE PTR [eax], 73	; 00000049H
  001d2	0f 84 10 05 00
	00		 je	 $LN2@DoFilesIns

; 472  : 			continue;
; 473  : 
; 474  : 		sprintf (szTmp, "%s%s", szDir, szFiles[i] + 1);

  001d8	40		 inc	 eax
  001d9	50		 push	 eax
  001da	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szDir$9[ebp]
  001e0	50		 push	 eax
  001e1	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001ec	50		 push	 eax
  001ed	e8 00 00 00 00	 call	 _sprintf
  001f2	83 c4 10	 add	 esp, 16			; 00000010H

; 475  : 
; 476  : 		if (bUninstall == FALSE)

  001f5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  001fc	75 0e		 jne	 SHORT $LN22@DoFilesIns

; 477  : 			CopyMessage (hwndDlg, szTmp);

  001fe	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00204	50		 push	 eax
  00205	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHILBMI@INSTALLING?$AA@

; 478  : 		else

  0020a	eb 15		 jmp	 SHORT $LN178@DoFilesIns
$LN22@DoFilesIns:

; 479  : 			RemoveMessage (hwndDlg, szTmp);

  0020c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00213	75 15		 jne	 SHORT $LN64@DoFilesIns
  00215	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0021b	50		 push	 eax
  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
$LN178@DoFilesIns:
  00221	53		 push	 ebx
  00222	e8 00 00 00 00	 call	 _StatusMessageParam
  00227	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN64@DoFilesIns:

; 480  : 
; 481  : 		if (bUninstall == FALSE)

  0022a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00231	0f 85 1b 04 00
	00		 jne	 $LN24@DoFilesIns

; 482  : 		{
; 483  : 			SetCurrentDirectory (SetupFilesDir);

  00237	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCurrentDirectoryA@4

; 484  : 
; 485  : 			if (strstr (szFiles[i], "GostCrypt Setup") != 0)

  00242	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IEENJPHG@GostCrypt?5Setup?$AA@
  00247	ff b7 00 00 00
	00		 push	 DWORD PTR _szFiles[edi]
  0024d	e8 00 00 00 00	 call	 _strstr
  00252	83 c4 08	 add	 esp, 8
  00255	85 c0		 test	 eax, eax
  00257	74 31		 je	 SHORT $LN26@DoFilesIns

; 486  : 			{
; 487  : 				// Copy ourselves (the distribution package) to the destination location as 'GostCrypt Setup.exe'
; 488  : 
; 489  : 				char mp[MAX_PATH];
; 490  : 
; 491  : 				GetModuleFileName (NULL, mp, sizeof (mp));

  00259	68 04 01 00 00	 push	 260			; 00000104H
  0025e	8d 85 58 f5 ff
	ff		 lea	 eax, DWORD PTR _mp$4[ebp]
  00264	50		 push	 eax
  00265	6a 00		 push	 0
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 492  : 				bResult = GSTCopyFile (mp, szTmp);

  0026d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00273	50		 push	 eax
  00274	8d 85 58 f5 ff
	ff		 lea	 eax, DWORD PTR _mp$4[ebp]
  0027a	50		 push	 eax
  0027b	e8 00 00 00 00	 call	 _GSTCopyFile
  00280	83 c4 08	 add	 esp, 8
  00283	8b f0		 mov	 esi, eax

; 493  : 			}
; 494  : 			else

  00285	e9 7b 01 00 00	 jmp	 $err$185
$LN26@DoFilesIns:

; 495  : 			{
; 496  : 				BOOL driver64 = FALSE;
; 497  : 
; 498  : 				strncpy (curFileName, szFiles[i] + 1, strlen (szFiles[i]) - 1);

  0028a	8b 97 00 00 00
	00		 mov	 edx, DWORD PTR _szFiles[edi]
  00290	33 db		 xor	 ebx, ebx
  00292	8b ca		 mov	 ecx, edx
  00294	89 9d c8 f4 ff
	ff		 mov	 DWORD PTR _driver64$1$[ebp], ebx
  0029a	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0029d	0f 1f 00	 npad	 3
$LL148@DoFilesIns:
  002a0	8a 01		 mov	 al, BYTE PTR [ecx]
  002a2	41		 inc	 ecx
  002a3	84 c0		 test	 al, al
  002a5	75 f9		 jne	 SHORT $LL148@DoFilesIns
  002a7	2b ce		 sub	 ecx, esi
  002a9	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  002ac	50		 push	 eax
  002ad	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  002b0	50		 push	 eax
  002b1	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _curFileName$[ebp]
  002b7	50		 push	 eax
  002b8	e8 00 00 00 00	 call	 _strncpy

; 499  : 				curFileName [strlen (szFiles[i]) - 1] = 0;

  002bd	8b 8f 00 00 00
	00		 mov	 ecx, DWORD PTR _szFiles[edi]
  002c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c6	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  002c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL149@DoFilesIns:
  002d0	8a 01		 mov	 al, BYTE PTR [ecx]
  002d2	41		 inc	 ecx
  002d3	84 c0		 test	 al, al
  002d5	75 f9		 jne	 SHORT $LL149@DoFilesIns
  002d7	2b ca		 sub	 ecx, edx
  002d9	49		 dec	 ecx
  002da	81 f9 04 01 00
	00		 cmp	 ecx, 260		; 00000104H
  002e0	0f 83 42 05 00
	00		 jae	 $LN183@DoFilesIns
  002e6	88 9c 0d ec fb
	ff ff		 mov	 BYTE PTR _curFileName$[ebp+ecx], bl

; 500  : 
; 501  : 				if (Is64BitOs ()
; 502  : 					&& strcmp (szFiles[i], "Dgostcrypt.sys") == 0)

  002ed	e8 00 00 00 00	 call	 _Is64BitOs
  002f2	85 c0		 test	 eax, eax
  002f4	74 55		 je	 SHORT $LN28@DoFilesIns
  002f6	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edi]
  002fc	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0P@MGBPBMGL@Dgostcrypt?4sys?$AA@
$LL150@DoFilesIns:
  00301	8a 10		 mov	 dl, BYTE PTR [eax]
  00303	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00305	75 1a		 jne	 SHORT $LN151@DoFilesIns
  00307	84 d2		 test	 dl, dl
  00309	74 12		 je	 SHORT $LN152@DoFilesIns
  0030b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0030e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00311	75 0e		 jne	 SHORT $LN151@DoFilesIns
  00313	83 c0 02	 add	 eax, 2
  00316	83 c1 02	 add	 ecx, 2
  00319	84 d2		 test	 dl, dl
  0031b	75 e4		 jne	 SHORT $LL150@DoFilesIns
$LN152@DoFilesIns:
  0031d	33 c0		 xor	 eax, eax
  0031f	eb 05		 jmp	 SHORT $LN153@DoFilesIns
$LN151@DoFilesIns:
  00321	1b c0		 sbb	 eax, eax
  00323	83 c8 01	 or	 eax, 1
$LN153@DoFilesIns:
  00326	85 c0		 test	 eax, eax
  00328	75 21		 jne	 SHORT $LN28@DoFilesIns

; 503  : 				{
; 504  : 					driver64 = TRUE;
; 505  : 					strncpy (curFileName, FILENAME_64BIT_DRIVER, sizeof (FILENAME_64BIT_DRIVER));

  0032a	6a 12		 push	 18			; 00000012H
  0032c	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _curFileName$[ebp]
  00332	bb 01 00 00 00	 mov	 ebx, 1
  00337	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MDIFFMMP@gostcrypt?9x64?4sys?$AA@
  0033c	50		 push	 eax
  0033d	89 9d c8 f4 ff
	ff		 mov	 DWORD PTR _driver64$1$[ebp], ebx
  00343	e8 00 00 00 00	 call	 _strncpy
  00348	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@DoFilesIns:

; 506  : 				}
; 507  : 
; 508  : 				if (!bDevm)

  0034b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  00352	0f 85 20 02 00
	00		 jne	 $LN29@DoFilesIns

; 509  : 				{
; 510  : 					bResult = FALSE;
; 511  : 
; 512  : 					// Find the correct decompressed file in memory
; 513  : 					for (fileNo = 0; fileNo < NBR_COMPRESSED_FILES; fileNo++)

  00358	33 c0		 xor	 eax, eax
  0035a	c7 85 d8 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR _bResult$1$[ebp], 0

; 514  : 					{
; 515  : 						// Write the file (stored in memory) directly to the destination location 
; 516  : 						// (there will be no temporary files).
; 517  : 						if (memcmp (
; 518  : 							curFileName, 
; 519  : 							Decompressed_Files[fileNo].fileName, 
; 520  : 							min (strlen (curFileName), (size_t) Decompressed_Files[fileNo].fileNameLength)) == 0)

  00364	8d 9d ec fb ff
	ff		 lea	 ebx, DWORD PTR _curFileName$[ebp]
  0036a	89 85 d0 f4 ff
	ff		 mov	 DWORD PTR _fileNo$1$[ebp], eax
  00370	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
$LL154@DoFilesIns:
  00373	8a 03		 mov	 al, BYTE PTR [ebx]
  00375	43		 inc	 ebx
  00376	84 c0		 test	 al, al
  00378	75 f9		 jne	 SHORT $LL154@DoFilesIns
  0037a	2b d9		 sub	 ebx, ecx
  0037c	33 ff		 xor	 edi, edi
  0037e	66 90		 npad	 2
$LL7@DoFilesIns:
  00380	8b b7 04 00 00
	00		 mov	 esi, DWORD PTR _Decompressed_Files[edi+4]
  00386	8d 95 ec fb ff
	ff		 lea	 edx, DWORD PTR _curFileName$[ebp]
  0038c	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _Decompressed_Files[edi]
  00392	3b de		 cmp	 ebx, esi
  00394	0f 42 f3	 cmovb	 esi, ebx
  00397	83 ee 04	 sub	 esi, 4
  0039a	72 15		 jb	 SHORT $LN157@DoFilesIns
  0039c	0f 1f 40 00	 npad	 4
$LL158@DoFilesIns:
  003a0	8b 0a		 mov	 ecx, DWORD PTR [edx]
  003a2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003a4	75 14		 jne	 SHORT $LN156@DoFilesIns
  003a6	83 c2 04	 add	 edx, 4
  003a9	83 c0 04	 add	 eax, 4
  003ac	83 ee 04	 sub	 esi, 4
  003af	73 ef		 jae	 SHORT $LL158@DoFilesIns
$LN157@DoFilesIns:
  003b1	83 fe fc	 cmp	 esi, -4			; fffffffcH
  003b4	0f 84 97 00 00
	00		 je	 $LN155@DoFilesIns
$LN156@DoFilesIns:
  003ba	8a 0a		 mov	 cl, BYTE PTR [edx]
  003bc	3a 08		 cmp	 cl, BYTE PTR [eax]
  003be	75 2b		 jne	 SHORT $LN159@DoFilesIns
  003c0	83 fe fd	 cmp	 esi, -3			; fffffffdH
  003c3	0f 84 88 00 00
	00		 je	 $LN155@DoFilesIns
  003c9	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  003cc	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  003cf	75 1a		 jne	 SHORT $LN159@DoFilesIns
  003d1	83 fe fe	 cmp	 esi, -2			; fffffffeH
  003d4	74 7b		 je	 SHORT $LN155@DoFilesIns
  003d6	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  003d9	3a 48 02	 cmp	 cl, BYTE PTR [eax+2]
  003dc	75 0d		 jne	 SHORT $LN159@DoFilesIns
  003de	83 fe ff	 cmp	 esi, -1
  003e1	74 6e		 je	 SHORT $LN155@DoFilesIns
  003e3	8a 4a 03	 mov	 cl, BYTE PTR [edx+3]
  003e6	3a 48 03	 cmp	 cl, BYTE PTR [eax+3]
  003e9	74 66		 je	 SHORT $LN155@DoFilesIns
$LN159@DoFilesIns:

; 509  : 				{
; 510  : 					bResult = FALSE;
; 511  : 
; 512  : 					// Find the correct decompressed file in memory
; 513  : 					for (fileNo = 0; fileNo < NBR_COMPRESSED_FILES; fileNo++)

  003eb	ff 85 d0 f4 ff
	ff		 inc	 DWORD PTR _fileNo$1$[ebp]
  003f1	83 c7 14	 add	 edi, 20			; 00000014H
  003f4	83 ff 78	 cmp	 edi, 120		; 00000078H
  003f7	72 87		 jb	 SHORT $LL7@DoFilesIns

; 616  : 
; 617  : 			if (!Silent && MessageBoxW (hwndDlg, szTmp2, lpszTitle, MB_YESNO | MB_ICONHAND) != IDYES)

  003f9	8b b5 d8 f4 ff
	ff		 mov	 esi, DWORD PTR _bResult$1$[ebp]
$LN174@DoFilesIns:
  003ff	8b 9d e0 f4 ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
$err$185:

; 590  : 		}
; 591  : 
; 592  : err:
; 593  : 		if (bResult == FALSE)

  00405	85 f6		 test	 esi, esi
  00407	0f 85 cf 02 00
	00		 jne	 $LN168@DoFilesIns

; 594  : 		{
; 595  : 			LPVOID lpMsgBuf;
; 596  : 			DWORD dwError = GetLastError ();

  0040d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 597  : 			wchar_t szTmp2[700];
; 598  : 
; 599  : 			FormatMessage (

  00413	56		 push	 esi
  00414	56		 push	 esi
  00415	8d 8d cc f4 ff
	ff		 lea	 ecx, DWORD PTR _lpMsgBuf$1[ebp]
  0041b	51		 push	 ecx
  0041c	68 00 04 00 00	 push	 1024			; 00000400H
  00421	50		 push	 eax
  00422	56		 push	 esi
  00423	68 00 11 00 00	 push	 4352			; 00001100H
  00428	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 600  : 					      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
; 601  : 					      NULL,
; 602  : 					      dwError,
; 603  : 				 MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),	/* Default language */
; 604  : 					      (char *) &lpMsgBuf,
; 605  : 					      0,
; 606  : 					      NULL
; 607  : 				);
; 608  : 
; 609  : 
; 610  : 			if (bUninstall == FALSE)
; 611  : 				wsprintfW (szTmp2, GetString ("INSTALL_OF_FAILED"), szTmp, lpMsgBuf);

  0042e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00434	ff b5 cc f4 ff
	ff		 push	 DWORD PTR _lpMsgBuf$1[ebp]
  0043a	50		 push	 eax
  0043b	39 35 00 00 00
	00		 cmp	 DWORD PTR ?bUninstall@@3HA, esi ; bUninstall
  00441	0f 85 43 02 00
	00		 jne	 $LN47@DoFilesIns
  00447	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MNFHJDAJ@INSTALL_OF_FAILED?$AA@

; 612  : 			else

  0044c	e9 3e 02 00 00	 jmp	 $LN181@DoFilesIns
$LN155@DoFilesIns:
  00451	8b bd c8 f4 ff
	ff		 mov	 edi, DWORD PTR _driver64$1$[ebp]
  00457	85 ff		 test	 edi, edi

; 521  : 						{
; 522  : 							// Dump filter driver cannot be installed to SysWOW64 directory
; 523  : 							if (driver64 && !EnableWow64FsRedirection (FALSE))

  00459	74 21		 je	 SHORT $LN32@DoFilesIns
  0045b	6a 00		 push	 0
  0045d	e8 00 00 00 00	 call	 _EnableWow64FsRedirection
  00462	83 c4 04	 add	 esp, 4
  00465	85 c0		 test	 eax, eax
  00467	75 13		 jne	 SHORT $LN32@DoFilesIns

; 524  : 							{
; 525  : 								handleWin32Error (hwndDlg);

  00469	8b 9d e0 f4 ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0046f	53		 push	 ebx
  00470	e8 00 00 00 00	 call	 _handleWin32Error
  00475	83 c4 04	 add	 esp, 4

; 526  : 								bResult = FALSE;

  00478	33 f6		 xor	 esi, esi

; 527  : 								goto err;

  0047a	eb 89		 jmp	 SHORT $err$185
$LN32@DoFilesIns:

; 528  : 							}
; 529  : 
; 530  : 							bResult = SaveBufferToFile (

  0047c	8b 85 d0 f4 ff
	ff		 mov	 eax, DWORD PTR _fileNo$1$[ebp]
  00482	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  00488	6a 00		 push	 0
  0048a	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0048d	ff 34 85 0c 00
	00 00		 push	 DWORD PTR _Decompressed_Files[eax*4+12]
  00494	51		 push	 ecx
  00495	ff 34 85 10 00
	00 00		 push	 DWORD PTR _Decompressed_Files[eax*4+16]
  0049c	e8 00 00 00 00	 call	 _SaveBufferToFile
  004a1	83 c4 10	 add	 esp, 16			; 00000010H
  004a4	8b f0		 mov	 esi, eax
  004a6	85 ff		 test	 edi, edi

; 531  : 								(char *) Decompressed_Files[fileNo].fileContent,
; 532  : 								szTmp,
; 533  : 								Decompressed_Files[fileNo].fileLength, 
; 534  : 								FALSE);
; 535  : 
; 536  : 							if (driver64)

  004a8	0f 84 91 00 00
	00		 je	 $LN171@DoFilesIns

; 537  : 							{
; 538  : 								if (!EnableWow64FsRedirection (TRUE))

  004ae	6a 01		 push	 1
  004b0	e8 00 00 00 00	 call	 _EnableWow64FsRedirection
  004b5	83 c4 04	 add	 esp, 4
  004b8	85 c0		 test	 eax, eax
  004ba	75 16		 jne	 SHORT $LN35@DoFilesIns

; 539  : 								{
; 540  : 									handleWin32Error (hwndDlg);

  004bc	8b 9d e0 f4 ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  004c2	53		 push	 ebx
  004c3	e8 00 00 00 00	 call	 _handleWin32Error
  004c8	83 c4 04	 add	 esp, 4

; 541  : 									bResult = FALSE;

  004cb	33 f6		 xor	 esi, esi

; 542  : 									goto err;

  004cd	e9 33 ff ff ff	 jmp	 $err$185
$LN35@DoFilesIns:

; 543  : 								}
; 544  : 
; 545  : 								if (!bResult)

  004d2	85 f6		 test	 esi, esi
  004d4	0f 84 25 ff ff
	ff		 je	 $LN174@DoFilesIns

; 546  : 									goto err;
; 547  : 
; 548  : 								if (bUpgrade && InstalledVersion < 0x700)

  004da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  004e1	74 5c		 je	 SHORT $LN171@DoFilesIns
  004e3	81 3d 00 00 00
	00 00 07 00 00	 cmp	 DWORD PTR ?InstalledVersion@@3JA, 1792 ; InstalledVersion, 00000700H
  004ed	7d 50		 jge	 SHORT $LN171@DoFilesIns

; 549  : 								{
; 550  : 									bResult = WriteLocalMachineRegistryString ("SYSTEM\\CurrentControlSet\\Services\\gostcrypt", "ImagePath", "System32\\drivers\\gostcrypt.sys", TRUE);

  004ef	6a 01		 push	 1
  004f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@KPLJJAIG@System32?2drivers?2gostcrypt?4sys?$AA@
  004f6	68 00 00 00 00	 push	 OFFSET ??_C@_09JMMKOPDJ@ImagePath?$AA@
  004fb	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@
  00500	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryString
  00505	83 c4 10	 add	 esp, 16			; 00000010H
  00508	89 85 d8 f4 ff
	ff		 mov	 DWORD PTR _bResult$1$[ebp], eax

; 551  : 									if (!bResult)

  0050e	85 c0		 test	 eax, eax
  00510	75 1a		 jne	 SHORT $LN40@DoFilesIns

; 552  : 									{
; 553  : 										handleWin32Error (hwndDlg);

  00512	8b 9d e0 f4 ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00518	53		 push	 ebx
  00519	e8 00 00 00 00	 call	 _handleWin32Error

; 554  : 										goto err;

  0051e	8b b5 d8 f4 ff
	ff		 mov	 esi, DWORD PTR _bResult$1$[ebp]
  00524	83 c4 04	 add	 esp, 4
  00527	e9 d9 fe ff ff	 jmp	 $err$185
$LN40@DoFilesIns:

; 555  : 									}
; 556  : 
; 557  : 									DeleteFile (szTmp);

  0052c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00532	50		 push	 eax
  00533	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4

; 558  : 								}
; 559  : 							}
; 560  : 
; 561  : 							break;
; 562  : 						}
; 563  : 					}
; 564  : 				}
; 565  : 				else

  00539	8b b5 d8 f4 ff
	ff		 mov	 esi, DWORD PTR _bResult$1$[ebp]
$LN171@DoFilesIns:
  0053f	8b bd dc f4 ff
	ff		 mov	 edi, DWORD PTR tv475[ebp]
$LN43@DoFilesIns:

; 574  : 				}
; 575  : 
; 576  : 				if (bResult && strcmp (szFiles[i], "AGostCrypt.exe") == 0)

  00545	85 f6		 test	 esi, esi
  00547	0f 84 b2 fe ff
	ff		 je	 $LN174@DoFilesIns
  0054d	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edi]
  00553	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0P@BPIJAOEL@AGostCrypt?4exe?$AA@
$LL160@DoFilesIns:
  00558	8a 10		 mov	 dl, BYTE PTR [eax]
  0055a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0055c	75 50		 jne	 SHORT $LN161@DoFilesIns
  0055e	84 d2		 test	 dl, dl
  00560	74 12		 je	 SHORT $LN162@DoFilesIns
  00562	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00565	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00568	75 44		 jne	 SHORT $LN161@DoFilesIns
  0056a	83 c0 02	 add	 eax, 2
  0056d	83 c1 02	 add	 ecx, 2
  00570	84 d2		 test	 dl, dl
  00572	75 e4		 jne	 SHORT $LL160@DoFilesIns
$LN162@DoFilesIns:
  00574	33 c0		 xor	 eax, eax
  00576	eb 3b		 jmp	 SHORT $LN163@DoFilesIns
$LN29@DoFilesIns:
  00578	85 db		 test	 ebx, ebx

; 566  : 				{
; 567  : 					if (driver64)

  0057a	74 0a		 je	 SHORT $LN42@DoFilesIns

; 568  : 						EnableWow64FsRedirection (FALSE);

  0057c	6a 00		 push	 0
  0057e	e8 00 00 00 00	 call	 _EnableWow64FsRedirection
  00583	83 c4 04	 add	 esp, 4
$LN42@DoFilesIns:

; 569  : 
; 570  : 					bResult = GSTCopyFile (curFileName, szTmp);

  00586	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0058c	50		 push	 eax
  0058d	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _curFileName$[ebp]
  00593	50		 push	 eax
  00594	e8 00 00 00 00	 call	 _GSTCopyFile
  00599	83 c4 08	 add	 esp, 8
  0059c	8b f0		 mov	 esi, eax
  0059e	85 db		 test	 ebx, ebx

; 571  : 
; 572  : 					if (driver64)

  005a0	74 a3		 je	 SHORT $LN43@DoFilesIns

; 573  : 						EnableWow64FsRedirection (TRUE);

  005a2	6a 01		 push	 1
  005a4	e8 00 00 00 00	 call	 _EnableWow64FsRedirection
  005a9	83 c4 04	 add	 esp, 4
  005ac	eb 97		 jmp	 SHORT $LN43@DoFilesIns
$LN161@DoFilesIns:

; 574  : 				}
; 575  : 
; 576  : 				if (bResult && strcmp (szFiles[i], "AGostCrypt.exe") == 0)

  005ae	1b c0		 sbb	 eax, eax
  005b0	83 c8 01	 or	 eax, 1
$LN163@DoFilesIns:
  005b3	85 c0		 test	 eax, eax
  005b5	0f 85 44 fe ff
	ff		 jne	 $LN174@DoFilesIns

; 577  : 				{
; 578  : 					string servicePath = GetServiceConfigPath (GST_APP_NAME ".exe");

  005bb	8d 85 5c f6 ff
	ff		 lea	 eax, DWORD PTR _servicePath$5[ebp]
  005c1	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@
  005c6	50		 push	 eax
  005c7	e8 00 00 00 00	 call	 ?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GetServiceConfigPath

; 579  : 					if (FileExists (servicePath.c_str()))

  005cc	83 bd 70 f6 ff
	ff 10		 cmp	 DWORD PTR _servicePath$5[ebp+20], 16 ; 00000010H
  005d3	8d 85 5c f6 ff
	ff		 lea	 eax, DWORD PTR _servicePath$5[ebp]
  005d9	0f 43 85 5c f6
	ff ff		 cmovae	 eax, DWORD PTR _servicePath$5[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 _FileExists

; 580  : 					{
; 581  : 						CopyMessage (hwndDlg, (char *) servicePath.c_str());

  005e6	8b 9d e0 f4 ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  005ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  005ef	85 c0		 test	 eax, eax
  005f1	74 4f		 je	 SHORT $LN45@DoFilesIns
  005f3	83 bd 70 f6 ff
	ff 10		 cmp	 DWORD PTR _servicePath$5[ebp+20], 16 ; 00000010H
  005fa	8d 85 5c f6 ff
	ff		 lea	 eax, DWORD PTR _servicePath$5[ebp]
  00600	0f 43 85 5c f6
	ff ff		 cmovae	 eax, DWORD PTR _servicePath$5[ebp]
  00607	50		 push	 eax
  00608	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHILBMI@INSTALLING?$AA@
  0060d	53		 push	 ebx
  0060e	e8 00 00 00 00	 call	 _StatusMessageParam
  00613	83 c4 0c	 add	 esp, 12			; 0000000cH

; 582  : 						bResult = CopyFile (szTmp, servicePath.c_str(), FALSE);

  00616	8d 85 5c f6 ff
	ff		 lea	 eax, DWORD PTR _servicePath$5[ebp]
  0061c	83 bd 70 f6 ff
	ff 10		 cmp	 DWORD PTR _servicePath$5[ebp+20], 16 ; 00000010H
  00623	0f 43 85 5c f6
	ff ff		 cmovae	 eax, DWORD PTR _servicePath$5[ebp]
  0062a	6a 00		 push	 0
  0062c	50		 push	 eax
  0062d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00633	50		 push	 eax
  00634	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyFileA@12
  0063a	89 85 d8 f4 ff
	ff		 mov	 DWORD PTR _bResult$1$[ebp], eax
  00640	8b f0		 mov	 esi, eax
$LN45@DoFilesIns:

; 583  : 					}
; 584  : 				}

  00642	8d 8d 5c f6 ff
	ff		 lea	 ecx, DWORD PTR _servicePath$5[ebp]
  00648	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 585  : 			}
; 586  : 		}
; 587  : 		else

  0064d	e9 b3 fd ff ff	 jmp	 $err$185
$LN24@DoFilesIns:

; 588  : 		{
; 589  : 			bResult = StatDeleteFile (szTmp);

  00652	8d 85 e4 f4 ff
	ff		 lea	 eax, DWORD PTR _st$2[ebp]
  00658	50		 push	 eax
  00659	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0065f	50		 push	 eax
  00660	e8 00 00 00 00	 call	 __stat64
  00665	83 c4 08	 add	 esp, 8
  00668	85 c0		 test	 eax, eax
  0066a	75 14		 jne	 SHORT $LN122@DoFilesIns
  0066c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00672	50		 push	 eax
  00673	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
  00679	8b f0		 mov	 esi, eax
  0067b	e9 85 fd ff ff	 jmp	 $err$185
$LN122@DoFilesIns:
  00680	be 01 00 00 00	 mov	 esi, 1
  00685	e9 7b fd ff ff	 jmp	 $err$185
$LN47@DoFilesIns:

; 613  : 				wsprintfW (szTmp2, GetString ("UNINSTALL_OF_FAILED"), szTmp, lpMsgBuf);

  0068a	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ICFIOGFL@UNINSTALL_OF_FAILED?$AA@
$LN181@DoFilesIns:
  0068f	e8 00 00 00 00	 call	 _GetString
  00694	83 c4 04	 add	 esp, 4
  00697	50		 push	 eax
  00698	8d 85 74 f6 ff
	ff		 lea	 eax, DWORD PTR _szTmp2$6[ebp]
  0069e	50		 push	 eax
  0069f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  006a5	83 c4 10	 add	 esp, 16			; 00000010H

; 614  : 
; 615  : 			LocalFree (lpMsgBuf);

  006a8	ff b5 cc f4 ff
	ff		 push	 DWORD PTR _lpMsgBuf$1[ebp]
  006ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 616  : 
; 617  : 			if (!Silent && MessageBoxW (hwndDlg, szTmp2, lpszTitle, MB_YESNO | MB_ICONHAND) != IDYES)

  006b4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  006bb	75 1f		 jne	 SHORT $LN168@DoFilesIns
  006bd	6a 14		 push	 20			; 00000014H
  006bf	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  006c5	8d 85 74 f6 ff
	ff		 lea	 eax, DWORD PTR _szTmp2$6[ebp]
  006cb	50		 push	 eax
  006cc	53		 push	 ebx
  006cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  006d3	83 f8 06	 cmp	 eax, 6
  006d6	0f 85 39 01 00
	00		 jne	 $LN133@DoFilesIns
$LN168@DoFilesIns:
  006dc	8b bd dc f4 ff
	ff		 mov	 edi, DWORD PTR tv475[ebp]
  006e2	8b b5 d4 f4 ff
	ff		 mov	 esi, DWORD PTR _szDestDir$GSCopy$1$[ebp]
$LN2@DoFilesIns:
  006e8	83 c7 04	 add	 edi, 4
  006eb	89 bd dc f4 ff
	ff		 mov	 DWORD PTR tv475[ebp], edi

; 433  : 
; 434  : 	for (i = 0; i < sizeof (szFiles) / sizeof (szFiles[0]); i++)

  006f1	83 ff 20	 cmp	 edi, 32			; 00000020H
  006f4	0f 82 d6 f9 ff
	ff		 jb	 $LL4@DoFilesIns

; 618  : 				return FALSE;
; 619  : 		}
; 620  : 	}
; 621  : 
; 622  : 	// Language pack
; 623  : 	if (bUninstall == FALSE)

  006fa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00701	0f 85 f8 00 00
	00		 jne	 $LN50@DoFilesIns

; 624  : 	{
; 625  : 		WIN32_FIND_DATA f;
; 626  : 		HANDLE h;
; 627  : 		
; 628  : 		SetCurrentDirectory (SetupFilesDir);

  00707	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  0070c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCurrentDirectoryA@4

; 629  : 		h = FindFirstFile ("Language.*.xml", &f);

  00712	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__FindFirstFileA@8
  00718	8d 85 1c f5 ff
	ff		 lea	 eax, DWORD PTR _f$3[ebp]
  0071e	50		 push	 eax
  0071f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GPPOMBKF@Language?4?$CK?4xml?$AA@
  00724	ff d6		 call	 esi

; 630  : 
; 631  : 		if (h != INVALID_HANDLE_VALUE)

  00726	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__FindClose@4
  0072c	8b f8		 mov	 edi, eax
  0072e	83 ff ff	 cmp	 edi, -1
  00731	74 4e		 je	 SHORT $LN51@DoFilesIns

; 632  : 		{
; 633  : 			char d[MAX_PATH*2];
; 634  : 			sprintf (d, "%s%s", szDestDir, f.cFileName);

  00733	8d 85 48 f5 ff
	ff		 lea	 eax, DWORD PTR _f$3[ebp+44]
  00739	50		 push	 eax
  0073a	ff b5 d4 f4 ff
	ff		 push	 DWORD PTR _szDestDir$GSCopy$1$[ebp]
  00740	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _d$8[ebp]
  00746	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0074b	50		 push	 eax
  0074c	e8 00 00 00 00	 call	 _sprintf

; 635  : 			CopyMessage (hwndDlg, d);

  00751	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _d$8[ebp]
  00757	50		 push	 eax
  00758	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHILBMI@INSTALLING?$AA@
  0075d	ff b5 e0 f4 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00763	e8 00 00 00 00	 call	 _StatusMessageParam

; 636  : 			GSTCopyFile (f.cFileName, d);

  00768	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _d$8[ebp]
  0076e	50		 push	 eax
  0076f	8d 85 48 f5 ff
	ff		 lea	 eax, DWORD PTR _f$3[ebp+44]
  00775	50		 push	 eax
  00776	e8 00 00 00 00	 call	 _GSTCopyFile
  0077b	83 c4 24	 add	 esp, 36			; 00000024H

; 637  : 			FindClose (h);

  0077e	57		 push	 edi
  0077f	ff d3		 call	 ebx
$LN51@DoFilesIns:

; 638  : 		}
; 639  : 
; 640  : 		SetCurrentDirectory (SetupFilesDir);

  00781	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetCurrentDirectoryA@4
  00787	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  0078c	ff d7		 call	 edi

; 641  : 		SetCurrentDirectory ("Setup files");

  0078e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LJEGBCFM@Setup?5files?$AA@
  00793	ff d7		 call	 edi

; 642  : 		h = FindFirstFile ("GostCrypt User Guide.*.pdf", &f);

  00795	8d 85 1c f5 ff
	ff		 lea	 eax, DWORD PTR _f$3[ebp]
  0079b	50		 push	 eax
  0079c	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HCDNBGHG@GostCrypt?5User?5Guide?4?$CK?4pdf?$AA@
  007a1	ff d6		 call	 esi
  007a3	8b f0		 mov	 esi, eax

; 643  : 		if (h != INVALID_HANDLE_VALUE)

  007a5	83 fe ff	 cmp	 esi, -1
  007a8	74 4e		 je	 SHORT $LN52@DoFilesIns

; 644  : 		{
; 645  : 			char d[MAX_PATH*2];
; 646  : 			sprintf (d, "%s%s", szDestDir, f.cFileName);

  007aa	8d 85 48 f5 ff
	ff		 lea	 eax, DWORD PTR _f$3[ebp+44]
  007b0	50		 push	 eax
  007b1	ff b5 d4 f4 ff
	ff		 push	 DWORD PTR _szDestDir$GSCopy$1$[ebp]
  007b7	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _d$7[ebp]
  007bd	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  007c2	50		 push	 eax
  007c3	e8 00 00 00 00	 call	 _sprintf

; 647  : 			CopyMessage (hwndDlg, d);

  007c8	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _d$7[ebp]
  007ce	50		 push	 eax
  007cf	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHILBMI@INSTALLING?$AA@
  007d4	ff b5 e0 f4 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  007da	e8 00 00 00 00	 call	 _StatusMessageParam

; 648  : 			GSTCopyFile (f.cFileName, d);

  007df	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _d$7[ebp]
  007e5	50		 push	 eax
  007e6	8d 85 48 f5 ff
	ff		 lea	 eax, DWORD PTR _f$3[ebp+44]
  007ec	50		 push	 eax
  007ed	e8 00 00 00 00	 call	 _GSTCopyFile
  007f2	83 c4 24	 add	 esp, 36			; 00000024H

; 649  : 			FindClose (h);

  007f5	56		 push	 esi
  007f6	ff d3		 call	 ebx
$LN52@DoFilesIns:

; 650  : 		}
; 651  : 		SetCurrentDirectory (SetupFilesDir);

  007f8	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  007fd	ff d7		 call	 edi
$LN50@DoFilesIns:

; 652  : 	}
; 653  : 
; 654  : 	return bOK;

  007ff	5f		 pop	 edi
  00800	5e		 pop	 esi
  00801	b8 01 00 00 00	 mov	 eax, 1
  00806	5b		 pop	 ebx

; 655  : }

  00807	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0080a	33 cd		 xor	 ecx, ebp
  0080c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00811	8b e5		 mov	 esp, ebp
  00813	5d		 pop	 ebp
  00814	c3		 ret	 0
$LN133@DoFilesIns:
  00815	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00818	33 c0		 xor	 eax, eax
  0081a	5f		 pop	 edi
  0081b	5e		 pop	 esi
  0081c	33 cd		 xor	 ecx, ebp
  0081e	5b		 pop	 ebx
  0081f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00824	8b e5		 mov	 esp, ebp
  00826	5d		 pop	 ebp
  00827	c3		 ret	 0
$LN183@DoFilesIns:

; 499  : 				curFileName [strlen (szFiles[i]) - 1] = 0;

  00828	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN184@DoFilesIns:
$LN177@DoFilesIns:
  0082d	cc		 int	 3
_DoFilesInstall ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _DetermineUpgradeDowngradeStatus
_TEXT	SEGMENT
_dwResult$1 = -8					; size = 4
_driverVersion$ = -4					; size = 4
_bCloseDriverHandle$ = 8				; size = 4
_driverVersionPtr$ = 12					; size = 4
_DetermineUpgradeDowngradeStatus PROC			; COMDAT

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 346  : 	LONG driverVersion = VERSION_NUM;
; 347  : 
; 348  : 	if (hDriver == INVALID_HANDLE_VALUE)

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _hDriver
  0000b	c7 45 fc 00 13
	00 00		 mov	 DWORD PTR _driverVersion$[ebp], 4864 ; 00001300H
  00012	83 f8 ff	 cmp	 eax, -1
  00015	75 13		 jne	 SHORT $LN13@DetermineU

; 349  : 		DriverAttach();

  00017	e8 00 00 00 00	 call	 _DriverAttach

; 350  : 
; 351  : 	if (hDriver != INVALID_HANDLE_VALUE)

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hDriver
  00021	83 f8 ff	 cmp	 eax, -1
  00024	0f 84 cd 00 00
	00		 je	 $LN14@DetermineU
$LN13@DetermineU:
  0002a	56		 push	 esi

; 352  : 	{
; 353  : 		DWORD dwResult;
; 354  : 		BOOL bResult = DeviceIoControl (hDriver, GST_IOCTL_GET_DRIVER_VERSION, NULL, 0, &driverVersion, sizeof (driverVersion), &dwResult, NULL);

  0002b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceIoControl@32
  00031	8d 4d f8	 lea	 ecx, DWORD PTR _dwResult$1[ebp]
  00034	6a 00		 push	 0
  00036	51		 push	 ecx
  00037	6a 04		 push	 4
  00039	8d 4d fc	 lea	 ecx, DWORD PTR _driverVersion$[ebp]
  0003c	51		 push	 ecx
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	68 04 20 22 00	 push	 2236420			; 00222004H
  00046	50		 push	 eax
  00047	ff d6		 call	 esi
  00049	8b c8		 mov	 ecx, eax

; 355  : 
; 356  : 		if (!bResult)

  0004b	85 c9		 test	 ecx, ecx
  0004d	75 25		 jne	 SHORT $LN12@DetermineU

; 357  : 			bResult = DeviceIoControl (hDriver, GST_IOCTL_LEGACY_GET_DRIVER_VERSION, NULL, 0, &driverVersion, sizeof (driverVersion), &dwResult, NULL);

  0004f	50		 push	 eax
  00050	8d 45 f8	 lea	 eax, DWORD PTR _dwResult$1[ebp]
  00053	50		 push	 eax
  00054	6a 04		 push	 4
  00056	8d 45 fc	 lea	 eax, DWORD PTR _driverVersion$[ebp]
  00059	50		 push	 eax
  0005a	51		 push	 ecx
  0005b	51		 push	 ecx
  0005c	68 18 20 07 00	 push	 466968			; 00072018H
  00061	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  00067	ff d6		 call	 esi
  00069	8b c8		 mov	 ecx, eax

; 358  : 
; 359  : 		if (bResult)

  0006b	85 c9		 test	 ecx, ecx
  0006d	75 05		 jne	 SHORT $LN12@DetermineU

; 361  : 
; 362  : 		bUpgrade = (bResult && driverVersion < VERSION_NUM);

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _driverVersion$[ebp]
  00072	eb 1d		 jmp	 SHORT $LN8@DetermineU
$LN12@DetermineU:

; 360  : 			InstalledVersion = driverVersion;

  00074	8b 45 fc	 mov	 eax, DWORD PTR _driverVersion$[ebp]
  00077	a3 00 00 00 00	 mov	 DWORD PTR ?InstalledVersion@@3JA, eax ; InstalledVersion

; 361  : 
; 362  : 		bUpgrade = (bResult && driverVersion < VERSION_NUM);

  0007c	85 c9		 test	 ecx, ecx
  0007e	74 11		 je	 SHORT $LN8@DetermineU
  00080	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bUpgrade, 1
  0008a	3d 00 13 00 00	 cmp	 eax, 4864		; 00001300H
  0008f	7c 0a		 jl	 SHORT $LN9@DetermineU
$LN8@DetermineU:
  00091	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bUpgrade, 0
$LN9@DetermineU:

; 363  : 		bDowngrade = (bResult && driverVersion > VERSION_NUM);

  0009b	85 c9		 test	 ecx, ecx
  0009d	74 11		 je	 SHORT $LN10@DetermineU
  0009f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDowngrade@@3HA, 1 ; bDowngrade
  000a9	3d 00 13 00 00	 cmp	 eax, 4864		; 00001300H
  000ae	7f 0a		 jg	 SHORT $LN11@DetermineU
$LN10@DetermineU:
  000b0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bDowngrade@@3HA, 0 ; bDowngrade
$LN11@DetermineU:

; 364  : 
; 365  : 		PortableMode = DeviceIoControl (hDriver, GST_IOCTL_GET_PORTABLE_MODE_STATUS, NULL, 0, NULL, 0, &dwResult, NULL);

  000ba	6a 00		 push	 0
  000bc	8d 45 f8	 lea	 eax, DWORD PTR _dwResult$1[ebp]
  000bf	50		 push	 eax
  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	6a 00		 push	 0
  000c6	6a 00		 push	 0
  000c8	68 64 20 22 00	 push	 2236516			; 00222064H
  000cd	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  000d3	ff d6		 call	 esi

; 366  : 
; 367  : 		if (bCloseDriverHandle)

  000d5	83 7d 08 00	 cmp	 DWORD PTR _bCloseDriverHandle$[ebp], 0
  000d9	a3 00 00 00 00	 mov	 DWORD PTR ?PortableMode@@3HA, eax ; PortableMode
  000de	5e		 pop	 esi
  000df	74 16		 je	 SHORT $LN14@DetermineU

; 368  : 		{
; 369  : 			CloseHandle (hDriver);

  000e1	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 370  : 			hDriver = INVALID_HANDLE_VALUE;

  000ed	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _hDriver, -1
$LN14@DetermineU:

; 371  : 		}
; 372  : 	}
; 373  : 
; 374  : 	*driverVersionPtr = driverVersion;

  000f7	8b 4d 0c	 mov	 ecx, DWORD PTR _driverVersionPtr$[ebp]
  000fa	8b 45 fc	 mov	 eax, DWORD PTR _driverVersion$[ebp]
  000fd	89 01		 mov	 DWORD PTR [ecx], eax

; 375  : }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
_DetermineUpgradeDowngradeStatus ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _IconMessage
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_txt$ = 12						; size = 4
_IconMessage PROC					; COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 332  : 	StatusMessageParam (hwndDlg, "ADDING_ICON", txt);

  00003	ff 75 0c	 push	 DWORD PTR _txt$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
  0000b	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  0000e	e8 00 00 00 00	 call	 _StatusMessageParam
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 333  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_IconMessage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _RemoveMessage
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_txt$ = 12						; size = 4
_RemoveMessage PROC					; COMDAT

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  : 	if (!Rollback)

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0000a	75 13		 jne	 SHORT $LN2@RemoveMess

; 318  : 		StatusMessageParam (hwndDlg, "REMOVING", txt);

  0000c	ff 75 0c	 push	 DWORD PTR _txt$[ebp]
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00014	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00017	e8 00 00 00 00	 call	 _StatusMessageParam
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@RemoveMess:

; 319  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_RemoveMessage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _CopyMessage
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_txt$ = 12						; size = 4
_CopyMessage PROC					; COMDAT

; 302  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 303  : 	StatusMessageParam (hwndDlg, "INSTALLING", txt);

  00003	ff 75 0c	 push	 DWORD PTR _txt$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHILBMI@INSTALLING?$AA@
  0000b	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  0000e	e8 00 00 00 00	 call	 _StatusMessageParam
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 304  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_CopyMessage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _RegMessage
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_txt$ = 12						; size = 4
_RegMessage PROC					; COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	StatusMessageParam (hwndDlg, "ADDING_REG", txt);

  00003	ff 75 0c	 push	 DWORD PTR _txt$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LFAEJJAB@ADDING_REG?$AA@
  0000b	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  0000e	e8 00 00 00 00	 call	 _StatusMessageParam
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 290  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_RegMessage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _ClearLogWindow
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_ClearLogWindow PROC					; COMDAT

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 275  : 	SendMessage (GetDlgItem (hwndDlg, IDC_LOG_WINDOW), LB_RESETCONTENT, 0, 0);

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	68 84 01 00 00	 push	 388			; 00000184H
  0000c	68 f9 03 00 00	 push	 1017			; 000003f9H
  00011	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 276  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_ClearLogWindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _StatusMessageParam
_TEXT	SEGMENT
_szTmp$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_stringId$ = 12						; size = 4
_param$ = 16						; size = 4
_StatusMessageParam PROC				; COMDAT

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 253  : 	wchar_t szTmp[1024];
; 254  : 
; 255  : 	if (Rollback)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _stringId$[ebp]
  0001d	8b 4d 10	 mov	 ecx, DWORD PTR _param$[ebp]
  00020	57		 push	 edi
  00021	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  00024	75 6b		 jne	 SHORT $LN1@StatusMess

; 256  : 		return;
; 257  : 
; 258  : 	wsprintfW (szTmp, L"%s %hs", GetString (stringId), param);

  00026	51		 push	 ecx
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _GetString
  0002d	83 c4 04	 add	 esp, 4
  00030	50		 push	 eax
  00031	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_1O@FHLBCOCO@?$AA?$CF?$AAs?$AA?5?$AA?$CF?$AAh?$AAs?$AA?$AA@
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  00043	83 c4 10	 add	 esp, 16			; 00000010H

; 259  : 	SendMessageW (GetDlgItem (hwndDlg, IDC_LOG_WINDOW), LB_ADDSTRING, 0, (LPARAM) szTmp);

  00046	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0004c	50		 push	 eax
  0004d	6a 00		 push	 0
  0004f	68 80 01 00 00	 push	 384			; 00000180H
  00054	68 f9 03 00 00	 push	 1017			; 000003f9H
  00059	57		 push	 edi
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00060	50		 push	 eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageW@16

; 260  : 		
; 261  : 	SendDlgItemMessage (hwndDlg, IDC_LOG_WINDOW, LB_SETTOPINDEX, 

  00067	6a 00		 push	 0
  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	68 8b 01 00 00	 push	 395			; 0000018bH
  00072	68 f9 03 00 00	 push	 1017			; 000003f9H
  00077	57		 push	 edi
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
  0007e	48		 dec	 eax
  0007f	50		 push	 eax
  00080	68 97 01 00 00	 push	 407			; 00000197H
  00085	68 f9 03 00 00	 push	 1017			; 000003f9H
  0008a	57		 push	 edi
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
$LN1@StatusMess:

; 262  : 		SendDlgItemMessage (hwndDlg, IDC_LOG_WINDOW, LB_GETCOUNT, 0, 0) - 1, 0);
; 263  : }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	5f		 pop	 edi
  00097	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_StatusMessageParam ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _StatusMessage
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_stringId$ = 12						; size = 4
_StatusMessage PROC					; COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 232  : 	if (Rollback)

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0000a	75 55		 jne	 SHORT $LN1@StatusMess

; 233  : 		return;
; 234  : 
; 235  : 	SendMessageW (GetDlgItem (hwndDlg, IDC_LOG_WINDOW), LB_ADDSTRING, 0, (LPARAM) GetString (stringId));

  0000c	57		 push	 edi
  0000d	ff 75 0c	 push	 DWORD PTR _stringId$[ebp]
  00010	e8 00 00 00 00	 call	 _GetString
  00015	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	6a 00		 push	 0
  0001e	68 80 01 00 00	 push	 384			; 00000180H
  00023	68 f9 03 00 00	 push	 1017			; 000003f9H
  00028	57		 push	 edi
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageW@16

; 236  : 
; 237  : 	SendDlgItemMessage (hwndDlg, IDC_LOG_WINDOW, LB_SETTOPINDEX, 

  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	68 8b 01 00 00	 push	 395			; 0000018bH
  00041	68 f9 03 00 00	 push	 1017			; 000003f9H
  00046	57		 push	 edi
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
  0004d	48		 dec	 eax
  0004e	50		 push	 eax
  0004f	68 97 01 00 00	 push	 407			; 00000197H
  00054	68 f9 03 00 00	 push	 1017			; 000003f9H
  00059	57		 push	 edi
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20
  00060	5f		 pop	 edi
$LN1@StatusMess:

; 238  : 		SendDlgItemMessage (hwndDlg, IDC_LOG_WINDOW, LB_GETCOUNT, 0, 0) - 1, 0);
; 239  : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_StatusMessage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _GetProgramPath
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hwndDlg$ = 8						; size = 4
_path$ = 12						; size = 4
_GetProgramPath PROC					; COMDAT

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 210  : 	ITEMIDLIST *i;
; 211  : 	HRESULT res;
; 212  : 
; 213  : 	if (bForAllUsers)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bForAllUsers, 0

; 214  :         res = SHGetSpecialFolderLocation (hwndDlg, CSIDL_COMMON_PROGRAMS, &i);

  0000b	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0000e	50		 push	 eax
  0000f	74 04		 je	 SHORT $LN2@GetProgram
  00011	6a 17		 push	 23			; 00000017H

; 215  : 	else

  00013	eb 02		 jmp	 SHORT $LN5@GetProgram
$LN2@GetProgram:

; 216  :         res = SHGetSpecialFolderLocation (hwndDlg, CSIDL_PROGRAMS, &i);

  00015	6a 02		 push	 2
$LN5@GetProgram:
  00017	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetSpecialFolderLocation@12

; 217  : 
; 218  : 	SHGetPathFromIDList (i, path);

  00020	ff 75 0c	 push	 DWORD PTR _path$[ebp]
  00023	ff 75 fc	 push	 DWORD PTR _i$[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetPathFromIDListA@8

; 219  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_GetProgramPath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _CreateLink
_TEXT	SEGMENT
_propVariant$1 = -552					; size = 16
_ppf$2 = -536						; size = 4
_propStore$3 = -532					; size = 4
_psl$ = -528						; size = 4
_wsz$4 = -524						; size = 520
__$ArrayPad$ = -4					; size = 4
_lpszPathObj$ = 8					; size = 4
_lpszArguments$ = 12					; size = 4
_lpszPathLink$ = 16					; size = 4
_CreateLink PROC					; COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 02 00
	00		 sub	 esp, 552		; 00000228H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 10	 mov	 ebx, DWORD PTR _lpszPathLink$[ebp]

; 142  : 	HRESULT hres;
; 143  : 	IShellLink *psl;
; 144  : 
; 145  : 	/* Get a pointer to the IShellLink interface.  */
; 146  : 	hres = CoCreateInstance (CLSID_ShellLink, NULL,

  00017	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _psl$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 08	 mov	 esi, DWORD PTR _lpszPathObj$[ebp]
  00021	57		 push	 edi
  00022	8b 7d 0c	 mov	 edi, DWORD PTR _lpszArguments$[ebp]
  00025	50		 push	 eax
  00026	68 00 00 00 00	 push	 OFFSET _IID_IShellLinkA
  0002b	6a 01		 push	 1
  0002d	6a 00		 push	 0
  0002f	68 00 00 00 00	 push	 OFFSET _CLSID_ShellLink
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 147  : 			       CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *) &psl);
; 148  : 	if (SUCCEEDED (hres))

  0003a	85 c0		 test	 eax, eax
  0003c	0f 88 21 01 00
	00		 js	 $LN2@CreateLink

; 149  : 	{
; 150  : 		IPersistFile *ppf;
; 151  : 
; 152  : 		/* Set the path to the shortcut target, and add the
; 153  : 		   description.  */
; 154  : 		psl->SetPath (lpszPathObj);

  00042	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _psl$[ebp]
  00048	56		 push	 esi
  00049	50		 push	 eax
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	ff 51 50	 call	 DWORD PTR [ecx+80]

; 155  : 		psl->SetArguments (lpszArguments);

  0004f	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _psl$[ebp]
  00055	57		 push	 edi
  00056	50		 push	 eax
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	ff 51 2c	 call	 DWORD PTR [ecx+44]

; 156  : 
; 157  : 		// Application ID
; 158  : 		if (strstr (lpszPathObj, GST_APP_NAME ".exe"))

  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@
  00061	56		 push	 esi
  00062	e8 00 00 00 00	 call	 _strstr
  00067	83 c4 08	 add	 esp, 8
  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 8a 00 00
	00		 je	 $LN4@CreateLink

; 159  : 		{
; 160  : 			IPropertyStore *propStore;
; 161  : 
; 162  : 			if (SUCCEEDED (psl->QueryInterface (IID_PPV_ARGS (&propStore))))

  00072	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _psl$[ebp]
  00078	8d 95 ec fd ff
	ff		 lea	 edx, DWORD PTR _propStore$3[ebp]
  0007e	52		 push	 edx
  0007f	68 00 00 00 00	 push	 OFFSET __GUID_886d8eeb_8cf2_4446_8d02_cdba1dbdcf99
  00084	50		 push	 eax
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	ff 11		 call	 DWORD PTR [ecx]
  00089	85 c0		 test	 eax, eax
  0008b	78 6f		 js	 SHORT $LN4@CreateLink

; 163  : 			{
; 164  : 				PROPVARIANT propVariant;
; 165  : 				if (SUCCEEDED (InitPropVariantFromString (GST_APPLICATION_ID, &propVariant)))

  0008d	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  00092	66 89 85 d8 fd
	ff ff		 mov	 WORD PTR _propVariant$1[ebp], ax
  00099	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _propVariant$1[ebp+8]
  0009f	50		 push	 eax
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@PACGJHBK@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAF?$AAo?$AAu?$AAn?$AAd?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHStrDupW@8
  000ab	85 c0		 test	 eax, eax
  000ad	79 0c		 jns	 SHORT $LN18@CreateLink
  000af	0f 57 c0	 xorps	 xmm0, xmm0
  000b2	0f 11 85 d8 fd
	ff ff		 movups	 XMMWORD PTR _propVariant$1[ebp], xmm0
  000b9	eb 35		 jmp	 SHORT $LN5@CreateLink
$LN18@CreateLink:

; 166  : 				{
; 167  : 					if (SUCCEEDED (propStore->SetValue (PKEY_AppUserModel_ID, propVariant)))

  000bb	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _propStore$3[ebp]
  000c1	8d 95 d8 fd ff
	ff		 lea	 edx, DWORD PTR _propVariant$1[ebp]
  000c7	52		 push	 edx
  000c8	68 00 00 00 00	 push	 OFFSET _PKEY_AppUserModel_ID
  000cd	50		 push	 eax
  000ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d0	ff 51 18	 call	 DWORD PTR [ecx+24]
  000d3	85 c0		 test	 eax, eax
  000d5	78 0c		 js	 SHORT $LN6@CreateLink

; 168  : 						propStore->Commit();

  000d7	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _propStore$3[ebp]
  000dd	50		 push	 eax
  000de	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e0	ff 51 1c	 call	 DWORD PTR [ecx+28]
$LN6@CreateLink:

; 169  : 
; 170  : 					PropVariantClear (&propVariant);

  000e3	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _propVariant$1[ebp]
  000e9	50		 push	 eax
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PropVariantClear@4
$LN5@CreateLink:

; 171  : 				}
; 172  : 
; 173  : 				propStore->Release();

  000f0	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _propStore$3[ebp]
  000f6	50		 push	 eax
  000f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f9	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN4@CreateLink:

; 174  : 			}
; 175  : 		}
; 176  : 
; 177  : 		/* Query IShellLink for the IPersistFile interface for saving
; 178  : 		   the shortcut in persistent storage.  */
; 179  : 		hres = psl->QueryInterface (IID_IPersistFile,

  000fc	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _psl$[ebp]
  00102	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _ppf$2[ebp]
  00108	52		 push	 edx
  00109	68 00 00 00 00	 push	 OFFSET _IID_IPersistFile
  0010e	50		 push	 eax
  0010f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00111	ff 11		 call	 DWORD PTR [ecx]
  00113	8b f0		 mov	 esi, eax

; 180  : 						    (void **) &ppf);
; 181  : 
; 182  : 		if (SUCCEEDED (hres))

  00115	85 f6		 test	 esi, esi
  00117	78 3c		 js	 SHORT $LN7@CreateLink

; 183  : 		{
; 184  : 			wchar_t wsz[GST_MAX_PATH];
; 185  : 
; 186  : 			/* Ensure that the string is ANSI.  */
; 187  : 			MultiByteToWideChar (CP_ACP, 0, lpszPathLink, -1,

  00119	68 04 01 00 00	 push	 260			; 00000104H
  0011e	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _wsz$4[ebp]
  00124	50		 push	 eax
  00125	6a ff		 push	 -1
  00127	53		 push	 ebx
  00128	6a 00		 push	 0
  0012a	6a 00		 push	 0
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 188  : 					     wsz, sizeof(wsz) / sizeof(wsz[0]));
; 189  : 
; 190  : 			/* Save the link by calling IPersistFile::Save.  */
; 191  : 			hres = ppf->Save (wsz, TRUE);

  00132	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _ppf$2[ebp]
  00138	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _wsz$4[ebp]
  0013e	6a 01		 push	 1
  00140	52		 push	 edx
  00141	50		 push	 eax
  00142	8b 08		 mov	 ecx, DWORD PTR [eax]
  00144	ff 51 18	 call	 DWORD PTR [ecx+24]
  00147	8b f0		 mov	 esi, eax

; 192  : 			ppf->Release ();

  00149	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _ppf$2[ebp]
  0014f	50		 push	 eax
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN7@CreateLink:

; 193  : 		}
; 194  : 		psl->Release ();

  00155	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _psl$[ebp]
  0015b	50		 push	 eax
  0015c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015e	ff 51 08	 call	 DWORD PTR [ecx+8]

; 195  : 	}
; 196  : 	return hres;

  00161	8b c6		 mov	 eax, esi
$LN2@CreateLink:

; 197  : }

  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	33 cd		 xor	 ecx, ebp
  0016a	5b		 pop	 ebx
  0016b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c3		 ret	 0
_CreateLink ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _StatRemoveDirectory
_TEXT	SEGMENT
_st$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_lpszDir$ = 8						; size = 4
_StatRemoveDirectory PROC				; COMDAT

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpszDir$[ebp]

; 131  : 	struct __stat64 st;
; 132  : 
; 133  : 	if (_stat64 (lpszDir, &st) == 0)

  00014	8d 45 c4	 lea	 eax, DWORD PTR _st$[ebp]
  00017	50		 push	 eax
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 __stat64
  0001e	83 c4 08	 add	 esp, 8
  00021	85 c0		 test	 eax, eax
  00023	75 16		 jne	 SHORT $LN2@StatRemove

; 134  : 		return RemoveDirectory (lpszDir);

  00025	56		 push	 esi
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RemoveDirectoryA@4
  0002c	5e		 pop	 esi

; 135  : 	else
; 136  : 		return TRUE;
; 137  : }

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00030	33 cd		 xor	 ecx, ebp
  00032	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN2@StatRemove:
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	33 cd		 xor	 ecx, ebp
  00045	5e		 pop	 esi
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_StatRemoveDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _StatDeleteFile
_TEXT	SEGMENT
_st$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_lpszFile$ = 8						; size = 4
_StatDeleteFile PROC					; COMDAT

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpszFile$[ebp]

; 113  : 	struct __stat64 st;
; 114  : 
; 115  : 	if (_stat64 (lpszFile, &st) == 0)

  00014	8d 45 c4	 lea	 eax, DWORD PTR _st$[ebp]
  00017	50		 push	 eax
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 __stat64
  0001e	83 c4 08	 add	 esp, 8
  00021	85 c0		 test	 eax, eax
  00023	75 16		 jne	 SHORT $LN2@StatDelete

; 116  : 		return DeleteFile (lpszFile);

  00025	56		 push	 esi
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
  0002c	5e		 pop	 esi

; 117  : 	else
; 118  : 		return TRUE;
; 119  : }

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00030	33 cd		 xor	 ecx, ebp
  00032	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN2@StatDelete:
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	33 cd		 xor	 ecx, ebp
  00045	5e		 pop	 esi
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_StatDeleteFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _localcleanup
_TEXT	SEGMENT
_localcleanup PROC					; COMDAT

; 97   : 	localcleanupwiz ();

  00000	e8 00 00 00 00	 call	 _localcleanupwiz

; 98   : 	cleanup ();

  00005	e8 00 00 00 00	 call	 _cleanup

; 99   : 
; 100  : 	CloseAppSetupMutex ();

  0000a	e9 00 00 00 00	 jmp	 _CloseAppSetupMutex
_localcleanup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2439 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2440 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00012	75 04		 jne	 SHORT $LN9@operator
  00014	33 c0		 xor	 eax, eax
  00016	eb 11		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00018	8b c2		 mov	 eax, edx
  0001a	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0001d	0f 1f 00	 npad	 3
$LL139@operator:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL139@operator
  00027	2b c6		 sub	 eax, esi
$LN10@operator:
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002c	50		 push	 eax
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00033	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00036	8b ce		 mov	 ecx, esi
  00038	50		 push	 eax
  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00040	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00047	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi

; 2441 : 	}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 26		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 20		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	8b ce		 mov	 ecx, esi
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00035	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2261 : 		_Eos(_Newsize);

  0003d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00041	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00044	72 0c		 jb	 SHORT $LN92@Tidy
  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 2262 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN92@Tidy:
  00052	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 2262 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2d		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1b		 jb	 SHORT $LN4@Inside
  0001d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	03 c6		 add	 eax, esi
  0002d	3b c2		 cmp	 eax, edx
  0002f	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2244 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2244 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	77 59		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000c	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  0000f	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00011	ff 71 10	 push	 DWORD PTR [ecx+16]
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0001a	85 f6		 test	 esi, esi
  0001c	5e		 pop	 esi
  0001d	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00024	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  00028	74 1f		 je	 SHORT $LN5@Grow
  0002a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0002d	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  0002f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00032	3b f0		 cmp	 esi, eax
  00034	0f 42 c6	 cmovb	 eax, esi
  00037	50		 push	 eax
  00038	6a 01		 push	 1
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0003f	85 f6		 test	 esi, esi
  00041	5e		 pop	 esi
  00042	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  00049	85 f6		 test	 esi, esi
  0004b	75 10		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  0004d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00051	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00054	72 02		 jb	 SHORT $LN80@Grow
  00056	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  00058	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0005b	85 f6		 test	 esi, esi
$LN88@Grow:
  0005d	0f 95 c0	 setne	 al
  00060	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  0006f	cc		 int	 3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0a		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 2220 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0

; 2220 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 0f	 or	 edi, 15			; 0000000fH

; 2184 : 		if (max_size() < _Newres)

  00038	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f8		 mov	 edi, eax
  0003f	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00041	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e7		 mul	 edi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005a	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00063	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  00068	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00072	85 c0		 test	 eax, eax
  00074	75 04		 jne	 SHORT $LN136@Copy
  00076	33 db		 xor	 ebx, ebx
  00078	eb 6d		 jmp	 SHORT $LN19@Copy
$LN136@Copy:
  0007a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007f	72 29		 jb	 SHORT $LN138@Copy
  00081	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00084	3b c8		 cmp	 ecx, eax
  00086	77 05		 ja	 SHORT $LN140@Copy
  00088	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN435@Copy:
$LN140@Copy:
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00093	83 c4 04	 add	 esp, 4
  00096	85 c0		 test	 eax, eax
  00098	75 05		 jne	 SHORT $LN141@Copy
  0009a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN436@Copy:
$LN141@Copy:
  0009f	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000a2	83 e3 e0	 and	 ebx, -32		; ffffffe0H
  000a5	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  000a8	eb 3d		 jmp	 SHORT $LN19@Copy
$LN138@Copy:
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b0	8b d8		 mov	 ebx, eax
  000b2	83 c4 04	 add	 esp, 4
  000b5	85 db		 test	 ebx, ebx
  000b7	75 2e		 jne	 SHORT $LN19@Copy
  000b9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN437@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000be	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  000c7	40		 inc	 eax
  000c8	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000cb	50		 push	 eax
  000cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000d0	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000d5	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  000d8	b8 00 00 00 00	 mov	 eax, $LN432@Copy
  000dd	c3		 ret	 0
$LN432@Copy:
  000de	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000e1	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000e4	8b 5d e8	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000e7	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  000ea	85 c0		 test	 eax, eax
  000ec	74 1b		 je	 SHORT $LN270@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000ee	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000f2	72 04		 jb	 SHORT $LN261@Copy
  000f4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f6	eb 02		 jmp	 SHORT $LN262@Copy
$LN261@Copy:
  000f8	8b ce		 mov	 ecx, esi
$LN262@Copy:
  000fa	85 c0		 test	 eax, eax
  000fc	74 0b		 je	 SHORT $LN270@Copy
  000fe	50		 push	 eax
  000ff	51		 push	 ecx
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _memcpy
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN270@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  00109	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0010c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010f	72 0b		 jb	 SHORT $LN274@Copy
  00111	40		 inc	 eax
  00112	8b ce		 mov	 ecx, esi
  00114	50		 push	 eax
  00115	ff 36		 push	 DWORD PTR [esi]
  00117	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN274@Copy:
  0011c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00123	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00127	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0012e	72 04		 jb	 SHORT $LN362@Copy
  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	eb 02		 jmp	 SHORT $LN363@Copy
$LN362@Copy:
  00134	8b c6		 mov	 eax, esi
$LN363@Copy:
  00136	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);
; 2212 : 		this->_Myres() = _Newres;
; 2213 : 		_Eos(_Oldlen);

  00139	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  0013c	89 1e		 mov	 DWORD PTR [esi], ebx
  0013e	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00141	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00145	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00148	72 02		 jb	 SHORT $LN426@Copy
  0014a	8b f3		 mov	 esi, ebx
$LN426@Copy:
  0014c	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 2214 : 		}

  00150	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00153	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015a	59		 pop	 ecx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00164	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00167	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0016a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0016d	72 0b		 jb	 SHORT $LN156@Copy
  0016f	40		 inc	 eax
  00170	8b ce		 mov	 ecx, esi
  00172	50		 push	 eax
  00173	ff 36		 push	 DWORD PTR [esi]
  00175	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN156@Copy:
  0017a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00181	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00185	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0018c	72 02		 jb	 SHORT $LN245@Copy
  0018e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN245@Copy:

; 2203 : 			_RERAISE;

  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	c6 06 00	 mov	 BYTE PTR [esi], 0
  00197	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN438@Copy:
$LN434@Copy:
  0019c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2175 : 		if (_Count == 1)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	83 f8 01	 cmp	 eax, 1
  0000b	75 15		 jne	 SHORT $LN2@Chassign

; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);

  0000d	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00011	72 02		 jb	 SHORT $LN16@Chassign
  00013	8b 12		 mov	 edx, DWORD PTR [edx]
$LN16@Chassign:
  00015	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00018	8a 4d 10	 mov	 cl, BYTE PTR __Ch$[ebp]
  0001b	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2179 : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Chassign:

; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

  00022	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00026	72 02		 jb	 SHORT $LN33@Chassign
  00028	8b 12		 mov	 edx, DWORD PTR [edx]
$LN33@Chassign:
  0002a	50		 push	 eax
  0002b	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0002f	50		 push	 eax
  00030	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00033	03 c2		 add	 eax, edx
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _memset
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2179 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 2168 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2171 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 2088 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2089 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  00005	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00015	51		 push	 ecx
  00016	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001d	8b ce		 mov	 ecx, esi
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	c6 06 00	 mov	 BYTE PTR [esi], 0
  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi

; 2090 : 		}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1895 : 		{	// look for [_Ptr, <null>) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1896 : 		_DEBUG_POINTER(_Ptr);
; 1897 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN5@find
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00018	5e		 pop	 esi

; 1898 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8

; 1896 : 		_DEBUG_POINTER(_Ptr);
; 1897 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

$LN5@find:
  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@find:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL7@find
  0002a	2b d7		 sub	 edx, edi
  0002c	5f		 pop	 edi
  0002d	52		 push	 edx
  0002e	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00037	5e		 pop	 esi

; 1898 : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1875 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1876 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1877 : 		if (_Count == 0 && _Off <= this->_Mysize())

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000e	85 db		 test	 ebx, ebx
  00010	75 0e		 jne	 SHORT $LN5@find
  00012	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00015	77 09		 ja	 SHORT $LN5@find

; 1878 : 			return (_Off);	// null string always matches (if inside string)

  00017	8b c2		 mov	 eax, edx
  00019	5b		 pop	 ebx

; 1892 : 		}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
$LN5@find:
  00020	56		 push	 esi

; 1879 : 
; 1880 : 		size_type _Nm;
; 1881 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))

  00021	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00024	57		 push	 edi
  00025	3b d6		 cmp	 edx, esi
  00027	73 6a		 jae	 SHORT $LN3@find
  00029	2b f2		 sub	 esi, edx
  0002b	3b de		 cmp	 ebx, esi
  0002d	77 64		 ja	 SHORT $LN3@find

; 1882 : 			{	// room for match, look for it
; 1883 : 			const _Elem *_Uptr, *_Vptr;
; 1884 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	2b c3		 sub	 eax, ebx
  00036	03 f0		 add	 esi, eax
  00038	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0003c	72 02		 jb	 SHORT $LN46@find
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN46@find:
  00040	8d 1c 11	 lea	 ebx, DWORD PTR [ecx+edx]
$LL4@find:

; 1885 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;

  00043	85 f6		 test	 esi, esi
  00045	74 4c		 je	 SHORT $LN3@find
  00047	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004a	56		 push	 esi
  0004b	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0004e	50		 push	 eax
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 _memchr
  00055	8b f8		 mov	 edi, eax
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	85 ff		 test	 edi, edi
  0005c	74 35		 je	 SHORT $LN3@find

; 1887 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  0005e	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00061	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	85 c0		 test	 eax, eax
  0006f	74 0a		 je	 SHORT $LN69@find

; 1886 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  00071	2b df		 sub	 ebx, edi
  00073	4b		 dec	 ebx
  00074	03 f3		 add	 esi, ebx
  00076	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  00079	eb c8		 jmp	 SHORT $LL4@find
$LN69@find:

; 1888 : 					return (_Uptr - this->_Myptr());	// found a match

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00082	72 02		 jb	 SHORT $LN64@find
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
$LN64@find:
  00086	2b f8		 sub	 edi, eax
  00088	8b c7		 mov	 eax, edi
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 1892 : 		}

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 0c 00	 ret	 12			; 0000000cH
$LN3@find:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi

; 1889 : 			}
; 1890 : 
; 1891 : 		return (npos);	// no match

  00095	83 c8 ff	 or	 eax, -1
  00098	5b		 pop	 ebx

; 1892 : 		}

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1766 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 1606 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	72 10		 jb	 SHORT $LN11@end
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000e	03 c8		 add	 ecx, eax
  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00013	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

$LN11@end:
  00019	8b c1		 mov	 eax, ecx
  0001b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0001e	03 c8		 add	 ecx, eax
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1594 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1595 : 		auto _Mydata = &this->_Get_data();
; 1596 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	72 02		 jb	 SHORT $LN11@begin
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@begin:
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 1597 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1585 : 		if (_First2 == _Last2)

  00003	8b 45 10	 mov	 eax, DWORD PTR __First2$[ebp]
  00006	8b 55 14	 mov	 edx, DWORD PTR __Last2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3b c2		 cmp	 eax, edx
  0000e	75 36		 jne	 SHORT $LN2@replace

; 1586 : 			erase(_First - begin(), _Last - _First);

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	2b c8		 sub	 ecx, eax
  00018	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001c	72 14		 jb	 SHORT $LN24@replace
  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
  00020	2b c2		 sub	 eax, edx
  00022	51		 push	 ecx
  00023	50		 push	 eax
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0002b	8b c6		 mov	 eax, esi
  0002d	5e		 pop	 esi

; 1591 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 10 00	 ret	 16			; 00000010H

; 1586 : 			erase(_First - begin(), _Last - _First);

$LN24@replace:
  00032	8b d6		 mov	 edx, esi
  00034	51		 push	 ecx
  00035	2b c2		 sub	 eax, edx
  00037	8b ce		 mov	 ecx, esi
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi

; 1591 : 		}

  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,

  00046	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00049	2b d0		 sub	 edx, eax
  0004b	53		 push	 ebx
  0004c	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0004f	2b d9		 sub	 ebx, ecx
  00051	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00055	57		 push	 edi
  00056	72 04		 jb	 SHORT $LN76@replace
  00058	8b 3e		 mov	 edi, DWORD PTR [esi]
  0005a	eb 02		 jmp	 SHORT $LN77@replace
$LN76@replace:
  0005c	8b fe		 mov	 edi, esi
$LN77@replace:
  0005e	52		 push	 edx
  0005f	50		 push	 eax
  00060	2b cf		 sub	 ecx, edi
  00062	53		 push	 ebx
  00063	51		 push	 ecx
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  0006b	5f		 pop	 edi
  0006c	5b		 pop	 ebx

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1591 : 		}

  00070	5d		 pop	 ebp
  00071	c2 10 00	 ret	 16			; 00000010H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z
_TEXT	SEGMENT
__Nm$1$ = -8						; size = 4
tv890 = -4						; size = 4
tv887 = -4						; size = 4
__Off$ = 8						; size = 4
tv891 = 12						; size = 4
tv888 = 12						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1454 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1455 : 		if (_Inside(_Ptr))

  00003	8b 55 10	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	85 d2		 test	 edx, edx
  0000f	74 4d		 je	 SHORT $LN2@replace
  00011	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00014	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00017	72 04		 jb	 SHORT $LN24@replace
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	eb 02		 jmp	 SHORT $LN25@replace
$LN24@replace:
  0001d	8b c6		 mov	 eax, esi
$LN25@replace:
  0001f	3b d0		 cmp	 edx, eax
  00021	72 3b		 jb	 SHORT $LN2@replace
  00023	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00026	72 04		 jb	 SHORT $LN38@replace
  00028	8b 3e		 mov	 edi, DWORD PTR [esi]
  0002a	eb 02		 jmp	 SHORT $LN39@replace
$LN38@replace:
  0002c	8b fe		 mov	 edi, esi
$LN39@replace:
  0002e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00031	03 c7		 add	 eax, edi
  00033	3b c2		 cmp	 eax, edx
  00035	76 27		 jbe	 SHORT $LN2@replace

; 1456 : 			return (replace(_Off, _N0, *this,

  00037	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003a	72 04		 jb	 SHORT $LN61@replace
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	eb 02		 jmp	 SHORT $LN62@replace
$LN61@replace:
  00040	8b c6		 mov	 eax, esi
$LN62@replace:
  00042	ff 75 14	 push	 DWORD PTR __Count$[ebp]
  00045	2b d0		 sub	 edx, eax
  00047	8b ce		 mov	 ecx, esi
  00049	52		 push	 edx
  0004a	56		 push	 esi
  0004b	ff 75 0c	 push	 DWORD PTR __N0$[ebp]
  0004e	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00051	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1480 : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  0005e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00061	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00064	3b c8		 cmp	 ecx, eax
  00066	0f 82 61 01 00
	00		 jb	 $LN312@replace

; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

  0006c	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  0006f	8b f9		 mov	 edi, ecx
  00071	2b f8		 sub	 edi, eax
  00073	8b c2		 mov	 eax, edx
  00075	53		 push	 ebx
  00076	8b 5d 0c	 mov	 ebx, DWORD PTR __N0$[ebp]
  00079	f7 d0		 not	 eax
  0007b	3b df		 cmp	 ebx, edi
  0007d	0f 47 df	 cmova	 ebx, edi
  00080	2b cb		 sub	 ecx, ebx
  00082	3b c1		 cmp	 eax, ecx
  00084	0f 86 4d 01 00
	00		 jbe	 $LN314@replace

; 1463 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;

  0008a	2b fb		 sub	 edi, ebx
  0008c	89 7d f8	 mov	 DWORD PTR __Nm$1$[ebp], edi

; 1464 : 
; 1465 : 		if (_Count < _N0)

  0008f	3b d3		 cmp	 edx, ebx
  00091	73 43		 jae	 SHORT $LN145@replace

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00093	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00096	83 f8 10	 cmp	 eax, 16			; 00000010H
  00099	72 07		 jb	 SHORT $LN124@replace
  0009b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0009d	89 4d 0c	 mov	 DWORD PTR tv891[ebp], ecx
  000a0	eb 03		 jmp	 SHORT $LN125@replace
$LN124@replace:
  000a2	89 75 0c	 mov	 DWORD PTR tv891[ebp], esi
$LN125@replace:
  000a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a8	72 07		 jb	 SHORT $LN138@replace
  000aa	8b 06		 mov	 eax, DWORD PTR [esi]
  000ac	89 45 fc	 mov	 DWORD PTR tv890[ebp], eax
  000af	eb 03		 jmp	 SHORT $LN139@replace
$LN138@replace:
  000b1	89 75 fc	 mov	 DWORD PTR tv890[ebp], esi
$LN139@replace:
  000b4	85 ff		 test	 edi, edi
  000b6	74 1e		 je	 SHORT $LN145@replace
  000b8	8b 45 0c	 mov	 eax, DWORD PTR tv891[ebp]
  000bb	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000be	03 c3		 add	 eax, ebx
  000c0	57		 push	 edi
  000c1	50		 push	 eax
  000c2	8b 45 fc	 mov	 eax, DWORD PTR tv890[ebp]
  000c5	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000c8	03 c2		 add	 eax, edx
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _memmove
  000d0	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN145@replace:

; 1467 : 				this->_Myptr() + _Off + _N0,
; 1468 : 				_Nm);	// smaller hole, move tail up
; 1469 : 		const size_type _Num = this->_Mysize() + _Count - _N0;

  000d6	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d9	8b f8		 mov	 edi, eax
  000db	2b fb		 sub	 edi, ebx
  000dd	03 fa		 add	 edi, edx

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  000df	85 d2		 test	 edx, edx
  000e1	75 08		 jne	 SHORT $LN6@replace
  000e3	85 db		 test	 ebx, ebx
  000e5	0f 84 d7 00 00
	00		 je	 $LN306@replace
$LN6@replace:
  000eb	83 ff fe	 cmp	 edi, -2			; fffffffeH
  000ee	0f 87 ed 00 00
	00		 ja	 $LN315@replace
  000f4	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  000f7	73 27		 jae	 SHORT $LN157@replace
  000f9	50		 push	 eax
  000fa	57		 push	 edi
  000fb	8b ce		 mov	 ecx, esi
  000fd	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00102	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  00105	85 ff		 test	 edi, edi
  00107	0f 84 b5 00 00
	00		 je	 $LN306@replace
$LN311@replace:

; 1472 : 			{	// make room and rearrange
; 1473 : 			if (_N0 < _Count)

  0010d	3b da		 cmp	 ebx, edx
  0010f	73 71		 jae	 SHORT $LN272@replace

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

  00111	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00114	83 f8 10	 cmp	 eax, 16			; 00000010H
  00117	72 32		 jb	 SHORT $LN251@replace
  00119	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0011b	89 4d 0c	 mov	 DWORD PTR tv888[ebp], ecx
  0011e	eb 2e		 jmp	 SHORT $LN252@replace

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN157@replace:
  00120	85 ff		 test	 edi, edi
  00122	75 e9		 jne	 SHORT $LN311@replace
  00124	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00127	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0012b	72 10		 jb	 SHORT $LN234@replace
  0012d	8b 06		 mov	 eax, DWORD PTR [esi]
  0012f	5b		 pop	 ebx
  00130	5f		 pop	 edi
  00131	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1478 : 			}
; 1479 : 		return (*this);

  00134	8b c6		 mov	 eax, esi
  00136	5e		 pop	 esi

; 1480 : 		}

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 10 00	 ret	 16			; 00000010H

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN234@replace:
  0013d	8b c6		 mov	 eax, esi
  0013f	5b		 pop	 ebx
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1480 : 		}

  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 10 00	 ret	 16			; 00000010H

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

$LN251@replace:
  0014b	89 75 0c	 mov	 DWORD PTR tv888[ebp], esi
$LN252@replace:
  0014e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00151	72 07		 jb	 SHORT $LN265@replace
  00153	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00155	89 4d fc	 mov	 DWORD PTR tv887[ebp], ecx
  00158	eb 03		 jmp	 SHORT $LN266@replace
$LN265@replace:
  0015a	89 75 fc	 mov	 DWORD PTR tv887[ebp], esi
$LN266@replace:
  0015d	8b 45 f8	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00160	85 c0		 test	 eax, eax
  00162	74 1e		 je	 SHORT $LN272@replace
  00164	50		 push	 eax
  00165	8b 45 0c	 mov	 eax, DWORD PTR tv888[ebp]
  00168	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0016b	03 c3		 add	 eax, ebx
  0016d	50		 push	 eax
  0016e	8b 45 fc	 mov	 eax, DWORD PTR tv887[ebp]
  00171	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00174	03 c2		 add	 eax, edx
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 _memmove
  0017c	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN272@replace:

; 1475 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1476 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  00182	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00186	72 04		 jb	 SHORT $LN283@replace
  00188	8b 06		 mov	 eax, DWORD PTR [esi]
  0018a	eb 02		 jmp	 SHORT $LN284@replace
$LN283@replace:
  0018c	8b c6		 mov	 eax, esi
$LN284@replace:
  0018e	85 d2		 test	 edx, edx
  00190	74 10		 je	 SHORT $LN290@replace
  00192	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00195	52		 push	 edx
  00196	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 _memcpy
  0019f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN290@replace:

; 1477 : 			_Eos(_Num);

  001a2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  001a6	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  001a9	72 11		 jb	 SHORT $LN301@replace
  001ab	8b 06		 mov	 eax, DWORD PTR [esi]
  001ad	5b		 pop	 ebx
  001ae	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1478 : 			}
; 1479 : 		return (*this);

  001b2	8b c6		 mov	 eax, esi
  001b4	5f		 pop	 edi
  001b5	5e		 pop	 esi

; 1480 : 		}

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c2 10 00	 ret	 16			; 00000010H

; 1477 : 			_Eos(_Num);

$LN301@replace:
  001bc	8b c6		 mov	 eax, esi
  001be	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN306@replace:

; 1478 : 			}
; 1479 : 		return (*this);

  001c2	5b		 pop	 ebx
  001c3	5f		 pop	 edi
  001c4	8b c6		 mov	 eax, esi
  001c6	5e		 pop	 esi

; 1480 : 		}

  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c2 10 00	 ret	 16			; 00000010H
$LN312@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  001d2	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN316@replace:
$LN314@replace:

; 1462 : 			_Xlen();	// result too long

  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001dc	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN317@replace:
$LN315@replace:

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  001e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001e6	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN318@replace:
$LN309@replace:
  001eb	cc		 int	 3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT	SEGMENT
tv1828 = -8						; size = 4
tv1825 = -8						; size = 4
__Max_effective_size$1$ = -8				; size = 4
__Nm$1$ = -4						; size = 4
tv1824 = 8						; size = 4
tv1821 = 8						; size = 4
tv1817 = 8						; size = 4
tv1813 = 8						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
tv1809 = 16						; size = 4
tv1807 = 16						; size = 4
tv1805 = 16						; size = 4
__Right$ = 16						; size = 4
tv1819 = 20						; size = 4
__Roff$ = 20						; size = 4
tv1798 = 24						; size = 4
__Newsize$1$ = 24					; size = 4
__Count$ = 24						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1390 : 		_Check_offset(_Off);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00011	3b c3		 cmp	 eax, ebx
  00013	0f 82 95 03 00
	00		 jb	 $LN600@replace

; 1391 : 		_Right._Check_offset(_Roff);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001c	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  0001f	3b 7d 14	 cmp	 edi, DWORD PTR __Roff$[ebp]
  00022	0f 82 90 03 00
	00		 jb	 $LN602@replace

; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);

  00028	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0002b	2b c3		 sub	 eax, ebx
  0002d	3b d0		 cmp	 edx, eax
  0002f	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00032	0f 47 d0	 cmova	 edx, eax

; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00035	2b 7d 14	 sub	 edi, DWORD PTR __Roff$[ebp]

; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

  00038	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0003b	89 7d f8	 mov	 DWORD PTR __Max_effective_size$1$[ebp], edi
  0003e	8b 7d 18	 mov	 edi, DWORD PTR __Count$[ebp]
  00041	3b 7d f8	 cmp	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  00044	89 55 0c	 mov	 DWORD PTR __N0$[ebp], edx
  00047	0f 47 7d f8	 cmova	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  0004b	2b c2		 sub	 eax, edx
  0004d	89 45 18	 mov	 DWORD PTR tv1798[ebp], eax
  00050	8b c7		 mov	 eax, edi
  00052	f7 d0		 not	 eax
  00054	3b 45 18	 cmp	 eax, DWORD PTR tv1798[ebp]
  00057	0f 86 65 03 00
	00		 jbe	 $LN603@replace

; 1396 : 
; 1397 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1398 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;

  0005d	8b 5d 18	 mov	 ebx, DWORD PTR tv1798[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00063	03 df		 add	 ebx, edi
  00065	2b c2		 sub	 eax, edx
  00067	89 5d 18	 mov	 DWORD PTR __Newsize$1$[ebp], ebx

; 1399 : 		if (this->_Mysize() < _Newsize)

  0006a	39 5e 10	 cmp	 DWORD PTR [esi+16], ebx
  0006d	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00070	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00073	73 53		 jae	 SHORT $LN194@replace

; 1400 : 			_Grow(_Newsize);

  00075	83 7d 18 fe	 cmp	 DWORD PTR __Newsize$1$[ebp], -2 ; fffffffeH
  00079	0f 87 4d 03 00
	00		 ja	 $LN604@replace
  0007f	8b 5d 18	 mov	 ebx, DWORD PTR __Newsize$1$[ebp]
  00082	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00085	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00088	73 18		 jae	 SHORT $LN112@replace
  0008a	ff 76 10	 push	 DWORD PTR [esi+16]
  0008d	8b ce		 mov	 ecx, esi
  0008f	ff 75 18	 push	 DWORD PTR __Newsize$1$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00097	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0009a	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  000a0	eb 26		 jmp	 SHORT $LN194@replace
$LN112@replace:
  000a2	83 7d 18 00	 cmp	 DWORD PTR __Newsize$1$[ebp], 0
  000a6	75 20		 jne	 SHORT $LN194@replace
  000a8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000af	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b3	72 07		 jb	 SHORT $LN189@replace
  000b5	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000b7	89 5d f8	 mov	 DWORD PTR tv1828[ebp], ebx
  000ba	eb 03		 jmp	 SHORT $LN190@replace
$LN189@replace:
  000bc	89 75 f8	 mov	 DWORD PTR tv1828[ebp], esi
$LN190@replace:
  000bf	8b 5d f8	 mov	 ebx, DWORD PTR tv1828[ebp]
  000c2	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000c5	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
$LN194@replace:

; 1401 : 
; 1402 : 		if (_Count == _N0)

  000c8	3b fa		 cmp	 edi, edx
  000ca	75 2b		 jne	 SHORT $LN4@replace

; 1403 : 			{	// only one movement required, so _Traits::move handles any overlap
; 1404 : 			_Traits::move(this->_Myptr() + _Off,

  000cc	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000d0	72 02		 jb	 SHORT $LN206@replace
  000d2	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN206@replace:
  000d4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000d8	72 04		 jb	 SHORT $LN220@replace
  000da	8b 16		 mov	 edx, DWORD PTR [esi]
  000dc	eb 02		 jmp	 SHORT $LN221@replace
$LN220@replace:
  000de	8b d6		 mov	 edx, esi
$LN221@replace:
  000e0	85 ff		 test	 edi, edi
  000e2	0f 84 9a 02 00
	00		 je	 $LN579@replace
  000e8	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  000eb	03 c1		 add	 eax, ecx
  000ed	57		 push	 edi
  000ee	50		 push	 eax
  000ef	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000f2	e9 82 02 00 00	 jmp	 $LN598@replace
$LN4@replace:

; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (this != &_Right)

  000f7	3b f1		 cmp	 esi, ecx
  000f9	74 77		 je	 SHORT $LN6@replace

; 1408 : 			{	// no overlap, just move down and copy in new stuff
; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000fb	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000ff	72 0a		 jb	 SHORT $LN238@replace
  00101	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00103	89 5d f8	 mov	 DWORD PTR tv1825[ebp], ebx
  00106	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00109	eb 03		 jmp	 SHORT $LN239@replace
$LN238@replace:
  0010b	89 75 f8	 mov	 DWORD PTR tv1825[ebp], esi
$LN239@replace:
  0010e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00112	72 0a		 jb	 SHORT $LN252@replace
  00114	8b 16		 mov	 edx, DWORD PTR [esi]
  00116	89 55 08	 mov	 DWORD PTR tv1824[ebp], edx
  00119	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0011c	eb 03		 jmp	 SHORT $LN253@replace
$LN252@replace:
  0011e	89 75 08	 mov	 DWORD PTR tv1824[ebp], esi
$LN253@replace:
  00121	85 c0		 test	 eax, eax
  00123	74 1c		 je	 SHORT $LN259@replace
  00125	50		 push	 eax
  00126	8b 45 f8	 mov	 eax, DWORD PTR tv1825[ebp]
  00129	03 c3		 add	 eax, ebx
  0012b	03 c2		 add	 eax, edx
  0012d	50		 push	 eax
  0012e	8b 45 08	 mov	 eax, DWORD PTR tv1824[ebp]
  00131	03 c3		 add	 eax, ebx
  00133	03 c7		 add	 eax, edi
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _memmove
  0013b	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN259@replace:

; 1410 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

  00141	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00145	72 02		 jb	 SHORT $LN270@replace
  00147	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN270@replace:
  00149	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0014d	72 04		 jb	 SHORT $LN284@replace
  0014f	8b 16		 mov	 edx, DWORD PTR [esi]
  00151	eb 02		 jmp	 SHORT $LN285@replace
$LN284@replace:
  00153	8b d6		 mov	 edx, esi
$LN285@replace:
  00155	85 ff		 test	 edi, edi
  00157	0f 84 25 02 00
	00		 je	 $LN579@replace
  0015d	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  00160	03 c1		 add	 eax, ecx
  00162	57		 push	 edi
  00163	50		 push	 eax
  00164	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _memcpy
  0016d	e9 0d 02 00 00	 jmp	 $LN599@replace
$LN6@replace:

; 1412 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1413 : 			}
; 1414 : 		else if (_Count < _N0)

  00172	3b fa		 cmp	 edi, edx
  00174	73 73		 jae	 SHORT $LN8@replace

; 1415 : 			{	// hole doesn't get larger, just copy in substring
; 1416 : 			_Traits::move(this->_Myptr() + _Off,

  00176	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00179	83 f8 10	 cmp	 eax, 16			; 00000010H
  0017c	72 07		 jb	 SHORT $LN302@replace
  0017e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00180	89 4d 08	 mov	 DWORD PTR tv1821[ebp], ecx
  00183	eb 03		 jmp	 SHORT $LN303@replace
$LN302@replace:
  00185	89 75 08	 mov	 DWORD PTR tv1821[ebp], esi
$LN303@replace:
  00188	83 f8 10	 cmp	 eax, 16			; 00000010H
  0018b	72 04		 jb	 SHORT $LN316@replace
  0018d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0018f	eb 02		 jmp	 SHORT $LN317@replace
$LN316@replace:
  00191	8b ce		 mov	 ecx, esi
$LN317@replace:
  00193	85 ff		 test	 edi, edi
  00195	74 17		 je	 SHORT $LN323@replace
  00197	8b 45 08	 mov	 eax, DWORD PTR tv1821[ebp]
  0019a	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  0019d	57		 push	 edi
  0019e	50		 push	 eax
  0019f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 _memmove
  001a8	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN323@replace:

; 1417 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001ae	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001b1	83 f8 10	 cmp	 eax, 16			; 00000010H
  001b4	72 07		 jb	 SHORT $LN334@replace
  001b6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001b8	89 4d 14	 mov	 DWORD PTR tv1819[ebp], ecx
  001bb	eb 03		 jmp	 SHORT $LN335@replace
$LN334@replace:
  001bd	89 75 14	 mov	 DWORD PTR tv1819[ebp], esi
$LN335@replace:
  001c0	83 f8 10	 cmp	 eax, 16			; 00000010H
  001c3	72 04		 jb	 SHORT $LN348@replace
  001c5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001c7	eb 02		 jmp	 SHORT $LN349@replace
$LN348@replace:
  001c9	8b ce		 mov	 ecx, esi
$LN349@replace:
  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  001ce	85 c0		 test	 eax, eax
  001d0	0f 84 ac 01 00
	00		 je	 $LN579@replace
  001d6	50		 push	 eax
  001d7	8b 45 14	 mov	 eax, DWORD PTR tv1819[ebp]
  001da	03 c3		 add	 eax, ebx
  001dc	03 c2		 add	 eax, edx
  001de	50		 push	 eax
  001df	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001e2	03 c7		 add	 eax, edi
  001e4	e9 90 01 00 00	 jmp	 $LN598@replace
$LN8@replace:

; 1419 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1420 : 			}
; 1421 : 		else if (_Roff <= _Off)

  001e9	8b 4d 14	 mov	 ecx, DWORD PTR __Roff$[ebp]
  001ec	3b cb		 cmp	 ecx, ebx
  001ee	77 6b		 ja	 SHORT $LN10@replace

; 1422 : 			{	// hole gets larger, substring begins before hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001f0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  001f3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001f6	72 0a		 jb	 SHORT $LN366@replace
  001f8	8b 16		 mov	 edx, DWORD PTR [esi]
  001fa	89 55 08	 mov	 DWORD PTR tv1817[ebp], edx
  001fd	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  00200	eb 03		 jmp	 SHORT $LN367@replace
$LN366@replace:
  00202	89 75 08	 mov	 DWORD PTR tv1817[ebp], esi
$LN367@replace:
  00205	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00208	72 04		 jb	 SHORT $LN380@replace
  0020a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0020c	eb 02		 jmp	 SHORT $LN381@replace
$LN380@replace:
  0020e	8b ce		 mov	 ecx, esi
$LN381@replace:
  00210	85 c0		 test	 eax, eax
  00212	74 17		 je	 SHORT $LN387@replace
  00214	50		 push	 eax
  00215	8b 45 08	 mov	 eax, DWORD PTR tv1817[ebp]
  00218	03 c3		 add	 eax, ebx
  0021a	03 c2		 add	 eax, edx
  0021c	50		 push	 eax
  0021d	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00220	03 c7		 add	 eax, edi
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 _memmove
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN387@replace:

; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,

  0022b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0022e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00231	72 04		 jb	 SHORT $LN398@replace
  00233	8b 16		 mov	 edx, DWORD PTR [esi]
  00235	eb 02		 jmp	 SHORT $LN399@replace
$LN398@replace:
  00237	8b d6		 mov	 edx, esi
$LN399@replace:
  00239	83 f8 10	 cmp	 eax, 16			; 00000010H
  0023c	72 04		 jb	 SHORT $LN412@replace
  0023e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00240	eb 02		 jmp	 SHORT $LN413@replace
$LN412@replace:
  00242	8b ce		 mov	 ecx, esi
$LN413@replace:
  00244	85 ff		 test	 edi, edi
  00246	0f 84 36 01 00
	00		 je	 $LN579@replace
  0024c	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  0024f	03 c2		 add	 eax, edx
  00251	57		 push	 edi
  00252	50		 push	 eax
  00253	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00256	e9 1e 01 00 00	 jmp	 $LN598@replace
$LN10@replace:

; 1426 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1427 : 			}
; 1428 : 		else if (_Off + _N0 <= _Roff)

  0025b	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0025e	3b c1		 cmp	 eax, ecx

; 1429 : 			{	// hole gets larger, substring begins after hole
; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00260	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00263	77 6d		 ja	 SHORT $LN12@replace
  00265	83 f8 10	 cmp	 eax, 16			; 00000010H
  00268	72 07		 jb	 SHORT $LN430@replace
  0026a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0026c	89 4d 08	 mov	 DWORD PTR tv1813[ebp], ecx
  0026f	eb 03		 jmp	 SHORT $LN431@replace
$LN430@replace:
  00271	89 75 08	 mov	 DWORD PTR tv1813[ebp], esi
$LN431@replace:
  00274	83 f8 10	 cmp	 eax, 16			; 00000010H
  00277	72 04		 jb	 SHORT $LN444@replace
  00279	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0027b	eb 02		 jmp	 SHORT $LN445@replace
$LN444@replace:
  0027d	8b ce		 mov	 ecx, esi
$LN445@replace:
  0027f	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00282	85 c0		 test	 eax, eax
  00284	74 1a		 je	 SHORT $LN451@replace
  00286	50		 push	 eax
  00287	8b 45 08	 mov	 eax, DWORD PTR tv1813[ebp]
  0028a	03 c3		 add	 eax, ebx
  0028c	03 c2		 add	 eax, edx
  0028e	50		 push	 eax
  0028f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00292	03 c7		 add	 eax, edi
  00294	50		 push	 eax
  00295	e8 00 00 00 00	 call	 _memmove
  0029a	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0029d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN451@replace:

; 1431 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1432 : 			_Traits::move(this->_Myptr() + _Off,

  002a0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  002a3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  002a6	72 04		 jb	 SHORT $LN462@replace
  002a8	8b 06		 mov	 eax, DWORD PTR [esi]
  002aa	eb 02		 jmp	 SHORT $LN463@replace
$LN462@replace:
  002ac	8b c6		 mov	 eax, esi
$LN463@replace:
  002ae	83 f9 10	 cmp	 ecx, 16			; 00000010H
  002b1	72 04		 jb	 SHORT $LN476@replace
  002b3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002b5	eb 02		 jmp	 SHORT $LN477@replace
$LN476@replace:
  002b7	8b ce		 mov	 ecx, esi
$LN477@replace:
  002b9	85 ff		 test	 edi, edi
  002bb	0f 84 c1 00 00
	00		 je	 $LN579@replace
  002c1	2b c2		 sub	 eax, edx
  002c3	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  002c6	03 c7		 add	 eax, edi
  002c8	57		 push	 edi
  002c9	50		 push	 eax
  002ca	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]

; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else

  002cd	e9 a7 00 00 00	 jmp	 $LN598@replace
$LN12@replace:

; 1437 : 			{	// hole gets larger, substring begins in hole
; 1438 : 			_Traits::move(this->_Myptr() + _Off,

  002d2	83 f8 10	 cmp	 eax, 16			; 00000010H
  002d5	72 07		 jb	 SHORT $LN494@replace
  002d7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002d9	89 4d 10	 mov	 DWORD PTR tv1809[ebp], ecx
  002dc	eb 03		 jmp	 SHORT $LN495@replace
$LN494@replace:
  002de	89 75 10	 mov	 DWORD PTR tv1809[ebp], esi
$LN495@replace:
  002e1	83 f8 10	 cmp	 eax, 16			; 00000010H
  002e4	72 04		 jb	 SHORT $LN508@replace
  002e6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002e8	eb 02		 jmp	 SHORT $LN509@replace
$LN508@replace:
  002ea	8b ce		 mov	 ecx, esi
$LN509@replace:
  002ec	85 d2		 test	 edx, edx
  002ee	74 17		 je	 SHORT $LN515@replace
  002f0	8b 45 10	 mov	 eax, DWORD PTR tv1809[ebp]
  002f3	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  002f6	52		 push	 edx
  002f7	50		 push	 eax
  002f8	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 _memmove
  00301	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  00304	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN515@replace:

; 1439 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00307	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0030a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0030d	72 07		 jb	 SHORT $LN526@replace
  0030f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00311	89 4d 10	 mov	 DWORD PTR tv1807[ebp], ecx
  00314	eb 03		 jmp	 SHORT $LN527@replace
$LN526@replace:
  00316	89 75 10	 mov	 DWORD PTR tv1807[ebp], esi
$LN527@replace:
  00319	83 f8 10	 cmp	 eax, 16			; 00000010H
  0031c	72 04		 jb	 SHORT $LN540@replace
  0031e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00320	eb 02		 jmp	 SHORT $LN541@replace
$LN540@replace:
  00322	8b ce		 mov	 ecx, esi
$LN541@replace:
  00324	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00327	85 c0		 test	 eax, eax
  00329	74 17		 je	 SHORT $LN547@replace
  0032b	50		 push	 eax
  0032c	8b 45 10	 mov	 eax, DWORD PTR tv1807[ebp]
  0032f	03 c3		 add	 eax, ebx
  00331	03 c2		 add	 eax, edx
  00333	50		 push	 eax
  00334	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00337	03 c7		 add	 eax, edi
  00339	50		 push	 eax
  0033a	e8 00 00 00 00	 call	 _memmove
  0033f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN547@replace:

; 1441 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

  00342	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00345	83 f8 10	 cmp	 eax, 16			; 00000010H
  00348	72 07		 jb	 SHORT $LN558@replace
  0034a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0034c	89 4d 10	 mov	 DWORD PTR tv1805[ebp], ecx
  0034f	eb 03		 jmp	 SHORT $LN559@replace
$LN558@replace:
  00351	89 75 10	 mov	 DWORD PTR tv1805[ebp], esi
$LN559@replace:
  00354	83 f8 10	 cmp	 eax, 16			; 00000010H
  00357	72 04		 jb	 SHORT $LN572@replace
  00359	8b 16		 mov	 edx, DWORD PTR [esi]
  0035b	eb 02		 jmp	 SHORT $LN573@replace
$LN572@replace:
  0035d	8b d6		 mov	 edx, esi
$LN573@replace:
  0035f	8b 4d 0c	 mov	 ecx, DWORD PTR __N0$[ebp]
  00362	8b c7		 mov	 eax, edi
  00364	2b c1		 sub	 eax, ecx
  00366	74 1a		 je	 SHORT $LN579@replace
  00368	50		 push	 eax
  00369	8b 45 10	 mov	 eax, DWORD PTR tv1805[ebp]
  0036c	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  0036f	03 c7		 add	 eax, edi
  00371	50		 push	 eax
  00372	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00375	03 c2		 add	 eax, edx
  00377	03 c1		 add	 eax, ecx
$LN598@replace:
  00379	50		 push	 eax
  0037a	e8 00 00 00 00	 call	 _memmove
$LN599@replace:
  0037f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN579@replace:

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

  00382	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00386	8b 4d 18	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00389	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0038c	72 11		 jb	 SHORT $LN590@replace
  0038e	8b 06		 mov	 eax, DWORD PTR [esi]
  00390	5f		 pop	 edi
  00391	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1448 : 		return (*this);

  00395	8b c6		 mov	 eax, esi
  00397	5e		 pop	 esi
  00398	5b		 pop	 ebx

; 1449 : 		}

  00399	8b e5		 mov	 esp, ebp
  0039b	5d		 pop	 ebp
  0039c	c2 14 00	 ret	 20			; 00000014H

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

$LN590@replace:
  0039f	8b c6		 mov	 eax, esi
  003a1	5f		 pop	 edi
  003a2	5e		 pop	 esi
  003a3	5b		 pop	 ebx
  003a4	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1449 : 		}

  003a8	8b e5		 mov	 esp, ebp
  003aa	5d		 pop	 ebp
  003ab	c2 14 00	 ret	 20			; 00000014H
$LN600@replace:

; 1390 : 		_Check_offset(_Off);

  003ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  003b3	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN605@replace:
$LN602@replace:

; 1391 : 		_Right._Check_offset(_Roff);

  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  003bd	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN606@replace:
$LN603@replace:

; 1395 : 			_Xlen();	// result too long

  003c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  003c7	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN607@replace:
$LN604@replace:

; 1400 : 			_Grow(_Newsize);

  003cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  003d1	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN608@replace:
$LN597@replace:
  003d6	cc		 int	 3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	72 7e		 jb	 SHORT $LN93@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00014	8b c7		 mov	 eax, edi
  00016	2b c1		 sub	 eax, ecx
  00018	3b c2		 cmp	 eax, edx
  0001a	77 23		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  0001c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0001f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00023	72 0e		 jb	 SHORT $LN41@erase
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5f		 pop	 edi
  00028	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1357 : 			}
; 1358 : 		return (*this);

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 1359 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1359 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  0003f	85 d2		 test	 edx, edx
  00041	74 44		 je	 SHORT $LN90@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  00043	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00047	72 04		 jb	 SHORT $LN58@erase
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  0004d	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  0004f	2b fa		 sub	 edi, edx
  00051	53		 push	 ebx
  00052	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00055	8b c7		 mov	 eax, edi
  00057	2b c1		 sub	 eax, ecx
  00059	74 0e		 je	 SHORT $LN74@erase
  0005b	50		 push	 eax
  0005c	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0005f	50		 push	 eax
  00060	53		 push	 ebx
  00061	e8 00 00 00 00	 call	 _memmove
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00069	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00070	5b		 pop	 ebx
  00071	72 0e		 jb	 SHORT $LN85@erase
  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1357 : 			}
; 1358 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1359 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN85@erase:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN90@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi

; 1359 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN93@erase:

; 1348 : 		_Check_offset(_Off);

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00094	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN95@erase:
$LN92@erase:
  00099	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 21		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00012	72 0c		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 1344 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00020	8b d1		 mov	 edx, ecx
  00022	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  00026	8b c1		 mov	 eax, ecx

; 1344 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  00036	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1271 : 		{	// insert [_Ptr, <null>) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN5@insert
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00013	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00018	5e		 pop	 esi

; 1274 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8

; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

$LN5@insert:
  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@insert:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL7@insert
  0002a	2b d7		 sub	 edx, edi
  0002c	5f		 pop	 edi
  0002d	52		 push	 edx
  0002e	56		 push	 esi
  0002f	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00032	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00037	5e		 pop	 esi

; 1274 : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z
_TEXT	SEGMENT
tv774 = -4						; size = 4
__Off$ = 8						; size = 4
tv775 = 12						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1251 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1252 : 		if (_Inside(_Ptr))

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	74 4a		 je	 SHORT $LN2@insert
  0000f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00012	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00015	72 04		 jb	 SHORT $LN21@insert
  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	eb 02		 jmp	 SHORT $LN22@insert
$LN21@insert:
  0001b	8b c6		 mov	 eax, esi
$LN22@insert:
  0001d	3b d8		 cmp	 ebx, eax
  0001f	72 38		 jb	 SHORT $LN2@insert
  00021	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00024	72 04		 jb	 SHORT $LN35@insert
  00026	8b 16		 mov	 edx, DWORD PTR [esi]
  00028	eb 02		 jmp	 SHORT $LN36@insert
$LN35@insert:
  0002a	8b d6		 mov	 edx, esi
$LN36@insert:
  0002c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002f	03 c2		 add	 eax, edx
  00031	3b c3		 cmp	 eax, ebx
  00033	76 24		 jbe	 SHORT $LN2@insert

; 1253 : 			return (insert(_Off, *this,

  00035	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00038	72 04		 jb	 SHORT $LN58@insert
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN59@insert
$LN58@insert:
  0003e	8b c6		 mov	 eax, esi
$LN59@insert:
  00040	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00043	2b d8		 sub	 ebx, eax
  00045	8b ce		 mov	 ecx, esi
  00047	53		 push	 ebx
  00048	56		 push	 esi
  00049	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0004c	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 1268 : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 0c 00	 ret	 12			; 0000000cH
$LN2@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);

  00059	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0005c	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0005f	0f 82 f9 00 00
	00		 jb	 $LN264@insert

; 1256 : 		if (npos - this->_Mysize() <= _Count)

  00065	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00068	8b c1		 mov	 eax, ecx
  0006a	f7 d0		 not	 eax
  0006c	3b c2		 cmp	 eax, edx
  0006e	0f 86 f4 00 00
	00		 jbe	 $LN266@insert

; 1258 : 		const size_type _Num = this->_Mysize() + _Count;

  00074	57		 push	 edi
  00075	8d 3c 11	 lea	 edi, DWORD PTR [ecx+edx]

; 1259 : 		if (0 < _Count && _Grow(_Num))

  00078	85 d2		 test	 edx, edx
  0007a	0f 84 d3 00 00
	00		 je	 $LN258@insert
  00080	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00083	0f 87 e9 00 00
	00		 ja	 $LN267@insert
  00089	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0008c	73 23		 jae	 SHORT $LN100@insert
  0008e	51		 push	 ecx
  0008f	57		 push	 edi
  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00097	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  0009a	85 ff		 test	 edi, edi
  0009c	0f 84 b1 00 00
	00		 je	 $LN258@insert
$LN263@insert:

; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000a2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a8	72 32		 jb	 SHORT $LN203@insert
  000aa	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ac	89 4d 0c	 mov	 DWORD PTR tv775[ebp], ecx
  000af	eb 2e		 jmp	 SHORT $LN204@insert

; 1259 : 		if (0 < _Count && _Grow(_Num))

$LN100@insert:
  000b1	85 ff		 test	 edi, edi
  000b3	75 ed		 jne	 SHORT $LN263@insert
  000b5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000bc	72 10		 jb	 SHORT $LN177@insert
  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	5f		 pop	 edi
  000c1	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1266 : 			}
; 1267 : 		return (*this);

  000c4	8b c6		 mov	 eax, esi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx

; 1268 : 		}

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 0c 00	 ret	 12			; 0000000cH

; 1259 : 		if (0 < _Count && _Grow(_Num))

$LN177@insert:
  000ce	8b c6		 mov	 eax, esi
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1268 : 		}

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 0c 00	 ret	 12			; 0000000cH

; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN203@insert:
  000dc	89 75 0c	 mov	 DWORD PTR tv775[ebp], esi
$LN204@insert:
  000df	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e2	72 07		 jb	 SHORT $LN217@insert
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	89 45 fc	 mov	 DWORD PTR tv774[ebp], eax
  000e9	eb 03		 jmp	 SHORT $LN218@insert
$LN217@insert:
  000eb	89 75 fc	 mov	 DWORD PTR tv774[ebp], esi
$LN218@insert:
  000ee	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  000f4	2b c1		 sub	 eax, ecx
  000f6	74 1a		 je	 SHORT $LN224@insert
  000f8	50		 push	 eax
  000f9	8b 45 0c	 mov	 eax, DWORD PTR tv775[ebp]
  000fc	03 c1		 add	 eax, ecx
  000fe	50		 push	 eax
  000ff	8b 45 fc	 mov	 eax, DWORD PTR tv774[ebp]
  00102	03 c1		 add	 eax, ecx
  00104	03 c2		 add	 eax, edx
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _memmove
  0010c	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN224@insert:

; 1262 : 				this->_Myptr() + _Off,
; 1263 : 				this->_Mysize() - _Off);	// empty out hole
; 1264 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  00112	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00116	72 04		 jb	 SHORT $LN235@insert
  00118	8b 16		 mov	 edx, DWORD PTR [esi]
  0011a	eb 02		 jmp	 SHORT $LN236@insert
$LN235@insert:
  0011c	8b d6		 mov	 edx, esi
$LN236@insert:
  0011e	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00121	85 c0		 test	 eax, eax
  00123	74 0e		 je	 SHORT $LN242@insert
  00125	50		 push	 eax
  00126	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00129	53		 push	 ebx
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memcpy
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN242@insert:

; 1265 : 			_Eos(_Num);

  00133	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00137	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0013a	72 11		 jb	 SHORT $LN253@insert
  0013c	8b 06		 mov	 eax, DWORD PTR [esi]
  0013e	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1266 : 			}
; 1267 : 		return (*this);

  00142	8b c6		 mov	 eax, esi
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx

; 1268 : 		}

  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 0c 00	 ret	 12			; 0000000cH

; 1265 : 			_Eos(_Num);

$LN253@insert:
  0014d	8b c6		 mov	 eax, esi
  0014f	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN258@insert:

; 1266 : 			}
; 1267 : 		return (*this);

  00153	5f		 pop	 edi
  00154	8b c6		 mov	 eax, esi
  00156	5e		 pop	 esi
  00157	5b		 pop	 ebx

; 1268 : 		}

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 0c 00	 ret	 12			; 0000000cH
$LN264@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);

  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00163	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN268@insert:
$LN266@insert:

; 1257 : 			_Xlen();	// result too long

  00168	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0016d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN269@insert:
$LN267@insert:

; 1259 : 		if (0 < _Count && _Grow(_Num))

  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00177	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN270@insert:
$LN261@insert:
  0017c	cc		 int	 3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv860 = 8						; size = 4
tv857 = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
tv849 = 16						; size = 4
__Roff$ = 16						; size = 4
tv862 = 20						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 1224 : 		_Check_offset(_Off);

  00008	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000b	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0000e	0f 82 55 01 00
	00		 jb	 $LN285@insert

; 1225 : 		_Right._Check_offset(_Roff);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	8b 55 10	 mov	 edx, DWORD PTR __Roff$[ebp]
  0001a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001d	3b c2		 cmp	 eax, edx
  0001f	0f 82 4e 01 00
	00		 jb	 $LN287@insert

; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00025	8b 7d 14	 mov	 edi, DWORD PTR __Count$[ebp]
  00028	2b c2		 sub	 eax, edx
  0002a	3b f8		 cmp	 edi, eax
  0002c	0f 47 f8	 cmova	 edi, eax

; 1227 : 		if (npos - this->_Mysize() <= _Count)

  0002f	8b c1		 mov	 eax, ecx
  00031	f7 d0		 not	 eax
  00033	3b c7		 cmp	 eax, edi
  00035	0f 86 42 01 00
	00		 jbe	 $LN288@insert

; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;

  0003b	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]

; 1231 : 		if (0 < _Count && _Grow(_Num))

  0003e	85 ff		 test	 edi, edi
  00040	0f 84 1a 01 00
	00		 je	 $LN279@insert
  00046	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  00049	0f 87 38 01 00
	00		 ja	 $LN289@insert
  0004f	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00052	73 20		 jae	 SHORT $LN75@insert
  00054	51		 push	 ecx
  00055	53		 push	 ebx
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0005d	85 db		 test	 ebx, ebx
  0005f	0f 84 fb 00 00
	00		 je	 $LN279@insert
$LN283@insert:

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00065	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00068	83 f8 10	 cmp	 eax, 16			; 00000010H
  0006b	72 2d		 jb	 SHORT $LN178@insert
  0006d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006f	89 4d 14	 mov	 DWORD PTR tv862[ebp], ecx
  00072	eb 29		 jmp	 SHORT $LN179@insert

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN75@insert:
  00074	85 db		 test	 ebx, ebx
  00076	75 ed		 jne	 SHORT $LN283@insert
  00078	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0007b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0007f	72 0d		 jb	 SHORT $LN152@insert
  00081	8b 06		 mov	 eax, DWORD PTR [esi]
  00083	5f		 pop	 edi
  00084	88 18		 mov	 BYTE PTR [eax], bl

; 1244 : 			}
; 1245 : 		return (*this);

  00086	8b c6		 mov	 eax, esi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx

; 1246 : 		}

  0008a	5d		 pop	 ebp
  0008b	c2 10 00	 ret	 16			; 00000010H

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN152@insert:
  0008e	8b c6		 mov	 eax, esi
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1246 : 		}

  00096	5d		 pop	 ebp
  00097	c2 10 00	 ret	 16			; 00000010H

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN178@insert:
  0009a	89 75 14	 mov	 DWORD PTR tv862[ebp], esi
$LN179@insert:
  0009d	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a0	72 04		 jb	 SHORT $LN192@insert
  000a2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a4	eb 02		 jmp	 SHORT $LN193@insert
$LN192@insert:
  000a6	8b ce		 mov	 ecx, esi
$LN193@insert:
  000a8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000ab	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000ae	2b c2		 sub	 eax, edx
  000b0	74 18		 je	 SHORT $LN199@insert
  000b2	50		 push	 eax
  000b3	8b 45 14	 mov	 eax, DWORD PTR tv862[ebp]
  000b6	03 c2		 add	 eax, edx
  000b8	50		 push	 eax
  000b9	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  000bc	03 c7		 add	 eax, edi
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _memmove
  000c4	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN199@insert:

; 1234 : 				this->_Myptr() + _Off,
; 1235 : 				this->_Mysize() - _Off);	// empty out hole
; 1236 : 			if (this == &_Right)

  000ca	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  000cd	3b f0		 cmp	 esi, eax
  000cf	75 42		 jne	 SHORT $LN4@insert

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

  000d1	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  000d4	3b d0		 cmp	 edx, eax
  000d6	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000d9	0f 43 c8	 cmovae	 ecx, eax
  000dc	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000df	89 4d 10	 mov	 DWORD PTR tv849[ebp], ecx
  000e2	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e5	72 07		 jb	 SHORT $LN210@insert
  000e7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000e9	89 4d 08	 mov	 DWORD PTR tv860[ebp], ecx
  000ec	eb 03		 jmp	 SHORT $LN211@insert
$LN210@insert:
  000ee	89 75 08	 mov	 DWORD PTR tv860[ebp], esi
$LN211@insert:
  000f1	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f4	72 04		 jb	 SHORT $LN224@insert
  000f6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f8	eb 02		 jmp	 SHORT $LN225@insert
$LN224@insert:
  000fa	8b ce		 mov	 ecx, esi
$LN225@insert:
  000fc	85 ff		 test	 edi, edi
  000fe	74 42		 je	 SHORT $LN263@insert
  00100	8b 45 10	 mov	 eax, DWORD PTR tv849[ebp]
  00103	03 45 08	 add	 eax, DWORD PTR tv860[ebp]
  00106	57		 push	 edi
  00107	50		 push	 eax
  00108	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _memmove

; 1238 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1239 : 						_Count);	// substring
; 1240 : 			else

  00111	eb 2c		 jmp	 SHORT $LN284@insert
$LN4@insert:

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

  00113	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00117	72 02		 jb	 SHORT $LN242@insert
  00119	8b 00		 mov	 eax, DWORD PTR [eax]
$LN242@insert:
  0011b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0011f	72 07		 jb	 SHORT $LN256@insert
  00121	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00123	89 4d 08	 mov	 DWORD PTR tv857[ebp], ecx
  00126	eb 03		 jmp	 SHORT $LN257@insert
$LN256@insert:
  00128	89 75 08	 mov	 DWORD PTR tv857[ebp], esi
$LN257@insert:
  0012b	85 ff		 test	 edi, edi
  0012d	74 13		 je	 SHORT $LN263@insert
  0012f	03 45 10	 add	 eax, DWORD PTR __Roff$[ebp]
  00132	57		 push	 edi
  00133	50		 push	 eax
  00134	8b 45 08	 mov	 eax, DWORD PTR tv857[ebp]
  00137	03 c2		 add	 eax, edx
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _memcpy
$LN284@insert:
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN263@insert:

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

  00142	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00146	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00149	72 0f		 jb	 SHORT $LN274@insert
  0014b	8b 06		 mov	 eax, DWORD PTR [esi]
  0014d	5f		 pop	 edi
  0014e	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0

; 1244 : 			}
; 1245 : 		return (*this);

  00152	8b c6		 mov	 eax, esi
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx

; 1246 : 		}

  00156	5d		 pop	 ebp
  00157	c2 10 00	 ret	 16			; 00000010H

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

$LN274@insert:
  0015a	8b c6		 mov	 eax, esi
  0015c	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0
$LN279@insert:

; 1244 : 			}
; 1245 : 		return (*this);

  00160	5f		 pop	 edi
  00161	8b c6		 mov	 eax, esi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx

; 1246 : 		}

  00165	5d		 pop	 ebp
  00166	c2 10 00	 ret	 16			; 00000010H
$LN285@insert:

; 1224 : 		_Check_offset(_Off);

  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0016e	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN290@insert:
$LN287@insert:

; 1225 : 		_Right._Check_offset(_Roff);

  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00178	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN291@insert:
$LN288@insert:

; 1228 : 			_Xlen();	// result too long

  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00182	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN292@insert:
$LN289@insert:

; 1231 : 		if (0 < _Count && _Grow(_Num))

  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0018c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN293@insert:
$LN281@insert:
  00191	cc		 int	 3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@assign
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1183 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@assign:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@assign
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1183 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@assign
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN57@assign
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1177 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1168 : 			return (assign(*this,

$LN57@assign:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1177 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@assign:
  00065	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00066	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00069	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006c	77 7d		 ja	 SHORT $LN187@assign
  0006e	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00071	73 19		 jae	 SHORT $LN63@assign
  00073	ff 76 10	 push	 DWORD PTR [esi+16]
  00076	8b ce		 mov	 ecx, esi
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0007e	85 ff		 test	 edi, edi
  00080	74 60		 je	 SHORT $LN181@assign
$LN186@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  00082	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00086	72 2b		 jb	 SHORT $LN158@assign
  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	eb 29		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  0008c	85 ff		 test	 edi, edi
  0008e	75 f2		 jne	 SHORT $LN186@assign
  00090	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00094	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00097	72 0e		 jb	 SHORT $LN140@assign
  00099	8b 06		 mov	 eax, DWORD PTR [esi]
  0009b	5f		 pop	 edi
  0009c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1175 : 			}
; 1176 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 1177 : 		}

  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a7	8b c6		 mov	 eax, esi
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1177 : 		}

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000b3	8b c6		 mov	 eax, esi
$LN159@assign:
  000b5	85 ff		 test	 edi, edi
  000b7	74 0b		 je	 SHORT $LN165@assign
  000b9	57		 push	 edi
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000cb	72 0f		 jb	 SHORT $LN176@assign
  000cd	8b 06		 mov	 eax, DWORD PTR [esi]
  000cf	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1175 : 			}
; 1176 : 		return (*this);

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 1177 : 		}

  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN176@assign:
  000dc	8b c6		 mov	 eax, esi
  000de	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN181@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e2	5f		 pop	 edi
  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1177 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN187@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f0	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN189@assign:
$LN184@assign:
  000f5	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e9 00 00
	00		 jb	 $LN208@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 47		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d9 00 00
	00		 jb	 $LN210@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0003a	72 19		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	51		 push	 ecx
  0003f	6a 00		 push	 0
  00041	8b ce		 mov	 ecx, esi
  00043	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00047	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0004c	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 1162 : 		}

  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

$LN63@assign:
  00055	8b d6		 mov	 edx, esi
  00057	51		 push	 ecx
  00058	6a 00		 push	 0
  0005a	8b ce		 mov	 ecx, esi
  0005c	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00060	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00065	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00066	8b c6		 mov	 eax, esi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 1162 : 		}

  0006a	5d		 pop	 ebp
  0006b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0006e	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00071	0f 87 9f 00 00
	00		 ja	 $LN211@assign
  00077	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0007a	73 24		 jae	 SHORT $LN72@assign
  0007c	ff 76 10	 push	 DWORD PTR [esi+16]
  0007f	8b ce		 mov	 ecx, esi
  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0008a	85 ff		 test	 edi, edi
  0008c	74 6b		 je	 SHORT $LN203@assign
$LN207@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0008e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00092	72 02		 jb	 SHORT $LN166@assign
  00094	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00096	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0009a	72 2b		 jb	 SHORT $LN180@assign
  0009c	8b 16		 mov	 edx, DWORD PTR [esi]
  0009e	eb 29		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  000a0	85 ff		 test	 edi, edi
  000a2	75 ea		 jne	 SHORT $LN207@assign
  000a4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ab	72 0e		 jb	 SHORT $LN149@assign
  000ad	8b 06		 mov	 eax, DWORD PTR [esi]
  000af	5f		 pop	 edi
  000b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000b3	8b c6		 mov	 eax, esi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 1162 : 		}

  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000bb	8b c6		 mov	 eax, esi
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1162 : 		}

  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000c7	8b d6		 mov	 edx, esi
$LN181@assign:
  000c9	85 ff		 test	 edi, edi
  000cb	74 0e		 je	 SHORT $LN187@assign
  000cd	57		 push	 edi
  000ce	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000d1	50		 push	 eax
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000db	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000df	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000e2	72 0f		 jb	 SHORT $LN198@assign
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000ea	8b c6		 mov	 eax, esi
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx

; 1162 : 		}

  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN198@assign:
  000f3	8b c6		 mov	 eax, esi
  000f5	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN203@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f9	5f		 pop	 edi
  000fa	8b c6		 mov	 eax, esi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 1162 : 		}

  000fe	5d		 pop	 ebp
  000ff	c2 0c 00	 ret	 12			; 0000000cH
$LN208@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00107	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN212@assign:
$LN210@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00111	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN213@assign:
$LN211@assign:

; 1155 : 		else if (_Grow(_Count))

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN214@assign:
$LN205@assign:
  00120	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1111 : 		{	// append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1112 : 		if (npos - this->_Mysize() <= _Count)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000e	8b c1		 mov	 eax, ecx
  00010	f7 d0		 not	 eax
  00012	3b c3		 cmp	 eax, ebx
  00014	76 7a		 jbe	 SHORT $LN141@append

; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

  00016	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]

; 1116 : 		if (0 < _Count && _Grow(_Num))

  00019	85 db		 test	 ebx, ebx
  0001b	74 6a		 je	 SHORT $LN136@append
  0001d	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00020	77 78		 ja	 SHORT $LN143@append
  00022	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00025	73 33		 jae	 SHORT $LN28@append
  00027	51		 push	 ecx
  00028	57		 push	 edi
  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00030	85 ff		 test	 edi, edi
  00032	74 53		 je	 SHORT $LN136@append
$LN140@append:

; 1117 : 			{	// make room and append new stuff using assign
; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

  00034	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00037	8b ce		 mov	 ecx, esi
  00039	53		 push	 ebx
  0003a	ff 76 10	 push	 DWORD PTR [esi+16]
  0003d	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1119 : 			_Eos(_Num);

  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00049	72 36		 jb	 SHORT $LN131@append
  0004b	8b 06		 mov	 eax, DWORD PTR [esi]
  0004d	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1120 : 			}
; 1121 : 		return (*this);

  00051	8b c6		 mov	 eax, esi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 1122 : 		}

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8

; 1116 : 		if (0 < _Count && _Grow(_Num))

$LN28@append:
  0005a	85 ff		 test	 edi, edi
  0005c	75 d6		 jne	 SHORT $LN140@append
  0005e	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00061	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00065	72 0e		 jb	 SHORT $LN105@append
  00067	8b 06		 mov	 eax, DWORD PTR [esi]
  00069	5f		 pop	 edi
  0006a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1120 : 			}
; 1121 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 1122 : 		}

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8

; 1116 : 		if (0 < _Count && _Grow(_Num))

$LN105@append:
  00075	8b c6		 mov	 eax, esi
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1122 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1119 : 			_Eos(_Num);

$LN131@append:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN136@append:

; 1120 : 			}
; 1121 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1122 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
$LN141@append:

; 1113 : 			_Xlen();	// result too long

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00095	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN144@append:
$LN143@append:

; 1116 : 		if (0 < _Count && _Grow(_Num))

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0009f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN145@append:
$LN138@append:
  000a4	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@append
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00015	5e		 pop	 esi

; 1108 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

$LN5@append:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@append:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@append
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00031	5e		 pop	 esi

; 1108 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1088 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1089 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@append
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN21@append
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN22@append
$LN21@append:
  0001a	8b c6		 mov	 eax, esi
$LN22@append:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@append
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN35@append
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN36@append
$LN35@append:
  00029	8b d6		 mov	 edx, esi
$LN36@append:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@append

; 1090 : 			return (append(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN58@append
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1102 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1090 : 			return (append(*this,

$LN58@append:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1102 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

  00065	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00068	8b c2		 mov	 eax, edx
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0006d	f7 d0		 not	 eax
  0006f	3b c1		 cmp	 eax, ecx
  00071	0f 86 98 00 00
	00		 jbe	 $LN217@append

; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

  00077	57		 push	 edi
  00078	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

  0007b	85 c9		 test	 ecx, ecx
  0007d	0f 84 83 00 00
	00		 je	 $LN211@append
  00083	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00086	0f 87 8d 00 00
	00		 ja	 $LN219@append
  0008c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0008f	73 1a		 jae	 SHORT $LN85@append
  00091	52		 push	 edx
  00092	57		 push	 edi
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0009d	85 ff		 test	 edi, edi
  0009f	74 65		 je	 SHORT $LN211@append
$LN216@append:

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

  000a1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a5	72 2b		 jb	 SHORT $LN179@append
  000a7	8b 16		 mov	 edx, DWORD PTR [esi]
  000a9	eb 29		 jmp	 SHORT $LN180@append

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN85@append:
  000ab	85 ff		 test	 edi, edi
  000ad	75 f2		 jne	 SHORT $LN216@append
  000af	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b6	72 0e		 jb	 SHORT $LN162@append
  000b8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ba	5f		 pop	 edi
  000bb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1100 : 			}
; 1101 : 		return (*this);

  000be	8b c6		 mov	 eax, esi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx

; 1102 : 		}

  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN162@append:
  000c6	8b c6		 mov	 eax, esi
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1102 : 		}

  000ce	5d		 pop	 ebp
  000cf	c2 08 00	 ret	 8

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

$LN179@append:
  000d2	8b d6		 mov	 edx, esi
$LN180@append:
  000d4	85 c9		 test	 ecx, ecx
  000d6	74 10		 je	 SHORT $LN195@append
  000d8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000db	51		 push	 ecx
  000dc	03 c2		 add	 eax, edx
  000de	53		 push	 ebx
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _memcpy
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN195@append:

; 1099 : 			_Eos(_Num);

  000e8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000ec	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ef	72 0f		 jb	 SHORT $LN206@append
  000f1	8b 06		 mov	 eax, DWORD PTR [esi]
  000f3	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1100 : 			}
; 1101 : 		return (*this);

  000f7	8b c6		 mov	 eax, esi
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx

; 1102 : 		}

  000fc	5d		 pop	 ebp
  000fd	c2 08 00	 ret	 8

; 1099 : 			_Eos(_Num);

$LN206@append:
  00100	8b c6		 mov	 eax, esi
  00102	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN211@append:

; 1100 : 			}
; 1101 : 		return (*this);

  00106	5f		 pop	 edi
  00107	8b c6		 mov	 eax, esi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx

; 1102 : 		}

  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
$LN217@append:

; 1093 : 			_Xlen();	// result too long

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00114	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN220@append:
$LN219@append:

; 1096 : 		if (0 < _Count && _Grow(_Num))

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN221@append:
$LN214@append:
  00123	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1071 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 c0 00 00
	00		 jb	 $LN201@append

; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

  00019	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	3b c8		 cmp	 ecx, eax
  00023	0f 47 c8	 cmova	 ecx, eax
  00026	8b c2		 mov	 eax, edx
  00028	f7 d0		 not	 eax
  0002a	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx
  0002d	3b c1		 cmp	 eax, ecx
  0002f	0f 86 ae 00 00
	00		 jbe	 $LN203@append

; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

  00035	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

  00038	85 c9		 test	 ecx, ecx
  0003a	0f 84 90 00 00
	00		 je	 $LN196@append
  00040	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00043	0f 87 a4 00 00
	00		 ja	 $LN204@append
  00049	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0004c	73 22		 jae	 SHORT $LN56@append
  0004e	52		 push	 edx
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00057	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005a	85 ff		 test	 edi, edi
  0005c	74 72		 je	 SHORT $LN196@append
$LN200@append:

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

  0005e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00062	72 02		 jb	 SHORT $LN150@append
  00064	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN150@append:
  00066	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006a	72 2b		 jb	 SHORT $LN164@append
  0006c	8b 16		 mov	 edx, DWORD PTR [esi]
  0006e	eb 29		 jmp	 SHORT $LN165@append

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN56@append:
  00070	85 ff		 test	 edi, edi
  00072	75 ea		 jne	 SHORT $LN200@append
  00074	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00077	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0007b	72 0e		 jb	 SHORT $LN133@append
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	5f		 pop	 edi
  00080	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1082 : 			}
; 1083 : 		return (*this);

  00083	8b c6		 mov	 eax, esi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 1084 : 		}

  00087	5d		 pop	 ebp
  00088	c2 0c 00	 ret	 12			; 0000000cH

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN133@append:
  0008b	8b c6		 mov	 eax, esi
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1084 : 		}

  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

$LN164@append:
  00097	8b d6		 mov	 edx, esi
$LN165@append:
  00099	85 c9		 test	 ecx, ecx
  0009b	74 15		 je	 SHORT $LN180@append
  0009d	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000a0	03 c3		 add	 eax, ebx
  000a2	51		 push	 ecx
  000a3	50		 push	 eax
  000a4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000a7	03 c2		 add	 eax, edx
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memcpy
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@append:

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b6	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b9	72 0f		 jb	 SHORT $LN191@append
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1082 : 			}
; 1083 : 		return (*this);

  000c1	8b c6		 mov	 eax, esi
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx

; 1084 : 		}

  000c6	5d		 pop	 ebp
  000c7	c2 0c 00	 ret	 12			; 0000000cH

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

$LN191@append:
  000ca	8b c6		 mov	 eax, esi
  000cc	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN196@append:

; 1082 : 			}
; 1083 : 		return (*this);

  000d0	5f		 pop	 edi
  000d1	8b c6		 mov	 eax, esi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx

; 1084 : 		}

  000d5	5d		 pop	 ebp
  000d6	c2 0c 00	 ret	 12			; 0000000cH
$LN201@append:

; 1071 : 		_Right._Check_offset(_Roff);

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000de	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN205@append:
$LN203@append:

; 1074 : 			_Xlen();	// result too long

  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000e8	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN206@append:
$LN204@append:

; 1077 : 		if (0 < _Count && _Grow(_Num))

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f2	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN207@append:
$LN198@append:
  000f7	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 07		 jb	 SHORT $LN94@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	5e		 pop	 esi
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1018 : 		}

  0002e	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN94@basic_stri:
  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	5e		 pop	 esi

; 1018 : 		}

  00033	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000e	73 15		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1b		 je	 SHORT $LN3@Assign_rv
  00018	50		 push	 eax
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00023	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00025	85 ff		 test	 edi, edi
  00027	74 04		 je	 SHORT $LN84@Assign_rv
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 07		 mov	 DWORD PTR [edi], eax
$LN84@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  00039	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003c	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  0003f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00046	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0004a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00051	72 0b		 jb	 SHORT $LN227@Assign_rv
  00053	8b 06		 mov	 eax, DWORD PTR [esi]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	c6 00 00	 mov	 BYTE PTR [eax], 0

; 973  : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN227@Assign_rv:
  0005e	5f		 pop	 edi
  0005f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00062	5e		 pop	 esi

; 973  : 		}

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 928  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 929  : 		if (this != &_Right)

  00025	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00028	74 38		 je	 SHORT $LN294@operator

; 930  : 			{	// different, assign it
; 931  : 			_Tidy(true);

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00030	72 09		 jb	 SHORT $LN10@operator
  00032	40		 inc	 eax
  00033	50		 push	 eax
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN10@operator:
  0003b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	72 04		 jb	 SHORT $LN98@operator
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN99@operator
$LN98@operator:
  00053	8b c6		 mov	 eax, esi
$LN99@operator:

; 932  : 
; 933  : 			if (_Alty::propagate_on_container_move_assignment::value
; 934  : 				&& this->_Getal() != _Right._Getal())
; 935  : 				this->_Move_alloc(_Right._Getal());
; 936  : 
; 937  : 			if (this->_Getal() != _Right._Getal())
; 938  : 				assign(_Right.begin(), _Right.end());
; 939  : 			else
; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  00055	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00058	8b ce		 mov	 ecx, esi
  0005a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005d	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN294@operator:

; 941  : 			}
; 942  : 		return (*this);

  00062	8b c6		 mov	 eax, esi

; 943  : 		}

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5e		 pop	 esi
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 914  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0001d	75 12		 jne	 SHORT $LN111@basic_stri
  0001f	33 d2		 xor	 edx, edx
  00021	52		 push	 edx
  00022	51		 push	 ecx
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN111@basic_stri:
  00031	8b d1		 mov	 edx, ecx
  00033	57		 push	 edi
  00034	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL113@basic_stri:
  00037	8a 02		 mov	 al, BYTE PTR [edx]
  00039	42		 inc	 edx
  0003a	84 c0		 test	 al, al
  0003c	75 f9		 jne	 SHORT $LL113@basic_stri
  0003e	2b d7		 sub	 edx, edi
  00040	5f		 pop	 edi
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 816  : 		_Tidy();
; 817  : 		assign(_Right, _Roff, _Count);

  00004	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00016	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001d	c6 06 00	 mov	 BYTE PTR [esi], 0
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 818  : 		}

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 795  : 		_Tidy();

  00000	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 796  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 607  : 		_Pocma(_Getal(), _Al);
; 608  : 		}

  00000	c2 04 00	 ret	 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 1009 : 		}

  00003	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN7@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN16@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN18@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN19@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN20@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN7@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 988  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN18@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN19@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN20@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN15@deallocate:
  00049	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 976  : 		return (_Mybase::allocate(_Count));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN6@allocate
$LN15@allocate:

; 977  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN6@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN8@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN17@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN19@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 977  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN8@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN15@allocate
  00045	eb 0a		 jmp	 SHORT $LN20@allocate
$LN17@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN21@allocate:
$LN19@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN20@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@allocate:
$LN16@allocate:
  00056	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 965  : 		}

  00002	c2 04 00	 ret	 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 927  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 870  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 750  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN6@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN14@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN16@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN12@allocate
  00045	eb 0a		 jmp	 SHORT $LN17@allocate
$LN14@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN18@allocate:
$LN16@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN17@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN13@allocate:
  00056	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN5@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN13@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN15@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN16@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN17@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN5@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 721  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN15@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN16@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN17@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN12@deallocate:
  00049	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 95   : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 133  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 67   : 			_Xbad_alloc();	// report no memory
; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 559  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00003	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00006	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 _memset
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 561  : 		}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00012	5d		 pop	 ebp

; 553  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?find@?$char_traits@D@std@@SAPBDPBDIABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT

; 545  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN3@find

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN3@find:

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  0000c	50		 push	 eax
  0000d	8b 45 10	 mov	 eax, DWORD PTR __Ch$[ebp]
  00010	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00017	e8 00 00 00 00	 call	 _memchr
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 530  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00012	5d		 pop	 ebp

; 530  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 04		 jne	 SHORT $LN3@length
  0000b	33 c0		 xor	 eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

  0000f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL5@length:
  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	40		 inc	 eax
  00015	84 c9		 test	 cl, cl
  00017	75 f9		 jne	 SHORT $LL5@length
  00019	2b c2		 sub	 eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 516  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 517  : 		return (_Count == 0 ? 0

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN3@compare
  0000a	33 c0		 xor	 eax, eax

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN3@compare:

; 517  : 		return (_Count == 0 ? 0

  0000e	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR __First2$[ebp]
  00015	83 e9 04	 sub	 ecx, 4
  00018	72 17		 jb	 SHORT $LN7@compare
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL8@compare:
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	3b 06		 cmp	 eax, DWORD PTR [esi]
  00024	75 10		 jne	 SHORT $LN6@compare
  00026	83 c2 04	 add	 edx, 4
  00029	83 c6 04	 add	 esi, 4
  0002c	83 e9 04	 sub	 ecx, 4
  0002f	73 ef		 jae	 SHORT $LL8@compare
$LN7@compare:
  00031	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00034	74 35		 je	 SHORT $LN5@compare
$LN6@compare:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	3a 06		 cmp	 al, BYTE PTR [esi]
  0003a	75 27		 jne	 SHORT $LN9@compare
  0003c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0003f	74 2a		 je	 SHORT $LN5@compare
  00041	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00044	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00047	75 1a		 jne	 SHORT $LN9@compare
  00049	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0004c	74 1d		 je	 SHORT $LN5@compare
  0004e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00051	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00054	75 0d		 jne	 SHORT $LN9@compare
  00056	83 f9 ff	 cmp	 ecx, -1
  00059	74 10		 je	 SHORT $LN5@compare
  0005b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0005e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00061	74 08		 je	 SHORT $LN5@compare
$LN9@compare:
  00063	1b c0		 sbb	 eax, eax
  00065	83 c8 01	 or	 eax, 1
  00068	5e		 pop	 esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN5@compare:

; 517  : 		return (_Count == 0 ? 0

  0006b	33 c0		 xor	 eax, eax
  0006d	5e		 pop	 esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\propvarutil.h
;	COMDAT ?InitPropVariantFromString@@YAJPB_WPAUtagPROPVARIANT@@@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
_ppropvar$ = 12						; size = 4
?InitPropVariantFromString@@YAJPB_WPAUtagPROPVARIANT@@@Z PROC ; InitPropVariantFromString, COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 453  :     ppropvar->vt = VT_LPWSTR;

  00004	8b 75 0c	 mov	 esi, DWORD PTR _ppropvar$[ebp]
  00007	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  0000c	66 89 06	 mov	 WORD PTR [esi], ax

; 454  :     HRESULT hr = SHStrDupW(psz, &ppropvar->pwszVal);

  0000f	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00012	50		 push	 eax
  00013	ff 75 08	 push	 DWORD PTR _psz$[ebp]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHStrDupW@8

; 455  :     if (FAILED(hr))

  0001c	85 c0		 test	 eax, eax
  0001e	79 06		 jns	 SHORT $LN2@InitPropVa

; 456  :     {
; 457  :         PropVariantInit(ppropvar);

  00020	0f 57 c0	 xorps	 xmm0, xmm0
  00023	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
$LN2@InitPropVa:
  00026	5e		 pop	 esi

; 458  :     }
; 459  :     return hr;
; 460  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?InitPropVariantFromString@@YAJPB_WPAUtagPROPVARIANT@@@Z ENDP ; InitPropVariantFromString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1960 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1961 :     int _Result;
; 1962 :     va_list _ArgList;
; 1963 :     __crt_va_start(_ArgList, _Format);
; 1964 : #pragma warning(suppress:28719)    // __WARNING_BANNED_API_USAGE
; 1965 :     _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1966 :     __crt_va_end(_ArgList);
; 1967 :     return _Result;
; 1968 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1406 :     #pragma warning(push)
; 1407 :     #pragma warning(disable: 4996) // Deprecation
; 1408 :     return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1409 :     #pragma warning(pop)
; 1410 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);
; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 836  :     __crt_va_end(_ArgList);
; 837  :     return _Result;
; 838  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 640  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT ?swprintf@@YAHQA_WQB_WZZ
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
?swprintf@@YAHQA_WQB_WZZ PROC				; swprintf, COMDAT

; 1824 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1825 :             int _Result;
; 1826 :             va_list _ArgList;
; 1827 :             __crt_va_start(_ArgList, _Format);
; 1828 :             #pragma warning(suppress: 28719)
; 1829 :             _Result = vswprintf(_Buffer, _CRT_INT_MAX, _Format, _ArgList);       

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00011	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00014	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	ff 30		 push	 DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ___stdio_common_vswprintf
  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1830 :             __crt_va_end(_ArgList);
; 1831 :             return _Result;
; 1832 :         }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?swprintf@@YAHQA_WQB_WZZ ENDP				; swprintf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT _vswprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vswprintf PROC						; COMDAT

; 1245 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1246 :     return _vswprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vswprintf
  00020	83 c9 ff	 or	 ecx, -1
  00023	83 c4 1c	 add	 esp, 28			; 0000001cH
  00026	85 c0		 test	 eax, eax
  00028	0f 48 c1	 cmovs	 eax, ecx

; 1247 : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_vswprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_c_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_c_l PROC					; COMDAT

; 1158 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1159 :     int const _Result = __stdio_common_vswprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vswprintf

; 1160 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1161 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1162 : 
; 1163 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1164 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vswprintf_c_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<wchar_t const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\propidl.h
;	COMDAT _PropVariantInit
_TEXT	SEGMENT
_pvar$ = 8						; size = 4
_PropVariantInit PROC					; COMDAT

; 1184 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1185 :     memset ( pvar, 0, sizeof(PROPVARIANT) );

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvar$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 1186 : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_PropVariantInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\setup.c
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_si$1 = -112						; size = 68
_pi$2 = -44						; size = 16
_tmpStr$3 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpszCommandLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 2301 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _hInstance$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 10	 mov	 edi, DWORD PTR _lpszCommandLine$[ebp]

; 2302 : 	atexit (localcleanup);

  00018	68 00 00 00 00	 push	 OFFSET _localcleanup
  0001d	e8 00 00 00 00	 call	 _atexit
  00022	83 c4 04	 add	 esp, 4

; 2303 : 
; 2304 : 	SelfExtractStartupInit();

  00025	e8 00 00 00 00	 call	 _SelfExtractStartupInit

; 2305 : 
; 2306 : 	lpszTitle = L"GostCrypt Setup";

  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpszTitle, OFFSET ??_C@_1CA@DBLADCOC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AA?$AA@

; 2307 : 
; 2308 : 	InitCommonControls ();

  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitCommonControls@0

; 2309 : 
; 2310 : 	/* Call InitApp to initialize the common code */
; 2311 : 	InitApp (hInstance, NULL);

  0003a	6a 00		 push	 0
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 _InitApp
  00042	83 c4 08	 add	 esp, 8

; 2312 : 
; 2313 : 	if (IsAdmin () != TRUE)

  00045	e8 00 00 00 00	 call	 _IsAdmin
  0004a	83 f8 01	 cmp	 eax, 1
  0004d	74 27		 je	 SHORT $LN5@WinMain

; 2314 : 		if (MessageBoxW (NULL, GetString ("SETUP_ADMIN"), lpszTitle, MB_YESNO | MB_ICONQUESTION) != IDYES)

  0004f	6a 24		 push	 36			; 00000024H
  00051	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HBOJDPDG@SETUP_ADMIN?$AA@
  0005c	e8 00 00 00 00	 call	 _GetString
  00061	83 c4 04	 add	 esp, 4
  00064	50		 push	 eax
  00065	6a 00		 push	 0
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  0006d	83 f8 06	 cmp	 eax, 6
  00070	0f 85 5d 02 00
	00		 jne	 $LN36@WinMain
$LN5@WinMain:

; 2317 : 		}
; 2318 : 
; 2319 : 	/* Setup directory */
; 2320 : 	{
; 2321 : 		char *s;
; 2322 : 		GetModuleFileName (NULL, SetupFilesDir, sizeof (SetupFilesDir));

  00076	68 04 01 00 00	 push	 260			; 00000104H
  0007b	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  00080	6a 00		 push	 0
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 2323 : 		s = strrchr (SetupFilesDir, '\\');

  00088	6a 5c		 push	 92			; 0000005cH
  0008a	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  0008f	e8 00 00 00 00	 call	 _strrchr
  00094	83 c4 08	 add	 esp, 8

; 2324 : 		if (s)

  00097	85 c0		 test	 eax, eax
  00099	74 04		 je	 SHORT $LN6@WinMain

; 2325 : 			s[1] = 0;

  0009b	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
$LN6@WinMain:

; 2326 : 	}
; 2327 : 
; 2328 : 	/* Parse command line arguments */
; 2329 : 
; 2330 : 	if (lpszCommandLine[0] == '/')

  0009f	80 3f 2f	 cmp	 BYTE PTR [edi], 47	; 0000002fH
  000a2	75 6c		 jne	 SHORT $LN14@WinMain

; 2331 : 	{
; 2332 : 		if (lpszCommandLine[1] == 'u')

  000a4	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000a7	80 f9 75	 cmp	 cl, 117			; 00000075H
  000aa	75 0c		 jne	 SHORT $LN8@WinMain

; 2333 : 		{
; 2334 : 			// Uninstall:	/u
; 2335 : 
; 2336 : 			bUninstall = TRUE;

  000ac	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bUninstall@@3HA, 1 ; bUninstall
  000b6	eb 58		 jmp	 SHORT $LN14@WinMain
$LN8@WinMain:

; 2337 : 		}
; 2338 : 		else if (lpszCommandLine[1] == 'c')

  000b8	80 f9 63	 cmp	 cl, 99			; 00000063H
  000bb	75 0c		 jne	 SHORT $LN10@WinMain

; 2339 : 		{
; 2340 : 			// Change:	/c
; 2341 : 
; 2342 : 			bChangeMode = TRUE;

  000bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bChangeMode@@3HA, 1 ; bChangeMode
  000c7	eb 47		 jmp	 SHORT $LN14@WinMain
$LN10@WinMain:

; 2343 : 		}
; 2344 : 		else if (lpszCommandLine[1] == 'p')

  000c9	80 f9 70	 cmp	 cl, 112			; 00000070H
  000cc	75 2d		 jne	 SHORT $LN12@WinMain

; 2358 : 	{
; 2359 : 		/* Create self-extracting package */
; 2360 : 
; 2361 : 		MakeSelfExtractingPackage (NULL, SetupFilesDir);

  000ce	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  000d3	6a 00		 push	 0
  000d5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bMakePackage@@3HA, 1 ; bMakePackage
  000df	e8 00 00 00 00	 call	 _MakeSelfExtractingPackage
  000e4	83 c4 08	 add	 esp, 8

; 2437 : 				}
; 2438 : 			}
; 2439 : 		}
; 2440 : 	}
; 2441 : 
; 2442 : 	return 0;

  000e7	33 c0		 xor	 eax, eax
  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi

; 2443 : }

  000eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ee	33 cd		 xor	 ecx, ebp
  000f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c2 10 00	 ret	 16			; 00000010H
$LN12@WinMain:

; 2345 : 		{
; 2346 : 			// Create self-extracting package:	/p
; 2347 : 
; 2348 : 			bMakePackage = TRUE;
; 2349 : 		}
; 2350 : 		else if (lpszCommandLine[1] == 'd')

  000fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _bDevm
  00100	80 f9 64	 cmp	 cl, 100			; 00000064H
  00103	ba 01 00 00 00	 mov	 edx, 1
  00108	0f 44 c2	 cmove	 eax, edx
  0010b	a3 00 00 00 00	 mov	 DWORD PTR _bDevm, eax
$LN14@WinMain:

; 2351 : 		{
; 2352 : 			// Dev mode:	/d
; 2353 : 			bDevm = TRUE;
; 2354 : 		}
; 2355 : 	}
; 2356 : 
; 2357 : 	if (bMakePackage)

  00110	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bMakePackage@@3HA, 0 ; bMakePackage
  00117	74 23		 je	 SHORT $LN15@WinMain

; 2358 : 	{
; 2359 : 		/* Create self-extracting package */
; 2360 : 
; 2361 : 		MakeSelfExtractingPackage (NULL, SetupFilesDir);

  00119	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  0011e	6a 00		 push	 0
  00120	e8 00 00 00 00	 call	 _MakeSelfExtractingPackage
  00125	83 c4 08	 add	 esp, 8

; 2437 : 				}
; 2438 : 			}
; 2439 : 		}
; 2440 : 	}
; 2441 : 
; 2442 : 	return 0;

  00128	33 c0		 xor	 eax, eax
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi

; 2443 : }

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012f	33 cd		 xor	 ecx, ebp
  00131	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c2 10 00	 ret	 16			; 00000010H
$LN15@WinMain:

; 2362 : 	}
; 2363 : 	else
; 2364 : 	{
; 2365 : 		SetInstallationPath (NULL);

  0013c	6a 00		 push	 0
  0013e	e8 00 00 00 00	 call	 _SetInstallationPath
  00143	83 c4 04	 add	 esp, 4

; 2366 : 
; 2367 : 		if (!bUninstall)

  00146	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  0014d	0f 85 94 00 00
	00		 jne	 $LN2@WinMain

; 2368 : 		{
; 2369 : 			if (IsSelfExtractingPackage())

  00153	e8 00 00 00 00	 call	 _IsSelfExtractingPackage
  00158	85 c0		 test	 eax, eax
  0015a	74 67		 je	 SHORT $LN18@WinMain

; 2370 : 			{
; 2371 : 				if (!VerifyPackageIntegrity())

  0015c	e8 00 00 00 00	 call	 _VerifyPackageIntegrity
  00161	85 c0		 test	 eax, eax
  00163	0f 84 71 01 00
	00		 je	 $LN38@WinMain

; 2375 : 				}
; 2376 : 				bDevm = FALSE;

  00169	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bDevm, 0
$LN21@WinMain:

; 2382 : 			}
; 2383 : 
; 2384 : 			if (bChangeMode)

  00173	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bChangeMode@@3HA, 0 ; bChangeMode
  0017a	74 6b		 je	 SHORT $LN2@WinMain

; 2385 : 			{
; 2386 : 				/* GostCrypt is already installed on this system and we were launched from the Program Files folder */
; 2387 : 
; 2388 : 				char *tmpStr[] = {0, "SELECT_AN_ACTION", "REPAIR_REINSTALL", "UNINSTALL", "EXIT", 0};
; 2389 : 
; 2390 : 				// Ask the user to select either Repair or Unistallation
; 2391 : 				switch (AskMultiChoice ((void **) tmpStr, FALSE))

  0017c	8d 45 e4	 lea	 eax, DWORD PTR _tmpStr$3[ebp]
  0017f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _tmpStr$3[ebp], 0
  00186	6a 00		 push	 0
  00188	50		 push	 eax
  00189	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _tmpStr$3[ebp+4], OFFSET ??_C@_0BB@FLPPPJPG@SELECT_AN_ACTION?$AA@
  00190	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tmpStr$3[ebp+8], OFFSET ??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@
  00197	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _tmpStr$3[ebp+12], OFFSET ??_C@_09DGJDINFF@UNINSTALL?$AA@
  0019e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _tmpStr$3[ebp+16], OFFSET ??_C@_04GOLNGIJ@EXIT?$AA@
  001a5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tmpStr$3[ebp+20], 0
  001ac	e8 00 00 00 00	 call	 _AskMultiChoice
  001b1	83 c4 08	 add	 esp, 8
  001b4	83 e8 01	 sub	 eax, 1
  001b7	74 24		 je	 SHORT $LN23@WinMain
  001b9	83 e8 01	 sub	 eax, 1
  001bc	74 13		 je	 SHORT $LN24@WinMain
  001be	e9 1e 01 00 00	 jmp	 $LN39@WinMain
$LN18@WinMain:

; 2377 : 			}
; 2378 : 			else if (!bDevm)

  001c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  001ca	75 a7		 jne	 SHORT $LN21@WinMain
  001cc	e9 17 01 00 00	 jmp	 $LN40@WinMain
$LN24@WinMain:

; 2395 : 					break;
; 2396 : 				case 2:
; 2397 : 					bUninstall = TRUE;

  001d1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bUninstall@@3HA, 1 ; bUninstall

; 2398 : 					break;

  001db	eb 0a		 jmp	 SHORT $LN2@WinMain
$LN23@WinMain:

; 2392 : 				{
; 2393 : 				case 1:
; 2394 : 					bRepairMode = TRUE;

  001dd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bRepairMode, 1
$LN2@WinMain:

; 2401 : 				}
; 2402 : 			}
; 2403 : 		}
; 2404 : 
; 2405 : 		// System Restore
; 2406 : 		SystemRestoreDll = LoadLibraryEx("srclient.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);

  001e7	68 00 08 00 00	 push	 2048			; 00000800H
  001ec	6a 00		 push	 0
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FMOIKEAK@srclient?4dll?$AA@
  001f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryExA@12

; 2407 : 
; 2408 : 		if (!bUninstall)

  001f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00200	a3 00 00 00 00	 mov	 DWORD PTR _SystemRestoreDll, eax
  00205	75 25		 jne	 SHORT $LN26@WinMain

; 2409 : 		{
; 2410 : 			/* Create the main dialog for install */
; 2411 : 
; 2412 : 			DialogBoxParamW (hInstance, MAKEINTRESOURCEW (IDD_INSTL_DLG), NULL, (DLGPROC) MainDialogProc, 

  00207	57		 push	 edi
  00208	68 00 00 00 00	 push	 OFFSET _MainDialogProc@16
  0020d	6a 00		 push	 0
  0020f	6a 6f		 push	 111			; 0000006fH
  00211	56		 push	 esi
  00212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20
  00218	5f		 pop	 edi

; 2437 : 				}
; 2438 : 			}
; 2439 : 		}
; 2440 : 	}
; 2441 : 
; 2442 : 	return 0;

  00219	33 c0		 xor	 eax, eax
  0021b	5e		 pop	 esi

; 2443 : }

  0021c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021f	33 cd		 xor	 ecx, ebp
  00221	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00226	8b e5		 mov	 esp, ebp
  00228	5d		 pop	 ebp
  00229	c2 10 00	 ret	 16			; 00000010H
$LN26@WinMain:

; 2413 : 				(LPARAM)lpszCommandLine);
; 2414 : 		}
; 2415 : 		else
; 2416 : 		{
; 2417 : 			/* Create the main dialog for uninstall  */
; 2418 : 
; 2419 : 			DialogBoxW (hInstance, MAKEINTRESOURCEW (IDD_UNINSTALL), NULL, (DLGPROC) UninstallDlgProc);

  0022c	6a 00		 push	 0
  0022e	68 00 00 00 00	 push	 OFFSET ?UninstallDlgProc@@YGHPAUHWND__@@IIJ@Z ; UninstallDlgProc
  00233	6a 00		 push	 0
  00235	6a 67		 push	 103			; 00000067H
  00237	56		 push	 esi
  00238	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20

; 2420 : 
; 2421 : 			if (UninstallBatch[0])

  0023e	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?UninstallBatch@@3PADA, 0
  00245	74 78		 je	 SHORT $LN30@WinMain

; 2422 : 			{
; 2423 : 				STARTUPINFO si;
; 2424 : 				PROCESS_INFORMATION pi;
; 2425 : 
; 2426 : 				ZeroMemory (&si, sizeof (si));

  00247	6a 44		 push	 68			; 00000044H
  00249	8d 45 90	 lea	 eax, DWORD PTR _si$1[ebp]
  0024c	6a 00		 push	 0
  0024e	50		 push	 eax
  0024f	e8 00 00 00 00	 call	 _memset
  00254	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2427 : 				si.cb = sizeof (si);

  00257	c7 45 90 44 00
	00 00		 mov	 DWORD PTR _si$1[ebp], 68 ; 00000044H

; 2428 : 				si.dwFlags = STARTF_USESHOWWINDOW;
; 2429 : 				si.wShowWindow = SW_HIDE;

  0025e	33 c0		 xor	 eax, eax
  00260	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR _si$1[ebp+44], 1
  00267	66 89 45 c0	 mov	 WORD PTR _si$1[ebp+48], ax

; 2430 : 
; 2431 : 				if (!CreateProcess (UninstallBatch, NULL, NULL, NULL, FALSE, IDLE_PRIORITY_CLASS, NULL, NULL, &si, &pi))

  0026b	8d 45 d4	 lea	 eax, DWORD PTR _pi$2[ebp]
  0026e	50		 push	 eax
  0026f	8d 45 90	 lea	 eax, DWORD PTR _si$1[ebp]
  00272	50		 push	 eax
  00273	6a 00		 push	 0
  00275	6a 00		 push	 0
  00277	6a 40		 push	 64			; 00000040H
  00279	6a 00		 push	 0
  0027b	6a 00		 push	 0
  0027d	6a 00		 push	 0
  0027f	6a 00		 push	 0
  00281	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA ; UninstallBatch
  00286	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40
  0028c	85 c0		 test	 eax, eax
  0028e	75 1f		 jne	 SHORT $LN29@WinMain

; 2432 : 					DeleteFile (UninstallBatch);

  00290	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA ; UninstallBatch
  00295	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
  0029b	5f		 pop	 edi

; 2437 : 				}
; 2438 : 			}
; 2439 : 		}
; 2440 : 	}
; 2441 : 
; 2442 : 	return 0;

  0029c	33 c0		 xor	 eax, eax
  0029e	5e		 pop	 esi

; 2443 : }

  0029f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a2	33 cd		 xor	 ecx, ebp
  002a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a9	8b e5		 mov	 esp, ebp
  002ab	5d		 pop	 ebp
  002ac	c2 10 00	 ret	 16			; 00000010H
$LN29@WinMain:

; 2433 : 				else
; 2434 : 				{
; 2435 : 					CloseHandle (pi.hProcess);

  002af	ff 75 d4	 push	 DWORD PTR _pi$2[ebp]
  002b2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  002b8	ff d6		 call	 esi

; 2436 : 					CloseHandle (pi.hThread);

  002ba	ff 75 d8	 push	 DWORD PTR _pi$2[ebp+4]
  002bd	ff d6		 call	 esi
$LN30@WinMain:

; 2443 : }

  002bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c2	33 c0		 xor	 eax, eax
  002c4	5f		 pop	 edi
  002c5	33 cd		 xor	 ecx, ebp
  002c7	5e		 pop	 esi
  002c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cd	8b e5		 mov	 esp, ebp
  002cf	5d		 pop	 ebp
  002d0	c2 10 00	 ret	 16			; 00000010H
$LN36@WinMain:

; 2315 : 		{
; 2316 : 			exit (1);

  002d3	6a 01		 push	 1
  002d5	e8 00 00 00 00	 call	 _exit
$LN41@WinMain:
$LN38@WinMain:

; 2372 : 				{
; 2373 : 					// Package corrupted 
; 2374 : 					exit (1);

  002da	6a 01		 push	 1
  002dc	e8 00 00 00 00	 call	 _exit
$LN42@WinMain:
$LN39@WinMain:

; 2399 : 				default:
; 2400 : 					exit (1);

  002e1	6a 01		 push	 1
  002e3	e8 00 00 00 00	 call	 _exit
$LN43@WinMain:
$LN40@WinMain:

; 2379 : 			{
; 2380 : 				MessageBox (NULL, "Error: This installer file does not contain any compressed files.\n\nTo create a self-extracting installation package (with embedded compressed files), run:\n\"GostCrypt Setup.exe\" /p", "GostCrypt", MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);

  002e8	68 10 00 05 00	 push	 327696			; 00050010H
  002ed	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0LE@HOLFPDAN@Error?3?5This?5installer?5file?5does?5@
  002f7	6a 00		 push	 0
  002f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 2381 : 				exit (1);

  002ff	6a 01		 push	 1
  00301	e8 00 00 00 00	 call	 _exit
$LN44@WinMain:
$LN35@WinMain:
  00306	cc		 int	 3
_WinMain@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__SubString$ = 12					; size = 4
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT

; 536  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 538  :     }

  00003	5d		 pop	 ebp

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00004	e9 00 00 00 00	 jmp	 _strstr
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strrchr@@YAPADQADH@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strrchr@@YAPADQADH@Z PROC				; strrchr, COMDAT

; 530  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 532  :     }

  00003	5d		 pop	 ebp

; 531  :         return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));

  00004	e9 00 00 00 00	 jmp	 _strrchr
?strrchr@@YAPADQADH@Z ENDP				; strrchr
_TEXT	ENDS
END
