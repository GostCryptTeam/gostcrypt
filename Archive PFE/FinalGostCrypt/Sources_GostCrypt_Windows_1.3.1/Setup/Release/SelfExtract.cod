; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Desktop\Sources_GostCrypt_Windows_1.3.1_COMMENTED\Sources_GostCrypt_Windows_1.3.1é\Sources_GostCrypt_Windows_1.3.1\Setup\SelfExtract.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_PipeWriteBuf
PUBLIC	_hChildStdinWrite
PUBLIC	_DecompressedData
_DATA	SEGMENT
COMM	_Decompressed_Files:BYTE:078H
COMM	_DestExtractPath:BYTE:0104H
COMM	_MagEndMarker:BYTE:010H
_DATA	ENDS
_BSS	SEGMENT
_PipeWriteBuf DD 01H DUP (?)
_DecompressedData DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_hChildStdinWrite DD 0ffffffffH
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__snwprintf
PUBLIC	_sprintf
PUBLIC	__snprintf
PUBLIC	_SelfExtractStartupInit
PUBLIC	_SelfExtractInMemory
PUBLIC	_ExtractAllFilesThread
PUBLIC	_MakeSelfExtractingPackage
PUBLIC	_VerifyPackageIntegrity
PUBLIC	_IsSelfExtractingPackage
PUBLIC	??_C@_0BJ@ELFIPPEB@GostCrypt?5User?5Guide?4pdf?$AA@ ; `string'
PUBLIC	??_C@_0M@HNDLNFKG@License?4txt?$AA@		; `string'
PUBLIC	??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@		; `string'
PUBLIC	??_C@_0BF@MBKAOEOG@GostCrypt?5Format?4exe?$AA@	; `string'
PUBLIC	??_C@_0O@IAPAHIFF@gostcrypt?4sys?$AA@		; `string'
PUBLIC	??_C@_0BC@MDIFFMMP@gostcrypt?9x64?4sys?$AA@	; `string'
PUBLIC	??_C@_0BA@LOGCKKME@T?1C?1I?1N?1S?1C?1R?1C?$AA@	; `string'
PUBLIC	??_C@_09NKHKFHLH@GostCrypt?$AA@			; `string'
PUBLIC	??_C@_0CG@GGPNKNGJ@Failed?5sending?5data?5to?5the?5STDIN@ ; `string'
PUBLIC	??_C@_0BC@LMFKNEDD@Cannot?5close?5pipe?$AA@	; `string'
PUBLIC	??_C@_0BL@CGCLLOGA@Cannot?5create?5STDOUT?5pipe?4?$AA@ ; `string'
PUBLIC	??_C@_0BK@CBLLHDHE@Cannot?5create?5STDIN?5pipe?4?$AA@ ; `string'
PUBLIC	??_C@_0M@HPMDPAK@gzip?5?9?9best?$AA@		; `string'
PUBLIC	??_C@_0BCK@ECOEIKIB@Error?3?5Cannot?5run?5gzip?4?6?6Before?5@ ; `string'
PUBLIC	??_C@_0BK@NGGPKPLC@Cannot?5close?5STDOUT?5write?$AA@ ; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_0BK@KDKMAE@GostCrypt?5Setup?51?43?41?4exe?$AA@ ; `string'
PUBLIC	??_C@_0DB@HAEGGKEK@Cannot?5copy?5?8GostCrypt?5Setup?4exe@ ; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BG@MKKJCCCC@File?5not?5found?3?6?6?8?$CFs?8?$AA@ ; `string'
PUBLIC	??_C@_0CN@MELKNJCC@Cannot?5allocate?5memory?5for?5uncom@ ; `string'
PUBLIC	??_C@_09JEFCBPAJ@GSTINSTRT?$AA@			; `string'
PUBLIC	??_C@_0BO@MFJOIAFD@Cannot?5write?5the?5start?5marker?$AA@ ; `string'
PUBLIC	??_C@_0BH@BHAJCMKJ@Cannot?5load?5file?5?6?8?$CFs?8?$AA@ ; `string'
PUBLIC	??_C@_0DF@FMCDCAIK@Cannot?5write?5the?5total?5size?5of?5t@ ; `string'
PUBLIC	??_C@_0CL@MCBJOHEJ@Cannot?5allocate?5memory?5for?5compr@ ; `string'
PUBLIC	??_C@_0BM@OPFGKMBF@Failed?5to?5compress?5the?5data?$AA@ ; `string'
PUBLIC	??_C@_0DD@BPNJOCGM@Cannot?5write?5the?5total?5size?5of?5t@ ; `string'
PUBLIC	??_C@_0CM@OKBFEFMD@Cannot?5write?5compressed?5data?5to?5@ ; `string'
PUBLIC	??_C@_0BM@CAOLNJAF@Cannot?5write?5the?5end?5marker?$AA@ ; `string'
PUBLIC	??_C@_0CH@KLAPHHKA@Cannot?5load?5the?5package?5to?5compu@ ; `string'
PUBLIC	??_C@_0DC@MFPOOIGB@Self?9extracting?5package?5successf@ ; `string'
PUBLIC	??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@	; `string'
PUBLIC	??_C@_0BO@FDGMLBCO@CANT_VERIFY_PACKAGE_INTEGRITY?$AA@ ; `string'
PUBLIC	??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@ ; `string'
PUBLIC	??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@		; `string'
PUBLIC	??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@	; `string'
PUBLIC	??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@		; `string'
PUBLIC	??_C@_0BE@BADKJOBO@CANNOT_WRITE_FILE_X?$AA@	; `string'
PUBLIC	__real@40c00000
PUBLIC	__real@42c80000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_strncat:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetHandleInformation@12:PROC
EXTRN	__imp__CreatePipe@16:PROC
EXTRN	__imp__CreateProcessA@40:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__wsprintfW:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__imp__GetParent@4:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__beginthread:PROC
EXTRN	___stdio_common_vswprintf:PROC
EXTRN	_remove:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_DecompressDeflatedData:PROC
EXTRN	_StatusMessageParam:PROC
EXTRN	_ClearLogWindow:PROC
EXTRN	_UpdateProgressBarProc:PROC
EXTRN	_GetCrc32:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	_FileExists:PROC
EXTRN	_FindStringInFile:PROC
EXTRN	_GSTCopyFile:PROC
EXTRN	_SaveBufferToFile:PROC
EXTRN	_GetFileSize64:PROC
EXTRN	_LoadInt32:PROC
EXTRN	_LoadFile:PROC
EXTRN	_LoadFileBlock:PROC
EXTRN	_Error:PROC
EXTRN	_mkfulldir:PROC
EXTRN	_GetString:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_MainDlg:DWORD
EXTRN	_lpszTitle:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT ??_C@_0BE@BADKJOBO@CANNOT_WRITE_FILE_X?$AA@
CONST	SEGMENT
??_C@_0BE@BADKJOBO@CANNOT_WRITE_FILE_X?$AA@ DB 'CANNOT_WRITE_FILE_X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@
CONST	SEGMENT
??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@ DB 'EXTRACTING_VERB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@
CONST	SEGMENT
??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@ DB 'CANT_CREATE_FOLDER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@
CONST	SEGMENT
??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@ DB 'ERR_MEM_ALLOC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@
CONST	SEGMENT
??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@ DB 'CANNOT_READ_FROM_PAC'
	DB	'KAGE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FDGMLBCO@CANT_VERIFY_PACKAGE_INTEGRITY?$AA@
CONST	SEGMENT
??_C@_0BO@FDGMLBCO@CANT_VERIFY_PACKAGE_INTEGRITY?$AA@ DB 'CANT_VERIFY_PAC'
	DB	'KAGE_INTEGRITY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@
CONST	SEGMENT
??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@ DB 'DIST_PACKAGE_CORRUPTED'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MFPOOIGB@Self?9extracting?5package?5successf@
CONST	SEGMENT
??_C@_0DC@MFPOOIGB@Self?9extracting?5package?5successf@ DB 'Self-extracti'
	DB	'ng package successfully created (%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KLAPHHKA@Cannot?5load?5the?5package?5to?5compu@
CONST	SEGMENT
??_C@_0CH@KLAPHHKA@Cannot?5load?5the?5package?5to?5compu@ DB 'Cannot load'
	DB	' the package to compute CRC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CAOLNJAF@Cannot?5write?5the?5end?5marker?$AA@
CONST	SEGMENT
??_C@_0BM@CAOLNJAF@Cannot?5write?5the?5end?5marker?$AA@ DB 'Cannot write '
	DB	'the end marker', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OKBFEFMD@Cannot?5write?5compressed?5data?5to?5@
CONST	SEGMENT
??_C@_0CM@OKBFEFMD@Cannot?5write?5compressed?5data?5to?5@ DB 'Cannot writ'
	DB	'e compressed data to the package', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BPNJOCGM@Cannot?5write?5the?5total?5size?5of?5t@
CONST	SEGMENT
??_C@_0DD@BPNJOCGM@Cannot?5write?5the?5total?5size?5of?5t@ DB 'Cannot wri'
	DB	'te the total size of the compressed data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OPFGKMBF@Failed?5to?5compress?5the?5data?$AA@
CONST	SEGMENT
??_C@_0BM@OPFGKMBF@Failed?5to?5compress?5the?5data?$AA@ DB 'Failed to com'
	DB	'press the data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MCBJOHEJ@Cannot?5allocate?5memory?5for?5compr@
CONST	SEGMENT
??_C@_0CL@MCBJOHEJ@Cannot?5allocate?5memory?5for?5compr@ DB 'Cannot alloc'
	DB	'ate memory for compressed data', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FMCDCAIK@Cannot?5write?5the?5total?5size?5of?5t@
CONST	SEGMENT
??_C@_0DF@FMCDCAIK@Cannot?5write?5the?5total?5size?5of?5t@ DB 'Cannot wri'
	DB	'te the total size of the uncompressed data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BHAJCMKJ@Cannot?5load?5file?5?6?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0BH@BHAJCMKJ@Cannot?5load?5file?5?6?8?$CFs?8?$AA@ DB 'Cannot load f'
	DB	'ile ', 0aH, '''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MFJOIAFD@Cannot?5write?5the?5start?5marker?$AA@
CONST	SEGMENT
??_C@_0BO@MFJOIAFD@Cannot?5write?5the?5start?5marker?$AA@ DB 'Cannot writ'
	DB	'e the start marker', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09JEFCBPAJ@GSTINSTRT?$AA@
CONST	SEGMENT
??_C@_09JEFCBPAJ@GSTINSTRT?$AA@ DB 'GSTINSTRT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MELKNJCC@Cannot?5allocate?5memory?5for?5uncom@
CONST	SEGMENT
??_C@_0CN@MELKNJCC@Cannot?5allocate?5memory?5for?5uncom@ DB 'Cannot alloc'
	DB	'ate memory for uncompressed data', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MKKJCCCC@File?5not?5found?3?6?6?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0BG@MKKJCCCC@File?5not?5found?3?6?6?8?$CFs?8?$AA@ DB 'File not foun'
	DB	'd:', 0aH, 0aH, '''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HAEGGKEK@Cannot?5copy?5?8GostCrypt?5Setup?4exe@
CONST	SEGMENT
??_C@_0DB@HAEGGKEK@Cannot?5copy?5?8GostCrypt?5Setup?4exe@ DB 'Cannot copy'
	DB	' ''GostCrypt Setup.exe'' to the package', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KDKMAE@GostCrypt?5Setup?51?43?41?4exe?$AA@
CONST	SEGMENT
??_C@_0BK@KDKMAE@GostCrypt?5Setup?51?43?41?4exe?$AA@ DB 'GostCrypt Setup '
	DB	'1.3.1.exe', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NGGPKPLC@Cannot?5close?5STDOUT?5write?$AA@
CONST	SEGMENT
??_C@_0BK@NGGPKPLC@Cannot?5close?5STDOUT?5write?$AA@ DB 'Cannot close STD'
	DB	'OUT write', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCK@ECOEIKIB@Error?3?5Cannot?5run?5gzip?4?6?6Before?5@
CONST	SEGMENT
??_C@_0BCK@ECOEIKIB@Error?3?5Cannot?5run?5gzip?4?6?6Before?5@ DB 'Error: '
	DB	'Cannot run gzip.', 0aH, 0aH, 'Before you can create a self-ex'
	DB	'tracting GostCrypt package, you need to have the open-source '
	DB	'''gzip'' compression tool placed in any directory in the sear'
	DB	'ch path for executable files (for example, in ''C:\Windows\'''
	DB	').', 0aH, 0aH, 'Note: gzip can be freely downloaded e.g. from'
	DB	' www.gzip.org', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HPMDPAK@gzip?5?9?9best?$AA@
CONST	SEGMENT
??_C@_0M@HPMDPAK@gzip?5?9?9best?$AA@ DB 'gzip --best', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CBLLHDHE@Cannot?5create?5STDIN?5pipe?4?$AA@
CONST	SEGMENT
??_C@_0BK@CBLLHDHE@Cannot?5create?5STDIN?5pipe?4?$AA@ DB 'Cannot create S'
	DB	'TDIN pipe.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CGCLLOGA@Cannot?5create?5STDOUT?5pipe?4?$AA@
CONST	SEGMENT
??_C@_0BL@CGCLLOGA@Cannot?5create?5STDOUT?5pipe?4?$AA@ DB 'Cannot create '
	DB	'STDOUT pipe.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LMFKNEDD@Cannot?5close?5pipe?$AA@
CONST	SEGMENT
??_C@_0BC@LMFKNEDD@Cannot?5close?5pipe?$AA@ DB 'Cannot close pipe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GGPNKNGJ@Failed?5sending?5data?5to?5the?5STDIN@
CONST	SEGMENT
??_C@_0CG@GGPNKNGJ@Failed?5sending?5data?5to?5the?5STDIN@ DB 'Failed send'
	DB	'ing data to the STDIN pipe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NKHKFHLH@GostCrypt?$AA@
CONST	SEGMENT
??_C@_09NKHKFHLH@GostCrypt?$AA@ DB 'GostCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LOGCKKME@T?1C?1I?1N?1S?1C?1R?1C?$AA@
CONST	SEGMENT
??_C@_0BA@LOGCKKME@T?1C?1I?1N?1S?1C?1R?1C?$AA@ DB 'T/C/I/N/S/C/R/C', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MDIFFMMP@gostcrypt?9x64?4sys?$AA@
CONST	SEGMENT
??_C@_0BC@MDIFFMMP@gostcrypt?9x64?4sys?$AA@ DB 'gostcrypt-x64.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IAPAHIFF@gostcrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0O@IAPAHIFF@gostcrypt?4sys?$AA@ DB 'gostcrypt.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MBKAOEOG@GostCrypt?5Format?4exe?$AA@
CONST	SEGMENT
??_C@_0BF@MBKAOEOG@GostCrypt?5Format?4exe?$AA@ DB 'GostCrypt Format.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@
CONST	SEGMENT
??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@ DB 'GostCrypt.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HNDLNFKG@License?4txt?$AA@
CONST	SEGMENT
??_C@_0M@HNDLNFKG@License?4txt?$AA@ DB 'License.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ELFIPPEB@GostCrypt?5User?5Guide?4pdf?$AA@
CONST	SEGMENT
??_C@_0BJ@ELFIPPEB@GostCrypt?5User?5Guide?4pdf?$AA@ DB 'GostCrypt User Gu'
	DB	'ide.pdf', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_szCompressedFiles DD FLAT:??_C@_0BJ@ELFIPPEB@GostCrypt?5User?5Guide?4pdf?$AA@
	DD	FLAT:??_C@_0M@HNDLNFKG@License?4txt?$AA@
	DD	FLAT:??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@
	DD	FLAT:??_C@_0BF@MBKAOEOG@GostCrypt?5Format?4exe?$AA@
	DD	FLAT:??_C@_0O@IAPAHIFF@gostcrypt?4sys?$AA@
	DD	FLAT:??_C@_0BC@MDIFFMMP@gostcrypt?9x64?4sys?$AA@
_DATA	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _FreeAllFileBuffers
_TEXT	SEGMENT
_FreeAllFileBuffers PROC				; COMDAT

; 620  : 	int fileNo;
; 621  : 
; 622  : 	if (DecompressedData != NULL)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _DecompressedData
  00005	85 c0		 test	 eax, eax
  00007	74 13		 je	 SHORT $LN5@FreeAllFil

; 623  : 	{
; 624  : 		free (DecompressedData);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4

; 625  : 		DecompressedData = NULL;

  00012	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DecompressedData, 0
$LN5@FreeAllFil:

; 626  : 	}
; 627  : 
; 628  : 	for (fileNo = 0; fileNo < NBR_COMPRESSED_FILES; fileNo++)
; 629  : 	{
; 630  : 		Decompressed_Files[fileNo].fileName = NULL;

  0001c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files, 0

; 631  : 		Decompressed_Files[fileNo].fileContent = NULL;

  00026	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+16, 0

; 632  : 		Decompressed_Files[fileNo].fileNameLength = 0;

  00030	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+4, 0

; 633  : 		Decompressed_Files[fileNo].fileLength = 0;

  0003a	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+12, 0

; 634  : 		Decompressed_Files[fileNo].crc = 0;

  00044	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+8, 0
  0004e	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+20, 0
  00058	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+36, 0
  00062	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+24, 0
  0006c	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+32, 0
  00076	c7 05 1c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+28, 0
  00080	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+40, 0
  0008a	c7 05 38 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+56, 0
  00094	c7 05 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+44, 0
  0009e	c7 05 34 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+52, 0
  000a8	c7 05 30 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+48, 0
  000b2	c7 05 3c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+60, 0
  000bc	c7 05 4c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+76, 0
  000c6	c7 05 40 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+64, 0
  000d0	c7 05 48 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+72, 0
  000da	c7 05 44 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+68, 0
  000e4	c7 05 50 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+80, 0
  000ee	c7 05 60 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+96, 0
  000f8	c7 05 54 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+84, 0
  00102	c7 05 5c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+92, 0
  0010c	c7 05 58 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+88, 0
  00116	c7 05 64 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+100, 0
  00120	c7 05 74 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+116, 0
  0012a	c7 05 68 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+104, 0
  00134	c7 05 70 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+112, 0
  0013e	c7 05 6c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Decompressed_Files+108, 0

; 635  : 	}
; 636  : }

  00148	c3		 ret	 0
_FreeAllFileBuffers ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _WipeSignatureAreas
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_WipeSignatureAreas PROC				; COMDAT

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 284  : 	// Clear bytes 0x130-0x1ff
; 285  : 	memset (buffer + 0x130, 0, 0x200 - 0x130);

  00003	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00006	68 d0 00 00 00	 push	 208			; 000000d0H
  0000b	05 30 01 00 00	 add	 eax, 304		; 00000130H
  00010	6a 00		 push	 0
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _memset
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 286  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_WipeSignatureAreas ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _CompressBuffer
_TEXT	SEGMENT
_startupInfo$ = -4224					; size = 68
_procInfo$ = -4156					; size = 16
tv151 = -4140						; size = 8
_securityAttrib$ = -4132				; size = 12
_out$GSCopy$1$ = -4120					; size = 4
_bytesReceived$ = -4116					; size = 4
_hChildStdinRead$ = -4112				; size = 4
_hChildStdoutRead$ = -4108				; size = 4
_hChildStdoutWrite$ = -4104				; size = 4
_pipeBuffer$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_len$ = 16						; size = 4
_CompressBuffer PROC					; COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 80 10 00 00	 mov	 eax, 4224		; 00001080H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  0001a	53		 push	 ebx
  0001b	57		 push	 edi

; 191  : 	SECURITY_ATTRIBUTES securityAttrib; 
; 192  : 	DWORD bytesReceived = 0;
; 193  : 	HANDLE hChildStdoutWrite = INVALID_HANDLE_VALUE;
; 194  : 	HANDLE hChildStdoutRead = INVALID_HANDLE_VALUE;
; 195  : 	HANDLE hChildStdinRead = INVALID_HANDLE_VALUE;
; 196  : 	STARTUPINFO startupInfo;
; 197  : 	PROCESS_INFORMATION procInfo; 
; 198  : 	char pipeBuffer [PIPE_BUFFER_LEN]; 
; 199  : 	int res_len = 0;
; 200  : 	BOOL bGzipHeaderRead = FALSE;
; 201  : 
; 202  : 	ZeroMemory (&startupInfo, sizeof (startupInfo));

  0001c	6a 44		 push	 68			; 00000044H
  0001e	89 85 e8 ef ff
	ff		 mov	 DWORD PTR _out$GSCopy$1$[ebp], eax
  00024	33 db		 xor	 ebx, ebx
  00026	8d 85 80 ef ff
	ff		 lea	 eax, DWORD PTR _startupInfo$[ebp]
  0002c	c7 85 ec ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _bytesReceived$[ebp], 0
  00036	53		 push	 ebx
  00037	50		 push	 eax
  00038	c7 85 f8 ef ff
	ff ff ff ff ff	 mov	 DWORD PTR _hChildStdoutWrite$[ebp], -1
  00042	c7 85 f4 ef ff
	ff ff ff ff ff	 mov	 DWORD PTR _hChildStdoutRead$[ebp], -1
  0004c	c7 85 f0 ef ff
	ff ff ff ff ff	 mov	 DWORD PTR _hChildStdinRead$[ebp], -1
  00056	e8 00 00 00 00	 call	 _memset

; 203  : 	ZeroMemory (&procInfo, sizeof (procInfo));
; 204  : 
; 205  : 	// Pipe handle inheritance
; 206  : 	securityAttrib.bInheritHandle = TRUE; 
; 207  : 	securityAttrib.nLength = sizeof (securityAttrib); 
; 208  : 	securityAttrib.lpSecurityDescriptor = NULL; 
; 209  : 
; 210  : 	if (!CreatePipe (&hChildStdoutRead, &hChildStdoutWrite, &securityAttrib, 0))

  0005b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CreatePipe@16
  00061	8d 85 dc ef ff
	ff		 lea	 eax, DWORD PTR _securityAttrib$[ebp]
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	c7 85 e4 ef ff
	ff 01 00 00 00	 mov	 DWORD PTR _securityAttrib$[ebp+8], 1
  00074	0f 57 c0	 xorps	 xmm0, xmm0
  00077	c7 85 dc ef ff
	ff 0c 00 00 00	 mov	 DWORD PTR _securityAttrib$[ebp], 12 ; 0000000cH
  00081	0f 11 85 c4 ef
	ff ff		 movups	 XMMWORD PTR _procInfo$[ebp], xmm0
  00088	89 9d e0 ef ff
	ff		 mov	 DWORD PTR _securityAttrib$[ebp+4], ebx
  0008e	53		 push	 ebx
  0008f	50		 push	 eax
  00090	8d 85 f8 ef ff
	ff		 lea	 eax, DWORD PTR _hChildStdoutWrite$[ebp]
  00096	50		 push	 eax
  00097	8d 85 f4 ef ff
	ff		 lea	 eax, DWORD PTR _hChildStdoutRead$[ebp]
  0009d	50		 push	 eax
  0009e	ff d7		 call	 edi
  000a0	85 c0		 test	 eax, eax
  000a2	75 28		 jne	 SHORT $LN4@CompressBu

; 211  : 	{
; 212  : 		PkgError ("Cannot create STDOUT pipe."); 

  000a4	68 10 00 05 00	 push	 327696			; 00050010H
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CGCLLOGA@Cannot?5create?5STDOUT?5pipe?4?$AA@
  000b3	50		 push	 eax
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  000ba	5f		 pop	 edi

; 213  : 		return 0;

  000bb	33 c0		 xor	 eax, eax
  000bd	5b		 pop	 ebx

; 268  : 	return res_len - 8;	// A gzip stream ends with a CRC-32 hash and a 32-bit size (those 8 bytes need to be chopped off)
; 269  : }

  000be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c1	33 cd		 xor	 ecx, ebp
  000c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN4@CompressBu:
  000cc	56		 push	 esi

; 214  : 	}
; 215  : 	SetHandleInformation (hChildStdoutRead, HANDLE_FLAG_INHERIT, 0);

  000cd	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetHandleInformation@12
  000d3	6a 00		 push	 0
  000d5	6a 01		 push	 1
  000d7	ff b5 f4 ef ff
	ff		 push	 DWORD PTR _hChildStdoutRead$[ebp]
  000dd	ff d6		 call	 esi

; 216  : 
; 217  : 	if (!CreatePipe (&hChildStdinRead, &((HANDLE) hChildStdinWrite), &securityAttrib, 0))

  000df	6a 00		 push	 0
  000e1	8d 85 dc ef ff
	ff		 lea	 eax, DWORD PTR _securityAttrib$[ebp]
  000e7	50		 push	 eax
  000e8	68 00 00 00 00	 push	 OFFSET _hChildStdinWrite
  000ed	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _hChildStdinRead$[ebp]
  000f3	50		 push	 eax
  000f4	ff d7		 call	 edi
  000f6	85 c0		 test	 eax, eax
  000f8	75 29		 jne	 SHORT $LN5@CompressBu

; 218  : 	{
; 219  : 		PkgError ("Cannot create STDIN pipe.");

  000fa	68 10 00 05 00	 push	 327696			; 00050010H
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CBLLHDHE@Cannot?5create?5STDIN?5pipe?4?$AA@
  00109	50		 push	 eax
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00110	5e		 pop	 esi
  00111	5f		 pop	 edi

; 220  : 		return 0;

  00112	33 c0		 xor	 eax, eax
  00114	5b		 pop	 ebx

; 268  : 	return res_len - 8;	// A gzip stream ends with a CRC-32 hash and a 32-bit size (those 8 bytes need to be chopped off)
; 269  : }

  00115	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00118	33 cd		 xor	 ecx, ebp
  0011a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN5@CompressBu:

; 221  : 	}
; 222  : 	SetHandleInformation (hChildStdinWrite, HANDLE_FLAG_INHERIT, 0);

  00123	a1 00 00 00 00	 mov	 eax, DWORD PTR _hChildStdinWrite
  00128	6a 00		 push	 0
  0012a	6a 01		 push	 1
  0012c	50		 push	 eax
  0012d	ff d6		 call	 esi

; 223  : 
; 224  : 	// Create a child process that will compress the data
; 225  : 
; 226  : 	startupInfo.wShowWindow = SW_HIDE;

  0012f	33 c0		 xor	 eax, eax

; 227  : 	startupInfo.hStdInput = hChildStdinRead;
; 228  : 	startupInfo.hStdOutput = hChildStdoutWrite;
; 229  : 	startupInfo.cb = sizeof (startupInfo); 
; 230  : 	startupInfo.hStdError = hChildStdoutWrite;
; 231  : 	startupInfo.dwFlags |= STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;

  00131	81 8d ac ef ff
	ff 01 01 00 00	 or	 DWORD PTR _startupInfo$[ebp+44], 257 ; 00000101H
  0013b	66 89 85 b0 ef
	ff ff		 mov	 WORD PTR _startupInfo$[ebp+48], ax
  00142	8b 85 f0 ef ff
	ff		 mov	 eax, DWORD PTR _hChildStdinRead$[ebp]
  00148	89 85 b8 ef ff
	ff		 mov	 DWORD PTR _startupInfo$[ebp+56], eax
  0014e	8b 85 f8 ef ff
	ff		 mov	 eax, DWORD PTR _hChildStdoutWrite$[ebp]
  00154	89 85 bc ef ff
	ff		 mov	 DWORD PTR _startupInfo$[ebp+60], eax
  0015a	89 85 c0 ef ff
	ff		 mov	 DWORD PTR _startupInfo$[ebp+64], eax

; 232  : 
; 233  : 	if (!CreateProcess (NULL, "gzip --best", NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &procInfo))

  00160	8d 85 c4 ef ff
	ff		 lea	 eax, DWORD PTR _procInfo$[ebp]
  00166	50		 push	 eax
  00167	8d 85 80 ef ff
	ff		 lea	 eax, DWORD PTR _startupInfo$[ebp]
  0016d	c7 85 80 ef ff
	ff 44 00 00 00	 mov	 DWORD PTR _startupInfo$[ebp], 68 ; 00000044H
  00177	50		 push	 eax
  00178	6a 00		 push	 0
  0017a	6a 00		 push	 0
  0017c	6a 00		 push	 0
  0017e	6a 01		 push	 1
  00180	6a 00		 push	 0
  00182	6a 00		 push	 0
  00184	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HPMDPAK@gzip?5?9?9best?$AA@
  00189	6a 00		 push	 0
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40
  00191	85 c0		 test	 eax, eax
  00193	75 29		 jne	 SHORT $LN6@CompressBu

; 234  : 	{
; 235  : 		PkgError ("Error: Cannot run gzip.\n\nBefore you can create a self-extracting GostCrypt package, you need to have the open-source 'gzip' compression tool placed in any directory in the search path for executable files (for example, in 'C:\\Windows\\').\n\nNote: gzip can be freely downloaded e.g. from www.gzip.org");

  00195	68 10 00 05 00	 push	 327696			; 00050010H
  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0BCK@ECOEIKIB@Error?3?5Cannot?5run?5gzip?4?6?6Before?5@
  001a4	50		 push	 eax
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  001ab	5e		 pop	 esi
  001ac	5f		 pop	 edi

; 236  : 		return 0;

  001ad	33 c0		 xor	 eax, eax
  001af	5b		 pop	 ebx

; 268  : 	return res_len - 8;	// A gzip stream ends with a CRC-32 hash and a 32-bit size (those 8 bytes need to be chopped off)
; 269  : }

  001b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b3	33 cd		 xor	 ecx, ebp
  001b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ba	8b e5		 mov	 esp, ebp
  001bc	5d		 pop	 ebp
  001bd	c3		 ret	 0
$LN6@CompressBu:

; 237  : 	}
; 238  : 
; 239  : 	CloseHandle (procInfo.hProcess);

  001be	ff b5 c4 ef ff
	ff		 push	 DWORD PTR _procInfo$[ebp]
  001c4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  001ca	ff d6		 call	 esi

; 240  : 	CloseHandle (procInfo.hThread);

  001cc	ff b5 c8 ef ff
	ff		 push	 DWORD PTR _procInfo$[ebp+4]
  001d2	ff d6		 call	 esi

; 241  : 
; 242  : 	// Start sending the uncompressed data to the pipe (STDIN)
; 243  : 	PipeWriteBuf = in;

  001d4	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  001d7	a3 00 00 00 00	 mov	 DWORD PTR _PipeWriteBuf, eax

; 244  : 	_beginthread (PipeWriteThread, PIPE_BUFFER_LEN * 2, (void *) &len);

  001dc	8d 45 10	 lea	 eax, DWORD PTR _len$[ebp]
  001df	50		 push	 eax
  001e0	68 00 20 00 00	 push	 8192			; 00002000H
  001e5	68 00 00 00 00	 push	 OFFSET _PipeWriteThread
  001ea	e8 00 00 00 00	 call	 __beginthread
  001ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 245  : 
; 246  : 	if (!CloseHandle (hChildStdoutWrite))

  001f2	ff b5 f8 ef ff
	ff		 push	 DWORD PTR _hChildStdoutWrite$[ebp]
  001f8	ff d6		 call	 esi
  001fa	85 c0		 test	 eax, eax
  001fc	75 29		 jne	 SHORT $LN7@CompressBu

; 247  : 	{
; 248  : 		PkgError ("Cannot close STDOUT write"); 

  001fe	68 10 00 05 00	 push	 327696			; 00050010H
  00203	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  00208	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@NGGPKPLC@Cannot?5close?5STDOUT?5write?$AA@
  0020d	50		 push	 eax
  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00214	5e		 pop	 esi
  00215	5f		 pop	 edi

; 249  : 		return 0;

  00216	33 c0		 xor	 eax, eax
  00218	5b		 pop	 ebx

; 268  : 	return res_len - 8;	// A gzip stream ends with a CRC-32 hash and a 32-bit size (those 8 bytes need to be chopped off)
; 269  : }

  00219	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021c	33 cd		 xor	 ecx, ebp
  0021e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00223	8b e5		 mov	 esp, ebp
  00225	5d		 pop	 ebp
  00226	c3		 ret	 0
$LN7@CompressBu:

; 250  : 	}
; 251  : 
; 252  : 	bGzipHeaderRead = FALSE;

  00227	33 ff		 xor	 edi, edi
  00229	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@CompressBu:

; 253  : 
; 254  : 	// Read the compressed data from the pipe (sent by the child process to STDOUT)
; 255  : 	while (TRUE) 
; 256  : 	{ 
; 257  : 		if (!ReadFile (hChildStdoutRead, pipeBuffer, bGzipHeaderRead ? PIPE_BUFFER_LEN : 10, &bytesReceived, NULL)) 

  00230	c7 85 d8 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR tv151[ebp+4], 0
  0023a	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  0023f	85 ff		 test	 edi, edi
  00241	75 05		 jne	 SHORT $LN13@CompressBu
  00243	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
$LN13@CompressBu:
  00248	6a 00		 push	 0
  0024a	8d 8d ec ef ff
	ff		 lea	 ecx, DWORD PTR _bytesReceived$[ebp]
  00250	51		 push	 ecx
  00251	50		 push	 eax
  00252	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _pipeBuffer$[ebp]
  00258	50		 push	 eax
  00259	ff b5 f4 ef ff
	ff		 push	 DWORD PTR _hChildStdoutRead$[ebp]
  0025f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00265	85 c0		 test	 eax, eax
  00267	74 2e		 je	 SHORT $LN24@CompressBu

; 258  : 			break; 
; 259  : 
; 260  : 		if (bGzipHeaderRead)

  00269	85 ff		 test	 edi, edi
  0026b	74 23		 je	 SHORT $LN9@CompressBu

; 261  : 		{
; 262  : 			memcpy (out + res_len, pipeBuffer, bytesReceived);

  0026d	8b b5 ec ef ff
	ff		 mov	 esi, DWORD PTR _bytesReceived$[ebp]
  00273	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _pipeBuffer$[ebp]
  00279	56		 push	 esi
  0027a	50		 push	 eax
  0027b	8b 85 e8 ef ff
	ff		 mov	 eax, DWORD PTR _out$GSCopy$1$[ebp]
  00281	03 c3		 add	 eax, ebx
  00283	50		 push	 eax
  00284	e8 00 00 00 00	 call	 _memcpy
  00289	83 c4 0c	 add	 esp, 12			; 0000000cH

; 263  : 			res_len += bytesReceived;

  0028c	03 de		 add	 ebx, esi

; 264  : 		}

  0028e	eb a0		 jmp	 SHORT $LL2@CompressBu
$LN9@CompressBu:

; 265  : 		else
; 266  : 			bGzipHeaderRead = TRUE;	// Skip the 10-byte gzip header

  00290	bf 01 00 00 00	 mov	 edi, 1

; 267  : 	} 

  00295	eb 99		 jmp	 SHORT $LL2@CompressBu
$LN24@CompressBu:

; 268  : 	return res_len - 8;	// A gzip stream ends with a CRC-32 hash and a 32-bit size (those 8 bytes need to be chopped off)
; 269  : }

  00297	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029a	8d 43 f8	 lea	 eax, DWORD PTR [ebx-8]
  0029d	5e		 pop	 esi
  0029e	5f		 pop	 edi
  0029f	33 cd		 xor	 ecx, ebp
  002a1	5b		 pop	 ebx
  002a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a7	8b e5		 mov	 esp, ebp
  002a9	5d		 pop	 ebp
  002aa	c3		 ret	 0
_CompressBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _PipeWriteThread
_TEXT	SEGMENT
_bytesSent$ = -4					; size = 4
_len$ = 8						; size = 4
_PipeWriteThread PROC					; COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 142  : 	int sendBufSize = PIPE_BUFFER_LEN, bytesSent = 0;
; 143  : 	int bytesToSend = *((int *) len), bytesSentTotal = 0;

  00006	8b 75 08	 mov	 esi, DWORD PTR _len$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	57		 push	 edi
  0000c	bf 00 10 00 00	 mov	 edi, 4096		; 00001000H
  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bytesSent$[ebp], 0
  00018	8b 36		 mov	 esi, DWORD PTR [esi]

; 144  : 
; 145  : 	if (PipeWriteBuf == NULL || (HANDLE) hChildStdinWrite == INVALID_HANDLE_VALUE)

  0001a	39 1d 00 00 00
	00		 cmp	 DWORD PTR _PipeWriteBuf, ebx
  00020	74 76		 je	 SHORT $LN5@PipeWriteT
  00022	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _hChildStdinWrite, -1
  00029	74 6d		 je	 SHORT $LN5@PipeWriteT

; 148  : 		return;
; 149  : 	}
; 150  : 
; 151  : 	while (bytesToSend > 0) 

  0002b	85 f6		 test	 esi, esi
  0002d	7e 3c		 jle	 SHORT $LN3@PipeWriteT
  0002f	90		 npad	 1
$LL2@PipeWriteT:

; 152  : 	{ 
; 153  : 		if (bytesToSend < PIPE_BUFFER_LEN)
; 154  : 			sendBufSize = bytesToSend;
; 155  : 
; 156  : 		if (!WriteFile ((HANDLE) hChildStdinWrite, (char *) PipeWriteBuf + bytesSentTotal, sendBufSize, &bytesSent, NULL) 
; 157  : 			|| bytesSent == 0
; 158  : 			|| bytesSent != sendBufSize) 

  00030	6a 00		 push	 0
  00032	8d 45 fc	 lea	 eax, DWORD PTR _bytesSent$[ebp]
  00035	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  0003b	50		 push	 eax
  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR _PipeWriteBuf
  00041	0f 4c fe	 cmovl	 edi, esi
  00044	57		 push	 edi
  00045	03 c3		 add	 eax, ebx
  00047	50		 push	 eax
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _hChildStdinWrite
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00054	85 c0		 test	 eax, eax
  00056	74 40		 je	 SHORT $LN5@PipeWriteT
  00058	8b 45 fc	 mov	 eax, DWORD PTR _bytesSent$[ebp]
  0005b	85 c0		 test	 eax, eax
  0005d	74 39		 je	 SHORT $LN5@PipeWriteT
  0005f	3b c7		 cmp	 eax, edi
  00061	75 35		 jne	 SHORT $LN5@PipeWriteT

; 159  : 		{
; 160  : 			PkgError ("Failed sending data to the STDIN pipe"); 
; 161  : 			return;
; 162  : 		}
; 163  : 
; 164  : 		bytesToSend -= bytesSent;

  00063	2b f0		 sub	 esi, eax

; 165  : 		bytesSentTotal += bytesSent;

  00065	03 d8		 add	 ebx, eax
  00067	85 f6		 test	 esi, esi
  00069	7f c5		 jg	 SHORT $LL2@PipeWriteT
$LN3@PipeWriteT:

; 166  : 	}
; 167  : 
; 168  : 	// Closing the pipe causes the child process to stop reading from it
; 169  : 
; 170  : 	if (!CloseHandle (hChildStdinWrite))

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hChildStdinWrite
  00070	50		 push	 eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00077	85 c0		 test	 eax, eax
  00079	75 34		 jne	 SHORT $LN9@PipeWriteT

; 171  : 	{
; 172  : 		PkgError ("Cannot close pipe"); 

  0007b	68 10 00 05 00	 push	 327696			; 00050010H
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@LMFKNEDD@Cannot?5close?5pipe?$AA@
  0008a	50		 push	 eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx

; 173  : 		return;
; 174  : 	}
; 175  : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
$LN5@PipeWriteT:

; 146  : 	{
; 147  : 		PkgError ("Failed sending data to the STDIN pipe"); 

  00098	68 10 00 05 00	 push	 327696			; 00050010H
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GGPNKNGJ@Failed?5sending?5data?5to?5the?5STDIN@
  000a7	6a 00		 push	 0
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN9@PipeWriteT:
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx

; 173  : 		return;
; 174  : 	}
; 175  : }

  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_PipeWriteThread ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _DecompressBuffer
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_len$ = 16						; size = 4
_DecompressBuffer PROC					; COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  : }

  00003	5d		 pop	 ebp

; 136  : 	return (DecompressDeflatedData (out, in, len));		// Inflate

  00004	e9 00 00 00 00	 jmp	 _DecompressDeflatedData
_DecompressBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _PkgInfo
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_PkgInfo PROC						; COMDAT

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 119  : 	MessageBox (NULL, msg, "GostCrypt", MB_ICONINFORMATION | MB_SETFOREGROUND | MB_TOPMOST);

  00003	68 40 00 05 00	 push	 327744			; 00050040H
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  0000d	ff 75 08	 push	 DWORD PTR _msg$[ebp]
  00010	6a 00		 push	 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 120  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_PkgInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _PkgError
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_PkgError PROC						; COMDAT

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   : 	MessageBox (NULL, msg, "GostCrypt", MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);

  00003	68 10 00 05 00	 push	 327696			; 00050010H
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  0000d	ff 75 08	 push	 DWORD PTR _msg$[ebp]
  00010	6a 00		 push	 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 92   : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_PkgError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _DeobfuscateMagEndMarker
_TEXT	SEGMENT
_DeobfuscateMagEndMarker PROC				; COMDAT

; 72   : 	int i;
; 73   : 
; 74   : 	for (i = 0; i < sizeof (MAG_END_MARKER_OBFUSCATED); i += 2)

  00000	33 c0		 xor	 eax, eax
$LL4@Deobfuscat:

; 75   : 		MagEndMarker [i/2] = MAG_END_MARKER_OBFUSCATED [i];

  00002	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ??_C@_0BA@LOGCKKME@T?1C?1I?1N?1S?1C?1R?1C?$AA@[eax]
  00008	8b d0		 mov	 edx, eax
  0000a	d1 ea		 shr	 edx, 1
  0000c	83 c0 02	 add	 eax, 2
  0000f	88 8a 00 00 00
	00		 mov	 BYTE PTR _MagEndMarker[edx], cl
  00015	83 f8 10	 cmp	 eax, 16			; 00000010H
  00018	72 e8		 jb	 SHORT $LL4@Deobfuscat

; 76   : 
; 77   : 	MagEndMarker [i/2] = 0;

  0001a	99		 cdq
  0001b	2b c2		 sub	 eax, edx
  0001d	d1 f8		 sar	 eax, 1
  0001f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00022	73 08		 jae	 SHORT $LN6@Deobfuscat
  00024	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _MagEndMarker[eax], 0

; 78   : }

  0002b	c3		 ret	 0
$LN6@Deobfuscat:

; 76   : 
; 77   : 	MagEndMarker [i/2] = 0;

  0002c	e9 00 00 00 00	 jmp	 ___report_rangecheckfailure
_DeobfuscateMagEndMarker ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _IsSelfExtractingPackage
_TEXT	SEGMENT
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_IsSelfExtractingPackage PROC				; COMDAT

; 602  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 603  : 	char path [GST_MAX_PATH];
; 604  : 
; 605  : 	GetModuleFileName (NULL, path, sizeof (path));

  00013	68 04 01 00 00	 push	 260			; 00000104H
  00018	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  0001e	50		 push	 eax
  0001f	6a 00		 push	 0
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 606  : 
; 607  : 	return (FindStringInFile (path, MagEndMarker, strlen (MagEndMarker)) != -1);

  00027	b8 00 00 00 00	 mov	 eax, OFFSET _MagEndMarker
  0002c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0002f	90		 npad	 1
$LL5@IsSelfExtr:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL5@IsSelfExtr
  00037	2b c2		 sub	 eax, edx
  00039	50		 push	 eax
  0003a	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00040	68 00 00 00 00	 push	 OFFSET _MagEndMarker
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _FindStringInFile
  0004b	23 c2		 and	 eax, edx
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	83 f8 ff	 cmp	 eax, -1
  00053	74 13		 je	 SHORT $LN3@IsSelfExtr
  00055	b8 01 00 00 00	 mov	 eax, 1

; 608  : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
$LN3@IsSelfExtr:
  00068	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006b	33 c0		 xor	 eax, eax
  0006d	33 cd		 xor	 ecx, ebp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_IsSelfExtractingPackage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _VerifyPackageIntegrity
_TEXT	SEGMENT
_tmpFileSize$ = -272					; size = 4
_crc$ = -268						; size = 4
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_VerifyPackageIntegrity PROC				; COMDAT

; 535  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 536  : 	int fileDataEndPos = 0;
; 537  : 	int fileDataStartPos = 0;
; 538  : 	unsigned __int32 crc = 0;
; 539  : 	unsigned char *tmpBuffer;
; 540  : 	int tmpFileSize;
; 541  : 	char path [GST_MAX_PATH];
; 542  : 
; 543  : 	GetModuleFileName (NULL, path, sizeof (path));

  00013	68 04 01 00 00	 push	 260			; 00000104H
  00018	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  0001e	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _crc$[ebp], 0
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 544  : 
; 545  : 	fileDataEndPos = (int) FindStringInFile (path, MagEndMarker, strlen (MagEndMarker));

  00031	b9 00 00 00 00	 mov	 ecx, OFFSET _MagEndMarker
  00036	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@VerifyPack:
  00040	8a 01		 mov	 al, BYTE PTR [ecx]
  00042	41		 inc	 ecx
  00043	84 c0		 test	 al, al
  00045	75 f9		 jne	 SHORT $LL10@VerifyPack
  00047	57		 push	 edi
  00048	2b ca		 sub	 ecx, edx
  0004a	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00050	51		 push	 ecx
  00051	68 00 00 00 00	 push	 OFFSET _MagEndMarker
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _FindStringInFile
  0005c	8b f8		 mov	 edi, eax
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 546  : 	if (fileDataEndPos < 0)

  00061	85 ff		 test	 edi, edi
  00063	79 1e		 jns	 SHORT $LN2@VerifyPack
$LN14@VerifyPack:

; 547  : 	{
; 548  : 		Error ("DIST_PACKAGE_CORRUPTED");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@
  0006a	e8 00 00 00 00	 call	 _Error
  0006f	83 c4 04	 add	 esp, 4

; 549  : 		return FALSE;

  00072	33 c0		 xor	 eax, eax
  00074	5f		 pop	 edi

; 588  : 
; 589  : 	return TRUE;
; 590  : }

  00075	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00078	33 cd		 xor	 ecx, ebp
  0007a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
$LN2@VerifyPack:

; 550  : 	}
; 551  : 	fileDataEndPos--;
; 552  : 
; 553  : 	fileDataStartPos = (int) FindStringInFile (path, MAG_START_MARKER, strlen (MAG_START_MARKER));

  00083	6a 09		 push	 9
  00085	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_09JEFCBPAJ@GSTINSTRT?$AA@
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _FindStringInFile
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 554  : 	if (fileDataStartPos < 0)

  00099	85 c0		 test	 eax, eax
  0009b	78 c8		 js	 SHORT $LN14@VerifyPack

; 555  : 	{
; 556  : 		Error ("DIST_PACKAGE_CORRUPTED");
; 557  : 		return FALSE;
; 558  : 	}
; 559  : 	fileDataStartPos += strlen (MAG_START_MARKER);
; 560  : 
; 561  : 
; 562  : 	if (!LoadInt32 (path, &crc, fileDataEndPos + strlen (MagEndMarker) + 1))

  0009d	b9 00 00 00 00	 mov	 ecx, OFFSET _MagEndMarker
  000a2	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL11@VerifyPack:
  000a5	8a 01		 mov	 al, BYTE PTR [ecx]
  000a7	41		 inc	 ecx
  000a8	84 c0		 test	 al, al
  000aa	75 f9		 jne	 SHORT $LL11@VerifyPack
  000ac	2b ca		 sub	 ecx, edx
  000ae	6a 00		 push	 0
  000b0	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  000b3	50		 push	 eax
  000b4	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _crc$[ebp]
  000ba	50		 push	 eax
  000bb	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _LoadInt32
  000c7	83 c4 10	 add	 esp, 16			; 00000010H
  000ca	85 c0		 test	 eax, eax
  000cc	75 1e		 jne	 SHORT $LN4@VerifyPack

; 563  : 	{
; 564  : 		Error ("CANT_VERIFY_PACKAGE_INTEGRITY");

  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FDGMLBCO@CANT_VERIFY_PACKAGE_INTEGRITY?$AA@
  000d3	e8 00 00 00 00	 call	 _Error
  000d8	83 c4 04	 add	 esp, 4

; 565  : 		return FALSE;

  000db	33 c0		 xor	 eax, eax
  000dd	5f		 pop	 edi

; 588  : 
; 589  : 	return TRUE;
; 590  : }

  000de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	33 cd		 xor	 ecx, ebp
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
$LN4@VerifyPack:
  000ec	56		 push	 esi

; 566  : 	}
; 567  : 
; 568  : 	// Compute the CRC-32 hash of the whole file (except the digital signature area, if present)
; 569  : 	tmpBuffer = LoadFile (path, &tmpFileSize);

  000ed	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _tmpFileSize$[ebp]
  000f3	50		 push	 eax
  000f4	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _LoadFile
  00100	8b f0		 mov	 esi, eax
  00102	83 c4 08	 add	 esp, 8

; 570  : 
; 571  : 	if (tmpBuffer == NULL)

  00105	85 f6		 test	 esi, esi
  00107	75 1f		 jne	 SHORT $LN5@VerifyPack

; 572  : 	{
; 573  : 		Error ("CANT_VERIFY_PACKAGE_INTEGRITY");

  00109	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FDGMLBCO@CANT_VERIFY_PACKAGE_INTEGRITY?$AA@
  0010e	e8 00 00 00 00	 call	 _Error
  00113	83 c4 04	 add	 esp, 4

; 574  : 		return FALSE;

  00116	33 c0		 xor	 eax, eax
  00118	5e		 pop	 esi
  00119	5f		 pop	 edi

; 588  : 
; 589  : 	return TRUE;
; 590  : }

  0011a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011d	33 cd		 xor	 ecx, ebp
  0011f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
$LN5@VerifyPack:

; 575  : 	}
; 576  : 
; 577  : 	// Zero all bytes that change when an exe is digitally signed (except appended blocks).
; 578  : 	WipeSignatureAreas (tmpBuffer);

  00128	68 d0 00 00 00	 push	 208			; 000000d0H
  0012d	8d 86 30 01 00
	00		 lea	 eax, DWORD PTR [esi+304]
  00133	6a 00		 push	 0
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _memset

; 579  : 
; 580  : 	if (crc != GetCrc32 (tmpBuffer, fileDataEndPos + 1 + strlen (MagEndMarker)))

  0013b	b9 00 00 00 00	 mov	 ecx, OFFSET _MagEndMarker
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH
  00143	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL12@VerifyPack:
  00146	8a 01		 mov	 al, BYTE PTR [ecx]
  00148	41		 inc	 ecx
  00149	84 c0		 test	 al, al
  0014b	75 f9		 jne	 SHORT $LL12@VerifyPack
  0014d	2b ca		 sub	 ecx, edx
  0014f	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00152	50		 push	 eax
  00153	56		 push	 esi
  00154	e8 00 00 00 00	 call	 _GetCrc32
  00159	83 c4 08	 add	 esp, 8

; 581  : 	{
; 582  : 		free (tmpBuffer);

  0015c	56		 push	 esi
  0015d	39 85 f4 fe ff
	ff		 cmp	 DWORD PTR _crc$[ebp], eax
  00163	74 24		 je	 SHORT $LN6@VerifyPack
  00165	e8 00 00 00 00	 call	 _free

; 583  : 		Error ("DIST_PACKAGE_CORRUPTED");

  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@
  0016f	e8 00 00 00 00	 call	 _Error
  00174	83 c4 08	 add	 esp, 8

; 584  : 		return FALSE;

  00177	33 c0		 xor	 eax, eax
  00179	5e		 pop	 esi
  0017a	5f		 pop	 edi

; 588  : 
; 589  : 	return TRUE;
; 590  : }

  0017b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017e	33 cd		 xor	 ecx, ebp
  00180	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
$LN6@VerifyPack:

; 585  : 	}
; 586  : 
; 587  : 	free (tmpBuffer);

  00189	e8 00 00 00 00	 call	 _free

; 588  : 
; 589  : 	return TRUE;
; 590  : }

  0018e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00191	83 c4 04	 add	 esp, 4
  00194	33 cd		 xor	 ecx, ebp
  00196	b8 01 00 00 00	 mov	 eax, 1
  0019b	5e		 pop	 esi
  0019c	5f		 pop	 edi
  0019d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
_VerifyPackageIntegrity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _MakeSelfExtractingPackage
_TEXT	SEGMENT
_hwndDlg$GSCopy$1$ = -3860				; size = 4
_szDestDir$GSCopy$1$ = -3856				; size = 4
tv406 = -3852						; size = 4
_buffer$1$ = -3848					; size = 4
_szTmp32bit$ = -3844					; size = 4
_tmpFileSize$1 = -3836					; size = 4
_tmpFileSize$2 = -3836					; size = 4
_tmpStr$ = -3832					; size = 2048
_tmpstr$3 = -1784					; size = 1000
_tmpstr$4 = -1784					; size = 1000
_inputFile$ = -784					; size = 260
_szTmpFilePath$ = -524					; size = 260
_outputFile$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_MakeSelfExtractingPackage PROC				; COMDAT

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 0f 00
	00		 sub	 esp, 3860		; 00000f14H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _szDestDir$[ebp]

; 300  : 	int i, x;
; 301  : 	unsigned char inputFile [GST_MAX_PATH];
; 302  : 	unsigned char outputFile [GST_MAX_PATH];
; 303  : 	unsigned char szTmpFilePath [GST_MAX_PATH];
; 304  : 	unsigned char szTmp32bit [4] = {0};

  00017	33 c0		 xor	 eax, eax

; 305  : 	unsigned char *szTmp32bitPtr = szTmp32bit;
; 306  : 	unsigned char *buffer = NULL, *compressedBuffer = NULL;
; 307  : 	unsigned char *bufIndex = NULL;
; 308  : 	char tmpStr [2048];
; 309  : 	int bufLen = 0, compressedDataLen = 0, uncompressedDataLen = 0;
; 310  : 
; 311  : 	x = strlen (szDestDir);

  00019	8b cb		 mov	 ecx, ebx
  0001b	89 9d f0 f0 ff
	ff		 mov	 DWORD PTR _szDestDir$GSCopy$1$[ebp], ebx
  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]
  00025	57		 push	 edi
  00026	89 b5 ec f0 ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], esi
  0002c	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0002f	c6 85 fc f0 ff
	ff 00		 mov	 BYTE PTR _szTmp32bit$[ebp], 0
  00036	66 89 85 fd f0
	ff ff		 mov	 WORD PTR _szTmp32bit$[ebp+1], ax
  0003d	88 85 ff f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp+3], al
$LL64@MakeSelfEx:
  00043	8a 01		 mov	 al, BYTE PTR [ecx]
  00045	41		 inc	 ecx
  00046	84 c0		 test	 al, al
  00048	75 f9		 jne	 SHORT $LL64@MakeSelfEx
  0004a	2b ca		 sub	 ecx, edx

; 312  : 	if (x < 2)

  0004c	83 f9 02	 cmp	 ecx, 2
  0004f	0f 8c 08 07 00
	00		 jl	 $LN24@MakeSelfEx

; 313  : 		goto err;
; 314  : 
; 315  : 	if (szDestDir[x - 1] != '\\')

  00055	80 7c 0b ff 5c	 cmp	 BYTE PTR [ebx+ecx-1], 92 ; 0000005cH
  0005a	74 17		 je	 SHORT $LN9@MakeSelfEx

; 316  : 		strcat (szDestDir, "\\");

  0005c	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
  0005f	90		 npad	 1
$LL65@MakeSelfEx:
  00060	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00063	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00066	84 c0		 test	 al, al
  00068	75 f6		 jne	 SHORT $LL65@MakeSelfEx
  0006a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  00070	66 89 07	 mov	 WORD PTR [edi], ax
$LN9@MakeSelfEx:

; 317  : 
; 318  : 	GetModuleFileName (NULL, inputFile, sizeof (inputFile));

  00073	68 04 01 00 00	 push	 260			; 00000104H
  00078	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _inputFile$[ebp]
  0007e	50		 push	 eax
  0007f	6a 00		 push	 0
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 319  : 
; 320  : 	strcpy (outputFile, szDestDir);

  00087	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _outputFile$[ebp]
  0008d	8b cb		 mov	 ecx, ebx
  0008f	2b d3		 sub	 edx, ebx
$LL26@MakeSelfEx:
  00091	8a 01		 mov	 al, BYTE PTR [ecx]
  00093	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00096	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  0009a	84 c0		 test	 al, al
  0009c	75 f3		 jne	 SHORT $LL26@MakeSelfEx

; 321  : 	strncat (outputFile, OutputPackageFile, sizeof (outputFile) - strlen (outputFile) - 1);

  0009e	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _outputFile$[ebp]
  000a4	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL66@MakeSelfEx:
  000a7	8a 01		 mov	 al, BYTE PTR [ecx]
  000a9	41		 inc	 ecx
  000aa	84 c0		 test	 al, al
  000ac	75 f9		 jne	 SHORT $LL66@MakeSelfEx
  000ae	2b ca		 sub	 ecx, edx
  000b0	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  000b5	2b c1		 sub	 eax, ecx
  000b7	50		 push	 eax
  000b8	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@KDKMAE@GostCrypt?5Setup?51?43?41?4exe?$AA@
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _strncat

; 322  : 
; 323  : 	// Clone 'GostCrypt Setup.exe' to create the base of the new self-extracting archive
; 324  : 
; 325  : 	if (!GSTCopyFile (inputFile, outputFile))

  000c9	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  000cf	50		 push	 eax
  000d0	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _inputFile$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _GSTCopyFile
  000dc	83 c4 14	 add	 esp, 20			; 00000014H
  000df	85 c0		 test	 eax, eax
  000e1	75 1d		 jne	 SHORT $LN10@MakeSelfEx

; 326  : 	{
; 327  : 		handleWin32Error (hwndDlg);

  000e3	56		 push	 esi
  000e4	e8 00 00 00 00	 call	 _handleWin32Error
  000e9	83 c4 04	 add	 esp, 4

; 328  : 		PkgError ("Cannot copy 'GostCrypt Setup.exe' to the package");

  000ec	68 10 00 05 00	 push	 327696			; 00050010H
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HAEGGKEK@Cannot?5copy?5?8GostCrypt?5Setup?4exe@

; 329  : 		goto err;

  000fb	e9 55 06 00 00	 jmp	 $LN73@MakeSelfEx
$LN10@MakeSelfEx:

; 330  : 	}
; 331  : 
; 332  : 	// Determine the buffer size needed for all the files and meta data and check if all required files exist
; 333  : 
; 334  : 	bufLen = 0;

  00100	33 ff		 xor	 edi, edi

; 335  : 
; 336  : 	for (i = 0; i < sizeof (szCompressedFiles) / sizeof (szCompressedFiles[0]); i++)

  00102	33 f6		 xor	 esi, esi
  00104	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@MakeSelfEx:

; 337  : 	{
; 338  : 		_snprintf (szTmpFilePath, sizeof(szTmpFilePath), "%s%s", szDestDir, szCompressedFiles[i]);

  00110	ff b6 00 00 00
	00		 push	 DWORD PTR _szCompressedFiles[esi]
  00116	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmpFilePath$[ebp]
  0011c	53		 push	 ebx
  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00122	68 04 01 00 00	 push	 260			; 00000104H
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 __snprintf

; 339  : 
; 340  : 		if (!FileExists (szTmpFilePath))

  0012d	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmpFilePath$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _FileExists
  00139	83 c4 18	 add	 esp, 24			; 00000018H
  0013c	85 c0		 test	 eax, eax

; 347  : 			goto err;
; 348  : 		}
; 349  : 
; 350  : 		bufLen += (int) GetFileSize64 (szTmpFilePath);

  0013e	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmpFilePath$[ebp]
  00144	50		 push	 eax
  00145	0f 84 d4 05 00
	00		 je	 $LN54@MakeSelfEx
  0014b	e8 00 00 00 00	 call	 _GetFileSize64

; 351  : 
; 352  : 		bufLen += 2;					// 16-bit filename length
; 353  : 		bufLen += strlen(szCompressedFiles[i]);	// Filename

  00150	8b 8e 00 00 00
	00		 mov	 ecx, DWORD PTR _szCompressedFiles[esi]
  00156	83 c4 04	 add	 esp, 4
  00159	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  0015c	03 d7		 add	 edx, edi
  0015e	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL67@MakeSelfEx:
  00161	8a 01		 mov	 al, BYTE PTR [ecx]
  00163	41		 inc	 ecx
  00164	84 c0		 test	 al, al
  00166	75 f9		 jne	 SHORT $LL67@MakeSelfEx
  00168	2b cf		 sub	 ecx, edi
  0016a	83 c6 04	 add	 esi, 4

; 354  : 		bufLen += 4;					// CRC-32
; 355  : 		bufLen += 4;					// 32-bit file length

  0016d	8d 7a 08	 lea	 edi, DWORD PTR [edx+8]
  00170	03 f9		 add	 edi, ecx
  00172	83 fe 18	 cmp	 esi, 24			; 00000018H
  00175	72 99		 jb	 SHORT $LL4@MakeSelfEx

; 356  : 	}
; 357  : 
; 358  : 	buffer = malloc (bufLen + 524288);	// + 512K reserve 

  00177	8d 87 00 00 08
	00		 lea	 eax, DWORD PTR [edi+524288]
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _malloc
  00183	83 c4 04	 add	 esp, 4
  00186	89 85 f8 f0 ff
	ff		 mov	 DWORD PTR _buffer$1$[ebp], eax

; 359  : 	if (buffer == NULL)

  0018c	85 c0		 test	 eax, eax
  0018e	75 38		 jne	 SHORT $LN12@MakeSelfEx

; 360  : 	{
; 361  : 		PkgError ("Cannot allocate memory for uncompressed data");

  00190	68 10 00 05 00	 push	 327696			; 00050010H
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@MELKNJCC@Cannot?5allocate?5memory?5for?5uncom@
  0019f	50		 push	 eax
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 362  : 		remove (outputFile);

  001a6	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  001ac	50		 push	 eax
  001ad	e8 00 00 00 00	 call	 _remove
  001b2	83 c4 04	 add	 esp, 4

; 521  : 
; 522  : 	return FALSE;

  001b5	33 c0		 xor	 eax, eax
  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx

; 523  : }

  001ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bd	33 cd		 xor	 ecx, ebp
  001bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$LN12@MakeSelfEx:

; 363  : 		goto err;
; 364  : 	}
; 365  : 
; 366  : 
; 367  : 	// Write the start marker
; 368  : 	if (!SaveBufferToFile (MAG_START_MARKER, outputFile, strlen (MAG_START_MARKER), TRUE))

  001c8	6a 01		 push	 1
  001ca	6a 09		 push	 9
  001cc	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  001d2	50		 push	 eax
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_09JEFCBPAJ@GSTINSTRT?$AA@
  001d8	e8 00 00 00 00	 call	 _SaveBufferToFile
  001dd	83 c4 10	 add	 esp, 16			; 00000010H
  001e0	85 c0		 test	 eax, eax
  001e2	75 2a		 jne	 SHORT $LN13@MakeSelfEx

; 369  : 	{
; 370  : 		PkgError ("Cannot write the start marker");

  001e4	68 10 00 05 00	 push	 327696			; 00050010H
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@MFJOIAFD@Cannot?5write?5the?5start?5marker?$AA@
  001f3	50		 push	 eax
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 371  : 		remove (outputFile);

  001fa	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  00200	50		 push	 eax
  00201	e8 00 00 00 00	 call	 _remove
  00206	83 c4 04	 add	 esp, 4

; 372  : 		goto err;

  00209	e9 e0 04 00 00	 jmp	 $LN74@MakeSelfEx
$LN13@MakeSelfEx:

; 373  : 	}
; 374  : 
; 375  : 
; 376  : 	bufIndex = buffer;

  0020e	8b 9d f8 f0 ff
	ff		 mov	 ebx, DWORD PTR _buffer$1$[ebp]

; 377  : 
; 378  : 	// Copy all required files and their meta data to the buffer
; 379  : 	for (i = 0; i < sizeof (szCompressedFiles) / sizeof (szCompressedFiles[0]); i++)

  00214	33 f6		 xor	 esi, esi
  00216	89 b5 f4 f0 ff
	ff		 mov	 DWORD PTR tv406[ebp], esi
  0021c	0f 1f 40 00	 npad	 4
$LL7@MakeSelfEx:

; 380  : 	{
; 381  : 		DWORD tmpFileSize;
; 382  : 		unsigned char *tmpBuffer;
; 383  : 
; 384  : 		_snprintf (szTmpFilePath, sizeof(szTmpFilePath), "%s%s", szDestDir, szCompressedFiles[i]);

  00220	ff b6 00 00 00
	00		 push	 DWORD PTR _szCompressedFiles[esi]
  00226	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmpFilePath$[ebp]
  0022c	ff b5 f0 f0 ff
	ff		 push	 DWORD PTR _szDestDir$GSCopy$1$[ebp]
  00232	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00237	68 04 01 00 00	 push	 260			; 00000104H
  0023c	50		 push	 eax
  0023d	e8 00 00 00 00	 call	 __snprintf

; 385  : 
; 386  : 		tmpBuffer = LoadFile (szTmpFilePath, &tmpFileSize);

  00242	8d 85 04 f1 ff
	ff		 lea	 eax, DWORD PTR _tmpFileSize$2[ebp]
  00248	50		 push	 eax
  00249	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmpFilePath$[ebp]
  0024f	50		 push	 eax
  00250	e8 00 00 00 00	 call	 _LoadFile
  00255	8b f8		 mov	 edi, eax
  00257	83 c4 1c	 add	 esp, 28			; 0000001cH

; 387  : 
; 388  : 		if (tmpBuffer == NULL)

  0025a	85 ff		 test	 edi, edi
  0025c	0f 84 40 04 00
	00		 je	 $LN55@MakeSelfEx

; 396  : 			goto err;
; 397  : 		}
; 398  : 
; 399  : 		// Copy the filename length to the main buffer
; 400  : 		mputWord (bufIndex, (WORD) strlen(szCompressedFiles[i]));

  00262	8b b6 00 00 00
	00		 mov	 esi, DWORD PTR _szCompressedFiles[esi]
  00268	8b ce		 mov	 ecx, esi
  0026a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0026d	0f 1f 00	 npad	 3
$LL68@MakeSelfEx:
  00270	8a 01		 mov	 al, BYTE PTR [ecx]
  00272	41		 inc	 ecx
  00273	84 c0		 test	 al, al
  00275	75 f9		 jne	 SHORT $LL68@MakeSelfEx
  00277	2b ca		 sub	 ecx, edx
  00279	c1 e9 08	 shr	 ecx, 8
  0027c	88 0b		 mov	 BYTE PTR [ebx], cl
  0027e	8b ce		 mov	 ecx, esi
  00280	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL69@MakeSelfEx:
  00283	8a 01		 mov	 al, BYTE PTR [ecx]
  00285	41		 inc	 ecx
  00286	84 c0		 test	 al, al
  00288	75 f9		 jne	 SHORT $LL69@MakeSelfEx
  0028a	2b ca		 sub	 ecx, edx
  0028c	88 4b 01	 mov	 BYTE PTR [ebx+1], cl

; 401  : 
; 402  : 		// Copy the filename to the main buffer
; 403  : 		memcpy (bufIndex, szCompressedFiles[i], strlen(szCompressedFiles[i]));

  0028f	8b ce		 mov	 ecx, esi
  00291	83 c3 02	 add	 ebx, 2
  00294	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL70@MakeSelfEx:
  00297	8a 01		 mov	 al, BYTE PTR [ecx]
  00299	41		 inc	 ecx
  0029a	84 c0		 test	 al, al
  0029c	75 f9		 jne	 SHORT $LL70@MakeSelfEx
  0029e	2b ca		 sub	 ecx, edx
  002a0	51		 push	 ecx
  002a1	56		 push	 esi
  002a2	53		 push	 ebx
  002a3	e8 00 00 00 00	 call	 _memcpy
  002a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 404  : 		bufIndex += strlen(szCompressedFiles[i]);

  002ab	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  002ae	66 90		 npad	 2
$LL71@MakeSelfEx:
  002b0	8a 06		 mov	 al, BYTE PTR [esi]
  002b2	46		 inc	 esi
  002b3	84 c0		 test	 al, al
  002b5	75 f9		 jne	 SHORT $LL71@MakeSelfEx

; 405  : 
; 406  : 		// Compute CRC-32 hash of the uncompressed file and copy it to the main buffer
; 407  : 		mputLong (bufIndex, GetCrc32 (tmpBuffer, tmpFileSize));

  002b7	ff b5 04 f1 ff
	ff		 push	 DWORD PTR _tmpFileSize$2[ebp]
  002bd	2b f1		 sub	 esi, ecx
  002bf	57		 push	 edi
  002c0	03 de		 add	 ebx, esi
  002c2	e8 00 00 00 00	 call	 _GetCrc32
  002c7	c1 e8 18	 shr	 eax, 24			; 00000018H
  002ca	88 03		 mov	 BYTE PTR [ebx], al
  002cc	ff b5 04 f1 ff
	ff		 push	 DWORD PTR _tmpFileSize$2[ebp]
  002d2	57		 push	 edi
  002d3	e8 00 00 00 00	 call	 _GetCrc32
  002d8	c1 e8 10	 shr	 eax, 16			; 00000010H
  002db	88 43 01	 mov	 BYTE PTR [ebx+1], al
  002de	ff b5 04 f1 ff
	ff		 push	 DWORD PTR _tmpFileSize$2[ebp]
  002e4	57		 push	 edi
  002e5	e8 00 00 00 00	 call	 _GetCrc32
  002ea	c1 e8 08	 shr	 eax, 8
  002ed	88 43 02	 mov	 BYTE PTR [ebx+2], al
  002f0	ff b5 04 f1 ff
	ff		 push	 DWORD PTR _tmpFileSize$2[ebp]
  002f6	57		 push	 edi
  002f7	e8 00 00 00 00	 call	 _GetCrc32
  002fc	88 43 03	 mov	 BYTE PTR [ebx+3], al

; 408  : 
; 409  : 		// Copy the file length to the main buffer
; 410  : 		mputLong (bufIndex, (unsigned __int32) tmpFileSize);

  002ff	8b 85 04 f1 ff
	ff		 mov	 eax, DWORD PTR _tmpFileSize$2[ebp]
  00305	c1 e8 18	 shr	 eax, 24			; 00000018H
  00308	88 43 04	 mov	 BYTE PTR [ebx+4], al
  0030b	8b 85 04 f1 ff
	ff		 mov	 eax, DWORD PTR _tmpFileSize$2[ebp]
  00311	c1 e8 10	 shr	 eax, 16			; 00000010H
  00314	88 43 05	 mov	 BYTE PTR [ebx+5], al
  00317	8b 85 04 f1 ff
	ff		 mov	 eax, DWORD PTR _tmpFileSize$2[ebp]
  0031d	c1 e8 08	 shr	 eax, 8
  00320	88 43 06	 mov	 BYTE PTR [ebx+6], al
  00323	8a 85 04 f1 ff
	ff		 mov	 al, BYTE PTR _tmpFileSize$2[ebp]
  00329	88 43 07	 mov	 BYTE PTR [ebx+7], al
  0032c	83 c3 08	 add	 ebx, 8

; 411  : 
; 412  : 		// Copy the file contents to the main buffer
; 413  : 		memcpy (bufIndex, tmpBuffer, tmpFileSize);

  0032f	ff b5 04 f1 ff
	ff		 push	 DWORD PTR _tmpFileSize$2[ebp]
  00335	57		 push	 edi
  00336	53		 push	 ebx
  00337	e8 00 00 00 00	 call	 _memcpy

; 414  : 		bufIndex += tmpFileSize;

  0033c	03 9d 04 f1 ff
	ff		 add	 ebx, DWORD PTR _tmpFileSize$2[ebp]

; 415  : 
; 416  : 		free (tmpBuffer);

  00342	57		 push	 edi
  00343	e8 00 00 00 00	 call	 _free
  00348	8b b5 f4 f0 ff
	ff		 mov	 esi, DWORD PTR tv406[ebp]
  0034e	83 c4 30	 add	 esp, 48			; 00000030H
  00351	83 c6 04	 add	 esi, 4
  00354	89 b5 f4 f0 ff
	ff		 mov	 DWORD PTR tv406[ebp], esi
  0035a	83 fe 18	 cmp	 esi, 24			; 00000018H
  0035d	0f 82 bd fe ff
	ff		 jb	 $LL7@MakeSelfEx

; 417  : 	}
; 418  : 
; 419  : 	// Calculate the total size of the uncompressed data
; 420  : 	uncompressedDataLen = (int) (bufIndex - buffer);

  00363	8b b5 f8 f0 ff
	ff		 mov	 esi, DWORD PTR _buffer$1$[ebp]
  00369	2b de		 sub	 ebx, esi

; 421  : 
; 422  : 	// Write total size of the uncompressed data
; 423  : 	szTmp32bitPtr = szTmp32bit;
; 424  : 	mputLong (szTmp32bitPtr, (unsigned __int32) uncompressedDataLen);

  0036b	8b c3		 mov	 eax, ebx
  0036d	88 9d ff f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp+3], bl
  00373	c1 e8 18	 shr	 eax, 24			; 00000018H
  00376	88 85 fc f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp], al
  0037c	8b c3		 mov	 eax, ebx
  0037e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00381	88 85 fd f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp+1], al
  00387	8b c3		 mov	 eax, ebx
  00389	c1 e8 08	 shr	 eax, 8

; 425  : 	if (!SaveBufferToFile (szTmp32bit, outputFile, sizeof (szTmp32bit), TRUE))

  0038c	6a 01		 push	 1
  0038e	88 85 fe f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp+2], al
  00394	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  0039a	6a 04		 push	 4
  0039c	50		 push	 eax
  0039d	8d 85 fc f0 ff
	ff		 lea	 eax, DWORD PTR _szTmp32bit$[ebp]
  003a3	50		 push	 eax
  003a4	e8 00 00 00 00	 call	 _SaveBufferToFile
  003a9	83 c4 10	 add	 esp, 16			; 00000010H
  003ac	85 c0		 test	 eax, eax
  003ae	75 2b		 jne	 SHORT $LN15@MakeSelfEx

; 426  : 	{
; 427  : 		remove (outputFile);

  003b0	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 _remove
  003bc	83 c4 04	 add	 esp, 4

; 428  : 		PkgError ("Cannot write the total size of the uncompressed data");

  003bf	68 10 00 05 00	 push	 327696			; 00050010H
  003c4	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  003c9	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@FMCDCAIK@Cannot?5write?5the?5total?5size?5of?5t@
  003ce	6a 00		 push	 0
  003d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 429  : 		goto err;

  003d6	e9 19 03 00 00	 jmp	 $LN75@MakeSelfEx
$LN15@MakeSelfEx:

; 430  : 	}
; 431  : 
; 432  : 	// Compress all the files and meta data in the buffer to create a solid archive
; 433  : 
; 434  : 	compressedBuffer = malloc (uncompressedDataLen + 524288);	// + 512K reserve

  003db	8d 83 00 00 08
	00		 lea	 eax, DWORD PTR [ebx+524288]
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 _malloc
  003e7	8b f8		 mov	 edi, eax
  003e9	83 c4 04	 add	 esp, 4

; 435  : 	if (compressedBuffer == NULL)

  003ec	85 ff		 test	 edi, edi
  003ee	75 2a		 jne	 SHORT $LN16@MakeSelfEx

; 436  : 	{
; 437  : 		remove (outputFile);

  003f0	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  003f6	50		 push	 eax
  003f7	e8 00 00 00 00	 call	 _remove
  003fc	83 c4 04	 add	 esp, 4

; 438  : 		PkgError ("Cannot allocate memory for compressed data");

  003ff	68 10 00 05 00	 push	 327696			; 00050010H
  00404	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  00409	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@MCBJOHEJ@Cannot?5allocate?5memory?5for?5compr@
  0040e	57		 push	 edi
  0040f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 439  : 		goto err;

  00415	e9 dc 02 00 00	 jmp	 $err$77
$LN16@MakeSelfEx:

; 440  : 	}
; 441  : 
; 442  : 	compressedDataLen = CompressBuffer (compressedBuffer, buffer, uncompressedDataLen);

  0041a	53		 push	 ebx
  0041b	56		 push	 esi
  0041c	57		 push	 edi
  0041d	e8 00 00 00 00	 call	 _CompressBuffer
  00422	8b d8		 mov	 ebx, eax
  00424	83 c4 0c	 add	 esp, 12			; 0000000cH

; 443  : 	if (compressedDataLen <= 0)

  00427	85 db		 test	 ebx, ebx
  00429	7f 2b		 jg	 SHORT $LN17@MakeSelfEx

; 444  : 	{
; 445  : 		remove (outputFile);

  0042b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  00431	50		 push	 eax
  00432	e8 00 00 00 00	 call	 _remove
  00437	83 c4 04	 add	 esp, 4

; 446  : 		PkgError ("Failed to compress the data");

  0043a	68 10 00 05 00	 push	 327696			; 00050010H
  0043f	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  00444	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OPFGKMBF@Failed?5to?5compress?5the?5data?$AA@
  00449	6a 00		 push	 0
  0044b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 447  : 		goto err;

  00451	e9 a0 02 00 00	 jmp	 $err$77
$LN17@MakeSelfEx:

; 448  : 	}
; 449  : 
; 450  : 	free (buffer);

  00456	56		 push	 esi
  00457	e8 00 00 00 00	 call	 _free

; 451  : 	buffer = NULL;
; 452  : 
; 453  : 	// Write the total size of the compressed data
; 454  : 	szTmp32bitPtr = szTmp32bit;
; 455  : 	mputLong (szTmp32bitPtr, (unsigned __int32) compressedDataLen);

  0045c	8b c3		 mov	 eax, ebx
  0045e	88 9d ff f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp+3], bl
  00464	c1 e8 18	 shr	 eax, 24			; 00000018H
  00467	88 85 fc f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp], al
  0046d	8b c3		 mov	 eax, ebx
  0046f	c1 e8 10	 shr	 eax, 16			; 00000010H
  00472	88 85 fd f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp+1], al
  00478	8b c3		 mov	 eax, ebx
  0047a	c1 e8 08	 shr	 eax, 8

; 456  : 	if (!SaveBufferToFile (szTmp32bit, outputFile, sizeof (szTmp32bit), TRUE))

  0047d	6a 01		 push	 1
  0047f	88 85 fe f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp+2], al
  00485	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  0048b	6a 04		 push	 4
  0048d	50		 push	 eax
  0048e	8d 85 fc f0 ff
	ff		 lea	 eax, DWORD PTR _szTmp32bit$[ebp]
  00494	50		 push	 eax
  00495	e8 00 00 00 00	 call	 _SaveBufferToFile
  0049a	83 c4 14	 add	 esp, 20			; 00000014H
  0049d	85 c0		 test	 eax, eax

; 457  : 	{
; 458  : 		remove (outputFile);

  0049f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  004a5	75 25		 jne	 SHORT $LN18@MakeSelfEx
  004a7	50		 push	 eax
  004a8	e8 00 00 00 00	 call	 _remove
  004ad	83 c4 04	 add	 esp, 4

; 459  : 		PkgError ("Cannot write the total size of the compressed data");

  004b0	68 10 00 05 00	 push	 327696			; 00050010H
  004b5	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  004ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@BPNJOCGM@Cannot?5write?5the?5total?5size?5of?5t@
  004bf	6a 00		 push	 0
  004c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 460  : 		goto err;

  004c7	e9 33 02 00 00	 jmp	 $LN23@MakeSelfEx
$LN18@MakeSelfEx:

; 461  : 	}
; 462  : 
; 463  : 	// Write the compressed data
; 464  : 	if (!SaveBufferToFile (compressedBuffer, outputFile, compressedDataLen, TRUE))

  004cc	6a 01		 push	 1
  004ce	53		 push	 ebx
  004cf	50		 push	 eax
  004d0	57		 push	 edi
  004d1	e8 00 00 00 00	 call	 _SaveBufferToFile
  004d6	83 c4 10	 add	 esp, 16			; 00000010H
  004d9	85 c0		 test	 eax, eax
  004db	75 2b		 jne	 SHORT $LN19@MakeSelfEx

; 465  : 	{
; 466  : 		remove (outputFile);

  004dd	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  004e3	50		 push	 eax
  004e4	e8 00 00 00 00	 call	 _remove
  004e9	83 c4 04	 add	 esp, 4

; 467  : 		PkgError ("Cannot write compressed data to the package");

  004ec	68 10 00 05 00	 push	 327696			; 00050010H
  004f1	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  004f6	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OKBFEFMD@Cannot?5write?5compressed?5data?5to?5@
  004fb	6a 00		 push	 0
  004fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 468  : 		goto err;

  00503	e9 f7 01 00 00	 jmp	 $LN23@MakeSelfEx
$LN19@MakeSelfEx:

; 469  : 	}
; 470  : 
; 471  : 	// Write the end marker
; 472  : 	if (!SaveBufferToFile (MagEndMarker, outputFile, strlen (MagEndMarker), TRUE))

  00508	b9 00 00 00 00	 mov	 ecx, OFFSET _MagEndMarker
  0050d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL72@MakeSelfEx:
  00510	8a 01		 mov	 al, BYTE PTR [ecx]
  00512	41		 inc	 ecx
  00513	84 c0		 test	 al, al
  00515	75 f9		 jne	 SHORT $LL72@MakeSelfEx
  00517	6a 01		 push	 1
  00519	2b ca		 sub	 ecx, edx
  0051b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  00521	51		 push	 ecx
  00522	50		 push	 eax
  00523	68 00 00 00 00	 push	 OFFSET _MagEndMarker
  00528	e8 00 00 00 00	 call	 _SaveBufferToFile
  0052d	83 c4 10	 add	 esp, 16			; 00000010H
  00530	85 c0		 test	 eax, eax
  00532	75 1e		 jne	 SHORT $LN20@MakeSelfEx

; 473  : 	{
; 474  : 		remove (outputFile);

  00534	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  0053a	50		 push	 eax
  0053b	e8 00 00 00 00	 call	 _remove

; 475  : 		PkgError ("Cannot write the end marker");

  00540	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@CAOLNJAF@Cannot?5write?5the?5end?5marker?$AA@
  00545	e8 00 00 00 00	 call	 _PkgError
  0054a	83 c4 08	 add	 esp, 8

; 476  : 		goto err;

  0054d	e9 ad 01 00 00	 jmp	 $LN23@MakeSelfEx
$LN20@MakeSelfEx:

; 477  : 	}
; 478  : 
; 479  : 	free (compressedBuffer);

  00552	57		 push	 edi
  00553	e8 00 00 00 00	 call	 _free

; 480  : 	compressedBuffer = NULL;
; 481  : 
; 482  : 	// Compute and write CRC-32 hash of the entire package
; 483  : 	{
; 484  : 		DWORD tmpFileSize;
; 485  : 		char *tmpBuffer;
; 486  : 
; 487  : 		tmpBuffer = LoadFile (outputFile, &tmpFileSize);

  00558	8d 85 04 f1 ff
	ff		 lea	 eax, DWORD PTR _tmpFileSize$1[ebp]
  0055e	50		 push	 eax
  0055f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  00565	50		 push	 eax
  00566	e8 00 00 00 00	 call	 _LoadFile
  0056b	8b f0		 mov	 esi, eax
  0056d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 488  : 
; 489  : 		if (tmpBuffer == NULL)

  00570	85 f6		 test	 esi, esi
  00572	75 37		 jne	 SHORT $LN21@MakeSelfEx

; 490  : 		{
; 491  : 			handleWin32Error (hwndDlg);

  00574	ff b5 ec f0 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0057a	e8 00 00 00 00	 call	 _handleWin32Error

; 492  : 			remove (outputFile);

  0057f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  00585	50		 push	 eax
  00586	e8 00 00 00 00	 call	 _remove

; 493  : 			PkgError ("Cannot load the package to compute CRC");

  0058b	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@KLAPHHKA@Cannot?5load?5the?5package?5to?5compu@
  00590	e8 00 00 00 00	 call	 _PkgError
  00595	83 c4 0c	 add	 esp, 12			; 0000000cH

; 521  : 
; 522  : 	return FALSE;

  00598	33 c0		 xor	 eax, eax
  0059a	5f		 pop	 edi
  0059b	5e		 pop	 esi
  0059c	5b		 pop	 ebx

; 523  : }

  0059d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005a0	33 cd		 xor	 ecx, ebp
  005a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005a7	8b e5		 mov	 esp, ebp
  005a9	5d		 pop	 ebp
  005aa	c3		 ret	 0
$LN21@MakeSelfEx:

; 494  : 			goto err;
; 495  : 		}
; 496  : 
; 497  : 		// Zero all bytes that change when the exe is digitally signed (except appended blocks).
; 498  : 		WipeSignatureAreas (tmpBuffer);

  005ab	68 d0 00 00 00	 push	 208			; 000000d0H
  005b0	8d 86 30 01 00
	00		 lea	 eax, DWORD PTR [esi+304]
  005b6	6a 00		 push	 0
  005b8	50		 push	 eax
  005b9	e8 00 00 00 00	 call	 _memset

; 499  : 
; 500  : 		szTmp32bitPtr = szTmp32bit;
; 501  : 		mputLong (szTmp32bitPtr, GetCrc32 (tmpBuffer, tmpFileSize));

  005be	ff b5 04 f1 ff
	ff		 push	 DWORD PTR _tmpFileSize$1[ebp]
  005c4	56		 push	 esi
  005c5	e8 00 00 00 00	 call	 _GetCrc32
  005ca	ff b5 04 f1 ff
	ff		 push	 DWORD PTR _tmpFileSize$1[ebp]
  005d0	c1 e8 18	 shr	 eax, 24			; 00000018H
  005d3	56		 push	 esi
  005d4	88 85 fc f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp], al
  005da	e8 00 00 00 00	 call	 _GetCrc32
  005df	ff b5 04 f1 ff
	ff		 push	 DWORD PTR _tmpFileSize$1[ebp]
  005e5	c1 e8 10	 shr	 eax, 16			; 00000010H
  005e8	56		 push	 esi
  005e9	88 85 fd f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp+1], al
  005ef	e8 00 00 00 00	 call	 _GetCrc32
  005f4	ff b5 04 f1 ff
	ff		 push	 DWORD PTR _tmpFileSize$1[ebp]
  005fa	c1 e8 08	 shr	 eax, 8
  005fd	56		 push	 esi
  005fe	88 85 fe f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp+2], al
  00604	e8 00 00 00 00	 call	 _GetCrc32

; 502  : 		free (tmpBuffer);

  00609	56		 push	 esi
  0060a	88 85 ff f0 ff
	ff		 mov	 BYTE PTR _szTmp32bit$[ebp+3], al
  00610	e8 00 00 00 00	 call	 _free

; 503  : 
; 504  : 		if (!SaveBufferToFile (szTmp32bit, outputFile, sizeof (szTmp32bit), TRUE))

  00615	6a 01		 push	 1
  00617	6a 04		 push	 4
  00619	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  0061f	50		 push	 eax
  00620	8d 85 fc f0 ff
	ff		 lea	 eax, DWORD PTR _szTmp32bit$[ebp]
  00626	50		 push	 eax
  00627	e8 00 00 00 00	 call	 _SaveBufferToFile
  0062c	83 c4 40	 add	 esp, 64			; 00000040H
  0062f	85 c0		 test	 eax, eax

; 505  : 		{
; 506  : 			remove (outputFile);

  00631	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  00637	50		 push	 eax
  00638	75 25		 jne	 SHORT $LN22@MakeSelfEx
  0063a	e8 00 00 00 00	 call	 _remove

; 507  : 			PkgError ("Cannot write the total size of the compressed data");

  0063f	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@BPNJOCGM@Cannot?5write?5the?5total?5size?5of?5t@
  00644	e8 00 00 00 00	 call	 _PkgError
  00649	83 c4 08	 add	 esp, 8

; 521  : 
; 522  : 	return FALSE;

  0064c	33 c0		 xor	 eax, eax
  0064e	5f		 pop	 edi
  0064f	5e		 pop	 esi
  00650	5b		 pop	 ebx

; 523  : }

  00651	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00654	33 cd		 xor	 ecx, ebp
  00656	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0065b	8b e5		 mov	 esp, ebp
  0065d	5d		 pop	 ebp
  0065e	c3		 ret	 0
$LN22@MakeSelfEx:

; 508  : 			goto err;
; 509  : 		}
; 510  : 	}
; 511  : 
; 512  : 	sprintf (tmpStr, "Self-extracting package successfully created (%s)", outputFile);

  0065f	8d 85 08 f1 ff
	ff		 lea	 eax, DWORD PTR _tmpStr$[ebp]
  00665	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@MFPOOIGB@Self?9extracting?5package?5successf@
  0066a	50		 push	 eax
  0066b	e8 00 00 00 00	 call	 _sprintf
  00670	83 c4 0c	 add	 esp, 12			; 0000000cH

; 513  : 	PkgInfo (tmpStr);

  00673	8d 85 08 f1 ff
	ff		 lea	 eax, DWORD PTR _tmpStr$[ebp]
  00679	68 40 00 05 00	 push	 327744			; 00050040H
  0067e	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  00683	50		 push	 eax
  00684	6a 00		 push	 0
  00686	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  0068c	5f		 pop	 edi
  0068d	5e		 pop	 esi

; 514  : 	return TRUE;

  0068e	b8 01 00 00 00	 mov	 eax, 1
  00693	5b		 pop	 ebx

; 523  : }

  00694	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00697	33 cd		 xor	 ecx, ebp
  00699	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0069e	8b e5		 mov	 esp, ebp
  006a0	5d		 pop	 ebp
  006a1	c3		 ret	 0
$LN55@MakeSelfEx:

; 389  : 		{
; 390  : 			char tmpstr [1000];
; 391  : 
; 392  : 			free (tmpBuffer);

  006a2	6a 00		 push	 0
  006a4	e8 00 00 00 00	 call	 _free

; 393  : 			_snprintf (tmpstr, sizeof(tmpstr), "Cannot load file \n'%s'", szTmpFilePath);

  006a9	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTmpFilePath$[ebp]
  006af	50		 push	 eax
  006b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BHAJCMKJ@Cannot?5load?5file?5?6?8?$CFs?8?$AA@
  006b5	8d 85 08 f9 ff
	ff		 lea	 eax, DWORD PTR _tmpstr$3[ebp]
  006bb	68 e8 03 00 00	 push	 1000			; 000003e8H
  006c0	50		 push	 eax
  006c1	e8 00 00 00 00	 call	 __snprintf

; 394  : 			remove (outputFile);

  006c6	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  006cc	50		 push	 eax
  006cd	e8 00 00 00 00	 call	 _remove
  006d2	83 c4 18	 add	 esp, 24			; 00000018H

; 395  : 			PkgError (tmpstr);

  006d5	8d 85 08 f9 ff
	ff		 lea	 eax, DWORD PTR _tmpstr$3[ebp]
  006db	68 10 00 05 00	 push	 327696			; 00050010H
  006e0	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  006e5	50		 push	 eax
  006e6	6a 00		 push	 0
  006e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN74@MakeSelfEx:
  006ee	8b b5 f8 f0 ff
	ff		 mov	 esi, DWORD PTR _buffer$1$[ebp]
$LN75@MakeSelfEx:
  006f4	33 ff		 xor	 edi, edi
$err$77:

; 515  : 
; 516  : err:
; 517  : 	if (buffer)
; 518  : 		free (buffer);

  006f6	56		 push	 esi
  006f7	e8 00 00 00 00	 call	 _free
  006fc	83 c4 04	 add	 esp, 4
$LN23@MakeSelfEx:

; 519  : 	if (compressedBuffer)

  006ff	85 ff		 test	 edi, edi
  00701	74 5a		 je	 SHORT $LN24@MakeSelfEx

; 520  : 		free (compressedBuffer);

  00703	57		 push	 edi
  00704	e8 00 00 00 00	 call	 _free
  00709	83 c4 04	 add	 esp, 4

; 521  : 
; 522  : 	return FALSE;

  0070c	33 c0		 xor	 eax, eax
  0070e	5f		 pop	 edi
  0070f	5e		 pop	 esi
  00710	5b		 pop	 ebx

; 523  : }

  00711	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00714	33 cd		 xor	 ecx, ebp
  00716	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0071b	8b e5		 mov	 esp, ebp
  0071d	5d		 pop	 ebp
  0071e	c3		 ret	 0
$LN54@MakeSelfEx:

; 341  : 		{
; 342  : 			char tmpstr [1000];
; 343  : 
; 344  : 			_snprintf (tmpstr, sizeof(tmpstr), "File not found:\n\n'%s'", szTmpFilePath);

  0071f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MKKJCCCC@File?5not?5found?3?6?6?8?$CFs?8?$AA@
  00724	8d 85 08 f9 ff
	ff		 lea	 eax, DWORD PTR _tmpstr$4[ebp]
  0072a	68 e8 03 00 00	 push	 1000			; 000003e8H
  0072f	50		 push	 eax
  00730	e8 00 00 00 00	 call	 __snprintf

; 345  : 			remove (outputFile);

  00735	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _outputFile$[ebp]
  0073b	50		 push	 eax
  0073c	e8 00 00 00 00	 call	 _remove
  00741	83 c4 14	 add	 esp, 20			; 00000014H

; 346  : 			PkgError (tmpstr);

  00744	8d 85 08 f9 ff
	ff		 lea	 eax, DWORD PTR _tmpstr$4[ebp]
  0074a	68 10 00 05 00	 push	 327696			; 00050010H
  0074f	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  00754	50		 push	 eax
$LN73@MakeSelfEx:
  00755	6a 00		 push	 0
  00757	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN24@MakeSelfEx:

; 523  : }

  0075d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00760	33 c0		 xor	 eax, eax
  00762	5f		 pop	 edi
  00763	5e		 pop	 esi
  00764	33 cd		 xor	 ecx, ebp
  00766	5b		 pop	 ebx
  00767	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0076c	8b e5		 mov	 esp, ebp
  0076e	5d		 pop	 ebp
  0076f	c3		 ret	 0
_MakeSelfExtractingPackage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _ExtractAllFilesThread
_TEXT	SEGMENT
_hwndDlg$GSCopy$1$ = -2080				; size = 4
_bSuccess$1$ = -2076					; size = 4
_fileNo$1$ = -2072					; size = 4
_szTmp$1 = -2068					; size = 1024
_packageFile$ = -1044					; size = 260
_szTmp$2 = -784						; size = 520
_fileName$3 = -524					; size = 260
_filePath$4 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_ExtractAllFilesThread PROC				; COMDAT

; 789  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 08 00
	00		 sub	 esp, 2080		; 00000820H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]

; 790  : 	int fileNo;
; 791  : 	BOOL bSuccess = FALSE;
; 792  : 	char packageFile [GST_MAX_PATH];
; 793  : 
; 794  : 	InvalidateRect (GetDlgItem (GetParent (hwndDlg), IDD_INSTL_DLG), NULL, TRUE);

  00019	6a 01		 push	 1
  0001b	6a 00		 push	 0
  0001d	6a 6f		 push	 111			; 0000006fH
  0001f	57		 push	 edi
  00020	89 bd e0 f7 ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], edi
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 795  : 
; 796  : 	ClearLogWindow (hwndDlg);

  0003a	57		 push	 edi
  0003b	e8 00 00 00 00	 call	 _ClearLogWindow
  00040	83 c4 04	 add	 esp, 4

; 797  : 
; 798  : 	GetModuleFileName (NULL, packageFile, sizeof (packageFile));

  00043	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _packageFile$[ebp]
  00049	68 04 01 00 00	 push	 260			; 00000104H
  0004e	50		 push	 eax
  0004f	6a 00		 push	 0
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 799  : 
; 800  : 	if (!(bSuccess = SelfExtractInMemory (packageFile)))

  00057	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _packageFile$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _SelfExtractInMemory
  00063	83 c4 04	 add	 esp, 4
  00066	89 85 e4 f7 ff
	ff		 mov	 DWORD PTR _bSuccess$1$[ebp], eax
  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 e6 01 00
	00		 je	 $LN25@ExtractAll

; 801  : 		goto eaf_end;
; 802  : 
; 803  : 	if (mkfulldir (DestExtractPath, TRUE) != 0)

  00074	6a 01		 push	 1
  00076	68 00 00 00 00	 push	 OFFSET _DestExtractPath
  0007b	e8 00 00 00 00	 call	 _mkfulldir
  00080	83 c4 08	 add	 esp, 8
  00083	85 c0		 test	 eax, eax
  00085	74 5c		 je	 SHORT $LN7@ExtractAll

; 804  : 	{
; 805  : 		if (mkfulldir (DestExtractPath, FALSE) != 0)

  00087	6a 00		 push	 0
  00089	68 00 00 00 00	 push	 OFFSET _DestExtractPath
  0008e	e8 00 00 00 00	 call	 _mkfulldir
  00093	83 c4 08	 add	 esp, 8
  00096	85 c0		 test	 eax, eax
  00098	74 49		 je	 SHORT $LN7@ExtractAll

; 806  : 		{
; 807  : 			wchar_t szTmp[GST_MAX_PATH];
; 808  : 
; 809  : 			handleWin32Error (hwndDlg);

  0009a	57		 push	 edi
  0009b	e8 00 00 00 00	 call	 _handleWin32Error
  000a0	83 c4 04	 add	 esp, 4

; 810  : 			wsprintfW (szTmp, GetString ("CANT_CREATE_FOLDER"), DestExtractPath);

  000a3	68 00 00 00 00	 push	 OFFSET _DestExtractPath
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@
  000ad	e8 00 00 00 00	 call	 _GetString
  000b2	83 c4 04	 add	 esp, 4
  000b5	50		 push	 eax
  000b6	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _szTmp$2[ebp]
  000bc	50		 push	 eax
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 811  : 			MessageBoxW (hwndDlg, szTmp, lpszTitle, MB_ICONHAND);

  000c6	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _szTmp$2[ebp]
  000cc	6a 10		 push	 16			; 00000010H
  000ce	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  000d4	50		 push	 eax
  000d5	57		 push	 edi
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 812  : 			bSuccess = FALSE;

  000dc	33 f6		 xor	 esi, esi

; 813  : 			goto eaf_end;

  000de	e9 79 01 00 00	 jmp	 $eaf_end$30
$LN7@ExtractAll:

; 814  : 		}
; 815  : 	}
; 816  : 
; 817  : 	for (fileNo = 0; fileNo < NBR_COMPRESSED_FILES; fileNo++)

  000e3	c7 85 e8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _fileNo$1$[ebp], 0
  000ed	33 db		 xor	 ebx, ebx
  000ef	90		 npad	 1
$LL4@ExtractAll:

; 818  : 	{
; 819  : 		char fileName [GST_MAX_PATH] = {0};
; 820  : 		char filePath [GST_MAX_PATH] = {0};
; 821  : 
; 822  : 		// Filename
; 823  : 		strncpy (fileName, Decompressed_Files[fileNo].fileName, Decompressed_Files[fileNo].fileNameLength);

  000f0	68 04 01 00 00	 push	 260			; 00000104H
  000f5	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _fileName$3[ebp]
  000fb	6a 00		 push	 0
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _memset
  00103	68 04 01 00 00	 push	 260			; 00000104H
  00108	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _filePath$4[ebp]
  0010e	6a 00		 push	 0
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _memset
  00116	ff b3 04 00 00
	00		 push	 DWORD PTR _Decompressed_Files[ebx+4]
  0011c	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _fileName$3[ebp]
  00122	ff b3 00 00 00
	00		 push	 DWORD PTR _Decompressed_Files[ebx]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _strncpy

; 824  : 		fileName [Decompressed_Files[fileNo].fileNameLength] = 0;

  0012e	8b 83 04 00 00
	00		 mov	 eax, DWORD PTR _Decompressed_Files[ebx+4]
  00134	83 c4 24	 add	 esp, 36			; 00000024H
  00137	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  0013c	0f 83 50 01 00
	00		 jae	 $LN28@ExtractAll
  00142	c6 84 05 f4 fd
	ff ff 00	 mov	 BYTE PTR _fileName$3[ebp+eax], 0

; 825  : 		strcpy (filePath, DestExtractPath);

  0014a	33 c9		 xor	 ecx, ecx
  0014c	0f 1f 40 00	 npad	 4
$LL14@ExtractAll:
  00150	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _DestExtractPath[ecx]
  00156	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00159	88 84 0d f7 fe
	ff ff		 mov	 BYTE PTR _filePath$4[ebp+ecx-1], al
  00160	84 c0		 test	 al, al
  00162	75 ec		 jne	 SHORT $LL14@ExtractAll

; 826  : 		strcat (filePath, fileName);

  00164	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _fileName$3[ebp]
  0016a	8b f2		 mov	 esi, edx
  0016c	0f 1f 40 00	 npad	 4
$LL23@ExtractAll:
  00170	8a 02		 mov	 al, BYTE PTR [edx]
  00172	42		 inc	 edx
  00173	84 c0		 test	 al, al
  00175	75 f9		 jne	 SHORT $LL23@ExtractAll
  00177	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _filePath$4[ebp]
  0017d	2b d6		 sub	 edx, esi
  0017f	4f		 dec	 edi
$LL24@ExtractAll:
  00180	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00183	47		 inc	 edi
  00184	84 c0		 test	 al, al
  00186	75 f8		 jne	 SHORT $LL24@ExtractAll
  00188	8b ca		 mov	 ecx, edx

; 827  : 
; 828  : 		StatusMessageParam (hwndDlg, "EXTRACTING_VERB", filePath);

  0018a	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _filePath$4[ebp]
  00190	c1 e9 02	 shr	 ecx, 2
  00193	f3 a5		 rep movsd
  00195	8b ca		 mov	 ecx, edx
  00197	83 e1 03	 and	 ecx, 3
  0019a	50		 push	 eax
  0019b	f3 a4		 rep movsb
  0019d	8b bd e0 f7 ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  001a3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@
  001a8	57		 push	 edi
  001a9	e8 00 00 00 00	 call	 _StatusMessageParam

; 829  : 
; 830  : 		// Write the file
; 831  : 		if (!SaveBufferToFile (

  001ae	6a 00		 push	 0
  001b0	ff b3 0c 00 00
	00		 push	 DWORD PTR _Decompressed_Files[ebx+12]
  001b6	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _filePath$4[ebp]
  001bc	50		 push	 eax
  001bd	ff b3 10 00 00
	00		 push	 DWORD PTR _Decompressed_Files[ebx+16]
  001c3	e8 00 00 00 00	 call	 _SaveBufferToFile
  001c8	83 c4 1c	 add	 esp, 28			; 0000001cH
  001cb	85 c0		 test	 eax, eax
  001cd	74 45		 je	 SHORT $LN17@ExtractAll

; 843  : 		}
; 844  : 		UpdateProgressBarProc ((int) (100 * ((float) fileNo / NBR_COMPRESSED_FILES)));

  001cf	8b b5 e8 f7 ff
	ff		 mov	 esi, DWORD PTR _fileNo$1$[ebp]
  001d5	66 0f 6e c6	 movd	 xmm0, esi
  001d9	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001dc	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40c00000
  001e4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42c80000
  001ec	f3 0f 2c c0	 cvttss2si eax, xmm0
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  001f6	46		 inc	 esi
  001f7	83 c3 14	 add	 ebx, 20			; 00000014H
  001fa	83 c4 04	 add	 esp, 4
  001fd	89 b5 e8 f7 ff
	ff		 mov	 DWORD PTR _fileNo$1$[ebp], esi
  00203	83 fb 78	 cmp	 ebx, 120		; 00000078H
  00206	0f 82 e4 fe ff
	ff		 jb	 $LL4@ExtractAll

; 829  : 
; 830  : 		// Write the file
; 831  : 		if (!SaveBufferToFile (

  0020c	8b b5 e4 f7 ff
	ff		 mov	 esi, DWORD PTR _bSuccess$1$[ebp]
  00212	eb 48		 jmp	 SHORT $eaf_end$30
$LN17@ExtractAll:

; 832  : 			Decompressed_Files[fileNo].fileContent,
; 833  : 			filePath,
; 834  : 			Decompressed_Files[fileNo].fileLength,
; 835  : 			FALSE))
; 836  : 		{
; 837  : 			wchar_t szTmp[512];
; 838  : 
; 839  : 			_snwprintf (szTmp, sizeof (szTmp) / 2, GetString ("CANNOT_WRITE_FILE_X"), filePath);

  00214	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _filePath$4[ebp]
  0021a	50		 push	 eax
  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BADKJOBO@CANNOT_WRITE_FILE_X?$AA@
  00220	e8 00 00 00 00	 call	 _GetString
  00225	83 c4 04	 add	 esp, 4
  00228	50		 push	 eax
  00229	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$1[ebp]
  0022f	68 00 02 00 00	 push	 512			; 00000200H
  00234	50		 push	 eax
  00235	e8 00 00 00 00	 call	 __snwprintf
  0023a	83 c4 10	 add	 esp, 16			; 00000010H

; 840  : 			MessageBoxW (hwndDlg, szTmp, lpszTitle, MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);

  0023d	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _szTmp$1[ebp]
  00243	68 10 00 05 00	 push	 327696			; 00050010H
  00248	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  0024e	50		 push	 eax
  0024f	57		 push	 edi
  00250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 841  : 			bSuccess = FALSE;

  00256	33 f6		 xor	 esi, esi

; 842  : 			goto eaf_end;

  00258	eb 02		 jmp	 SHORT $eaf_end$30
$LN25@ExtractAll:
  0025a	8b f0		 mov	 esi, eax
$eaf_end$30:

; 845  : 	}
; 846  : 
; 847  : eaf_end:
; 848  : 	FreeAllFileBuffers();

  0025c	e8 00 00 00 00	 call	 _FreeAllFileBuffers
  00261	5f		 pop	 edi

; 849  : 
; 850  : 	if (bSuccess)

  00262	85 f6		 test	 esi, esi
  00264	5e		 pop	 esi
  00265	5b		 pop	 ebx

; 851  : 		PostMessage (MainDlg, GST_APPMSG_EXTRACTION_SUCCESS, 0, 0);

  00266	6a 00		 push	 0
  00268	6a 00		 push	 0
  0026a	74 07		 je	 SHORT $LN9@ExtractAll
  0026c	68 93 81 00 00	 push	 33171			; 00008193H
  00271	eb 05		 jmp	 SHORT $LN27@ExtractAll
$LN9@ExtractAll:

; 852  : 	else
; 853  : 		PostMessage (MainDlg, GST_APPMSG_EXTRACTION_FAILURE, 0, 0);

  00273	68 96 81 00 00	 push	 33174			; 00008196H
$LN27@ExtractAll:
  00278	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0027e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 854  : }

  00284	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00287	33 cd		 xor	 ecx, ebp
  00289	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c3		 ret	 0
$LN28@ExtractAll:

; 824  : 		fileName [Decompressed_Files[fileNo].fileNameLength] = 0;

  00292	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN29@ExtractAll:
$LN26@ExtractAll:
  00297	cc		 int	 3
_ExtractAllFilesThread ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _SelfExtractInMemory
_TEXT	SEGMENT
_bufEndPos$1$ = -16					; size = 4
_compressedData$1$ = -12				; size = 4
_filePos$1$ = -12					; size = 4
_uncompressedLen$ = -8					; size = 4
_compressedLen$ = -4					; size = 4
_path$ = 8						; size = 4
_SelfExtractInMemory PROC				; COMDAT

; 652  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 653  : 	int filePos = 0, fileNo = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 654  : 	int fileDataEndPos = 0;
; 655  : 	int fileDataStartPos = 0;
; 656  : 	int uncompressedLen = 0;

  0000b	89 5d f8	 mov	 DWORD PTR _uncompressedLen$[ebp], ebx

; 657  : 	int compressedLen = 0;

  0000e	89 5d fc	 mov	 DWORD PTR _compressedLen$[ebp], ebx

; 658  : 	unsigned char *compressedData = NULL;
; 659  : 	unsigned char *bufPos = NULL, *bufEndPos = NULL;
; 660  : 
; 661  : 	FreeAllFileBuffers();

  00011	e8 00 00 00 00	 call	 _FreeAllFileBuffers

; 662  : 
; 663  : 	fileDataEndPos = (int) FindStringInFile (path, MagEndMarker, strlen (MagEndMarker));

  00016	b9 00 00 00 00	 mov	 ecx, OFFSET _MagEndMarker
  0001b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0001e	66 90		 npad	 2
$LL23@SelfExtrac:
  00020	8a 01		 mov	 al, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL23@SelfExtrac
  00027	8b 7d 08	 mov	 edi, DWORD PTR _path$[ebp]
  0002a	2b ca		 sub	 ecx, edx
  0002c	51		 push	 ecx
  0002d	68 00 00 00 00	 push	 OFFSET _MagEndMarker
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 _FindStringInFile
  00038	8b f0		 mov	 esi, eax
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 664  : 	if (fileDataEndPos < 0)

  0003d	85 f6		 test	 esi, esi
  0003f	79 16		 jns	 SHORT $LN4@SelfExtrac
$LN26@SelfExtrac:

; 665  : 	{
; 666  : 		Error ("CANNOT_READ_FROM_PACKAGE");

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@
  00046	e8 00 00 00 00	 call	 _Error

; 775  : 	free (compressedData);

  0004b	83 c4 04	 add	 esp, 4

; 776  : 	return FALSE;

  0004e	33 c0		 xor	 eax, eax
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 777  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN4@SelfExtrac:

; 667  : 		return FALSE;
; 668  : 	}
; 669  : 
; 670  : 	fileDataEndPos--;
; 671  : 
; 672  : 	fileDataStartPos = (int) FindStringInFile (path, MAG_START_MARKER, strlen (MAG_START_MARKER));

  00057	6a 09		 push	 9
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_09JEFCBPAJ@GSTINSTRT?$AA@
  0005e	57		 push	 edi
  0005f	e8 00 00 00 00	 call	 _FindStringInFile
  00064	8b f8		 mov	 edi, eax
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 673  : 	if (fileDataStartPos < 0)

  00069	85 ff		 test	 edi, edi
  0006b	78 d4		 js	 SHORT $LN26@SelfExtrac

; 674  : 	{
; 675  : 		Error ("CANNOT_READ_FROM_PACKAGE");
; 676  : 		return FALSE;
; 677  : 	}
; 678  : 
; 679  : 	fileDataStartPos += strlen (MAG_START_MARKER);

  0006d	83 c7 09	 add	 edi, 9

; 680  : 
; 681  : 	filePos = fileDataStartPos;
; 682  : 
; 683  : 	// Read the stored total size of the uncompressed data
; 684  : 	if (!LoadInt32 (path, &uncompressedLen, filePos))

  00070	8b c7		 mov	 eax, edi
  00072	99		 cdq
  00073	52		 push	 edx
  00074	50		 push	 eax
  00075	8d 45 f8	 lea	 eax, DWORD PTR _uncompressedLen$[ebp]
  00078	50		 push	 eax
  00079	ff 75 08	 push	 DWORD PTR _path$[ebp]
  0007c	e8 00 00 00 00	 call	 _LoadInt32
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	85 c0		 test	 eax, eax
  00086	74 b9		 je	 SHORT $LN26@SelfExtrac

; 685  : 	{
; 686  : 		Error ("CANNOT_READ_FROM_PACKAGE");
; 687  : 		return FALSE;
; 688  : 	}
; 689  : 
; 690  : 	filePos += 4;

  00088	8d 47 04	 lea	 eax, DWORD PTR [edi+4]

; 691  : 
; 692  : 	// Read the stored total size of the compressed data
; 693  : 	if (!LoadInt32 (path, &compressedLen, filePos))

  0008b	99		 cdq
  0008c	52		 push	 edx
  0008d	50		 push	 eax
  0008e	8d 45 fc	 lea	 eax, DWORD PTR _compressedLen$[ebp]
  00091	50		 push	 eax
  00092	ff 75 08	 push	 DWORD PTR _path$[ebp]
  00095	e8 00 00 00 00	 call	 _LoadInt32
  0009a	83 c4 10	 add	 esp, 16			; 00000010H
  0009d	85 c0		 test	 eax, eax
  0009f	74 a0		 je	 SHORT $LN26@SelfExtrac

; 694  : 	{
; 695  : 		Error ("CANNOT_READ_FROM_PACKAGE");
; 696  : 		return FALSE;
; 697  : 	}
; 698  : 
; 699  : 	filePos += 4;
; 700  : 
; 701  : 	if (compressedLen != fileDataEndPos - fileDataStartPos - 8 + 1)

  000a1	2b f7		 sub	 esi, edi
  000a3	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  000a6	83 ee 08	 sub	 esi, 8
  000a9	89 45 f4	 mov	 DWORD PTR _filePos$1$[ebp], eax
  000ac	39 75 fc	 cmp	 DWORD PTR _compressedLen$[ebp], esi
  000af	74 0d		 je	 SHORT $LN8@SelfExtrac

; 702  : 	{
; 703  : 		Error ("DIST_PACKAGE_CORRUPTED");

  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@
  000b6	e8 00 00 00 00	 call	 _Error
  000bb	83 c4 04	 add	 esp, 4
$LN8@SelfExtrac:

; 704  : 	}
; 705  : 
; 706  : 	DecompressedData = malloc (uncompressedLen + 524288);	// + 512K reserve 

  000be	8b 45 f8	 mov	 eax, DWORD PTR _uncompressedLen$[ebp]
  000c1	05 00 00 08 00	 add	 eax, 524288		; 00080000H
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _malloc
  000cc	8b f0		 mov	 esi, eax
  000ce	83 c4 04	 add	 esp, 4
  000d1	89 35 00 00 00
	00		 mov	 DWORD PTR _DecompressedData, esi

; 707  : 	if (DecompressedData == NULL)

  000d7	85 f6		 test	 esi, esi
  000d9	75 16		 jne	 SHORT $LN9@SelfExtrac

; 708  : 	{
; 709  : 		Error ("ERR_MEM_ALLOC");

  000db	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@
  000e0	e8 00 00 00 00	 call	 _Error

; 775  : 	free (compressedData);

  000e5	83 c4 04	 add	 esp, 4

; 776  : 	return FALSE;

  000e8	33 c0		 xor	 eax, eax
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx

; 777  : }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
$LN9@SelfExtrac:

; 710  : 		return FALSE;
; 711  : 	}
; 712  : 
; 713  : 	bufPos = DecompressedData;
; 714  : 	bufEndPos = bufPos + uncompressedLen - 1;
; 715  : 
; 716  : 	compressedData = LoadFileBlock (path, filePos, compressedLen);

  000f1	ff 75 fc	 push	 DWORD PTR _compressedLen$[ebp]
  000f4	8b 45 f4	 mov	 eax, DWORD PTR _filePos$1$[ebp]
  000f7	8b 7d f8	 mov	 edi, DWORD PTR _uncompressedLen$[ebp]
  000fa	99		 cdq
  000fb	4f		 dec	 edi
  000fc	52		 push	 edx
  000fd	50		 push	 eax
  000fe	ff 75 08	 push	 DWORD PTR _path$[ebp]
  00101	03 fe		 add	 edi, esi
  00103	89 7d f0	 mov	 DWORD PTR _bufEndPos$1$[ebp], edi
  00106	e8 00 00 00 00	 call	 _LoadFileBlock
  0010b	83 c4 10	 add	 esp, 16			; 00000010H
  0010e	89 45 f4	 mov	 DWORD PTR _compressedData$1$[ebp], eax

; 717  : 
; 718  : 	if (compressedData == NULL)

  00111	85 c0		 test	 eax, eax
  00113	75 27		 jne	 SHORT $LN10@SelfExtrac

; 719  : 	{
; 720  : 		free (DecompressedData);

  00115	ff 35 00 00 00
	00		 push	 DWORD PTR _DecompressedData
  0011b	e8 00 00 00 00	 call	 _free

; 721  : 		DecompressedData = NULL;
; 722  : 
; 723  : 		Error ("CANNOT_READ_FROM_PACKAGE");

  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@
  00125	89 1d 00 00 00
	00		 mov	 DWORD PTR _DecompressedData, ebx
  0012b	e8 00 00 00 00	 call	 _Error
  00130	83 c4 08	 add	 esp, 8

; 776  : 	return FALSE;

  00133	33 c0		 xor	 eax, eax
  00135	5f		 pop	 edi
  00136	5e		 pop	 esi
  00137	5b		 pop	 ebx

; 777  : }

  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c3		 ret	 0
$LN10@SelfExtrac:

; 724  : 		return FALSE;
; 725  : 	}
; 726  : 
; 727  : 	// Decompress the data
; 728  : 	if (DecompressBuffer (DecompressedData, compressedData, compressedLen) != uncompressedLen)

  0013c	ff 75 fc	 push	 DWORD PTR _compressedLen$[ebp]
  0013f	50		 push	 eax
  00140	ff 35 00 00 00
	00		 push	 DWORD PTR _DecompressedData
  00146	e8 00 00 00 00	 call	 _DecompressDeflatedData
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014e	3b 45 f8	 cmp	 eax, DWORD PTR _uncompressedLen$[ebp]
  00151	0f 85 c6 00 00
	00		 jne	 $LN22@SelfExtrac

; 729  : 	{
; 730  : 		Error ("DIST_PACKAGE_CORRUPTED");
; 731  : 		goto sem_end;
; 732  : 	}
; 733  : 
; 734  : 	while (bufPos <= bufEndPos && fileNo < NBR_COMPRESSED_FILES)

  00157	3b f7		 cmp	 esi, edi
  00159	0f 87 be 00 00
	00		 ja	 $LN22@SelfExtrac
  0015f	33 ff		 xor	 edi, edi
$LL2@SelfExtrac:
  00161	83 ff 78	 cmp	 edi, 120		; 00000078H
  00164	0f 83 9c 00 00
	00		 jae	 $LN13@SelfExtrac

; 735  : 	{
; 736  : 		// Filename length
; 737  : 		Decompressed_Files[fileNo].fileNameLength = mgetWord (bufPos);

  0016a	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  0016d	83 c6 02	 add	 esi, 2
  00170	c1 e1 08	 shl	 ecx, 8
  00173	0f b6 46 ff	 movzx	 eax, BYTE PTR [esi-1]
  00177	0b c8		 or	 ecx, eax

; 738  : 
; 739  : 		// Filename
; 740  : 		Decompressed_Files[fileNo].fileName = bufPos;

  00179	89 b7 00 00 00
	00		 mov	 DWORD PTR _Decompressed_Files[edi], esi

; 741  : 		bufPos += Decompressed_Files[fileNo].fileNameLength;
; 742  : 
; 743  : 		// CRC-32 of the file
; 744  : 		Decompressed_Files[fileNo].crc = mgetLong (bufPos);

  0017f	03 f1		 add	 esi, ecx
  00181	89 8f 04 00 00
	00		 mov	 DWORD PTR _Decompressed_Files[edi+4], ecx
  00187	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  0018a	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  0018e	c1 e1 08	 shl	 ecx, 8
  00191	0b c8		 or	 ecx, eax
  00193	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00197	c1 e1 08	 shl	 ecx, 8
  0019a	0b c8		 or	 ecx, eax
  0019c	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  001a0	c1 e1 08	 shl	 ecx, 8

; 745  : 
; 746  : 		// File length
; 747  : 		Decompressed_Files[fileNo].fileLength = mgetLong (bufPos);

  001a3	83 c6 08	 add	 esi, 8
  001a6	0b c8		 or	 ecx, eax
  001a8	89 8f 08 00 00
	00		 mov	 DWORD PTR _Decompressed_Files[edi+8], ecx
  001ae	0f b6 4e fc	 movzx	 ecx, BYTE PTR [esi-4]
  001b2	0f b6 46 fd	 movzx	 eax, BYTE PTR [esi-3]
  001b6	c1 e1 08	 shl	 ecx, 8
  001b9	0b c8		 or	 ecx, eax
  001bb	0f b6 46 fe	 movzx	 eax, BYTE PTR [esi-2]
  001bf	c1 e1 08	 shl	 ecx, 8
  001c2	0b c8		 or	 ecx, eax
  001c4	0f b6 46 ff	 movzx	 eax, BYTE PTR [esi-1]
  001c8	c1 e1 08	 shl	 ecx, 8
  001cb	0b c8		 or	 ecx, eax

; 748  : 
; 749  : 		// File content
; 750  : 		Decompressed_Files[fileNo].fileContent = bufPos;

  001cd	89 b7 10 00 00
	00		 mov	 DWORD PTR _Decompressed_Files[edi+16], esi

; 751  : 		bufPos += Decompressed_Files[fileNo].fileLength;

  001d3	8b c1		 mov	 eax, ecx
  001d5	89 8f 0c 00 00
	00		 mov	 DWORD PTR _Decompressed_Files[edi+12], ecx

; 752  : 
; 753  : 		// Verify CRC-32 of the file (to verify that it didn't get corrupted while creating the solid archive).
; 754  : 		if (Decompressed_Files[fileNo].crc 
; 755  : 			!= GetCrc32 (Decompressed_Files[fileNo].fileContent, Decompressed_Files[fileNo].fileLength))

  001db	50		 push	 eax
  001dc	ff b7 10 00 00
	00		 push	 DWORD PTR _Decompressed_Files[edi+16]
  001e2	03 f0		 add	 esi, eax
  001e4	e8 00 00 00 00	 call	 _GetCrc32
  001e9	83 c4 08	 add	 esp, 8
  001ec	39 87 08 00 00
	00		 cmp	 DWORD PTR _Decompressed_Files[edi+8], eax
  001f2	75 29		 jne	 SHORT $LN22@SelfExtrac

; 756  : 		{
; 757  : 			Error ("DIST_PACKAGE_CORRUPTED");
; 758  : 			goto sem_end;
; 759  : 		}
; 760  : 
; 761  : 		fileNo++;

  001f4	43		 inc	 ebx
  001f5	83 c7 14	 add	 edi, 20			; 00000014H
  001f8	3b 75 f0	 cmp	 esi, DWORD PTR _bufEndPos$1$[ebp]
  001fb	0f 86 60 ff ff
	ff		 jbe	 $LL2@SelfExtrac

; 762  : 	}
; 763  : 
; 764  : 	if (fileNo < NBR_COMPRESSED_FILES)

  00201	83 fb 06	 cmp	 ebx, 6
  00204	72 17		 jb	 SHORT $LN22@SelfExtrac
$LN13@SelfExtrac:

; 767  : 		goto sem_end;
; 768  : 	}
; 769  : 
; 770  : 	free (compressedData);

  00206	ff 75 f4	 push	 DWORD PTR _compressedData$1$[ebp]
  00209	e8 00 00 00 00	 call	 _free
  0020e	83 c4 04	 add	 esp, 4

; 771  : 	return TRUE;

  00211	b8 01 00 00 00	 mov	 eax, 1
  00216	5f		 pop	 edi
  00217	5e		 pop	 esi
  00218	5b		 pop	 ebx

; 777  : }

  00219	8b e5		 mov	 esp, ebp
  0021b	5d		 pop	 ebp
  0021c	c3		 ret	 0
$LN22@SelfExtrac:

; 765  : 	{
; 766  : 		Error ("DIST_PACKAGE_CORRUPTED");

  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@
  00222	e8 00 00 00 00	 call	 _Error
  00227	83 c4 04	 add	 esp, 4
$sem_end$28:

; 772  : 
; 773  : sem_end:
; 774  : 	FreeAllFileBuffers();

  0022a	e8 00 00 00 00	 call	 _FreeAllFileBuffers

; 775  : 	free (compressedData);

  0022f	ff 75 f4	 push	 DWORD PTR _compressedData$1$[ebp]
  00232	e8 00 00 00 00	 call	 _free
  00237	83 c4 04	 add	 esp, 4

; 776  : 	return FALSE;

  0023a	33 c0		 xor	 eax, eax
  0023c	5f		 pop	 edi
  0023d	5e		 pop	 esi
  0023e	5b		 pop	 ebx

; 777  : }

  0023f	8b e5		 mov	 esp, ebp
  00241	5d		 pop	 ebp
  00242	c3		 ret	 0
_SelfExtractInMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\setup\selfextract.c
;	COMDAT _SelfExtractStartupInit
_TEXT	SEGMENT
_SelfExtractStartupInit PROC				; COMDAT

; 56   : 	DeobfuscateMagEndMarker ();

  00000	33 c0		 xor	 eax, eax
$LL6@SelfExtrac:
  00002	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ??_C@_0BA@LOGCKKME@T?1C?1I?1N?1S?1C?1R?1C?$AA@[eax]
  00008	8b d0		 mov	 edx, eax
  0000a	d1 ea		 shr	 edx, 1
  0000c	83 c0 02	 add	 eax, 2
  0000f	88 8a 00 00 00
	00		 mov	 BYTE PTR _MagEndMarker[edx], cl
  00015	83 f8 10	 cmp	 eax, 16			; 00000010H
  00018	72 e8		 jb	 SHORT $LL6@SelfExtrac
  0001a	99		 cdq
  0001b	2b c2		 sub	 eax, edx
  0001d	d1 f8		 sar	 eax, 1
  0001f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00022	73 08		 jae	 SHORT $LN8@SelfExtrac
  00024	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _MagEndMarker[eax], 0

; 57   : }

  0002b	c3		 ret	 0
$LN8@SelfExtrac:

; 56   : 	DeobfuscateMagEndMarker ();

  0002c	e9 00 00 00 00	 jmp	 ___report_rangecheckfailure
_SelfExtractStartupInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1960 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1961 :     int _Result;
; 1962 :     va_list _ArgList;
; 1963 :     __crt_va_start(_ArgList, _Format);
; 1964 : #pragma warning(suppress:28719)    // __WARNING_BANNED_API_USAGE
; 1965 :     _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1966 :     __crt_va_end(_ArgList);
; 1967 :     return _Result;
; 1968 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1406 :     #pragma warning(push)
; 1407 :     #pragma warning(disable: 4996) // Deprecation
; 1408 :     return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1409 :     #pragma warning(pop)
; 1410 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __snwprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snwprintf PROC					; COMDAT

; 1673 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1674 :     int _Result;
; 1675 :     va_list _ArgList;
; 1676 :     __crt_va_start(_ArgList, _Format);
; 1677 : 
; 1678 :     #pragma warning(push)
; 1679 :     #pragma warning(disable: 4996) // Deprecation
; 1680 :     _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vswprintf
  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1681 :     #pragma warning(pop)
; 1682 : 
; 1683 :     __crt_va_end(_ArgList);
; 1684 :     return _Result;
; 1685 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snwprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vsnwprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnwprintf_l PROC					; COMDAT

; 1056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1057 :     int const _Result = __stdio_common_vswprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vswprintf

; 1058 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1059 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1060 : 
; 1061 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1062 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnwprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
