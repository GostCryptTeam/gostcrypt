<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gostcrypt: Common/Inflate.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Gostcrypt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4ab6b4cc6a7edbff49100e9123df213f.html">Common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Inflate.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inflate codes, decompress inflate and inflate a block.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;inflate.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Inflate.c:</div>
<div class="dyncontent">
<div class="center"><img src="_inflate_8c__incl.png" border="0" usemap="#_common_2_inflate_8c" alt=""/></div>
<map name="_common_2_inflate_8c" id="_common_2_inflate_8c">
<area shape="rect" id="node2" href="_inflate_8h_source.html" title="inflate.h" alt="" coords="51,80,117,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7d76837255cc0896396e457c40795a93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_inflate_8c.html#a7d76837255cc0896396e457c40795a93">INFMOD</a>&#160;&#160;&#160;/* tell inflate.h to include code to be compiled */</td></tr>
<tr class="separator:a7d76837255cc0896396e457c40795a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c6b59ca21f041b23efbb9845cc4e32"><td class="memItemLeft" align="right" valign="top"><a id="a01c6b59ca21f041b23efbb9845cc4e32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>wsize</b>&#160;&#160;&#160;WSIZE       /* wsize is a constant */</td></tr>
<tr class="separator:a01c6b59ca21f041b23efbb9845cc4e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbafe3dcd659cd7ff763ec43ebcfa0dd"><td class="memItemLeft" align="right" valign="top"><a id="afbafe3dcd659cd7ff763ec43ebcfa0dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MESSAGE</b>(str,  len,  flag)&#160;&#160;&#160;fprintf(stderr,(char *)(str))</td></tr>
<tr class="separator:afbafe3dcd659cd7ff763ec43ebcfa0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bbe97269cf8304b452a4d472dba191"><td class="memItemLeft" align="right" valign="top"><a id="a93bbe97269cf8304b452a4d472dba191"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Trace</b>(x)</td></tr>
<tr class="separator:a93bbe97269cf8304b452a4d472dba191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afc4cfe7d1af63e72b1e88b34c8b520"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_inflate_8c.html#a4afc4cfe7d1af63e72b1e88b34c8b520">CHECK_EOF</a>&#160;&#160;&#160;/* default as of 5.13/5.2 */</td></tr>
<tr class="separator:a4afc4cfe7d1af63e72b1e88b34c8b520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3731a4aa4bb04481dc95069bbfb7156"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>NEEDBITS</b>(n)</td></tr>
<tr class="separator:ab3731a4aa4bb04481dc95069bbfb7156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75de43cc4baf11259d310b999e54c965"><td class="memItemLeft" align="right" valign="top"><a id="a75de43cc4baf11259d310b999e54c965"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DUMPBITS</b>(n)&#160;&#160;&#160;{b&gt;&gt;=(n);k-=(n);}</td></tr>
<tr class="separator:a75de43cc4baf11259d310b999e54c965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cd58bc28249a2827ecb52e0ff15ac3"><td class="memItemLeft" align="right" valign="top"><a id="a04cd58bc28249a2827ecb52e0ff15ac3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BMAX</b>&#160;&#160;&#160;16         /* maximum bit length of any code (16 for explode) */</td></tr>
<tr class="separator:a04cd58bc28249a2827ecb52e0ff15ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0909f9743b77b5e83d3e8e1d61989b10"><td class="memItemLeft" align="right" valign="top"><a id="a0909f9743b77b5e83d3e8e1d61989b10"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>N_MAX</b>&#160;&#160;&#160;288       /* maximum number of <a class="el" href="_decompressor_8c.html#afce25d8162a22b60b1c6124eeac0e37e">codes</a> in any set */</td></tr>
<tr class="separator:a0909f9743b77b5e83d3e8e1d61989b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a82ed4d9cfc2583019bf41b9f9e198e34"><td class="memItemLeft" align="right" valign="top"><a id="a82ed4d9cfc2583019bf41b9f9e198e34"></a>
int <a class="el" href="_inflate_8c.html#a8d36cae246bb8a9e5fec9f551a843977">inflate_codes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OF</b> ((__GPRO__ struct <a class="el" href="structhuft.html">huft</a> *tl, struct <a class="el" href="structhuft.html">huft</a> *td, int bl, int bd))</td></tr>
<tr class="separator:a82ed4d9cfc2583019bf41b9f9e198e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d36cae246bb8a9e5fec9f551a843977"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_inflate_8c.html#a8d36cae246bb8a9e5fec9f551a843977">inflate_codes</a> (__G__ tl, td, bl, bd) w</td></tr>
<tr class="memdesc:a8d36cae246bb8a9e5fec9f551a843977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inflate the coded data: Make local copy of global, get length of block to copy, decode distance of block to copy, do the copy, restore the globals from the locals.  <a href="#a8d36cae246bb8a9e5fec9f551a843977">More...</a><br /></td></tr>
<tr class="separator:a8d36cae246bb8a9e5fec9f551a843977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdafe3be7e00ce3d4f0cb50a9a5eb39"><td class="memItemLeft" align="right" valign="top"><a id="a8fdafe3be7e00ce3d4f0cb50a9a5eb39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>while</b> (1)</td></tr>
<tr class="separator:a8fdafe3be7e00ce3d4f0cb50a9a5eb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab90c65f96a7052e51f2972d1989bd2"><td class="memItemLeft" align="right" valign="top"><a id="a5ab90c65f96a7052e51f2972d1989bd2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (if(==0) return inflate_stored(__G) t==2)</td></tr>
<tr class="separator:a5ab90c65f96a7052e51f2972d1989bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76887b80d42e0722f22efe877c9983e"><td class="memItemLeft" align="right" valign="top"><a id="ad76887b80d42e0722f22efe877c9983e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>inflate_free</b> (__G)</td></tr>
<tr class="separator:ad76887b80d42e0722f22efe877c9983e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac3baa7c01f9453c5a2521be7ef3c66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_inflate_8c.html#aaac3baa7c01f9453c5a2521be7ef3c66">huft_build</a> (__GDEF ZCONST unsigned *b, unsigned n, unsigned s, ZCONST ush *d, ZCONST ush *e, struct <a class="el" href="structhuft.html">huft</a> **t, int *m)</td></tr>
<tr class="memdesc:aaac3baa7c01f9453c5a2521be7ef3c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. The code with value 256 is special, and the tables are constructed so that no bits beyond that code are fetched when that code is decoded.  <a href="#aaac3baa7c01f9453c5a2521be7ef3c66">More...</a><br /></td></tr>
<tr class="separator:aaac3baa7c01f9453c5a2521be7ef3c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45d17d87f09fb609612f19c964b7984"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_inflate_8c.html#af45d17d87f09fb609612f19c964b7984">huft_free</a> (struct <a class="el" href="structhuft.html">huft</a> *t)</td></tr>
<tr class="memdesc:af45d17d87f09fb609612f19c964b7984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the malloc'ed tables built by <a class="el" href="_inflate_8c.html#aaac3baa7c01f9453c5a2521be7ef3c66" title="Given a list of code lengths and a maximum table size, make a set of tables to decode that set of cod...">huft_build()</a>, which makes a linked list of the tables it made, with the links in a dummy first entry of each table.  <a href="#af45d17d87f09fb609612f19c964b7984">More...</a><br /></td></tr>
<tr class="separator:af45d17d87f09fb609612f19c964b7984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ac38e3e4a82422701f49531882d5cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_inflate_8c.html#a59ac38e3e4a82422701f49531882d5cc">DecompressDeflatedData</a> (char *out, char *in, int inLength)</td></tr>
<tr class="memdesc:a59ac38e3e4a82422701f49531882d5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main public function. Decompresses raw data compressed using the DEFLATE algorithm (RFC 1951 - e.g. zlib, gzip). Returns 0 if decompression fails or, if successful, returns the size of the decompressed data.  <a href="#a59ac38e3e4a82422701f49531882d5cc">More...</a><br /></td></tr>
<tr class="separator:a59ac38e3e4a82422701f49531882d5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2616fe56c6c0d284768ae53f69efed4b"><td class="memItemLeft" align="right" valign="top"><a id="a2616fe56c6c0d284768ae53f69efed4b"></a>
<a class="el" href="struct_g__struct.html">G_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><b>G</b></td></tr>
<tr class="separator:a2616fe56c6c0d284768ae53f69efed4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd7e2464e60c65fa55fb0716689090c"><td class="memItemLeft" align="right" valign="top"><a id="afcd7e2464e60c65fa55fb0716689090c"></a>
uch&#160;</td><td class="memItemRight" valign="bottom"><b>redirSlide</b> [WSIZE]</td></tr>
<tr class="separator:afcd7e2464e60c65fa55fb0716689090c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d494dcf3fd9efd6c0296a90a1f50fc2"><td class="memItemLeft" align="right" valign="top">ZCONST ush near&#160;</td><td class="memItemRight" valign="bottom"><b>mask_bits</b> []</td></tr>
<tr class="separator:a8d494dcf3fd9efd6c0296a90a1f50fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad64aacc6741f76d9561195fc2a7b8f3"><td class="memItemLeft" align="right" valign="top"><a id="aad64aacc6741f76d9561195fc2a7b8f3"></a>
__GDEF struct <a class="el" href="structhuft.html">huft</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>tl</b></td></tr>
<tr class="separator:aad64aacc6741f76d9561195fc2a7b8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4321d070a30d5540b4019b3f0ea18a26"><td class="memItemLeft" align="right" valign="top"><a id="a4321d070a30d5540b4019b3f0ea18a26"></a>
__GDEF struct <a class="el" href="structhuft.html">huft</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>td</b></td></tr>
<tr class="separator:a4321d070a30d5540b4019b3f0ea18a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb63accab286c308a0f783f0afe8f32a"><td class="memItemLeft" align="right" valign="top"><a id="abb63accab286c308a0f783f0afe8f32a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>bl</b></td></tr>
<tr class="separator:abb63accab286c308a0f783f0afe8f32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36d1100473c16852c1b64d1917454a4"><td class="memItemLeft" align="right" valign="top"><a id="ab36d1100473c16852c1b64d1917454a4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>bd</b></td></tr>
<tr class="separator:ab36d1100473c16852c1b64d1917454a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079528bb7fc5a12e84dee1bbbe451563"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>n</b></td></tr>
<tr class="separator:a079528bb7fc5a12e84dee1bbbe451563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97cf1b8363ec7aebe0d49f84d8ee68b"><td class="memItemLeft" align="right" valign="top"><a id="af97cf1b8363ec7aebe0d49f84d8ee68b"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>d</b></td></tr>
<tr class="separator:af97cf1b8363ec7aebe0d49f84d8ee68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2ee9ec393223c855b9595e52382ac0"><td class="memItemLeft" align="right" valign="top"><a id="aab2ee9ec393223c855b9595e52382ac0"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>w</b></td></tr>
<tr class="separator:aab2ee9ec393223c855b9595e52382ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccc9105df5383111407fd5b41255e23"><td class="memItemLeft" align="right" valign="top"><a id="aaccc9105df5383111407fd5b41255e23"></a>
struct <a class="el" href="structhuft.html">huft</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>t</b> = (unsigned)b &amp; 3</td></tr>
<tr class="separator:aaccc9105df5383111407fd5b41255e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b8016ea7f5d48a5da241d6de64e4ce"><td class="memItemLeft" align="right" valign="top"><a id="a68b8016ea7f5d48a5da241d6de64e4ce"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ml</b> = mask_bits[bl]</td></tr>
<tr class="separator:a68b8016ea7f5d48a5da241d6de64e4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29785b126ac854eae64708b0b52c413a"><td class="memItemLeft" align="right" valign="top"><a id="a29785b126ac854eae64708b0b52c413a"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>md</b> = mask_bits[bd]</td></tr>
<tr class="separator:a29785b126ac854eae64708b0b52c413a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76181755c4a6b7250805f0e87a68102"><td class="memItemLeft" align="right" valign="top"><a id="ac76181755c4a6b7250805f0e87a68102"></a>
register ulg&#160;</td><td class="memItemRight" valign="bottom"><b>b</b> = G.bb</td></tr>
<tr class="separator:ac76181755c4a6b7250805f0e87a68102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad120517d0e9ed6741006993b9956af5d"><td class="memItemLeft" align="right" valign="top"><a id="ad120517d0e9ed6741006993b9956af5d"></a>
register unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>k</b> = G.bk</td></tr>
<tr class="separator:ad120517d0e9ed6741006993b9956af5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed41a5e642c36c2363312dd465fc40f1"><td class="memItemLeft" align="right" valign="top"><a id="aed41a5e642c36c2363312dd465fc40f1"></a>
G&#160;</td><td class="memItemRight" valign="bottom"><b>wp</b> = w</td></tr>
<tr class="separator:aed41a5e642c36c2363312dd465fc40f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259f7522cd7302fa1523e2a43ec51595"><td class="memItemLeft" align="right" valign="top"><a id="a259f7522cd7302fa1523e2a43ec51595"></a>
G&#160;</td><td class="memItemRight" valign="bottom"><b>bb</b> = b</td></tr>
<tr class="separator:a259f7522cd7302fa1523e2a43ec51595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf912ef45677c37b8a7f3540d092407"><td class="memItemLeft" align="right" valign="top"><a id="a2bf912ef45677c37b8a7f3540d092407"></a>
G&#160;</td><td class="memItemRight" valign="bottom"><b>bk</b> = k</td></tr>
<tr class="separator:a2bf912ef45677c37b8a7f3540d092407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9717e7bbecb906637e86cef6da3d83c2"><td class="memItemLeft" align="right" valign="top"><a id="a9717e7bbecb906637e86cef6da3d83c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b></td></tr>
<tr class="separator:a9717e7bbecb906637e86cef6da3d83c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c880a962c4056c39079e5e8a97a764"><td class="memItemLeft" align="right" valign="top"><a id="ab4c880a962c4056c39079e5e8a97a764"></a>
*&#160;</td><td class="memItemRight" valign="bottom"><b>e</b> = (int)b &amp; 1</td></tr>
<tr class="separator:ab4c880a962c4056c39079e5e8a97a764"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Inflate codes, decompress inflate and inflate a block. </p>
<dl class="section version"><dt>Version</dt><dd>1.3.1 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/01/2017 </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a4afc4cfe7d1af63e72b1e88b34c8b520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afc4cfe7d1af63e72b1e88b34c8b520">&#9670;&nbsp;</a></span>CHECK_EOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_EOF&#160;&#160;&#160;/* default as of 5.13/5.2 */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macros for inflate() bit peeking and grabbing. The usage is: </p><pre class="fragment"> NEEDBITS(j)
 x = b &amp; mask_bits[j];
 DUMPBITS(j)
</pre><p>where NEEDBITS makes sure that b has at least j bits in it, and DUMPBITS removes the bits from b. The macros use the variable k for the number of bits in b. Normally, b and k are register variables for speed and are initialized at the begining of a routine that uses these macros from a global bit buffer and count.</p>
<p>In order to not ask for more bits than there are in the compressed stream, the Huffman tables are constructed to only ask for just enough bits to make up the end-of-block code (value 256). Then no bytes need to be "returned" to the buffer at the end of the last block. See the <a class="el" href="_inflate_8c.html#aaac3baa7c01f9453c5a2521be7ef3c66" title="Given a list of code lengths and a maximum table size, make a set of tables to decode that set of cod...">huft_build()</a> routine. </p>

</div>
</div>
<a id="a7d76837255cc0896396e457c40795a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d76837255cc0896396e457c40795a93">&#9670;&nbsp;</a></span>INFMOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INFMOD&#160;&#160;&#160;/* tell inflate.h to include code to be compiled */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="_inflate_8c.html" title="Inflate codes, decompress inflate and inflate a block. ">inflate.c</a> &ndash; put in the public domain by Mark Adler</p>
<p>Decompresses raw data compressed using the DEFLATE algorithm (RFC 1951)</p>
<p>You can do whatever you like with this source file, though I would prefer that if you modify it and redistribute it that you include comments to that effect with your name and the date. Thank you.</p>
<p>History: vers date who what </p><hr/>
<p> a ~~ Feb 92 M. Adler used full (large, one-step) lookup table b1 21 Mar 92 M. Adler first version with partial lookup tables b2 21 Mar 92 M. Adler fixed bug in fixed-code blocks b3 22 Mar 92 M. Adler sped up match copies, cleaned up some b4 25 Mar 92 M. Adler added prototypes; removed window[] (now is the responsibility of unzip.h&ndash;also changed name to slide[]), so needs diffs for unzip.c and unzip.h (this allows compiling in the small model on MSDOS); fixed cast of q in <a class="el" href="_inflate_8c.html#aaac3baa7c01f9453c5a2521be7ef3c66" title="Given a list of code lengths and a maximum table size, make a set of tables to decode that set of cod...">huft_build()</a>; b5 26 Mar 92 M. Adler got rid of unintended macro recursion. b6 27 Mar 92 M. Adler got rid of nextbyte() routine. fixed bug in inflate_fixed(). c1 30 Mar 92 M. Adler removed lbits, dbits environment variables. changed BMAX to 16 for explode. Removed OUTB usage, and replaced it with flush()&ndash; this was a 20% speed improvement! Added an explode.c (to replace unimplod.c) that uses the huft routines here. Removed register union. c2 4 Apr 92 M. Adler fixed bug for file sizes a multiple of 32k. c3 10 Apr 92 M. Adler reduced memory of code tables made by huft_build significantly (factor of two to three). c4 15 Apr 92 M. Adler added NOMEMCPY do kill use of memcpy(). worked around a Turbo C optimization bug.</p>
<p>c5 21 Apr 92 M. Adler added the WSIZE #define to allow reducing the 32K window size for specialized applications. c6 31 May 92 M. Adler added some typecasts to eliminate warnings c7 27 Jun 92 G. Roelofs added some more typecasts (444: MSC bug). c8 5 Oct 92 J-l. Gailly added ifdef'd code to deal with PKZIP bug. c9 9 Oct 92 M. Adler removed a memory error message (~line 416). c10 17 Oct 92 G. Roelofs changed ULONG/UWORD/byte to ulg/ush/uch, removed old inflate, renamed inflate_entry to inflate, added Mark's fix to a comment. c10.5 14 Dec 92 M. Adler fix up error messages for incomplete trees. c11 2 Jan 93 M. Adler fixed bug in detection of incomplete tables, and removed assumption that EOB is the longest code (bad assumption). c12 3 Jan 93 M. Adler make tables for fixed blocks only once. c13 5 Jan 93 M. Adler allow all zero length codes (pkzip 2.04c outputs one zero length code for an empty distance tree). c14 12 Mar 93 M. Adler made <a class="el" href="_inflate_8c.html" title="Inflate codes, decompress inflate and inflate a block. ">inflate.c</a> standalone with the introduction of <a class="el" href="_inflate_8h_source.html">inflate.h</a>. c14b 16 Jul 93 G. Roelofs added (unsigned) typecast to w at 470. c14c 19 Jul 93 J. Bush changed v[N_MAX], l[288], ll[28x+3x] arrays to static for Amiga. c14d 13 Aug 93 J-l. Gailly de-complicatified Mark's c[*p++]++ thing. c14e 8 Oct 93 G. Roelofs changed memset() to memzero(). c14f 22 Oct 93 G. Roelofs renamed quietflg to qflag; made Trace() conditional; added inflate_free(). c14g 28 Oct 93 G. Roelofs changed l/(lx+1) macro to pointer (Cray bug) c14h 7 Dec 93 C. Ghisler <a class="el" href="_inflate_8c.html#aaac3baa7c01f9453c5a2521be7ef3c66" title="Given a list of code lengths and a maximum table size, make a set of tables to decode that set of cod...">huft_build()</a> optimizations. c14i 9 Jan 94 A. Verheijen set fixed_t{d,l} to NULL after freeing; G. Roelofs check NEXTBYTE macro for EOF. c14j 23 Jan 94 G. Roelofs removed Ghisler "optimizations"; ifdef'd EOF check. c14k 27 Feb 94 G. Roelofs added some typecasts to avoid warnings. c14l 9 Apr 94 G. Roelofs fixed split comments on preprocessor lines to avoid bug in Encore compiler. c14m 7 Jul 94 P. Kienitz modified to allow assembler version of <a class="el" href="_inflate_8c.html#a8d36cae246bb8a9e5fec9f551a843977" title="Inflate the coded data: Make local copy of global, get length of block to copy, decode distance of bl...">inflate_codes()</a> (define ASM_INFLATECODES) c14n 22 Jul 94 G. Roelofs changed fprintf to macro for DLL versions c14o 23 Aug 94 C. Spieler added a newline to a debug statement; G. Roelofs added another typecast to avoid MSC warning c14p 4 Oct 94 G. Roelofs added (voidp *) cast to free() argument c14q 30 Oct 94 G. Roelofs changed fprintf macro to MESSAGE() c14r 1 Nov 94 G. Roelofs fixed possible redefinition of CHECK_EOF c14s 7 May 95 S. Maxwell OS/2 DLL globals stuff incorporated; P. Kienitz "fixed" ASM_INFLATECODES macro/prototype c14t 18 Aug 95 G. Roelofs added inflate() to use zlib functions; changed voidp to zvoid; moved <a class="el" href="_inflate_8c.html#aaac3baa7c01f9453c5a2521be7ef3c66" title="Given a list of code lengths and a maximum table size, make a set of tables to decode that set of cod...">huft_build()</a> and <a class="el" href="_inflate_8c.html#af45d17d87f09fb609612f19c964b7984" title="Free the malloc&#39;ed tables built by huft_build(), which makes a linked list of the tables it made...">huft_free()</a> to end of file c14u 1 Oct 95 G. Roelofs moved G into definition of MESSAGE macro c14v 8 Nov 95 P. Kienitz changed ASM_INFLATECODES to use a regular call with <b>G</b> instead of a macro c15 3 Aug 96 M. Adler fixed bomb-bug on random input data (Adobe) c15b 24 Aug 96 M. Adler more fixes for random input data c15c 28 Mar 97 G. Roelofs changed USE_ZLIB fatal exit code from PK_MEM2 to PK_MEM3 c16 20 Apr 97 J. Altman added memzero(v[]) in <a class="el" href="_inflate_8c.html#aaac3baa7c01f9453c5a2521be7ef3c66" title="Given a list of code lengths and a maximum table size, make a set of tables to decode that set of cod...">huft_build()</a> c16b 29 Mar 98 C. Spieler modified DLL code for slide redirection</p>
<p>fork 12 Dec 07 Adapted for TrueCrypt</p>
<p>Inflate deflated (PKZIP's method 8 compressed) data. The compression method searches for as much of the current string of bytes (up to a length of 258) in the previous 32K bytes. If it doesn't find any matches (of at least length 3), it codes the next byte. Otherwise, it codes the length of the matched string and its distance backwards from the current position. There is a single Huffman code that codes both single bytes (called "literals") and match lengths. A second Huffman code codes the distance information, which follows a length code. Each length or distance code actually represents a base value and a number of "extra" (sometimes zero) bits to get to add to the base value. At the end of each deflated block is a special end-of-block (EOB) literal/ length code. The decoding process is basically: get a literal/length code; if EOB then done; if a literal, emit the decoded byte; if a length then get the distance and emit the referred-to bytes from the sliding window of previously emitted data.</p>
<p>There are (currently) three kinds of inflate blocks: stored, fixed, and dynamic. The compressor outputs a chunk of data at a time and decides which method to use on a chunk-by-chunk basis. A chunk might typically be 32K to 64K, uncompressed. If the chunk is uncompressible, then the "stored" method is used. In this case, the bytes are simply stored as is, eight bits per byte, with none of the above coding. The bytes are preceded by a count, since there is no longer an EOB code.</p>
<p>If the data are compressible, then either the fixed or dynamic methods are used. In the dynamic method, the compressed data are preceded by an encoding of the literal/length and distance Huffman codes that are to be used to decode this block. The representation is itself Huffman coded, and so is preceded by a description of that code. These code descriptions take up a little space, and so for small blocks, there is a predefined set of codes, called the fixed codes. The fixed method is used if the block ends up smaller that way (usually for quite small chunks); otherwise the dynamic method is used. In the latter case, the codes are customized to the probabilities in the current block and so can code it much better than the pre-determined fixed codes can.</p>
<p>The Huffman codes themselves are decoded using a multi-level table lookup, in order to maximize the speed of decoding plus the speed of building the decoding tables. See the comments below that precede the lbits and dbits tuning parameters.</p>
<p>GRR: return values(?) 0 OK 1 incomplete table 2 bad input 3 not enough memory</p>
<p>Notes beyond the 1.93a appnote.txt:</p>
<ol type="1">
<li>Distance pointers never point before the beginning of the output stream.</li>
<li>Distance pointers can point back across blocks, up to 32k away.</li>
<li>There is an implied maximum of 7 bits for the bit length table and 15 bits for the actual data.</li>
<li>If only one code exists, then it is encoded using one bit. (Zero would be more efficient, but perhaps a little confusing.) If two codes exist, they are coded using one bit each (0 and 1).</li>
<li>There is no way of sending zero distance codes&ndash;a dummy must be sent if there are none. (History: a pre 2.0 version of PKZIP would store blocks with no distance codes, but this was discovered to be too harsh a criterion.) Valid only for 1.93a. 2.04c does allow zero distance codes, which is sent as one code of zero bits in length.</li>
<li>There are up to 286 literal/length codes. Code 256 represents the end-of-block. Note however that the static length tree defines 288 codes just to fill out the Huffman codes. Codes 286 and 287 cannot be used though, since there is no length base or extra bits defined for them. Similarily, there are up to 30 distance codes. However, static trees define 32 codes (all 5 bits) to fill out the Huffman codes, but the last two had better not show up in the data.</li>
<li>Unzip can check dynamic Huffman blocks for complete code sets. The exception is that a single code would not be complete (see #4).</li>
<li>The five bits following the block type is really the number of literal codes sent minus 257.</li>
<li>Length codes 8,16,16 are interpreted as 13 length codes of 8 bits (1+6+6). Therefore, to output three times the length, you output three codes (1+1+1), whereas to output four times the same length, you only need two codes (1+3). Hmm.</li>
<li>In the tree reconstruction algorithm, Code = Code + Increment only if BitLength(i) is not zero. (Pretty obvious.)</li>
<li>Correction: 4 Bits: # of Bit Length codes - 4 (4 - 19)</li>
<li>Note: length code 284 can represent 227-258, but length code 285 really is 258. The last length deserves its own, short code since it gets used a lot in very redundant files. The length 258 is special since 258 - 3 (the min match length) is 255.</li>
<li>The literal/length and distance code bit lengths are read as a single stream of lengths. It is possible (and advantageous) for a repeat code (16, 17, or 18) to go across the boundary between the two sets of lengths. </li>
</ol>

</div>
</div>
<a id="ab3731a4aa4bb04481dc95069bbfb7156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3731a4aa4bb04481dc95069bbfb7156">&#9670;&nbsp;</a></span>NEEDBITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NEEDBITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{<span class="keywordflow">while</span>(k&lt;(n)){<span class="keywordtype">int</span> c=NEXTBYTE;<span class="keywordflow">if</span>(c==EOF)<span class="keywordflow">return</span> 1;\</div><div class="line">    b|=((ulg)c)&lt;&lt;k;k+=8;}}</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a59ac38e3e4a82422701f49531882d5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ac38e3e4a82422701f49531882d5cc">&#9670;&nbsp;</a></span>DecompressDeflatedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DecompressDeflatedData </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main public function. Decompresses raw data compressed using the DEFLATE algorithm (RFC 1951 - e.g. zlib, gzip). Returns 0 if decompression fails or, if successful, returns the size of the decompressed data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">int</td><td>inLength </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">char</td><td>* in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">char</td><td>* out </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 if (inflate(__G) != 0) G.outCounter else </dd></dl>

</div>
</div>
<a id="aaac3baa7c01f9453c5a2521be7ef3c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac3baa7c01f9453c5a2521be7ef3c66">&#9670;&nbsp;</a></span>huft_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int huft_build </td>
          <td>(</td>
          <td class="paramtype">__GDEF ZCONST unsigned *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZCONST ush *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZCONST ush *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhuft.html">huft</a> **&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. The code with value 256 is special, and the tables are constructed so that no bits beyond that code are fetched when that code is decoded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">int</td><td>* m </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">struct</td><td>huft ** t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ZCONST</td><td>ush * e </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ZCONST</td><td>ush * d </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unsigned</td><td>s </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unsigned</td><td>n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ZCONST</td><td>unsigned * b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 if (c[0] == n) 2 if ((y -= c[j]) &lt; 0) 2 if ((y -= c[i]) &lt; 0) 3 if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) == (struct huft *)NULL &amp;&amp; h) y != 0 &amp;&amp; g != 1 else </dd></dl>

</div>
</div>
<a id="af45d17d87f09fb609612f19c964b7984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45d17d87f09fb609612f19c964b7984">&#9670;&nbsp;</a></span>huft_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int huft_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhuft.html">huft</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the malloc'ed tables built by <a class="el" href="_inflate_8c.html#aaac3baa7c01f9453c5a2521be7ef3c66" title="Given a list of code lengths and a maximum table size, make a set of tables to decode that set of cod...">huft_build()</a>, which makes a linked list of the tables it made, with the links in a dummy first entry of each table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">struct</td><td>huft * t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 </dd></dl>

</div>
</div>
<a id="a8d36cae246bb8a9e5fec9f551a843977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d36cae246bb8a9e5fec9f551a843977">&#9670;&nbsp;</a></span>inflate_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int inflate_codes </td>
          <td>(</td>
          <td class="paramtype">__G__&#160;</td>
          <td class="paramname"><em>tl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">td&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bl&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bd&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inflate the coded data: Make local copy of global, get length of block to copy, decode distance of block to copy, do the copy, restore the globals from the locals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">int</td><td>bd </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">int</td><td>bl </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">struct</td><td>huft * td </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">struct</td><td>huft * tl </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 1 ((e = (t = tl + ((unsigned)b &amp; ml))-&gt;e) &gt; 16 &amp;&amp; (e == 99)) 1 ((e = (t = td + ((unsigned)b &amp; md))-&gt;e) &gt; 16 (e == 99)) 1 if (G.redirect_slide &amp;&amp; (d &gt;= wsize)) 0 else </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8d494dcf3fd9efd6c0296a90a1f50fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d494dcf3fd9efd6c0296a90a1f50fc2">&#9670;&nbsp;</a></span>mask_bits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ZCONST ush near mask_bits[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    0x0000,</div><div class="line">    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,</div><div class="line">    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff</div><div class="line">}</div></div><!-- fragment -->
</div>
</div>
<a id="a079528bb7fc5a12e84dee1bbbe451563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079528bb7fc5a12e84dee1bbbe451563">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned n</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> e</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
