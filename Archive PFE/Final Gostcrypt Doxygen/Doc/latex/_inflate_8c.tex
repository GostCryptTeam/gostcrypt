\hypertarget{_inflate_8c}{}\section{Common/\+Inflate.c File Reference}
\label{_inflate_8c}\index{Common/\+Inflate.\+c@{Common/\+Inflate.\+c}}


Inflate codes, decompress inflate and inflate a block.  


{\ttfamily \#include \char`\"{}inflate.\+h\char`\"{}}\newline
Include dependency graph for Inflate.\+c\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=206pt]{_inflate_8c__incl}
\end{center}
\end{figure}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{_inflate_8c_a7d76837255cc0896396e457c40795a93}{I\+N\+F\+M\+OD}~/$\ast$ tell inflate.\+h to include code to be compiled $\ast$/
\item 
\mbox{\Hypertarget{_inflate_8c_a01c6b59ca21f041b23efbb9845cc4e32}\label{_inflate_8c_a01c6b59ca21f041b23efbb9845cc4e32}} 
\#define {\bfseries wsize}~W\+S\+I\+ZE       /$\ast$ wsize is a constant $\ast$/
\item 
\mbox{\Hypertarget{_inflate_8c_afbafe3dcd659cd7ff763ec43ebcfa0dd}\label{_inflate_8c_afbafe3dcd659cd7ff763ec43ebcfa0dd}} 
\#define {\bfseries M\+E\+S\+S\+A\+GE}(str,  len,  flag)~fprintf(stderr,(char $\ast$)(str))
\item 
\mbox{\Hypertarget{_inflate_8c_a93bbe97269cf8304b452a4d472dba191}\label{_inflate_8c_a93bbe97269cf8304b452a4d472dba191}} 
\#define {\bfseries Trace}(x)
\item 
\#define \hyperlink{_inflate_8c_a4afc4cfe7d1af63e72b1e88b34c8b520}{C\+H\+E\+C\+K\+\_\+\+E\+OF}~/$\ast$ default as of 5.\+13/5.\+2 $\ast$/
\item 
\#define {\bfseries N\+E\+E\+D\+B\+I\+TS}(n)
\item 
\mbox{\Hypertarget{_inflate_8c_a75de43cc4baf11259d310b999e54c965}\label{_inflate_8c_a75de43cc4baf11259d310b999e54c965}} 
\#define {\bfseries D\+U\+M\+P\+B\+I\+TS}(n)~\{b$>$$>$=(n);k-\/=(n);\}
\item 
\mbox{\Hypertarget{_inflate_8c_a04cd58bc28249a2827ecb52e0ff15ac3}\label{_inflate_8c_a04cd58bc28249a2827ecb52e0ff15ac3}} 
\#define {\bfseries B\+M\+AX}~16         /$\ast$ maximum bit length of any code (16 for explode) $\ast$/
\item 
\mbox{\Hypertarget{_inflate_8c_a0909f9743b77b5e83d3e8e1d61989b10}\label{_inflate_8c_a0909f9743b77b5e83d3e8e1d61989b10}} 
\#define {\bfseries N\+\_\+\+M\+AX}~288       /$\ast$ maximum number of \hyperlink{_decompressor_8c_afce25d8162a22b60b1c6124eeac0e37e}{codes} in any set $\ast$/
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{_inflate_8c_a82ed4d9cfc2583019bf41b9f9e198e34}\label{_inflate_8c_a82ed4d9cfc2583019bf41b9f9e198e34}} 
int \hyperlink{_inflate_8c_a8d36cae246bb8a9e5fec9f551a843977}{inflate\+\_\+codes} {\bfseries OF} ((\+\_\+\+\_\+\+G\+P\+R\+O\+\_\+\+\_\+ struct \hyperlink{structhuft}{huft} $\ast$tl, struct \hyperlink{structhuft}{huft} $\ast$td, int bl, int bd))
\item 
int \hyperlink{_inflate_8c_a8d36cae246bb8a9e5fec9f551a843977}{inflate\+\_\+codes} (\+\_\+\+\_\+\+G\+\_\+\+\_\+ tl, td, bl, bd) w
\begin{DoxyCompactList}\small\item\em Inflate the coded data\+: Make local copy of global, get length of block to copy, decode distance of block to copy, do the copy, restore the globals from the locals. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{_inflate_8c_a8fdafe3be7e00ce3d4f0cb50a9a5eb39}\label{_inflate_8c_a8fdafe3be7e00ce3d4f0cb50a9a5eb39}} 
{\bfseries while} (1)
\item 
\mbox{\Hypertarget{_inflate_8c_a5ab90c65f96a7052e51f2972d1989bd2}\label{_inflate_8c_a5ab90c65f96a7052e51f2972d1989bd2}} 
{\bfseries if} (if(==0) return inflate\+\_\+stored(\+\_\+\+\_\+G) t==2)
\item 
\mbox{\Hypertarget{_inflate_8c_ad76887b80d42e0722f22efe877c9983e}\label{_inflate_8c_ad76887b80d42e0722f22efe877c9983e}} 
int {\bfseries inflate\+\_\+free} (\+\_\+\+\_\+G)
\item 
int \hyperlink{_inflate_8c_aaac3baa7c01f9453c5a2521be7ef3c66}{huft\+\_\+build} (\+\_\+\+\_\+\+G\+D\+EF Z\+C\+O\+N\+ST unsigned $\ast$b, unsigned n, unsigned s, Z\+C\+O\+N\+ST ush $\ast$d, Z\+C\+O\+N\+ST ush $\ast$e, struct \hyperlink{structhuft}{huft} $\ast$$\ast$t, int $\ast$m)
\begin{DoxyCompactList}\small\item\em Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. The code with value 256 is special, and the tables are constructed so that no bits beyond that code are fetched when that code is decoded. \end{DoxyCompactList}\item 
int \hyperlink{_inflate_8c_af45d17d87f09fb609612f19c964b7984}{huft\+\_\+free} (struct \hyperlink{structhuft}{huft} $\ast$t)
\begin{DoxyCompactList}\small\item\em Free the malloc\textquotesingle{}ed tables built by \hyperlink{_inflate_8c_aaac3baa7c01f9453c5a2521be7ef3c66}{huft\+\_\+build()}, which makes a linked list of the tables it made, with the links in a dummy first entry of each table. \end{DoxyCompactList}\item 
int \hyperlink{_inflate_8c_a59ac38e3e4a82422701f49531882d5cc}{Decompress\+Deflated\+Data} (char $\ast$out, char $\ast$in, int in\+Length)
\begin{DoxyCompactList}\small\item\em Main public function. Decompresses raw data compressed using the D\+E\+F\+L\+A\+TE algorithm (R\+FC 1951 -\/ e.\+g. zlib, gzip). Returns 0 if decompression fails or, if successful, returns the size of the decompressed data. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{_inflate_8c_a2616fe56c6c0d284768ae53f69efed4b}\label{_inflate_8c_a2616fe56c6c0d284768ae53f69efed4b}} 
\hyperlink{struct_g__struct}{G\+\_\+struct} {\bfseries G}
\item 
\mbox{\Hypertarget{_inflate_8c_afcd7e2464e60c65fa55fb0716689090c}\label{_inflate_8c_afcd7e2464e60c65fa55fb0716689090c}} 
uch {\bfseries redir\+Slide} \mbox{[}W\+S\+I\+ZE\mbox{]}
\item 
Z\+C\+O\+N\+ST ush near {\bfseries mask\+\_\+bits} \mbox{[}$\,$\mbox{]}
\item 
\mbox{\Hypertarget{_inflate_8c_aad64aacc6741f76d9561195fc2a7b8f3}\label{_inflate_8c_aad64aacc6741f76d9561195fc2a7b8f3}} 
\+\_\+\+\_\+\+G\+D\+EF struct \hyperlink{structhuft}{huft} $\ast$ {\bfseries tl}
\item 
\mbox{\Hypertarget{_inflate_8c_a4321d070a30d5540b4019b3f0ea18a26}\label{_inflate_8c_a4321d070a30d5540b4019b3f0ea18a26}} 
\+\_\+\+\_\+\+G\+D\+EF struct \hyperlink{structhuft}{huft} $\ast$ {\bfseries td}
\item 
\mbox{\Hypertarget{_inflate_8c_abb63accab286c308a0f783f0afe8f32a}\label{_inflate_8c_abb63accab286c308a0f783f0afe8f32a}} 
int {\bfseries bl}
\item 
\mbox{\Hypertarget{_inflate_8c_ab36d1100473c16852c1b64d1917454a4}\label{_inflate_8c_ab36d1100473c16852c1b64d1917454a4}} 
int {\bfseries bd}
\item 
unsigned {\bfseries n}
\item 
\mbox{\Hypertarget{_inflate_8c_af97cf1b8363ec7aebe0d49f84d8ee68b}\label{_inflate_8c_af97cf1b8363ec7aebe0d49f84d8ee68b}} 
unsigned {\bfseries d}
\item 
\mbox{\Hypertarget{_inflate_8c_aab2ee9ec393223c855b9595e52382ac0}\label{_inflate_8c_aab2ee9ec393223c855b9595e52382ac0}} 
unsigned {\bfseries w}
\item 
\mbox{\Hypertarget{_inflate_8c_aaccc9105df5383111407fd5b41255e23}\label{_inflate_8c_aaccc9105df5383111407fd5b41255e23}} 
struct \hyperlink{structhuft}{huft} $\ast$ {\bfseries t} = (unsigned)b \& 3
\item 
\mbox{\Hypertarget{_inflate_8c_a68b8016ea7f5d48a5da241d6de64e4ce}\label{_inflate_8c_a68b8016ea7f5d48a5da241d6de64e4ce}} 
unsigned {\bfseries ml} = mask\+\_\+bits\mbox{[}bl\mbox{]}
\item 
\mbox{\Hypertarget{_inflate_8c_a29785b126ac854eae64708b0b52c413a}\label{_inflate_8c_a29785b126ac854eae64708b0b52c413a}} 
unsigned {\bfseries md} = mask\+\_\+bits\mbox{[}bd\mbox{]}
\item 
\mbox{\Hypertarget{_inflate_8c_ac76181755c4a6b7250805f0e87a68102}\label{_inflate_8c_ac76181755c4a6b7250805f0e87a68102}} 
register ulg {\bfseries b} = G.\+bb
\item 
\mbox{\Hypertarget{_inflate_8c_ad120517d0e9ed6741006993b9956af5d}\label{_inflate_8c_ad120517d0e9ed6741006993b9956af5d}} 
register unsigned {\bfseries k} = G.\+bk
\item 
\mbox{\Hypertarget{_inflate_8c_aed41a5e642c36c2363312dd465fc40f1}\label{_inflate_8c_aed41a5e642c36c2363312dd465fc40f1}} 
G {\bfseries wp} = w
\item 
\mbox{\Hypertarget{_inflate_8c_a259f7522cd7302fa1523e2a43ec51595}\label{_inflate_8c_a259f7522cd7302fa1523e2a43ec51595}} 
G {\bfseries bb} = b
\item 
\mbox{\Hypertarget{_inflate_8c_a2bf912ef45677c37b8a7f3540d092407}\label{_inflate_8c_a2bf912ef45677c37b8a7f3540d092407}} 
G {\bfseries bk} = k
\item 
\mbox{\Hypertarget{_inflate_8c_a9717e7bbecb906637e86cef6da3d83c2}\label{_inflate_8c_a9717e7bbecb906637e86cef6da3d83c2}} 
{\bfseries return}
\item 
\mbox{\Hypertarget{_inflate_8c_ab4c880a962c4056c39079e5e8a97a764}\label{_inflate_8c_ab4c880a962c4056c39079e5e8a97a764}} 
$\ast$ {\bfseries e} = (int)b \& 1
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Inflate codes, decompress inflate and inflate a block. 

\begin{DoxyVersion}{Version}
1.\+3.\+1 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
23/01/2017 
\end{DoxyDate}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{_inflate_8c_a4afc4cfe7d1af63e72b1e88b34c8b520}\label{_inflate_8c_a4afc4cfe7d1af63e72b1e88b34c8b520}} 
\index{Inflate.\+c@{Inflate.\+c}!C\+H\+E\+C\+K\+\_\+\+E\+OF@{C\+H\+E\+C\+K\+\_\+\+E\+OF}}
\index{C\+H\+E\+C\+K\+\_\+\+E\+OF@{C\+H\+E\+C\+K\+\_\+\+E\+OF}!Inflate.\+c@{Inflate.\+c}}
\subsubsection{\texorpdfstring{C\+H\+E\+C\+K\+\_\+\+E\+OF}{CHECK\_EOF}}
{\footnotesize\ttfamily \#define C\+H\+E\+C\+K\+\_\+\+E\+OF~/$\ast$ default as of 5.\+13/5.\+2 $\ast$/}

Macros for inflate() bit peeking and grabbing. The usage is\+: \begin{DoxyVerb} NEEDBITS(j)
 x = b & mask_bits[j];
 DUMPBITS(j)
\end{DoxyVerb}


where N\+E\+E\+D\+B\+I\+TS makes sure that b has at least j bits in it, and D\+U\+M\+P\+B\+I\+TS removes the bits from b. The macros use the variable k for the number of bits in b. Normally, b and k are register variables for speed and are initialized at the begining of a routine that uses these macros from a global bit buffer and count.

In order to not ask for more bits than there are in the compressed stream, the Huffman tables are constructed to only ask for just enough bits to make up the end-\/of-\/block code (value 256). Then no bytes need to be \char`\"{}returned\char`\"{} to the buffer at the end of the last block. See the \hyperlink{_inflate_8c_aaac3baa7c01f9453c5a2521be7ef3c66}{huft\+\_\+build()} routine. \mbox{\Hypertarget{_inflate_8c_a7d76837255cc0896396e457c40795a93}\label{_inflate_8c_a7d76837255cc0896396e457c40795a93}} 
\index{Inflate.\+c@{Inflate.\+c}!I\+N\+F\+M\+OD@{I\+N\+F\+M\+OD}}
\index{I\+N\+F\+M\+OD@{I\+N\+F\+M\+OD}!Inflate.\+c@{Inflate.\+c}}
\subsubsection{\texorpdfstring{I\+N\+F\+M\+OD}{INFMOD}}
{\footnotesize\ttfamily \#define I\+N\+F\+M\+OD~/$\ast$ tell inflate.\+h to include code to be compiled $\ast$/}

\hyperlink{_inflate_8c}{inflate.\+c} -- put in the public domain by Mark Adler

Decompresses raw data compressed using the D\+E\+F\+L\+A\+TE algorithm (R\+FC 1951)

You can do whatever you like with this source file, though I would prefer that if you modify it and redistribute it that you include comments to that effect with your name and the date. Thank you.

History\+: vers date who what 

 a $\sim$$\sim$ Feb 92 M. Adler used full (large, one-\/step) lookup table b1 21 Mar 92 M. Adler first version with partial lookup tables b2 21 Mar 92 M. Adler fixed bug in fixed-\/code blocks b3 22 Mar 92 M. Adler sped up match copies, cleaned up some b4 25 Mar 92 M. Adler added prototypes; removed window\mbox{[}\mbox{]} (now is the responsibility of unzip.\+h--also changed name to slide\mbox{[}\mbox{]}), so needs diffs for unzip.\+c and unzip.\+h (this allows compiling in the small model on M\+S\+D\+OS); fixed cast of q in \hyperlink{_inflate_8c_aaac3baa7c01f9453c5a2521be7ef3c66}{huft\+\_\+build()}; b5 26 Mar 92 M. Adler got rid of unintended macro recursion. b6 27 Mar 92 M. Adler got rid of nextbyte() routine. fixed bug in inflate\+\_\+fixed(). c1 30 Mar 92 M. Adler removed lbits, dbits environment variables. changed B\+M\+AX to 16 for explode. Removed O\+U\+TB usage, and replaced it with flush()-- this was a 20\% speed improvement! Added an explode.\+c (to replace unimplod.\+c) that uses the huft routines here. Removed register union. c2 4 Apr 92 M. Adler fixed bug for file sizes a multiple of 32k. c3 10 Apr 92 M. Adler reduced memory of code tables made by huft\+\_\+build significantly (factor of two to three). c4 15 Apr 92 M. Adler added N\+O\+M\+E\+M\+C\+PY do kill use of memcpy(). worked around a Turbo C optimization bug.

c5 21 Apr 92 M. Adler added the W\+S\+I\+ZE \#define to allow reducing the 32K window size for specialized applications. c6 31 May 92 M. Adler added some typecasts to eliminate warnings c7 27 Jun 92 G. Roelofs added some more typecasts (444\+: M\+SC bug). c8 5 Oct 92 J-\/l. Gailly added ifdef\textquotesingle{}d code to deal with P\+K\+Z\+IP bug. c9 9 Oct 92 M. Adler removed a memory error message ($\sim$line 416). c10 17 Oct 92 G. Roelofs changed U\+L\+O\+N\+G/\+U\+W\+O\+R\+D/byte to ulg/ush/uch, removed old inflate, renamed inflate\+\_\+entry to inflate, added Mark\textquotesingle{}s fix to a comment. c10.\+5 14 Dec 92 M. Adler fix up error messages for incomplete trees. c11 2 Jan 93 M. Adler fixed bug in detection of incomplete tables, and removed assumption that E\+OB is the longest code (bad assumption). c12 3 Jan 93 M. Adler make tables for fixed blocks only once. c13 5 Jan 93 M. Adler allow all zero length codes (pkzip 2.\+04c outputs one zero length code for an empty distance tree). c14 12 Mar 93 M. Adler made \hyperlink{_inflate_8c}{inflate.\+c} standalone with the introduction of \hyperlink{_inflate_8h_source}{inflate.\+h}. c14b 16 Jul 93 G. Roelofs added (unsigned) typecast to w at 470. c14c 19 Jul 93 J. Bush changed v\mbox{[}N\+\_\+\+M\+AX\mbox{]}, l\mbox{[}288\mbox{]}, ll\mbox{[}28x+3x\mbox{]} arrays to static for Amiga. c14d 13 Aug 93 J-\/l. Gailly de-\/complicatified Mark\textquotesingle{}s c\mbox{[}$\ast$p++\mbox{]}++ thing. c14e 8 Oct 93 G. Roelofs changed memset() to memzero(). c14f 22 Oct 93 G. Roelofs renamed quietflg to qflag; made Trace() conditional; added inflate\+\_\+free(). c14g 28 Oct 93 G. Roelofs changed l/(lx+1) macro to pointer (Cray bug) c14h 7 Dec 93 C. Ghisler \hyperlink{_inflate_8c_aaac3baa7c01f9453c5a2521be7ef3c66}{huft\+\_\+build()} optimizations. c14i 9 Jan 94 A. Verheijen set fixed\+\_\+t\{d,l\} to N\+U\+LL after freeing; G. Roelofs check N\+E\+X\+T\+B\+Y\+TE macro for E\+OF. c14j 23 Jan 94 G. Roelofs removed Ghisler \char`\"{}optimizations\char`\"{}; ifdef\textquotesingle{}d E\+OF check. c14k 27 Feb 94 G. Roelofs added some typecasts to avoid warnings. c14l 9 Apr 94 G. Roelofs fixed split comments on preprocessor lines to avoid bug in Encore compiler. c14m 7 Jul 94 P. Kienitz modified to allow assembler version of \hyperlink{_inflate_8c_a8d36cae246bb8a9e5fec9f551a843977}{inflate\+\_\+codes()} (define A\+S\+M\+\_\+\+I\+N\+F\+L\+A\+T\+E\+C\+O\+D\+ES) c14n 22 Jul 94 G. Roelofs changed fprintf to macro for D\+LL versions c14o 23 Aug 94 C. Spieler added a newline to a debug statement; G. Roelofs added another typecast to avoid M\+SC warning c14p 4 Oct 94 G. Roelofs added (voidp $\ast$) cast to free() argument c14q 30 Oct 94 G. Roelofs changed fprintf macro to M\+E\+S\+S\+A\+G\+E() c14r 1 Nov 94 G. Roelofs fixed possible redefinition of C\+H\+E\+C\+K\+\_\+\+E\+OF c14s 7 May 95 S. Maxwell O\+S/2 D\+LL globals stuff incorporated; P. Kienitz \char`\"{}fixed\char`\"{} A\+S\+M\+\_\+\+I\+N\+F\+L\+A\+T\+E\+C\+O\+D\+ES macro/prototype c14t 18 Aug 95 G. Roelofs added inflate() to use zlib functions; changed voidp to zvoid; moved \hyperlink{_inflate_8c_aaac3baa7c01f9453c5a2521be7ef3c66}{huft\+\_\+build()} and \hyperlink{_inflate_8c_af45d17d87f09fb609612f19c964b7984}{huft\+\_\+free()} to end of file c14u 1 Oct 95 G. Roelofs moved G into definition of M\+E\+S\+S\+A\+GE macro c14v 8 Nov 95 P. Kienitz changed A\+S\+M\+\_\+\+I\+N\+F\+L\+A\+T\+E\+C\+O\+D\+ES to use a regular call with {\bfseries G} instead of a macro c15 3 Aug 96 M. Adler fixed bomb-\/bug on random input data (Adobe) c15b 24 Aug 96 M. Adler more fixes for random input data c15c 28 Mar 97 G. Roelofs changed U\+S\+E\+\_\+\+Z\+L\+IB fatal exit code from P\+K\+\_\+\+M\+E\+M2 to P\+K\+\_\+\+M\+E\+M3 c16 20 Apr 97 J. Altman added memzero(v\mbox{[}$\,$\mbox{]}) in \hyperlink{_inflate_8c_aaac3baa7c01f9453c5a2521be7ef3c66}{huft\+\_\+build()} c16b 29 Mar 98 C. Spieler modified D\+LL code for slide redirection

fork 12 Dec 07 Adapted for True\+Crypt

Inflate deflated (P\+K\+Z\+IP\textquotesingle{}s method 8 compressed) data. The compression method searches for as much of the current string of bytes (up to a length of 258) in the previous 32K bytes. If it doesn\textquotesingle{}t find any matches (of at least length 3), it codes the next byte. Otherwise, it codes the length of the matched string and its distance backwards from the current position. There is a single Huffman code that codes both single bytes (called \char`\"{}literals\char`\"{}) and match lengths. A second Huffman code codes the distance information, which follows a length code. Each length or distance code actually represents a base value and a number of \char`\"{}extra\char`\"{} (sometimes zero) bits to get to add to the base value. At the end of each deflated block is a special end-\/of-\/block (E\+OB) literal/ length code. The decoding process is basically\+: get a literal/length code; if E\+OB then done; if a literal, emit the decoded byte; if a length then get the distance and emit the referred-\/to bytes from the sliding window of previously emitted data.

There are (currently) three kinds of inflate blocks\+: stored, fixed, and dynamic. The compressor outputs a chunk of data at a time and decides which method to use on a chunk-\/by-\/chunk basis. A chunk might typically be 32K to 64K, uncompressed. If the chunk is uncompressible, then the \char`\"{}stored\char`\"{} method is used. In this case, the bytes are simply stored as is, eight bits per byte, with none of the above coding. The bytes are preceded by a count, since there is no longer an E\+OB code.

If the data are compressible, then either the fixed or dynamic methods are used. In the dynamic method, the compressed data are preceded by an encoding of the literal/length and distance Huffman codes that are to be used to decode this block. The representation is itself Huffman coded, and so is preceded by a description of that code. These code descriptions take up a little space, and so for small blocks, there is a predefined set of codes, called the fixed codes. The fixed method is used if the block ends up smaller that way (usually for quite small chunks); otherwise the dynamic method is used. In the latter case, the codes are customized to the probabilities in the current block and so can code it much better than the pre-\/determined fixed codes can.

The Huffman codes themselves are decoded using a multi-\/level table lookup, in order to maximize the speed of decoding plus the speed of building the decoding tables. See the comments below that precede the lbits and dbits tuning parameters.

G\+RR\+: return values(?) 0 OK 1 incomplete table 2 bad input 3 not enough memory

Notes beyond the 1.\+93a appnote.\+txt\+:


\begin{DoxyEnumerate}
\item Distance pointers never point before the beginning of the output stream.
\item Distance pointers can point back across blocks, up to 32k away.
\item There is an implied maximum of 7 bits for the bit length table and 15 bits for the actual data.
\item If only one code exists, then it is encoded using one bit. (Zero would be more efficient, but perhaps a little confusing.) If two codes exist, they are coded using one bit each (0 and 1).
\item There is no way of sending zero distance codes--a dummy must be sent if there are none. (History\+: a pre 2.\+0 version of P\+K\+Z\+IP would store blocks with no distance codes, but this was discovered to be too harsh a criterion.) Valid only for 1.\+93a. 2.\+04c does allow zero distance codes, which is sent as one code of zero bits in length.
\item There are up to 286 literal/length codes. Code 256 represents the end-\/of-\/block. Note however that the static length tree defines 288 codes just to fill out the Huffman codes. Codes 286 and 287 cannot be used though, since there is no length base or extra bits defined for them. Similarily, there are up to 30 distance codes. However, static trees define 32 codes (all 5 bits) to fill out the Huffman codes, but the last two had better not show up in the data.
\item Unzip can check dynamic Huffman blocks for complete code sets. The exception is that a single code would not be complete (see \#4).
\item The five bits following the block type is really the number of literal codes sent minus 257.
\item Length codes 8,16,16 are interpreted as 13 length codes of 8 bits (1+6+6). Therefore, to output three times the length, you output three codes (1+1+1), whereas to output four times the same length, you only need two codes (1+3). Hmm.
\item In the tree reconstruction algorithm, Code = Code + Increment only if Bit\+Length(i) is not zero. (Pretty obvious.)
\item Correction\+: 4 Bits\+: \# of Bit Length codes -\/ 4 (4 -\/ 19)
\item Note\+: length code 284 can represent 227-\/258, but length code 285 really is 258. The last length deserves its own, short code since it gets used a lot in very redundant files. The length 258 is special since 258 -\/ 3 (the min match length) is 255.
\item The literal/length and distance code bit lengths are read as a single stream of lengths. It is possible (and advantageous) for a repeat code (16, 17, or 18) to go across the boundary between the two sets of lengths. 
\end{DoxyEnumerate}\mbox{\Hypertarget{_inflate_8c_ab3731a4aa4bb04481dc95069bbfb7156}\label{_inflate_8c_ab3731a4aa4bb04481dc95069bbfb7156}} 
\index{Inflate.\+c@{Inflate.\+c}!N\+E\+E\+D\+B\+I\+TS@{N\+E\+E\+D\+B\+I\+TS}}
\index{N\+E\+E\+D\+B\+I\+TS@{N\+E\+E\+D\+B\+I\+TS}!Inflate.\+c@{Inflate.\+c}}
\subsubsection{\texorpdfstring{N\+E\+E\+D\+B\+I\+TS}{NEEDBITS}}
{\footnotesize\ttfamily \#define N\+E\+E\+D\+B\+I\+TS(\begin{DoxyParamCaption}\item[{}]{n }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
\{\textcolor{keywordflow}{while}(k<(n))\{\textcolor{keywordtype}{int} c=NEXTBYTE;\textcolor{keywordflow}{if}(c==EOF)\textcolor{keywordflow}{return} 1;\(\backslash\)
    b|=((ulg)c)<<k;k+=8;\}\}
\end{DoxyCode}


\subsection{Function Documentation}
\mbox{\Hypertarget{_inflate_8c_a59ac38e3e4a82422701f49531882d5cc}\label{_inflate_8c_a59ac38e3e4a82422701f49531882d5cc}} 
\index{Inflate.\+c@{Inflate.\+c}!Decompress\+Deflated\+Data@{Decompress\+Deflated\+Data}}
\index{Decompress\+Deflated\+Data@{Decompress\+Deflated\+Data}!Inflate.\+c@{Inflate.\+c}}
\subsubsection{\texorpdfstring{Decompress\+Deflated\+Data()}{DecompressDeflatedData()}}
{\footnotesize\ttfamily int Decompress\+Deflated\+Data (\begin{DoxyParamCaption}\item[{char $\ast$}]{out,  }\item[{char $\ast$}]{in,  }\item[{int}]{in\+Length }\end{DoxyParamCaption})}



Main public function. Decompresses raw data compressed using the D\+E\+F\+L\+A\+TE algorithm (R\+FC 1951 -\/ e.\+g. zlib, gzip). Returns 0 if decompression fails or, if successful, returns the size of the decompressed data. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em int} & in\+Length \\
\hline
\mbox{\tt in}  & {\em char} & $\ast$ in \\
\hline
\mbox{\tt in}  & {\em char} & $\ast$ out \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 0 if (inflate(\+\_\+\+\_\+\+G) != 0) G.\+out\+Counter else 
\end{DoxyReturn}
\mbox{\Hypertarget{_inflate_8c_aaac3baa7c01f9453c5a2521be7ef3c66}\label{_inflate_8c_aaac3baa7c01f9453c5a2521be7ef3c66}} 
\index{Inflate.\+c@{Inflate.\+c}!huft\+\_\+build@{huft\+\_\+build}}
\index{huft\+\_\+build@{huft\+\_\+build}!Inflate.\+c@{Inflate.\+c}}
\subsubsection{\texorpdfstring{huft\+\_\+build()}{huft\_build()}}
{\footnotesize\ttfamily int huft\+\_\+build (\begin{DoxyParamCaption}\item[{\+\_\+\+\_\+\+G\+D\+EF Z\+C\+O\+N\+ST unsigned $\ast$}]{b,  }\item[{unsigned}]{n,  }\item[{unsigned}]{s,  }\item[{Z\+C\+O\+N\+ST ush $\ast$}]{d,  }\item[{Z\+C\+O\+N\+ST ush $\ast$}]{e,  }\item[{struct \hyperlink{structhuft}{huft} $\ast$$\ast$}]{t,  }\item[{int $\ast$}]{m }\end{DoxyParamCaption})}



Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. The code with value 256 is special, and the tables are constructed so that no bits beyond that code are fetched when that code is decoded. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em int} & $\ast$ m \\
\hline
\mbox{\tt in}  & {\em struct} & huft $\ast$$\ast$ t \\
\hline
\mbox{\tt in}  & {\em Z\+C\+O\+N\+ST} & ush $\ast$ e \\
\hline
\mbox{\tt in}  & {\em Z\+C\+O\+N\+ST} & ush $\ast$ d \\
\hline
\mbox{\tt in}  & {\em unsigned} & s \\
\hline
\mbox{\tt in}  & {\em unsigned} & n \\
\hline
\mbox{\tt in}  & {\em Z\+C\+O\+N\+ST} & unsigned $\ast$ b \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 0 if (c\mbox{[}0\mbox{]} == n) 2 if ((y -\/= c\mbox{[}j\mbox{]}) $<$ 0) 2 if ((y -\/= c\mbox{[}i\mbox{]}) $<$ 0) 3 if ((q = (struct huft $\ast$)malloc((z + 1)$\ast$sizeof(struct huft))) == (struct huft $\ast$)N\+U\+LL \&\& h) y != 0 \&\& g != 1 else 
\end{DoxyReturn}
\mbox{\Hypertarget{_inflate_8c_af45d17d87f09fb609612f19c964b7984}\label{_inflate_8c_af45d17d87f09fb609612f19c964b7984}} 
\index{Inflate.\+c@{Inflate.\+c}!huft\+\_\+free@{huft\+\_\+free}}
\index{huft\+\_\+free@{huft\+\_\+free}!Inflate.\+c@{Inflate.\+c}}
\subsubsection{\texorpdfstring{huft\+\_\+free()}{huft\_free()}}
{\footnotesize\ttfamily int huft\+\_\+free (\begin{DoxyParamCaption}\item[{struct \hyperlink{structhuft}{huft} $\ast$}]{t }\end{DoxyParamCaption})}



Free the malloc\textquotesingle{}ed tables built by \hyperlink{_inflate_8c_aaac3baa7c01f9453c5a2521be7ef3c66}{huft\+\_\+build()}, which makes a linked list of the tables it made, with the links in a dummy first entry of each table. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em struct} & huft $\ast$ t \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 0 
\end{DoxyReturn}
\mbox{\Hypertarget{_inflate_8c_a8d36cae246bb8a9e5fec9f551a843977}\label{_inflate_8c_a8d36cae246bb8a9e5fec9f551a843977}} 
\index{Inflate.\+c@{Inflate.\+c}!inflate\+\_\+codes@{inflate\+\_\+codes}}
\index{inflate\+\_\+codes@{inflate\+\_\+codes}!Inflate.\+c@{Inflate.\+c}}
\subsubsection{\texorpdfstring{inflate\+\_\+codes()}{inflate\_codes()}}
{\footnotesize\ttfamily int inflate\+\_\+codes (\begin{DoxyParamCaption}\item[{\+\_\+\+\_\+\+G\+\_\+\+\_\+}]{tl,  }\item[{td}]{,  }\item[{bl}]{,  }\item[{bd}]{ }\end{DoxyParamCaption})}



Inflate the coded data\+: Make local copy of global, get length of block to copy, decode distance of block to copy, do the copy, restore the globals from the locals. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em int} & bd \\
\hline
\mbox{\tt in}  & {\em int} & bl \\
\hline
\mbox{\tt in}  & {\em struct} & huft $\ast$ td \\
\hline
\mbox{\tt in}  & {\em struct} & huft $\ast$ tl \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 1 ((e = (t = tl + ((unsigned)b \& ml))-\/$>$e) $>$ 16 \&\& (e == 99)) 1 ((e = (t = td + ((unsigned)b \& md))-\/$>$e) $>$ 16 (e == 99)) 1 if (G.\+redirect\+\_\+slide \&\& (d $>$= wsize)) 0 else 
\end{DoxyReturn}


\subsection{Variable Documentation}
\mbox{\Hypertarget{_inflate_8c_a8d494dcf3fd9efd6c0296a90a1f50fc2}\label{_inflate_8c_a8d494dcf3fd9efd6c0296a90a1f50fc2}} 
\index{Inflate.\+c@{Inflate.\+c}!mask\+\_\+bits@{mask\+\_\+bits}}
\index{mask\+\_\+bits@{mask\+\_\+bits}!Inflate.\+c@{Inflate.\+c}}
\subsubsection{\texorpdfstring{mask\+\_\+bits}{mask\_bits}}
{\footnotesize\ttfamily Z\+C\+O\+N\+ST ush near mask\+\_\+bits\mbox{[}$\,$\mbox{]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
\}
\end{DoxyCode}
\mbox{\Hypertarget{_inflate_8c_a079528bb7fc5a12e84dee1bbbe451563}\label{_inflate_8c_a079528bb7fc5a12e84dee1bbbe451563}} 
\index{Inflate.\+c@{Inflate.\+c}!n@{n}}
\index{n@{n}!Inflate.\+c@{Inflate.\+c}}
\subsubsection{\texorpdfstring{n}{n}}
{\footnotesize\ttfamily unsigned n}

{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
  \textcolor{keyword}{register} \textcolor{keywordtype}{unsigned} e
\end{DoxyCode}
