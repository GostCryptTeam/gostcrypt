; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

C_3	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
GostR3411_94_CryptoProParamSet DB 01H
	DB	03H
	DB	0aH
	DB	09H
	DB	05H
	DB	0bH
	DB	04H
	DB	0fH
	DB	08H
	DB	06H
	DB	07H
	DB	0eH
	DB	0dH
	DB	00H
	DB	02H
	DB	0cH
	DB	0dH
	DB	0eH
	DB	04H
	DB	01H
	DB	07H
	DB	00H
	DB	05H
	DB	0aH
	DB	03H
	DB	0cH
	DB	08H
	DB	0fH
	DB	06H
	DB	02H
	DB	09H
	DB	0bH
	DB	07H
	DB	06H
	DB	02H
	DB	04H
	DB	0dH
	DB	09H
	DB	0fH
	DB	00H
	DB	0aH
	DB	01H
	DB	05H
	DB	0bH
	DB	08H
	DB	0eH
	DB	0cH
	DB	03H
	DB	07H
	DB	06H
	DB	04H
	DB	0bH
	DB	09H
	DB	0cH
	DB	02H
	DB	0aH
	DB	01H
	DB	08H
	DB	00H
	DB	0eH
	DB	0fH
	DB	0dH
	DB	03H
	DB	05H
	DB	04H
	DB	0aH
	DB	07H
	DB	0cH
	DB	00H
	DB	0fH
	DB	02H
	DB	08H
	DB	0eH
	DB	01H
	DB	06H
	DB	05H
	DB	0dH
	DB	0bH
	DB	09H
	DB	03H
	DB	07H
	DB	0fH
	DB	0cH
	DB	0eH
	DB	09H
	DB	04H
	DB	01H
	DB	00H
	DB	03H
	DB	0bH
	DB	05H
	DB	02H
	DB	06H
	DB	0aH
	DB	08H
	DB	0dH
	DB	05H
	DB	0fH
	DB	04H
	DB	00H
	DB	02H
	DB	0dH
	DB	0bH
	DB	09H
	DB	01H
	DB	07H
	DB	06H
	DB	03H
	DB	0cH
	DB	0eH
	DB	0aH
	DB	08H
	DB	0aH
	DB	04H
	DB	05H
	DB	06H
	DB	08H
	DB	01H
	DB	03H
	DB	07H
	DB	0dH
	DB	0cH
	DB	0eH
	DB	00H
	DB	09H
	DB	02H
	DB	0bH
	DB	0fH
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\crypto\gosthash.c
pdata	SEGMENT
$pdata$A DD	imagerel A
	DD	imagerel A+155
	DD	imagerel $unwind$A
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$A DD	010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT A
_TEXT	SEGMENT
i$ = 0
F$ = 32
T$ = 40
A	PROC						; COMDAT

; 288  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 289  : 	byte i;
; 290  : 	for (i = 0; i < 24; i++)

  0000e	c6 04 24 00	 mov	 BYTE PTR i$[rsp], 0
  00012	eb 09		 jmp	 SHORT $LN6@A
$LN5@A:
  00014	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  00018	04 01		 add	 al, 1
  0001a	88 04 24	 mov	 BYTE PTR i$[rsp], al
$LN6@A:
  0001d	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  00021	83 f8 18	 cmp	 eax, 24
  00024	7d 22		 jge	 SHORT $LN4@A

; 291  : 		T[i] = F[i+8];

  00026	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  0002a	83 c0 08	 add	 eax, 8
  0002d	4c 63 c0	 movsxd	 r8, eax
  00030	0f b6 14 24	 movzx	 edx, BYTE PTR i$[rsp]
  00034	48 8b 4c 24 28	 mov	 rcx, QWORD PTR T$[rsp]
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR F$[rsp]
  0003e	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  00043	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00046	eb cc		 jmp	 SHORT $LN5@A
$LN4@A:

; 292  : 	for (i = 0; i < 8; i++)

  00048	c6 04 24 00	 mov	 BYTE PTR i$[rsp], 0
  0004c	eb 09		 jmp	 SHORT $LN3@A
$LN2@A:
  0004e	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  00052	04 01		 add	 al, 1
  00054	88 04 24	 mov	 BYTE PTR i$[rsp], al
$LN3@A:
  00057	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  0005b	83 f8 08	 cmp	 eax, 8
  0005e	7d 36		 jge	 SHORT $LN1@A

; 293  : 		T[i+24] = F[i] ^ F[i+8];

  00060	0f b6 0c 24	 movzx	 ecx, BYTE PTR i$[rsp]
  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR F$[rsp]
  00069	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0006d	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  00071	83 c0 08	 add	 eax, 8
  00074	48 63 c8	 movsxd	 rcx, eax
  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR F$[rsp]
  0007c	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00080	33 d0		 xor	 edx, eax
  00082	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  00086	83 c0 18	 add	 eax, 24
  00089	48 63 c8	 movsxd	 rcx, eax
  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR T$[rsp]
  00091	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00094	eb b8		 jmp	 SHORT $LN2@A
$LN1@A:

; 294  : }

  00096	48 83 c4 18	 add	 rsp, 24
  0009a	c3		 ret	 0
A	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$P_transform DD imagerel P_transform
	DD	imagerel P_transform+119
	DD	imagerel $unwind$P_transform
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$P_transform DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT P_transform
_TEXT	SEGMENT
i$ = 0
k$ = 4
F$ = 32
T$ = 40
P_transform PROC					; COMDAT

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 269  : 	gst_dword i, k;
; 270  : 	for (i = 0; i < 4; i++)

  0000e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00015	eb 09		 jmp	 SHORT $LN6@P_transfor
$LN5@P_transfor:
  00017	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001a	83 c0 01	 add	 eax, 1
  0001d	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN6@P_transfor:
  00020	83 3c 24 04	 cmp	 DWORD PTR i$[rsp], 4
  00024	7d 4c		 jge	 SHORT $LN4@P_transfor

; 271  : 		for (k = 0; k < 8; k++)

  00026	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  0002e	eb 0b		 jmp	 SHORT $LN3@P_transfor
$LN2@P_transfor:
  00030	8b 44 24 04	 mov	 eax, DWORD PTR k$[rsp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 44 24 04	 mov	 DWORD PTR k$[rsp], eax
$LN3@P_transfor:
  0003b	83 7c 24 04 08	 cmp	 DWORD PTR k$[rsp], 8
  00040	7d 2e		 jge	 SHORT $LN1@P_transfor

; 272  : 			T[i+4*k] = F[8*i+k];

  00042	8b 4c 24 04	 mov	 ecx, DWORD PTR k$[rsp]
  00046	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00049	8d 04 c1	 lea	 eax, DWORD PTR [rcx+rax*8]
  0004c	4c 63 c0	 movsxd	 r8, eax
  0004f	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00052	8b 44 24 04	 mov	 eax, DWORD PTR k$[rsp]
  00056	8d 04 81	 lea	 eax, DWORD PTR [rcx+rax*4]
  00059	48 63 d0	 movsxd	 rdx, eax
  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR T$[rsp]
  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR F$[rsp]
  00066	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  0006b	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  0006e	eb c0		 jmp	 SHORT $LN2@P_transfor
$LN1@P_transfor:
  00070	eb a5		 jmp	 SHORT $LN5@P_transfor
$LN4@P_transfor:

; 273  : }

  00072	48 83 c4 18	 add	 rsp, 24
  00076	c3		 ret	 0
P_transform ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$xor_blocks DD imagerel xor_blocks
	DD	imagerel xor_blocks+98
	DD	imagerel $unwind$xor_blocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$xor_blocks DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT xor_blocks
_TEXT	SEGMENT
i$ = 0
T$ = 32
F$ = 40
S$ = 48
len$ = 56
xor_blocks PROC						; COMDAT

; 246  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 247  : 	gst_dword i;
; 248  : 	for (i = 0; i < len; i++)

  00018	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001f	eb 09		 jmp	 SHORT $LN3@xor_blocks
$LN2@xor_blocks:
  00021	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00024	83 c0 01	 add	 eax, 1
  00027	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN3@xor_blocks:
  0002a	8b 44 24 38	 mov	 eax, DWORD PTR len$[rsp]
  0002e	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00031	7d 2a		 jge	 SHORT $LN1@xor_blocks

; 249  : 		T[i] = F[i] ^ S[i];

  00033	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR F$[rsp]
  0003c	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00040	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR S$[rsp]
  00049	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0004d	33 d0		 xor	 edx, eax
  0004f	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR T$[rsp]
  00058	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  0005b	eb c4		 jmp	 SHORT $LN2@xor_blocks
$LN1@xor_blocks:

; 250  : }

  0005d	48 83 c4 18	 add	 rsp, 24
  00061	c3		 ret	 0
xor_blocks ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_blocks DD imagerel add_blocks
	DD	imagerel add_blocks+138
	DD	imagerel $unwind$add_blocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_blocks DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT add_blocks
_TEXT	SEGMENT
i$ = 0
carry$ = 4
sum$ = 8
T$ = 32
F$ = 40
len$ = 48
add_blocks PROC						; COMDAT

; 222  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 223  : 	gst_dword i;
; 224  : 	gst_word carry = 0;

  00013	33 c0		 xor	 eax, eax
  00015	66 89 44 24 04	 mov	 WORD PTR carry$[rsp], ax

; 225  : 	gst_word sum;
; 226  : 	for (i = 0; i < len; i++)

  0001a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00021	eb 09		 jmp	 SHORT $LN3@add_blocks
$LN2@add_blocks:
  00023	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00026	83 c0 01	 add	 eax, 1
  00029	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN3@add_blocks:
  0002c	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00030	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00033	7d 50		 jge	 SHORT $LN1@add_blocks

; 227  : 	{
; 228  : 		sum = (gst_word)T[i] + (gst_word)F[i] + carry;

  00035	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR T$[rsp]
  0003e	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00042	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00046	48 8b 44 24 28	 mov	 rax, QWORD PTR F$[rsp]
  0004b	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0004f	8b c2		 mov	 eax, edx
  00051	03 c1		 add	 eax, ecx
  00053	0f bf 4c 24 04	 movsx	 ecx, WORD PTR carry$[rsp]
  00058	03 c1		 add	 eax, ecx
  0005a	66 89 44 24 08	 mov	 WORD PTR sum$[rsp], ax

; 229  : 		T[i] = (byte)sum & 0xFF;

  0005f	0f b6 54 24 08	 movzx	 edx, BYTE PTR sum$[rsp]
  00064	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0006a	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR T$[rsp]
  00073	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 230  : 		carry = sum >> 8;

  00076	0f bf 44 24 08	 movsx	 eax, WORD PTR sum$[rsp]
  0007b	c1 f8 08	 sar	 eax, 8
  0007e	66 89 44 24 04	 mov	 WORD PTR carry$[rsp], ax

; 231  : 	}

  00083	eb 9e		 jmp	 SHORT $LN2@add_blocks
$LN1@add_blocks:

; 232  : }

  00085	48 83 c4 18	 add	 rsp, 24
  00089	c3		 ret	 0
add_blocks ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_blocks DD imagerel set_blocks
	DD	imagerel set_blocks+69
	DD	imagerel $unwind$set_blocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_blocks DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_blocks
_TEXT	SEGMENT
i$ = 0
ptr$ = 32
val$ = 40
len$ = 48
set_blocks PROC						; COMDAT

; 204  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 205  : 	gst_dword i;
; 206  : 	for (i = 0; i < len; i++)

  00012	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00019	eb 09		 jmp	 SHORT $LN3@set_blocks@2
$LN2@set_blocks@2:
  0001b	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001e	83 c0 01	 add	 eax, 1
  00021	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN3@set_blocks@2:
  00024	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00028	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0002b	7d 13		 jge	 SHORT $LN1@set_blocks@2

; 207  : 		ptr[i] = val;

  0002d	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  00036	0f b6 44 24 28	 movzx	 eax, BYTE PTR val$[rsp]
  0003b	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  0003e	eb db		 jmp	 SHORT $LN2@set_blocks@2
$LN1@set_blocks@2:

; 208  : }

  00040	48 83 c4 18	 add	 rsp, 24
  00044	c3		 ret	 0
set_blocks ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$move_blocks DD imagerel move_blocks
	DD	imagerel move_blocks+148
	DD	imagerel $unwind$move_blocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$move_blocks DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT move_blocks
_TEXT	SEGMENT
i$ = 0
to$ = 32
from$ = 40
len$ = 48
move_blocks PROC					; COMDAT

; 183  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 184  : 	gst_dword i;
; 185  : 	if (from < to)

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR to$[rsp]
  00018	48 39 44 24 28	 cmp	 QWORD PTR from$[rsp], rax
  0001d	73 39		 jae	 SHORT $LN8@move_block

; 186  : 		for (i = len-1; i >= 0; i--)

  0001f	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00023	83 e8 01	 sub	 eax, 1
  00026	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  00029	eb 09		 jmp	 SHORT $LN7@move_block
$LN6@move_block:
  0002b	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0002e	83 e8 01	 sub	 eax, 1
  00031	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@move_block:
  00034	83 3c 24 00	 cmp	 DWORD PTR i$[rsp], 0
  00038	7c 1c		 jl	 SHORT $LN5@move_block

; 187  : 			to[i] = from[i];

  0003a	4c 63 04 24	 movsxd	 r8, DWORD PTR i$[rsp]
  0003e	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  00042	48 8b 4c 24 20	 mov	 rcx, QWORD PTR to$[rsp]
  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR from$[rsp]
  0004c	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  00051	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00054	eb d5		 jmp	 SHORT $LN6@move_block
$LN5@move_block:

; 188  : 	else

  00056	eb 37		 jmp	 SHORT $LN4@move_block
$LN8@move_block:

; 189  : 		for (i = 0; i < len; i++)

  00058	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0005f	eb 09		 jmp	 SHORT $LN3@move_block
$LN2@move_block:
  00061	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00064	83 c0 01	 add	 eax, 1
  00067	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN3@move_block:
  0006a	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0006e	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00071	7d 1c		 jge	 SHORT $LN1@move_block

; 190  : 			to[i] = from[i];

  00073	4c 63 04 24	 movsxd	 r8, DWORD PTR i$[rsp]
  00077	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR to$[rsp]
  00080	48 8b 44 24 28	 mov	 rax, QWORD PTR from$[rsp]
  00085	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  0008a	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  0008d	eb d2		 jmp	 SHORT $LN2@move_block
$LN1@move_block:
$LN4@move_block:

; 191  : }

  0008f	48 83 c4 18	 add	 rsp, 24
  00093	c3		 ret	 0
move_blocks ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_blocks DD imagerel copy_blocks
	DD	imagerel copy_blocks+79
	DD	imagerel $unwind$copy_blocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_blocks DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT copy_blocks
_TEXT	SEGMENT
i$ = 0
dst$ = 32
src$ = 40
len$ = 48
copy_blocks PROC					; COMDAT

; 166  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 167  : 	gst_dword i;
; 168  : 	for (i = 0; i < len; i++)

  00013	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 09		 jmp	 SHORT $LN3@copy_block@2
$LN2@copy_block@2:
  0001c	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN3@copy_block@2:
  00025	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00029	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0002c	7d 1c		 jge	 SHORT $LN1@copy_block@2

; 169  : 		dst[i] = src[i];

  0002e	4c 63 04 24	 movsxd	 r8, DWORD PTR i$[rsp]
  00032	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  00036	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dst$[rsp]
  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR src$[rsp]
  00040	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  00045	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00048	eb d2		 jmp	 SHORT $LN2@copy_block@2
$LN1@copy_block@2:

; 170  : }

  0004a	48 83 c4 18	 add	 rsp, 24
  0004e	c3		 ret	 0
copy_blocks ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$r DD	imagerel r
	DD	imagerel r+290
	DD	imagerel $unwind$r
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$r DD	011101H
	DD	02211H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT r
_TEXT	SEGMENT
sbox$ = 0
n1$ = 32
n2$ = 40
X$ = 48
r	PROC						; COMDAT

; 58   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 18	 sub	 rsp, 24

; 59   : 	gosthash_s_box *sbox = &GostR3411_94_CryptoProParamSet;

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:GostR3411_94_CryptoProParamSet
  00018	48 89 04 24	 mov	 QWORD PTR sbox$[rsp], rax

; 60   : 	n1 += X;

  0001c	8b 4c 24 30	 mov	 ecx, DWORD PTR X$[rsp]
  00020	8b 44 24 20	 mov	 eax, DWORD PTR n1$[rsp]
  00024	03 c1		 add	 eax, ecx
  00026	89 44 24 20	 mov	 DWORD PTR n1$[rsp], eax

; 61   : 	n1 =  (gst_udword)sbox->k8[(n1>>28)&0xF]<<28 | (gst_udword)sbox->k7[(n1>>24)&0xF]<<24
; 62   : 				| (gst_udword)sbox->k6[(n1>>20)&0xF]<<20 | (gst_udword)sbox->k5[(n1>>16)&0xF]<<16
; 63   : 				| (gst_udword)sbox->k4[(n1>>12)&0xF]<<12 | (gst_udword)sbox->k3[(n1>>8)&0xF]<<8
; 64   : 				| (gst_udword)sbox->k2[(n1>>4)&0xF]<<4 | (gst_udword)sbox->k1[n1&0xF];

  0002a	8b 44 24 20	 mov	 eax, DWORD PTR n1$[rsp]
  0002e	c1 e8 1c	 shr	 eax, 28
  00031	83 e0 0f	 and	 eax, 15
  00034	8b c8		 mov	 ecx, eax
  00036	48 8b 04 24	 mov	 rax, QWORD PTR sbox$[rsp]
  0003a	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0003e	c1 e2 1c	 shl	 edx, 28
  00041	8b 44 24 20	 mov	 eax, DWORD PTR n1$[rsp]
  00045	c1 e8 18	 shr	 eax, 24
  00048	83 e0 0f	 and	 eax, 15
  0004b	8b c8		 mov	 ecx, eax
  0004d	48 8b 04 24	 mov	 rax, QWORD PTR sbox$[rsp]
  00051	0f b6 44 08 10	 movzx	 eax, BYTE PTR [rax+rcx+16]
  00056	c1 e0 18	 shl	 eax, 24
  00059	0b d0		 or	 edx, eax
  0005b	8b 44 24 20	 mov	 eax, DWORD PTR n1$[rsp]
  0005f	c1 e8 14	 shr	 eax, 20
  00062	83 e0 0f	 and	 eax, 15
  00065	8b c8		 mov	 ecx, eax
  00067	48 8b 04 24	 mov	 rax, QWORD PTR sbox$[rsp]
  0006b	0f b6 44 08 20	 movzx	 eax, BYTE PTR [rax+rcx+32]
  00070	c1 e0 14	 shl	 eax, 20
  00073	0b d0		 or	 edx, eax
  00075	8b 44 24 20	 mov	 eax, DWORD PTR n1$[rsp]
  00079	c1 e8 10	 shr	 eax, 16
  0007c	83 e0 0f	 and	 eax, 15
  0007f	8b c8		 mov	 ecx, eax
  00081	48 8b 04 24	 mov	 rax, QWORD PTR sbox$[rsp]
  00085	0f b6 44 08 30	 movzx	 eax, BYTE PTR [rax+rcx+48]
  0008a	c1 e0 10	 shl	 eax, 16
  0008d	0b d0		 or	 edx, eax
  0008f	8b 44 24 20	 mov	 eax, DWORD PTR n1$[rsp]
  00093	c1 e8 0c	 shr	 eax, 12
  00096	83 e0 0f	 and	 eax, 15
  00099	8b c8		 mov	 ecx, eax
  0009b	48 8b 04 24	 mov	 rax, QWORD PTR sbox$[rsp]
  0009f	0f b6 44 08 40	 movzx	 eax, BYTE PTR [rax+rcx+64]
  000a4	c1 e0 0c	 shl	 eax, 12
  000a7	0b d0		 or	 edx, eax
  000a9	8b 44 24 20	 mov	 eax, DWORD PTR n1$[rsp]
  000ad	c1 e8 08	 shr	 eax, 8
  000b0	83 e0 0f	 and	 eax, 15
  000b3	8b c8		 mov	 ecx, eax
  000b5	48 8b 04 24	 mov	 rax, QWORD PTR sbox$[rsp]
  000b9	0f b6 44 08 50	 movzx	 eax, BYTE PTR [rax+rcx+80]
  000be	c1 e0 08	 shl	 eax, 8
  000c1	0b d0		 or	 edx, eax
  000c3	8b 44 24 20	 mov	 eax, DWORD PTR n1$[rsp]
  000c7	c1 e8 04	 shr	 eax, 4
  000ca	83 e0 0f	 and	 eax, 15
  000cd	8b c8		 mov	 ecx, eax
  000cf	48 8b 04 24	 mov	 rax, QWORD PTR sbox$[rsp]
  000d3	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  000d8	c1 e0 04	 shl	 eax, 4
  000db	0b d0		 or	 edx, eax
  000dd	8b 44 24 20	 mov	 eax, DWORD PTR n1$[rsp]
  000e1	83 e0 0f	 and	 eax, 15
  000e4	8b c8		 mov	 ecx, eax
  000e6	48 8b 04 24	 mov	 rax, QWORD PTR sbox$[rsp]
  000ea	0f b6 4c 08 70	 movzx	 ecx, BYTE PTR [rax+rcx+112]
  000ef	8b c2		 mov	 eax, edx
  000f1	0b c1		 or	 eax, ecx
  000f3	89 44 24 20	 mov	 DWORD PTR n1$[rsp], eax

; 65   : 	n1 = gosthash_rotl32(n1, 11);

  000f7	8b 44 24 20	 mov	 eax, DWORD PTR n1$[rsp]
  000fb	c1 e0 0b	 shl	 eax, 11
  000fe	8b 4c 24 20	 mov	 ecx, DWORD PTR n1$[rsp]
  00102	c1 e9 15	 shr	 ecx, 21
  00105	0b c1		 or	 eax, ecx
  00107	89 44 24 20	 mov	 DWORD PTR n1$[rsp], eax

; 66   : 	n2 ^= n1;

  0010b	8b 4c 24 20	 mov	 ecx, DWORD PTR n1$[rsp]
  0010f	8b 44 24 28	 mov	 eax, DWORD PTR n2$[rsp]
  00113	33 c1		 xor	 eax, ecx
  00115	89 44 24 28	 mov	 DWORD PTR n2$[rsp], eax

; 67   : 	return n2;

  00119	8b 44 24 28	 mov	 eax, DWORD PTR n2$[rsp]

; 68   : }

  0011d	48 83 c4 18	 add	 rsp, 24
  00121	c3		 ret	 0
r	ENDP
PUBLIC	GOSTHASH_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$GOSTHASH_init DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$GOSTHASH_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GOSTHASH_init DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GOSTHASH_init
_TEXT	SEGMENT
ctx$ = 48
GOSTHASH_init PROC					; COMDAT

; 324  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 325  : 	set_blocks((byte *)ctx, 0, sizeof(gost_hash_ctx));

  00009	41 b8 68 00 00
	00		 mov	 r8d, 104		; 00000068H
  0000f	33 d2		 xor	 edx, edx
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ctx$[rsp]
  00016	e8 00 00 00 00	 call	 set_blocks

; 326  : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
GOSTHASH_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PSI DD	imagerel PSI
	DD	imagerel PSI+225
	DD	imagerel $unwind$PSI
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PSI DD	010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PSI
_TEXT	SEGMENT
T$ = 32
X$ = 64
PSI	PROC						; COMDAT

; 305  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 306  : 	gst_word T;
; 307  : 
; 308  : 	T = (gst_word)(X[0]^X[2]^X[4]^X[6]^X[24]^X[30])|
; 309  : 		((gst_word)(X[1]^X[3]^X[5]^X[7]^X[25]^X[31])<<8);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  0000e	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  00016	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0001a	33 d0		 xor	 edx, eax
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  00021	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00025	33 d0		 xor	 edx, eax
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  0002c	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00030	33 d0		 xor	 edx, eax
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  00037	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0003b	33 d0		 xor	 edx, eax
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  00042	0f b6 48 1e	 movzx	 ecx, BYTE PTR [rax+30]
  00046	8b c2		 mov	 eax, edx
  00048	33 c1		 xor	 eax, ecx
  0004a	44 0f bf c0	 movsx	 r8d, ax
  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  00053	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  0005c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00060	33 d0		 xor	 edx, eax
  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  00067	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0006b	33 d0		 xor	 edx, eax
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  00072	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  00076	33 d0		 xor	 edx, eax
  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  0007d	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  00081	33 d0		 xor	 edx, eax
  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  00088	0f b6 48 1f	 movzx	 ecx, BYTE PTR [rax+31]
  0008c	8b c2		 mov	 eax, edx
  0008e	33 c1		 xor	 eax, ecx
  00090	0f bf c8	 movsx	 ecx, ax
  00093	c1 e1 08	 shl	 ecx, 8
  00096	41 8b c0	 mov	 eax, r8d
  00099	0b c1		 or	 eax, ecx
  0009b	66 89 44 24 20	 mov	 WORD PTR T$[rsp], ax

; 310  : 	move_blocks(X, X+2, 30);

  000a0	48 8b 54 24 40	 mov	 rdx, QWORD PTR X$[rsp]
  000a5	48 83 c2 02	 add	 rdx, 2
  000a9	41 b8 1e 00 00
	00		 mov	 r8d, 30
  000af	48 8b 4c 24 40	 mov	 rcx, QWORD PTR X$[rsp]
  000b4	e8 00 00 00 00	 call	 move_blocks

; 311  : 	X[30] = (byte)(T&0xFF);

  000b9	0f bf 4c 24 20	 movsx	 ecx, WORD PTR T$[rsp]
  000be	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  000c9	88 48 1e	 mov	 BYTE PTR [rax+30], cl

; 312  : 	X[31] = (byte)(T>>8);

  000cc	0f bf 4c 24 20	 movsx	 ecx, WORD PTR T$[rsp]
  000d1	c1 f9 08	 sar	 ecx, 8
  000d4	48 8b 44 24 40	 mov	 rax, QWORD PTR X$[rsp]
  000d9	88 48 1f	 mov	 BYTE PTR [rax+31], cl

; 313  : }

  000dc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e0	c3		 ret	 0
PSI	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gost_encrypt_with_key DD imagerel gost_encrypt_with_key
	DD	imagerel gost_encrypt_with_key+1458
	DD	imagerel $unwind$gost_encrypt_with_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gost_encrypt_with_key DD 011301H
	DD	0a213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gost_encrypt_with_key
_TEXT	SEGMENT
X5$ = 32
X0$ = 36
i$ = 40
X6$ = 44
X3$ = 48
n1$ = 52
X7$ = 56
X2$ = 60
X1$ = 64
X4$ = 68
n2$ = 72
in$ = 96
out$ = 104
key$ = 112
gost_encrypt_with_key PROC				; COMDAT

; 81   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 82   : 	gst_dword i;
; 83   : 	gst_udword n1, n2;
; 84   : 	gst_udword X0, X1, X2, X3, X4, X5, X6, X7;
; 85   : 
; 86   : 	n1 = (gst_udword)in[3] << 24 | (gst_udword)in[2] << 16 | (gst_udword)in[1] << 8 | (gst_udword)in[0];

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR in$[rsp]
  00018	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  0001c	c1 e2 18	 shl	 edx, 24
  0001f	48 8b 44 24 60	 mov	 rax, QWORD PTR in$[rsp]
  00024	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00028	c1 e0 10	 shl	 eax, 16
  0002b	0b d0		 or	 edx, eax
  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR in$[rsp]
  00032	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00036	c1 e0 08	 shl	 eax, 8
  00039	0b d0		 or	 edx, eax
  0003b	48 8b 44 24 60	 mov	 rax, QWORD PTR in$[rsp]
  00040	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00043	8b c2		 mov	 eax, edx
  00045	0b c1		 or	 eax, ecx
  00047	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 87   : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];

  0004b	48 8b 44 24 60	 mov	 rax, QWORD PTR in$[rsp]
  00050	0f b6 50 07	 movzx	 edx, BYTE PTR [rax+7]
  00054	c1 e2 18	 shl	 edx, 24
  00057	48 8b 44 24 60	 mov	 rax, QWORD PTR in$[rsp]
  0005c	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00060	c1 e0 10	 shl	 eax, 16
  00063	0b d0		 or	 edx, eax
  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR in$[rsp]
  0006a	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0006e	c1 e0 08	 shl	 eax, 8
  00071	0b d0		 or	 edx, eax
  00073	48 8b 44 24 60	 mov	 rax, QWORD PTR in$[rsp]
  00078	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  0007c	8b c2		 mov	 eax, edx
  0007e	0b c1		 or	 eax, ecx
  00080	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 88   : 
; 89   : 	/* Set the 8 round keys */
; 90   : 	X0 = 0;

  00084	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR X0$[rsp], 0

; 91   : 	X1 = 0;

  0008c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR X1$[rsp], 0

; 92   : 	X2 = 0;

  00094	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR X2$[rsp], 0

; 93   : 	X3 = 0;

  0009c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR X3$[rsp], 0

; 94   : 	X4 = 0;

  000a4	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR X4$[rsp], 0

; 95   : 	X5 = 0;

  000ac	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR X5$[rsp], 0

; 96   : 	X6 = 0;

  000b4	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR X6$[rsp], 0

; 97   : 	X7 = 0;

  000bc	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR X7$[rsp], 0

; 98   : 	
; 99   : 	for (i = 0; i < GOSTHASH_GOST_KEYSIZE / 8; i++)

  000c4	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000cc	eb 0b		 jmp	 SHORT $LN3@gost_encry
$LN2@gost_encry:
  000ce	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN3@gost_encry:
  000d9	83 7c 24 28 04	 cmp	 DWORD PTR i$[rsp], 4
  000de	0f 8d 68 01 00
	00		 jge	 $LN1@gost_encry

; 100  : 	{
; 101  : 		X0 |= (gst_udword)key[i + 0] << (i * 8);

  000e4	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR i$[rsp]
  000e9	48 8b 44 24 70	 mov	 rax, QWORD PTR key$[rsp]
  000ee	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  000f2	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000f6	c1 e0 03	 shl	 eax, 3
  000f9	0f b6 c8	 movzx	 ecx, al
  000fc	8b c2		 mov	 eax, edx
  000fe	d3 e0		 shl	 eax, cl
  00100	8b c8		 mov	 ecx, eax
  00102	8b 44 24 24	 mov	 eax, DWORD PTR X0$[rsp]
  00106	0b c1		 or	 eax, ecx
  00108	89 44 24 24	 mov	 DWORD PTR X0$[rsp], eax

; 102  : 		X1 |= (gst_udword)key[i + 4] << (i * 8);

  0010c	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00110	83 c0 04	 add	 eax, 4
  00113	48 63 c8	 movsxd	 rcx, eax
  00116	48 8b 44 24 70	 mov	 rax, QWORD PTR key$[rsp]
  0011b	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0011f	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00123	c1 e0 03	 shl	 eax, 3
  00126	0f b6 c8	 movzx	 ecx, al
  00129	8b c2		 mov	 eax, edx
  0012b	d3 e0		 shl	 eax, cl
  0012d	8b c8		 mov	 ecx, eax
  0012f	8b 44 24 40	 mov	 eax, DWORD PTR X1$[rsp]
  00133	0b c1		 or	 eax, ecx
  00135	89 44 24 40	 mov	 DWORD PTR X1$[rsp], eax

; 103  : 		X2 |= (gst_udword)key[i + 8] << (i * 8);

  00139	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0013d	83 c0 08	 add	 eax, 8
  00140	48 63 c8	 movsxd	 rcx, eax
  00143	48 8b 44 24 70	 mov	 rax, QWORD PTR key$[rsp]
  00148	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0014c	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00150	c1 e0 03	 shl	 eax, 3
  00153	0f b6 c8	 movzx	 ecx, al
  00156	8b c2		 mov	 eax, edx
  00158	d3 e0		 shl	 eax, cl
  0015a	8b c8		 mov	 ecx, eax
  0015c	8b 44 24 3c	 mov	 eax, DWORD PTR X2$[rsp]
  00160	0b c1		 or	 eax, ecx
  00162	89 44 24 3c	 mov	 DWORD PTR X2$[rsp], eax

; 104  : 		X3 |= (gst_udword)key[i + 12] << (i * 8);

  00166	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0016a	83 c0 0c	 add	 eax, 12
  0016d	48 63 c8	 movsxd	 rcx, eax
  00170	48 8b 44 24 70	 mov	 rax, QWORD PTR key$[rsp]
  00175	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00179	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0017d	c1 e0 03	 shl	 eax, 3
  00180	0f b6 c8	 movzx	 ecx, al
  00183	8b c2		 mov	 eax, edx
  00185	d3 e0		 shl	 eax, cl
  00187	8b c8		 mov	 ecx, eax
  00189	8b 44 24 30	 mov	 eax, DWORD PTR X3$[rsp]
  0018d	0b c1		 or	 eax, ecx
  0018f	89 44 24 30	 mov	 DWORD PTR X3$[rsp], eax

; 105  : 		X4 |= (gst_udword)key[i + 16] << (i * 8);

  00193	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00197	83 c0 10	 add	 eax, 16
  0019a	48 63 c8	 movsxd	 rcx, eax
  0019d	48 8b 44 24 70	 mov	 rax, QWORD PTR key$[rsp]
  001a2	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  001a6	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001aa	c1 e0 03	 shl	 eax, 3
  001ad	0f b6 c8	 movzx	 ecx, al
  001b0	8b c2		 mov	 eax, edx
  001b2	d3 e0		 shl	 eax, cl
  001b4	8b c8		 mov	 ecx, eax
  001b6	8b 44 24 44	 mov	 eax, DWORD PTR X4$[rsp]
  001ba	0b c1		 or	 eax, ecx
  001bc	89 44 24 44	 mov	 DWORD PTR X4$[rsp], eax

; 106  : 		X5 |= (gst_udword)key[i + 20] << (i * 8);

  001c0	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001c4	83 c0 14	 add	 eax, 20
  001c7	48 63 c8	 movsxd	 rcx, eax
  001ca	48 8b 44 24 70	 mov	 rax, QWORD PTR key$[rsp]
  001cf	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  001d3	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001d7	c1 e0 03	 shl	 eax, 3
  001da	0f b6 c8	 movzx	 ecx, al
  001dd	8b c2		 mov	 eax, edx
  001df	d3 e0		 shl	 eax, cl
  001e1	8b c8		 mov	 ecx, eax
  001e3	8b 44 24 20	 mov	 eax, DWORD PTR X5$[rsp]
  001e7	0b c1		 or	 eax, ecx
  001e9	89 44 24 20	 mov	 DWORD PTR X5$[rsp], eax

; 107  : 		X6 |= (gst_udword)key[i + 24] << (i * 8);

  001ed	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001f1	83 c0 18	 add	 eax, 24
  001f4	48 63 c8	 movsxd	 rcx, eax
  001f7	48 8b 44 24 70	 mov	 rax, QWORD PTR key$[rsp]
  001fc	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00200	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00204	c1 e0 03	 shl	 eax, 3
  00207	0f b6 c8	 movzx	 ecx, al
  0020a	8b c2		 mov	 eax, edx
  0020c	d3 e0		 shl	 eax, cl
  0020e	8b c8		 mov	 ecx, eax
  00210	8b 44 24 2c	 mov	 eax, DWORD PTR X6$[rsp]
  00214	0b c1		 or	 eax, ecx
  00216	89 44 24 2c	 mov	 DWORD PTR X6$[rsp], eax

; 108  : 		X7 |= (gst_udword)key[i + 28] << (i * 8);

  0021a	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0021e	83 c0 1c	 add	 eax, 28
  00221	48 63 c8	 movsxd	 rcx, eax
  00224	48 8b 44 24 70	 mov	 rax, QWORD PTR key$[rsp]
  00229	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0022d	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00231	c1 e0 03	 shl	 eax, 3
  00234	0f b6 c8	 movzx	 ecx, al
  00237	8b c2		 mov	 eax, edx
  00239	d3 e0		 shl	 eax, cl
  0023b	8b c8		 mov	 ecx, eax
  0023d	8b 44 24 38	 mov	 eax, DWORD PTR X7$[rsp]
  00241	0b c1		 or	 eax, ecx
  00243	89 44 24 38	 mov	 DWORD PTR X7$[rsp], eax

; 109  : 	}

  00247	e9 82 fe ff ff	 jmp	 $LN2@gost_encry
$LN1@gost_encry:

; 110  : 
; 111  : 	/* Encryption rounds 1-24 */
; 112  : 	n2 = r(n1, n2, X0);

  0024c	44 8b 44 24 24	 mov	 r8d, DWORD PTR X0$[rsp]
  00251	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  00255	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00259	e8 00 00 00 00	 call	 r
  0025e	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 113  : 	n1 = r(n2, n1, X1);

  00262	44 8b 44 24 40	 mov	 r8d, DWORD PTR X1$[rsp]
  00267	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  0026b	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  0026f	e8 00 00 00 00	 call	 r
  00274	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 114  : 	n2 = r(n1, n2, X2);

  00278	44 8b 44 24 3c	 mov	 r8d, DWORD PTR X2$[rsp]
  0027d	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  00281	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00285	e8 00 00 00 00	 call	 r
  0028a	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 115  : 	n1 = r(n2, n1, X3);

  0028e	44 8b 44 24 30	 mov	 r8d, DWORD PTR X3$[rsp]
  00293	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  00297	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  0029b	e8 00 00 00 00	 call	 r
  002a0	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 116  : 	n2 = r(n1, n2, X4);

  002a4	44 8b 44 24 44	 mov	 r8d, DWORD PTR X4$[rsp]
  002a9	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  002ad	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  002b1	e8 00 00 00 00	 call	 r
  002b6	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 117  : 	n1 = r(n2, n1, X5);

  002ba	44 8b 44 24 20	 mov	 r8d, DWORD PTR X5$[rsp]
  002bf	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  002c3	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  002c7	e8 00 00 00 00	 call	 r
  002cc	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 118  : 	n2 = r(n1, n2, X6);

  002d0	44 8b 44 24 2c	 mov	 r8d, DWORD PTR X6$[rsp]
  002d5	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  002d9	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  002dd	e8 00 00 00 00	 call	 r
  002e2	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 119  : 	n1 = r(n2, n1, X7);

  002e6	44 8b 44 24 38	 mov	 r8d, DWORD PTR X7$[rsp]
  002eb	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  002ef	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  002f3	e8 00 00 00 00	 call	 r
  002f8	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 120  : 	
; 121  : 	n2 = r(n1, n2, X0);

  002fc	44 8b 44 24 24	 mov	 r8d, DWORD PTR X0$[rsp]
  00301	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  00305	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00309	e8 00 00 00 00	 call	 r
  0030e	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 122  : 	n1 = r(n2, n1, X1);

  00312	44 8b 44 24 40	 mov	 r8d, DWORD PTR X1$[rsp]
  00317	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  0031b	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  0031f	e8 00 00 00 00	 call	 r
  00324	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 123  : 	n2 = r(n1, n2, X2);

  00328	44 8b 44 24 3c	 mov	 r8d, DWORD PTR X2$[rsp]
  0032d	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  00331	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00335	e8 00 00 00 00	 call	 r
  0033a	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 124  : 	n1 = r(n2, n1, X3);

  0033e	44 8b 44 24 30	 mov	 r8d, DWORD PTR X3$[rsp]
  00343	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  00347	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  0034b	e8 00 00 00 00	 call	 r
  00350	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 125  : 	n2 = r(n1, n2, X4);

  00354	44 8b 44 24 44	 mov	 r8d, DWORD PTR X4$[rsp]
  00359	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  0035d	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00361	e8 00 00 00 00	 call	 r
  00366	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 126  : 	n1 = r(n2, n1, X5);

  0036a	44 8b 44 24 20	 mov	 r8d, DWORD PTR X5$[rsp]
  0036f	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  00373	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  00377	e8 00 00 00 00	 call	 r
  0037c	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 127  : 	n2 = r(n1, n2, X6);

  00380	44 8b 44 24 2c	 mov	 r8d, DWORD PTR X6$[rsp]
  00385	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  00389	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  0038d	e8 00 00 00 00	 call	 r
  00392	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 128  : 	n1 = r(n2, n1, X7);

  00396	44 8b 44 24 38	 mov	 r8d, DWORD PTR X7$[rsp]
  0039b	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  0039f	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  003a3	e8 00 00 00 00	 call	 r
  003a8	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 129  : 
; 130  : 	n2 = r(n1, n2, X0);

  003ac	44 8b 44 24 24	 mov	 r8d, DWORD PTR X0$[rsp]
  003b1	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  003b5	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  003b9	e8 00 00 00 00	 call	 r
  003be	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 131  : 	n1 = r(n2, n1, X1);

  003c2	44 8b 44 24 40	 mov	 r8d, DWORD PTR X1$[rsp]
  003c7	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  003cb	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  003cf	e8 00 00 00 00	 call	 r
  003d4	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 132  : 	n2 = r(n1, n2, X2);

  003d8	44 8b 44 24 3c	 mov	 r8d, DWORD PTR X2$[rsp]
  003dd	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  003e1	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  003e5	e8 00 00 00 00	 call	 r
  003ea	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 133  : 	n1 = r(n2, n1, X3);

  003ee	44 8b 44 24 30	 mov	 r8d, DWORD PTR X3$[rsp]
  003f3	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  003f7	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  003fb	e8 00 00 00 00	 call	 r
  00400	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 134  : 	n2 = r(n1, n2, X4);

  00404	44 8b 44 24 44	 mov	 r8d, DWORD PTR X4$[rsp]
  00409	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  0040d	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00411	e8 00 00 00 00	 call	 r
  00416	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 135  : 	n1 = r(n2, n1, X5);

  0041a	44 8b 44 24 20	 mov	 r8d, DWORD PTR X5$[rsp]
  0041f	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  00423	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  00427	e8 00 00 00 00	 call	 r
  0042c	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 136  : 	n2 = r(n1, n2, X6);

  00430	44 8b 44 24 2c	 mov	 r8d, DWORD PTR X6$[rsp]
  00435	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  00439	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  0043d	e8 00 00 00 00	 call	 r
  00442	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 137  : 	n1 = r(n2, n1, X7);

  00446	44 8b 44 24 38	 mov	 r8d, DWORD PTR X7$[rsp]
  0044b	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  0044f	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  00453	e8 00 00 00 00	 call	 r
  00458	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 138  : 
; 139  : 	/* Encryption rounds 25-32 */
; 140  : 	n2 = r(n1, n2, X7);

  0045c	44 8b 44 24 38	 mov	 r8d, DWORD PTR X7$[rsp]
  00461	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  00465	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00469	e8 00 00 00 00	 call	 r
  0046e	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 141  : 	n1 = r(n2, n1, X6);

  00472	44 8b 44 24 2c	 mov	 r8d, DWORD PTR X6$[rsp]
  00477	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  0047b	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  0047f	e8 00 00 00 00	 call	 r
  00484	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 142  : 	n2 = r(n1, n2, X5);

  00488	44 8b 44 24 20	 mov	 r8d, DWORD PTR X5$[rsp]
  0048d	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  00491	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00495	e8 00 00 00 00	 call	 r
  0049a	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 143  : 	n1 = r(n2, n1, X4);

  0049e	44 8b 44 24 44	 mov	 r8d, DWORD PTR X4$[rsp]
  004a3	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  004a7	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  004ab	e8 00 00 00 00	 call	 r
  004b0	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 144  : 	n2 = r(n1, n2, X3);

  004b4	44 8b 44 24 30	 mov	 r8d, DWORD PTR X3$[rsp]
  004b9	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  004bd	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  004c1	e8 00 00 00 00	 call	 r
  004c6	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 145  : 	n1 = r(n2, n1, X2);

  004ca	44 8b 44 24 3c	 mov	 r8d, DWORD PTR X2$[rsp]
  004cf	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  004d3	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  004d7	e8 00 00 00 00	 call	 r
  004dc	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 146  : 	n2 = r(n1, n2, X1);

  004e0	44 8b 44 24 40	 mov	 r8d, DWORD PTR X1$[rsp]
  004e5	8b 54 24 48	 mov	 edx, DWORD PTR n2$[rsp]
  004e9	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  004ed	e8 00 00 00 00	 call	 r
  004f2	89 44 24 48	 mov	 DWORD PTR n2$[rsp], eax

; 147  : 	n1 = r(n2, n1, X0);

  004f6	44 8b 44 24 24	 mov	 r8d, DWORD PTR X0$[rsp]
  004fb	8b 54 24 34	 mov	 edx, DWORD PTR n1$[rsp]
  004ff	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  00503	e8 00 00 00 00	 call	 r
  00508	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 148  : 
; 149  : 	out[0] = (byte)(n2 & 0xFF); out[1] = (byte)((n2 >> 8) & 0xFF); out[2] = (byte)((n2 >> 16) & 0xFF); out[3] = (byte)((n2 >> 24) & 0xFF);

  0050c	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  00510	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00516	48 8b 44 24 68	 mov	 rax, QWORD PTR out$[rsp]
  0051b	88 08		 mov	 BYTE PTR [rax], cl
  0051d	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  00521	c1 e9 08	 shr	 ecx, 8
  00524	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0052a	48 8b 44 24 68	 mov	 rax, QWORD PTR out$[rsp]
  0052f	88 48 01	 mov	 BYTE PTR [rax+1], cl
  00532	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  00536	c1 e9 10	 shr	 ecx, 16
  00539	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0053f	48 8b 44 24 68	 mov	 rax, QWORD PTR out$[rsp]
  00544	88 48 02	 mov	 BYTE PTR [rax+2], cl
  00547	8b 4c 24 48	 mov	 ecx, DWORD PTR n2$[rsp]
  0054b	c1 e9 18	 shr	 ecx, 24
  0054e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00554	48 8b 44 24 68	 mov	 rax, QWORD PTR out$[rsp]
  00559	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 150  : 	out[4] = (byte)(n1 & 0xFF); out[5] = (byte)((n1 >> 8) & 0xFF); out[6] = (byte)((n1 >> 16) & 0xFF); out[7] = (byte)((n1 >> 24) & 0xFF);

  0055c	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00560	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00566	48 8b 44 24 68	 mov	 rax, QWORD PTR out$[rsp]
  0056b	88 48 04	 mov	 BYTE PTR [rax+4], cl
  0056e	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00572	c1 e9 08	 shr	 ecx, 8
  00575	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0057b	48 8b 44 24 68	 mov	 rax, QWORD PTR out$[rsp]
  00580	88 48 05	 mov	 BYTE PTR [rax+5], cl
  00583	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  00587	c1 e9 10	 shr	 ecx, 16
  0058a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00590	48 8b 44 24 68	 mov	 rax, QWORD PTR out$[rsp]
  00595	88 48 06	 mov	 BYTE PTR [rax+6], cl
  00598	8b 4c 24 34	 mov	 ecx, DWORD PTR n1$[rsp]
  0059c	c1 e9 18	 shr	 ecx, 24
  0059f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  005a5	48 8b 44 24 68	 mov	 rax, QWORD PTR out$[rsp]
  005aa	88 48 07	 mov	 BYTE PTR [rax+7], cl

; 151  : }

  005ad	48 83 c4 58	 add	 rsp, 88			; 00000058H
  005b1	c3		 ret	 0
gost_encrypt_with_key ENDP
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$step DD	imagerel step
	DD	imagerel step+733
	DD	imagerel $unwind$step
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$step DD	022819H
	DD	0290116H
	DD	imagerel __GSHandlerCheck
	DD	0130H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT step
_TEXT	SEGMENT
W$ = 40
i$ = 72
S$ = 80
V$ = 112
K$ = 144
U$ = 272
__$ArrayPad$ = 304
H$ = 336
M$ = 344
ctx$ = 352
step	PROC						; COMDAT

; 339  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 340  : 	byte U[32], W[32], V[32], S[32], K[4][32];
; 341  : 	gst_dword i;
; 342  : 	
; 343  : 	xor_blocks(W, H, M, 32);

  00028	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  0002e	4c 8b 84 24 58
	01 00 00	 mov	 r8, QWORD PTR M$[rsp]
  00036	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR H$[rsp]
  0003e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR W$[rsp]
  00043	e8 00 00 00 00	 call	 xor_blocks

; 344  : 	P_transform(W, K[0]); //First key

  00048	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR K$[rsp]
  00050	48 8d 4c 24 28	 lea	 rcx, QWORD PTR W$[rsp]
  00055	e8 00 00 00 00	 call	 P_transform

; 345  : 
; 346  : 	gost_encrypt_with_key (H, S, K[0]);

  0005a	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR K$[rsp]
  00062	48 8d 54 24 50	 lea	 rdx, QWORD PTR S$[rsp]
  00067	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR H$[rsp]
  0006f	e8 00 00 00 00	 call	 gost_encrypt_with_key

; 347  : 
; 348  : 	A (H, U);

  00074	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR U$[rsp]
  0007c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR H$[rsp]
  00084	e8 00 00 00 00	 call	 A

; 349  : 	A (M, V);

  00089	48 8d 54 24 70	 lea	 rdx, QWORD PTR V$[rsp]
  0008e	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR M$[rsp]
  00096	e8 00 00 00 00	 call	 A

; 350  : 	A (V, V);

  0009b	48 8d 54 24 70	 lea	 rdx, QWORD PTR V$[rsp]
  000a0	48 8d 4c 24 70	 lea	 rcx, QWORD PTR V$[rsp]
  000a5	e8 00 00 00 00	 call	 A

; 351  : 	xor_blocks(W, U, V, 32);

  000aa	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  000b0	4c 8d 44 24 70	 lea	 r8, QWORD PTR V$[rsp]
  000b5	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR U$[rsp]
  000bd	48 8d 4c 24 28	 lea	 rcx, QWORD PTR W$[rsp]
  000c2	e8 00 00 00 00	 call	 xor_blocks

; 352  : 	P_transform(W, K[1]); //Second key

  000c7	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR K$[rsp+32]
  000cf	48 8d 4c 24 28	 lea	 rcx, QWORD PTR W$[rsp]
  000d4	e8 00 00 00 00	 call	 P_transform

; 353  : 
; 354  : 	gost_encrypt_with_key (H + 8, S + 8, K[1]);

  000d9	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR K$[rsp+32]
  000e1	48 8d 54 24 58	 lea	 rdx, QWORD PTR S$[rsp+8]
  000e6	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR H$[rsp]
  000ee	48 83 c1 08	 add	 rcx, 8
  000f2	e8 00 00 00 00	 call	 gost_encrypt_with_key

; 355  : 
; 356  : 	A (U, U);

  000f7	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR U$[rsp]
  000ff	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR U$[rsp]
  00107	e8 00 00 00 00	 call	 A

; 357  : 	/* As the other C values are all 0's, we only need to XOR
; 358  :      * with C[3] */
; 359  : 	xor_blocks(U, U, C_3, 32);

  0010c	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  00112	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:C_3
  00119	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR U$[rsp]
  00121	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR U$[rsp]
  00129	e8 00 00 00 00	 call	 xor_blocks

; 360  : 	A (V, V);

  0012e	48 8d 54 24 70	 lea	 rdx, QWORD PTR V$[rsp]
  00133	48 8d 4c 24 70	 lea	 rcx, QWORD PTR V$[rsp]
  00138	e8 00 00 00 00	 call	 A

; 361  : 	A (V, V);

  0013d	48 8d 54 24 70	 lea	 rdx, QWORD PTR V$[rsp]
  00142	48 8d 4c 24 70	 lea	 rcx, QWORD PTR V$[rsp]
  00147	e8 00 00 00 00	 call	 A

; 362  : 	xor_blocks (W, U, V, 32);

  0014c	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  00152	4c 8d 44 24 70	 lea	 r8, QWORD PTR V$[rsp]
  00157	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR U$[rsp]
  0015f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR W$[rsp]
  00164	e8 00 00 00 00	 call	 xor_blocks

; 363  : 	P_transform (W, K[2]); //Third key

  00169	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR K$[rsp+64]
  00171	48 8d 4c 24 28	 lea	 rcx, QWORD PTR W$[rsp]
  00176	e8 00 00 00 00	 call	 P_transform

; 364  : 	
; 365  : 	gost_encrypt_with_key (H + 16, S + 16, K[2]);

  0017b	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR K$[rsp+64]
  00183	48 8d 54 24 60	 lea	 rdx, QWORD PTR S$[rsp+16]
  00188	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR H$[rsp]
  00190	48 83 c1 10	 add	 rcx, 16
  00194	e8 00 00 00 00	 call	 gost_encrypt_with_key

; 366  : 	
; 367  : 	A (U, U);

  00199	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR U$[rsp]
  001a1	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR U$[rsp]
  001a9	e8 00 00 00 00	 call	 A

; 368  : 	A (V, V);

  001ae	48 8d 54 24 70	 lea	 rdx, QWORD PTR V$[rsp]
  001b3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR V$[rsp]
  001b8	e8 00 00 00 00	 call	 A

; 369  : 	A (V, V);

  001bd	48 8d 54 24 70	 lea	 rdx, QWORD PTR V$[rsp]
  001c2	48 8d 4c 24 70	 lea	 rcx, QWORD PTR V$[rsp]
  001c7	e8 00 00 00 00	 call	 A

; 370  : 	xor_blocks (W, U, V, 32);

  001cc	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  001d2	4c 8d 44 24 70	 lea	 r8, QWORD PTR V$[rsp]
  001d7	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR U$[rsp]
  001df	48 8d 4c 24 28	 lea	 rcx, QWORD PTR W$[rsp]
  001e4	e8 00 00 00 00	 call	 xor_blocks

; 371  : 	P_transform (W, K[3]); //Fourth key

  001e9	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR K$[rsp+96]
  001f1	48 8d 4c 24 28	 lea	 rcx, QWORD PTR W$[rsp]
  001f6	e8 00 00 00 00	 call	 P_transform

; 372  : 	
; 373  : 	gost_encrypt_with_key (H + 24, S + 24, K[3]);

  001fb	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR K$[rsp+96]
  00203	48 8d 54 24 68	 lea	 rdx, QWORD PTR S$[rsp+24]
  00208	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR H$[rsp]
  00210	48 83 c1 18	 add	 rcx, 24
  00214	e8 00 00 00 00	 call	 gost_encrypt_with_key

; 374  : 
; 375  : 	for (i = 0; i < 12; i++)

  00219	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00221	eb 0b		 jmp	 SHORT $LN6@step
$LN5@step:
  00223	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00227	83 c0 01	 add	 eax, 1
  0022a	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN6@step:
  0022e	83 7c 24 48 0c	 cmp	 DWORD PTR i$[rsp], 12
  00233	7d 0c		 jge	 SHORT $LN4@step

; 376  : 		PSI (S);

  00235	48 8d 4c 24 50	 lea	 rcx, QWORD PTR S$[rsp]
  0023a	e8 00 00 00 00	 call	 PSI
  0023f	eb e2		 jmp	 SHORT $LN5@step
$LN4@step:

; 377  : 	xor_blocks (S, S, M, 32);

  00241	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  00247	4c 8b 84 24 58
	01 00 00	 mov	 r8, QWORD PTR M$[rsp]
  0024f	48 8d 54 24 50	 lea	 rdx, QWORD PTR S$[rsp]
  00254	48 8d 4c 24 50	 lea	 rcx, QWORD PTR S$[rsp]
  00259	e8 00 00 00 00	 call	 xor_blocks

; 378  : 	PSI (S);

  0025e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR S$[rsp]
  00263	e8 00 00 00 00	 call	 PSI

; 379  : 	xor_blocks (S, S, H, 32);

  00268	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  0026e	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR H$[rsp]
  00276	48 8d 54 24 50	 lea	 rdx, QWORD PTR S$[rsp]
  0027b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR S$[rsp]
  00280	e8 00 00 00 00	 call	 xor_blocks

; 380  : 	for (i = 0; i < 61; i++)

  00285	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0028d	eb 0b		 jmp	 SHORT $LN3@step
$LN2@step:
  0028f	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00293	83 c0 01	 add	 eax, 1
  00296	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN3@step:
  0029a	83 7c 24 48 3d	 cmp	 DWORD PTR i$[rsp], 61	; 0000003dH
  0029f	7d 0c		 jge	 SHORT $LN1@step

; 381  : 		PSI (S);

  002a1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR S$[rsp]
  002a6	e8 00 00 00 00	 call	 PSI
  002ab	eb e2		 jmp	 SHORT $LN2@step
$LN1@step:

; 382  : 	copy_blocks (H, S, 32);

  002ad	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  002b3	48 8d 54 24 50	 lea	 rdx, QWORD PTR S$[rsp]
  002b8	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR H$[rsp]
  002c0	e8 00 00 00 00	 call	 copy_blocks

; 383  : }

  002c5	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002cd	48 33 cc	 xor	 rcx, rsp
  002d0	e8 00 00 00 00	 call	 __security_check_cookie
  002d5	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  002dc	c3		 ret	 0
step	ENDP
PUBLIC	__$ArrayPad$
PUBLIC	GOSTHASH_finalize
;	COMDAT pdata
pdata	SEGMENT
$pdata$GOSTHASH_finalize DD imagerel $LN6
	DD	imagerel $LN6+431
	DD	imagerel $unwind$GOSTHASH_finalize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GOSTHASH_finalize DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GOSTHASH_finalize
_TEXT	SEGMENT
H$ = 40
S$ = 72
final_len$ = 104
buf$ = 112
bptr$ = 144
__$ArrayPad$ = 152
ctx$ = 176
out$ = 184
GOSTHASH_finalize PROC					; COMDAT

; 459  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 460  : 	byte buf[32];
; 461  : 	byte H[32];
; 462  : 	byte S[32];
; 463  : 	gst_dword final_len;
; 464  : 	gst_dword bptr;
; 465  : 
; 466  : 	final_len = ctx->len;

  00023	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ctx$[rsp]
  0002b	8b 00		 mov	 eax, DWORD PTR [rax]
  0002d	89 44 24 68	 mov	 DWORD PTR final_len$[rsp], eax

; 467  : 	
; 468  : 	copy_blocks(H, ctx->H, 32);

  00031	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ctx$[rsp]
  00039	48 83 c2 08	 add	 rdx, 8
  0003d	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00043	48 8d 4c 24 28	 lea	 rcx, QWORD PTR H$[rsp]
  00048	e8 00 00 00 00	 call	 copy_blocks

; 469  : 	copy_blocks(S, ctx->S, 32);

  0004d	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ctx$[rsp]
  00055	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00059	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0005f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR S$[rsp]
  00064	e8 00 00 00 00	 call	 copy_blocks

; 470  : 
; 471  : 	if (ctx->left) //Handle any remaining bytes

  00069	4c 8b 9c 24 b0
	00 00 00	 mov	 r11, QWORD PTR ctx$[rsp]
  00071	41 83 7b 04 00	 cmp	 DWORD PTR [r11+4], 0
  00076	74 76		 je	 SHORT $LN3@GOSTHASH_f

; 472  : 	{
; 473  : 		set_blocks(buf, 0, 32);

  00078	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0007e	33 d2		 xor	 edx, edx
  00080	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$[rsp]
  00085	e8 00 00 00 00	 call	 set_blocks

; 474  : 		copy_blocks(buf, ctx->remainder, (gst_dword)ctx->left);

  0008a	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ctx$[rsp]
  00092	48 83 c2 48	 add	 rdx, 72			; 00000048H
  00096	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ctx$[rsp]
  0009e	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  000a2	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$[rsp]
  000a7	e8 00 00 00 00	 call	 copy_blocks

; 475  : 		step (H, buf, ctx);

  000ac	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR ctx$[rsp]
  000b4	48 8d 54 24 70	 lea	 rdx, QWORD PTR buf$[rsp]
  000b9	48 8d 4c 24 28	 lea	 rcx, QWORD PTR H$[rsp]
  000be	e8 00 00 00 00	 call	 step

; 476  : 		add_blocks (S, buf, 32);

  000c3	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000c9	48 8d 54 24 70	 lea	 rdx, QWORD PTR buf$[rsp]
  000ce	48 8d 4c 24 48	 lea	 rcx, QWORD PTR S$[rsp]
  000d3	e8 00 00 00 00	 call	 add_blocks

; 477  : 		final_len += ctx->left;

  000d8	4c 8b 9c 24 b0
	00 00 00	 mov	 r11, QWORD PTR ctx$[rsp]
  000e0	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  000e4	8b 44 24 68	 mov	 eax, DWORD PTR final_len$[rsp]
  000e8	03 c1		 add	 eax, ecx
  000ea	89 44 24 68	 mov	 DWORD PTR final_len$[rsp], eax
$LN3@GOSTHASH_f:

; 478  : 	}
; 479  : 
; 480  : 	set_blocks(buf, 0, 32);

  000ee	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000f4	33 d2		 xor	 edx, edx
  000f6	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$[rsp]
  000fb	e8 00 00 00 00	 call	 set_blocks

; 481  : 	bptr = 0;

  00100	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR bptr$[rsp], 0

; 482  : 	final_len <<= 3;

  0010b	8b 44 24 68	 mov	 eax, DWORD PTR final_len$[rsp]
  0010f	c1 e0 03	 shl	 eax, 3
  00112	89 44 24 68	 mov	 DWORD PTR final_len$[rsp], eax
$LN2@GOSTHASH_f:

; 483  : 	while (final_len > 0)

  00116	83 7c 24 68 00	 cmp	 DWORD PTR final_len$[rsp], 0
  0011b	7e 34		 jle	 SHORT $LN1@GOSTHASH_f

; 484  : 	{
; 485  : 		buf[bptr++] = (byte)(final_len & 0xFF);

  0011d	8b 4c 24 68	 mov	 ecx, DWORD PTR final_len$[rsp]
  00121	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00127	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR bptr$[rsp]
  0012f	88 4c 04 70	 mov	 BYTE PTR buf$[rsp+rax], cl
  00133	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR bptr$[rsp]
  0013a	83 c0 01	 add	 eax, 1
  0013d	89 84 24 90 00
	00 00		 mov	 DWORD PTR bptr$[rsp], eax

; 486  : 		final_len >>= 8;

  00144	8b 44 24 68	 mov	 eax, DWORD PTR final_len$[rsp]
  00148	c1 f8 08	 sar	 eax, 8
  0014b	89 44 24 68	 mov	 DWORD PTR final_len$[rsp], eax

; 487  : 	}

  0014f	eb c5		 jmp	 SHORT $LN2@GOSTHASH_f
$LN1@GOSTHASH_f:

; 488  : 
; 489  : 	step (H, buf, ctx);

  00151	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR ctx$[rsp]
  00159	48 8d 54 24 70	 lea	 rdx, QWORD PTR buf$[rsp]
  0015e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR H$[rsp]
  00163	e8 00 00 00 00	 call	 step

; 490  : 	step (H, S, ctx);

  00168	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR ctx$[rsp]
  00170	48 8d 54 24 48	 lea	 rdx, QWORD PTR S$[rsp]
  00175	48 8d 4c 24 28	 lea	 rcx, QWORD PTR H$[rsp]
  0017a	e8 00 00 00 00	 call	 step

; 491  : 	copy_blocks (out, H, 32);

  0017f	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00185	48 8d 54 24 28	 lea	 rdx, QWORD PTR H$[rsp]
  0018a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00192	e8 00 00 00 00	 call	 copy_blocks

; 492  : }

  00197	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0019f	48 33 cc	 xor	 rcx, rsp
  001a2	e8 00 00 00 00	 call	 __security_check_cookie
  001a7	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001ae	c3		 ret	 0
GOSTHASH_finalize ENDP
_TEXT	ENDS
PUBLIC	GOSTHASH_add
;	COMDAT pdata
pdata	SEGMENT
$pdata$GOSTHASH_add DD imagerel $LN12
	DD	imagerel $LN12+531
	DD	imagerel $unwind$GOSTHASH_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GOSTHASH_add DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GOSTHASH_add
_TEXT	SEGMENT
curptr$ = 32
barrier$ = 40
add_bytes$ = 48
tv74 = 52
block$ = 80
len$ = 88
ctx$ = 96
GOSTHASH_add PROC					; COMDAT

; 396  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 397  : 	gst_udword add_bytes;
; 398  : 
; 399  : 	byte *curptr = block;

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  00017	48 89 44 24 20	 mov	 QWORD PTR curptr$[rsp], rax

; 400  : 	byte *barrier = block + (len - 32); //In order that curptr += 32 won't overshoot len.

  0001c	8b 44 24 58	 mov	 eax, DWORD PTR len$[rsp]
  00020	83 e8 20	 sub	 eax, 32			; 00000020H
  00023	8b c8		 mov	 ecx, eax
  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  0002a	48 03 c1	 add	 rax, rcx
  0002d	48 89 44 24 28	 mov	 QWORD PTR barrier$[rsp], rax

; 401  : 
; 402  : 	if (ctx->left) //There are unsigned chars left from the last GOSTHASH_add

  00032	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00037	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0003b	0f 84 d9 00 00
	00		 je	 $LN7@GOSTHASH_a

; 403  : 	{
; 404  : 		add_bytes = (32 - ctx->left) > len ? len : (32 - ctx->left);

  00041	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  00046	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0004b	2b 41 04	 sub	 eax, DWORD PTR [rcx+4]
  0004e	3b 44 24 58	 cmp	 eax, DWORD PTR len$[rsp]
  00052	76 0a		 jbe	 SHORT $LN10@GOSTHASH_a
  00054	8b 44 24 58	 mov	 eax, DWORD PTR len$[rsp]
  00058	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
  0005c	eb 11		 jmp	 SHORT $LN11@GOSTHASH_a
$LN10@GOSTHASH_a:
  0005e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  00063	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00068	2b 41 04	 sub	 eax, DWORD PTR [rcx+4]
  0006b	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN11@GOSTHASH_a:
  0006f	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]
  00073	89 44 24 30	 mov	 DWORD PTR add_bytes$[rsp], eax

; 405  : 		copy_blocks(ctx->remainder + (byte)ctx->left, block, (gst_dword)add_bytes);

  00077	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  0007c	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  00080	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00085	48 8d 4c 08 48	 lea	 rcx, QWORD PTR [rax+rcx+72]
  0008a	44 8b 44 24 30	 mov	 r8d, DWORD PTR add_bytes$[rsp]
  0008f	48 8b 54 24 50	 mov	 rdx, QWORD PTR block$[rsp]
  00094	e8 00 00 00 00	 call	 copy_blocks

; 406  : 		if ((ctx->left + add_bytes) < 32) //This can be finished in the finalize stage if needed

  00099	4c 8b 5c 24 60	 mov	 r11, QWORD PTR ctx$[rsp]
  0009e	41 8b 43 04	 mov	 eax, DWORD PTR [r11+4]
  000a2	03 44 24 30	 add	 eax, DWORD PTR add_bytes$[rsp]
  000a6	83 f8 20	 cmp	 eax, 32			; 00000020H
  000a9	73 05		 jae	 SHORT $LN6@GOSTHASH_a

; 407  : 		{
; 408  : 			return;

  000ab	e9 5e 01 00 00	 jmp	 $LN8@GOSTHASH_a
$LN6@GOSTHASH_a:

; 409  : 		}
; 410  : 		
; 411  : 		curptr += add_bytes;

  000b0	8b 4c 24 30	 mov	 ecx, DWORD PTR add_bytes$[rsp]
  000b4	48 8b 44 24 20	 mov	 rax, QWORD PTR curptr$[rsp]
  000b9	48 03 c1	 add	 rax, rcx
  000bc	48 89 44 24 20	 mov	 QWORD PTR curptr$[rsp], rax

; 412  : 		step (ctx->H, ctx->remainder, ctx);

  000c1	48 8b 54 24 60	 mov	 rdx, QWORD PTR ctx$[rsp]
  000c6	48 83 c2 48	 add	 rdx, 72			; 00000048H
  000ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  000cf	48 83 c1 08	 add	 rcx, 8
  000d3	4c 8b 44 24 60	 mov	 r8, QWORD PTR ctx$[rsp]
  000d8	e8 00 00 00 00	 call	 step

; 413  : 		add_blocks(ctx->S, ctx->remainder, 32);

  000dd	48 8b 54 24 60	 mov	 rdx, QWORD PTR ctx$[rsp]
  000e2	48 83 c2 48	 add	 rdx, 72			; 00000048H
  000e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  000eb	48 83 c1 28	 add	 rcx, 40			; 00000028H
  000ef	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000f5	e8 00 00 00 00	 call	 add_blocks

; 414  : 		ctx->len += 32;

  000fa	4c 8b 5c 24 60	 mov	 r11, QWORD PTR ctx$[rsp]
  000ff	41 8b 0b	 mov	 ecx, DWORD PTR [r11]
  00102	83 c1 20	 add	 ecx, 32			; 00000020H
  00105	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  0010a	89 08		 mov	 DWORD PTR [rax], ecx

; 415  : 		ctx->left = 0;

  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00111	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00118	eb 4d		 jmp	 SHORT $LN5@GOSTHASH_a
$LN7@GOSTHASH_a:

; 416  : 	}
; 417  : /**
; 418  :  *
; 419  :  *	\fn else if (ctx->left + len < 32)
; 420  :  *	\brief
; 421  :  *	\param[in] ctx->left +
; 422  :  *	\return
; 423  :  *
; 424  :  */
; 425  : 	else if (ctx->left + len < 32)

  0011a	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  0011f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00122	03 44 24 58	 add	 eax, DWORD PTR len$[rsp]
  00126	83 f8 20	 cmp	 eax, 32			; 00000020H
  00129	73 3c		 jae	 SHORT $LN4@GOSTHASH_a

; 426  : 	{
; 427  : 		copy_blocks(ctx->remainder + (byte)ctx->left, block, (gst_dword)len);

  0012b	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00130	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  00134	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00139	48 8d 4c 08 48	 lea	 rcx, QWORD PTR [rax+rcx+72]
  0013e	44 8b 44 24 58	 mov	 r8d, DWORD PTR len$[rsp]
  00143	48 8b 54 24 50	 mov	 rdx, QWORD PTR block$[rsp]
  00148	e8 00 00 00 00	 call	 copy_blocks

; 428  : 		ctx->left += len;

  0014d	4c 8b 5c 24 60	 mov	 r11, QWORD PTR ctx$[rsp]
  00152	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  00156	03 4c 24 58	 add	 ecx, DWORD PTR len$[rsp]
  0015a	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  0015f	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 429  : 		return;

  00162	e9 a7 00 00 00	 jmp	 $LN8@GOSTHASH_a
$LN4@GOSTHASH_a:
$LN5@GOSTHASH_a:
$LN3@GOSTHASH_a:

; 430  : 	}
; 431  : 
; 432  : 	while (curptr <= barrier) //Add the input block to the hash

  00167	48 8b 44 24 28	 mov	 rax, QWORD PTR barrier$[rsp]
  0016c	48 39 44 24 20	 cmp	 QWORD PTR curptr$[rsp], rax
  00171	77 53		 ja	 SHORT $LN2@GOSTHASH_a

; 433  : 	{
; 434  : 		step(ctx->H, curptr, ctx);

  00173	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  00178	48 83 c1 08	 add	 rcx, 8
  0017c	4c 8b 44 24 60	 mov	 r8, QWORD PTR ctx$[rsp]
  00181	48 8b 54 24 20	 mov	 rdx, QWORD PTR curptr$[rsp]
  00186	e8 00 00 00 00	 call	 step

; 435  : 		
; 436  : 		add_blocks(ctx->S, curptr, 32); //Add 32 unsigned chars of the message to the encrypted message

  0018b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  00190	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00194	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0019a	48 8b 54 24 20	 mov	 rdx, QWORD PTR curptr$[rsp]
  0019f	e8 00 00 00 00	 call	 add_blocks

; 437  : 		
; 438  : 		ctx->len += 32; //We've processed 32 unsigned chars

  001a4	4c 8b 5c 24 60	 mov	 r11, QWORD PTR ctx$[rsp]
  001a9	41 8b 0b	 mov	 ecx, DWORD PTR [r11]
  001ac	83 c1 20	 add	 ecx, 32			; 00000020H
  001af	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  001b4	89 08		 mov	 DWORD PTR [rax], ecx

; 439  : 		curptr += 32; //Advance the block-pointer 32 unsigned chars

  001b6	48 8b 44 24 20	 mov	 rax, QWORD PTR curptr$[rsp]
  001bb	48 83 c0 20	 add	 rax, 32			; 00000020H
  001bf	48 89 44 24 20	 mov	 QWORD PTR curptr$[rsp], rax

; 440  : 	}

  001c4	eb a1		 jmp	 SHORT $LN3@GOSTHASH_a
$LN2@GOSTHASH_a:

; 441  : 
; 442  : 	if (curptr != block + len) //If we have unsigned chars remaining, add them for the next GOSTHASH_add of _finalize

  001c6	8b 4c 24 58	 mov	 ecx, DWORD PTR len$[rsp]
  001ca	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  001cf	48 03 c1	 add	 rax, rcx
  001d2	48 39 44 24 20	 cmp	 QWORD PTR curptr$[rsp], rax
  001d7	74 35		 je	 SHORT $LN1@GOSTHASH_a

; 443  : 	{
; 444  : 		ctx->left = (gst_udword)(block + len - curptr);

  001d9	8b 44 24 58	 mov	 eax, DWORD PTR len$[rsp]
  001dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR block$[rsp]
  001e2	48 03 c8	 add	 rcx, rax
  001e5	48 2b 4c 24 20	 sub	 rcx, QWORD PTR curptr$[rsp]
  001ea	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  001ef	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 445  : 		copy_blocks(ctx->remainder, curptr, (gst_dword)ctx->left);

  001f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  001f7	48 83 c1 48	 add	 rcx, 72			; 00000048H
  001fb	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00200	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00204	48 8b 54 24 20	 mov	 rdx, QWORD PTR curptr$[rsp]
  00209	e8 00 00 00 00	 call	 copy_blocks
$LN1@GOSTHASH_a:
$LN8@GOSTHASH_a:

; 446  : 	}
; 447  : }

  0020e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00212	c3		 ret	 0
GOSTHASH_add ENDP
END
