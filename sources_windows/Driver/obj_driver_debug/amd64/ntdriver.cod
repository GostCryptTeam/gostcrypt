; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	RootDeviceObject
PUBLIC	DriverShuttingDown
PUBLIC	OsMajorVersion
PUBLIC	DriverUnloadDisabled
PUBLIC	PortableMode
PUBLIC	VolumeClassFilterRegistered
PUBLIC	CacheBootPassword
PUBLIC	NonAdminSystemFavoritesAccessDisabled
PUBLIC	??_C@_0BN@IJHBALAF@DriverEntry?5GostCrypt?51?43?41?6?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@JKDEOCBN@GSTCreateRootDeviceObject?5BEGIN?6@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0DB@OPKDMPGO@GSTCreateRootDeviceObject?5NTSTAT@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CO@HAIDILJN@GSTCreateRootDeviceObject?5STATUS@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0BN@PHNPLCFI@GSTCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CN@DMFEOBLG@GSTCreateDeviceObject?5NTSTATUS?5?$DN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CK@MMFHFIAK@GSTCreateDeviceObject?5STATUS_SUC@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@BDAPNECM@IOCTL?5GetMountedVolume?5received?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@BBCNGDEK@Getting?5device?5object?5for?5drive?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CH@OLDNEABP@Checking?5if?5VolumeIsAccessibleFo@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09HOKHNNKO@Check?51?4?4?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03LNENHCAP@2?4?4?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03FPBBFGK@3?4?4?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03JICGCNND@4?4?4?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_07PAKHCJIG@5?4?5ok?4?6?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@HFFKBABD@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EM@MIDFEHFB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@BAABOJFJ@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@EOEOPACH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@IDPGBIEP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DE@GAINGGCN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FG@HBCEKCMI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FK@HGCJBAGN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FG@IMGIDGAD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EK@MMBMBMJA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@IDPKBABP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EO@GLOOMNEL@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EO@DHKDLHAP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@PPEMADCA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@MCFBGJPI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EG@HHHEAACH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@JBCOBEAN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@GDKLDIKK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EI@NOJNBFFK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@DMOEFLGD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EG@IMOGEOLC@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EG@NPJNJBOI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@NDHFIBG@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EO@INPMIMDN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@ONAAGKIP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@OHCBBBLA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@MLCMIONK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@FDLLEINC@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EI@BKLPHECB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EG@HMABOPFD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@GBDFCIBH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CI@DKAFEOJJ@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@MLPMMHHD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EI@DOJOHJF@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@PNIAGIJL@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FG@CELNGCOA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@DKMHFKKB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@NHKGKLDG@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@DCDMLFMB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@OKCPOKLC@GSTDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@IPOBHCAN@GSTDeleteDeviceObject?5END?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@CIHDGGMI@GSTUnloadDriver?5BEGIN?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@ECIECEFH@GSTUnloadDriver?5END?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DA@KKKCGJKE@Mount?5SUCCESS?5GST?5code?5?$DN?50x?$CF08x?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@DOMBPHHO@Mount?5FAILURE?5GST?5code?5?$DN?50x?$CF08x?6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CI@OFAMGLPO@retryDelay?5?$DO?50?5?$CG?$CG?5retryDelay?5?$DM?$DN?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BE@NLKDDOJN@?$AAg?$AAo?$AAs?$AAt?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1HM@FBFGPOIK@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@KPILIDPC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@BHENEMCP@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_PsGetVersion:PROC
EXTRN	__imp_IoGetDeviceInterfaces:PROC
EXTRN	__imp_ObQueryNameString:PROC
EXTRN	GUID_DEVINTERFACE_VOLUME:BYTE
EXTRN	__imp_IoRegisterShutdownNotification:PROC
EXTRN	__imp_KeInitializeSemaphore:PROC
EXTRN	__imp_IoEnumerateDeviceObjectList:PROC
EXTRN	__imp_ObOpenObjectByPointer:PROC
EXTRN	__imp_PsCreateSystemThread:PROC
EXTRN	__imp_SeCreateClientSecurity:PROC
EXTRN	__imp_KeReleaseSemaphore:PROC
EXTRN	__imp_KeInitializeTimerEx:PROC
EXTRN	__imp_KeSetTimerEx:PROC
EXTRN	__imp_wcsncat:PROC
EXTRN	__imp_MmGetSystemRoutineAddress:PROC
EXTRN	__imp_SeTokenType:PROC
EXTRN	__imp_IoGetDeviceObjectPointer:PROC
EXTRN	__imp_ObReferenceObjectByHandle:PROC
EXTRN	__imp_IoBuildSynchronousFsdRequest:PROC
EXTRN	__imp_ObfReferenceObject:PROC
EXTRN	__imp_IoBuildDeviceIoControlRequest:PROC
EXTRN	__imp_IoGetRelatedDeviceObject:PROC
EXTRN	__imp_IoCreateSymbolicLink:PROC
EXTRN	__imp_IoDeleteSymbolicLink:PROC
EXTRN	__imp_RtlLengthSid:PROC
EXTRN	__imp_RtlCopySid:PROC
EXTRN	__imp_ZwQuerySymbolicLinkObject:PROC
EXTRN	__imp_ZwCreateFile:PROC
EXTRN	__imp_ZwOpenSymbolicLinkObject:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_KeQueryActiveProcessors:PROC
EXTRN	__imp_KeDelayExecutionThread:PROC
EXTRN	__imp_ZwQueryValueKey:PROC
EXTRN	__imp_ZwClose:PROC
EXTRN	__imp_ZwOpenKey:PROC
EXTRN	__imp_ZwSetValueKey:PROC
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	__imp_SeCaptureSubjectContext:PROC
EXTRN	__imp_SeReleaseSubjectContext:PROC
EXTRN	__imp_RtlEqualSid:PROC
EXTRN	__imp_SeTokenIsAdmin:PROC
EXTRN	__imp_SeQueryInformationToken:PROC
EXTRN	__imp_KeQueryPerformanceCounter:PROC
COMM	VirtualVolumeDeviceObjects:QWORD:01aH
COMM	LastUniqueVolumeId:DWORD
COMM	OsMinorVersion:DWORD
COMM	SelfTestsPassed:DWORD
COMM	GSTDriverObject:QWORD
RootDeviceObject DQ 01H DUP (?)
DriverShuttingDown DD 01H DUP (?)
OsMajorVersion DD 01H DUP (?)
DriverUnloadDisabled DD 01H DUP (?)
PortableMode DD	01H DUP (?)
VolumeClassFilterRegistered DD 01H DUP (?)
CacheBootPassword DD 01H DUP (?)
NonAdminSystemFavoritesAccessDisabled DD 01H DUP (?)
	ALIGN	8

EncryptionThreadPoolFreeCpuCountLimit DQ 01H DUP (?)
SystemFavoriteVolumeDirty DD 01H DUP (?)
PagingFileCreationPrevented DD 01H DUP (?)
;	COMDAT ??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@ DB 'OsMajorV'
	DB	'ersion != 0', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ DB 'S'
	DB	'kipping bad sector at %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ DB 'Zero'
	DB	'ing sector at %I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@BHENEMCP@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@BHENEMCP@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'E', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'y'
	DB	00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'F', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, 'C', 00H, 'p', 00H, 'u', 00H, 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@ DB 'C'
	DB	'onfiguration flags = 0x%x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@KPILIDPC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@KPILIDPC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i'
	DB	00H, 'g', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1HM@FBFGPOIK@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1HM@FBFGPOIK@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'S', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'g'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@ DB 'Volu'
	DB	'me class filter active', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BE@NLKDDOJN@?$AAg?$AAo?$AAs?$AAt?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BE@NLKDDOJN@?$AAg?$AAo?$AAs?$AAt?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB 'g'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ DB 'U'
	DB	00H, 'p', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'C', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '\', 00H, 'C', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, '\', 00H, '{', 00H, '7', 00H
	DB	'1', 00H, 'A', 00H, '2', 00H, '7', 00H, 'C', 00H, 'D', 00H, 'D'
	DB	00H, '-', 00H, '8', 00H, '1', 00H, '2', 00H, 'A', 00H, '-', 00H
	DB	'1', 00H, '1', 00H, 'D', 00H, '0', 00H, '-', 00H, 'B', 00H, 'E'
	DB	00H, 'C', 00H, '7', 00H, '-', 00H, '0', 00H, '8', 00H, '0', 00H
	DB	'0', 00H, '2', 00H, 'B', 00H, 'E', 00H, '2', 00H, '0', 00H, '9'
	DB	00H, '2', 00H, 'F', 00H, '}', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CI@OFAMGLPO@retryDelay?5?$DO?50?5?$CG?$CG?5retryDelay?5?$DM?$DN?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CI@OFAMGLPO@retryDelay?5?$DO?50?5?$CG?$CG?5retryDelay?5?$DM?$DN?5@FNODOBFM@ DB 'r'
	DB	'etryDelay > 0 && retryDelay <= timeout', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@ DB '('
	DB	'maxSizeInBytes & 1) == 0', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@
text$s	SEGMENT
??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@ DB '!'
	DB	'IoIsSystemThread (PsGetCurrentThread())', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@ DB 'Unmountin'
	DB	'g all volumes', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@ DB 'FS'
	DB	'CTL_DISMOUNT_VOLUME returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@ DB 'F'
	DB	'SCTL_LOCK_VOLUME returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@ DB 'UnmountDevice'
	DB	' %d', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@DOMBPHHO@Mount?5FAILURE?5GST?5code?5?$DN?50x?$CF08x?6@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@DOMBPHHO@Mount?5FAILURE?5GST?5code?5?$DN?50x?$CF08x?6@FNODOBFM@ DB 'M'
	DB	'ount FAILURE GST code = 0x%08x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DA@KKKCGJKE@Mount?5SUCCESS?5GST?5code?5?$DN?50x?$CF08x?5@FNODOBFM@
text$s	SEGMENT
??_C@_0DA@KKKCGJKE@Mount?5SUCCESS?5GST?5code?5?$DN?50x?$CF08x?5@FNODOBFM@ DB 'M'
	DB	'ount SUCCESS GST code = 0x%08x READ-ONLY = %d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@ DB 'Mou'
	DB	'nt FAILURE NT ERROR, ntStatus = 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@ DB 'Mo'
	DB	'unt CREATE DEVICE ERROR, ntStatus = 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@ DB 'WA'
	DB	'RNING: MOUNT DRIVE LETTER INVALID', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@ DB 'Mount'
	DB	' request looks valid', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@ DB 'IOCTL_'
	DB	'MOUNTMGR_DELETE_POINTS returned 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'P'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'M', 00H, 'a', 00H
	DB	'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@ DB 'Io'
	DB	'DeleteSymbolicLink returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@ DB 'Io'
	DB	'CreateSymbolicLink returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@ DB 'K'
	DB	'eGetCurrentIrql() <= APC_LEVEL', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@ DB 'V'
	DB	'olume %ls open NTSTATUS 0x%08x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@ DB 'R'
	DB	'eal drive size = %I64d bytes (%I64d hidden)', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@ DB 'F'
	DB	'ailed to get drive size - error %x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@ DB 'IRP alloca'
	DB	'tion failed', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@ECIECEFH@GSTUnloadDriver?5END?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@ECIECEFH@GSTUnloadDriver?5END?6?$AA@FNODOBFM@ DB 'GSTUnloadDriv'
	DB	'er END', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@CIHDGGMI@GSTUnloadDriver?5BEGIN?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@CIHDGGMI@GSTUnloadDriver?5BEGIN?6?$AA@FNODOBFM@ DB 'GSTUnloadDr'
	DB	'iver BEGIN', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@IPOBHCAN@GSTDeleteDeviceObject?5END?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@IPOBHCAN@GSTDeleteDeviceObject?5END?6?$AA@FNODOBFM@ DB 'GSTDele'
	DB	'teDeviceObject END', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ DB 'P'
	DB	00H, 's', 00H, 'D', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'I'
	DB	00H, 'm', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'o', 00H
	DB	'n', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@
text$s	SEGMENT
??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@ DB 'IoDel'
	DB	'eteSymbolicLink failed ntStatus = 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'G', 00H, 'o'
	DB	00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@OKCPOKLC@GSTDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@OKCPOKLC@GSTDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@ DB 'GSTDe'
	DB	'leteDeviceObject BEGIN', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@ DB 'I', 00H
	DB	'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'D', 00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, '_'
	DB	00H, 'C', 00H, 'O', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'O', 00H
	DB	'L', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'S', 00H, 'H', 00H, 'U', 00H, 'T', 00H, 'D', 00H, 'O', 00H, 'W'
	DB	00H, 'N', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'F', 00H, 'L', 00H, 'U', 00H, 'S', 00H, 'H', 00H, '_', 00H, 'B'
	DB	00H, 'U', 00H, 'F', 00H, 'F', 00H, 'E', 00H, 'R', 00H, 'S', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'C', 00H, 'L', 00H, 'E', 00H, 'A', 00H, 'N', 00H, 'U', 00H, 'P'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'C', 00H, 'L', 00H, 'O', 00H, 'S', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'C', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'T', 00H, 'E', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'W', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'R', 00H, 'E', 00H, 'A', 00H, 'D', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'O', 00H, 'R', 00H, 'A', 00H, 'G', 00H, 'E', 00H, '_'
	DB	00H, 'S', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'H', 00H, 'O', 00H
	DB	'T', 00H, 'P', 00H, 'L', 00H, 'U', 00H, 'G', 00H, '_', 00H, 'I'
	DB	00H, 'N', 00H, 'F', 00H, 'O', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'M', 00H, 'E', 00H, 'D', 00H, 'I', 00H, 'A', 00H
	DB	'_', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H, 'S', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'F', 00H, 'I', 00H, 'N'
	DB	00H, 'D', 00H, '_', 00H, 'N', 00H, 'E', 00H, 'W', 00H, '_', 00H
	DB	'D', 00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, 'S'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'L'
	DB	00H, 'E', 00H, 'A', 00H, 'S', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'S'
	DB	00H, 'E', 00H, 'R', 00H, 'V', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'L', 00H, 'O', 00H, 'A'
	DB	00H, 'D', 00H, '_', 00H, 'M', 00H, 'E', 00H, 'D', 00H, 'I', 00H
	DB	'A', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'E', 00H, 'J', 00H, 'E'
	DB	00H, 'C', 00H, 'T', 00H, '_', 00H, 'M', 00H, 'E', 00H, 'D', 00H
	DB	'I', 00H, 'A', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'M', 00H, 'E', 00H, 'D'
	DB	00H, 'I', 00H, 'A', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'M', 00H
	DB	'O', 00H, 'V', 00H, 'A', 00H, 'L', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'E'
	DB	00H, 'C', 00H, 'K', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R', 00H
	DB	'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, 'E', 00H, 'R', 00H, 'N', 00H, 'A', 00H, 'L', 00H, '_', 00H
	DB	'C', 00H, 'L', 00H, 'E', 00H, 'A', 00H, 'R', 00H, '_', 00H, 'V'
	DB	00H, 'E', 00H, 'R', 00H, 'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, 'E', 00H, 'R', 00H, 'N', 00H, 'A', 00H, 'L', 00H, '_', 00H
	DB	'S', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R'
	DB	00H, 'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ DB 'S'
	DB	00H, 'M', 00H, 'A', 00H, 'R', 00H, 'T', 00H, '_', 00H, 'R', 00H
	DB	'C', 00H, 'V', 00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V'
	DB	00H, 'E', 00H, '_', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@ DB 'S'
	DB	00H, 'M', 00H, 'A', 00H, 'R', 00H, 'T', 00H, '_', 00H, 'S', 00H
	DB	'E', 00H, 'N', 00H, 'D', 00H, '_', 00H, 'D', 00H, 'R', 00H, 'I'
	DB	00H, 'V', 00H, 'E', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'M', 00H
	DB	'M', 00H, 'A', 00H, 'N', 00H, 'D', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ DB 'S'
	DB	00H, 'M', 00H, 'A', 00H, 'R', 00H, 'T', 00H, '_', 00H, 'G', 00H
	DB	'E', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R', 00H, 'S'
	DB	00H, 'I', 00H, 'O', 00H, 'N', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N'
	DB	00H, 'T', 00H, 'R', 00H, 'O', 00H, 'L', 00H, 'L', 00H, 'E', 00H
	DB	'R', 00H, '_', 00H, 'N', 00H, 'U', 00H, 'M', 00H, 'B', 00H, 'E'
	DB	00H, 'R', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'Q'
	DB	00H, 'U', 00H, 'E', 00H, 'S', 00H, 'T', 00H, '_', 00H, 'D', 00H
	DB	'A', 00H, 'T', 00H, 'A', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'Q'
	DB	00H, 'U', 00H, 'E', 00H, 'S', 00H, 'T', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'R', 00H, 'U', 00H, 'C', 00H, 'T', 00H, 'U', 00H, 'R'
	DB	00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'S'
	DB	00H, 'T', 00H, 'O', 00H, 'G', 00H, 'R', 00H, 'A', 00H, 'M', 00H
	DB	'_', 00H, 'R', 00H, 'E', 00H, 'S', 00H, 'E', 00H, 'T', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'S'
	DB	00H, 'T', 00H, 'O', 00H, 'G', 00H, 'R', 00H, 'A', 00H, 'M', 00H
	DB	'_', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'S'
	DB	00H, 'T', 00H, 'O', 00H, 'G', 00H, 'R', 00H, 'A', 00H, 'M', 00H
	DB	'_', 00H, 'S', 00H, 'T', 00H, 'R', 00H, 'U', 00H, 'C', 00H, 'T'
	DB	00H, 'U', 00H, 'R', 00H, 'E', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'F', 00H, 'O', 00H, 'R'
	DB	00H, 'M', 00H, 'A', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'R', 00H
	DB	'A', 00H, 'C', 00H, 'K', 00H, 'S', 00H, '_', 00H, 'E', 00H, 'X'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'L', 00H, 'O', 00H, 'G'
	DB	00H, 'G', 00H, 'I', 00H, 'N', 00H, 'G', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_'
	DB	00H, 'W', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'A', 00H, 'B', 00H
	DB	'L', 00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'P', 00H, 'E', 00H, 'R'
	DB	00H, 'F', 00H, 'O', 00H, 'R', 00H, 'M', 00H, 'A', 00H, 'N', 00H
	DB	'C', 00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'A'
	DB	00H, 'S', 00H, 'S', 00H, 'I', 00H, 'G', 00H, 'N', 00H, '_', 00H
	DB	'B', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'K', 00H, 'S', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'F', 00H, 'O', 00H, 'R'
	DB	00H, 'M', 00H, 'A', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'R', 00H
	DB	'A', 00H, 'C', 00H, 'K', 00H, 'S', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R'
	DB	00H, 'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'L', 00H, 'A', 00H, 'Y', 00H, 'O', 00H, 'U', 00H, 'T'
	DB	00H, '_', 00H, 'E', 00H, 'X', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'L', 00H, 'A', 00H, 'Y', 00H, 'O', 00H, 'U', 00H, 'T'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'I', 00H, 'N'
	DB	00H, 'F', 00H, 'O', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'I', 00H, 'N'
	DB	00H, 'F', 00H, 'O', 00H, '_', 00H, 'E', 00H, 'X', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'I', 00H, 'N'
	DB	00H, 'F', 00H, 'O', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'O', 00H, 'R', 00H, 'A', 00H, 'G', 00H, 'E', 00H, '_'
	DB	00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D', 00H, 'E', 00H
	DB	'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, '_', 00H, 'N', 00H, 'U'
	DB	00H, 'M', 00H, 'B', 00H, 'E', 00H, 'R', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'L', 00H, 'E', 00H, 'N', 00H, 'G', 00H, 'T', 00H
	DB	'H', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'F', 00H, 'O', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'M', 00H, 'G', 00H, 'R'
	DB	00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H
	DB	'_', 00H, 'D', 00H, 'E', 00H, 'L', 00H, 'E', 00H, 'T', 00H, 'E'
	DB	00H, 'D', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'M', 00H, 'G', 00H, 'R'
	DB	00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H
	DB	'_', 00H, 'C', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'T', 00H, 'E'
	DB	00H, 'D', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'M', 00H, 'G', 00H, 'R'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 'S'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'K', 00H, '_', 00H
	DB	'D', 00H, 'E', 00H, 'L', 00H, 'E', 00H, 'T', 00H, 'E', 00H, 'D'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'K', 00H, '_', 00H
	DB	'C', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'T', 00H, 'E', 00H, 'D'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'V', 00H
	DB	'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'O'
	DB	00H, 'N', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'U', 00H, 'N', 00H, 'I', 00H, 'Q', 00H, 'U', 00H, 'E'
	DB	00H, '_', 00H, 'I', 00H, 'D', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@
text$s	SEGMENT
??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'S', 00H, 'U', 00H, 'G', 00H, 'G', 00H, 'E', 00H, 'S'
	DB	00H, 'T', 00H, 'E', 00H, 'D', 00H, '_', 00H, 'L', 00H, 'I', 00H
	DB	'N', 00H, 'K', 00H, '_', 00H, 'N', 00H, 'A', 00H, 'M', 00H, 'E'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'D', 00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E'
	DB	00H, '_', 00H, 'N', 00H, 'A', 00H, 'M', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'G', 00H, 'E', 00H, 'O', 00H, 'M', 00H, 'E', 00H, 'T'
	DB	00H, 'R', 00H, 'Y', 00H, '_', 00H, 'E', 00H, 'X', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'G', 00H, 'E', 00H, 'O', 00H, 'M', 00H, 'E', 00H, 'T'
	DB	00H, 'R', 00H, 'Y', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@
text$s	SEGMENT
??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'V', 00H
	DB	'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'G'
	DB	00H, 'E', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H
	DB	'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S'
	DB	00H, 'K', 00H, '_', 00H, 'E', 00H, 'X', 00H, 'T', 00H, 'E', 00H
	DB	'N', 00H, 'T', 00H, 'S', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@DCDMLFMB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@DCDMLFMB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'W', 00H, 'R', 00H, 'I', 00H, 'T'
	DB	00H, 'E', 00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H
	DB	'_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_'
	DB	00H, 'S', 00H, 'E', 00H, 'C', 00H, 'T', 00H, 'O', 00H, 'R', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@NHKGKLDG@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@NHKGKLDG@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'S', 00H, 'S', 00H, 'W', 00H
	DB	'O', 00H, 'R', 00H, 'D', 00H, '_', 00H, 'C', 00H, 'A', 00H, 'C'
	DB	00H, 'H', 00H, 'E', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@DKMHFKKB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@DKMHFKKB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'R'
	DB	00H, 'T', 00H, '_', 00H, 'D', 00H, 'E', 00H, 'C', 00H, 'O', 00H
	DB	'Y', 00H, '_', 00H, 'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E'
	DB	00H, 'M', 00H, '_', 00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FG@CELNGCOA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO@FNODOBFM@
text$s	SEGMENT
??_C@_1FG@CELNGCOA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H
	DB	'_', 00H, 'F', 00H, 'A', 00H, 'V', 00H, 'O', 00H, 'R', 00H, 'I'
	DB	00H, 'T', 00H, 'E', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H
	DB	'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'R'
	DB	00H, 'T', 00H, 'Y', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@PNIAGIJL@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@PNIAGIJL@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'R', 00H, 'E'
	DB	00H, 'A', 00H, 'D', 00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H
	DB	'V', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N'
	DB	00H, 'F', 00H, 'I', 00H, 'G', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EI@DOJOHJF@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA@FNODOBFM@
text$s	SEGMENT
??_C@_1EI@DOJOHJF@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'O', 00H, 'P'
	DB	00H, 'E', 00H, 'N', 00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H
	DB	'T', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M'
	DB	00H, 'E', 00H, '_', 00H, 'H', 00H, 'E', 00H, 'A', 00H, 'D', 00H
	DB	'E', 00H, 'R', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@MLPMMHHD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@MLPMMHHD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'P', 00H, 'R', 00H, 'O', 00H, 'B'
	DB	00H, 'E', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'L', 00H
	DB	'_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_'
	DB	00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CI@DKAFEOJJ@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CI@DKAFEOJJ@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'O', 00H, 'P', 00H, 'E', 00H, 'N'
	DB	00H, '_', 00H, 'T', 00H, 'E', 00H, 'S', 00H, 'T', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@GBDFCIBH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@GBDFCIBH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N'
	DB	00H, 'T', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H
	DB	'M', 00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EG@HMABOPFD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI@FNODOBFM@
text$s	SEGMENT
??_C@_1EG@HMABOPFD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'H'
	DB	00H, 'I', 00H, 'D', 00H, 'D', 00H, 'E', 00H, 'N', 00H, '_', 00H
	DB	'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_'
	DB	00H, 'R', 00H, 'U', 00H, 'N', 00H, 'N', 00H, 'I', 00H, 'N', 00H
	DB	'G', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EI@BKLPHECB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB@FNODOBFM@
text$s	SEGMENT
??_C@_1EI@BKLPHECB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'D'
	DB	00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, 'R', 00H, '_', 00H
	DB	'U', 00H, 'N', 00H, 'L', 00H, 'O', 00H, 'A', 00H, 'D', 00H, '_'
	DB	00H, 'D', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'B', 00H, 'L', 00H
	DB	'E', 00H, 'D', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@FDLLEINC@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@FDLLEINC@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'A'
	DB	00H, 'N', 00H, 'Y', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H
	DB	'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U'
	DB	00H, 'N', 00H, 'T', 00H, 'E', 00H, 'D', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@MLCMIONK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@MLCMIONK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S', 00H, 'K'
	DB	00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'W', 00H, 'R', 00H
	DB	'I', 00H, 'T', 00H, 'A', 00H, 'B', 00H, 'L', 00H, 'E', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@OHCBBBLA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@OHCBBBLA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'W', 00H, 'A', 00H, 'R', 00H, 'N', 00H, 'I', 00H, 'N', 00H
	DB	'G', 00H, '_', 00H, 'F', 00H, 'L', 00H, 'A', 00H, 'G', 00H, 'S'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@ONAAGKIP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@ONAAGKIP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H
	DB	'_', 00H, 'P', 00H, 'R', 00H, 'O', 00H, 'P', 00H, 'E', 00H, 'R'
	DB	00H, 'T', 00H, 'I', 00H, 'E', 00H, 'S', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EO@INPMIMDN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_@FNODOBFM@
text$s	SEGMENT
??_C@_1EO@INPMIMDN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H
	DB	'_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_'
	DB	00H, 'D', 00H, 'U', 00H, 'M', 00H, 'P', 00H, '_', 00H, 'C', 00H
	DB	'O', 00H, 'N', 00H, 'F', 00H, 'I', 00H, 'G', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@NDHFIBG@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@NDHFIBG@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'R', 00H, 'E', 00H, 'S', 00H, 'O', 00H, 'L', 00H, 'V', 00H
	DB	'E', 00H, 'D', 00H, '_', 00H, 'S', 00H, 'Y', 00H, 'M', 00H, 'L'
	DB	00H, 'I', 00H, 'N', 00H, 'K', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EG@NPJNJBOI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@
text$s	SEGMENT
??_C@_1EG@NPJNJBOI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'P', 00H, 'O', 00H, 'R', 00H, 'T', 00H, 'A', 00H, 'B', 00H
	DB	'L', 00H, 'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'D', 00H, 'E'
	DB	00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'U', 00H
	DB	'S', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EG@IMOGEOLC@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@
text$s	SEGMENT
??_C@_1EG@IMOGEOLC@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'P', 00H, 'O', 00H, 'R', 00H, 'T', 00H, 'A', 00H, 'B', 00H
	DB	'L', 00H, 'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'D', 00H, 'E'
	DB	00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'U', 00H
	DB	'S', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@DMOEFLGD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@DMOEFLGD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H
	DB	'_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_'
	DB	00H, 'C', 00H, 'O', 00H, 'N', 00H, 'F', 00H, 'I', 00H, 'G', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EI@NOJNBFFK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA@FNODOBFM@
text$s	SEGMENT
??_C@_1EI@NOJNBFFK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'P', 00H, 'A', 00H, 'S', 00H, 'S', 00H, 'W', 00H, 'O', 00H
	DB	'R', 00H, 'D', 00H, '_', 00H, 'C', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'E', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H
	DB	'U', 00H, 'S', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@GDKLDIKK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@GDKLDIKK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'E', 00H
	DB	'D', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M'
	DB	00H, 'E', 00H, 'S', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@JBCOBEAN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@JBCOBEAN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, 'R', 00H
	DB	'_', 00H, 'V', 00H, 'E', 00H, 'R', 00H, 'S', 00H, 'I', 00H, 'O'
	DB	00H, 'N', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EG@HHHEAACH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1EG@HHHEAACH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H
	DB	'P', 00H, 'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H, 'T', 00H, 'I'
	DB	00H, 'O', 00H, 'N', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'F', 00H
	DB	'O', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@MCFBGJPI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@MCFBGJPI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H
	DB	'G', 00H, 'E', 00H, 'O', 00H, 'M', 00H, 'E', 00H, 'T', 00H, 'R'
	DB	00H, 'Y', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@PPEMADCA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@PPEMADCA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'D', 00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H
	DB	'_', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'C', 00H, 'O', 00H, 'U'
	DB	00H, 'N', 00H, 'T', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EO@DHKDLHAP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_@FNODOBFM@
text$s	SEGMENT
??_C@_1EO@DHKDLHAP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'D', 00H, 'E', 00H, 'C', 00H, 'O', 00H, 'Y', 00H, '_', 00H
	DB	'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_'
	DB	00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'A', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EO@GLOOMNEL@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_@FNODOBFM@
text$s	SEGMENT
??_C@_1EO@GLOOMNEL@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'D', 00H, 'E', 00H, 'C', 00H, 'O', 00H, 'Y', 00H, '_', 00H
	DB	'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_'
	DB	00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E', 00H, '_', 00H, 'R', 00H
	DB	'E', 00H, 'S', 00H, 'U', 00H, 'L', 00H, 'T', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@IDPKBABP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@IDPKBABP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'L', 00H
	DB	'O', 00H, 'A', 00H, 'D', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'V'
	DB	00H, 'E', 00H, 'R', 00H, 'S', 00H, 'I', 00H, 'O', 00H, 'N', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EK@MMBMBMJA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT@FNODOBFM@
text$s	SEGMENT
??_C@_1EK@MMBMBMJA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'E', 00H
	DB	'N', 00H, 'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T', 00H, 'I'
	DB	00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H
	DB	'T', 00H, 'U', 00H, 'S', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FG@IMGIDGAD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE@FNODOBFM@
text$s	SEGMENT
??_C@_1FG@IMGIDGAD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'E', 00H
	DB	'N', 00H, 'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T', 00H, 'I'
	DB	00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H
	DB	'U', 00H, 'P', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'S', 00H, 'U'
	DB	00H, 'L', 00H, 'T', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FK@HGCJBAGN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL@FNODOBFM@
text$s	SEGMENT
??_C@_1FK@HGCJBAGN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'E', 00H
	DB	'N', 00H, 'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T', 00H, 'I'
	DB	00H, 'O', 00H, 'N', 00H, '_', 00H, 'A', 00H, 'L', 00H, 'G', 00H
	DB	'O', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'H', 00H, 'M', 00H, '_'
	DB	00H, 'N', 00H, 'A', 00H, 'M', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FG@HBCEKCMI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_@FNODOBFM@
text$s	SEGMENT
??_C@_1FG@HBCEKCMI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'D', 00H
	DB	'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'V', 00H, 'O'
	DB	00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'P', 00H
	DB	'R', 00H, 'O', 00H, 'P', 00H, 'E', 00H, 'R', 00H, 'T', 00H, 'I'
	DB	00H, 'E', 00H, 'S', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DE@GAINGGCN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@GAINGGCN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S', 00H, 'M'
	DB	00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'V', 00H
	DB	'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@IDPGBIEP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@IDPGBIEP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S', 00H, 'M'
	DB	00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'A', 00H
	DB	'L', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U'
	DB	00H, 'M', 00H, 'E', 00H, 'S', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@EOEOPACH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@EOEOPACH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T'
	DB	00H, '_', 00H, 'E', 00H, 'N', 00H, 'C', 00H, 'R', 00H, 'Y', 00H
	DB	'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'S'
	DB	00H, 'E', 00H, 'T', 00H, 'U', 00H, 'P', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@BAABOJFJ@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@BAABOJFJ@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'A', 00H, 'B', 00H, 'O', 00H, 'R'
	DB	00H, 'T', 00H, '_', 00H, 'D', 00H, 'E', 00H, 'C', 00H, 'O', 00H
	DB	'Y', 00H, '_', 00H, 'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E'
	DB	00H, 'M', 00H, '_', 00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EM@MIDFEHFB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_@FNODOBFM@
text$s	SEGMENT
??_C@_1EM@MIDFEHFB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_@FNODOBFM@ DB 'G'
	DB	00H, 'S', 00H, 'T', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H
	DB	'T', 00H, 'L', 00H, '_', 00H, 'A', 00H, 'B', 00H, 'O', 00H, 'R'
	DB	00H, 'T', 00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H
	DB	'_', 00H, 'E', 00H, 'N', 00H, 'C', 00H, 'R', 00H, 'Y', 00H, 'P'
	DB	00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H
	DB	'E', 00H, 'T', 00H, 'U', 00H, 'P', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@HFFKBABD@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@HFFKBABD@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@ DB 'Closing volume', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@ DB 'i'
	DB	'rpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@
text$s	SEGMENT
??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@ DB 'M'
	DB	'ount THREAD request for File %ls DriveNumber %d Device = %d', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ DB '\', 00H
	DB	'?', 00H, '?', 00H, '\', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@ DB 'Mou'
	DB	'nt THREAD OPENING VOLUME BEGIN', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@ DB 'Thread exited', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@ DB 'NT_SUCC'
	DB	'ESS (ntStatus)', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@ DB 'S'
	DB	'ignalling thread to quit...', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@
text$s	SEGMENT
??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@ DB 'W'
	DB	'aiting completed! Thread returns 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@ DB 'Wait'
	DB	'ing for thread to initialize...', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@ DB 'PsCr'
	DB	'eateSystemThread Failed END', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@ DB 'Starting th'
	DB	'read...', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@ DB 'IOCTL erro'
	DB	'r 0x%08x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_07PAKHCJIG@5?4?5ok?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_07PAKHCJIG@5?4?5ok?4?6?$AA@FNODOBFM@ DB '5. ok.', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03JICGCNND@4?4?4?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03JICGCNND@4?4?4?$AA@FNODOBFM@ DB '4..', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03FPBBFGK@3?4?4?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03FPBBFGK@3?4?4?$AA@FNODOBFM@ DB '3..', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03LNENHCAP@2?4?4?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03LNENHCAP@2?4?4?$AA@FNODOBFM@ DB '2..', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09HOKHNNKO@Check?51?4?4?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09HOKHNNKO@Check?51?4?4?$AA@FNODOBFM@ DB 'Check 1..', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CH@OLDNEABP@Checking?5if?5VolumeIsAccessibleFo@FNODOBFM@
text$s	SEGMENT
??_C@_0CH@OLDNEABP@Checking?5if?5VolumeIsAccessibleFo@FNODOBFM@ DB 'Check'
	DB	'ing if VolumeIsAccessibleForUSer.', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@BBCNGDEK@Getting?5device?5object?5for?5drive?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@BBCNGDEK@Getting?5device?5object?5for?5drive?5@FNODOBFM@ DB 'Ge'
	DB	'tting device object for drive %d .', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@BDAPNECM@IOCTL?5GetMountedVolume?5received?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@BDAPNECM@IOCTL?5GetMountedVolume?5received?$AA@FNODOBFM@ DB 'IO'
	DB	'CTL GetMountedVolume received', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@ DB 'Setting po'
	DB	'rtable mode', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@ DB 'O'
	DB	'pen test on file %ls success.', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@ DB 'GostCrypt', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ DB 'I'
	DB	'OCTL error 0x%08x (0x%x %d)', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@ DB 'link = %ls', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@ DB 'id = %s', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@FNODOBFM@ DB 'GostCryptVolume', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@ DB 'name = %ls', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CK@MMFHFIAK@GSTCreateDeviceObject?5STATUS_SUC@FNODOBFM@
text$s	SEGMENT
??_C@_0CK@MMFHFIAK@GSTCreateDeviceObject?5STATUS_SUC@FNODOBFM@ DB 'GSTCre'
	DB	'ateDeviceObject STATUS_SUCCESS END', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CN@DMFEOBLG@GSTCreateDeviceObject?5NTSTATUS?5?$DN@FNODOBFM@
text$s	SEGMENT
??_C@_0CN@DMFEOBLG@GSTCreateDeviceObject?5NTSTATUS?5?$DN@FNODOBFM@ DB 'GS'
	DB	'TCreateDeviceObject NTSTATUS = 0x%08x END', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@ DB 'C'
	DB	'reating device nt=%ls dos=%ls', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@PHNPLCFI@GSTCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@PHNPLCFI@GSTCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@ DB 'GSTCr'
	DB	'eateDeviceObject BEGIN', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@HAIDILJN@GSTCreateRootDeviceObject?5STATUS@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CO@HAIDILJN@GSTCreateRootDeviceObject?5STATUS@PBOPGDP@ DB 'GSTCrea'
	DB	'teRootDeviceObject STATUS_SUCCESS END', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0DB@OPKDMPGO@GSTCreateRootDeviceObject?5NTSTAT@PBOPGDP@
INIT$s	SEGMENT
??_C@_0DB@OPKDMPGO@GSTCreateRootDeviceObject?5NTSTAT@PBOPGDP@ DB 'GSTCrea'
	DB	'teRootDeviceObject NTSTATUS = 0x%08x END', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@ DB 'C'
	DB	'reating root device nt=%ls dos=%ls', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'G', 00H, 'o'
	DB	00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@ DB 'K'
	DB	'eGetCurrentIrql() == PASSIVE_LEVEL', 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@PBOPGDP@
INIT$s	SEGMENT
??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@PBOPGDP@ DB 'c:\'
	DB	'users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commente'
	DB	'd\sources_gostcrypt_windows_1.3.1', 0e9H, '\sources_gostcrypt'
	DB	'_windows_1.3.1\driver\ntdriver.c', 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CB@JKDEOCBN@GSTCreateRootDeviceObject?5BEGIN?6@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CB@JKDEOCBN@GSTCreateRootDeviceObject?5BEGIN?6@PBOPGDP@ DB 'GSTCre'
	DB	'ateRootDeviceObject BEGIN', 0aH, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
text$s	SEGMENT
??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@ DB 'c:'
	DB	'\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_comment'
	DB	'ed\sources_gostcrypt_windows_1.3.1', 0e9H, '\sources_gostcryp'
	DB	't_windows_1.3.1\driver\ntdriver.c', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@
text$s	SEGMENT
??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@ DB 'R'
	DB	'emovable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_N'
	DB	'OT_READY', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@
text$s	SEGMENT
??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@ DB 'D'
	DB	'evice %d shutting down: STATUS_DELETE_PENDING', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@ DB 'Driver shut'
	DB	'ting down', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ DB '%ls '
	DB	'(0x%x %d)', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@
text$s	SEGMENT
??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@ DB 'STA'
	DB	'TUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d in'
	DB	'size=%d outsize=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@
text$s	SEGMENT
??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@ DB '0'
	DB	'x%08p  %02x %02x %02x %02x %02x %02x %02x %02x  %s', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@ DB 'V'
	DB	'olume pdo=%p interface=%ws', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@ DB 'A'
	DB	'ddDevice pdo=%p type=%x name=%ws', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@ DB '?', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ DB 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0BN@IJHBALAF@DriverEntry?5GostCrypt?51?43?41?6?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_0BN@IJHBALAF@DriverEntry?5GostCrypt?51?43?41?6?$AA@PBOPGDP@ DB 'Dri'
	DB	'verEntry GostCrypt 1.3.1', 0aH, 00H		;  ?? ::PBOPGDP::`string'
PUBLIC	IsOSAtLeast
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
pdata	SEGMENT
$pdata$IsOSAtLeast DD imagerel $LN15
	DD	imagerel $LN15+313
	DD	imagerel $unwind$IsOSAtLeast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsOSAtLeast DD 010801H
	DD	0a208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsOSAtLeast
_TEXT	SEGMENT
minor$ = 48
major$ = 52
tv69 = 56
tv70 = 60
tv88 = 64
reqMinOS$ = 96
IsOSAtLeast PROC					; COMDAT

; 3869 : {

$LN15:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3870 : 	/* When updating this function, update IsOSVersionAtLeast() in Dlgcode.c too. */
; 3871 : 
; 3872 : 	ULONG major = 0, minor = 0;

  00008	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR major$[rsp], 0
  00010	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR minor$[rsp], 0

; 3873 : 
; 3874 : 	ASSERT (OsMajorVersion != 0);

  00018	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMajorVersion, 0
  0001f	75 27		 jne	 SHORT $LN11@IsOSAtLeas
  00021	45 33 c9	 xor	 r9d, r9d
  00024	41 b8 22 0f 00
	00		 mov	 r8d, 3874		; 00000f22H
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  0003e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  00046	eb 08		 jmp	 SHORT $LN12@IsOSAtLeas
$LN11@IsOSAtLeas:
  00048	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
$LN12@IsOSAtLeas:

; 3875 : 
; 3876 : 	switch (reqMinOS)

  00050	8b 44 24 60	 mov	 eax, DWORD PTR reqMinOS$[rsp]
  00054	89 44 24 3c	 mov	 DWORD PTR tv70[rsp], eax
  00058	83 7c 24 3c 07	 cmp	 DWORD PTR tv70[rsp], 7
  0005d	74 1e		 je	 SHORT $LN6@IsOSAtLeas
  0005f	83 7c 24 3c 08	 cmp	 DWORD PTR tv70[rsp], 8
  00064	74 29		 je	 SHORT $LN5@IsOSAtLeas
  00066	83 7c 24 3c 0a	 cmp	 DWORD PTR tv70[rsp], 10
  0006b	74 34		 je	 SHORT $LN4@IsOSAtLeas
  0006d	83 7c 24 3c 0b	 cmp	 DWORD PTR tv70[rsp], 11
  00072	74 3f		 je	 SHORT $LN3@IsOSAtLeas
  00074	83 7c 24 3c 0d	 cmp	 DWORD PTR tv70[rsp], 13
  00079	74 4a		 je	 SHORT $LN2@IsOSAtLeas
  0007b	eb 5a		 jmp	 SHORT $LN1@IsOSAtLeas
$LN6@IsOSAtLeas:

; 3877 : 	{
; 3878 : 	case WIN_2000:			major = 5; minor = 0; break;

  0007d	c7 44 24 34 05
	00 00 00	 mov	 DWORD PTR major$[rsp], 5
  00085	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR minor$[rsp], 0
  0008d	eb 67		 jmp	 SHORT $LN7@IsOSAtLeas
$LN5@IsOSAtLeas:

; 3879 : 	case WIN_XP:			major = 5; minor = 1; break;

  0008f	c7 44 24 34 05
	00 00 00	 mov	 DWORD PTR major$[rsp], 5
  00097	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR minor$[rsp], 1
  0009f	eb 55		 jmp	 SHORT $LN7@IsOSAtLeas
$LN4@IsOSAtLeas:

; 3880 : 	case WIN_SERVER_2003:	major = 5; minor = 2; break;

  000a1	c7 44 24 34 05
	00 00 00	 mov	 DWORD PTR major$[rsp], 5
  000a9	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR minor$[rsp], 2
  000b1	eb 43		 jmp	 SHORT $LN7@IsOSAtLeas
$LN3@IsOSAtLeas:

; 3881 : 	case WIN_VISTA:			major = 6; minor = 0; break;

  000b3	c7 44 24 34 06
	00 00 00	 mov	 DWORD PTR major$[rsp], 6
  000bb	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR minor$[rsp], 0
  000c3	eb 31		 jmp	 SHORT $LN7@IsOSAtLeas
$LN2@IsOSAtLeas:

; 3882 : 	case WIN_7:				major = 6; minor = 1; break;

  000c5	c7 44 24 34 06
	00 00 00	 mov	 DWORD PTR major$[rsp], 6
  000cd	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR minor$[rsp], 1
  000d5	eb 1f		 jmp	 SHORT $LN7@IsOSAtLeas
$LN1@IsOSAtLeas:

; 3883 : 
; 3884 : 	default:
; 3885 : 		GST_THROW_FATAL_EXCEPTION;

  000d7	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  000e0	45 33 c9	 xor	 r9d, r9d
  000e3	45 33 c0	 xor	 r8d, r8d
  000e6	ba 2d 0f 00 00	 mov	 edx, 3885		; 00000f2dH
  000eb	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN7@IsOSAtLeas:

; 3886 : 		break;
; 3887 : 	}
; 3888 : 
; 3889 : 	return ((OsMajorVersion << 16 | OsMinorVersion << 8)
; 3890 : 		>= (major << 16 | minor << 8));

  000f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR OsMajorVersion
  000fc	c1 e2 10	 shl	 edx, 16
  000ff	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR OsMinorVersion
  00105	c1 e0 08	 shl	 eax, 8
  00108	0b d0		 or	 edx, eax
  0010a	8b 44 24 34	 mov	 eax, DWORD PTR major$[rsp]
  0010e	c1 e0 10	 shl	 eax, 16
  00111	8b 4c 24 30	 mov	 ecx, DWORD PTR minor$[rsp]
  00115	c1 e1 08	 shl	 ecx, 8
  00118	0b c1		 or	 eax, ecx
  0011a	3b d0		 cmp	 edx, eax
  0011c	72 0a		 jb	 SHORT $LN13@IsOSAtLeas
  0011e	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  00126	eb 08		 jmp	 SHORT $LN14@IsOSAtLeas
$LN13@IsOSAtLeas:
  00128	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN14@IsOSAtLeas:
  00130	8b 44 24 40	 mov	 eax, DWORD PTR tv88[rsp]
$LN10@IsOSAtLeas:

; 3891 : }

  00134	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00138	c3		 ret	 0
IsOSAtLeast ENDP
_TEXT	ENDS
PUBLIC	GSTReadRegistryKey
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTReadRegistryKey DD imagerel $LN7
	DD	imagerel $LN7+443
	DD	imagerel $unwind$GSTReadRegistryKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTReadRegistryKey DD 021601H
	DD	0130116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTReadRegistryKey
_TEXT	SEGMENT
regObjAttribs$ = 48
size$ = 96
valName$ = 104
regKeyHandle$ = 120
status$ = 128
resultSize$ = 132
keyPath$ = 160
keyValueName$ = 168
keyData$ = 176
GSTReadRegistryKey PROC					; COMDAT

; 3473 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 3474 : 	OBJECT_ATTRIBUTES regObjAttribs;
; 3475 : 	HANDLE regKeyHandle;
; 3476 : 	NTSTATUS status;
; 3477 : 	UNICODE_STRING valName;
; 3478 : 	ULONG size = 0;

  00016	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 3479 : 	ULONG resultSize;
; 3480 : 
; 3481 : 	InitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  0001e	c7 44 24 30 30
	00 00 00	 mov	 DWORD PTR regObjAttribs$[rsp], 48 ; 00000030H
  00026	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR regObjAttribs$[rsp+8], 0
  0002f	c7 44 24 48 40
	02 00 00	 mov	 DWORD PTR regObjAttribs$[rsp+24], 576 ; 00000240H
  00037	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR keyPath$[rsp]
  0003f	48 89 44 24 40	 mov	 QWORD PTR regObjAttribs$[rsp+16], rax
  00044	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR regObjAttribs$[rsp+32], 0
  0004d	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR regObjAttribs$[rsp+40], 0

; 3482 : 	status = ZwOpenKey (&regKeyHandle, KEY_READ, &regObjAttribs);

  00056	4c 8d 44 24 30	 lea	 r8, QWORD PTR regObjAttribs$[rsp]
  0005b	ba 19 00 02 00	 mov	 edx, 131097		; 00020019H
  00060	48 8d 4c 24 78	 lea	 rcx, QWORD PTR regKeyHandle$[rsp]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenKey
  0006b	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 3483 : 	if (!NT_SUCCESS (status))

  00072	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR status$[rsp], 0
  0007a	7d 0c		 jge	 SHORT $LN4@GSTReadReg

; 3484 : 		return status;

  0007c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00083	e9 2b 01 00 00	 jmp	 $LN5@GSTReadReg
$LN4@GSTReadReg:

; 3485 : 
; 3486 : 	RtlInitUnicodeString (&valName, keyValueName);

  00088	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR keyValueName$[rsp]
  00090	48 8d 4c 24 68	 lea	 rcx, QWORD PTR valName$[rsp]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3487 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, NULL, 0, &size);

  0009b	4c 8d 5c 24 60	 lea	 r11, QWORD PTR size$[rsp]
  000a0	4c 89 5c 24 28	 mov	 QWORD PTR [rsp+40], r11
  000a5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  000ad	45 33 c9	 xor	 r9d, r9d
  000b0	41 b8 02 00 00
	00		 mov	 r8d, 2
  000b6	48 8d 54 24 68	 lea	 rdx, QWORD PTR valName$[rsp]
  000bb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryValueKey
  000c6	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 3488 : 		
; 3489 : 	if (!NT_SUCCESS (status) && status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL)

  000cd	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR status$[rsp], 0
  000d5	7d 31		 jge	 SHORT $LN3@GSTReadReg
  000d7	81 bc 24 80 00
	00 00 05 00 00
	80		 cmp	 DWORD PTR status$[rsp], -2147483643 ; ffffffff80000005H
  000e2	74 24		 je	 SHORT $LN3@GSTReadReg
  000e4	81 bc 24 80 00
	00 00 23 00 00
	c0		 cmp	 DWORD PTR status$[rsp], -1073741789 ; ffffffffc0000023H
  000ef	74 17		 je	 SHORT $LN3@GSTReadReg

; 3490 : 	{
; 3491 : 		ZwClose (regKeyHandle);

  000f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3492 : 		return status;

  000fc	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00103	e9 ab 00 00 00	 jmp	 $LN5@GSTReadReg
$LN3@GSTReadReg:

; 3493 : 	}
; 3494 : 
; 3495 : 	if (size == 0)

  00108	83 7c 24 60 00	 cmp	 DWORD PTR size$[rsp], 0
  0010d	75 15		 jne	 SHORT $LN2@GSTReadReg

; 3496 : 	{
; 3497 : 		ZwClose (regKeyHandle);

  0010f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3498 : 		return STATUS_NO_DATA_DETECTED;

  0011a	b8 22 00 00 80	 mov	 eax, -2147483614	; ffffffff80000022H
  0011f	e9 8f 00 00 00	 jmp	 $LN5@GSTReadReg
$LN2@GSTReadReg:

; 3499 : 	}
; 3500 : 
; 3501 : 	*keyData = (PKEY_VALUE_PARTIAL_INFORMATION) GSTalloc (size);

  00124	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  00128	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0012e	33 c9		 xor	 ecx, ecx
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00136	4c 8b d8	 mov	 r11, rax
  00139	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR keyData$[rsp]
  00141	4c 89 18	 mov	 QWORD PTR [rax], r11

; 3502 : 	if (!*keyData)

  00144	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR keyData$[rsp]
  0014c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00150	75 12		 jne	 SHORT $LN1@GSTReadReg

; 3503 : 	{
; 3504 : 		ZwClose (regKeyHandle);

  00152	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3505 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0015d	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00162	eb 4f		 jmp	 SHORT $LN5@GSTReadReg
$LN1@GSTReadReg:

; 3506 : 	}
; 3507 : 
; 3508 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, *keyData, size, &resultSize);

  00164	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR resultSize$[rsp]
  0016c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00171	8b 44 24 60	 mov	 eax, DWORD PTR size$[rsp]
  00175	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00179	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR keyData$[rsp]
  00181	4d 8b 09	 mov	 r9, QWORD PTR [r9]
  00184	41 b8 02 00 00
	00		 mov	 r8d, 2
  0018a	48 8d 54 24 68	 lea	 rdx, QWORD PTR valName$[rsp]
  0018f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryValueKey
  0019a	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 3509 : 
; 3510 : 	ZwClose (regKeyHandle);

  001a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3511 : 	return status;

  001ac	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
$LN5@GSTReadReg:

; 3512 : }

  001b3	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001ba	c3		 ret	 0
GSTReadRegistryKey ENDP
_TEXT	ENDS
PUBLIC	EnsureNullTerminatedString
;	COMDAT pdata
pdata	SEGMENT
$pdata$EnsureNullTerminatedString DD imagerel $LN5
	DD	imagerel $LN5+111
	DD	imagerel $unwind$EnsureNullTerminatedString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EnsureNullTerminatedString DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EnsureNullTerminatedString
_TEXT	SEGMENT
tv70 = 32
str$ = 64
maxSizeInBytes$ = 72
EnsureNullTerminatedString PROC				; COMDAT

; 3421 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3422 : 	ASSERT ((maxSizeInBytes & 1) == 0);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR maxSizeInBytes$[rsp]
  00013	48 83 e0 01	 and	 rax, 1
  00017	48 85 c0	 test	 rax, rax
  0001a	74 27		 je	 SHORT $LN3@EnsureNull
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 5e 0d 00
	00		 mov	 r8d, 3422		; 00000d5eH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00039	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00041	eb 08		 jmp	 SHORT $LN4@EnsureNull
$LN3@EnsureNull:
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
$LN4@EnsureNull:

; 3423 : 	str[maxSizeInBytes / sizeof (wchar_t) - 1] = 0;

  0004b	33 d2		 xor	 edx, edx
  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR maxSizeInBytes$[rsp]
  00052	b9 02 00 00 00	 mov	 ecx, 2
  00057	48 f7 f1	 div	 rcx
  0005a	4c 8b c0	 mov	 r8, rax
  0005d	33 c9		 xor	 ecx, ecx
  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR str$[rsp]
  00064	66 42 89 4c 40
	fe		 mov	 WORD PTR [rax+r8*2-2], cx

; 3424 : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
EnsureNullTerminatedString ENDP
_TEXT	ENDS
PUBLIC	GetCpuCount
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetCpuCount DD imagerel $LN7
	DD	imagerel $LN7+130
	DD	imagerel $unwind$GetCpuCount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetCpuCount DD 010401H
	DD	08204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetCpuCount
_TEXT	SEGMENT
mapSize$ = 32
activeCpuMap$ = 40
cpuCount$ = 48
GetCpuCount PROC					; COMDAT

; 3391 : {

$LN7:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3392 : 	KAFFINITY activeCpuMap = KeQueryActiveProcessors();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeQueryActiveProcessors
  0000a	48 89 44 24 28	 mov	 QWORD PTR activeCpuMap$[rsp], rax

; 3393 : 	size_t mapSize = sizeof (activeCpuMap) * 8;

  0000f	48 c7 44 24 20
	40 00 00 00	 mov	 QWORD PTR mapSize$[rsp], 64 ; 00000040H

; 3394 : 	size_t cpuCount = 0;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR cpuCount$[rsp], 0
$LN4@GetCpuCoun:

; 3395 : 
; 3396 : 	while (mapSize--)

  00021	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mapSize$[rsp]
  00026	48 8b 44 24 20	 mov	 rax, QWORD PTR mapSize$[rsp]
  0002b	48 83 e8 01	 sub	 rax, 1
  0002f	48 89 44 24 20	 mov	 QWORD PTR mapSize$[rsp], rax
  00034	48 85 c9	 test	 rcx, rcx
  00037	74 2b		 je	 SHORT $LN3@GetCpuCoun

; 3397 : 	{
; 3398 : 		if (activeCpuMap & 1)

  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR activeCpuMap$[rsp]
  0003e	48 83 e0 01	 and	 rax, 1
  00042	48 85 c0	 test	 rax, rax
  00045	74 0e		 je	 SHORT $LN2@GetCpuCoun

; 3399 : 			++cpuCount;

  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR cpuCount$[rsp]
  0004c	48 83 c0 01	 add	 rax, 1
  00050	48 89 44 24 30	 mov	 QWORD PTR cpuCount$[rsp], rax
$LN2@GetCpuCoun:

; 3400 : 
; 3401 : 		activeCpuMap >>= 1;

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR activeCpuMap$[rsp]
  0005a	48 d1 e8	 shr	 rax, 1
  0005d	48 89 44 24 28	 mov	 QWORD PTR activeCpuMap$[rsp], rax

; 3402 : 	}

  00062	eb bd		 jmp	 SHORT $LN4@GetCpuCoun
$LN3@GetCpuCoun:

; 3403 : 
; 3404 : 	if (cpuCount == 0)

  00064	48 83 7c 24 30
	00		 cmp	 QWORD PTR cpuCount$[rsp], 0
  0006a	75 0c		 jne	 SHORT $LN1@GetCpuCoun

; 3405 : 		return 1;

  0006c	48 b8 01 00 00
	00 00 00 00 00	 mov	 rax, 1
  00076	eb 05		 jmp	 SHORT $LN5@GetCpuCoun
$LN1@GetCpuCoun:

; 3406 : 
; 3407 : 	return cpuCount;

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR cpuCount$[rsp]
$LN5@GetCpuCoun:

; 3408 : }

  0007d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00081	c3		 ret	 0
GetCpuCount ENDP
_TEXT	ENDS
PUBLIC	GSTCompleteDiskIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTCompleteDiskIrp DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$GSTCompleteDiskIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCompleteDiskIrp DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTCompleteDiskIrp
_TEXT	SEGMENT
tv67 = 32
irp$ = 64
status$ = 72
information$ = 80
GSTCompleteDiskIrp PROC					; COMDAT

; 3375 : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3376 : 	irp->IoStatus.Status = status;

  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR irp$[rsp]
  00017	8b 44 24 48	 mov	 eax, DWORD PTR status$[rsp]
  0001b	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 3377 : 	irp->IoStatus.Information = information;

  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR irp$[rsp]
  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR information$[rsp]
  00028	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 3378 : 	IoCompleteRequest (irp, NT_SUCCESS (status) ? IO_DISK_INCREMENT : IO_NO_INCREMENT);

  0002c	83 7c 24 48 00	 cmp	 DWORD PTR status$[rsp], 0
  00031	7c 0a		 jl	 SHORT $LN3@GSTComplet
  00033	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  0003b	eb 08		 jmp	 SHORT $LN4@GSTComplet
$LN3@GSTComplet:
  0003d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@GSTComplet:
  00045	0f b6 54 24 20	 movzx	 edx, BYTE PTR tv67[rsp]
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR irp$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 3379 : 	return status;

  00055	8b 44 24 48	 mov	 eax, DWORD PTR status$[rsp]

; 3380 : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
GSTCompleteDiskIrp ENDP
_TEXT	ENDS
PUBLIC	GSTCompleteIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTCompleteIrp DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$GSTCompleteIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCompleteIrp DD 011201H
	DD	04212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTCompleteIrp
_TEXT	SEGMENT
irp$ = 48
status$ = 56
information$ = 64
GSTCompleteIrp PROC					; COMDAT

; 3356 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3357 : 	irp->IoStatus.Status = status;

  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR irp$[rsp]
  00017	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]
  0001b	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 3358 : 	irp->IoStatus.Information = information;

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR irp$[rsp]
  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR information$[rsp]
  00028	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 3359 : 	IoCompleteRequest (irp, IO_NO_INCREMENT);

  0002c	33 d2		 xor	 edx, edx
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR irp$[rsp]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 3360 : 	return status;

  00039	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]

; 3361 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
GSTCompleteIrp ENDP
_TEXT	ENDS
PUBLIC	GetIntersection
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetIntersection DD imagerel $LN10
	DD	imagerel $LN10+217
	DD	imagerel $unwind$GetIntersection
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetIntersection DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetIntersection
_TEXT	SEGMENT
intersectEnd$ = 0
end1$ = 8
tv68 = 16
tv70 = 24
tv74 = 32
start1$ = 64
length1$ = 72
start2$ = 80
end2$ = 88
intersectStart$ = 96
intersectLength$ = 104
GetIntersection PROC					; COMDAT

; 3246 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3247 : 	uint64 end1 = start1 + length1 - 1;

  00017	8b 4c 24 48	 mov	 ecx, DWORD PTR length1$[rsp]
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR start1$[rsp]
  00020	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00025	48 89 44 24 08	 mov	 QWORD PTR end1$[rsp], rax

; 3248 : 	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

  0002a	48 8b 44 24 58	 mov	 rax, QWORD PTR end2$[rsp]
  0002f	48 39 44 24 08	 cmp	 QWORD PTR end1$[rsp], rax
  00034	77 0c		 ja	 SHORT $LN4@GetInterse
  00036	48 8b 44 24 08	 mov	 rax, QWORD PTR end1$[rsp]
  0003b	48 89 44 24 10	 mov	 QWORD PTR tv68[rsp], rax
  00040	eb 0a		 jmp	 SHORT $LN5@GetInterse
$LN4@GetInterse:
  00042	48 8b 44 24 58	 mov	 rax, QWORD PTR end2$[rsp]
  00047	48 89 44 24 10	 mov	 QWORD PTR tv68[rsp], rax
$LN5@GetInterse:
  0004c	48 8b 44 24 10	 mov	 rax, QWORD PTR tv68[rsp]
  00051	48 89 04 24	 mov	 QWORD PTR intersectEnd$[rsp], rax

; 3249 : 	
; 3250 : 	*intersectStart = (start1 >= start2) ? start1 : start2;

  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR start2$[rsp]
  0005a	48 39 44 24 40	 cmp	 QWORD PTR start1$[rsp], rax
  0005f	72 0c		 jb	 SHORT $LN6@GetInterse
  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR start1$[rsp]
  00066	48 89 44 24 18	 mov	 QWORD PTR tv70[rsp], rax
  0006b	eb 0a		 jmp	 SHORT $LN7@GetInterse
$LN6@GetInterse:
  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR start2$[rsp]
  00072	48 89 44 24 18	 mov	 QWORD PTR tv70[rsp], rax
$LN7@GetInterse:
  00077	48 8b 4c 24 60	 mov	 rcx, QWORD PTR intersectStart$[rsp]
  0007c	48 8b 44 24 18	 mov	 rax, QWORD PTR tv70[rsp]
  00081	48 89 01	 mov	 QWORD PTR [rcx], rax

; 3251 : 	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

  00084	48 8b 4c 24 60	 mov	 rcx, QWORD PTR intersectStart$[rsp]
  00089	48 8b 04 24	 mov	 rax, QWORD PTR intersectEnd$[rsp]
  0008d	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00090	76 0b		 jbe	 SHORT $LN8@GetInterse
  00092	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv74[rsp], 0
  0009b	eb 15		 jmp	 SHORT $LN9@GetInterse
$LN8@GetInterse:
  0009d	48 8b 04 24	 mov	 rax, QWORD PTR intersectEnd$[rsp]
  000a1	48 83 c0 01	 add	 rax, 1
  000a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR intersectStart$[rsp]
  000aa	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  000ad	48 89 44 24 20	 mov	 QWORD PTR tv74[rsp], rax
$LN9@GetInterse:
  000b2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR intersectLength$[rsp]
  000b7	8b 44 24 20	 mov	 eax, DWORD PTR tv74[rsp]
  000bb	89 01		 mov	 DWORD PTR [rcx], eax

; 3252 : 	
; 3253 : 	if (*intersectLength == 0)

  000bd	48 8b 44 24 68	 mov	 rax, QWORD PTR intersectLength$[rsp]
  000c2	83 38 00	 cmp	 DWORD PTR [rax], 0
  000c5	75 0d		 jne	 SHORT $LN1@GetInterse

; 3254 : 		*intersectStart = start1;

  000c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR intersectStart$[rsp]
  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR start1$[rsp]
  000d1	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN1@GetInterse:

; 3255 : }

  000d4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d8	c3		 ret	 0
GetIntersection ENDP
_TEXT	ENDS
PUBLIC	RegionsOverlap
;	COMDAT pdata
pdata	SEGMENT
$pdata$RegionsOverlap DD imagerel $LN9
	DD	imagerel $LN9+120
	DD	imagerel $unwind$RegionsOverlap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RegionsOverlap DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RegionsOverlap
_TEXT	SEGMENT
tv68 = 0
tv69 = 4
tv67 = 8
start1$ = 32
end1$ = 40
start2$ = 48
end2$ = 56
RegionsOverlap PROC					; COMDAT

; 3227 : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 3228 : 	return (start1 < start2) ? (end1 >= start2) : (start1 <= end2);

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR start2$[rsp]
  0001d	48 39 44 24 20	 cmp	 QWORD PTR start1$[rsp], rax
  00022	73 25		 jae	 SHORT $LN7@RegionsOve
  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR start2$[rsp]
  00029	48 39 44 24 28	 cmp	 QWORD PTR end1$[rsp], rax
  0002e	72 09		 jb	 SHORT $LN5@RegionsOve
  00030	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv68[rsp], 1
  00037	eb 07		 jmp	 SHORT $LN6@RegionsOve
$LN5@RegionsOve:
  00039	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN6@RegionsOve:
  00040	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  00043	89 44 24 04	 mov	 DWORD PTR tv69[rsp], eax
  00047	eb 26		 jmp	 SHORT $LN8@RegionsOve
$LN7@RegionsOve:
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR end2$[rsp]
  0004e	48 39 44 24 20	 cmp	 QWORD PTR start1$[rsp], rax
  00053	77 0a		 ja	 SHORT $LN3@RegionsOve
  00055	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  0005d	eb 08		 jmp	 SHORT $LN4@RegionsOve
$LN3@RegionsOve:
  0005f	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@RegionsOve:
  00067	8b 44 24 08	 mov	 eax, DWORD PTR tv67[rsp]
  0006b	89 44 24 04	 mov	 DWORD PTR tv69[rsp], eax
$LN8@RegionsOve:
  0006f	8b 44 24 04	 mov	 eax, DWORD PTR tv69[rsp]

; 3229 : }

  00073	48 83 c4 18	 add	 rsp, 24
  00077	c3		 ret	 0
RegionsOverlap ENDP
_TEXT	ENDS
PUBLIC	SymbolicLinkToTarget
;	COMDAT pdata
pdata	SEGMENT
$pdata$SymbolicLinkToTarget DD imagerel $LN4
	DD	imagerel $LN4+228
	DD	imagerel $unwind$SymbolicLinkToTarget
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SymbolicLinkToTarget DD 021801H
	DD	07011f218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SymbolicLinkToTarget
_TEXT	SEGMENT
objectAttributes$ = 32
ntStatus$ = 80
fullFileName$ = 88
handle$ = 104
target$32018 = 112
symlinkName$ = 144
targetName$ = 152
maxTargetNameLength$ = 160
SymbolicLinkToTarget PROC				; COMDAT

; 3186 : {

$LN4:
  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	57		 push	 rdi
  00011	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 3187 : 	NTSTATUS ntStatus;
; 3188 : 	OBJECT_ATTRIBUTES objectAttributes;
; 3189 : 	UNICODE_STRING fullFileName;
; 3190 : 	HANDLE handle;
; 3191 : 
; 3192 : 	RtlInitUnicodeString (&fullFileName, symlinkName);

  00018	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR symlinkName$[rsp]
  00020	48 8d 4c 24 58	 lea	 rcx, QWORD PTR fullFileName$[rsp]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3193 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  0002b	c7 44 24 20 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  00033	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+8], 0
  0003c	c7 44 24 38 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  00044	48 8d 44 24 58	 lea	 rax, QWORD PTR fullFileName$[rsp]
  00049	48 89 44 24 30	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  0004e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+32], 0
  00057	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+40], 0

; 3194 : 
; 3195 : 	ntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);

  00060	4c 8d 44 24 20	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  00065	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0006a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR handle$[rsp]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenSymbolicLinkObject
  00075	89 44 24 50	 mov	 DWORD PTR ntStatus$[rsp], eax

; 3196 : 
; 3197 : 	if (NT_SUCCESS (ntStatus))

  00079	83 7c 24 50 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0007e	7c 57		 jl	 SHORT $LN1@SymbolicLi

; 3198 : 	{
; 3199 : 		UNICODE_STRING target;
; 3200 : 		target.Buffer = targetName;

  00080	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR targetName$[rsp]
  00088	48 89 44 24 78	 mov	 QWORD PTR target$32018[rsp+8], rax

; 3201 : 		target.Length = 0;

  0008d	33 c0		 xor	 eax, eax
  0008f	66 89 44 24 70	 mov	 WORD PTR target$32018[rsp], ax

; 3202 : 		target.MaximumLength = maxTargetNameLength;

  00094	0f b7 84 24 a0
	00 00 00	 movzx	 eax, WORD PTR maxTargetNameLength$[rsp]
  0009c	66 89 44 24 72	 mov	 WORD PTR target$32018[rsp+2], ax

; 3203 : 		memset (targetName, 0, maxTargetNameLength);

  000a1	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR maxTargetNameLength$[rsp]
  000a9	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR targetName$[rsp]
  000b1	33 c0		 xor	 eax, eax
  000b3	f3 aa		 rep stosb

; 3204 : 
; 3205 : 		ntStatus = ZwQuerySymbolicLinkObject (handle, &target, NULL);

  000b5	45 33 c0	 xor	 r8d, r8d
  000b8	48 8d 54 24 70	 lea	 rdx, QWORD PTR target$32018[rsp]
  000bd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR handle$[rsp]
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQuerySymbolicLinkObject
  000c8	89 44 24 50	 mov	 DWORD PTR ntStatus$[rsp], eax

; 3206 : 
; 3207 : 		ZwClose (handle);

  000cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR handle$[rsp]
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@SymbolicLi:

; 3208 : 	}
; 3209 : 
; 3210 : 	return ntStatus;

  000d7	8b 44 24 50	 mov	 eax, DWORD PTR ntStatus$[rsp]

; 3211 : }

  000db	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000e2	5f		 pop	 rdi
  000e3	c3		 ret	 0
SymbolicLinkToTarget ENDP
_TEXT	ENDS
PUBLIC	GSTCloseFsVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTCloseFsVolume DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$GSTCloseFsVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCloseFsVolume DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTCloseFsVolume
_TEXT	SEGMENT
volumeHandle$ = 48
fileObject$ = 56
GSTCloseFsVolume PROC					; COMDAT

; 2614 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2615 : 	ObDereferenceObject (fileObject);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fileObject$[rsp]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2616 : 	ZwClose (volumeHandle);

  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 2617 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
GSTCloseFsVolume ENDP
_TEXT	ENDS
PUBLIC	SendDeviceIoControlRequest
;	COMDAT pdata
pdata	SEGMENT
$pdata$SendDeviceIoControlRequestWorkItemRoutine DD imagerel SendDeviceIoControlRequestWorkItemRoutine
	DD	imagerel SendDeviceIoControlRequestWorkItemRoutine+116
	DD	imagerel $unwind$SendDeviceIoControlRequestWorkItemRoutine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SendDeviceIoControlRequestWorkItemRoutine DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SendDeviceIoControlRequestWorkItemRoutine
_TEXT	SEGMENT
rootDeviceObject$ = 64
arg$ = 72
SendDeviceIoControlRequestWorkItemRoutine PROC		; COMDAT

; 2418 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2419 : 	arg->Status = SendDeviceIoControlRequest (arg->deviceObject, arg->ioControlCode, arg->inputBuffer, arg->inputBufferSize, arg->outputBuffer, arg->outputBufferSize);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  00013	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00016	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0001a	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  0001f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00023	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00028	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  0002d	44 8b 48 18	 mov	 r9d, DWORD PTR [rax+24]
  00031	4c 8b 44 24 48	 mov	 r8, QWORD PTR arg$[rsp]
  00036	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  0003f	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00042	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00047	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004a	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0004f	44 8b d8	 mov	 r11d, eax
  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  00057	44 89 58 2c	 mov	 DWORD PTR [rax+44], r11d

; 2420 : 	KeSetEvent (&arg->WorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);

  0005b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00060	48 83 c1 30	 add	 rcx, 48			; 00000030H
  00064	45 33 c0	 xor	 r8d, r8d
  00067	33 d2		 xor	 edx, edx
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 2421 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
SendDeviceIoControlRequestWorkItemRoutine ENDP
_TEXT	ENDS
PUBLIC	GSTTranslateCode
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTTranslateCode DD imagerel $LN153
	DD	imagerel $LN153+2249
	DD	imagerel $unwind$GSTTranslateCode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTTranslateCode DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTTranslateCode
_TEXT	SEGMENT
tv64 = 0
ulCode$ = 32
GSTTranslateCode PROC					; COMDAT

; 2061 : {

$LN153:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 2062 : 	switch (ulCode)

  00008	8b 44 24 20	 mov	 eax, DWORD PTR ulCode$[rsp]
  0000c	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  0000f	81 3c 24 00 00
	56 00		 cmp	 DWORD PTR tv64[rsp], 5636096 ; 00560000H
  00016	77 43		 ja	 SHORT $LN150@GSTTransla
  00018	81 3c 24 00 00
	56 00		 cmp	 DWORD PTR tv64[rsp], 5636096 ; 00560000H
  0001f	0f 84 03 02 00
	00		 je	 $LN107@GSTTransla
  00025	8b 04 24	 mov	 eax, DWORD PTR tv64[rsp]
  00028	2d 04 20 22 00	 sub	 eax, 2236420		; 00222004H
  0002d	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00030	81 3c 24 94 00
	00 00		 cmp	 DWORD PTR tv64[rsp], 148 ; 00000094H
  00037	0f 87 f7 01 00
	00		 ja	 $LN146@GSTTransla
  0003d	8b 04 24	 mov	 eax, DWORD PTR tv64[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00047	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN151@GSTTransla[rcx+rax]
  0004f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN152@GSTTransla[rcx+rax*4]
  00056	48 03 c1	 add	 rax, rcx
  00059	ff e0		 jmp	 rax
$LN150@GSTTransla:
  0005b	e9 d4 01 00 00	 jmp	 $LN146@GSTTransla
$LN145@GSTTransla:

; 2063 : 	{
; 2064 : #define GST_CASE_RET_NAME(CODE) case CODE : return L###CODE
; 2065 : 
; 2066 : 		GST_CASE_RET_NAME (GST_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP);

  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EM@MIDFEHFB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_@FNODOBFM@
  00067	e9 24 07 00 00	 jmp	 $LN148@GSTTransla
$LN144@GSTTransla:

; 2067 : 		GST_CASE_RET_NAME (GST_IOCTL_ABORT_DECOY_SYSTEM_WIPE);

  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EE@BAABOJFJ@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP@FNODOBFM@
  00073	e9 18 07 00 00	 jmp	 $LN148@GSTTransla
$LN143@GSTTransla:

; 2068 : 		GST_CASE_RET_NAME (GST_IOCTL_BOOT_ENCRYPTION_SETUP);

  00078	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EA@EOEOPACH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@
  0007f	e9 0c 07 00 00	 jmp	 $LN148@GSTTransla
$LN142@GSTTransla:

; 2069 : 		GST_CASE_RET_NAME (GST_IOCTL_DISMOUNT_ALL_VOLUMES);

  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@IDPGBIEP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
  0008b	e9 00 07 00 00	 jmp	 $LN148@GSTTransla
$LN141@GSTTransla:

; 2070 : 		GST_CASE_RET_NAME (GST_IOCTL_DISMOUNT_VOLUME);

  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DE@GAINGGCN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
  00097	e9 f4 06 00 00	 jmp	 $LN148@GSTTransla
$LN140@GSTTransla:

; 2071 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES);

  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FG@HBCEKCMI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_@FNODOBFM@
  000a3	e9 e8 06 00 00	 jmp	 $LN148@GSTTransla
$LN139@GSTTransla:

; 2072 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME);

  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FK@HGCJBAGN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL@FNODOBFM@
  000af	e9 dc 06 00 00	 jmp	 $LN148@GSTTransla
$LN138@GSTTransla:

; 2073 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT);

  000b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FG@IMGIDGAD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE@FNODOBFM@
  000bb	e9 d0 06 00 00	 jmp	 $LN148@GSTTransla
$LN137@GSTTransla:

; 2074 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_BOOT_ENCRYPTION_STATUS);

  000c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EK@MMBMBMJA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT@FNODOBFM@
  000c7	e9 c4 06 00 00	 jmp	 $LN148@GSTTransla
$LN136@GSTTransla:

; 2075 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_BOOT_LOADER_VERSION);

  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EE@IDPKBABP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO@FNODOBFM@
  000d3	e9 b8 06 00 00	 jmp	 $LN148@GSTTransla
$LN135@GSTTransla:

; 2076 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT);

  000d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EO@GLOOMNEL@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_@FNODOBFM@
  000df	e9 ac 06 00 00	 jmp	 $LN148@GSTTransla
$LN134@GSTTransla:

; 2077 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS);

  000e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EO@DHKDLHAP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_@FNODOBFM@
  000eb	e9 a0 06 00 00	 jmp	 $LN148@GSTTransla
$LN133@GSTTransla:

; 2078 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_DEVICE_REFCOUNT);

  000f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@PPEMADCA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@
  000f7	e9 94 06 00 00	 jmp	 $LN148@GSTTransla
$LN132@GSTTransla:

; 2079 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_DRIVE_GEOMETRY);

  000fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DK@MCFBGJPI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
  00103	e9 88 06 00 00	 jmp	 $LN148@GSTTransla
$LN131@GSTTransla:

; 2080 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_DRIVE_PARTITION_INFO);

  00108	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EG@HHHEAACH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN@FNODOBFM@
  0010f	e9 7c 06 00 00	 jmp	 $LN148@GSTTransla
$LN130@GSTTransla:

; 2081 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_DRIVER_VERSION);

  00114	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DK@JBCOBEAN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
  0011b	e9 70 06 00 00	 jmp	 $LN148@GSTTransla
$LN129@GSTTransla:

; 2082 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_MOUNTED_VOLUMES);

  00120	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@GDKLDIKK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
  00127	e9 64 06 00 00	 jmp	 $LN148@GSTTransla
$LN128@GSTTransla:

; 2083 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_PASSWORD_CACHE_STATUS);

  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EI@NOJNBFFK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA@FNODOBFM@
  00133	e9 58 06 00 00	 jmp	 $LN148@GSTTransla
$LN127@GSTTransla:

; 2084 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_SYSTEM_DRIVE_CONFIG);

  00138	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EE@DMOEFLGD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI@FNODOBFM@
  0013f	e9 4c 06 00 00	 jmp	 $LN148@GSTTransla
$LN126@GSTTransla:

; 2085 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_PORTABLE_MODE_STATUS);

  00144	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EG@IMOGEOLC@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@
  0014b	e9 40 06 00 00	 jmp	 $LN148@GSTTransla
$LN125@GSTTransla:

; 2086 : 		GST_CASE_RET_NAME (GST_IOCTL_SET_PORTABLE_MODE_STATUS);

  00150	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EG@NPJNJBOI@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@
  00157	e9 34 06 00 00	 jmp	 $LN148@GSTTransla
$LN124@GSTTransla:

; 2087 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_RESOLVED_SYMLINK);

  0015c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@NDHFIBG@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@
  00163	e9 28 06 00 00	 jmp	 $LN148@GSTTransla
$LN123@GSTTransla:

; 2088 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG);

  00168	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EO@INPMIMDN@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_@FNODOBFM@
  0016f	e9 1c 06 00 00	 jmp	 $LN148@GSTTransla
$LN122@GSTTransla:

; 2089 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_VOLUME_PROPERTIES);

  00174	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EA@ONAAGKIP@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@
  0017b	e9 10 06 00 00	 jmp	 $LN148@GSTTransla
$LN121@GSTTransla:

; 2090 : 		GST_CASE_RET_NAME (GST_IOCTL_GET_WARNING_FLAGS);

  00180	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@OHCBBBLA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@
  00187	e9 04 06 00 00	 jmp	 $LN148@GSTTransla
$LN120@GSTTransla:

; 2091 : 		GST_CASE_RET_NAME (GST_IOCTL_DISK_IS_WRITABLE);

  0018c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@MLCMIONK@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
  00193	e9 f8 05 00 00	 jmp	 $LN148@GSTTransla
$LN119@GSTTransla:

; 2092 : 		GST_CASE_RET_NAME (GST_IOCTL_IS_ANY_VOLUME_MOUNTED);

  00198	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EA@FDLLEINC@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
  0019f	e9 ec 05 00 00	 jmp	 $LN148@GSTTransla
$LN118@GSTTransla:

; 2093 : 		GST_CASE_RET_NAME (GST_IOCTL_IS_DRIVER_UNLOAD_DISABLED);

  001a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EI@BKLPHECB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB@FNODOBFM@
  001ab	e9 e0 05 00 00	 jmp	 $LN148@GSTTransla
$LN117@GSTTransla:

; 2094 : 		GST_CASE_RET_NAME (GST_IOCTL_IS_HIDDEN_SYSTEM_RUNNING);

  001b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EG@HMABOPFD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI@FNODOBFM@
  001b7	e9 d4 05 00 00	 jmp	 $LN148@GSTTransla
$LN116@GSTTransla:

; 2095 : 		GST_CASE_RET_NAME (GST_IOCTL_MOUNT_VOLUME);

  001bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CO@GBDFCIBH@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
  001c3	e9 c8 05 00 00	 jmp	 $LN148@GSTTransla
$LN115@GSTTransla:

; 2096 : 		GST_CASE_RET_NAME (GST_IOCTL_OPEN_TEST);

  001c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CI@DKAFEOJJ@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@
  001cf	e9 bc 05 00 00	 jmp	 $LN148@GSTTransla
$LN114@GSTTransla:

; 2097 : 		GST_CASE_RET_NAME (GST_IOCTL_PROBE_REAL_DRIVE_SIZE);

  001d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EA@MLPMMHHD@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@
  001db	e9 b0 05 00 00	 jmp	 $LN148@GSTTransla
$LN113@GSTTransla:

; 2098 : 		GST_CASE_RET_NAME (GST_IOCTL_REOPEN_BOOT_VOLUME_HEADER);

  001e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EI@DOJOHJF@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA@FNODOBFM@
  001e7	e9 a4 05 00 00	 jmp	 $LN148@GSTTransla
$LN112@GSTTransla:

; 2099 : 		GST_CASE_RET_NAME (GST_IOCTL_REREAD_DRIVER_CONFIG);

  001ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@PNIAGIJL@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@
  001f3	e9 98 05 00 00	 jmp	 $LN148@GSTTransla
$LN111@GSTTransla:

; 2100 : 		GST_CASE_RET_NAME (GST_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY);

  001f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FG@CELNGCOA@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO@FNODOBFM@
  001ff	e9 8c 05 00 00	 jmp	 $LN148@GSTTransla
$LN110@GSTTransla:

; 2101 : 		GST_CASE_RET_NAME (GST_IOCTL_START_DECOY_SYSTEM_WIPE);

  00204	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EE@DKMHFKKB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP@FNODOBFM@
  0020b	e9 80 05 00 00	 jmp	 $LN148@GSTTransla
$LN109@GSTTransla:

; 2102 : 		GST_CASE_RET_NAME (GST_IOCTL_WIPE_PASSWORD_CACHE);

  00210	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@NHKGKLDG@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@
  00217	e9 74 05 00 00	 jmp	 $LN148@GSTTransla
$LN108@GSTTransla:

; 2103 : 		GST_CASE_RET_NAME (GST_IOCTL_WRITE_BOOT_DRIVE_SECTOR);

  0021c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EE@DCDMLFMB@?$AAG?$AAS?$AAT?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO@FNODOBFM@
  00223	e9 68 05 00 00	 jmp	 $LN148@GSTTransla
$LN107@GSTTransla:

; 2104 : 
; 2105 : 		GST_CASE_RET_NAME (IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS);

  00228	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@
  0022f	e9 5c 05 00 00	 jmp	 $LN148@GSTTransla
$LN146@GSTTransla:

; 2106 : 
; 2107 : #undef GST_CASE_RET_NAME
; 2108 : 	}
; 2109 : 
; 2110 : 	if (ulCode ==			 IOCTL_DISK_GET_DRIVE_GEOMETRY)

  00234	81 7c 24 20 00
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458752 ; 00070000H
  0023c	75 11		 jne	 SHORT $LN106@GSTTransla

; 2111 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_DRIVE_GEOMETRY");

  0023e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
  00245	e9 46 05 00 00	 jmp	 $LN148@GSTTransla
  0024a	e9 41 05 00 00	 jmp	 $LN105@GSTTransla
$LN106@GSTTransla:

; 2112 : 	else if (ulCode ==		 IOCTL_DISK_GET_DRIVE_GEOMETRY_EX)

  0024f	81 7c 24 20 a0
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458912 ; 000700a0H
  00257	75 11		 jne	 SHORT $LN104@GSTTransla

; 2113 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_DRIVE_GEOMETRY_EX");

  00259	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@
  00260	e9 2b 05 00 00	 jmp	 $LN148@GSTTransla
  00265	e9 26 05 00 00	 jmp	 $LN103@GSTTransla
$LN104@GSTTransla:

; 2114 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_QUERY_DEVICE_NAME)

  0026a	81 7c 24 20 08
	00 4d 00	 cmp	 DWORD PTR ulCode$[rsp], 5046280 ; 004d0008H
  00272	75 11		 jne	 SHORT $LN102@GSTTransla

; 2115 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_QUERY_DEVICE_NAME");

  00274	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@
  0027b	e9 10 05 00 00	 jmp	 $LN148@GSTTransla
  00280	e9 0b 05 00 00	 jmp	 $LN101@GSTTransla
$LN102@GSTTransla:

; 2116 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME)

  00285	81 7c 24 20 0c
	00 4d 00	 cmp	 DWORD PTR ulCode$[rsp], 5046284 ; 004d000cH
  0028d	75 11		 jne	 SHORT $LN100@GSTTransla

; 2117 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME");

  0028f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@
  00296	e9 f5 04 00 00	 jmp	 $LN148@GSTTransla
  0029b	e9 f0 04 00 00	 jmp	 $LN99@GSTTransla
$LN100@GSTTransla:

; 2118 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_QUERY_UNIQUE_ID)

  002a0	81 7c 24 20 00
	00 4d 00	 cmp	 DWORD PTR ulCode$[rsp], 5046272 ; 004d0000H
  002a8	75 11		 jne	 SHORT $LN98@GSTTransla

; 2119 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_QUERY_UNIQUE_ID");

  002aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@
  002b1	e9 da 04 00 00	 jmp	 $LN148@GSTTransla
  002b6	e9 d5 04 00 00	 jmp	 $LN97@GSTTransla
$LN98@GSTTransla:

; 2120 : 	else if (ulCode ==		 IOCTL_VOLUME_ONLINE)

  002bb	81 7c 24 20 08
	c0 56 00	 cmp	 DWORD PTR ulCode$[rsp], 5685256 ; 0056c008H
  002c3	75 11		 jne	 SHORT $LN96@GSTTransla

; 2121 : 		return (LPWSTR) _T ("IOCTL_VOLUME_ONLINE");

  002c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@
  002cc	e9 bf 04 00 00	 jmp	 $LN148@GSTTransla
  002d1	e9 ba 04 00 00	 jmp	 $LN95@GSTTransla
$LN96@GSTTransla:

; 2122 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_LINK_CREATED)

  002d6	81 7c 24 20 10
	c0 4d 00	 cmp	 DWORD PTR ulCode$[rsp], 5095440 ; 004dc010H
  002de	75 11		 jne	 SHORT $LN94@GSTTransla

; 2123 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_LINK_CREATED");

  002e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
  002e7	e9 a4 04 00 00	 jmp	 $LN148@GSTTransla
  002ec	e9 9f 04 00 00	 jmp	 $LN93@GSTTransla
$LN94@GSTTransla:

; 2124 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_LINK_DELETED)

  002f1	81 7c 24 20 14
	c0 4d 00	 cmp	 DWORD PTR ulCode$[rsp], 5095444 ; 004dc014H
  002f9	75 11		 jne	 SHORT $LN92@GSTTransla

; 2125 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_LINK_DELETED");

  002fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
  00302	e9 89 04 00 00	 jmp	 $LN148@GSTTransla
  00307	e9 84 04 00 00	 jmp	 $LN91@GSTTransla
$LN92@GSTTransla:

; 2126 : 	else if (ulCode ==		 IOCTL_MOUNTMGR_QUERY_POINTS)

  0030c	81 7c 24 20 08
	00 6d 00	 cmp	 DWORD PTR ulCode$[rsp], 7143432 ; 006d0008H
  00314	75 11		 jne	 SHORT $LN90@GSTTransla

; 2127 : 		return (LPWSTR) _T ("IOCTL_MOUNTMGR_QUERY_POINTS");

  00316	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@
  0031d	e9 6e 04 00 00	 jmp	 $LN148@GSTTransla
  00322	e9 69 04 00 00	 jmp	 $LN89@GSTTransla
$LN90@GSTTransla:

; 2128 : 	else if (ulCode ==		 IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED)

  00327	81 7c 24 20 18
	c0 6d 00	 cmp	 DWORD PTR ulCode$[rsp], 7192600 ; 006dc018H
  0032f	75 11		 jne	 SHORT $LN88@GSTTransla

; 2129 : 		return (LPWSTR) _T ("IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED");

  00331	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
  00338	e9 53 04 00 00	 jmp	 $LN148@GSTTransla
  0033d	e9 4e 04 00 00	 jmp	 $LN87@GSTTransla
$LN88@GSTTransla:

; 2130 : 	else if (ulCode ==		 IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED)

  00342	81 7c 24 20 1c
	c0 6d 00	 cmp	 DWORD PTR ulCode$[rsp], 7192604 ; 006dc01cH
  0034a	75 11		 jne	 SHORT $LN86@GSTTransla

; 2131 : 		return (LPWSTR) _T ("IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED");

  0034c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
  00353	e9 38 04 00 00	 jmp	 $LN148@GSTTransla
  00358	e9 33 04 00 00	 jmp	 $LN85@GSTTransla
$LN86@GSTTransla:

; 2132 : 	else if (ulCode ==		 IOCTL_DISK_GET_LENGTH_INFO)

  0035d	81 7c 24 20 5c
	40 07 00	 cmp	 DWORD PTR ulCode$[rsp], 475228 ; 0007405cH
  00365	75 11		 jne	 SHORT $LN84@GSTTransla

; 2133 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_LENGTH_INFO");

  00367	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  0036e	e9 1d 04 00 00	 jmp	 $LN148@GSTTransla
  00373	e9 18 04 00 00	 jmp	 $LN83@GSTTransla
$LN84@GSTTransla:

; 2134 : 	else if (ulCode ==		 IOCTL_STORAGE_GET_DEVICE_NUMBER)

  00378	81 7c 24 20 80
	10 2d 00	 cmp	 DWORD PTR ulCode$[rsp], 2953344 ; 002d1080H
  00380	75 11		 jne	 SHORT $LN82@GSTTransla

; 2135 : 		return (LPWSTR) _T ("IOCTL_STORAGE_GET_DEVICE_NUMBER");

  00382	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
  00389	e9 02 04 00 00	 jmp	 $LN148@GSTTransla
  0038e	e9 fd 03 00 00	 jmp	 $LN81@GSTTransla
$LN82@GSTTransla:

; 2136 : 	else if (ulCode ==		 IOCTL_DISK_GET_PARTITION_INFO)

  00393	81 7c 24 20 04
	40 07 00	 cmp	 DWORD PTR ulCode$[rsp], 475140 ; 00074004H
  0039b	75 11		 jne	 SHORT $LN80@GSTTransla

; 2137 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_PARTITION_INFO");

  0039d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  003a4	e9 e7 03 00 00	 jmp	 $LN148@GSTTransla
  003a9	e9 e2 03 00 00	 jmp	 $LN79@GSTTransla
$LN80@GSTTransla:

; 2138 : 	else if (ulCode ==		 IOCTL_DISK_GET_PARTITION_INFO_EX)

  003ae	81 7c 24 20 48
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458824 ; 00070048H
  003b6	75 11		 jne	 SHORT $LN78@GSTTransla

; 2139 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_PARTITION_INFO_EX");

  003b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@
  003bf	e9 cc 03 00 00	 jmp	 $LN148@GSTTransla
  003c4	e9 c7 03 00 00	 jmp	 $LN77@GSTTransla
$LN78@GSTTransla:

; 2140 : 	else if (ulCode ==		 IOCTL_DISK_SET_PARTITION_INFO)

  003c9	81 7c 24 20 08
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 507912 ; 0007c008H
  003d1	75 11		 jne	 SHORT $LN76@GSTTransla

; 2141 : 		return (LPWSTR) _T ("IOCTL_DISK_SET_PARTITION_INFO");

  003d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  003da	e9 b1 03 00 00	 jmp	 $LN148@GSTTransla
  003df	e9 ac 03 00 00	 jmp	 $LN75@GSTTransla
$LN76@GSTTransla:

; 2142 : 	else if (ulCode ==		 IOCTL_DISK_GET_DRIVE_LAYOUT)

  003e4	81 7c 24 20 0c
	40 07 00	 cmp	 DWORD PTR ulCode$[rsp], 475148 ; 0007400cH
  003ec	75 11		 jne	 SHORT $LN74@GSTTransla

; 2143 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_DRIVE_LAYOUT");

  003ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@
  003f5	e9 96 03 00 00	 jmp	 $LN148@GSTTransla
  003fa	e9 91 03 00 00	 jmp	 $LN73@GSTTransla
$LN74@GSTTransla:

; 2144 : 	else if (ulCode ==		 IOCTL_DISK_SET_DRIVE_LAYOUT_EX)

  003ff	81 7c 24 20 54
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 507988 ; 0007c054H
  00407	75 11		 jne	 SHORT $LN72@GSTTransla

; 2145 : 		return (LPWSTR) _T ("IOCTL_DISK_SET_DRIVE_LAYOUT_EX");

  00409	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
  00410	e9 7b 03 00 00	 jmp	 $LN148@GSTTransla
  00415	e9 76 03 00 00	 jmp	 $LN71@GSTTransla
$LN72@GSTTransla:

; 2146 : 	else if (ulCode ==		 IOCTL_DISK_VERIFY)

  0041a	81 7c 24 20 14
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458772 ; 00070014H
  00422	75 11		 jne	 SHORT $LN70@GSTTransla

; 2147 : 		return (LPWSTR) _T ("IOCTL_DISK_VERIFY");

  00424	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
  0042b	e9 60 03 00 00	 jmp	 $LN148@GSTTransla
  00430	e9 5b 03 00 00	 jmp	 $LN69@GSTTransla
$LN70@GSTTransla:

; 2148 : 	else if (ulCode == IOCTL_DISK_FORMAT_TRACKS)

  00435	81 7c 24 20 18
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 507928 ; 0007c018H
  0043d	75 11		 jne	 SHORT $LN68@GSTTransla

; 2149 : 		return (LPWSTR) _T ("IOCTL_DISK_FORMAT_TRACKS");

  0043f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
  00446	e9 45 03 00 00	 jmp	 $LN148@GSTTransla
  0044b	e9 40 03 00 00	 jmp	 $LN67@GSTTransla
$LN68@GSTTransla:

; 2150 : 	else if (ulCode == IOCTL_DISK_REASSIGN_BLOCKS)

  00450	81 7c 24 20 1c
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 507932 ; 0007c01cH
  00458	75 11		 jne	 SHORT $LN66@GSTTransla

; 2151 : 		return (LPWSTR) _T ("IOCTL_DISK_REASSIGN_BLOCKS");

  0045a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
  00461	e9 2a 03 00 00	 jmp	 $LN148@GSTTransla
  00466	e9 25 03 00 00	 jmp	 $LN65@GSTTransla
$LN66@GSTTransla:

; 2152 : 	else if (ulCode == IOCTL_DISK_PERFORMANCE)

  0046b	81 7c 24 20 20
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458784 ; 00070020H
  00473	75 11		 jne	 SHORT $LN64@GSTTransla

; 2153 : 		return (LPWSTR) _T ("IOCTL_DISK_PERFORMANCE");

  00475	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@
  0047c	e9 0f 03 00 00	 jmp	 $LN148@GSTTransla
  00481	e9 0a 03 00 00	 jmp	 $LN63@GSTTransla
$LN64@GSTTransla:

; 2154 : 	else if (ulCode == IOCTL_DISK_IS_WRITABLE)

  00486	81 7c 24 20 24
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458788 ; 00070024H
  0048e	75 11		 jne	 SHORT $LN62@GSTTransla

; 2155 : 		return (LPWSTR) _T ("IOCTL_DISK_IS_WRITABLE");

  00490	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
  00497	e9 f4 02 00 00	 jmp	 $LN148@GSTTransla
  0049c	e9 ef 02 00 00	 jmp	 $LN61@GSTTransla
$LN62@GSTTransla:

; 2156 : 	else if (ulCode == IOCTL_DISK_LOGGING)

  004a1	81 7c 24 20 28
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458792 ; 00070028H
  004a9	75 11		 jne	 SHORT $LN60@GSTTransla

; 2157 : 		return (LPWSTR) _T ("IOCTL_DISK_LOGGING");

  004ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@
  004b2	e9 d9 02 00 00	 jmp	 $LN148@GSTTransla
  004b7	e9 d4 02 00 00	 jmp	 $LN59@GSTTransla
$LN60@GSTTransla:

; 2158 : 	else if (ulCode == IOCTL_DISK_FORMAT_TRACKS_EX)

  004bc	81 7c 24 20 2c
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 507948 ; 0007c02cH
  004c4	75 11		 jne	 SHORT $LN58@GSTTransla

; 2159 : 		return (LPWSTR) _T ("IOCTL_DISK_FORMAT_TRACKS_EX");

  004c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
  004cd	e9 be 02 00 00	 jmp	 $LN148@GSTTransla
  004d2	e9 b9 02 00 00	 jmp	 $LN57@GSTTransla
$LN58@GSTTransla:

; 2160 : 	else if (ulCode == IOCTL_DISK_HISTOGRAM_STRUCTURE)

  004d7	81 7c 24 20 30
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458800 ; 00070030H
  004df	75 11		 jne	 SHORT $LN56@GSTTransla

; 2161 : 		return (LPWSTR) _T ("IOCTL_DISK_HISTOGRAM_STRUCTURE");

  004e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
  004e8	e9 a3 02 00 00	 jmp	 $LN148@GSTTransla
  004ed	e9 9e 02 00 00	 jmp	 $LN55@GSTTransla
$LN56@GSTTransla:

; 2162 : 	else if (ulCode == IOCTL_DISK_HISTOGRAM_DATA)

  004f2	81 7c 24 20 34
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458804 ; 00070034H
  004fa	75 11		 jne	 SHORT $LN54@GSTTransla

; 2163 : 		return (LPWSTR) _T ("IOCTL_DISK_HISTOGRAM_DATA");

  004fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
  00503	e9 88 02 00 00	 jmp	 $LN148@GSTTransla
  00508	e9 83 02 00 00	 jmp	 $LN53@GSTTransla
$LN54@GSTTransla:

; 2164 : 	else if (ulCode == IOCTL_DISK_HISTOGRAM_RESET)

  0050d	81 7c 24 20 38
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458808 ; 00070038H
  00515	75 11		 jne	 SHORT $LN52@GSTTransla

; 2165 : 		return (LPWSTR) _T ("IOCTL_DISK_HISTOGRAM_RESET");

  00517	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@
  0051e	e9 6d 02 00 00	 jmp	 $LN148@GSTTransla
  00523	e9 68 02 00 00	 jmp	 $LN51@GSTTransla
$LN52@GSTTransla:

; 2166 : 	else if (ulCode == IOCTL_DISK_REQUEST_STRUCTURE)

  00528	81 7c 24 20 3c
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458812 ; 0007003cH
  00530	75 11		 jne	 SHORT $LN50@GSTTransla

; 2167 : 		return (LPWSTR) _T ("IOCTL_DISK_REQUEST_STRUCTURE");

  00532	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
  00539	e9 52 02 00 00	 jmp	 $LN148@GSTTransla
  0053e	e9 4d 02 00 00	 jmp	 $LN49@GSTTransla
$LN50@GSTTransla:

; 2168 : 	else if (ulCode == IOCTL_DISK_REQUEST_DATA)

  00543	81 7c 24 20 40
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458816 ; 00070040H
  0054b	75 11		 jne	 SHORT $LN48@GSTTransla

; 2169 : 		return (LPWSTR) _T ("IOCTL_DISK_REQUEST_DATA");

  0054d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
  00554	e9 37 02 00 00	 jmp	 $LN148@GSTTransla
  00559	e9 32 02 00 00	 jmp	 $LN47@GSTTransla
$LN48@GSTTransla:

; 2170 : 	else if (ulCode == IOCTL_DISK_CONTROLLER_NUMBER)

  0055e	81 7c 24 20 44
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458820 ; 00070044H
  00566	75 11		 jne	 SHORT $LN46@GSTTransla

; 2171 : 		return (LPWSTR) _T ("IOCTL_DISK_CONTROLLER_NUMBER");

  00568	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
  0056f	e9 1c 02 00 00	 jmp	 $LN148@GSTTransla
  00574	e9 17 02 00 00	 jmp	 $LN45@GSTTransla
$LN46@GSTTransla:

; 2172 : 	else if (ulCode == SMART_GET_VERSION)

  00579	81 7c 24 20 80
	40 07 00	 cmp	 DWORD PTR ulCode$[rsp], 475264 ; 00074080H
  00581	75 11		 jne	 SHORT $LN44@GSTTransla

; 2173 : 		return (LPWSTR) _T ("SMART_GET_VERSION");

  00583	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
  0058a	e9 01 02 00 00	 jmp	 $LN148@GSTTransla
  0058f	e9 fc 01 00 00	 jmp	 $LN43@GSTTransla
$LN44@GSTTransla:

; 2174 : 	else if (ulCode == SMART_SEND_DRIVE_COMMAND)

  00594	81 7c 24 20 84
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 508036 ; 0007c084H
  0059c	75 11		 jne	 SHORT $LN42@GSTTransla

; 2175 : 		return (LPWSTR) _T ("SMART_SEND_DRIVE_COMMAND");

  0059e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@
  005a5	e9 e6 01 00 00	 jmp	 $LN148@GSTTransla
  005aa	e9 e1 01 00 00	 jmp	 $LN41@GSTTransla
$LN42@GSTTransla:

; 2176 : 	else if (ulCode == SMART_RCV_DRIVE_DATA)

  005af	81 7c 24 20 88
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 508040 ; 0007c088H
  005b7	75 11		 jne	 SHORT $LN40@GSTTransla

; 2177 : 		return (LPWSTR) _T ("SMART_RCV_DRIVE_DATA");

  005b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
  005c0	e9 cb 01 00 00	 jmp	 $LN148@GSTTransla
  005c5	e9 c6 01 00 00	 jmp	 $LN39@GSTTransla
$LN40@GSTTransla:

; 2178 : 	else if (ulCode == IOCTL_DISK_INTERNAL_SET_VERIFY)

  005ca	81 7c 24 20 03
	04 07 00	 cmp	 DWORD PTR ulCode$[rsp], 459779 ; 00070403H
  005d2	75 11		 jne	 SHORT $LN38@GSTTransla

; 2179 : 		return (LPWSTR) _T ("IOCTL_DISK_INTERNAL_SET_VERIFY");

  005d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
  005db	e9 b0 01 00 00	 jmp	 $LN148@GSTTransla
  005e0	e9 ab 01 00 00	 jmp	 $LN37@GSTTransla
$LN38@GSTTransla:

; 2180 : 	else if (ulCode == IOCTL_DISK_INTERNAL_CLEAR_VERIFY)

  005e5	81 7c 24 20 07
	04 07 00	 cmp	 DWORD PTR ulCode$[rsp], 459783 ; 00070407H
  005ed	75 11		 jne	 SHORT $LN36@GSTTransla

; 2181 : 		return (LPWSTR) _T ("IOCTL_DISK_INTERNAL_CLEAR_VERIFY");

  005ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@
  005f6	e9 95 01 00 00	 jmp	 $LN148@GSTTransla
  005fb	e9 90 01 00 00	 jmp	 $LN35@GSTTransla
$LN36@GSTTransla:

; 2182 : 	else if (ulCode == IOCTL_DISK_CHECK_VERIFY)

  00600	81 7c 24 20 00
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477184 ; 00074800H
  00608	75 11		 jne	 SHORT $LN34@GSTTransla

; 2183 : 		return (LPWSTR) _T ("IOCTL_DISK_CHECK_VERIFY");

  0060a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
  00611	e9 7a 01 00 00	 jmp	 $LN148@GSTTransla
  00616	e9 75 01 00 00	 jmp	 $LN33@GSTTransla
$LN34@GSTTransla:

; 2184 : 	else if (ulCode == IOCTL_DISK_MEDIA_REMOVAL)

  0061b	81 7c 24 20 04
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477188 ; 00074804H
  00623	75 11		 jne	 SHORT $LN32@GSTTransla

; 2185 : 		return (LPWSTR) _T ("IOCTL_DISK_MEDIA_REMOVAL");

  00625	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@
  0062c	e9 5f 01 00 00	 jmp	 $LN148@GSTTransla
  00631	e9 5a 01 00 00	 jmp	 $LN31@GSTTransla
$LN32@GSTTransla:

; 2186 : 	else if (ulCode == IOCTL_DISK_EJECT_MEDIA)

  00636	81 7c 24 20 08
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477192 ; 00074808H
  0063e	75 11		 jne	 SHORT $LN30@GSTTransla

; 2187 : 		return (LPWSTR) _T ("IOCTL_DISK_EJECT_MEDIA");

  00640	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
  00647	e9 44 01 00 00	 jmp	 $LN148@GSTTransla
  0064c	e9 3f 01 00 00	 jmp	 $LN29@GSTTransla
$LN30@GSTTransla:

; 2188 : 	else if (ulCode == IOCTL_DISK_LOAD_MEDIA)

  00651	81 7c 24 20 0c
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477196 ; 0007480cH
  00659	75 11		 jne	 SHORT $LN28@GSTTransla

; 2189 : 		return (LPWSTR) _T ("IOCTL_DISK_LOAD_MEDIA");

  0065b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
  00662	e9 29 01 00 00	 jmp	 $LN148@GSTTransla
  00667	e9 24 01 00 00	 jmp	 $LN27@GSTTransla
$LN28@GSTTransla:

; 2190 : 	else if (ulCode == IOCTL_DISK_RESERVE)

  0066c	81 7c 24 20 10
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477200 ; 00074810H
  00674	75 11		 jne	 SHORT $LN26@GSTTransla

; 2191 : 		return (LPWSTR) _T ("IOCTL_DISK_RESERVE");

  00676	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@
  0067d	e9 0e 01 00 00	 jmp	 $LN148@GSTTransla
  00682	e9 09 01 00 00	 jmp	 $LN25@GSTTransla
$LN26@GSTTransla:

; 2192 : 	else if (ulCode == IOCTL_DISK_RELEASE)

  00687	81 7c 24 20 14
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477204 ; 00074814H
  0068f	75 11		 jne	 SHORT $LN24@GSTTransla

; 2193 : 		return (LPWSTR) _T ("IOCTL_DISK_RELEASE");

  00691	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@
  00698	e9 f3 00 00 00	 jmp	 $LN148@GSTTransla
  0069d	e9 ee 00 00 00	 jmp	 $LN23@GSTTransla
$LN24@GSTTransla:

; 2194 : 	else if (ulCode == IOCTL_DISK_FIND_NEW_DEVICES)

  006a2	81 7c 24 20 18
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477208 ; 00074818H
  006aa	75 11		 jne	 SHORT $LN22@GSTTransla

; 2195 : 		return (LPWSTR) _T ("IOCTL_DISK_FIND_NEW_DEVICES");

  006ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@
  006b3	e9 d8 00 00 00	 jmp	 $LN148@GSTTransla
  006b8	e9 d3 00 00 00	 jmp	 $LN21@GSTTransla
$LN22@GSTTransla:

; 2196 : 	else if (ulCode == IOCTL_DISK_GET_MEDIA_TYPES)

  006bd	81 7c 24 20 00
	0c 07 00	 cmp	 DWORD PTR ulCode$[rsp], 461824 ; 00070c00H
  006c5	75 11		 jne	 SHORT $LN20@GSTTransla

; 2197 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_MEDIA_TYPES");

  006c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@
  006ce	e9 bd 00 00 00	 jmp	 $LN148@GSTTransla
  006d3	e9 b8 00 00 00	 jmp	 $LN19@GSTTransla
$LN20@GSTTransla:

; 2198 : 	else if (ulCode == IOCTL_STORAGE_SET_HOTPLUG_INFO)

  006d8	81 7c 24 20 18
	cc 2d 00	 cmp	 DWORD PTR ulCode$[rsp], 3001368 ; 002dcc18H
  006e0	75 11		 jne	 SHORT $LN18@GSTTransla

; 2199 : 		return (LPWSTR) _T ("IOCTL_STORAGE_SET_HOTPLUG_INFO");

  006e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  006e9	e9 a2 00 00 00	 jmp	 $LN148@GSTTransla
  006ee	e9 9d 00 00 00	 jmp	 $LN17@GSTTransla
$LN18@GSTTransla:

; 2200 : 	else if (ulCode == IRP_MJ_READ)

  006f3	83 7c 24 20 03	 cmp	 DWORD PTR ulCode$[rsp], 3
  006f8	75 11		 jne	 SHORT $LN16@GSTTransla

; 2201 : 		return (LPWSTR) _T ("IRP_MJ_READ");

  006fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@
  00701	e9 8a 00 00 00	 jmp	 $LN148@GSTTransla
  00706	e9 85 00 00 00	 jmp	 $LN15@GSTTransla
$LN16@GSTTransla:

; 2202 : 	else if (ulCode == IRP_MJ_WRITE)

  0070b	83 7c 24 20 04	 cmp	 DWORD PTR ulCode$[rsp], 4
  00710	75 0b		 jne	 SHORT $LN14@GSTTransla

; 2203 : 		return (LPWSTR) _T ("IRP_MJ_WRITE");

  00712	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@
  00719	eb 75		 jmp	 SHORT $LN148@GSTTransla
  0071b	eb 73		 jmp	 SHORT $LN13@GSTTransla
$LN14@GSTTransla:

; 2204 : 	else if (ulCode == IRP_MJ_CREATE)

  0071d	83 7c 24 20 00	 cmp	 DWORD PTR ulCode$[rsp], 0
  00722	75 0b		 jne	 SHORT $LN12@GSTTransla

; 2205 : 		return (LPWSTR) _T ("IRP_MJ_CREATE");

  00724	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@
  0072b	eb 63		 jmp	 SHORT $LN148@GSTTransla
  0072d	eb 61		 jmp	 SHORT $LN11@GSTTransla
$LN12@GSTTransla:

; 2206 : 	else if (ulCode == IRP_MJ_CLOSE)

  0072f	83 7c 24 20 02	 cmp	 DWORD PTR ulCode$[rsp], 2
  00734	75 0b		 jne	 SHORT $LN10@GSTTransla

; 2207 : 		return (LPWSTR) _T ("IRP_MJ_CLOSE");

  00736	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@
  0073d	eb 51		 jmp	 SHORT $LN148@GSTTransla
  0073f	eb 4f		 jmp	 SHORT $LN9@GSTTransla
$LN10@GSTTransla:

; 2208 : 	else if (ulCode == IRP_MJ_CLEANUP)

  00741	83 7c 24 20 12	 cmp	 DWORD PTR ulCode$[rsp], 18
  00746	75 0b		 jne	 SHORT $LN8@GSTTransla

; 2209 : 		return (LPWSTR) _T ("IRP_MJ_CLEANUP");

  00748	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@
  0074f	eb 3f		 jmp	 SHORT $LN148@GSTTransla
  00751	eb 3d		 jmp	 SHORT $LN7@GSTTransla
$LN8@GSTTransla:

; 2210 : 	else if (ulCode == IRP_MJ_FLUSH_BUFFERS)

  00753	83 7c 24 20 09	 cmp	 DWORD PTR ulCode$[rsp], 9
  00758	75 0b		 jne	 SHORT $LN6@GSTTransla

; 2211 : 		return (LPWSTR) _T ("IRP_MJ_FLUSH_BUFFERS");

  0075a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@
  00761	eb 2d		 jmp	 SHORT $LN148@GSTTransla
  00763	eb 2b		 jmp	 SHORT $LN5@GSTTransla
$LN6@GSTTransla:

; 2212 : 	else if (ulCode == IRP_MJ_SHUTDOWN)

  00765	83 7c 24 20 10	 cmp	 DWORD PTR ulCode$[rsp], 16
  0076a	75 0b		 jne	 SHORT $LN4@GSTTransla

; 2213 : 		return (LPWSTR) _T ("IRP_MJ_SHUTDOWN");

  0076c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@
  00773	eb 1b		 jmp	 SHORT $LN148@GSTTransla
  00775	eb 19		 jmp	 SHORT $LN3@GSTTransla
$LN4@GSTTransla:

; 2214 : 	else if (ulCode == IRP_MJ_DEVICE_CONTROL)

  00777	83 7c 24 20 0e	 cmp	 DWORD PTR ulCode$[rsp], 14
  0077c	75 0b		 jne	 SHORT $LN2@GSTTransla

; 2215 : 		return (LPWSTR) _T ("IRP_MJ_DEVICE_CONTROL");

  0077e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@
  00785	eb 09		 jmp	 SHORT $LN148@GSTTransla

; 2216 : 	else

  00787	eb 07		 jmp	 SHORT $LN1@GSTTransla
$LN2@GSTTransla:

; 2217 : 	{
; 2218 : 		return (LPWSTR) _T ("IOCTL");

  00789	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@
$LN1@GSTTransla:
$LN3@GSTTransla:
$LN5@GSTTransla:
$LN7@GSTTransla:
$LN9@GSTTransla:
$LN11@GSTTransla:
$LN13@GSTTransla:
$LN15@GSTTransla:
$LN17@GSTTransla:
$LN19@GSTTransla:
$LN21@GSTTransla:
$LN23@GSTTransla:
$LN25@GSTTransla:
$LN27@GSTTransla:
$LN29@GSTTransla:
$LN31@GSTTransla:
$LN33@GSTTransla:
$LN35@GSTTransla:
$LN37@GSTTransla:
$LN39@GSTTransla:
$LN41@GSTTransla:
$LN43@GSTTransla:
$LN45@GSTTransla:
$LN47@GSTTransla:
$LN49@GSTTransla:
$LN51@GSTTransla:
$LN53@GSTTransla:
$LN55@GSTTransla:
$LN57@GSTTransla:
$LN59@GSTTransla:
$LN61@GSTTransla:
$LN63@GSTTransla:
$LN65@GSTTransla:
$LN67@GSTTransla:
$LN69@GSTTransla:
$LN71@GSTTransla:
$LN73@GSTTransla:
$LN75@GSTTransla:
$LN77@GSTTransla:
$LN79@GSTTransla:
$LN81@GSTTransla:
$LN83@GSTTransla:
$LN85@GSTTransla:
$LN87@GSTTransla:
$LN89@GSTTransla:
$LN91@GSTTransla:
$LN93@GSTTransla:
$LN95@GSTTransla:
$LN97@GSTTransla:
$LN99@GSTTransla:
$LN101@GSTTransla:
$LN103@GSTTransla:
$LN105@GSTTransla:
$LN148@GSTTransla:

; 2219 : 	}
; 2220 : }

  00790	48 83 c4 18	 add	 rsp, 24
  00794	c3		 ret	 0
  00795	0f 1f 00	 npad	 3
$LN152@GSTTransla:
  00798	00 00 00 00	 DD	 $LN130@GSTTransla
  0079c	00 00 00 00	 DD	 $LN136@GSTTransla
  007a0	00 00 00 00	 DD	 $LN116@GSTTransla
  007a4	00 00 00 00	 DD	 $LN141@GSTTransla
  007a8	00 00 00 00	 DD	 $LN142@GSTTransla
  007ac	00 00 00 00	 DD	 $LN129@GSTTransla
  007b0	00 00 00 00	 DD	 $LN122@GSTTransla
  007b4	00 00 00 00	 DD	 $LN133@GSTTransla
  007b8	00 00 00 00	 DD	 $LN118@GSTTransla
  007bc	00 00 00 00	 DD	 $LN119@GSTTransla
  007c0	00 00 00 00	 DD	 $LN128@GSTTransla
  007c4	00 00 00 00	 DD	 $LN109@GSTTransla
  007c8	00 00 00 00	 DD	 $LN115@GSTTransla
  007cc	00 00 00 00	 DD	 $LN131@GSTTransla
  007d0	00 00 00 00	 DD	 $LN132@GSTTransla
  007d4	00 00 00 00	 DD	 $LN114@GSTTransla
  007d8	00 00 00 00	 DD	 $LN124@GSTTransla
  007dc	00 00 00 00	 DD	 $LN137@GSTTransla
  007e0	00 00 00 00	 DD	 $LN143@GSTTransla
  007e4	00 00 00 00	 DD	 $LN145@GSTTransla
  007e8	00 00 00 00	 DD	 $LN138@GSTTransla
  007ec	00 00 00 00	 DD	 $LN140@GSTTransla
  007f0	00 00 00 00	 DD	 $LN113@GSTTransla
  007f4	00 00 00 00	 DD	 $LN139@GSTTransla
  007f8	00 00 00 00	 DD	 $LN126@GSTTransla
  007fc	00 00 00 00	 DD	 $LN125@GSTTransla
  00800	00 00 00 00	 DD	 $LN117@GSTTransla
  00804	00 00 00 00	 DD	 $LN127@GSTTransla
  00808	00 00 00 00	 DD	 $LN120@GSTTransla
  0080c	00 00 00 00	 DD	 $LN110@GSTTransla
  00810	00 00 00 00	 DD	 $LN144@GSTTransla
  00814	00 00 00 00	 DD	 $LN134@GSTTransla
  00818	00 00 00 00	 DD	 $LN135@GSTTransla
  0081c	00 00 00 00	 DD	 $LN108@GSTTransla
  00820	00 00 00 00	 DD	 $LN121@GSTTransla
  00824	00 00 00 00	 DD	 $LN111@GSTTransla
  00828	00 00 00 00	 DD	 $LN112@GSTTransla
  0082c	00 00 00 00	 DD	 $LN123@GSTTransla
  00830	00 00 00 00	 DD	 $LN146@GSTTransla
$LN151@GSTTransla:
  00834	00		 DB	 0
  00835	26		 DB	 38			; 00000026H
  00836	26		 DB	 38			; 00000026H
  00837	26		 DB	 38			; 00000026H
  00838	01		 DB	 1
  00839	26		 DB	 38			; 00000026H
  0083a	26		 DB	 38			; 00000026H
  0083b	26		 DB	 38			; 00000026H
  0083c	02		 DB	 2
  0083d	26		 DB	 38			; 00000026H
  0083e	26		 DB	 38			; 00000026H
  0083f	26		 DB	 38			; 00000026H
  00840	03		 DB	 3
  00841	26		 DB	 38			; 00000026H
  00842	26		 DB	 38			; 00000026H
  00843	26		 DB	 38			; 00000026H
  00844	04		 DB	 4
  00845	26		 DB	 38			; 00000026H
  00846	26		 DB	 38			; 00000026H
  00847	26		 DB	 38			; 00000026H
  00848	05		 DB	 5
  00849	26		 DB	 38			; 00000026H
  0084a	26		 DB	 38			; 00000026H
  0084b	26		 DB	 38			; 00000026H
  0084c	06		 DB	 6
  0084d	26		 DB	 38			; 00000026H
  0084e	26		 DB	 38			; 00000026H
  0084f	26		 DB	 38			; 00000026H
  00850	07		 DB	 7
  00851	26		 DB	 38			; 00000026H
  00852	26		 DB	 38			; 00000026H
  00853	26		 DB	 38			; 00000026H
  00854	08		 DB	 8
  00855	26		 DB	 38			; 00000026H
  00856	26		 DB	 38			; 00000026H
  00857	26		 DB	 38			; 00000026H
  00858	09		 DB	 9
  00859	26		 DB	 38			; 00000026H
  0085a	26		 DB	 38			; 00000026H
  0085b	26		 DB	 38			; 00000026H
  0085c	0a		 DB	 10
  0085d	26		 DB	 38			; 00000026H
  0085e	26		 DB	 38			; 00000026H
  0085f	26		 DB	 38			; 00000026H
  00860	0b		 DB	 11
  00861	26		 DB	 38			; 00000026H
  00862	26		 DB	 38			; 00000026H
  00863	26		 DB	 38			; 00000026H
  00864	0c		 DB	 12
  00865	26		 DB	 38			; 00000026H
  00866	26		 DB	 38			; 00000026H
  00867	26		 DB	 38			; 00000026H
  00868	0d		 DB	 13
  00869	26		 DB	 38			; 00000026H
  0086a	26		 DB	 38			; 00000026H
  0086b	26		 DB	 38			; 00000026H
  0086c	0e		 DB	 14
  0086d	26		 DB	 38			; 00000026H
  0086e	26		 DB	 38			; 00000026H
  0086f	26		 DB	 38			; 00000026H
  00870	0f		 DB	 15
  00871	26		 DB	 38			; 00000026H
  00872	26		 DB	 38			; 00000026H
  00873	26		 DB	 38			; 00000026H
  00874	10		 DB	 16
  00875	26		 DB	 38			; 00000026H
  00876	26		 DB	 38			; 00000026H
  00877	26		 DB	 38			; 00000026H
  00878	11		 DB	 17
  00879	26		 DB	 38			; 00000026H
  0087a	26		 DB	 38			; 00000026H
  0087b	26		 DB	 38			; 00000026H
  0087c	12		 DB	 18
  0087d	26		 DB	 38			; 00000026H
  0087e	26		 DB	 38			; 00000026H
  0087f	26		 DB	 38			; 00000026H
  00880	13		 DB	 19
  00881	26		 DB	 38			; 00000026H
  00882	26		 DB	 38			; 00000026H
  00883	26		 DB	 38			; 00000026H
  00884	14		 DB	 20
  00885	26		 DB	 38			; 00000026H
  00886	26		 DB	 38			; 00000026H
  00887	26		 DB	 38			; 00000026H
  00888	15		 DB	 21
  00889	26		 DB	 38			; 00000026H
  0088a	26		 DB	 38			; 00000026H
  0088b	26		 DB	 38			; 00000026H
  0088c	16		 DB	 22
  0088d	26		 DB	 38			; 00000026H
  0088e	26		 DB	 38			; 00000026H
  0088f	26		 DB	 38			; 00000026H
  00890	17		 DB	 23
  00891	26		 DB	 38			; 00000026H
  00892	26		 DB	 38			; 00000026H
  00893	26		 DB	 38			; 00000026H
  00894	18		 DB	 24
  00895	26		 DB	 38			; 00000026H
  00896	26		 DB	 38			; 00000026H
  00897	26		 DB	 38			; 00000026H
  00898	19		 DB	 25
  00899	26		 DB	 38			; 00000026H
  0089a	26		 DB	 38			; 00000026H
  0089b	26		 DB	 38			; 00000026H
  0089c	1a		 DB	 26
  0089d	26		 DB	 38			; 00000026H
  0089e	26		 DB	 38			; 00000026H
  0089f	26		 DB	 38			; 00000026H
  008a0	1b		 DB	 27
  008a1	26		 DB	 38			; 00000026H
  008a2	26		 DB	 38			; 00000026H
  008a3	26		 DB	 38			; 00000026H
  008a4	1c		 DB	 28
  008a5	26		 DB	 38			; 00000026H
  008a6	26		 DB	 38			; 00000026H
  008a7	26		 DB	 38			; 00000026H
  008a8	1d		 DB	 29
  008a9	26		 DB	 38			; 00000026H
  008aa	26		 DB	 38			; 00000026H
  008ab	26		 DB	 38			; 00000026H
  008ac	1e		 DB	 30
  008ad	26		 DB	 38			; 00000026H
  008ae	26		 DB	 38			; 00000026H
  008af	26		 DB	 38			; 00000026H
  008b0	1f		 DB	 31
  008b1	26		 DB	 38			; 00000026H
  008b2	26		 DB	 38			; 00000026H
  008b3	26		 DB	 38			; 00000026H
  008b4	20		 DB	 32			; 00000020H
  008b5	26		 DB	 38			; 00000026H
  008b6	26		 DB	 38			; 00000026H
  008b7	26		 DB	 38			; 00000026H
  008b8	21		 DB	 33			; 00000021H
  008b9	26		 DB	 38			; 00000026H
  008ba	26		 DB	 38			; 00000026H
  008bb	26		 DB	 38			; 00000026H
  008bc	22		 DB	 34			; 00000022H
  008bd	26		 DB	 38			; 00000026H
  008be	26		 DB	 38			; 00000026H
  008bf	26		 DB	 38			; 00000026H
  008c0	23		 DB	 35			; 00000023H
  008c1	26		 DB	 38			; 00000026H
  008c2	26		 DB	 38			; 00000026H
  008c3	26		 DB	 38			; 00000026H
  008c4	24		 DB	 36			; 00000024H
  008c5	26		 DB	 38			; 00000026H
  008c6	26		 DB	 38			; 00000026H
  008c7	26		 DB	 38			; 00000026H
  008c8	25		 DB	 37			; 00000025H
GSTTranslateCode ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	GSTGetDosNameFromNumber
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTGetDosNameFromNumber DD imagerel $LN5
	DD	imagerel $LN5+232
	DD	imagerel $unwind$GSTGetDosNameFromNumber
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTGetDosNameFromNumber DD 021d19H
	DD	0700a720eH
	DD	imagerel __GSHandlerCheck
	DD	038H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTGetDosNameFromNumber
_TEXT	SEGMENT
tmp$ = 8
j$ = 16
tv66 = 24
tv67 = 32
tv68 = 40
tv69 = 48
__$ArrayPad$ = 56
dosname$ = 80
nDriveNo$ = 88
GSTGetDosNameFromNumber PROC				; COMDAT

; 2049 : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2050 : 	WCHAR tmp[3] =
; 2051 : 	{0, ':', 0};

  0001d	33 c0		 xor	 eax, eax
  0001f	66 89 44 24 08	 mov	 WORD PTR tmp$[rsp], ax
  00024	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH
  00029	66 89 44 24 0a	 mov	 WORD PTR tmp$[rsp+2], ax
  0002e	33 c0		 xor	 eax, eax
  00030	66 89 44 24 0c	 mov	 WORD PTR tmp$[rsp+4], ax

; 2052 : 	int j = nDriveNo + (WCHAR) 'A';

  00035	8b 44 24 58	 mov	 eax, DWORD PTR nDriveNo$[rsp]
  00039	83 c0 41	 add	 eax, 65			; 00000041H
  0003c	89 44 24 10	 mov	 DWORD PTR j$[rsp], eax

; 2053 : 
; 2054 : 	tmp[0] = (short) j;

  00040	0f b7 44 24 10	 movzx	 eax, WORD PTR j$[rsp]
  00045	66 89 44 24 08	 mov	 WORD PTR tmp$[rsp], ax

; 2055 : 	wcscpy (dosname, (LPWSTR) DOS_MOUNT_PREFIX);

  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
  00051	48 89 44 24 18	 mov	 QWORD PTR tv66[rsp], rax
  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR dosname$[rsp]
  0005b	48 89 44 24 20	 mov	 QWORD PTR tv67[rsp], rax
  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR tv67[rsp]
  00065	48 89 44 24 28	 mov	 QWORD PTR tv68[rsp], rax
$LN3@GSTGetDosN:
  0006a	48 8b 44 24 18	 mov	 rax, QWORD PTR tv66[rsp]
  0006f	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00072	66 89 44 24 30	 mov	 WORD PTR tv69[rsp], ax
  00077	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv67[rsp]
  0007c	0f b7 44 24 30	 movzx	 eax, WORD PTR tv69[rsp]
  00081	66 89 01	 mov	 WORD PTR [rcx], ax
  00084	48 8b 44 24 18	 mov	 rax, QWORD PTR tv66[rsp]
  00089	48 83 c0 02	 add	 rax, 2
  0008d	48 89 44 24 18	 mov	 QWORD PTR tv66[rsp], rax
  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR tv67[rsp]
  00097	48 83 c0 02	 add	 rax, 2
  0009b	48 89 44 24 20	 mov	 QWORD PTR tv67[rsp], rax
  000a0	66 83 7c 24 30
	00		 cmp	 WORD PTR tv69[rsp], 0
  000a6	75 c2		 jne	 SHORT $LN3@GSTGetDosN

; 2056 : 	wcscat (dosname, tmp);

  000a8	48 8b 7c 24 50	 mov	 rdi, QWORD PTR dosname$[rsp]
  000ad	33 c0		 xor	 eax, eax
  000af	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  000b6	66 f2 af	 repne scasw
  000b9	48 83 ef 02	 sub	 rdi, 2
  000bd	48 8d 54 24 08	 lea	 rdx, QWORD PTR tmp$[rsp]
  000c2	33 c9		 xor	 ecx, ecx
$LL4@GSTGetDosN:
  000c4	0f b7 04 0a	 movzx	 eax, WORD PTR [rdx+rcx]
  000c8	66 89 04 0f	 mov	 WORD PTR [rdi+rcx], ax
  000cc	48 83 c1 02	 add	 rcx, 2
  000d0	66 85 c0	 test	 ax, ax
  000d3	75 ef		 jne	 SHORT $LL4@GSTGetDosN

; 2057 : }

  000d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000da	48 33 cc	 xor	 rcx, rsp
  000dd	e8 00 00 00 00	 call	 __security_check_cookie
  000e2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
GSTGetDosNameFromNumber ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	GSTGetNTNameFromNumber
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTGetNTNameFromNumber DD imagerel $LN4
	DD	imagerel $LN4+207
	DD	imagerel $unwind$GSTGetNTNameFromNumber
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTGetNTNameFromNumber DD 011c19H
	DD	0c20dH
	DD	imagerel __GSHandlerCheck
	DD	058H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTGetNTNameFromNumber
_TEXT	SEGMENT
tmp$ = 40
j$ = 48
tv66 = 56
tv67 = 64
tv68 = 72
tv69 = 80
__$ArrayPad$ = 88
ntname$ = 112
nDriveNo$ = 120
GSTGetNTNameFromNumber PROC				; COMDAT

; 2029 : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2030 : 	WCHAR tmp[3] =
; 2031 : 	{0, ':', 0};

  0001c	33 c0		 xor	 eax, eax
  0001e	66 89 44 24 28	 mov	 WORD PTR tmp$[rsp], ax
  00023	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH
  00028	66 89 44 24 2a	 mov	 WORD PTR tmp$[rsp+2], ax
  0002d	33 c0		 xor	 eax, eax
  0002f	66 89 44 24 2c	 mov	 WORD PTR tmp$[rsp+4], ax

; 2032 : 	int j = nDriveNo + (WCHAR) 'A';

  00034	8b 44 24 78	 mov	 eax, DWORD PTR nDriveNo$[rsp]
  00038	83 c0 41	 add	 eax, 65			; 00000041H
  0003b	89 44 24 30	 mov	 DWORD PTR j$[rsp], eax

; 2033 : 
; 2034 : 	tmp[0] = (short) j;

  0003f	0f b7 44 24 30	 movzx	 eax, WORD PTR j$[rsp]
  00044	66 89 44 24 28	 mov	 WORD PTR tmp$[rsp], ax

; 2035 : 	wcscpy (ntname, (LPWSTR) NT_MOUNT_PREFIX);

  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DA@HFFKBABD@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
  00050	48 89 44 24 38	 mov	 QWORD PTR tv66[rsp], rax
  00055	48 8b 44 24 70	 mov	 rax, QWORD PTR ntname$[rsp]
  0005a	48 89 44 24 40	 mov	 QWORD PTR tv67[rsp], rax
  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR tv67[rsp]
  00064	48 89 44 24 48	 mov	 QWORD PTR tv68[rsp], rax
$LN3@GSTGetNTNa:
  00069	48 8b 44 24 38	 mov	 rax, QWORD PTR tv66[rsp]
  0006e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00071	66 89 44 24 50	 mov	 WORD PTR tv69[rsp], ax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv67[rsp]
  0007b	0f b7 44 24 50	 movzx	 eax, WORD PTR tv69[rsp]
  00080	66 89 01	 mov	 WORD PTR [rcx], ax
  00083	48 8b 44 24 38	 mov	 rax, QWORD PTR tv66[rsp]
  00088	48 83 c0 02	 add	 rax, 2
  0008c	48 89 44 24 38	 mov	 QWORD PTR tv66[rsp], rax
  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR tv67[rsp]
  00096	48 83 c0 02	 add	 rax, 2
  0009a	48 89 44 24 40	 mov	 QWORD PTR tv67[rsp], rax
  0009f	66 83 7c 24 50
	00		 cmp	 WORD PTR tv69[rsp], 0
  000a5	75 c2		 jne	 SHORT $LN3@GSTGetNTNa

; 2036 : 	wcsncat (ntname, tmp, 1);

  000a7	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ad	48 8d 54 24 28	 lea	 rdx, QWORD PTR tmp$[rsp]
  000b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ntname$[rsp]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 2037 : }

  000bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c2	48 33 cc	 xor	 rcx, rsp
  000c5	e8 00 00 00 00	 call	 __security_check_cookie
  000ca	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ce	c3		 ret	 0
GSTGetNTNameFromNumber ENDP
_TEXT	ENDS
PUBLIC	GSTSleep
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTSleep DD imagerel $LN4
	DD	imagerel $LN4+143
	DD	imagerel $unwind$GSTSleep
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTSleep DD 010801H
	DD	08208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTSleep
_TEXT	SEGMENT
timer$ = 48
duetime$ = 56
milliSeconds$ = 80
GSTSleep PROC						; COMDAT

; 1887 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1888 : 	PKTIMER timer = (PKTIMER) GSTalloc (sizeof (KTIMER));

  00008	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0000e	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00013	33 c9		 xor	 ecx, ecx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0001b	48 89 44 24 30	 mov	 QWORD PTR timer$[rsp], rax

; 1889 : 	LARGE_INTEGER duetime;
; 1890 : 
; 1891 : 	if (!timer)

  00020	48 83 7c 24 30
	00		 cmp	 QWORD PTR timer$[rsp], 0
  00026	75 02		 jne	 SHORT $LN1@GSTSleep

; 1892 : 		return;

  00028	eb 60		 jmp	 SHORT $LN2@GSTSleep
$LN1@GSTSleep:

; 1893 : 
; 1894 : 	duetime.QuadPart = (__int64) milliSeconds * -10000;

  0002a	48 63 44 24 50	 movsxd	 rax, DWORD PTR milliSeconds$[rsp]
  0002f	48 69 c0 f0 d8
	ff ff		 imul	 rax, -10000		; ffffffffffffd8f0H
  00036	48 89 44 24 38	 mov	 QWORD PTR duetime$[rsp], rax

; 1895 : 	KeInitializeTimerEx(timer, NotificationTimer);

  0003b	33 d2		 xor	 edx, edx
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR timer$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeTimerEx

; 1896 : 	KeSetTimerEx(timer, duetime, 0, NULL);

  00048	45 33 c9	 xor	 r9d, r9d
  0004b	45 33 c0	 xor	 r8d, r8d
  0004e	48 8b 54 24 38	 mov	 rdx, QWORD PTR duetime$[rsp]
  00053	48 8b 4c 24 30	 mov	 rcx, QWORD PTR timer$[rsp]
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetTimerEx

; 1897 : 
; 1898 : 	KeWaitForSingleObject (timer, Executive, KernelMode, FALSE, NULL);

  0005e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00067	45 33 c9	 xor	 r9d, r9d
  0006a	45 33 c0	 xor	 r8d, r8d
  0006d	33 d2		 xor	 edx, edx
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR timer$[rsp]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1899 : 
; 1900 : 	GSTfree (timer);

  0007a	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR timer$[rsp]
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@GSTSleep:

; 1901 : }

  0008a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008e	c3		 ret	 0
GSTSleep ENDP
_TEXT	ENDS
PUBLIC	GSTStopVolumeThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTStopVolumeThread DD imagerel $LN6
	DD	imagerel $LN6+200
	DD	imagerel $unwind$GSTStopVolumeThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTStopVolumeThread DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTStopVolumeThread
_TEXT	SEGMENT
ntStatus$ = 48
tv84 = 52
DeviceObject$ = 80
Extension$ = 88
GSTStopVolumeThread PROC				; COMDAT

; 1848 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1849 : 	NTSTATUS ntStatus;
; 1850 : 
; 1851 : 	if (DeviceObject);	/* Remove compiler warning */
; 1852 : 
; 1853 : 	Dump ("Signalling thread to quit...\n");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@
  00015	e8 00 00 00 00	 call	 DbgPrint

; 1854 : 
; 1855 : 	Extension->bThreadShouldQuit = TRUE;

  0001a	4c 8b 5c 24 58	 mov	 r11, QWORD PTR Extension$[rsp]
  0001f	41 c7 43 1c 01
	00 00 00	 mov	 DWORD PTR [r11+28], 1

; 1856 : 
; 1857 : 	KeReleaseSemaphore (&Extension->RequestSemaphore,
; 1858 : 			    0,
; 1859 : 			    1,
; 1860 : 			    TRUE);

  00027	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Extension$[rsp]
  0002c	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00030	41 b1 01	 mov	 r9b, 1
  00033	41 b8 01 00 00
	00		 mov	 r8d, 1
  00039	33 d2		 xor	 edx, edx
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSemaphore

; 1861 : 
; 1862 : 	ntStatus = KeWaitForSingleObject (Extension->peThread,
; 1863 : 					  Executive,
; 1864 : 					  KernelMode,
; 1865 : 					  FALSE,
; 1866 : 					  NULL);

  00041	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0004a	45 33 c9	 xor	 r9d, r9d
  0004d	45 33 c0	 xor	 r8d, r8d
  00050	33 d2		 xor	 edx, edx
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Extension$[rsp]
  00057	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00061	89 44 24 30	 mov	 DWORD PTR ntStatus$[rsp], eax

; 1867 : 
; 1868 : 	ASSERT (NT_SUCCESS (ntStatus));

  00065	83 7c 24 30 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0006a	7d 27		 jge	 SHORT $LN4@GSTStopVol
  0006c	45 33 c9	 xor	 r9d, r9d
  0006f	41 b8 4c 07 00
	00		 mov	 r8d, 1868		; 0000074cH
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00089	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
  00091	eb 08		 jmp	 SHORT $LN5@GSTStopVol
$LN4@GSTStopVol:
  00093	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
$LN5@GSTStopVol:

; 1869 : 
; 1870 : 	ObDereferenceObject (Extension->peThread);

  0009b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Extension$[rsp]
  000a0	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 1871 : 	Extension->peThread = NULL;

  000aa	4c 8b 5c 24 58	 mov	 r11, QWORD PTR Extension$[rsp]
  000af	49 c7 43 20 00
	00 00 00	 mov	 QWORD PTR [r11+32], 0

; 1872 : 
; 1873 : 	Dump ("Thread exited\n");

  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@
  000be	e8 00 00 00 00	 call	 DbgPrint

; 1874 : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
GSTStopVolumeThread ENDP
_TEXT	ENDS
PUBLIC	GSTStopThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTStopThread DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$GSTStopThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTStopThread DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTStopThread
_TEXT	SEGMENT
kThread$ = 64
wakeUpEvent$ = 72
GSTStopThread PROC					; COMDAT

; 1742 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1743 : 	if (wakeUpEvent)

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR wakeUpEvent$[rsp], 0
  00014	74 10		 je	 SHORT $LN1@GSTStopThr

; 1744 : 		KeSetEvent (wakeUpEvent, 0, FALSE);

  00016	45 33 c0	 xor	 r8d, r8d
  00019	33 d2		 xor	 edx, edx
  0001b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR wakeUpEvent$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN1@GSTStopThr:

; 1745 : 
; 1746 : 	KeWaitForSingleObject (kThread, Executive, KernelMode, FALSE, NULL);

  00026	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	45 33 c0	 xor	 r8d, r8d
  00035	33 d2		 xor	 edx, edx
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR kThread$[rsp]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1747 : 	ObDereferenceObject (kThread);

  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR kThread$[rsp]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 1748 : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
GSTStopThread ENDP
_TEXT	ENDS
PUBLIC	GSTStartThreadInProcess
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTStartThreadInProcess DD imagerel $LN8
	DD	imagerel $LN8+403
	DD	imagerel $unwind$GSTStartThreadInProcess
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTStartThreadInProcess DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTStartThreadInProcess
_TEXT	SEGMENT
threadObjAttributes$ = 64
processHandle$ = 112
threadHandle$ = 120
status$ = 128
threadProc$ = 160
threadArg$ = 168
kThread$ = 176
process$ = 184
GSTStartThreadInProcess PROC				; COMDAT

; 1697 : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1698 : 	NTSTATUS status;
; 1699 : 	HANDLE threadHandle;
; 1700 : 	HANDLE processHandle = NULL;

  0001b	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR processHandle$[rsp], 0

; 1701 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1702 : 
; 1703 : 	if (process)

  00024	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR process$[rsp], 0
  0002d	74 4e		 je	 SHORT $LN5@GSTStartTh

; 1704 : 	{
; 1705 : 		status = ObOpenObjectByPointer (process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &processHandle);

  0002f	48 8d 44 24 70	 lea	 rax, QWORD PTR processHandle$[rsp]
  00034	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00039	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0003e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00047	45 33 c9	 xor	 r9d, r9d
  0004a	45 33 c0	 xor	 r8d, r8d
  0004d	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00052	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR process$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObOpenObjectByPointer
  00060	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 1706 : 		if (!NT_SUCCESS (status))

  00067	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR status$[rsp], 0
  0006f	7d 0c		 jge	 SHORT $LN4@GSTStartTh

; 1707 : 			return status;

  00071	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00078	e9 0e 01 00 00	 jmp	 $LN6@GSTStartTh
$LN4@GSTStartTh:
$LN5@GSTStartTh:

; 1708 : 	}
; 1709 : 
; 1710 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  0007d	c7 44 24 40 30
	00 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp], 48 ; 00000030H
  00085	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+8], 0
  0008e	c7 44 24 58 00
	02 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp+24], 512 ; 00000200H
  00096	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+16], 0
  0009f	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+32], 0
  000a8	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+40], 0

; 1711 : 	
; 1712 : 	status = PsCreateSystemThread (&threadHandle, THREAD_ALL_ACCESS, &threadObjAttributes, processHandle, NULL, threadProc, threadArg);

  000b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR threadArg$[rsp]
  000b9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000be	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR threadProc$[rsp]
  000c6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000cb	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000d4	4c 8b 4c 24 70	 mov	 r9, QWORD PTR processHandle$[rsp]
  000d9	4c 8d 44 24 40	 lea	 r8, QWORD PTR threadObjAttributes$[rsp]
  000de	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  000e3	48 8d 4c 24 78	 lea	 rcx, QWORD PTR threadHandle$[rsp]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread
  000ee	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 1713 : 	if (!NT_SUCCESS (status))

  000f5	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR status$[rsp], 0
  000fd	7d 0c		 jge	 SHORT $LN3@GSTStartTh

; 1714 : 		return status;

  000ff	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00106	e9 80 00 00 00	 jmp	 $LN6@GSTStartTh
$LN3@GSTStartTh:

; 1715 : 
; 1716 : 	status = ObReferenceObjectByHandle (threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *) kThread, NULL);

  0010b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00114	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR kThread$[rsp]
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	45 33 c9	 xor	 r9d, r9d
  00124	45 33 c0	 xor	 r8d, r8d
  00127	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  0012c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  00137	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 1717 : 	if (!NT_SUCCESS (status))

  0013e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR status$[rsp], 0
  00146	7d 23		 jge	 SHORT $LN2@GSTStartTh

; 1718 : 	{
; 1719 : 		ZwClose (threadHandle);

  00148	48 8b 4c 24 78	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1720 : 		*kThread = NULL;

  00153	4c 8b 9c 24 b0
	00 00 00	 mov	 r11, QWORD PTR kThread$[rsp]
  0015b	49 c7 03 00 00
	00 00		 mov	 QWORD PTR [r11], 0

; 1721 : 		return status;

  00162	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00169	eb 20		 jmp	 SHORT $LN6@GSTStartTh
$LN2@GSTStartTh:

; 1722 : 	}
; 1723 : 
; 1724 : 	if (processHandle)

  0016b	48 83 7c 24 70
	00		 cmp	 QWORD PTR processHandle$[rsp], 0
  00171	74 0b		 je	 SHORT $LN1@GSTStartTh

; 1725 : 		ZwClose (processHandle);

  00173	48 8b 4c 24 70	 mov	 rcx, QWORD PTR processHandle$[rsp]
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@GSTStartTh:

; 1726 : 
; 1727 : 	ZwClose (threadHandle);

  0017e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1728 : 	return STATUS_SUCCESS;

  00189	33 c0		 xor	 eax, eax
$LN6@GSTStartTh:

; 1729 : }

  0018b	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00192	c3		 ret	 0
GSTStartThreadInProcess ENDP
_TEXT	ENDS
PUBLIC	GSTStartThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTStartThread DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$GSTStartThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTStartThread DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTStartThread
_TEXT	SEGMENT
threadProc$ = 48
threadArg$ = 56
kThread$ = 64
GSTStartThread PROC					; COMDAT

; 1680 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1681 : 	return GSTStartThreadInProcess (threadProc, threadArg, kThread, NULL);

  00013	45 33 c9	 xor	 r9d, r9d
  00016	4c 8b 44 24 40	 mov	 r8, QWORD PTR kThread$[rsp]
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR threadArg$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR threadProc$[rsp]
  00025	e8 00 00 00 00	 call	 GSTStartThreadInProcess

; 1682 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
GSTStartThread ENDP
_TEXT	ENDS
PUBLIC	RootDeviceControlMutexRelease
RootDeviceControlMutex DB 038H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$RootDeviceControlMutexRelease DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$RootDeviceControlMutexRelease
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RootDeviceControlMutexRelease DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RootDeviceControlMutexRelease
_TEXT	SEGMENT
RootDeviceControlMutexRelease PROC			; COMDAT

; 575  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 576  : 	KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  00004	33 d2		 xor	 edx, edx
  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex

; 577  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
RootDeviceControlMutexRelease ENDP
_TEXT	ENDS
PUBLIC	RootDeviceControlMutexAcquireNoWait
;	COMDAT pdata
pdata	SEGMENT
$pdata$RootDeviceControlMutexAcquireNoWait DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$RootDeviceControlMutexAcquireNoWait
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RootDeviceControlMutexAcquireNoWait DD 010401H
	DD	0a204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RootDeviceControlMutexAcquireNoWait
_TEXT	SEGMENT
status$ = 48
timeout$ = 56
tv72 = 64
RootDeviceControlMutexAcquireNoWait PROC		; COMDAT

; 557  : {

$LN5:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 558  : 	NTSTATUS status;
; 559  : 	LARGE_INTEGER timeout;
; 560  : 	timeout.QuadPart = 0;

  00004	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR timeout$[rsp], 0

; 561  : 
; 562  : 	status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, &timeout);

  0000d	48 8d 44 24 38	 lea	 rax, QWORD PTR timeout$[rsp]
  00012	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00017	45 33 c9	 xor	 r9d, r9d
  0001a	45 33 c0	 xor	 r8d, r8d
  0001d	33 d2		 xor	 edx, edx
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0002c	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 563  : 	return NT_SUCCESS (status) && status != STATUS_TIMEOUT;

  00030	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00035	7c 14		 jl	 SHORT $LN3@RootDevice
  00037	81 7c 24 30 02
	01 00 00	 cmp	 DWORD PTR status$[rsp], 258 ; 00000102H
  0003f	74 0a		 je	 SHORT $LN3@RootDevice
  00041	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00049	eb 08		 jmp	 SHORT $LN4@RootDevice
$LN3@RootDevice:
  0004b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN4@RootDevice:
  00053	8b 44 24 40	 mov	 eax, DWORD PTR tv72[rsp]

; 564  : }

  00057	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0005b	c3		 ret	 0
RootDeviceControlMutexAcquireNoWait ENDP
_TEXT	ENDS
PUBLIC	GetVirtualVolumeDeviceObject
; Function compile flags: /Odtp
;	COMDAT GetVirtualVolumeDeviceObject
_TEXT	SEGMENT
driveNumber$ = 8
GetVirtualVolumeDeviceObject PROC			; COMDAT

; 245  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 246  : 	if (driveNumber < MIN_MOUNTED_VOLUME_DRIVE_NUMBER || driveNumber > MAX_MOUNTED_VOLUME_DRIVE_NUMBER)

  00004	83 7c 24 08 00	 cmp	 DWORD PTR driveNumber$[rsp], 0
  00009	7c 07		 jl	 SHORT $LN1@GetVirtual
  0000b	83 7c 24 08 19	 cmp	 DWORD PTR driveNumber$[rsp], 25
  00010	7e 04		 jle	 SHORT $LN2@GetVirtual
$LN1@GetVirtual:

; 247  : 		return NULL;

  00012	33 c0		 xor	 eax, eax
  00014	eb 10		 jmp	 SHORT $LN3@GetVirtual
$LN2@GetVirtual:

; 248  : 
; 249  : 	return VirtualVolumeDeviceObjects[driveNumber];

  00016	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR driveNumber$[rsp]
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:VirtualVolumeDeviceObjects
  00022	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
$LN3@GetVirtual:

; 250  : }

  00026	f3 c3		 fatret	 0
GetVirtualVolumeDeviceObject ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	DumpMemory
;	COMDAT pdata
pdata	SEGMENT
$pdata$DumpMemory DD imagerel $LN11
	DD	imagerel $LN11+386
	DD	imagerel $unwind$DumpMemory
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpMemory DD 042419H
	DD	0150112H
	DD	0300a700bH
	DD	imagerel __GSHandlerCheck
	DD	090H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DumpMemory
_TEXT	SEGMENT
i$ = 96
j$ = 100
m$ = 104
str$ = 120
__$ArrayPad$ = 144
mem$ = 192
size$ = 200
DumpMemory PROC						; COMDAT

; 179  : {

$LN11:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	53		 push	 rbx
  0000a	57		 push	 rdi
  0000b	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 180  : 	unsigned char str[20];
; 181  : 	unsigned char *m = mem;

  00024	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR mem$[rsp]
  0002c	48 89 44 24 68	 mov	 QWORD PTR m$[rsp], rax

; 182  : 	int i,j;
; 183  : 
; 184  : 	for (j = 0; j < size / 8; j++)

  00031	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00039	eb 0b		 jmp	 SHORT $LN8@DumpMemory
$LN7@DumpMemory:
  0003b	8b 44 24 64	 mov	 eax, DWORD PTR j$[rsp]
  0003f	83 c0 01	 add	 eax, 1
  00042	89 44 24 64	 mov	 DWORD PTR j$[rsp], eax
$LN8@DumpMemory:
  00046	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  0004d	99		 cdq
  0004e	83 e2 07	 and	 edx, 7
  00051	03 c2		 add	 eax, edx
  00053	c1 f8 03	 sar	 eax, 3
  00056	39 44 24 64	 cmp	 DWORD PTR j$[rsp], eax
  0005a	0f 8d 08 01 00
	00		 jge	 $LN6@DumpMemory

; 185  : 	{
; 186  : 		memset (str,0,sizeof str);

  00060	48 8d 7c 24 78	 lea	 rdi, QWORD PTR str$[rsp]
  00065	33 c0		 xor	 eax, eax
  00067	b9 14 00 00 00	 mov	 ecx, 20
  0006c	f3 aa		 rep stosb

; 187  : 		for (i = 0; i < 8; i++) 

  0006e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00076	eb 0b		 jmp	 SHORT $LN5@DumpMemory
$LN4@DumpMemory:
  00078	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0007c	83 c0 01	 add	 eax, 1
  0007f	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN5@DumpMemory:
  00083	83 7c 24 60 08	 cmp	 DWORD PTR i$[rsp], 8
  00088	7d 4b		 jge	 SHORT $LN3@DumpMemory

; 188  : 		{
; 189  : 			if (m[i] > ' ' && m[i] <= '~')

  0008a	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  0008f	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  00094	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00098	83 f8 20	 cmp	 eax, 32			; 00000020H
  0009b	7e 2c		 jle	 SHORT $LN2@DumpMemory
  0009d	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a2	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000a7	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000ab	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  000ae	7f 19		 jg	 SHORT $LN2@DumpMemory

; 190  : 				str[i]=m[i];

  000b0	48 63 54 24 60	 movsxd	 rdx, DWORD PTR i$[rsp]
  000b5	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  000ba	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000bf	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  000c3	88 44 0c 78	 mov	 BYTE PTR str$[rsp+rcx], al

; 191  : 			else

  000c7	eb 0a		 jmp	 SHORT $LN1@DumpMemory
$LN2@DumpMemory:

; 192  : 				str[i]='.';

  000c9	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000ce	c6 44 04 78 2e	 mov	 BYTE PTR str$[rsp+rax], 46 ; 0000002eH
$LN1@DumpMemory:

; 193  : 		}

  000d3	eb a3		 jmp	 SHORT $LN4@DumpMemory
$LN3@DumpMemory:

; 194  : 
; 195  : 		Dump ("0x%08p  %02x %02x %02x %02x %02x %02x %02x %02x  %s\n",
; 196  : 			m, m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], str);

  000d5	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000da	0f b6 58 07	 movzx	 ebx, BYTE PTR [rax+7]
  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000e3	44 0f b6 58 06	 movzx	 r11d, BYTE PTR [rax+6]
  000e8	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000ed	44 0f b6 50 05	 movzx	 r10d, BYTE PTR [rax+5]
  000f2	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000f7	0f b6 78 04	 movzx	 edi, BYTE PTR [rax+4]
  000fb	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  00100	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00104	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  00109	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0010d	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  00112	44 0f b6 48 01	 movzx	 r9d, BYTE PTR [rax+1]
  00117	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  0011c	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  00120	48 8d 44 24 78	 lea	 rax, QWORD PTR str$[rsp]
  00125	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0012a	89 5c 24 48	 mov	 DWORD PTR [rsp+72], ebx
  0012e	44 89 5c 24 40	 mov	 DWORD PTR [rsp+64], r11d
  00133	44 89 54 24 38	 mov	 DWORD PTR [rsp+56], r10d
  00138	89 7c 24 30	 mov	 DWORD PTR [rsp+48], edi
  0013c	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00140	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00144	48 8b 54 24 68	 mov	 rdx, QWORD PTR m$[rsp]
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@
  00150	e8 00 00 00 00	 call	 DbgPrint

; 197  : 
; 198  : 		m+=8;

  00155	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  0015a	48 83 c0 08	 add	 rax, 8
  0015e	48 89 44 24 68	 mov	 QWORD PTR m$[rsp], rax

; 199  : 	}

  00163	e9 d3 fe ff ff	 jmp	 $LN7@DumpMemory
$LN6@DumpMemory:

; 200  : }

  00168	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00170	48 33 cc	 xor	 rcx, rsp
  00173	e8 00 00 00 00	 call	 __security_check_cookie
  00178	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0017f	5f		 pop	 rdi
  00180	5b		 pop	 rbx
  00181	c3		 ret	 0
DumpMemory ENDP
PUBLIC	ReadRegistryConfigFlags
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadRegistryConfigFlags DD imagerel $LN13
	DD	imagerel $LN13+307
	DD	imagerel $unwind$ReadRegistryConfigFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadRegistryConfigFlags DD 010801H
	DD	0a208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReadRegistryConfigFlags
_TEXT	SEGMENT
flags$ = 32
name$ = 40
status$ = 56
data$ = 64
tv83 = 72
driverEntry$ = 96
ReadRegistryConfigFlags PROC				; COMDAT

; 3599 : {

$LN13:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3600 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3601 : 	UNICODE_STRING name;
; 3602 : 	NTSTATUS status;
; 3603 : 	uint32 flags = 0;

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR flags$[rsp], 0

; 3604 : 
; 3605 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\gostcrypt");

  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1HM@FBFGPOIK@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  00017	48 8d 4c 24 28	 lea	 rcx, QWORD PTR name$[rsp]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3606 : 	status = GSTReadRegistryKey (&name, GST_DRIVER_CONFIG_REG_VALUE_NAME, &data);

  00022	4c 8d 44 24 40	 lea	 r8, QWORD PTR data$[rsp]
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@KPILIDPC@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
  0002e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR name$[rsp]
  00033	e8 00 00 00 00	 call	 GSTReadRegistryKey
  00038	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3607 : 
; 3608 : 	if (NT_SUCCESS (status))

  0003c	83 7c 24 38 00	 cmp	 DWORD PTR status$[rsp], 0
  00041	0f 8c 98 00 00
	00		 jl	 $LN8@ReadRegist

; 3609 : 	{
; 3610 : 		if (data->Type == REG_DWORD)

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0004c	83 78 04 04	 cmp	 DWORD PTR [rax+4], 4
  00050	75 75		 jne	 SHORT $LN7@ReadRegist

; 3611 : 		{
; 3612 : 			flags = *(uint32 *) data->Data;

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00057	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0005a	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax

; 3613 : 			Dump ("Configuration flags = 0x%x\n", flags);

  0005e	8b 54 24 20	 mov	 edx, DWORD PTR flags$[rsp]
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@
  00069	e8 00 00 00 00	 call	 DbgPrint

; 3614 : 
; 3615 : 			if (driverEntry)

  0006e	83 7c 24 60 00	 cmp	 DWORD PTR driverEntry$[rsp], 0
  00073	74 2a		 je	 SHORT $LN6@ReadRegist

; 3616 : 			{
; 3617 : 				if (flags & (GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD | GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))

  00075	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00079	83 e0 03	 and	 eax, 3
  0007c	85 c0		 test	 eax, eax
  0007e	74 0a		 je	 SHORT $LN5@ReadRegist

; 3618 : 					CacheBootPassword = TRUE;

  00080	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR CacheBootPassword, 1
$LN5@ReadRegist:

; 3619 : 
; 3620 : 				if (flags & GST_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS)

  0008a	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  0008e	83 e0 04	 and	 eax, 4
  00091	85 c0		 test	 eax, eax
  00093	74 0a		 je	 SHORT $LN4@ReadRegist

; 3621 : 					NonAdminSystemFavoritesAccessDisabled = TRUE;

  00095	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NonAdminSystemFavoritesAccessDisabled, 1
$LN4@ReadRegist:
$LN6@ReadRegist:

; 3622 : 			}
; 3623 : 
; 3624 : 			EnableHwEncryption ((flags & GST_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION) ? FALSE : TRUE);

  0009f	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  000a3	83 e0 08	 and	 eax, 8
  000a6	85 c0		 test	 eax, eax
  000a8	74 0a		 je	 SHORT $LN11@ReadRegist
  000aa	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  000b2	eb 08		 jmp	 SHORT $LN12@ReadRegist
$LN11@ReadRegist:
  000b4	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
$LN12@ReadRegist:
  000bc	8b 4c 24 48	 mov	 ecx, DWORD PTR tv83[rsp]
  000c0	e8 00 00 00 00	 call	 EnableHwEncryption

; 3625 : 		}
; 3626 : 		else

  000c5	eb 08		 jmp	 SHORT $LN3@ReadRegist
$LN7@ReadRegist:

; 3627 : 			status = STATUS_INVALID_PARAMETER;

  000c7	c7 44 24 38 0d
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741811 ; ffffffffc000000dH
$LN3@ReadRegist:

; 3628 : 
; 3629 : 		GSTfree (data);

  000cf	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  000d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN8@ReadRegist:

; 3630 : 	}
; 3631 : 
; 3632 : 	if (driverEntry && NT_SUCCESS (GSTReadRegistryKey (&name, GST_ENCRYPTION_FREE_CPU_COUNT_REG_VALUE_NAME, &data)))

  000df	83 7c 24 60 00	 cmp	 DWORD PTR driverEntry$[rsp], 0
  000e4	74 44		 je	 SHORT $LN2@ReadRegist
  000e6	4c 8d 44 24 40	 lea	 r8, QWORD PTR data$[rsp]
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EA@BHENEMCP@?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
  000f2	48 8d 4c 24 28	 lea	 rcx, QWORD PTR name$[rsp]
  000f7	e8 00 00 00 00	 call	 GSTReadRegistryKey
  000fc	85 c0		 test	 eax, eax
  000fe	7c 2a		 jl	 SHORT $LN2@ReadRegist

; 3633 : 	{
; 3634 : 		if (data->Type == REG_DWORD)

  00100	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00105	83 78 04 04	 cmp	 DWORD PTR [rax+4], 4
  00109	75 0f		 jne	 SHORT $LN1@ReadRegist

; 3635 : 			EncryptionThreadPoolFreeCpuCountLimit = *(uint32 *) data->Data;

  0010b	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00110	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00113	48 89 05 00 00
	00 00		 mov	 QWORD PTR EncryptionThreadPoolFreeCpuCountLimit, rax
$LN1@ReadRegist:

; 3636 : 
; 3637 : 		GSTfree (data);

  0011a	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0011f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@ReadRegist:

; 3638 : 	}
; 3639 : 
; 3640 : 	return status;

  0012a	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]

; 3641 : }

  0012e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00132	c3		 ret	 0
ReadRegistryConfigFlags ENDP
_TEXT	ENDS
PUBLIC	IsVolumeClassFilterRegistered
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsVolumeClassFilterRegistered DD imagerel $LN9
	DD	imagerel $LN9+219
	DD	imagerel $unwind$IsVolumeClassFilterRegistered
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsVolumeClassFilterRegistered DD 010401H
	DD	0a204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsVolumeClassFilterRegistered
_TEXT	SEGMENT
registered$ = 32
name$ = 40
data$ = 56
status$ = 64
i$32193 = 68
IsVolumeClassFilterRegistered PROC			; COMDAT

; 3556 : {

$LN9:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3557 : 	UNICODE_STRING name;
; 3558 : 	NTSTATUS status;
; 3559 : 	BOOL registered = FALSE;

  00004	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR registered$[rsp], 0

; 3560 : 
; 3561 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3562 : 
; 3563 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}");

  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  00013	48 8d 4c 24 28	 lea	 rcx, QWORD PTR name$[rsp]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3564 : 	status = GSTReadRegistryKey (&name, L"UpperFilters", &data);

  0001e	4c 8d 44 24 38	 lea	 r8, QWORD PTR data$[rsp]
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
  0002a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR name$[rsp]
  0002f	e8 00 00 00 00	 call	 GSTReadRegistryKey
  00034	89 44 24 40	 mov	 DWORD PTR status$[rsp], eax

; 3565 : 
; 3566 : 	if (NT_SUCCESS (status))

  00038	83 7c 24 40 00	 cmp	 DWORD PTR status$[rsp], 0
  0003d	0f 8c 8f 00 00
	00		 jl	 $LN6@IsVolumeCl

; 3567 : 	{
; 3568 : 		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))

  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  00048	83 78 04 07	 cmp	 DWORD PTR [rax+4], 7
  0004c	75 74		 jne	 SHORT $LN5@IsVolumeCl
  0004e	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  00053	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00056	48 83 f8 12	 cmp	 rax, 18
  0005a	72 66		 jb	 SHORT $LN5@IsVolumeCl

; 3569 : 		{
; 3570 : 			// Search for the string "gostcrypt"
; 3571 : 			ULONG i;
; 3572 : 			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)

  0005c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$32193[rsp], 0
  00064	eb 0b		 jmp	 SHORT $LN4@IsVolumeCl
$LN3@IsVolumeCl:
  00066	8b 44 24 44	 mov	 eax, DWORD PTR i$32193[rsp]
  0006a	83 c0 01	 add	 eax, 1
  0006d	89 44 24 44	 mov	 DWORD PTR i$32193[rsp], eax
$LN4@IsVolumeCl:
  00071	8b 4c 24 44	 mov	 ecx, DWORD PTR i$32193[rsp]
  00075	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  0007a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0007d	48 83 e8 12	 sub	 rax, 18
  00081	48 3b c8	 cmp	 rcx, rax
  00084	77 3c		 ja	 SHORT $LN2@IsVolumeCl

; 3573 : 			{
; 3574 : 				if (memcmp (data->Data + i, L"gostcrypt", 9 * sizeof (wchar_t)) == 0)

  00086	8b 4c 24 44	 mov	 ecx, DWORD PTR i$32193[rsp]
  0008a	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  0008f	48 8d 4c 08 0c	 lea	 rcx, QWORD PTR [rax+rcx+12]
  00094	41 b8 12 00 00
	00		 mov	 r8d, 18
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BE@NLKDDOJN@?$AAg?$AAo?$AAs?$AAt?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  000a1	e8 00 00 00 00	 call	 memcmp
  000a6	85 c0		 test	 eax, eax
  000a8	75 16		 jne	 SHORT $LN1@IsVolumeCl

; 3575 : 				{
; 3576 : 					Dump ("Volume class filter active\n");

  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@
  000b1	e8 00 00 00 00	 call	 DbgPrint

; 3577 : 					registered = TRUE;

  000b6	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR registered$[rsp], 1

; 3578 : 					break;

  000be	eb 02		 jmp	 SHORT $LN2@IsVolumeCl
$LN1@IsVolumeCl:

; 3579 : 				}
; 3580 : 			}

  000c0	eb a4		 jmp	 SHORT $LN3@IsVolumeCl
$LN2@IsVolumeCl:
$LN5@IsVolumeCl:

; 3581 : 		}
; 3582 : 
; 3583 : 		GSTfree (data);

  000c2	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  000c7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@IsVolumeCl:

; 3584 : 	}
; 3585 : 
; 3586 : 	return registered;

  000d2	8b 44 24 20	 mov	 eax, DWORD PTR registered$[rsp]

; 3587 : }

  000d6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000da	c3		 ret	 0
IsVolumeClassFilterRegistered ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	IsDriveLetterAvailable
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsDriveLetterAvailable DD imagerel $LN4
	DD	imagerel $LN4+196
	DD	imagerel $unwind$IsDriveLetterAvailable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsDriveLetterAvailable DD 021d19H
	DD	031010bH
	DD	imagerel __GSHandlerCheck
	DD	0178H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsDriveLetterAvailable
_TEXT	SEGMENT
objectAttributes$ = 32
link$ = 96
objectName$ = 352
handle$ = 368
__$ArrayPad$ = 376
nDosDriveNo$ = 400
IsDriveLetterAvailable PROC				; COMDAT

; 3325 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3326 : 	OBJECT_ATTRIBUTES objectAttributes;
; 3327 : 	UNICODE_STRING objectName;
; 3328 : 	WCHAR link[128];
; 3329 : 	HANDLE handle;
; 3330 : 
; 3331 : 	GSTGetDosNameFromNumber (link, nDosDriveNo);

  0001d	8b 94 24 90 01
	00 00		 mov	 edx, DWORD PTR nDosDriveNo$[rsp]
  00024	48 8d 4c 24 60	 lea	 rcx, QWORD PTR link$[rsp]
  00029	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 3332 : 	RtlInitUnicodeString (&objectName, link);

  0002e	48 8d 54 24 60	 lea	 rdx, QWORD PTR link$[rsp]
  00033	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR objectName$[rsp]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3333 : 	InitializeObjectAttributes (&objectAttributes, &objectName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00041	c7 44 24 20 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  00049	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+8], 0
  00052	c7 44 24 38 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  0005a	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR objectName$[rsp]
  00062	48 89 44 24 30	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  00067	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+32], 0
  00070	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+40], 0

; 3334 : 
; 3335 : 	if (NT_SUCCESS (ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes)))

  00079	4c 8d 44 24 20	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  0007e	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00083	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR handle$[rsp]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenSymbolicLinkObject
  00091	85 c0		 test	 eax, eax
  00093	7c 12		 jl	 SHORT $LN1@IsDriveLet

; 3336 : 	{
; 3337 : 		ZwClose (handle);

  00095	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR handle$[rsp]
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3338 : 		return FALSE;

  000a3	33 c0		 xor	 eax, eax
  000a5	eb 05		 jmp	 SHORT $LN2@IsDriveLet
$LN1@IsDriveLet:

; 3339 : 	}
; 3340 : 
; 3341 : 	return TRUE;

  000a7	b8 01 00 00 00	 mov	 eax, 1
$LN2@IsDriveLet:

; 3342 : }

  000ac	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b4	48 33 cc	 xor	 rcx, rsp
  000b7	e8 00 00 00 00	 call	 __security_check_cookie
  000bc	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  000c3	c3		 ret	 0
IsDriveLetterAvailable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FindVolumeWithHighestUniqueId DD imagerel FindVolumeWithHighestUniqueId
	DD	imagerel FindVolumeWithHighestUniqueId+151
	DD	imagerel $unwind$FindVolumeWithHighestUniqueId
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FindVolumeWithHighestUniqueId DD 010801H
	DD	08208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT FindVolumeWithHighestUniqueId
_TEXT	SEGMENT
highestId$ = 32
drive$ = 36
highestIdDevice$ = 40
device$31976 = 48
extension$31978 = 56
maxUniqueId$ = 80
FindVolumeWithHighestUniqueId PROC			; COMDAT

; 3107 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3108 : 	PDEVICE_OBJECT highestIdDevice = NULL;

  00008	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR highestIdDevice$[rsp], 0

; 3109 : 	int highestId = -1;

  00011	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR highestId$[rsp], -1

; 3110 : 	int drive;
; 3111 : 
; 3112 : 	for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00019	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR drive$[rsp], 0
  00021	eb 0b		 jmp	 SHORT $LN5@FindVolume
$LN4@FindVolume:
  00023	8b 44 24 24	 mov	 eax, DWORD PTR drive$[rsp]
  00027	83 c0 01	 add	 eax, 1
  0002a	89 44 24 24	 mov	 DWORD PTR drive$[rsp], eax
$LN5@FindVolume:
  0002e	83 7c 24 24 19	 cmp	 DWORD PTR drive$[rsp], 25
  00033	7f 58		 jg	 SHORT $LN3@FindVolume

; 3113 : 	{
; 3114 : 		PDEVICE_OBJECT device = GetVirtualVolumeDeviceObject (drive);

  00035	8b 4c 24 24	 mov	 ecx, DWORD PTR drive$[rsp]
  00039	e8 00 00 00 00	 call	 GetVirtualVolumeDeviceObject
  0003e	48 89 44 24 30	 mov	 QWORD PTR device$31976[rsp], rax

; 3115 : 		if (device)

  00043	48 83 7c 24 30
	00		 cmp	 QWORD PTR device$31976[rsp], 0
  00049	74 40		 je	 SHORT $LN2@FindVolume

; 3116 : 		{
; 3117 : 			PEXTENSION extension = (PEXTENSION) device->DeviceExtension;

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR device$31976[rsp]
  00050	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00054	48 89 44 24 38	 mov	 QWORD PTR extension$31978[rsp], rax

; 3118 : 			if (extension->UniqueVolumeId > highestId && extension->UniqueVolumeId <= maxUniqueId)

  00059	48 8b 4c 24 38	 mov	 rcx, QWORD PTR extension$31978[rsp]
  0005e	8b 44 24 20	 mov	 eax, DWORD PTR highestId$[rsp]
  00062	39 41 10	 cmp	 DWORD PTR [rcx+16], eax
  00065	7e 24		 jle	 SHORT $LN1@FindVolume
  00067	48 8b 4c 24 38	 mov	 rcx, QWORD PTR extension$31978[rsp]
  0006c	8b 44 24 50	 mov	 eax, DWORD PTR maxUniqueId$[rsp]
  00070	39 41 10	 cmp	 DWORD PTR [rcx+16], eax
  00073	7f 16		 jg	 SHORT $LN1@FindVolume

; 3119 : 			{
; 3120 : 				highestId = extension->UniqueVolumeId;

  00075	48 8b 44 24 38	 mov	 rax, QWORD PTR extension$31978[rsp]
  0007a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007d	89 44 24 20	 mov	 DWORD PTR highestId$[rsp], eax

; 3121 : 				highestIdDevice = device;

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR device$31976[rsp]
  00086	48 89 44 24 28	 mov	 QWORD PTR highestIdDevice$[rsp], rax
$LN1@FindVolume:
$LN2@FindVolume:

; 3122 : 			}
; 3123 : 		}
; 3124 : 	}

  0008b	eb 96		 jmp	 SHORT $LN4@FindVolume
$LN3@FindVolume:

; 3125 : 
; 3126 : 	return highestIdDevice;

  0008d	48 8b 44 24 28	 mov	 rax, QWORD PTR highestIdDevice$[rsp]

; 3127 : }

  00092	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00096	c3		 ret	 0
FindVolumeWithHighestUniqueId ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	RemoveDriveLink
;	COMDAT pdata
pdata	SEGMENT
$pdata$RemoveDriveLink DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$RemoveDriveLink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RemoveDriveLink DD 021d19H
	DD	04b010bH
	DD	imagerel __GSHandlerCheck
	DD	0240H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RemoveDriveLink
_TEXT	SEGMENT
symLink$ = 32
ntStatus$ = 48
link$ = 64
__$ArrayPad$ = 576
nDosDriveNo$ = 608
RemoveDriveLink PROC					; COMDAT

; 2770 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2771 : 	WCHAR link[256];
; 2772 : 	UNICODE_STRING symLink;
; 2773 : 	NTSTATUS ntStatus;
; 2774 : 
; 2775 : 	GSTGetDosNameFromNumber (link, nDosDriveNo);

  0001d	8b 94 24 60 02
	00 00		 mov	 edx, DWORD PTR nDosDriveNo$[rsp]
  00024	48 8d 4c 24 40	 lea	 rcx, QWORD PTR link$[rsp]
  00029	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 2776 : 	RtlInitUnicodeString (&symLink, link);

  0002e	48 8d 54 24 40	 lea	 rdx, QWORD PTR link$[rsp]
  00033	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2777 : 
; 2778 : 	ntStatus = IoDeleteSymbolicLink (&symLink);

  0003e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink
  00049	89 44 24 30	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2779 : 	Dump ("IoDeleteSymbolicLink returned %X\n", ntStatus);

  0004d	8b 54 24 30	 mov	 edx, DWORD PTR ntStatus$[rsp]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@
  00058	e8 00 00 00 00	 call	 DbgPrint

; 2780 : 	return ntStatus;

  0005d	8b 44 24 30	 mov	 eax, DWORD PTR ntStatus$[rsp]

; 2781 : }

  00061	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00069	48 33 cc	 xor	 rcx, rsp
  0006c	e8 00 00 00 00	 call	 __security_check_cookie
  00071	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  00078	c3		 ret	 0
RemoveDriveLink ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	CreateDriveLink
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateDriveLink DD imagerel $LN3
	DD	imagerel $LN3+165
	DD	imagerel $unwind$CreateDriveLink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateDriveLink DD 021d19H
	DD	04d010bH
	DD	imagerel __GSHandlerCheck
	DD	0250H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CreateDriveLink
_TEXT	SEGMENT
symLink$ = 32
deviceName$ = 48
ntStatus$ = 64
link$ = 80
dev$ = 336
__$ArrayPad$ = 592
nDosDriveNo$ = 624
CreateDriveLink PROC					; COMDAT

; 2744 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 68 02
	00 00		 sub	 rsp, 616		; 00000268H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2745 : 	WCHAR dev[128], link[128];
; 2746 : 	UNICODE_STRING deviceName, symLink;
; 2747 : 	NTSTATUS ntStatus;
; 2748 : 
; 2749 : 	GSTGetNTNameFromNumber (dev, nDosDriveNo);

  0001d	8b 94 24 70 02
	00 00		 mov	 edx, DWORD PTR nDosDriveNo$[rsp]
  00024	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 2750 : 	GSTGetDosNameFromNumber (link, nDosDriveNo);

  00031	8b 94 24 70 02
	00 00		 mov	 edx, DWORD PTR nDosDriveNo$[rsp]
  00038	48 8d 4c 24 50	 lea	 rcx, QWORD PTR link$[rsp]
  0003d	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 2751 : 
; 2752 : 	RtlInitUnicodeString (&deviceName, dev);

  00042	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR dev$[rsp]
  0004a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR deviceName$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2753 : 	RtlInitUnicodeString (&symLink, link);

  00055	48 8d 54 24 50	 lea	 rdx, QWORD PTR link$[rsp]
  0005a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2754 : 
; 2755 : 	ntStatus = IoCreateSymbolicLink (&symLink, &deviceName);

  00065	48 8d 54 24 30	 lea	 rdx, QWORD PTR deviceName$[rsp]
  0006a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink
  00075	89 44 24 40	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2756 : 	Dump ("IoCreateSymbolicLink returned %X\n", ntStatus);

  00079	8b 54 24 40	 mov	 edx, DWORD PTR ntStatus$[rsp]
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@
  00084	e8 00 00 00 00	 call	 DbgPrint

; 2757 : 	return ntStatus;

  00089	8b 44 24 40	 mov	 eax, DWORD PTR ntStatus$[rsp]

; 2758 : }

  0008d	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00095	48 33 cc	 xor	 rcx, rsp
  00098	e8 00 00 00 00	 call	 __security_check_cookie
  0009d	48 81 c4 68 02
	00 00		 add	 rsp, 616		; 00000268H
  000a4	c3		 ret	 0
CreateDriveLink ENDP
_TEXT	ENDS
PUBLIC	GSTFsctlCall
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTFsctlCall DD imagerel $LN5
	DD	imagerel $LN5+302
	DD	imagerel $unwind$GSTFsctlCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTFsctlCall DD 021a01H
	DD	015011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTFsctlCall
_TEXT	SEGMENT
deviceObject$ = 80
irp$ = 88
stack$ = 96
ntStatus$ = 104
ioStatusBlock$ = 112
event$ = 128
fileObject$ = 176
IoControlCode$ = 184
InputBuffer$ = 192
InputBufferSize$ = 200
OutputBuffer$ = 208
OutputBufferSize$ = 216
GSTFsctlCall PROC					; COMDAT

; 2697 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2698 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2699 : 	NTSTATUS ntStatus;
; 2700 : 	PIRP irp;
; 2701 : 	KEVENT event;
; 2702 : 	PIO_STACK_LOCATION stack;
; 2703 : 	PDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject (fileObject);

  0001a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR fileObject$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetRelatedDeviceObject
  00028	48 89 44 24 50	 mov	 QWORD PTR deviceObject$[rsp], rax

; 2704 : 
; 2705 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  0002d	45 33 c0	 xor	 r8d, r8d
  00030	33 d2		 xor	 edx, edx
  00032	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2706 : 
; 2707 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2708 : 					     deviceObject,
; 2709 : 					     InputBuffer, InputBufferSize,
; 2710 : 					     OutputBuffer, OutputBufferSize,
; 2711 : 					     FALSE,
; 2712 : 					     &event,
; 2713 : 					     &ioStatusBlock);

  00040	4c 8d 5c 24 70	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  00045	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  0004a	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR event$[rsp]
  00052	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00057	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  0005c	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR OutputBufferSize$[rsp]
  00063	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00067	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR OutputBuffer$[rsp]
  0006f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00074	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR InputBufferSize$[rsp]
  0007c	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR InputBuffer$[rsp]
  00084	48 8b 54 24 50	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  00089	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR IoControlCode$[rsp]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  00096	48 89 44 24 58	 mov	 QWORD PTR irp$[rsp], rax

; 2714 : 
; 2715 : 	if (irp == NULL)

  0009b	48 83 7c 24 58
	00		 cmp	 QWORD PTR irp$[rsp], 0
  000a1	75 07		 jne	 SHORT $LN2@GSTFsctlCa

; 2716 : 		return STATUS_INSUFFICIENT_RESOURCES;

  000a3	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  000a8	eb 7c		 jmp	 SHORT $LN3@GSTFsctlCa
$LN2@GSTFsctlCa:

; 2717 : 
; 2718 : 	stack = IoGetNextIrpStackLocation(irp);

  000aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR irp$[rsp]
  000af	e8 00 00 00 00	 call	 IoGetNextIrpStackLocation
  000b4	48 89 44 24 60	 mov	 QWORD PTR stack$[rsp], rax

; 2719 : 	
; 2720 : 	stack->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;

  000b9	48 8b 44 24 60	 mov	 rax, QWORD PTR stack$[rsp]
  000be	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 2721 : 	stack->MinorFunction = IRP_MN_USER_FS_REQUEST;

  000c1	48 8b 44 24 60	 mov	 rax, QWORD PTR stack$[rsp]
  000c6	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0

; 2722 : 	stack->FileObject = fileObject;

  000ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR stack$[rsp]
  000cf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR fileObject$[rsp]
  000d7	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 2723 : 
; 2724 : 	ntStatus = IoCallDriver (deviceObject, irp);

  000db	48 8b 54 24 58	 mov	 rdx, QWORD PTR irp$[rsp]
  000e0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  000eb	89 44 24 68	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2725 : 	if (ntStatus == STATUS_PENDING)

  000ef	81 7c 24 68 03
	01 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 259 ; 00000103H
  000f7	75 29		 jne	 SHORT $LN1@GSTFsctlCa

; 2726 : 	{
; 2727 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  000f9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00102	45 33 c9	 xor	 r9d, r9d
  00105	45 33 c0	 xor	 r8d, r8d
  00108	33 d2		 xor	 edx, edx
  0010a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2728 : 		ntStatus = ioStatusBlock.Status;

  00118	44 8b 5c 24 70	 mov	 r11d, DWORD PTR ioStatusBlock$[rsp]
  0011d	44 89 5c 24 68	 mov	 DWORD PTR ntStatus$[rsp], r11d
$LN1@GSTFsctlCa:

; 2729 : 	}
; 2730 : 
; 2731 : 	return ntStatus;

  00122	8b 44 24 68	 mov	 eax, DWORD PTR ntStatus$[rsp]
$LN3@GSTFsctlCa:

; 2732 : }

  00126	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0012d	c3		 ret	 0
GSTFsctlCall ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTReadWriteDevice DD imagerel GSTReadWriteDevice
	DD	imagerel GSTReadWriteDevice+337
	DD	imagerel $unwind$GSTReadWriteDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTReadWriteDevice DD 021a01H
	DD	011011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTReadWriteDevice
_TEXT	SEGMENT
completionEvent$ = 64
irp$ = 88
ioStatusBlock$ = 96
status$ = 112
tv71 = 116
tv83 = 120
write$ = 144
deviceObject$ = 152
buffer$ = 160
offset$ = 168
length$ = 176
GSTReadWriteDevice PROC					; COMDAT

; 2633 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2634 : 	NTSTATUS status;
; 2635 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2636 : 	PIRP irp;
; 2637 : 	KEVENT completionEvent;
; 2638 : 
; 2639 : 	ASSERT (KeGetCurrentIrql() <= APC_LEVEL);

  0001a	e8 00 00 00 00	 call	 KeGetCurrentIrql
  0001f	0f b6 c0	 movzx	 eax, al
  00022	83 f8 01	 cmp	 eax, 1
  00025	7e 27		 jle	 SHORT $LN6@GSTReadWri
  00027	45 33 c9	 xor	 r9d, r9d
  0002a	41 b8 4f 0a 00
	00		 mov	 r8d, 2639		; 00000a4fH
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00044	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0004c	eb 08		 jmp	 SHORT $LN7@GSTReadWri
$LN6@GSTReadWri:
  0004e	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN7@GSTReadWri:

; 2640 : 
; 2641 : 	KeInitializeEvent (&completionEvent, NotificationEvent, FALSE);

  00056	45 33 c0	 xor	 r8d, r8d
  00059	33 d2		 xor	 edx, edx
  0005b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR completionEvent$[rsp]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2642 : 	irp = IoBuildSynchronousFsdRequest (write ? IRP_MJ_WRITE : IRP_MJ_READ, deviceObject, buffer, length, &offset, &completionEvent, &ioStatusBlock);

  00066	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR write$[rsp], 0
  0006e	74 0a		 je	 SHORT $LN8@GSTReadWri
  00070	c7 44 24 78 04
	00 00 00	 mov	 DWORD PTR tv83[rsp], 4
  00078	eb 08		 jmp	 SHORT $LN9@GSTReadWri
$LN8@GSTReadWri:
  0007a	c7 44 24 78 03
	00 00 00	 mov	 DWORD PTR tv83[rsp], 3
$LN9@GSTReadWri:
  00082	48 8d 44 24 60	 lea	 rax, QWORD PTR ioStatusBlock$[rsp]
  00087	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0008c	48 8d 44 24 40	 lea	 rax, QWORD PTR completionEvent$[rsp]
  00091	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00096	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR offset$[rsp]
  0009e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a3	44 8b 8c 24 b0
	00 00 00	 mov	 r9d, DWORD PTR length$[rsp]
  000ab	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR buffer$[rsp]
  000b3	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  000bb	8b 4c 24 78	 mov	 ecx, DWORD PTR tv83[rsp]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildSynchronousFsdRequest
  000c5	48 89 44 24 58	 mov	 QWORD PTR irp$[rsp], rax

; 2643 : 	if (!irp)

  000ca	48 83 7c 24 58
	00		 cmp	 QWORD PTR irp$[rsp], 0
  000d0	75 07		 jne	 SHORT $LN3@GSTReadWri

; 2644 : 		return STATUS_INSUFFICIENT_RESOURCES;

  000d2	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  000d7	eb 70		 jmp	 SHORT $LN4@GSTReadWri
$LN3@GSTReadWri:

; 2645 : 
; 2646 : 	ObReferenceObject (deviceObject);

  000d9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfReferenceObject

; 2647 : 	status = IoCallDriver (deviceObject, irp);

  000e7	48 8b 54 24 58	 mov	 rdx, QWORD PTR irp$[rsp]
  000ec	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  000fa	89 44 24 70	 mov	 DWORD PTR status$[rsp], eax

; 2648 : 
; 2649 : 	if (status == STATUS_PENDING)

  000fe	81 7c 24 70 03
	01 00 00	 cmp	 DWORD PTR status$[rsp], 259 ; 00000103H
  00106	75 2f		 jne	 SHORT $LN2@GSTReadWri

; 2650 : 	{
; 2651 : 		status = KeWaitForSingleObject (&completionEvent, Executive, KernelMode, FALSE, NULL);

  00108	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00111	45 33 c9	 xor	 r9d, r9d
  00114	45 33 c0	 xor	 r8d, r8d
  00117	33 d2		 xor	 edx, edx
  00119	48 8d 4c 24 40	 lea	 rcx, QWORD PTR completionEvent$[rsp]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00124	89 44 24 70	 mov	 DWORD PTR status$[rsp], eax

; 2652 : 		if (NT_SUCCESS (status))

  00128	83 7c 24 70 00	 cmp	 DWORD PTR status$[rsp], 0
  0012d	7c 08		 jl	 SHORT $LN1@GSTReadWri

; 2653 : 			status = ioStatusBlock.Status;

  0012f	8b 44 24 60	 mov	 eax, DWORD PTR ioStatusBlock$[rsp]
  00133	89 44 24 70	 mov	 DWORD PTR status$[rsp], eax
$LN1@GSTReadWri:
$LN2@GSTReadWri:

; 2654 : 	}
; 2655 : 
; 2656 : 	ObDereferenceObject (deviceObject);

  00137	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2657 : 	return status;

  00145	8b 44 24 70	 mov	 eax, DWORD PTR status$[rsp]
$LN4@GSTReadWri:

; 2658 : }

  00149	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00150	c3		 ret	 0
GSTReadWriteDevice ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	GSTOpenFsVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTOpenFsVolume DD imagerel $LN5
	DD	imagerel $LN5+407
	DD	imagerel $unwind$GSTOpenFsVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTOpenFsVolume DD 022819H
	DD	05d0116H
	DD	imagerel __GSHandlerCheck
	DD	02d8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTOpenFsVolume
_TEXT	SEGMENT
objectAttributes$ = 96
volumeName$ = 160
ntStatus$ = 688
fullFileName$ = 696
ioStatus$ = 712
__$ArrayPad$ = 728
Extension$ = 752
volumeHandle$ = 760
fileObject$ = 768
GSTOpenFsVolume PROC					; COMDAT

; 2562 : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 02
	00 00		 sub	 rsp, 744		; 000002e8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2563 : 	NTSTATUS ntStatus;
; 2564 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2565 : 	UNICODE_STRING fullFileName;
; 2566 : 	IO_STATUS_BLOCK ioStatus;
; 2567 : 	WCHAR volumeName[GST_MAX_PATH];
; 2568 : 
; 2569 : 	GSTGetNTNameFromNumber (volumeName, Extension->nDosDriveNo);

  00028	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00030	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00033	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR volumeName$[rsp]
  0003b	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 2570 : 	RtlInitUnicodeString (&fullFileName, volumeName);

  00040	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR volumeName$[rsp]
  00048	48 8d 8c 24 b8
	02 00 00	 lea	 rcx, QWORD PTR fullFileName$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2571 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  00056	c7 44 24 60 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  0005e	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+8], 0
  00067	c7 44 24 78 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  0006f	48 8d 84 24 b8
	02 00 00	 lea	 rax, QWORD PTR fullFileName$[rsp]
  00077	48 89 44 24 70	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  0007c	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR objectAttributes$[rsp+32], 0
  00088	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR objectAttributes$[rsp+40], 0

; 2572 : 
; 2573 : 	ntStatus = ZwCreateFile (volumeHandle,
; 2574 : 		SYNCHRONIZE | GENERIC_READ,
; 2575 : 		&objectAttributes,
; 2576 : 		&ioStatus,
; 2577 : 		NULL,
; 2578 : 		FILE_ATTRIBUTE_NORMAL,
; 2579 : 		FILE_SHARE_READ | FILE_SHARE_WRITE,
; 2580 : 		FILE_OPEN,
; 2581 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2582 : 		NULL,
; 2583 : 		0);

  00094	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  0009c	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  000a5	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  000ad	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  000b5	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  000bd	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  000c5	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000ce	4c 8d 8c 24 c8
	02 00 00	 lea	 r9, QWORD PTR ioStatus$[rsp]
  000d6	4c 8d 44 24 60	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  000db	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  000e0	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  000ee	89 84 24 b0 02
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 2584 : 
; 2585 : 	Dump ("Volume %ls open NTSTATUS 0x%08x\n", volumeName, ntStatus);

  000f5	44 8b 84 24 b0
	02 00 00	 mov	 r8d, DWORD PTR ntStatus$[rsp]
  000fd	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR volumeName$[rsp]
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@
  0010c	e8 00 00 00 00	 call	 DbgPrint

; 2586 : 
; 2587 : 	if (!NT_SUCCESS (ntStatus))

  00111	83 bc 24 b0 02
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00119	7d 09		 jge	 SHORT $LN2@GSTOpenFsV

; 2588 : 		return ntStatus;

  0011b	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
  00122	eb 5b		 jmp	 SHORT $LN3@GSTOpenFsV
$LN2@GSTOpenFsV:

; 2589 : 
; 2590 : 	ntStatus = ObReferenceObjectByHandle (*volumeHandle,
; 2591 : 		FILE_READ_DATA,
; 2592 : 		NULL,
; 2593 : 		KernelMode,
; 2594 : 		fileObject,
; 2595 : 		NULL);

  00124	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0012d	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR fileObject$[rsp]
  00135	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013a	45 33 c9	 xor	 r9d, r9d
  0013d	45 33 c0	 xor	 r8d, r8d
  00140	ba 01 00 00 00	 mov	 edx, 1
  00145	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  0014d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  00156	89 84 24 b0 02
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 2596 : 
; 2597 : 	if (!NT_SUCCESS (ntStatus))

  0015d	83 bc 24 b0 02
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00165	7d 11		 jge	 SHORT $LN1@GSTOpenFsV

; 2598 : 		ZwClose (*volumeHandle);

  00167	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  0016f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@GSTOpenFsV:

; 2599 : 
; 2600 : 	return ntStatus;

  00178	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
$LN3@GSTOpenFsV:

; 2601 : }

  0017f	48 8b 8c 24 d8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00187	48 33 cc	 xor	 rcx, rsp
  0018a	e8 00 00 00 00	 call	 __security_check_cookie
  0018f	48 81 c4 e8 02
	00 00		 add	 rsp, 744		; 000002e8H
  00196	c3		 ret	 0
GSTOpenFsVolume ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SendDeviceIoControlRequest DD imagerel $LN7
	DD	imagerel $LN7+534
	DD	imagerel $unwind$SendDeviceIoControlRequest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SendDeviceIoControlRequest DD 021a01H
	DD	01f011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SendDeviceIoControlRequest
_TEXT	SEGMENT
irp$ = 80
ioStatusBlock$ = 88
event$ = 104
status$ = 128
args$31658 = 144
workItem$31659 = 224
deviceObject$ = 256
ioControlCode$ = 264
inputBuffer$ = 272
inputBufferSize$ = 280
outputBuffer$ = 288
outputBufferSize$ = 296
SendDeviceIoControlRequest PROC				; COMDAT

; 2438 : {

$LN7:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 2439 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2440 : 	NTSTATUS status;
; 2441 : 	PIRP irp;
; 2442 : 	KEVENT event;
; 2443 : 
; 2444 : 	if (KeGetCurrentIrql() > APC_LEVEL)

  0001a	e8 00 00 00 00	 call	 KeGetCurrentIrql
  0001f	0f b6 c0	 movzx	 eax, al
  00022	83 f8 01	 cmp	 eax, 1
  00025	0f 8e f6 00 00
	00		 jle	 $LN4@SendDevice

; 2445 : 	{
; 2446 : 		SendDeviceIoControlRequestWorkItemArgs args;
; 2447 : 
; 2448 : 		PIO_WORKITEM workItem = IoAllocateWorkItem (RootDeviceObject);

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAllocateWorkItem
  00038	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR workItem$31659[rsp], rax

; 2449 : 		if (!workItem)

  00040	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR workItem$31659[rsp], 0
  00049	75 0a		 jne	 SHORT $LN3@SendDevice

; 2450 : 			return STATUS_INSUFFICIENT_RESOURCES;

  0004b	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00050	e9 b9 01 00 00	 jmp	 $LN5@SendDevice
$LN3@SendDevice:

; 2451 : 
; 2452 : 		args.deviceObject = deviceObject;

  00055	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR deviceObject$[rsp]
  0005d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR args$31658[rsp], rax

; 2453 : 		args.ioControlCode = ioControlCode;

  00065	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR ioControlCode$[rsp]
  0006c	89 84 24 98 00
	00 00		 mov	 DWORD PTR args$31658[rsp+8], eax

; 2454 : 		args.inputBuffer = inputBuffer;

  00073	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR inputBuffer$[rsp]
  0007b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR args$31658[rsp+16], rax

; 2455 : 		args.inputBufferSize = inputBufferSize;

  00083	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR inputBufferSize$[rsp]
  0008a	89 84 24 a8 00
	00 00		 mov	 DWORD PTR args$31658[rsp+24], eax

; 2456 : 		args.outputBuffer = outputBuffer;

  00091	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR outputBuffer$[rsp]
  00099	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR args$31658[rsp+32], rax

; 2457 : 		args.outputBufferSize = outputBufferSize;

  000a1	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR outputBufferSize$[rsp]
  000a8	89 84 24 b8 00
	00 00		 mov	 DWORD PTR args$31658[rsp+40], eax

; 2458 : 
; 2459 : 		KeInitializeEvent (&args.WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  000af	45 33 c0	 xor	 r8d, r8d
  000b2	ba 01 00 00 00	 mov	 edx, 1
  000b7	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR args$31658[rsp+48]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2460 : 		IoQueueWorkItem (workItem, SendDeviceIoControlRequestWorkItemRoutine, DelayedWorkQueue, &args); 

  000c5	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR args$31658[rsp]
  000cd	41 b8 01 00 00
	00		 mov	 r8d, 1
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:SendDeviceIoControlRequestWorkItemRoutine
  000da	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR workItem$31659[rsp]
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoQueueWorkItem

; 2461 : 
; 2462 : 		KeWaitForSingleObject (&args.WorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);

  000e8	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000f1	45 33 c9	 xor	 r9d, r9d
  000f4	45 33 c0	 xor	 r8d, r8d
  000f7	33 d2		 xor	 edx, edx
  000f9	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR args$31658[rsp+48]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2463 : 		IoFreeWorkItem (workItem);

  00107	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR workItem$31659[rsp]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoFreeWorkItem

; 2464 :  
; 2465 : 		return args.Status;

  00115	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR args$31658[rsp+44]
  0011c	e9 ed 00 00 00	 jmp	 $LN5@SendDevice
$LN4@SendDevice:

; 2466 : 	}
; 2467 : 
; 2468 : 	KeInitializeEvent (&event, NotificationEvent, FALSE);

  00121	45 33 c0	 xor	 r8d, r8d
  00124	33 d2		 xor	 edx, edx
  00126	48 8d 4c 24 68	 lea	 rcx, QWORD PTR event$[rsp]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2469 : 
; 2470 : 	irp = IoBuildDeviceIoControlRequest (ioControlCode, deviceObject, inputBuffer, inputBufferSize,
; 2471 : 		outputBuffer, outputBufferSize, FALSE, &event, &ioStatusBlock);

  00131	4c 8d 5c 24 58	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  00136	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  0013b	48 8d 44 24 68	 lea	 rax, QWORD PTR event$[rsp]
  00140	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00145	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  0014a	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR outputBufferSize$[rsp]
  00151	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00155	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR outputBuffer$[rsp]
  0015d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00162	44 8b 8c 24 18
	01 00 00	 mov	 r9d, DWORD PTR inputBufferSize$[rsp]
  0016a	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR inputBuffer$[rsp]
  00172	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  0017a	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR ioControlCode$[rsp]
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  00187	48 89 44 24 50	 mov	 QWORD PTR irp$[rsp], rax

; 2472 : 
; 2473 : 	if (!irp)

  0018c	48 83 7c 24 50
	00		 cmp	 QWORD PTR irp$[rsp], 0
  00192	75 07		 jne	 SHORT $LN2@SendDevice

; 2474 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00194	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00199	eb 73		 jmp	 SHORT $LN5@SendDevice
$LN2@SendDevice:

; 2475 : 
; 2476 : 	ObReferenceObject (deviceObject);

  0019b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfReferenceObject

; 2477 : 
; 2478 : 	status = IoCallDriver (deviceObject, irp);

  001a9	48 8b 54 24 50	 mov	 rdx, QWORD PTR irp$[rsp]
  001ae	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  001bc	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 2479 : 	if (status == STATUS_PENDING)

  001c3	81 bc 24 80 00
	00 00 03 01 00
	00		 cmp	 DWORD PTR status$[rsp], 259 ; 00000103H
  001ce	75 29		 jne	 SHORT $LN1@SendDevice

; 2480 : 	{
; 2481 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  001d0	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001d9	45 33 c9	 xor	 r9d, r9d
  001dc	45 33 c0	 xor	 r8d, r8d
  001df	33 d2		 xor	 edx, edx
  001e1	48 8d 4c 24 68	 lea	 rcx, QWORD PTR event$[rsp]
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2482 : 		status = ioStatusBlock.Status;

  001ec	44 8b 5c 24 58	 mov	 r11d, DWORD PTR ioStatusBlock$[rsp]
  001f1	44 89 9c 24 80
	00 00 00	 mov	 DWORD PTR status$[rsp], r11d
$LN1@SendDevice:

; 2483 : 	}
; 2484 : 
; 2485 : 	ObDereferenceObject (deviceObject);

  001f9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2486 : 	return status;

  00207	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
$LN5@SendDevice:

; 2487 : }

  0020e	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00215	c3		 ret	 0
SendDeviceIoControlRequest ENDP
_TEXT	ENDS
PUBLIC	GSTDeviceIoControl
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTDeviceIoControl DD imagerel $LN6
	DD	imagerel $LN6+353
	DD	imagerel $unwind$GSTDeviceIoControl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTDeviceIoControl DD 021a01H
	DD	017011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTDeviceIoControl
_TEXT	SEGMENT
deviceObject$ = 80
fileObject$ = 88
name$ = 96
irp$ = 112
ntStatus$ = 120
ioStatusBlock$ = 128
event$ = 144
deviceName$ = 192
IoControlCode$ = 200
InputBuffer$ = 208
InputBufferSize$ = 216
OutputBuffer$ = 224
OutputBufferSize$ = 232
GSTDeviceIoControl PROC					; COMDAT

; 2353 : {

$LN6:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2354 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2355 : 	NTSTATUS ntStatus;
; 2356 : 	PIRP irp;
; 2357 : 	PFILE_OBJECT fileObject;
; 2358 : 	PDEVICE_OBJECT deviceObject;
; 2359 : 	KEVENT event;
; 2360 : 	UNICODE_STRING name;
; 2361 : 
; 2362 : 	RtlInitUnicodeString(&name, deviceName);

  0001a	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR deviceName$[rsp]
  00022	48 8d 4c 24 60	 lea	 rcx, QWORD PTR name$[rsp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2363 : 	ntStatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  0002d	4c 8d 4c 24 50	 lea	 r9, QWORD PTR deviceObject$[rsp]
  00032	4c 8d 44 24 58	 lea	 r8, QWORD PTR fileObject$[rsp]
  00037	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0003c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR name$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer
  00047	89 44 24 78	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2364 : 
; 2365 : 	if (!NT_SUCCESS (ntStatus))

  0004b	83 7c 24 78 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00050	7d 09		 jge	 SHORT $LN3@GSTDeviceI

; 2366 : 		return ntStatus;

  00052	8b 44 24 78	 mov	 eax, DWORD PTR ntStatus$[rsp]
  00056	e9 fe 00 00 00	 jmp	 $LN4@GSTDeviceI
$LN3@GSTDeviceI:

; 2367 : 
; 2368 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  0005b	45 33 c0	 xor	 r8d, r8d
  0005e	33 d2		 xor	 edx, edx
  00060	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2369 : 
; 2370 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2371 : 					     deviceObject,
; 2372 : 					     InputBuffer, InputBufferSize,
; 2373 : 					     OutputBuffer, OutputBufferSize,
; 2374 : 					     FALSE,
; 2375 : 					     &event,
; 2376 : 					     &ioStatusBlock);

  0006e	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  00076	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  0007b	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR event$[rsp]
  00083	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00088	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  0008d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR OutputBufferSize$[rsp]
  00094	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00098	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR OutputBuffer$[rsp]
  000a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a5	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR InputBufferSize$[rsp]
  000ad	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR InputBuffer$[rsp]
  000b5	48 8b 54 24 50	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  000ba	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR IoControlCode$[rsp]
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  000c7	48 89 44 24 70	 mov	 QWORD PTR irp$[rsp], rax

; 2377 : 
; 2378 : 	if (irp == NULL)

  000cc	48 83 7c 24 70
	00		 cmp	 QWORD PTR irp$[rsp], 0
  000d2	75 16		 jne	 SHORT $LN2@GSTDeviceI

; 2379 : 	{
; 2380 : 		Dump ("IRP allocation failed\n");

  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@
  000db	e8 00 00 00 00	 call	 DbgPrint

; 2381 : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  000e0	c7 44 24 78 9a
	00 00 c0	 mov	 DWORD PTR ntStatus$[rsp], -1073741670 ; ffffffffc000009aH

; 2382 : 		goto ret;

  000e8	eb 60		 jmp	 SHORT $ret$31620
$LN2@GSTDeviceI:

; 2383 : 	}
; 2384 : 
; 2385 : 	IoGetNextIrpStackLocation (irp)->FileObject = fileObject;

  000ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR irp$[rsp]
  000ef	e8 00 00 00 00	 call	 IoGetNextIrpStackLocation
  000f4	4c 8b d8	 mov	 r11, rax
  000f7	48 8b 44 24 58	 mov	 rax, QWORD PTR fileObject$[rsp]
  000fc	49 89 43 30	 mov	 QWORD PTR [r11+48], rax

; 2386 : 
; 2387 : 	ntStatus = IoCallDriver (deviceObject, irp);

  00100	48 8b 54 24 70	 mov	 rdx, QWORD PTR irp$[rsp]
  00105	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  00110	89 44 24 78	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2388 : 	if (ntStatus == STATUS_PENDING)

  00114	81 7c 24 78 03
	01 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 259 ; 00000103H
  0011c	75 2c		 jne	 SHORT $LN1@GSTDeviceI

; 2389 : 	{
; 2390 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  0011e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00127	45 33 c9	 xor	 r9d, r9d
  0012a	45 33 c0	 xor	 r8d, r8d
  0012d	33 d2		 xor	 edx, edx
  0012f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2391 : 		ntStatus = ioStatusBlock.Status;

  0013d	44 8b 9c 24 80
	00 00 00	 mov	 r11d, DWORD PTR ioStatusBlock$[rsp]
  00145	44 89 5c 24 78	 mov	 DWORD PTR ntStatus$[rsp], r11d
$LN1@GSTDeviceI:
$ret$31620:

; 2392 : 	}
; 2393 : 
; 2394 : ret:
; 2395 : 	ObDereferenceObject (fileObject);

  0014a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fileObject$[rsp]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2396 : 	return ntStatus;

  00155	8b 44 24 78	 mov	 eax, DWORD PTR ntStatus$[rsp]
$LN4@GSTDeviceI:

; 2397 : }

  00159	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00160	c3		 ret	 0
GSTDeviceIoControl ENDP
_TEXT	ENDS
PUBLIC	OnShutdownPending
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnShutdownPending DD imagerel $LN8
	DD	imagerel $LN8+153
	DD	imagerel $unwind$OnShutdownPending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnShutdownPending DD 020601H
	DD	070027206H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT OnShutdownPending
_TEXT	SEGMENT
unmount$ = 48
OnShutdownPending PROC					; COMDAT

; 2327 : {

$LN8:
  00000	40 57		 push	 rdi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2328 : 	UNMOUNT_STRUCT unmount;
; 2329 : 	memset (&unmount, 0, sizeof (unmount));

  00006	48 8d 7c 24 30	 lea	 rdi, QWORD PTR unmount$[rsp]
  0000b	33 c0		 xor	 eax, eax
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	f3 aa		 rep stosb

; 2330 : 	unmount.ignoreOpenFiles = TRUE;

  00014	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR unmount$[rsp+4], 1
$LN5@OnShutdown:

; 2331 : 
; 2332 : 	while (SendDeviceIoControlRequest (RootDeviceObject, GST_IOCTL_DISMOUNT_ALL_VOLUMES, &unmount, sizeof (unmount), &unmount, sizeof (unmount)) == STATUS_INSUFFICIENT_RESOURCES || unmount.HiddenVolumeProtectionTriggered)

  0001c	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR [rsp+40], 16
  00024	48 8d 44 24 30	 lea	 rax, QWORD PTR unmount$[rsp]
  00029	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002e	41 b9 10 00 00
	00		 mov	 r9d, 16
  00034	4c 8d 44 24 30	 lea	 r8, QWORD PTR unmount$[rsp]
  00039	ba 14 20 22 00	 mov	 edx, 2236436		; 00222014H
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00045	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0004a	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  0004f	74 07		 je	 SHORT $LN3@OnShutdown
  00051	83 7c 24 38 00	 cmp	 DWORD PTR unmount$[rsp+8], 0
  00056	74 0a		 je	 SHORT $LN4@OnShutdown
$LN3@OnShutdown:

; 2333 : 		unmount.HiddenVolumeProtectionTriggered = FALSE;

  00058	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR unmount$[rsp+8], 0
  00060	eb ba		 jmp	 SHORT $LN5@OnShutdown
$LN4@OnShutdown:
$LN2@OnShutdown:

; 2334 : 
; 2335 : 	while (SendDeviceIoControlRequest (RootDeviceObject, GST_IOCTL_WIPE_PASSWORD_CACHE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00062	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0006a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00073	45 33 c9	 xor	 r9d, r9d
  00076	45 33 c0	 xor	 r8d, r8d
  00079	ba 30 20 22 00	 mov	 edx, 2236464		; 00222030H
  0007e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00085	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0008a	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  0008f	75 02		 jne	 SHORT $LN1@OnShutdown
  00091	eb cf		 jmp	 SHORT $LN2@OnShutdown
$LN1@OnShutdown:

; 2336 : }

  00093	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
OnShutdownPending ENDP
_TEXT	ENDS
PUBLIC	GSTDeleteDeviceObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTDeleteDeviceObject DD imagerel $LN14
	DD	imagerel $LN14+400
	DD	imagerel $unwind$GSTDeleteDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTDeleteDeviceObject DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTDeleteDeviceObject
_TEXT	SEGMENT
Win32NameString$ = 48
ntStatus$ = 64
name$31561 = 72
PsDereferenceImpersonationTokenD$31560 = 88
DeviceObject$ = 112
Extension$ = 120
GSTDeleteDeviceObject PROC				; COMDAT

; 2234 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2235 : 	UNICODE_STRING Win32NameString;
; 2236 : 	NTSTATUS ntStatus;
; 2237 : 
; 2238 : 	Dump ("GSTDeleteDeviceObject BEGIN\n");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@OKCPOKLC@GSTDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@
  00015	e8 00 00 00 00	 call	 DbgPrint

; 2239 : 
; 2240 : 	if (Extension->bRootDevice)

  0001a	4c 8b 5c 24 78	 mov	 r11, QWORD PTR Extension$[rsp]
  0001f	41 83 3b 00	 cmp	 DWORD PTR [r11], 0
  00023	74 48		 je	 SHORT $LN11@GSTDeleteD

; 2241 : 	{
; 2242 : 		RtlInitUnicodeString (&Win32NameString, (LPWSTR) DOS_ROOT_PREFIX);

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  0002c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2243 : 		ntStatus = IoDeleteSymbolicLink (&Win32NameString);

  00037	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink
  00042	89 44 24 40	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2244 : 		if (!NT_SUCCESS (ntStatus))

  00046	83 7c 24 40 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0004b	7d 10		 jge	 SHORT $LN10@GSTDeleteD

; 2245 : 			Dump ("IoDeleteSymbolicLink failed ntStatus = 0x%08x\n", ntStatus);

  0004d	8b 54 24 40	 mov	 edx, DWORD PTR ntStatus$[rsp]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@
  00058	e8 00 00 00 00	 call	 DbgPrint
$LN10@GSTDeleteD:

; 2246 : 
; 2247 : 		RootDeviceObject = NULL;

  0005d	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR RootDeviceObject, 0

; 2248 : 	}
; 2249 : 	else

  00068	e9 07 01 00 00	 jmp	 $LN9@GSTDeleteD
$LN11@GSTDeleteD:

; 2250 : 	{
; 2251 : 		if (Extension->peThread != NULL)

  0006d	48 8b 44 24 78	 mov	 rax, QWORD PTR Extension$[rsp]
  00072	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00077	74 0f		 je	 SHORT $LN8@GSTDeleteD

; 2252 : 			GSTStopVolumeThread (DeviceObject, Extension);

  00079	48 8b 54 24 78	 mov	 rdx, QWORD PTR Extension$[rsp]
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00083	e8 00 00 00 00	 call	 GSTStopVolumeThread
$LN8@GSTDeleteD:

; 2253 : 
; 2254 : 		if (Extension->UserSid)

  00088	48 8b 44 24 78	 mov	 rax, QWORD PTR Extension$[rsp]
  0008d	48 83 b8 e0 05
	00 00 00	 cmp	 QWORD PTR [rax+1504], 0
  00095	74 17		 je	 SHORT $LN7@GSTDeleteD

; 2255 : 			GSTfree (Extension->UserSid);

  00097	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0009c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Extension$[rsp]
  000a1	48 8b 89 e0 05
	00 00		 mov	 rcx, QWORD PTR [rcx+1504]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN7@GSTDeleteD:

; 2256 : 
; 2257 : 		if (Extension->SecurityClientContextValid)

  000ae	48 8b 44 24 78	 mov	 rax, QWORD PTR Extension$[rsp]
  000b3	83 b8 e8 05 00
	00 00		 cmp	 DWORD PTR [rax+1512], 0
  000ba	0f 84 9c 00 00
	00		 je	 $LN6@GSTDeleteD

; 2258 : 		{
; 2259 : 			if (OsMajorVersion == 5 && OsMinorVersion == 0)

  000c0	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR OsMajorVersion, 5
  000c7	75 1d		 jne	 SHORT $LN5@GSTDeleteD
  000c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMinorVersion, 0
  000d0	75 14		 jne	 SHORT $LN5@GSTDeleteD

; 2260 : 			{
; 2261 : 				ObDereferenceObject (Extension->SecurityClientContext.ClientToken);

  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Extension$[rsp]
  000d7	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2262 : 			}
; 2263 : 			else

  000e4	eb 76		 jmp	 SHORT $LN4@GSTDeleteD
$LN5@GSTDeleteD:

; 2264 : 			{
; 2265 : 				// Windows 2000 does not support PsDereferenceImpersonationToken() used by SeDeleteClientSecurity().
; 2266 : 				// TODO: Use only SeDeleteClientSecurity() once support for Windows 2000 is dropped.
; 2267 : 
; 2268 : 				VOID (*PsDereferenceImpersonationTokenD) (PACCESS_TOKEN ImpersonationToken);
; 2269 : 				UNICODE_STRING name;
; 2270 : 				RtlInitUnicodeString (&name, L"PsDereferenceImpersonationToken");

  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
  000ed	48 8d 4c 24 48	 lea	 rcx, QWORD PTR name$31561[rsp]
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2271 : 
; 2272 : 				PsDereferenceImpersonationTokenD = MmGetSystemRoutineAddress (&name);

  000f8	48 8d 4c 24 48	 lea	 rcx, QWORD PTR name$31561[rsp]
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress
  00103	48 89 44 24 58	 mov	 QWORD PTR PsDereferenceImpersonationTokenD$31560[rsp], rax

; 2273 : 				if (!PsDereferenceImpersonationTokenD)

  00108	48 83 7c 24 58
	00		 cmp	 QWORD PTR PsDereferenceImpersonationTokenD$31560[rsp], 0
  0010e	75 23		 jne	 SHORT $LN3@GSTDeleteD

; 2274 : 					GST_BUG_CHECK (STATUS_NOT_IMPLEMENTED);

  00110	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00119	45 33 c9	 xor	 r9d, r9d
  0011c	49 c7 c0 02 00
	00 c0		 mov	 r8, -1073741822		; ffffffffc0000002H
  00123	ba e2 08 00 00	 mov	 edx, 2274		; 000008e2H
  00128	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN3@GSTDeleteD:

; 2275 : 				
; 2276 : #				define PsDereferencePrimaryToken
; 2277 : #				define PsDereferenceImpersonationToken PsDereferenceImpersonationTokenD
; 2278 : 
; 2279 : 				SeDeleteClientSecurity (&Extension->SecurityClientContext);

  00133	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Extension$[rsp]
  00138	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeTokenType
  00145	83 f8 01	 cmp	 eax, 1
  00148	75 02		 jne	 SHORT $LN2@GSTDeleteD
  0014a	eb 10		 jmp	 SHORT $LN1@GSTDeleteD
$LN2@GSTDeleteD:
  0014c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Extension$[rsp]
  00151	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  00158	ff 54 24 58	 call	 QWORD PTR PsDereferenceImpersonationTokenD$31560[rsp]
$LN1@GSTDeleteD:
$LN4@GSTDeleteD:
$LN6@GSTDeleteD:

; 2280 : 
; 2281 : #				undef PsDereferencePrimaryToken
; 2282 : #				undef PsDereferenceImpersonationToken
; 2283 : 			}
; 2284 : 		}
; 2285 : 
; 2286 : 		VirtualVolumeDeviceObjects[Extension->nDosDriveNo] = NULL;

  0015c	48 8b 44 24 78	 mov	 rax, QWORD PTR Extension$[rsp]
  00161	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00165	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:VirtualVolumeDeviceObjects
  0016c	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0
$LN9@GSTDeleteD:

; 2287 : 	}
; 2288 : 
; 2289 : 	IoDeleteDevice (DeviceObject);

  00174	48 8b 4c 24 70	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 2290 : 
; 2291 : 	Dump ("GSTDeleteDeviceObject END\n");

  0017f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@IPOBHCAN@GSTDeleteDeviceObject?5END?6?$AA@FNODOBFM@
  00186	e8 00 00 00 00	 call	 DbgPrint
$LN13@GSTDeleteD:

; 2292 : }

  0018b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018f	c3		 ret	 0
GSTDeleteDeviceObject ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	GSTCreateDeviceObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTCreateDeviceObject DD imagerel $LN10
	DD	imagerel $LN10+897
	DD	imagerel $unwind$GSTCreateDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCreateDeviceObject DD 032919H
	DD	0240117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTCreateDeviceObject
_TEXT	SEGMENT
devChars$ = 64
ntUnicodeString$ = 72
ntname$ = 96
Extension$ = 160
Win32NameString$ = 168
dosname$ = 192
ntStatus$ = 256
tv72 = 260
tv85 = 264
tv89 = 268
__$ArrayPad$ = 272
DriverObject$ = 304
ppDeviceObject$ = 312
mount$ = 320
GSTCreateDeviceObject PROC				; COMDAT

; 485  : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 486  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 487  : 	WCHAR dosname[32], ntname[32];
; 488  : 	PEXTENSION Extension;
; 489  : 	NTSTATUS ntStatus;
; 490  : 	ULONG devChars = 0;

  00029	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR devChars$[rsp], 0

; 491  : 
; 492  : 	Dump ("GSTCreateDeviceObject BEGIN\n");

  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@PHNPLCFI@GSTCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@
  00038	e8 00 00 00 00	 call	 DbgPrint

; 493  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

  0003d	e8 00 00 00 00	 call	 KeGetCurrentIrql
  00042	0f b6 c0	 movzx	 eax, al
  00045	85 c0		 test	 eax, eax
  00047	74 2a		 je	 SHORT $LN4@GSTCreateD
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	41 b8 ed 01 00
	00		 mov	 r8d, 493		; 000001edH
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00066	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv72[rsp], 0
  00071	eb 0b		 jmp	 SHORT $LN5@GSTCreateD
$LN4@GSTCreateD:
  00073	c7 84 24 04 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv72[rsp], 1
$LN5@GSTCreateD:

; 494  : 
; 495  : 	GSTGetDosNameFromNumber (dosname, mount->nDosDriveNo);

  0007e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00086	8b 90 64 02 00
	00		 mov	 edx, DWORD PTR [rax+612]
  0008c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dosname$[rsp]
  00094	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 496  : 	GSTGetNTNameFromNumber (ntname, mount->nDosDriveNo);

  00099	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR mount$[rsp]
  000a1	8b 92 64 02 00
	00		 mov	 edx, DWORD PTR [rdx+612]
  000a7	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ntname$[rsp]
  000ac	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 497  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  000b1	48 8d 54 24 60	 lea	 rdx, QWORD PTR ntname$[rsp]
  000b6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ntUnicodeString$[rsp]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 498  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  000c1	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR dosname$[rsp]
  000c9	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 499  : 
; 500  : 	devChars = FILE_DEVICE_SECURE_OPEN;

  000d7	c7 44 24 40 00
	01 00 00	 mov	 DWORD PTR devChars$[rsp], 256 ; 00000100H

; 501  : 	devChars |= mount->bMountReadOnly ? FILE_READ_ONLY_DEVICE : 0;

  000df	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  000e7	83 b8 6c 02 00
	00 00		 cmp	 DWORD PTR [rax+620], 0
  000ee	74 0d		 je	 SHORT $LN6@GSTCreateD
  000f0	c7 84 24 08 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv85[rsp], 2
  000fb	eb 0b		 jmp	 SHORT $LN7@GSTCreateD
$LN6@GSTCreateD:
  000fd	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv85[rsp], 0
$LN7@GSTCreateD:
  00108	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv85[rsp]
  0010f	8b 44 24 40	 mov	 eax, DWORD PTR devChars$[rsp]
  00113	0b c1		 or	 eax, ecx
  00115	89 44 24 40	 mov	 DWORD PTR devChars$[rsp], eax

; 502  : 	devChars |= mount->bMountRemovable ? FILE_REMOVABLE_MEDIA : 0;

  00119	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00121	83 b8 70 02 00
	00 00		 cmp	 DWORD PTR [rax+624], 0
  00128	74 0d		 je	 SHORT $LN8@GSTCreateD
  0012a	c7 84 24 0c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv89[rsp], 1
  00135	eb 0b		 jmp	 SHORT $LN9@GSTCreateD
$LN8@GSTCreateD:
  00137	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv89[rsp], 0
$LN9@GSTCreateD:
  00142	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv89[rsp]
  00149	8b 44 24 40	 mov	 eax, DWORD PTR devChars$[rsp]
  0014d	0b c1		 or	 eax, ecx
  0014f	89 44 24 40	 mov	 DWORD PTR devChars$[rsp], eax

; 503  : 
; 504  : 	Dump ("Creating device nt=%ls dos=%ls\n", ntname, dosname);

  00153	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR dosname$[rsp]
  0015b	48 8d 54 24 60	 lea	 rdx, QWORD PTR ntname$[rsp]
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@
  00167	e8 00 00 00 00	 call	 DbgPrint

; 505  : 
; 506  : 	ntStatus = IoCreateDevice (
; 507  : 					  DriverObject,			/* Our Driver Object */
; 508  : 					  sizeof (EXTENSION),	/* Size of state information */
; 509  : 					  &ntUnicodeString,		/* Device name "\Device\Name" */
; 510  : 					  FILE_DEVICE_DISK,		/* Device type */
; 511  : 					  devChars,				/* Device characteristics */
; 512  : 					  FALSE,				/* Exclusive device */
; 513  : 					  ppDeviceObject);		/* Returned ptr to Device Object */

  0016c	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR ppDeviceObject$[rsp]
  00174	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  00179	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0017e	8b 44 24 40	 mov	 eax, DWORD PTR devChars$[rsp]
  00182	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00186	41 b9 07 00 00
	00		 mov	 r9d, 7
  0018c	4c 8d 44 24 48	 lea	 r8, QWORD PTR ntUnicodeString$[rsp]
  00191	ba 38 06 00 00	 mov	 edx, 1592		; 00000638H
  00196	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice
  001a4	89 84 24 00 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 514  : 
; 515  : 	if (!NT_SUCCESS (ntStatus))

  001ab	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  001b3	7d 1f		 jge	 SHORT $LN1@GSTCreateD

; 516  : 	{
; 517  : 		Dump ("GSTCreateDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);

  001b5	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR ntStatus$[rsp]
  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@DMFEOBLG@GSTCreateDeviceObject?5NTSTATUS?5?$DN@FNODOBFM@
  001c3	e8 00 00 00 00	 call	 DbgPrint

; 518  : 		return ntStatus;/* Failed to create DeviceObject */

  001c8	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
  001cf	e9 94 01 00 00	 jmp	 $LN2@GSTCreateD
$LN1@GSTCreateD:

; 519  : 	}
; 520  : 	/* Initialize device object and extension. */
; 521  : 
; 522  : 	(*ppDeviceObject)->Flags |= DO_DIRECT_IO;

  001d4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  001dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001df	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  001e2	83 c9 10	 or	 ecx, 16
  001e5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  001ed	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f0	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 523  : 	(*ppDeviceObject)->StackSize += 6;		// Reduce occurrence of NO_MORE_IRP_STACK_LOCATIONS bug check caused by buggy drivers

  001f3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  001fb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001fe	0f be 48 4c	 movsx	 ecx, BYTE PTR [rax+76]
  00202	83 c1 06	 add	 ecx, 6
  00205	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  0020d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00210	88 48 4c	 mov	 BYTE PTR [rax+76], cl

; 524  : 
; 525  : 	/* Setup the device extension */
; 526  : 	Extension = (PEXTENSION) (*ppDeviceObject)->DeviceExtension;

  00213	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  0021b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0021e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00222	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR Extension$[rsp], rax

; 527  : 	memset (Extension, 0, sizeof (EXTENSION));

  0022a	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR Extension$[rsp]
  00232	33 c0		 xor	 eax, eax
  00234	b9 38 06 00 00	 mov	 ecx, 1592		; 00000638H
  00239	f3 aa		 rep stosb

; 528  : 
; 529  : 	Extension->IsVolumeDevice = TRUE;

  0023b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00243	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1

; 530  : 	Extension->nDosDriveNo = mount->nDosDriveNo;

  0024a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00252	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0025a	8b 80 64 02 00
	00		 mov	 eax, DWORD PTR [rax+612]
  00260	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 531  : 	Extension->bRemovable = mount->bMountRemovable;

  00263	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0026b	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00273	8b 80 70 02 00
	00		 mov	 eax, DWORD PTR [rax+624]
  00279	89 81 9c 03 00
	00		 mov	 DWORD PTR [rcx+924], eax

; 532  : 	Extension->PartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;

  0027f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00287	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0028f	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [rax+640]
  00295	89 81 a0 03 00
	00		 mov	 DWORD PTR [rcx+928], eax

; 533  : 	Extension->SystemFavorite = mount->SystemFavorite;

  0029b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002a3	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  002ab	8b 80 88 02 00
	00		 mov	 eax, DWORD PTR [rax+648]
  002b1	89 81 ac 03 00
	00		 mov	 DWORD PTR [rcx+940], eax

; 534  : 
; 535  : 	KeInitializeEvent (&Extension->keCreateEvent, SynchronizationEvent, FALSE);

  002b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002bf	48 83 c1 28	 add	 rcx, 40			; 00000028H
  002c3	45 33 c0	 xor	 r8d, r8d
  002c6	ba 01 00 00 00	 mov	 edx, 1
  002cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 536  : 	KeInitializeSemaphore (&Extension->RequestSemaphore, 0L, MAXLONG);

  002d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002d9	48 83 c1 58	 add	 rcx, 88			; 00000058H
  002dd	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  002e3	33 d2		 xor	 edx, edx
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeSemaphore

; 537  : 	KeInitializeSpinLock (&Extension->ListSpinLock);

  002eb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002f3	48 83 c1 40	 add	 rcx, 64			; 00000040H
  002f7	e8 00 00 00 00	 call	 KeInitializeSpinLock

; 538  : 	InitializeListHead (&Extension->ListEntry);

  002fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00304	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00308	e8 00 00 00 00	 call	 InitializeListHead

; 539  : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  0030d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00315	48 81 c1 80 01
	00 00		 add	 rcx, 384		; 00000180H
  0031c	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  00324	45 33 c9	 xor	 r9d, r9d
  00327	45 33 c0	 xor	 r8d, r8d
  0032a	ba 54 43 52 4c	 mov	 edx, 1280459604		; 4c524354H
  0032f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoInitializeRemoveLockEx

; 540  : 
; 541  : 	VirtualVolumeDeviceObjects[mount->nDosDriveNo] = *ppDeviceObject;

  00335	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR mount$[rsp]
  0033d	48 63 92 64 02
	00 00		 movsxd	 rdx, DWORD PTR [rdx+612]
  00344	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VirtualVolumeDeviceObjects
  0034b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  00353	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00356	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 542  : 
; 543  : 	Dump ("GSTCreateDeviceObject STATUS_SUCCESS END\n");

  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@MMFHFIAK@GSTCreateDeviceObject?5STATUS_SUC@FNODOBFM@
  00361	e8 00 00 00 00	 call	 DbgPrint

; 544  : 
; 545  : 	return STATUS_SUCCESS;

  00366	33 c0		 xor	 eax, eax
$LN2@GSTCreateD:

; 546  : }

  00368	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00370	48 33 cc	 xor	 rcx, rsp
  00373	e8 00 00 00 00	 call	 __security_check_cookie
  00378	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  0037f	5f		 pop	 rdi
  00380	c3		 ret	 0
GSTCreateDeviceObject ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	GSTCreateRootDeviceObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTCreateRootDeviceObject DD imagerel $LN9
	DD	imagerel $LN9+780
	DD	imagerel $unwind$GSTCreateRootDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCreateRootDeviceObject DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0148H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTCreateRootDeviceObject
INIT	SEGMENT
ntUnicodeString$ = 64
ntname$ = 96
bRootExtension$ = 160
Win32NameString$ = 168
DeviceObject$ = 184
dosname$ = 192
ntStatus$ = 256
tv72 = 260
tv74 = 264
tv75 = 272
tv76 = 280
tv77 = 288
tv82 = 296
tv83 = 304
tv84 = 312
tv85 = 320
__$ArrayPad$ = 328
DriverObject$ = 352
GSTCreateRootDeviceObject PROC				; COMDAT

; 425  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 426  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 427  : 	WCHAR dosname[32], ntname[32];
; 428  : 	PDEVICE_OBJECT DeviceObject;
; 429  : 	NTSTATUS ntStatus;
; 430  : 	BOOL *bRootExtension;
; 431  : 
; 432  : 	Dump ("GSTCreateRootDeviceObject BEGIN\n");

  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@JKDEOCBN@GSTCreateRootDeviceObject?5BEGIN?6@PBOPGDP@
  00025	e8 00 00 00 00	 call	 DbgPrint

; 433  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

  0002a	e8 00 00 00 00	 call	 KeGetCurrentIrql
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	74 2a		 je	 SHORT $LN5@GSTCreateR
  00036	45 33 c9	 xor	 r9d, r9d
  00039	41 b8 b1 01 00
	00		 mov	 r8d, 433		; 000001b1H
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@PBOPGDP@
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00053	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv72[rsp], 0
  0005e	eb 0b		 jmp	 SHORT $LN6@GSTCreateR
$LN5@GSTCreateR:
  00060	c7 84 24 04 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv72[rsp], 1
$LN6@GSTCreateR:

; 434  : 
; 435  : 	wcscpy (dosname, (LPWSTR) DOS_ROOT_PREFIX);

  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CM@JDHADMGE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  00072	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv74[rsp], rax
  0007a	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR dosname$[rsp]
  00082	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv75[rsp], rax
  0008a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  00092	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv76[rsp], rax
$LN7@GSTCreateR:
  0009a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv74[rsp]
  000a2	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000a5	66 89 84 24 20
	01 00 00	 mov	 WORD PTR tv77[rsp], ax
  000ad	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv75[rsp]
  000b5	0f b7 84 24 20
	01 00 00	 movzx	 eax, WORD PTR tv77[rsp]
  000bd	66 89 01	 mov	 WORD PTR [rcx], ax
  000c0	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv74[rsp]
  000c8	48 83 c0 02	 add	 rax, 2
  000cc	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv74[rsp], rax
  000d4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  000dc	48 83 c0 02	 add	 rax, 2
  000e0	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv75[rsp], rax
  000e8	66 83 bc 24 20
	01 00 00 00	 cmp	 WORD PTR tv77[rsp], 0
  000f1	75 a7		 jne	 SHORT $LN7@GSTCreateR

; 436  : 	wcscpy (ntname, (LPWSTR) NT_ROOT_PREFIX);

  000f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  000fa	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv82[rsp], rax
  00102	48 8d 44 24 60	 lea	 rax, QWORD PTR ntname$[rsp]
  00107	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv83[rsp], rax
  0010f	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv83[rsp]
  00117	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv84[rsp], rax
$LN8@GSTCreateR:
  0011f	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv82[rsp]
  00127	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0012a	66 89 84 24 40
	01 00 00	 mov	 WORD PTR tv85[rsp], ax
  00132	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv83[rsp]
  0013a	0f b7 84 24 40
	01 00 00	 movzx	 eax, WORD PTR tv85[rsp]
  00142	66 89 01	 mov	 WORD PTR [rcx], ax
  00145	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv82[rsp]
  0014d	48 83 c0 02	 add	 rax, 2
  00151	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv82[rsp], rax
  00159	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv83[rsp]
  00161	48 83 c0 02	 add	 rax, 2
  00165	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv83[rsp], rax
  0016d	66 83 bc 24 40
	01 00 00 00	 cmp	 WORD PTR tv85[rsp], 0
  00176	75 a7		 jne	 SHORT $LN8@GSTCreateR

; 437  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  00178	48 8d 54 24 60	 lea	 rdx, QWORD PTR ntname$[rsp]
  0017d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ntUnicodeString$[rsp]
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 438  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  00188	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR dosname$[rsp]
  00190	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 439  : 
; 440  : 	Dump ("Creating root device nt=%ls dos=%ls\n", ntname, dosname);

  0019e	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR dosname$[rsp]
  001a6	48 8d 54 24 60	 lea	 rdx, QWORD PTR ntname$[rsp]
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@
  001b2	e8 00 00 00 00	 call	 DbgPrint

; 441  : 	
; 442  : 	ntStatus = IoCreateDevice (
; 443  : 					  DriverObject,
; 444  : 					  sizeof (BOOL),
; 445  : 					  &ntUnicodeString,
; 446  : 					  FILE_DEVICE_UNKNOWN,
; 447  : 					  FILE_DEVICE_SECURE_OPEN,
; 448  : 					  FALSE,
; 449  : 					  &DeviceObject);

  001b7	4c 8d 9c 24 b8
	00 00 00	 lea	 r11, QWORD PTR DeviceObject$[rsp]
  001bf	4c 89 5c 24 30	 mov	 QWORD PTR [rsp+48], r11
  001c4	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  001c9	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  001d1	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  001d7	4c 8d 44 24 40	 lea	 r8, QWORD PTR ntUnicodeString$[rsp]
  001dc	ba 04 00 00 00	 mov	 edx, 4
  001e1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice
  001ef	89 84 24 00 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 450  : 
; 451  : 	if (!NT_SUCCESS (ntStatus))

  001f6	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  001fe	7d 1f		 jge	 SHORT $LN2@GSTCreateR

; 452  : 	{
; 453  : 		Dump ("GSTCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);

  00200	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR ntStatus$[rsp]
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@OPKDMPGO@GSTCreateRootDeviceObject?5NTSTAT@PBOPGDP@
  0020e	e8 00 00 00 00	 call	 DbgPrint

; 454  : 		return ntStatus;/* Failed to create DeviceObject */

  00213	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
  0021a	e9 d5 00 00 00	 jmp	 $LN3@GSTCreateR
$LN2@GSTCreateR:

; 455  : 	}
; 456  : 
; 457  : 	DeviceObject->Flags |= DO_DIRECT_IO;

  0021f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00227	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  0022a	83 c9 10	 or	 ecx, 16
  0022d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00235	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 458  : 	DeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

  00238	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00240	c7 80 98 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+152], 1

; 459  : 
; 460  : 	/* Setup the device extension */
; 461  : 	bRootExtension = (BOOL *) DeviceObject->DeviceExtension;

  0024a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00252	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00256	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR bRootExtension$[rsp], rax

; 462  : 	*bRootExtension = TRUE;

  0025e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bRootExtension$[rsp]
  00266	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 463  : 
; 464  : 	KeInitializeMutex (&RootDeviceControlMutex, 0);

  0026c	33 d2		 xor	 edx, edx
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeMutex

; 465  : 
; 466  : 	ntStatus = IoCreateSymbolicLink (&Win32NameString, &ntUnicodeString);

  0027b	48 8d 54 24 40	 lea	 rdx, QWORD PTR ntUnicodeString$[rsp]
  00280	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink
  0028e	89 84 24 00 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 467  : 
; 468  : 	if (!NT_SUCCESS (ntStatus))

  00295	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0029d	7d 2a		 jge	 SHORT $LN1@GSTCreateR

; 469  : 	{
; 470  : 		Dump ("GSTCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);

  0029f	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR ntStatus$[rsp]
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@OPKDMPGO@GSTCreateRootDeviceObject?5NTSTAT@PBOPGDP@
  002ad	e8 00 00 00 00	 call	 DbgPrint

; 471  : 		IoDeleteDevice (DeviceObject);

  002b2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 472  : 		return ntStatus;

  002c0	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
  002c7	eb 2b		 jmp	 SHORT $LN3@GSTCreateR
$LN1@GSTCreateR:

; 473  : 	}
; 474  : 
; 475  : 	IoRegisterShutdownNotification (DeviceObject);

  002c9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoRegisterShutdownNotification

; 476  : 	RootDeviceObject = DeviceObject;

  002d7	4c 8b 9c 24 b8
	00 00 00	 mov	 r11, QWORD PTR DeviceObject$[rsp]
  002df	4c 89 1d 00 00
	00 00		 mov	 QWORD PTR RootDeviceObject, r11

; 477  : 
; 478  : 	Dump ("GSTCreateRootDeviceObject STATUS_SUCCESS END\n");

  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@HAIDILJN@GSTCreateRootDeviceObject?5STATUS@PBOPGDP@
  002ed	e8 00 00 00 00	 call	 DbgPrint

; 479  : 	return STATUS_SUCCESS;

  002f2	33 c0		 xor	 eax, eax
$LN3@GSTCreateR:

; 480  : }

  002f4	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002fc	48 33 cc	 xor	 rcx, rsp
  002ff	e8 00 00 00 00	 call	 __security_check_cookie
  00304	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  0030b	c3		 ret	 0
GSTCreateRootDeviceObject ENDP
INIT	ENDS
PUBLIC	ValidateIOBufferSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$ValidateIOBufferSize DD imagerel $LN11
	DD	imagerel $LN11+340
	DD	imagerel $unwind$ValidateIOBufferSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ValidateIOBufferSize DD 021401H
	DD	07010b214H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ValidateIOBufferSize
_TEXT	SEGMENT
output$ = 64
input$ = 68
irpSp$ = 72
tv68 = 80
tv71 = 84
irp$ = 112
requiredBufferSize$ = 120
type$ = 128
ValidateIOBufferSize PROC				; COMDAT

; 214  : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 215  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);

  00014	48 8b 4c 24 70	 mov	 rcx, QWORD PTR irp$[rsp]
  00019	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  0001e	48 89 44 24 48	 mov	 QWORD PTR irpSp$[rsp], rax

; 216  : 	BOOL input = (type == ValidateInput || type == ValidateInputOutput);

  00023	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR type$[rsp], 0
  0002b	74 14		 je	 SHORT $LN7@ValidateIO
  0002d	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  00035	74 0a		 je	 SHORT $LN7@ValidateIO
  00037	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
  0003f	eb 08		 jmp	 SHORT $LN8@ValidateIO
$LN7@ValidateIO:
  00041	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
$LN8@ValidateIO:
  00049	8b 44 24 50	 mov	 eax, DWORD PTR tv68[rsp]
  0004d	89 44 24 44	 mov	 DWORD PTR input$[rsp], eax

; 217  : 	BOOL output = (type == ValidateOutput || type == ValidateInputOutput);

  00051	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00059	74 14		 je	 SHORT $LN9@ValidateIO
  0005b	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  00063	74 0a		 je	 SHORT $LN9@ValidateIO
  00065	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0006d	eb 08		 jmp	 SHORT $LN10@ValidateIO
$LN9@ValidateIO:
  0006f	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN10@ValidateIO:
  00077	8b 44 24 54	 mov	 eax, DWORD PTR tv71[rsp]
  0007b	89 44 24 40	 mov	 DWORD PTR output$[rsp], eax

; 218  : 
; 219  : 	if ((input && irpSp->Parameters.DeviceIoControl.InputBufferLength < requiredBufferSize)
; 220  : 		|| (output && irpSp->Parameters.DeviceIoControl.OutputBufferLength < requiredBufferSize))

  0007f	83 7c 24 44 00	 cmp	 DWORD PTR input$[rsp], 0
  00084	74 0f		 je	 SHORT $LN2@ValidateIO
  00086	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  0008b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0008e	48 3b 44 24 78	 cmp	 rax, QWORD PTR requiredBufferSize$[rsp]
  00093	72 1a		 jb	 SHORT $LN3@ValidateIO
$LN2@ValidateIO:
  00095	83 7c 24 40 00	 cmp	 DWORD PTR output$[rsp], 0
  0009a	0f 84 86 00 00
	00		 je	 $LN4@ValidateIO
  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  000a5	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000a8	48 3b 44 24 78	 cmp	 rax, QWORD PTR requiredBufferSize$[rsp]
  000ad	73 77		 jae	 SHORT $LN4@ValidateIO
$LN3@ValidateIO:

; 221  : 	{
; 222  : 		Dump ("STATUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d insize=%d outsize=%d\n", (int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16), (int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2), input, output, requiredBufferSize, irpSp->Parameters.DeviceIoControl.InputBufferLength, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  000af	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  000b4	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  000b8	41 81 e0 ff 1f
	00 00		 and	 r8d, 8191		; 00001fffH
  000bf	41 c1 e8 02	 shr	 r8d, 2
  000c3	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  000c8	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  000cb	c1 ea 10	 shr	 edx, 16
  000ce	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  000d3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000d6	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  000da	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  000df	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000e2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000e6	48 8b 44 24 78	 mov	 rax, QWORD PTR requiredBufferSize$[rsp]
  000eb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f0	8b 44 24 40	 mov	 eax, DWORD PTR output$[rsp]
  000f4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000f8	44 8b 4c 24 44	 mov	 r9d, DWORD PTR input$[rsp]
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@
  00104	e8 00 00 00 00	 call	 DbgPrint

; 223  : 
; 224  : 		irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;

  00109	48 8b 54 24 70	 mov	 rdx, QWORD PTR irp$[rsp]
  0010e	c7 42 30 23 00
	00 c0		 mov	 DWORD PTR [rdx+48], -1073741789 ; ffffffffc0000023H

; 225  : 		irp->IoStatus.Information = 0;

  00115	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  0011a	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 226  : 		return FALSE;

  00122	33 c0		 xor	 eax, eax
  00124	eb 28		 jmp	 SHORT $LN5@ValidateIO
$LN4@ValidateIO:

; 227  : 	}
; 228  : 
; 229  : 	if (!input && output)

  00126	83 7c 24 44 00	 cmp	 DWORD PTR input$[rsp], 0
  0012b	75 1c		 jne	 SHORT $LN1@ValidateIO
  0012d	83 7c 24 40 00	 cmp	 DWORD PTR output$[rsp], 0
  00132	74 15		 je	 SHORT $LN1@ValidateIO

; 230  : 		memset (irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  00134	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  00139	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0013c	48 8b 7c 24 70	 mov	 rdi, QWORD PTR irp$[rsp]
  00141	48 8b 7f 18	 mov	 rdi, QWORD PTR [rdi+24]
  00145	33 c0		 xor	 eax, eax
  00147	f3 aa		 rep stosb
$LN1@ValidateIO:

; 231  : 
; 232  : 	return TRUE;

  00149	b8 01 00 00 00	 mov	 eax, 1
$LN5@ValidateIO:

; 233  : }

  0014e	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00152	5f		 pop	 rdi
  00153	c3		 ret	 0
ValidateIOBufferSize ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	DriverAddDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverAddDevice DD imagerel $LN8
	DD	imagerel $LN8+387
	DD	imagerel $unwind$DriverAddDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverAddDevice DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DriverAddDevice
_TEXT	SEGMENT
nameInfoBuffer$ = 48
nameInfoSize$ = 176
nameInfo$ = 184
interfaceLinks$30331 = 192
tv72 = 200
__$ArrayPad$ = 208
driverObject$ = 240
pdo$ = 248
DriverAddDevice PROC					; COMDAT

; 139  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 140  : #ifdef DEBUG
; 141  : 	char nameInfoBuffer[128];
; 142  : 	POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION) nameInfoBuffer;

  00023	48 8d 44 24 30	 lea	 rax, QWORD PTR nameInfoBuffer$[rsp]
  00028	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR nameInfo$[rsp], rax

; 143  : 	ULONG nameInfoSize;
; 144  : 	Dump ("AddDevice pdo=%p type=%x name=%ws\n", pdo, pdo->DeviceType, NT_SUCCESS (ObQueryNameString (pdo, nameInfo, sizeof (nameInfoBuffer), &nameInfoSize)) ? nameInfo->Name.Buffer : L"?");

  00030	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR nameInfoSize$[rsp]
  00038	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0003e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR nameInfo$[rsp]
  00046	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pdo$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObQueryNameString
  00054	85 c0		 test	 eax, eax
  00056	7c 16		 jl	 SHORT $LN6@DriverAddD
  00058	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR nameInfo$[rsp]
  00060	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00064	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv72[rsp], rax
  0006c	eb 0f		 jmp	 SHORT $LN7@DriverAddD
$LN6@DriverAddD:
  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@
  00075	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv72[rsp], rax
$LN7@DriverAddD:
  0007d	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR tv72[rsp]
  00085	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pdo$[rsp]
  0008d	44 8b 40 48	 mov	 r8d, DWORD PTR [rax+72]
  00091	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pdo$[rsp]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@
  000a0	e8 00 00 00 00	 call	 DbgPrint

; 145  : #endif
; 146  : 
; 147  : 	if (VolumeClassFilterRegistered && BootArgsValid && BootArgs.HiddenSystemPartitionStart != 0)

  000a5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR VolumeClassFilterRegistered, 0
  000ac	0f 84 a4 00 00
	00		 je	 $LN3@DriverAddD
  000b2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR BootArgsValid, 0
  000b9	0f 84 97 00 00
	00		 je	 $LN3@DriverAddD
  000bf	48 83 3d 5a 00
	00 00 00	 cmp	 QWORD PTR BootArgs+90, 0
  000c7	0f 84 89 00 00
	00		 je	 $LN3@DriverAddD

; 148  : 	{
; 149  : 		PWSTR interfaceLinks;
; 150  : 		if (NT_SUCCESS (IoGetDeviceInterfaces (&GUID_DEVINTERFACE_VOLUME, pdo, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &interfaceLinks)))

  000cd	4c 8d 8c 24 c0
	00 00 00	 lea	 r9, QWORD PTR interfaceLinks$30331[rsp]
  000d5	41 b8 01 00 00
	00		 mov	 r8d, 1
  000db	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pdo$[rsp]
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:GUID_DEVINTERFACE_VOLUME
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceInterfaces
  000f0	85 c0		 test	 eax, eax
  000f2	7c 62		 jl	 SHORT $LN2@DriverAddD

; 151  : 		{
; 152  : 			if (interfaceLinks[0] != UNICODE_NULL)

  000f4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR interfaceLinks$30331[rsp]
  000fc	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000ff	85 c0		 test	 eax, eax
  00101	74 43		 je	 SHORT $LN1@DriverAddD

; 153  : 			{
; 154  : 				Dump ("Volume pdo=%p interface=%ws\n", pdo, interfaceLinks);

  00103	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR interfaceLinks$30331[rsp]
  0010b	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pdo$[rsp]
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@
  0011a	e8 00 00 00 00	 call	 DbgPrint

; 155  : 				ExFreePool (interfaceLinks);

  0011f	33 d2		 xor	 edx, edx
  00121	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR interfaceLinks$30331[rsp]
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 156  : 
; 157  : 				return VolumeFilterAddDevice (driverObject, pdo);

  0012f	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pdo$[rsp]
  00137	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR driverObject$[rsp]
  0013f	e8 00 00 00 00	 call	 VolumeFilterAddDevice
  00144	eb 25		 jmp	 SHORT $LN4@DriverAddD
$LN1@DriverAddD:

; 158  : 			}
; 159  : 
; 160  : 			ExFreePool (interfaceLinks);

  00146	33 d2		 xor	 edx, edx
  00148	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR interfaceLinks$30331[rsp]
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@DriverAddD:
$LN3@DriverAddD:

; 161  : 		}
; 162  : 	}
; 163  : 
; 164  : 	return DriveFilterAddDevice (driverObject, pdo);

  00156	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pdo$[rsp]
  0015e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR driverObject$[rsp]
  00166	e8 00 00 00 00	 call	 DriveFilterAddDevice
$LN4@DriverAddD:

; 165  : }

  0016b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00173	48 33 cc	 xor	 rcx, rsp
  00176	e8 00 00 00 00	 call	 __security_check_cookie
  0017b	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00182	c3		 ret	 0
DriverAddDevice ENDP
PUBLIC	GetDeviceSectorSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetDeviceSectorSize DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$GetDeviceSectorSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetDeviceSectorSize DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetDeviceSectorSize
_TEXT	SEGMENT
geometry$ = 48
status$ = 72
deviceObject$ = 96
bytesPerSector$ = 104
GetDeviceSectorSize PROC				; COMDAT

; 3671 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3672 : 	NTSTATUS status;
; 3673 : 	DISK_GEOMETRY geometry;
; 3674 : 
; 3675 : 	status = SendDeviceIoControlRequest (deviceObject, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry));

  0000e	c7 44 24 28 18
	00 00 00	 mov	 DWORD PTR [rsp+40], 24
  00016	48 8d 44 24 30	 lea	 rax, QWORD PTR geometry$[rsp]
  0001b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00020	45 33 c9	 xor	 r9d, r9d
  00023	45 33 c0	 xor	 r8d, r8d
  00026	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  0002b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00030	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00035	89 44 24 48	 mov	 DWORD PTR status$[rsp], eax

; 3676 : 
; 3677 : 	if (!NT_SUCCESS (status))

  00039	83 7c 24 48 00	 cmp	 DWORD PTR status$[rsp], 0
  0003e	7d 06		 jge	 SHORT $LN1@GetDeviceS

; 3678 : 		return status;

  00040	8b 44 24 48	 mov	 eax, DWORD PTR status$[rsp]
  00044	eb 0d		 jmp	 SHORT $LN2@GetDeviceS
$LN1@GetDeviceS:

; 3679 : 
; 3680 : 	*bytesPerSector = geometry.BytesPerSector;

  00046	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bytesPerSector$[rsp]
  0004b	8b 44 24 44	 mov	 eax, DWORD PTR geometry$[rsp+20]
  0004f	89 01		 mov	 DWORD PTR [rcx], eax

; 3681 : 	return STATUS_SUCCESS;

  00051	33 c0		 xor	 eax, eax
$LN2@GetDeviceS:

; 3682 : }

  00053	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00057	c3		 ret	 0
GetDeviceSectorSize ENDP
_TEXT	ENDS
PUBLIC	IsAccessibleByUser
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsAccessibleByUser DD imagerel $LN8
	DD	imagerel $LN8+326
	DD	imagerel $unwind$IsAccessibleByUser
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsAccessibleByUser DD 021001H
	DD	0190110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsAccessibleByUser
_TEXT	SEGMENT
fileHandle$ = 96
ioStatusBlock$ = 104
status$ = 120
fileObjAttributes$ = 128
tv73 = 176
tv85 = 180
objectFileName$ = 208
readOnly$ = 216
IsAccessibleByUser PROC					; COMDAT

; 3268 : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 3269 : 	OBJECT_ATTRIBUTES fileObjAttributes;
; 3270 : 	IO_STATUS_BLOCK ioStatusBlock;
; 3271 : 	HANDLE fileHandle;
; 3272 : 	NTSTATUS status;
; 3273 : 
; 3274 : 	ASSERT (!IoIsSystemThread (PsGetCurrentThread()));

  00010	e8 00 00 00 00	 call	 PsGetCurrentThread
  00015	48 8b c8	 mov	 rcx, rax
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	74 2a		 je	 SHORT $LN4@IsAccessib
  00025	45 33 c9	 xor	 r9d, r9d
  00028	41 b8 ca 0c 00
	00		 mov	 r8d, 3274		; 00000ccaH
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00042	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv73[rsp], 0
  0004d	eb 0b		 jmp	 SHORT $LN5@IsAccessib
$LN4@IsAccessib:
  0004f	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv73[rsp], 1
$LN5@IsAccessib:

; 3275 : 
; 3276 : 	InitializeObjectAttributes (&fileObjAttributes, objectFileName, OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE, NULL, NULL);

  0005a	c7 84 24 80 00
	00 00 30 00 00
	00		 mov	 DWORD PTR fileObjAttributes$[rsp], 48 ; 00000030H
  00065	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fileObjAttributes$[rsp+8], 0
  00071	c7 84 24 98 00
	00 00 40 06 00
	00		 mov	 DWORD PTR fileObjAttributes$[rsp+24], 1600 ; 00000640H
  0007c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR objectFileName$[rsp]
  00084	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR fileObjAttributes$[rsp+16], rax
  0008c	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fileObjAttributes$[rsp+32], 0
  00098	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fileObjAttributes$[rsp+40], 0

; 3277 : 	
; 3278 : 	status = ZwCreateFile (&fileHandle,
; 3279 : 		readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
; 3280 : 		&fileObjAttributes,
; 3281 : 		&ioStatusBlock,
; 3282 : 		NULL,
; 3283 : 		FILE_ATTRIBUTE_NORMAL,
; 3284 : 		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
; 3285 : 		FILE_OPEN,
; 3286 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 3287 : 		NULL,
; 3288 : 		0);

  000a4	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR readOnly$[rsp], 0
  000ac	74 0d		 je	 SHORT $LN6@IsAccessib
  000ae	c7 84 24 b4 00
	00 00 00 00 00
	80		 mov	 DWORD PTR tv85[rsp], -2147483648 ; 80000000H
  000b9	eb 0b		 jmp	 SHORT $LN7@IsAccessib
$LN6@IsAccessib:
  000bb	c7 84 24 b4 00
	00 00 00 00 00
	c0		 mov	 DWORD PTR tv85[rsp], -1073741824 ; c0000000H
$LN7@IsAccessib:
  000c6	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  000ce	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  000d7	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  000df	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  000e7	c7 44 24 30 07
	00 00 00	 mov	 DWORD PTR [rsp+48], 7
  000ef	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  000f7	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00100	4c 8d 4c 24 68	 lea	 r9, QWORD PTR ioStatusBlock$[rsp]
  00105	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR fileObjAttributes$[rsp]
  0010d	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR tv85[rsp]
  00114	48 8d 4c 24 60	 lea	 rcx, QWORD PTR fileHandle$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  0011f	89 44 24 78	 mov	 DWORD PTR status$[rsp], eax

; 3289 : 
; 3290 : 	if (NT_SUCCESS (status))

  00123	83 7c 24 78 00	 cmp	 DWORD PTR status$[rsp], 0
  00128	7c 12		 jl	 SHORT $LN1@IsAccessib

; 3291 : 	{
; 3292 : 		ZwClose (fileHandle);

  0012a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fileHandle$[rsp]
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3293 : 		return TRUE;

  00135	b8 01 00 00 00	 mov	 eax, 1
  0013a	eb 02		 jmp	 SHORT $LN2@IsAccessib
$LN1@IsAccessib:

; 3294 : 	}
; 3295 : 
; 3296 : 	return FALSE;

  0013c	33 c0		 xor	 eax, eax
$LN2@IsAccessib:

; 3297 : }

  0013e	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00145	c3		 ret	 0
IsAccessibleByUser ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	MountManagerUnmount
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountManagerUnmount DD imagerel $LN3
	DD	imagerel $LN3+245
	DD	imagerel $unwind$MountManagerUnmount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountManagerUnmount DD 031e19H
	DD	052010cH
	DD	07005H
	DD	imagerel __GSHandlerCheck
	DD	0280H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT MountManagerUnmount
_TEXT	SEGMENT
in$ = 48
buf$ = 64
ntStatus$ = 320
out$ = 336
__$ArrayPad$ = 640
nDosDriveNo$ = 672
MountManagerUnmount PROC				; COMDAT

; 2838 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 81 ec 90 02
	00 00		 sub	 rsp, 656		; 00000290H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2839 : 	NTSTATUS ntStatus; 
; 2840 : 	char buf[256], out[300];
; 2841 : 	PMOUNTMGR_MOUNT_POINT in = (PMOUNTMGR_MOUNT_POINT) buf;

  0001e	48 8d 44 24 40	 lea	 rax, QWORD PTR buf$[rsp]
  00023	48 89 44 24 30	 mov	 QWORD PTR in$[rsp], rax

; 2842 : 
; 2843 : 	memset (buf, 0, sizeof buf);

  00028	48 8d 7c 24 40	 lea	 rdi, QWORD PTR buf$[rsp]
  0002d	33 c0		 xor	 eax, eax
  0002f	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00034	f3 aa		 rep stosb

; 2844 : 
; 2845 : 	GSTGetDosNameFromNumber ((PWSTR) &in[1], nDosDriveNo);

  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR in$[rsp]
  0003b	48 83 c1 18	 add	 rcx, 24
  0003f	8b 94 24 a0 02
	00 00		 mov	 edx, DWORD PTR nDosDriveNo$[rsp]
  00046	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 2846 : 
; 2847 : 	// Only symbolic link can be deleted with IOCTL_MOUNTMGR_DELETE_POINTS. If any other entry is specified, the mount manager will ignore subsequent IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for the same volume ID.
; 2848 : 	in->SymbolicLinkNameOffset = sizeof (MOUNTMGR_MOUNT_POINT);

  0004b	48 8b 54 24 30	 mov	 rdx, QWORD PTR in$[rsp]
  00050	c7 02 18 00 00
	00		 mov	 DWORD PTR [rdx], 24

; 2849 : 	in->SymbolicLinkNameLength = (USHORT) wcslen ((PWCHAR) &in[1]) * 2;

  00056	48 8b 7c 24 30	 mov	 rdi, QWORD PTR in$[rsp]
  0005b	48 83 c7 18	 add	 rdi, 24
  0005f	33 c0		 xor	 eax, eax
  00061	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00068	66 f2 af	 repne scasw
  0006b	48 f7 d1	 not	 rcx
  0006e	48 83 e9 01	 sub	 rcx, 1
  00072	0f b7 c9	 movzx	 ecx, cx
  00075	d1 e1		 shl	 ecx, 1
  00077	48 8b 44 24 30	 mov	 rax, QWORD PTR in$[rsp]
  0007c	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 2850 : 
; 2851 : 	ntStatus = GSTDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_DELETE_POINTS,
; 2852 : 		in, sizeof(MOUNTMGR_MOUNT_POINT) + in->SymbolicLinkNameLength, out, sizeof out);

  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR in$[rsp]
  00085	0f b7 48 04	 movzx	 ecx, WORD PTR [rax+4]
  00089	48 83 c1 18	 add	 rcx, 24
  0008d	c7 44 24 28 2c
	01 00 00	 mov	 DWORD PTR [rsp+40], 300	; 0000012cH
  00095	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR out$[rsp]
  0009d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a2	44 8b c9	 mov	 r9d, ecx
  000a5	4c 8b 44 24 30	 mov	 r8, QWORD PTR in$[rsp]
  000aa	ba 04 c0 6d 00	 mov	 edx, 7192580		; 006dc004H
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  000b6	e8 00 00 00 00	 call	 GSTDeviceIoControl
  000bb	89 84 24 40 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 2853 : 
; 2854 : 	Dump ("IOCTL_MOUNTMGR_DELETE_POINTS returned 0x%08x\n", ntStatus);

  000c2	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR ntStatus$[rsp]
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@
  000d0	e8 00 00 00 00	 call	 DbgPrint

; 2855 : 
; 2856 : 	return ntStatus;

  000d5	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]

; 2857 : }

  000dc	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e4	48 33 cc	 xor	 rcx, rsp
  000e7	e8 00 00 00 00	 call	 __security_check_cookie
  000ec	48 81 c4 90 02
	00 00		 add	 rsp, 656		; 00000290H
  000f3	5f		 pop	 rdi
  000f4	c3		 ret	 0
MountManagerUnmount ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	MountManagerMount
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountManagerMount DD imagerel $LN4
	DD	imagerel $LN4+706
	DD	imagerel $unwind$MountManagerMount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountManagerMount DD 031f19H
	DD	06e010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0368H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT MountManagerMount
_TEXT	SEGMENT
point$ = 48
in$ = 56
arrVolume$ = 80
buf$ = 592
devName$ = 800
ntStatus$ = 816
symName$ = 824
tv74 = 840
tv76 = 848
tv77 = 856
tv78 = 864
__$ArrayPad$ = 872
mount$ = 896
MountManagerMount PROC					; COMDAT

; 2793 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 70 03
	00 00		 sub	 rsp, 880		; 00000370H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2794 : 	NTSTATUS ntStatus; 
; 2795 : 	WCHAR arrVolume[256];
; 2796 : 	char buf[200];
; 2797 : 	PMOUNTMGR_TARGET_NAME in = (PMOUNTMGR_TARGET_NAME) buf;

  0001f	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00027	48 89 44 24 38	 mov	 QWORD PTR in$[rsp], rax

; 2798 : 	PMOUNTMGR_CREATE_POINT_INPUT point = (PMOUNTMGR_CREATE_POINT_INPUT) buf;

  0002c	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00034	48 89 44 24 30	 mov	 QWORD PTR point$[rsp], rax

; 2799 : 	UNICODE_STRING symName, devName;
; 2800 : 
; 2801 : 	GSTGetNTNameFromNumber (arrVolume, mount->nDosDriveNo);

  00039	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00041	8b 90 64 02 00
	00		 mov	 edx, DWORD PTR [rax+612]
  00047	48 8d 4c 24 50	 lea	 rcx, QWORD PTR arrVolume$[rsp]
  0004c	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 2802 : 	in->DeviceNameLength = (USHORT) wcslen (arrVolume) * 2;

  00051	33 c0		 xor	 eax, eax
  00053	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0005a	48 8d 7c 24 50	 lea	 rdi, QWORD PTR arrVolume$[rsp]
  0005f	66 f2 af	 repne scasw
  00062	48 f7 d1	 not	 rcx
  00065	48 83 e9 01	 sub	 rcx, 1
  00069	0f b7 c9	 movzx	 ecx, cx
  0006c	d1 e1		 shl	 ecx, 1
  0006e	48 8b 44 24 38	 mov	 rax, QWORD PTR in$[rsp]
  00073	66 89 08	 mov	 WORD PTR [rax], cx

; 2803 : 	wcscpy(in->DeviceName, arrVolume);

  00076	48 8d 44 24 50	 lea	 rax, QWORD PTR arrVolume$[rsp]
  0007b	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR tv74[rsp], rax
  00083	48 8b 44 24 38	 mov	 rax, QWORD PTR in$[rsp]
  00088	48 83 c0 02	 add	 rax, 2
  0008c	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR tv76[rsp], rax
  00094	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR tv76[rsp]
  0009c	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR tv77[rsp], rax
$LN3@MountManag:
  000a4	48 8b 84 24 48
	03 00 00	 mov	 rax, QWORD PTR tv74[rsp]
  000ac	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000af	66 89 84 24 60
	03 00 00	 mov	 WORD PTR tv78[rsp], ax
  000b7	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR tv76[rsp]
  000bf	0f b7 84 24 60
	03 00 00	 movzx	 eax, WORD PTR tv78[rsp]
  000c7	66 89 01	 mov	 WORD PTR [rcx], ax
  000ca	48 8b 84 24 48
	03 00 00	 mov	 rax, QWORD PTR tv74[rsp]
  000d2	48 83 c0 02	 add	 rax, 2
  000d6	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR tv74[rsp], rax
  000de	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR tv76[rsp]
  000e6	48 83 c0 02	 add	 rax, 2
  000ea	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR tv76[rsp], rax
  000f2	66 83 bc 24 60
	03 00 00 00	 cmp	 WORD PTR tv78[rsp], 0
  000fb	75 a7		 jne	 SHORT $LN3@MountManag

; 2804 : 
; 2805 : 	ntStatus = GSTDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
; 2806 : 		in, (ULONG) (sizeof (in->DeviceNameLength) + wcslen (arrVolume) * 2), 0, 0);

  000fd	33 c0		 xor	 eax, eax
  000ff	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00106	48 8d 7c 24 50	 lea	 rdi, QWORD PTR arrVolume$[rsp]
  0010b	66 f2 af	 repne scasw
  0010e	48 f7 d1	 not	 rcx
  00111	48 83 e9 01	 sub	 rcx, 1
  00115	48 8d 44 09 02	 lea	 rax, QWORD PTR [rcx+rcx+2]
  0011a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00122	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0012b	44 8b c8	 mov	 r9d, eax
  0012e	4c 8b 44 24 38	 mov	 r8, QWORD PTR in$[rsp]
  00133	ba 2c 40 6d 00	 mov	 edx, 7159852		; 006d402cH
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0013f	e8 00 00 00 00	 call	 GSTDeviceIoControl
  00144	89 84 24 30 03
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 2807 : 
; 2808 : 	memset (buf, 0, sizeof buf);

  0014b	48 8d bc 24 50
	02 00 00	 lea	 rdi, QWORD PTR buf$[rsp]
  00153	33 c0		 xor	 eax, eax
  00155	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  0015a	f3 aa		 rep stosb

; 2809 : 	GSTGetDosNameFromNumber ((PWSTR) &point[1], mount->nDosDriveNo);

  0015c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR point$[rsp]
  00161	48 83 c1 08	 add	 rcx, 8
  00165	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0016d	8b 90 64 02 00
	00		 mov	 edx, DWORD PTR [rax+612]
  00173	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 2810 : 
; 2811 : 	point->SymbolicLinkNameOffset = sizeof (MOUNTMGR_CREATE_POINT_INPUT);

  00178	ba 08 00 00 00	 mov	 edx, 8
  0017d	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  00182	66 89 10	 mov	 WORD PTR [rax], dx

; 2812 : 	point->SymbolicLinkNameLength = (USHORT) wcslen ((PWSTR) &point[1]) * 2;

  00185	48 8b 7c 24 30	 mov	 rdi, QWORD PTR point$[rsp]
  0018a	48 83 c7 08	 add	 rdi, 8
  0018e	33 c0		 xor	 eax, eax
  00190	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00197	66 f2 af	 repne scasw
  0019a	48 f7 d1	 not	 rcx
  0019d	48 83 e9 01	 sub	 rcx, 1
  001a1	0f b7 c9	 movzx	 ecx, cx
  001a4	d1 e1		 shl	 ecx, 1
  001a6	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  001ab	66 89 48 02	 mov	 WORD PTR [rax+2], cx

; 2813 : 
; 2814 : 	RtlInitUnicodeString(&symName, (PWSTR) (buf + point->SymbolicLinkNameOffset));

  001af	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  001b4	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001b7	48 8d 94 04 50
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp+rax]
  001bf	48 8d 8c 24 38
	03 00 00	 lea	 rcx, QWORD PTR symName$[rsp]
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2815 : 
; 2816 : 	point->DeviceNameOffset = point->SymbolicLinkNameOffset + point->SymbolicLinkNameLength;

  001cd	48 8b 54 24 30	 mov	 rdx, QWORD PTR point$[rsp]
  001d2	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  001d5	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  001da	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  001de	03 c8		 add	 ecx, eax
  001e0	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  001e5	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 2817 : 	GSTGetNTNameFromNumber ((PWSTR) (buf + point->DeviceNameOffset), mount->nDosDriveNo);

  001e9	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  001ee	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  001f2	48 8d 8c 04 50
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rax]
  001fa	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00202	8b 90 64 02 00
	00		 mov	 edx, DWORD PTR [rax+612]
  00208	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 2818 : 	point->DeviceNameLength = (USHORT) wcslen ((PWSTR) (buf + point->DeviceNameOffset)) * 2;

  0020d	48 8b 54 24 30	 mov	 rdx, QWORD PTR point$[rsp]
  00212	0f b7 42 04	 movzx	 eax, WORD PTR [rdx+4]
  00216	48 8d bc 04 50
	02 00 00	 lea	 rdi, QWORD PTR buf$[rsp+rax]
  0021e	33 c0		 xor	 eax, eax
  00220	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00227	66 f2 af	 repne scasw
  0022a	48 f7 d1	 not	 rcx
  0022d	48 83 e9 01	 sub	 rcx, 1
  00231	0f b7 c9	 movzx	 ecx, cx
  00234	d1 e1		 shl	 ecx, 1
  00236	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  0023b	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 2819 : 
; 2820 : 	RtlInitUnicodeString(&devName, (PWSTR) (buf + point->DeviceNameOffset));

  0023f	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  00244	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  00248	48 8d 94 04 50
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp+rax]
  00250	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR devName$[rsp]
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2821 : 
; 2822 : 	ntStatus = GSTDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_CREATE_POINT, point,
; 2823 : 		point->DeviceNameOffset + point->DeviceNameLength, 0, 0);

  0025e	48 8b 54 24 30	 mov	 rdx, QWORD PTR point$[rsp]
  00263	44 0f b7 4a 04	 movzx	 r9d, WORD PTR [rdx+4]
  00268	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  0026d	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00271	44 03 c8	 add	 r9d, eax
  00274	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0027c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00285	4c 8b 44 24 30	 mov	 r8, QWORD PTR point$[rsp]
  0028a	ba 00 c0 6d 00	 mov	 edx, 7192576		; 006dc000H
  0028f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00296	e8 00 00 00 00	 call	 GSTDeviceIoControl
  0029b	89 84 24 30 03
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 2824 : 
; 2825 : 	return ntStatus;

  002a2	8b 84 24 30 03
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]

; 2826 : }

  002a9	48 8b 8c 24 68
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002b1	48 33 cc	 xor	 rcx, rsp
  002b4	e8 00 00 00 00	 call	 __security_check_cookie
  002b9	48 81 c4 70 03
	00 00		 add	 rsp, 880		; 00000370H
  002c0	5f		 pop	 rdi
  002c1	c3		 ret	 0
MountManagerMount ENDP
_TEXT	ENDS
PUBLIC	GSTWriteDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTWriteDevice DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$GSTWriteDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTWriteDevice DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTWriteDevice
_TEXT	SEGMENT
deviceObject$ = 64
buffer$ = 72
offset$ = 80
length$ = 88
GSTWriteDevice PROC					; COMDAT

; 2690 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2691 : 	return GSTReadWriteDevice (TRUE, deviceObject, buffer, offset, length);

  00018	8b 44 24 58	 mov	 eax, DWORD PTR length$[rsp]
  0001c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00020	4c 8b 4c 24 50	 mov	 r9, QWORD PTR offset$[rsp]
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR buffer$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  0002f	b9 01 00 00 00	 mov	 ecx, 1
  00034	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 2692 : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
GSTWriteDevice ENDP
_TEXT	ENDS
PUBLIC	GSTReadDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTReadDevice DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$GSTReadDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTReadDevice DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTReadDevice
_TEXT	SEGMENT
deviceObject$ = 64
buffer$ = 72
offset$ = 80
length$ = 88
GSTReadDevice PROC					; COMDAT

; 2673 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2674 : 	return GSTReadWriteDevice (FALSE, deviceObject, buffer, offset, length);

  00018	8b 44 24 58	 mov	 eax, DWORD PTR length$[rsp]
  0001c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00020	4c 8b 4c 24 50	 mov	 r9, QWORD PTR offset$[rsp]
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR buffer$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  0002f	33 c9		 xor	 ecx, ecx
  00031	e8 00 00 00 00	 call	 GSTReadWriteDevice

; 2675 : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
GSTReadDevice ENDP
_TEXT	ENDS
PUBLIC	GSTUnloadDriver
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTUnloadDriver DD imagerel $LN4
	DD	imagerel $LN4+115
	DD	imagerel $unwind$GSTUnloadDriver
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTUnloadDriver DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTUnloadDriver
_TEXT	SEGMENT
DriverObject$ = 64
GSTUnloadDriver PROC					; COMDAT

; 2304 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2305 : 	Dump ("GSTUnloadDriver BEGIN\n");

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@CIHDGGMI@GSTUnloadDriver?5BEGIN?6?$AA@FNODOBFM@
  00010	e8 00 00 00 00	 call	 DbgPrint

; 2306 : 
; 2307 : 	OnShutdownPending();

  00015	e8 00 00 00 00	 call	 OnShutdownPending

; 2308 : 
; 2309 : 	if (IsBootDriveMounted())

  0001a	e8 00 00 00 00	 call	 IsBootDriveMounted
  0001f	85 c0		 test	 eax, eax
  00021	74 23		 je	 SHORT $LN1@GSTUnloadD

; 2310 : 		GST_BUG_CHECK (STATUS_INVALID_DEVICE_STATE);

  00023	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0002c	45 33 c9	 xor	 r9d, r9d
  0002f	49 c7 c0 84 01
	00 c0		 mov	 r8, -1073741436		; ffffffffc0000184H
  00036	ba 06 09 00 00	 mov	 edx, 2310		; 00000906H
  0003b	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN1@GSTUnloadD:

; 2311 : 
; 2312 : 	EncryptionThreadPoolStop();

  00046	e8 00 00 00 00	 call	 EncryptionThreadPoolStop

; 2313 : 	GSTDeleteDeviceObject (RootDeviceObject, (PEXTENSION) RootDeviceObject->DeviceExtension);

  0004b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR RootDeviceObject
  00052	48 8b 52 40	 mov	 rdx, QWORD PTR [rdx+64]
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0005d	e8 00 00 00 00	 call	 GSTDeleteDeviceObject

; 2314 : 
; 2315 : 	Dump ("GSTUnloadDriver END\n");

  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@ECIECEFH@GSTUnloadDriver?5END?6?$AA@FNODOBFM@
  00069	e8 00 00 00 00	 call	 DbgPrint
$LN3@GSTUnloadD:

; 2316 : }

  0006e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00072	c3		 ret	 0
GSTUnloadDriver ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	ProcessVolumeDeviceControlIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessVolumeDeviceControlIrp DD imagerel $LN57
	DD	imagerel $LN57+3560
	DD	imagerel $unwind$ProcessVolumeDeviceControlIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessVolumeDeviceControlIrp DD 042a19H
	DD	0b90118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	05b8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ProcessVolumeDeviceControlIrp
_TEXT	SEGMENT
irpSp$ = 80
ntUnicodeString$30540 = 88
outputBuffer$30542 = 104
ntName$30541 = 128
outLength$30539 = 640
outputBuffer$30560 = 648
tmp$30559 = 656
volId$30558 = 672
outLength$30557 = 800
ntUnicodeString$30575 = 808
outputBuffer$30577 = 824
ntName$30576 = 832
outLength$30574 = 1344
outputBuffer$30594 = 1352
outputBuffer$30601 = 1360
outputBuffer$30608 = 1368
outputBuffer$30615 = 1376
outputBuffer$30625 = 1384
pVerifyInformation$30632 = 1392
buffer$30638 = 1400
ioStatus$30637 = 1408
offset$30643 = 1424
extents$30671 = 1432
tv67 = 1440
tv218 = 1444
tv313 = 1448
tv359 = 1456
__$ArrayPad$ = 1464
DeviceObject$ = 1504
Extension$ = 1512
Irp$ = 1520
ProcessVolumeDeviceControlIrp PROC			; COMDAT

; 591  : {

$LN57:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec c8 05
	00 00		 sub	 rsp, 1480		; 000005c8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 b8
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 592  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0002a	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00032	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  00037	48 89 44 24 50	 mov	 QWORD PTR irpSp$[rsp], rax

; 593  : 
; 594  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR irpSp$[rsp]
  00041	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00044	89 84 24 a0 05
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  0004b	81 bc 24 a0 05
	00 00 5c 40 07
	00		 cmp	 DWORD PTR tv67[rsp], 475228 ; 0007405cH
  00056	0f 87 9f 00 00
	00		 ja	 $LN53@ProcessVol
  0005c	81 bc 24 a0 05
	00 00 5c 40 07
	00		 cmp	 DWORD PTR tv67[rsp], 475228 ; 0007405cH
  00067	0f 84 d4 08 00
	00		 je	 $LN23@ProcessVol
  0006d	81 bc 24 a0 05
	00 00 48 00 07
	00		 cmp	 DWORD PTR tv67[rsp], 458824 ; 00070048H
  00078	77 49		 ja	 SHORT $LN54@ProcessVol
  0007a	81 bc 24 a0 05
	00 00 48 00 07
	00		 cmp	 DWORD PTR tv67[rsp], 458824 ; 00070048H
  00085	0f 84 d7 06 00
	00		 je	 $LN27@ProcessVol
  0008b	81 bc 24 a0 05
	00 00 00 00 07
	00		 cmp	 DWORD PTR tv67[rsp], 458752 ; 00070000H
  00096	0f 84 f5 04 00
	00		 je	 $LN31@ProcessVol
  0009c	81 bc 24 a0 05
	00 00 14 00 07
	00		 cmp	 DWORD PTR tv67[rsp], 458772 ; 00070014H
  000a7	0f 84 23 09 00
	00		 je	 $LN20@ProcessVol
  000ad	81 bc 24 a0 05
	00 00 24 00 07
	00		 cmp	 DWORD PTR tv67[rsp], 458788 ; 00070024H
  000b8	0f 84 82 0b 00
	00		 je	 $LN11@ProcessVol
  000be	e9 8a 0c 00 00	 jmp	 $LN2@ProcessVol
$LN54@ProcessVol:
  000c3	81 bc 24 a0 05
	00 00 00 0c 07
	00		 cmp	 DWORD PTR tv67[rsp], 461824 ; 00070c00H
  000ce	0f 84 bd 04 00
	00		 je	 $LN31@ProcessVol
  000d4	81 bc 24 a0 05
	00 00 04 40 07
	00		 cmp	 DWORD PTR tv67[rsp], 475140 ; 00074004H
  000df	0f 84 a4 05 00
	00		 je	 $LN29@ProcessVol
  000e5	81 bc 24 a0 05
	00 00 0c 40 07
	00		 cmp	 DWORD PTR tv67[rsp], 475148 ; 0007400cH
  000f0	0f 84 54 07 00
	00		 je	 $LN25@ProcessVol
  000f6	e9 52 0c 00 00	 jmp	 $LN2@ProcessVol
$LN53@ProcessVol:
  000fb	81 bc 24 a0 05
	00 00 08 00 4d
	00		 cmp	 DWORD PTR tv67[rsp], 5046280 ; 004d0008H
  00106	77 45		 ja	 SHORT $LN55@ProcessVol
  00108	81 bc 24 a0 05
	00 00 08 00 4d
	00		 cmp	 DWORD PTR tv67[rsp], 5046280 ; 004d0008H
  00113	74 70		 je	 SHORT $LN42@ProcessVol
  00115	81 bc 24 a0 05
	00 00 00 48 07
	00		 cmp	 DWORD PTR tv67[rsp], 477184 ; 00074800H
  00120	0f 84 c6 0a 00
	00		 je	 $LN13@ProcessVol
  00126	81 bc 24 a0 05
	00 00 00 48 2d
	00		 cmp	 DWORD PTR tv67[rsp], 2967552 ; 002d4800H
  00131	0f 84 b5 0a 00
	00		 je	 $LN13@ProcessVol
  00137	81 bc 24 a0 05
	00 00 00 00 4d
	00		 cmp	 DWORD PTR tv67[rsp], 5046272 ; 004d0000H
  00142	0f 84 5b 01 00
	00		 je	 $LN38@ProcessVol
  00148	e9 00 0c 00 00	 jmp	 $LN2@ProcessVol
$LN55@ProcessVol:
  0014d	81 bc 24 a0 05
	00 00 0c 00 4d
	00		 cmp	 DWORD PTR tv67[rsp], 5046284 ; 004d000cH
  00158	0f 84 f2 02 00
	00		 je	 $LN34@ProcessVol
  0015e	81 bc 24 a0 05
	00 00 00 00 56
	00		 cmp	 DWORD PTR tv67[rsp], 5636096 ; 00560000H
  00169	0f 84 3b 0b 00
	00		 je	 $LN7@ProcessVol
  0016f	81 bc 24 a0 05
	00 00 08 c0 56
	00		 cmp	 DWORD PTR tv67[rsp], 5685256 ; 0056c008H
  0017a	0f 84 06 0b 00
	00		 je	 $LN8@ProcessVol
  00180	e9 c8 0b 00 00	 jmp	 $LN2@ProcessVol
$LN42@ProcessVol:

; 595  : 	{
; 596  : 
; 597  : 	case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
; 598  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_NAME), ValidateOutput))

  00185	41 b8 01 00 00
	00		 mov	 r8d, 1
  0018b	ba 04 00 00 00	 mov	 edx, 4
  00190	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00198	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0019d	85 c0		 test	 eax, eax
  0019f	75 24		 jne	 SHORT $LN41@ProcessVol

; 599  : 		{
; 600  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);

  001a1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  001a9	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 601  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  001b1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  001b9	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 602  : 		}
; 603  : 		else

  001c0	e9 d9 00 00 00	 jmp	 $LN40@ProcessVol
$LN41@ProcessVol:

; 604  : 		{
; 605  : 			ULONG outLength;
; 606  : 			UNICODE_STRING ntUnicodeString;
; 607  : 			WCHAR ntName[256];
; 608  : 			PMOUNTDEV_NAME outputBuffer = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;

  001c5	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  001cd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001d1	48 89 44 24 68	 mov	 QWORD PTR outputBuffer$30542[rsp], rax

; 609  : 
; 610  : 			GSTGetNTNameFromNumber (ntName, Extension->nDosDriveNo);

  001d6	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  001de	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  001e1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ntName$30541[rsp]
  001e9	e8 00 00 00 00	 call	 GSTGetNTNameFromNumber

; 611  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  001ee	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR ntName$30541[rsp]
  001f6	48 8d 4c 24 58	 lea	 rcx, QWORD PTR ntUnicodeString$30540[rsp]
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 612  : 
; 613  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  00201	48 8b 54 24 68	 mov	 rdx, QWORD PTR outputBuffer$30542[rsp]
  00206	0f b7 44 24 58	 movzx	 eax, WORD PTR ntUnicodeString$30540[rsp]
  0020b	66 89 02	 mov	 WORD PTR [rdx], ax

; 614  : 			outLength = ntUnicodeString.Length + sizeof(USHORT);

  0020e	0f b7 44 24 58	 movzx	 eax, WORD PTR ntUnicodeString$30540[rsp]
  00213	48 83 c0 02	 add	 rax, 2
  00217	89 84 24 80 02
	00 00		 mov	 DWORD PTR outLength$30539[rsp], eax

; 615  : 
; 616  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  0021e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR irpSp$[rsp]
  00223	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR outLength$30539[rsp]
  0022a	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  0022d	73 24		 jae	 SHORT $LN39@ProcessVol

; 617  : 			{
; 618  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);

  0022f	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00237	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 619  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  0023f	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00247	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 620  : 
; 621  : 				break;

  0024e	e9 11 0b 00 00	 jmp	 $LN43@ProcessVol
$LN39@ProcessVol:

; 622  : 			}
; 623  : 
; 624  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  00253	0f b7 4c 24 58	 movzx	 ecx, WORD PTR ntUnicodeString$30540[rsp]
  00258	48 8b 7c 24 68	 mov	 rdi, QWORD PTR outputBuffer$30542[rsp]
  0025d	48 83 c7 02	 add	 rdi, 2
  00261	48 8b 74 24 60	 mov	 rsi, QWORD PTR ntUnicodeString$30540[rsp+8]
  00266	f3 a4		 rep movsb

; 625  : 
; 626  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00268	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00270	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 627  : 			Irp->IoStatus.Information = outLength;

  00277	8b 8c 24 80 02
	00 00		 mov	 ecx, DWORD PTR outLength$30539[rsp]
  0027e	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00286	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 628  : 
; 629  : 			Dump ("name = %ls\n",ntName);

  0028a	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR ntName$30541[rsp]
  00292	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@
  00299	e8 00 00 00 00	 call	 DbgPrint
$LN40@ProcessVol:

; 630  : 		}
; 631  : 		break;

  0029e	e9 c1 0a 00 00	 jmp	 $LN43@ProcessVol
$LN38@ProcessVol:

; 632  : 
; 633  : 	case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
; 634  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_UNIQUE_ID), ValidateOutput))

  002a3	41 b8 01 00 00
	00		 mov	 r8d, 1
  002a9	ba 04 00 00 00	 mov	 edx, 4
  002ae	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  002b6	e8 00 00 00 00	 call	 ValidateIOBufferSize
  002bb	85 c0		 test	 eax, eax
  002bd	75 24		 jne	 SHORT $LN37@ProcessVol

; 635  : 		{
; 636  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);

  002bf	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002c7	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 637  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  002cf	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002d7	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 638  : 		}
; 639  : 		else

  002de	e9 68 01 00 00	 jmp	 $LN36@ProcessVol
$LN37@ProcessVol:

; 640  : 		{
; 641  : 			ULONG outLength;
; 642  : 			UCHAR volId[128], tmp[] = { 0,0 };

  002e3	c6 84 24 90 02
	00 00 00	 mov	 BYTE PTR tmp$30559[rsp], 0
  002eb	c6 84 24 91 02
	00 00 00	 mov	 BYTE PTR tmp$30559[rsp+1], 0

; 643  : 			PMOUNTDEV_UNIQUE_ID outputBuffer = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;

  002f3	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002fb	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  002ff	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR outputBuffer$30560[rsp], rax

; 644  : 
; 645  : 			strcpy (volId, GST_UNIQUE_ID_PREFIX); 

  00307	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR volId$30558[rsp]
  0030f	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_0BA@OIGBKMHJ@GostCryptVolume?$AA@FNODOBFM@
  00316	b9 10 00 00 00	 mov	 ecx, 16
  0031b	f3 a4		 rep movsb

; 646  : 			tmp[0] = 'A' + (UCHAR) Extension->nDosDriveNo;

  0031d	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00325	0f b6 40 14	 movzx	 eax, BYTE PTR [rax+20]
  00329	83 c0 41	 add	 eax, 65			; 00000041H
  0032c	88 84 24 90 02
	00 00		 mov	 BYTE PTR tmp$30559[rsp], al

; 647  : 			strcat (volId, tmp);

  00333	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR volId$30558[rsp]
  0033b	33 c0		 xor	 eax, eax
  0033d	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00344	f2 ae		 repne scasb
  00346	48 83 ef 01	 sub	 rdi, 1
  0034a	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR tmp$30559[rsp]
  00352	33 c9		 xor	 ecx, ecx
$LL56@ProcessVol:
  00354	0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+rcx]
  00358	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
  0035b	48 83 c1 01	 add	 rcx, 1
  0035f	84 c0		 test	 al, al
  00361	75 f1		 jne	 SHORT $LL56@ProcessVol

; 648  : 			
; 649  : 			outputBuffer->UniqueIdLength = (USHORT) strlen (volId);

  00363	33 c0		 xor	 eax, eax
  00365	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0036c	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR volId$30558[rsp]
  00374	f2 ae		 repne scasb
  00376	48 f7 d1	 not	 rcx
  00379	48 83 e9 01	 sub	 rcx, 1
  0037d	48 8b 84 24 88
	02 00 00	 mov	 rax, QWORD PTR outputBuffer$30560[rsp]
  00385	66 89 08	 mov	 WORD PTR [rax], cx

; 650  : 			outLength = (ULONG) (strlen (volId) + sizeof (USHORT));

  00388	33 c0		 xor	 eax, eax
  0038a	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00391	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR volId$30558[rsp]
  00399	f2 ae		 repne scasb
  0039b	48 f7 d1	 not	 rcx
  0039e	48 83 e9 01	 sub	 rcx, 1
  003a2	48 8b c1	 mov	 rax, rcx
  003a5	48 83 c0 02	 add	 rax, 2
  003a9	89 84 24 20 03
	00 00		 mov	 DWORD PTR outLength$30557[rsp], eax

; 651  : 
; 652  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  003b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR irpSp$[rsp]
  003b5	8b 84 24 20 03
	00 00		 mov	 eax, DWORD PTR outLength$30557[rsp]
  003bc	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  003bf	73 24		 jae	 SHORT $LN35@ProcessVol

; 653  : 			{
; 654  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);

  003c1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  003c9	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 655  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  003d1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  003d9	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 656  : 				break;

  003e0	e9 7f 09 00 00	 jmp	 $LN43@ProcessVol
$LN35@ProcessVol:

; 657  : 			}
; 658  : 
; 659  : 			RtlCopyMemory ((PCHAR)outputBuffer->UniqueId, volId, strlen (volId));

  003e5	33 c0		 xor	 eax, eax
  003e7	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  003ee	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR volId$30558[rsp]
  003f6	f2 ae		 repne scasb
  003f8	48 f7 d1	 not	 rcx
  003fb	48 83 e9 01	 sub	 rcx, 1
  003ff	48 8b bc 24 88
	02 00 00	 mov	 rdi, QWORD PTR outputBuffer$30560[rsp]
  00407	48 83 c7 02	 add	 rdi, 2
  0040b	48 8d b4 24 a0
	02 00 00	 lea	 rsi, QWORD PTR volId$30558[rsp]
  00413	f3 a4		 rep movsb

; 660  : 
; 661  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00415	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0041d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 662  : 			Irp->IoStatus.Information = outLength;

  00424	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR outLength$30557[rsp]
  0042b	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00433	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 663  : 
; 664  : 			Dump ("id = %s\n",volId);

  00437	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR volId$30558[rsp]
  0043f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@
  00446	e8 00 00 00 00	 call	 DbgPrint
$LN36@ProcessVol:

; 665  : 		}
; 666  : 		break;

  0044b	e9 14 09 00 00	 jmp	 $LN43@ProcessVol
$LN34@ProcessVol:

; 667  : 
; 668  : 	case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
; 669  : 		{
; 670  : 			ULONG outLength;
; 671  : 			UNICODE_STRING ntUnicodeString;
; 672  : 			WCHAR ntName[256];
; 673  : 			PMOUNTDEV_SUGGESTED_LINK_NAME outputBuffer = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;

  00450	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00458	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0045c	48 89 84 24 38
	03 00 00	 mov	 QWORD PTR outputBuffer$30577[rsp], rax

; 674  : 
; 675  : 			if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_SUGGESTED_LINK_NAME), ValidateOutput))

  00464	41 b8 01 00 00
	00		 mov	 r8d, 1
  0046a	ba 06 00 00 00	 mov	 edx, 6
  0046f	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00477	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0047c	85 c0		 test	 eax, eax
  0047e	75 24		 jne	 SHORT $LN33@ProcessVol

; 676  : 			{
; 677  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00480	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00488	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 678  : 				Irp->IoStatus.Information = 0;

  0048f	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00497	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 679  : 				break; 

  0049f	e9 c0 08 00 00	 jmp	 $LN43@ProcessVol
$LN33@ProcessVol:

; 680  : 			}
; 681  : 
; 682  : 			GSTGetDosNameFromNumber (ntName, Extension->nDosDriveNo);

  004a4	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  004ac	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  004af	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR ntName$30576[rsp]
  004b7	e8 00 00 00 00	 call	 GSTGetDosNameFromNumber

; 683  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  004bc	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR ntName$30576[rsp]
  004c4	48 8d 8c 24 28
	03 00 00	 lea	 rcx, QWORD PTR ntUnicodeString$30575[rsp]
  004cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 684  : 
; 685  : 			outLength = FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME,Name) + ntUnicodeString.Length;

  004d2	0f b7 84 24 28
	03 00 00	 movzx	 eax, WORD PTR ntUnicodeString$30575[rsp]
  004da	83 c0 04	 add	 eax, 4
  004dd	89 84 24 40 05
	00 00		 mov	 DWORD PTR outLength$30574[rsp], eax

; 686  : 
; 687  : 			outputBuffer->UseOnlyIfThereAreNoOtherLinks = FALSE;

  004e4	48 8b 84 24 38
	03 00 00	 mov	 rax, QWORD PTR outputBuffer$30577[rsp]
  004ec	c6 00 00	 mov	 BYTE PTR [rax], 0

; 688  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  004ef	48 8b 8c 24 38
	03 00 00	 mov	 rcx, QWORD PTR outputBuffer$30577[rsp]
  004f7	0f b7 84 24 28
	03 00 00	 movzx	 eax, WORD PTR ntUnicodeString$30575[rsp]
  004ff	66 89 41 02	 mov	 WORD PTR [rcx+2], ax

; 689  : 
; 690  : 			if(irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00503	48 8b 4c 24 50	 mov	 rcx, QWORD PTR irpSp$[rsp]
  00508	8b 84 24 40 05
	00 00		 mov	 eax, DWORD PTR outLength$30574[rsp]
  0050f	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  00512	73 24		 jae	 SHORT $LN32@ProcessVol

; 691  : 			{
; 692  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_SUGGESTED_LINK_NAME);

  00514	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0051c	48 c7 40 38 06
	00 00 00	 mov	 QWORD PTR [rax+56], 6

; 693  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  00524	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0052c	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 694  : 				break;

  00533	e9 2c 08 00 00	 jmp	 $LN43@ProcessVol
$LN32@ProcessVol:

; 695  : 			}
; 696  : 
; 697  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  00538	0f b7 8c 24 28
	03 00 00	 movzx	 ecx, WORD PTR ntUnicodeString$30575[rsp]
  00540	48 8b bc 24 38
	03 00 00	 mov	 rdi, QWORD PTR outputBuffer$30577[rsp]
  00548	48 83 c7 04	 add	 rdi, 4
  0054c	48 8b b4 24 30
	03 00 00	 mov	 rsi, QWORD PTR ntUnicodeString$30575[rsp+8]
  00554	f3 a4		 rep movsb

; 698  : 		
; 699  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00556	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0055e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 700  : 			Irp->IoStatus.Information = outLength;

  00565	8b 8c 24 40 05
	00 00		 mov	 ecx, DWORD PTR outLength$30574[rsp]
  0056c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00574	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 701  : 
; 702  : 			Dump ("link = %ls\n",ntName);

  00578	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR ntName$30576[rsp]
  00580	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@
  00587	e8 00 00 00 00	 call	 DbgPrint

; 703  : 		}
; 704  : 		break;

  0058c	e9 d3 07 00 00	 jmp	 $LN43@ProcessVol
$LN31@ProcessVol:

; 705  : 
; 706  : 	case IOCTL_DISK_GET_MEDIA_TYPES:
; 707  : 	case IOCTL_DISK_GET_DRIVE_GEOMETRY:
; 708  : 		/* Return the drive geometry for the disk.  Note that we
; 709  : 		   return values which were made up to suit the disk size.  */
; 710  : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY), ValidateOutput))

  00591	41 b8 01 00 00
	00		 mov	 r8d, 1
  00597	ba 18 00 00 00	 mov	 edx, 24
  0059c	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  005a4	e8 00 00 00 00	 call	 ValidateIOBufferSize
  005a9	85 c0		 test	 eax, eax
  005ab	0f 84 d3 00 00
	00		 je	 $LN30@ProcessVol

; 711  : 		{
; 712  : 			PDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY)
; 713  : 			Irp->AssociatedIrp.SystemBuffer;

  005b1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  005b9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  005bd	48 89 84 24 48
	05 00 00	 mov	 QWORD PTR outputBuffer$30594[rsp], rax

; 714  : 
; 715  : 			outputBuffer->MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;

  005c5	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  005cd	83 b8 9c 03 00
	00 00		 cmp	 DWORD PTR [rax+924], 0
  005d4	74 0d		 je	 SHORT $LN47@ProcessVol
  005d6	c7 84 24 a4 05
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv218[rsp], 11
  005e1	eb 0b		 jmp	 SHORT $LN48@ProcessVol
$LN47@ProcessVol:
  005e3	c7 84 24 a4 05
	00 00 0c 00 00
	00		 mov	 DWORD PTR tv218[rsp], 12
$LN48@ProcessVol:
  005ee	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30594[rsp]
  005f6	8b 84 24 a4 05
	00 00		 mov	 eax, DWORD PTR tv218[rsp]
  005fd	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 716  : 			outputBuffer->Cylinders.QuadPart = Extension->NumberOfCylinders;

  00600	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30594[rsp]
  00608	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00610	48 8b 80 a8 00
	00 00		 mov	 rax, QWORD PTR [rax+168]
  00617	48 89 01	 mov	 QWORD PTR [rcx], rax

; 717  : 			outputBuffer->TracksPerCylinder = Extension->TracksPerCylinder;

  0061a	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30594[rsp]
  00622	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0062a	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [rax+176]
  00630	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 718  : 			outputBuffer->SectorsPerTrack = Extension->SectorsPerTrack;

  00633	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30594[rsp]
  0063b	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00643	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [rax+180]
  00649	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 719  : 			outputBuffer->BytesPerSector = Extension->BytesPerSector;

  0064c	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30594[rsp]
  00654	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0065c	8b 80 b8 00 00
	00		 mov	 eax, DWORD PTR [rax+184]
  00662	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 720  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00665	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0066d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 721  : 			Irp->IoStatus.Information = sizeof (DISK_GEOMETRY);

  00674	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0067c	48 c7 40 38 18
	00 00 00	 mov	 QWORD PTR [rax+56], 24
$LN30@ProcessVol:

; 722  : 		}
; 723  : 		break;

  00684	e9 db 06 00 00	 jmp	 $LN43@ProcessVol
$LN29@ProcessVol:

; 724  : 
; 725  : 	case IOCTL_DISK_GET_PARTITION_INFO:
; 726  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION), ValidateOutput))

  00689	41 b8 01 00 00
	00		 mov	 r8d, 1
  0068f	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00694	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0069c	e8 00 00 00 00	 call	 ValidateIOBufferSize
  006a1	85 c0		 test	 eax, eax
  006a3	0f 84 b4 00 00
	00		 je	 $LN28@ProcessVol

; 727  : 		{
; 728  : 			PPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)
; 729  : 			Irp->AssociatedIrp.SystemBuffer;

  006a9	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  006b1	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  006b5	48 89 84 24 50
	05 00 00	 mov	 QWORD PTR outputBuffer$30601[rsp], rax

; 730  : 
; 731  : 			outputBuffer->PartitionType = Extension->PartitionType;

  006bd	48 8b 8c 24 50
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30601[rsp]
  006c5	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  006cd	0f b6 80 bc 00
	00 00		 movzx	 eax, BYTE PTR [rax+188]
  006d4	88 41 18	 mov	 BYTE PTR [rcx+24], al

; 732  : 			outputBuffer->BootIndicator = FALSE;

  006d7	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30601[rsp]
  006df	c6 40 19 00	 mov	 BYTE PTR [rax+25], 0

; 733  : 			outputBuffer->RecognizedPartition = TRUE;

  006e3	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30601[rsp]
  006eb	c6 40 1a 01	 mov	 BYTE PTR [rax+26], 1

; 734  : 			outputBuffer->RewritePartition = FALSE;

  006ef	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30601[rsp]
  006f7	c6 40 1b 00	 mov	 BYTE PTR [rax+27], 0

; 735  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  006fb	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00703	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [rax+184]
  00709	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30601[rsp]
  00711	48 89 08	 mov	 QWORD PTR [rax], rcx

; 736  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  00714	48 8b 8c 24 50
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30601[rsp]
  0071c	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00724	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0072b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 737  : 			outputBuffer->HiddenSectors = 0;

  0072f	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30601[rsp]
  00737	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 738  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0073e	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00746	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 739  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);

  0074d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00755	48 c7 40 38 20
	00 00 00	 mov	 QWORD PTR [rax+56], 32	; 00000020H
$LN28@ProcessVol:

; 740  : 		}
; 741  : 		break;

  0075d	e9 02 06 00 00	 jmp	 $LN43@ProcessVol
$LN27@ProcessVol:

; 742  : 
; 743  : 	case IOCTL_DISK_GET_PARTITION_INFO_EX:
; 744  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION_EX), ValidateOutput))

  00762	41 b8 01 00 00
	00		 mov	 r8d, 1
  00768	ba 90 00 00 00	 mov	 edx, 144		; 00000090H
  0076d	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00775	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0077a	85 c0		 test	 eax, eax
  0077c	0f 84 c3 00 00
	00		 je	 $LN26@ProcessVol

; 745  : 		{
; 746  : 			PPARTITION_INFORMATION_EX outputBuffer = (PPARTITION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;

  00782	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0078a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0078e	48 89 84 24 58
	05 00 00	 mov	 QWORD PTR outputBuffer$30608[rsp], rax

; 747  : 
; 748  : 			outputBuffer->PartitionStyle = PARTITION_STYLE_MBR;

  00796	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30608[rsp]
  0079e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 749  : 			outputBuffer->RewritePartition = FALSE;

  007a4	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30608[rsp]
  007ac	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 750  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  007b0	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  007b8	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [rax+184]
  007be	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30608[rsp]
  007c6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 751  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  007ca	48 8b 8c 24 58
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30608[rsp]
  007d2	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  007da	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  007e1	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 752  : 			outputBuffer->Mbr.PartitionType = Extension->PartitionType;

  007e5	48 8b 8c 24 58
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30608[rsp]
  007ed	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  007f5	0f b6 80 bc 00
	00 00		 movzx	 eax, BYTE PTR [rax+188]
  007fc	88 41 20	 mov	 BYTE PTR [rcx+32], al

; 753  : 			outputBuffer->Mbr.BootIndicator = FALSE;

  007ff	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30608[rsp]
  00807	c6 40 21 00	 mov	 BYTE PTR [rax+33], 0

; 754  : 			outputBuffer->Mbr.RecognizedPartition = TRUE;

  0080b	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30608[rsp]
  00813	c6 40 22 01	 mov	 BYTE PTR [rax+34], 1

; 755  : 			outputBuffer->Mbr.HiddenSectors = 0;

  00817	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30608[rsp]
  0081f	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 756  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00826	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0082e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 757  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION_EX);

  00835	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0083d	48 c7 40 38 90
	00 00 00	 mov	 QWORD PTR [rax+56], 144	; 00000090H
$LN26@ProcessVol:

; 758  : 		}
; 759  : 		break;

  00845	e9 1a 05 00 00	 jmp	 $LN43@ProcessVol
$LN25@ProcessVol:

; 760  : 
; 761  : 	case IOCTL_DISK_GET_DRIVE_LAYOUT:
; 762  : 		if (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION), ValidateOutput))

  0084a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00850	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00855	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0085d	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00862	85 c0		 test	 eax, eax
  00864	0f 84 d2 00 00
	00		 je	 $LN24@ProcessVol

; 763  : 		{
; 764  : 			PDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION)
; 765  : 			Irp->AssociatedIrp.SystemBuffer;

  0086a	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00872	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00876	48 89 84 24 60
	05 00 00	 mov	 QWORD PTR outputBuffer$30615[rsp], rax

; 766  : 
; 767  : 			outputBuffer->PartitionCount = 1;

  0087e	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30615[rsp]
  00886	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 768  : 			outputBuffer->Signature = 0;

  0088c	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30615[rsp]
  00894	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 769  : 
; 770  : 			outputBuffer->PartitionEntry->PartitionType = Extension->PartitionType;

  0089b	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30615[rsp]
  008a3	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  008ab	0f b6 80 bc 00
	00 00		 movzx	 eax, BYTE PTR [rax+188]
  008b2	88 41 20	 mov	 BYTE PTR [rcx+32], al

; 771  : 			outputBuffer->PartitionEntry->BootIndicator = FALSE;

  008b5	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30615[rsp]
  008bd	c6 40 21 00	 mov	 BYTE PTR [rax+33], 0

; 772  : 			outputBuffer->PartitionEntry->RecognizedPartition = TRUE;

  008c1	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30615[rsp]
  008c9	c6 40 22 01	 mov	 BYTE PTR [rax+34], 1

; 773  : 			outputBuffer->PartitionEntry->RewritePartition = FALSE;

  008cd	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30615[rsp]
  008d5	c6 40 23 00	 mov	 BYTE PTR [rax+35], 0

; 774  : 			outputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;

  008d9	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  008e1	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [rax+184]
  008e7	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30615[rsp]
  008ef	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 775  : 			outputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;

  008f3	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30615[rsp]
  008fb	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00903	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0090a	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 776  : 			outputBuffer->PartitionEntry->HiddenSectors = 0;

  0090e	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$30615[rsp]
  00916	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 777  : 
; 778  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0091d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00925	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 779  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);

  0092c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00934	48 c7 40 38 20
	00 00 00	 mov	 QWORD PTR [rax+56], 32	; 00000020H
$LN24@ProcessVol:

; 780  : 		}
; 781  : 		break;

  0093c	e9 23 04 00 00	 jmp	 $LN43@ProcessVol
$LN23@ProcessVol:

; 782  : 
; 783  : 	case IOCTL_DISK_GET_LENGTH_INFO:
; 784  : 		if (!ValidateIOBufferSize (Irp, sizeof (GET_LENGTH_INFORMATION), ValidateOutput))

  00941	41 b8 01 00 00
	00		 mov	 r8d, 1
  00947	ba 08 00 00 00	 mov	 edx, 8
  0094c	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00954	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00959	85 c0		 test	 eax, eax
  0095b	75 21		 jne	 SHORT $LN22@ProcessVol

; 785  : 		{
; 786  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  0095d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00965	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 787  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);

  0096c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00974	48 c7 40 38 08
	00 00 00	 mov	 QWORD PTR [rax+56], 8

; 788  : 		}
; 789  : 		else

  0097c	eb 4d		 jmp	 SHORT $LN21@ProcessVol
$LN22@ProcessVol:

; 790  : 		{
; 791  : 			PGET_LENGTH_INFORMATION outputBuffer = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

  0097e	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00986	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0098a	48 89 84 24 68
	05 00 00	 mov	 QWORD PTR outputBuffer$30625[rsp], rax

; 792  : 
; 793  : 			outputBuffer->Length.QuadPart = Extension->DiskLength;

  00992	48 8b 8c 24 68
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$30625[rsp]
  0099a	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  009a2	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  009a9	48 89 01	 mov	 QWORD PTR [rcx], rax

; 794  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  009ac	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  009b4	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 795  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);

  009bb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  009c3	48 c7 40 38 08
	00 00 00	 mov	 QWORD PTR [rax+56], 8
$LN21@ProcessVol:

; 796  : 		}
; 797  : 		break;

  009cb	e9 94 03 00 00	 jmp	 $LN43@ProcessVol
$LN20@ProcessVol:

; 798  : 
; 799  : 	case IOCTL_DISK_VERIFY:
; 800  : 		if (ValidateIOBufferSize (Irp, sizeof (VERIFY_INFORMATION), ValidateInput))

  009d0	45 33 c0	 xor	 r8d, r8d
  009d3	ba 10 00 00 00	 mov	 edx, 16
  009d8	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  009e0	e8 00 00 00 00	 call	 ValidateIOBufferSize
  009e5	85 c0		 test	 eax, eax
  009e7	0f 84 fa 01 00
	00		 je	 $LN19@ProcessVol

; 801  : 		{
; 802  : 			PVERIFY_INFORMATION pVerifyInformation;
; 803  : 			pVerifyInformation = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

  009ed	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  009f5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  009f9	48 89 84 24 70
	05 00 00	 mov	 QWORD PTR pVerifyInformation$30632[rsp], rax

; 804  : 
; 805  : 			if (pVerifyInformation->StartingOffset.QuadPart + pVerifyInformation->Length > Extension->DiskLength)

  00a01	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$30632[rsp]
  00a09	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00a0c	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$30632[rsp]
  00a14	48 03 08	 add	 rcx, QWORD PTR [rax]
  00a17	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00a1f	48 3b 88 a0 00
	00 00		 cmp	 rcx, QWORD PTR [rax+160]
  00a26	7e 14		 jle	 SHORT $LN18@ProcessVol

; 806  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00a28	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00a30	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 807  : 			else

  00a37	e9 9b 01 00 00	 jmp	 $LN17@ProcessVol
$LN18@ProcessVol:

; 808  : 			{
; 809  : 				IO_STATUS_BLOCK ioStatus;
; 810  : 				PVOID buffer = GSTalloc (max (pVerifyInformation->Length, PAGE_SIZE));

  00a3c	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$30632[rsp]
  00a44	81 78 08 00 10
	00 00		 cmp	 DWORD PTR [rax+8], 4096	; 00001000H
  00a4b	76 14		 jbe	 SHORT $LN49@ProcessVol
  00a4d	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$30632[rsp]
  00a55	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00a58	89 84 24 a8 05
	00 00		 mov	 DWORD PTR tv313[rsp], eax
  00a5f	eb 0b		 jmp	 SHORT $LN50@ProcessVol
$LN49@ProcessVol:
  00a61	c7 84 24 a8 05
	00 00 00 10 00
	00		 mov	 DWORD PTR tv313[rsp], 4096 ; 00001000H
$LN50@ProcessVol:
  00a6c	8b 94 24 a8 05
	00 00		 mov	 edx, DWORD PTR tv313[rsp]
  00a73	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00a79	33 c9		 xor	 ecx, ecx
  00a7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00a81	48 89 84 24 78
	05 00 00	 mov	 QWORD PTR buffer$30638[rsp], rax

; 811  : 				
; 812  : 				if (!buffer)

  00a89	48 83 bc 24 78
	05 00 00 00	 cmp	 QWORD PTR buffer$30638[rsp], 0
  00a92	75 14		 jne	 SHORT $LN16@ProcessVol

; 813  : 				{
; 814  : 					Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  00a94	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00a9c	c7 40 30 9a 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741670 ; ffffffffc000009aH

; 815  : 				}
; 816  : 				else

  00aa3	e9 2f 01 00 00	 jmp	 $LN15@ProcessVol
$LN16@ProcessVol:

; 817  : 				{
; 818  : 					LARGE_INTEGER offset = pVerifyInformation->StartingOffset;

  00aa8	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$30632[rsp]
  00ab0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ab3	48 89 84 24 90
	05 00 00	 mov	 QWORD PTR offset$30643[rsp], rax

; 819  : 					offset.QuadPart += Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset;

  00abb	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00ac3	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00aca	83 b8 48 04 00
	00 00		 cmp	 DWORD PTR [rax+1096], 0
  00ad1	74 20		 je	 SHORT $LN51@ProcessVol
  00ad3	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00adb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00ae2	48 8b 80 c0 1e
	00 00		 mov	 rax, QWORD PTR [rax+7872]
  00ae9	48 89 84 24 b0
	05 00 00	 mov	 QWORD PTR tv359[rsp], rax
  00af1	eb 1e		 jmp	 SHORT $LN52@ProcessVol
$LN51@ProcessVol:
  00af3	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00afb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00b02	48 8b 80 b0 1e
	00 00		 mov	 rax, QWORD PTR [rax+7856]
  00b09	48 89 84 24 b0
	05 00 00	 mov	 QWORD PTR tv359[rsp], rax
$LN52@ProcessVol:
  00b11	48 8b 8c 24 b0
	05 00 00	 mov	 rcx, QWORD PTR tv359[rsp]
  00b19	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR offset$30643[rsp]
  00b21	48 03 c1	 add	 rax, rcx
  00b24	48 89 84 24 90
	05 00 00	 mov	 QWORD PTR offset$30643[rsp], rax

; 820  : 
; 821  : 					Irp->IoStatus.Status = ZwReadFile (Extension->hDeviceFile, NULL, NULL, NULL, &ioStatus, buffer, pVerifyInformation->Length, &offset, NULL);

  00b2c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00b35	48 8d 84 24 90
	05 00 00	 lea	 rax, QWORD PTR offset$30643[rsp]
  00b3d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00b42	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$30632[rsp]
  00b4a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00b4d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00b51	48 8b 84 24 78
	05 00 00	 mov	 rax, QWORD PTR buffer$30638[rsp]
  00b59	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b5e	48 8d 84 24 80
	05 00 00	 lea	 rax, QWORD PTR ioStatus$30637[rsp]
  00b66	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b6b	45 33 c9	 xor	 r9d, r9d
  00b6e	45 33 c0	 xor	 r8d, r8d
  00b71	33 d2		 xor	 edx, edx
  00b73	48 8b 8c 24 e8
	05 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00b7b	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00b7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  00b85	8b d0		 mov	 edx, eax
  00b87	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00b8f	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 822  : 					GSTfree (buffer);

  00b92	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00b97	48 8b 8c 24 78
	05 00 00	 mov	 rcx, QWORD PTR buffer$30638[rsp]
  00b9f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 823  : 
; 824  : 					if (NT_SUCCESS (Irp->IoStatus.Status) && ioStatus.Information != pVerifyInformation->Length)

  00ba5	48 8b 94 24 f0
	05 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00bad	83 7a 30 00	 cmp	 DWORD PTR [rdx+48], 0
  00bb1	7c 24		 jl	 SHORT $LN14@ProcessVol
  00bb3	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$30632[rsp]
  00bbb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00bbe	48 39 84 24 88
	05 00 00	 cmp	 QWORD PTR ioStatus$30637[rsp+8], rax
  00bc6	74 0f		 je	 SHORT $LN14@ProcessVol

; 825  : 						Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00bc8	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00bd0	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH
$LN14@ProcessVol:
$LN15@ProcessVol:
$LN17@ProcessVol:

; 826  : 				}
; 827  : 			}
; 828  : 
; 829  : 			Irp->IoStatus.Information = 0;

  00bd7	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00bdf	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN19@ProcessVol:

; 830  : 		}
; 831  : 		break;

  00be7	e9 78 01 00 00	 jmp	 $LN43@ProcessVol
$LN13@ProcessVol:

; 832  : 
; 833  : 	case IOCTL_DISK_CHECK_VERIFY:
; 834  : 	case IOCTL_STORAGE_CHECK_VERIFY:
; 835  : 		{
; 836  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00bec	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00bf4	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 837  : 			Irp->IoStatus.Information = 0;

  00bfb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c03	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 838  : 
; 839  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (ULONG))

  00c0b	48 8b 44 24 50	 mov	 rax, QWORD PTR irpSp$[rsp]
  00c10	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00c13	48 83 f8 04	 cmp	 rax, 4
  00c17	72 22		 jb	 SHORT $LN12@ProcessVol

; 840  : 			{
; 841  : 				*((ULONG *) Irp->AssociatedIrp.SystemBuffer) = 0;

  00c19	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c21	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00c25	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 842  : 				Irp->IoStatus.Information = sizeof (ULONG);

  00c2b	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c33	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4
$LN12@ProcessVol:

; 843  : 			}
; 844  : 		}
; 845  : 		break;

  00c3b	e9 24 01 00 00	 jmp	 $LN43@ProcessVol
$LN11@ProcessVol:

; 846  : 
; 847  : 	case IOCTL_DISK_IS_WRITABLE:
; 848  : 		{
; 849  : 			if (Extension->bReadOnly)

  00c40	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00c48	83 b8 98 03 00
	00 00		 cmp	 DWORD PTR [rax+920], 0
  00c4f	74 11		 je	 SHORT $LN10@ProcessVol

; 850  : 				Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;

  00c51	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c59	c7 40 30 a2 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741662 ; ffffffffc00000a2H

; 851  : 			else

  00c60	eb 0f		 jmp	 SHORT $LN9@ProcessVol
$LN10@ProcessVol:

; 852  : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  00c62	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c6a	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN9@ProcessVol:

; 853  : 			Irp->IoStatus.Information = 0;

  00c71	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c79	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 854  : 
; 855  : 		}
; 856  : 		break;

  00c81	e9 de 00 00 00	 jmp	 $LN43@ProcessVol
$LN8@ProcessVol:

; 857  : 		
; 858  : 	case IOCTL_VOLUME_ONLINE:
; 859  : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  00c86	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c8e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 860  : 		Irp->IoStatus.Information = 0;

  00c95	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c9d	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 861  : 		break;

  00ca5	e9 ba 00 00 00	 jmp	 $LN43@ProcessVol
$LN7@ProcessVol:

; 862  : 
; 863  : 	case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
; 864  : 
; 865  : 		// Vista's filesystem defragmenter fails if IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS does not succeed.
; 866  : 		if (!(OsMajorVersion == 6 && OsMinorVersion == 0))

  00caa	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR OsMajorVersion, 6
  00cb1	75 09		 jne	 SHORT $LN5@ProcessVol
  00cb3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMinorVersion, 0
  00cba	74 21		 je	 SHORT $LN6@ProcessVol
$LN5@ProcessVol:

; 867  : 		{
; 868  : 			Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

  00cbc	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00cc4	c7 40 30 10 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741808 ; ffffffffc0000010H

; 869  : 			Irp->IoStatus.Information = 0;

  00ccb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00cd3	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
  00cdb	eb 6e		 jmp	 SHORT $LN4@ProcessVol
$LN6@ProcessVol:

; 870  : 		}
; 871  : 		else if (ValidateIOBufferSize (Irp, sizeof (VOLUME_DISK_EXTENTS), ValidateOutput))

  00cdd	41 b8 01 00 00
	00		 mov	 r8d, 1
  00ce3	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00ce8	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00cf0	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00cf5	85 c0		 test	 eax, eax
  00cf7	74 52		 je	 SHORT $LN3@ProcessVol

; 872  : 		{
; 873  : 			VOLUME_DISK_EXTENTS *extents = (VOLUME_DISK_EXTENTS *) Irp->AssociatedIrp.SystemBuffer;

  00cf9	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d01	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00d05	48 89 84 24 98
	05 00 00	 mov	 QWORD PTR extents$30671[rsp], rax

; 874  : 
; 875  : 			// No extent data can be returned as this is not a physical drive.
; 876  : 			memset (extents, 0, sizeof (*extents));

  00d0d	48 8b bc 24 98
	05 00 00	 mov	 rdi, QWORD PTR extents$30671[rsp]
  00d15	33 c0		 xor	 eax, eax
  00d17	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00d1c	f3 aa		 rep stosb

; 877  : 			extents->NumberOfDiskExtents = 0;

  00d1e	48 8b 84 24 98
	05 00 00	 mov	 rax, QWORD PTR extents$30671[rsp]
  00d26	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 878  : 
; 879  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00d2c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d34	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 880  : 			Irp->IoStatus.Information = sizeof (*extents);

  00d3b	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d43	48 c7 40 38 20
	00 00 00	 mov	 QWORD PTR [rax+56], 32	; 00000020H
$LN3@ProcessVol:
$LN4@ProcessVol:

; 881  : 		}
; 882  : 		break;

  00d4b	eb 17		 jmp	 SHORT $LN43@ProcessVol
$LN2@ProcessVol:

; 883  : 
; 884  : 	default:
; 885  : 		return GSTCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  00d4d	45 33 c0	 xor	 r8d, r8d
  00d50	ba 10 00 00 c0	 mov	 edx, -1073741808	; ffffffffc0000010H
  00d55	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00d5d	e8 00 00 00 00	 call	 GSTCompleteIrp
  00d62	eb 6a		 jmp	 SHORT $LN45@ProcessVol
$LN43@ProcessVol:

; 886  : 	}
; 887  : 
; 888  : #ifdef DEBUG
; 889  : 	if (!NT_SUCCESS (Irp->IoStatus.Status))

  00d64	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d6c	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00d70	7d 38		 jge	 SHORT $LN1@ProcessVol

; 890  : 	{
; 891  : 		Dump ("IOCTL error 0x%08x (0x%x %d)\n",
; 892  : 			Irp->IoStatus.Status,
; 893  : 			(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 894  : 			(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));

  00d72	48 8b 44 24 50	 mov	 rax, QWORD PTR irpSp$[rsp]
  00d77	44 8b 48 18	 mov	 r9d, DWORD PTR [rax+24]
  00d7b	41 81 e1 ff 1f
	00 00		 and	 r9d, 8191		; 00001fffH
  00d82	41 c1 e9 02	 shr	 r9d, 2
  00d86	48 8b 44 24 50	 mov	 rax, QWORD PTR irpSp$[rsp]
  00d8b	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  00d8f	41 c1 e8 10	 shr	 r8d, 16
  00d93	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d9b	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  00d9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
  00da5	e8 00 00 00 00	 call	 DbgPrint
$LN1@ProcessVol:

; 895  : 	}
; 896  : #endif
; 897  : 
; 898  : 	return GSTCompleteDiskIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  00daa	4c 8b 84 24 f0
	05 00 00	 mov	 r8, QWORD PTR Irp$[rsp]
  00db2	4d 8b 40 38	 mov	 r8, QWORD PTR [r8+56]
  00db6	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00dbe	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  00dc1	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00dc9	e8 00 00 00 00	 call	 GSTCompleteDiskIrp
$LN45@ProcessVol:

; 899  : }

  00dce	48 8b 8c 24 b8
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00dd6	48 33 cc	 xor	 rcx, rsp
  00dd9	e8 00 00 00 00	 call	 __security_check_cookie
  00dde	48 81 c4 c8 05
	00 00		 add	 rsp, 1480		; 000005c8H
  00de5	5f		 pop	 rdi
  00de6	5e		 pop	 rsi
  00de7	c3		 ret	 0
ProcessVolumeDeviceControlIrp ENDP
PUBLIC	ReadDeviceSkipUnreadableSectors
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadDeviceSkipUnreadableSectors DD imagerel $LN8
	DD	imagerel $LN8+239
	DD	imagerel $unwind$ReadDeviceSkipUnreadableSectors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadDeviceSkipUnreadableSectors DD 021901H
	DD	070155219H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReadDeviceSkipUnreadableSectors
_TEXT	SEGMENT
sectorSize$ = 32
status$ = 36
sectorCount$ = 40
deviceObject$ = 64
buffer$ = 72
startOffset$ = 80
size$ = 88
badSectorCount$ = 96
ReadDeviceSkipUnreadableSectors PROC			; COMDAT

; 3752 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3753 : 	NTSTATUS status;
; 3754 : 	ULONG sectorSize;
; 3755 : 	ULONG sectorCount;
; 3756 : 
; 3757 : 	*badSectorCount = 0;

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR badSectorCount$[rsp]
  0001e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3758 : 
; 3759 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  00025	48 8d 54 24 20	 lea	 rdx, QWORD PTR sectorSize$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  0002f	e8 00 00 00 00	 call	 GetDeviceSectorSize
  00034	89 44 24 24	 mov	 DWORD PTR status$[rsp], eax

; 3760 : 	if (!NT_SUCCESS (status))

  00038	83 7c 24 24 00	 cmp	 DWORD PTR status$[rsp], 0
  0003d	7d 09		 jge	 SHORT $LN5@ReadDevice

; 3761 : 		return status;

  0003f	8b 44 24 24	 mov	 eax, DWORD PTR status$[rsp]
  00043	e9 a1 00 00 00	 jmp	 $LN6@ReadDevice
$LN5@ReadDevice:

; 3762 : 
; 3763 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize, buffer += sectorSize)

  00048	33 d2		 xor	 edx, edx
  0004a	8b 44 24 58	 mov	 eax, DWORD PTR size$[rsp]
  0004e	f7 74 24 20	 div	 DWORD PTR sectorSize$[rsp]
  00052	89 44 24 28	 mov	 DWORD PTR sectorCount$[rsp], eax
  00056	eb 2d		 jmp	 SHORT $LN4@ReadDevice
$LN3@ReadDevice:
  00058	8b 44 24 28	 mov	 eax, DWORD PTR sectorCount$[rsp]
  0005c	83 e8 01	 sub	 eax, 1
  0005f	89 44 24 28	 mov	 DWORD PTR sectorCount$[rsp], eax
  00063	8b 4c 24 20	 mov	 ecx, DWORD PTR sectorSize$[rsp]
  00067	48 8b 44 24 50	 mov	 rax, QWORD PTR startOffset$[rsp]
  0006c	48 03 c1	 add	 rax, rcx
  0006f	48 89 44 24 50	 mov	 QWORD PTR startOffset$[rsp], rax
  00074	8b 4c 24 20	 mov	 ecx, DWORD PTR sectorSize$[rsp]
  00078	48 8b 44 24 48	 mov	 rax, QWORD PTR buffer$[rsp]
  0007d	48 03 c1	 add	 rax, rcx
  00080	48 89 44 24 48	 mov	 QWORD PTR buffer$[rsp], rax
$LN4@ReadDevice:
  00085	83 7c 24 28 00	 cmp	 DWORD PTR sectorCount$[rsp], 0
  0008a	76 5b		 jbe	 SHORT $LN2@ReadDevice

; 3764 : 	{
; 3765 : 		status = GSTReadDevice (deviceObject, buffer, startOffset, sectorSize);

  0008c	44 8b 4c 24 20	 mov	 r9d, DWORD PTR sectorSize$[rsp]
  00091	4c 8b 44 24 50	 mov	 r8, QWORD PTR startOffset$[rsp]
  00096	48 8b 54 24 48	 mov	 rdx, QWORD PTR buffer$[rsp]
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000a0	e8 00 00 00 00	 call	 GSTReadDevice
  000a5	89 44 24 24	 mov	 DWORD PTR status$[rsp], eax

; 3766 : 		if (!NT_SUCCESS (status))

  000a9	83 7c 24 24 00	 cmp	 DWORD PTR status$[rsp], 0
  000ae	7d 32		 jge	 SHORT $LN1@ReadDevice

; 3767 : 		{
; 3768 : 			Dump ("Skipping bad sector at %I64d\n", startOffset.QuadPart);

  000b0	48 8b 54 24 50	 mov	 rdx, QWORD PTR startOffset$[rsp]
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
  000bc	e8 00 00 00 00	 call	 DbgPrint

; 3769 : 			memset (buffer, 0, sectorSize);

  000c1	8b 4c 24 20	 mov	 ecx, DWORD PTR sectorSize$[rsp]
  000c5	48 8b 7c 24 48	 mov	 rdi, QWORD PTR buffer$[rsp]
  000ca	33 c0		 xor	 eax, eax
  000cc	f3 aa		 rep stosb

; 3770 : 			++(*badSectorCount);

  000ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR badSectorCount$[rsp]
  000d3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d6	48 83 c1 01	 add	 rcx, 1
  000da	48 8b 44 24 60	 mov	 rax, QWORD PTR badSectorCount$[rsp]
  000df	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@ReadDevice:

; 3771 : 		}
; 3772 : 	}

  000e2	e9 71 ff ff ff	 jmp	 $LN3@ReadDevice
$LN2@ReadDevice:

; 3773 : 
; 3774 : 	return STATUS_SUCCESS;

  000e7	33 c0		 xor	 eax, eax
$LN6@ReadDevice:

; 3775 : }

  000e9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ed	5f		 pop	 rdi
  000ee	c3		 ret	 0
ReadDeviceSkipUnreadableSectors ENDP
_TEXT	ENDS
PUBLIC	ZeroUnreadableSectors
;	COMDAT pdata
pdata	SEGMENT
$pdata$ZeroUnreadableSectors DD imagerel $LN11
	DD	imagerel $LN11+348
	DD	imagerel $unwind$ZeroUnreadableSectors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ZeroUnreadableSectors DD 021901H
	DD	070157219H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ZeroUnreadableSectors
_TEXT	SEGMENT
sectorSize$ = 32
sectorBuffer$ = 40
status$ = 48
sectorCount$ = 52
deviceObject$ = 80
startOffset$ = 88
size$ = 96
zeroedSectorCount$ = 104
ZeroUnreadableSectors PROC				; COMDAT

; 3697 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3698 : 	NTSTATUS status;
; 3699 : 	ULONG sectorSize;
; 3700 : 	ULONG sectorCount;
; 3701 : 	byte *sectorBuffer = NULL;

  00019	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR sectorBuffer$[rsp], 0

; 3702 : 
; 3703 : 	*zeroedSectorCount = 0;

  00022	48 8b 44 24 68	 mov	 rax, QWORD PTR zeroedSectorCount$[rsp]
  00027	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3704 : 
; 3705 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  0002e	48 8d 54 24 20	 lea	 rdx, QWORD PTR sectorSize$[rsp]
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00038	e8 00 00 00 00	 call	 GetDeviceSectorSize
  0003d	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 3706 : 	if (!NT_SUCCESS (status))

  00041	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00046	7d 09		 jge	 SHORT $LN8@ZeroUnread

; 3707 : 		return status;

  00048	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
  0004c	e9 05 01 00 00	 jmp	 $LN9@ZeroUnread
$LN8@ZeroUnread:

; 3708 : 
; 3709 : 	sectorBuffer = GSTalloc (sectorSize);

  00051	8b 54 24 20	 mov	 edx, DWORD PTR sectorSize$[rsp]
  00055	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0005b	33 c9		 xor	 ecx, ecx
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00063	48 89 44 24 28	 mov	 QWORD PTR sectorBuffer$[rsp], rax

; 3710 : 	if (!sectorBuffer)

  00068	48 83 7c 24 28
	00		 cmp	 QWORD PTR sectorBuffer$[rsp], 0
  0006e	75 0a		 jne	 SHORT $LN7@ZeroUnread

; 3711 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00070	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00075	e9 dc 00 00 00	 jmp	 $LN9@ZeroUnread
$LN7@ZeroUnread:

; 3712 : 
; 3713 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)

  0007a	33 d2		 xor	 edx, edx
  0007c	8b 44 24 60	 mov	 eax, DWORD PTR size$[rsp]
  00080	f7 74 24 20	 div	 DWORD PTR sectorSize$[rsp]
  00084	89 44 24 34	 mov	 DWORD PTR sectorCount$[rsp], eax
  00088	eb 1c		 jmp	 SHORT $LN6@ZeroUnread
$LN5@ZeroUnread:
  0008a	8b 44 24 34	 mov	 eax, DWORD PTR sectorCount$[rsp]
  0008e	83 e8 01	 sub	 eax, 1
  00091	89 44 24 34	 mov	 DWORD PTR sectorCount$[rsp], eax
  00095	8b 4c 24 20	 mov	 ecx, DWORD PTR sectorSize$[rsp]
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR startOffset$[rsp]
  0009e	48 03 c1	 add	 rax, rcx
  000a1	48 89 44 24 58	 mov	 QWORD PTR startOffset$[rsp], rax
$LN6@ZeroUnread:
  000a6	83 7c 24 34 00	 cmp	 DWORD PTR sectorCount$[rsp], 0
  000ab	0f 86 81 00 00
	00		 jbe	 $LN4@ZeroUnread

; 3714 : 	{
; 3715 : 		status = GSTReadDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  000b1	44 8b 4c 24 20	 mov	 r9d, DWORD PTR sectorSize$[rsp]
  000b6	4c 8b 44 24 58	 mov	 r8, QWORD PTR startOffset$[rsp]
  000bb	48 8b 54 24 28	 mov	 rdx, QWORD PTR sectorBuffer$[rsp]
  000c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000c5	e8 00 00 00 00	 call	 GSTReadDevice
  000ca	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 3716 : 		if (!NT_SUCCESS (status))

  000ce	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  000d3	7d 58		 jge	 SHORT $LN3@ZeroUnread

; 3717 : 		{
; 3718 : 			Dump ("Zeroing sector at %I64d\n", startOffset.QuadPart);

  000d5	48 8b 54 24 58	 mov	 rdx, QWORD PTR startOffset$[rsp]
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
  000e1	e8 00 00 00 00	 call	 DbgPrint

; 3719 : 			memset (sectorBuffer, 0, sectorSize);

  000e6	8b 4c 24 20	 mov	 ecx, DWORD PTR sectorSize$[rsp]
  000ea	48 8b 7c 24 28	 mov	 rdi, QWORD PTR sectorBuffer$[rsp]
  000ef	33 c0		 xor	 eax, eax
  000f1	f3 aa		 rep stosb

; 3720 : 
; 3721 : 			status = GSTWriteDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  000f3	44 8b 4c 24 20	 mov	 r9d, DWORD PTR sectorSize$[rsp]
  000f8	4c 8b 44 24 58	 mov	 r8, QWORD PTR startOffset$[rsp]
  000fd	48 8b 54 24 28	 mov	 rdx, QWORD PTR sectorBuffer$[rsp]
  00102	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00107	e8 00 00 00 00	 call	 GSTWriteDevice
  0010c	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 3722 : 			if (!NT_SUCCESS (status))

  00110	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00115	7d 02		 jge	 SHORT $LN2@ZeroUnread

; 3723 : 				goto err;

  00117	eb 21		 jmp	 SHORT $err$32271
$LN2@ZeroUnread:

; 3724 : 
; 3725 : 			++(*zeroedSectorCount);

  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR zeroedSectorCount$[rsp]
  0011e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00121	48 83 c1 01	 add	 rcx, 1
  00125	48 8b 44 24 68	 mov	 rax, QWORD PTR zeroedSectorCount$[rsp]
  0012a	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@ZeroUnread:

; 3726 : 		}
; 3727 : 	}

  0012d	e9 58 ff ff ff	 jmp	 $LN5@ZeroUnread
$LN4@ZeroUnread:

; 3728 : 
; 3729 : 	status = STATUS_SUCCESS;

  00132	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0
$err$32271:

; 3730 : 
; 3731 : err:
; 3732 : 	if (sectorBuffer)

  0013a	48 83 7c 24 28
	00		 cmp	 QWORD PTR sectorBuffer$[rsp], 0
  00140	74 10		 je	 SHORT $LN1@ZeroUnread

; 3733 : 		GSTfree (sectorBuffer);

  00142	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00147	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sectorBuffer$[rsp]
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN1@ZeroUnread:

; 3734 : 
; 3735 : 	return status;

  00152	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
$LN9@ZeroUnread:

; 3736 : }

  00156	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0015a	5f		 pop	 rdi
  0015b	c3		 ret	 0
ZeroUnreadableSectors ENDP
_TEXT	ENDS
PUBLIC	UserCanAccessDriveDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$UserCanAccessDriveDevice DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$UserCanAccessDriveDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UserCanAccessDriveDevice DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT UserCanAccessDriveDevice
_TEXT	SEGMENT
name$ = 32
UserCanAccessDriveDevice PROC				; COMDAT

; 3308 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3309 : 	UNICODE_STRING name;
; 3310 : 	RtlInitUnicodeString (&name, L"\\Device\\MountPointManager");

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0000b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3311 : 
; 3312 : 	return IsAccessibleByUser (&name, FALSE);

  00016	33 d2		 xor	 edx, edx
  00018	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  0001d	e8 00 00 00 00	 call	 IsAccessibleByUser

; 3313 : }

  00022	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00026	c3		 ret	 0
UserCanAccessDriveDevice ENDP
_TEXT	ENDS
PUBLIC	UnmountDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnmountDevice DD imagerel $LN23
	DD	imagerel $LN23+822
	DD	imagerel $unwind$UnmountDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnmountDevice DD 021601H
	DD	0190116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT UnmountDevice
_TEXT	SEGMENT
volumeFileObject$ = 48
volumeHandle$ = 56
extension$ = 64
ntStatus$ = 72
dismountRetry$31926 = 76
ntfsData$31928 = 80
cryptoInfo$31962 = 176
tv168 = 184
tv184 = 188
unmountRequest$ = 208
deviceObject$ = 216
ignoreOpenFiles$ = 224
UnmountDevice PROC					; COMDAT

; 3012 : {

$LN23:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 3013 : 	PEXTENSION extension = deviceObject->DeviceExtension;

  00016	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR deviceObject$[rsp]
  0001e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00022	48 89 44 24 40	 mov	 QWORD PTR extension$[rsp], rax

; 3014 : 	NTSTATUS ntStatus;
; 3015 : 	HANDLE volumeHandle;
; 3016 : 	PFILE_OBJECT volumeFileObject;
; 3017 : 
; 3018 : 	Dump ("UnmountDevice %d\n", extension->nDosDriveNo);

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR extension$[rsp]
  0002c	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@
  00036	e8 00 00 00 00	 call	 DbgPrint

; 3019 : 
; 3020 : 	ntStatus = GSTOpenFsVolume (extension, &volumeHandle, &volumeFileObject);

  0003b	4c 8d 44 24 30	 lea	 r8, QWORD PTR volumeFileObject$[rsp]
  00040	48 8d 54 24 38	 lea	 rdx, QWORD PTR volumeHandle$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR extension$[rsp]
  0004a	e8 00 00 00 00	 call	 GSTOpenFsVolume
  0004f	89 44 24 48	 mov	 DWORD PTR ntStatus$[rsp], eax

; 3021 : 
; 3022 : 	if (NT_SUCCESS (ntStatus))

  00053	83 7c 24 48 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00058	0f 8c 55 01 00
	00		 jl	 $LN16@UnmountDev

; 3023 : 	{
; 3024 : 		int dismountRetry;
; 3025 : 
; 3026 : 		// Dismounting a writable NTFS filesystem prevents the driver from being unloaded on Windows 7
; 3027 : 		if (IsOSAtLeast (WIN_7) && !extension->bReadOnly)

  0005e	b9 0d 00 00 00	 mov	 ecx, 13
  00063	e8 00 00 00 00	 call	 IsOSAtLeast
  00068	85 c0		 test	 eax, eax
  0006a	74 43		 je	 SHORT $LN15@UnmountDev
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR extension$[rsp]
  00071	83 b8 98 03 00
	00 00		 cmp	 DWORD PTR [rax+920], 0
  00078	75 35		 jne	 SHORT $LN15@UnmountDev

; 3028 : 		{
; 3029 : 			NTFS_VOLUME_DATA_BUFFER ntfsData;
; 3030 : 
; 3031 : 			if (NT_SUCCESS (GSTFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))

  0007a	c7 44 24 28 60
	00 00 00	 mov	 DWORD PTR [rsp+40], 96	; 00000060H
  00082	48 8d 44 24 50	 lea	 rax, QWORD PTR ntfsData$31928[rsp]
  00087	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008c	45 33 c9	 xor	 r9d, r9d
  0008f	45 33 c0	 xor	 r8d, r8d
  00092	ba 64 00 09 00	 mov	 edx, 589924		; 00090064H
  00097	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  0009c	e8 00 00 00 00	 call	 GSTFsctlCall
  000a1	85 c0		 test	 eax, eax
  000a3	7c 0a		 jl	 SHORT $LN14@UnmountDev

; 3032 : 				DriverUnloadDisabled = TRUE;

  000a5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DriverUnloadDisabled, 1
$LN14@UnmountDev:
$LN15@UnmountDev:

; 3033 : 		}
; 3034 : 
; 3035 : 		// Lock volume
; 3036 : 		ntStatus = GSTFsctlCall (volumeFileObject, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

  000af	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  000b7	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000c0	45 33 c9	 xor	 r9d, r9d
  000c3	45 33 c0	 xor	 r8d, r8d
  000c6	ba 18 00 09 00	 mov	 edx, 589848		; 00090018H
  000cb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  000d0	e8 00 00 00 00	 call	 GSTFsctlCall
  000d5	89 44 24 48	 mov	 DWORD PTR ntStatus$[rsp], eax

; 3037 : 		Dump ("FSCTL_LOCK_VOLUME returned %X\n", ntStatus);

  000d9	8b 54 24 48	 mov	 edx, DWORD PTR ntStatus$[rsp]
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@
  000e4	e8 00 00 00 00	 call	 DbgPrint

; 3038 : 
; 3039 : 		if (!NT_SUCCESS (ntStatus) && !ignoreOpenFiles)

  000e9	83 7c 24 48 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  000ee	7d 23		 jge	 SHORT $LN13@UnmountDev
  000f0	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR ignoreOpenFiles$[rsp], 0
  000f8	75 19		 jne	 SHORT $LN13@UnmountDev

; 3040 : 		{
; 3041 : 			GSTCloseFsVolume (volumeHandle, volumeFileObject);

  000fa	48 8b 54 24 30	 mov	 rdx, QWORD PTR volumeFileObject$[rsp]
  000ff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  00104	e8 00 00 00 00	 call	 GSTCloseFsVolume

; 3042 : 			return ERR_FILES_OPEN;

  00109	b8 06 00 00 00	 mov	 eax, 6
  0010e	e9 1b 02 00 00	 jmp	 $LN17@UnmountDev
$LN13@UnmountDev:

; 3043 : 		}
; 3044 : 
; 3045 : 		// Dismount volume
; 3046 : 		for (dismountRetry = 0; dismountRetry < 200; ++dismountRetry)

  00113	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR dismountRetry$31926[rsp], 0
  0011b	eb 0b		 jmp	 SHORT $LN12@UnmountDev
$LN11@UnmountDev:
  0011d	8b 44 24 4c	 mov	 eax, DWORD PTR dismountRetry$31926[rsp]
  00121	83 c0 01	 add	 eax, 1
  00124	89 44 24 4c	 mov	 DWORD PTR dismountRetry$31926[rsp], eax
$LN12@UnmountDev:
  00128	81 7c 24 4c c8
	00 00 00	 cmp	 DWORD PTR dismountRetry$31926[rsp], 200 ; 000000c8H
  00130	7d 7f		 jge	 SHORT $LN10@UnmountDev

; 3047 : 		{
; 3048 : 			ntStatus = GSTFsctlCall (volumeFileObject, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);

  00132	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0013a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00143	45 33 c9	 xor	 r9d, r9d
  00146	45 33 c0	 xor	 r8d, r8d
  00149	ba 20 00 09 00	 mov	 edx, 589856		; 00090020H
  0014e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  00153	e8 00 00 00 00	 call	 GSTFsctlCall
  00158	89 44 24 48	 mov	 DWORD PTR ntStatus$[rsp], eax

; 3049 : 			Dump ("FSCTL_DISMOUNT_VOLUME returned %X\n", ntStatus);

  0015c	8b 54 24 48	 mov	 edx, DWORD PTR ntStatus$[rsp]
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@
  00167	e8 00 00 00 00	 call	 DbgPrint

; 3050 : 
; 3051 : 			if (NT_SUCCESS (ntStatus) || ntStatus == STATUS_VOLUME_DISMOUNTED)

  0016c	83 7c 24 48 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00171	7d 0a		 jge	 SHORT $LN8@UnmountDev
  00173	81 7c 24 48 6e
	02 00 c0	 cmp	 DWORD PTR ntStatus$[rsp], -1073741202 ; ffffffffc000026eH
  0017b	75 02		 jne	 SHORT $LN9@UnmountDev
$LN8@UnmountDev:

; 3052 : 				break;

  0017d	eb 32		 jmp	 SHORT $LN10@UnmountDev
$LN9@UnmountDev:

; 3053 : 
; 3054 : 			if (!ignoreOpenFiles)

  0017f	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR ignoreOpenFiles$[rsp], 0
  00187	75 19		 jne	 SHORT $LN7@UnmountDev

; 3055 : 			{
; 3056 : 				GSTCloseFsVolume (volumeHandle, volumeFileObject);

  00189	48 8b 54 24 30	 mov	 rdx, QWORD PTR volumeFileObject$[rsp]
  0018e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  00193	e8 00 00 00 00	 call	 GSTCloseFsVolume

; 3057 : 				return ERR_FILES_OPEN;

  00198	b8 06 00 00 00	 mov	 eax, 6
  0019d	e9 8c 01 00 00	 jmp	 $LN17@UnmountDev
$LN7@UnmountDev:

; 3058 : 			}
; 3059 : 
; 3060 : 			GSTSleep (100);

  001a2	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001a7	e8 00 00 00 00	 call	 GSTSleep

; 3061 : 		}

  001ac	e9 6c ff ff ff	 jmp	 $LN11@UnmountDev
$LN10@UnmountDev:

; 3062 : 	}
; 3063 : 	else 

  001b1	eb 1f		 jmp	 SHORT $LN6@UnmountDev
$LN16@UnmountDev:

; 3064 : 	{
; 3065 : 		// Volume cannot be opened => force dismount if allowed
; 3066 : 		if (!ignoreOpenFiles)

  001b3	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR ignoreOpenFiles$[rsp], 0
  001bb	75 0c		 jne	 SHORT $LN5@UnmountDev

; 3067 : 			return ERR_FILES_OPEN;

  001bd	b8 06 00 00 00	 mov	 eax, 6
  001c2	e9 67 01 00 00	 jmp	 $LN17@UnmountDev

; 3068 : 		else

  001c7	eb 09		 jmp	 SHORT $LN4@UnmountDev
$LN5@UnmountDev:

; 3069 : 			volumeHandle = NULL;

  001c9	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR volumeHandle$[rsp], 0
$LN4@UnmountDev:
$LN6@UnmountDev:

; 3070 : 	}
; 3071 : 
; 3072 : 	if (extension->bMountManager)

  001d2	48 8b 44 24 40	 mov	 rax, QWORD PTR extension$[rsp]
  001d7	83 b8 a8 03 00
	00 00		 cmp	 DWORD PTR [rax+936], 0
  001de	74 0d		 je	 SHORT $LN3@UnmountDev

; 3073 : 		MountManagerUnmount (extension->nDosDriveNo);

  001e0	48 8b 44 24 40	 mov	 rax, QWORD PTR extension$[rsp]
  001e5	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  001e8	e8 00 00 00 00	 call	 MountManagerUnmount
$LN3@UnmountDev:

; 3074 : 
; 3075 : 	// We always remove symbolic link as mount manager might fail to do so
; 3076 : 	RemoveDriveLink (extension->nDosDriveNo);

  001ed	48 8b 44 24 40	 mov	 rax, QWORD PTR extension$[rsp]
  001f2	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  001f5	e8 00 00 00 00	 call	 RemoveDriveLink

; 3077 : 
; 3078 : 	extension->bShuttingDown = TRUE;

  001fa	4c 8b 5c 24 40	 mov	 r11, QWORD PTR extension$[rsp]
  001ff	41 c7 43 18 01
	00 00 00	 mov	 DWORD PTR [r11+24], 1

; 3079 : 
; 3080 : 	ntStatus = IoAcquireRemoveLock (&extension->Queue.RemoveLock, NULL);

  00207	48 8b 4c 24 40	 mov	 rcx, QWORD PTR extension$[rsp]
  0020c	48 81 c1 80 01
	00 00		 add	 rcx, 384		; 00000180H
  00213	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  0021b	41 b9 08 0c 00
	00		 mov	 r9d, 3080		; 00000c08H
  00221	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  00228	33 d2		 xor	 edx, edx
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00230	89 44 24 48	 mov	 DWORD PTR ntStatus$[rsp], eax

; 3081 : 	ASSERT (NT_SUCCESS (ntStatus));

  00234	83 7c 24 48 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00239	7d 2a		 jge	 SHORT $LN19@UnmountDev
  0023b	45 33 c9	 xor	 r9d, r9d
  0023e	41 b8 09 0c 00
	00		 mov	 r8d, 3081		; 00000c09H
  00244	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  0024b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@
  00252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00258	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv168[rsp], 0
  00263	eb 0b		 jmp	 SHORT $LN20@UnmountDev
$LN19@UnmountDev:
  00265	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv168[rsp], 1
$LN20@UnmountDev:

; 3082 : 	IoReleaseRemoveLockAndWait (&extension->Queue.RemoveLock, NULL);

  00270	48 8b 4c 24 40	 mov	 rcx, QWORD PTR extension$[rsp]
  00275	48 81 c1 80 01
	00 00		 add	 rcx, 384		; 00000180H
  0027c	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00282	33 d2		 xor	 edx, edx
  00284	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockAndWaitEx

; 3083 : 
; 3084 : 	if (volumeHandle != NULL)

  0028a	48 83 7c 24 38
	00		 cmp	 QWORD PTR volumeHandle$[rsp], 0
  00290	74 0f		 je	 SHORT $LN2@UnmountDev

; 3085 : 		GSTCloseFsVolume (volumeHandle, volumeFileObject);

  00292	48 8b 54 24 30	 mov	 rdx, QWORD PTR volumeFileObject$[rsp]
  00297	48 8b 4c 24 38	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  0029c	e8 00 00 00 00	 call	 GSTCloseFsVolume
$LN2@UnmountDev:

; 3086 : 
; 3087 : 	if (unmountRequest)

  002a1	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR unmountRequest$[rsp], 0
  002aa	74 67		 je	 SHORT $LN1@UnmountDev

; 3088 : 	{
; 3089 : 		PCRYPTO_INFO cryptoInfo = ((PEXTENSION) deviceObject->DeviceExtension)->cryptoInfo;

  002ac	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR deviceObject$[rsp]
  002b4	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  002b8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002bf	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR cryptoInfo$31962[rsp], rax

; 3090 : 		unmountRequest->HiddenVolumeProtectionTriggered = (cryptoInfo->bProtectHiddenVolume && cryptoInfo->bHiddenVolProtectionAction);

  002c7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$31962[rsp]
  002cf	83 b8 a8 1e 00
	00 00		 cmp	 DWORD PTR [rax+7848], 0
  002d6	74 1e		 je	 SHORT $LN21@UnmountDev
  002d8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$31962[rsp]
  002e0	83 b8 ac 1e 00
	00 00		 cmp	 DWORD PTR [rax+7852], 0
  002e7	74 0d		 je	 SHORT $LN21@UnmountDev
  002e9	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv184[rsp], 1
  002f4	eb 0b		 jmp	 SHORT $LN22@UnmountDev
$LN21@UnmountDev:
  002f6	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv184[rsp], 0
$LN22@UnmountDev:
  00301	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR unmountRequest$[rsp]
  00309	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv184[rsp]
  00310	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN1@UnmountDev:

; 3091 : 	}
; 3092 : 
; 3093 : 	GSTDeleteDeviceObject (deviceObject, (PEXTENSION) deviceObject->DeviceExtension);

  00313	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  0031b	48 8b 52 40	 mov	 rdx, QWORD PTR [rdx+64]
  0031f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00327	e8 00 00 00 00	 call	 GSTDeleteDeviceObject

; 3094 : 	return 0;

  0032c	33 c0		 xor	 eax, eax
$LN17@UnmountDev:

; 3095 : }

  0032e	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00335	c3		 ret	 0
UnmountDevice ENDP
_TEXT	ENDS
PUBLIC	ProbeRealDriveSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProbeRealDriveSize DD imagerel $LN12
	DD	imagerel $LN12+427
	DD	imagerel $unwind$ProbeRealDriveSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProbeRealDriveSize DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ProbeRealDriveSize
_TEXT	SEGMENT
sysLength$ = 48
sectorBuffer$ = 56
offset$ = 64
startTime$ = 72
status$ = 80
driveDeviceObject$ = 112
driveSize$ = 120
ProbeRealDriveSize PROC					; COMDAT

; 2500 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2501 : 	NTSTATUS status;
; 2502 : 	LARGE_INTEGER sysLength;
; 2503 : 	LARGE_INTEGER offset;
; 2504 : 	byte *sectorBuffer;
; 2505 : 	ULONGLONG startTime;
; 2506 : 
; 2507 : 	if (!UserCanAccessDriveDevice())

  0000e	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00013	85 c0		 test	 eax, eax
  00015	75 0a		 jne	 SHORT $LN9@ProbeRealD

; 2508 : 		return STATUS_ACCESS_DENIED;

  00017	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  0001c	e9 85 01 00 00	 jmp	 $LN10@ProbeRealD
$LN9@ProbeRealD:

; 2509 : 
; 2510 : 	sectorBuffer = GSTalloc (GST_SECTOR_SIZE_BIOS);

  00021	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00027	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0002c	33 c9		 xor	 ecx, ecx
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00034	48 89 44 24 38	 mov	 QWORD PTR sectorBuffer$[rsp], rax

; 2511 : 	if (!sectorBuffer)

  00039	48 83 7c 24 38
	00		 cmp	 QWORD PTR sectorBuffer$[rsp], 0
  0003f	75 0a		 jne	 SHORT $LN8@ProbeRealD

; 2512 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00041	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00046	e9 5b 01 00 00	 jmp	 $LN10@ProbeRealD
$LN8@ProbeRealD:

; 2513 : 
; 2514 : 	status = SendDeviceIoControlRequest (driveDeviceObject, IOCTL_DISK_GET_LENGTH_INFO,
; 2515 : 		NULL, 0, &sysLength, sizeof (sysLength));

  0004b	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  00053	48 8d 44 24 30	 lea	 rax, QWORD PTR sysLength$[rsp]
  00058	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005d	45 33 c9	 xor	 r9d, r9d
  00060	45 33 c0	 xor	 r8d, r8d
  00063	ba 5c 40 07 00	 mov	 edx, 475228		; 0007405cH
  00068	48 8b 4c 24 70	 mov	 rcx, QWORD PTR driveDeviceObject$[rsp]
  0006d	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00072	89 44 24 50	 mov	 DWORD PTR status$[rsp], eax

; 2516 : 
; 2517 : 	if (!NT_SUCCESS (status))

  00076	83 7c 24 50 00	 cmp	 DWORD PTR status$[rsp], 0
  0007b	7d 29		 jge	 SHORT $LN7@ProbeRealD

; 2518 : 	{
; 2519 : 		Dump ("Failed to get drive size - error %x\n", status);

  0007d	8b 54 24 50	 mov	 edx, DWORD PTR status$[rsp]
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@
  00088	e8 00 00 00 00	 call	 DbgPrint

; 2520 : 		GSTfree (sectorBuffer);

  0008d	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00092	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sectorBuffer$[rsp]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 2521 : 		return status;

  0009d	8b 44 24 50	 mov	 eax, DWORD PTR status$[rsp]
  000a1	e9 00 01 00 00	 jmp	 $LN10@ProbeRealD
$LN7@ProbeRealD:

; 2522 : 	}
; 2523 : 
; 2524 : 	startTime = KeQueryInterruptTime ();

  000a6	48 b8 08 00 00
	00 80 f7 ff ff	 mov	 rax, -9345848836088	; fffff78000000008H
  000b0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b3	48 89 44 24 48	 mov	 QWORD PTR startTime$[rsp], rax

; 2525 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += GST_SECTOR_SIZE_BIOS)

  000b8	48 8b 44 24 30	 mov	 rax, QWORD PTR sysLength$[rsp]
  000bd	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax
  000c2	eb 10		 jmp	 SHORT $LN6@ProbeRealD
$LN5@ProbeRealD:
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  000c9	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  000cf	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax
$LN6@ProbeRealD:

; 2526 : 	{
; 2527 : 		status = GSTReadDevice (driveDeviceObject, sectorBuffer, offset, GST_SECTOR_SIZE_BIOS);

  000d4	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  000da	4c 8b 44 24 40	 mov	 r8, QWORD PTR offset$[rsp]
  000df	48 8b 54 24 38	 mov	 rdx, QWORD PTR sectorBuffer$[rsp]
  000e4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR driveDeviceObject$[rsp]
  000e9	e8 00 00 00 00	 call	 GSTReadDevice
  000ee	89 44 24 50	 mov	 DWORD PTR status$[rsp], eax

; 2528 : 		
; 2529 : 		if (NT_SUCCESS (status))

  000f2	83 7c 24 50 00	 cmp	 DWORD PTR status$[rsp], 0
  000f7	7c 1e		 jl	 SHORT $LN3@ProbeRealD

; 2530 : 			status = GSTWriteDevice (driveDeviceObject, sectorBuffer, offset, GST_SECTOR_SIZE_BIOS);

  000f9	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  000ff	4c 8b 44 24 40	 mov	 r8, QWORD PTR offset$[rsp]
  00104	48 8b 54 24 38	 mov	 rdx, QWORD PTR sectorBuffer$[rsp]
  00109	48 8b 4c 24 70	 mov	 rcx, QWORD PTR driveDeviceObject$[rsp]
  0010e	e8 00 00 00 00	 call	 GSTWriteDevice
  00113	89 44 24 50	 mov	 DWORD PTR status$[rsp], eax
$LN3@ProbeRealD:

; 2531 : 
; 2532 : 		if (!NT_SUCCESS (status))

  00117	83 7c 24 50 00	 cmp	 DWORD PTR status$[rsp], 0
  0011c	7d 45		 jge	 SHORT $LN2@ProbeRealD

; 2533 : 		{
; 2534 : 			driveSize->QuadPart = offset.QuadPart;

  0011e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR driveSize$[rsp]
  00123	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  00128	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2535 : 			Dump ("Real drive size = %I64d bytes (%I64d hidden)\n", driveSize->QuadPart, driveSize->QuadPart - sysLength.QuadPart);

  0012b	4c 8b 44 24 78	 mov	 r8, QWORD PTR driveSize$[rsp]
  00130	48 8b 44 24 30	 mov	 rax, QWORD PTR sysLength$[rsp]
  00135	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00138	4c 2b c0	 sub	 r8, rax
  0013b	48 8b 54 24 78	 mov	 rdx, QWORD PTR driveSize$[rsp]
  00140	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@
  0014a	e8 00 00 00 00	 call	 DbgPrint

; 2536 : 			GSTfree (sectorBuffer);

  0014f	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00154	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sectorBuffer$[rsp]
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 2537 : 			return STATUS_SUCCESS;

  0015f	33 c0		 xor	 eax, eax
  00161	eb 43		 jmp	 SHORT $LN10@ProbeRealD
$LN2@ProbeRealD:

; 2538 : 		}
; 2539 : 
; 2540 : 		if (KeQueryInterruptTime() - startTime > 3ULL * 60 * 1000 * 1000 * 10)

  00163	48 b8 08 00 00
	00 80 f7 ff ff	 mov	 rax, -9345848836088	; fffff78000000008H
  0016d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00170	48 2b 44 24 48	 sub	 rax, QWORD PTR startTime$[rsp]
  00175	48 3d 00 d2 49
	6b		 cmp	 rax, 1800000000		; 6b49d200H
  0017b	76 24		 jbe	 SHORT $LN1@ProbeRealD

; 2541 : 		{
; 2542 : 			// Abort if probing for more than 3 minutes
; 2543 : 			driveSize->QuadPart = sysLength.QuadPart;

  0017d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR driveSize$[rsp]
  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR sysLength$[rsp]
  00187	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2544 : 			GSTfree (sectorBuffer);

  0018a	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0018f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sectorBuffer$[rsp]
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 2545 : 			return STATUS_TIMEOUT;

  0019a	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  0019f	eb 05		 jmp	 SHORT $LN10@ProbeRealD
$LN1@ProbeRealD:

; 2546 : 		}
; 2547 : 	}

  001a1	e9 1e ff ff ff	 jmp	 $LN5@ProbeRealD
$LN10@ProbeRealD:

; 2548 : }

  001a6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001aa	c3		 ret	 0
ProbeRealDriveSize ENDP
PUBLIC	IsVolumeAccessibleByCurrentUser
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsVolumeAccessibleByCurrentUser DD imagerel $LN10
	DD	imagerel $LN10+277
	DD	imagerel $unwind$IsVolumeAccessibleByCurrentUser
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsVolumeAccessibleByCurrentUser DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsVolumeAccessibleByCurrentUser
_TEXT	SEGMENT
accessToken$ = 32
subContext$ = 40
tokenUser$ = 72
result$ = 80
tv78 = 88
volumeDeviceExtension$ = 112
IsVolumeAccessibleByCurrentUser PROC			; COMDAT

; 3787 : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3788 : 	SECURITY_SUBJECT_CONTEXT subContext;
; 3789 : 	PACCESS_TOKEN accessToken;
; 3790 : 	PTOKEN_USER tokenUser;
; 3791 : 	BOOL result = FALSE;

  00009	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 3792 : 
; 3793 : 	if (IoIsSystemThread (PsGetCurrentThread())
; 3794 : 		|| UserCanAccessDriveDevice()
; 3795 : 		|| !volumeDeviceExtension->UserSid
; 3796 : 		|| (volumeDeviceExtension->SystemFavorite && !NonAdminSystemFavoritesAccessDisabled))

  00011	e8 00 00 00 00	 call	 PsGetCurrentThread
  00016	48 8b c8	 mov	 rcx, rax
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  0001f	0f b6 c0	 movzx	 eax, al
  00022	85 c0		 test	 eax, eax
  00024	75 2f		 jne	 SHORT $LN4@IsVolumeAc
  00026	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  0002b	85 c0		 test	 eax, eax
  0002d	75 26		 jne	 SHORT $LN4@IsVolumeAc
  0002f	48 8b 44 24 70	 mov	 rax, QWORD PTR volumeDeviceExtension$[rsp]
  00034	48 83 b8 e0 05
	00 00 00	 cmp	 QWORD PTR [rax+1504], 0
  0003c	74 17		 je	 SHORT $LN4@IsVolumeAc
  0003e	48 8b 44 24 70	 mov	 rax, QWORD PTR volumeDeviceExtension$[rsp]
  00043	83 b8 ac 03 00
	00 00		 cmp	 DWORD PTR [rax+940], 0
  0004a	74 13		 je	 SHORT $LN5@IsVolumeAc
  0004c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NonAdminSystemFavoritesAccessDisabled, 0
  00053	75 0a		 jne	 SHORT $LN5@IsVolumeAc
$LN4@IsVolumeAc:

; 3797 : 	{
; 3798 : 		return TRUE;

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	e9 b1 00 00 00	 jmp	 $LN6@IsVolumeAc
$LN5@IsVolumeAc:

; 3799 : 	}
; 3800 : 
; 3801 : 	SeCaptureSubjectContext (&subContext);

  0005f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR subContext$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCaptureSubjectContext

; 3802 : 	accessToken = SeQuerySubjectContextToken (&subContext);

  0006a	48 83 7c 24 28
	00		 cmp	 QWORD PTR subContext$[rsp], 0
  00070	74 0c		 je	 SHORT $LN8@IsVolumeAc
  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR subContext$[rsp]
  00077	48 89 44 24 58	 mov	 QWORD PTR tv78[rsp], rax
  0007c	eb 0a		 jmp	 SHORT $LN9@IsVolumeAc
$LN8@IsVolumeAc:
  0007e	48 8b 44 24 38	 mov	 rax, QWORD PTR subContext$[rsp+16]
  00083	48 89 44 24 58	 mov	 QWORD PTR tv78[rsp], rax
$LN9@IsVolumeAc:
  00088	48 8b 44 24 58	 mov	 rax, QWORD PTR tv78[rsp]
  0008d	48 89 44 24 20	 mov	 QWORD PTR accessToken$[rsp], rax

; 3803 : 
; 3804 : 	if (!accessToken)

  00092	48 83 7c 24 20
	00		 cmp	 QWORD PTR accessToken$[rsp], 0
  00098	75 02		 jne	 SHORT $LN3@IsVolumeAc

; 3805 : 		goto ret;

  0009a	eb 65		 jmp	 SHORT $ret$32314
$LN3@IsVolumeAc:

; 3806 : 	
; 3807 : 	if (SeTokenIsAdmin (accessToken))

  0009c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR accessToken$[rsp]
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeTokenIsAdmin
  000a7	0f b6 c0	 movzx	 eax, al
  000aa	85 c0		 test	 eax, eax
  000ac	74 0a		 je	 SHORT $LN2@IsVolumeAc

; 3808 : 	{
; 3809 : 		result = TRUE;

  000ae	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR result$[rsp], 1

; 3810 : 		goto ret;

  000b6	eb 49		 jmp	 SHORT $ret$32314
$LN2@IsVolumeAc:

; 3811 : 	}
; 3812 : 
; 3813 : 	if (!NT_SUCCESS (SeQueryInformationToken (accessToken, TokenUser, &tokenUser)))

  000b8	4c 8d 44 24 48	 lea	 r8, QWORD PTR tokenUser$[rsp]
  000bd	ba 01 00 00 00	 mov	 edx, 1
  000c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR accessToken$[rsp]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeQueryInformationToken
  000cd	85 c0		 test	 eax, eax
  000cf	7d 02		 jge	 SHORT $LN1@IsVolumeAc

; 3814 : 		goto ret;

  000d1	eb 2e		 jmp	 SHORT $ret$32314
$LN1@IsVolumeAc:

; 3815 : 
; 3816 : 	result = RtlEqualSid (volumeDeviceExtension->UserSid, tokenUser->User.Sid);

  000d3	48 8b 54 24 48	 mov	 rdx, QWORD PTR tokenUser$[rsp]
  000d8	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000db	48 8b 4c 24 70	 mov	 rcx, QWORD PTR volumeDeviceExtension$[rsp]
  000e0	48 8b 89 e0 05
	00 00		 mov	 rcx, QWORD PTR [rcx+1504]
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlEqualSid
  000ed	0f b6 c0	 movzx	 eax, al
  000f0	89 44 24 50	 mov	 DWORD PTR result$[rsp], eax

; 3817 : 	ExFreePool (tokenUser);		// Documented in newer versions of WDK

  000f4	33 d2		 xor	 edx, edx
  000f6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tokenUser$[rsp]
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$ret$32314:

; 3818 : 
; 3819 : ret:
; 3820 : 	SeReleaseSubjectContext (&subContext);

  00101	48 8d 4c 24 28	 lea	 rcx, QWORD PTR subContext$[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeReleaseSubjectContext

; 3821 : 	return result;

  0010c	8b 44 24 50	 mov	 eax, DWORD PTR result$[rsp]
$LN6@IsVolumeAc:

; 3822 : }

  00110	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00114	c3		 ret	 0
IsVolumeAccessibleByCurrentUser ENDP
_TEXT	ENDS
PUBLIC	UnmountAllDevices
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnmountAllDevices DD imagerel $LN11
	DD	imagerel $LN11+247
	DD	imagerel $unwind$UnmountAllDevices
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnmountAllDevices DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT UnmountAllDevices
_TEXT	SEGMENT
ListDevice$ = 32
status$ = 40
maxUniqueId$ = 44
ListExtension$31995 = 48
ntStatus$31998 = 56
tv83 = 60
unmountRequest$ = 80
ignoreOpenFiles$ = 88
UnmountAllDevices PROC					; COMDAT

; 3140 : {

$LN11:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3141 : 	NTSTATUS status = 0;

  0000d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 3142 : 	PDEVICE_OBJECT ListDevice;
; 3143 : 	int maxUniqueId = LastUniqueVolumeId;

  00015	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR LastUniqueVolumeId
  0001b	89 44 24 2c	 mov	 DWORD PTR maxUniqueId$[rsp], eax

; 3144 : 
; 3145 : 	Dump ("Unmounting all volumes\n");

  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@
  00026	e8 00 00 00 00	 call	 DbgPrint

; 3146 : 
; 3147 : 	if (unmountRequest)

  0002b	48 83 7c 24 50
	00		 cmp	 QWORD PTR unmountRequest$[rsp], 0
  00031	74 0c		 je	 SHORT $LN6@UnmountAll

; 3148 : 		unmountRequest->HiddenVolumeProtectionTriggered = FALSE;

  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR unmountRequest$[rsp]
  00038	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0
$LN6@UnmountAll:
$LN5@UnmountAll:

; 3149 : 
; 3150 : 	// Dismount volumes in the reverse order they were mounted to properly dismount nested volumes
; 3151 : 	while ((ListDevice = FindVolumeWithHighestUniqueId (maxUniqueId)) != NULL)

  0003f	8b 4c 24 2c	 mov	 ecx, DWORD PTR maxUniqueId$[rsp]
  00043	e8 00 00 00 00	 call	 FindVolumeWithHighestUniqueId
  00048	48 89 44 24 20	 mov	 QWORD PTR ListDevice$[rsp], rax
  0004d	48 83 7c 24 20
	00		 cmp	 QWORD PTR ListDevice$[rsp], 0
  00053	0f 84 95 00 00
	00		 je	 $LN4@UnmountAll

; 3152 : 	{
; 3153 : 		PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR ListDevice$[rsp]
  0005e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00062	48 89 44 24 30	 mov	 QWORD PTR ListExtension$31995[rsp], rax

; 3154 : 		maxUniqueId = ListExtension->UniqueVolumeId - 1;

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR ListExtension$31995[rsp]
  0006c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006f	83 e8 01	 sub	 eax, 1
  00072	89 44 24 2c	 mov	 DWORD PTR maxUniqueId$[rsp], eax

; 3155 : 
; 3156 : 		if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ListExtension$31995[rsp]
  0007b	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  00080	85 c0		 test	 eax, eax
  00082	74 65		 je	 SHORT $LN3@UnmountAll

; 3157 : 		{
; 3158 : 			NTSTATUS ntStatus;
; 3159 : 
; 3160 : 			if (unmountRequest)

  00084	48 83 7c 24 50
	00		 cmp	 QWORD PTR unmountRequest$[rsp], 0
  0008a	74 0f		 je	 SHORT $LN2@UnmountAll

; 3161 : 				unmountRequest->nDosDriveNo = ListExtension->nDosDriveNo;

  0008c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR unmountRequest$[rsp]
  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR ListExtension$31995[rsp]
  00096	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00099	89 01		 mov	 DWORD PTR [rcx], eax
$LN2@UnmountAll:

; 3162 : 
; 3163 : 			ntStatus = UnmountDevice (unmountRequest, ListDevice, ignoreOpenFiles);

  0009b	44 8b 44 24 58	 mov	 r8d, DWORD PTR ignoreOpenFiles$[rsp]
  000a0	48 8b 54 24 20	 mov	 rdx, QWORD PTR ListDevice$[rsp]
  000a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR unmountRequest$[rsp]
  000aa	e8 00 00 00 00	 call	 UnmountDevice
  000af	89 44 24 38	 mov	 DWORD PTR ntStatus$31998[rsp], eax

; 3164 : 			status = ntStatus == 0 ? status : ntStatus;

  000b3	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$31998[rsp], 0
  000b8	75 0a		 jne	 SHORT $LN9@UnmountAll
  000ba	8b 44 24 28	 mov	 eax, DWORD PTR status$[rsp]
  000be	89 44 24 3c	 mov	 DWORD PTR tv83[rsp], eax
  000c2	eb 08		 jmp	 SHORT $LN10@UnmountAll
$LN9@UnmountAll:
  000c4	8b 44 24 38	 mov	 eax, DWORD PTR ntStatus$31998[rsp]
  000c8	89 44 24 3c	 mov	 DWORD PTR tv83[rsp], eax
$LN10@UnmountAll:
  000cc	8b 44 24 3c	 mov	 eax, DWORD PTR tv83[rsp]
  000d0	89 44 24 28	 mov	 DWORD PTR status$[rsp], eax

; 3165 : 
; 3166 : 			if (unmountRequest && unmountRequest->HiddenVolumeProtectionTriggered)

  000d4	48 83 7c 24 50
	00		 cmp	 QWORD PTR unmountRequest$[rsp], 0
  000da	74 0d		 je	 SHORT $LN1@UnmountAll
  000dc	48 8b 44 24 50	 mov	 rax, QWORD PTR unmountRequest$[rsp]
  000e1	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000e5	74 02		 je	 SHORT $LN1@UnmountAll

; 3167 : 				break;

  000e7	eb 05		 jmp	 SHORT $LN4@UnmountAll
$LN1@UnmountAll:
$LN3@UnmountAll:

; 3168 : 		}
; 3169 : 	}

  000e9	e9 51 ff ff ff	 jmp	 $LN5@UnmountAll
$LN4@UnmountAll:

; 3170 : 
; 3171 : 	return status;

  000ee	8b 44 24 28	 mov	 eax, DWORD PTR status$[rsp]

; 3172 : }

  000f2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f6	c3		 ret	 0
UnmountAllDevices ENDP
PUBLIC	VolumeThreadProc
;	COMDAT pdata
pdata	SEGMENT
$pdata$VolumeThreadProc DD imagerel $LN19
	DD	imagerel $LN19+1104
	DD	imagerel $unwind$VolumeThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$VolumeThreadProc DD 020c01H
	DD	013010cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT VolumeThreadProc
_TEXT	SEGMENT
bDevice$ = 48
Extension$ = 56
pThreadBlock$ = 64
DeviceObject$ = 72
irp$31199 = 80
request$31198 = 88
irpSp$31197 = 96
tv79 = 104
tv81 = 112
tv82 = 120
tv83 = 128
tv214 = 132
Context$ = 160
VolumeThreadProc PROC					; COMDAT

; 1915 : {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1916 : 	PTHREAD_BLOCK pThreadBlock = (PTHREAD_BLOCK) Context;

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR Context$[rsp]
  00014	48 89 44 24 40	 mov	 QWORD PTR pThreadBlock$[rsp], rax

; 1917 : 	PDEVICE_OBJECT DeviceObject = pThreadBlock->DeviceObject;

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 89 44 24 48	 mov	 QWORD PTR DeviceObject$[rsp], rax

; 1918 : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  0002b	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0002f	48 89 44 24 38	 mov	 QWORD PTR Extension$[rsp], rax

; 1919 : 	BOOL bDevice;
; 1920 : 
; 1921 : 	/* Set thread priority to lowest realtime level. */
; 1922 : 	KeSetPriorityThread (KeGetCurrentThread (), LOW_REALTIME_PRIORITY);

  00034	e8 00 00 00 00	 call	 KeGetCurrentThread
  00039	ba 10 00 00 00	 mov	 edx, 16
  0003e	48 8b c8	 mov	 rcx, rax
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetPriorityThread

; 1923 : 
; 1924 : 	Dump ("Mount THREAD OPENING VOLUME BEGIN\n");

  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@
  0004e	e8 00 00 00 00	 call	 DbgPrint

; 1925 : 
; 1926 : 	if (memcmp (pThreadBlock->mount->wszVolume, WIDE ("\\Device"), 14) != 0)

  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  00058	48 8b 89 28 02
	00 00		 mov	 rcx, QWORD PTR [rcx+552]
  0005f	48 83 c1 10	 add	 rcx, 16
  00063	41 b8 0e 00 00
	00		 mov	 r8d, 14
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
  00070	e8 00 00 00 00	 call	 memcmp
  00075	85 c0		 test	 eax, eax
  00077	0f 84 9a 00 00
	00		 je	 $LN13@VolumeThre

; 1927 : 	{
; 1928 : 		wcscpy (pThreadBlock->wszMountVolume, WIDE ("\\??\\"));

  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
  00084	48 89 44 24 68	 mov	 QWORD PTR tv79[rsp], rax
  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  0008e	48 83 c0 0c	 add	 rax, 12
  00092	48 89 44 24 70	 mov	 QWORD PTR tv81[rsp], rax
  00097	48 8b 44 24 70	 mov	 rax, QWORD PTR tv81[rsp]
  0009c	48 89 44 24 78	 mov	 QWORD PTR tv82[rsp], rax
$LN16@VolumeThre:
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR tv79[rsp]
  000a6	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000a9	66 89 84 24 80
	00 00 00	 mov	 WORD PTR tv83[rsp], ax
  000b1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv81[rsp]
  000b6	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR tv83[rsp]
  000be	66 89 01	 mov	 WORD PTR [rcx], ax
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR tv79[rsp]
  000c6	48 83 c0 02	 add	 rax, 2
  000ca	48 89 44 24 68	 mov	 QWORD PTR tv79[rsp], rax
  000cf	48 8b 44 24 70	 mov	 rax, QWORD PTR tv81[rsp]
  000d4	48 83 c0 02	 add	 rax, 2
  000d8	48 89 44 24 70	 mov	 QWORD PTR tv81[rsp], rax
  000dd	66 83 bc 24 80
	00 00 00 00	 cmp	 WORD PTR tv83[rsp], 0
  000e6	75 b9		 jne	 SHORT $LN16@VolumeThre

; 1929 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1930 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 5);

  000e8	48 8b 54 24 40	 mov	 rdx, QWORD PTR pThreadBlock$[rsp]
  000ed	48 8b 92 28 02
	00 00		 mov	 rdx, QWORD PTR [rdx+552]
  000f4	48 83 c2 10	 add	 rdx, 16
  000f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  000fd	48 83 c1 0c	 add	 rcx, 12
  00101	41 b8 07 01 00
	00		 mov	 r8d, 263		; 00000107H
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 1931 : 		bDevice = FALSE;

  0010d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR bDevice$[rsp], 0

; 1932 : 	}
; 1933 : 	else

  00115	eb 38		 jmp	 SHORT $LN12@VolumeThre
$LN13@VolumeThre:

; 1934 : 	{
; 1935 : 		pThreadBlock->wszMountVolume[0] = 0;

  00117	33 c9		 xor	 ecx, ecx
  00119	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  0011e	66 89 48 0c	 mov	 WORD PTR [rax+12], cx

; 1936 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1937 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 1);

  00122	48 8b 54 24 40	 mov	 rdx, QWORD PTR pThreadBlock$[rsp]
  00127	48 8b 92 28 02
	00 00		 mov	 rdx, QWORD PTR [rdx+552]
  0012e	48 83 c2 10	 add	 rdx, 16
  00132	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  00137	48 83 c1 0c	 add	 rcx, 12
  0013b	41 b8 0b 01 00
	00		 mov	 r8d, 267		; 0000010bH
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 1938 : 		bDevice = TRUE;

  00147	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR bDevice$[rsp], 1
$LN12@VolumeThre:

; 1939 : 	}
; 1940 : 
; 1941 : 	Dump ("Mount THREAD request for File %ls DriveNumber %d Device = %d\n",
; 1942 : 	      pThreadBlock->wszMountVolume, pThreadBlock->mount->nDosDriveNo, bDevice);

  0014f	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  00154	48 8b 80 28 02
	00 00		 mov	 rax, QWORD PTR [rax+552]
  0015b	48 8b 54 24 40	 mov	 rdx, QWORD PTR pThreadBlock$[rsp]
  00160	48 83 c2 0c	 add	 rdx, 12
  00164	44 8b 4c 24 30	 mov	 r9d, DWORD PTR bDevice$[rsp]
  00169	44 8b 80 64 02
	00 00		 mov	 r8d, DWORD PTR [rax+612]
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@
  00177	e8 00 00 00 00	 call	 DbgPrint

; 1943 : 
; 1944 : 	pThreadBlock->ntCreateStatus = GSTOpenVolume (DeviceObject,
; 1945 : 		Extension,
; 1946 : 		pThreadBlock->mount,
; 1947 : 		pThreadBlock->wszMountVolume,
; 1948 : 		bDevice);

  0017c	4c 8b 4c 24 40	 mov	 r9, QWORD PTR pThreadBlock$[rsp]
  00181	49 83 c1 0c	 add	 r9, 12
  00185	8b 44 24 30	 mov	 eax, DWORD PTR bDevice$[rsp]
  00189	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0018d	4c 8b 44 24 40	 mov	 r8, QWORD PTR pThreadBlock$[rsp]
  00192	4d 8b 80 28 02
	00 00		 mov	 r8, QWORD PTR [r8+552]
  00199	48 8b 54 24 38	 mov	 rdx, QWORD PTR Extension$[rsp]
  0019e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  001a3	e8 00 00 00 00	 call	 GSTOpenVolume
  001a8	44 8b d8	 mov	 r11d, eax
  001ab	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  001b0	44 89 58 08	 mov	 DWORD PTR [rax+8], r11d

; 1949 : 
; 1950 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus) || pThreadBlock->mount->nReturnCode != 0)

  001b4	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  001b9	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  001bd	7c 11		 jl	 SHORT $LN10@VolumeThre
  001bf	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  001c4	48 8b 80 28 02
	00 00		 mov	 rax, QWORD PTR [rax+552]
  001cb	83 38 00	 cmp	 DWORD PTR [rax], 0
  001ce	74 1c		 je	 SHORT $LN11@VolumeThre
$LN10@VolumeThre:

; 1951 : 	{
; 1952 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  001d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  001d5	48 83 c1 28	 add	 rcx, 40			; 00000028H
  001d9	45 33 c0	 xor	 r8d, r8d
  001dc	33 d2		 xor	 edx, edx
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 1953 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  001e4	33 c9		 xor	 ecx, ecx
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN11@VolumeThre:

; 1954 : 	}
; 1955 : 
; 1956 : 	// Start IO queue
; 1957 : 	Extension->Queue.IsFilterDevice = FALSE;

  001ec	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  001f1	c7 80 48 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+328], 0

; 1958 : 	Extension->Queue.DeviceObject = DeviceObject;

  001fb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00200	48 8b 44 24 48	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00205	48 89 81 e0 00
	00 00		 mov	 QWORD PTR [rcx+224], rax

; 1959 : 	Extension->Queue.CryptoInfo = Extension->cryptoInfo;

  0020c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00211	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00216	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0021d	48 89 81 28 01
	00 00		 mov	 QWORD PTR [rcx+296], rax

; 1960 : 	Extension->Queue.HostFileHandle = Extension->hDeviceFile;

  00224	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00229	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  0022e	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00232	48 89 81 30 01
	00 00		 mov	 QWORD PTR [rcx+304], rax

; 1961 : 	Extension->Queue.VirtualDeviceLength = Extension->DiskLength;

  00239	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  0023e	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00243	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0024a	48 89 81 38 01
	00 00		 mov	 QWORD PTR [rcx+312], rax

; 1962 : 	Extension->Queue.MaxReadAheadOffset.QuadPart = Extension->HostLength;

  00251	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00256	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  0025b	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00262	48 89 81 10 03
	00 00		 mov	 QWORD PTR [rcx+784], rax

; 1963 : 
; 1964 : 	if (Extension->SecurityClientContextValid)

  00269	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  0026e	83 b8 e8 05 00
	00 00		 cmp	 DWORD PTR [rax+1512], 0
  00275	74 1a		 je	 SHORT $LN9@VolumeThre

; 1965 : 		Extension->Queue.SecurityClientContext = &Extension->SecurityClientContext;

  00277	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  0027c	48 81 c1 f0 05
	00 00		 add	 rcx, 1520		; 000005f0H
  00283	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00288	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 1966 : 	else

  0028f	eb 10		 jmp	 SHORT $LN8@VolumeThre
$LN9@VolumeThre:

; 1967 : 		Extension->Queue.SecurityClientContext = NULL;

  00291	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00296	48 c7 80 40 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+320], 0
$LN8@VolumeThre:

; 1968 : 
; 1969 : 	pThreadBlock->ntCreateStatus = EncryptedIoQueueStart (&Extension->Queue);

  002a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  002a6	48 81 c1 e0 00
	00 00		 add	 rcx, 224		; 000000e0H
  002ad	e8 00 00 00 00	 call	 EncryptedIoQueueStart
  002b2	44 8b d8	 mov	 r11d, eax
  002b5	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  002ba	44 89 58 08	 mov	 DWORD PTR [rax+8], r11d

; 1970 : 
; 1971 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus))

  002be	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  002c3	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  002c7	7d 3d		 jge	 SHORT $LN7@VolumeThre

; 1972 : 	{
; 1973 : 		GSTCloseVolume (DeviceObject, Extension);

  002c9	48 8b 54 24 38	 mov	 rdx, QWORD PTR Extension$[rsp]
  002ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  002d3	e8 00 00 00 00	 call	 GSTCloseVolume

; 1974 : 
; 1975 : 		pThreadBlock->mount->nReturnCode = ERR_OS_ERROR;

  002d8	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  002dd	48 8b 80 28 02
	00 00		 mov	 rax, QWORD PTR [rax+552]
  002e4	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 1976 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  002ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  002ef	48 83 c1 28	 add	 rcx, 40			; 00000028H
  002f3	45 33 c0	 xor	 r8d, r8d
  002f6	33 d2		 xor	 edx, edx
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 1977 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  002fe	33 c9		 xor	 ecx, ecx
  00300	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN7@VolumeThre:

; 1978 : 	}
; 1979 : 
; 1980 : 	KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00306	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  0030b	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0030f	45 33 c0	 xor	 r8d, r8d
  00312	33 d2		 xor	 edx, edx
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 1981 : 	/* From this point on pThreadBlock cannot be used as it will have been released! */
; 1982 : 	pThreadBlock = NULL;

  0031a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pThreadBlock$[rsp], 0
$LN6@VolumeThre:

; 1983 : 
; 1984 : 	for (;;)
; 1985 : 	{
; 1986 : 		/* Wait for a request from the dispatch routines. */
; 1987 : 		KeWaitForSingleObject ((PVOID) & Extension->RequestSemaphore, Executive, KernelMode, FALSE, NULL);

  00323	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00328	48 83 c1 58	 add	 rcx, 88			; 00000058H
  0032c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00335	45 33 c9	 xor	 r9d, r9d
  00338	45 33 c0	 xor	 r8d, r8d
  0033b	33 d2		 xor	 edx, edx
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
$LN4@VolumeThre:

; 1988 : 
; 1989 : 		for (;;)
; 1990 : 		{
; 1991 : 			PIO_STACK_LOCATION irpSp;
; 1992 : 			PLIST_ENTRY request;
; 1993 : 			PIRP irp;
; 1994 : 
; 1995 : 			request = ExInterlockedRemoveHeadList (&Extension->ListEntry, &Extension->ListSpinLock);

  00343	48 8b 54 24 38	 mov	 rdx, QWORD PTR Extension$[rsp]
  00348	48 83 c2 40	 add	 rdx, 64			; 00000040H
  0034c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00351	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00355	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList
  0035b	48 89 44 24 58	 mov	 QWORD PTR request$31198[rsp], rax

; 1996 : 			if (request == NULL)

  00360	48 83 7c 24 58
	00		 cmp	 QWORD PTR request$31198[rsp], 0
  00366	75 05		 jne	 SHORT $LN2@VolumeThre

; 1997 : 				break;

  00368	e9 97 00 00 00	 jmp	 $LN3@VolumeThre
$LN2@VolumeThre:

; 1998 : 
; 1999 : 			irp = CONTAINING_RECORD (request, IRP, Tail.Overlay.ListEntry);

  0036d	48 8b 44 24 58	 mov	 rax, QWORD PTR request$31198[rsp]
  00372	48 2d a8 00 00
	00		 sub	 rax, 168		; 000000a8H
  00378	48 89 44 24 50	 mov	 QWORD PTR irp$31199[rsp], rax

; 2000 : 			irpSp = IoGetCurrentIrpStackLocation (irp);

  0037d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR irp$31199[rsp]
  00382	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  00387	48 89 44 24 60	 mov	 QWORD PTR irpSp$31197[rsp], rax

; 2001 : 
; 2002 : 			ASSERT (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);

  0038c	48 8b 44 24 60	 mov	 rax, QWORD PTR irpSp$31197[rsp]
  00391	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00394	83 f8 0e	 cmp	 eax, 14
  00397	74 2a		 je	 SHORT $LN17@VolumeThre
  00399	45 33 c9	 xor	 r9d, r9d
  0039c	41 b8 d2 07 00
	00		 mov	 r8d, 2002		; 000007d2H
  003a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  003a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@
  003b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  003b6	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv214[rsp], 0
  003c1	eb 0b		 jmp	 SHORT $LN18@VolumeThre
$LN17@VolumeThre:
  003c3	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv214[rsp], 1
$LN18@VolumeThre:

; 2003 : 
; 2004 : 			ProcessVolumeDeviceControlIrp (DeviceObject, Extension, irp);

  003ce	4c 8b 44 24 50	 mov	 r8, QWORD PTR irp$31199[rsp]
  003d3	48 8b 54 24 38	 mov	 rdx, QWORD PTR Extension$[rsp]
  003d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  003dd	e8 00 00 00 00	 call	 ProcessVolumeDeviceControlIrp

; 2005 : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, irp);

  003e2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  003e7	48 81 c1 80 01
	00 00		 add	 rcx, 384		; 00000180H
  003ee	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  003f4	48 8b 54 24 50	 mov	 rdx, QWORD PTR irp$31199[rsp]
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 2006 : 		}

  003ff	e9 3f ff ff ff	 jmp	 $LN4@VolumeThre
$LN3@VolumeThre:

; 2007 : 
; 2008 : 		if (Extension->bThreadShouldQuit)

  00404	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00409	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  0040d	74 34		 je	 SHORT $LN1@VolumeThre

; 2009 : 		{
; 2010 : 			Dump ("Closing volume\n");

  0040f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@
  00416	e8 00 00 00 00	 call	 DbgPrint

; 2011 : 			EncryptedIoQueueStop (&Extension->Queue);

  0041b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00420	48 81 c1 e0 00
	00 00		 add	 rcx, 224		; 000000e0H
  00427	e8 00 00 00 00	 call	 EncryptedIoQueueStop

; 2012 : 
; 2013 : 			GSTCloseVolume (DeviceObject, Extension);

  0042c	48 8b 54 24 38	 mov	 rdx, QWORD PTR Extension$[rsp]
  00431	48 8b 4c 24 48	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00436	e8 00 00 00 00	 call	 GSTCloseVolume

; 2014 : 			PsTerminateSystemThread (STATUS_SUCCESS);

  0043b	33 c9		 xor	 ecx, ecx
  0043d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN1@VolumeThre:

; 2015 : 		}
; 2016 : 	}

  00443	e9 db fe ff ff	 jmp	 $LN6@VolumeThre

; 2017 : }

  00448	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0044f	c3		 ret	 0
VolumeThreadProc ENDP
_TEXT	ENDS
PUBLIC	GSTStartVolumeThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTStartVolumeThread DD imagerel $LN8
	DD	imagerel $LN8+586
	DD	imagerel $unwind$GSTStartVolumeThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTStartVolumeThread DD 031701H
	DD	0140117H
	DD	03010H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTStartVolumeThread
_TEXT	SEGMENT
threadObjAttributes$ = 64
pThreadBlock$ = 112
qos$ = 120
ntStatus$ = 136
hThread$ = 144
DeviceObject$ = 176
Extension$ = 184
mount$ = 192
GSTStartVolumeThread PROC				; COMDAT

; 1762 : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 1763 : 	PTHREAD_BLOCK pThreadBlock = GSTalloc (sizeof (THREAD_BLOCK));

  00017	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0001d	ba 30 02 00 00	 mov	 edx, 560		; 00000230H
  00022	33 c9		 xor	 ecx, ecx
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0002a	48 89 44 24 70	 mov	 QWORD PTR pThreadBlock$[rsp], rax

; 1764 : 	HANDLE hThread;
; 1765 : 	NTSTATUS ntStatus;
; 1766 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1767 : 	SECURITY_QUALITY_OF_SERVICE qos;
; 1768 : 
; 1769 : 	Dump ("Starting thread...\n");

  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@
  00036	e8 00 00 00 00	 call	 DbgPrint

; 1770 : 
; 1771 : 	if (pThreadBlock == NULL)

  0003b	48 83 7c 24 70
	00		 cmp	 QWORD PTR pThreadBlock$[rsp], 0
  00041	75 0c		 jne	 SHORT $LN5@GSTStartVo

; 1772 : 	{
; 1773 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00043	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00048	e9 f4 01 00 00	 jmp	 $LN6@GSTStartVo

; 1774 : 	}
; 1775 : 	else

  0004d	eb 24		 jmp	 SHORT $LN4@GSTStartVo
$LN5@GSTStartVo:

; 1776 : 	{
; 1777 : 		pThreadBlock->DeviceObject = DeviceObject;

  0004f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  00054	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  0005c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1778 : 		pThreadBlock->mount = mount;

  0005f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  00064	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0006c	48 89 81 28 02
	00 00		 mov	 QWORD PTR [rcx+552], rax
$LN4@GSTStartVo:

; 1779 : 	}
; 1780 : 
; 1781 : 	qos.Length = sizeof (qos);

  00073	c7 44 24 78 0c
	00 00 00	 mov	 DWORD PTR qos$[rsp], 12

; 1782 : 	qos.ContextTrackingMode = SECURITY_STATIC_TRACKING;

  0007b	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR qos$[rsp+8], 0

; 1783 : 	qos.EffectiveOnly = TRUE;

  00083	c6 84 24 81 00
	00 00 01	 mov	 BYTE PTR qos$[rsp+9], 1

; 1784 : 	qos.ImpersonationLevel = SecurityImpersonation;

  0008b	c7 44 24 7c 02
	00 00 00	 mov	 DWORD PTR qos$[rsp+4], 2

; 1785 : 
; 1786 : 	ntStatus = SeCreateClientSecurity (PsGetCurrentThread(), &qos, FALSE, &Extension->SecurityClientContext);

  00093	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR Extension$[rsp]
  0009b	48 81 c3 f0 05
	00 00		 add	 rbx, 1520		; 000005f0H
  000a2	e8 00 00 00 00	 call	 PsGetCurrentThread
  000a7	4c 8b cb	 mov	 r9, rbx
  000aa	45 33 c0	 xor	 r8d, r8d
  000ad	48 8d 54 24 78	 lea	 rdx, QWORD PTR qos$[rsp]
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCreateClientSecurity
  000bb	89 84 24 88 00
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 1787 : 	if (!NT_SUCCESS (ntStatus))

  000c2	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  000ca	7d 05		 jge	 SHORT $LN3@GSTStartVo

; 1788 : 		goto ret;

  000cc	e9 59 01 00 00	 jmp	 $ret$31117
$LN3@GSTStartVo:

; 1789 : 
; 1790 : 	Extension->SecurityClientContextValid = TRUE;

  000d1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000d9	c7 80 e8 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1512], 1

; 1791 : 
; 1792 : 	Extension->bThreadShouldQuit = FALSE;

  000e3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000eb	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 1793 : 
; 1794 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  000f2	c7 44 24 40 30
	00 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp], 48 ; 00000030H
  000fa	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+8], 0
  00103	c7 44 24 58 00
	02 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp+24], 512 ; 00000200H
  0010b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+16], 0
  00114	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+32], 0
  0011d	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+40], 0

; 1795 : 
; 1796 : 	ntStatus = PsCreateSystemThread (&hThread,
; 1797 : 					 THREAD_ALL_ACCESS,
; 1798 : 					 &threadObjAttributes,
; 1799 : 					 NULL,
; 1800 : 					 NULL,
; 1801 : 					 VolumeThreadProc,
; 1802 : 					 pThreadBlock);

  00126	48 8b 44 24 70	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  0012b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00130	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:VolumeThreadProc
  00137	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0013c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00145	45 33 c9	 xor	 r9d, r9d
  00148	4c 8d 44 24 40	 lea	 r8, QWORD PTR threadObjAttributes$[rsp]
  0014d	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  00152	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR hThread$[rsp]
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread
  00160	89 84 24 88 00
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 1803 : 
; 1804 : 	if (!NT_SUCCESS (ntStatus))

  00167	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0016f	7d 11		 jge	 SHORT $LN2@GSTStartVo

; 1805 : 	{
; 1806 : 		Dump ("PsCreateSystemThread Failed END\n");

  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@
  00178	e8 00 00 00 00	 call	 DbgPrint

; 1807 : 		goto ret;

  0017d	e9 a8 00 00 00	 jmp	 $ret$31117
$LN2@GSTStartVo:

; 1808 : 	}
; 1809 : 
; 1810 : 	ntStatus = ObReferenceObjectByHandle (hThread,
; 1811 : 				   THREAD_ALL_ACCESS,
; 1812 : 				   NULL,
; 1813 : 				   KernelMode,
; 1814 : 				   &Extension->peThread,
; 1815 : 				   NULL);

  00182	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0018a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0018e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00197	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019c	45 33 c9	 xor	 r9d, r9d
  0019f	45 33 c0	 xor	 r8d, r8d
  001a2	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  001a7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR hThread$[rsp]
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  001b5	89 84 24 88 00
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 1816 : 
; 1817 : 	ZwClose (hThread);

  001bc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR hThread$[rsp]
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1818 : 
; 1819 : 	if (!NT_SUCCESS (ntStatus))

  001ca	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  001d2	7d 02		 jge	 SHORT $LN1@GSTStartVo

; 1820 : 		goto ret;

  001d4	eb 54		 jmp	 SHORT $ret$31117
$LN1@GSTStartVo:

; 1821 : 
; 1822 : 	Dump ("Waiting for thread to initialize...\n");

  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@
  001dd	e8 00 00 00 00	 call	 DbgPrint

; 1823 : 
; 1824 : 	KeWaitForSingleObject (&Extension->keCreateEvent,
; 1825 : 			       Executive,
; 1826 : 			       KernelMode,
; 1827 : 			       FALSE,
; 1828 : 			       NULL);

  001e2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  001ea	48 83 c1 28	 add	 rcx, 40			; 00000028H
  001ee	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001f7	45 33 c9	 xor	 r9d, r9d
  001fa	45 33 c0	 xor	 r8d, r8d
  001fd	33 d2		 xor	 edx, edx
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1829 : 
; 1830 : 	Dump ("Waiting completed! Thread returns 0x%08x\n", pThreadBlock->ntCreateStatus);

  00205	4c 8b 5c 24 70	 mov	 r11, QWORD PTR pThreadBlock$[rsp]
  0020a	41 8b 53 08	 mov	 edx, DWORD PTR [r11+8]
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@
  00215	e8 00 00 00 00	 call	 DbgPrint

; 1831 : 	ntStatus = pThreadBlock->ntCreateStatus;

  0021a	4c 8b 5c 24 70	 mov	 r11, QWORD PTR pThreadBlock$[rsp]
  0021f	41 8b 43 08	 mov	 eax, DWORD PTR [r11+8]
  00223	89 84 24 88 00
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax
$ret$31117:

; 1832 : 
; 1833 : ret:
; 1834 : 	GSTfree (pThreadBlock);

  0022a	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0022f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  00234	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 1835 : 	return ntStatus;

  0023a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
$LN6@GSTStartVo:

; 1836 : }

  00241	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00248	5b		 pop	 rbx
  00249	c3		 ret	 0
GSTStartVolumeThread ENDP
PUBLIC	MountDevice
EXTRN	__C_specific_handler:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountDevice DD imagerel $LN30
	DD	imagerel $LN30+997
	DD	imagerel $unwind$MountDevice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountDevice$filt$0 DD imagerel MountDevice$filt$0
	DD	imagerel MountDevice$filt$0+29
	DD	imagerel $unwind$MountDevice$filt$0
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountDevice$filt$0 DD 020f01H
	DD	0500b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountDevice DD 021109H
	DD	0150111H
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN30+832
	DD	imagerel $LN30+912
	DD	imagerel MountDevice$filt$0
	DD	imagerel $LN30+912
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT MountDevice
_TEXT	SEGMENT
NewDeviceObject$ = 48
ntStatus$ = 56
accessToken$31871 = 64
NewExtension$31868 = 72
subContext$31870 = 80
tokenUser$31882 = 112
sidLength$31885 = 120
volumeFileObject$31898 = 128
volumeHandle$31897 = 136
fsStatus$31905 = 144
tv86 = 152
DeviceObject$ = 176
mount$ = 184
MountDevice PROC					; COMDAT

; 2870 : {

$LN30:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2871 : 	PDEVICE_OBJECT NewDeviceObject;
; 2872 : 	NTSTATUS ntStatus;
; 2873 : 
; 2874 : 	// Make sure the user is asking for a reasonable nDosDriveNo
; 2875 : 	if (mount->nDosDriveNo >= 0 && mount->nDosDriveNo <= 25 && IsDriveLetterAvailable (mount->nDosDriveNo))

  00011	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00019	83 b8 64 02 00
	00 00		 cmp	 DWORD PTR [rax+612], 0
  00020	7c 36		 jl	 SHORT $LN20@MountDevic
  00022	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0002a	83 b8 64 02 00
	00 19		 cmp	 DWORD PTR [rax+612], 25
  00031	7f 25		 jg	 SHORT $LN20@MountDevic
  00033	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0003b	8b 88 64 02 00
	00		 mov	 ecx, DWORD PTR [rax+612]
  00041	e8 00 00 00 00	 call	 IsDriveLetterAvailable
  00046	85 c0		 test	 eax, eax
  00048	74 0e		 je	 SHORT $LN20@MountDevic

; 2876 : 	{
; 2877 : 		Dump ("Mount request looks valid\n");

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@
  00051	e8 00 00 00 00	 call	 DbgPrint

; 2878 : 	}
; 2879 : 	else

  00056	eb 25		 jmp	 SHORT $LN19@MountDevic
$LN20@MountDevic:

; 2880 : 	{
; 2881 : 		Dump ("WARNING: MOUNT DRIVE LETTER INVALID\n");

  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@
  0005f	e8 00 00 00 00	 call	 DbgPrint

; 2882 : 		mount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  00064	4c 8b 9c 24 b8
	00 00 00	 mov	 r11, QWORD PTR mount$[rsp]
  0006c	41 c7 03 05 00
	00 00		 mov	 DWORD PTR [r11], 5

; 2883 : 		return ERR_DRIVE_NOT_FOUND;

  00073	b8 05 00 00 00	 mov	 eax, 5
  00078	e9 60 03 00 00	 jmp	 $LN25@MountDevic
$LN19@MountDevic:

; 2884 : 	}
; 2885 : 
; 2886 : 	if (!SelfTestsPassed)

  0007d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR SelfTestsPassed, 0
  00084	75 18		 jne	 SHORT $LN18@MountDevic

; 2887 : 	{
; 2888 : 		mount->nReturnCode = ERR_SELF_TESTS_FAILED;

  00086	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0008e	c7 00 13 00 00
	00		 mov	 DWORD PTR [rax], 19

; 2889 : 		return ERR_SELF_TESTS_FAILED;

  00094	b8 13 00 00 00	 mov	 eax, 19
  00099	e9 3f 03 00 00	 jmp	 $LN25@MountDevic
$LN18@MountDevic:

; 2890 : 	}
; 2891 : 
; 2892 : 	ntStatus = GSTCreateDeviceObject (DeviceObject->DriverObject, &NewDeviceObject, mount);

  0009e	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR mount$[rsp]
  000a6	48 8d 54 24 30	 lea	 rdx, QWORD PTR NewDeviceObject$[rsp]
  000ab	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  000b3	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b7	e8 00 00 00 00	 call	 GSTCreateDeviceObject
  000bc	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2893 : 
; 2894 : 	if (!NT_SUCCESS (ntStatus))

  000c0	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  000c5	7d 1e		 jge	 SHORT $LN17@MountDevic

; 2895 : 	{
; 2896 : 		Dump ("Mount CREATE DEVICE ERROR, ntStatus = 0x%08x\n", ntStatus);

  000c7	8b 54 24 38	 mov	 edx, DWORD PTR ntStatus$[rsp]
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@
  000d2	e8 00 00 00 00	 call	 DbgPrint

; 2897 : 		return ntStatus;

  000d7	8b 44 24 38	 mov	 eax, DWORD PTR ntStatus$[rsp]
  000db	e9 fd 02 00 00	 jmp	 $LN25@MountDevic

; 2898 : 	}
; 2899 : 	else

  000e0	e9 f8 02 00 00	 jmp	 $LN25@MountDevic
$LN17@MountDevic:

; 2900 : 	{
; 2901 : 		PEXTENSION NewExtension = (PEXTENSION) NewDeviceObject->DeviceExtension;

  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  000ea	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000ee	48 89 44 24 48	 mov	 QWORD PTR NewExtension$31868[rsp], rax

; 2902 : 		SECURITY_SUBJECT_CONTEXT subContext;
; 2903 : 		PACCESS_TOKEN accessToken;
; 2904 : 
; 2905 : 		SeCaptureSubjectContext (&subContext);

  000f3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR subContext$31870[rsp]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCaptureSubjectContext

; 2906 : 		accessToken = SeQuerySubjectContextToken (&subContext);

  000fe	48 83 7c 24 50
	00		 cmp	 QWORD PTR subContext$31870[rsp], 0
  00104	74 0f		 je	 SHORT $LN23@MountDevic
  00106	48 8b 44 24 50	 mov	 rax, QWORD PTR subContext$31870[rsp]
  0010b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  00113	eb 0d		 jmp	 SHORT $LN24@MountDevic
$LN23@MountDevic:
  00115	48 8b 44 24 60	 mov	 rax, QWORD PTR subContext$31870[rsp+16]
  0011a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
$LN24@MountDevic:
  00122	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv86[rsp]
  0012a	48 89 44 24 40	 mov	 QWORD PTR accessToken$31871[rsp], rax

; 2907 : 
; 2908 : 		if (!accessToken)

  0012f	48 83 7c 24 40
	00		 cmp	 QWORD PTR accessToken$31871[rsp], 0
  00135	75 0d		 jne	 SHORT $LN15@MountDevic

; 2909 : 		{
; 2910 : 			ntStatus = STATUS_INVALID_PARAMETER;

  00137	c7 44 24 38 0d
	00 00 c0	 mov	 DWORD PTR ntStatus$[rsp], -1073741811 ; ffffffffc000000dH

; 2911 : 		}
; 2912 : 		else

  0013f	e9 9b 00 00 00	 jmp	 $LN14@MountDevic
$LN15@MountDevic:

; 2913 : 		{
; 2914 : 			PTOKEN_USER tokenUser;
; 2915 : 
; 2916 : 			ntStatus = SeQueryInformationToken (accessToken, TokenUser, &tokenUser);

  00144	4c 8d 44 24 70	 lea	 r8, QWORD PTR tokenUser$31882[rsp]
  00149	ba 01 00 00 00	 mov	 edx, 1
  0014e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR accessToken$31871[rsp]
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeQueryInformationToken
  00159	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2917 : 			if (NT_SUCCESS (ntStatus))

  0015d	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00162	7c 7b		 jl	 SHORT $LN14@MountDevic

; 2918 : 			{
; 2919 : 				ULONG sidLength = RtlLengthSid (tokenUser->User.Sid);

  00164	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenUser$31882[rsp]
  00169	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlLengthSid
  00172	89 44 24 78	 mov	 DWORD PTR sidLength$31885[rsp], eax

; 2920 : 
; 2921 : 				NewExtension->UserSid = GSTalloc (sidLength);

  00176	8b 54 24 78	 mov	 edx, DWORD PTR sidLength$31885[rsp]
  0017a	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00180	33 c9		 xor	 ecx, ecx
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00188	4c 8b d8	 mov	 r11, rax
  0018b	48 8b 44 24 48	 mov	 rax, QWORD PTR NewExtension$31868[rsp]
  00190	4c 89 98 e0 05
	00 00		 mov	 QWORD PTR [rax+1504], r11

; 2922 : 				if (!NewExtension->UserSid)

  00197	48 8b 44 24 48	 mov	 rax, QWORD PTR NewExtension$31868[rsp]
  0019c	48 83 b8 e0 05
	00 00 00	 cmp	 QWORD PTR [rax+1504], 0
  001a4	75 0a		 jne	 SHORT $LN12@MountDevic

; 2923 : 					ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  001a6	c7 44 24 38 9a
	00 00 c0	 mov	 DWORD PTR ntStatus$[rsp], -1073741670 ; ffffffffc000009aH

; 2924 : 				else

  001ae	eb 22		 jmp	 SHORT $LN11@MountDevic
$LN12@MountDevic:

; 2925 : 					ntStatus = RtlCopySid (sidLength, NewExtension->UserSid, tokenUser->User.Sid);

  001b0	4c 8b 44 24 70	 mov	 r8, QWORD PTR tokenUser$31882[rsp]
  001b5	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  001b8	48 8b 54 24 48	 mov	 rdx, QWORD PTR NewExtension$31868[rsp]
  001bd	48 8b 92 e0 05
	00 00		 mov	 rdx, QWORD PTR [rdx+1504]
  001c4	8b 4c 24 78	 mov	 ecx, DWORD PTR sidLength$31885[rsp]
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopySid
  001ce	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax
$LN11@MountDevic:

; 2926 : 
; 2927 : 				ExFreePool (tokenUser);		// Documented in newer versions of WDK

  001d2	33 d2		 xor	 edx, edx
  001d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenUser$31882[rsp]
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN14@MountDevic:

; 2928 : 			}
; 2929 : 		}
; 2930 : 
; 2931 : 		SeReleaseSubjectContext (&subContext);

  001df	48 8d 4c 24 50	 lea	 rcx, QWORD PTR subContext$31870[rsp]
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeReleaseSubjectContext

; 2932 : 
; 2933 : 		if (NT_SUCCESS (ntStatus))

  001ea	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  001ef	7c 1b		 jl	 SHORT $LN10@MountDevic

; 2934 : 			ntStatus = GSTStartVolumeThread (NewDeviceObject, NewExtension, mount);

  001f1	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR mount$[rsp]
  001f9	48 8b 54 24 48	 mov	 rdx, QWORD PTR NewExtension$31868[rsp]
  001fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  00203	e8 00 00 00 00	 call	 GSTStartVolumeThread
  00208	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax
$LN10@MountDevic:

; 2935 : 
; 2936 : 		if (!NT_SUCCESS (ntStatus))

  0020c	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00211	7d 2d		 jge	 SHORT $LN9@MountDevic

; 2937 : 		{
; 2938 : 			Dump ("Mount FAILURE NT ERROR, ntStatus = 0x%08x\n", ntStatus);

  00213	8b 54 24 38	 mov	 edx, DWORD PTR ntStatus$[rsp]
  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@
  0021e	e8 00 00 00 00	 call	 DbgPrint

; 2939 : 			GSTDeleteDeviceObject (NewDeviceObject, NewExtension);

  00223	48 8b 54 24 48	 mov	 rdx, QWORD PTR NewExtension$31868[rsp]
  00228	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  0022d	e8 00 00 00 00	 call	 GSTDeleteDeviceObject

; 2940 : 			return ntStatus;

  00232	8b 44 24 38	 mov	 eax, DWORD PTR ntStatus$[rsp]
  00236	e9 a2 01 00 00	 jmp	 $LN25@MountDevic

; 2941 : 		}
; 2942 : 		else

  0023b	e9 9d 01 00 00	 jmp	 $LN25@MountDevic
$LN9@MountDevic:

; 2943 : 		{
; 2944 : 			if (mount->nReturnCode == 0)

  00240	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00248	83 38 00	 cmp	 DWORD PTR [rax], 0
  0024b	0f 85 65 01 00
	00		 jne	 $LN7@MountDevic

; 2945 : 			{
; 2946 : 				HANDLE volumeHandle;
; 2947 : 				PFILE_OBJECT volumeFileObject;
; 2948 : 
; 2949 : 				Dump ("Mount SUCCESS GST code = 0x%08x READ-ONLY = %d\n", mount->nReturnCode, NewExtension->bReadOnly);

  00251	48 8b 44 24 48	 mov	 rax, QWORD PTR NewExtension$31868[rsp]
  00256	44 8b 80 98 03
	00 00		 mov	 r8d, DWORD PTR [rax+920]
  0025d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00265	8b 10		 mov	 edx, DWORD PTR [rax]
  00267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DA@KKKCGJKE@Mount?5SUCCESS?5GST?5code?5?$DN?50x?$CF08x?5@FNODOBFM@
  0026e	e8 00 00 00 00	 call	 DbgPrint

; 2950 : 
; 2951 : 				if (NewExtension->bReadOnly)

  00273	4c 8b 5c 24 48	 mov	 r11, QWORD PTR NewExtension$31868[rsp]
  00278	41 83 bb 98 03
	00 00 00	 cmp	 DWORD PTR [r11+920], 0
  00280	74 13		 je	 SHORT $LN6@MountDevic

; 2952 : 					NewDeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  00282	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  00287	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  0028a	83 c9 02	 or	 ecx, 2
  0028d	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  00292	89 48 34	 mov	 DWORD PTR [rax+52], ecx
$LN6@MountDevic:

; 2953 : 
; 2954 : 				NewDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00295	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  0029a	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  0029d	81 e1 7f ff ff
	ff		 and	 ecx, -129		; ffffff7fH
  002a3	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  002a8	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 2955 : 
; 2956 : 				NewExtension->UniqueVolumeId = LastUniqueVolumeId++;

  002ab	48 8b 4c 24 48	 mov	 rcx, QWORD PTR NewExtension$31868[rsp]
  002b0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR LastUniqueVolumeId
  002b6	89 41 10	 mov	 DWORD PTR [rcx+16], eax
  002b9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR LastUniqueVolumeId
  002bf	83 c0 01	 add	 eax, 1
  002c2	89 05 00 00 00
	00		 mov	 DWORD PTR LastUniqueVolumeId, eax

; 2957 : 
; 2958 : 				if (mount->bMountManager)

  002c8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  002d0	83 b8 78 02 00
	00 00		 cmp	 DWORD PTR [rax+632], 0
  002d7	74 0d		 je	 SHORT $LN5@MountDevic

; 2959 : 					MountManagerMount (mount);

  002d9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR mount$[rsp]
  002e1	e8 00 00 00 00	 call	 MountManagerMount
$LN5@MountDevic:

; 2960 : 
; 2961 : 				NewExtension->bMountManager = mount->bMountManager;

  002e6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR NewExtension$31868[rsp]
  002eb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  002f3	8b 80 78 02 00
	00		 mov	 eax, DWORD PTR [rax+632]
  002f9	89 81 a8 03 00
	00		 mov	 DWORD PTR [rcx+936], eax

; 2962 : 
; 2963 : 				// We create symbolic link even if mount manager is notified of
; 2964 : 				// arriving volume as it apparently sometimes fails to create the link
; 2965 : 				CreateDriveLink (mount->nDosDriveNo);

  002ff	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00307	8b 88 64 02 00
	00		 mov	 ecx, DWORD PTR [rax+612]
  0030d	e8 00 00 00 00	 call	 CreateDriveLink

; 2966 : 
; 2967 : 				mount->FilesystemDirty = FALSE;

  00312	4c 8b 9c 24 b8
	00 00 00	 mov	 r11, QWORD PTR mount$[rsp]
  0031a	41 c7 43 04 00
	00 00 00	 mov	 DWORD PTR [r11+4], 0

; 2968 : 
; 2969 : 				if (NT_SUCCESS (GSTOpenFsVolume (NewExtension, &volumeHandle, &volumeFileObject)))

  00322	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR volumeFileObject$31898[rsp]
  0032a	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR volumeHandle$31897[rsp]
  00332	48 8b 4c 24 48	 mov	 rcx, QWORD PTR NewExtension$31868[rsp]
  00337	e8 00 00 00 00	 call	 GSTOpenFsVolume
  0033c	85 c0		 test	 eax, eax
  0033e	7c 74		 jl	 SHORT $LN4@MountDevic

; 2970 : 				{
; 2971 : 					__try
; 2972 : 					{
; 2973 : 						ULONG fsStatus;
; 2974 : 
; 2975 : 						if (NT_SUCCESS (GSTFsctlCall (volumeFileObject, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &fsStatus, sizeof (fsStatus)))
; 2976 : 							&& (fsStatus & VOLUME_IS_DIRTY))

  00340	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  00348	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR fsStatus$31905[rsp]
  00350	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00355	45 33 c9	 xor	 r9d, r9d
  00358	45 33 c0	 xor	 r8d, r8d
  0035b	ba 78 00 09 00	 mov	 edx, 589944		; 00090078H
  00360	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR volumeFileObject$31898[rsp]
  00368	e8 00 00 00 00	 call	 GSTFsctlCall
  0036d	85 c0		 test	 eax, eax
  0036f	7c 1d		 jl	 SHORT $LN2@MountDevic
  00371	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR fsStatus$31905[rsp]
  00378	83 e0 01	 and	 eax, 1
  0037b	85 c0		 test	 eax, eax
  0037d	74 0f		 je	 SHORT $LN2@MountDevic

; 2977 : 						{
; 2978 : 							mount->FilesystemDirty = TRUE;

  0037f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00387	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1
$LN2@MountDevic:

; 2979 : 						}
; 2980 : 					}

  0038e	eb 0f		 jmp	 SHORT $LN29@MountDevic
$LN27@MountDevic:

; 2981 : 					__except (EXCEPTION_EXECUTE_HANDLER)
; 2982 : 					{
; 2983 : 						mount->FilesystemDirty = TRUE;

  00390	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00398	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1
$LN29@MountDevic:

; 2984 : 					}
; 2985 : 
; 2986 : 
; 2987 : 					GSTCloseFsVolume (volumeHandle, volumeFileObject);

  0039f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR volumeFileObject$31898[rsp]
  003a7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR volumeHandle$31897[rsp]
  003af	e8 00 00 00 00	 call	 GSTCloseFsVolume
$LN4@MountDevic:

; 2988 : 				}
; 2989 : 			}
; 2990 : 			else

  003b4	eb 25		 jmp	 SHORT $LN1@MountDevic
$LN7@MountDevic:

; 2991 : 			{
; 2992 : 				Dump ("Mount FAILURE GST code = 0x%08x\n", mount->nReturnCode);

  003b6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  003be	8b 10		 mov	 edx, DWORD PTR [rax]
  003c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@DOMBPHHO@Mount?5FAILURE?5GST?5code?5?$DN?50x?$CF08x?6@FNODOBFM@
  003c7	e8 00 00 00 00	 call	 DbgPrint

; 2993 : 				GSTDeleteDeviceObject (NewDeviceObject, NewExtension);

  003cc	48 8b 54 24 48	 mov	 rdx, QWORD PTR NewExtension$31868[rsp]
  003d1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  003d6	e8 00 00 00 00	 call	 GSTDeleteDeviceObject
$LN1@MountDevic:

; 2994 : 			}
; 2995 : 			
; 2996 : 			return STATUS_SUCCESS;

  003db	33 c0		 xor	 eax, eax
$LN25@MountDevic:

; 2997 : 		}
; 2998 : 	}
; 2999 : }

  003dd	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003e4	c3		 ret	 0
MountDevice ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
NewDeviceObject$ = 48
ntStatus$ = 56
accessToken$31871 = 64
NewExtension$31868 = 72
subContext$31870 = 80
tokenUser$31882 = 112
sidLength$31885 = 120
volumeFileObject$31898 = 128
volumeHandle$31897 = 136
fsStatus$31905 = 144
tv86 = 152
DeviceObject$ = 176
mount$ = 184
MountDevice$filt$0 PROC
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b ea	 mov	 rbp, rdx
$LN26@MountDevic@2:

; 2981 : 					__except (EXCEPTION_EXECUTE_HANDLER)

  00012	b8 01 00 00 00	 mov	 eax, 1
$LN28@MountDevic@2:
  00017	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
MountDevice$filt$0 ENDP
text$x	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	ProcessMainDeviceControlIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessMainDeviceControlIrp DD imagerel $LN174
	DD	imagerel $LN174+8577
	DD	imagerel $unwind$ProcessMainDeviceControlIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessMainDeviceControlIrp DD 042a19H
	DD	0b30118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0588H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ProcessMainDeviceControlIrp
_TEXT	SEGMENT
ntStatus$ = 96
irpSp$ = 104
tmp$30697 = 112
deviceObjectCount$30709 = 116
drive$30720 = 120
FullFileName$30736 = 128
access$30739 = 144
offset$30738 = 152
opentest$30732 = 160
ObjectAttributes$30734 = 168
IoStatus$30737 = 216
NtFileHandle$30735 = 232
readBuffer$30754 = 240
i$30765 = 248
FullFileName$30789 = 256
readBuffer$30792 = 288
offset$30791 = 800
ObjectAttributes$30787 = 808
request$30785 = 856
IoStatus$30790 = 864
NtFileHandle$30788 = 880
i$30809 = 888
i$30811 = 896
list$30842 = 904
drive$30845 = 912
ListDevice$30844 = 920
ListExtension$30849 = 928
ListDevice$30878 = 936
prop$30876 = 944
ListExtension$30881 = 952
resolve$30891 = 960
ntStatus$30893 = 968
info$30898 = 976
pi$30900 = 992
ntStatus$30901 = 1136
lengthInfo$30910 = 1144
g$30923 = 1152
ntStatus$30925 = 1160
deviceObject$30936 = 1168
fileObject$30935 = 1176
name$30934 = 1184
request$30931 = 1200
status$30933 = 1208
mount$30951 = 1216
burnc$30962 = 1224
burnm$30960 = 1232
burnc$30971 = 1240
burnm$30969 = 1248
unmount$30978 = 1256
ListDevice$30980 = 1264
ListExtension$30982 = 1272
unmount$30990 = 1280
flags$31016 = 1288
request$31029 = 1296
tv67 = 1304
tv235 = 1312
tv248 = 1320
tv383 = 1328
tv392 = 1332
tv419 = 1336
tv425 = 1344
tv426 = 1352
tv427 = 1360
tv516 = 1368
tv518 = 1376
tv519 = 1384
tv520 = 1392
tv557 = 1396
tv567 = 1400
tv646 = 1404
tv870 = 1408
tv940 = 1412
__$ArrayPad$ = 1416
DeviceObject$ = 1456
Extension$ = 1464
Irp$ = 1472
ProcessMainDeviceControlIrp PROC			; COMDAT

; 913  : {

$LN174:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 05
	00 00		 sub	 rsp, 1432		; 00000598H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 88
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 914  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0002a	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00032	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  00037	48 89 44 24 68	 mov	 QWORD PTR irpSp$[rsp], rax

; 915  : 	NTSTATUS ntStatus;
; 916  : 
; 917  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0003c	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  00041	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00044	89 84 24 18 05
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  0004b	81 bc 24 18 05
	00 00 04 20 22
	00		 cmp	 DWORD PTR tv67[rsp], 2236420 ; 00222004H
  00056	77 30		 ja	 SHORT $LN169@ProcessMai
  00058	81 bc 24 18 05
	00 00 04 20 22
	00		 cmp	 DWORD PTR tv67[rsp], 2236420 ; 00222004H
  00063	74 69		 je	 SHORT $LN148@ProcessMai
  00065	81 bc 24 18 05
	00 00 04 20 07
	00		 cmp	 DWORD PTR tv67[rsp], 466948 ; 00072004H
  00070	0f 84 2f 0e 00
	00		 je	 $LN79@ProcessMai
  00076	81 bc 24 18 05
	00 00 18 20 07
	00		 cmp	 DWORD PTR tv67[rsp], 466968 ; 00072018H
  00081	74 4b		 je	 SHORT $LN148@ProcessMai
  00083	e9 a4 1e 00 00	 jmp	 $LN6@ProcessMai
$LN169@ProcessMai:
  00088	8b 84 24 18 05
	00 00		 mov	 eax, DWORD PTR tv67[rsp]
  0008f	2d 08 20 22 00	 sub	 eax, 2236424		; 00222008H
  00094	89 84 24 18 05
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  0009b	81 bc 24 18 05
	00 00 90 00 00
	00		 cmp	 DWORD PTR tv67[rsp], 144 ; 00000090H
  000a6	0f 87 80 1e 00
	00		 ja	 $LN6@ProcessMai
  000ac	8b 84 24 18 05
	00 00		 mov	 eax, DWORD PTR tv67[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000ba	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN172@ProcessMai[rcx+rax]
  000c2	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN173@ProcessMai[rcx+rax*4]
  000c9	48 03 c1	 add	 rax, rcx
  000cc	ff e0		 jmp	 rax
$LN148@ProcessMai:

; 918  : 	{
; 919  : 	case GST_IOCTL_GET_DRIVER_VERSION:
; 920  : 	case GST_IOCTL_LEGACY_GET_DRIVER_VERSION:
; 921  : 		if (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))

  000ce	41 b8 01 00 00
	00		 mov	 r8d, 1
  000d4	ba 04 00 00 00	 mov	 edx, 4
  000d9	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  000e1	e8 00 00 00 00	 call	 ValidateIOBufferSize
  000e6	85 c0		 test	 eax, eax
  000e8	74 39		 je	 SHORT $LN147@ProcessMai

; 922  : 		{
; 923  : 			LONG tmp = VERSION_NUM;

  000ea	c7 44 24 70 00
	13 00 00	 mov	 DWORD PTR tmp$30697[rsp], 4864 ; 00001300H

; 924  : 			memcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);

  000f2	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  000fa	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000fe	8b 44 24 70	 mov	 eax, DWORD PTR tmp$30697[rsp]
  00102	89 01		 mov	 DWORD PTR [rcx], eax

; 925  : 			Irp->IoStatus.Information = sizeof (LONG);

  00104	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0010c	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 926  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00114	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0011c	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN147@ProcessMai:

; 927  : 		}
; 928  : 		break;

  00123	e9 1e 1e 00 00	 jmp	 $LN149@ProcessMai
$LN146@ProcessMai:

; 929  : 
; 930  : 	case GST_IOCTL_GET_DEVICE_REFCOUNT:
; 931  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00128	41 b8 01 00 00
	00		 mov	 r8d, 1
  0012e	ba 04 00 00 00	 mov	 edx, 4
  00133	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0013b	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00140	85 c0		 test	 eax, eax
  00142	74 38		 je	 SHORT $LN145@ProcessMai

; 932  : 		{
; 933  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;

  00144	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0014c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00150	48 8b 84 24 b0
	05 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00158	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0015b	89 01		 mov	 DWORD PTR [rcx], eax

; 934  : 			Irp->IoStatus.Information = sizeof (int);

  0015d	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00165	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 935  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0016d	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00175	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN145@ProcessMai:

; 936  : 		}
; 937  : 		break;

  0017c	e9 c5 1d 00 00	 jmp	 $LN149@ProcessMai
$LN144@ProcessMai:

; 938  : 
; 939  : 	case GST_IOCTL_IS_DRIVER_UNLOAD_DISABLED:
; 940  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00181	41 b8 01 00 00
	00		 mov	 r8d, 1
  00187	ba 04 00 00 00	 mov	 edx, 4
  0018c	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00194	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00199	85 c0		 test	 eax, eax
  0019b	74 72		 je	 SHORT $LN143@ProcessMai

; 941  : 		{
; 942  : 			LONG deviceObjectCount = 0;

  0019d	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR deviceObjectCount$30709[rsp], 0

; 943  : 
; 944  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;

  001a5	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  001ad	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001b1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DriverUnloadDisabled
  001b7	89 01		 mov	 DWORD PTR [rcx], eax

; 945  : 
; 946  : 			if (IoEnumerateDeviceObjectList (GSTDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)

  001b9	4c 8d 4c 24 74	 lea	 r9, QWORD PTR deviceObjectCount$30709[rsp]
  001be	45 33 c0	 xor	 r8d, r8d
  001c1	33 d2		 xor	 edx, edx
  001c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR GSTDriverObject
  001ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoEnumerateDeviceObjectList
  001d0	3d 23 00 00 c0	 cmp	 eax, -1073741789	; ffffffffc0000023H
  001d5	75 19		 jne	 SHORT $LN142@ProcessMai
  001d7	83 7c 24 74 01	 cmp	 DWORD PTR deviceObjectCount$30709[rsp], 1
  001dc	7e 12		 jle	 SHORT $LN142@ProcessMai

; 947  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;

  001de	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  001e6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001ea	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN142@ProcessMai:

; 948  : 
; 949  : 			Irp->IoStatus.Information = sizeof (int);

  001f0	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  001f8	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 950  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00200	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00208	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN143@ProcessMai:

; 951  : 		}
; 952  : 		break;

  0020f	e9 32 1d 00 00	 jmp	 $LN149@ProcessMai
$LN141@ProcessMai:

; 953  : 
; 954  : 	case GST_IOCTL_IS_ANY_VOLUME_MOUNTED:
; 955  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00214	41 b8 01 00 00
	00		 mov	 r8d, 1
  0021a	ba 04 00 00 00	 mov	 edx, 4
  0021f	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00227	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0022c	85 c0		 test	 eax, eax
  0022e	0f 84 8c 00 00
	00		 je	 $LN140@ProcessMai

; 956  : 		{
; 957  : 			int drive;
; 958  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = 0;

  00234	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0023c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00240	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 959  : 
; 960  : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00246	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR drive$30720[rsp], 0
  0024e	eb 0b		 jmp	 SHORT $LN139@ProcessMai
$LN138@ProcessMai:
  00250	8b 44 24 78	 mov	 eax, DWORD PTR drive$30720[rsp]
  00254	83 c0 01	 add	 eax, 1
  00257	89 44 24 78	 mov	 DWORD PTR drive$30720[rsp], eax
$LN139@ProcessMai:
  0025b	83 7c 24 78 19	 cmp	 DWORD PTR drive$30720[rsp], 25
  00260	7f 24		 jg	 SHORT $LN137@ProcessMai

; 961  : 			{
; 962  : 				if (GetVirtualVolumeDeviceObject (drive))

  00262	8b 4c 24 78	 mov	 ecx, DWORD PTR drive$30720[rsp]
  00266	e8 00 00 00 00	 call	 GetVirtualVolumeDeviceObject
  0026b	48 85 c0	 test	 rax, rax
  0026e	74 14		 je	 SHORT $LN136@ProcessMai

; 963  : 				{
; 964  : 					*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  00270	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00278	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0027c	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 965  : 					break;

  00282	eb 02		 jmp	 SHORT $LN137@ProcessMai
$LN136@ProcessMai:

; 966  : 				}
; 967  : 			}

  00284	eb ca		 jmp	 SHORT $LN138@ProcessMai
$LN137@ProcessMai:

; 968  : 
; 969  : 			if (IsBootDriveMounted())

  00286	e8 00 00 00 00	 call	 IsBootDriveMounted
  0028b	85 c0		 test	 eax, eax
  0028d	74 12		 je	 SHORT $LN135@ProcessMai

; 970  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  0028f	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00297	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0029b	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN135@ProcessMai:

; 971  : 
; 972  : 			Irp->IoStatus.Information = sizeof (int);

  002a1	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002a9	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 973  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  002b1	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002b9	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN140@ProcessMai:

; 974  : 		}
; 975  : 		break;

  002c0	e9 81 1c 00 00	 jmp	 $LN149@ProcessMai
$LN134@ProcessMai:

; 976  : 
; 977  : 	case GST_IOCTL_OPEN_TEST:
; 978  : 		{
; 979  : 			OPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  002c5	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002cd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  002d1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR opentest$30732[rsp], rax

; 980  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 981  : 			HANDLE NtFileHandle;
; 982  : 			UNICODE_STRING FullFileName;
; 983  : 			IO_STATUS_BLOCK IoStatus;
; 984  : 			LARGE_INTEGER offset;
; 985  : 			ACCESS_MASK access = FILE_READ_ATTRIBUTES;

  002d9	c7 84 24 90 00
	00 00 80 00 00
	00		 mov	 DWORD PTR access$30739[rsp], 128 ; 00000080H

; 986  : 
; 987  : 			if (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))

  002e4	41 b8 02 00 00
	00		 mov	 r8d, 2
  002ea	ba 18 02 00 00	 mov	 edx, 536		; 00000218H
  002ef	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  002f7	e8 00 00 00 00	 call	 ValidateIOBufferSize
  002fc	85 c0		 test	 eax, eax
  002fe	75 05		 jne	 SHORT $LN133@ProcessMai

; 988  : 				break;

  00300	e9 41 1c 00 00	 jmp	 $LN149@ProcessMai
$LN133@ProcessMai:

; 989  : 
; 990  : 			EnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));

  00305	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  0030a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR opentest$30732[rsp]
  00312	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 991  : 			RtlInitUnicodeString (&FullFileName, opentest->wszFileName);

  00317	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR opentest$30732[rsp]
  0031f	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR FullFileName$30736[rsp]
  00327	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 992  : 
; 993  : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  0032d	c7 84 24 a8 00
	00 00 30 00 00
	00		 mov	 DWORD PTR ObjectAttributes$30734[rsp], 48 ; 00000030H
  00338	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$30734[rsp+8], 0
  00344	c7 84 24 c0 00
	00 00 40 02 00
	00		 mov	 DWORD PTR ObjectAttributes$30734[rsp+24], 576 ; 00000240H
  0034f	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR FullFileName$30736[rsp]
  00357	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR ObjectAttributes$30734[rsp+16], rax
  0035f	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$30734[rsp+32], 0
  0036b	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$30734[rsp+40], 0

; 994  : 
; 995  : 			if (opentest->bDetectGSTBootLoader || opentest->DetectFilesystem)

  00377	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$30732[rsp]
  0037f	83 b8 08 02 00
	00 00		 cmp	 DWORD PTR [rax+520], 0
  00386	75 11		 jne	 SHORT $LN131@ProcessMai
  00388	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$30732[rsp]
  00390	83 b8 10 02 00
	00 00		 cmp	 DWORD PTR [rax+528], 0
  00397	74 11		 je	 SHORT $LN132@ProcessMai
$LN131@ProcessMai:

; 996  : 				access |= FILE_READ_DATA;

  00399	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR access$30739[rsp]
  003a0	83 c8 01	 or	 eax, 1
  003a3	89 84 24 90 00
	00 00		 mov	 DWORD PTR access$30739[rsp], eax
$LN132@ProcessMai:

; 997  : 
; 998  : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 999  : 						 SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,
; 1000 : 						 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

  003aa	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR access$30739[rsp]
  003b1	81 ca 00 00 10
	00		 or	 edx, 1048576		; 00100000H
  003b7	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  003bf	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  003c8	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  003d0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  003d8	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  003e0	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  003e8	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  003f1	4c 8d 8c 24 d8
	00 00 00	 lea	 r9, QWORD PTR IoStatus$30737[rsp]
  003f9	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR ObjectAttributes$30734[rsp]
  00401	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR NtFileHandle$30735[rsp]
  00409	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  0040f	89 44 24 60	 mov	 DWORD PTR ntStatus$[rsp], eax

; 1001 : 
; 1002 : 			if (NT_SUCCESS (ntStatus))

  00413	83 7c 24 60 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00418	0f 8c 4e 02 00
	00		 jl	 $LN130@ProcessMai

; 1003 : 			{
; 1004 : 				opentest->GSTBootLoaderDetected = FALSE;

  0041e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$30732[rsp]
  00426	c7 80 0c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+524], 0

; 1005 : 				opentest->FilesystemDetected = FALSE;

  00430	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$30732[rsp]
  00438	c7 80 14 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+532], 0

; 1006 : 
; 1007 : 				if (opentest->bDetectGSTBootLoader || opentest->DetectFilesystem)

  00442	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$30732[rsp]
  0044a	83 b8 08 02 00
	00 00		 cmp	 DWORD PTR [rax+520], 0
  00451	75 15		 jne	 SHORT $LN128@ProcessMai
  00453	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$30732[rsp]
  0045b	83 b8 10 02 00
	00 00		 cmp	 DWORD PTR [rax+528], 0
  00462	0f 84 e2 01 00
	00		 je	 $LN129@ProcessMai
$LN128@ProcessMai:

; 1008 : 				{
; 1009 : 					byte *readBuffer = GSTalloc (GST_MAX_VOLUME_SECTOR_SIZE);

  00468	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0046e	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00473	33 c9		 xor	 ecx, ecx
  00475	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0047b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR readBuffer$30754[rsp], rax

; 1010 : 					if (!readBuffer)

  00483	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR readBuffer$30754[rsp], 0
  0048c	75 0d		 jne	 SHORT $LN127@ProcessMai

; 1011 : 					{
; 1012 : 						ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0048e	c7 44 24 60 9a
	00 00 c0	 mov	 DWORD PTR ntStatus$[rsp], -1073741670 ; ffffffffc000009aH

; 1013 : 					}
; 1014 : 					else

  00496	e9 af 01 00 00	 jmp	 $LN126@ProcessMai
$LN127@ProcessMai:

; 1015 : 					{
; 1016 : 						// Determine if the first sector contains a portion of the GostCrypt Boot Loader
; 1017 : 
; 1018 : 						offset.QuadPart = 0;

  0049b	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR offset$30738[rsp], 0

; 1019 : 
; 1020 : 						ntStatus = ZwReadFile (NtFileHandle,
; 1021 : 							NULL,
; 1022 : 							NULL,
; 1023 : 							NULL,
; 1024 : 							&IoStatus,
; 1025 : 							readBuffer,
; 1026 : 							GST_MAX_VOLUME_SECTOR_SIZE,
; 1027 : 							&offset,
; 1028 : 							NULL);

  004a7	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  004b0	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR offset$30738[rsp]
  004b8	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  004bd	c7 44 24 30 00
	10 00 00	 mov	 DWORD PTR [rsp+48], 4096 ; 00001000H
  004c5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR readBuffer$30754[rsp]
  004cd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004d2	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR IoStatus$30737[rsp]
  004da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004df	45 33 c9	 xor	 r9d, r9d
  004e2	45 33 c0	 xor	 r8d, r8d
  004e5	33 d2		 xor	 edx, edx
  004e7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR NtFileHandle$30735[rsp]
  004ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  004f5	89 44 24 60	 mov	 DWORD PTR ntStatus$[rsp], eax

; 1029 : 
; 1030 : 						if (NT_SUCCESS (ntStatus))

  004f9	83 7c 24 60 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  004fe	0f 8c 33 01 00
	00		 jl	 $LN125@ProcessMai

; 1031 : 						{
; 1032 : 							size_t i;
; 1033 : 
; 1034 : 							if (opentest->bDetectGSTBootLoader && IoStatus.Information >= GST_SECTOR_SIZE_BIOS)

  00504	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$30732[rsp]
  0050c	83 b8 08 02 00
	00 00		 cmp	 DWORD PTR [rax+520], 0
  00513	0f 84 82 00 00
	00		 je	 $LN124@ProcessMai
  00519	48 81 bc 24 e0
	00 00 00 00 02
	00 00		 cmp	 QWORD PTR IoStatus$30737[rsp+8], 512 ; 00000200H
  00525	72 74		 jb	 SHORT $LN124@ProcessMai

; 1035 : 							{
; 1036 : 								// Search for the string "GostCrypt"
; 1037 : 								for (i = 0; i < GST_SECTOR_SIZE_BIOS - strlen (GST_APP_NAME); ++i)

  00527	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$30765[rsp], 0
  00533	eb 14		 jmp	 SHORT $LN123@ProcessMai
$LN122@ProcessMai:
  00535	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR i$30765[rsp]
  0053d	48 83 c0 01	 add	 rax, 1
  00541	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR i$30765[rsp], rax
$LN123@ProcessMai:
  00549	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0054e	48 83 e8 09	 sub	 rax, 9
  00552	48 39 84 24 f8
	00 00 00	 cmp	 QWORD PTR i$30765[rsp], rax
  0055a	73 3f		 jae	 SHORT $LN121@ProcessMai

; 1038 : 								{
; 1039 : 									if (memcmp (readBuffer + i, GST_APP_NAME, strlen (GST_APP_NAME)) == 0)

  0055c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR i$30765[rsp]
  00564	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR readBuffer$30754[rsp]
  0056c	48 03 c8	 add	 rcx, rax
  0056f	41 b8 09 00 00
	00		 mov	 r8d, 9
  00575	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@
  0057c	e8 00 00 00 00	 call	 memcmp
  00581	85 c0		 test	 eax, eax
  00583	75 14		 jne	 SHORT $LN120@ProcessMai

; 1040 : 									{
; 1041 : 										opentest->GSTBootLoaderDetected = TRUE;

  00585	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$30732[rsp]
  0058d	c7 80 0c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+524], 1

; 1042 : 										break;

  00597	eb 02		 jmp	 SHORT $LN121@ProcessMai
$LN120@ProcessMai:

; 1043 : 									}
; 1044 : 								}

  00599	eb 9a		 jmp	 SHORT $LN122@ProcessMai
$LN121@ProcessMai:
$LN124@ProcessMai:

; 1045 : 							}
; 1046 : 
; 1047 : 							if (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))

  0059b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$30732[rsp]
  005a3	83 b8 10 02 00
	00 00		 cmp	 DWORD PTR [rax+528], 0
  005aa	0f 84 87 00 00
	00		 je	 $LN119@ProcessMai
  005b0	48 83 bc 24 e0
	00 00 00 08	 cmp	 QWORD PTR IoStatus$30737[rsp+8], 8
  005b9	72 7c		 jb	 SHORT $LN119@ProcessMai

; 1048 : 							{
; 1049 : 								switch (BE64 (*(uint64 *) readBuffer))

  005bb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR readBuffer$30754[rsp]
  005c3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  005c6	e8 00 00 00 00	 call	 MirrorBytes64
  005cb	48 89 84 24 20
	05 00 00	 mov	 QWORD PTR tv235[rsp], rax
  005d3	48 b8 53 4f 44
	53 4d 90 3c eb	 mov	 rax, -1496162314409980077 ; eb3c904d53444f53H
  005dd	48 39 84 24 20
	05 00 00	 cmp	 QWORD PTR tv235[rsp], rax
  005e5	74 3e		 je	 SHORT $LN116@ProcessMai
  005e7	48 b8 20 53 46
	54 4e 90 52 eb	 mov	 rax, -1489969860610469088 ; eb52904e54465320H
  005f1	48 39 84 24 20
	05 00 00	 cmp	 QWORD PTR tv235[rsp], rax
  005f9	74 2a		 je	 SHORT $LN116@ProcessMai
  005fb	48 b8 53 4f 44
	53 4d 90 58 eb	 mov	 rax, -1488281015062081709 ; eb58904d53444f53H
  00605	48 39 84 24 20
	05 00 00	 cmp	 QWORD PTR tv235[rsp], rax
  0060d	74 16		 je	 SHORT $LN116@ProcessMai
  0060f	48 b8 54 41 46
	58 45 90 76 eb	 mov	 rax, -1479836800036486828 ; eb76904558464154H
  00619	48 39 84 24 20
	05 00 00	 cmp	 QWORD PTR tv235[rsp], rax
  00621	74 02		 je	 SHORT $LN116@ProcessMai
  00623	eb 12		 jmp	 SHORT $LN117@ProcessMai
$LN116@ProcessMai:

; 1050 : 								{
; 1051 : 								case 0xEB52904E54465320: // NTFS
; 1052 : 								case 0xEB3C904D53444F53: // FAT16
; 1053 : 								case 0xEB58904D53444F53: // FAT32
; 1054 : 								case 0xEB76904558464154: // exFAT
; 1055 : 
; 1056 : 									opentest->FilesystemDetected = TRUE;

  00625	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$30732[rsp]
  0062d	c7 80 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+532], 1
$LN117@ProcessMai:
$LN119@ProcessMai:
$LN125@ProcessMai:

; 1057 : 									break;
; 1058 : 								}
; 1059 : 							}
; 1060 : 						}
; 1061 : 
; 1062 : 						GSTfree (readBuffer);

  00637	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0063c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR readBuffer$30754[rsp]
  00644	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN126@ProcessMai:
$LN129@ProcessMai:

; 1063 : 					}
; 1064 : 				}
; 1065 : 
; 1066 : 				ZwClose (NtFileHandle);

  0064a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR NtFileHandle$30735[rsp]
  00652	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1067 : 				Dump ("Open test on file %ls success.\n", opentest->wszFileName);

  00658	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR opentest$30732[rsp]
  00660	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@
  00667	e8 00 00 00 00	 call	 DbgPrint
$LN130@ProcessMai:

; 1068 : 			}
; 1069 : 			else
; 1070 : 			{
; 1071 : #if 0
; 1072 : 				Dump ("Open test on file %ls failed NTSTATUS 0x%08x\n", opentest->wszFileName, ntStatus);
; 1073 : #endif
; 1074 : 			}
; 1075 : 
; 1076 : 			Irp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;

  0066c	83 7c 24 60 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00671	7c 0e		 jl	 SHORT $LN153@ProcessMai
  00673	48 c7 84 24 28
	05 00 00 18 02
	00 00		 mov	 QWORD PTR tv248[rsp], 536 ; 00000218H
  0067f	eb 0c		 jmp	 SHORT $LN154@ProcessMai
$LN153@ProcessMai:
  00681	48 c7 84 24 28
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv248[rsp], 0
$LN154@ProcessMai:
  0068d	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00695	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR tv248[rsp]
  0069d	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 1077 : 			Irp->IoStatus.Status = ntStatus;

  006a1	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  006a9	8b 44 24 60	 mov	 eax, DWORD PTR ntStatus$[rsp]
  006ad	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1078 : 		}
; 1079 : 		break;

  006b0	e9 91 18 00 00	 jmp	 $LN149@ProcessMai
$LN114@ProcessMai:

; 1080 : 
; 1081 : 	case GST_IOCTL_GET_SYSTEM_DRIVE_CONFIG:
; 1082 : 		{
; 1083 : 			GetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;

  006b5	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  006bd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  006c1	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR request$30785[rsp], rax

; 1084 : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 1085 : 			HANDLE NtFileHandle;
; 1086 : 			UNICODE_STRING FullFileName;
; 1087 : 			IO_STATUS_BLOCK IoStatus;
; 1088 : 			LARGE_INTEGER offset;
; 1089 : 			byte readBuffer [GST_SECTOR_SIZE_BIOS];
; 1090 : 
; 1091 : 			if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))

  006c9	41 b8 02 00 00
	00		 mov	 r8d, 2
  006cf	ba 29 02 00 00	 mov	 edx, 553		; 00000229H
  006d4	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  006dc	e8 00 00 00 00	 call	 ValidateIOBufferSize
  006e1	85 c0		 test	 eax, eax
  006e3	75 05		 jne	 SHORT $LN113@ProcessMai

; 1092 : 				break;

  006e5	e9 5c 18 00 00	 jmp	 $LN149@ProcessMai
$LN113@ProcessMai:

; 1093 : 
; 1094 : 			EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));

  006ea	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  006ef	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR request$30785[rsp]
  006f7	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1095 : 			RtlInitUnicodeString (&FullFileName, request->DevicePath);

  006fc	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR request$30785[rsp]
  00704	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR FullFileName$30789[rsp]
  0070c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 1096 : 
; 1097 : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  00712	c7 84 24 28 03
	00 00 30 00 00
	00		 mov	 DWORD PTR ObjectAttributes$30787[rsp], 48 ; 00000030H
  0071d	48 c7 84 24 30
	03 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$30787[rsp+8], 0
  00729	c7 84 24 40 03
	00 00 40 02 00
	00		 mov	 DWORD PTR ObjectAttributes$30787[rsp+24], 576 ; 00000240H
  00734	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR FullFileName$30789[rsp]
  0073c	48 89 84 24 38
	03 00 00	 mov	 QWORD PTR ObjectAttributes$30787[rsp+16], rax
  00744	48 c7 84 24 48
	03 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$30787[rsp+32], 0
  00750	48 c7 84 24 50
	03 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$30787[rsp+40], 0

; 1098 : 
; 1099 : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 1100 : 				SYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,
; 1101 : 				FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);

  0075c	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  00764	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  0076d	c7 44 24 40 20
	08 00 00	 mov	 DWORD PTR [rsp+64], 2080 ; 00000820H
  00775	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  0077d	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  00785	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  0078d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00796	4c 8d 8c 24 60
	03 00 00	 lea	 r9, QWORD PTR IoStatus$30790[rsp]
  0079e	4c 8d 84 24 28
	03 00 00	 lea	 r8, QWORD PTR ObjectAttributes$30787[rsp]
  007a6	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  007ab	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR NtFileHandle$30788[rsp]
  007b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  007b9	89 44 24 60	 mov	 DWORD PTR ntStatus$[rsp], eax

; 1102 : 
; 1103 : 			if (NT_SUCCESS (ntStatus))

  007bd	83 7c 24 60 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  007c2	0f 8c 7d 02 00
	00		 jl	 $LN112@ProcessMai

; 1104 : 			{
; 1105 : 				// Determine if the first sector contains a portion of the GostCrypt Boot Loader
; 1106 : 				offset.QuadPart = 0;	// MBR

  007c8	48 c7 84 24 20
	03 00 00 00 00
	00 00		 mov	 QWORD PTR offset$30791[rsp], 0

; 1107 : 
; 1108 : 				ntStatus = ZwReadFile (NtFileHandle,
; 1109 : 					NULL,
; 1110 : 					NULL,
; 1111 : 					NULL,
; 1112 : 					&IoStatus,
; 1113 : 					readBuffer,
; 1114 : 					sizeof(readBuffer),
; 1115 : 					&offset,
; 1116 : 					NULL);

  007d4	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  007dd	48 8d 84 24 20
	03 00 00	 lea	 rax, QWORD PTR offset$30791[rsp]
  007e5	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  007ea	c7 44 24 30 00
	02 00 00	 mov	 DWORD PTR [rsp+48], 512	; 00000200H
  007f2	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR readBuffer$30792[rsp]
  007fa	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007ff	48 8d 84 24 60
	03 00 00	 lea	 rax, QWORD PTR IoStatus$30790[rsp]
  00807	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0080c	45 33 c9	 xor	 r9d, r9d
  0080f	45 33 c0	 xor	 r8d, r8d
  00812	33 d2		 xor	 edx, edx
  00814	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR NtFileHandle$30788[rsp]
  0081c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  00822	89 44 24 60	 mov	 DWORD PTR ntStatus$[rsp], eax

; 1117 : 
; 1118 : 				if (NT_SUCCESS (ntStatus))

  00826	83 7c 24 60 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0082b	0f 8c e5 01 00
	00		 jl	 $LN111@ProcessMai

; 1119 : 				{
; 1120 : 					size_t i;
; 1121 : 
; 1122 : 					// Check for dynamic drive
; 1123 : 					request->DriveIsDynamic = FALSE;

  00831	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$30785[rsp]
  00839	c7 80 09 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+521], 0

; 1124 : 
; 1125 : 					if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)

  00843	0f b6 84 24 1e
	03 00 00	 movzx	 eax, BYTE PTR readBuffer$30792[rsp+510]
  0084b	83 f8 55	 cmp	 eax, 85			; 00000055H
  0084e	75 6b		 jne	 SHORT $LN110@ProcessMai
  00850	0f b6 84 24 1f
	03 00 00	 movzx	 eax, BYTE PTR readBuffer$30792[rsp+511]
  00858	3d aa 00 00 00	 cmp	 eax, 170		; 000000aaH
  0085d	75 5c		 jne	 SHORT $LN110@ProcessMai

; 1126 : 					{
; 1127 : 						int i;
; 1128 : 						for (i = 0; i < 4; ++i)

  0085f	c7 84 24 80 03
	00 00 00 00 00
	00		 mov	 DWORD PTR i$30811[rsp], 0
  0086a	eb 11		 jmp	 SHORT $LN109@ProcessMai
$LN108@ProcessMai:
  0086c	8b 84 24 80 03
	00 00		 mov	 eax, DWORD PTR i$30811[rsp]
  00873	83 c0 01	 add	 eax, 1
  00876	89 84 24 80 03
	00 00		 mov	 DWORD PTR i$30811[rsp], eax
$LN109@ProcessMai:
  0087d	83 bc 24 80 03
	00 00 04	 cmp	 DWORD PTR i$30811[rsp], 4
  00885	7d 34		 jge	 SHORT $LN107@ProcessMai

; 1129 : 						{
; 1130 : 							if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)

  00887	8b 84 24 80 03
	00 00		 mov	 eax, DWORD PTR i$30811[rsp]
  0088e	6b c0 10	 imul	 eax, 16
  00891	05 c2 01 00 00	 add	 eax, 450		; 000001c2H
  00896	48 98		 cdqe
  00898	0f b6 84 04 20
	01 00 00	 movzx	 eax, BYTE PTR readBuffer$30792[rsp+rax]
  008a0	83 f8 42	 cmp	 eax, 66			; 00000042H
  008a3	75 14		 jne	 SHORT $LN106@ProcessMai

; 1131 : 							{
; 1132 : 								request->DriveIsDynamic = TRUE;

  008a5	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$30785[rsp]
  008ad	c7 80 09 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+521], 1

; 1133 : 								break;

  008b7	eb 02		 jmp	 SHORT $LN107@ProcessMai
$LN106@ProcessMai:

; 1134 : 							}
; 1135 : 						}

  008b9	eb b1		 jmp	 SHORT $LN108@ProcessMai
$LN107@ProcessMai:
$LN110@ProcessMai:

; 1136 : 					}
; 1137 : 
; 1138 : 					request->BootLoaderVersion = 0;

  008bb	33 c9		 xor	 ecx, ecx
  008bd	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$30785[rsp]
  008c5	66 89 88 0d 02
	00 00		 mov	 WORD PTR [rax+525], cx

; 1139 : 					request->Configuration = 0;

  008cc	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$30785[rsp]
  008d4	c6 80 08 02 00
	00 00		 mov	 BYTE PTR [rax+520], 0

; 1140 : 					request->UserConfiguration = 0;

  008db	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$30785[rsp]
  008e3	c6 80 0f 02 00
	00 00		 mov	 BYTE PTR [rax+527], 0

; 1141 : 					request->CustomUserMessage[0] = 0;

  008ea	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$30785[rsp]
  008f2	c6 80 10 02 00
	00 00		 mov	 BYTE PTR [rax+528], 0

; 1142 : 
; 1143 : 					// Search for the string "GostCrypt"
; 1144 : 					for (i = 0; i < sizeof (readBuffer) - strlen (GST_APP_NAME); ++i)

  008f9	48 c7 84 24 78
	03 00 00 00 00
	00 00		 mov	 QWORD PTR i$30809[rsp], 0
  00905	eb 14		 jmp	 SHORT $LN105@ProcessMai
$LN104@ProcessMai:
  00907	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR i$30809[rsp]
  0090f	48 83 c0 01	 add	 rax, 1
  00913	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR i$30809[rsp], rax
$LN105@ProcessMai:
  0091b	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00920	48 83 e8 09	 sub	 rax, 9
  00924	48 39 84 24 78
	03 00 00	 cmp	 QWORD PTR i$30809[rsp], rax
  0092c	0f 83 c3 00 00
	00		 jae	 $LN103@ProcessMai

; 1145 : 					{
; 1146 : 						if (memcmp (readBuffer + i, GST_APP_NAME, strlen (GST_APP_NAME)) == 0)

  00932	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR i$30809[rsp]
  0093a	48 8d 8c 04 20
	01 00 00	 lea	 rcx, QWORD PTR readBuffer$30792[rsp+rax]
  00942	41 b8 09 00 00
	00		 mov	 r8d, 9
  00948	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09NKHKFHLH@GostCrypt?$AA@FNODOBFM@
  0094f	e8 00 00 00 00	 call	 memcmp
  00954	85 c0		 test	 eax, eax
  00956	0f 85 94 00 00
	00		 jne	 $LN102@ProcessMai

; 1147 : 						{
; 1148 : 							request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + GST_BOOT_SECTOR_VERSION_OFFSET));

  0095c	0f b7 8c 24 ce
	02 00 00	 movzx	 ecx, WORD PTR readBuffer$30792[rsp+430]
  00964	e8 00 00 00 00	 call	 MirrorBytes16
  00969	0f b7 d0	 movzx	 edx, ax
  0096c	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$30785[rsp]
  00974	66 89 90 0d 02
	00 00		 mov	 WORD PTR [rax+525], dx

; 1149 : 							request->Configuration = readBuffer[GST_BOOT_SECTOR_CONFIG_OFFSET];

  0097b	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR request$30785[rsp]
  00983	0f b6 84 24 d7
	02 00 00	 movzx	 eax, BYTE PTR readBuffer$30792[rsp+439]
  0098b	88 81 08 02 00
	00		 mov	 BYTE PTR [rcx+520], al

; 1150 : 
; 1151 : 							if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)

  00991	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$30785[rsp]
  00999	0f b7 80 0d 02
	00 00		 movzx	 eax, WORD PTR [rax+525]
  009a0	85 c0		 test	 eax, eax
  009a2	74 4a		 je	 SHORT $LN101@ProcessMai
  009a4	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$30785[rsp]
  009ac	0f b7 80 0d 02
	00 00		 movzx	 eax, WORD PTR [rax+525]
  009b3	3d 00 13 00 00	 cmp	 eax, 4864		; 00001300H
  009b8	7f 34		 jg	 SHORT $LN101@ProcessMai

; 1152 : 							{
; 1153 : 								request->UserConfiguration = readBuffer[GST_BOOT_SECTOR_USER_CONFIG_OFFSET];

  009ba	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR request$30785[rsp]
  009c2	0f b6 84 24 d6
	02 00 00	 movzx	 eax, BYTE PTR readBuffer$30792[rsp+438]
  009ca	88 81 0f 02 00
	00		 mov	 BYTE PTR [rcx+527], al

; 1154 : 								memcpy (request->CustomUserMessage, readBuffer + GST_BOOT_SECTOR_USER_MESSAGE_OFFSET, GST_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  009d0	48 8b bc 24 58
	03 00 00	 mov	 rdi, QWORD PTR request$30785[rsp]
  009d8	48 8d b4 24 b6
	02 00 00	 lea	 rsi, QWORD PTR readBuffer$30792[rsp+406]
  009e0	48 81 c7 10 02
	00 00		 add	 rdi, 528		; 00000210H
  009e7	b9 18 00 00 00	 mov	 ecx, 24
  009ec	f3 a4		 rep movsb
$LN101@ProcessMai:

; 1155 : 							}
; 1156 : 							break;

  009ee	eb 05		 jmp	 SHORT $LN103@ProcessMai
$LN102@ProcessMai:

; 1157 : 						}
; 1158 : 					}

  009f0	e9 12 ff ff ff	 jmp	 $LN104@ProcessMai
$LN103@ProcessMai:

; 1159 : 
; 1160 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  009f5	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  009fd	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1161 : 					Irp->IoStatus.Information = sizeof (*request);

  00a04	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00a0c	48 c7 40 38 29
	02 00 00	 mov	 QWORD PTR [rax+56], 553	; 00000229H

; 1162 : 				}
; 1163 : 				else

  00a14	eb 1f		 jmp	 SHORT $LN100@ProcessMai
$LN111@ProcessMai:

; 1164 : 				{
; 1165 : 					Irp->IoStatus.Status = ntStatus;

  00a16	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00a1e	8b 44 24 60	 mov	 eax, DWORD PTR ntStatus$[rsp]
  00a22	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1166 : 					Irp->IoStatus.Information = 0;

  00a25	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00a2d	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN100@ProcessMai:

; 1167 : 				}
; 1168 : 
; 1169 : 				ZwClose (NtFileHandle);

  00a35	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR NtFileHandle$30788[rsp]
  00a3d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1170 : 
; 1171 : 			}
; 1172 : 			else

  00a43	eb 1f		 jmp	 SHORT $LN99@ProcessMai
$LN112@ProcessMai:

; 1173 : 			{
; 1174 : 				Irp->IoStatus.Status = ntStatus;

  00a45	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00a4d	8b 44 24 60	 mov	 eax, DWORD PTR ntStatus$[rsp]
  00a51	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1175 : 				Irp->IoStatus.Information = 0;

  00a54	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00a5c	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN99@ProcessMai:

; 1176 : 			}
; 1177 : 		}
; 1178 : 		break;

  00a64	e9 dd 14 00 00	 jmp	 $LN149@ProcessMai
$LN98@ProcessMai:

; 1179 : 
; 1180 : 	case GST_IOCTL_WIPE_PASSWORD_CACHE:
; 1181 : 		WipeCache ();

  00a69	e8 00 00 00 00	 call	 WipeCache

; 1182 : 
; 1183 : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  00a6e	48 8b 94 24 c0
	05 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00a76	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [rdx+48], 0

; 1184 : 		Irp->IoStatus.Information = 0;

  00a7d	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00a85	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1185 : 		break;

  00a8d	e9 b4 14 00 00	 jmp	 $LN149@ProcessMai
$LN97@ProcessMai:

; 1186 : 
; 1187 : 	case GST_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1188 : 		Irp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;

  00a92	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cacheEmpty, 0
  00a99	74 0d		 je	 SHORT $LN155@ProcessMai
  00a9b	c7 84 24 30 05
	00 00 d9 00 00
	c0		 mov	 DWORD PTR tv383[rsp], -1073741607 ; ffffffffc00000d9H
  00aa6	eb 0b		 jmp	 SHORT $LN156@ProcessMai
$LN155@ProcessMai:
  00aa8	c7 84 24 30 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv383[rsp], 0
$LN156@ProcessMai:
  00ab3	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00abb	8b 84 24 30 05
	00 00		 mov	 eax, DWORD PTR tv383[rsp]
  00ac2	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1189 : 		Irp->IoStatus.Information = 0;

  00ac5	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00acd	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1190 : 		break;

  00ad5	e9 6c 14 00 00	 jmp	 $LN149@ProcessMai
$LN96@ProcessMai:

; 1191 : 
; 1192 : 	case GST_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1193 : 		if (!UserCanAccessDriveDevice())

  00ada	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00adf	85 c0		 test	 eax, eax
  00ae1	75 21		 jne	 SHORT $LN95@ProcessMai

; 1194 : 		{
; 1195 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  00ae3	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00aeb	c7 40 30 22 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741790 ; ffffffffc0000022H

; 1196 : 			Irp->IoStatus.Information = 0;

  00af2	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00afa	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1197 : 		}
; 1198 : 		else

  00b02	eb 16		 jmp	 SHORT $LN94@ProcessMai
$LN95@ProcessMai:

; 1199 : 		{
; 1200 : 			PortableMode = TRUE;

  00b04	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR PortableMode, 1

; 1201 : 			Dump ("Setting portable mode\n");

  00b0e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@
  00b15	e8 00 00 00 00	 call	 DbgPrint
$LN94@ProcessMai:

; 1202 : 		}
; 1203 : 		break;

  00b1a	e9 27 14 00 00	 jmp	 $LN149@ProcessMai
$LN93@ProcessMai:

; 1204 : 
; 1205 : 	case GST_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1206 : 		Irp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;

  00b1f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR PortableMode, 0
  00b26	74 0d		 je	 SHORT $LN157@ProcessMai
  00b28	c7 84 24 34 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv392[rsp], 0
  00b33	eb 0b		 jmp	 SHORT $LN158@ProcessMai
$LN157@ProcessMai:
  00b35	c7 84 24 34 05
	00 00 d9 00 00
	c0		 mov	 DWORD PTR tv392[rsp], -1073741607 ; ffffffffc00000d9H
$LN158@ProcessMai:
  00b40	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00b48	8b 84 24 34 05
	00 00		 mov	 eax, DWORD PTR tv392[rsp]
  00b4f	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1207 : 		Irp->IoStatus.Information = 0;

  00b52	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00b5a	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1208 : 		break;

  00b62	e9 df 13 00 00	 jmp	 $LN149@ProcessMai
$LN92@ProcessMai:

; 1209 : 
; 1210 : 	case GST_IOCTL_GET_MOUNTED_VOLUMES:
; 1211 : 		Dump("IOCTL GetMountedVolume received");

  00b67	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@BDAPNECM@IOCTL?5GetMountedVolume?5received?$AA@FNODOBFM@
  00b6e	e8 00 00 00 00	 call	 DbgPrint

; 1212 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))

  00b73	41 b8 01 00 00
	00		 mov	 r8d, 1
  00b79	ba 74 36 00 00	 mov	 edx, 13940		; 00003674H
  00b7e	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00b86	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00b8b	85 c0		 test	 eax, eax
  00b8d	0f 84 0d 03 00
	00		 je	 $LN91@ProcessMai

; 1213 : 		{
; 1214 : 			MOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00b93	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00b9b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00b9f	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR list$30842[rsp], rax

; 1215 : 			PDEVICE_OBJECT ListDevice;
; 1216 : 			int drive;
; 1217 : 
; 1218 : 			list->ulMountedDrives = 0;

  00ba7	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$30842[rsp]
  00baf	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1219 : 
; 1220 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00bb5	c7 84 24 90 03
	00 00 00 00 00
	00		 mov	 DWORD PTR drive$30845[rsp], 0
  00bc0	eb 11		 jmp	 SHORT $LN90@ProcessMai
$LN89@ProcessMai:
  00bc2	8b 84 24 90 03
	00 00		 mov	 eax, DWORD PTR drive$30845[rsp]
  00bc9	83 c0 01	 add	 eax, 1
  00bcc	89 84 24 90 03
	00 00		 mov	 DWORD PTR drive$30845[rsp], eax
$LN90@ProcessMai:
  00bd3	83 bc 24 90 03
	00 00 19	 cmp	 DWORD PTR drive$30845[rsp], 25
  00bdb	0f 8f a0 02 00
	00		 jg	 $LN88@ProcessMai

; 1221 : 			{
; 1222 : 				PEXTENSION ListExtension;
; 1223 : 				Dump("Getting device object for drive %d .", drive );

  00be1	8b 94 24 90 03
	00 00		 mov	 edx, DWORD PTR drive$30845[rsp]
  00be8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@BBCNGDEK@Getting?5device?5object?5for?5drive?5@FNODOBFM@
  00bef	e8 00 00 00 00	 call	 DbgPrint

; 1224 : 				ListDevice = GetVirtualVolumeDeviceObject (drive);

  00bf4	8b 8c 24 90 03
	00 00		 mov	 ecx, DWORD PTR drive$30845[rsp]
  00bfb	e8 00 00 00 00	 call	 GetVirtualVolumeDeviceObject
  00c00	48 89 84 24 98
	03 00 00	 mov	 QWORD PTR ListDevice$30844[rsp], rax

; 1225 : 				if (!ListDevice)

  00c08	48 83 bc 24 98
	03 00 00 00	 cmp	 QWORD PTR ListDevice$30844[rsp], 0
  00c11	75 02		 jne	 SHORT $LN87@ProcessMai

; 1226 : 					continue;

  00c13	eb ad		 jmp	 SHORT $LN89@ProcessMai
$LN87@ProcessMai:

; 1227 : 				
; 1228 : 				ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00c15	48 8b 84 24 98
	03 00 00	 mov	 rax, QWORD PTR ListDevice$30844[rsp]
  00c1d	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00c21	48 89 84 24 a0
	03 00 00	 mov	 QWORD PTR ListExtension$30849[rsp], rax

; 1229 : 				Dump("Checking if VolumeIsAccessibleForUSer.");

  00c29	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@OLDNEABP@Checking?5if?5VolumeIsAccessibleFo@FNODOBFM@
  00c30	e8 00 00 00 00	 call	 DbgPrint

; 1230 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00c35	48 8b 8c 24 a0
	03 00 00	 mov	 rcx, QWORD PTR ListExtension$30849[rsp]
  00c3d	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  00c42	85 c0		 test	 eax, eax
  00c44	0f 84 32 02 00
	00		 je	 $LN86@ProcessMai

; 1231 : 				{
; 1232 : 					list->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);

  00c4a	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00c52	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00c55	ba 01 00 00 00	 mov	 edx, 1
  00c5a	0f b6 c8	 movzx	 ecx, al
  00c5d	d3 e2		 shl	 edx, cl
  00c5f	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$30842[rsp]
  00c67	8b 08		 mov	 ecx, DWORD PTR [rax]
  00c69	0b ca		 or	 ecx, edx
  00c6b	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$30842[rsp]
  00c73	89 08		 mov	 DWORD PTR [rax], ecx

; 1233 : 					Dump("Check 1..");

  00c75	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09HOKHNNKO@Check?51?4?4?$AA@FNODOBFM@
  00c7c	e8 00 00 00 00	 call	 DbgPrint

; 1234 : 					wcscpy (list->wszVolume[ListExtension->nDosDriveNo], ListExtension->wszVolume);

  00c81	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00c89	48 05 b0 03 00
	00		 add	 rax, 944		; 000003b0H
  00c8f	48 89 84 24 38
	05 00 00	 mov	 QWORD PTR tv419[rsp], rax
  00c97	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00c9f	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00ca3	48 69 c9 08 02
	00 00		 imul	 rcx, 520		; 00000208H
  00caa	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$30842[rsp]
  00cb2	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  00cb7	48 89 84 24 40
	05 00 00	 mov	 QWORD PTR tv425[rsp], rax
  00cbf	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR tv425[rsp]
  00cc7	48 89 84 24 48
	05 00 00	 mov	 QWORD PTR tv426[rsp], rax
$LN159@ProcessMai:
  00ccf	48 8b 84 24 38
	05 00 00	 mov	 rax, QWORD PTR tv419[rsp]
  00cd7	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00cda	66 89 84 24 50
	05 00 00	 mov	 WORD PTR tv427[rsp], ax
  00ce2	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR tv425[rsp]
  00cea	0f b7 84 24 50
	05 00 00	 movzx	 eax, WORD PTR tv427[rsp]
  00cf2	66 89 01	 mov	 WORD PTR [rcx], ax
  00cf5	48 8b 84 24 38
	05 00 00	 mov	 rax, QWORD PTR tv419[rsp]
  00cfd	48 83 c0 02	 add	 rax, 2
  00d01	48 89 84 24 38
	05 00 00	 mov	 QWORD PTR tv419[rsp], rax
  00d09	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR tv425[rsp]
  00d11	48 83 c0 02	 add	 rax, 2
  00d15	48 89 84 24 40
	05 00 00	 mov	 QWORD PTR tv425[rsp], rax
  00d1d	66 83 bc 24 50
	05 00 00 00	 cmp	 WORD PTR tv427[rsp], 0
  00d26	75 a7		 jne	 SHORT $LN159@ProcessMai

; 1235 : 					Dump("2..");

  00d28	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03LNENHCAP@2?4?4?$AA@FNODOBFM@
  00d2f	e8 00 00 00 00	 call	 DbgPrint

; 1236 : 					list->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;

  00d34	48 8b 94 24 a0
	03 00 00	 mov	 rdx, QWORD PTR ListExtension$30849[rsp]
  00d3c	48 63 52 14	 movsxd	 rdx, DWORD PTR [rdx+20]
  00d40	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR list$30842[rsp]
  00d48	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00d50	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00d57	48 89 84 d1 d4
	34 00 00	 mov	 QWORD PTR [rcx+rdx*8+13524], rax

; 1237 : 					Dump("3..");

  00d5f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03FPBBFGK@3?4?4?$AA@FNODOBFM@
  00d66	e8 00 00 00 00	 call	 DbgPrint

; 1238 : 					list->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;

  00d6b	48 8b bc 24 a0
	03 00 00	 mov	 rdi, QWORD PTR ListExtension$30849[rsp]
  00d73	48 8b bf 90 00
	00 00		 mov	 rdi, QWORD PTR [rdi+144]
  00d7a	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00d82	48 63 50 14	 movsxd	 rdx, DWORD PTR [rax+20]
  00d86	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR list$30842[rsp]
  00d8e	8b 07		 mov	 eax, DWORD PTR [rdi]
  00d90	89 84 91 a4 35
	00 00		 mov	 DWORD PTR [rcx+rdx*4+13732], eax

; 1239 : 					Dump("4..");

  00d97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03JICGCNND@4?4?4?$AA@FNODOBFM@
  00d9e	e8 00 00 00 00	 call	 DbgPrint

; 1240 : 					if (ListExtension->cryptoInfo->hiddenVolume)

  00da3	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00dab	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00db2	83 b8 48 04 00
	00 00		 cmp	 DWORD PTR [rax+1096], 0
  00db9	74 24		 je	 SHORT $LN85@ProcessMai

; 1241 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;	// Hidden volume

  00dbb	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00dc3	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00dc7	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$30842[rsp]
  00dcf	c7 84 88 0c 36
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+13836], 1
  00dda	e9 91 00 00 00	 jmp	 $LN84@ProcessMai
$LN85@ProcessMai:

; 1242 : 					else if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)

  00ddf	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00de7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00dee	83 b8 ac 1e 00
	00 00		 cmp	 DWORD PTR [rax+7852], 0
  00df5	74 21		 je	 SHORT $LN83@ProcessMai

; 1243 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;	// Normal/outer volume (hidden volume protected AND write already prevented)

  00df7	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00dff	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00e03	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$30842[rsp]
  00e0b	c7 84 88 0c 36
	00 00 03 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+13836], 3
  00e16	eb 58		 jmp	 SHORT $LN82@ProcessMai
$LN83@ProcessMai:

; 1244 : 					else if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  00e18	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00e20	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00e27	83 b8 a8 1e 00
	00 00		 cmp	 DWORD PTR [rax+7848], 0
  00e2e	74 21		 je	 SHORT $LN81@ProcessMai

; 1245 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;	// Normal/outer volume (hidden volume protected)

  00e30	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00e38	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00e3c	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$30842[rsp]
  00e44	c7 84 88 0c 36
	00 00 02 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+13836], 2

; 1246 : 					else

  00e4f	eb 1f		 jmp	 SHORT $LN80@ProcessMai
$LN81@ProcessMai:

; 1247 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;	// Normal volume

  00e51	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30849[rsp]
  00e59	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00e5d	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$30842[rsp]
  00e65	c7 84 88 0c 36
	00 00 00 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+13836], 0
$LN80@ProcessMai:
$LN82@ProcessMai:
$LN84@ProcessMai:

; 1248 : 					Dump("5. ok.\n");

  00e70	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07PAKHCJIG@5?4?5ok?4?6?$AA@FNODOBFM@
  00e77	e8 00 00 00 00	 call	 DbgPrint
$LN86@ProcessMai:

; 1249 : 				}
; 1250 : 			}

  00e7c	e9 41 fd ff ff	 jmp	 $LN89@ProcessMai
$LN88@ProcessMai:

; 1251 : 
; 1252 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00e81	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00e89	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1253 : 			Irp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);

  00e90	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00e98	48 c7 40 38 74
	36 00 00	 mov	 QWORD PTR [rax+56], 13940 ; 00003674H
$LN91@ProcessMai:

; 1254 : 		}
; 1255 : 		break;

  00ea0	e9 a1 10 00 00	 jmp	 $LN149@ProcessMai
$LN79@ProcessMai:

; 1256 : 
; 1257 : 	case GST_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:
; 1258 : 		if (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))

  00ea5	41 b8 01 00 00
	00		 mov	 r8d, 1
  00eab	ba 04 00 00 00	 mov	 edx, 4
  00eb0	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00eb8	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00ebd	85 c0		 test	 eax, eax
  00ebf	74 4d		 je	 SHORT $LN78@ProcessMai

; 1259 : 		{
; 1260 : 			// Prevent the user from downgrading to versions lower than 5.0 by faking mounted volumes.
; 1261 : 			// The user could render the system unbootable by downgrading when boot encryption
; 1262 : 			// is active or being set up.
; 1263 : 
; 1264 : 			memset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  00ec1	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  00ec6	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00ec9	48 8b bc 24 c0
	05 00 00	 mov	 rdi, QWORD PTR Irp$[rsp]
  00ed1	48 8b 7f 18	 mov	 rdi, QWORD PTR [rdi+24]
  00ed5	33 c0		 xor	 eax, eax
  00ed7	f3 aa		 rep stosb

; 1265 : 			*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;

  00ed9	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00ee1	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00ee5	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1	; ffffffffH

; 1266 : 
; 1267 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00eeb	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00ef3	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1268 : 			Irp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

  00efa	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  00eff	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00f02	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00f0a	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN78@ProcessMai:

; 1269 : 		}
; 1270 : 		break;

  00f0e	e9 33 10 00 00	 jmp	 $LN149@ProcessMai
$LN77@ProcessMai:

; 1271 : 
; 1272 : 	case GST_IOCTL_GET_VOLUME_PROPERTIES:
; 1273 : 		if (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))

  00f13	41 b8 02 00 00
	00		 mov	 r8d, 2
  00f19	ba 54 02 00 00	 mov	 edx, 596		; 00000254H
  00f1e	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00f26	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00f2b	85 c0		 test	 eax, eax
  00f2d	0f 84 79 03 00
	00		 je	 $LN76@ProcessMai

; 1274 : 		{
; 1275 : 			VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00f33	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00f3b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00f3f	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR prop$30876[rsp], rax

; 1276 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);

  00f47	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR prop$30876[rsp]
  00f4f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00f51	e8 00 00 00 00	 call	 GetVirtualVolumeDeviceObject
  00f56	48 89 84 24 a8
	03 00 00	 mov	 QWORD PTR ListDevice$30878[rsp], rax

; 1277 : 
; 1278 : 			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00f5e	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00f66	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 1279 : 			Irp->IoStatus.Information = 0;

  00f6d	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00f75	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1280 : 
; 1281 : 			if (ListDevice)

  00f7d	48 83 bc 24 a8
	03 00 00 00	 cmp	 QWORD PTR ListDevice$30878[rsp], 0
  00f86	0f 84 20 03 00
	00		 je	 $LN75@ProcessMai

; 1282 : 			{
; 1283 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00f8c	48 8b 84 24 a8
	03 00 00	 mov	 rax, QWORD PTR ListDevice$30878[rsp]
  00f94	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00f98	48 89 84 24 b8
	03 00 00	 mov	 QWORD PTR ListExtension$30881[rsp], rax

; 1284 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00fa0	48 8b 8c 24 b8
	03 00 00	 mov	 rcx, QWORD PTR ListExtension$30881[rsp]
  00fa8	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  00fad	85 c0		 test	 eax, eax
  00faf	0f 84 f7 02 00
	00		 je	 $LN74@ProcessMai

; 1285 : 				{
; 1286 : 					prop->uniqueId = ListExtension->UniqueVolumeId;

  00fb5	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  00fbd	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  00fc5	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00fc8	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1287 : 					wcscpy (prop->wszVolume, ListExtension->wszVolume);

  00fcb	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  00fd3	48 05 b0 03 00
	00		 add	 rax, 944		; 000003b0H
  00fd9	48 89 84 24 58
	05 00 00	 mov	 QWORD PTR tv516[rsp], rax
  00fe1	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR prop$30876[rsp]
  00fe9	48 83 c0 08	 add	 rax, 8
  00fed	48 89 84 24 60
	05 00 00	 mov	 QWORD PTR tv518[rsp], rax
  00ff5	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR tv518[rsp]
  00ffd	48 89 84 24 68
	05 00 00	 mov	 QWORD PTR tv519[rsp], rax
$LN160@ProcessMai:
  01005	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR tv516[rsp]
  0100d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  01010	66 89 84 24 70
	05 00 00	 mov	 WORD PTR tv520[rsp], ax
  01018	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR tv518[rsp]
  01020	0f b7 84 24 70
	05 00 00	 movzx	 eax, WORD PTR tv520[rsp]
  01028	66 89 01	 mov	 WORD PTR [rcx], ax
  0102b	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR tv516[rsp]
  01033	48 83 c0 02	 add	 rax, 2
  01037	48 89 84 24 58
	05 00 00	 mov	 QWORD PTR tv516[rsp], rax
  0103f	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR tv518[rsp]
  01047	48 83 c0 02	 add	 rax, 2
  0104b	48 89 84 24 60
	05 00 00	 mov	 QWORD PTR tv518[rsp], rax
  01053	66 83 bc 24 70
	05 00 00 00	 cmp	 WORD PTR tv520[rsp], 0
  0105c	75 a7		 jne	 SHORT $LN160@ProcessMai

; 1288 : 					prop->diskLength = ListExtension->DiskLength;

  0105e	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  01066	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  0106e	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01075	48 89 81 10 02
	00 00		 mov	 QWORD PTR [rcx+528], rax

; 1289 : 					prop->ea = ListExtension->cryptoInfo->ea;

  0107c	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  01084	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0108b	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  01093	8b 00		 mov	 eax, DWORD PTR [rax]
  01095	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 1290 : 					prop->mode = ListExtension->cryptoInfo->mode;

  0109b	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  010a3	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  010aa	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  010b2	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  010b5	89 81 1c 02 00
	00		 mov	 DWORD PTR [rcx+540], eax

; 1291 : 					prop->pkcs5 = ListExtension->cryptoInfo->pkcs5;

  010bb	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  010c3	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  010ca	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  010d2	8b 80 94 1e 00
	00		 mov	 eax, DWORD PTR [rax+7828]
  010d8	89 81 20 02 00
	00		 mov	 DWORD PTR [rcx+544], eax

; 1292 : 					prop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;

  010de	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  010e6	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  010ed	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  010f5	8b 80 90 1e 00
	00		 mov	 eax, DWORD PTR [rax+7824]
  010fb	89 81 24 02 00
	00		 mov	 DWORD PTR [rcx+548], eax

; 1293 : #if 0
; 1294 : 					prop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;
; 1295 : 					prop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;
; 1296 : #endif
; 1297 : 					prop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;

  01101	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  01109	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01110	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  01118	8b 80 08 1f 00
	00		 mov	 eax, DWORD PTR [rax+7944]
  0111e	89 81 38 02 00
	00		 mov	 DWORD PTR [rcx+568], eax

; 1298 : 					prop->readOnly = ListExtension->bReadOnly;

  01124	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  0112c	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  01134	8b 80 98 03 00
	00		 mov	 eax, DWORD PTR [rax+920]
  0113a	89 81 2c 02 00
	00		 mov	 DWORD PTR [rcx+556], eax

; 1299 : 					prop->removable = ListExtension->bRemovable;

  01140	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  01148	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  01150	8b 80 9c 03 00
	00		 mov	 eax, DWORD PTR [rax+924]
  01156	89 81 30 02 00
	00		 mov	 DWORD PTR [rcx+560], eax

; 1300 : 					prop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;

  0115c	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  01164	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  0116c	8b 80 a0 03 00
	00		 mov	 eax, DWORD PTR [rax+928]
  01172	89 81 34 02 00
	00		 mov	 DWORD PTR [rcx+564], eax

; 1301 : 					prop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;

  01178	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  01180	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01187	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  0118f	8b 80 48 04 00
	00		 mov	 eax, DWORD PTR [rax+1096]
  01195	89 81 28 02 00
	00		 mov	 DWORD PTR [rcx+552], eax

; 1302 : 
; 1303 : 					if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  0119b	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  011a3	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  011aa	83 b8 a8 1e 00
	00 00		 cmp	 DWORD PTR [rax+7848], 0
  011b1	74 47		 je	 SHORT $LN73@ProcessMai

; 1304 : 						prop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;

  011b3	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  011bb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  011c2	83 b8 ac 1e 00
	00 00		 cmp	 DWORD PTR [rax+7852], 0
  011c9	74 0d		 je	 SHORT $LN161@ProcessMai
  011cb	c7 84 24 74 05
	00 00 02 00 00
	00		 mov	 DWORD PTR tv557[rsp], 2
  011d6	eb 0b		 jmp	 SHORT $LN162@ProcessMai
$LN161@ProcessMai:
  011d8	c7 84 24 74 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv557[rsp], 1
$LN162@ProcessMai:
  011e3	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  011eb	8b 84 24 74 05
	00 00		 mov	 eax, DWORD PTR tv557[rsp]
  011f2	89 81 4c 02 00
	00		 mov	 DWORD PTR [rcx+588], eax

; 1305 : 					else

  011f8	eb 12		 jmp	 SHORT $LN72@ProcessMai
$LN73@ProcessMai:

; 1306 : 						prop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;

  011fa	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR prop$30876[rsp]
  01202	c7 80 4c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+588], 0
$LN72@ProcessMai:

; 1307 : 
; 1308 : 					prop->totalBytesRead = ListExtension->Queue.TotalBytesRead;

  0120c	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  01214	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  0121c	48 8b 80 58 03
	00 00		 mov	 rax, QWORD PTR [rax+856]
  01223	48 89 81 3c 02
	00 00		 mov	 QWORD PTR [rcx+572], rax

; 1309 : 					prop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;

  0122a	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  01232	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  0123a	48 8b 80 60 03
	00 00		 mov	 rax, QWORD PTR [rax+864]
  01241	48 89 81 44 02
	00 00		 mov	 QWORD PTR [rcx+580], rax

; 1310 : 
; 1311 : 					prop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? GST_VOLUME_FORMAT_VERSION_PRE_6_0 : GST_VOLUME_FORMAT_VERSION;

  01248	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$30881[rsp]
  01250	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01257	83 b8 e4 1e 00
	00 00		 cmp	 DWORD PTR [rax+7908], 0
  0125e	74 0d		 je	 SHORT $LN163@ProcessMai
  01260	c7 84 24 78 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv567[rsp], 1
  0126b	eb 0b		 jmp	 SHORT $LN164@ProcessMai
$LN163@ProcessMai:
  0126d	c7 84 24 78 05
	00 00 0d 00 00
	00		 mov	 DWORD PTR tv567[rsp], 13
$LN164@ProcessMai:
  01278	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$30876[rsp]
  01280	8b 84 24 78 05
	00 00		 mov	 eax, DWORD PTR tv567[rsp]
  01287	89 81 50 02 00
	00		 mov	 DWORD PTR [rcx+592], eax

; 1312 : 
; 1313 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  0128d	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01295	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1314 : 					Irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);

  0129c	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  012a4	48 c7 40 38 54
	02 00 00	 mov	 QWORD PTR [rax+56], 596	; 00000254H
$LN74@ProcessMai:
$LN75@ProcessMai:
$LN76@ProcessMai:

; 1315 : 				}
; 1316 : 			}
; 1317 : 		}
; 1318 : 		break;

  012ac	e9 95 0c 00 00	 jmp	 $LN149@ProcessMai
$LN71@ProcessMai:

; 1319 : 
; 1320 : 	case GST_IOCTL_GET_RESOLVED_SYMLINK:
; 1321 : 		if (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))

  012b1	41 b8 02 00 00
	00		 mov	 r8d, 2
  012b7	ba 10 04 00 00	 mov	 edx, 1040		; 00000410H
  012bc	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  012c4	e8 00 00 00 00	 call	 ValidateIOBufferSize
  012c9	85 c0		 test	 eax, eax
  012cb	74 70		 je	 SHORT $LN70@ProcessMai

; 1322 : 		{
; 1323 : 			RESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  012cd	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  012d5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  012d9	48 89 84 24 c0
	03 00 00	 mov	 QWORD PTR resolve$30891[rsp], rax

; 1324 : 			{
; 1325 : 				NTSTATUS ntStatus;
; 1326 : 
; 1327 : 				EnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));

  012e1	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  012e6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR resolve$30891[rsp]
  012ee	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1328 : 
; 1329 : 				ntStatus = SymbolicLinkToTarget (resolve->symLinkName,
; 1330 : 					resolve->targetName,
; 1331 : 					sizeof (resolve->targetName));

  012f3	48 8b 94 24 c0
	03 00 00	 mov	 rdx, QWORD PTR resolve$30891[rsp]
  012fb	48 81 c2 08 02
	00 00		 add	 rdx, 520		; 00000208H
  01302	66 41 b8 08 02	 mov	 r8w, 520		; 00000208H
  01307	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR resolve$30891[rsp]
  0130f	e8 00 00 00 00	 call	 SymbolicLinkToTarget
  01314	89 84 24 c8 03
	00 00		 mov	 DWORD PTR ntStatus$30893[rsp], eax

; 1332 : 
; 1333 : 				Irp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);

  0131b	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01323	48 c7 40 38 10
	04 00 00	 mov	 QWORD PTR [rax+56], 1040 ; 00000410H

; 1334 : 				Irp->IoStatus.Status = ntStatus;

  0132b	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01333	8b 84 24 c8 03
	00 00		 mov	 eax, DWORD PTR ntStatus$30893[rsp]
  0133a	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN70@ProcessMai:

; 1335 : 			}
; 1336 : 		}
; 1337 : 		break;

  0133d	e9 04 0c 00 00	 jmp	 $LN149@ProcessMai
$LN69@ProcessMai:

; 1338 : 
; 1339 : 	case GST_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1340 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))

  01342	41 b8 02 00 00
	00		 mov	 r8d, 2
  01348	ba 30 02 00 00	 mov	 edx, 560		; 00000230H
  0134d	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01355	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0135a	85 c0		 test	 eax, eax
  0135c	0f 84 85 02 00
	00		 je	 $LN68@ProcessMai

; 1341 : 		{
; 1342 : 			DISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01362	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0136a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0136e	48 89 84 24 d0
	03 00 00	 mov	 QWORD PTR info$30898[rsp], rax

; 1343 : 			{
; 1344 : 				PARTITION_INFORMATION_EX pi;
; 1345 : 				NTSTATUS ntStatus;
; 1346 : 
; 1347 : 				EnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));

  01376	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  0137b	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$30898[rsp]
  01383	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1348 : 
; 1349 : 				ntStatus = GSTDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));

  01388	c7 44 24 28 90
	00 00 00	 mov	 DWORD PTR [rsp+40], 144	; 00000090H
  01390	48 8d 84 24 e0
	03 00 00	 lea	 rax, QWORD PTR pi$30900[rsp]
  01398	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0139d	45 33 c9	 xor	 r9d, r9d
  013a0	45 33 c0	 xor	 r8d, r8d
  013a3	ba 48 00 07 00	 mov	 edx, 458824		; 00070048H
  013a8	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$30898[rsp]
  013b0	e8 00 00 00 00	 call	 GSTDeviceIoControl
  013b5	89 84 24 70 04
	00 00		 mov	 DWORD PTR ntStatus$30901[rsp], eax

; 1350 : 				if (NT_SUCCESS(ntStatus))

  013bc	83 bc 24 70 04
	00 00 00	 cmp	 DWORD PTR ntStatus$30901[rsp], 0
  013c4	0f 8c ca 00 00
	00		 jl	 $LN67@ProcessMai

; 1351 : 				{
; 1352 : 					memset (&info->partInfo, 0, sizeof (info->partInfo));

  013ca	48 8b bc 24 d0
	03 00 00	 mov	 rdi, QWORD PTR info$30898[rsp]
  013d2	48 81 c7 08 02
	00 00		 add	 rdi, 520		; 00000208H
  013d9	33 c0		 xor	 eax, eax
  013db	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  013e0	f3 aa		 rep stosb

; 1353 : 
; 1354 : 					info->partInfo.PartitionLength = pi.PartitionLength;

  013e2	48 8b 94 24 d0
	03 00 00	 mov	 rdx, QWORD PTR info$30898[rsp]
  013ea	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR pi$30900[rsp+16]
  013f2	48 89 82 10 02
	00 00		 mov	 QWORD PTR [rdx+528], rax

; 1355 : 					info->partInfo.PartitionNumber = pi.PartitionNumber;

  013f9	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$30898[rsp]
  01401	8b 84 24 f8 03
	00 00		 mov	 eax, DWORD PTR pi$30900[rsp+24]
  01408	89 81 1c 02 00
	00		 mov	 DWORD PTR [rcx+540], eax

; 1356 : 					info->partInfo.StartingOffset = pi.StartingOffset;

  0140e	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$30898[rsp]
  01416	48 8b 84 24 e8
	03 00 00	 mov	 rax, QWORD PTR pi$30900[rsp+8]
  0141e	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax

; 1357 : 
; 1358 : 					if (pi.PartitionStyle == PARTITION_STYLE_MBR)

  01425	83 bc 24 e0 03
	00 00 00	 cmp	 DWORD PTR pi$30900[rsp], 0
  0142d	75 2c		 jne	 SHORT $LN66@ProcessMai

; 1359 : 					{
; 1360 : 						info->partInfo.PartitionType = pi.Mbr.PartitionType;

  0142f	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$30898[rsp]
  01437	0f b6 84 24 00
	04 00 00	 movzx	 eax, BYTE PTR pi$30900[rsp+32]
  0143f	88 81 20 02 00
	00		 mov	 BYTE PTR [rcx+544], al

; 1361 : 						info->partInfo.BootIndicator = pi.Mbr.BootIndicator;

  01445	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$30898[rsp]
  0144d	0f b6 84 24 01
	04 00 00	 movzx	 eax, BYTE PTR pi$30900[rsp+33]
  01455	88 81 21 02 00
	00		 mov	 BYTE PTR [rcx+545], al
$LN66@ProcessMai:

; 1362 : 					}
; 1363 : 
; 1364 : 					info->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;

  0145b	83 bc 24 e0 03
	00 00 01	 cmp	 DWORD PTR pi$30900[rsp], 1
  01463	75 0d		 jne	 SHORT $LN165@ProcessMai
  01465	c7 84 24 7c 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv646[rsp], 1
  01470	eb 0b		 jmp	 SHORT $LN166@ProcessMai
$LN165@ProcessMai:
  01472	c7 84 24 7c 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv646[rsp], 0
$LN166@ProcessMai:
  0147d	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$30898[rsp]
  01485	8b 84 24 7c 05
	00 00		 mov	 eax, DWORD PTR tv646[rsp]
  0148c	89 81 28 02 00
	00		 mov	 DWORD PTR [rcx+552], eax

; 1365 : 				}
; 1366 : 				else

  01492	eb 4c		 jmp	 SHORT $LN65@ProcessMai
$LN67@ProcessMai:

; 1367 : 				{
; 1368 : 					// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 1369 : 					ntStatus = GSTDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));

  01494	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR info$30898[rsp]
  0149c	48 05 08 02 00
	00		 add	 rax, 520		; 00000208H
  014a2	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  014aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014af	45 33 c9	 xor	 r9d, r9d
  014b2	45 33 c0	 xor	 r8d, r8d
  014b5	ba 04 40 07 00	 mov	 edx, 475140		; 00074004H
  014ba	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$30898[rsp]
  014c2	e8 00 00 00 00	 call	 GSTDeviceIoControl
  014c7	89 84 24 70 04
	00 00		 mov	 DWORD PTR ntStatus$30901[rsp], eax

; 1370 : 					info->IsGPT = FALSE;

  014ce	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR info$30898[rsp]
  014d6	c7 80 28 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+552], 0
$LN65@ProcessMai:

; 1371 : 				}
; 1372 : 
; 1373 : 				if (!NT_SUCCESS (ntStatus))

  014e0	83 bc 24 70 04
	00 00 00	 cmp	 DWORD PTR ntStatus$30901[rsp], 0
  014e8	7d 6d		 jge	 SHORT $LN64@ProcessMai

; 1374 : 				{
; 1375 : 					GET_LENGTH_INFORMATION lengthInfo;
; 1376 : 					ntStatus = GSTDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));

  014ea	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  014f2	48 8d 84 24 78
	04 00 00	 lea	 rax, QWORD PTR lengthInfo$30910[rsp]
  014fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014ff	45 33 c9	 xor	 r9d, r9d
  01502	45 33 c0	 xor	 r8d, r8d
  01505	ba 5c 40 07 00	 mov	 edx, 475228		; 0007405cH
  0150a	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$30898[rsp]
  01512	e8 00 00 00 00	 call	 GSTDeviceIoControl
  01517	89 84 24 70 04
	00 00		 mov	 DWORD PTR ntStatus$30901[rsp], eax

; 1377 : 
; 1378 : 					if (NT_SUCCESS (ntStatus))

  0151e	83 bc 24 70 04
	00 00 00	 cmp	 DWORD PTR ntStatus$30901[rsp], 0
  01526	7c 2f		 jl	 SHORT $LN63@ProcessMai

; 1379 : 					{
; 1380 : 						memset (&info->partInfo, 0, sizeof (info->partInfo));

  01528	48 8b bc 24 d0
	03 00 00	 mov	 rdi, QWORD PTR info$30898[rsp]
  01530	48 81 c7 08 02
	00 00		 add	 rdi, 520		; 00000208H
  01537	33 c0		 xor	 eax, eax
  01539	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0153e	f3 aa		 rep stosb

; 1381 : 						info->partInfo.PartitionLength = lengthInfo.Length;

  01540	48 8b 94 24 d0
	03 00 00	 mov	 rdx, QWORD PTR info$30898[rsp]
  01548	48 8b 84 24 78
	04 00 00	 mov	 rax, QWORD PTR lengthInfo$30910[rsp]
  01550	48 89 82 10 02
	00 00		 mov	 QWORD PTR [rdx+528], rax
$LN63@ProcessMai:
$LN64@ProcessMai:

; 1382 : 					}
; 1383 : 				}
; 1384 : 
; 1385 : 				info->IsDynamic = FALSE;

  01557	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR info$30898[rsp]
  0155f	c7 80 2c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+556], 0

; 1386 : 
; 1387 : 				if (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)

  01569	83 bc 24 70 04
	00 00 00	 cmp	 DWORD PTR ntStatus$30901[rsp], 0
  01571	7c 52		 jl	 SHORT $LN62@ProcessMai
  01573	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR OsMajorVersion, 6
  0157a	72 49		 jb	 SHORT $LN62@ProcessMai

; 1388 : 				{
; 1389 : #					define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)
; 1390 : 					if (!NT_SUCCESS (GSTDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))

  0157c	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR info$30898[rsp]
  01584	48 05 2c 02 00
	00		 add	 rax, 556		; 0000022cH
  0158a	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  01592	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01597	45 33 c9	 xor	 r9d, r9d
  0159a	45 33 c0	 xor	 r8d, r8d
  0159d	ba 48 00 56 00	 mov	 edx, 5636168		; 00560048H
  015a2	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$30898[rsp]
  015aa	e8 00 00 00 00	 call	 GSTDeviceIoControl
  015af	85 c0		 test	 eax, eax
  015b1	7d 12		 jge	 SHORT $LN61@ProcessMai

; 1391 : 						info->IsDynamic = FALSE;

  015b3	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR info$30898[rsp]
  015bb	c7 80 2c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+556], 0
$LN61@ProcessMai:
$LN62@ProcessMai:

; 1392 : 				}
; 1393 : 
; 1394 : 				Irp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);

  015c5	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  015cd	48 c7 40 38 30
	02 00 00	 mov	 QWORD PTR [rax+56], 560	; 00000230H

; 1395 : 				Irp->IoStatus.Status = ntStatus;

  015d5	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  015dd	8b 84 24 70 04
	00 00		 mov	 eax, DWORD PTR ntStatus$30901[rsp]
  015e4	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN68@ProcessMai:

; 1396 : 			}
; 1397 : 		}
; 1398 : 		break;

  015e7	e9 5a 09 00 00	 jmp	 $LN149@ProcessMai
$LN60@ProcessMai:

; 1399 : 
; 1400 : 	case GST_IOCTL_GET_DRIVE_GEOMETRY:
; 1401 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))

  015ec	41 b8 02 00 00
	00		 mov	 r8d, 2
  015f2	ba 20 02 00 00	 mov	 edx, 544		; 00000220H
  015f7	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  015ff	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01604	85 c0		 test	 eax, eax
  01606	0f 84 82 00 00
	00		 je	 $LN59@ProcessMai

; 1402 : 		{
; 1403 : 			DISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0160c	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01614	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01618	48 89 84 24 80
	04 00 00	 mov	 QWORD PTR g$30923[rsp], rax

; 1404 : 			{
; 1405 : 				NTSTATUS ntStatus;
; 1406 : 
; 1407 : 				EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));

  01620	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  01625	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR g$30923[rsp]
  0162d	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1408 : 
; 1409 : 				ntStatus = GSTDeviceIoControl (g->deviceName,
; 1410 : 					IOCTL_DISK_GET_DRIVE_GEOMETRY,
; 1411 : 					NULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));

  01632	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR g$30923[rsp]
  0163a	48 05 08 02 00
	00		 add	 rax, 520		; 00000208H
  01640	c7 44 24 28 18
	00 00 00	 mov	 DWORD PTR [rsp+40], 24
  01648	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0164d	45 33 c9	 xor	 r9d, r9d
  01650	45 33 c0	 xor	 r8d, r8d
  01653	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  01658	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR g$30923[rsp]
  01660	e8 00 00 00 00	 call	 GSTDeviceIoControl
  01665	89 84 24 88 04
	00 00		 mov	 DWORD PTR ntStatus$30925[rsp], eax

; 1412 : 
; 1413 : 				Irp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);

  0166c	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01674	48 c7 40 38 20
	02 00 00	 mov	 QWORD PTR [rax+56], 544	; 00000220H

; 1414 : 				Irp->IoStatus.Status = ntStatus;

  0167c	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01684	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR ntStatus$30925[rsp]
  0168b	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN59@ProcessMai:

; 1415 : 			}
; 1416 : 		}
; 1417 : 		break;

  0168e	e9 b3 08 00 00	 jmp	 $LN149@ProcessMai
$LN58@ProcessMai:

; 1418 : 
; 1419 : 	case GST_IOCTL_PROBE_REAL_DRIVE_SIZE:
; 1420 : 		if (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))

  01693	41 b8 02 00 00
	00		 mov	 r8d, 2
  01699	ba 14 02 00 00	 mov	 edx, 532		; 00000214H
  0169e	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  016a6	e8 00 00 00 00	 call	 ValidateIOBufferSize
  016ab	85 c0		 test	 eax, eax
  016ad	0f 84 6a 01 00
	00		 je	 $LN57@ProcessMai

; 1421 : 		{
; 1422 : 			ProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;

  016b3	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  016bb	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  016bf	48 89 84 24 b0
	04 00 00	 mov	 QWORD PTR request$30931[rsp], rax

; 1423 : 			NTSTATUS status;
; 1424 : 			UNICODE_STRING name;
; 1425 : 			PFILE_OBJECT fileObject;
; 1426 : 			PDEVICE_OBJECT deviceObject;
; 1427 : 
; 1428 : 			EnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));

  016c7	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  016cc	48 8b 8c 24 b0
	04 00 00	 mov	 rcx, QWORD PTR request$30931[rsp]
  016d4	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1429 : 
; 1430 : 			RtlInitUnicodeString (&name, request->DeviceName);

  016d9	48 8b 94 24 b0
	04 00 00	 mov	 rdx, QWORD PTR request$30931[rsp]
  016e1	48 8d 8c 24 a0
	04 00 00	 lea	 rcx, QWORD PTR name$30934[rsp]
  016e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 1431 : 			status = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  016ef	4c 8d 8c 24 90
	04 00 00	 lea	 r9, QWORD PTR deviceObject$30936[rsp]
  016f7	4c 8d 84 24 98
	04 00 00	 lea	 r8, QWORD PTR fileObject$30935[rsp]
  016ff	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01704	48 8d 8c 24 a0
	04 00 00	 lea	 rcx, QWORD PTR name$30934[rsp]
  0170c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer
  01712	89 84 24 b8 04
	00 00		 mov	 DWORD PTR status$30933[rsp], eax

; 1432 : 			if (!NT_SUCCESS (status))

  01719	83 bc 24 b8 04
	00 00 00	 cmp	 DWORD PTR status$30933[rsp], 0
  01721	7d 27		 jge	 SHORT $LN56@ProcessMai

; 1433 : 			{
; 1434 : 				Irp->IoStatus.Information = 0;

  01723	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0172b	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1435 : 				Irp->IoStatus.Status = status;

  01733	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0173b	8b 84 24 b8 04
	00 00		 mov	 eax, DWORD PTR status$30933[rsp]
  01742	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1436 : 				break;

  01745	e9 fc 07 00 00	 jmp	 $LN149@ProcessMai
$LN56@ProcessMai:

; 1437 : 			}
; 1438 : 
; 1439 : 			status = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);

  0174a	48 8b 94 24 b0
	04 00 00	 mov	 rdx, QWORD PTR request$30931[rsp]
  01752	48 81 c2 08 02
	00 00		 add	 rdx, 520		; 00000208H
  01759	48 8b 8c 24 90
	04 00 00	 mov	 rcx, QWORD PTR deviceObject$30936[rsp]
  01761	e8 00 00 00 00	 call	 ProbeRealDriveSize
  01766	89 84 24 b8 04
	00 00		 mov	 DWORD PTR status$30933[rsp], eax

; 1440 : 			ObDereferenceObject (fileObject);

  0176d	48 8b 8c 24 98
	04 00 00	 mov	 rcx, QWORD PTR fileObject$30935[rsp]
  01775	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 1441 : 
; 1442 : 			if (status == STATUS_TIMEOUT)

  0177b	81 bc 24 b8 04
	00 00 02 01 00
	00		 cmp	 DWORD PTR status$30933[rsp], 258 ; 00000102H
  01786	75 33		 jne	 SHORT $LN55@ProcessMai

; 1443 : 			{
; 1444 : 				request->TimeOut = TRUE;

  01788	48 8b 84 24 b0
	04 00 00	 mov	 rax, QWORD PTR request$30931[rsp]
  01790	c7 80 10 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+528], 1

; 1445 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  0179a	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  017a2	48 c7 40 38 14
	02 00 00	 mov	 QWORD PTR [rax+56], 532	; 00000214H

; 1446 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  017aa	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  017b2	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
  017b9	eb 62		 jmp	 SHORT $LN54@ProcessMai
$LN55@ProcessMai:

; 1447 : 			}
; 1448 : 			else if (!NT_SUCCESS (status))

  017bb	83 bc 24 b8 04
	00 00 00	 cmp	 DWORD PTR status$30933[rsp], 0
  017c3	7d 24		 jge	 SHORT $LN53@ProcessMai

; 1449 : 			{
; 1450 : 				Irp->IoStatus.Information = 0;

  017c5	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  017cd	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1451 : 				Irp->IoStatus.Status = status;

  017d5	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  017dd	8b 84 24 b8 04
	00 00		 mov	 eax, DWORD PTR status$30933[rsp]
  017e4	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1452 : 			}
; 1453 : 			else

  017e7	eb 34		 jmp	 SHORT $LN52@ProcessMai
$LN53@ProcessMai:

; 1454 : 			{
; 1455 : 				request->TimeOut = FALSE;

  017e9	48 8b 84 24 b0
	04 00 00	 mov	 rax, QWORD PTR request$30931[rsp]
  017f1	c7 80 10 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+528], 0

; 1456 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  017fb	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01803	48 c7 40 38 14
	02 00 00	 mov	 QWORD PTR [rax+56], 532	; 00000214H

; 1457 : 				Irp->IoStatus.Status = status;

  0180b	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01813	8b 84 24 b8 04
	00 00		 mov	 eax, DWORD PTR status$30933[rsp]
  0181a	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN52@ProcessMai:
$LN54@ProcessMai:
$LN57@ProcessMai:

; 1458 : 			}
; 1459 : 		}
; 1460 : 		break;

  0181d	e9 24 07 00 00	 jmp	 $LN149@ProcessMai
$LN51@ProcessMai:

; 1461 : 
; 1462 : 	case GST_IOCTL_MOUNT_VOLUME:
; 1463 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))

  01822	41 b8 02 00 00
	00		 mov	 r8d, 2
  01828	ba e0 02 00 00	 mov	 edx, 736		; 000002e0H
  0182d	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01835	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0183a	85 c0		 test	 eax, eax
  0183c	0f 84 9c 01 00
	00		 je	 $LN50@ProcessMai

; 1464 : 		{
; 1465 : 			MOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01842	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0184a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0184e	48 89 84 24 c0
	04 00 00	 mov	 QWORD PTR mount$30951[rsp], rax

; 1466 : 
; 1467 : 			if (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD)

  01856	48 8b 84 24 c0
	04 00 00	 mov	 rax, QWORD PTR mount$30951[rsp]
  0185e	83 b8 18 02 00
	00 40		 cmp	 DWORD PTR [rax+536], 64	; 00000040H
  01865	77 11		 ja	 SHORT $LN48@ProcessMai
  01867	48 8b 84 24 c0
	04 00 00	 mov	 rax, QWORD PTR mount$30951[rsp]
  0186f	83 b8 90 02 00
	00 40		 cmp	 DWORD PTR [rax+656], 64	; 00000040H
  01876	76 24		 jbe	 SHORT $LN49@ProcessMai
$LN48@ProcessMai:

; 1468 : 			{
; 1469 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  01878	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01880	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 1470 : 				Irp->IoStatus.Information = 0;

  01887	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0188f	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1471 : 				break;

  01897	e9 aa 06 00 00	 jmp	 $LN149@ProcessMai
$LN49@ProcessMai:

; 1472 : 			}
; 1473 : 
; 1474 : 			EnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));

  0189c	48 8b 8c 24 c0
	04 00 00	 mov	 rcx, QWORD PTR mount$30951[rsp]
  018a4	48 83 c1 10	 add	 rcx, 16
  018a8	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  018ad	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1475 : 
; 1476 : 			Irp->IoStatus.Information = sizeof (MOUNT_STRUCT);

  018b2	48 8b 94 24 c0
	05 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  018ba	48 c7 42 38 e0
	02 00 00	 mov	 QWORD PTR [rdx+56], 736	; 000002e0H

; 1477 : 			Irp->IoStatus.Status = MountDevice (DeviceObject, mount);

  018c2	48 8b 94 24 c0
	04 00 00	 mov	 rdx, QWORD PTR mount$30951[rsp]
  018ca	48 8b 8c 24 b0
	05 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  018d2	e8 00 00 00 00	 call	 MountDevice
  018d7	8b d0		 mov	 edx, eax
  018d9	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  018e1	89 50 30	 mov	 DWORD PTR [rax+48], edx
$LN47@ProcessMai:

; 1478 : 
; 1479 : 			burn (&mount->VolumePassword, sizeof (mount->VolumePassword));

  018e4	48 8b 84 24 c0
	04 00 00	 mov	 rax, QWORD PTR mount$30951[rsp]
  018ec	48 05 18 02 00
	00		 add	 rax, 536		; 00000218H
  018f2	48 89 84 24 d0
	04 00 00	 mov	 QWORD PTR burnm$30960[rsp], rax
  018fa	c7 84 24 c8 04
	00 00 48 00 00
	00		 mov	 DWORD PTR burnc$30962[rsp], 72 ; 00000048H
  01905	48 8b 8c 24 c0
	04 00 00	 mov	 rcx, QWORD PTR mount$30951[rsp]
  0190d	48 81 c1 18 02
	00 00		 add	 rcx, 536		; 00000218H
  01914	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  01919	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN44@ProcessMai:
  0191e	8b 8c 24 c8 04
	00 00		 mov	 ecx, DWORD PTR burnc$30962[rsp]
  01925	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR burnc$30962[rsp]
  0192c	83 e8 01	 sub	 eax, 1
  0192f	89 84 24 c8 04
	00 00		 mov	 DWORD PTR burnc$30962[rsp], eax
  01936	85 c9		 test	 ecx, ecx
  01938	74 21		 je	 SHORT $LN43@ProcessMai
  0193a	48 8b 84 24 d0
	04 00 00	 mov	 rax, QWORD PTR burnm$30960[rsp]
  01942	c6 00 00	 mov	 BYTE PTR [rax], 0
  01945	48 8b 84 24 d0
	04 00 00	 mov	 rax, QWORD PTR burnm$30960[rsp]
  0194d	48 83 c0 01	 add	 rax, 1
  01951	48 89 84 24 d0
	04 00 00	 mov	 QWORD PTR burnm$30960[rsp], rax
  01959	eb c3		 jmp	 SHORT $LN44@ProcessMai
$LN43@ProcessMai:
  0195b	33 c0		 xor	 eax, eax
  0195d	85 c0		 test	 eax, eax
  0195f	75 83		 jne	 SHORT $LN47@ProcessMai
$LN42@ProcessMai:

; 1480 : 			burn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));

  01961	48 8b 84 24 c0
	04 00 00	 mov	 rax, QWORD PTR mount$30951[rsp]
  01969	48 05 90 02 00
	00		 add	 rax, 656		; 00000290H
  0196f	48 89 84 24 e0
	04 00 00	 mov	 QWORD PTR burnm$30969[rsp], rax
  01977	c7 84 24 d8 04
	00 00 48 00 00
	00		 mov	 DWORD PTR burnc$30971[rsp], 72 ; 00000048H
  01982	48 8b 8c 24 c0
	04 00 00	 mov	 rcx, QWORD PTR mount$30951[rsp]
  0198a	48 81 c1 90 02
	00 00		 add	 rcx, 656		; 00000290H
  01991	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  01996	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN39@ProcessMai:
  0199b	8b 8c 24 d8 04
	00 00		 mov	 ecx, DWORD PTR burnc$30971[rsp]
  019a2	8b 84 24 d8 04
	00 00		 mov	 eax, DWORD PTR burnc$30971[rsp]
  019a9	83 e8 01	 sub	 eax, 1
  019ac	89 84 24 d8 04
	00 00		 mov	 DWORD PTR burnc$30971[rsp], eax
  019b3	85 c9		 test	 ecx, ecx
  019b5	74 21		 je	 SHORT $LN38@ProcessMai
  019b7	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR burnm$30969[rsp]
  019bf	c6 00 00	 mov	 BYTE PTR [rax], 0
  019c2	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR burnm$30969[rsp]
  019ca	48 83 c0 01	 add	 rax, 1
  019ce	48 89 84 24 e0
	04 00 00	 mov	 QWORD PTR burnm$30969[rsp], rax
  019d6	eb c3		 jmp	 SHORT $LN39@ProcessMai
$LN38@ProcessMai:
  019d8	33 c0		 xor	 eax, eax
  019da	85 c0		 test	 eax, eax
  019dc	75 83		 jne	 SHORT $LN42@ProcessMai
$LN50@ProcessMai:

; 1481 : 		}
; 1482 : 		break;

  019de	e9 63 05 00 00	 jmp	 $LN149@ProcessMai
$LN37@ProcessMai:

; 1483 : 
; 1484 : 	case GST_IOCTL_DISMOUNT_VOLUME:
; 1485 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  019e3	41 b8 02 00 00
	00		 mov	 r8d, 2
  019e9	ba 10 00 00 00	 mov	 edx, 16
  019ee	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  019f6	e8 00 00 00 00	 call	 ValidateIOBufferSize
  019fb	85 c0		 test	 eax, eax
  019fd	0f 84 b7 00 00
	00		 je	 $LN36@ProcessMai

; 1486 : 		{
; 1487 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01a03	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01a0b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01a0f	48 89 84 24 e8
	04 00 00	 mov	 QWORD PTR unmount$30978[rsp], rax

; 1488 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);

  01a17	48 8b 84 24 e8
	04 00 00	 mov	 rax, QWORD PTR unmount$30978[rsp]
  01a1f	8b 08		 mov	 ecx, DWORD PTR [rax]
  01a21	e8 00 00 00 00	 call	 GetVirtualVolumeDeviceObject
  01a26	48 89 84 24 f0
	04 00 00	 mov	 QWORD PTR ListDevice$30980[rsp], rax

; 1489 : 
; 1490 : 			unmount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  01a2e	48 8b 84 24 e8
	04 00 00	 mov	 rax, QWORD PTR unmount$30978[rsp]
  01a36	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [rax+12], 5

; 1491 : 
; 1492 : 			if (ListDevice)

  01a3d	48 83 bc 24 f0
	04 00 00 00	 cmp	 QWORD PTR ListDevice$30980[rsp], 0
  01a46	74 53		 je	 SHORT $LN35@ProcessMai

; 1493 : 			{
; 1494 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  01a48	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR ListDevice$30980[rsp]
  01a50	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  01a54	48 89 84 24 f8
	04 00 00	 mov	 QWORD PTR ListExtension$30982[rsp], rax

; 1495 : 
; 1496 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  01a5c	48 8b 8c 24 f8
	04 00 00	 mov	 rcx, QWORD PTR ListExtension$30982[rsp]
  01a64	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  01a69	85 c0		 test	 eax, eax
  01a6b	74 2e		 je	 SHORT $LN34@ProcessMai

; 1497 : 					unmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);

  01a6d	48 8b 84 24 e8
	04 00 00	 mov	 rax, QWORD PTR unmount$30978[rsp]
  01a75	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  01a79	48 8b 94 24 f0
	04 00 00	 mov	 rdx, QWORD PTR ListDevice$30980[rsp]
  01a81	48 8b 8c 24 e8
	04 00 00	 mov	 rcx, QWORD PTR unmount$30978[rsp]
  01a89	e8 00 00 00 00	 call	 UnmountDevice
  01a8e	8b d0		 mov	 edx, eax
  01a90	48 8b 84 24 e8
	04 00 00	 mov	 rax, QWORD PTR unmount$30978[rsp]
  01a98	89 50 0c	 mov	 DWORD PTR [rax+12], edx
$LN34@ProcessMai:
$LN35@ProcessMai:

; 1498 : 			}
; 1499 : 
; 1500 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  01a9b	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01aa3	48 c7 40 38 10
	00 00 00	 mov	 QWORD PTR [rax+56], 16

; 1501 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01aab	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01ab3	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN36@ProcessMai:

; 1502 : 		}
; 1503 : 		break;

  01aba	e9 87 04 00 00	 jmp	 $LN149@ProcessMai
$LN33@ProcessMai:

; 1504 : 
; 1505 : 	case GST_IOCTL_DISMOUNT_ALL_VOLUMES:
; 1506 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  01abf	41 b8 02 00 00
	00		 mov	 r8d, 2
  01ac5	ba 10 00 00 00	 mov	 edx, 16
  01aca	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01ad2	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01ad7	85 c0		 test	 eax, eax
  01ad9	74 58		 je	 SHORT $LN32@ProcessMai

; 1507 : 		{
; 1508 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01adb	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01ae3	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01ae7	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR unmount$30990[rsp], rax

; 1509 : 
; 1510 : 			unmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);

  01aef	48 8b 84 24 00
	05 00 00	 mov	 rax, QWORD PTR unmount$30990[rsp]
  01af7	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  01afa	48 8b 8c 24 00
	05 00 00	 mov	 rcx, QWORD PTR unmount$30990[rsp]
  01b02	e8 00 00 00 00	 call	 UnmountAllDevices
  01b07	8b d0		 mov	 edx, eax
  01b09	48 8b 84 24 00
	05 00 00	 mov	 rax, QWORD PTR unmount$30990[rsp]
  01b11	89 50 0c	 mov	 DWORD PTR [rax+12], edx

; 1511 : 
; 1512 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  01b14	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01b1c	48 c7 40 38 10
	00 00 00	 mov	 QWORD PTR [rax+56], 16

; 1513 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01b24	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01b2c	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN32@ProcessMai:

; 1514 : 		}
; 1515 : 		break;

  01b33	e9 0e 04 00 00	 jmp	 $LN149@ProcessMai
$LN31@ProcessMai:

; 1516 : 
; 1517 : 	case GST_IOCTL_BOOT_ENCRYPTION_SETUP:
; 1518 : 		Irp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);

  01b38	4c 8b 44 24 68	 mov	 r8, QWORD PTR irpSp$[rsp]
  01b3d	48 8b 94 24 c0
	05 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  01b45	48 8b 8c 24 b0
	05 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  01b4d	e8 00 00 00 00	 call	 StartBootEncryptionSetup
  01b52	8b d0		 mov	 edx, eax
  01b54	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01b5c	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1519 : 		Irp->IoStatus.Information = 0;

  01b5f	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01b67	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1520 : 		break;

  01b6f	e9 d2 03 00 00	 jmp	 $LN149@ProcessMai
$LN30@ProcessMai:

; 1521 : 
; 1522 : 	case GST_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:
; 1523 : 		Irp->IoStatus.Status = AbortBootEncryptionSetup();

  01b74	e8 00 00 00 00	 call	 AbortBootEncryptionSetup
  01b79	8b d0		 mov	 edx, eax
  01b7b	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01b83	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1524 : 		Irp->IoStatus.Information = 0;

  01b86	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01b8e	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1525 : 		break;

  01b96	e9 ab 03 00 00	 jmp	 $LN149@ProcessMai
$LN29@ProcessMai:

; 1526 : 
; 1527 : 	case GST_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1528 : 		GetBootEncryptionStatus (Irp, irpSp);

  01b9b	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01ba0	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01ba8	e8 00 00 00 00	 call	 GetBootEncryptionStatus

; 1529 : 		break;

  01bad	e9 94 03 00 00	 jmp	 $LN149@ProcessMai
$LN28@ProcessMai:

; 1530 : 
; 1531 : 	case GST_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:
; 1532 : 		Irp->IoStatus.Information = 0;

  01bb2	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01bba	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1533 : 		Irp->IoStatus.Status = GetSetupResult();

  01bc2	e8 00 00 00 00	 call	 GetSetupResult
  01bc7	8b d0		 mov	 edx, eax
  01bc9	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01bd1	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1534 : 		break;

  01bd4	e9 6d 03 00 00	 jmp	 $LN149@ProcessMai
$LN27@ProcessMai:

; 1535 : 
; 1536 : 	case GST_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1537 : 		GetBootDriveVolumeProperties (Irp, irpSp);

  01bd9	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01bde	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01be6	e8 00 00 00 00	 call	 GetBootDriveVolumeProperties

; 1538 : 		break;

  01beb	e9 56 03 00 00	 jmp	 $LN149@ProcessMai
$LN26@ProcessMai:

; 1539 : 
; 1540 : 	case GST_IOCTL_GET_BOOT_LOADER_VERSION:
; 1541 : 		GetBootLoaderVersion (Irp, irpSp);

  01bf0	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01bf5	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01bfd	e8 00 00 00 00	 call	 GetBootLoaderVersion

; 1542 : 		break;

  01c02	e9 3f 03 00 00	 jmp	 $LN149@ProcessMai
$LN25@ProcessMai:

; 1543 : 
; 1544 : 	case GST_IOCTL_REOPEN_BOOT_VOLUME_HEADER:
; 1545 : 		ReopenBootVolumeHeader (Irp, irpSp);

  01c07	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01c0c	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01c14	e8 00 00 00 00	 call	 ReopenBootVolumeHeader

; 1546 : 		break;

  01c19	e9 28 03 00 00	 jmp	 $LN149@ProcessMai
$LN24@ProcessMai:

; 1547 : 
; 1548 : 	case GST_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:
; 1549 : 		GetBootEncryptionAlgorithmName (Irp, irpSp);

  01c1e	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01c23	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01c2b	e8 00 00 00 00	 call	 GetBootEncryptionAlgorithmName

; 1550 : 		break;

  01c30	e9 11 03 00 00	 jmp	 $LN149@ProcessMai
$LN23@ProcessMai:

; 1551 : 
; 1552 : 	case GST_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1553 : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  01c35	41 b8 01 00 00
	00		 mov	 r8d, 1
  01c3b	ba 04 00 00 00	 mov	 edx, 4
  01c40	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01c48	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01c4d	85 c0		 test	 eax, eax
  01c4f	74 55		 je	 SHORT $LN22@ProcessMai

; 1554 : 		{
; 1555 : 			*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;

  01c51	e8 00 00 00 00	 call	 IsHiddenSystemRunning
  01c56	85 c0		 test	 eax, eax
  01c58	74 0d		 je	 SHORT $LN167@ProcessMai
  01c5a	c7 84 24 80 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv870[rsp], 1
  01c65	eb 0b		 jmp	 SHORT $LN168@ProcessMai
$LN167@ProcessMai:
  01c67	c7 84 24 80 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv870[rsp], 0
$LN168@ProcessMai:
  01c72	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01c7a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01c7e	8b 84 24 80 05
	00 00		 mov	 eax, DWORD PTR tv870[rsp]
  01c85	89 01		 mov	 DWORD PTR [rcx], eax

; 1556 : 			Irp->IoStatus.Information = sizeof (int);

  01c87	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01c8f	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 1557 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01c97	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01c9f	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN22@ProcessMai:

; 1558 : 		}
; 1559 : 		break;

  01ca6	e9 9b 02 00 00	 jmp	 $LN149@ProcessMai
$LN21@ProcessMai:

; 1560 : 
; 1561 : 	case GST_IOCTL_START_DECOY_SYSTEM_WIPE:
; 1562 : 		Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);

  01cab	4c 8b 44 24 68	 mov	 r8, QWORD PTR irpSp$[rsp]
  01cb0	48 8b 94 24 c0
	05 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  01cb8	48 8b 8c 24 b0
	05 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  01cc0	e8 00 00 00 00	 call	 StartDecoySystemWipe
  01cc5	8b d0		 mov	 edx, eax
  01cc7	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01ccf	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1563 : 		Irp->IoStatus.Information = 0;

  01cd2	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01cda	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1564 : 		break;

  01ce2	e9 5f 02 00 00	 jmp	 $LN149@ProcessMai
$LN20@ProcessMai:

; 1565 : 
; 1566 : 	case GST_IOCTL_ABORT_DECOY_SYSTEM_WIPE:
; 1567 : 		Irp->IoStatus.Status = AbortDecoySystemWipe();

  01ce7	e8 00 00 00 00	 call	 AbortDecoySystemWipe
  01cec	8b d0		 mov	 edx, eax
  01cee	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01cf6	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1568 : 		Irp->IoStatus.Information = 0;

  01cf9	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01d01	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1569 : 		break;

  01d09	e9 38 02 00 00	 jmp	 $LN149@ProcessMai
$LN19@ProcessMai:

; 1570 : 
; 1571 : 	case GST_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:
; 1572 : 		Irp->IoStatus.Status = GetDecoySystemWipeResult();

  01d0e	e8 00 00 00 00	 call	 GetDecoySystemWipeResult
  01d13	8b d0		 mov	 edx, eax
  01d15	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01d1d	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1573 : 		Irp->IoStatus.Information = 0;

  01d20	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01d28	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1574 : 		break;

  01d30	e9 11 02 00 00	 jmp	 $LN149@ProcessMai
$LN18@ProcessMai:

; 1575 : 
; 1576 : 	case GST_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 1577 : 		GetDecoySystemWipeStatus (Irp, irpSp);

  01d35	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01d3a	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01d42	e8 00 00 00 00	 call	 GetDecoySystemWipeStatus

; 1578 : 		break;

  01d47	e9 fa 01 00 00	 jmp	 $LN149@ProcessMai
$LN17@ProcessMai:

; 1579 : 
; 1580 : 	case GST_IOCTL_WRITE_BOOT_DRIVE_SECTOR:
; 1581 : 		Irp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);

  01d4c	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01d51	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01d59	e8 00 00 00 00	 call	 WriteBootDriveSector
  01d5e	8b d0		 mov	 edx, eax
  01d60	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01d68	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1582 : 		Irp->IoStatus.Information = 0;

  01d6b	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01d73	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1583 : 		break;

  01d7b	e9 c6 01 00 00	 jmp	 $LN149@ProcessMai
$LN16@ProcessMai:

; 1584 : 
; 1585 : 	case GST_IOCTL_GET_WARNING_FLAGS:
; 1586 : 		if (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))

  01d80	41 b8 01 00 00
	00		 mov	 r8d, 1
  01d86	ba 08 00 00 00	 mov	 edx, 8
  01d8b	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01d93	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01d98	85 c0		 test	 eax, eax
  01d9a	74 68		 je	 SHORT $LN15@ProcessMai

; 1587 : 		{
; 1588 : 			GetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;

  01d9c	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01da4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01da8	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR flags$31016[rsp], rax

; 1589 : 
; 1590 : 			flags->PagingFileCreationPrevented = PagingFileCreationPrevented;

  01db0	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR flags$31016[rsp]
  01db8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PagingFileCreationPrevented
  01dbe	89 01		 mov	 DWORD PTR [rcx], eax

; 1591 : 			PagingFileCreationPrevented = FALSE;

  01dc0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR PagingFileCreationPrevented, 0

; 1592 : 			flags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;

  01dca	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR flags$31016[rsp]
  01dd2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SystemFavoriteVolumeDirty
  01dd8	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1593 : 			SystemFavoriteVolumeDirty = FALSE;

  01ddb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR SystemFavoriteVolumeDirty, 0

; 1594 : 
; 1595 : 			Irp->IoStatus.Information = sizeof (GetWarningFlagsRequest);

  01de5	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01ded	48 c7 40 38 08
	00 00 00	 mov	 QWORD PTR [rax+56], 8

; 1596 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01df5	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01dfd	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN15@ProcessMai:

; 1597 : 		}
; 1598 : 		break;

  01e04	e9 3d 01 00 00	 jmp	 $LN149@ProcessMai
$LN14@ProcessMai:

; 1599 : 
; 1600 : 	case GST_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:
; 1601 : 		if (UserCanAccessDriveDevice())

  01e09	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  01e0e	85 c0		 test	 eax, eax
  01e10	74 1b		 je	 SHORT $LN13@ProcessMai

; 1602 : 		{
; 1603 : 			SystemFavoriteVolumeDirty = TRUE;

  01e12	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR SystemFavoriteVolumeDirty, 1

; 1604 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01e1c	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e24	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1605 : 		}
; 1606 : 		else

  01e2b	eb 0f		 jmp	 SHORT $LN12@ProcessMai
$LN13@ProcessMai:

; 1607 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  01e2d	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e35	c7 40 30 22 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741790 ; ffffffffc0000022H
$LN12@ProcessMai:

; 1608 : 
; 1609 : 		Irp->IoStatus.Information = 0;

  01e3c	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e44	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1610 : 		break;

  01e4c	e9 f5 00 00 00	 jmp	 $LN149@ProcessMai
$LN11@ProcessMai:

; 1611 : 
; 1612 : 	case GST_IOCTL_REREAD_DRIVER_CONFIG:
; 1613 : 		Irp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);

  01e51	33 c9		 xor	 ecx, ecx
  01e53	e8 00 00 00 00	 call	 ReadRegistryConfigFlags
  01e58	8b d0		 mov	 edx, eax
  01e5a	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e62	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1614 : 		Irp->IoStatus.Information = 0;

  01e65	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e6d	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1615 : 		break;

  01e75	e9 cc 00 00 00	 jmp	 $LN149@ProcessMai
$LN10@ProcessMai:

; 1616 : 
; 1617 : 	case GST_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:
; 1618 : 		if (ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))

  01e7a	41 b8 01 00 00
	00		 mov	 r8d, 1
  01e80	ba 0c 00 00 00	 mov	 edx, 12
  01e85	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01e8d	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01e92	85 c0		 test	 eax, eax
  01e94	0f 84 90 00 00
	00		 je	 $LN9@ProcessMai

; 1619 : 		{
; 1620 : 			GetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;

  01e9a	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01ea2	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01ea6	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR request$31029[rsp], rax

; 1621 : 
; 1622 : 			request->BootDriveFilterExtension = GetBootDriveFilterExtension();

  01eae	e8 00 00 00 00	 call	 GetBootDriveFilterExtension
  01eb3	48 8b d0	 mov	 rdx, rax
  01eb6	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR request$31029[rsp]
  01ebe	48 89 10	 mov	 QWORD PTR [rax], rdx

; 1623 : 			if (IsBootDriveMounted() && request->BootDriveFilterExtension)

  01ec1	e8 00 00 00 00	 call	 IsBootDriveMounted
  01ec6	85 c0		 test	 eax, eax
  01ec8	74 41		 je	 SHORT $LN8@ProcessMai
  01eca	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR request$31029[rsp]
  01ed2	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01ed6	74 33		 je	 SHORT $LN8@ProcessMai

; 1624 : 			{
; 1625 : 				request->HwEncryptionEnabled = IsHwEncryptionEnabled();

  01ed8	e8 00 00 00 00	 call	 IsHwEncryptionEnabled
  01edd	8b d0		 mov	 edx, eax
  01edf	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR request$31029[rsp]
  01ee7	89 50 08	 mov	 DWORD PTR [rax+8], edx

; 1626 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  01eea	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01ef2	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1627 : 				Irp->IoStatus.Information = sizeof (*request);

  01ef9	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01f01	48 c7 40 38 0c
	00 00 00	 mov	 QWORD PTR [rax+56], 12

; 1628 : 			}
; 1629 : 			else

  01f09	eb 1f		 jmp	 SHORT $LN7@ProcessMai
$LN8@ProcessMai:

; 1630 : 			{
; 1631 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  01f0b	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01f13	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 1632 : 				Irp->IoStatus.Information = 0;

  01f1a	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01f22	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN7@ProcessMai:
$LN9@ProcessMai:

; 1633 : 			}
; 1634 : 		}
; 1635 : 		break;

  01f2a	eb 1a		 jmp	 SHORT $LN149@ProcessMai
$LN6@ProcessMai:

; 1636 : 
; 1637 : 	default:
; 1638 : 		return GSTCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  01f2c	45 33 c0	 xor	 r8d, r8d
  01f2f	ba 10 00 00 c0	 mov	 edx, -1073741808	; ffffffffc0000010H
  01f34	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01f3c	e8 00 00 00 00	 call	 GSTCompleteIrp
  01f41	e9 99 00 00 00	 jmp	 $LN151@ProcessMai
$LN149@ProcessMai:

; 1639 : 	}
; 1640 : 
; 1641 : 	
; 1642 : #ifdef DEBUG
; 1643 : 	if (!NT_SUCCESS (Irp->IoStatus.Status))

  01f46	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01f4e	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  01f52	7d 67		 jge	 SHORT $LN5@ProcessMai

; 1644 : 	{
; 1645 : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  01f54	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  01f59	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01f5c	89 84 24 84 05
	00 00		 mov	 DWORD PTR tv940[rsp], eax
  01f63	8b 84 24 84 05
	00 00		 mov	 eax, DWORD PTR tv940[rsp]
  01f6a	2d 18 20 22 00	 sub	 eax, 2236440		; 00222018H
  01f6f	89 84 24 84 05
	00 00		 mov	 DWORD PTR tv940[rsp], eax
  01f76	83 bc 24 84 05
	00 00 54	 cmp	 DWORD PTR tv940[rsp], 84 ; 00000054H
  01f7e	77 24		 ja	 SHORT $LN1@ProcessMai
  01f80	8b 84 24 84 05
	00 00		 mov	 eax, DWORD PTR tv940[rsp]
  01f87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  01f8e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN170@ProcessMai[rcx+rax]
  01f96	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN171@ProcessMai[rcx+rax*4]
  01f9d	48 03 c1	 add	 rax, rcx
  01fa0	ff e0		 jmp	 rax
$LN2@ProcessMai:

; 1646 : 		{
; 1647 : 		case GST_IOCTL_GET_MOUNTED_VOLUMES:
; 1648 : 		case GST_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1649 : 		case GST_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1650 : 		case GST_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1651 : 		case GST_IOCTL_OPEN_TEST:
; 1652 : 		case GST_IOCTL_GET_RESOLVED_SYMLINK:
; 1653 : 		case GST_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1654 : 		case GST_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1655 : 		case GST_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1656 : 		case GST_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1657 : 			break;

  01fa2	eb 17		 jmp	 SHORT $LN3@ProcessMai
$LN1@ProcessMai:

; 1658 : 
; 1659 : 		default:
; 1660 : 			Dump ("IOCTL error 0x%08x\n", Irp->IoStatus.Status);

  01fa4	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01fac	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  01faf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@
  01fb6	e8 00 00 00 00	 call	 DbgPrint
$LN3@ProcessMai:
$LN5@ProcessMai:

; 1661 : 		}
; 1662 : 	}
; 1663 : #endif
; 1664 : 
; 1665 : 	return GSTCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  01fbb	4c 8b 84 24 c0
	05 00 00	 mov	 r8, QWORD PTR Irp$[rsp]
  01fc3	4d 8b 40 38	 mov	 r8, QWORD PTR [r8+56]
  01fc7	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01fcf	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  01fd2	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01fda	e8 00 00 00 00	 call	 GSTCompleteIrp
$LN151@ProcessMai:

; 1666 : }

  01fdf	48 8b 8c 24 88
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01fe7	48 33 cc	 xor	 rcx, rsp
  01fea	e8 00 00 00 00	 call	 __security_check_cookie
  01fef	48 81 c4 98 05
	00 00		 add	 rsp, 1432		; 00000598H
  01ff6	5f		 pop	 rdi
  01ff7	5e		 pop	 rsi
  01ff8	c3		 ret	 0
  01ff9	0f 1f 00	 npad	 3
$LN173@ProcessMai:
  01ffc	00 00 00 00	 DD	 $LN26@ProcessMai
  02000	00 00 00 00	 DD	 $LN51@ProcessMai
  02004	00 00 00 00	 DD	 $LN37@ProcessMai
  02008	00 00 00 00	 DD	 $LN33@ProcessMai
  0200c	00 00 00 00	 DD	 $LN92@ProcessMai
  02010	00 00 00 00	 DD	 $LN77@ProcessMai
  02014	00 00 00 00	 DD	 $LN146@ProcessMai
  02018	00 00 00 00	 DD	 $LN144@ProcessMai
  0201c	00 00 00 00	 DD	 $LN141@ProcessMai
  02020	00 00 00 00	 DD	 $LN97@ProcessMai
  02024	00 00 00 00	 DD	 $LN98@ProcessMai
  02028	00 00 00 00	 DD	 $LN134@ProcessMai
  0202c	00 00 00 00	 DD	 $LN69@ProcessMai
  02030	00 00 00 00	 DD	 $LN60@ProcessMai
  02034	00 00 00 00	 DD	 $LN58@ProcessMai
  02038	00 00 00 00	 DD	 $LN71@ProcessMai
  0203c	00 00 00 00	 DD	 $LN29@ProcessMai
  02040	00 00 00 00	 DD	 $LN31@ProcessMai
  02044	00 00 00 00	 DD	 $LN30@ProcessMai
  02048	00 00 00 00	 DD	 $LN28@ProcessMai
  0204c	00 00 00 00	 DD	 $LN27@ProcessMai
  02050	00 00 00 00	 DD	 $LN25@ProcessMai
  02054	00 00 00 00	 DD	 $LN24@ProcessMai
  02058	00 00 00 00	 DD	 $LN93@ProcessMai
  0205c	00 00 00 00	 DD	 $LN96@ProcessMai
  02060	00 00 00 00	 DD	 $LN23@ProcessMai
  02064	00 00 00 00	 DD	 $LN114@ProcessMai
  02068	00 00 00 00	 DD	 $LN21@ProcessMai
  0206c	00 00 00 00	 DD	 $LN20@ProcessMai
  02070	00 00 00 00	 DD	 $LN18@ProcessMai
  02074	00 00 00 00	 DD	 $LN19@ProcessMai
  02078	00 00 00 00	 DD	 $LN17@ProcessMai
  0207c	00 00 00 00	 DD	 $LN16@ProcessMai
  02080	00 00 00 00	 DD	 $LN14@ProcessMai
  02084	00 00 00 00	 DD	 $LN11@ProcessMai
  02088	00 00 00 00	 DD	 $LN10@ProcessMai
  0208c	00 00 00 00	 DD	 $LN6@ProcessMai
$LN172@ProcessMai:
  02090	00		 DB	 0
  02091	24		 DB	 36			; 00000024H
  02092	24		 DB	 36			; 00000024H
  02093	24		 DB	 36			; 00000024H
  02094	01		 DB	 1
  02095	24		 DB	 36			; 00000024H
  02096	24		 DB	 36			; 00000024H
  02097	24		 DB	 36			; 00000024H
  02098	02		 DB	 2
  02099	24		 DB	 36			; 00000024H
  0209a	24		 DB	 36			; 00000024H
  0209b	24		 DB	 36			; 00000024H
  0209c	03		 DB	 3
  0209d	24		 DB	 36			; 00000024H
  0209e	24		 DB	 36			; 00000024H
  0209f	24		 DB	 36			; 00000024H
  020a0	04		 DB	 4
  020a1	24		 DB	 36			; 00000024H
  020a2	24		 DB	 36			; 00000024H
  020a3	24		 DB	 36			; 00000024H
  020a4	05		 DB	 5
  020a5	24		 DB	 36			; 00000024H
  020a6	24		 DB	 36			; 00000024H
  020a7	24		 DB	 36			; 00000024H
  020a8	06		 DB	 6
  020a9	24		 DB	 36			; 00000024H
  020aa	24		 DB	 36			; 00000024H
  020ab	24		 DB	 36			; 00000024H
  020ac	07		 DB	 7
  020ad	24		 DB	 36			; 00000024H
  020ae	24		 DB	 36			; 00000024H
  020af	24		 DB	 36			; 00000024H
  020b0	08		 DB	 8
  020b1	24		 DB	 36			; 00000024H
  020b2	24		 DB	 36			; 00000024H
  020b3	24		 DB	 36			; 00000024H
  020b4	09		 DB	 9
  020b5	24		 DB	 36			; 00000024H
  020b6	24		 DB	 36			; 00000024H
  020b7	24		 DB	 36			; 00000024H
  020b8	0a		 DB	 10
  020b9	24		 DB	 36			; 00000024H
  020ba	24		 DB	 36			; 00000024H
  020bb	24		 DB	 36			; 00000024H
  020bc	0b		 DB	 11
  020bd	24		 DB	 36			; 00000024H
  020be	24		 DB	 36			; 00000024H
  020bf	24		 DB	 36			; 00000024H
  020c0	0c		 DB	 12
  020c1	24		 DB	 36			; 00000024H
  020c2	24		 DB	 36			; 00000024H
  020c3	24		 DB	 36			; 00000024H
  020c4	0d		 DB	 13
  020c5	24		 DB	 36			; 00000024H
  020c6	24		 DB	 36			; 00000024H
  020c7	24		 DB	 36			; 00000024H
  020c8	0e		 DB	 14
  020c9	24		 DB	 36			; 00000024H
  020ca	24		 DB	 36			; 00000024H
  020cb	24		 DB	 36			; 00000024H
  020cc	0f		 DB	 15
  020cd	24		 DB	 36			; 00000024H
  020ce	24		 DB	 36			; 00000024H
  020cf	24		 DB	 36			; 00000024H
  020d0	10		 DB	 16
  020d1	24		 DB	 36			; 00000024H
  020d2	24		 DB	 36			; 00000024H
  020d3	24		 DB	 36			; 00000024H
  020d4	11		 DB	 17
  020d5	24		 DB	 36			; 00000024H
  020d6	24		 DB	 36			; 00000024H
  020d7	24		 DB	 36			; 00000024H
  020d8	12		 DB	 18
  020d9	24		 DB	 36			; 00000024H
  020da	24		 DB	 36			; 00000024H
  020db	24		 DB	 36			; 00000024H
  020dc	13		 DB	 19
  020dd	24		 DB	 36			; 00000024H
  020de	24		 DB	 36			; 00000024H
  020df	24		 DB	 36			; 00000024H
  020e0	14		 DB	 20
  020e1	24		 DB	 36			; 00000024H
  020e2	24		 DB	 36			; 00000024H
  020e3	24		 DB	 36			; 00000024H
  020e4	15		 DB	 21
  020e5	24		 DB	 36			; 00000024H
  020e6	24		 DB	 36			; 00000024H
  020e7	24		 DB	 36			; 00000024H
  020e8	16		 DB	 22
  020e9	24		 DB	 36			; 00000024H
  020ea	24		 DB	 36			; 00000024H
  020eb	24		 DB	 36			; 00000024H
  020ec	17		 DB	 23
  020ed	24		 DB	 36			; 00000024H
  020ee	24		 DB	 36			; 00000024H
  020ef	24		 DB	 36			; 00000024H
  020f0	18		 DB	 24
  020f1	24		 DB	 36			; 00000024H
  020f2	24		 DB	 36			; 00000024H
  020f3	24		 DB	 36			; 00000024H
  020f4	19		 DB	 25
  020f5	24		 DB	 36			; 00000024H
  020f6	24		 DB	 36			; 00000024H
  020f7	24		 DB	 36			; 00000024H
  020f8	1a		 DB	 26
  020f9	24		 DB	 36			; 00000024H
  020fa	24		 DB	 36			; 00000024H
  020fb	24		 DB	 36			; 00000024H
  020fc	24		 DB	 36			; 00000024H
  020fd	24		 DB	 36			; 00000024H
  020fe	24		 DB	 36			; 00000024H
  020ff	24		 DB	 36			; 00000024H
  02100	1b		 DB	 27
  02101	24		 DB	 36			; 00000024H
  02102	24		 DB	 36			; 00000024H
  02103	24		 DB	 36			; 00000024H
  02104	1c		 DB	 28
  02105	24		 DB	 36			; 00000024H
  02106	24		 DB	 36			; 00000024H
  02107	24		 DB	 36			; 00000024H
  02108	1d		 DB	 29
  02109	24		 DB	 36			; 00000024H
  0210a	24		 DB	 36			; 00000024H
  0210b	24		 DB	 36			; 00000024H
  0210c	1e		 DB	 30
  0210d	24		 DB	 36			; 00000024H
  0210e	24		 DB	 36			; 00000024H
  0210f	24		 DB	 36			; 00000024H
  02110	1f		 DB	 31
  02111	24		 DB	 36			; 00000024H
  02112	24		 DB	 36			; 00000024H
  02113	24		 DB	 36			; 00000024H
  02114	20		 DB	 32			; 00000020H
  02115	24		 DB	 36			; 00000024H
  02116	24		 DB	 36			; 00000024H
  02117	24		 DB	 36			; 00000024H
  02118	21		 DB	 33			; 00000021H
  02119	24		 DB	 36			; 00000024H
  0211a	24		 DB	 36			; 00000024H
  0211b	24		 DB	 36			; 00000024H
  0211c	22		 DB	 34			; 00000022H
  0211d	24		 DB	 36			; 00000024H
  0211e	24		 DB	 36			; 00000024H
  0211f	24		 DB	 36			; 00000024H
  02120	23		 DB	 35			; 00000023H
  02121	0f 1f 00	 npad	 3
$LN171@ProcessMai:
  02124	00 00 00 00	 DD	 $LN2@ProcessMai
  02128	00 00 00 00	 DD	 $LN1@ProcessMai
$LN170@ProcessMai:
  0212c	00		 DB	 0
  0212d	01		 DB	 1
  0212e	01		 DB	 1
  0212f	01		 DB	 1
  02130	01		 DB	 1
  02131	01		 DB	 1
  02132	01		 DB	 1
  02133	01		 DB	 1
  02134	01		 DB	 1
  02135	01		 DB	 1
  02136	01		 DB	 1
  02137	01		 DB	 1
  02138	01		 DB	 1
  02139	01		 DB	 1
  0213a	01		 DB	 1
  0213b	01		 DB	 1
  0213c	01		 DB	 1
  0213d	01		 DB	 1
  0213e	01		 DB	 1
  0213f	01		 DB	 1
  02140	00		 DB	 0
  02141	01		 DB	 1
  02142	01		 DB	 1
  02143	01		 DB	 1
  02144	01		 DB	 1
  02145	01		 DB	 1
  02146	01		 DB	 1
  02147	01		 DB	 1
  02148	00		 DB	 0
  02149	01		 DB	 1
  0214a	01		 DB	 1
  0214b	01		 DB	 1
  0214c	00		 DB	 0
  0214d	01		 DB	 1
  0214e	01		 DB	 1
  0214f	01		 DB	 1
  02150	01		 DB	 1
  02151	01		 DB	 1
  02152	01		 DB	 1
  02153	01		 DB	 1
  02154	01		 DB	 1
  02155	01		 DB	 1
  02156	01		 DB	 1
  02157	01		 DB	 1
  02158	00		 DB	 0
  02159	01		 DB	 1
  0215a	01		 DB	 1
  0215b	01		 DB	 1
  0215c	00		 DB	 0
  0215d	01		 DB	 1
  0215e	01		 DB	 1
  0215f	01		 DB	 1
  02160	01		 DB	 1
  02161	01		 DB	 1
  02162	01		 DB	 1
  02163	01		 DB	 1
  02164	01		 DB	 1
  02165	01		 DB	 1
  02166	01		 DB	 1
  02167	01		 DB	 1
  02168	01		 DB	 1
  02169	01		 DB	 1
  0216a	01		 DB	 1
  0216b	01		 DB	 1
  0216c	00		 DB	 0
  0216d	01		 DB	 1
  0216e	01		 DB	 1
  0216f	01		 DB	 1
  02170	01		 DB	 1
  02171	01		 DB	 1
  02172	01		 DB	 1
  02173	01		 DB	 1
  02174	01		 DB	 1
  02175	01		 DB	 1
  02176	01		 DB	 1
  02177	01		 DB	 1
  02178	00		 DB	 0
  02179	01		 DB	 1
  0217a	01		 DB	 1
  0217b	01		 DB	 1
  0217c	00		 DB	 0
  0217d	01		 DB	 1
  0217e	01		 DB	 1
  0217f	01		 DB	 1
  02180	00		 DB	 0
ProcessMainDeviceControlIrp ENDP
PUBLIC	GSTDispatchQueueIRP
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTDispatchQueueIRP DD imagerel $LN43
	DD	imagerel $LN43+1516
	DD	imagerel $unwind$GSTDispatchQueueIRP
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTDispatchQueueIRP DD 031001H
	DD	0700cc210H
	DD	0300bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GSTDispatchQueueIRP
_TEXT	SEGMENT
Extension$ = 48
ntStatus$ = 56
irpSp$ = 64
status$30430 = 72
tv73 = 76
tv135 = 80
tv210 = 84
DeviceObject$ = 128
Irp$ = 136
GSTDispatchQueueIRP PROC				; COMDAT

; 265  : {

$LN43:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 266  : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  00010	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00018	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0001c	48 89 44 24 30	 mov	 QWORD PTR Extension$[rsp], rax

; 267  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00021	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00029	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  0002e	48 89 44 24 40	 mov	 QWORD PTR irpSp$[rsp], rax

; 268  : 	NTSTATUS ntStatus;
; 269  : 
; 270  : #ifdef _DEBUG
; 271  : 	if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL && (Extension->bRootDevice || Extension->IsVolumeDevice))

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00038	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003b	83 f8 0e	 cmp	 eax, 14
  0003e	0f 85 b8 00 00
	00		 jne	 $LN35@GSTDispatc
  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00049	83 38 00	 cmp	 DWORD PTR [rax], 0
  0004c	75 0f		 jne	 SHORT $LN34@GSTDispatc
  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00053	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00057	0f 84 9f 00 00
	00		 je	 $LN35@GSTDispatc
$LN34@GSTDispatc:

; 272  : 	{
; 273  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00062	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00065	89 44 24 4c	 mov	 DWORD PTR tv73[rsp], eax
  00069	81 7c 24 4c 18
	20 22 00	 cmp	 DWORD PTR tv73[rsp], 2236440 ; 00222018H
  00071	77 16		 ja	 SHORT $LN38@GSTDispatc
  00073	81 7c 24 4c 18
	20 22 00	 cmp	 DWORD PTR tv73[rsp], 2236440 ; 00222018H
  0007b	74 3f		 je	 SHORT $LN31@GSTDispatc
  0007d	81 7c 24 4c 00
	48 07 00	 cmp	 DWORD PTR tv73[rsp], 477184 ; 00074800H
  00085	74 35		 je	 SHORT $LN31@GSTDispatc
  00087	eb 35		 jmp	 SHORT $LN30@GSTDispatc
$LN38@GSTDispatc:
  00089	8b 44 24 4c	 mov	 eax, DWORD PTR tv73[rsp]
  0008d	2d 20 20 22 00	 sub	 eax, 2236448		; 00222020H
  00092	89 44 24 4c	 mov	 DWORD PTR tv73[rsp], eax
  00096	83 7c 24 4c 6c	 cmp	 DWORD PTR tv73[rsp], 108 ; 0000006cH
  0009b	77 21		 ja	 SHORT $LN30@GSTDispatc
  0009d	8b 44 24 4c	 mov	 eax, DWORD PTR tv73[rsp]
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a8	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN41@GSTDispatc[rcx+rax]
  000b0	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN42@GSTDispatc[rcx+rax*4]
  000b7	48 03 c1	 add	 rax, rcx
  000ba	ff e0		 jmp	 rax
$LN31@GSTDispatc:

; 274  : 		{
; 275  : 		case GST_IOCTL_GET_MOUNTED_VOLUMES:
; 276  : 		case GST_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 277  : 		case GST_IOCTL_GET_PORTABLE_MODE_STATUS:
; 278  : 		case GST_IOCTL_SET_PORTABLE_MODE_STATUS:
; 279  : 		case GST_IOCTL_OPEN_TEST:
; 280  : 		case GST_IOCTL_GET_RESOLVED_SYMLINK:
; 281  : 		case GST_IOCTL_GET_DEVICE_REFCOUNT:
; 282  : 		case GST_IOCTL_GET_DRIVE_PARTITION_INFO:
; 283  : 		case GST_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 284  : 		case GST_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 285  : 		case GST_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 286  : 		case GST_IOCTL_GET_WARNING_FLAGS:
; 287  : 		case GST_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 288  : 		case IOCTL_DISK_CHECK_VERIFY:
; 289  : 			break;

  000bc	eb 3e		 jmp	 SHORT $LN32@GSTDispatc
$LN30@GSTDispatc:

; 290  : 
; 291  : 		default:
; 292  : 			Dump ("%ls (0x%x %d)\n",
; 293  : 				GSTTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode),
; 294  : 				(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 295  : 				(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));

  000be	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  000c3	8b 78 18	 mov	 edi, DWORD PTR [rax+24]
  000c6	81 e7 ff 1f 00
	00		 and	 edi, 8191		; 00001fffH
  000cc	c1 ef 02	 shr	 edi, 2
  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  000d4	8b 58 18	 mov	 ebx, DWORD PTR [rax+24]
  000d7	c1 eb 10	 shr	 ebx, 16
  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  000df	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000e2	e8 00 00 00 00	 call	 GSTTranslateCode
  000e7	44 8b cf	 mov	 r9d, edi
  000ea	44 8b c3	 mov	 r8d, ebx
  000ed	48 8b d0	 mov	 rdx, rax
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
  000f7	e8 00 00 00 00	 call	 DbgPrint
$LN32@GSTDispatc:
$LN35@GSTDispatc:

; 296  : 		}
; 297  : 	}
; 298  : #endif
; 299  : 
; 300  : 	if (!Extension->bRootDevice)

  000fc	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00101	83 38 00	 cmp	 DWORD PTR [rax], 0
  00104	75 4a		 jne	 SHORT $LN29@GSTDispatc

; 301  : 	{
; 302  : 		// Drive filter IRP
; 303  : 		if (Extension->IsDriveFilterDevice)

  00106	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  0010b	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0010f	74 1a		 je	 SHORT $LN28@GSTDispatc

; 304  : 			return DriveFilterDispatchIrp (DeviceObject, Irp);

  00111	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00119	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00121	e8 00 00 00 00	 call	 DriveFilterDispatchIrp
  00126	e9 10 04 00 00	 jmp	 $LN36@GSTDispatc
$LN28@GSTDispatc:

; 305  : 
; 306  : 		// Volume filter IRP
; 307  : 		if (Extension->IsVolumeFilterDevice)

  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00130	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  00134	74 1a		 je	 SHORT $LN27@GSTDispatc

; 308  : 			return VolumeFilterDispatchIrp (DeviceObject, Irp);

  00136	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  0013e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00146	e8 00 00 00 00	 call	 VolumeFilterDispatchIrp
  0014b	e9 eb 03 00 00	 jmp	 $LN36@GSTDispatc
$LN27@GSTDispatc:
$LN29@GSTDispatc:

; 309  : 	}
; 310  : 
; 311  : 	switch (irpSp->MajorFunction)

  00150	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00155	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00158	89 44 24 50	 mov	 DWORD PTR tv135[rsp], eax
  0015c	83 7c 24 50 1b	 cmp	 DWORD PTR tv135[rsp], 27
  00161	0f 87 bf 03 00
	00		 ja	 $LN25@GSTDispatc
  00167	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv135[rsp]
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00173	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN39@GSTDispatc[rcx+rax]
  0017b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN40@GSTDispatc[rcx+rax*4]
  00182	48 03 c1	 add	 rax, rcx
  00185	ff e0		 jmp	 rax
$LN24@GSTDispatc:

; 312  : 	{
; 313  : 	case IRP_MJ_CLOSE:
; 314  : 	case IRP_MJ_CREATE:
; 315  : 	case IRP_MJ_CLEANUP:
; 316  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  00187	45 33 c9	 xor	 r9d, r9d
  0018a	45 33 c0	 xor	 r8d, r8d
  0018d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00195	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  0019d	e8 00 00 00 00	 call	 COMPLETE_IRP
  001a2	e9 94 03 00 00	 jmp	 $LN36@GSTDispatc
$LN23@GSTDispatc:

; 317  : 
; 318  : 	case IRP_MJ_SHUTDOWN:
; 319  : 		if (Extension->bRootDevice)

  001a7	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  001ac	83 38 00	 cmp	 DWORD PTR [rax], 0
  001af	0f 84 91 00 00
	00		 je	 $LN22@GSTDispatc

; 320  : 		{
; 321  : 			Dump ("Driver shutting down\n");

  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@
  001bc	e8 00 00 00 00	 call	 DbgPrint

; 322  : 			DriverShuttingDown = TRUE;

  001c1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DriverShuttingDown, 1

; 323  : 
; 324  : 			if (EncryptionSetupThread)

  001cb	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR EncryptionSetupThread, 0
  001d3	74 31		 je	 SHORT $LN21@GSTDispatc
$LN20@GSTDispatc:

; 325  : 				while (SendDeviceIoControlRequest (RootDeviceObject, GST_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  001d5	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  001dd	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001e6	45 33 c9	 xor	 r9d, r9d
  001e9	45 33 c0	 xor	 r8d, r8d
  001ec	ba 50 20 22 00	 mov	 edx, 2236496		; 00222050H
  001f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  001f8	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  001fd	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  00202	75 02		 jne	 SHORT $LN19@GSTDispatc
  00204	eb cf		 jmp	 SHORT $LN20@GSTDispatc
$LN19@GSTDispatc:
$LN21@GSTDispatc:

; 326  : 
; 327  : 			if (DecoySystemWipeThread)

  00206	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR DecoySystemWipeThread, 0
  0020e	74 31		 je	 SHORT $LN18@GSTDispatc
$LN17@GSTDispatc:

; 328  : 				while (SendDeviceIoControlRequest (RootDeviceObject, GST_IOCTL_ABORT_DECOY_SYSTEM_WIPE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00210	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00218	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00221	45 33 c9	 xor	 r9d, r9d
  00224	45 33 c0	 xor	 r8d, r8d
  00227	ba 7c 20 22 00	 mov	 edx, 2236540		; 0022207cH
  0022c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00233	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00238	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  0023d	75 02		 jne	 SHORT $LN16@GSTDispatc
  0023f	eb cf		 jmp	 SHORT $LN17@GSTDispatc
$LN16@GSTDispatc:
$LN18@GSTDispatc:

; 329  : 
; 330  : 			OnShutdownPending();

  00241	e8 00 00 00 00	 call	 OnShutdownPending
$LN22@GSTDispatc:

; 331  : 		}
; 332  : 
; 333  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  00246	45 33 c9	 xor	 r9d, r9d
  00249	45 33 c0	 xor	 r8d, r8d
  0024c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00254	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  0025c	e8 00 00 00 00	 call	 COMPLETE_IRP
  00261	e9 d5 02 00 00	 jmp	 $LN36@GSTDispatc
$LN15@GSTDispatc:

; 334  : 
; 335  : 	case IRP_MJ_FLUSH_BUFFERS:
; 336  : 	case IRP_MJ_READ:
; 337  : 	case IRP_MJ_WRITE:
; 338  : 	case IRP_MJ_DEVICE_CONTROL:
; 339  : 
; 340  : 		if (Extension->bRootDevice)

  00266	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  0026b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0026e	74 7a		 je	 SHORT $LN14@GSTDispatc

; 341  : 		{
; 342  : 			if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)

  00270	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00275	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00278	83 f8 0e	 cmp	 eax, 14
  0027b	75 68		 jne	 SHORT $LN13@GSTDispatc

; 343  : 			{
; 344  : 				NTSTATUS status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, NULL);

  0027d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00286	45 33 c9	 xor	 r9d, r9d
  00289	45 33 c0	 xor	 r8d, r8d
  0028c	33 d2		 xor	 edx, edx
  0028e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0029b	89 44 24 48	 mov	 DWORD PTR status$30430[rsp], eax

; 345  : 				if (!NT_SUCCESS (status))

  0029f	83 7c 24 48 00	 cmp	 DWORD PTR status$30430[rsp], 0
  002a4	7d 09		 jge	 SHORT $LN12@GSTDispatc

; 346  : 					return status;

  002a6	8b 44 24 48	 mov	 eax, DWORD PTR status$30430[rsp]
  002aa	e9 8c 02 00 00	 jmp	 $LN36@GSTDispatc
$LN12@GSTDispatc:

; 347  : 
; 348  : 				status = ProcessMainDeviceControlIrp (DeviceObject, Extension, Irp);

  002af	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR Irp$[rsp]
  002b7	48 8b 54 24 30	 mov	 rdx, QWORD PTR Extension$[rsp]
  002bc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  002c4	e8 00 00 00 00	 call	 ProcessMainDeviceControlIrp
  002c9	89 44 24 48	 mov	 DWORD PTR status$30430[rsp], eax

; 349  : 
; 350  : 				KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  002cd	33 d2		 xor	 edx, edx
  002cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  002d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex

; 351  : 				return status;

  002dc	8b 44 24 48	 mov	 eax, DWORD PTR status$30430[rsp]
  002e0	e9 56 02 00 00	 jmp	 $LN36@GSTDispatc
$LN13@GSTDispatc:

; 352  : 			}
; 353  : 			break;

  002e5	e9 3c 02 00 00	 jmp	 $LN25@GSTDispatc
$LN14@GSTDispatc:

; 354  : 		}
; 355  : 
; 356  : 		if (Extension->bShuttingDown)

  002ea	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  002ef	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  002f3	74 2e		 je	 SHORT $LN11@GSTDispatc

; 357  : 		{
; 358  : 			Dump ("Device %d shutting down: STATUS_DELETE_PENDING\n", Extension->nDosDriveNo);

  002f5	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  002fa	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@
  00304	e8 00 00 00 00	 call	 DbgPrint

; 359  : 			return GSTCompleteDiskIrp (Irp, STATUS_DELETE_PENDING, 0);

  00309	45 33 c0	 xor	 r8d, r8d
  0030c	ba 56 00 00 c0	 mov	 edx, -1073741738	; ffffffffc0000056H
  00311	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00319	e8 00 00 00 00	 call	 GSTCompleteDiskIrp
  0031e	e9 18 02 00 00	 jmp	 $LN36@GSTDispatc
$LN11@GSTDispatc:

; 360  : 		}
; 361  : 
; 362  : 		if (Extension->bRemovable
; 363  : 			&& (DeviceObject->Flags & DO_VERIFY_VOLUME)
; 364  : 			&& !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)
; 365  : 			&& irpSp->MajorFunction != IRP_MJ_FLUSH_BUFFERS)

  00323	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00328	83 b8 9c 03 00
	00 00		 cmp	 DWORD PTR [rax+924], 0
  0032f	74 5d		 je	 SHORT $LN10@GSTDispatc
  00331	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00339	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0033c	83 e0 02	 and	 eax, 2
  0033f	85 c0		 test	 eax, eax
  00341	74 4b		 je	 SHORT $LN10@GSTDispatc
  00343	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00348	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0034c	83 e0 02	 and	 eax, 2
  0034f	85 c0		 test	 eax, eax
  00351	75 3b		 jne	 SHORT $LN10@GSTDispatc
  00353	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00358	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0035b	83 f8 09	 cmp	 eax, 9
  0035e	74 2e		 je	 SHORT $LN10@GSTDispatc

; 366  : 		{
; 367  : 			Dump ("Removable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_NOT_READY\n", Extension->nDosDriveNo);

  00360	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00365	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00368	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@
  0036f	e8 00 00 00 00	 call	 DbgPrint

; 368  : 			return GSTCompleteDiskIrp (Irp, STATUS_DEVICE_NOT_READY, 0);

  00374	45 33 c0	 xor	 r8d, r8d
  00377	ba a3 00 00 c0	 mov	 edx, -1073741661	; ffffffffc00000a3H
  0037c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00384	e8 00 00 00 00	 call	 GSTCompleteDiskIrp
  00389	e9 ad 01 00 00	 jmp	 $LN36@GSTDispatc
$LN10@GSTDispatc:

; 369  : 		}
; 370  : 
; 371  : 		switch (irpSp->MajorFunction)

  0038e	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00393	8a 00		 mov	 al, BYTE PTR [rax]
  00395	88 44 24 54	 mov	 BYTE PTR tv210[rsp], al
  00399	80 7c 24 54 03	 cmp	 BYTE PTR tv210[rsp], 3
  0039e	0f 82 24 01 00
	00		 jb	 $LN8@GSTDispatc
  003a4	80 7c 24 54 04	 cmp	 BYTE PTR tv210[rsp], 4
  003a9	76 17		 jbe	 SHORT $LN7@GSTDispatc
  003ab	80 7c 24 54 09	 cmp	 BYTE PTR tv210[rsp], 9
  003b0	0f 84 fe 00 00
	00		 je	 $LN3@GSTDispatc
  003b6	80 7c 24 54 0e	 cmp	 BYTE PTR tv210[rsp], 14
  003bb	74 49		 je	 SHORT $LN5@GSTDispatc
  003bd	e9 06 01 00 00	 jmp	 $LN8@GSTDispatc
$LN7@GSTDispatc:

; 372  : 		{
; 373  : 		case IRP_MJ_READ:
; 374  : 		case IRP_MJ_WRITE:
; 375  : 			ntStatus = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);

  003c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  003c7	48 81 c1 e0 00
	00 00		 add	 rcx, 224		; 000000e0H
  003ce	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  003d6	e8 00 00 00 00	 call	 EncryptedIoQueueAddIrp
  003db	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax

; 376  : 
; 377  : 			if (ntStatus != STATUS_PENDING)

  003df	81 7c 24 38 03
	01 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 259 ; 00000103H
  003e7	74 14		 je	 SHORT $LN6@GSTDispatc

; 378  : 				GSTCompleteDiskIrp (Irp, ntStatus, 0);

  003e9	45 33 c0	 xor	 r8d, r8d
  003ec	8b 54 24 38	 mov	 edx, DWORD PTR ntStatus$[rsp]
  003f0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  003f8	e8 00 00 00 00	 call	 GSTCompleteDiskIrp
$LN6@GSTDispatc:

; 379  : 
; 380  : 			return ntStatus;

  003fd	8b 44 24 38	 mov	 eax, DWORD PTR ntStatus$[rsp]
  00401	e9 35 01 00 00	 jmp	 $LN36@GSTDispatc
$LN5@GSTDispatc:

; 381  : 
; 382  : 		case IRP_MJ_DEVICE_CONTROL:
; 383  : 			ntStatus = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00406	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  0040b	48 81 c1 80 01
	00 00		 add	 rcx, 384		; 00000180H
  00412	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  0041a	41 b9 7f 01 00
	00		 mov	 r9d, 383		; 0000017fH
  00420	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0JF@EIKLNJII@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  00427	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  0042f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00435	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax

; 384  : 			if (!NT_SUCCESS (ntStatus))

  00439	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0043e	7d 19		 jge	 SHORT $LN4@GSTDispatc

; 385  : 				return GSTCompleteIrp (Irp, ntStatus, 0);

  00440	45 33 c0	 xor	 r8d, r8d
  00443	8b 54 24 38	 mov	 edx, DWORD PTR ntStatus$[rsp]
  00447	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0044f	e8 00 00 00 00	 call	 GSTCompleteIrp
  00454	e9 e2 00 00 00	 jmp	 $LN36@GSTDispatc
$LN4@GSTDispatc:

; 386  : 
; 387  : 			IoMarkIrpPending (Irp);

  00459	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00461	e8 00 00 00 00	 call	 IoMarkIrpPending

; 388  : 			
; 389  : 			ExInterlockedInsertTailList (&Extension->ListEntry, &Irp->Tail.Overlay.ListEntry, &Extension->ListSpinLock);

  00466	4c 8b 44 24 30	 mov	 r8, QWORD PTR Extension$[rsp]
  0046b	49 83 c0 40	 add	 r8, 64			; 00000040H
  0046f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00477	48 81 c2 a8 00
	00 00		 add	 rdx, 168		; 000000a8H
  0047e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  00483	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00487	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedInsertTailList

; 390  : 			KeReleaseSemaphore (&Extension->RequestSemaphore, IO_DISK_INCREMENT, 1, FALSE);

  0048d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  00492	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00496	45 33 c9	 xor	 r9d, r9d
  00499	41 b8 01 00 00
	00		 mov	 r8d, 1
  0049f	ba 01 00 00 00	 mov	 edx, 1
  004a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSemaphore

; 391  : 			
; 392  : 			return STATUS_PENDING;

  004aa	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  004af	e9 87 00 00 00	 jmp	 $LN36@GSTDispatc
$LN3@GSTDispatc:

; 393  : 
; 394  : 		case IRP_MJ_FLUSH_BUFFERS:
; 395  : 			return GSTCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  004b4	45 33 c0	 xor	 r8d, r8d
  004b7	33 d2		 xor	 edx, edx
  004b9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  004c1	e8 00 00 00 00	 call	 GSTCompleteDiskIrp
  004c6	eb 73		 jmp	 SHORT $LN36@GSTDispatc
$LN8@GSTDispatc:

; 396  : 		}
; 397  : 
; 398  : 		break;

  004c8	eb 5c		 jmp	 SHORT $LN25@GSTDispatc
$LN2@GSTDispatc:

; 399  : 
; 400  : 	case IRP_MJ_PNP:
; 401  : 		if (!Extension->bRootDevice
; 402  : 			&& Extension->IsVolumeDevice
; 403  : 			&& irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION
; 404  : 			&& irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
; 405  : 			&& irpSp->Parameters.UsageNotification.InPath)

  004ca	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  004cf	83 38 00	 cmp	 DWORD PTR [rax], 0
  004d2	75 52		 jne	 SHORT $LN1@GSTDispatc
  004d4	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  004d9	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  004dd	74 47		 je	 SHORT $LN1@GSTDispatc
  004df	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  004e4	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  004e8	83 f8 16	 cmp	 eax, 22
  004eb	75 39		 jne	 SHORT $LN1@GSTDispatc
  004ed	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  004f2	83 78 10 01	 cmp	 DWORD PTR [rax+16], 1
  004f6	75 2e		 jne	 SHORT $LN1@GSTDispatc
  004f8	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  004fd	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00501	85 c0		 test	 eax, eax
  00503	74 21		 je	 SHORT $LN1@GSTDispatc

; 406  : 		{
; 407  : 			PagingFileCreationPrevented = TRUE;

  00505	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR PagingFileCreationPrevented, 1

; 408  : 			return GSTCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);

  0050f	45 33 c0	 xor	 r8d, r8d
  00512	ba 01 00 00 c0	 mov	 edx, -1073741823	; ffffffffc0000001H
  00517	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0051f	e8 00 00 00 00	 call	 GSTCompleteIrp
  00524	eb 15		 jmp	 SHORT $LN36@GSTDispatc
$LN1@GSTDispatc:
$LN25@GSTDispatc:

; 409  : 		}
; 410  : 		break;
; 411  : 	}
; 412  : 
; 413  : 	return GSTCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  00526	45 33 c0	 xor	 r8d, r8d
  00529	ba 10 00 00 c0	 mov	 edx, -1073741808	; ffffffffc0000010H
  0052e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00536	e8 00 00 00 00	 call	 GSTCompleteIrp
$LN36@GSTDispatc:

; 414  : }

  0053b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0053f	5f		 pop	 rdi
  00540	5b		 pop	 rbx
  00541	c3		 ret	 0
  00542	66 90		 npad	 2
$LN42@GSTDispatc:
  00544	00 00 00 00	 DD	 $LN31@GSTDispatc
  00548	00 00 00 00	 DD	 $LN30@GSTDispatc
$LN41@GSTDispatc:
  0054c	00		 DB	 0
  0054d	01		 DB	 1
  0054e	01		 DB	 1
  0054f	01		 DB	 1
  00550	01		 DB	 1
  00551	01		 DB	 1
  00552	01		 DB	 1
  00553	01		 DB	 1
  00554	01		 DB	 1
  00555	01		 DB	 1
  00556	01		 DB	 1
  00557	01		 DB	 1
  00558	00		 DB	 0
  00559	01		 DB	 1
  0055a	01		 DB	 1
  0055b	01		 DB	 1
  0055c	01		 DB	 1
  0055d	01		 DB	 1
  0055e	01		 DB	 1
  0055f	01		 DB	 1
  00560	00		 DB	 0
  00561	01		 DB	 1
  00562	01		 DB	 1
  00563	01		 DB	 1
  00564	00		 DB	 0
  00565	01		 DB	 1
  00566	01		 DB	 1
  00567	01		 DB	 1
  00568	01		 DB	 1
  00569	01		 DB	 1
  0056a	01		 DB	 1
  0056b	01		 DB	 1
  0056c	01		 DB	 1
  0056d	01		 DB	 1
  0056e	01		 DB	 1
  0056f	01		 DB	 1
  00570	00		 DB	 0
  00571	01		 DB	 1
  00572	01		 DB	 1
  00573	01		 DB	 1
  00574	00		 DB	 0
  00575	01		 DB	 1
  00576	01		 DB	 1
  00577	01		 DB	 1
  00578	01		 DB	 1
  00579	01		 DB	 1
  0057a	01		 DB	 1
  0057b	01		 DB	 1
  0057c	01		 DB	 1
  0057d	01		 DB	 1
  0057e	01		 DB	 1
  0057f	01		 DB	 1
  00580	01		 DB	 1
  00581	01		 DB	 1
  00582	01		 DB	 1
  00583	01		 DB	 1
  00584	00		 DB	 0
  00585	01		 DB	 1
  00586	01		 DB	 1
  00587	01		 DB	 1
  00588	01		 DB	 1
  00589	01		 DB	 1
  0058a	01		 DB	 1
  0058b	01		 DB	 1
  0058c	01		 DB	 1
  0058d	01		 DB	 1
  0058e	01		 DB	 1
  0058f	01		 DB	 1
  00590	00		 DB	 0
  00591	01		 DB	 1
  00592	01		 DB	 1
  00593	01		 DB	 1
  00594	00		 DB	 0
  00595	01		 DB	 1
  00596	01		 DB	 1
  00597	01		 DB	 1
  00598	00		 DB	 0
  00599	01		 DB	 1
  0059a	01		 DB	 1
  0059b	01		 DB	 1
  0059c	01		 DB	 1
  0059d	01		 DB	 1
  0059e	01		 DB	 1
  0059f	01		 DB	 1
  005a0	01		 DB	 1
  005a1	01		 DB	 1
  005a2	01		 DB	 1
  005a3	01		 DB	 1
  005a4	01		 DB	 1
  005a5	01		 DB	 1
  005a6	01		 DB	 1
  005a7	01		 DB	 1
  005a8	01		 DB	 1
  005a9	01		 DB	 1
  005aa	01		 DB	 1
  005ab	01		 DB	 1
  005ac	00		 DB	 0
  005ad	01		 DB	 1
  005ae	01		 DB	 1
  005af	01		 DB	 1
  005b0	01		 DB	 1
  005b1	01		 DB	 1
  005b2	01		 DB	 1
  005b3	01		 DB	 1
  005b4	01		 DB	 1
  005b5	01		 DB	 1
  005b6	01		 DB	 1
  005b7	01		 DB	 1
  005b8	00		 DB	 0
  005b9	0f 1f 00	 npad	 3
$LN40@GSTDispatc:
  005bc	00 00 00 00	 DD	 $LN24@GSTDispatc
  005c0	00 00 00 00	 DD	 $LN15@GSTDispatc
  005c4	00 00 00 00	 DD	 $LN23@GSTDispatc
  005c8	00 00 00 00	 DD	 $LN2@GSTDispatc
  005cc	00 00 00 00	 DD	 $LN25@GSTDispatc
$LN39@GSTDispatc:
  005d0	00		 DB	 0
  005d1	04		 DB	 4
  005d2	00		 DB	 0
  005d3	01		 DB	 1
  005d4	01		 DB	 1
  005d5	04		 DB	 4
  005d6	04		 DB	 4
  005d7	04		 DB	 4
  005d8	04		 DB	 4
  005d9	01		 DB	 1
  005da	04		 DB	 4
  005db	04		 DB	 4
  005dc	04		 DB	 4
  005dd	04		 DB	 4
  005de	01		 DB	 1
  005df	04		 DB	 4
  005e0	02		 DB	 2
  005e1	04		 DB	 4
  005e2	00		 DB	 0
  005e3	04		 DB	 4
  005e4	04		 DB	 4
  005e5	04		 DB	 4
  005e6	04		 DB	 4
  005e7	04		 DB	 4
  005e8	04		 DB	 4
  005e9	04		 DB	 4
  005ea	04		 DB	 4
  005eb	03		 DB	 3
GSTDispatchQueueIRP ENDP
_TEXT	ENDS
PUBLIC	DriverEntry
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN10
	DD	imagerel $LN10+407
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 020f01H
	DD	0700b920fH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DriverEntry
INIT	SEGMENT
i$ = 48
startKeyValue$ = 56
version$ = 64
DriverObject$ = 96
RegistryPath$ = 104
DriverEntry PROC					; COMDAT

; 81   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 82   : 	PKEY_VALUE_PARTIAL_INFORMATION startKeyValue;
; 83   : 	LONG version;
; 84   : 	int i;
; 85   : 
; 86   : 	Dump ("DriverEntry " GST_APP_NAME " " VERSION_STRING "\n");

  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@IJHBALAF@DriverEntry?5GostCrypt?51?43?41?6?$AA@PBOPGDP@
  00016	e8 00 00 00 00	 call	 DbgPrint

; 87   : 
; 88   : 	PsGetVersion (&OsMajorVersion, &OsMinorVersion, NULL, NULL);

  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	45 33 c0	 xor	 r8d, r8d
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:OsMinorVersion
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:OsMajorVersion
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsGetVersion

; 89   : 
; 90   : 	// Load dump filter if the main driver is already loaded
; 91   : 	if (NT_SUCCESS (GSTDeviceIoControl (NT_ROOT_PREFIX, GST_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version))))

  00035	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  0003d	48 8d 44 24 40	 lea	 rax, QWORD PTR version$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	45 33 c9	 xor	 r9d, r9d
  0004a	45 33 c0	 xor	 r8d, r8d
  0004d	ba 04 20 22 00	 mov	 edx, 2236420		; 00222004H
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  00059	e8 00 00 00 00	 call	 GSTDeviceIoControl
  0005e	85 c0		 test	 eax, eax
  00060	7c 14		 jl	 SHORT $LN7@DriverEntr

; 92   : 		return DumpFilterEntry ((PFILTER_EXTENSION) DriverObject, (PFILTER_INITIALIZATION_DATA) RegistryPath);

  00062	48 8b 54 24 68	 mov	 rdx, QWORD PTR RegistryPath$[rsp]
  00067	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  0006c	e8 00 00 00 00	 call	 DumpFilterEntry
  00071	e9 1b 01 00 00	 jmp	 $LN8@DriverEntr
$LN7@DriverEntr:

; 93   : 
; 94   : 	GSTDriverObject = DriverObject;

  00076	48 8b 44 24 60	 mov	 rax, QWORD PTR DriverObject$[rsp]
  0007b	48 89 05 00 00
	00 00		 mov	 QWORD PTR GSTDriverObject, rax

; 95   : 	memset (VirtualVolumeDeviceObjects, 0, sizeof (VirtualVolumeDeviceObjects));

  00082	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:VirtualVolumeDeviceObjects
  00089	33 c0		 xor	 eax, eax
  0008b	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  00090	f3 aa		 rep stosb

; 96   : 
; 97   : 	ReadRegistryConfigFlags (TRUE);

  00092	b9 01 00 00 00	 mov	 ecx, 1
  00097	e8 00 00 00 00	 call	 ReadRegistryConfigFlags

; 98   : 	EncryptionThreadPoolStart (EncryptionThreadPoolFreeCpuCountLimit);

  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR EncryptionThreadPoolFreeCpuCountLimit
  000a3	e8 00 00 00 00	 call	 EncryptionThreadPoolStart

; 99   : 	SelfTestsPassed = AutoTestAlgorithms();

  000a8	e8 00 00 00 00	 call	 AutoTestAlgorithms
  000ad	89 05 00 00 00
	00		 mov	 DWORD PTR SelfTestsPassed, eax

; 100  : 
; 101  : 	// Enable device class filters and load boot arguments if the driver is set to start at system boot
; 102  : 		
; 103  : 	if (NT_SUCCESS (GSTReadRegistryKey (RegistryPath, L"Start", &startKeyValue)))

  000b3	4c 8d 44 24 38	 lea	 r8, QWORD PTR startKeyValue$[rsp]
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
  000bf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RegistryPath$[rsp]
  000c4	e8 00 00 00 00	 call	 GSTReadRegistryKey
  000c9	85 c0		 test	 eax, eax
  000cb	7c 76		 jl	 SHORT $LN6@DriverEntr

; 104  : 	{
; 105  : 		if (startKeyValue->Type == REG_DWORD && *((uint32 *) startKeyValue->Data) == SERVICE_BOOT_START)

  000cd	48 8b 44 24 38	 mov	 rax, QWORD PTR startKeyValue$[rsp]
  000d2	83 78 04 04	 cmp	 DWORD PTR [rax+4], 4
  000d6	75 5b		 jne	 SHORT $LN5@DriverEntr
  000d8	48 8b 44 24 38	 mov	 rax, QWORD PTR startKeyValue$[rsp]
  000dd	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  000e1	75 50		 jne	 SHORT $LN5@DriverEntr

; 106  : 		{
; 107  : 			if (!SelfTestsPassed)

  000e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR SelfTestsPassed, 0
  000ea	75 23		 jne	 SHORT $LN4@DriverEntr

; 108  : 				GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000ec	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  000f5	45 33 c9	 xor	 r9d, r9d
  000f8	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  000ff	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  00104	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN4@DriverEntr:

; 109  : 
; 110  : 			LoadBootArguments();

  0010f	e8 00 00 00 00	 call	 LoadBootArguments

; 111  : 			VolumeClassFilterRegistered = IsVolumeClassFilterRegistered();

  00114	e8 00 00 00 00	 call	 IsVolumeClassFilterRegistered
  00119	89 05 00 00 00
	00		 mov	 DWORD PTR VolumeClassFilterRegistered, eax

; 112  : 
; 113  : 			DriverObject->DriverExtension->AddDevice = DriverAddDevice;

  0011f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  00124	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00128	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DriverAddDevice
  0012f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN5@DriverEntr:

; 114  : 		}
; 115  : 
; 116  : 		GSTfree (startKeyValue);

  00133	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00138	48 8b 4c 24 38	 mov	 rcx, QWORD PTR startKeyValue$[rsp]
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@DriverEntr:

; 117  : 	}
; 118  : 
; 119  : 	for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)

  00143	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0014b	eb 0b		 jmp	 SHORT $LN3@DriverEntr
$LN2@DriverEntr:
  0014d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00151	83 c0 01	 add	 eax, 1
  00154	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN3@DriverEntr:
  00158	83 7c 24 30 1b	 cmp	 DWORD PTR i$[rsp], 27
  0015d	7f 18		 jg	 SHORT $LN1@DriverEntr

; 120  : 	{
; 121  : 		DriverObject->MajorFunction[i] = GSTDispatchQueueIRP;

  0015f	48 63 54 24 30	 movsxd	 rdx, DWORD PTR i$[rsp]
  00164	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  00169	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:GSTDispatchQueueIRP
  00170	48 89 44 d1 70	 mov	 QWORD PTR [rcx+rdx*8+112], rax

; 122  : 	}

  00175	eb d6		 jmp	 SHORT $LN2@DriverEntr
$LN1@DriverEntr:

; 123  : 
; 124  : 	DriverObject->DriverUnload = GSTUnloadDriver;

  00177	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:GSTUnloadDriver
  00183	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 125  : 	return GSTCreateRootDeviceObject (DriverObject);

  00187	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  0018c	e8 00 00 00 00	 call	 GSTCreateRootDeviceObject
$LN8@DriverEntr:
$LN9@DriverEntr:

; 126  : }

  00191	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00195	5f		 pop	 rdi
  00196	c3		 ret	 0
DriverEntry ENDP
INIT	ENDS
END
