; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\driver\ntvol.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ProbingHostDeviceForWrite
_BSS	SEGMENT
_ProbingHostDeviceForWrite DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_IoGetNextIrpStackLocation@4
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _IoGetNextIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetNextIrpStackLocation@4 PROC			; COMDAT

; 23479: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23480:     ASSERT(Irp->CurrentLocation > 0);
; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000b	83 e8 24	 sub	 eax, 36			; 00000024H

; 23483: }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_IoGetNextIrpStackLocation@4 ENDP
_TEXT	ENDS
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	__imp_@IofCallDriver@8:PROC
EXTRN	__imp__IoBuildDeviceIoControlRequest@36:PROC
EXTRN	__imp__KeClearEvent@4:PROC
; Function compile flags: /Ogsp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\driver\ntvol.c
;	COMDAT _GSTSendHostDeviceIoControlRequest@20
_TEXT	SEGMENT
_IoStatusBlock$ = -8					; size = 8
_IoControlCode$ = 8					; size = 4
_OutputBuffer$ = 12					; size = 4
_OutputBufferSize$ = 16					; size = 4
_GSTSendHostDeviceIoControlRequest@20 PROC		; COMDAT
; _Extension$ = esi

; 804  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	57		 push	 edi

; 805  : 	IO_STATUS_BLOCK IoStatusBlock;
; 806  : 	NTSTATUS ntStatus;
; 807  : 	PIRP Irp;
; 808  : 
; 809  : 	if (DeviceObject);	/* Remove compiler warning */
; 810  : 
; 811  : 	KeClearEvent (&Extension->keVolumeEvent);

  00009	8d be 94 00 00
	00		 lea	 edi, DWORD PTR [esi+148]
  0000f	57		 push	 edi
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeClearEvent@4

; 812  : 
; 813  : 	Irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 814  : 					     Extension->pFsdDevice,
; 815  : 					     NULL, 0,
; 816  : 					     OutputBuffer, OutputBufferSize,
; 817  : 					     FALSE,
; 818  : 					     &Extension->keVolumeEvent,
; 819  : 					     &IoStatusBlock);

  00016	8d 45 f8	 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  00019	50		 push	 eax
  0001a	57		 push	 edi
  0001b	33 db		 xor	 ebx, ebx
  0001d	53		 push	 ebx
  0001e	ff 75 10	 push	 DWORD PTR _OutputBufferSize$[ebp]
  00021	ff 75 0c	 push	 DWORD PTR _OutputBuffer$[ebp]
  00024	53		 push	 ebx
  00025	53		 push	 ebx
  00026	ff 76 5c	 push	 DWORD PTR [esi+92]
  00029	ff 75 08	 push	 DWORD PTR _IoControlCode$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 820  : 
; 821  : 	if (Irp == NULL)

  00032	3b c3		 cmp	 eax, ebx
  00034	75 07		 jne	 SHORT $LN2@GSTSendHos

; 822  : 	{
; 823  : 		Dump ("IRP allocation failed\n");
; 824  : 		return STATUS_INSUFFICIENT_RESOURCES;

  00036	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0003b	eb 29		 jmp	 SHORT $LN4@GSTSendHos
$LN2@GSTSendHos:

; 825  : 	}
; 826  : 
; 827  : 	// Disk device may be used by filesystem driver which needs file object
; 828  : 	IoGetNextIrpStackLocation (Irp) -> FileObject = Extension->pfoDeviceFile;

  0003d	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00040	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  00043	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 829  : 
; 830  : 	ntStatus = IoCallDriver (Extension->pFsdDevice, Irp);

  00046	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  00049	8b d0		 mov	 edx, eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 831  : 	if (ntStatus == STATUS_PENDING)

  00051	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  00056	75 0e		 jne	 SHORT $LN4@GSTSendHos

; 832  : 	{
; 833  : 		KeWaitForSingleObject (&Extension->keVolumeEvent, Executive, KernelMode, FALSE, NULL);

  00058	53		 push	 ebx
  00059	53		 push	 ebx
  0005a	53		 push	 ebx
  0005b	53		 push	 ebx
  0005c	57		 push	 edi
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 834  : 		ntStatus = IoStatusBlock.Status;

  00063	8b 45 f8	 mov	 eax, DWORD PTR _IoStatusBlock$[ebp]
$LN4@GSTSendHos:
  00066	5f		 pop	 edi
  00067	5b		 pop	 ebx

; 835  : 	}
; 836  : 
; 837  : 	return ntStatus;
; 838  : }

  00068	c9		 leave
  00069	c2 0c 00	 ret	 12			; 0000000cH
_GSTSendHostDeviceIoControlRequest@20 ENDP
_TEXT	ENDS
PUBLIC	_COMPLETE_IRP@16
EXTRN	__imp_@IofCompleteRequest@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _COMPLETE_IRP@16
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_IrpStatus$ = 16					; size = 4
_IrpInformation$ = 20					; size = 4
_COMPLETE_IRP@16 PROC					; COMDAT

; 855  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 856  : 	Irp->IoStatus.Status = IrpStatus;

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]

; 857  : 	Irp->IoStatus.Information = IrpInformation;

  00008	8b 45 14	 mov	 eax, DWORD PTR _IrpInformation$[ebp]
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR _IrpStatus$[ebp]

; 858  : 
; 859  : 	if (DeviceObject);	/* Remove compiler warning */
; 860  : 
; 861  : #if EXTRA_INFO
; 862  : 	if (!NT_SUCCESS (IrpStatus))
; 863  : 	{
; 864  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 865  : 		Dump ("COMPLETE_IRP FAILING IRP %ls Flags 0x%08x vpb 0x%08x NTSTATUS 0x%08x\n", GSTTranslateCode (irpSp->MajorFunction),
; 866  : 		      (ULONG) DeviceObject->Flags, (ULONG) DeviceObject->Vpb->Flags, IrpStatus);
; 867  : 	}
; 868  : 	else
; 869  : 	{
; 870  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 871  : 		Dump ("COMPLETE_IRP SUCCESS IRP %ls Flags 0x%08x vpb 0x%08x NTSTATUS 0x%08x\n", GSTTranslateCode (irpSp->MajorFunction),
; 872  : 		      (ULONG) DeviceObject->Flags, (ULONG) DeviceObject->Vpb->Flags, IrpStatus);
; 873  : 	}
; 874  : #endif
; 875  : 	IoCompleteRequest (Irp, IO_NO_INCREMENT);

  0000f	32 d2		 xor	 dl, dl
  00011	89 71 18	 mov	 DWORD PTR [ecx+24], esi
  00014	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 876  : 	return IrpStatus;

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 877  : }

  00020	5d		 pop	 ebp
  00021	c2 10 00	 ret	 16			; 00000010H
_COMPLETE_IRP@16 ENDP
_TEXT	ENDS
EXTRN	__imp__ZwSetInformationFile@20:PROC
EXTRN	__imp__ZwQueryInformationFile@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _RestoreTimeStamp@4
_TEXT	SEGMENT
_FileBasicInfo$ = -48					; size = 40
_IoStatusBlock$ = -8					; size = 8
_RestoreTimeStamp@4 PROC				; COMDAT
; _Extension$ = esi

; 889  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 890  : 	NTSTATUS ntStatus;
; 891  : 	FILE_BASIC_INFORMATION FileBasicInfo;
; 892  : 	IO_STATUS_BLOCK IoStatusBlock;
; 893  : 
; 894  : 	if (Extension->hDeviceFile != NULL 
; 895  : 		&& Extension->bRawDevice == FALSE 
; 896  : 		&& Extension->bReadOnly == FALSE
; 897  : 		&& Extension->bTimeStampValid)

  00005	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00008	33 c9		 xor	 ecx, ecx
  0000a	83 ec 30	 sub	 esp, 48			; 00000030H
  0000d	3b c1		 cmp	 eax, ecx
  0000f	0f 84 90 00 00
	00		 je	 $LN1@RestoreTim
  00015	39 8e 54 02 00
	00		 cmp	 DWORD PTR [esi+596], ecx
  0001b	0f 85 84 00 00
	00		 jne	 $LN1@RestoreTim
  00021	39 8e 48 02 00
	00		 cmp	 DWORD PTR [esi+584], ecx
  00027	75 7c		 jne	 SHORT $LN1@RestoreTim
  00029	39 8e 88 04 00
	00		 cmp	 DWORD PTR [esi+1160], ecx
  0002f	74 74		 je	 SHORT $LN1@RestoreTim

; 898  : 	{
; 899  : 		ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 900  : 			&IoStatusBlock,
; 901  : 			&FileBasicInfo,
; 902  : 			sizeof (FileBasicInfo),
; 903  : 			FileBasicInformation); 

  00031	6a 04		 push	 4
  00033	6a 28		 push	 40			; 00000028H
  00035	8d 4d d0	 lea	 ecx, DWORD PTR _FileBasicInfo$[ebp]
  00038	51		 push	 ecx
  00039	8d 4d f8	 lea	 ecx, DWORD PTR _IoStatusBlock$[ebp]
  0003c	51		 push	 ecx
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwQueryInformationFile@20

; 904  : 
; 905  : 		if (!NT_SUCCESS (ntStatus))

  00044	85 c0		 test	 eax, eax
  00046	7c 5d		 jl	 SHORT $LN1@RestoreTim

; 906  : 		{
; 907  : 			Dump ("ZwQueryInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x\n",
; 908  : 				ntStatus);
; 909  : 		}
; 910  : 		else
; 911  : 		{
; 912  : 			FileBasicInfo.CreationTime = Extension->fileCreationTime;

  00048	8b 86 68 04 00
	00		 mov	 eax, DWORD PTR [esi+1128]
  0004e	89 45 d0	 mov	 DWORD PTR _FileBasicInfo$[ebp], eax
  00051	8b 86 6c 04 00
	00		 mov	 eax, DWORD PTR [esi+1132]
  00057	89 45 d4	 mov	 DWORD PTR _FileBasicInfo$[ebp+4], eax

; 913  : 			FileBasicInfo.LastAccessTime = Extension->fileLastAccessTime;

  0005a	8b 86 70 04 00
	00		 mov	 eax, DWORD PTR [esi+1136]
  00060	89 45 d8	 mov	 DWORD PTR _FileBasicInfo$[ebp+8], eax
  00063	8b 86 74 04 00
	00		 mov	 eax, DWORD PTR [esi+1140]
  00069	89 45 dc	 mov	 DWORD PTR _FileBasicInfo$[ebp+12], eax

; 914  : 			FileBasicInfo.LastWriteTime = Extension->fileLastWriteTime;

  0006c	8b 86 78 04 00
	00		 mov	 eax, DWORD PTR [esi+1144]
  00072	89 45 e0	 mov	 DWORD PTR _FileBasicInfo$[ebp+16], eax
  00075	8b 86 7c 04 00
	00		 mov	 eax, DWORD PTR [esi+1148]
  0007b	89 45 e4	 mov	 DWORD PTR _FileBasicInfo$[ebp+20], eax

; 915  : 			FileBasicInfo.ChangeTime = Extension->fileLastChangeTime;

  0007e	8b 86 80 04 00
	00		 mov	 eax, DWORD PTR [esi+1152]
  00084	89 45 e8	 mov	 DWORD PTR _FileBasicInfo$[ebp+24], eax
  00087	8b 86 84 04 00
	00		 mov	 eax, DWORD PTR [esi+1156]

; 916  : 
; 917  : 			ntStatus = ZwSetInformationFile(
; 918  : 				Extension->hDeviceFile,
; 919  : 				&IoStatusBlock,
; 920  : 				&FileBasicInfo,
; 921  : 				sizeof (FileBasicInfo),
; 922  : 				FileBasicInformation); 

  0008d	6a 04		 push	 4
  0008f	89 45 ec	 mov	 DWORD PTR _FileBasicInfo$[ebp+28], eax
  00092	6a 28		 push	 40			; 00000028H
  00094	8d 45 d0	 lea	 eax, DWORD PTR _FileBasicInfo$[ebp]
  00097	50		 push	 eax
  00098	8d 45 f8	 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  0009b	50		 push	 eax
  0009c	ff 76 54	 push	 DWORD PTR [esi+84]
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwSetInformationFile@20
$LN1@RestoreTim:

; 923  : 
; 924  : 			if (!NT_SUCCESS (ntStatus))
; 925  : 				Dump ("ZwSetInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x\n",ntStatus);
; 926  : 		}
; 927  : 	}
; 928  : }

  000a5	c9		 leave
  000a6	c3		 ret	 0
_RestoreTimeStamp@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_pwszMountVolume$GSCopy$
PUBLIC	_mount$GSCopy$
PUBLIC	_DeviceObject$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_GSTOpenVolume@20
EXTRN	_crypto_close@4:PROC
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp__wcsncpy:PROC
EXTRN	__imp__wcsstr:PROC
EXTRN	_GetSystemDriveCryptoInfo@0:PROC
EXTRN	_EAGetKeySize@4:PROC
EXTRN	_HiddenSysLeakProtectionCount:DWORD
EXTRN	_ReadVolumeHeaderWCache@20:PROC
EXTRN	_ReadVolumeHeaderRecoveryMode:DWORD
EXTRN	__imp__ZwClose@4:PROC
EXTRN	__imp__ZwReadFile@36:PROC
EXTRN	__imp___snwprintf:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	_GSTFsctlCall@24:PROC
EXTRN	__imp__IoGetRelatedDeviceObject@4:PROC
EXTRN	__imp__ObReferenceObjectByHandle@24:PROC
EXTRN	_IoFileObjectType:DWORD
EXTRN	__imp__ZwCreateFile@44:PROC
EXTRN	_IsHiddenSystemRunning@0:PROC
EXTRN	__imp__IoGetDeviceObjectPointer@16:PROC
EXTRN	__imp__SeImpersonateClientEx@8:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__RtlInitUnicodeString@8:PROC
EXTRN	_OsMinorVersion:DWORD
EXTRN	_OsMajorVersion:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__alldiv:PROC
EXTRN	_memset:PROC
EXTRN	__allmul:PROC
;	COMDAT ??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, '\', 00H, '%', 00H, 's', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, 'U', 00H, 'N', 00H, 'C', 00H
	DB	'\', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'd', 00H, 'i'
	DB	00H, 's', 00H, 'k', 00H, '%', 00H, 'd', 00H, '\', 00H, 'P', 00H
	DB	'a', 00H, 'r', 00H, 't', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, '0', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _GSTOpenVolume@20
_TEXT	SEGMENT
_pix$28108 = -532					; size = 144
_FileStandardInfo$ = -388				; size = 24
_pi$28107 = -364					; size = 32
_FileBasicInfo$ = -332					; size = 40
_FullParentPath$28202 = -292				; size = 8
_dg$28110 = -284					; size = 24
tv745 = -260						; size = 8
_oaParentFileAttributes$28203 = -252			; size = 24
_oaFileAttributes$ = -228				; size = 24
_parentKeyDataOffset$28204 = -204			; size = 8
_FullFileName$ = -196					; size = 8
tv1021 = -188						; size = 8
_disableBuffering$ = -184				; size = 4
tv1025 = -180						; size = 8
_diskLengthInfo$28109 = -180				; size = 8
_IoStatusBlock$ = -172					; size = 8
tv969 = -164						; size = 4
_DeviceObject$GSCopy$ = -164				; size = 4
tv870 = -160						; size = 4
_pwszMountVolume$GSCopy$ = -156				; size = 4
_headerOffset$28182 = -152				; size = 8
_partitionStartingOffset$ = -144			; size = 8
tv872 = -136						; size = 4
_tmpCryptoInfo$ = -132					; size = 4
_readBuffer$ = -128					; size = 4
_hParentDeviceFile$28200 = -124				; size = 4
_exclusiveAccess$ = -124				; size = 4
_lDiskLength$ = -120					; size = 8
_volumeType$ = -112					; size = 4
_pfoTmpDeviceFile$28161 = -112				; size = 4
_mount$GSCopy$ = -108					; size = 4
_ntStatus$ = -104					; size = 4
_parentDrivePath$28199 = -100				; size = 96
__$ArrayPad$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_mount$ = 16						; size = 4
_pwszMountVolume$ = 20					; size = 4
_bRawDevice$ = 24					; size = 4
_GSTOpenVolume@20 PROC					; COMDAT

; 68   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 14 02 00
	00		 sub	 esp, 532		; 00000214H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 69   : 	FILE_STANDARD_INFORMATION FileStandardInfo;
; 70   : 	FILE_BASIC_INFORMATION FileBasicInfo;
; 71   : 	OBJECT_ATTRIBUTES oaFileAttributes;
; 72   : 	UNICODE_STRING FullFileName;
; 73   : 	IO_STATUS_BLOCK IoStatusBlock;
; 74   : 	PCRYPTO_INFO cryptoInfoPtr = NULL;
; 75   : 	PCRYPTO_INFO tmpCryptoInfo = NULL;
; 76   : 	LARGE_INTEGER lDiskLength;
; 77   : 	__int64 partitionStartingOffset = 0;

  00015	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00018	8b 4d 14	 mov	 ecx, DWORD PTR _pwszMountVolume$[ebp]
  0001b	53		 push	 ebx
  0001c	8b 5d 0c	 mov	 ebx, DWORD PTR _Extension$[ebp]
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	33 ff		 xor	 edi, edi
  00023	89 85 5c ff ff
	ff		 mov	 DWORD PTR _DeviceObject$GSCopy$[ebp], eax
  00029	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  0002c	89 45 94	 mov	 DWORD PTR _mount$GSCopy$[ebp], eax
  0002f	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _pwszMountVolume$GSCopy$[ebp], ecx
  00035	89 bd 7c ff ff
	ff		 mov	 DWORD PTR _tmpCryptoInfo$[ebp], edi
  0003b	89 bd 70 ff ff
	ff		 mov	 DWORD PTR _partitionStartingOffset$[ebp], edi
  00041	89 bd 74 ff ff
	ff		 mov	 DWORD PTR _partitionStartingOffset$[ebp+4], edi

; 78   : 	int volumeType;
; 79   : 	char *readBuffer = 0;

  00047	89 7d 80	 mov	 DWORD PTR _readBuffer$[ebp], edi

; 80   : 	NTSTATUS ntStatus = 0;

  0004a	89 7d 98	 mov	 DWORD PTR _ntStatus$[ebp], edi

; 81   : 	BOOL forceAccessCheck = (!bRawDevice && !(OsMajorVersion == 5 &&OsMinorVersion == 0)); // Windows 2000 does not support OBJ_FORCE_ACCESS_CHECK attribute

  0004d	39 7d 18	 cmp	 DWORD PTR _bRawDevice$[ebp], edi
  00050	75 16		 jne	 SHORT $LN111@GSTOpenVol
  00052	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _OsMajorVersion, 5
  00059	75 08		 jne	 SHORT $LN110@GSTOpenVol
  0005b	39 3d 00 00 00
	00		 cmp	 DWORD PTR _OsMinorVersion, edi
  00061	74 05		 je	 SHORT $LN111@GSTOpenVol
$LN110@GSTOpenVol:
  00063	33 f6		 xor	 esi, esi
  00065	46		 inc	 esi
  00066	eb 02		 jmp	 SHORT $LN112@GSTOpenVol
$LN111@GSTOpenVol:
  00068	33 f6		 xor	 esi, esi
$LN112@GSTOpenVol:

; 82   : 	BOOL disableBuffering = TRUE;
; 83   : 	BOOL exclusiveAccess = mount->bExclusiveAccess;

  0006a	8b 80 74 02 00
	00		 mov	 eax, DWORD PTR [eax+628]
  00070	89 45 84	 mov	 DWORD PTR _exclusiveAccess$[ebp], eax

; 84   : 
; 85   : 	Extension->pfoDeviceFile = NULL;

  00073	8d 43 58	 lea	 eax, DWORD PTR [ebx+88]
  00076	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv870[ebp], eax
  0007c	89 38		 mov	 DWORD PTR [eax], edi

; 86   : 	Extension->hDeviceFile = NULL;

  0007e	8d 43 54	 lea	 eax, DWORD PTR [ebx+84]
  00081	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv872[ebp], eax
  00087	89 38		 mov	 DWORD PTR [eax], edi

; 87   : 	Extension->bTimeStampValid = FALSE;
; 88   : 
; 89   : 	RtlInitUnicodeString (&FullFileName, pwszMountVolume);

  00089	51		 push	 ecx
  0008a	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _FullFileName$[ebp]
  00090	50		 push	 eax
  00091	c7 85 48 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _disableBuffering$[ebp], 1
  0009b	89 bb 88 04 00
	00		 mov	 DWORD PTR [ebx+1160], edi
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 90   : 	InitializeObjectAttributes (&oaFileAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | (forceAccessCheck ? OBJ_FORCE_ACCESS_CHECK : 0) | OBJ_KERNEL_HANDLE, NULL, NULL);

  000a7	f7 de		 neg	 esi
  000a9	1b f6		 sbb	 esi, esi
  000ab	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _FullFileName$[ebp]

; 91   : 	KeInitializeEvent (&Extension->keVolumeEvent, NotificationEvent, FALSE);

  000b1	57		 push	 edi
  000b2	89 85 24 ff ff
	ff		 mov	 DWORD PTR _oaFileAttributes$[ebp+8], eax
  000b8	81 e6 00 04 00
	00		 and	 esi, 1024		; 00000400H
  000be	57		 push	 edi
  000bf	8d 83 94 00 00
	00		 lea	 eax, DWORD PTR [ebx+148]
  000c5	81 ce 40 02 00
	00		 or	 esi, 576		; 00000240H
  000cb	50		 push	 eax
  000cc	c7 85 1c ff ff
	ff 18 00 00 00	 mov	 DWORD PTR _oaFileAttributes$[ebp], 24 ; 00000018H
  000d6	89 bd 20 ff ff
	ff		 mov	 DWORD PTR _oaFileAttributes$[ebp+4], edi
  000dc	89 b5 28 ff ff
	ff		 mov	 DWORD PTR _oaFileAttributes$[ebp+12], esi
  000e2	89 bd 2c ff ff
	ff		 mov	 DWORD PTR _oaFileAttributes$[ebp+16], edi
  000e8	89 bd 30 ff ff
	ff		 mov	 DWORD PTR _oaFileAttributes$[ebp+20], edi
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 92   : 
; 93   : 	if (Extension->SecurityClientContextValid)

  000f4	39 bb 90 04 00
	00		 cmp	 DWORD PTR [ebx+1168], edi
  000fa	74 19		 je	 SHORT $LN106@GSTOpenVol

; 94   : 	{
; 95   : 		ntStatus = SeImpersonateClientEx (&Extension->SecurityClientContext, NULL);

  000fc	57		 push	 edi
  000fd	8d 83 94 04 00
	00		 lea	 eax, DWORD PTR [ebx+1172]
  00103	50		 push	 eax
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeImpersonateClientEx@8

; 96   : 		if (!NT_SUCCESS (ntStatus))

  0010a	3b c7		 cmp	 eax, edi
  0010c	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax
  0010f	0f 8c 9b 0c 00
	00		 jl	 $error$28105
$LN106@GSTOpenVol:

; 97   : 			goto error;
; 98   : 	}
; 99   : 
; 100  : 	mount->VolumeMountedReadOnlyAfterDeviceWriteProtected = FALSE;

  00115	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  00118	89 78 0c	 mov	 DWORD PTR [eax+12], edi

; 101  : 
; 102  : 	// If we are opening a device, query its size first
; 103  : 	if (bRawDevice)

  0011b	39 7d 18	 cmp	 DWORD PTR _bRawDevice$[ebp], edi
  0011e	0f 84 14 02 00
	00		 je	 $LN105@GSTOpenVol

; 104  : 	{
; 105  : 		PARTITION_INFORMATION pi;
; 106  : 		PARTITION_INFORMATION_EX pix;
; 107  : 		LARGE_INTEGER diskLengthInfo;
; 108  : 		DISK_GEOMETRY dg;
; 109  : 
; 110  : 		ntStatus = IoGetDeviceObjectPointer (&FullFileName,
; 111  : 			FILE_READ_DATA | FILE_READ_ATTRIBUTES,
; 112  : 			&Extension->pfoDeviceFile,
; 113  : 			&Extension->pFsdDevice);

  00124	8d 43 5c	 lea	 eax, DWORD PTR [ebx+92]
  00127	50		 push	 eax
  00128	ff b5 60 ff ff
	ff		 push	 DWORD PTR tv870[ebp]
  0012e	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _FullFileName$[ebp]
  00134	68 81 00 00 00	 push	 129			; 00000081H
  00139	50		 push	 eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceObjectPointer@16

; 114  : 
; 115  : 		if (!NT_SUCCESS (ntStatus))

  00140	3b c7		 cmp	 eax, edi
  00142	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax
  00145	0f 8c 65 0c 00
	00		 jl	 $error$28105

; 116  : 			goto error;
; 117  : 
; 118  : 		ntStatus = GSTSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_DRIVE_GEOMETRY, (char *) &dg, sizeof (dg));

  0014b	6a 18		 push	 24			; 00000018H
  0014d	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _dg$28110[ebp]
  00153	50		 push	 eax
  00154	68 00 00 07 00	 push	 458752			; 00070000H
  00159	8b f3		 mov	 esi, ebx
  0015b	e8 00 00 00 00	 call	 _GSTSendHostDeviceIoControlRequest@20

; 119  : 		if (!NT_SUCCESS (ntStatus))

  00160	3b c7		 cmp	 eax, edi
  00162	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax
  00165	0f 8c 45 0c 00
	00		 jl	 $error$28105

; 120  : 			goto error;
; 121  : 
; 122  : 		lDiskLength.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;

  0016b	8b b5 f8 fe ff
	ff		 mov	 esi, DWORD PTR _dg$28110[ebp+20]
  00171	8b c6		 mov	 eax, esi
  00173	f7 a5 f0 fe ff
	ff		 mul	 DWORD PTR _dg$28110[ebp+12]
  00179	57		 push	 edi
  0017a	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _dg$28110[ebp+16]
  00180	52		 push	 edx
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 __allmul
  00187	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _dg$28110[ebp+4]
  0018d	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _dg$28110[ebp]
  00193	52		 push	 edx
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 __allmul
  0019a	89 45 88	 mov	 DWORD PTR _lDiskLength$[ebp], eax

; 123  : 		Extension->HostBytesPerSector = dg.BytesPerSector;
; 124  : 
; 125  : 		// Drive geometry is used only when IOCTL_DISK_GET_PARTITION_INFO fails
; 126  : 		if (NT_SUCCESS (GSTSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_PARTITION_INFO_EX, (char *) &pix, sizeof (pix))))

  0019d	68 90 00 00 00	 push	 144			; 00000090H
  001a2	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pix$28108[ebp]
  001a8	50		 push	 eax
  001a9	89 b3 90 00 00
	00		 mov	 DWORD PTR [ebx+144], esi
  001af	68 48 00 07 00	 push	 458824			; 00070048H
  001b4	8b f3		 mov	 esi, ebx
  001b6	89 55 8c	 mov	 DWORD PTR _lDiskLength$[ebp+4], edx
  001b9	e8 00 00 00 00	 call	 _GSTSendHostDeviceIoControlRequest@20
  001be	85 c0		 test	 eax, eax
  001c0	7c 26		 jl	 SHORT $LN102@GSTOpenVol

; 127  : 		{
; 128  : 			lDiskLength.QuadPart = pix.PartitionLength.QuadPart;

  001c2	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR _pix$28108[ebp+16]
  001c8	89 45 88	 mov	 DWORD PTR _lDiskLength$[ebp], eax
  001cb	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR _pix$28108[ebp+20]
  001d1	89 45 8c	 mov	 DWORD PTR _lDiskLength$[ebp+4], eax

; 129  : 			partitionStartingOffset = pix.StartingOffset.QuadPart;

  001d4	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _pix$28108[ebp+8]
  001da	89 85 70 ff ff
	ff		 mov	 DWORD PTR _partitionStartingOffset$[ebp], eax
  001e0	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _pix$28108[ebp+12]
  001e6	eb 3b		 jmp	 SHORT $LN157@GSTOpenVol
$LN102@GSTOpenVol:

; 130  : 		}
; 131  : 		// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 132  : 		else if (NT_SUCCESS (GSTSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_PARTITION_INFO, (char *) &pi, sizeof (pi))))

  001e8	6a 20		 push	 32			; 00000020H
  001ea	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _pi$28107[ebp]
  001f0	50		 push	 eax
  001f1	68 04 40 07 00	 push	 475140			; 00074004H
  001f6	e8 00 00 00 00	 call	 _GSTSendHostDeviceIoControlRequest@20
  001fb	85 c0		 test	 eax, eax
  001fd	7c 2c		 jl	 SHORT $LN100@GSTOpenVol

; 133  : 		{
; 134  : 			lDiskLength.QuadPart = pi.PartitionLength.QuadPart;

  001ff	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _pi$28107[ebp+8]
  00205	89 45 88	 mov	 DWORD PTR _lDiskLength$[ebp], eax
  00208	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _pi$28107[ebp+12]
  0020e	89 45 8c	 mov	 DWORD PTR _lDiskLength$[ebp+4], eax

; 135  : 			partitionStartingOffset = pi.StartingOffset.QuadPart;

  00211	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _pi$28107[ebp]
  00217	89 85 70 ff ff
	ff		 mov	 DWORD PTR _partitionStartingOffset$[ebp], eax
  0021d	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _pi$28107[ebp+4]
$LN157@GSTOpenVol:
  00223	89 85 74 ff ff
	ff		 mov	 DWORD PTR _partitionStartingOffset$[ebp+4], eax
  00229	eb 29		 jmp	 SHORT $LN98@GSTOpenVol
$LN100@GSTOpenVol:

; 136  : 		}
; 137  : 		else if (NT_SUCCESS (GSTSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_LENGTH_INFO, &diskLengthInfo, sizeof (diskLengthInfo))))

  0022b	6a 08		 push	 8
  0022d	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _diskLengthInfo$28109[ebp]
  00233	50		 push	 eax
  00234	68 5c 40 07 00	 push	 475228			; 0007405cH
  00239	e8 00 00 00 00	 call	 _GSTSendHostDeviceIoControlRequest@20
  0023e	85 c0		 test	 eax, eax
  00240	7c 12		 jl	 SHORT $LN98@GSTOpenVol

; 138  : 		{
; 139  : 			lDiskLength = diskLengthInfo;

  00242	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _diskLengthInfo$28109[ebp]
  00248	89 45 88	 mov	 DWORD PTR _lDiskLength$[ebp], eax
  0024b	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _diskLengthInfo$28109[ebp+4]
  00251	89 45 8c	 mov	 DWORD PTR _lDiskLength$[ebp+4], eax
$LN98@GSTOpenVol:

; 140  : 		}
; 141  : 
; 142  : 		ProbingHostDeviceForWrite = TRUE;
; 143  : 
; 144  : 		if (!mount->bMountReadOnly
; 145  : 			&& GSTSendHostDeviceIoControlRequest (DeviceObject, Extension,
; 146  : 				IsHiddenSystemRunning() ? GST_IOCTL_DISK_IS_WRITABLE : IOCTL_DISK_IS_WRITABLE, NULL, 0) == STATUS_MEDIA_WRITE_PROTECTED)

  00254	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  00257	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ProbingHostDeviceForWrite, 1
  00261	39 b8 6c 02 00
	00		 cmp	 DWORD PTR [eax+620], edi
  00267	75 3d		 jne	 SHORT $LN97@GSTOpenVol
  00269	57		 push	 edi
  0026a	57		 push	 edi
  0026b	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  00270	f7 d8		 neg	 eax
  00272	1b c0		 sbb	 eax, eax
  00274	25 50 20 1b 00	 and	 eax, 1777744		; 001b2050H
  00279	05 24 00 07 00	 add	 eax, 458788		; 00070024H
  0027e	50		 push	 eax
  0027f	8b f3		 mov	 esi, ebx
  00281	e8 00 00 00 00	 call	 _GSTSendHostDeviceIoControlRequest@20
  00286	3d a2 00 00 c0	 cmp	 eax, -1073741662	; c00000a2H
  0028b	75 19		 jne	 SHORT $LN97@GSTOpenVol

; 147  : 		{
; 148  : 			mount->bMountReadOnly = TRUE;

  0028d	8b 4d 94	 mov	 ecx, DWORD PTR _mount$GSCopy$[ebp]

; 149  : 			DeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  00290	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _DeviceObject$GSCopy$[ebp]
  00296	33 d2		 xor	 edx, edx
  00298	42		 inc	 edx
  00299	89 91 6c 02 00
	00		 mov	 DWORD PTR [ecx+620], edx
  0029f	83 48 20 02	 or	 DWORD PTR [eax+32], 2

; 150  : 			mount->VolumeMountedReadOnlyAfterDeviceWriteProtected = TRUE;

  002a3	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN97@GSTOpenVol:

; 151  : 		}
; 152  : 
; 153  : 		ProbingHostDeviceForWrite = FALSE;

  002a6	89 3d 00 00 00
	00		 mov	 DWORD PTR _ProbingHostDeviceForWrite, edi

; 154  : 
; 155  : 		// Some Windows tools (e.g. diskmgmt, diskpart, vssadmin) fail or experience timeouts when there is a raw device
; 156  : 		// open for exclusive access. Therefore, exclusive access is used only for file-hosted volumes.
; 157  : 		// Applications requiring a consistent device image need to acquire exclusive write access first. This is prevented
; 158  : 		// when a device-hosted volume is mounted.
; 159  : 
; 160  : 		exclusiveAccess = FALSE;

  002ac	89 7d 84	 mov	 DWORD PTR _exclusiveAccess$[ebp], edi
$LN146@GSTOpenVol:

; 174  : 			disableBuffering = FALSE;

  002af	8b b5 48 ff ff
	ff		 mov	 esi, DWORD PTR _disableBuffering$[ebp]
$LN94@GSTOpenVol:

; 175  : 	}
; 176  : 
; 177  : 	// Open the volume hosting file/device
; 178  : 	if (!mount->bMountReadOnly)

  002b5	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  002b8	39 b8 6c 02 00
	00		 cmp	 DWORD PTR [eax+620], edi
  002be	75 4c		 jne	 SHORT $LN150@GSTOpenVol

; 179  : 	{
; 180  : 		ntStatus = ZwCreateFile (&Extension->hDeviceFile,
; 181  : 			GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
; 182  : 			&oaFileAttributes,
; 183  : 			&IoStatusBlock,
; 184  : 			NULL,
; 185  : 			FILE_ATTRIBUTE_NORMAL |
; 186  : 			FILE_ATTRIBUTE_SYSTEM,
; 187  : 			exclusiveAccess ? 0 : FILE_SHARE_READ | FILE_SHARE_WRITE,
; 188  : 			FILE_OPEN,
; 189  : 			FILE_RANDOM_ACCESS |
; 190  : 			FILE_WRITE_THROUGH |
; 191  : 			(disableBuffering ? FILE_NO_INTERMEDIATE_BUFFERING : 0) |
; 192  : 			FILE_SYNCHRONOUS_IO_NONALERT,
; 193  : 			NULL,
; 194  : 			0);

  002c0	57		 push	 edi
  002c1	57		 push	 edi
  002c2	8b c6		 mov	 eax, esi
  002c4	f7 d8		 neg	 eax
  002c6	1b c0		 sbb	 eax, eax
  002c8	83 e0 08	 and	 eax, 8
  002cb	0d 22 08 00 00	 or	 eax, 2082		; 00000822H
  002d0	50		 push	 eax
  002d1	8b 45 84	 mov	 eax, DWORD PTR _exclusiveAccess$[ebp]
  002d4	f7 d8		 neg	 eax
  002d6	1b c0		 sbb	 eax, eax
  002d8	6a 01		 push	 1
  002da	83 e0 fd	 and	 eax, -3			; fffffffdH
  002dd	83 c0 03	 add	 eax, 3
  002e0	50		 push	 eax
  002e1	68 84 00 00 00	 push	 132			; 00000084H
  002e6	57		 push	 edi
  002e7	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  002ed	50		 push	 eax
  002ee	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _oaFileAttributes$[ebp]
  002f4	50		 push	 eax
  002f5	68 00 00 10 c0	 push	 -1072693248		; c0100000H
  002fa	ff b5 78 ff ff
	ff		 push	 DWORD PTR tv872[ebp]
  00300	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44
  00306	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax
  00309	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
$LN150@GSTOpenVol:

; 195  : 	}
; 196  : 
; 197  : 	/* 26-4-99 NT for some partitions returns this code, it is really a	access denied */
; 198  : 	if (ntStatus == 0xc000001b)

  0030c	81 7d 98 1b 00
	00 c0		 cmp	 DWORD PTR _ntStatus$[ebp], -1073741797 ; c000001bH
  00313	b9 22 00 00 c0	 mov	 ecx, -1073741790	; c0000022H
  00318	75 03		 jne	 SHORT $LN92@GSTOpenVol

; 199  : 		ntStatus = STATUS_ACCESS_DENIED;

  0031a	89 4d 98	 mov	 DWORD PTR _ntStatus$[ebp], ecx
$LN92@GSTOpenVol:

; 200  : 
; 201  : 	mount->VolumeMountedReadOnlyAfterAccessDenied = FALSE;

  0031d	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 202  : 
; 203  : 	if (mount->bMountReadOnly || ntStatus == STATUS_ACCESS_DENIED)

  00320	39 b8 6c 02 00
	00		 cmp	 DWORD PTR [eax+620], edi
  00326	75 41		 jne	 SHORT $LN90@GSTOpenVol
  00328	39 4d 98	 cmp	 DWORD PTR _ntStatus$[ebp], ecx
  0032b	74 3c		 je	 SHORT $LN90@GSTOpenVol

; 226  : 	}
; 227  : 	else
; 228  : 		Extension->bReadOnly = FALSE;

  0032d	89 bb 48 02 00
	00		 mov	 DWORD PTR [ebx+584], edi
  00333	e9 a2 00 00 00	 jmp	 $LN88@GSTOpenVol
$LN105@GSTOpenVol:

; 161  : 	}
; 162  : 	else
; 163  : 	{
; 164  : 		// Limit the maximum required buffer size
; 165  : 		if (mount->BytesPerSector > 128 * BYTES_PER_KB)

  00338	8b 80 68 02 00
	00		 mov	 eax, DWORD PTR [eax+616]
  0033e	3d 00 00 02 00	 cmp	 eax, 131072		; 00020000H
  00343	76 0c		 jbe	 SHORT $LN95@GSTOpenVol

; 166  : 		{
; 167  : 			ntStatus = STATUS_INVALID_PARAMETER;

  00345	c7 45 98 0d 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741811 ; c000000dH

; 168  : 			goto error;

  0034c	e9 5f 0a 00 00	 jmp	 $error$28105
$LN95@GSTOpenVol:

; 169  : 		}
; 170  : 
; 171  : 		Extension->HostBytesPerSector = mount->BytesPerSector;

  00351	89 83 90 00 00
	00		 mov	 DWORD PTR [ebx+144], eax

; 172  : 
; 173  : 		if (Extension->HostBytesPerSector != GST_SECTOR_SIZE_FILE_HOSTED_VOLUME)

  00357	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  0035c	0f 84 4d ff ff
	ff		 je	 $LN146@GSTOpenVol

; 174  : 			disableBuffering = FALSE;

  00362	33 f6		 xor	 esi, esi
  00364	e9 4c ff ff ff	 jmp	 $LN94@GSTOpenVol
$LN90@GSTOpenVol:

; 204  : 	{
; 205  : 		ntStatus = ZwCreateFile (&Extension->hDeviceFile,
; 206  : 			GENERIC_READ | SYNCHRONIZE,
; 207  : 			&oaFileAttributes,
; 208  : 			&IoStatusBlock,
; 209  : 			NULL,
; 210  : 			FILE_ATTRIBUTE_NORMAL |
; 211  : 			FILE_ATTRIBUTE_SYSTEM,
; 212  : 			exclusiveAccess ? FILE_SHARE_READ : FILE_SHARE_READ | FILE_SHARE_WRITE,
; 213  : 			FILE_OPEN,
; 214  : 			FILE_RANDOM_ACCESS |
; 215  : 			FILE_WRITE_THROUGH |
; 216  : 			(disableBuffering ? FILE_NO_INTERMEDIATE_BUFFERING : 0) |
; 217  : 			FILE_SYNCHRONOUS_IO_NONALERT,
; 218  : 			NULL,
; 219  : 			0);

  00369	f7 de		 neg	 esi
  0036b	1b f6		 sbb	 esi, esi
  0036d	33 c0		 xor	 eax, eax
  0036f	57		 push	 edi
  00370	83 e6 08	 and	 esi, 8
  00373	57		 push	 edi
  00374	81 ce 22 08 00
	00		 or	 esi, 2082		; 00000822H
  0037a	39 7d 84	 cmp	 DWORD PTR _exclusiveAccess$[ebp], edi
  0037d	56		 push	 esi
  0037e	0f 94 c0	 sete	 al
  00381	6a 01		 push	 1
  00383	8d 44 00 01	 lea	 eax, DWORD PTR [eax+eax+1]
  00387	50		 push	 eax
  00388	68 84 00 00 00	 push	 132			; 00000084H
  0038d	57		 push	 edi
  0038e	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  00394	50		 push	 eax
  00395	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _oaFileAttributes$[ebp]
  0039b	50		 push	 eax
  0039c	68 00 00 10 80	 push	 -2146435072		; 80100000H
  003a1	ff b5 78 ff ff
	ff		 push	 DWORD PTR tv872[ebp]
  003a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44

; 220  : 
; 221  : 		if (NT_SUCCESS (ntStatus) && !mount->bMountReadOnly)

  003ad	3b c7		 cmp	 eax, edi
  003af	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax
  003b2	7c 12		 jl	 SHORT $LN151@GSTOpenVol
  003b4	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  003b7	39 b8 6c 02 00
	00		 cmp	 DWORD PTR [eax+620], edi
  003bd	75 07		 jne	 SHORT $LN151@GSTOpenVol

; 222  : 			mount->VolumeMountedReadOnlyAfterAccessDenied = TRUE;

  003bf	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1
$LN151@GSTOpenVol:

; 223  : 
; 224  : 		Extension->bReadOnly = TRUE;
; 225  : 		DeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  003c6	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _DeviceObject$GSCopy$[ebp]
  003cc	c7 83 48 02 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+584], 1
  003d6	83 48 20 02	 or	 DWORD PTR [eax+32], 2
$LN88@GSTOpenVol:

; 229  : 
; 230  : 	/* 26-4-99 NT for some partitions returns this code, it is really a
; 231  : 	access denied */
; 232  : 	if (ntStatus == 0xc000001b)

  003da	81 7d 98 1b 00
	00 c0		 cmp	 DWORD PTR _ntStatus$[ebp], -1073741797 ; c000001bH
  003e1	75 07		 jne	 SHORT $LN87@GSTOpenVol

; 233  : 	{
; 234  : 		/* Partitions which return this code can still be opened with
; 235  : 		FILE_SHARE_READ but this causes NT problems elsewhere in
; 236  : 		particular if you do FILE_SHARE_READ NT will die later if
; 237  : 		anyone even tries to open the partition (or file for that
; 238  : 		matter...)  */
; 239  : 		ntStatus = STATUS_SHARING_VIOLATION;

  003e3	c7 45 98 43 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741757 ; c0000043H
$LN87@GSTOpenVol:

; 240  : 	}
; 241  : 
; 242  : 	if (!NT_SUCCESS (ntStatus))

  003ea	39 7d 98	 cmp	 DWORD PTR _ntStatus$[ebp], edi
  003ed	0f 8c bd 09 00
	00		 jl	 $error$28105

; 243  : 	{
; 244  : 		goto error;
; 245  : 	}
; 246  : 
; 247  : 	// If we have opened a file, query its size now
; 248  : 	if (bRawDevice == FALSE)

  003f3	39 7d 18	 cmp	 DWORD PTR _bRawDevice$[ebp], edi
  003f6	0f 85 38 01 00
	00		 jne	 $LN85@GSTOpenVol

; 249  : 	{
; 250  : 		ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 251  : 			&IoStatusBlock,
; 252  : 			&FileBasicInfo,
; 253  : 			sizeof (FileBasicInfo),
; 254  : 			FileBasicInformation);

  003fc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ZwQueryInformationFile@20
  00402	6a 04		 push	 4
  00404	6a 28		 push	 40			; 00000028H
  00406	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _FileBasicInfo$[ebp]
  0040c	50		 push	 eax
  0040d	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  00413	50		 push	 eax
  00414	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv872[ebp]
  0041a	ff 30		 push	 DWORD PTR [eax]
  0041c	ff d6		 call	 esi

; 255  : 
; 256  : 		if (NT_SUCCESS (ntStatus))

  0041e	3b c7		 cmp	 eax, edi
  00420	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax
  00423	0f 8c 87 09 00
	00		 jl	 $error$28105

; 257  : 		{
; 258  : 			if (mount->bPreserveTimestamp)

  00429	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  0042c	39 b8 7c 02 00
	00		 cmp	 DWORD PTR [eax+636], edi
  00432	74 6a		 je	 SHORT $LN83@GSTOpenVol

; 259  : 			{
; 260  : 				Extension->fileCreationTime = FileBasicInfo.CreationTime;

  00434	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _FileBasicInfo$[ebp]
  0043a	89 83 68 04 00
	00		 mov	 DWORD PTR [ebx+1128], eax
  00440	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _FileBasicInfo$[ebp+4]
  00446	89 83 6c 04 00
	00		 mov	 DWORD PTR [ebx+1132], eax

; 261  : 				Extension->fileLastAccessTime = FileBasicInfo.LastAccessTime;

  0044c	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _FileBasicInfo$[ebp+8]
  00452	89 83 70 04 00
	00		 mov	 DWORD PTR [ebx+1136], eax
  00458	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _FileBasicInfo$[ebp+12]
  0045e	89 83 74 04 00
	00		 mov	 DWORD PTR [ebx+1140], eax

; 262  : 				Extension->fileLastWriteTime = FileBasicInfo.LastWriteTime;

  00464	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _FileBasicInfo$[ebp+16]
  0046a	89 83 78 04 00
	00		 mov	 DWORD PTR [ebx+1144], eax
  00470	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _FileBasicInfo$[ebp+20]
  00476	89 83 7c 04 00
	00		 mov	 DWORD PTR [ebx+1148], eax

; 263  : 				Extension->fileLastChangeTime = FileBasicInfo.ChangeTime;

  0047c	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _FileBasicInfo$[ebp+24]
  00482	89 83 80 04 00
	00		 mov	 DWORD PTR [ebx+1152], eax
  00488	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _FileBasicInfo$[ebp+28]
  0048e	89 83 84 04 00
	00		 mov	 DWORD PTR [ebx+1156], eax

; 264  : 				Extension->bTimeStampValid = TRUE;

  00494	c7 83 88 04 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+1160], 1
$LN83@GSTOpenVol:

; 265  : 			}
; 266  : 
; 267  : 			ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 268  : 				&IoStatusBlock,
; 269  : 				&FileStandardInfo,
; 270  : 				sizeof (FileStandardInfo),
; 271  : 				FileStandardInformation);

  0049e	6a 05		 push	 5
  004a0	6a 18		 push	 24			; 00000018H
  004a2	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _FileStandardInfo$[ebp]
  004a8	50		 push	 eax
  004a9	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  004af	50		 push	 eax
  004b0	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv872[ebp]
  004b6	ff 30		 push	 DWORD PTR [eax]
  004b8	ff d6		 call	 esi

; 272  : 		}
; 273  : 
; 274  : 		if (!NT_SUCCESS (ntStatus))

  004ba	3b c7		 cmp	 eax, edi
  004bc	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax
  004bf	0f 8c eb 08 00
	00		 jl	 $error$28105

; 275  : 		{
; 276  : 			Dump ("ZwQueryInformationFile failed while opening file: NTSTATUS 0x%08x\n",
; 277  : 				ntStatus);
; 278  : 			goto error;
; 279  : 		}
; 280  : 
; 281  : 		lDiskLength.QuadPart = FileStandardInfo.EndOfFile.QuadPart;
; 282  : 
; 283  : 		if (FileBasicInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED)

  004c5	f7 85 d4 fe ff
	ff 00 08 00 00	 test	 DWORD PTR _FileBasicInfo$[ebp+32], 2048 ; 00000800H
  004cf	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _FileStandardInfo$[ebp+8]
  004d5	89 45 88	 mov	 DWORD PTR _lDiskLength$[ebp], eax
  004d8	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _FileStandardInfo$[ebp+12]
  004de	89 45 8c	 mov	 DWORD PTR _lDiskLength$[ebp+4], eax
  004e1	74 11		 je	 SHORT $LN81@GSTOpenVol

; 284  : 		{
; 285  : 			Dump ("File \"%ls\" is marked as compressed - not supported!\n", pwszMountVolume);
; 286  : 			mount->nReturnCode = ERR_COMPRESSION_NOT_SUPPORTED;

  004e3	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  004e6	c7 00 08 00 00
	00		 mov	 DWORD PTR [eax], 8
$LN162@GSTOpenVol:

; 287  : 			ntStatus = STATUS_SUCCESS;

  004ec	89 7d 98	 mov	 DWORD PTR _ntStatus$[ebp], edi

; 288  : 			goto error;

  004ef	e9 c9 08 00 00	 jmp	 $LN7@GSTOpenVol
$LN81@GSTOpenVol:

; 289  : 		}
; 290  : 
; 291  : 		ntStatus = ObReferenceObjectByHandle (Extension->hDeviceFile,
; 292  : 			FILE_ALL_ACCESS,
; 293  : 			*IoFileObjectType,
; 294  : 			KernelMode,
; 295  : 			&Extension->pfoDeviceFile,
; 296  : 			0);

  004f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _IoFileObjectType
  004f9	57		 push	 edi
  004fa	ff b5 60 ff ff
	ff		 push	 DWORD PTR tv870[ebp]
  00500	57		 push	 edi
  00501	ff 30		 push	 DWORD PTR [eax]
  00503	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv872[ebp]
  00509	68 ff 01 1f 00	 push	 2032127			; 001f01ffH
  0050e	ff 30		 push	 DWORD PTR [eax]
  00510	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24

; 297  : 
; 298  : 		if (!NT_SUCCESS (ntStatus))

  00516	3b c7		 cmp	 eax, edi
  00518	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax
  0051b	0f 8c 8f 08 00
	00		 jl	 $error$28105

; 299  : 		{
; 300  : 			goto error;
; 301  : 		}
; 302  : 
; 303  : 		/* Get the FSD device for the file (probably either NTFS or	FAT) */
; 304  : 		Extension->pFsdDevice = IoGetRelatedDeviceObject (Extension->pfoDeviceFile);

  00521	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv870[ebp]
  00527	ff 30		 push	 DWORD PTR [eax]
  00529	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetRelatedDeviceObject@4
  0052f	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 305  : 	}
; 306  : 	else

  00532	eb 46		 jmp	 SHORT $LN78@GSTOpenVol
$LN85@GSTOpenVol:

; 307  : 	{
; 308  : 		// Try to gain "raw" access to the partition in case there is a live filesystem on it (otherwise, 
; 309  : 		// the NTFS driver guards hidden sectors and prevents mounting using a backup header e.g. after the user 
; 310  : 		// accidentally quick-formats a dismounted partition-hosted GostCrypt volume as NTFS).
; 311  : 
; 312  : 		PFILE_OBJECT pfoTmpDeviceFile = NULL;
; 313  : 
; 314  : 		if (NT_SUCCESS (ObReferenceObjectByHandle (Extension->hDeviceFile, FILE_ALL_ACCESS, *IoFileObjectType, KernelMode, &pfoTmpDeviceFile, NULL))
; 315  : 			&& pfoTmpDeviceFile != NULL)

  00534	57		 push	 edi
  00535	8d 45 90	 lea	 eax, DWORD PTR _pfoTmpDeviceFile$28161[ebp]
  00538	50		 push	 eax
  00539	a1 00 00 00 00	 mov	 eax, DWORD PTR _IoFileObjectType
  0053e	57		 push	 edi
  0053f	89 7d 90	 mov	 DWORD PTR _pfoTmpDeviceFile$28161[ebp], edi
  00542	ff 30		 push	 DWORD PTR [eax]
  00544	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv872[ebp]
  0054a	68 ff 01 1f 00	 push	 2032127			; 001f01ffH
  0054f	ff 30		 push	 DWORD PTR [eax]
  00551	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  00557	85 c0		 test	 eax, eax
  00559	7c 1f		 jl	 SHORT $LN78@GSTOpenVol
  0055b	39 7d 90	 cmp	 DWORD PTR _pfoTmpDeviceFile$28161[ebp], edi
  0055e	74 1a		 je	 SHORT $LN78@GSTOpenVol

; 316  : 		{
; 317  : 			GSTFsctlCall (pfoTmpDeviceFile, FSCTL_ALLOW_EXTENDED_DASD_IO, NULL, 0, NULL, 0);

  00560	57		 push	 edi
  00561	57		 push	 edi
  00562	57		 push	 edi
  00563	57		 push	 edi
  00564	68 83 00 09 00	 push	 589955			; 00090083H
  00569	ff 75 90	 push	 DWORD PTR _pfoTmpDeviceFile$28161[ebp]
  0056c	e8 00 00 00 00	 call	 _GSTFsctlCall@24

; 318  : 			ObDereferenceObject (pfoTmpDeviceFile);

  00571	8b 4d 90	 mov	 ecx, DWORD PTR _pfoTmpDeviceFile$28161[ebp]
  00574	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4
$LN78@GSTOpenVol:

; 319  : 		}
; 320  : 	}
; 321  : 
; 322  : 	// Check volume size
; 323  : 	if (lDiskLength.QuadPart < GST_MIN_VOLUME_SIZE_LEGACY || lDiskLength.QuadPart > GST_MAX_VOLUME_SIZE)

  0057a	8b 55 88	 mov	 edx, DWORD PTR _lDiskLength$[ebp]
  0057d	8b 75 8c	 mov	 esi, DWORD PTR _lDiskLength$[ebp+4]
  00580	8b ca		 mov	 ecx, edx
  00582	81 c1 00 b6 ff
	ff		 add	 ecx, -18944		; ffffb600H
  00588	8b c6		 mov	 eax, esi
  0058a	83 d0 ff	 adc	 eax, -1
  0058d	3d ff ff 03 00	 cmp	 eax, 262143		; 0003ffffH
  00592	0f 87 0c 08 00
	00		 ja	 $LN76@GSTOpenVol
  00598	72 0c		 jb	 SHORT $LN140@GSTOpenVol
  0059a	81 f9 00 b6 ff
	ff		 cmp	 ecx, -18944		; ffffb600H
  005a0	0f 87 fe 07 00
	00		 ja	 $LN76@GSTOpenVol
$LN140@GSTOpenVol:

; 327  : 		goto error;
; 328  : 	}
; 329  : 
; 330  : 	Extension->DiskLength = lDiskLength.QuadPart;
; 331  : 	Extension->HostLength = lDiskLength.QuadPart;
; 332  : 
; 333  : 	readBuffer = GSTalloc (max (max (GST_VOLUME_HEADER_EFFECTIVE_SIZE, PAGE_SIZE), Extension->HostBytesPerSector));

  005a6	8b 8b 90 00 00
	00		 mov	 ecx, DWORD PTR [ebx+144]
  005ac	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  005b1	89 53 70	 mov	 DWORD PTR [ebx+112], edx
  005b4	89 73 74	 mov	 DWORD PTR [ebx+116], esi
  005b7	89 53 68	 mov	 DWORD PTR [ebx+104], edx
  005ba	89 73 6c	 mov	 DWORD PTR [ebx+108], esi
  005bd	3b c8		 cmp	 ecx, eax
  005bf	72 02		 jb	 SHORT $LN114@GSTOpenVol
  005c1	8b c1		 mov	 eax, ecx
$LN114@GSTOpenVol:
  005c3	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  005c8	50		 push	 eax
  005c9	57		 push	 edi
  005ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  005d0	89 45 80	 mov	 DWORD PTR _readBuffer$[ebp], eax

; 334  : 	if (readBuffer == NULL)

  005d3	3b c7		 cmp	 eax, edi
  005d5	75 0c		 jne	 SHORT $LN75@GSTOpenVol
$LN161@GSTOpenVol:

; 335  : 	{
; 336  : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  005d7	c7 45 98 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 337  : 		goto error;

  005de	e9 cd 07 00 00	 jmp	 $error$28105
$LN75@GSTOpenVol:

; 338  : 	}
; 339  : 
; 340  : 	// Go through all volume types (e.g., normal, hidden)
; 341  : 	for (volumeType = GST_VOLUME_TYPE_NORMAL;
; 342  : 		volumeType < GST_VOLUME_TYPE_COUNT;
; 343  : 		volumeType++)	

  005e3	89 7d 90	 mov	 DWORD PTR _volumeType$[ebp], edi
$LL147@GSTOpenVol:
  005e6	8b 75 94	 mov	 esi, DWORD PTR _mount$GSCopy$[ebp]
  005e9	ba 00 02 00 00	 mov	 edx, 512		; 00000200H

; 344  : 	{
; 345  : 		Dump ("Trying to open volume type %d\n", volumeType);
; 346  : 
; 347  : 		if (mount->bPartitionInInactiveSysEncScope
; 348  : 			&& volumeType == GST_VOLUME_TYPE_HIDDEN_LEGACY)

  005ee	39 be 80 02 00
	00		 cmp	 DWORD PTR [esi+640], edi
  005f4	0f 84 19 01 00
	00		 je	 $LN69@GSTOpenVol
  005fa	83 7d 90 02	 cmp	 DWORD PTR _volumeType$[ebp], 2
  005fe	0f 84 16 07 00
	00		 je	 $LN73@GSTOpenVol

; 349  : 			continue;		
; 350  : 
; 351  : 		/* Read the volume header */
; 352  : 
; 353  : 		if (!mount->bPartitionInInactiveSysEncScope
; 354  : 			|| (mount->bPartitionInInactiveSysEncScope && volumeType == GST_VOLUME_TYPE_HIDDEN))

  00604	83 7d 90 01	 cmp	 DWORD PTR _volumeType$[ebp], 1
  00608	0f 84 05 01 00
	00		 je	 $LN69@GSTOpenVol

; 399  : 		}
; 400  : 		else
; 401  : 		{
; 402  : 			// Header of a partition that is within the scope of system encryption
; 403  : 
; 404  : 			WCHAR parentDrivePath [47+1] = {0};

  0060e	33 c0		 xor	 eax, eax
  00610	6a 5e		 push	 94			; 0000005eH
  00612	66 89 45 9c	 mov	 WORD PTR _parentDrivePath$28199[ebp], ax
  00616	8d 45 9e	 lea	 eax, DWORD PTR _parentDrivePath$28199[ebp+2]
  00619	57		 push	 edi
  0061a	50		 push	 eax
  0061b	e8 00 00 00 00	 call	 _memset

; 405  : 			HANDLE hParentDeviceFile = NULL;
; 406  : 			UNICODE_STRING FullParentPath;
; 407  : 			OBJECT_ATTRIBUTES oaParentFileAttributes;
; 408  : 			LARGE_INTEGER parentKeyDataOffset;
; 409  : 
; 410  : 			_snwprintf (parentDrivePath,
; 411  : 				sizeof (parentDrivePath) / sizeof (WCHAR) - 1,
; 412  : 				WIDE ("\\Device\\Harddisk%d\\Partition0"),
; 413  : 				mount->nPartitionInInactiveSysEncScopeDriveNo);

  00620	ff b6 84 02 00
	00		 push	 DWORD PTR [esi+644]
  00626	8d 45 9c	 lea	 eax, DWORD PTR _parentDrivePath$28199[ebp]
  00629	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@
  0062e	6a 2f		 push	 47			; 0000002fH
  00630	50		 push	 eax
  00631	89 7d 84	 mov	 DWORD PTR _hParentDeviceFile$28200[ebp], edi
  00634	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snwprintf
  0063a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 414  : 
; 415  : 			Dump ("Mounting partition within scope of system encryption (reading key data from: %ls)\n", parentDrivePath);
; 416  : 
; 417  : 			RtlInitUnicodeString (&FullParentPath, parentDrivePath);

  0063d	8d 45 9c	 lea	 eax, DWORD PTR _parentDrivePath$28199[ebp]
  00640	50		 push	 eax
  00641	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _FullParentPath$28202[ebp]
  00647	50		 push	 eax
  00648	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 418  : 			InitializeObjectAttributes (&oaParentFileAttributes, &FullParentPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,	NULL, NULL);
; 419  : 
; 420  : 			ntStatus = ZwCreateFile (&hParentDeviceFile,
; 421  : 				GENERIC_READ | SYNCHRONIZE,
; 422  : 				&oaParentFileAttributes,
; 423  : 				&IoStatusBlock,
; 424  : 				NULL,
; 425  : 				FILE_ATTRIBUTE_NORMAL |
; 426  : 				FILE_ATTRIBUTE_SYSTEM,
; 427  : 				FILE_SHARE_READ | FILE_SHARE_WRITE,
; 428  : 				FILE_OPEN,
; 429  : 				FILE_RANDOM_ACCESS |
; 430  : 				FILE_WRITE_THROUGH |
; 431  : 				FILE_NO_INTERMEDIATE_BUFFERING |
; 432  : 				FILE_SYNCHRONOUS_IO_NONALERT,
; 433  : 				NULL,
; 434  : 				0);

  0064e	57		 push	 edi
  0064f	57		 push	 edi
  00650	68 2a 08 00 00	 push	 2090			; 0000082aH
  00655	6a 01		 push	 1
  00657	6a 03		 push	 3
  00659	68 84 00 00 00	 push	 132			; 00000084H
  0065e	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _FullParentPath$28202[ebp]
  00664	89 85 0c ff ff
	ff		 mov	 DWORD PTR _oaParentFileAttributes$28203[ebp+8], eax
  0066a	57		 push	 edi
  0066b	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  00671	50		 push	 eax
  00672	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _oaParentFileAttributes$28203[ebp]
  00678	50		 push	 eax
  00679	68 00 00 10 80	 push	 -2146435072		; 80100000H
  0067e	8d 45 84	 lea	 eax, DWORD PTR _hParentDeviceFile$28200[ebp]
  00681	50		 push	 eax
  00682	c7 85 04 ff ff
	ff 18 00 00 00	 mov	 DWORD PTR _oaParentFileAttributes$28203[ebp], 24 ; 00000018H
  0068c	89 bd 08 ff ff
	ff		 mov	 DWORD PTR _oaParentFileAttributes$28203[ebp+4], edi
  00692	c7 85 10 ff ff
	ff 40 02 00 00	 mov	 DWORD PTR _oaParentFileAttributes$28203[ebp+12], 576 ; 00000240H
  0069c	89 bd 14 ff ff
	ff		 mov	 DWORD PTR _oaParentFileAttributes$28203[ebp+16], edi
  006a2	89 bd 18 ff ff
	ff		 mov	 DWORD PTR _oaParentFileAttributes$28203[ebp+20], edi
  006a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44

; 435  : 
; 436  : 			if (!NT_SUCCESS (ntStatus))

  006ae	3b c7		 cmp	 eax, edi
  006b0	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax
  006b3	0f 8c 73 06 00
	00		 jl	 $LN130@GSTOpenVol

; 444  : 			}
; 445  : 
; 446  : 			parentKeyDataOffset.QuadPart = GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET;
; 447  : 
; 448  : 			ntStatus = ZwReadFile (hParentDeviceFile,
; 449  : 				NULL,
; 450  : 				NULL,
; 451  : 				NULL,
; 452  : 				&IoStatusBlock,
; 453  : 				readBuffer,
; 454  : 				max (GST_VOLUME_HEADER_EFFECTIVE_SIZE, Extension->HostBytesPerSector),
; 455  : 				&parentKeyDataOffset,
; 456  : 				NULL);

  006b9	8b 8b 90 00 00
	00		 mov	 ecx, DWORD PTR [ebx+144]
  006bf	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  006c4	c7 85 34 ff ff
	ff 00 7c 00 00	 mov	 DWORD PTR _parentKeyDataOffset$28204[ebp], 31744 ; 00007c00H
  006ce	89 bd 38 ff ff
	ff		 mov	 DWORD PTR _parentKeyDataOffset$28204[ebp+4], edi
  006d4	3b c8		 cmp	 ecx, eax
  006d6	72 02		 jb	 SHORT $LN124@GSTOpenVol
  006d8	8b c1		 mov	 eax, ecx
$LN124@GSTOpenVol:
  006da	57		 push	 edi
  006db	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _parentKeyDataOffset$28204[ebp]
  006e1	51		 push	 ecx
  006e2	50		 push	 eax
  006e3	ff 75 80	 push	 DWORD PTR _readBuffer$[ebp]
  006e6	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  006ec	50		 push	 eax
  006ed	57		 push	 edi
  006ee	57		 push	 edi
  006ef	57		 push	 edi
  006f0	ff 75 84	 push	 DWORD PTR _hParentDeviceFile$28200[ebp]
  006f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
  006f9	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 457  : 
; 458  : 			if (hParentDeviceFile != NULL)

  006fc	39 7d 84	 cmp	 DWORD PTR _hParentDeviceFile$28200[ebp], edi
  006ff	0f 84 f9 00 00
	00		 je	 $LN56@GSTOpenVol

; 459  : 				ZwClose (hParentDeviceFile);

  00705	ff 75 84	 push	 DWORD PTR _hParentDeviceFile$28200[ebp]
  00708	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
  0070e	e9 eb 00 00 00	 jmp	 $LN56@GSTOpenVol
$LN69@GSTOpenVol:

; 355  : 		{
; 356  : 			// Header of a volume that is not within the scope of system encryption, or
; 357  : 			// header of a system hidden volume (containing a hidden OS)
; 358  : 
; 359  : 			LARGE_INTEGER headerOffset;
; 360  : 
; 361  : 			if (mount->UseBackupHeader && lDiskLength.QuadPart <= GST_TOTAL_VOLUME_HEADERS_SIZE)

  00713	8b 8e d8 02 00
	00		 mov	 ecx, DWORD PTR [esi+728]
  00719	3b cf		 cmp	 ecx, edi
  0071b	74 18		 je	 SHORT $LN154@GSTOpenVol
  0071d	39 7d 8c	 cmp	 DWORD PTR _lDiskLength$[ebp+4], edi
  00720	0f 8c f4 05 00
	00		 jl	 $LN73@GSTOpenVol
  00726	7f 0d		 jg	 SHORT $LN154@GSTOpenVol
  00728	81 7d 88 00 00
	04 00		 cmp	 DWORD PTR _lDiskLength$[ebp], 262144 ; 00040000H
  0072f	0f 86 e5 05 00
	00		 jbe	 $LN73@GSTOpenVol
$LN154@GSTOpenVol:

; 362  : 				continue;
; 363  : 
; 364  : 			switch (volumeType)

  00735	8b 45 90	 mov	 eax, DWORD PTR _volumeType$[ebp]
  00738	2b c7		 sub	 eax, edi
  0073a	74 5f		 je	 SHORT $LN65@GSTOpenVol
  0073c	48		 dec	 eax
  0073d	74 2a		 je	 SHORT $LN64@GSTOpenVol
  0073f	48		 dec	 eax
  00740	0f 85 80 00 00
	00		 jne	 $LN116@GSTOpenVol

; 376  : 
; 377  : 			case GST_VOLUME_TYPE_HIDDEN_LEGACY:
; 378  : 				if (mount->UseBackupHeader)

  00746	3b cf		 cmp	 ecx, edi
  00748	0f 85 cc 05 00
	00		 jne	 $LN73@GSTOpenVol

; 379  : 					continue;
; 380  : 
; 381  : 				if (bRawDevice && Extension->HostBytesPerSector != GST_SECTOR_SIZE_LEGACY)

  0074e	39 7d 18	 cmp	 DWORD PTR _bRawDevice$[ebp], edi
  00751	74 0c		 je	 SHORT $LN60@GSTOpenVol
  00753	39 93 90 00 00
	00		 cmp	 DWORD PTR [ebx+144], edx
  00759	0f 85 bb 05 00
	00		 jne	 $LN73@GSTOpenVol
$LN60@GSTOpenVol:

; 382  : 					continue;
; 383  : 
; 384  : 				headerOffset.QuadPart = lDiskLength.QuadPart - GST_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  0075f	8b 45 88	 mov	 eax, DWORD PTR _lDiskLength$[ebp]
  00762	2d 00 06 00 00	 sub	 eax, 1536		; 00000600H

; 385  : 				break;

  00767	eb 3e		 jmp	 SHORT $LN159@GSTOpenVol
$LN64@GSTOpenVol:

; 368  : 				break;
; 369  : 
; 370  : 			case GST_VOLUME_TYPE_HIDDEN:
; 371  : 				if (lDiskLength.QuadPart <= GST_VOLUME_HEADER_GROUP_SIZE)

  00769	39 7d 8c	 cmp	 DWORD PTR _lDiskLength$[ebp+4], edi
  0076c	0f 8c a8 05 00
	00		 jl	 $LN73@GSTOpenVol
  00772	7f 0d		 jg	 SHORT $LN155@GSTOpenVol
  00774	81 7d 88 00 00
	02 00		 cmp	 DWORD PTR _lDiskLength$[ebp], 131072 ; 00020000H
  0077b	0f 86 99 05 00
	00		 jbe	 $LN73@GSTOpenVol
$LN155@GSTOpenVol:

; 372  : 					continue;
; 373  : 
; 374  : 				headerOffset.QuadPart = mount->UseBackupHeader ? lDiskLength.QuadPart - GST_HIDDEN_VOLUME_HEADER_OFFSET : GST_HIDDEN_VOLUME_HEADER_OFFSET;

  00781	3b cf		 cmp	 ecx, edi
  00783	74 0a		 je	 SHORT $LN117@GSTOpenVol
  00785	8b 45 88	 mov	 eax, DWORD PTR _lDiskLength$[ebp]
  00788	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  0078d	eb 18		 jmp	 SHORT $LN159@GSTOpenVol
$LN117@GSTOpenVol:
  0078f	c7 85 68 ff ff
	ff 00 00 01 00	 mov	 DWORD PTR _headerOffset$28182[ebp], 65536 ; 00010000H

; 375  : 				break;

  00799	eb 25		 jmp	 SHORT $LN158@GSTOpenVol
$LN65@GSTOpenVol:

; 365  : 			{
; 366  : 			case GST_VOLUME_TYPE_NORMAL:
; 367  : 				headerOffset.QuadPart = mount->UseBackupHeader ? lDiskLength.QuadPart - GST_VOLUME_HEADER_GROUP_SIZE : GST_VOLUME_HEADER_OFFSET;

  0079b	3b cf		 cmp	 ecx, edi
  0079d	74 1b		 je	 SHORT $LN115@GSTOpenVol
  0079f	8b 45 88	 mov	 eax, DWORD PTR _lDiskLength$[ebp]
  007a2	2d 00 00 02 00	 sub	 eax, 131072		; 00020000H
$LN159@GSTOpenVol:
  007a7	8b 4d 8c	 mov	 ecx, DWORD PTR _lDiskLength$[ebp+4]
  007aa	1b cf		 sbb	 ecx, edi
  007ac	89 85 68 ff ff
	ff		 mov	 DWORD PTR _headerOffset$28182[ebp], eax
  007b2	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _headerOffset$28182[ebp+4], ecx
  007b8	eb 0c		 jmp	 SHORT $LN116@GSTOpenVol
$LN115@GSTOpenVol:
  007ba	89 bd 68 ff ff
	ff		 mov	 DWORD PTR _headerOffset$28182[ebp], edi
$LN158@GSTOpenVol:
  007c0	89 bd 6c ff ff
	ff		 mov	 DWORD PTR _headerOffset$28182[ebp+4], edi
$LN116@GSTOpenVol:

; 386  : 			}
; 387  : 
; 388  : 			Dump ("Reading volume header at %I64d\n", headerOffset.QuadPart);
; 389  : 
; 390  : 			ntStatus = ZwReadFile (Extension->hDeviceFile,
; 391  : 			NULL,
; 392  : 			NULL,
; 393  : 			NULL,
; 394  : 			&IoStatusBlock,
; 395  : 			readBuffer,
; 396  : 			bRawDevice ? max (GST_VOLUME_HEADER_EFFECTIVE_SIZE, Extension->HostBytesPerSector) : GST_VOLUME_HEADER_EFFECTIVE_SIZE,
; 397  : 			&headerOffset,
; 398  : 			NULL);

  007c6	39 7d 18	 cmp	 DWORD PTR _bRawDevice$[ebp], edi
  007c9	74 0a		 je	 SHORT $LN121@GSTOpenVol
  007cb	8b 83 90 00 00
	00		 mov	 eax, DWORD PTR [ebx+144]
  007d1	3b c2		 cmp	 eax, edx
  007d3	73 02		 jae	 SHORT $LN122@GSTOpenVol
$LN121@GSTOpenVol:
  007d5	8b c2		 mov	 eax, edx
$LN122@GSTOpenVol:
  007d7	57		 push	 edi
  007d8	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _headerOffset$28182[ebp]
  007de	51		 push	 ecx
  007df	50		 push	 eax
  007e0	ff 75 80	 push	 DWORD PTR _readBuffer$[ebp]
  007e3	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  007e9	50		 push	 eax
  007ea	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv872[ebp]
  007f0	57		 push	 edi
  007f1	57		 push	 edi
  007f2	57		 push	 edi
  007f3	ff 30		 push	 DWORD PTR [eax]
  007f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
  007fb	89 45 98	 mov	 DWORD PTR _ntStatus$[ebp], eax
$LN56@GSTOpenVol:

; 460  : 		}
; 461  : 
; 462  : 		if (!NT_SUCCESS (ntStatus) && ntStatus != STATUS_END_OF_FILE)

  007fe	39 7d 98	 cmp	 DWORD PTR _ntStatus$[ebp], edi
  00801	7d 10		 jge	 SHORT $LN152@GSTOpenVol
  00803	81 7d 98 11 00
	00 c0		 cmp	 DWORD PTR _ntStatus$[ebp], -1073741807 ; c0000011H
  0080a	0f 85 a0 05 00
	00		 jne	 $error$28105
  00810	8b 75 94	 mov	 esi, DWORD PTR _mount$GSCopy$[ebp]
$LN152@GSTOpenVol:

; 463  : 		{
; 464  : 			Dump ("Read failed: NTSTATUS 0x%08x\n", ntStatus);
; 465  : 			goto error;
; 466  : 		}
; 467  : 
; 468  : 		if (ntStatus == STATUS_END_OF_FILE || IoStatusBlock.Information < GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  00813	81 7d 98 11 00
	00 c0		 cmp	 DWORD PTR _ntStatus$[ebp], -1073741807 ; c0000011H
  0081a	74 0c		 je	 SHORT $LN53@GSTOpenVol
  0081c	81 bd 58 ff ff
	ff 00 02 00 00	 cmp	 DWORD PTR _IoStatusBlock$[ebp+4], 512 ; 00000200H
  00826	73 11		 jae	 SHORT $LN54@GSTOpenVol
$LN53@GSTOpenVol:

; 469  : 		{
; 470  : 			Dump ("Read didn't read enough data\n");
; 471  : 
; 472  : 			// If FSCTL_ALLOW_EXTENDED_DASD_IO failed and there is a live filesystem on the partition, then the
; 473  : 			// filesystem driver may report EOF when we are reading hidden sectors (when the filesystem is 
; 474  : 			// shorter than the partition). This can happen for example after the user quick-formats a dismounted
; 475  : 			// partition-hosted GostCrypt volume and then tries to mount the volume using the embedded backup header.
; 476  : 			memset (readBuffer, 0, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00828	68 00 02 00 00	 push	 512			; 00000200H
  0082d	57		 push	 edi
  0082e	ff 75 80	 push	 DWORD PTR _readBuffer$[ebp]
  00831	e8 00 00 00 00	 call	 _memset
  00836	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@GSTOpenVol:

; 477  : 		}
; 478  : 
; 479  : 		/* Attempt to recognize the volume (decrypt the header) */
; 480  : 
; 481  : 		ReadVolumeHeaderRecoveryMode = mount->RecoveryMode;

  00839	8b 86 dc 02 00
	00		 mov	 eax, DWORD PTR [esi+732]
  0083f	a3 00 00 00 00	 mov	 DWORD PTR _ReadVolumeHeaderRecoveryMode, eax

; 482  : 
; 483  : 		if ((volumeType == GST_VOLUME_TYPE_HIDDEN || volumeType == GST_VOLUME_TYPE_HIDDEN_LEGACY) && mount->bProtectHiddenVolume)

  00844	33 c0		 xor	 eax, eax
  00846	40		 inc	 eax
  00847	39 45 90	 cmp	 DWORD PTR _volumeType$[ebp], eax
  0084a	74 06		 je	 SHORT $LN51@GSTOpenVol
  0084c	83 7d 90 02	 cmp	 DWORD PTR _volumeType$[ebp], 2
  00850	75 22		 jne	 SHORT $LN52@GSTOpenVol
$LN51@GSTOpenVol:
  00852	39 be 8c 02 00
	00		 cmp	 DWORD PTR [esi+652], edi
  00858	74 1a		 je	 SHORT $LN52@GSTOpenVol

; 484  : 		{
; 485  : 			mount->nReturnCode = ReadVolumeHeaderWCache (
; 486  : 				FALSE,
; 487  : 				mount->bCache,
; 488  : 				readBuffer,
; 489  : 				&mount->ProtectedHidVolPassword,
; 490  : 				&tmpCryptoInfo);

  0085a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _tmpCryptoInfo$[ebp]
  00860	50		 push	 eax
  00861	8d 86 90 02 00
	00		 lea	 eax, DWORD PTR [esi+656]
  00867	50		 push	 eax
  00868	ff 75 80	 push	 DWORD PTR _readBuffer$[ebp]
  0086b	ff b6 60 02 00
	00		 push	 DWORD PTR [esi+608]
  00871	57		 push	 edi

; 491  : 		}
; 492  : 		else

  00872	eb 24		 jmp	 SHORT $LN160@GSTOpenVol
$LN52@GSTOpenVol:

; 493  : 		{
; 494  : 			mount->nReturnCode = ReadVolumeHeaderWCache (
; 495  : 				mount->bPartitionInInactiveSysEncScope && volumeType == GST_VOLUME_TYPE_NORMAL,
; 496  : 				mount->bCache,
; 497  : 				readBuffer,
; 498  : 				&mount->VolumePassword,
; 499  : 				&Extension->cryptoInfo);

  00874	39 be 80 02 00
	00		 cmp	 DWORD PTR [esi+640], edi
  0087a	74 05		 je	 SHORT $LN125@GSTOpenVol
  0087c	39 7d 90	 cmp	 DWORD PTR _volumeType$[ebp], edi
  0087f	74 02		 je	 SHORT $LN126@GSTOpenVol
$LN125@GSTOpenVol:
  00881	33 c0		 xor	 eax, eax
$LN126@GSTOpenVol:
  00883	8d 4b 60	 lea	 ecx, DWORD PTR [ebx+96]
  00886	51		 push	 ecx
  00887	8d 8e 18 02 00
	00		 lea	 ecx, DWORD PTR [esi+536]
  0088d	51		 push	 ecx
  0088e	ff 75 80	 push	 DWORD PTR _readBuffer$[ebp]
  00891	ff b6 60 02 00
	00		 push	 DWORD PTR [esi+608]
  00897	50		 push	 eax
$LN160@GSTOpenVol:
  00898	e8 00 00 00 00	 call	 _ReadVolumeHeaderWCache@20
  0089d	89 06		 mov	 DWORD PTR [esi], eax

; 500  : 		}
; 501  : 
; 502  : 		ReadVolumeHeaderRecoveryMode = FALSE;

  0089f	89 3d 00 00 00
	00		 mov	 DWORD PTR _ReadVolumeHeaderRecoveryMode, edi

; 503  : 
; 504  : 		if (mount->nReturnCode == 0 || mount->nReturnCode == ERR_CIPHER_INIT_WEAK_KEY)

  008a5	8b 06		 mov	 eax, DWORD PTR [esi]
  008a7	3b c7		 cmp	 eax, edi
  008a9	74 2c		 je	 SHORT $LN48@GSTOpenVol
  008ab	83 f8 12	 cmp	 eax, 18			; 00000012H
  008ae	74 27		 je	 SHORT $LN48@GSTOpenVol

; 699  : 			}
; 700  : 		}
; 701  : 		else if ((mount->bProtectHiddenVolume && volumeType == GST_VOLUME_TYPE_NORMAL)
; 702  : 			  || mount->nReturnCode != ERR_PASSWORD_WRONG)

  008b0	39 be 8c 02 00
	00		 cmp	 DWORD PTR [esi+652], edi
  008b6	74 05		 je	 SHORT $LN10@GSTOpenVol
  008b8	39 7d 90	 cmp	 DWORD PTR _volumeType$[ebp], edi
  008bb	74 09		 je	 SHORT $LN72@GSTOpenVol
$LN10@GSTOpenVol:
  008bd	83 f8 03	 cmp	 eax, 3
  008c0	0f 84 54 04 00
	00		 je	 $LN73@GSTOpenVol
$LN72@GSTOpenVol:

; 703  : 		{
; 704  : 			 /* If we are not supposed to protect a hidden volume, the only error that is
; 705  : 				tolerated is ERR_PASSWORD_WRONG (to allow mounting a possible hidden volume). 
; 706  : 
; 707  : 				If we _are_ supposed to protect a hidden volume, we do not tolerate any error
; 708  : 				(both volume headers must be successfully decrypted). */
; 709  : 
; 710  : 			break;
; 711  : 		}
; 712  : 	}
; 713  : 
; 714  : 	/* Failed due to some non-OS reason so we drop through and return NT
; 715  : 	   SUCCESS then nReturnCode is checked later in user-mode */
; 716  : 
; 717  : 	if (mount->nReturnCode == ERR_OUTOFMEMORY)

  008c6	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  008c9	83 38 02	 cmp	 DWORD PTR [eax], 2
  008cc	0f 85 db 04 00
	00		 jne	 $LN9@GSTOpenVol

; 718  : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 719  : 	else

  008d2	e9 00 fd ff ff	 jmp	 $LN161@GSTOpenVol
$LN48@GSTOpenVol:

; 505  : 		{
; 506  : 			/* Volume header successfully decrypted */
; 507  : 
; 508  : 			Dump ("Volume header decrypted\n");
; 509  : 			Dump ("Required program version = %x\n", (int) Extension->cryptoInfo->RequiredProgramVersion);
; 510  : 			Dump ("Legacy volume = %d\n", (int) Extension->cryptoInfo->LegacyVolume);
; 511  : 
; 512  : 			if (IsHiddenSystemRunning() && !Extension->cryptoInfo->hiddenVolume)

  008d7	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  008dc	85 c0		 test	 eax, eax
  008de	74 20		 je	 SHORT $LN47@GSTOpenVol
  008e0	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  008e3	39 b8 48 04 00
	00		 cmp	 DWORD PTR [eax+1096], edi
  008e9	75 15		 jne	 SHORT $LN47@GSTOpenVol

; 513  : 			{
; 514  : 				Extension->bReadOnly = mount->bMountReadOnly = TRUE;

  008eb	33 c0		 xor	 eax, eax
  008ed	40		 inc	 eax
  008ee	89 86 6c 02 00
	00		 mov	 DWORD PTR [esi+620], eax
  008f4	89 83 48 02 00
	00		 mov	 DWORD PTR [ebx+584], eax

; 515  : 				HiddenSysLeakProtectionCount++;

  008fa	ff 05 00 00 00
	00		 inc	 DWORD PTR _HiddenSysLeakProtectionCount
$LN47@GSTOpenVol:

; 516  : 			}
; 517  : 
; 518  : 			Extension->cryptoInfo->bProtectHiddenVolume = FALSE;

  00900	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00903	89 b8 a8 1e 00
	00		 mov	 DWORD PTR [eax+7848], edi

; 519  : 			Extension->cryptoInfo->bHiddenVolProtectionAction = FALSE;

  00909	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  0090c	89 b8 ac 1e 00
	00		 mov	 DWORD PTR [eax+7852], edi

; 520  : 
; 521  : 			Extension->cryptoInfo->bPartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;

  00912	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00915	8b 8e 80 02 00
	00		 mov	 ecx, DWORD PTR [esi+640]
  0091b	89 88 d0 1e 00
	00		 mov	 DWORD PTR [eax+7888], ecx

; 522  : 
; 523  : 			if (volumeType == GST_VOLUME_TYPE_NORMAL)

  00921	39 7d 90	 cmp	 DWORD PTR _volumeType$[ebp], edi
  00924	0f 85 cf 00 00
	00		 jne	 $LN39@GSTOpenVol

; 524  : 			{
; 525  : 				if (mount->bPartitionInInactiveSysEncScope)
; 526  : 				{
; 527  : 					if (Extension->cryptoInfo->EncryptedAreaStart.Value > (unsigned __int64) partitionStartingOffset
; 528  : 						|| Extension->cryptoInfo->EncryptedAreaStart.Value + Extension->cryptoInfo->VolumeSize.Value <= (unsigned __int64) partitionStartingOffset)

  0092a	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  0092d	39 be 80 02 00
	00		 cmp	 DWORD PTR [esi+640], edi
  00933	0f 84 93 00 00
	00		 je	 $LN45@GSTOpenVol
  00939	8b 90 fc 1e 00
	00		 mov	 edx, DWORD PTR [eax+7932]
  0093f	8b 88 f8 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7928]
  00945	89 95 48 ff ff
	ff		 mov	 DWORD PTR tv1021[ebp+4], edx
  0094b	3b 95 74 ff ff
	ff		 cmp	 edx, DWORD PTR _partitionStartingOffset$[ebp+4]
  00951	0f 87 e5 03 00
	00		 ja	 $LN43@GSTOpenVol
  00957	72 0c		 jb	 SHORT $LN143@GSTOpenVol
  00959	3b 8d 70 ff ff
	ff		 cmp	 ecx, DWORD PTR _partitionStartingOffset$[ebp]
  0095f	0f 87 d7 03 00
	00		 ja	 $LN43@GSTOpenVol
$LN143@GSTOpenVol:
  00965	03 88 f0 1e 00
	00		 add	 ecx, DWORD PTR [eax+7920]
  0096b	8b 90 f4 1e 00
	00		 mov	 edx, DWORD PTR [eax+7924]
  00971	89 8d fc fe ff
	ff		 mov	 DWORD PTR tv745[ebp], ecx
  00977	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv1021[ebp+4]
  0097d	13 ca		 adc	 ecx, edx
  0097f	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv1025[ebp+4], edx
  00985	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv745[ebp]
  0098b	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _partitionStartingOffset$[ebp+4]
  00991	0f 82 a5 03 00
	00		 jb	 $LN43@GSTOpenVol
  00997	77 0c		 ja	 SHORT $LN144@GSTOpenVol
  00999	3b 95 70 ff ff
	ff		 cmp	 edx, DWORD PTR _partitionStartingOffset$[ebp]
  0099f	0f 86 97 03 00
	00		 jbe	 $LN43@GSTOpenVol
$LN144@GSTOpenVol:

; 534  : 					}
; 535  : 
; 536  : 					if (Extension->cryptoInfo->EncryptedAreaLength.Value != Extension->cryptoInfo->VolumeSize.Value)

  009a5	8b 88 00 1f 00
	00		 mov	 ecx, DWORD PTR [eax+7936]
  009ab	3b 88 f0 1e 00
	00		 cmp	 ecx, DWORD PTR [eax+7920]
  009b1	75 0e		 jne	 SHORT $LN133@GSTOpenVol
  009b3	8b 80 04 1f 00
	00		 mov	 eax, DWORD PTR [eax+7940]
  009b9	3b 85 50 ff ff
	ff		 cmp	 eax, DWORD PTR tv1025[ebp+4]
  009bf	74 38		 je	 SHORT $LN39@GSTOpenVol
$LN133@GSTOpenVol:

; 537  : 					{
; 538  : 						// Partial encryption is not supported for volumes mounted as regular
; 539  : 						mount->nReturnCode = ERR_ENCRYPTION_NOT_COMPLETED;

  009c1	c7 06 1d 00 00
	00		 mov	 DWORD PTR [esi], 29	; 0000001dH

; 540  : 						ntStatus = STATUS_SUCCESS;
; 541  : 						goto error;

  009c7	e9 20 fb ff ff	 jmp	 $LN162@GSTOpenVol
$LN45@GSTOpenVol:

; 542  : 					}
; 543  : 				}
; 544  : 				else if (Extension->cryptoInfo->HeaderFlags & GST_HEADER_FLAG_NONSYS_INPLACE_ENC)

  009cc	f6 80 08 1f 00
	00 02		 test	 BYTE PTR [eax+7944], 2
  009d3	74 24		 je	 SHORT $LN39@GSTOpenVol

; 545  : 				{
; 546  : 					if (Extension->cryptoInfo->EncryptedAreaLength.Value != Extension->cryptoInfo->VolumeSize.Value)

  009d5	8b 88 00 1f 00
	00		 mov	 ecx, DWORD PTR [eax+7936]
  009db	3b 88 f0 1e 00
	00		 cmp	 ecx, DWORD PTR [eax+7920]
  009e1	0f 85 60 03 00
	00		 jne	 $LN134@GSTOpenVol
  009e7	8b 88 04 1f 00
	00		 mov	 ecx, DWORD PTR [eax+7940]
  009ed	3b 88 f4 1e 00
	00		 cmp	 ecx, DWORD PTR [eax+7924]
  009f3	0f 85 4e 03 00
	00		 jne	 $LN134@GSTOpenVol
$LN39@GSTOpenVol:

; 552  : 					}
; 553  : 				}
; 554  : 			}
; 555  : 
; 556  : 			Extension->cryptoInfo->FirstDataUnitNo.Value = 0;

  009f9	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  009fc	89 b8 d8 1e 00
	00		 mov	 DWORD PTR [eax+7896], edi
  00a02	89 b8 dc 1e 00
	00		 mov	 DWORD PTR [eax+7900], edi

; 557  : 
; 558  : 			if (Extension->cryptoInfo->hiddenVolume && IsHiddenSystemRunning())

  00a08	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00a0b	39 b8 48 04 00
	00		 cmp	 DWORD PTR [eax+1096], edi
  00a11	74 43		 je	 SHORT $LN153@GSTOpenVol
  00a13	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  00a18	85 c0		 test	 eax, eax
  00a1a	74 3a		 je	 SHORT $LN153@GSTOpenVol

; 559  : 			{
; 560  : 				// Prevent mount of a hidden system partition if the system hosted on it is currently running
; 561  : 				if (memcmp (Extension->cryptoInfo->master_keydata, GetSystemDriveCryptoInfo()->master_keydata, EAGetKeySize (Extension->cryptoInfo->ea)) == 0)

  00a1c	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00a1f	ff 30		 push	 DWORD PTR [eax]
  00a21	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00a26	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv969[ebp], eax
  00a2c	e8 00 00 00 00	 call	 _GetSystemDriveCryptoInfo@0
  00a31	8b 73 60	 mov	 esi, DWORD PTR [ebx+96]
  00a34	8b f8		 mov	 edi, eax
  00a36	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv969[ebp]
  00a3c	81 c7 50 1c 00
	00		 add	 edi, 7248		; 00001c50H
  00a42	81 c6 50 1c 00
	00		 add	 esi, 7248		; 00001c50H
  00a48	8b c8		 mov	 ecx, eax
  00a4a	33 c0		 xor	 eax, eax
  00a4c	f3 a6		 repe cmpsb
  00a4e	0f 84 fe 02 00
	00		 je	 $LN135@GSTOpenVol
  00a54	33 ff		 xor	 edi, edi
$LN153@GSTOpenVol:

; 566  : 				}
; 567  : 			}
; 568  : 
; 569  : 			switch (volumeType)

  00a56	8b 45 90	 mov	 eax, DWORD PTR _volumeType$[ebp]
  00a59	3b c7		 cmp	 eax, edi
  00a5b	0f 84 1d 01 00
	00		 je	 $LN34@GSTOpenVol
  00a61	0f 8e c6 01 00
	00		 jle	 $LN30@GSTOpenVol
  00a67	83 f8 02	 cmp	 eax, 2
  00a6a	0f 8f bd 01 00
	00		 jg	 $LN30@GSTOpenVol

; 590  : 				}
; 591  : 
; 592  : 				break;
; 593  : 
; 594  : 			case GST_VOLUME_TYPE_HIDDEN:
; 595  : 			case GST_VOLUME_TYPE_HIDDEN_LEGACY:
; 596  : 
; 597  : 				cryptoInfoPtr = mount->bProtectHiddenVolume ? tmpCryptoInfo : Extension->cryptoInfo;

  00a70	8b 4d 94	 mov	 ecx, DWORD PTR _mount$GSCopy$[ebp]
  00a73	39 b9 8c 02 00
	00		 cmp	 DWORD PTR [ecx+652], edi
  00a79	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _tmpCryptoInfo$[ebp]
  00a7f	75 03		 jne	 SHORT $LN128@GSTOpenVol
  00a81	8b 4b 60	 mov	 ecx, DWORD PTR [ebx+96]
$LN128@GSTOpenVol:

; 598  : 
; 599  : 				if (volumeType == GST_VOLUME_TYPE_HIDDEN_LEGACY)

  00a84	83 f8 02	 cmp	 eax, 2

; 600  : 					Extension->cryptoInfo->hiddenVolumeOffset = lDiskLength.QuadPart - cryptoInfoPtr->hiddenVolumeSize - GST_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  00a87	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00a8a	75 29		 jne	 SHORT $LN28@GSTOpenVol
  00a8c	8b 55 88	 mov	 edx, DWORD PTR _lDiskLength$[ebp]
  00a8f	2b 91 b8 1e 00
	00		 sub	 edx, DWORD PTR [ecx+7864]
  00a95	8b 75 8c	 mov	 esi, DWORD PTR _lDiskLength$[ebp+4]
  00a98	1b b1 bc 1e 00
	00		 sbb	 esi, DWORD PTR [ecx+7868]
  00a9e	81 c2 00 fa ff
	ff		 add	 edx, -1536		; fffffa00H
  00aa4	83 d6 ff	 adc	 esi, -1
  00aa7	89 90 c0 1e 00
	00		 mov	 DWORD PTR [eax+7872], edx
  00aad	89 b0 c4 1e 00
	00		 mov	 DWORD PTR [eax+7876], esi

; 601  : 				else

  00ab3	eb 18		 jmp	 SHORT $LN27@GSTOpenVol
$LN28@GSTOpenVol:

; 602  : 					Extension->cryptoInfo->hiddenVolumeOffset = cryptoInfoPtr->EncryptedAreaStart.Value;

  00ab5	8b 91 f8 1e 00
	00		 mov	 edx, DWORD PTR [ecx+7928]
  00abb	89 90 c0 1e 00
	00		 mov	 DWORD PTR [eax+7872], edx
  00ac1	8b 91 fc 1e 00
	00		 mov	 edx, DWORD PTR [ecx+7932]
  00ac7	89 90 c4 1e 00
	00		 mov	 DWORD PTR [eax+7876], edx
$LN27@GSTOpenVol:

; 603  : 
; 604  : 				Dump ("Hidden volume offset = %I64d\n", Extension->cryptoInfo->hiddenVolumeOffset);
; 605  : 				Dump ("Hidden volume size = %I64d\n", cryptoInfoPtr->hiddenVolumeSize);
; 606  : 				Dump ("Hidden volume end = %I64d\n", Extension->cryptoInfo->hiddenVolumeOffset + cryptoInfoPtr->hiddenVolumeSize - 1);
; 607  : 
; 608  : 				// Validate the offset
; 609  : 				if (Extension->cryptoInfo->hiddenVolumeOffset % ENCRYPTION_DATA_UNIT_SIZE != 0)

  00acd	8b 53 60	 mov	 edx, DWORD PTR [ebx+96]
  00ad0	8b 82 c0 1e 00
	00		 mov	 eax, DWORD PTR [edx+7872]
  00ad6	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00adb	0b c7		 or	 eax, edi

; 614  : 				}
; 615  : 
; 616  : 				// If we are supposed to actually mount the hidden volume (not just to protect it)
; 617  : 				if (!mount->bProtectHiddenVolume)	

  00add	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  00ae0	0f 85 7d 02 00
	00		 jne	 $LN136@GSTOpenVol
  00ae6	39 b8 8c 02 00
	00		 cmp	 DWORD PTR [eax+652], edi
  00aec	75 3c		 jne	 SHORT $LN25@GSTOpenVol

; 618  : 				{
; 619  : 					Extension->DiskLength = cryptoInfoPtr->hiddenVolumeSize;

  00aee	8b 81 b8 1e 00
	00		 mov	 eax, DWORD PTR [ecx+7864]
  00af4	89 43 70	 mov	 DWORD PTR [ebx+112], eax
  00af7	8b 81 bc 1e 00
	00		 mov	 eax, DWORD PTR [ecx+7868]
  00afd	89 43 74	 mov	 DWORD PTR [ebx+116], eax

; 620  : 					Extension->cryptoInfo->hiddenVolume = TRUE;

  00b00	c7 82 48 04 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+1096], 1

; 621  : 					Extension->cryptoInfo->volDataAreaOffset = Extension->cryptoInfo->hiddenVolumeOffset;

  00b0a	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00b0d	8b 88 c0 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7872]
  00b13	89 88 b0 1e 00
	00		 mov	 DWORD PTR [eax+7856], ecx
  00b19	8b 88 c4 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7876]
  00b1f	89 88 b4 1e 00
	00		 mov	 DWORD PTR [eax+7860], ecx

; 622  : 				}
; 623  : 				else

  00b25	e9 03 01 00 00	 jmp	 $LN30@GSTOpenVol
$LN25@GSTOpenVol:

; 624  : 				{
; 625  : 					// Hidden volume protection
; 626  : 					Extension->cryptoInfo->hiddenVolume = FALSE;
; 627  : 					Extension->cryptoInfo->bProtectHiddenVolume = TRUE;
; 628  : 					
; 629  : 					Extension->cryptoInfo->hiddenVolumeProtectedSize = tmpCryptoInfo->hiddenVolumeSize;
; 630  : 
; 631  : 					if (volumeType == GST_VOLUME_TYPE_HIDDEN_LEGACY)

  00b2a	83 7d 90 02	 cmp	 DWORD PTR _volumeType$[ebp], 2
  00b2e	89 ba 48 04 00
	00		 mov	 DWORD PTR [edx+1096], edi
  00b34	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00b37	c7 80 a8 1e 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7848], 1
  00b41	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _tmpCryptoInfo$[ebp]
  00b47	8b 90 b8 1e 00
	00		 mov	 edx, DWORD PTR [eax+7864]
  00b4d	8b 4b 60	 mov	 ecx, DWORD PTR [ebx+96]
  00b50	89 91 c8 1e 00
	00		 mov	 DWORD PTR [ecx+7880], edx
  00b56	8b 80 bc 1e 00
	00		 mov	 eax, DWORD PTR [eax+7868]
  00b5c	89 81 cc 1e 00
	00		 mov	 DWORD PTR [ecx+7884], eax
  00b62	0f 85 c5 00 00
	00		 jne	 $LN30@GSTOpenVol

; 632  : 						Extension->cryptoInfo->hiddenVolumeProtectedSize += GST_VOLUME_HEADER_SIZE_LEGACY;

  00b68	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00b6b	05 c8 1e 00 00	 add	 eax, 7880		; 00001ec8H
  00b70	81 00 00 02 00
	00		 add	 DWORD PTR [eax], 512	; 00000200H
  00b76	11 78 04	 adc	 DWORD PTR [eax+4], edi

; 633  : 
; 634  : 					Dump ("Hidden volume protection active: %I64d-%I64d (%I64d)\n", Extension->cryptoInfo->hiddenVolumeOffset, Extension->cryptoInfo->hiddenVolumeProtectedSize + Extension->cryptoInfo->hiddenVolumeOffset - 1, Extension->cryptoInfo->hiddenVolumeProtectedSize);
; 635  : 				}
; 636  : 
; 637  : 				break;

  00b79	e9 af 00 00 00	 jmp	 $LN30@GSTOpenVol
$LN34@GSTOpenVol:

; 570  : 			{
; 571  : 			case GST_VOLUME_TYPE_NORMAL:
; 572  : 
; 573  : 				Extension->cryptoInfo->hiddenVolume = FALSE;

  00b7e	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00b81	89 b8 48 04 00
	00		 mov	 DWORD PTR [eax+1096], edi

; 574  : 
; 575  : 				if (mount->bPartitionInInactiveSysEncScope)

  00b87	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  00b8a	39 b8 80 02 00
	00		 cmp	 DWORD PTR [eax+640], edi

; 576  : 				{
; 577  : 					Extension->cryptoInfo->volDataAreaOffset = 0;

  00b90	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00b93	74 40		 je	 SHORT $LN33@GSTOpenVol
  00b95	89 b8 b0 1e 00
	00		 mov	 DWORD PTR [eax+7856], edi

; 578  : 					Extension->DiskLength = lDiskLength.QuadPart;
; 579  : 					Extension->cryptoInfo->FirstDataUnitNo.Value = partitionStartingOffset / ENCRYPTION_DATA_UNIT_SIZE;

  00b9b	57		 push	 edi
  00b9c	89 b8 b4 1e 00
	00		 mov	 DWORD PTR [eax+7860], edi
  00ba2	8b 45 88	 mov	 eax, DWORD PTR _lDiskLength$[ebp]
  00ba5	68 00 02 00 00	 push	 512			; 00000200H
  00baa	ff b5 74 ff ff
	ff		 push	 DWORD PTR _partitionStartingOffset$[ebp+4]
  00bb0	89 43 70	 mov	 DWORD PTR [ebx+112], eax
  00bb3	8b 45 8c	 mov	 eax, DWORD PTR _lDiskLength$[ebp+4]
  00bb6	ff b5 70 ff ff
	ff		 push	 DWORD PTR _partitionStartingOffset$[ebp]
  00bbc	89 43 74	 mov	 DWORD PTR [ebx+116], eax
  00bbf	e8 00 00 00 00	 call	 __alldiv
  00bc4	8b 4b 60	 mov	 ecx, DWORD PTR [ebx+96]
  00bc7	89 81 d8 1e 00
	00		 mov	 DWORD PTR [ecx+7896], eax
  00bcd	89 91 dc 1e 00
	00		 mov	 DWORD PTR [ecx+7900], edx
  00bd3	eb 58		 jmp	 SHORT $LN30@GSTOpenVol
$LN33@GSTOpenVol:

; 580  : 				}
; 581  : 				else if (Extension->cryptoInfo->LegacyVolume)

  00bd5	39 b8 e4 1e 00
	00		 cmp	 DWORD PTR [eax+7908], edi
  00bdb	74 23		 je	 SHORT $LN31@GSTOpenVol

; 582  : 				{
; 583  : 					Extension->cryptoInfo->volDataAreaOffset = GST_VOLUME_HEADER_SIZE_LEGACY;

  00bdd	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00be2	89 88 b0 1e 00
	00		 mov	 DWORD PTR [eax+7856], ecx
  00be8	89 b8 b4 1e 00
	00		 mov	 DWORD PTR [eax+7860], edi

; 584  : 					Extension->DiskLength = lDiskLength.QuadPart - GST_VOLUME_HEADER_SIZE_LEGACY;

  00bee	8b 45 88	 mov	 eax, DWORD PTR _lDiskLength$[ebp]
  00bf1	2b c1		 sub	 eax, ecx
  00bf3	8b 4d 8c	 mov	 ecx, DWORD PTR _lDiskLength$[ebp+4]
  00bf6	1b cf		 sbb	 ecx, edi
  00bf8	89 43 70	 mov	 DWORD PTR [ebx+112], eax
  00bfb	89 4b 74	 mov	 DWORD PTR [ebx+116], ecx

; 585  : 				}
; 586  : 				else

  00bfe	eb 2d		 jmp	 SHORT $LN30@GSTOpenVol
$LN31@GSTOpenVol:

; 587  : 				{
; 588  : 					Extension->cryptoInfo->volDataAreaOffset = Extension->cryptoInfo->EncryptedAreaStart.Value;

  00c00	8b 88 f8 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7928]
  00c06	89 88 b0 1e 00
	00		 mov	 DWORD PTR [eax+7856], ecx
  00c0c	8b 88 fc 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7932]
  00c12	89 88 b4 1e 00
	00		 mov	 DWORD PTR [eax+7860], ecx

; 589  : 					Extension->DiskLength = Extension->cryptoInfo->VolumeSize.Value;

  00c18	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00c1b	8b 88 f0 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7920]
  00c21	89 4b 70	 mov	 DWORD PTR [ebx+112], ecx
  00c24	8b 80 f4 1e 00
	00		 mov	 eax, DWORD PTR [eax+7924]
  00c2a	89 43 74	 mov	 DWORD PTR [ebx+116], eax
$LN30@GSTOpenVol:

; 638  : 			}
; 639  : 
; 640  : 			Dump ("Volume data offset = %I64d\n", Extension->cryptoInfo->volDataAreaOffset);
; 641  : 			Dump ("Volume data size = %I64d\n", Extension->DiskLength);
; 642  : 			Dump ("Volume data end = %I64d\n", Extension->cryptoInfo->volDataAreaOffset + Extension->DiskLength - 1);
; 643  : 
; 644  : 			if (Extension->DiskLength == 0)

  00c2d	8b 4b 70	 mov	 ecx, DWORD PTR [ebx+112]
  00c30	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  00c33	8b c1		 mov	 eax, ecx
  00c35	0b c2		 or	 eax, edx
  00c37	0f 84 dd 00 00
	00		 je	 $LN73@GSTOpenVol

; 645  : 			{
; 646  : 				Dump ("Incorrect volume size\n");
; 647  : 				continue;
; 648  : 			}
; 649  : 
; 650  : 			// If this is a hidden volume, make sure we are supposed to actually
; 651  : 			// mount it (i.e. not just to protect it)
; 652  : 			if (volumeType == GST_VOLUME_TYPE_NORMAL || !mount->bProtectHiddenVolume)	

  00c3d	39 7d 90	 cmp	 DWORD PTR _volumeType$[ebp], edi
  00c40	74 0f		 je	 SHORT $LN148@GSTOpenVol
  00c42	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  00c45	39 b8 8c 02 00
	00		 cmp	 DWORD PTR [eax+652], edi
  00c4b	0f 85 b9 00 00
	00		 jne	 $LN17@GSTOpenVol
$LN148@GSTOpenVol:

; 653  : 			{
; 654  : 				// Validate sector size
; 655  : 				if (bRawDevice && Extension->cryptoInfo->SectorSize != Extension->HostBytesPerSector)

  00c51	8b 75 18	 mov	 esi, DWORD PTR _bRawDevice$[ebp]
  00c54	3b f7		 cmp	 esi, edi
  00c56	74 15		 je	 SHORT $LN19@GSTOpenVol
  00c58	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00c5b	8b 80 e8 1e 00
	00		 mov	 eax, DWORD PTR [eax+7912]
  00c61	3b 83 90 00 00
	00		 cmp	 eax, DWORD PTR [ebx+144]
  00c67	0f 85 01 01 00
	00		 jne	 $LN137@GSTOpenVol
$LN19@GSTOpenVol:

; 660  : 				}
; 661  : 
; 662  : 				// Calculate virtual volume geometry
; 663  : 				Extension->TracksPerCylinder = 1;

  00c6d	33 c0		 xor	 eax, eax
  00c6f	40		 inc	 eax
  00c70	89 83 80 00 00
	00		 mov	 DWORD PTR [ebx+128], eax

; 664  : 				Extension->SectorsPerTrack = 1;

  00c76	89 83 84 00 00
	00		 mov	 DWORD PTR [ebx+132], eax

; 665  : 				Extension->BytesPerSector = Extension->cryptoInfo->SectorSize;

  00c7c	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00c7f	8b 80 e8 1e 00
	00		 mov	 eax, DWORD PTR [eax+7912]

; 666  : 				Extension->NumberOfCylinders = Extension->DiskLength / Extension->BytesPerSector;

  00c85	57		 push	 edi
  00c86	50		 push	 eax
  00c87	52		 push	 edx
  00c88	51		 push	 ecx
  00c89	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  00c8f	e8 00 00 00 00	 call	 __alldiv

; 667  : 				Extension->PartitionType = 0;
; 668  : 
; 669  : 				Extension->bRawDevice = bRawDevice;
; 670  : 				
; 671  : 				memset (Extension->wszVolume, 0, sizeof (Extension->wszVolume));

  00c94	68 08 02 00 00	 push	 520			; 00000208H
  00c99	89 b3 54 02 00
	00		 mov	 DWORD PTR [ebx+596], esi
  00c9f	8d b3 60 02 00
	00		 lea	 esi, DWORD PTR [ebx+608]
  00ca5	57		 push	 edi
  00ca6	56		 push	 esi
  00ca7	89 43 78	 mov	 DWORD PTR [ebx+120], eax
  00caa	89 53 7c	 mov	 DWORD PTR [ebx+124], edx
  00cad	c6 83 8c 00 00
	00 00		 mov	 BYTE PTR [ebx+140], 0
  00cb4	e8 00 00 00 00	 call	 _memset

; 672  : 				if (wcsstr (pwszMountVolume, WIDE ("\\??\\UNC\\")) == pwszMountVolume)

  00cb9	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@
  00cbe	ff b5 64 ff ff
	ff		 push	 DWORD PTR _pwszMountVolume$GSCopy$[ebp]
  00cc4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsstr
  00cca	83 c4 14	 add	 esp, 20			; 00000014H
  00ccd	3b 85 64 ff ff
	ff		 cmp	 eax, DWORD PTR _pwszMountVolume$GSCopy$[ebp]
  00cd3	75 20		 jne	 SHORT $LN18@GSTOpenVol

; 673  : 				{
; 674  : 					/* UNC path */
; 675  : 					_snwprintf (Extension->wszVolume,
; 676  : 						sizeof (Extension->wszVolume) / sizeof (WCHAR) - 1,
; 677  : 						WIDE ("\\??\\\\%s"),
; 678  : 						pwszMountVolume + 7);

  00cd5	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _pwszMountVolume$GSCopy$[ebp]
  00cdb	83 c0 0e	 add	 eax, 14			; 0000000eH
  00cde	50		 push	 eax
  00cdf	68 00 00 00 00	 push	 OFFSET ??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
  00ce4	68 03 01 00 00	 push	 259			; 00000103H
  00ce9	56		 push	 esi
  00cea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snwprintf
  00cf0	83 c4 10	 add	 esp, 16			; 00000010H

; 679  : 				}
; 680  : 				else

  00cf3	eb 15		 jmp	 SHORT $LN17@GSTOpenVol
$LN18@GSTOpenVol:

; 681  : 				{
; 682  : 					wcsncpy (Extension->wszVolume, pwszMountVolume, sizeof (Extension->wszVolume) / sizeof (WCHAR) - 1);

  00cf5	68 03 01 00 00	 push	 259			; 00000103H
  00cfa	ff b5 64 ff ff
	ff		 push	 DWORD PTR _pwszMountVolume$GSCopy$[ebp]
  00d00	56		 push	 esi
  00d01	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncpy
  00d07	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@GSTOpenVol:

; 683  : 				}
; 684  : 			}
; 685  : 
; 686  : 			// If we are to protect a hidden volume we cannot exit yet, for we must also
; 687  : 			// decrypt the hidden volume header.
; 688  : 			if (!(volumeType == GST_VOLUME_TYPE_NORMAL && mount->bProtectHiddenVolume))

  00d0a	39 7d 90	 cmp	 DWORD PTR _volumeType$[ebp], edi
  00d0d	75 6d		 jne	 SHORT $LN138@GSTOpenVol
  00d0f	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  00d12	39 b8 8c 02 00
	00		 cmp	 DWORD PTR [eax+652], edi
  00d18	74 62		 je	 SHORT $LN138@GSTOpenVol
$LN73@GSTOpenVol:

; 338  : 	}
; 339  : 
; 340  : 	// Go through all volume types (e.g., normal, hidden)
; 341  : 	for (volumeType = GST_VOLUME_TYPE_NORMAL;
; 342  : 		volumeType < GST_VOLUME_TYPE_COUNT;
; 343  : 		volumeType++)	

  00d1a	ff 45 90	 inc	 DWORD PTR _volumeType$[ebp]
  00d1d	83 7d 90 03	 cmp	 DWORD PTR _volumeType$[ebp], 3
  00d21	0f 8c bf f8 ff
	ff		 jl	 $LL147@GSTOpenVol

; 683  : 				}
; 684  : 			}
; 685  : 
; 686  : 			// If we are to protect a hidden volume we cannot exit yet, for we must also
; 687  : 			// decrypt the hidden volume header.
; 688  : 			if (!(volumeType == GST_VOLUME_TYPE_NORMAL && mount->bProtectHiddenVolume))

  00d27	e9 9a fb ff ff	 jmp	 $LN72@GSTOpenVol
$LN130@GSTOpenVol:

; 437  : 			{
; 438  : 				if (hParentDeviceFile != NULL)

  00d2c	39 7d 84	 cmp	 DWORD PTR _hParentDeviceFile$28200[ebp], edi
  00d2f	74 7f		 je	 SHORT $error$28105

; 439  : 					ZwClose (hParentDeviceFile);

  00d31	ff 75 84	 push	 DWORD PTR _hParentDeviceFile$28200[ebp]
  00d34	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 440  : 
; 441  : 				Dump ("Cannot open %ls\n", parentDrivePath);
; 442  : 
; 443  : 				goto error;

  00d3a	eb 74		 jmp	 SHORT $error$28105
$LN43@GSTOpenVol:

; 529  : 					{
; 530  : 						// The partition is not within the key scope of system encryption
; 531  : 						mount->nReturnCode = ERR_PASSWORD_WRONG;

  00d3c	c7 06 03 00 00
	00		 mov	 DWORD PTR [esi], 3

; 532  : 						ntStatus = STATUS_SUCCESS;
; 533  : 						goto error;

  00d42	e9 a5 f7 ff ff	 jmp	 $LN162@GSTOpenVol
$LN134@GSTOpenVol:

; 547  : 					{
; 548  : 						// Non-system in-place encryption process has not been completed on this volume
; 549  : 						mount->nReturnCode = ERR_NONSYS_INPLACE_ENC_INCOMPLETE;

  00d47	c7 06 20 00 00
	00		 mov	 DWORD PTR [esi], 32	; 00000020H

; 550  : 						ntStatus = STATUS_SUCCESS;
; 551  : 						goto error;

  00d4d	e9 9a f7 ff ff	 jmp	 $LN162@GSTOpenVol
$LN135@GSTOpenVol:

; 562  : 				{
; 563  : 					mount->nReturnCode = ERR_VOL_ALREADY_MOUNTED;

  00d52	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]

; 564  : 					ntStatus = STATUS_SUCCESS;

  00d55	83 65 98 00	 and	 DWORD PTR _ntStatus$[ebp], 0
  00d59	c7 00 15 00 00
	00		 mov	 DWORD PTR [eax], 21	; 00000015H

; 565  : 					goto error;

  00d5f	33 ff		 xor	 edi, edi
  00d61	eb 5a		 jmp	 SHORT $LN7@GSTOpenVol
$LN136@GSTOpenVol:

; 610  : 				{
; 611  : 					mount->nReturnCode = ERR_VOL_SIZE_WRONG;

  00d63	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7

; 612  : 					ntStatus = STATUS_SUCCESS;
; 613  : 					goto error;

  00d69	e9 7e f7 ff ff	 jmp	 $LN162@GSTOpenVol
$LN137@GSTOpenVol:

; 656  : 				{
; 657  : 					mount->nReturnCode = ERR_PARAMETER_INCORRECT;

  00d6e	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  00d71	c7 00 1e 00 00
	00		 mov	 DWORD PTR [eax], 30	; 0000001eH

; 658  : 					ntStatus = STATUS_SUCCESS;
; 659  : 					goto error;

  00d77	e9 70 f7 ff ff	 jmp	 $LN162@GSTOpenVol
$LN138@GSTOpenVol:

; 689  : 			{
; 690  : 				GSTfree (readBuffer);

  00d7c	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00d81	ff 75 80	 push	 DWORD PTR _readBuffer$[ebp]
  00d84	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 691  : 
; 692  : 				if (tmpCryptoInfo != NULL)

  00d8a	39 bd 7c ff ff
	ff		 cmp	 DWORD PTR _tmpCryptoInfo$[ebp], edi
  00d90	74 0b		 je	 SHORT $LN14@GSTOpenVol

; 693  : 				{
; 694  : 					crypto_close (tmpCryptoInfo);

  00d92	ff b5 7c ff ff
	ff		 push	 DWORD PTR _tmpCryptoInfo$[ebp]
  00d98	e8 00 00 00 00	 call	 _crypto_close@4
$LN14@GSTOpenVol:

; 695  : 					tmpCryptoInfo = NULL;
; 696  : 				}
; 697  : 				
; 698  : 				return STATUS_SUCCESS;

  00d9d	33 c0		 xor	 eax, eax
  00d9f	e9 8c 00 00 00	 jmp	 $LN108@GSTOpenVol
$LN76@GSTOpenVol:

; 324  : 	{
; 325  : 		mount->nReturnCode = ERR_VOL_SIZE_WRONG;

  00da4	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  00da7	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7
$LN9@GSTOpenVol:

; 326  : 		ntStatus = STATUS_SUCCESS;

  00dad	89 7d 98	 mov	 DWORD PTR _ntStatus$[ebp], edi
$error$28105:

; 720  : 		ntStatus = STATUS_SUCCESS;
; 721  : 
; 722  : error:
; 723  : 	if (mount->nReturnCode == ERR_SUCCESS)

  00db0	8b 45 94	 mov	 eax, DWORD PTR _mount$GSCopy$[ebp]
  00db3	39 38		 cmp	 DWORD PTR [eax], edi
  00db5	75 06		 jne	 SHORT $LN7@GSTOpenVol

; 724  : 		mount->nReturnCode = ERR_PASSWORD_WRONG;

  00db7	c7 00 03 00 00
	00		 mov	 DWORD PTR [eax], 3
$LN7@GSTOpenVol:

; 725  : 
; 726  : 	if (tmpCryptoInfo != NULL)

  00dbd	39 bd 7c ff ff
	ff		 cmp	 DWORD PTR _tmpCryptoInfo$[ebp], edi
  00dc3	74 11		 je	 SHORT $LN6@GSTOpenVol

; 727  : 	{
; 728  : 		crypto_close (tmpCryptoInfo);

  00dc5	ff b5 7c ff ff
	ff		 push	 DWORD PTR _tmpCryptoInfo$[ebp]
  00dcb	e8 00 00 00 00	 call	 _crypto_close@4

; 729  : 		tmpCryptoInfo = NULL;

  00dd0	89 bd 7c ff ff
	ff		 mov	 DWORD PTR _tmpCryptoInfo$[ebp], edi
$LN6@GSTOpenVol:

; 730  : 	}
; 731  : 
; 732  : 	if (Extension->cryptoInfo)

  00dd6	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00dd9	3b c7		 cmp	 eax, edi
  00ddb	74 09		 je	 SHORT $LN5@GSTOpenVol

; 733  : 	{
; 734  : 		crypto_close (Extension->cryptoInfo);

  00ddd	50		 push	 eax
  00dde	e8 00 00 00 00	 call	 _crypto_close@4

; 735  : 		Extension->cryptoInfo = NULL;

  00de3	89 7b 60	 mov	 DWORD PTR [ebx+96], edi
$LN5@GSTOpenVol:

; 736  : 	}
; 737  : 
; 738  : 	if (Extension->bTimeStampValid)

  00de6	39 bb 88 04 00
	00		 cmp	 DWORD PTR [ebx+1160], edi
  00dec	74 07		 je	 SHORT $LN4@GSTOpenVol

; 739  : 	{
; 740  : 		RestoreTimeStamp (Extension);

  00dee	8b f3		 mov	 esi, ebx
  00df0	e8 00 00 00 00	 call	 _RestoreTimeStamp@4
$LN4@GSTOpenVol:

; 741  : 	}
; 742  : 
; 743  : 	/* Close the hDeviceFile */
; 744  : 	if (Extension->hDeviceFile != NULL)

  00df5	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv872[ebp]
  00dfb	8b 00		 mov	 eax, DWORD PTR [eax]
  00dfd	3b c7		 cmp	 eax, edi
  00dff	74 07		 je	 SHORT $LN3@GSTOpenVol

; 745  : 		ZwClose (Extension->hDeviceFile);

  00e01	50		 push	 eax
  00e02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN3@GSTOpenVol:

; 746  : 
; 747  : 	/* The cryptoInfo pointer is deallocated if the readheader routines
; 748  : 	   fail so there is no need to deallocate here  */
; 749  : 
; 750  : 	/* Dereference the user-mode file object */
; 751  : 	if (Extension->pfoDeviceFile != NULL)

  00e08	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv870[ebp]
  00e0e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e10	3b cf		 cmp	 ecx, edi
  00e12	74 06		 je	 SHORT $LN2@GSTOpenVol

; 752  : 		ObDereferenceObject (Extension->pfoDeviceFile);

  00e14	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4
$LN2@GSTOpenVol:

; 753  : 
; 754  : 	/* Free the tmp IO buffers */
; 755  : 	if (readBuffer != NULL)

  00e1a	39 7d 80	 cmp	 DWORD PTR _readBuffer$[ebp], edi
  00e1d	74 0e		 je	 SHORT $LN1@GSTOpenVol

; 756  : 		GSTfree (readBuffer);

  00e1f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00e24	ff 75 80	 push	 DWORD PTR _readBuffer$[ebp]
  00e27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN1@GSTOpenVol:

; 757  : 
; 758  : 	return ntStatus;

  00e2d	8b 45 98	 mov	 eax, DWORD PTR _ntStatus$[ebp]
$LN108@GSTOpenVol:

; 759  : }

  00e30	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e33	5f		 pop	 edi
  00e34	5e		 pop	 esi
  00e35	33 cd		 xor	 ecx, ebp
  00e37	5b		 pop	 ebx
  00e38	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e3d	c9		 leave
  00e3e	c2 14 00	 ret	 20			; 00000014H
_GSTOpenVolume@20 ENDP
_TEXT	ENDS
PUBLIC	_GSTCloseVolume@8
; Function compile flags: /Ogsp
;	COMDAT _GSTCloseVolume@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_GSTCloseVolume@8 PROC					; COMDAT

; 771  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 772  : 	if (DeviceObject);	/* Remove compiler warning */
; 773  : 
; 774  : 	if (Extension->hDeviceFile != NULL)

  00006	8b 75 0c	 mov	 esi, DWORD PTR _Extension$[ebp]
  00009	33 c0		 xor	 eax, eax
  0000b	39 46 54	 cmp	 DWORD PTR [esi+84], eax
  0000e	74 1e		 je	 SHORT $LN2@GSTCloseVo

; 775  : 	{
; 776  : 		if (Extension->bRawDevice == FALSE
; 777  : 			&& Extension->bTimeStampValid)

  00010	39 86 54 02 00
	00		 cmp	 DWORD PTR [esi+596], eax
  00016	75 0d		 jne	 SHORT $LN1@GSTCloseVo
  00018	39 86 88 04 00
	00		 cmp	 DWORD PTR [esi+1160], eax
  0001e	74 05		 je	 SHORT $LN1@GSTCloseVo

; 778  : 		{
; 779  : 			RestoreTimeStamp (Extension);

  00020	e8 00 00 00 00	 call	 _RestoreTimeStamp@4
$LN1@GSTCloseVo:

; 780  : 		}
; 781  : 		ZwClose (Extension->hDeviceFile);

  00025	ff 76 54	 push	 DWORD PTR [esi+84]
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN2@GSTCloseVo:

; 782  : 	}
; 783  : 	ObDereferenceObject (Extension->pfoDeviceFile);

  0002e	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 784  : 	crypto_close (Extension->cryptoInfo);

  00037	ff 76 60	 push	 DWORD PTR [esi+96]
  0003a	e8 00 00 00 00	 call	 _crypto_close@4
  0003f	5e		 pop	 esi

; 785  : }

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
_GSTCloseVolume@8 ENDP
_TEXT	ENDS
END
