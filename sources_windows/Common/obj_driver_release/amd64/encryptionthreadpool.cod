; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ExInitializeFastMutex
EXTRN	__imp_ExAcquireFastMutex:PROC
EXTRN	__imp_ExReleaseFastMutex:PROC
ThreadPoolRunning DD 01H DUP (?)
StopPending DD	01H DUP (?)
PUBLIC	IsEncryptionThreadPoolRunning
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT IsEncryptionThreadPoolRunning
_TEXT	SEGMENT
IsEncryptionThreadPoolRunning PROC			; COMDAT

; 599  : 	return ThreadPoolRunning;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning

; 600  : }

  00006	c3		 ret	 0
IsEncryptionThreadPoolRunning ENDP
_TEXT	ENDS
PUBLIC	GetEncryptionThreadCount
ThreadCount DD	01H DUP (?)
; Function compile flags: /Ogspy
;	COMDAT GetEncryptionThreadCount
_TEXT	SEGMENT
GetEncryptionThreadCount PROC				; COMDAT

; 573  : 	return ThreadPoolRunning ? ThreadCount : 0;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  00006	f7 d8		 neg	 eax
  00008	1b c9		 sbb	 ecx, ecx
  0000a	23 0d 00 00 00
	00		 and	 ecx, DWORD PTR ThreadCount
  00010	8b c1		 mov	 eax, ecx

; 574  : }

  00012	c3		 ret	 0
GetEncryptionThreadCount ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT SetWorkItemState
_TEXT	SEGMENT
workItem$ = 8
newState$ = 16
SetWorkItemState PROC					; COMDAT

; 145  : 	InterlockedExchange ((LONG *) &workItem->State, (LONG) newState);

  00000	87 11		 xchg	 DWORD PTR [rcx], edx

; 146  : }

  00002	c3		 ret	 0
SetWorkItemState ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT GetWorkItemState
_TEXT	SEGMENT
workItem$ = 8
GetWorkItemState PROC					; COMDAT

; 130  : 	return InterlockedExchangeAdd ((LONG *) &workItem->State, 0);

  00000	33 c0		 xor	 eax, eax
  00002	f0 0f c1 01	 lock xadd DWORD PTR [rcx], eax

; 131  : }

  00006	c3		 ret	 0
GetWorkItemState ENDP
; Function compile flags: /Ogspy
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT ExInitializeFastMutex
_TEXT	SEGMENT
FastMutex$ = 8
ExInitializeFastMutex PROC				; COMDAT

; 16363: 
; 16364:     FastMutex->Count = FM_LOCK_BIT;
; 16365:     FastMutex->Owner = NULL;

  00000	48 83 61 08 00	 and	 QWORD PTR [rcx+8], 0

; 16366:     FastMutex->Contention = 0;

  00005	83 61 10 00	 and	 DWORD PTR [rcx+16], 0
  00009	ba 01 00 00 00	 mov	 edx, 1
  0000e	89 11		 mov	 DWORD PTR [rcx], edx

; 16367:     KeInitializeEvent(&FastMutex->Event, SynchronizationEvent, FALSE);

  00010	45 33 c0	 xor	 r8d, r8d
  00013	48 83 c1 18	 add	 rcx, 24

; 16368:     return;
; 16369: }

  00017	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeInitializeEvent
ExInitializeFastMutex ENDP
PUBLIC	EncryptionThreadPoolBeginKeyDerivation
WorkItemReadyEvent DB 018H DUP (?)
WorkItemCompletedEvent DB 018H DUP (?)
WorkItemQueue DB 03c00H DUP (?)
EnqueuePosition DD 01H DUP (?)
EnqueueMutex DB	038H DUP (?)
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
pdata	SEGMENT
$pdata$EncryptionThreadPoolBeginKeyDerivation DD imagerel $LN14
	DD	imagerel $LN14+348
	DD	imagerel $unwind$EncryptionThreadPoolBeginKeyDerivation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolBeginKeyDerivation DD 0a1901H
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0c0155219H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptionThreadPoolBeginKeyDerivation
_TEXT	SEGMENT
completionEvent$ = 64
noOutstandingWorkItemEvent$ = 72
completionFlag$ = 80
outstandingWorkItemCount$ = 88
pkcs5Prf$ = 96
password$ = 104
passwordLength$ = 112
salt$ = 120
iterationCount$ = 128
derivedKey$ = 136
EncryptionThreadPoolBeginKeyDerivation PROC		; COMDAT

; 410  : {

$LN14:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 6b 10	 mov	 QWORD PTR [r11+16], rbp
  0000b	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  0000f	49 89 7b 20	 mov	 QWORD PTR [r11+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 411  : 	EncryptionThreadPoolWorkItem *workItem;
; 412  : 
; 413  : 	if (!ThreadPoolRunning)

  00019	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0001f	49 8b f9	 mov	 rdi, r9
  00022	49 8b e8	 mov	 rbp, r8
  00025	48 8b f2	 mov	 rsi, rdx
  00028	4c 8b e1	 mov	 r12, rcx
  0002b	85 c0		 test	 eax, eax
  0002d	75 1d		 jne	 SHORT $LN4@Encryption

; 414  : 		GST_THROW_FATAL_EXCEPTION;

  0002f	8d 48 29	 lea	 ecx, QWORD PTR [rax+41]
  00032	45 33 c9	 xor	 r9d, r9d
  00035	45 33 c0	 xor	 r8d, r8d
  00038	ba 9e 01 00 00	 mov	 edx, 414		; 0000019eH
  0003d	49 c7 43 e8 54
	53 47 00	 mov	 QWORD PTR [r11-24], 4674388 ; 00475354H
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0004b	cc		 int	 3
$LN4@Encryption:

; 415  : 
; 416  : 	GST_ACQUIRE_MUTEX (&EnqueueMutex);

  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex

; 417  : 
; 418  : 	workItem = &WorkItemQueue[EnqueuePosition++];

  00059	48 63 1d 00 00
	00 00		 movsxd	 rbx, DWORD PTR EnqueuePosition
  00060	ff 05 00 00 00
	00		 inc	 DWORD PTR EnqueuePosition
  00066	48 6b db 78	 imul	 rbx, 120		; 00000078H
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  00071	48 03 d8	 add	 rbx, rax

; 419  : 	if (EnqueuePosition >= GST_ENC_THREAD_POOL_QUEUE_SIZE)

  00074	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  0007a	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0007f	7c 0a		 jl	 SHORT $LN11@Encryption

; 420  : 		EnqueuePosition = 0;

  00081	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EnqueuePosition, 0
$LN11@Encryption:

; 421  : 
; 422  : 	while (GetWorkItemState (workItem) != WorkItemFree)

  0008b	33 c0		 xor	 eax, eax
  0008d	f0 0f c1 03	 lock xadd DWORD PTR [rbx], eax
  00091	85 c0		 test	 eax, eax
  00093	74 28		 je	 SHORT $LN1@Encryption
$LL2@Encryption:

; 423  : 	{
; 424  : 		GST_WAIT_EVENT (WorkItemCompletedEvent);

  00095	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	45 33 c0	 xor	 r8d, r8d
  000a8	33 d2		 xor	 edx, edx
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  000b0	45 33 db	 xor	 r11d, r11d

; 421  : 
; 422  : 	while (GetWorkItemState (workItem) != WorkItemFree)

  000b3	f0 44 0f c1 1b	 lock xadd DWORD PTR [rbx], r11d
  000b8	45 85 db	 test	 r11d, r11d
  000bb	75 d8		 jne	 SHORT $LL2@Encryption
$LN1@Encryption:

; 425  : 	}
; 426  : 
; 427  : 	workItem->Type = DeriveKeyWork;
; 428  : 	workItem->KeyDerivation.CompletionEvent = completionEvent;
; 429  : 	workItem->KeyDerivation.CompletionFlag = completionFlag;
; 430  : 	workItem->KeyDerivation.DerivedKey = derivedKey;

  000bd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR derivedKey$[rsp]
  000c5	c7 43 04 02 00
	00 00		 mov	 DWORD PTR [rbx+4], 2
  000cc	4c 89 63 30	 mov	 QWORD PTR [rbx+48], r12
  000d0	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 431  : 	workItem->KeyDerivation.IterationCount = iterationCount;

  000d4	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR iterationCount$[rsp]
  000db	48 89 6b 38	 mov	 QWORD PTR [rbx+56], rbp
  000df	89 43 48	 mov	 DWORD PTR [rbx+72], eax

; 432  : 	workItem->KeyDerivation.NoOutstandingWorkItemEvent = noOutstandingWorkItemEvent;
; 433  : 	workItem->KeyDerivation.OutstandingWorkItemCount = outstandingWorkItemCount;
; 434  : 	workItem->KeyDerivation.Password = password;

  000e2	48 8b 44 24 68	 mov	 rax, QWORD PTR password$[rsp]
  000e7	48 89 73 50	 mov	 QWORD PTR [rbx+80], rsi
  000eb	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 435  : 	workItem->KeyDerivation.PasswordLength = passwordLength;

  000ef	8b 44 24 70	 mov	 eax, DWORD PTR passwordLength$[rsp]
  000f3	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  000f7	89 43 68	 mov	 DWORD PTR [rbx+104], eax

; 436  : 	workItem->KeyDerivation.Pkcs5Prf = pkcs5Prf;

  000fa	8b 44 24 60	 mov	 eax, DWORD PTR pkcs5Prf$[rsp]
  000fe	89 43 6c	 mov	 DWORD PTR [rbx+108], eax

; 437  : 	workItem->KeyDerivation.Salt = salt;

  00101	48 8b 44 24 78	 mov	 rax, QWORD PTR salt$[rsp]
  00106	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 438  : 
; 439  : 	InterlockedIncrement (outstandingWorkItemCount);

  0010a	f0 83 07 01	 lock add DWORD PTR [rdi], 1

; 440  : 	GST_CLEAR_EVENT (*noOutstandingWorkItemEvent);

  0010e	48 8b ce	 mov	 rcx, rsi
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeClearEvent

; 441  : 
; 442  : 	SetWorkItemState (workItem, WorkItemReady);
; 443  : 	GST_SET_EVENT (WorkItemReadyEvent);

  00117	45 33 c0	 xor	 r8d, r8d
  0011a	41 bb 01 00 00
	00		 mov	 r11d, 1
  00120	44 87 1b	 xchg	 DWORD PTR [rbx], r11d
  00123	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 444  : 	GST_RELEASE_MUTEX (&EnqueueMutex);

  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex

; 445  : }

  0013b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00140	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00145	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0014a	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0014f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00153	41 5c		 pop	 r12
  00155	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_ExReleaseFastMutex
$LN13@Encryption:
EncryptionThreadPoolBeginKeyDerivation ENDP
_TEXT	ENDS
PUBLIC	EncryptionThreadPoolStop
ThreadHandles DQ 040H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptionThreadPoolStop DD imagerel $LN9
	DD	imagerel $LN9+116
	DD	imagerel $unwind$EncryptionThreadPoolStop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolStop DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptionThreadPoolStop
_TEXT	SEGMENT
EncryptionThreadPoolStop PROC				; COMDAT

; 354  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 355  : 	size_t i;
; 356  : 
; 357  : 	if (!ThreadPoolRunning)

  00006	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0000c	85 c0		 test	 eax, eax
  0000e	74 5e		 je	 SHORT $LN5@Encryption@2

; 358  : 		return;
; 359  : 
; 360  : 	StopPending = TRUE;
; 361  : 	GST_SET_EVENT (WorkItemReadyEvent);

  00010	45 33 c0	 xor	 r8d, r8d
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  0001a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR StopPending, 1
  00024	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 362  : 
; 363  : 	for (i = 0; i < ThreadCount; ++i)

  0002e	33 db		 xor	 ebx, ebx
  00030	39 1d 00 00 00
	00		 cmp	 DWORD PTR ThreadCount, ebx
  00036	76 25		 jbe	 SHORT $LN1@Encryption@2
$LL3@Encryption@2:
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadHandles

; 364  : 	{
; 365  : #ifdef DEVICE_DRIVER
; 366  : 		GSTStopThread (ThreadHandles[i], &WorkItemReadyEvent);

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:WorkItemReadyEvent
  00046	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  0004a	e8 00 00 00 00	 call	 GSTStopThread
  0004f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadCount
  00055	48 ff c3	 inc	 rbx
  00058	48 3b d8	 cmp	 rbx, rax
  0005b	72 db		 jb	 SHORT $LL3@Encryption@2
$LN1@Encryption@2:

; 367  : #else
; 368  : 		GST_WAIT_EVENT (ThreadHandles[i]);
; 369  : #endif
; 370  : 	}
; 371  : 
; 372  : 	ThreadCount = 0;

  0005d	83 25 00 00 00
	00 00		 and	 DWORD PTR ThreadCount, 0

; 373  : 
; 374  : #ifndef DEVICE_DRIVER
; 375  : 	CloseHandle (DequeueMutex);
; 376  : 	CloseHandle (EnqueueMutex);
; 377  : 
; 378  : 	CloseHandle (WorkItemReadyEvent);
; 379  : 	CloseHandle (WorkItemCompletedEvent);
; 380  : 
; 381  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)
; 382  : 	{
; 383  : 		if (WorkItemQueue[i].ItemCompletedEvent)
; 384  : 			CloseHandle (WorkItemQueue[i].ItemCompletedEvent);
; 385  : 	}
; 386  : #endif
; 387  : 
; 388  : 	ThreadPoolRunning = FALSE;

  00064	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ThreadPoolRunning, 0
$LN5@Encryption@2:

; 389  : }

  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5b		 pop	 rbx
  00073	c3		 ret	 0
EncryptionThreadPoolStop ENDP
PUBLIC	EncryptionThreadPoolDoWork
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptionThreadPoolDoWork DD imagerel $LN38
	DD	imagerel $LN38+645
	DD	imagerel $unwind$EncryptionThreadPoolDoWork
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolDoWork DD 0c1c01H
	DD	010641cH
	DD	0f541cH
	DD	0e341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptionThreadPoolDoWork
_TEXT	SEGMENT
fragmentStartUnitNo$1$ = 48
type$ = 112
data$ = 120
startUnitNo$ = 128
remainder$1$ = 136
unitCount$ = 136
cryptoInfo$ = 144
EncryptionThreadPoolDoWork PROC				; COMDAT

; 461  : {

$LN38:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 462  : 	uint32 fragmentCount;
; 463  : 	uint32 unitsPerFragment;
; 464  : 	uint32 remainder;
; 465  : 
; 466  : 	byte *fragmentData;
; 467  : 	uint64 fragmentStartUnitNo;
; 468  : 
; 469  : 	EncryptionThreadPoolWorkItem *workItem;
; 470  : 	EncryptionThreadPoolWorkItem *firstFragmentWorkItem;
; 471  : 	
; 472  : 	if (unitCount == 0)

  0001c	33 db		 xor	 ebx, ebx
  0001e	4d 8b d0	 mov	 r10, r8
  00021	4c 8b fa	 mov	 r15, rdx
  00024	8b e9		 mov	 ebp, ecx
  00026	44 3b cb	 cmp	 r9d, ebx
  00029	0f 84 38 02 00
	00		 je	 $LN15@Encryption@3

; 473  : 		return;
; 474  : 	
; 475  : 	if (!ThreadPoolRunning || unitCount == 1)

  0002f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  00035	8d 4b 01	 lea	 ecx, QWORD PTR [rbx+1]
  00038	3b c3		 cmp	 eax, ebx
  0003a	0f 84 d2 01 00
	00		 je	 $LN17@Encryption@3
  00040	44 3b c9	 cmp	 r9d, ecx
  00043	0f 84 c9 01 00
	00		 je	 $LN17@Encryption@3

; 489  : 		}
; 490  : 
; 491  : 		return;
; 492  : 	}
; 493  : 
; 494  : 	if (unitCount <= ThreadCount)

  00049	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ThreadCount
  0004f	44 3b ce	 cmp	 r9d, esi
  00052	77 0e		 ja	 SHORT $LN11@Encryption@3

; 495  : 	{
; 496  : 		fragmentCount = unitCount;

  00054	41 8b f1	 mov	 esi, r9d

; 497  : 		unitsPerFragment = 1;

  00057	8b f9		 mov	 edi, ecx

; 498  : 		remainder = 0;

  00059	89 9c 24 88 00
	00 00		 mov	 DWORD PTR remainder$1$[rsp], ebx

; 499  : 	}
; 500  : 	else

  00060	eb 16		 jmp	 SHORT $LN9@Encryption@3
$LN11@Encryption@3:

; 501  : 	{
; 502  : 		/* Note that it is not efficient to divide the data into fragments smaller than a few hundred bytes.
; 503  : 		The reason is that the overhead associated with thread handling would in most cases make a multi-threaded 
; 504  : 		process actually slower than a single-threaded process. */
; 505  : 
; 506  : 		fragmentCount = ThreadCount;
; 507  : 		unitsPerFragment = unitCount / ThreadCount;

  00062	33 d2		 xor	 edx, edx
  00064	41 8b c1	 mov	 eax, r9d
  00067	f7 f6		 div	 esi
  00069	89 94 24 88 00
	00 00		 mov	 DWORD PTR remainder$1$[rsp], edx
  00070	8b f8		 mov	 edi, eax

; 508  : 		remainder = unitCount % ThreadCount;
; 509  : 
; 510  : 		if (remainder > 0)

  00072	3b d3		 cmp	 edx, ebx
  00074	76 02		 jbe	 SHORT $LN9@Encryption@3

; 511  : 			++unitsPerFragment;

  00076	03 f9		 add	 edi, ecx
$LN9@Encryption@3:

; 512  : 	}
; 513  : 	
; 514  : 	fragmentData = data;
; 515  : 	fragmentStartUnitNo = startUnitNo->Value;

  00078	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 516  : 
; 517  : 	GST_ACQUIRE_MUTEX (&EnqueueMutex);

  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  00082	48 89 44 24 30	 mov	 QWORD PTR fragmentStartUnitNo$1$[rsp], rax
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex

; 518  : 	firstFragmentWorkItem = &WorkItemQueue[EnqueuePosition];

  0008d	4c 63 2d 00 00
	00 00		 movsxd	 r13, DWORD PTR EnqueuePosition
  00094	4d 6b ed 78	 imul	 r13, 120		; 00000078H
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemQueue

; 519  : 
; 520  : 	while (GetWorkItemState (firstFragmentWorkItem) != WorkItemFree)

  0009f	8b c3		 mov	 eax, ebx
  000a1	4c 03 e9	 add	 r13, rcx
  000a4	f0 41 0f c1 45
	00		 lock xadd DWORD PTR [r13], eax
  000aa	3b c3		 cmp	 eax, ebx
  000ac	74 2f		 je	 SHORT $LN7@Encryption@3
$LL8@Encryption@3:

; 521  : 	{
; 522  : 		GST_WAIT_EVENT (WorkItemCompletedEvent);

  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  000b5	45 33 c9	 xor	 r9d, r9d
  000b8	45 33 c0	 xor	 r8d, r8d
  000bb	33 d2		 xor	 edx, edx
  000bd	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  000c8	44 8b db	 mov	 r11d, ebx

; 519  : 
; 520  : 	while (GetWorkItemState (firstFragmentWorkItem) != WorkItemFree)

  000cb	f0 45 0f c1 5d
	00		 lock xadd DWORD PTR [r13], r11d
  000d1	44 3b db	 cmp	 r11d, ebx
  000d4	75 d8		 jne	 SHORT $LL8@Encryption@3
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemQueue
$LN7@Encryption@3:

; 523  : 	}
; 524  : 
; 525  : 	firstFragmentWorkItem->OutstandingFragmentCount = fragmentCount;

  000dd	41 89 75 28	 mov	 DWORD PTR [r13+40], esi

; 526  : 
; 527  : 	while (fragmentCount-- > 0)

  000e1	3b f3		 cmp	 esi, ebx
  000e3	0f 86 eb 00 00
	00		 jbe	 $LN35@Encryption@3
  000e9	44 8b f7	 mov	 r14d, edi
  000ec	41 c1 e6 09	 shl	 r14d, 9
$LL6@Encryption@3:

; 528  : 	{
; 529  : 		workItem = &WorkItemQueue[EnqueuePosition++];

  000f0	4c 63 25 00 00
	00 00		 movsxd	 r12, DWORD PTR EnqueuePosition
  000f7	ff 05 00 00 00
	00		 inc	 DWORD PTR EnqueuePosition

; 530  : 		if (EnqueuePosition >= GST_ENC_THREAD_POOL_QUEUE_SIZE)

  000fd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  00103	4d 6b e4 78	 imul	 r12, 120		; 00000078H
  00107	4c 03 e1	 add	 r12, rcx
  0010a	ff ce		 dec	 esi
  0010c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00111	7c 06		 jl	 SHORT $LN32@Encryption@3

; 531  : 			EnqueuePosition = 0;

  00113	89 1d 00 00 00
	00		 mov	 DWORD PTR EnqueuePosition, ebx
$LN32@Encryption@3:

; 532  : 
; 533  : 		while (GetWorkItemState (workItem) != WorkItemFree)

  00119	8b c3		 mov	 eax, ebx
  0011b	f0 41 0f c1 04
	24		 lock xadd DWORD PTR [r12], eax
  00121	3b c3		 cmp	 eax, ebx
  00123	74 28		 je	 SHORT $LN2@Encryption@3
$LL3@Encryption@3:

; 534  : 		{
; 535  : 			GST_WAIT_EVENT (WorkItemCompletedEvent);

  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  0012c	45 33 c9	 xor	 r9d, r9d
  0012f	45 33 c0	 xor	 r8d, r8d
  00132	33 d2		 xor	 edx, edx
  00134	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0013f	44 8b db	 mov	 r11d, ebx

; 532  : 
; 533  : 		while (GetWorkItemState (workItem) != WorkItemFree)

  00142	f0 45 0f c1 1c
	24		 lock xadd DWORD PTR [r12], r11d
  00148	44 3b db	 cmp	 r11d, ebx
  0014b	75 d8		 jne	 SHORT $LL3@Encryption@3
$LN2@Encryption@3:

; 536  : 		}
; 537  : 
; 538  : 		workItem->Type = type;
; 539  : 		workItem->FirstFragment = firstFragmentWorkItem;
; 540  : 
; 541  : 		workItem->Encryption.CryptoInfo = cryptoInfo;
; 542  : 		workItem->Encryption.Data = fragmentData;
; 543  : 		workItem->Encryption.UnitCount = unitsPerFragment;
; 544  : 		workItem->Encryption.StartUnitNo.Value = fragmentStartUnitNo;

  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fragmentStartUnitNo$1$[rsp]
  00152	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0015a	4d 89 7c 24 38	 mov	 QWORD PTR [r12+56], r15
  0015f	49 89 44 24 30	 mov	 QWORD PTR [r12+48], rax

; 545  : 
; 546  :  		fragmentData += unitsPerFragment * ENCRYPTION_DATA_UNIT_SIZE;

  00164	41 8b c6	 mov	 eax, r14d
  00167	49 89 4c 24 40	 mov	 QWORD PTR [r12+64], rcx
  0016c	4c 03 f8	 add	 r15, rax

; 547  : 		fragmentStartUnitNo += unitsPerFragment;

  0016f	8b c7		 mov	 eax, edi
  00171	41 89 6c 24 04	 mov	 DWORD PTR [r12+4], ebp
  00176	48 03 c8	 add	 rcx, rax

; 548  : 
; 549  : 		if (remainder > 0 && --remainder == 0)

  00179	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR remainder$1$[rsp]
  00180	4d 89 6c 24 20	 mov	 QWORD PTR [r12+32], r13
  00185	41 89 7c 24 48	 mov	 DWORD PTR [r12+72], edi
  0018a	48 89 4c 24 30	 mov	 QWORD PTR fragmentStartUnitNo$1$[rsp], rcx
  0018f	3b c3		 cmp	 eax, ebx
  00191	76 15		 jbe	 SHORT $LN1@Encryption@3
  00193	83 c0 ff	 add	 eax, -1			; ffffffffH
  00196	89 84 24 88 00
	00 00		 mov	 DWORD PTR remainder$1$[rsp], eax
  0019d	75 09		 jne	 SHORT $LN1@Encryption@3

; 550  : 			--unitsPerFragment;

  0019f	ff cf		 dec	 edi
  001a1	41 81 c6 00 fe
	ff ff		 add	 r14d, -512		; fffffe00H
$LN1@Encryption@3:

; 551  : 
; 552  : 		SetWorkItemState (workItem, WorkItemReady);
; 553  : 		GST_SET_EVENT (WorkItemReadyEvent);

  001a8	45 33 c0	 xor	 r8d, r8d
  001ab	b8 01 00 00 00	 mov	 eax, 1
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  001b7	41 87 04 24	 xchg	 DWORD PTR [r12], eax
  001bb	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemQueue
  001cc	3b f3		 cmp	 esi, ebx
  001ce	0f 87 1c ff ff
	ff		 ja	 $LL6@Encryption@3
$LN35@Encryption@3:

; 554  : 	}
; 555  : 
; 556  : 	GST_RELEASE_MUTEX (&EnqueueMutex);

  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseFastMutex

; 557  : 
; 558  : 	GST_WAIT_EVENT (firstFragmentWorkItem->ItemCompletedEvent);

  001e1	49 8d 4d 08	 lea	 rcx, QWORD PTR [r13+8]
  001e5	45 33 c9	 xor	 r9d, r9d
  001e8	45 33 c0	 xor	 r8d, r8d
  001eb	33 d2		 xor	 edx, edx
  001ed	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 559  : 	SetWorkItemState (firstFragmentWorkItem, WorkItemFree);

  001f8	41 87 5d 00	 xchg	 DWORD PTR [r13], ebx

; 560  : 	GST_SET_EVENT (WorkItemCompletedEvent);

  001fc	45 33 c0	 xor	 r8d, r8d
  001ff	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
  00210	eb 55		 jmp	 SHORT $LN15@Encryption@3
$LN17@Encryption@3:

; 476  : 	{
; 477  : 		switch (type)

  00212	3b eb		 cmp	 ebp, ebx
  00214	74 3b		 je	 SHORT $LN13@Encryption@3
  00216	3b e9		 cmp	 ebp, ecx
  00218	74 1f		 je	 SHORT $LN14@Encryption@3

; 485  : 			break;
; 486  : 
; 487  : 		default:
; 488  : 			GST_THROW_FATAL_EXCEPTION;

  0021a	45 33 c9	 xor	 r9d, r9d
  0021d	45 33 c0	 xor	 r8d, r8d
  00220	ba e8 01 00 00	 mov	 edx, 488		; 000001e8H
  00225	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00229	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00238	cc		 int	 3
$LN14@Encryption@3:

; 478  : 		{
; 479  : 		case DecryptDataUnitsWork:
; 480  : 			DecryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00239	45 8b c1	 mov	 r8d, r9d
  0023c	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR cryptoInfo$[rsp]
  00244	49 8b d2	 mov	 rdx, r10
  00247	49 8b cf	 mov	 rcx, r15
  0024a	e8 00 00 00 00	 call	 DecryptDataUnitsCurrentThread

; 481  : 			break;

  0024f	eb 16		 jmp	 SHORT $LN15@Encryption@3
$LN13@Encryption@3:

; 482  : 
; 483  : 		case EncryptDataUnitsWork:
; 484  : 			EncryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00251	45 8b c1	 mov	 r8d, r9d
  00254	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR cryptoInfo$[rsp]
  0025c	49 8b d2	 mov	 rdx, r10
  0025f	49 8b cf	 mov	 rcx, r15
  00262	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread
$LN15@Encryption@3:

; 561  : }

  00267	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  0026c	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00270	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  00274	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00278	49 8b e3	 mov	 rsp, r11
  0027b	41 5f		 pop	 r15
  0027d	41 5e		 pop	 r14
  0027f	41 5d		 pop	 r13
  00281	41 5c		 pop	 r12
  00283	5f		 pop	 rdi
  00284	c3		 ret	 0
$LN37@Encryption@3:
EncryptionThreadPoolDoWork ENDP
DequeuePosition DD 01H DUP (?)
DequeueMutex DB	038H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptionThreadProc DD imagerel EncryptionThreadProc
	DD	imagerel EncryptionThreadProc+635
	DD	imagerel $unwind$EncryptionThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadProc DD 040a01H
	DD	0a340aH
	DD	07006720aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptionThreadProc
_TEXT	SEGMENT
threadArg$ = 80
EncryptionThreadProc PROC				; COMDAT

; 158  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 159  : 	EncryptionThreadPoolWorkItem *workItem;
; 160  : 
; 161  : 	while (!StopPending)

  0000a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR StopPending
  00010	85 c0		 test	 eax, eax
  00012	0f 85 12 02 00
	00		 jne	 $LN38@Encryption@4
  00018	8d 78 01	 lea	 edi, QWORD PTR [rax+1]
$LL21@Encryption@4:

; 162  : 	{
; 163  : 		GST_ACQUIRE_MUTEX (&DequeueMutex);

  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DequeueMutex
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex

; 164  : 
; 165  : 		workItem = &WorkItemQueue[DequeuePosition++];

  00028	48 63 1d 00 00
	00 00		 movsxd	 rbx, DWORD PTR DequeuePosition
  0002f	01 3d 00 00 00
	00		 add	 DWORD PTR DequeuePosition, edi
  00035	48 6b db 78	 imul	 rbx, 120		; 00000078H
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  00040	48 03 d8	 add	 rbx, rax

; 166  : 
; 167  : 		if (DequeuePosition >= GST_ENC_THREAD_POOL_QUEUE_SIZE)

  00043	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DequeuePosition
  00049	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0004e	7c 0a		 jl	 SHORT $LN34@Encryption@4

; 168  : 			DequeuePosition = 0;

  00050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DequeuePosition, 0
$LN34@Encryption@4:

; 169  : 
; 170  : 		while (!StopPending && GetWorkItemState (workItem) != WorkItemReady)

  0005a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR StopPending
  00060	85 c0		 test	 eax, eax
  00062	75 31		 jne	 SHORT $LN17@Encryption@4
$LL18@Encryption@4:
  00064	33 c0		 xor	 eax, eax
  00066	f0 0f c1 03	 lock xadd DWORD PTR [rbx], eax
  0006a	3b c7		 cmp	 eax, edi
  0006c	74 27		 je	 SHORT $LN17@Encryption@4

; 171  : 		{
; 172  : 			GST_WAIT_EVENT (WorkItemReadyEvent);

  0006e	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  0007b	45 33 c9	 xor	 r9d, r9d
  0007e	45 33 c0	 xor	 r8d, r8d
  00081	33 d2		 xor	 edx, edx
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00089	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR StopPending
  00090	45 85 db	 test	 r11d, r11d
  00093	74 cf		 je	 SHORT $LL18@Encryption@4
$LN17@Encryption@4:

; 173  : 		}
; 174  : 
; 175  : 		SetWorkItemState (workItem, WorkItemBusy);

  00095	b8 02 00 00 00	 mov	 eax, 2

; 176  : 
; 177  : 		GST_RELEASE_MUTEX (&DequeueMutex);

  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DequeueMutex
  000a1	87 03		 xchg	 DWORD PTR [rbx], eax
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseFastMutex

; 178  : 
; 179  : 		if (StopPending)

  000a9	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR StopPending
  000b0	45 85 db	 test	 r11d, r11d
  000b3	0f 85 71 01 00
	00		 jne	 $LN38@Encryption@4

; 180  : 			break;
; 181  : 
; 182  : 		switch (workItem->Type)

  000b9	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  000bc	85 c9		 test	 ecx, ecx
  000be	0f 84 09 01 00
	00		 je	 $LN12@Encryption@4
  000c4	2b cf		 sub	 ecx, edi
  000c6	0f 84 ea 00 00
	00		 je	 $LN13@Encryption@4
  000cc	3b cf		 cmp	 ecx, edi
  000ce	0f 85 88 01 00
	00		 jne	 $LN37@Encryption@4

; 190  : 			break;
; 191  : 
; 192  : 		case DeriveKeyWork:
; 193  : 			switch (workItem->KeyDerivation.Pkcs5Prf)

  000d4	8b 4b 6c	 mov	 ecx, DWORD PTR [rbx+108]
  000d7	2b cf		 sub	 ecx, edi
  000d9	74 6e		 je	 SHORT $LN6@Encryption@4
  000db	2b cf		 sub	 ecx, edi
  000dd	74 39		 je	 SHORT $LN7@Encryption@4
  000df	3b cf		 cmp	 ecx, edi
  000e1	0f 85 56 01 00
	00		 jne	 $LN39@Encryption@4

; 194  : 			{
; 195  : #ifndef GST_WINDOWS_BOOT
; 196  : 			case WHIRLPOOL:
; 197  : 				derive_key_whirlpool (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 198  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  000e7	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  000ec	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  000f0	8b 53 68	 mov	 edx, DWORD PTR [rbx+104]
  000f3	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000f7	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000fb	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  000ff	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00104	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  00107	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  0010d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00111	e8 00 00 00 00	 call	 derive_key_whirlpool

; 199  : 				break;

  00116	eb 60		 jmp	 SHORT $LN9@Encryption@4
$LN7@Encryption@4:

; 200  : 			case GOSTHASH:
; 201  : 				derive_key_gosthash (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 202  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00118	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  0011d	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  00121	8b 53 68	 mov	 edx, DWORD PTR [rbx+104]
  00124	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00128	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0012c	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00130	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00135	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  00138	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  0013e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00142	e8 00 00 00 00	 call	 derive_key_gosthash

; 203  : 				break;

  00147	eb 2f		 jmp	 SHORT $LN9@Encryption@4
$LN6@Encryption@4:

; 204  : #endif
; 205  : 			case STRIBOG:
; 206  : 				derive_key_stribog (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 207  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00149	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  0014e	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  00152	8b 53 68	 mov	 edx, DWORD PTR [rbx+104]
  00155	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00159	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0015d	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00161	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00166	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  00169	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  0016f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00173	e8 00 00 00 00	 call	 derive_key_stribog
$LN9@Encryption@4:

; 211  : 			} 
; 212  : 
; 213  : 			InterlockedExchange (workItem->KeyDerivation.CompletionFlag, TRUE);

  00178	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0017c	8b cf		 mov	 ecx, edi

; 214  : 			GST_SET_EVENT (*workItem->KeyDerivation.CompletionEvent);

  0017e	45 33 c0	 xor	 r8d, r8d
  00181	87 08		 xchg	 DWORD PTR [rax], ecx
  00183	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00187	8b d7		 mov	 edx, edi
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 215  : 			
; 216  : 			if (InterlockedDecrement (workItem->KeyDerivation.OutstandingWorkItemCount) == 0)

  0018f	4c 8b 5b 58	 mov	 r11, QWORD PTR [rbx+88]
  00193	f0 41 83 03 ff	 lock add DWORD PTR [r11], -1
  00198	75 0f		 jne	 SHORT $LN4@Encryption@4

; 217  : 				GST_SET_EVENT (*workItem->KeyDerivation.NoOutstandingWorkItemEvent);

  0019a	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  0019e	45 33 c0	 xor	 r8d, r8d
  001a1	8b d7		 mov	 edx, edi
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN4@Encryption@4:

; 218  : 
; 219  : 			SetWorkItemState (workItem, WorkItemFree);

  001a9	33 c0		 xor	 eax, eax

; 220  : 			GST_SET_EVENT (WorkItemCompletedEvent);

  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  001b2	87 03		 xchg	 DWORD PTR [rbx], eax

; 221  : 			continue;

  001b4	eb 5b		 jmp	 SHORT $LN42@Encryption@4
$LN13@Encryption@4:

; 183  : 		{
; 184  : 		case DecryptDataUnitsWork:
; 185  : 			DecryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  001b6	44 8b 43 48	 mov	 r8d, DWORD PTR [rbx+72]
  001ba	4c 8b 4b 30	 mov	 r9, QWORD PTR [rbx+48]
  001be	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  001c2	48 8d 53 40	 lea	 rdx, QWORD PTR [rbx+64]
  001c6	e8 00 00 00 00	 call	 DecryptDataUnitsCurrentThread

; 186  : 			break;

  001cb	eb 15		 jmp	 SHORT $LN14@Encryption@4
$LN12@Encryption@4:

; 187  : 
; 188  : 		case EncryptDataUnitsWork:
; 189  : 			EncryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  001cd	44 8b 43 48	 mov	 r8d, DWORD PTR [rbx+72]
  001d1	4c 8b 4b 30	 mov	 r9, QWORD PTR [rbx+48]
  001d5	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  001d9	48 8d 53 40	 lea	 rdx, QWORD PTR [rbx+64]
  001dd	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread
$LN14@Encryption@4:

; 225  : 		}
; 226  : 
; 227  : 		if (workItem != workItem->FirstFragment)

  001e2	48 3b 5b 20	 cmp	 rbx, QWORD PTR [rbx+32]
  001e6	74 16		 je	 SHORT $LN2@Encryption@4

; 228  : 		{
; 229  : 			SetWorkItemState (workItem, WorkItemFree);

  001e8	33 c0		 xor	 eax, eax

; 230  : 			GST_SET_EVENT (WorkItemCompletedEvent);

  001ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  001f1	45 33 c0	 xor	 r8d, r8d
  001f4	87 03		 xchg	 DWORD PTR [rbx], eax
  001f6	8b d7		 mov	 edx, edi
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN2@Encryption@4:

; 231  : 		}
; 232  : 
; 233  : 		if (InterlockedDecrement (&workItem->FirstFragment->OutstandingFragmentCount) == 0)

  001fe	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00202	f0 83 41 28 ff	 lock add DWORD PTR [rcx+40], -1
  00207	75 13		 jne	 SHORT $LN1@Encryption@4

; 234  : 			GST_SET_EVENT (workItem->FirstFragment->ItemCompletedEvent);

  00209	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0020d	48 83 c1 08	 add	 rcx, 8
$LN42@Encryption@4:
  00211	45 33 c0	 xor	 r8d, r8d
  00214	8b d7		 mov	 edx, edi
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN1@Encryption@4:
  0021c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR StopPending
  00222	85 c0		 test	 eax, eax
  00224	0f 84 f1 fd ff
	ff		 je	 $LL21@Encryption@4
$LN38@Encryption@4:

; 235  : 	}
; 236  : 
; 237  : #ifdef DEVICE_DRIVER
; 238  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  0022a	33 c9		 xor	 ecx, ecx

; 239  : #else
; 240  : 	_endthreadex (0);
; 241  :     return 0;
; 242  : #endif
; 243  : }

  0022c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00231	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00235	5f		 pop	 rdi
  00236	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_PsTerminateSystemThread
$LN39@Encryption@4:

; 208  : 				break;
; 209  : 			default:		
; 210  : 				GST_THROW_FATAL_EXCEPTION;

  0023d	45 33 c9	 xor	 r9d, r9d
  00240	45 33 c0	 xor	 r8d, r8d
  00243	ba d2 00 00 00	 mov	 edx, 210		; 000000d2H
  00248	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0024c	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0025b	cc		 int	 3
$LN37@Encryption@4:

; 222  : 
; 223  : 		default:
; 224  : 			GST_THROW_FATAL_EXCEPTION;

  0025c	45 33 c9	 xor	 r9d, r9d
  0025f	45 33 c0	 xor	 r8d, r8d
  00262	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  00267	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0026b	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0027a	cc		 int	 3
$LN41@Encryption@4:
EncryptionThreadProc ENDP
PUBLIC	EncryptionThreadPoolStart
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$EncryptionThreadPoolStart DD imagerel $LN33
	DD	imagerel $LN33+422
	DD	imagerel $unwind$EncryptionThreadPoolStart
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolStart DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
xdata	ENDS
;	COMDAT EncryptionThreadPoolStart
_TEXT	SEGMENT
encryptionFreeCpuCount$ = 48
EncryptionThreadPoolStart PROC				; COMDAT

; 255  : {

$LN33:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 256  : 	size_t cpuCount, i;
; 257  : 
; 258  : 	if (ThreadPoolRunning)

  00014	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0001a	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR EncryptionThreadPoolFreeCpuCountLimit
  00021	85 c0		 test	 eax, eax
  00023	74 0a		 je	 SHORT $LN11@Encryption@5

; 259  : 		return TRUE;

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	e9 59 01 00 00	 jmp	 $LN12@Encryption@5
$LN11@Encryption@5:

; 260  : 
; 261  : #ifdef DEVICE_DRIVER
; 262  : 	cpuCount = GetCpuCount();

  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeQueryActiveProcessors
  00035	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0003a	33 ff		 xor	 edi, edi
  0003c	8d 5a c1	 lea	 ebx, QWORD PTR [rdx-63]
  0003f	48 8b ca	 mov	 rcx, rdx
$LL17@Encryption@5:
  00042	48 2b cb	 sub	 rcx, rbx
  00045	84 c3		 test	 al, bl
  00047	74 03		 je	 SHORT $LN15@Encryption@5
  00049	48 03 fb	 add	 rdi, rbx
$LN15@Encryption@5:
  0004c	48 d1 e8	 shr	 rax, 1
  0004f	48 85 c9	 test	 rcx, rcx
  00052	75 ee		 jne	 SHORT $LL17@Encryption@5
  00054	48 85 ff	 test	 rdi, rdi
  00057	48 0f 44 fb	 cmove	 rdi, rbx

; 263  : #else
; 264  : 	{
; 265  : 		SYSTEM_INFO sysInfo;
; 266  : 		GetSystemInfo (&sysInfo);
; 267  : 		cpuCount = sysInfo.dwNumberOfProcessors;
; 268  : 	}
; 269  : #endif
; 270  : 
; 271  : 	if (cpuCount > encryptionFreeCpuCount)

  0005b	48 3b fe	 cmp	 rdi, rsi
  0005e	76 03		 jbe	 SHORT $LN10@Encryption@5

; 272  : 		cpuCount -= encryptionFreeCpuCount;

  00060	48 2b fe	 sub	 rdi, rsi
$LN10@Encryption@5:

; 273  : 
; 274  : 	if (cpuCount < 2)

  00063	48 83 ff 02	 cmp	 rdi, 2

; 275  : 		return TRUE;

  00067	0f 82 19 01 00
	00		 jb	 $LN32@Encryption@5

; 276  : 
; 277  : 	if (cpuCount > GST_ENC_THREAD_POOL_MAX_THREAD_COUNT)

  0006d	48 3b fa	 cmp	 rdi, rdx

; 278  : 		cpuCount = GST_ENC_THREAD_POOL_MAX_THREAD_COUNT;
; 279  : 
; 280  : 	StopPending = FALSE;

  00070	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR StopPending, 0

; 281  : 	DequeuePosition = 0;

  0007a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DequeuePosition, 0
  00084	48 0f 47 fa	 cmova	 rdi, rdx

; 282  : 	EnqueuePosition = 0;

  00088	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EnqueuePosition, 0

; 283  : 
; 284  : #ifdef DEVICE_DRIVER
; 285  : 	KeInitializeEvent (&WorkItemReadyEvent, SynchronizationEvent, FALSE);

  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  00099	45 33 c0	 xor	 r8d, r8d
  0009c	8b d3		 mov	 edx, ebx
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 286  : 	KeInitializeEvent (&WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  000ab	45 33 c0	 xor	 r8d, r8d
  000ae	8b d3		 mov	 edx, ebx
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 287  : #else
; 288  : 	WorkItemReadyEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 289  : 	if (!WorkItemReadyEvent)
; 290  : 		return FALSE;
; 291  : 	
; 292  : 	WorkItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 293  : 	if (!WorkItemCompletedEvent)
; 294  : 		return FALSE;
; 295  : #endif
; 296  : 	
; 297  : #ifdef DEVICE_DRIVER
; 298  : 	ExInitializeFastMutex (&DequeueMutex);

  000b6	48 83 25 08 00
	00 00 00	 and	 QWORD PTR DequeueMutex+8, 0
  000be	83 25 10 00 00
	00 00		 and	 DWORD PTR DequeueMutex+16, 0
  000c5	89 1d 00 00 00
	00		 mov	 DWORD PTR DequeueMutex, ebx
  000cb	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:DequeueMutex+24
  000d2	45 33 c0	 xor	 r8d, r8d
  000d5	8b d3		 mov	 edx, ebx
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 299  : 	ExInitializeFastMutex (&EnqueueMutex);

  000dd	48 83 25 08 00
	00 00 00	 and	 QWORD PTR EnqueueMutex+8, 0
  000e5	83 25 10 00 00
	00 00		 and	 DWORD PTR EnqueueMutex+16, 0
  000ec	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex+24
  000f3	45 33 c0	 xor	 r8d, r8d
  000f6	8b d3		 mov	 edx, ebx
  000f8	89 1d 00 00 00
	00		 mov	 DWORD PTR EnqueueMutex, ebx
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 300  : #else
; 301  : 	DequeueMutex = CreateMutex (NULL, FALSE, NULL);
; 302  : 	if (!DequeueMutex)
; 303  : 		return FALSE;
; 304  : 
; 305  : 	EnqueueMutex = CreateMutex (NULL, FALSE, NULL);
; 306  : 	if (!EnqueueMutex)
; 307  : 		return FALSE;
; 308  : #endif
; 309  : 
; 310  : 	memset (WorkItemQueue, 0, sizeof (WorkItemQueue));

  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemQueue
  0010b	33 d2		 xor	 edx, edx
  0010d	41 b8 00 3c 00
	00		 mov	 r8d, 15360		; 00003c00H
  00113	e8 00 00 00 00	 call	 memset
  00118	48 8d 35 08 00
	00 00		 lea	 rsi, OFFSET FLAT:WorkItemQueue+8
  0011f	bd 80 00 00 00	 mov	 ebp, 128		; 00000080H
$LL7@Encryption@5:

; 311  : 
; 312  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)
; 313  : 	{
; 314  : 		WorkItemQueue[i].State = WorkItemFree;

  00124	83 66 f8 00	 and	 DWORD PTR [rsi-8], 0

; 315  : 
; 316  : #ifdef DEVICE_DRIVER
; 317  : 		KeInitializeEvent (&WorkItemQueue[i].ItemCompletedEvent, SynchronizationEvent, FALSE);

  00128	45 33 c0	 xor	 r8d, r8d
  0012b	8b d3		 mov	 edx, ebx
  0012d	48 8b ce	 mov	 rcx, rsi
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent
  00136	48 83 c6 78	 add	 rsi, 120		; 00000078H
  0013a	48 2b eb	 sub	 rbp, rbx
  0013d	75 e5		 jne	 SHORT $LL7@Encryption@5

; 318  : #else
; 319  : 		WorkItemQueue[i].ItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 320  : 		if (!WorkItemQueue[i].ItemCompletedEvent)
; 321  : 		{
; 322  : 			EncryptionThreadPoolStop();
; 323  : 			return FALSE;
; 324  : 		}
; 325  : #endif
; 326  : 	}
; 327  : 
; 328  : 	for (ThreadCount = 0; ThreadCount < cpuCount; ++ThreadCount)

  0013f	33 c9		 xor	 ecx, ecx
  00141	89 0d 00 00 00
	00		 mov	 DWORD PTR ThreadCount, ecx
  00147	48 85 ff	 test	 rdi, rdi
  0014a	74 34		 je	 SHORT $LN2@Encryption@5
$LL4@Encryption@5:

; 329  : 	{
; 330  : #ifdef DEVICE_DRIVER
; 331  : 		if (!NT_SUCCESS (GSTStartThread (EncryptionThreadProc, NULL, &ThreadHandles[ThreadCount])))

  0014c	8b c1		 mov	 eax, ecx
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadHandles
  00155	33 d2		 xor	 edx, edx
  00157	4c 8d 04 c1	 lea	 r8, QWORD PTR [rcx+rax*8]
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionThreadProc
  00162	e8 00 00 00 00	 call	 GSTStartThread
  00167	85 c0		 test	 eax, eax
  00169	78 32		 js	 SHORT $LN27@Encryption@5
  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ThreadCount
  00171	03 cb		 add	 ecx, ebx
  00173	8b c1		 mov	 eax, ecx
  00175	89 0d 00 00 00
	00		 mov	 DWORD PTR ThreadCount, ecx
  0017b	48 3b c7	 cmp	 rax, rdi
  0017e	72 cc		 jb	 SHORT $LL4@Encryption@5
$LN2@Encryption@5:

; 338  : 		}
; 339  : 	}
; 340  : 
; 341  : 	ThreadPoolRunning = TRUE;

  00180	89 1d 00 00 00
	00		 mov	 DWORD PTR ThreadPoolRunning, ebx
$LN32@Encryption@5:

; 342  : 	return TRUE;

  00186	8b c3		 mov	 eax, ebx
$LN12@Encryption@5:

; 343  : }

  00188	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0018d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00192	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00197	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019b	5f		 pop	 rdi
  0019c	c3		 ret	 0
$LN27@Encryption@5:

; 332  : #else
; 333  : 		if (!(ThreadHandles[ThreadCount] = (HANDLE) _beginthreadex (NULL, 0, EncryptionThreadProc, NULL, 0, NULL)))
; 334  : #endif
; 335  : 		{
; 336  : 			EncryptionThreadPoolStop();

  0019d	e8 00 00 00 00	 call	 EncryptionThreadPoolStop

; 337  : 			return FALSE;

  001a2	33 c0		 xor	 eax, eax
  001a4	eb e2		 jmp	 SHORT $LN12@Encryption@5
EncryptionThreadPoolStart ENDP
END
