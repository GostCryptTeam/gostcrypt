; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ReadVolumeHeaderRecoveryMode
ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
PUBLIC	GetHeaderField64
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT GetHeaderField64
_TEXT	SEGMENT
header$ = 8
offset$ = 16
GetHeaderField64 PROC					; COMDAT

; 174  : 	UINT64_STRUCT uint64Struct;
; 175  : 
; 176  : #ifndef GST_NO_COMPILER_INT64
; 177  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  00000	48 63 c2	 movsxd	 rax, edx
  00003	4c 8b 04 08	 mov	 r8, QWORD PTR [rax+rcx]
  00007	49 8b c0	 mov	 rax, r8
  0000a	41 0f b6 c8	 movzx	 ecx, r8b
  0000e	48 c1 e8 08	 shr	 rax, 8
  00012	48 c1 e1 08	 shl	 rcx, 8
  00016	0f b6 c0	 movzx	 eax, al
  00019	48 0b c1	 or	 rax, rcx
  0001c	49 8b c8	 mov	 rcx, r8
  0001f	48 c1 e0 08	 shl	 rax, 8
  00023	48 c1 e9 10	 shr	 rcx, 16
  00027	0f b6 d1	 movzx	 edx, cl
  0002a	49 8b c8	 mov	 rcx, r8
  0002d	48 0b c2	 or	 rax, rdx
  00030	48 c1 e9 18	 shr	 rcx, 24
  00034	48 c1 e0 08	 shl	 rax, 8
  00038	0f b6 d1	 movzx	 edx, cl
  0003b	49 8b c8	 mov	 rcx, r8
  0003e	48 0b c2	 or	 rax, rdx
  00041	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  00045	48 c1 e0 08	 shl	 rax, 8
  00049	0f b6 d1	 movzx	 edx, cl
  0004c	49 8b c8	 mov	 rcx, r8
  0004f	48 0b c2	 or	 rax, rdx
  00052	48 c1 e9 28	 shr	 rcx, 40			; 00000028H
  00056	48 c1 e0 08	 shl	 rax, 8
  0005a	0f b6 d1	 movzx	 edx, cl
  0005d	49 8b c8	 mov	 rcx, r8
  00060	48 0b c2	 or	 rax, rdx
  00063	48 c1 e9 30	 shr	 rcx, 48			; 00000030H
  00067	49 c1 e8 38	 shr	 r8, 56			; 00000038H
  0006b	48 c1 e0 08	 shl	 rax, 8
  0006f	0f b6 d1	 movzx	 edx, cl
  00072	48 0b c2	 or	 rax, rdx
  00075	48 c1 e0 08	 shl	 rax, 8
  00079	49 0b c0	 or	 rax, r8

; 178  : #else
; 179  : 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; 180  : 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; 181  : #endif
; 182  : 	return uint64Struct;
; 183  : }

  0007c	c3		 ret	 0
GetHeaderField64 ENDP
_TEXT	ENDS
PUBLIC	GetHeaderField32
; Function compile flags: /Ogspy
;	COMDAT GetHeaderField32
_TEXT	SEGMENT
header$ = 8
offset$ = 16
GetHeaderField32 PROC					; COMDAT

; 159  : 	return BE32 (*(uint32 *) (header + offset));

  00000	48 63 c2	 movsxd	 rax, edx
  00003	44 8b 04 08	 mov	 r8d, DWORD PTR [rax+rcx]
  00007	41 8b c0	 mov	 eax, r8d
  0000a	41 0f b6 c8	 movzx	 ecx, r8b
  0000e	c1 e8 08	 shr	 eax, 8
  00011	c1 e1 08	 shl	 ecx, 8
  00014	0f b6 c0	 movzx	 eax, al
  00017	0b c1		 or	 eax, ecx
  00019	41 8b c8	 mov	 ecx, r8d
  0001c	41 c1 e8 18	 shr	 r8d, 24
  00020	c1 e0 08	 shl	 eax, 8
  00023	c1 e9 10	 shr	 ecx, 16
  00026	0f b6 d1	 movzx	 edx, cl
  00029	0b c2		 or	 eax, edx
  0002b	c1 e0 08	 shl	 eax, 8
  0002e	41 0b c0	 or	 eax, r8d

; 160  : }

  00031	c3		 ret	 0
GetHeaderField32 ENDP
_TEXT	ENDS
PUBLIC	GetHeaderField16
; Function compile flags: /Ogspy
;	COMDAT GetHeaderField16
_TEXT	SEGMENT
header$ = 8
offset$ = 16
GetHeaderField16 PROC					; COMDAT

; 144  : 	return BE16 (*(uint16 *) (header + offset));

  00000	48 63 c2	 movsxd	 rax, edx
  00003	0f b7 14 08	 movzx	 edx, WORD PTR [rax+rcx]
  00007	8b c2		 mov	 eax, edx
  00009	c1 e2 08	 shl	 edx, 8
  0000c	c1 e8 08	 shr	 eax, 8
  0000f	0b c2		 or	 eax, edx

; 145  : }

  00011	c3		 ret	 0
GetHeaderField16 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	ReadVolumeHeader
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$ReadVolumeHeader DD imagerel $LN225
	DD	imagerel $LN225+2679
	DD	imagerel $unwind$ReadVolumeHeader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadVolumeHeader DD 0a2619H
	DD	0ab0114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	0540H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\volumes.c
xdata	ENDS
;	COMDAT ReadVolumeHeader
_TEXT	SEGMENT
$T41755 = 64
pkcs5_prf$1$ = 64
retInfo$GSCopy$1$ = 72
retHeaderCryptoInfo$GSCopy$1$ = 80
bBoot$GSCopy$1$ = 88
outstandingWorkItemCount$ = 92
queuedWorkItems$1$ = 96
encryptionThreadCount$1$ = 104
encryptedHeader$GSCopy$1$ = 112
keyDerivationWorkItems$ = 112
noOutstandingWorkItemEvent$ = 120
keyDerivationCompletedEvent$ = 144
keyInfo$ = 176
header$ = 576
dk$ = 1088
__$ArrayPad$ = 1344
bBoot$ = 1440
encryptedHeader$ = 1448
password$ = 1456
retInfo$ = 1464
retHeaderCryptoInfo$ = 1472
ReadVolumeHeader PROC					; COMDAT

; 212  : {

$LN225:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec 58 05
	00 00		 sub	 rsp, 1368		; 00000558H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 40
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 213  : 	char header[GST_VOLUME_HEADER_EFFECTIVE_SIZE];
; 214  : 	KEY_INFO keyInfo;
; 215  : 	PCRYPTO_INFO cryptoInfo;
; 216  : 	char dk[MASTER_KEYDATA_SIZE];
; 217  : 	int enqPkcs5Prf, pkcs5_prf;
; 218  : 	uint16 headerVersion;
; 219  : 	int status = ERR_PARAMETER_INCORRECT;
; 220  : 	int primaryKeyOffset;
; 221  : 
; 222  : 	GST_EVENT keyDerivationCompletedEvent;
; 223  : 	GST_EVENT noOutstandingWorkItemEvent;
; 224  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 225  : 	KeyDerivationWorkItem *item;
; 226  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;
; 227  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  00026	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0002c	89 4c 24 58	 mov	 DWORD PTR bBoot$GSCopy$1$[rsp], ecx
  00030	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR retHeaderCryptoInfo$[rsp]
  00038	f7 d8		 neg	 eax
  0003a	4d 8b e9	 mov	 r13, r9
  0003d	4c 89 4c 24 48	 mov	 QWORD PTR retInfo$GSCopy$1$[rsp], r9
  00042	1b c0		 sbb	 eax, eax

; 228  : 	size_t queuedWorkItems = 0;

  00044	45 33 e4	 xor	 r12d, r12d
  00047	49 8b f0	 mov	 rsi, r8
  0004a	23 05 00 00 00
	00		 and	 eax, DWORD PTR ThreadCount

; 229  : 	LONG outstandingWorkItemCount = 0;

  00050	44 21 64 24 5c	 and	 DWORD PTR outstandingWorkItemCount$[rsp], r12d
  00055	48 8b ea	 mov	 rbp, rdx
  00058	8b f8		 mov	 edi, eax
  0005a	48 89 54 24 70	 mov	 QWORD PTR encryptedHeader$GSCopy$1$[rsp], rdx
  0005f	48 89 4c 24 50	 mov	 QWORD PTR retHeaderCryptoInfo$GSCopy$1$[rsp], rcx
  00064	4c 89 64 24 60	 mov	 QWORD PTR queuedWorkItems$1$[rsp], r12
  00069	48 89 7c 24 68	 mov	 QWORD PTR encryptionThreadCount$1$[rsp], rdi

; 230  : 	int i;
; 231  : 
; 232  : 	if (retHeaderCryptoInfo != NULL)

  0006e	48 85 c9	 test	 rcx, rcx
  00071	74 68		 je	 SHORT $LN84@ReadVolume

; 233  : 	{
; 234  : 		cryptoInfo = retHeaderCryptoInfo;

  00073	48 8b d9	 mov	 rbx, rcx
$LN82@ReadVolume:

; 241  : 	}
; 242  : 
; 243  : 	if (encryptionThreadCount > 1)

  00076	41 bd 01 00 00
	00		 mov	 r13d, 1
  0007c	49 3b fd	 cmp	 rdi, r13
  0007f	76 75		 jbe	 SHORT $LN215@ReadVolume

; 244  : 	{
; 245  : 		keyDerivationWorkItems = GSTalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00081	ba 24 03 00 00	 mov	 edx, 804		; 00000324H
  00086	33 c9		 xor	 ecx, ecx
  00088	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00094	4c 8b f8	 mov	 r15, rax

; 246  : 		if (!keyDerivationWorkItems)

  00097	48 85 c0	 test	 rax, rax

; 247  : 			return ERR_OUTOFMEMORY;

  0009a	74 50		 je	 SHORT $LN224@ReadVolume

; 248  : 
; 249  : 		for (i = 0; i < pkcs5PrfCount; ++i)

  0009c	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  000a2	41 8d 4d 02	 lea	 ecx, QWORD PTR [r13+2]
$LL79@ReadVolume:

; 250  : 			keyDerivationWorkItems[i].Free = TRUE;

  000a6	44 89 28	 mov	 DWORD PTR [rax], r13d
  000a9	48 05 0c 01 00
	00		 add	 rax, 268		; 0000010cH
  000af	49 2b cd	 sub	 rcx, r13
  000b2	75 f2		 jne	 SHORT $LL79@ReadVolume

; 251  : 
; 252  : #ifdef DEVICE_DRIVER
; 253  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);

  000b4	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR keyDerivationCompletedEvent$[rsp]
  000bc	45 33 c0	 xor	 r8d, r8d
  000bf	41 8b d5	 mov	 edx, r13d
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 254  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);

  000c8	48 8d 4c 24 78	 lea	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  000cd	45 8a c5	 mov	 r8b, r13b
  000d0	41 8b d5	 mov	 edx, r13d
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent
  000d9	eb 20		 jmp	 SHORT $LN81@ReadVolume
$LN84@ReadVolume:

; 235  : 	}
; 236  : 	else
; 237  : 	{
; 238  : 		cryptoInfo = *retInfo = crypto_open ();

  000db	e8 00 00 00 00	 call	 crypto_open
  000e0	48 8b d8	 mov	 rbx, rax
  000e3	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 239  : 		if (cryptoInfo == NULL)

  000e7	48 85 c0	 test	 rax, rax
  000ea	75 8a		 jne	 SHORT $LN82@ReadVolume
$LN224@ReadVolume:

; 240  : 			return ERR_OUTOFMEMORY;

  000ec	b8 02 00 00 00	 mov	 eax, 2
  000f1	e9 5d 09 00 00	 jmp	 $LN85@ReadVolume
$LN215@ReadVolume:

; 254  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);

  000f6	4c 8b 7c 24 70	 mov	 r15, QWORD PTR keyDerivationWorkItems$[rsp]
$LN81@ReadVolume:

; 255  : #else
; 256  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 257  : 		if (!keyDerivationCompletedEvent)
; 258  : 		{
; 259  : 			GSTfree (keyDerivationWorkItems);
; 260  : 			return ERR_OUTOFMEMORY;
; 261  : 		}
; 262  : 
; 263  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);
; 264  : 		if (!noOutstandingWorkItemEvent)
; 265  : 		{
; 266  : 			CloseHandle (keyDerivationCompletedEvent);
; 267  : 			GSTfree (keyDerivationWorkItems);
; 268  : 			return ERR_OUTOFMEMORY;
; 269  : 		}
; 270  : #endif
; 271  : 	}
; 272  : 		
; 273  : #ifndef DEVICE_DRIVER
; 274  : 	VirtualLock (&keyInfo, sizeof (keyInfo));
; 275  : 	VirtualLock (&dk, sizeof (dk));
; 276  : #endif
; 277  : 
; 278  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  000fb	4c 63 0e	 movsxd	 r9, DWORD PTR [rsi]
  000fe	41 be 40 00 00
	00		 mov	 r14d, 64		; 00000040H
  00104	48 8d bc 24 b8
	00 00 00	 lea	 rdi, QWORD PTR keyInfo$[rsp+8]
  0010c	33 c0		 xor	 eax, eax
  0010e	49 8b ce	 mov	 rcx, r14
  00111	44 89 8c 24 b4
	00 00 00	 mov	 DWORD PTR keyInfo$[rsp+4], r9d
  00119	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+8]
  00121	45 8b c6	 mov	 r8d, r14d
  00124	f3 aa		 rep stosb
$LL90@ReadVolume:
  00126	88 02		 mov	 BYTE PTR [rdx], al
  00128	49 03 d5	 add	 rdx, r13
  0012b	45 2b c5	 sub	 r8d, r13d
  0012e	75 f6		 jne	 SHORT $LL90@ReadVolume
  00130	48 8d 56 04	 lea	 rdx, QWORD PTR [rsi+4]
  00134	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  0013c	4d 8b c1	 mov	 r8, r9
  0013f	e8 00 00 00 00	 call	 memcpy

; 279  : 
; 280  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 281  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  00144	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+72]
  0014c	48 8b d5	 mov	 rdx, rbp
  0014f	4d 8b c6	 mov	 r8, r14
  00152	e8 00 00 00 00	 call	 memcpy

; 282  : 
; 283  : 	// Test all available PKCS5 PRFs
; 284  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  00157	41 8b ed	 mov	 ebp, r13d
  0015a	41 be 00 01 00
	00		 mov	 r14d, 256		; 00000100H
$LL76@ReadVolume:
  00160	83 fd 03	 cmp	 ebp, 3
  00163	7e 09		 jle	 SHORT $LN73@ReadVolume
  00165	4d 85 e4	 test	 r12, r12
  00168	0f 84 71 05 00
	00		 je	 $LN74@ReadVolume
$LN73@ReadVolume:

; 285  : 	{
; 286  : 
; 287  : 		if (encryptionThreadCount > 1)

  0016e	48 8b 44 24 68	 mov	 rax, QWORD PTR encryptionThreadCount$1$[rsp]
  00173	49 3b c5	 cmp	 rax, r13
  00176	0f 86 28 02 00
	00		 jbe	 $LN72@ReadVolume

; 288  : 		{
; 289  : 			// Enqueue key derivation on thread pool
; 290  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  0017c	4c 3b e0	 cmp	 r12, rax
  0017f	0f 83 81 01 00
	00		 jae	 $LN71@ReadVolume
  00185	83 fd 03	 cmp	 ebp, 3
  00188	0f 8f 78 01 00
	00		 jg	 $LN71@ReadVolume

; 291  : 			{
; 292  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  0018e	33 c0		 xor	 eax, eax
  00190	49 8b f7	 mov	 rsi, r15
$LL70@ReadVolume:

; 293  : 				{
; 294  : 					item = &keyDerivationWorkItems[i];
; 295  : 					if (item->Free)

  00193	83 be 00 01 00
	00 00		 cmp	 DWORD PTR [rsi+256], 0
  0019a	75 15		 jne	 SHORT $LN191@ReadVolume
  0019c	49 03 c5	 add	 rax, r13
  0019f	48 81 c6 0c 01
	00 00		 add	 rsi, 268		; 0000010cH
  001a6	48 83 f8 03	 cmp	 rax, 3
  001aa	7c e7		 jl	 SHORT $LL70@ReadVolume

; 296  : 					{
; 297  : 						item->Free = FALSE;
; 298  : 						item->KeyReady = FALSE;
; 299  : 						item->Pkcs5Prf = enqPkcs5Prf;
; 300  : 
; 301  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 302  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 303  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  001ac	e9 4a 01 00 00	 jmp	 $LN68@ReadVolume
$LN191@ReadVolume:
  001b1	8b 54 24 58	 mov	 edx, DWORD PTR bBoot$GSCopy$1$[rsp]
  001b5	83 a6 00 01 00
	00 00		 and	 DWORD PTR [rsi+256], 0
  001bc	4c 8d a6 04 01
	00 00		 lea	 r12, QWORD PTR [rsi+260]
  001c3	41 83 24 24 00	 and	 DWORD PTR [r12], 0
  001c8	8b cd		 mov	 ecx, ebp
  001ca	89 ae 08 01 00
	00		 mov	 DWORD PTR [rsi+264], ebp
  001d0	e8 00 00 00 00	 call	 get_pkcs5_iteration_count
  001d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ThreadPoolRunning
  001db	44 8b e8	 mov	 r13d, eax
  001de	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp+4]
  001e5	89 44 24 40	 mov	 DWORD PTR $T41755[rsp], eax
  001e9	85 c9		 test	 ecx, ecx
  001eb	0f 84 f8 04 00
	00		 je	 $LN196@ReadVolume
  001f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex
  001fe	48 63 3d 00 00
	00 00		 movsxd	 rdi, DWORD PTR EnqueuePosition
  00205	ff 05 00 00 00
	00		 inc	 DWORD PTR EnqueuePosition
  0020b	48 6b ff 78	 imul	 rdi, 120		; 00000078H
  0020f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  00216	48 03 f8	 add	 rdi, rax
  00219	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  0021f	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00224	7c 0a		 jl	 SHORT $LN183@ReadVolume
  00226	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EnqueuePosition, 0
$LN183@ReadVolume:
  00230	33 c0		 xor	 eax, eax
  00232	f0 0f c1 07	 lock xadd DWORD PTR [rdi], eax
  00236	85 c0		 test	 eax, eax
  00238	74 25		 je	 SHORT $LN98@ReadVolume
$LL99@ReadVolume:
  0023a	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  00247	45 33 c9	 xor	 r9d, r9d
  0024a	45 33 c0	 xor	 r8d, r8d
  0024d	33 d2		 xor	 edx, edx
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00255	33 d2		 xor	 edx, edx
  00257	f0 0f c1 17	 lock xadd DWORD PTR [rdi], edx
  0025b	85 d2		 test	 edx, edx
  0025d	75 db		 jne	 SHORT $LL99@ReadVolume
$LN98@ReadVolume:
  0025f	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR keyDerivationCompletedEvent$[rsp]
  00267	44 89 6f 48	 mov	 DWORD PTR [rdi+72], r13d
  0026b	c7 47 04 02 00
	00 00		 mov	 DWORD PTR [rdi+4], 2
  00272	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  00276	48 8d 44 24 78	 lea	 rax, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  0027b	4c 89 67 38	 mov	 QWORD PTR [rdi+56], r12
  0027f	48 89 47 50	 mov	 QWORD PTR [rdi+80], rax
  00283	48 8d 44 24 5c	 lea	 rax, QWORD PTR outstandingWorkItemCount$[rsp]
  00288	48 89 77 40	 mov	 QWORD PTR [rdi+64], rsi
  0028c	48 89 47 58	 mov	 QWORD PTR [rdi+88], rax
  00290	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR keyInfo$[rsp+8]
  00298	89 6f 6c	 mov	 DWORD PTR [rdi+108], ebp
  0029b	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  0029f	8b 44 24 40	 mov	 eax, DWORD PTR $T41755[rsp]
  002a3	41 bd 01 00 00
	00		 mov	 r13d, 1
  002a9	89 47 68	 mov	 DWORD PTR [rdi+104], eax
  002ac	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR keyInfo$[rsp+72]
  002b4	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax
  002b8	f0 44 01 6c 24
	5c		 lock add DWORD PTR outstandingWorkItemCount$[rsp], r13d
  002be	48 8d 4c 24 78	 lea	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  002c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeClearEvent
  002c9	41 8b d5	 mov	 edx, r13d
  002cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  002d3	87 17		 xchg	 DWORD PTR [rdi], edx
  002d5	41 8b d5	 mov	 edx, r13d
  002d8	45 33 c0	 xor	 r8d, r8d
  002db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
  002e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  002e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseFastMutex

; 304  : 						
; 305  : 						++queuedWorkItems;

  002ee	4c 8b 64 24 60	 mov	 r12, QWORD PTR queuedWorkItems$1$[rsp]
  002f3	4d 03 e5	 add	 r12, r13
  002f6	4c 89 64 24 60	 mov	 QWORD PTR queuedWorkItems$1$[rsp], r12
$LN68@ReadVolume:

; 306  : 						break;
; 307  : 					}
; 308  : 				}
; 309  : 
; 310  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  002fb	83 fd 03	 cmp	 ebp, 3
  002fe	0f 8c ce 03 00
	00		 jl	 $LN75@ReadVolume

; 311  : 					continue;
; 312  : 			}
; 313  : 			else

  00304	eb 03		 jmp	 SHORT $LN184@ReadVolume
$LN71@ReadVolume:

; 314  : 				--enqPkcs5Prf;

  00306	41 2b ed	 sub	 ebp, r13d
$LN184@ReadVolume:

; 315  : 
; 316  : 			// Wait for completion of a key derivation
; 317  : 			while (queuedWorkItems > 0)

  00309	4d 85 e4	 test	 r12, r12
  0030c	0f 84 c0 03 00
	00		 je	 $LN75@ReadVolume
$LL64@ReadVolume:

; 318  : 			{
; 319  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00312	33 d2		 xor	 edx, edx
  00314	49 8d 8f 04 01
	00 00		 lea	 rcx, QWORD PTR [r15+260]
$LL62@ReadVolume:

; 320  : 				{
; 321  : 					item = &keyDerivationWorkItems[i];
; 322  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  0031b	83 79 fc 00	 cmp	 DWORD PTR [rcx-4], 0
  0031f	48 8d b9 fc fe
	ff ff		 lea	 rdi, QWORD PTR [rcx-260]
  00326	75 0b		 jne	 SHORT $LN61@ReadVolume
  00328	33 c0		 xor	 eax, eax
  0032a	f0 0f c1 01	 lock xadd DWORD PTR [rcx], eax
  0032e	41 3b c5	 cmp	 eax, r13d
  00331	74 2e		 je	 SHORT $LN192@ReadVolume
$LN61@ReadVolume:

; 318  : 			{
; 319  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00333	49 03 d5	 add	 rdx, r13
  00336	48 81 c1 0c 01
	00 00		 add	 rcx, 268		; 0000010cH
  0033d	48 83 fa 03	 cmp	 rdx, 3
  00341	7c d8		 jl	 SHORT $LL62@ReadVolume

; 330  : 						goto KeyReady;
; 331  : 					}
; 332  : 				}
; 333  : 
; 334  : 				if (queuedWorkItems > 0)
; 335  : 					GST_WAIT_EVENT (keyDerivationCompletedEvent);

  00343	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00349	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR keyDerivationCompletedEvent$[rsp]
  00351	45 33 c9	 xor	 r9d, r9d
  00354	45 33 c0	 xor	 r8d, r8d
  00357	33 d2		 xor	 edx, edx
  00359	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0035f	eb b1		 jmp	 SHORT $LL64@ReadVolume
$LN192@ReadVolume:

; 323  : 					{
; 324  : 						pkcs5_prf = item->Pkcs5Prf;

  00361	8b b7 08 01 00
	00		 mov	 esi, DWORD PTR [rdi+264]

; 325  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  00367	8b 54 24 58	 mov	 edx, DWORD PTR bBoot$GSCopy$1$[rsp]
  0036b	8b ce		 mov	 ecx, esi
  0036d	89 74 24 40	 mov	 DWORD PTR pkcs5_prf$1$[rsp], esi
  00371	e8 00 00 00 00	 call	 get_pkcs5_iteration_count

; 326  : 						memcpy (dk, item->DerivedKey, sizeof (dk));

  00376	48 8d 8c 24 40
	04 00 00	 lea	 rcx, QWORD PTR dk$[rsp]
  0037e	48 8b d7	 mov	 rdx, rdi
  00381	4d 8b c6	 mov	 r8, r14
  00384	89 84 24 b0 00
	00 00		 mov	 DWORD PTR keyInfo$[rsp], eax
  0038b	e8 00 00 00 00	 call	 memcpy

; 327  : 
; 328  : 						item->Free = TRUE;
; 329  : 						--queuedWorkItems;

  00390	4d 2b e5	 sub	 r12, r13
  00393	44 89 af 00 01
	00 00		 mov	 DWORD PTR [rdi+256], r13d
  0039a	4c 89 64 24 60	 mov	 QWORD PTR queuedWorkItems$1$[rsp], r12
$KeyReady$28309:

; 336  : 			}
; 337  : 			continue;
; 338  : KeyReady:	;
; 339  : 		}
; 340  : 		else

  0039f	e9 e9 00 00 00	 jmp	 $LN55@ReadVolume
$LN72@ReadVolume:

; 341  : 		{
; 342  : 			pkcs5_prf = enqPkcs5Prf;
; 343  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  003a4	8b 54 24 58	 mov	 edx, DWORD PTR bBoot$GSCopy$1$[rsp]
  003a8	8b cd		 mov	 ecx, ebp
  003aa	89 6c 24 40	 mov	 DWORD PTR pkcs5_prf$1$[rsp], ebp
  003ae	e8 00 00 00 00	 call	 get_pkcs5_iteration_count

; 344  : 
; 345  : 			switch (pkcs5_prf)

  003b3	8b d5		 mov	 edx, ebp
  003b5	41 2b d5	 sub	 edx, r13d
  003b8	8b f8		 mov	 edi, eax
  003ba	89 84 24 b0 00
	00 00		 mov	 DWORD PTR keyInfo$[rsp], eax
  003c1	0f 84 8a 00 00
	00		 je	 $LN53@ReadVolume
  003c7	41 2b d5	 sub	 edx, r13d
  003ca	74 47		 je	 SHORT $LN52@ReadVolume
  003cc	41 3b d5	 cmp	 edx, r13d
  003cf	0f 85 33 03 00
	00		 jne	 $LN214@ReadVolume

; 346  : 			{
; 347  : 			case WHIRLPOOL:
; 348  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 349  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  003d5	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  003da	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  003e1	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  003e9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  003ed	48 8d 84 24 40
	04 00 00	 lea	 rax, QWORD PTR dk$[rsp]
  003f5	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  003fd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00402	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00408	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  0040c	e8 00 00 00 00	 call	 derive_key_whirlpool

; 350  : 				break;

  00411	eb 7a		 jmp	 SHORT $LN55@ReadVolume
$LN52@ReadVolume:

; 354  : 				break;
; 355  : 			case GOSTHASH:
; 356  : 				derive_key_gosthash (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 357  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00413	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00418	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  0041f	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  00427	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0042b	48 8d 84 24 40
	04 00 00	 lea	 rax, QWORD PTR dk$[rsp]
  00433	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  0043b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00440	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00446	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  0044a	e8 00 00 00 00	 call	 derive_key_gosthash

; 358  : 				break;

  0044f	eb 3c		 jmp	 SHORT $LN55@ReadVolume
$LN53@ReadVolume:

; 351  : 			case STRIBOG:
; 352  : 				derive_key_stribog (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 353  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00451	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00456	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  0045d	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  00465	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00469	48 8d 84 24 40
	04 00 00	 lea	 rax, QWORD PTR dk$[rsp]
  00471	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  00479	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0047e	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00484	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00488	e8 00 00 00 00	 call	 derive_key_stribog
$LN55@ReadVolume:

; 362  : 			} 
; 363  : 		}
; 364  : 
; 365  : 		// Test all available modes of operation
; 366  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; 367  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 368  : 			cryptoInfo->mode++)

  0048d	44 89 6b 04	 mov	 DWORD PTR [rbx+4], r13d
$LL50@ReadVolume:

; 369  : 		{
; 370  : 			switch (cryptoInfo->mode)
; 371  : 			{
; 372  : 			default:
; 373  : 				primaryKeyOffset = 0;
; 374  : 			}
; 375  : 
; 376  : 			// Test all available encryption algorithms
; 377  : 			for (cryptoInfo->ea = EAGetFirst ();
; 378  : 				cryptoInfo->ea != 0;
; 379  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  00491	44 89 2b	 mov	 DWORD PTR [rbx], r13d
$LL44@ReadVolume:

; 380  : 			{
; 381  : 				int blockSize;
; 382  : 
; 383  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  00494	8b 53 04	 mov	 edx, DWORD PTR [rbx+4]
  00497	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00499	e8 00 00 00 00	 call	 EAIsModeSupported
  0049e	85 c0		 test	 eax, eax
  004a0	0f 84 fa 01 00
	00		 je	 $LN43@ReadVolume

; 384  : 					continue;	// This encryption algorithm has never been available with this mode of operation
; 385  : 
; 386  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));
; 387  : 
; 388  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  004a6	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  004a9	0f 84 ef 04 00
	00		 je	 $LN212@ReadVolume
  004af	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  004b1	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  004b5	48 8d 94 24 40
	04 00 00	 lea	 rdx, QWORD PTR dk$[rsp]
  004bd	e8 00 00 00 00	 call	 EAInit
  004c2	8b f0		 mov	 esi, eax

; 389  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  004c4	83 f8 11	 cmp	 eax, 17
  004c7	0f 84 d6 04 00
	00		 je	 $LN220@ReadVolume

; 390  : 					goto err;
; 391  : 
; 392  : 				// Init objects related to the mode of operation
; 393  : 
; 394  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  004cd	44 39 6b 04	 cmp	 DWORD PTR [rbx+4], r13d
  004d1	74 06		 je	 SHORT $LN38@ReadVolume
  004d3	83 7b 04 02	 cmp	 DWORD PTR [rbx+4], 2
  004d7	75 3b		 jne	 SHORT $LN37@ReadVolume
$LN38@ReadVolume:

; 395  : 				{
; 396  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 397  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  004d9	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  004db	e8 00 00 00 00	 call	 EAGetKeySize
  004e0	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  004e2	48 63 f8	 movsxd	 rdi, eax
  004e5	e8 00 00 00 00	 call	 EAGetKeySize
  004ea	4c 8b c7	 mov	 r8, rdi
  004ed	48 63 c8	 movsxd	 rcx, eax
  004f0	48 8d 94 0c 40
	04 00 00	 lea	 rdx, QWORD PTR dk$[rsp+rcx]
  004f8	48 8d 8b 50 1d
	00 00		 lea	 rcx, QWORD PTR [rbx+7504]
  004ff	e8 00 00 00 00	 call	 memcpy

; 398  : 
; 399  : 					// Secondary key schedule
; 400  : 					if (!EAInitMode (cryptoInfo))

  00504	48 8b cb	 mov	 rcx, rbx
  00507	e8 00 00 00 00	 call	 EAInitMode
  0050c	85 c0		 test	 eax, eax
  0050e	0f 84 83 04 00
	00		 je	 $LN194@ReadVolume
$LN37@ReadVolume:

; 404  : 					}
; 405  : 				}
; 406  : 
; 407  : 				// Copy the header for decryption
; 408  : 				memcpy (header, encryptedHeader, sizeof (header));

  00514	48 8b 54 24 70	 mov	 rdx, QWORD PTR encryptedHeader$GSCopy$1$[rsp]
  00519	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00521	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00527	e8 00 00 00 00	 call	 memcpy

; 409  : 
; 410  : 				// Try to decrypt header 
; 411  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  0052c	44 39 6b 04	 cmp	 DWORD PTR [rbx+4], r13d
  00530	74 06		 je	 SHORT $LN35@ReadVolume
  00532	83 7b 04 02	 cmp	 DWORD PTR [rbx+4], 2
  00536	75 15		 jne	 SHORT $LN36@ReadVolume
$LN35@ReadVolume:

; 412  : 					DecryptBuffer(header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  00538	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR header$[rsp+64]
  00540	4c 8b c3	 mov	 r8, rbx
  00543	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  00548	e8 00 00 00 00	 call	 DecryptBuffer
$LN36@ReadVolume:

; 413  : 
; 414  : 				// Magic 'TRUE'
; 415  : 				if (GetHeaderField32 (header, GST_HEADER_OFFSET_MAGIC) != 0x54525545)

  0054d	8b bc 24 80 02
	00 00		 mov	 edi, DWORD PTR header$[rsp+64]
  00554	8b c7		 mov	 eax, edi
  00556	c1 e8 08	 shr	 eax, 8
  00559	0f b6 d0	 movzx	 edx, al
  0055c	40 0f b6 c7	 movzx	 eax, dil
  00560	c1 e0 08	 shl	 eax, 8
  00563	0b d0		 or	 edx, eax
  00565	8b c7		 mov	 eax, edi
  00567	c1 ef 18	 shr	 edi, 24
  0056a	c1 e2 08	 shl	 edx, 8
  0056d	c1 e8 10	 shr	 eax, 16
  00570	0f b6 c8	 movzx	 ecx, al
  00573	0b d1		 or	 edx, ecx
  00575	c1 e2 08	 shl	 edx, 8
  00578	0b d7		 or	 edx, edi
  0057a	81 fa 45 55 52
	54		 cmp	 edx, 1414681925		; 54525545H
  00580	0f 85 1a 01 00
	00		 jne	 $LN43@ReadVolume

; 416  : 					continue;
; 417  : 
; 418  : 				// Header version
; 419  : 				headerVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_VERSION);

  00586	44 0f b7 ac 24
	84 02 00 00	 movzx	 r13d, WORD PTR header$[rsp+68]

; 420  : 				
; 421  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  0058f	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  00594	66 41 c1 c5 08	 rol	 r13w, 8
  00599	66 44 3b e8	 cmp	 r13w, ax
  0059d	0f 87 e7 00 00
	00		 ja	 $LN195@ReadVolume

; 422  : 				{
; 423  : 					status = ERR_NEW_VERSION_REQUIRED;
; 424  : 					goto err;
; 425  : 				}
; 426  : 
; 427  : 				// Check CRC of the header fields
; 428  : 				if (!ReadVolumeHeaderRecoveryMode
; 429  : 					&& headerVersion >= 4
; 430  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC))

  005a3	44 8b 35 00 00
	00 00		 mov	 r14d, DWORD PTR ReadVolumeHeaderRecoveryMode
  005aa	45 85 f6	 test	 r14d, r14d
  005ad	75 52		 jne	 SHORT $LN32@ReadVolume
  005af	66 41 83 fd 04	 cmp	 r13w, 4
  005b4	72 4b		 jb	 SHORT $LN32@ReadVolume
  005b6	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR header$[rsp+64]
  005be	ba bc 00 00 00	 mov	 edx, 188		; 000000bcH
  005c3	e8 00 00 00 00	 call	 GetCrc32
  005c8	8b bc 24 3c 03
	00 00		 mov	 edi, DWORD PTR header$[rsp+252]
  005cf	44 8b d8	 mov	 r11d, eax
  005d2	8b cf		 mov	 ecx, edi
  005d4	c1 e9 08	 shr	 ecx, 8
  005d7	0f b6 c1	 movzx	 eax, cl
  005da	40 0f b6 cf	 movzx	 ecx, dil
  005de	c1 e1 08	 shl	 ecx, 8
  005e1	0b c1		 or	 eax, ecx
  005e3	8b cf		 mov	 ecx, edi
  005e5	c1 ef 18	 shr	 edi, 24
  005e8	c1 e0 08	 shl	 eax, 8
  005eb	c1 e9 10	 shr	 ecx, 16
  005ee	0f b6 d1	 movzx	 edx, cl
  005f1	0b c2		 or	 eax, edx
  005f3	c1 e0 08	 shl	 eax, 8
  005f6	0b c7		 or	 eax, edi
  005f8	41 3b c3	 cmp	 eax, r11d
  005fb	0f 85 93 00 00
	00		 jne	 $LN219@ReadVolume
$LN32@ReadVolume:

; 431  : 					continue;
; 432  : 
; 433  : 				// Required program version
; 434  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_REQUIRED_VERSION);

  00601	44 0f b7 a4 24
	86 02 00 00	 movzx	 r12d, WORD PTR header$[rsp+70]

; 435  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  0060a	33 c0		 xor	 eax, eax
  0060c	b9 00 06 00 00	 mov	 ecx, 1536		; 00000600H
  00611	66 41 c1 c4 08	 rol	 r12w, 8
  00616	66 44 3b e1	 cmp	 r12w, cx
  0061a	66 44 89 a3 e0
	1e 00 00	 mov	 WORD PTR [rbx+7904], r12w
  00622	0f 92 c0	 setb	 al

; 436  : 
; 437  : 				// Check CRC of the key set
; 438  : 				if (!ReadVolumeHeaderRecoveryMode
; 439  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  00625	45 85 f6	 test	 r14d, r14d
  00628	41 be 00 01 00
	00		 mov	 r14d, 256		; 00000100H
  0062e	89 83 e4 1e 00
	00		 mov	 DWORD PTR [rbx+7908], eax
  00634	75 45		 jne	 SHORT $LN31@ReadVolume
  00636	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp+256]
  0063e	41 8b d6	 mov	 edx, r14d
  00641	e8 00 00 00 00	 call	 GetCrc32
  00646	8b bc 24 88 02
	00 00		 mov	 edi, DWORD PTR header$[rsp+72]
  0064d	44 8b d8	 mov	 r11d, eax
  00650	8b cf		 mov	 ecx, edi
  00652	c1 e9 08	 shr	 ecx, 8
  00655	0f b6 c1	 movzx	 eax, cl
  00658	40 0f b6 cf	 movzx	 ecx, dil
  0065c	c1 e1 08	 shl	 ecx, 8
  0065f	0b c1		 or	 eax, ecx
  00661	8b cf		 mov	 ecx, edi
  00663	c1 ef 18	 shr	 edi, 24
  00666	c1 e0 08	 shl	 eax, 8
  00669	c1 e9 10	 shr	 ecx, 16
  0066c	0f b6 d1	 movzx	 edx, cl
  0066f	0b c2		 or	 eax, edx
  00671	c1 e0 08	 shl	 eax, 8
  00674	0b c7		 or	 eax, edi
  00676	41 3b c3	 cmp	 eax, r11d
  00679	75 1f		 jne	 SHORT $LN222@ReadVolume
$LN31@ReadVolume:

; 440  : 					continue;
; 441  : 
; 442  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 443  : 
; 444  : 				// Check the version required to handle this volume
; 445  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  0067b	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  00680	66 44 3b e0	 cmp	 r12w, ax
  00684	0f 86 9d 00 00
	00		 jbe	 $LN30@ReadVolume
$LN195@ReadVolume:

; 446  : 				{
; 447  : 					status = ERR_NEW_VERSION_REQUIRED;

  0068a	be 10 00 00 00	 mov	 esi, 16

; 448  : 					goto err;

  0068f	e9 0f 03 00 00	 jmp	 $LN220@ReadVolume
$LN219@ReadVolume:
  00694	41 be 00 01 00
	00		 mov	 r14d, 256		; 00000100H
$LN222@ReadVolume:

; 212  : {

  0069a	41 bd 01 00 00
	00		 mov	 r13d, 1
$LN43@ReadVolume:

; 369  : 		{
; 370  : 			switch (cryptoInfo->mode)
; 371  : 			{
; 372  : 			default:
; 373  : 				primaryKeyOffset = 0;
; 374  : 			}
; 375  : 
; 376  : 			// Test all available encryption algorithms
; 377  : 			for (cryptoInfo->ea = EAGetFirst ();
; 378  : 				cryptoInfo->ea != 0;
; 379  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  006a0	8b 13		 mov	 edx, DWORD PTR [rbx]
  006a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  006a9	41 03 d5	 add	 edx, r13d
  006ac	48 63 c2	 movsxd	 rax, edx
  006af	48 c1 e0 05	 shl	 rax, 5
  006b3	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  006b6	f7 d8		 neg	 eax
  006b8	1b c9		 sbb	 ecx, ecx
  006ba	23 ca		 and	 ecx, edx
  006bc	89 0b		 mov	 DWORD PTR [rbx], ecx
  006be	0f 85 d0 fd ff
	ff		 jne	 $LL44@ReadVolume
  006c4	44 01 6b 04	 add	 DWORD PTR [rbx+4], r13d
  006c8	83 7b 04 02	 cmp	 DWORD PTR [rbx+4], 2
  006cc	0f 8e bf fd ff
	ff		 jle	 $LL50@ReadVolume
$LN75@ReadVolume:

; 282  : 
; 283  : 	// Test all available PKCS5 PRFs
; 284  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  006d2	4c 8b 64 24 60	 mov	 r12, QWORD PTR queuedWorkItems$1$[rsp]
  006d7	41 03 ed	 add	 ebp, r13d
  006da	e9 81 fa ff ff	 jmp	 $LL76@ReadVolume
$LN74@ReadVolume:

; 540  : 			}
; 541  : 		}
; 542  : 	}
; 543  : 	status = ERR_PASSWORD_WRONG;

  006df	be 03 00 00 00	 mov	 esi, 3
  006e4	e9 ba 02 00 00	 jmp	 $LN220@ReadVolume
$LN196@ReadVolume:

; 296  : 					{
; 297  : 						item->Free = FALSE;
; 298  : 						item->KeyReady = FALSE;
; 299  : 						item->Pkcs5Prf = enqPkcs5Prf;
; 300  : 
; 301  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 302  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 303  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  006e9	45 33 c9	 xor	 r9d, r9d
  006ec	45 33 c0	 xor	 r8d, r8d
  006ef	ba 9e 01 00 00	 mov	 edx, 414		; 0000019eH
  006f4	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  006f8	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00701	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00707	cc		 int	 3
$LN214@ReadVolume:

; 359  : 			default:		
; 360  : 				// Unknown/wrong ID
; 361  : 				GST_THROW_FATAL_EXCEPTION;

  00708	45 33 c9	 xor	 r9d, r9d
  0070b	45 33 c0	 xor	 r8d, r8d
  0070e	ba 69 01 00 00	 mov	 edx, 361		; 00000169H
  00713	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00717	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00720	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00726	cc		 int	 3
$LN30@ReadVolume:

; 449  : 				}
; 450  : 
; 451  : 				// Header version
; 452  : 				cryptoInfo->HeaderVersion = headerVersion;
; 453  : 
; 454  : 				// Volume creation time (legacy)
; 455  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  00727	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  0072f	ba 4c 00 00 00	 mov	 edx, 76			; 0000004cH
  00734	66 44 89 ab 4c
	04 00 00	 mov	 WORD PTR [rbx+1100], r13w
  0073c	e8 00 00 00 00	 call	 GetHeaderField64

; 456  : 
; 457  : 				// Header creation time (legacy)
; 458  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_MODIFICATION_TIME).Value;

  00741	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00749	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  0074e	48 89 83 98 1e
	00 00		 mov	 QWORD PTR [rbx+7832], rax
  00755	e8 00 00 00 00	 call	 GetHeaderField64

; 459  : 
; 460  : 				// Hidden volume size (if any)
; 461  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  0075a	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00762	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00767	48 89 83 a0 1e
	00 00		 mov	 QWORD PTR [rbx+7840], rax
  0076e	e8 00 00 00 00	 call	 GetHeaderField64

; 462  : 
; 463  : 				// Hidden volume status
; 464  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  00773	33 c9		 xor	 ecx, ecx

; 465  : 
; 466  : 				// Volume size
; 467  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_SIZE);

  00775	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0077a	48 85 c0	 test	 rax, rax
  0077d	48 89 83 b8 1e
	00 00		 mov	 QWORD PTR [rbx+7864], rax
  00784	0f 95 c1	 setne	 cl
  00787	89 8b 48 04 00
	00		 mov	 DWORD PTR [rbx+1096], ecx
  0078d	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00795	e8 00 00 00 00	 call	 GetHeaderField64

; 468  : 				
; 469  : 				// Encrypted area size and length
; 470  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_START);

  0079a	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  007a2	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  007a7	48 89 83 f0 1e
	00 00		 mov	 QWORD PTR [rbx+7920], rax
  007ae	e8 00 00 00 00	 call	 GetHeaderField64

; 471  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  007b3	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  007bb	ba 74 00 00 00	 mov	 edx, 116		; 00000074H
  007c0	48 89 83 f8 1e
	00 00		 mov	 QWORD PTR [rbx+7928], rax
  007c7	e8 00 00 00 00	 call	 GetHeaderField64

; 472  : 
; 473  : 				// Flags
; 474  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, GST_HEADER_OFFSET_FLAGS);

  007cc	8b bc 24 bc 02
	00 00		 mov	 edi, DWORD PTR header$[rsp+124]
  007d3	48 89 83 00 1f
	00 00		 mov	 QWORD PTR [rbx+7936], rax
  007da	8b c7		 mov	 eax, edi
  007dc	c1 e8 08	 shr	 eax, 8
  007df	0f b6 d0	 movzx	 edx, al
  007e2	40 0f b6 c7	 movzx	 eax, dil
  007e6	c1 e0 08	 shl	 eax, 8
  007e9	0b d0		 or	 edx, eax
  007eb	8b c7		 mov	 eax, edi
  007ed	c1 ef 18	 shr	 edi, 24
  007f0	c1 e2 08	 shl	 edx, 8
  007f3	c1 e8 10	 shr	 eax, 16
  007f6	0f b6 c8	 movzx	 ecx, al
  007f9	0b d1		 or	 edx, ecx
  007fb	c1 e2 08	 shl	 edx, 8
  007fe	0b d7		 or	 edx, edi
  00800	89 93 08 1f 00
	00		 mov	 DWORD PTR [rbx+7944], edx

; 475  : 
; 476  : 				// Sector size
; 477  : 				if (headerVersion >= 5)

  00806	66 41 83 fd 05	 cmp	 r13w, 5
  0080b	72 35		 jb	 SHORT $LN29@ReadVolume

; 478  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, GST_HEADER_OFFSET_SECTOR_SIZE);

  0080d	8b bc 24 c0 02
	00 00		 mov	 edi, DWORD PTR header$[rsp+128]
  00814	8b c7		 mov	 eax, edi
  00816	c1 e8 08	 shr	 eax, 8
  00819	0f b6 d0	 movzx	 edx, al
  0081c	40 0f b6 c7	 movzx	 eax, dil
  00820	c1 e0 08	 shl	 eax, 8
  00823	0b d0		 or	 edx, eax
  00825	8b c7		 mov	 eax, edi
  00827	c1 ef 18	 shr	 edi, 24
  0082a	c1 e2 08	 shl	 edx, 8
  0082d	c1 e8 10	 shr	 eax, 16
  00830	0f b6 c8	 movzx	 ecx, al
  00833	0b d1		 or	 edx, ecx
  00835	c1 e2 08	 shl	 edx, 8
  00838	0b d7		 or	 edx, edi
  0083a	89 93 e8 1e 00
	00		 mov	 DWORD PTR [rbx+7912], edx

; 479  : 				else

  00840	eb 0a		 jmp	 SHORT $LN28@ReadVolume
$LN29@ReadVolume:

; 480  : 					cryptoInfo->SectorSize = GST_SECTOR_SIZE_LEGACY;

  00842	c7 83 e8 1e 00
	00 00 02 00 00	 mov	 DWORD PTR [rbx+7912], 512 ; 00000200H
$LN28@ReadVolume:

; 481  : 
; 482  : 				if (cryptoInfo->SectorSize < GST_MIN_VOLUME_SECTOR_SIZE
; 483  : 					|| cryptoInfo->SectorSize > GST_MAX_VOLUME_SECTOR_SIZE
; 484  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  0084c	8b 83 e8 1e 00
	00		 mov	 eax, DWORD PTR [rbx+7912]
  00852	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  00857	0f 82 33 01 00
	00		 jb	 $LN26@ReadVolume
  0085d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00862	0f 87 28 01 00
	00		 ja	 $LN26@ReadVolume
  00868	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  0086d	0f 85 1d 01 00
	00		 jne	 $LN26@ReadVolume

; 487  : 					goto err;
; 488  : 				}
; 489  : 
; 490  : 				// Preserve scheduled header keys if requested			
; 491  : 				if (retHeaderCryptoInfo)

  00873	48 8b 6c 24 50	 mov	 rbp, QWORD PTR retHeaderCryptoInfo$GSCopy$1$[rsp]

; 492  : 				{
; 493  : 					if (retInfo == NULL)

  00878	4c 8b 6c 24 48	 mov	 r13, QWORD PTR retInfo$GSCopy$1$[rsp]
  0087d	48 85 ed	 test	 rbp, rbp
  00880	74 4b		 je	 SHORT $LN25@ReadVolume
  00882	4d 85 ed	 test	 r13, r13
  00885	75 1c		 jne	 SHORT $LN24@ReadVolume

; 494  : 					{
; 495  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  00887	8b 44 24 40	 mov	 eax, DWORD PTR pkcs5_prf$1$[rsp]
  0088b	89 83 94 1e 00
	00		 mov	 DWORD PTR [rbx+7828], eax

; 496  : 						cryptoInfo->noIterations = keyInfo.noIterations;

  00891	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  00898	89 83 90 1e 00
	00		 mov	 DWORD PTR [rbx+7824], eax

; 497  : 						goto ret;

  0089e	e9 1c 01 00 00	 jmp	 $ret$28354
$LN24@ReadVolume:

; 498  : 					}
; 499  : 
; 500  : 					cryptoInfo = *retInfo = crypto_open ();

  008a3	e8 00 00 00 00	 call	 crypto_open
  008a8	48 8b d8	 mov	 rbx, rax
  008ab	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 501  : 					if (cryptoInfo == NULL)

  008af	48 85 c0	 test	 rax, rax
  008b2	75 08		 jne	 SHORT $LN23@ReadVolume

; 502  : 					{
; 503  : 						status = ERR_OUTOFMEMORY;

  008b4	8d 70 02	 lea	 esi, QWORD PTR [rax+2]

; 504  : 						goto err;

  008b7	e9 f1 00 00 00	 jmp	 $err$28336
$LN23@ReadVolume:

; 505  : 					}
; 506  : 
; 507  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  008bc	41 b8 10 1f 00
	00		 mov	 r8d, 7952		; 00001f10H
  008c2	48 8b d5	 mov	 rdx, rbp
  008c5	48 8b c8	 mov	 rcx, rax
  008c8	e8 00 00 00 00	 call	 memcpy
$LN25@ReadVolume:

; 508  : 				}
; 509  : 
; 510  : 				// Master key data
; 511  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);

  008cd	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+136]
  008d5	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR header$[rsp+256]
  008dd	4d 8b c6	 mov	 r8, r14
  008e0	e8 00 00 00 00	 call	 memcpy

; 512  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  008e5	48 8d 8b 50 1c
	00 00		 lea	 rcx, QWORD PTR [rbx+7248]
  008ec	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR header$[rsp+256]
  008f4	4d 8b c6	 mov	 r8, r14
  008f7	e8 00 00 00 00	 call	 memcpy

; 513  : 
; 514  : 				// PKCS #5
; 515  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);

  008fc	48 8d 8b 50 1e
	00 00		 lea	 rcx, QWORD PTR [rbx+7760]
  00903	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+72]
  0090b	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00911	e8 00 00 00 00	 call	 memcpy

; 516  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  00916	8b 44 24 40	 mov	 eax, DWORD PTR pkcs5_prf$1$[rsp]

; 517  : 				cryptoInfo->noIterations = keyInfo.noIterations;
; 518  : 
; 519  : 				// Init the cipher with the decrypted master key
; 520  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  0091a	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0091c	89 83 94 1e 00
	00		 mov	 DWORD PTR [rbx+7828], eax
  00922	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  00929	89 83 90 1e 00
	00		 mov	 DWORD PTR [rbx+7824], eax
  0092f	85 c9		 test	 ecx, ecx
  00931	75 05		 jne	 SHORT $LN171@ReadVolume
  00933	8d 71 11	 lea	 esi, QWORD PTR [rcx+17]
  00936	eb 75		 jmp	 SHORT $err$28336
$LN171@ReadVolume:
  00938	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  0093c	48 8d 94 24 38
	01 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+136]
  00944	e8 00 00 00 00	 call	 EAInit
  00949	8b f0		 mov	 esi, eax

; 521  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  0094b	83 f8 11	 cmp	 eax, 17
  0094e	74 5d		 je	 SHORT $err$28336

; 522  : 					goto err;
; 523  : 
; 524  : 				switch (cryptoInfo->mode)
; 525  : 				{
; 526  : 				default:
; 527  : 					// The secondary master key (if cascade, multiple concatenated)
; 528  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00950	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00952	e8 00 00 00 00	 call	 EAGetKeySize
  00957	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00959	48 63 f8	 movsxd	 rdi, eax
  0095c	e8 00 00 00 00	 call	 EAGetKeySize
  00961	4c 8b c7	 mov	 r8, rdi
  00964	48 63 c8	 movsxd	 rcx, eax
  00967	48 8d 94 0c 38
	01 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+rcx+136]
  0096f	48 8d 8b 50 1d
	00 00		 lea	 rcx, QWORD PTR [rbx+7504]
  00976	e8 00 00 00 00	 call	 memcpy

; 529  : 
; 530  : 				}
; 531  : 
; 532  : 				if (!EAInitMode (cryptoInfo))

  0097b	48 8b cb	 mov	 rcx, rbx
  0097e	e8 00 00 00 00	 call	 EAInitMode
  00983	85 c0		 test	 eax, eax
  00985	75 05		 jne	 SHORT $LN18@ReadVolume

; 533  : 				{
; 534  : 					status = ERR_MODE_INIT_FAILED;

  00987	8d 70 1b	 lea	 esi, QWORD PTR [rax+27]

; 535  : 					goto err;

  0098a	eb 21		 jmp	 SHORT $err$28336
$LN18@ReadVolume:

; 536  : 				}
; 537  : 
; 538  : 				status = ERR_SUCCESS;

  0098c	33 f6		 xor	 esi, esi

; 539  : 				goto ret;

  0098e	eb 2f		 jmp	 SHORT $ret$28354
$LN26@ReadVolume:

; 485  : 				{
; 486  : 					status = ERR_PARAMETER_INCORRECT;

  00990	be 1e 00 00 00	 mov	 esi, 30
  00995	eb 0c		 jmp	 SHORT $LN220@ReadVolume
$LN194@ReadVolume:

; 401  : 					{
; 402  : 						status = ERR_MODE_INIT_FAILED;

  00997	be 1b 00 00 00	 mov	 esi, 27

; 403  : 						goto err;

  0099c	eb 05		 jmp	 SHORT $LN220@ReadVolume
$LN212@ReadVolume:

; 384  : 					continue;	// This encryption algorithm has never been available with this mode of operation
; 385  : 
; 386  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));
; 387  : 
; 388  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  0099e	be 11 00 00 00	 mov	 esi, 17
$LN220@ReadVolume:

; 282  : 
; 283  : 	// Test all available PKCS5 PRFs
; 284  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  009a3	48 8b 6c 24 50	 mov	 rbp, QWORD PTR retHeaderCryptoInfo$GSCopy$1$[rsp]
  009a8	4c 8b 6c 24 48	 mov	 r13, QWORD PTR retInfo$GSCopy$1$[rsp]
$err$28336:

; 544  : 
; 545  : err:
; 546  : 	if (cryptoInfo != retHeaderCryptoInfo)

  009ad	48 3b dd	 cmp	 rbx, rbp
  009b0	74 0d		 je	 SHORT $ret$28354

; 547  : 	{
; 548  : 		crypto_close(cryptoInfo);

  009b2	48 8b cb	 mov	 rcx, rbx
  009b5	e8 00 00 00 00	 call	 crypto_close

; 549  : 		*retInfo = NULL; 

  009ba	49 83 65 00 00	 and	 QWORD PTR [r13], 0
$ret$28354:

; 550  : 	}
; 551  : 
; 552  : ret:
; 553  : 	burn (&keyInfo, sizeof (keyInfo));

  009bf	ba 88 01 00 00	 mov	 edx, 392		; 00000188H
  009c4	48 8d bc 24 b0
	00 00 00	 lea	 rdi, QWORD PTR keyInfo$[rsp]
  009cc	33 c0		 xor	 eax, eax
  009ce	48 8b ca	 mov	 rcx, rdx
  009d1	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp]
  009d9	f3 aa		 rep stosb
$LL13@ReadVolume:
  009db	41 88 00	 mov	 BYTE PTR [r8], al
  009de	49 ff c0	 inc	 r8
  009e1	83 ea 01	 sub	 edx, 1
  009e4	75 f5		 jne	 SHORT $LL13@ReadVolume

; 554  : 	burn (dk, sizeof(dk));

  009e6	48 8d bc 24 40
	04 00 00	 lea	 rdi, QWORD PTR dk$[rsp]
  009ee	49 8b ce	 mov	 rcx, r14
  009f1	48 8d 94 24 40
	04 00 00	 lea	 rdx, QWORD PTR dk$[rsp]
  009f9	f3 aa		 rep stosb
$LL8@ReadVolume:
  009fb	88 02		 mov	 BYTE PTR [rdx], al
  009fd	48 ff c2	 inc	 rdx
  00a00	41 83 ee 01	 sub	 r14d, 1
  00a04	75 f5		 jne	 SHORT $LL8@ReadVolume

; 555  : 
; 556  : #ifndef DEVICE_DRIVER
; 557  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));
; 558  : 	VirtualUnlock (&dk, sizeof (dk));
; 559  : #endif
; 560  : 
; 561  : 	if (encryptionThreadCount > 1)

  00a06	48 83 7c 24 68
	01		 cmp	 QWORD PTR encryptionThreadCount$1$[rsp], 1
  00a0c	76 43		 jbe	 SHORT $LN6@ReadVolume

; 562  : 	{
; 563  : 		GST_WAIT_EVENT (noOutstandingWorkItemEvent);

  00a0e	48 21 44 24 20	 and	 QWORD PTR [rsp+32], rax
  00a13	48 8d 4c 24 78	 lea	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  00a18	45 33 c9	 xor	 r9d, r9d
  00a1b	45 33 c0	 xor	 r8d, r8d
  00a1e	33 d2		 xor	 edx, edx
  00a20	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 564  : 
; 565  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00a26	ba 24 03 00 00	 mov	 edx, 804		; 00000324H
  00a2b	49 8b ff	 mov	 rdi, r15
  00a2e	33 c0		 xor	 eax, eax
  00a30	48 8b ca	 mov	 rcx, rdx
  00a33	4d 8b df	 mov	 r11, r15
  00a36	f3 aa		 rep stosb
$LL2@ReadVolume:
  00a38	41 88 03	 mov	 BYTE PTR [r11], al
  00a3b	49 ff c3	 inc	 r11
  00a3e	83 ea 01	 sub	 edx, 1
  00a41	75 f5		 jne	 SHORT $LL2@ReadVolume

; 566  : 		GSTfree (keyDerivationWorkItems);

  00a43	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00a48	49 8b cf	 mov	 rcx, r15
  00a4b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@ReadVolume:

; 567  : 
; 568  : #ifndef DEVICE_DRIVER
; 569  : 		CloseHandle (keyDerivationCompletedEvent);
; 570  : 		CloseHandle (noOutstandingWorkItemEvent);
; 571  : #endif
; 572  : 	}
; 573  : 
; 574  : 	return status;

  00a51	8b c6		 mov	 eax, esi
$LN85@ReadVolume:

; 575  : }

  00a53	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a5b	48 33 cc	 xor	 rcx, rsp
  00a5e	e8 00 00 00 00	 call	 __security_check_cookie
  00a63	48 81 c4 58 05
	00 00		 add	 rsp, 1368		; 00000558H
  00a6a	41 5f		 pop	 r15
  00a6c	41 5e		 pop	 r14
  00a6e	41 5d		 pop	 r13
  00a70	41 5c		 pop	 r12
  00a72	5f		 pop	 rdi
  00a73	5e		 pop	 rsi
  00a74	5d		 pop	 rbp
  00a75	5b		 pop	 rbx
  00a76	c3		 ret	 0
$LN223@ReadVolume:
ReadVolumeHeader ENDP
END
