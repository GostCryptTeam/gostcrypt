; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@ DB '(Unknown)', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@ DB 'HMAC-GOST '
	DB	'R 34.11-94', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@ DB 'HMAC-GOS'
	DB	'T R 34.11-2012', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@ DB 'HMAC-Whirlpool', 00H ;  ?? ::FNODOBFM::`string'
PUBLIC	get_pkcs5_iteration_count
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
pdata	SEGMENT
$pdata$get_pkcs5_iteration_count DD imagerel $LN9
	DD	imagerel $LN9+102
	DD	imagerel $unwind$get_pkcs5_iteration_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_pkcs5_iteration_count DD 010c01H
	DD	0820cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_pkcs5_iteration_count
_TEXT	SEGMENT
tv64 = 48
pkcs5_prf_id$ = 80
bBoot$ = 88
get_pkcs5_iteration_count PROC				; COMDAT

; 562  : {

$LN9:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 563  : 	switch (pkcs5_prf_id)

  0000c	8b 44 24 50	 mov	 eax, DWORD PTR pkcs5_prf_id$[rsp]
  00010	89 44 24 30	 mov	 DWORD PTR tv64[rsp], eax
  00014	83 7c 24 30 01	 cmp	 DWORD PTR tv64[rsp], 1
  00019	74 17		 je	 SHORT $LN3@get_pkcs5_
  0001b	83 7c 24 30 02	 cmp	 DWORD PTR tv64[rsp], 2
  00020	74 17		 je	 SHORT $LN2@get_pkcs5_
  00022	83 7c 24 30 03	 cmp	 DWORD PTR tv64[rsp], 3
  00027	74 02		 je	 SHORT $LN4@get_pkcs5_
  00029	eb 15		 jmp	 SHORT $LN1@get_pkcs5_
$LN4@get_pkcs5_:

; 564  : 	{
; 565  : 	case WHIRLPOOL:	
; 566  : 		return 1000;

  0002b	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00030	eb 2f		 jmp	 SHORT $LN7@get_pkcs5_
$LN3@get_pkcs5_:

; 567  : 	case STRIBOG:
; 568  : 		return 1000;

  00032	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00037	eb 28		 jmp	 SHORT $LN7@get_pkcs5_
$LN2@get_pkcs5_:

; 569  : 	case GOSTHASH:
; 570  : 		return 1000;

  00039	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0003e	eb 21		 jmp	 SHORT $LN7@get_pkcs5_
$LN1@get_pkcs5_:

; 571  : 	default:		
; 572  : 		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00040	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	45 33 c0	 xor	 r8d, r8d
  0004f	ba 3c 02 00 00	 mov	 edx, 572		; 0000023cH
  00054	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx

; 573  : 	}
; 574  : 	return 0;

  0005f	33 c0		 xor	 eax, eax
$LN7@get_pkcs5_:
$LN8@get_pkcs5_:

; 575  : }

  00061	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00065	c3		 ret	 0
get_pkcs5_iteration_count ENDP
_TEXT	ENDS
PUBLIC	hmac_truncate
;	COMDAT pdata
pdata	SEGMENT
$pdata$hmac_truncate DD imagerel $LN6
	DD	imagerel $LN6+79
	DD	imagerel $unwind$hmac_truncate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_truncate DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hmac_truncate
_TEXT	SEGMENT
i$ = 0
d1$ = 32
d2$ = 40
len$ = 48
hmac_truncate PROC					; COMDAT

; 38   : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 39   : 	int i;
; 40   : 	for (i = 0; i < len; i++)

  00013	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 09		 jmp	 SHORT $LN3@hmac_trunc
$LN2@hmac_trunc:
  0001c	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN3@hmac_trunc:
  00025	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00029	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0002c	7d 1c		 jge	 SHORT $LN1@hmac_trunc

; 41   : 		d2[i] = d1[i];

  0002e	4c 63 04 24	 movsxd	 r8, DWORD PTR i$[rsp]
  00032	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR d2$[rsp]
  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR d1$[rsp]
  00040	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  00045	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00048	eb d2		 jmp	 SHORT $LN2@hmac_trunc
$LN1@hmac_trunc:

; 42   : }

  0004a	48 83 c4 18	 add	 rsp, 24
  0004e	c3		 ret	 0
hmac_truncate ENDP
PUBLIC	__$ArrayPad$
PUBLIC	hmac_whirlpool
;	COMDAT pdata
pdata	SEGMENT
$pdata$hmac_whirlpool DD imagerel $LN53
	DD	imagerel $LN53+1419
	DD	imagerel $unwind$hmac_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_whirlpool DD 022c19H
	DD	079011aH
	DD	imagerel __GSHandlerCheck
	DD	03b8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hmac_whirlpool
_TEXT	SEGMENT
i$ = 32
key$ = 48
owhi$ = 112
buf$ = 176
ictx$ = 240
iwhi$ = 416
octx$ = 480
tctx$27200 = 656
burnc$27208 = 832
burnm$27206 = 840
burnc$27237 = 848
burnm$27235 = 856
burnc$27246 = 864
burnm$27244 = 872
burnc$27255 = 880
burnm$27253 = 888
burnc$27264 = 896
burnm$27262 = 904
burnc$27273 = 912
burnm$27271 = 920
burnc$27282 = 928
burnm$27280 = 936
tv156 = 944
__$ArrayPad$ = 952
k$ = 976
lk$ = 984
d$ = 992
ld$ = 1000
out$ = 1008
t$ = 1016
hmac_whirlpool PROC					; COMDAT

; 54   : {

$LN53:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec c8 03
	00 00		 sub	 rsp, 968		; 000003c8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 b8
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 55   : 	WHIRLPOOL_CTX ictx, octx;
; 56   : 	char iwhi[WHIRLPOOL_DIGESTSIZE], owhi[WHIRLPOOL_DIGESTSIZE];
; 57   : 	char key[WHIRLPOOL_DIGESTSIZE];
; 58   : 	char buf[WHIRLPOOL_BLOCKSIZE];
; 59   : 	int i;
; 60   : 
; 61   :     /* If the key is longer than the hash algorithm block size,
; 62   : 	   let key = whirlpool(key), as per HMAC specifications. */
; 63   : 	if (lk > WHIRLPOOL_BLOCKSIZE)

  0002c	83 bc 24 d8 03
	00 00 40	 cmp	 DWORD PTR lk$[rsp], 64	; 00000040H
  00034	0f 8e c6 00 00
	00		 jle	 $LN48@hmac_whirl

; 64   : 	{
; 65   : 		WHIRLPOOL_CTX tctx;
; 66   : 
; 67   : 		WHIRLPOOL_init (&tctx);

  0003a	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR tctx$27200[rsp]
  00042	e8 00 00 00 00	 call	 WHIRLPOOL_init

; 68   : 		WHIRLPOOL_add ((unsigned char *) k, lk * 8, &tctx);

  00047	8b 94 24 d8 03
	00 00		 mov	 edx, DWORD PTR lk$[rsp]
  0004e	c1 e2 03	 shl	 edx, 3
  00051	4c 8d 84 24 90
	02 00 00	 lea	 r8, QWORD PTR tctx$27200[rsp]
  00059	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  00061	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 69   : 		WHIRLPOOL_finalize (&tctx, (unsigned char *) key);

  00066	48 8d 54 24 30	 lea	 rdx, QWORD PTR key$[rsp]
  0006b	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR tctx$27200[rsp]
  00073	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 70   : 
; 71   : 		k = key;

  00078	4c 8d 5c 24 30	 lea	 r11, QWORD PTR key$[rsp]
  0007d	4c 89 9c 24 d0
	03 00 00	 mov	 QWORD PTR k$[rsp], r11

; 72   : 		lk = WHIRLPOOL_DIGESTSIZE;

  00085	c7 84 24 d8 03
	00 00 40 00 00
	00		 mov	 DWORD PTR lk$[rsp], 64	; 00000040H
$LN47@hmac_whirl:

; 73   : 
; 74   : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  00090	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR tctx$27200[rsp]
  00098	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR burnm$27206[rsp], rax
  000a0	c7 84 24 40 03
	00 00 a8 00 00
	00		 mov	 DWORD PTR burnc$27208[rsp], 168 ; 000000a8H
  000ab	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  000b0	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR tctx$27200[rsp]
  000b8	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN44@hmac_whirl:
  000bd	8b 8c 24 40 03
	00 00		 mov	 ecx, DWORD PTR burnc$27208[rsp]
  000c4	8b 84 24 40 03
	00 00		 mov	 eax, DWORD PTR burnc$27208[rsp]
  000cb	83 e8 01	 sub	 eax, 1
  000ce	89 84 24 40 03
	00 00		 mov	 DWORD PTR burnc$27208[rsp], eax
  000d5	85 c9		 test	 ecx, ecx
  000d7	74 21		 je	 SHORT $LN43@hmac_whirl
  000d9	48 8b 84 24 48
	03 00 00	 mov	 rax, QWORD PTR burnm$27206[rsp]
  000e1	c6 00 00	 mov	 BYTE PTR [rax], 0
  000e4	48 8b 84 24 48
	03 00 00	 mov	 rax, QWORD PTR burnm$27206[rsp]
  000ec	48 83 c0 01	 add	 rax, 1
  000f0	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR burnm$27206[rsp], rax
  000f8	eb c3		 jmp	 SHORT $LN44@hmac_whirl
$LN43@hmac_whirl:
  000fa	33 c0		 xor	 eax, eax
  000fc	85 c0		 test	 eax, eax
  000fe	75 90		 jne	 SHORT $LN47@hmac_whirl
$LN48@hmac_whirl:

; 75   : 	}
; 76   : 
; 77   : 	/**** Inner Digest ****/
; 78   : 
; 79   : 	WHIRLPOOL_init (&ictx);

  00100	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR ictx$[rsp]
  00108	e8 00 00 00 00	 call	 WHIRLPOOL_init

; 80   : 
; 81   : 	/* Pad the key for inner digest */
; 82   : 	for (i = 0; i < lk; ++i)

  0010d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00115	eb 0b		 jmp	 SHORT $LN42@hmac_whirl
$LN41@hmac_whirl:
  00117	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN42@hmac_whirl:
  00122	8b 84 24 d8 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00129	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0012d	7d 22		 jge	 SHORT $LN40@hmac_whirl

; 83   : 		buf[i] = (char) (k[i] ^ 0x36);

  0012f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00134	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR k$[rsp]
  0013c	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  00140	83 f1 36	 xor	 ecx, 54			; 00000036H
  00143	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00148	88 8c 04 b0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  0014f	eb c6		 jmp	 SHORT $LN41@hmac_whirl
$LN40@hmac_whirl:

; 84   : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  00151	8b 84 24 d8 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00158	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0015c	eb 0b		 jmp	 SHORT $LN39@hmac_whirl
$LN38@hmac_whirl:
  0015e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00162	83 c0 01	 add	 eax, 1
  00165	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN39@hmac_whirl:
  00169	83 7c 24 20 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0016e	7d 0f		 jge	 SHORT $LN37@hmac_whirl

; 85   : 		buf[i] = 0x36;

  00170	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00175	c6 84 04 b0 00
	00 00 36	 mov	 BYTE PTR buf$[rsp+rax], 54 ; 00000036H
  0017d	eb df		 jmp	 SHORT $LN38@hmac_whirl
$LN37@hmac_whirl:

; 86   : 
; 87   : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &ictx);

  0017f	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR ictx$[rsp]
  00187	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0018c	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00194	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 88   : 	WHIRLPOOL_add ((unsigned char *) d, ld * 8, &ictx);

  00199	8b 94 24 e8 03
	00 00		 mov	 edx, DWORD PTR ld$[rsp]
  001a0	c1 e2 03	 shl	 edx, 3
  001a3	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR ictx$[rsp]
  001ab	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  001b3	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 89   : 
; 90   : 	WHIRLPOOL_finalize (&ictx, (unsigned char *) iwhi);

  001b8	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR iwhi$[rsp]
  001c0	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR ictx$[rsp]
  001c8	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 91   : 
; 92   : 	/**** Outer Digest ****/
; 93   : 
; 94   : 	WHIRLPOOL_init (&octx);

  001cd	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  001d5	e8 00 00 00 00	 call	 WHIRLPOOL_init

; 95   : 
; 96   : 	for (i = 0; i < lk; ++i)

  001da	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001e2	eb 0b		 jmp	 SHORT $LN36@hmac_whirl
$LN35@hmac_whirl:
  001e4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001e8	83 c0 01	 add	 eax, 1
  001eb	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN36@hmac_whirl:
  001ef	8b 84 24 d8 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  001f6	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001fa	7d 22		 jge	 SHORT $LN34@hmac_whirl

; 97   : 		buf[i] = (char) (k[i] ^ 0x5C);

  001fc	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00201	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR k$[rsp]
  00209	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  0020d	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  00210	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00215	88 8c 04 b0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  0021c	eb c6		 jmp	 SHORT $LN35@hmac_whirl
$LN34@hmac_whirl:

; 98   : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  0021e	8b 84 24 d8 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00225	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00229	eb 0b		 jmp	 SHORT $LN33@hmac_whirl
$LN32@hmac_whirl:
  0022b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0022f	83 c0 01	 add	 eax, 1
  00232	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN33@hmac_whirl:
  00236	83 7c 24 20 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0023b	7d 0f		 jge	 SHORT $LN31@hmac_whirl

; 99   : 		buf[i] = 0x5C;

  0023d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00242	c6 84 04 b0 00
	00 00 5c	 mov	 BYTE PTR buf$[rsp+rax], 92 ; 0000005cH
  0024a	eb df		 jmp	 SHORT $LN32@hmac_whirl
$LN31@hmac_whirl:

; 100  : 
; 101  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  0024c	4c 8d 84 24 e0
	01 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  00254	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00259	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00261	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 102  : 	WHIRLPOOL_add ((unsigned char *) iwhi, WHIRLPOOL_DIGESTSIZE * 8, &octx);

  00266	4c 8d 84 24 e0
	01 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  0026e	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00273	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR iwhi$[rsp]
  0027b	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 103  : 
; 104  : 	WHIRLPOOL_finalize (&octx, (unsigned char *) owhi);

  00280	48 8d 54 24 70	 lea	 rdx, QWORD PTR owhi$[rsp]
  00285	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  0028d	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 105  : 
; 106  : 	/* truncate and print the results */
; 107  : 	t = t > WHIRLPOOL_DIGESTSIZE ? WHIRLPOOL_DIGESTSIZE : t;

  00292	83 bc 24 f8 03
	00 00 40	 cmp	 DWORD PTR t$[rsp], 64	; 00000040H
  0029a	7e 0d		 jle	 SHORT $LN51@hmac_whirl
  0029c	c7 84 24 b0 03
	00 00 40 00 00
	00		 mov	 DWORD PTR tv156[rsp], 64 ; 00000040H
  002a7	eb 0e		 jmp	 SHORT $LN52@hmac_whirl
$LN51@hmac_whirl:
  002a9	8b 84 24 f8 03
	00 00		 mov	 eax, DWORD PTR t$[rsp]
  002b0	89 84 24 b0 03
	00 00		 mov	 DWORD PTR tv156[rsp], eax
$LN52@hmac_whirl:
  002b7	8b 84 24 b0 03
	00 00		 mov	 eax, DWORD PTR tv156[rsp]
  002be	89 84 24 f8 03
	00 00		 mov	 DWORD PTR t$[rsp], eax

; 108  : 	hmac_truncate (owhi, out, t);

  002c5	44 8b 84 24 f8
	03 00 00	 mov	 r8d, DWORD PTR t$[rsp]
  002cd	48 8b 94 24 f0
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  002d5	48 8d 4c 24 70	 lea	 rcx, QWORD PTR owhi$[rsp]
  002da	e8 00 00 00 00	 call	 hmac_truncate
$LN30@hmac_whirl:

; 109  : 
; 110  : 	/* Prevent possible leaks. */
; 111  : 	burn (&ictx, sizeof(ictx));

  002df	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR ictx$[rsp]
  002e7	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR burnm$27235[rsp], rax
  002ef	c7 84 24 50 03
	00 00 a8 00 00
	00		 mov	 DWORD PTR burnc$27237[rsp], 168 ; 000000a8H
  002fa	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  002ff	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR ictx$[rsp]
  00307	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN27@hmac_whirl:
  0030c	8b 8c 24 50 03
	00 00		 mov	 ecx, DWORD PTR burnc$27237[rsp]
  00313	8b 84 24 50 03
	00 00		 mov	 eax, DWORD PTR burnc$27237[rsp]
  0031a	83 e8 01	 sub	 eax, 1
  0031d	89 84 24 50 03
	00 00		 mov	 DWORD PTR burnc$27237[rsp], eax
  00324	85 c9		 test	 ecx, ecx
  00326	74 21		 je	 SHORT $LN26@hmac_whirl
  00328	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR burnm$27235[rsp]
  00330	c6 00 00	 mov	 BYTE PTR [rax], 0
  00333	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR burnm$27235[rsp]
  0033b	48 83 c0 01	 add	 rax, 1
  0033f	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR burnm$27235[rsp], rax
  00347	eb c3		 jmp	 SHORT $LN27@hmac_whirl
$LN26@hmac_whirl:
  00349	33 c0		 xor	 eax, eax
  0034b	85 c0		 test	 eax, eax
  0034d	75 90		 jne	 SHORT $LN30@hmac_whirl
$LN25@hmac_whirl:

; 112  : 	burn (&octx, sizeof(octx));

  0034f	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR octx$[rsp]
  00357	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR burnm$27244[rsp], rax
  0035f	c7 84 24 60 03
	00 00 a8 00 00
	00		 mov	 DWORD PTR burnc$27246[rsp], 168 ; 000000a8H
  0036a	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  0036f	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  00377	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN22@hmac_whirl:
  0037c	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR burnc$27246[rsp]
  00383	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR burnc$27246[rsp]
  0038a	83 e8 01	 sub	 eax, 1
  0038d	89 84 24 60 03
	00 00		 mov	 DWORD PTR burnc$27246[rsp], eax
  00394	85 c9		 test	 ecx, ecx
  00396	74 21		 je	 SHORT $LN21@hmac_whirl
  00398	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR burnm$27244[rsp]
  003a0	c6 00 00	 mov	 BYTE PTR [rax], 0
  003a3	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR burnm$27244[rsp]
  003ab	48 83 c0 01	 add	 rax, 1
  003af	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR burnm$27244[rsp], rax
  003b7	eb c3		 jmp	 SHORT $LN22@hmac_whirl
$LN21@hmac_whirl:
  003b9	33 c0		 xor	 eax, eax
  003bb	85 c0		 test	 eax, eax
  003bd	75 90		 jne	 SHORT $LN25@hmac_whirl
$LN20@hmac_whirl:

; 113  : 	burn (owhi, sizeof(owhi));

  003bf	48 8d 44 24 70	 lea	 rax, QWORD PTR owhi$[rsp]
  003c4	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR burnm$27253[rsp], rax
  003cc	c7 84 24 70 03
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27255[rsp], 64 ; 00000040H
  003d7	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  003dc	48 8d 4c 24 70	 lea	 rcx, QWORD PTR owhi$[rsp]
  003e1	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN17@hmac_whirl:
  003e6	8b 8c 24 70 03
	00 00		 mov	 ecx, DWORD PTR burnc$27255[rsp]
  003ed	8b 84 24 70 03
	00 00		 mov	 eax, DWORD PTR burnc$27255[rsp]
  003f4	83 e8 01	 sub	 eax, 1
  003f7	89 84 24 70 03
	00 00		 mov	 DWORD PTR burnc$27255[rsp], eax
  003fe	85 c9		 test	 ecx, ecx
  00400	74 21		 je	 SHORT $LN16@hmac_whirl
  00402	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR burnm$27253[rsp]
  0040a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0040d	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR burnm$27253[rsp]
  00415	48 83 c0 01	 add	 rax, 1
  00419	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR burnm$27253[rsp], rax
  00421	eb c3		 jmp	 SHORT $LN17@hmac_whirl
$LN16@hmac_whirl:
  00423	33 c0		 xor	 eax, eax
  00425	85 c0		 test	 eax, eax
  00427	75 96		 jne	 SHORT $LN20@hmac_whirl
$LN15@hmac_whirl:

; 114  : 	burn (iwhi, sizeof(iwhi));

  00429	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR iwhi$[rsp]
  00431	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR burnm$27262[rsp], rax
  00439	c7 84 24 80 03
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27264[rsp], 64 ; 00000040H
  00444	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00449	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR iwhi$[rsp]
  00451	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN12@hmac_whirl:
  00456	8b 8c 24 80 03
	00 00		 mov	 ecx, DWORD PTR burnc$27264[rsp]
  0045d	8b 84 24 80 03
	00 00		 mov	 eax, DWORD PTR burnc$27264[rsp]
  00464	83 e8 01	 sub	 eax, 1
  00467	89 84 24 80 03
	00 00		 mov	 DWORD PTR burnc$27264[rsp], eax
  0046e	85 c9		 test	 ecx, ecx
  00470	74 21		 je	 SHORT $LN11@hmac_whirl
  00472	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR burnm$27262[rsp]
  0047a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0047d	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR burnm$27262[rsp]
  00485	48 83 c0 01	 add	 rax, 1
  00489	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR burnm$27262[rsp], rax
  00491	eb c3		 jmp	 SHORT $LN12@hmac_whirl
$LN11@hmac_whirl:
  00493	33 c0		 xor	 eax, eax
  00495	85 c0		 test	 eax, eax
  00497	75 90		 jne	 SHORT $LN15@hmac_whirl
$LN10@hmac_whirl:

; 115  : 	burn (buf, sizeof(buf));

  00499	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  004a1	48 89 84 24 98
	03 00 00	 mov	 QWORD PTR burnm$27271[rsp], rax
  004a9	c7 84 24 90 03
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27273[rsp], 64 ; 00000040H
  004b4	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  004b9	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004c1	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@hmac_whirl:
  004c6	8b 8c 24 90 03
	00 00		 mov	 ecx, DWORD PTR burnc$27273[rsp]
  004cd	8b 84 24 90 03
	00 00		 mov	 eax, DWORD PTR burnc$27273[rsp]
  004d4	83 e8 01	 sub	 eax, 1
  004d7	89 84 24 90 03
	00 00		 mov	 DWORD PTR burnc$27273[rsp], eax
  004de	85 c9		 test	 ecx, ecx
  004e0	74 21		 je	 SHORT $LN6@hmac_whirl
  004e2	48 8b 84 24 98
	03 00 00	 mov	 rax, QWORD PTR burnm$27271[rsp]
  004ea	c6 00 00	 mov	 BYTE PTR [rax], 0
  004ed	48 8b 84 24 98
	03 00 00	 mov	 rax, QWORD PTR burnm$27271[rsp]
  004f5	48 83 c0 01	 add	 rax, 1
  004f9	48 89 84 24 98
	03 00 00	 mov	 QWORD PTR burnm$27271[rsp], rax
  00501	eb c3		 jmp	 SHORT $LN7@hmac_whirl
$LN6@hmac_whirl:
  00503	33 c0		 xor	 eax, eax
  00505	85 c0		 test	 eax, eax
  00507	75 90		 jne	 SHORT $LN10@hmac_whirl
$LN5@hmac_whirl:

; 116  : 	burn (key, sizeof(key));

  00509	48 8d 44 24 30	 lea	 rax, QWORD PTR key$[rsp]
  0050e	48 89 84 24 a8
	03 00 00	 mov	 QWORD PTR burnm$27280[rsp], rax
  00516	c7 84 24 a0 03
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27282[rsp], 64 ; 00000040H
  00521	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00526	48 8d 4c 24 30	 lea	 rcx, QWORD PTR key$[rsp]
  0052b	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@hmac_whirl:
  00530	8b 8c 24 a0 03
	00 00		 mov	 ecx, DWORD PTR burnc$27282[rsp]
  00537	8b 84 24 a0 03
	00 00		 mov	 eax, DWORD PTR burnc$27282[rsp]
  0053e	83 e8 01	 sub	 eax, 1
  00541	89 84 24 a0 03
	00 00		 mov	 DWORD PTR burnc$27282[rsp], eax
  00548	85 c9		 test	 ecx, ecx
  0054a	74 21		 je	 SHORT $LN1@hmac_whirl
  0054c	48 8b 84 24 a8
	03 00 00	 mov	 rax, QWORD PTR burnm$27280[rsp]
  00554	c6 00 00	 mov	 BYTE PTR [rax], 0
  00557	48 8b 84 24 a8
	03 00 00	 mov	 rax, QWORD PTR burnm$27280[rsp]
  0055f	48 83 c0 01	 add	 rax, 1
  00563	48 89 84 24 a8
	03 00 00	 mov	 QWORD PTR burnm$27280[rsp], rax
  0056b	eb c3		 jmp	 SHORT $LN2@hmac_whirl
$LN1@hmac_whirl:
  0056d	33 c0		 xor	 eax, eax
  0056f	85 c0		 test	 eax, eax
  00571	75 96		 jne	 SHORT $LN5@hmac_whirl

; 117  : }

  00573	48 8b 8c 24 b8
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0057b	48 33 cc	 xor	 rcx, rsp
  0057e	e8 00 00 00 00	 call	 __security_check_cookie
  00583	48 81 c4 c8 03
	00 00		 add	 rsp, 968		; 000003c8H
  0058a	c3		 ret	 0
hmac_whirlpool ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_whirlpool
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_u_whirlpool DD imagerel $LN19
	DD	imagerel $LN19+664
	DD	imagerel $unwind$derive_u_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_whirlpool DD 042e19H
	DD	033011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0180H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_u_whirlpool
_TEXT	SEGMENT
i$ = 48
init$ = 64
counter$ = 192
k$ = 208
c$ = 272
j$ = 288
burnc$27319 = 352
burnm$27317 = 360
burnc$27328 = 368
burnm$27326 = 376
__$ArrayPad$ = 384
pwd$ = 432
pwd_len$ = 440
salt$ = 448
salt_len$ = 456
iterations$ = 464
u$ = 472
b$ = 480
derive_u_whirlpool PROC					; COMDAT

; 134  : {

$LN19:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 135  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 136  : 	char init[128];
; 137  : 	char counter[4];
; 138  : 	int c, i;
; 139  : 
; 140  : 	/* iteration 1 */
; 141  : 	memset (counter, 0, 4);

  0002e	48 8d bc 24 c0
	00 00 00	 lea	 rdi, QWORD PTR counter$[rsp]
  00036	33 c0		 xor	 eax, eax
  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	f3 aa		 rep stosb

; 142  : 	counter[3] = (char) b;

  0003f	0f b6 84 24 e0
	01 00 00	 movzx	 eax, BYTE PTR b$[rsp]
  00047	88 84 24 c3 00
	00 00		 mov	 BYTE PTR counter$[rsp+3], al

; 143  : 	memcpy (init, salt, salt_len);	/* salt */

  0004e	48 63 8c 24 c8
	01 00 00	 movsxd	 rcx, DWORD PTR salt_len$[rsp]
  00056	48 8d 7c 24 40	 lea	 rdi, QWORD PTR init$[rsp]
  0005b	48 8b b4 24 c0
	01 00 00	 mov	 rsi, QWORD PTR salt$[rsp]
  00063	f3 a4		 rep movsb

; 144  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00065	48 63 94 24 c8
	01 00 00	 movsxd	 rdx, DWORD PTR salt_len$[rsp]
  0006d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR counter$[rsp]
  00074	89 44 14 40	 mov	 DWORD PTR init$[rsp+rdx], eax

; 145  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);

  00078	44 8b 8c 24 c8
	01 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  00080	41 83 c1 04	 add	 r9d, 4
  00084	c7 44 24 28 40
	00 00 00	 mov	 DWORD PTR [rsp+40], 64	; 00000040H
  0008c	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR j$[rsp]
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8d 44 24 40	 lea	 r8, QWORD PTR init$[rsp]
  0009e	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000a5	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  000ad	e8 00 00 00 00	 call	 hmac_whirlpool

; 146  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);

  000b2	48 8d b4 24 20
	01 00 00	 lea	 rsi, QWORD PTR j$[rsp]
  000ba	48 8b bc 24 d8
	01 00 00	 mov	 rdi, QWORD PTR u$[rsp]
  000c2	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000c7	f3 a4		 rep movsb

; 147  : 
; 148  : 	/* remaining iterations */
; 149  : 	for (c = 1; c < iterations; c++)

  000c9	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR c$[rsp], 1
  000d4	eb 11		 jmp	 SHORT $LN16@derive_u_w
$LN15@derive_u_w:
  000d6	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  000dd	83 c0 01	 add	 eax, 1
  000e0	89 84 24 10 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
$LN16@derive_u_w:
  000e7	8b 84 24 d0 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000ee	39 84 24 10 01
	00 00		 cmp	 DWORD PTR c$[rsp], eax
  000f5	0f 8d a3 00 00
	00		 jge	 $LN14@derive_u_w

; 150  : 	{
; 151  : 		hmac_whirlpool (pwd, pwd_len, j, WHIRLPOOL_DIGESTSIZE, k, WHIRLPOOL_DIGESTSIZE);

  000fb	c7 44 24 28 40
	00 00 00	 mov	 DWORD PTR [rsp+40], 64	; 00000040H
  00103	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00116	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR j$[rsp]
  0011e	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  00125	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  0012d	e8 00 00 00 00	 call	 hmac_whirlpool

; 152  : 		for (i = 0; i < WHIRLPOOL_DIGESTSIZE; i++)

  00132	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0013a	eb 0b		 jmp	 SHORT $LN13@derive_u_w
$LN12@derive_u_w:
  0013c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00140	83 c0 01	 add	 eax, 1
  00143	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@derive_u_w:
  00147	83 7c 24 30 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0014c	7d 4b		 jge	 SHORT $LN11@derive_u_w

; 153  : 		{
; 154  : 			u[i] ^= k[i];

  0014e	48 63 54 24 30	 movsxd	 rdx, DWORD PTR i$[rsp]
  00153	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00158	0f be 8c 04 d0
	00 00 00	 movsx	 ecx, BYTE PTR k$[rsp+rax]
  00160	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00168	0f be 14 10	 movsx	 edx, BYTE PTR [rax+rdx]
  0016c	33 d1		 xor	 edx, ecx
  0016e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00173	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0017b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 155  : 			j[i] = k[i];

  0017e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00183	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00188	0f b6 84 04 d0
	00 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00190	88 84 0c 20 01
	00 00		 mov	 BYTE PTR j$[rsp+rcx], al

; 156  : 		}

  00197	eb a3		 jmp	 SHORT $LN12@derive_u_w
$LN11@derive_u_w:

; 157  : 	}

  00199	e9 38 ff ff ff	 jmp	 $LN15@derive_u_w
$LN14@derive_u_w:
$LN10@derive_u_w:

; 158  : 
; 159  : 	/* Prevent possible leaks. */
; 160  : 	burn (j, sizeof(j));

  0019e	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR j$[rsp]
  001a6	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR burnm$27317[rsp], rax
  001ae	c7 84 24 60 01
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27319[rsp], 64 ; 00000040H
  001b9	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001be	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR j$[rsp]
  001c6	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@derive_u_w:
  001cb	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR burnc$27319[rsp]
  001d2	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR burnc$27319[rsp]
  001d9	83 e8 01	 sub	 eax, 1
  001dc	89 84 24 60 01
	00 00		 mov	 DWORD PTR burnc$27319[rsp], eax
  001e3	85 c9		 test	 ecx, ecx
  001e5	74 21		 je	 SHORT $LN6@derive_u_w
  001e7	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR burnm$27317[rsp]
  001ef	c6 00 00	 mov	 BYTE PTR [rax], 0
  001f2	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR burnm$27317[rsp]
  001fa	48 83 c0 01	 add	 rax, 1
  001fe	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR burnm$27317[rsp], rax
  00206	eb c3		 jmp	 SHORT $LN7@derive_u_w
$LN6@derive_u_w:
  00208	33 c0		 xor	 eax, eax
  0020a	85 c0		 test	 eax, eax
  0020c	75 90		 jne	 SHORT $LN10@derive_u_w
$LN5@derive_u_w:

; 161  : 	burn (k, sizeof(k));

  0020e	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  00216	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR burnm$27326[rsp], rax
  0021e	c7 84 24 70 01
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27328[rsp], 64 ; 00000040H
  00229	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0022e	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00236	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_u_w:
  0023b	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR burnc$27328[rsp]
  00242	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR burnc$27328[rsp]
  00249	83 e8 01	 sub	 eax, 1
  0024c	89 84 24 70 01
	00 00		 mov	 DWORD PTR burnc$27328[rsp], eax
  00253	85 c9		 test	 ecx, ecx
  00255	74 21		 je	 SHORT $LN1@derive_u_w
  00257	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR burnm$27326[rsp]
  0025f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00262	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR burnm$27326[rsp]
  0026a	48 83 c0 01	 add	 rax, 1
  0026e	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR burnm$27326[rsp], rax
  00276	eb c3		 jmp	 SHORT $LN2@derive_u_w
$LN1@derive_u_w:
  00278	33 c0		 xor	 eax, eax
  0027a	85 c0		 test	 eax, eax
  0027c	75 90		 jne	 SHORT $LN5@derive_u_w

; 162  : }

  0027e	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00286	48 33 cc	 xor	 rcx, rsp
  00289	e8 00 00 00 00	 call	 __security_check_cookie
  0028e	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00295	5f		 pop	 rdi
  00296	5e		 pop	 rsi
  00297	c3		 ret	 0
derive_u_whirlpool ENDP
PUBLIC	__$ArrayPad$
PUBLIC	hmac_gosthash
;	COMDAT pdata
pdata	SEGMENT
$pdata$hmac_gosthash DD imagerel $LN46
	DD	imagerel $LN46+1188
	DD	imagerel $unwind$hmac_gosthash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_gosthash DD 022c19H
	DD	033011aH
	DD	imagerel __GSHandlerCheck
	DD	0180H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hmac_gosthash
_TEXT	SEGMENT
i$ = 32
key$ = 48
ctx$ = 80
inner$ = 192
buf$ = 224
outer$ = 256
burnc$27390 = 288
burnm$27388 = 296
burnc$27419 = 304
burnm$27417 = 312
burnc$27428 = 320
burnm$27426 = 328
burnc$27437 = 336
burnm$27435 = 344
burnc$27446 = 352
burnm$27444 = 360
burnc$27455 = 368
burnm$27453 = 376
__$ArrayPad$ = 384
k$ = 416
lk$ = 424
d$ = 432
ld$ = 440
out$ = 448
hmac_gosthash PROC					; COMDAT

; 219  : {

$LN46:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 220  : 	gost_hash_ctx ctx;
; 221  : 	char inner[GOSTHASH_DIGESTSIZE], outer[GOSTHASH_DIGESTSIZE];
; 222  : 	char key[GOSTHASH_DIGESTSIZE];
; 223  : 	char buf[GOSTHASH_BLOCKSIZE];
; 224  : 	int32 i;
; 225  : 
; 226  :     /* If the key is longer than the hash algorithm block size,
; 227  : 	   let key = gosthash(key), as per HMAC specifications. */
; 228  : 	if (lk > GOSTHASH_BLOCKSIZE)

  0002c	83 bc 24 a8 01
	00 00 20	 cmp	 DWORD PTR lk$[rsp], 32	; 00000020H
  00034	0f 8e b4 00 00
	00		 jle	 $LN43@hmac_gosth

; 229  : 	{
; 230  : 		GOSTHASH_init (&ctx);

  0003a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  0003f	e8 00 00 00 00	 call	 GOSTHASH_init

; 231  : 		GOSTHASH_add ((unsigned char *)k, lk, &ctx);

  00044	4c 8d 44 24 50	 lea	 r8, QWORD PTR ctx$[rsp]
  00049	8b 94 24 a8 01
	00 00		 mov	 edx, DWORD PTR lk$[rsp]
  00050	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  00058	e8 00 00 00 00	 call	 GOSTHASH_add

; 232  : 		GOSTHASH_finalize (&ctx, (unsigned char *) key);

  0005d	48 8d 54 24 30	 lea	 rdx, QWORD PTR key$[rsp]
  00062	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  00067	e8 00 00 00 00	 call	 GOSTHASH_finalize

; 233  : 
; 234  : 		k = key;

  0006c	4c 8d 5c 24 30	 lea	 r11, QWORD PTR key$[rsp]
  00071	4c 89 9c 24 a0
	01 00 00	 mov	 QWORD PTR k$[rsp], r11

; 235  : 		lk = GOSTHASH_DIGESTSIZE;

  00079	c7 84 24 a8 01
	00 00 20 00 00
	00		 mov	 DWORD PTR lk$[rsp], 32	; 00000020H
$LN42@hmac_gosth:

; 236  : 
; 237  : 		burn (&ctx, sizeof(ctx));		// Prevent leaks

  00084	48 8d 44 24 50	 lea	 rax, QWORD PTR ctx$[rsp]
  00089	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR burnm$27388[rsp], rax
  00091	c7 84 24 20 01
	00 00 68 00 00
	00		 mov	 DWORD PTR burnc$27390[rsp], 104 ; 00000068H
  0009c	ba 68 00 00 00	 mov	 edx, 104		; 00000068H
  000a1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  000a6	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN39@hmac_gosth:
  000ab	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR burnc$27390[rsp]
  000b2	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR burnc$27390[rsp]
  000b9	83 e8 01	 sub	 eax, 1
  000bc	89 84 24 20 01
	00 00		 mov	 DWORD PTR burnc$27390[rsp], eax
  000c3	85 c9		 test	 ecx, ecx
  000c5	74 21		 je	 SHORT $LN38@hmac_gosth
  000c7	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR burnm$27388[rsp]
  000cf	c6 00 00	 mov	 BYTE PTR [rax], 0
  000d2	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR burnm$27388[rsp]
  000da	48 83 c0 01	 add	 rax, 1
  000de	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR burnm$27388[rsp], rax
  000e6	eb c3		 jmp	 SHORT $LN39@hmac_gosth
$LN38@hmac_gosth:
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	75 96		 jne	 SHORT $LN42@hmac_gosth
$LN43@hmac_gosth:

; 238  : 	}
; 239  : 
; 240  : 	/**** Inner Digest ****/
; 241  : 
; 242  : 	GOSTHASH_init (&ctx);

  000ee	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  000f3	e8 00 00 00 00	 call	 GOSTHASH_init

; 243  : 
; 244  : 	/* Pad the key for inner digest */
; 245  : 	for (i = 0; i < lk; ++i)

  000f8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00100	eb 0b		 jmp	 SHORT $LN37@hmac_gosth
$LN36@hmac_gosth:
  00102	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00106	83 c0 01	 add	 eax, 1
  00109	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN37@hmac_gosth:
  0010d	8b 84 24 a8 01
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00114	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00118	7d 22		 jge	 SHORT $LN35@hmac_gosth

; 246  : 		buf[i] = (char) (k[i] ^ 0x36);

  0011a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0011f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR k$[rsp]
  00127	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  0012b	83 f1 36	 xor	 ecx, 54			; 00000036H
  0012e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00133	88 8c 04 e0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  0013a	eb c6		 jmp	 SHORT $LN36@hmac_gosth
$LN35@hmac_gosth:

; 247  : 	for (i = lk; i < GOSTHASH_BLOCKSIZE; ++i)

  0013c	8b 84 24 a8 01
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00143	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00147	eb 0b		 jmp	 SHORT $LN34@hmac_gosth
$LN33@hmac_gosth:
  00149	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0014d	83 c0 01	 add	 eax, 1
  00150	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN34@hmac_gosth:
  00154	83 7c 24 20 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  00159	7d 0f		 jge	 SHORT $LN32@hmac_gosth

; 248  : 		buf[i] = 0x36;

  0015b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00160	c6 84 04 e0 00
	00 00 36	 mov	 BYTE PTR buf$[rsp+rax], 54 ; 00000036H
  00168	eb df		 jmp	 SHORT $LN33@hmac_gosth
$LN32@hmac_gosth:

; 249  : 
; 250  : 	GOSTHASH_add ((unsigned char *) buf, GOSTHASH_BLOCKSIZE, &ctx);

  0016a	4c 8d 44 24 50	 lea	 r8, QWORD PTR ctx$[rsp]
  0016f	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00174	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0017c	e8 00 00 00 00	 call	 GOSTHASH_add

; 251  : 	GOSTHASH_add ((unsigned char *) d, ld, &ctx);

  00181	4c 8d 44 24 50	 lea	 r8, QWORD PTR ctx$[rsp]
  00186	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR ld$[rsp]
  0018d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  00195	e8 00 00 00 00	 call	 GOSTHASH_add

; 252  : 
; 253  : 	GOSTHASH_finalize (&ctx, (unsigned char *) inner);

  0019a	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR inner$[rsp]
  001a2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  001a7	e8 00 00 00 00	 call	 GOSTHASH_finalize

; 254  : 
; 255  : 	/**** Outer Digest ****/
; 256  : 	
; 257  : 	GOSTHASH_init (&ctx);

  001ac	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  001b1	e8 00 00 00 00	 call	 GOSTHASH_init

; 258  : 
; 259  : 	for (i = 0; i < lk; ++i)

  001b6	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001be	eb 0b		 jmp	 SHORT $LN31@hmac_gosth
$LN30@hmac_gosth:
  001c0	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001c4	83 c0 01	 add	 eax, 1
  001c7	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN31@hmac_gosth:
  001cb	8b 84 24 a8 01
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  001d2	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001d6	7d 22		 jge	 SHORT $LN29@hmac_gosth

; 260  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001d8	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001dd	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR k$[rsp]
  001e5	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  001e9	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  001ec	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001f1	88 8c 04 e0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  001f8	eb c6		 jmp	 SHORT $LN30@hmac_gosth
$LN29@hmac_gosth:

; 261  : 	for (i = lk; i < GOSTHASH_BLOCKSIZE; ++i)

  001fa	8b 84 24 a8 01
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00201	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00205	eb 0b		 jmp	 SHORT $LN28@hmac_gosth
$LN27@hmac_gosth:
  00207	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0020b	83 c0 01	 add	 eax, 1
  0020e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN28@hmac_gosth:
  00212	83 7c 24 20 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  00217	7d 0f		 jge	 SHORT $LN26@hmac_gosth

; 262  : 		buf[i] = 0x5C;

  00219	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0021e	c6 84 04 e0 00
	00 00 5c	 mov	 BYTE PTR buf$[rsp+rax], 92 ; 0000005cH
  00226	eb df		 jmp	 SHORT $LN27@hmac_gosth
$LN26@hmac_gosth:

; 263  : 
; 264  : 	GOSTHASH_add ((unsigned char *) buf, GOSTHASH_BLOCKSIZE, &ctx);

  00228	4c 8d 44 24 50	 lea	 r8, QWORD PTR ctx$[rsp]
  0022d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00232	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0023a	e8 00 00 00 00	 call	 GOSTHASH_add

; 265  : 	GOSTHASH_add ((unsigned char *) inner, GOSTHASH_DIGESTSIZE, &ctx);

  0023f	4c 8d 44 24 50	 lea	 r8, QWORD PTR ctx$[rsp]
  00244	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00249	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR inner$[rsp]
  00251	e8 00 00 00 00	 call	 GOSTHASH_add

; 266  : 
; 267  : 	GOSTHASH_finalize (&ctx, (unsigned char *) out);

  00256	48 8b 94 24 c0
	01 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  0025e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  00263	e8 00 00 00 00	 call	 GOSTHASH_finalize
$LN25@hmac_gosth:

; 268  : 
; 269  : 	/* Prevent possible leaks. */
; 270  : 	burn (&ctx, sizeof(ctx));

  00268	48 8d 44 24 50	 lea	 rax, QWORD PTR ctx$[rsp]
  0026d	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR burnm$27417[rsp], rax
  00275	c7 84 24 30 01
	00 00 68 00 00
	00		 mov	 DWORD PTR burnc$27419[rsp], 104 ; 00000068H
  00280	ba 68 00 00 00	 mov	 edx, 104		; 00000068H
  00285	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  0028a	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN22@hmac_gosth:
  0028f	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR burnc$27419[rsp]
  00296	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR burnc$27419[rsp]
  0029d	83 e8 01	 sub	 eax, 1
  002a0	89 84 24 30 01
	00 00		 mov	 DWORD PTR burnc$27419[rsp], eax
  002a7	85 c9		 test	 ecx, ecx
  002a9	74 21		 je	 SHORT $LN21@hmac_gosth
  002ab	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR burnm$27417[rsp]
  002b3	c6 00 00	 mov	 BYTE PTR [rax], 0
  002b6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR burnm$27417[rsp]
  002be	48 83 c0 01	 add	 rax, 1
  002c2	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR burnm$27417[rsp], rax
  002ca	eb c3		 jmp	 SHORT $LN22@hmac_gosth
$LN21@hmac_gosth:
  002cc	33 c0		 xor	 eax, eax
  002ce	85 c0		 test	 eax, eax
  002d0	75 96		 jne	 SHORT $LN25@hmac_gosth
$LN20@hmac_gosth:

; 271  : 	burn (outer, sizeof(outer));

  002d2	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR outer$[rsp]
  002da	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR burnm$27426[rsp], rax
  002e2	c7 84 24 40 01
	00 00 20 00 00
	00		 mov	 DWORD PTR burnc$27428[rsp], 32 ; 00000020H
  002ed	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  002f2	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR outer$[rsp]
  002fa	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN17@hmac_gosth:
  002ff	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR burnc$27428[rsp]
  00306	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR burnc$27428[rsp]
  0030d	83 e8 01	 sub	 eax, 1
  00310	89 84 24 40 01
	00 00		 mov	 DWORD PTR burnc$27428[rsp], eax
  00317	85 c9		 test	 ecx, ecx
  00319	74 21		 je	 SHORT $LN16@hmac_gosth
  0031b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR burnm$27426[rsp]
  00323	c6 00 00	 mov	 BYTE PTR [rax], 0
  00326	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR burnm$27426[rsp]
  0032e	48 83 c0 01	 add	 rax, 1
  00332	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR burnm$27426[rsp], rax
  0033a	eb c3		 jmp	 SHORT $LN17@hmac_gosth
$LN16@hmac_gosth:
  0033c	33 c0		 xor	 eax, eax
  0033e	85 c0		 test	 eax, eax
  00340	75 90		 jne	 SHORT $LN20@hmac_gosth
$LN15@hmac_gosth:

; 272  : 	burn (inner, sizeof(inner));

  00342	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR inner$[rsp]
  0034a	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR burnm$27435[rsp], rax
  00352	c7 84 24 50 01
	00 00 20 00 00
	00		 mov	 DWORD PTR burnc$27437[rsp], 32 ; 00000020H
  0035d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00362	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR inner$[rsp]
  0036a	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN12@hmac_gosth:
  0036f	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR burnc$27437[rsp]
  00376	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR burnc$27437[rsp]
  0037d	83 e8 01	 sub	 eax, 1
  00380	89 84 24 50 01
	00 00		 mov	 DWORD PTR burnc$27437[rsp], eax
  00387	85 c9		 test	 ecx, ecx
  00389	74 21		 je	 SHORT $LN11@hmac_gosth
  0038b	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR burnm$27435[rsp]
  00393	c6 00 00	 mov	 BYTE PTR [rax], 0
  00396	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR burnm$27435[rsp]
  0039e	48 83 c0 01	 add	 rax, 1
  003a2	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR burnm$27435[rsp], rax
  003aa	eb c3		 jmp	 SHORT $LN12@hmac_gosth
$LN11@hmac_gosth:
  003ac	33 c0		 xor	 eax, eax
  003ae	85 c0		 test	 eax, eax
  003b0	75 90		 jne	 SHORT $LN15@hmac_gosth
$LN10@hmac_gosth:

; 273  : 	burn (buf, sizeof(buf));

  003b2	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  003ba	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR burnm$27444[rsp], rax
  003c2	c7 84 24 60 01
	00 00 20 00 00
	00		 mov	 DWORD PTR burnc$27446[rsp], 32 ; 00000020H
  003cd	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  003d2	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003da	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@hmac_gosth:
  003df	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR burnc$27446[rsp]
  003e6	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR burnc$27446[rsp]
  003ed	83 e8 01	 sub	 eax, 1
  003f0	89 84 24 60 01
	00 00		 mov	 DWORD PTR burnc$27446[rsp], eax
  003f7	85 c9		 test	 ecx, ecx
  003f9	74 21		 je	 SHORT $LN6@hmac_gosth
  003fb	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR burnm$27444[rsp]
  00403	c6 00 00	 mov	 BYTE PTR [rax], 0
  00406	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR burnm$27444[rsp]
  0040e	48 83 c0 01	 add	 rax, 1
  00412	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR burnm$27444[rsp], rax
  0041a	eb c3		 jmp	 SHORT $LN7@hmac_gosth
$LN6@hmac_gosth:
  0041c	33 c0		 xor	 eax, eax
  0041e	85 c0		 test	 eax, eax
  00420	75 90		 jne	 SHORT $LN10@hmac_gosth
$LN5@hmac_gosth:

; 274  : 	burn (key, sizeof(key));

  00422	48 8d 44 24 30	 lea	 rax, QWORD PTR key$[rsp]
  00427	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR burnm$27453[rsp], rax
  0042f	c7 84 24 70 01
	00 00 20 00 00
	00		 mov	 DWORD PTR burnc$27455[rsp], 32 ; 00000020H
  0043a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0043f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR key$[rsp]
  00444	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@hmac_gosth:
  00449	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR burnc$27455[rsp]
  00450	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR burnc$27455[rsp]
  00457	83 e8 01	 sub	 eax, 1
  0045a	89 84 24 70 01
	00 00		 mov	 DWORD PTR burnc$27455[rsp], eax
  00461	85 c9		 test	 ecx, ecx
  00463	74 21		 je	 SHORT $LN1@hmac_gosth
  00465	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR burnm$27453[rsp]
  0046d	c6 00 00	 mov	 BYTE PTR [rax], 0
  00470	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR burnm$27453[rsp]
  00478	48 83 c0 01	 add	 rax, 1
  0047c	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR burnm$27453[rsp], rax
  00484	eb c3		 jmp	 SHORT $LN2@hmac_gosth
$LN1@hmac_gosth:
  00486	33 c0		 xor	 eax, eax
  00488	85 c0		 test	 eax, eax
  0048a	75 96		 jne	 SHORT $LN5@hmac_gosth

; 275  : }

  0048c	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00494	48 33 cc	 xor	 rcx, rsp
  00497	e8 00 00 00 00	 call	 __security_check_cookie
  0049c	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  004a3	c3		 ret	 0
hmac_gosthash ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_whirlpool
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_key_whirlpool DD imagerel $LN13
	DD	imagerel $LN13+530
	DD	imagerel $unwind$derive_key_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_whirlpool DD 042e19H
	DD	017011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_key_whirlpool
_TEXT	SEGMENT
u$ = 80
b$ = 144
l$ = 148
r$ = 152
burnc$27361 = 156
burnm$27359 = 160
__$ArrayPad$ = 168
pwd$ = 208
pwd_len$ = 216
salt$ = 224
salt_len$ = 232
iterations$ = 240
dk$ = 248
dklen$ = 256
derive_key_whirlpool PROC				; COMDAT

; 179  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 180  : 	char u[WHIRLPOOL_DIGESTSIZE];
; 181  : 	int b, l, r;
; 182  : 
; 183  : 	if (dklen % WHIRLPOOL_DIGESTSIZE)

  0002e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00035	99		 cdq
  00036	83 e2 3f	 and	 edx, 63			; 0000003fH
  00039	03 c2		 add	 eax, edx
  0003b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0003e	2b c2		 sub	 eax, edx
  00040	85 c0		 test	 eax, eax
  00042	74 1c		 je	 SHORT $LN10@derive_key

; 184  : 	{
; 185  : 		l = 1 + dklen / WHIRLPOOL_DIGESTSIZE;

  00044	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0004b	99		 cdq
  0004c	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004f	03 c2		 add	 eax, edx
  00051	c1 f8 06	 sar	 eax, 6
  00054	83 c0 01	 add	 eax, 1
  00057	89 84 24 94 00
	00 00		 mov	 DWORD PTR l$[rsp], eax

; 186  : 	}
; 187  : 	else

  0005e	eb 17		 jmp	 SHORT $LN9@derive_key
$LN10@derive_key:

; 188  : 	{
; 189  : 		l = dklen / WHIRLPOOL_DIGESTSIZE;

  00060	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00067	99		 cdq
  00068	83 e2 3f	 and	 edx, 63			; 0000003fH
  0006b	03 c2		 add	 eax, edx
  0006d	c1 f8 06	 sar	 eax, 6
  00070	89 84 24 94 00
	00 00		 mov	 DWORD PTR l$[rsp], eax
$LN9@derive_key:

; 190  : 	}
; 191  : 
; 192  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;

  00077	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR l$[rsp]
  0007e	83 e9 01	 sub	 ecx, 1
  00081	6b c9 40	 imul	 ecx, 64			; 00000040H
  00084	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0008b	2b c1		 sub	 eax, ecx
  0008d	89 84 24 98 00
	00 00		 mov	 DWORD PTR r$[rsp], eax

; 193  : 
; 194  : 	/* first l - 1 blocks */
; 195  : 	for (b = 1; b < l; b++)

  00094	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR b$[rsp], 1
  0009f	eb 11		 jmp	 SHORT $LN8@derive_key
$LN7@derive_key:
  000a1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 84 24 90 00
	00 00		 mov	 DWORD PTR b$[rsp], eax
$LN8@derive_key:
  000b2	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR l$[rsp]
  000b9	39 84 24 90 00
	00 00		 cmp	 DWORD PTR b$[rsp], eax
  000c0	7d 71		 jge	 SHORT $LN6@derive_key

; 196  : 	{
; 197  : 		derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  000c9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000cd	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000d2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d7	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000de	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e2	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  000ea	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  000f2	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000f9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  00101	e8 00 00 00 00	 call	 derive_u_whirlpool

; 198  : 		memcpy (dk, u, WHIRLPOOL_DIGESTSIZE);

  00106	48 8d 74 24 50	 lea	 rsi, QWORD PTR u$[rsp]
  0010b	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  00113	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00118	f3 a4		 rep movsb

; 199  : 		dk += WHIRLPOOL_DIGESTSIZE;

  0011a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dk$[rsp]
  00122	48 83 c0 40	 add	 rax, 64			; 00000040H
  00126	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR dk$[rsp], rax

; 200  : 	}

  0012e	e9 6e ff ff ff	 jmp	 $LN7@derive_key
$LN6@derive_key:

; 201  : 
; 202  : 	/* last block */
; 203  : 	derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00133	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  0013a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0013e	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00143	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00148	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  0014f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00153	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  0015b	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  00163	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  0016a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  00172	e8 00 00 00 00	 call	 derive_u_whirlpool

; 204  : 	memcpy (dk, u, r);

  00177	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR r$[rsp]
  0017f	48 8d 74 24 50	 lea	 rsi, QWORD PTR u$[rsp]
  00184	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  0018c	f3 a4		 rep movsb
$LN5@derive_key:

; 205  : 
; 206  : 
; 207  : 	/* Prevent possible leaks. */
; 208  : 	burn (u, sizeof(u));

  0018e	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00193	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR burnm$27359[rsp], rax
  0019b	c7 84 24 9c 00
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27361[rsp], 64 ; 00000040H
  001a6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001ab	48 8d 4c 24 50	 lea	 rcx, QWORD PTR u$[rsp]
  001b0	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_key:
  001b5	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR burnc$27361[rsp]
  001bc	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR burnc$27361[rsp]
  001c3	83 e8 01	 sub	 eax, 1
  001c6	89 84 24 9c 00
	00 00		 mov	 DWORD PTR burnc$27361[rsp], eax
  001cd	85 c9		 test	 ecx, ecx
  001cf	74 21		 je	 SHORT $LN1@derive_key
  001d1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR burnm$27359[rsp]
  001d9	c6 00 00	 mov	 BYTE PTR [rax], 0
  001dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR burnm$27359[rsp]
  001e4	48 83 c0 01	 add	 rax, 1
  001e8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR burnm$27359[rsp], rax
  001f0	eb c3		 jmp	 SHORT $LN2@derive_key
$LN1@derive_key:
  001f2	33 c0		 xor	 eax, eax
  001f4	85 c0		 test	 eax, eax
  001f6	75 96		 jne	 SHORT $LN5@derive_key

; 209  : }

  001f8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00200	48 33 cc	 xor	 rcx, rsp
  00203	e8 00 00 00 00	 call	 __security_check_cookie
  00208	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0020f	5f		 pop	 rdi
  00210	5e		 pop	 rsi
  00211	c3		 ret	 0
derive_key_whirlpool ENDP
PUBLIC	__$ArrayPad$
PUBLIC	hmac_stribog
;	COMDAT pdata
pdata	SEGMENT
$pdata$hmac_stribog DD imagerel $LN46
	DD	imagerel $LN46+1193
	DD	imagerel $unwind$hmac_stribog
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_stribog DD 022c19H
	DD	067011aH
	DD	imagerel __GSHandlerCheck
	DD	0320H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hmac_stribog
_TEXT	SEGMENT
i$ = 32
key$ = 48
ctx$ = 112
inner$ = 512
buf$ = 576
outer$ = 640
burnc$27563 = 704
burnm$27561 = 712
burnc$27592 = 720
burnm$27590 = 728
burnc$27601 = 736
burnm$27599 = 744
burnc$27610 = 752
burnm$27608 = 760
burnc$27619 = 768
burnm$27617 = 776
burnc$27628 = 784
burnm$27626 = 792
__$ArrayPad$ = 800
k$ = 832
lk$ = 840
d$ = 848
ld$ = 856
out$ = 864
hmac_stribog PROC					; COMDAT

; 379  : {

$LN46:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 38 03
	00 00		 sub	 rsp, 824		; 00000338H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 380  : 	STRIBOG_CTX ctx;
; 381  : 	char inner[STRIBOG_DIGESTSIZE], outer[STRIBOG_DIGESTSIZE];
; 382  : 	char key[STRIBOG_DIGESTSIZE];
; 383  : 	char buf[STRIBOG_BLOCKSIZE];
; 384  : 	int32 i;
; 385  : 
; 386  :     /* If the key is longer than the hash algorithm block size,
; 387  : 	   let key = stribog(key), as per HMAC specifications. */
; 388  : 	if (lk > STRIBOG_BLOCKSIZE)

  0002c	83 bc 24 48 03
	00 00 40	 cmp	 DWORD PTR lk$[rsp], 64	; 00000040H
  00034	0f 8e b5 00 00
	00		 jle	 $LN43@hmac_strib

; 389  : 	{
; 390  : 		STRIBOG_init (&ctx);

  0003a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  0003f	e8 00 00 00 00	 call	 STRIBOG_init

; 391  : 		STRIBOG_add (&ctx, (unsigned char *)k, lk);

  00044	44 8b 84 24 48
	03 00 00	 mov	 r8d, DWORD PTR lk$[rsp]
  0004c	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR k$[rsp]
  00054	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  00059	e8 00 00 00 00	 call	 STRIBOG_add

; 392  : 		STRIBOG_finalize (&ctx, (unsigned char *) key);

  0005e	48 8d 54 24 30	 lea	 rdx, QWORD PTR key$[rsp]
  00063	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  00068	e8 00 00 00 00	 call	 STRIBOG_finalize

; 393  : 
; 394  : 		k = key;

  0006d	4c 8d 5c 24 30	 lea	 r11, QWORD PTR key$[rsp]
  00072	4c 89 9c 24 40
	03 00 00	 mov	 QWORD PTR k$[rsp], r11

; 395  : 		lk = STRIBOG_DIGESTSIZE;

  0007a	c7 84 24 48 03
	00 00 40 00 00
	00		 mov	 DWORD PTR lk$[rsp], 64	; 00000040H
$LN42@hmac_strib:

; 396  : 
; 397  : 		burn (&ctx, sizeof(ctx));		// Prevent leaks

  00085	48 8d 44 24 70	 lea	 rax, QWORD PTR ctx$[rsp]
  0008a	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR burnm$27561[rsp], rax
  00092	c7 84 24 c0 02
	00 00 81 01 00
	00		 mov	 DWORD PTR burnc$27563[rsp], 385 ; 00000181H
  0009d	ba 81 01 00 00	 mov	 edx, 385		; 00000181H
  000a2	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  000a7	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN39@hmac_strib:
  000ac	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR burnc$27563[rsp]
  000b3	8b 84 24 c0 02
	00 00		 mov	 eax, DWORD PTR burnc$27563[rsp]
  000ba	83 e8 01	 sub	 eax, 1
  000bd	89 84 24 c0 02
	00 00		 mov	 DWORD PTR burnc$27563[rsp], eax
  000c4	85 c9		 test	 ecx, ecx
  000c6	74 21		 je	 SHORT $LN38@hmac_strib
  000c8	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR burnm$27561[rsp]
  000d0	c6 00 00	 mov	 BYTE PTR [rax], 0
  000d3	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR burnm$27561[rsp]
  000db	48 83 c0 01	 add	 rax, 1
  000df	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR burnm$27561[rsp], rax
  000e7	eb c3		 jmp	 SHORT $LN39@hmac_strib
$LN38@hmac_strib:
  000e9	33 c0		 xor	 eax, eax
  000eb	85 c0		 test	 eax, eax
  000ed	75 96		 jne	 SHORT $LN42@hmac_strib
$LN43@hmac_strib:

; 398  : 	}
; 399  : 
; 400  : 	/**** Inner Digest ****/
; 401  : 
; 402  : 	STRIBOG_init (&ctx);

  000ef	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  000f4	e8 00 00 00 00	 call	 STRIBOG_init

; 403  : 
; 404  : 	/* Pad the key for inner digest */
; 405  : 	for (i = 0; i < lk; ++i)

  000f9	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00101	eb 0b		 jmp	 SHORT $LN37@hmac_strib
$LN36@hmac_strib:
  00103	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00107	83 c0 01	 add	 eax, 1
  0010a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN37@hmac_strib:
  0010e	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00115	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00119	7d 22		 jge	 SHORT $LN35@hmac_strib

; 406  : 		buf[i] = (char) (k[i] ^ 0x36);

  0011b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00120	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR k$[rsp]
  00128	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  0012c	83 f1 36	 xor	 ecx, 54			; 00000036H
  0012f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00134	88 8c 04 40 02
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  0013b	eb c6		 jmp	 SHORT $LN36@hmac_strib
$LN35@hmac_strib:

; 407  : 	for (i = lk; i < STRIBOG_BLOCKSIZE; ++i)

  0013d	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00144	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00148	eb 0b		 jmp	 SHORT $LN34@hmac_strib
$LN33@hmac_strib:
  0014a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0014e	83 c0 01	 add	 eax, 1
  00151	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN34@hmac_strib:
  00155	83 7c 24 20 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0015a	7d 0f		 jge	 SHORT $LN32@hmac_strib

; 408  : 		buf[i] = 0x36;

  0015c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00161	c6 84 04 40 02
	00 00 36	 mov	 BYTE PTR buf$[rsp+rax], 54 ; 00000036H
  00169	eb df		 jmp	 SHORT $LN33@hmac_strib
$LN32@hmac_strib:

; 409  : 
; 410  : 	STRIBOG_add (&ctx, (unsigned char *) buf, STRIBOG_BLOCKSIZE);

  0016b	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00171	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00179	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  0017e	e8 00 00 00 00	 call	 STRIBOG_add

; 411  : 	STRIBOG_add (&ctx, (unsigned char *) d, ld);

  00183	44 8b 84 24 58
	03 00 00	 mov	 r8d, DWORD PTR ld$[rsp]
  0018b	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR d$[rsp]
  00193	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  00198	e8 00 00 00 00	 call	 STRIBOG_add

; 412  : 
; 413  : 	STRIBOG_finalize (&ctx, (unsigned char *) inner);

  0019d	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR inner$[rsp]
  001a5	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  001aa	e8 00 00 00 00	 call	 STRIBOG_finalize

; 414  : 
; 415  : 	/**** Outer Digest ****/
; 416  : 	
; 417  : 	STRIBOG_init (&ctx);

  001af	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  001b4	e8 00 00 00 00	 call	 STRIBOG_init

; 418  : 
; 419  : 	for (i = 0; i < lk; ++i)

  001b9	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001c1	eb 0b		 jmp	 SHORT $LN31@hmac_strib
$LN30@hmac_strib:
  001c3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001c7	83 c0 01	 add	 eax, 1
  001ca	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN31@hmac_strib:
  001ce	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  001d5	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001d9	7d 22		 jge	 SHORT $LN29@hmac_strib

; 420  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001db	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001e0	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR k$[rsp]
  001e8	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  001ec	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  001ef	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001f4	88 8c 04 40 02
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  001fb	eb c6		 jmp	 SHORT $LN30@hmac_strib
$LN29@hmac_strib:

; 421  : 	for (i = lk; i < STRIBOG_BLOCKSIZE; ++i)

  001fd	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00204	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00208	eb 0b		 jmp	 SHORT $LN28@hmac_strib
$LN27@hmac_strib:
  0020a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0020e	83 c0 01	 add	 eax, 1
  00211	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN28@hmac_strib:
  00215	83 7c 24 20 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0021a	7d 0f		 jge	 SHORT $LN26@hmac_strib

; 422  : 		buf[i] = 0x5C;

  0021c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00221	c6 84 04 40 02
	00 00 5c	 mov	 BYTE PTR buf$[rsp+rax], 92 ; 0000005cH
  00229	eb df		 jmp	 SHORT $LN27@hmac_strib
$LN26@hmac_strib:

; 423  : 
; 424  : 	STRIBOG_add (&ctx, (unsigned char *) buf, STRIBOG_BLOCKSIZE);

  0022b	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00231	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00239	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  0023e	e8 00 00 00 00	 call	 STRIBOG_add

; 425  : 	STRIBOG_add (&ctx, (unsigned char *) inner, STRIBOG_DIGESTSIZE);

  00243	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00249	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR inner$[rsp]
  00251	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  00256	e8 00 00 00 00	 call	 STRIBOG_add

; 426  : 
; 427  : 	STRIBOG_finalize (&ctx, (unsigned char *) out);

  0025b	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00263	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  00268	e8 00 00 00 00	 call	 STRIBOG_finalize
$LN25@hmac_strib:

; 428  : 
; 429  : 	/* Prevent possible leaks. */
; 430  : 	burn (&ctx, sizeof(ctx));

  0026d	48 8d 44 24 70	 lea	 rax, QWORD PTR ctx$[rsp]
  00272	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR burnm$27590[rsp], rax
  0027a	c7 84 24 d0 02
	00 00 81 01 00
	00		 mov	 DWORD PTR burnc$27592[rsp], 385 ; 00000181H
  00285	ba 81 01 00 00	 mov	 edx, 385		; 00000181H
  0028a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ctx$[rsp]
  0028f	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN22@hmac_strib:
  00294	8b 8c 24 d0 02
	00 00		 mov	 ecx, DWORD PTR burnc$27592[rsp]
  0029b	8b 84 24 d0 02
	00 00		 mov	 eax, DWORD PTR burnc$27592[rsp]
  002a2	83 e8 01	 sub	 eax, 1
  002a5	89 84 24 d0 02
	00 00		 mov	 DWORD PTR burnc$27592[rsp], eax
  002ac	85 c9		 test	 ecx, ecx
  002ae	74 21		 je	 SHORT $LN21@hmac_strib
  002b0	48 8b 84 24 d8
	02 00 00	 mov	 rax, QWORD PTR burnm$27590[rsp]
  002b8	c6 00 00	 mov	 BYTE PTR [rax], 0
  002bb	48 8b 84 24 d8
	02 00 00	 mov	 rax, QWORD PTR burnm$27590[rsp]
  002c3	48 83 c0 01	 add	 rax, 1
  002c7	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR burnm$27590[rsp], rax
  002cf	eb c3		 jmp	 SHORT $LN22@hmac_strib
$LN21@hmac_strib:
  002d1	33 c0		 xor	 eax, eax
  002d3	85 c0		 test	 eax, eax
  002d5	75 96		 jne	 SHORT $LN25@hmac_strib
$LN20@hmac_strib:

; 431  : 	burn (outer, sizeof(outer));

  002d7	48 8d 84 24 80
	02 00 00	 lea	 rax, QWORD PTR outer$[rsp]
  002df	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR burnm$27599[rsp], rax
  002e7	c7 84 24 e0 02
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27601[rsp], 64 ; 00000040H
  002f2	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  002f7	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR outer$[rsp]
  002ff	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN17@hmac_strib:
  00304	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR burnc$27601[rsp]
  0030b	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR burnc$27601[rsp]
  00312	83 e8 01	 sub	 eax, 1
  00315	89 84 24 e0 02
	00 00		 mov	 DWORD PTR burnc$27601[rsp], eax
  0031c	85 c9		 test	 ecx, ecx
  0031e	74 21		 je	 SHORT $LN16@hmac_strib
  00320	48 8b 84 24 e8
	02 00 00	 mov	 rax, QWORD PTR burnm$27599[rsp]
  00328	c6 00 00	 mov	 BYTE PTR [rax], 0
  0032b	48 8b 84 24 e8
	02 00 00	 mov	 rax, QWORD PTR burnm$27599[rsp]
  00333	48 83 c0 01	 add	 rax, 1
  00337	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR burnm$27599[rsp], rax
  0033f	eb c3		 jmp	 SHORT $LN17@hmac_strib
$LN16@hmac_strib:
  00341	33 c0		 xor	 eax, eax
  00343	85 c0		 test	 eax, eax
  00345	75 90		 jne	 SHORT $LN20@hmac_strib
$LN15@hmac_strib:

; 432  : 	burn (inner, sizeof(inner));

  00347	48 8d 84 24 00
	02 00 00	 lea	 rax, QWORD PTR inner$[rsp]
  0034f	48 89 84 24 f8
	02 00 00	 mov	 QWORD PTR burnm$27608[rsp], rax
  00357	c7 84 24 f0 02
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27610[rsp], 64 ; 00000040H
  00362	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00367	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR inner$[rsp]
  0036f	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN12@hmac_strib:
  00374	8b 8c 24 f0 02
	00 00		 mov	 ecx, DWORD PTR burnc$27610[rsp]
  0037b	8b 84 24 f0 02
	00 00		 mov	 eax, DWORD PTR burnc$27610[rsp]
  00382	83 e8 01	 sub	 eax, 1
  00385	89 84 24 f0 02
	00 00		 mov	 DWORD PTR burnc$27610[rsp], eax
  0038c	85 c9		 test	 ecx, ecx
  0038e	74 21		 je	 SHORT $LN11@hmac_strib
  00390	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR burnm$27608[rsp]
  00398	c6 00 00	 mov	 BYTE PTR [rax], 0
  0039b	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR burnm$27608[rsp]
  003a3	48 83 c0 01	 add	 rax, 1
  003a7	48 89 84 24 f8
	02 00 00	 mov	 QWORD PTR burnm$27608[rsp], rax
  003af	eb c3		 jmp	 SHORT $LN12@hmac_strib
$LN11@hmac_strib:
  003b1	33 c0		 xor	 eax, eax
  003b3	85 c0		 test	 eax, eax
  003b5	75 90		 jne	 SHORT $LN15@hmac_strib
$LN10@hmac_strib:

; 433  : 	burn (buf, sizeof(buf));

  003b7	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  003bf	48 89 84 24 08
	03 00 00	 mov	 QWORD PTR burnm$27617[rsp], rax
  003c7	c7 84 24 00 03
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27619[rsp], 64 ; 00000040H
  003d2	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  003d7	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003df	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@hmac_strib:
  003e4	8b 8c 24 00 03
	00 00		 mov	 ecx, DWORD PTR burnc$27619[rsp]
  003eb	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR burnc$27619[rsp]
  003f2	83 e8 01	 sub	 eax, 1
  003f5	89 84 24 00 03
	00 00		 mov	 DWORD PTR burnc$27619[rsp], eax
  003fc	85 c9		 test	 ecx, ecx
  003fe	74 21		 je	 SHORT $LN6@hmac_strib
  00400	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR burnm$27617[rsp]
  00408	c6 00 00	 mov	 BYTE PTR [rax], 0
  0040b	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR burnm$27617[rsp]
  00413	48 83 c0 01	 add	 rax, 1
  00417	48 89 84 24 08
	03 00 00	 mov	 QWORD PTR burnm$27617[rsp], rax
  0041f	eb c3		 jmp	 SHORT $LN7@hmac_strib
$LN6@hmac_strib:
  00421	33 c0		 xor	 eax, eax
  00423	85 c0		 test	 eax, eax
  00425	75 90		 jne	 SHORT $LN10@hmac_strib
$LN5@hmac_strib:

; 434  : 	burn (key, sizeof(key));

  00427	48 8d 44 24 30	 lea	 rax, QWORD PTR key$[rsp]
  0042c	48 89 84 24 18
	03 00 00	 mov	 QWORD PTR burnm$27626[rsp], rax
  00434	c7 84 24 10 03
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27628[rsp], 64 ; 00000040H
  0043f	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00444	48 8d 4c 24 30	 lea	 rcx, QWORD PTR key$[rsp]
  00449	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@hmac_strib:
  0044e	8b 8c 24 10 03
	00 00		 mov	 ecx, DWORD PTR burnc$27628[rsp]
  00455	8b 84 24 10 03
	00 00		 mov	 eax, DWORD PTR burnc$27628[rsp]
  0045c	83 e8 01	 sub	 eax, 1
  0045f	89 84 24 10 03
	00 00		 mov	 DWORD PTR burnc$27628[rsp], eax
  00466	85 c9		 test	 ecx, ecx
  00468	74 21		 je	 SHORT $LN1@hmac_strib
  0046a	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR burnm$27626[rsp]
  00472	c6 00 00	 mov	 BYTE PTR [rax], 0
  00475	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR burnm$27626[rsp]
  0047d	48 83 c0 01	 add	 rax, 1
  00481	48 89 84 24 18
	03 00 00	 mov	 QWORD PTR burnm$27626[rsp], rax
  00489	eb c3		 jmp	 SHORT $LN2@hmac_strib
$LN1@hmac_strib:
  0048b	33 c0		 xor	 eax, eax
  0048d	85 c0		 test	 eax, eax
  0048f	75 96		 jne	 SHORT $LN5@hmac_strib

; 435  : }

  00491	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00499	48 33 cc	 xor	 rcx, rsp
  0049c	e8 00 00 00 00	 call	 __security_check_cookie
  004a1	48 81 c4 38 03
	00 00		 add	 rsp, 824		; 00000338H
  004a8	c3		 ret	 0
hmac_stribog ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_gosthash
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_u_gosthash DD imagerel $LN19
	DD	imagerel $LN19+648
	DD	imagerel $unwind$derive_u_gosthash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_gosthash DD 042e19H
	DD	029011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0130H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_u_gosthash
_TEXT	SEGMENT
i$ = 48
init$ = 64
counter$ = 192
k$ = 200
c$ = 232
j$ = 240
burnc$27492 = 272
burnm$27490 = 280
burnc$27501 = 288
burnm$27499 = 296
__$ArrayPad$ = 304
pwd$ = 352
pwd_len$ = 360
salt$ = 368
salt_len$ = 376
iterations$ = 384
u$ = 392
b$ = 400
derive_u_gosthash PROC					; COMDAT

; 292  : {

$LN19:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 293  : 	char j[GOSTHASH_DIGESTSIZE], k[GOSTHASH_DIGESTSIZE];
; 294  : 	char init[128];
; 295  : 	char counter[4];
; 296  : 	int c, i;
; 297  : 
; 298  : 	/* iteration 1 */
; 299  : 	memset (counter, 0, 4);

  0002e	48 8d bc 24 c0
	00 00 00	 lea	 rdi, QWORD PTR counter$[rsp]
  00036	33 c0		 xor	 eax, eax
  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	f3 aa		 rep stosb

; 300  : 	counter[3] = (char) b;

  0003f	0f b6 84 24 90
	01 00 00	 movzx	 eax, BYTE PTR b$[rsp]
  00047	88 84 24 c3 00
	00 00		 mov	 BYTE PTR counter$[rsp+3], al

; 301  : 	memcpy (init, salt, salt_len);	/* salt */

  0004e	48 63 8c 24 78
	01 00 00	 movsxd	 rcx, DWORD PTR salt_len$[rsp]
  00056	48 8d 7c 24 40	 lea	 rdi, QWORD PTR init$[rsp]
  0005b	48 8b b4 24 70
	01 00 00	 mov	 rsi, QWORD PTR salt$[rsp]
  00063	f3 a4		 rep movsb

; 302  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00065	48 63 94 24 78
	01 00 00	 movsxd	 rdx, DWORD PTR salt_len$[rsp]
  0006d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR counter$[rsp]
  00074	89 44 14 40	 mov	 DWORD PTR init$[rsp+rdx], eax

; 303  : 	hmac_gosthash (pwd, pwd_len, init, salt_len + 4, j);

  00078	44 8b 8c 24 78
	01 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  00080	41 83 c1 04	 add	 r9d, 4
  00084	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR j$[rsp]
  0008c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00091	4c 8d 44 24 40	 lea	 r8, QWORD PTR init$[rsp]
  00096	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  0009d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  000a5	e8 00 00 00 00	 call	 hmac_gosthash

; 304  : 	memcpy (u, j, GOSTHASH_DIGESTSIZE);

  000aa	48 8d b4 24 f0
	00 00 00	 lea	 rsi, QWORD PTR j$[rsp]
  000b2	48 8b bc 24 88
	01 00 00	 mov	 rdi, QWORD PTR u$[rsp]
  000ba	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000bf	f3 a4		 rep movsb

; 305  : 
; 306  : 	/* remaining iterations */
; 307  : 	for (c = 1; c < iterations; c++)

  000c1	c7 84 24 e8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR c$[rsp], 1
  000cc	eb 11		 jmp	 SHORT $LN16@derive_u_g
$LN15@derive_u_g:
  000ce	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 84 24 e8 00
	00 00		 mov	 DWORD PTR c$[rsp], eax
$LN16@derive_u_g:
  000df	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000e6	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR c$[rsp], eax
  000ed	0f 8d 9b 00 00
	00		 jge	 $LN14@derive_u_g

; 308  : 	{
; 309  : 		hmac_gosthash (pwd, pwd_len, j, GOSTHASH_DIGESTSIZE, k);

  000f3	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  000fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00100	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  00106	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR j$[rsp]
  0010e	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  00115	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  0011d	e8 00 00 00 00	 call	 hmac_gosthash

; 310  : 		for (i = 0; i < GOSTHASH_DIGESTSIZE; i++)

  00122	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0012a	eb 0b		 jmp	 SHORT $LN13@derive_u_g
$LN12@derive_u_g:
  0012c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00130	83 c0 01	 add	 eax, 1
  00133	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@derive_u_g:
  00137	83 7c 24 30 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  0013c	7d 4b		 jge	 SHORT $LN11@derive_u_g

; 311  : 		{
; 312  : 			u[i] ^= k[i];

  0013e	48 63 54 24 30	 movsxd	 rdx, DWORD PTR i$[rsp]
  00143	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00148	0f be 8c 04 c8
	00 00 00	 movsx	 ecx, BYTE PTR k$[rsp+rax]
  00150	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00158	0f be 14 10	 movsx	 edx, BYTE PTR [rax+rdx]
  0015c	33 d1		 xor	 edx, ecx
  0015e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00163	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0016b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 313  : 			j[i] = k[i];

  0016e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00173	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00178	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00180	88 84 0c f0 00
	00 00		 mov	 BYTE PTR j$[rsp+rcx], al

; 314  : 		}

  00187	eb a3		 jmp	 SHORT $LN12@derive_u_g
$LN11@derive_u_g:

; 315  : 	}

  00189	e9 40 ff ff ff	 jmp	 $LN15@derive_u_g
$LN14@derive_u_g:
$LN10@derive_u_g:

; 316  : 
; 317  : 	/* Prevent possible leaks. */
; 318  : 	burn (j, sizeof(j));

  0018e	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR j$[rsp]
  00196	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR burnm$27490[rsp], rax
  0019e	c7 84 24 10 01
	00 00 20 00 00
	00		 mov	 DWORD PTR burnc$27492[rsp], 32 ; 00000020H
  001a9	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001ae	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR j$[rsp]
  001b6	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@derive_u_g:
  001bb	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR burnc$27492[rsp]
  001c2	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR burnc$27492[rsp]
  001c9	83 e8 01	 sub	 eax, 1
  001cc	89 84 24 10 01
	00 00		 mov	 DWORD PTR burnc$27492[rsp], eax
  001d3	85 c9		 test	 ecx, ecx
  001d5	74 21		 je	 SHORT $LN6@derive_u_g
  001d7	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR burnm$27490[rsp]
  001df	c6 00 00	 mov	 BYTE PTR [rax], 0
  001e2	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR burnm$27490[rsp]
  001ea	48 83 c0 01	 add	 rax, 1
  001ee	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR burnm$27490[rsp], rax
  001f6	eb c3		 jmp	 SHORT $LN7@derive_u_g
$LN6@derive_u_g:
  001f8	33 c0		 xor	 eax, eax
  001fa	85 c0		 test	 eax, eax
  001fc	75 90		 jne	 SHORT $LN10@derive_u_g
$LN5@derive_u_g:

; 319  : 	burn (k, sizeof(k));

  001fe	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  00206	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR burnm$27499[rsp], rax
  0020e	c7 84 24 20 01
	00 00 20 00 00
	00		 mov	 DWORD PTR burnc$27501[rsp], 32 ; 00000020H
  00219	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0021e	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00226	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_u_g:
  0022b	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR burnc$27501[rsp]
  00232	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR burnc$27501[rsp]
  00239	83 e8 01	 sub	 eax, 1
  0023c	89 84 24 20 01
	00 00		 mov	 DWORD PTR burnc$27501[rsp], eax
  00243	85 c9		 test	 ecx, ecx
  00245	74 21		 je	 SHORT $LN1@derive_u_g
  00247	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR burnm$27499[rsp]
  0024f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00252	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR burnm$27499[rsp]
  0025a	48 83 c0 01	 add	 rax, 1
  0025e	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR burnm$27499[rsp], rax
  00266	eb c3		 jmp	 SHORT $LN2@derive_u_g
$LN1@derive_u_g:
  00268	33 c0		 xor	 eax, eax
  0026a	85 c0		 test	 eax, eax
  0026c	75 90		 jne	 SHORT $LN5@derive_u_g

; 320  : }

  0026e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00276	48 33 cc	 xor	 rcx, rsp
  00279	e8 00 00 00 00	 call	 __security_check_cookie
  0027e	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  00285	5f		 pop	 rdi
  00286	5e		 pop	 rsi
  00287	c3		 ret	 0
derive_u_gosthash ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_stribog
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_u_stribog DD imagerel $LN19
	DD	imagerel $LN19+648
	DD	imagerel $unwind$derive_u_stribog
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_stribog DD 042e19H
	DD	033011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0180H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_u_stribog
_TEXT	SEGMENT
i$ = 48
init$ = 64
counter$ = 192
k$ = 208
c$ = 272
j$ = 288
burnc$27665 = 352
burnm$27663 = 360
burnc$27674 = 368
burnm$27672 = 376
__$ArrayPad$ = 384
pwd$ = 432
pwd_len$ = 440
salt$ = 448
salt_len$ = 456
iterations$ = 464
u$ = 472
b$ = 480
derive_u_stribog PROC					; COMDAT

; 452  : {

$LN19:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 453  : 	char j[STRIBOG_DIGESTSIZE], k[STRIBOG_DIGESTSIZE];
; 454  : 	char init[128];
; 455  : 	char counter[4];
; 456  : 	int c, i;
; 457  : 
; 458  : 	/* iteration 1 */
; 459  : 	memset (counter, 0, 4);

  0002e	48 8d bc 24 c0
	00 00 00	 lea	 rdi, QWORD PTR counter$[rsp]
  00036	33 c0		 xor	 eax, eax
  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	f3 aa		 rep stosb

; 460  : 	counter[3] = (char) b;

  0003f	0f b6 84 24 e0
	01 00 00	 movzx	 eax, BYTE PTR b$[rsp]
  00047	88 84 24 c3 00
	00 00		 mov	 BYTE PTR counter$[rsp+3], al

; 461  : 	memcpy (init, salt, salt_len);	/* salt */

  0004e	48 63 8c 24 c8
	01 00 00	 movsxd	 rcx, DWORD PTR salt_len$[rsp]
  00056	48 8d 7c 24 40	 lea	 rdi, QWORD PTR init$[rsp]
  0005b	48 8b b4 24 c0
	01 00 00	 mov	 rsi, QWORD PTR salt$[rsp]
  00063	f3 a4		 rep movsb

; 462  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00065	48 63 94 24 c8
	01 00 00	 movsxd	 rdx, DWORD PTR salt_len$[rsp]
  0006d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR counter$[rsp]
  00074	89 44 14 40	 mov	 DWORD PTR init$[rsp+rdx], eax

; 463  : 	hmac_stribog (pwd, pwd_len, init, salt_len + 4, j);

  00078	44 8b 8c 24 c8
	01 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  00080	41 83 c1 04	 add	 r9d, 4
  00084	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR j$[rsp]
  0008c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00091	4c 8d 44 24 40	 lea	 r8, QWORD PTR init$[rsp]
  00096	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  0009d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  000a5	e8 00 00 00 00	 call	 hmac_stribog

; 464  : 	memcpy (u, j, STRIBOG_DIGESTSIZE);

  000aa	48 8d b4 24 20
	01 00 00	 lea	 rsi, QWORD PTR j$[rsp]
  000b2	48 8b bc 24 d8
	01 00 00	 mov	 rdi, QWORD PTR u$[rsp]
  000ba	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000bf	f3 a4		 rep movsb

; 465  : 
; 466  : 	/* remaining iterations */
; 467  : 	for (c = 1; c < iterations; c++)

  000c1	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR c$[rsp], 1
  000cc	eb 11		 jmp	 SHORT $LN16@derive_u_s
$LN15@derive_u_s:
  000ce	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 84 24 10 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
$LN16@derive_u_s:
  000df	8b 84 24 d0 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000e6	39 84 24 10 01
	00 00		 cmp	 DWORD PTR c$[rsp], eax
  000ed	0f 8d 9b 00 00
	00		 jge	 $LN14@derive_u_s

; 468  : 	{
; 469  : 		hmac_stribog (pwd, pwd_len, j, STRIBOG_DIGESTSIZE, k);

  000f3	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  000fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00100	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00106	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR j$[rsp]
  0010e	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  00115	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  0011d	e8 00 00 00 00	 call	 hmac_stribog

; 470  : 		for (i = 0; i < STRIBOG_DIGESTSIZE; i++)

  00122	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0012a	eb 0b		 jmp	 SHORT $LN13@derive_u_s
$LN12@derive_u_s:
  0012c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00130	83 c0 01	 add	 eax, 1
  00133	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@derive_u_s:
  00137	83 7c 24 30 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0013c	7d 4b		 jge	 SHORT $LN11@derive_u_s

; 471  : 		{
; 472  : 			u[i] ^= k[i];

  0013e	48 63 54 24 30	 movsxd	 rdx, DWORD PTR i$[rsp]
  00143	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00148	0f be 8c 04 d0
	00 00 00	 movsx	 ecx, BYTE PTR k$[rsp+rax]
  00150	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00158	0f be 14 10	 movsx	 edx, BYTE PTR [rax+rdx]
  0015c	33 d1		 xor	 edx, ecx
  0015e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00163	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0016b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 473  : 			j[i] = k[i];

  0016e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00173	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00178	0f b6 84 04 d0
	00 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00180	88 84 0c 20 01
	00 00		 mov	 BYTE PTR j$[rsp+rcx], al

; 474  : 		}

  00187	eb a3		 jmp	 SHORT $LN12@derive_u_s
$LN11@derive_u_s:

; 475  : 	}

  00189	e9 40 ff ff ff	 jmp	 $LN15@derive_u_s
$LN14@derive_u_s:
$LN10@derive_u_s:

; 476  : 
; 477  : 	/* Prevent possible leaks. */
; 478  : 	burn (j, sizeof(j));

  0018e	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR j$[rsp]
  00196	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR burnm$27663[rsp], rax
  0019e	c7 84 24 60 01
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27665[rsp], 64 ; 00000040H
  001a9	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001ae	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR j$[rsp]
  001b6	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@derive_u_s:
  001bb	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR burnc$27665[rsp]
  001c2	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR burnc$27665[rsp]
  001c9	83 e8 01	 sub	 eax, 1
  001cc	89 84 24 60 01
	00 00		 mov	 DWORD PTR burnc$27665[rsp], eax
  001d3	85 c9		 test	 ecx, ecx
  001d5	74 21		 je	 SHORT $LN6@derive_u_s
  001d7	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR burnm$27663[rsp]
  001df	c6 00 00	 mov	 BYTE PTR [rax], 0
  001e2	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR burnm$27663[rsp]
  001ea	48 83 c0 01	 add	 rax, 1
  001ee	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR burnm$27663[rsp], rax
  001f6	eb c3		 jmp	 SHORT $LN7@derive_u_s
$LN6@derive_u_s:
  001f8	33 c0		 xor	 eax, eax
  001fa	85 c0		 test	 eax, eax
  001fc	75 90		 jne	 SHORT $LN10@derive_u_s
$LN5@derive_u_s:

; 479  : 	burn (k, sizeof(k));

  001fe	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  00206	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR burnm$27672[rsp], rax
  0020e	c7 84 24 70 01
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27674[rsp], 64 ; 00000040H
  00219	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0021e	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00226	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_u_s:
  0022b	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR burnc$27674[rsp]
  00232	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR burnc$27674[rsp]
  00239	83 e8 01	 sub	 eax, 1
  0023c	89 84 24 70 01
	00 00		 mov	 DWORD PTR burnc$27674[rsp], eax
  00243	85 c9		 test	 ecx, ecx
  00245	74 21		 je	 SHORT $LN1@derive_u_s
  00247	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR burnm$27672[rsp]
  0024f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00252	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR burnm$27672[rsp]
  0025a	48 83 c0 01	 add	 rax, 1
  0025e	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR burnm$27672[rsp], rax
  00266	eb c3		 jmp	 SHORT $LN2@derive_u_s
$LN1@derive_u_s:
  00268	33 c0		 xor	 eax, eax
  0026a	85 c0		 test	 eax, eax
  0026c	75 90		 jne	 SHORT $LN5@derive_u_s

; 480  : }

  0026e	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00276	48 33 cc	 xor	 rcx, rsp
  00279	e8 00 00 00 00	 call	 __security_check_cookie
  0027e	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00285	5f		 pop	 rdi
  00286	5e		 pop	 rsi
  00287	c3		 ret	 0
derive_u_stribog ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_gosthash
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_key_gosthash DD imagerel $LN13
	DD	imagerel $LN13+467
	DD	imagerel $unwind$derive_key_gosthash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_gosthash DD 042e19H
	DD	013011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	080H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_key_gosthash
_TEXT	SEGMENT
u$ = 72
b$ = 104
l$ = 108
r$ = 112
burnc$27534 = 116
burnm$27532 = 120
__$ArrayPad$ = 128
pwd$ = 176
pwd_len$ = 184
salt$ = 192
salt_len$ = 200
iterations$ = 208
dk$ = 216
dklen$ = 224
derive_key_gosthash PROC				; COMDAT

; 337  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 338  : 	char u[GOSTHASH_DIGESTSIZE];
; 339  : 	int b, l, r;
; 340  : 
; 341  : 	if (dklen % GOSTHASH_DIGESTSIZE)

  0002e	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00035	99		 cdq
  00036	83 e2 1f	 and	 edx, 31
  00039	03 c2		 add	 eax, edx
  0003b	83 e0 1f	 and	 eax, 31
  0003e	2b c2		 sub	 eax, edx
  00040	85 c0		 test	 eax, eax
  00042	74 19		 je	 SHORT $LN10@derive_key@2

; 342  : 	{
; 343  : 		l = 1 + dklen / GOSTHASH_DIGESTSIZE;

  00044	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0004b	99		 cdq
  0004c	83 e2 1f	 and	 edx, 31
  0004f	03 c2		 add	 eax, edx
  00051	c1 f8 05	 sar	 eax, 5
  00054	83 c0 01	 add	 eax, 1
  00057	89 44 24 6c	 mov	 DWORD PTR l$[rsp], eax

; 344  : 	}
; 345  : 	else

  0005b	eb 14		 jmp	 SHORT $LN9@derive_key@2
$LN10@derive_key@2:

; 346  : 	{
; 347  : 		l = dklen / GOSTHASH_DIGESTSIZE;

  0005d	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00064	99		 cdq
  00065	83 e2 1f	 and	 edx, 31
  00068	03 c2		 add	 eax, edx
  0006a	c1 f8 05	 sar	 eax, 5
  0006d	89 44 24 6c	 mov	 DWORD PTR l$[rsp], eax
$LN9@derive_key@2:

; 348  : 	}
; 349  : 
; 350  : 	r = dklen - (l - 1) * GOSTHASH_DIGESTSIZE;

  00071	8b 4c 24 6c	 mov	 ecx, DWORD PTR l$[rsp]
  00075	83 e9 01	 sub	 ecx, 1
  00078	6b c9 20	 imul	 ecx, 32			; 00000020H
  0007b	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00082	2b c1		 sub	 eax, ecx
  00084	89 44 24 70	 mov	 DWORD PTR r$[rsp], eax

; 351  : 
; 352  : 	/* first l - 1 blocks */
; 353  : 	for (b = 1; b < l; b++)

  00088	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR b$[rsp], 1
  00090	eb 0b		 jmp	 SHORT $LN8@derive_key@2
$LN7@derive_key@2:
  00092	8b 44 24 68	 mov	 eax, DWORD PTR b$[rsp]
  00096	83 c0 01	 add	 eax, 1
  00099	89 44 24 68	 mov	 DWORD PTR b$[rsp], eax
$LN8@derive_key@2:
  0009d	8b 44 24 6c	 mov	 eax, DWORD PTR l$[rsp]
  000a1	39 44 24 68	 cmp	 DWORD PTR b$[rsp], eax
  000a5	7d 6b		 jge	 SHORT $LN6@derive_key@2

; 354  : 	{
; 355  : 		derive_u_gosthash (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000a7	8b 44 24 68	 mov	 eax, DWORD PTR b$[rsp]
  000ab	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000af	48 8d 44 24 48	 lea	 rax, QWORD PTR u$[rsp]
  000b4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b9	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000c0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c4	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  000cc	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  000d4	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000db	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  000e3	e8 00 00 00 00	 call	 derive_u_gosthash

; 356  : 		memcpy (dk, u, GOSTHASH_DIGESTSIZE);

  000e8	48 8d 74 24 48	 lea	 rsi, QWORD PTR u$[rsp]
  000ed	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  000f5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000fa	f3 a4		 rep movsb

; 357  : 		dk += GOSTHASH_DIGESTSIZE;

  000fc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dk$[rsp]
  00104	48 83 c0 20	 add	 rax, 32			; 00000020H
  00108	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR dk$[rsp], rax

; 358  : 	}

  00110	eb 80		 jmp	 SHORT $LN7@derive_key@2
$LN6@derive_key@2:

; 359  : 
; 360  : 	/* last block */
; 361  : 	derive_u_gosthash (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00112	8b 44 24 68	 mov	 eax, DWORD PTR b$[rsp]
  00116	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0011a	48 8d 44 24 48	 lea	 rax, QWORD PTR u$[rsp]
  0011f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00124	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  0012b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0012f	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  00137	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  0013f	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  00146	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  0014e	e8 00 00 00 00	 call	 derive_u_gosthash

; 362  : 	memcpy (dk, u, r);

  00153	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR r$[rsp]
  00158	48 8d 74 24 48	 lea	 rsi, QWORD PTR u$[rsp]
  0015d	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  00165	f3 a4		 rep movsb
$LN5@derive_key@2:

; 363  : 
; 364  : 
; 365  : 	/* Prevent possible leaks. */
; 366  : 	burn (u, sizeof(u));

  00167	48 8d 44 24 48	 lea	 rax, QWORD PTR u$[rsp]
  0016c	48 89 44 24 78	 mov	 QWORD PTR burnm$27532[rsp], rax
  00171	c7 44 24 74 20
	00 00 00	 mov	 DWORD PTR burnc$27534[rsp], 32 ; 00000020H
  00179	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0017e	48 8d 4c 24 48	 lea	 rcx, QWORD PTR u$[rsp]
  00183	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_key@2:
  00188	8b 4c 24 74	 mov	 ecx, DWORD PTR burnc$27534[rsp]
  0018c	8b 44 24 74	 mov	 eax, DWORD PTR burnc$27534[rsp]
  00190	83 e8 01	 sub	 eax, 1
  00193	89 44 24 74	 mov	 DWORD PTR burnc$27534[rsp], eax
  00197	85 c9		 test	 ecx, ecx
  00199	74 18		 je	 SHORT $LN1@derive_key@2
  0019b	48 8b 44 24 78	 mov	 rax, QWORD PTR burnm$27532[rsp]
  001a0	c6 00 00	 mov	 BYTE PTR [rax], 0
  001a3	48 8b 44 24 78	 mov	 rax, QWORD PTR burnm$27532[rsp]
  001a8	48 83 c0 01	 add	 rax, 1
  001ac	48 89 44 24 78	 mov	 QWORD PTR burnm$27532[rsp], rax
  001b1	eb d5		 jmp	 SHORT $LN2@derive_key@2
$LN1@derive_key@2:
  001b3	33 c0		 xor	 eax, eax
  001b5	85 c0		 test	 eax, eax
  001b7	75 ae		 jne	 SHORT $LN5@derive_key@2

; 367  : }

  001b9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c1	48 33 cc	 xor	 rcx, rsp
  001c4	e8 00 00 00 00	 call	 __security_check_cookie
  001c9	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001d0	5f		 pop	 rdi
  001d1	5e		 pop	 rsi
  001d2	c3		 ret	 0
derive_key_gosthash ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_stribog
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_key_stribog DD imagerel $LN13
	DD	imagerel $LN13+530
	DD	imagerel $unwind$derive_key_stribog
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_stribog DD 042e19H
	DD	017011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_key_stribog
_TEXT	SEGMENT
u$ = 80
b$ = 144
l$ = 148
r$ = 152
burnc$27707 = 156
burnm$27705 = 160
__$ArrayPad$ = 168
pwd$ = 208
pwd_len$ = 216
salt$ = 224
salt_len$ = 232
iterations$ = 240
dk$ = 248
dklen$ = 256
derive_key_stribog PROC					; COMDAT

; 497  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 498  : 	char u[STRIBOG_DIGESTSIZE];
; 499  : 	int b, l, r;
; 500  : 
; 501  : 	if (dklen % STRIBOG_DIGESTSIZE)

  0002e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00035	99		 cdq
  00036	83 e2 3f	 and	 edx, 63			; 0000003fH
  00039	03 c2		 add	 eax, edx
  0003b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0003e	2b c2		 sub	 eax, edx
  00040	85 c0		 test	 eax, eax
  00042	74 1c		 je	 SHORT $LN10@derive_key@3

; 502  : 	{
; 503  : 		l = 1 + dklen / STRIBOG_DIGESTSIZE;

  00044	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0004b	99		 cdq
  0004c	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004f	03 c2		 add	 eax, edx
  00051	c1 f8 06	 sar	 eax, 6
  00054	83 c0 01	 add	 eax, 1
  00057	89 84 24 94 00
	00 00		 mov	 DWORD PTR l$[rsp], eax

; 504  : 	}
; 505  : 	else

  0005e	eb 17		 jmp	 SHORT $LN9@derive_key@3
$LN10@derive_key@3:

; 506  : 	{
; 507  : 		l = dklen / STRIBOG_DIGESTSIZE;

  00060	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00067	99		 cdq
  00068	83 e2 3f	 and	 edx, 63			; 0000003fH
  0006b	03 c2		 add	 eax, edx
  0006d	c1 f8 06	 sar	 eax, 6
  00070	89 84 24 94 00
	00 00		 mov	 DWORD PTR l$[rsp], eax
$LN9@derive_key@3:

; 508  : 	}
; 509  : 
; 510  : 	r = dklen - (l - 1) * STRIBOG_DIGESTSIZE;

  00077	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR l$[rsp]
  0007e	83 e9 01	 sub	 ecx, 1
  00081	6b c9 40	 imul	 ecx, 64			; 00000040H
  00084	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0008b	2b c1		 sub	 eax, ecx
  0008d	89 84 24 98 00
	00 00		 mov	 DWORD PTR r$[rsp], eax

; 511  : 
; 512  : 	/* first l - 1 blocks */
; 513  : 	for (b = 1; b < l; b++)

  00094	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR b$[rsp], 1
  0009f	eb 11		 jmp	 SHORT $LN8@derive_key@3
$LN7@derive_key@3:
  000a1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 84 24 90 00
	00 00		 mov	 DWORD PTR b$[rsp], eax
$LN8@derive_key@3:
  000b2	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR l$[rsp]
  000b9	39 84 24 90 00
	00 00		 cmp	 DWORD PTR b$[rsp], eax
  000c0	7d 71		 jge	 SHORT $LN6@derive_key@3

; 514  : 	{
; 515  : 		derive_u_stribog (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  000c9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000cd	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000d2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d7	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000de	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e2	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  000ea	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  000f2	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000f9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  00101	e8 00 00 00 00	 call	 derive_u_stribog

; 516  : 		memcpy (dk, u, STRIBOG_DIGESTSIZE);

  00106	48 8d 74 24 50	 lea	 rsi, QWORD PTR u$[rsp]
  0010b	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  00113	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00118	f3 a4		 rep movsb

; 517  : 		dk += STRIBOG_DIGESTSIZE;

  0011a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dk$[rsp]
  00122	48 83 c0 40	 add	 rax, 64			; 00000040H
  00126	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR dk$[rsp], rax

; 518  : 	}

  0012e	e9 6e ff ff ff	 jmp	 $LN7@derive_key@3
$LN6@derive_key@3:

; 519  : 
; 520  : 	/* last block */
; 521  : 	derive_u_stribog (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00133	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  0013a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0013e	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00143	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00148	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  0014f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00153	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  0015b	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  00163	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  0016a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  00172	e8 00 00 00 00	 call	 derive_u_stribog

; 522  : 	memcpy (dk, u, r);

  00177	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR r$[rsp]
  0017f	48 8d 74 24 50	 lea	 rsi, QWORD PTR u$[rsp]
  00184	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  0018c	f3 a4		 rep movsb
$LN5@derive_key@3:

; 523  : 
; 524  : 
; 525  : 	/* Prevent possible leaks. */
; 526  : 	burn (u, sizeof(u));

  0018e	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00193	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR burnm$27705[rsp], rax
  0019b	c7 84 24 9c 00
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$27707[rsp], 64 ; 00000040H
  001a6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001ab	48 8d 4c 24 50	 lea	 rcx, QWORD PTR u$[rsp]
  001b0	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_key@3:
  001b5	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR burnc$27707[rsp]
  001bc	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR burnc$27707[rsp]
  001c3	83 e8 01	 sub	 eax, 1
  001c6	89 84 24 9c 00
	00 00		 mov	 DWORD PTR burnc$27707[rsp], eax
  001cd	85 c9		 test	 ecx, ecx
  001cf	74 21		 je	 SHORT $LN1@derive_key@3
  001d1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR burnm$27705[rsp]
  001d9	c6 00 00	 mov	 BYTE PTR [rax], 0
  001dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR burnm$27705[rsp]
  001e4	48 83 c0 01	 add	 rax, 1
  001e8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR burnm$27705[rsp], rax
  001f0	eb c3		 jmp	 SHORT $LN2@derive_key@3
$LN1@derive_key@3:
  001f2	33 c0		 xor	 eax, eax
  001f4	85 c0		 test	 eax, eax
  001f6	75 96		 jne	 SHORT $LN5@derive_key@3

; 527  : }

  001f8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00200	48 33 cc	 xor	 rcx, rsp
  00203	e8 00 00 00 00	 call	 __security_check_cookie
  00208	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0020f	5f		 pop	 rdi
  00210	5e		 pop	 rsi
  00211	c3		 ret	 0
derive_key_stribog ENDP
END
