; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_hmac_truncate@12
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _hmac_truncate@12
_TEXT	SEGMENT
_i$ = -4						; size = 4
_d1$ = 8						; size = 4
_d2$ = 12						; size = 4
_len$ = 16						; size = 4
_hmac_truncate@12 PROC					; COMDAT

; 38   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 39   : 	int i;
; 40   : 	for (i = 0; i < len; i++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN3@hmac_trunc
$LN2@hmac_trunc:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@hmac_trunc:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	3b 4d 10	 cmp	 ecx, DWORD PTR _len$[ebp]
  0001e	7d 12		 jge	 SHORT $LN4@hmac_trunc

; 41   : 		d2[i] = d1[i];

  00020	8b 55 0c	 mov	 edx, DWORD PTR _d2$[ebp]
  00023	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00026	8b 45 08	 mov	 eax, DWORD PTR _d1$[ebp]
  00029	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0002c	8a 08		 mov	 cl, BYTE PTR [eax]
  0002e	88 0a		 mov	 BYTE PTR [edx], cl
  00030	eb dd		 jmp	 SHORT $LN2@hmac_trunc
$LN4@hmac_trunc:

; 42   : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 0c 00	 ret	 12			; 0000000cH
_hmac_truncate@12 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_whirlpool@24
EXTRN	_WHIRLPOOL_finalize@8:PROC
EXTRN	_WHIRLPOOL_add@12:PROC
EXTRN	_WHIRLPOOL_init@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
;	COMDAT _hmac_whirlpool@24
_TEXT	SEGMENT
tv150 = -828						; size = 4
_burnm$25629 = -824					; size = 4
_burnc$25631 = -820					; size = 4
_burnm$25620 = -816					; size = 4
_burnc$25622 = -812					; size = 4
_burnm$25611 = -808					; size = 4
_burnc$25613 = -804					; size = 4
_burnm$25602 = -800					; size = 4
_burnc$25604 = -796					; size = 4
_burnm$25593 = -792					; size = 4
_burnc$25595 = -788					; size = 4
_burnm$25584 = -784					; size = 4
_burnc$25586 = -780					; size = 4
_burnm$25555 = -776					; size = 4
_burnc$25557 = -772					; size = 4
_tctx$25549 = -768					; size = 168
_octx$ = -600						; size = 168
_iwhi$ = -432						; size = 64
_ictx$ = -368						; size = 168
_buf$ = -200						; size = 64
_owhi$ = -136						; size = 64
_key$ = -72						; size = 64
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_whirlpool@24 PROC					; COMDAT

; 54   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 3c 03 00
	00		 sub	 esp, 828		; 0000033cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 55   : 	WHIRLPOOL_CTX ictx, octx;
; 56   : 	char iwhi[WHIRLPOOL_DIGESTSIZE], owhi[WHIRLPOOL_DIGESTSIZE];
; 57   : 	char key[WHIRLPOOL_DIGESTSIZE];
; 58   : 	char buf[WHIRLPOOL_BLOCKSIZE];
; 59   : 	int i;
; 60   : 
; 61   :     /* If the key is longer than the hash algorithm block size,
; 62   : 	   let key = whirlpool(key), as per HMAC specifications. */
; 63   : 	if (lk > WHIRLPOOL_BLOCKSIZE)

  00015	83 7d 0c 40	 cmp	 DWORD PTR _lk$[ebp], 64	; 00000040H
  00019	0f 8e 9e 00 00
	00		 jle	 $LN48@hmac_whirl

; 64   : 	{
; 65   : 		WHIRLPOOL_CTX tctx;
; 66   : 
; 67   : 		WHIRLPOOL_init (&tctx);

  0001f	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$25549[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4

; 68   : 		WHIRLPOOL_add ((unsigned char *) k, lk * 8, &tctx);

  0002b	8d 8d 00 fd ff
	ff		 lea	 ecx, DWORD PTR _tctx$25549[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  00035	c1 e2 03	 shl	 edx, 3
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 69   : 		WHIRLPOOL_finalize (&tctx, (unsigned char *) key);

  00042	8d 4d b8	 lea	 ecx, DWORD PTR _key$[ebp]
  00045	51		 push	 ecx
  00046	8d 95 00 fd ff
	ff		 lea	 edx, DWORD PTR _tctx$25549[ebp]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8

; 70   : 
; 71   : 		k = key;

  00052	8d 45 b8	 lea	 eax, DWORD PTR _key$[ebp]
  00055	89 45 08	 mov	 DWORD PTR _k$[ebp], eax

; 72   : 		lk = WHIRLPOOL_DIGESTSIZE;

  00058	c7 45 0c 40 00
	00 00		 mov	 DWORD PTR _lk$[ebp], 64	; 00000040H
$LN47@hmac_whirl:

; 73   : 
; 74   : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  0005f	8d 8d 00 fd ff
	ff		 lea	 ecx, DWORD PTR _tctx$25549[ebp]
  00065	89 8d f8 fc ff
	ff		 mov	 DWORD PTR _burnm$25555[ebp], ecx
  0006b	c7 85 fc fc ff
	ff a8 00 00 00	 mov	 DWORD PTR _burnc$25557[ebp], 168 ; 000000a8H
  00075	68 a8 00 00 00	 push	 168			; 000000a8H
  0007a	8d 95 00 fd ff
	ff		 lea	 edx, DWORD PTR _tctx$25549[ebp]
  00080	52		 push	 edx
  00081	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN44@hmac_whirl:
  00086	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _burnc$25557[ebp]
  0008c	8b 8d fc fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$25557[ebp]
  00092	83 e9 01	 sub	 ecx, 1
  00095	89 8d fc fc ff
	ff		 mov	 DWORD PTR _burnc$25557[ebp], ecx
  0009b	85 c0		 test	 eax, eax
  0009d	74 1a		 je	 SHORT $LN46@hmac_whirl
  0009f	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$25555[ebp]
  000a5	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a8	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$25555[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _burnm$25555[ebp], eax
  000b7	eb cd		 jmp	 SHORT $LN44@hmac_whirl
$LN46@hmac_whirl:
  000b9	33 c9		 xor	 ecx, ecx
  000bb	75 a2		 jne	 SHORT $LN47@hmac_whirl
$LN48@hmac_whirl:

; 75   : 	}
; 76   : 
; 77   : 	/**** Inner Digest ****/
; 78   : 
; 79   : 	WHIRLPOOL_init (&ictx);

  000bd	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4

; 80   : 
; 81   : 	/* Pad the key for inner digest */
; 82   : 	for (i = 0; i < lk; ++i)

  000c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN42@hmac_whirl
$LN41@hmac_whirl:
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN42@hmac_whirl:
  000db	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000de	3b 4d 0c	 cmp	 ecx, DWORD PTR _lk$[ebp]
  000e1	7d 18		 jge	 SHORT $LN40@hmac_whirl

; 83   : 		buf[i] = (char) (k[i] ^ 0x36);

  000e3	8b 55 08	 mov	 edx, DWORD PTR _k$[ebp]
  000e6	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000e9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000ec	83 f0 36	 xor	 eax, 54			; 00000036H
  000ef	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000f2	88 84 0d 38 ff
	ff ff		 mov	 BYTE PTR _buf$[ebp+ecx], al
  000f9	eb d7		 jmp	 SHORT $LN41@hmac_whirl
$LN40@hmac_whirl:

; 84   : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  000fb	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  000fe	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  00101	eb 09		 jmp	 SHORT $LN39@hmac_whirl
$LN38@hmac_whirl:
  00103	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00106	83 c0 01	 add	 eax, 1
  00109	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN39@hmac_whirl:
  0010c	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00110	7d 0d		 jge	 SHORT $LN37@hmac_whirl

; 85   : 		buf[i] = 0x36;

  00112	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00115	c6 84 0d 38 ff
	ff ff 36	 mov	 BYTE PTR _buf$[ebp+ecx], 54 ; 00000036H
  0011d	eb e4		 jmp	 SHORT $LN38@hmac_whirl
$LN37@hmac_whirl:

; 86   : 
; 87   : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &ictx);

  0011f	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  00125	52		 push	 edx
  00126	68 00 02 00 00	 push	 512			; 00000200H
  0012b	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 88   : 	WHIRLPOOL_add ((unsigned char *) d, ld * 8, &ictx);

  00137	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _ictx$[ebp]
  0013d	51		 push	 ecx
  0013e	8b 55 14	 mov	 edx, DWORD PTR _ld$[ebp]
  00141	c1 e2 03	 shl	 edx, 3
  00144	52		 push	 edx
  00145	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 89   : 
; 90   : 	WHIRLPOOL_finalize (&ictx, (unsigned char *) iwhi);

  0014e	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR _iwhi$[ebp]
  00154	51		 push	 ecx
  00155	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  0015b	52		 push	 edx
  0015c	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8

; 91   : 
; 92   : 	/**** Outer Digest ****/
; 93   : 
; 94   : 	WHIRLPOOL_init (&octx);

  00161	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4

; 95   : 
; 96   : 	for (i = 0; i < lk; ++i)

  0016d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00174	eb 09		 jmp	 SHORT $LN36@hmac_whirl
$LN35@hmac_whirl:
  00176	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00179	83 c1 01	 add	 ecx, 1
  0017c	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN36@hmac_whirl:
  0017f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00182	3b 55 0c	 cmp	 edx, DWORD PTR _lk$[ebp]
  00185	7d 18		 jge	 SHORT $LN34@hmac_whirl

; 97   : 		buf[i] = (char) (k[i] ^ 0x5C);

  00187	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  0018a	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0018d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00190	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  00193	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00196	88 8c 15 38 ff
	ff ff		 mov	 BYTE PTR _buf$[ebp+edx], cl
  0019d	eb d7		 jmp	 SHORT $LN35@hmac_whirl
$LN34@hmac_whirl:

; 98   : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  0019f	8b 45 0c	 mov	 eax, DWORD PTR _lk$[ebp]
  001a2	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  001a5	eb 09		 jmp	 SHORT $LN33@hmac_whirl
$LN32@hmac_whirl:
  001a7	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001aa	83 c1 01	 add	 ecx, 1
  001ad	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN33@hmac_whirl:
  001b0	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  001b4	7d 0d		 jge	 SHORT $LN31@hmac_whirl

; 99   : 		buf[i] = 0x5C;

  001b6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001b9	c6 84 15 38 ff
	ff ff 5c	 mov	 BYTE PTR _buf$[ebp+edx], 92 ; 0000005cH
  001c1	eb e4		 jmp	 SHORT $LN32@hmac_whirl
$LN31@hmac_whirl:

; 100  : 
; 101  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  001c3	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  001c9	50		 push	 eax
  001ca	68 00 02 00 00	 push	 512			; 00000200H
  001cf	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  001d5	51		 push	 ecx
  001d6	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 102  : 	WHIRLPOOL_add ((unsigned char *) iwhi, WHIRLPOOL_DIGESTSIZE * 8, &octx);

  001db	8d 95 a8 fd ff
	ff		 lea	 edx, DWORD PTR _octx$[ebp]
  001e1	52		 push	 edx
  001e2	68 00 02 00 00	 push	 512			; 00000200H
  001e7	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 103  : 
; 104  : 	WHIRLPOOL_finalize (&octx, (unsigned char *) owhi);

  001f3	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _owhi$[ebp]
  001f9	51		 push	 ecx
  001fa	8d 95 a8 fd ff
	ff		 lea	 edx, DWORD PTR _octx$[ebp]
  00200	52		 push	 edx
  00201	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8

; 105  : 
; 106  : 	/* truncate and print the results */
; 107  : 	t = t > WHIRLPOOL_DIGESTSIZE ? WHIRLPOOL_DIGESTSIZE : t;

  00206	83 7d 1c 40	 cmp	 DWORD PTR _t$[ebp], 64	; 00000040H
  0020a	7e 0c		 jle	 SHORT $LN51@hmac_whirl
  0020c	c7 85 c4 fc ff
	ff 40 00 00 00	 mov	 DWORD PTR tv150[ebp], 64 ; 00000040H
  00216	eb 09		 jmp	 SHORT $LN52@hmac_whirl
$LN51@hmac_whirl:
  00218	8b 45 1c	 mov	 eax, DWORD PTR _t$[ebp]
  0021b	89 85 c4 fc ff
	ff		 mov	 DWORD PTR tv150[ebp], eax
$LN52@hmac_whirl:
  00221	8b 8d c4 fc ff
	ff		 mov	 ecx, DWORD PTR tv150[ebp]
  00227	89 4d 1c	 mov	 DWORD PTR _t$[ebp], ecx

; 108  : 	hmac_truncate (owhi, out, t);

  0022a	8b 55 1c	 mov	 edx, DWORD PTR _t$[ebp]
  0022d	52		 push	 edx
  0022e	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00231	50		 push	 eax
  00232	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _owhi$[ebp]
  00238	51		 push	 ecx
  00239	e8 00 00 00 00	 call	 _hmac_truncate@12
$LN30@hmac_whirl:

; 109  : 
; 110  : 	/* Prevent possible leaks. */
; 111  : 	burn (&ictx, sizeof(ictx));

  0023e	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  00244	89 95 f0 fc ff
	ff		 mov	 DWORD PTR _burnm$25584[ebp], edx
  0024a	c7 85 f4 fc ff
	ff a8 00 00 00	 mov	 DWORD PTR _burnc$25586[ebp], 168 ; 000000a8H
  00254	68 a8 00 00 00	 push	 168			; 000000a8H
  00259	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN27@hmac_whirl:
  00265	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$25586[ebp]
  0026b	8b 95 f4 fc ff
	ff		 mov	 edx, DWORD PTR _burnc$25586[ebp]
  00271	83 ea 01	 sub	 edx, 1
  00274	89 95 f4 fc ff
	ff		 mov	 DWORD PTR _burnc$25586[ebp], edx
  0027a	85 c9		 test	 ecx, ecx
  0027c	74 1a		 je	 SHORT $LN29@hmac_whirl
  0027e	8b 85 f0 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$25584[ebp]
  00284	c6 00 00	 mov	 BYTE PTR [eax], 0
  00287	8b 8d f0 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$25584[ebp]
  0028d	83 c1 01	 add	 ecx, 1
  00290	89 8d f0 fc ff
	ff		 mov	 DWORD PTR _burnm$25584[ebp], ecx
  00296	eb cd		 jmp	 SHORT $LN27@hmac_whirl
$LN29@hmac_whirl:
  00298	33 d2		 xor	 edx, edx
  0029a	75 a2		 jne	 SHORT $LN30@hmac_whirl
$LN25@hmac_whirl:

; 112  : 	burn (&octx, sizeof(octx));

  0029c	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  002a2	89 85 e8 fc ff
	ff		 mov	 DWORD PTR _burnm$25593[ebp], eax
  002a8	c7 85 ec fc ff
	ff a8 00 00 00	 mov	 DWORD PTR _burnc$25595[ebp], 168 ; 000000a8H
  002b2	68 a8 00 00 00	 push	 168			; 000000a8H
  002b7	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR _octx$[ebp]
  002bd	51		 push	 ecx
  002be	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN22@hmac_whirl:
  002c3	8b 95 ec fc ff
	ff		 mov	 edx, DWORD PTR _burnc$25595[ebp]
  002c9	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _burnc$25595[ebp]
  002cf	83 e8 01	 sub	 eax, 1
  002d2	89 85 ec fc ff
	ff		 mov	 DWORD PTR _burnc$25595[ebp], eax
  002d8	85 d2		 test	 edx, edx
  002da	74 1a		 je	 SHORT $LN24@hmac_whirl
  002dc	8b 8d e8 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$25593[ebp]
  002e2	c6 01 00	 mov	 BYTE PTR [ecx], 0
  002e5	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$25593[ebp]
  002eb	83 c2 01	 add	 edx, 1
  002ee	89 95 e8 fc ff
	ff		 mov	 DWORD PTR _burnm$25593[ebp], edx
  002f4	eb cd		 jmp	 SHORT $LN22@hmac_whirl
$LN24@hmac_whirl:
  002f6	33 c0		 xor	 eax, eax
  002f8	75 a2		 jne	 SHORT $LN25@hmac_whirl
$LN20@hmac_whirl:

; 113  : 	burn (owhi, sizeof(owhi));

  002fa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _owhi$[ebp]
  00300	89 8d e0 fc ff
	ff		 mov	 DWORD PTR _burnm$25602[ebp], ecx
  00306	c7 85 e4 fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25604[ebp], 64 ; 00000040H
  00310	6a 40		 push	 64			; 00000040H
  00312	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _owhi$[ebp]
  00318	52		 push	 edx
  00319	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN17@hmac_whirl:
  0031e	8b 85 e4 fc ff
	ff		 mov	 eax, DWORD PTR _burnc$25604[ebp]
  00324	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$25604[ebp]
  0032a	83 e9 01	 sub	 ecx, 1
  0032d	89 8d e4 fc ff
	ff		 mov	 DWORD PTR _burnc$25604[ebp], ecx
  00333	85 c0		 test	 eax, eax
  00335	74 1a		 je	 SHORT $LN19@hmac_whirl
  00337	8b 95 e0 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$25602[ebp]
  0033d	c6 02 00	 mov	 BYTE PTR [edx], 0
  00340	8b 85 e0 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$25602[ebp]
  00346	83 c0 01	 add	 eax, 1
  00349	89 85 e0 fc ff
	ff		 mov	 DWORD PTR _burnm$25602[ebp], eax
  0034f	eb cd		 jmp	 SHORT $LN17@hmac_whirl
$LN19@hmac_whirl:
  00351	33 c9		 xor	 ecx, ecx
  00353	75 a5		 jne	 SHORT $LN20@hmac_whirl
$LN15@hmac_whirl:

; 114  : 	burn (iwhi, sizeof(iwhi));

  00355	8d 95 50 fe ff
	ff		 lea	 edx, DWORD PTR _iwhi$[ebp]
  0035b	89 95 d8 fc ff
	ff		 mov	 DWORD PTR _burnm$25611[ebp], edx
  00361	c7 85 dc fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25613[ebp], 64 ; 00000040H
  0036b	6a 40		 push	 64			; 00000040H
  0036d	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  00373	50		 push	 eax
  00374	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN12@hmac_whirl:
  00379	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$25613[ebp]
  0037f	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _burnc$25613[ebp]
  00385	83 ea 01	 sub	 edx, 1
  00388	89 95 dc fc ff
	ff		 mov	 DWORD PTR _burnc$25613[ebp], edx
  0038e	85 c9		 test	 ecx, ecx
  00390	74 1a		 je	 SHORT $LN14@hmac_whirl
  00392	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$25611[ebp]
  00398	c6 00 00	 mov	 BYTE PTR [eax], 0
  0039b	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$25611[ebp]
  003a1	83 c1 01	 add	 ecx, 1
  003a4	89 8d d8 fc ff
	ff		 mov	 DWORD PTR _burnm$25611[ebp], ecx
  003aa	eb cd		 jmp	 SHORT $LN12@hmac_whirl
$LN14@hmac_whirl:
  003ac	33 d2		 xor	 edx, edx
  003ae	75 a5		 jne	 SHORT $LN15@hmac_whirl
$LN10@hmac_whirl:

; 115  : 	burn (buf, sizeof(buf));

  003b0	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  003b6	89 85 d0 fc ff
	ff		 mov	 DWORD PTR _burnm$25620[ebp], eax
  003bc	c7 85 d4 fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25622[ebp], 64 ; 00000040H
  003c6	6a 40		 push	 64			; 00000040H
  003c8	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  003ce	51		 push	 ecx
  003cf	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@hmac_whirl:
  003d4	8b 95 d4 fc ff
	ff		 mov	 edx, DWORD PTR _burnc$25622[ebp]
  003da	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _burnc$25622[ebp]
  003e0	83 e8 01	 sub	 eax, 1
  003e3	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _burnc$25622[ebp], eax
  003e9	85 d2		 test	 edx, edx
  003eb	74 1a		 je	 SHORT $LN9@hmac_whirl
  003ed	8b 8d d0 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$25620[ebp]
  003f3	c6 01 00	 mov	 BYTE PTR [ecx], 0
  003f6	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$25620[ebp]
  003fc	83 c2 01	 add	 edx, 1
  003ff	89 95 d0 fc ff
	ff		 mov	 DWORD PTR _burnm$25620[ebp], edx
  00405	eb cd		 jmp	 SHORT $LN7@hmac_whirl
$LN9@hmac_whirl:
  00407	33 c0		 xor	 eax, eax
  00409	75 a5		 jne	 SHORT $LN10@hmac_whirl
$LN5@hmac_whirl:

; 116  : 	burn (key, sizeof(key));

  0040b	8d 4d b8	 lea	 ecx, DWORD PTR _key$[ebp]
  0040e	89 8d c8 fc ff
	ff		 mov	 DWORD PTR _burnm$25629[ebp], ecx
  00414	c7 85 cc fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25631[ebp], 64 ; 00000040H
  0041e	6a 40		 push	 64			; 00000040H
  00420	8d 55 b8	 lea	 edx, DWORD PTR _key$[ebp]
  00423	52		 push	 edx
  00424	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@hmac_whirl:
  00429	8b 85 cc fc ff
	ff		 mov	 eax, DWORD PTR _burnc$25631[ebp]
  0042f	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$25631[ebp]
  00435	83 e9 01	 sub	 ecx, 1
  00438	89 8d cc fc ff
	ff		 mov	 DWORD PTR _burnc$25631[ebp], ecx
  0043e	85 c0		 test	 eax, eax
  00440	74 1a		 je	 SHORT $LN4@hmac_whirl
  00442	8b 95 c8 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$25629[ebp]
  00448	c6 02 00	 mov	 BYTE PTR [edx], 0
  0044b	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$25629[ebp]
  00451	83 c0 01	 add	 eax, 1
  00454	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _burnm$25629[ebp], eax
  0045a	eb cd		 jmp	 SHORT $LN2@hmac_whirl
$LN4@hmac_whirl:
  0045c	33 c9		 xor	 ecx, ecx
  0045e	75 ab		 jne	 SHORT $LN5@hmac_whirl

; 117  : }

  00460	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00463	33 cd		 xor	 ecx, ebp
  00465	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0046a	8b e5		 mov	 esp, ebp
  0046c	5d		 pop	 ebp
  0046d	c2 18 00	 ret	 24			; 00000018H
_hmac_whirlpool@24 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_whirlpool@28
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _derive_u_whirlpool@28
_TEXT	SEGMENT
_burnm$25675 = -296					; size = 4
_burnc$25677 = -292					; size = 4
_burnm$25666 = -288					; size = 4
_burnc$25668 = -284					; size = 4
_j$ = -280						; size = 64
_c$ = -212						; size = 4
_k$ = -208						; size = 64
_counter$ = -140					; size = 4
_init$ = -136						; size = 128
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_whirlpool@28 PROC				; COMDAT

; 134  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 135  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 136  : 	char init[128];
; 137  : 	char counter[4];
; 138  : 	int c, i;
; 139  : 
; 140  : 	/* iteration 1 */
; 141  : 	memset (counter, 0, 4);

  00017	33 c0		 xor	 eax, eax
  00019	89 85 74 ff ff
	ff		 mov	 DWORD PTR _counter$[ebp], eax

; 142  : 	counter[3] = (char) b;

  0001f	8a 4d 20	 mov	 cl, BYTE PTR _b$[ebp]
  00022	88 8d 77 ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], cl

; 143  : 	memcpy (init, salt, salt_len);	/* salt */

  00028	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0002f	50		 push	 eax
  00030	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _init$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  0003f	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00042	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00048	89 84 15 78 ff
	ff ff		 mov	 DWORD PTR _init$[ebp+edx], eax

; 145  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);

  0004f	6a 40		 push	 64			; 00000040H
  00051	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  0005b	83 c2 04	 add	 edx, 4
  0005e	52		 push	 edx
  0005f	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00065	50		 push	 eax
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _hmac_whirlpool@24

; 146  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);

  00073	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00078	8d b5 e8 fe ff
	ff		 lea	 esi, DWORD PTR _j$[ebp]
  0007e	8b 7d 1c	 mov	 edi, DWORD PTR _u$[ebp]
  00081	f3 a5		 rep movsd

; 147  : 
; 148  : 	/* remaining iterations */
; 149  : 	for (c = 1; c < iterations; c++)

  00083	c7 85 2c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _c$[ebp], 1
  0008d	eb 0f		 jmp	 SHORT $LN16@derive_u_w
$LN15@derive_u_w:
  0008f	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _c$[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 85 2c ff ff
	ff		 mov	 DWORD PTR _c$[ebp], eax
$LN16@derive_u_w:
  0009e	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _c$[ebp]
  000a4	3b 4d 18	 cmp	 ecx, DWORD PTR _iterations$[ebp]
  000a7	7d 70		 jge	 SHORT $LN10@derive_u_w

; 150  : 	{
; 151  : 		hmac_whirlpool (pwd, pwd_len, j, WHIRLPOOL_DIGESTSIZE, k, WHIRLPOOL_DIGESTSIZE);

  000a9	6a 40		 push	 64			; 00000040H
  000ab	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  000b1	52		 push	 edx
  000b2	6a 40		 push	 64			; 00000040H
  000b4	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  000be	51		 push	 ecx
  000bf	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 _hmac_whirlpool@24

; 152  : 		for (i = 0; i < WHIRLPOOL_DIGESTSIZE; i++)

  000c8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000cf	eb 09		 jmp	 SHORT $LN13@derive_u_w
$LN12@derive_u_w:
  000d1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d4	83 c0 01	 add	 eax, 1
  000d7	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@derive_u_w:
  000da	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  000de	7d 34		 jge	 SHORT $LN11@derive_u_w

; 153  : 		{
; 154  : 			u[i] ^= k[i];

  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e3	0f be 94 0d 30
	ff ff ff	 movsx	 edx, BYTE PTR _k$[ebp+ecx]
  000eb	8b 45 1c	 mov	 eax, DWORD PTR _u$[ebp]
  000ee	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000f1	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f4	33 ca		 xor	 ecx, edx
  000f6	8b 55 1c	 mov	 edx, DWORD PTR _u$[ebp]
  000f9	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000fc	88 0a		 mov	 BYTE PTR [edx], cl

; 155  : 			j[i] = k[i];

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00101	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00104	8a 94 0d 30 ff
	ff ff		 mov	 dl, BYTE PTR _k$[ebp+ecx]
  0010b	88 94 05 e8 fe
	ff ff		 mov	 BYTE PTR _j$[ebp+eax], dl

; 156  : 		}

  00112	eb bd		 jmp	 SHORT $LN12@derive_u_w
$LN11@derive_u_w:

; 157  : 	}

  00114	e9 76 ff ff ff	 jmp	 $LN15@derive_u_w
$LN10@derive_u_w:

; 158  : 
; 159  : 	/* Prevent possible leaks. */
; 160  : 	burn (j, sizeof(j));

  00119	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  0011f	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _burnm$25666[ebp], eax
  00125	c7 85 e4 fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25668[ebp], 64 ; 00000040H
  0012f	6a 40		 push	 64			; 00000040H
  00131	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@derive_u_w:
  0013d	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _burnc$25668[ebp]
  00143	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _burnc$25668[ebp]
  00149	83 e8 01	 sub	 eax, 1
  0014c	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _burnc$25668[ebp], eax
  00152	85 d2		 test	 edx, edx
  00154	74 1a		 je	 SHORT $LN9@derive_u_w
  00156	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$25666[ebp]
  0015c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0015f	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$25666[ebp]
  00165	83 c2 01	 add	 edx, 1
  00168	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _burnm$25666[ebp], edx
  0016e	eb cd		 jmp	 SHORT $LN7@derive_u_w
$LN9@derive_u_w:
  00170	33 c0		 xor	 eax, eax
  00172	75 a5		 jne	 SHORT $LN10@derive_u_w
$LN5@derive_u_w:

; 161  : 	burn (k, sizeof(k));

  00174	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  0017a	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _burnm$25675[ebp], ecx
  00180	c7 85 dc fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25677[ebp], 64 ; 00000040H
  0018a	6a 40		 push	 64			; 00000040H
  0018c	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  00192	52		 push	 edx
  00193	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_u_w:
  00198	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _burnc$25677[ebp]
  0019e	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$25677[ebp]
  001a4	83 e9 01	 sub	 ecx, 1
  001a7	89 8d dc fe ff
	ff		 mov	 DWORD PTR _burnc$25677[ebp], ecx
  001ad	85 c0		 test	 eax, eax
  001af	74 1a		 je	 SHORT $LN4@derive_u_w
  001b1	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$25675[ebp]
  001b7	c6 02 00	 mov	 BYTE PTR [edx], 0
  001ba	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$25675[ebp]
  001c0	83 c0 01	 add	 eax, 1
  001c3	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _burnm$25675[ebp], eax
  001c9	eb cd		 jmp	 SHORT $LN2@derive_u_w
$LN4@derive_u_w:
  001cb	33 c9		 xor	 ecx, ecx
  001cd	75 a5		 jne	 SHORT $LN5@derive_u_w

; 162  : }

  001cf	5f		 pop	 edi
  001d0	5e		 pop	 esi
  001d1	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d4	33 cd		 xor	 ecx, ebp
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	8b e5		 mov	 esp, ebp
  001dd	5d		 pop	 ebp
  001de	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_whirlpool@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_whirlpool@28
; Function compile flags: /Odtp
;	COMDAT _derive_key_whirlpool@28
_TEXT	SEGMENT
_burnm$25708 = -92					; size = 4
_burnc$25710 = -88					; size = 4
_r$ = -84						; size = 4
_l$ = -80						; size = 4
_b$ = -76						; size = 4
_u$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_whirlpool@28 PROC				; COMDAT

; 179  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	57		 push	 edi

; 180  : 	char u[WHIRLPOOL_DIGESTSIZE];
; 181  : 	int b, l, r;
; 182  : 
; 183  : 	if (dklen % WHIRLPOOL_DIGESTSIZE)

  00014	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00017	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0001c	79 05		 jns	 SHORT $LN13@derive_key
  0001e	48		 dec	 eax
  0001f	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00022	40		 inc	 eax
$LN13@derive_key:
  00023	85 c0		 test	 eax, eax
  00025	74 14		 je	 SHORT $LN10@derive_key

; 184  : 	{
; 185  : 		l = 1 + dklen / WHIRLPOOL_DIGESTSIZE;

  00027	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0002a	99		 cdq
  0002b	83 e2 3f	 and	 edx, 63			; 0000003fH
  0002e	03 c2		 add	 eax, edx
  00030	c1 f8 06	 sar	 eax, 6
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 b0	 mov	 DWORD PTR _l$[ebp], eax

; 186  : 	}
; 187  : 	else

  00039	eb 0f		 jmp	 SHORT $LN9@derive_key
$LN10@derive_key:

; 188  : 	{
; 189  : 		l = dklen / WHIRLPOOL_DIGESTSIZE;

  0003b	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0003e	99		 cdq
  0003f	83 e2 3f	 and	 edx, 63			; 0000003fH
  00042	03 c2		 add	 eax, edx
  00044	c1 f8 06	 sar	 eax, 6
  00047	89 45 b0	 mov	 DWORD PTR _l$[ebp], eax
$LN9@derive_key:

; 190  : 	}
; 191  : 
; 192  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;

  0004a	8b 4d b0	 mov	 ecx, DWORD PTR _l$[ebp]
  0004d	83 e9 01	 sub	 ecx, 1
  00050	c1 e1 06	 shl	 ecx, 6
  00053	8b 55 20	 mov	 edx, DWORD PTR _dklen$[ebp]
  00056	2b d1		 sub	 edx, ecx
  00058	89 55 ac	 mov	 DWORD PTR _r$[ebp], edx

; 193  : 
; 194  : 	/* first l - 1 blocks */
; 195  : 	for (b = 1; b < l; b++)

  0005b	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _b$[ebp], 1
  00062	eb 09		 jmp	 SHORT $LN8@derive_key
$LN7@derive_key:
  00064	8b 45 b4	 mov	 eax, DWORD PTR _b$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 b4	 mov	 DWORD PTR _b$[ebp], eax
$LN8@derive_key:
  0006d	8b 4d b4	 mov	 ecx, DWORD PTR _b$[ebp]
  00070	3b 4d b0	 cmp	 ecx, DWORD PTR _l$[ebp]
  00073	7d 39		 jge	 SHORT $LN6@derive_key

; 196  : 	{
; 197  : 		derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00075	8b 55 b4	 mov	 edx, DWORD PTR _b$[ebp]
  00078	52		 push	 edx
  00079	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 18	 mov	 ecx, DWORD PTR _iterations$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00084	52		 push	 edx
  00085	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  00088	50		 push	 eax
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _derive_u_whirlpool@28

; 198  : 		memcpy (dk, u, WHIRLPOOL_DIGESTSIZE);

  00096	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0009b	8d 75 b8	 lea	 esi, DWORD PTR _u$[ebp]
  0009e	8b 7d 1c	 mov	 edi, DWORD PTR _dk$[ebp]
  000a1	f3 a5		 rep movsd

; 199  : 		dk += WHIRLPOOL_DIGESTSIZE;

  000a3	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  000a6	83 c0 40	 add	 eax, 64			; 00000040H
  000a9	89 45 1c	 mov	 DWORD PTR _dk$[ebp], eax

; 200  : 	}

  000ac	eb b6		 jmp	 SHORT $LN7@derive_key
$LN6@derive_key:

; 201  : 
; 202  : 	/* last block */
; 203  : 	derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000ae	8b 4d b4	 mov	 ecx, DWORD PTR _b$[ebp]
  000b1	51		 push	 ecx
  000b2	8d 55 b8	 lea	 edx, DWORD PTR _u$[ebp]
  000b5	52		 push	 edx
  000b6	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  000bd	51		 push	 ecx
  000be	8b 55 10	 mov	 edx, DWORD PTR _salt$[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _pwd_len$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _pwd$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _derive_u_whirlpool@28

; 204  : 	memcpy (dk, u, r);

  000cf	8b 55 ac	 mov	 edx, DWORD PTR _r$[ebp]
  000d2	52		 push	 edx
  000d3	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 1c	 mov	 ecx, DWORD PTR _dk$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _memcpy
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@derive_key:

; 205  : 
; 206  : 
; 207  : 	/* Prevent possible leaks. */
; 208  : 	burn (u, sizeof(u));

  000e3	8d 55 b8	 lea	 edx, DWORD PTR _u$[ebp]
  000e6	89 55 a4	 mov	 DWORD PTR _burnm$25708[ebp], edx
  000e9	c7 45 a8 40 00
	00 00		 mov	 DWORD PTR _burnc$25710[ebp], 64 ; 00000040H
  000f0	6a 40		 push	 64			; 00000040H
  000f2	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_key:
  000fb	8b 4d a8	 mov	 ecx, DWORD PTR _burnc$25710[ebp]
  000fe	8b 55 a8	 mov	 edx, DWORD PTR _burnc$25710[ebp]
  00101	83 ea 01	 sub	 edx, 1
  00104	89 55 a8	 mov	 DWORD PTR _burnc$25710[ebp], edx
  00107	85 c9		 test	 ecx, ecx
  00109	74 11		 je	 SHORT $LN4@derive_key
  0010b	8b 45 a4	 mov	 eax, DWORD PTR _burnm$25708[ebp]
  0010e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00111	8b 4d a4	 mov	 ecx, DWORD PTR _burnm$25708[ebp]
  00114	83 c1 01	 add	 ecx, 1
  00117	89 4d a4	 mov	 DWORD PTR _burnm$25708[ebp], ecx
  0011a	eb df		 jmp	 SHORT $LN2@derive_key
$LN4@derive_key:
  0011c	33 d2		 xor	 edx, edx
  0011e	75 c3		 jne	 SHORT $LN5@derive_key

; 209  : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00125	33 cd		 xor	 ecx, ebp
  00127	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_whirlpool@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_gosthash@20
EXTRN	_GOSTHASH_finalize@8:PROC
EXTRN	_GOSTHASH_add@12:PROC
EXTRN	_GOSTHASH_init@4:PROC
; Function compile flags: /Odtp
;	COMDAT _hmac_gosthash@20
_TEXT	SEGMENT
_burnm$25802 = -288					; size = 4
_burnc$25804 = -284					; size = 4
_burnm$25793 = -280					; size = 4
_burnc$25795 = -276					; size = 4
_burnm$25784 = -272					; size = 4
_burnc$25786 = -268					; size = 4
_burnm$25775 = -264					; size = 4
_burnc$25777 = -260					; size = 4
_burnm$25766 = -256					; size = 4
_burnc$25768 = -252					; size = 4
_burnm$25737 = -248					; size = 4
_burnc$25739 = -244					; size = 4
_outer$ = -240						; size = 32
_buf$ = -208						; size = 32
_inner$ = -176						; size = 32
_ctx$ = -144						; size = 104
_key$ = -40						; size = 32
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_hmac_gosthash@20 PROC					; COMDAT

; 219  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 220  : 	gost_hash_ctx ctx;
; 221  : 	char inner[GOSTHASH_DIGESTSIZE], outer[GOSTHASH_DIGESTSIZE];
; 222  : 	char key[GOSTHASH_DIGESTSIZE];
; 223  : 	char buf[GOSTHASH_BLOCKSIZE];
; 224  : 	int32 i;
; 225  : 
; 226  :     /* If the key is longer than the hash algorithm block size,
; 227  : 	   let key = gosthash(key), as per HMAC specifications. */
; 228  : 	if (lk > GOSTHASH_BLOCKSIZE)

  00015	83 7d 0c 20	 cmp	 DWORD PTR _lk$[ebp], 32	; 00000020H
  00019	0f 8e 98 00 00
	00		 jle	 $LN43@hmac_gosth

; 229  : 	{
; 230  : 		GOSTHASH_init (&ctx);

  0001f	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _GOSTHASH_init@4

; 231  : 		GOSTHASH_add ((unsigned char *)k, lk, &ctx);

  0002b	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _GOSTHASH_add@12

; 232  : 		GOSTHASH_finalize (&ctx, (unsigned char *) key);

  0003f	8d 4d d8	 lea	 ecx, DWORD PTR _key$[ebp]
  00042	51		 push	 ecx
  00043	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 _GOSTHASH_finalize@8

; 233  : 
; 234  : 		k = key;

  0004f	8d 45 d8	 lea	 eax, DWORD PTR _key$[ebp]
  00052	89 45 08	 mov	 DWORD PTR _k$[ebp], eax

; 235  : 		lk = GOSTHASH_DIGESTSIZE;

  00055	c7 45 0c 20 00
	00 00		 mov	 DWORD PTR _lk$[ebp], 32	; 00000020H
$LN42@hmac_gosth:

; 236  : 
; 237  : 		burn (&ctx, sizeof(ctx));		// Prevent leaks

  0005c	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  00062	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _burnm$25737[ebp], ecx
  00068	c7 85 0c ff ff
	ff 68 00 00 00	 mov	 DWORD PTR _burnc$25739[ebp], 104 ; 00000068H
  00072	6a 68		 push	 104			; 00000068H
  00074	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN39@hmac_gosth:
  00080	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _burnc$25739[ebp]
  00086	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _burnc$25739[ebp]
  0008c	83 e9 01	 sub	 ecx, 1
  0008f	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _burnc$25739[ebp], ecx
  00095	85 c0		 test	 eax, eax
  00097	74 1a		 je	 SHORT $LN41@hmac_gosth
  00099	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _burnm$25737[ebp]
  0009f	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a2	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _burnm$25737[ebp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 85 08 ff ff
	ff		 mov	 DWORD PTR _burnm$25737[ebp], eax
  000b1	eb cd		 jmp	 SHORT $LN39@hmac_gosth
$LN41@hmac_gosth:
  000b3	33 c9		 xor	 ecx, ecx
  000b5	75 a5		 jne	 SHORT $LN42@hmac_gosth
$LN43@hmac_gosth:

; 238  : 	}
; 239  : 
; 240  : 	/**** Inner Digest ****/
; 241  : 
; 242  : 	GOSTHASH_init (&ctx);

  000b7	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _GOSTHASH_init@4

; 243  : 
; 244  : 	/* Pad the key for inner digest */
; 245  : 	for (i = 0; i < lk; ++i)

  000c3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ca	eb 09		 jmp	 SHORT $LN37@hmac_gosth
$LN36@hmac_gosth:
  000cc	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN37@hmac_gosth:
  000d5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d8	3b 4d 0c	 cmp	 ecx, DWORD PTR _lk$[ebp]
  000db	7d 18		 jge	 SHORT $LN35@hmac_gosth

; 246  : 		buf[i] = (char) (k[i] ^ 0x36);

  000dd	8b 55 08	 mov	 edx, DWORD PTR _k$[ebp]
  000e0	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000e3	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000e6	83 f0 36	 xor	 eax, 54			; 00000036H
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000ec	88 84 0d 30 ff
	ff ff		 mov	 BYTE PTR _buf$[ebp+ecx], al
  000f3	eb d7		 jmp	 SHORT $LN36@hmac_gosth
$LN35@hmac_gosth:

; 247  : 	for (i = lk; i < GOSTHASH_BLOCKSIZE; ++i)

  000f5	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  000f8	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  000fb	eb 09		 jmp	 SHORT $LN34@hmac_gosth
$LN33@hmac_gosth:
  000fd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00100	83 c0 01	 add	 eax, 1
  00103	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN34@hmac_gosth:
  00106	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0010a	7d 0d		 jge	 SHORT $LN32@hmac_gosth

; 248  : 		buf[i] = 0x36;

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0010f	c6 84 0d 30 ff
	ff ff 36	 mov	 BYTE PTR _buf$[ebp+ecx], 54 ; 00000036H
  00117	eb e4		 jmp	 SHORT $LN33@hmac_gosth
$LN32@hmac_gosth:

; 249  : 
; 250  : 	GOSTHASH_add ((unsigned char *) buf, GOSTHASH_BLOCKSIZE, &ctx);

  00119	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  0011f	52		 push	 edx
  00120	6a 20		 push	 32			; 00000020H
  00122	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _GOSTHASH_add@12

; 251  : 	GOSTHASH_add ((unsigned char *) d, ld, &ctx);

  0012e	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  00134	51		 push	 ecx
  00135	8b 55 14	 mov	 edx, DWORD PTR _ld$[ebp]
  00138	52		 push	 edx
  00139	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _GOSTHASH_add@12

; 252  : 
; 253  : 	GOSTHASH_finalize (&ctx, (unsigned char *) inner);

  00142	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _inner$[ebp]
  00148	51		 push	 ecx
  00149	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  0014f	52		 push	 edx
  00150	e8 00 00 00 00	 call	 _GOSTHASH_finalize@8

; 254  : 
; 255  : 	/**** Outer Digest ****/
; 256  : 	
; 257  : 	GOSTHASH_init (&ctx);

  00155	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 _GOSTHASH_init@4

; 258  : 
; 259  : 	for (i = 0; i < lk; ++i)

  00161	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00168	eb 09		 jmp	 SHORT $LN31@hmac_gosth
$LN30@hmac_gosth:
  0016a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN31@hmac_gosth:
  00173	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00176	3b 55 0c	 cmp	 edx, DWORD PTR _lk$[ebp]
  00179	7d 18		 jge	 SHORT $LN29@hmac_gosth

; 260  : 		buf[i] = (char) (k[i] ^ 0x5C);

  0017b	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  0017e	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00181	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00184	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  00187	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0018a	88 8c 15 30 ff
	ff ff		 mov	 BYTE PTR _buf$[ebp+edx], cl
  00191	eb d7		 jmp	 SHORT $LN30@hmac_gosth
$LN29@hmac_gosth:

; 261  : 	for (i = lk; i < GOSTHASH_BLOCKSIZE; ++i)

  00193	8b 45 0c	 mov	 eax, DWORD PTR _lk$[ebp]
  00196	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00199	eb 09		 jmp	 SHORT $LN28@hmac_gosth
$LN27@hmac_gosth:
  0019b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0019e	83 c1 01	 add	 ecx, 1
  001a1	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN28@hmac_gosth:
  001a4	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  001a8	7d 0d		 jge	 SHORT $LN26@hmac_gosth

; 262  : 		buf[i] = 0x5C;

  001aa	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001ad	c6 84 15 30 ff
	ff ff 5c	 mov	 BYTE PTR _buf$[ebp+edx], 92 ; 0000005cH
  001b5	eb e4		 jmp	 SHORT $LN27@hmac_gosth
$LN26@hmac_gosth:

; 263  : 
; 264  : 	GOSTHASH_add ((unsigned char *) buf, GOSTHASH_BLOCKSIZE, &ctx);

  001b7	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  001bd	50		 push	 eax
  001be	6a 20		 push	 32			; 00000020H
  001c0	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  001c6	51		 push	 ecx
  001c7	e8 00 00 00 00	 call	 _GOSTHASH_add@12

; 265  : 	GOSTHASH_add ((unsigned char *) inner, GOSTHASH_DIGESTSIZE, &ctx);

  001cc	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  001d2	52		 push	 edx
  001d3	6a 20		 push	 32			; 00000020H
  001d5	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _inner$[ebp]
  001db	50		 push	 eax
  001dc	e8 00 00 00 00	 call	 _GOSTHASH_add@12

; 266  : 
; 267  : 	GOSTHASH_finalize (&ctx, (unsigned char *) out);

  001e1	8b 4d 18	 mov	 ecx, DWORD PTR _out$[ebp]
  001e4	51		 push	 ecx
  001e5	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  001eb	52		 push	 edx
  001ec	e8 00 00 00 00	 call	 _GOSTHASH_finalize@8
$LN25@hmac_gosth:

; 268  : 
; 269  : 	/* Prevent possible leaks. */
; 270  : 	burn (&ctx, sizeof(ctx));

  001f1	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  001f7	89 85 00 ff ff
	ff		 mov	 DWORD PTR _burnm$25766[ebp], eax
  001fd	c7 85 04 ff ff
	ff 68 00 00 00	 mov	 DWORD PTR _burnc$25768[ebp], 104 ; 00000068H
  00207	6a 68		 push	 104			; 00000068H
  00209	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN22@hmac_gosth:
  00215	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _burnc$25768[ebp]
  0021b	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _burnc$25768[ebp]
  00221	83 e8 01	 sub	 eax, 1
  00224	89 85 04 ff ff
	ff		 mov	 DWORD PTR _burnc$25768[ebp], eax
  0022a	85 d2		 test	 edx, edx
  0022c	74 1a		 je	 SHORT $LN24@hmac_gosth
  0022e	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _burnm$25766[ebp]
  00234	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00237	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _burnm$25766[ebp]
  0023d	83 c2 01	 add	 edx, 1
  00240	89 95 00 ff ff
	ff		 mov	 DWORD PTR _burnm$25766[ebp], edx
  00246	eb cd		 jmp	 SHORT $LN22@hmac_gosth
$LN24@hmac_gosth:
  00248	33 c0		 xor	 eax, eax
  0024a	75 a5		 jne	 SHORT $LN25@hmac_gosth
$LN20@hmac_gosth:

; 271  : 	burn (outer, sizeof(outer));

  0024c	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _outer$[ebp]
  00252	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _burnm$25775[ebp], ecx
  00258	c7 85 fc fe ff
	ff 20 00 00 00	 mov	 DWORD PTR _burnc$25777[ebp], 32 ; 00000020H
  00262	6a 20		 push	 32			; 00000020H
  00264	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _outer$[ebp]
  0026a	52		 push	 edx
  0026b	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN17@hmac_gosth:
  00270	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _burnc$25777[ebp]
  00276	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$25777[ebp]
  0027c	83 e9 01	 sub	 ecx, 1
  0027f	89 8d fc fe ff
	ff		 mov	 DWORD PTR _burnc$25777[ebp], ecx
  00285	85 c0		 test	 eax, eax
  00287	74 1a		 je	 SHORT $LN19@hmac_gosth
  00289	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$25775[ebp]
  0028f	c6 02 00	 mov	 BYTE PTR [edx], 0
  00292	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$25775[ebp]
  00298	83 c0 01	 add	 eax, 1
  0029b	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _burnm$25775[ebp], eax
  002a1	eb cd		 jmp	 SHORT $LN17@hmac_gosth
$LN19@hmac_gosth:
  002a3	33 c9		 xor	 ecx, ecx
  002a5	75 a5		 jne	 SHORT $LN20@hmac_gosth
$LN15@hmac_gosth:

; 272  : 	burn (inner, sizeof(inner));

  002a7	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR _inner$[ebp]
  002ad	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _burnm$25784[ebp], edx
  002b3	c7 85 f4 fe ff
	ff 20 00 00 00	 mov	 DWORD PTR _burnc$25786[ebp], 32 ; 00000020H
  002bd	6a 20		 push	 32			; 00000020H
  002bf	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _inner$[ebp]
  002c5	50		 push	 eax
  002c6	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN12@hmac_gosth:
  002cb	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$25786[ebp]
  002d1	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _burnc$25786[ebp]
  002d7	83 ea 01	 sub	 edx, 1
  002da	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _burnc$25786[ebp], edx
  002e0	85 c9		 test	 ecx, ecx
  002e2	74 1a		 je	 SHORT $LN14@hmac_gosth
  002e4	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$25784[ebp]
  002ea	c6 00 00	 mov	 BYTE PTR [eax], 0
  002ed	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$25784[ebp]
  002f3	83 c1 01	 add	 ecx, 1
  002f6	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _burnm$25784[ebp], ecx
  002fc	eb cd		 jmp	 SHORT $LN12@hmac_gosth
$LN14@hmac_gosth:
  002fe	33 d2		 xor	 edx, edx
  00300	75 a5		 jne	 SHORT $LN15@hmac_gosth
$LN10@hmac_gosth:

; 273  : 	burn (buf, sizeof(buf));

  00302	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00308	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _burnm$25793[ebp], eax
  0030e	c7 85 ec fe ff
	ff 20 00 00 00	 mov	 DWORD PTR _burnc$25795[ebp], 32 ; 00000020H
  00318	6a 20		 push	 32			; 00000020H
  0031a	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  00320	51		 push	 ecx
  00321	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@hmac_gosth:
  00326	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _burnc$25795[ebp]
  0032c	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _burnc$25795[ebp]
  00332	83 e8 01	 sub	 eax, 1
  00335	89 85 ec fe ff
	ff		 mov	 DWORD PTR _burnc$25795[ebp], eax
  0033b	85 d2		 test	 edx, edx
  0033d	74 1a		 je	 SHORT $LN9@hmac_gosth
  0033f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$25793[ebp]
  00345	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00348	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$25793[ebp]
  0034e	83 c2 01	 add	 edx, 1
  00351	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _burnm$25793[ebp], edx
  00357	eb cd		 jmp	 SHORT $LN7@hmac_gosth
$LN9@hmac_gosth:
  00359	33 c0		 xor	 eax, eax
  0035b	75 a5		 jne	 SHORT $LN10@hmac_gosth
$LN5@hmac_gosth:

; 274  : 	burn (key, sizeof(key));

  0035d	8d 4d d8	 lea	 ecx, DWORD PTR _key$[ebp]
  00360	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _burnm$25802[ebp], ecx
  00366	c7 85 e4 fe ff
	ff 20 00 00 00	 mov	 DWORD PTR _burnc$25804[ebp], 32 ; 00000020H
  00370	6a 20		 push	 32			; 00000020H
  00372	8d 55 d8	 lea	 edx, DWORD PTR _key$[ebp]
  00375	52		 push	 edx
  00376	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@hmac_gosth:
  0037b	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _burnc$25804[ebp]
  00381	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$25804[ebp]
  00387	83 e9 01	 sub	 ecx, 1
  0038a	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _burnc$25804[ebp], ecx
  00390	85 c0		 test	 eax, eax
  00392	74 1a		 je	 SHORT $LN4@hmac_gosth
  00394	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$25802[ebp]
  0039a	c6 02 00	 mov	 BYTE PTR [edx], 0
  0039d	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$25802[ebp]
  003a3	83 c0 01	 add	 eax, 1
  003a6	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _burnm$25802[ebp], eax
  003ac	eb cd		 jmp	 SHORT $LN2@hmac_gosth
$LN4@hmac_gosth:
  003ae	33 c9		 xor	 ecx, ecx
  003b0	75 ab		 jne	 SHORT $LN5@hmac_gosth

; 275  : }

  003b2	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b5	33 cd		 xor	 ecx, ebp
  003b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003bc	8b e5		 mov	 esp, ebp
  003be	5d		 pop	 ebp
  003bf	c2 14 00	 ret	 20			; 00000014H
_hmac_gosthash@20 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_gosthash@28
; Function compile flags: /Odtp
;	COMDAT _derive_u_gosthash@28
_TEXT	SEGMENT
_burnm$25848 = -224					; size = 4
_burnc$25850 = -220					; size = 4
_burnm$25839 = -216					; size = 4
_burnc$25841 = -212					; size = 4
_j$ = -208						; size = 32
_c$ = -176						; size = 4
_k$ = -172						; size = 32
_counter$ = -140					; size = 4
_init$ = -136						; size = 128
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_gosthash@28 PROC				; COMDAT

; 292  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 293  : 	char j[GOSTHASH_DIGESTSIZE], k[GOSTHASH_DIGESTSIZE];
; 294  : 	char init[128];
; 295  : 	char counter[4];
; 296  : 	int c, i;
; 297  : 
; 298  : 	/* iteration 1 */
; 299  : 	memset (counter, 0, 4);

  00017	33 c0		 xor	 eax, eax
  00019	89 85 74 ff ff
	ff		 mov	 DWORD PTR _counter$[ebp], eax

; 300  : 	counter[3] = (char) b;

  0001f	8a 4d 20	 mov	 cl, BYTE PTR _b$[ebp]
  00022	88 8d 77 ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], cl

; 301  : 	memcpy (init, salt, salt_len);	/* salt */

  00028	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0002f	50		 push	 eax
  00030	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _init$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  0003f	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00042	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00048	89 84 15 78 ff
	ff ff		 mov	 DWORD PTR _init$[ebp+edx], eax

; 303  : 	hmac_gosthash (pwd, pwd_len, init, salt_len + 4, j);

  0004f	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00055	51		 push	 ecx
  00056	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	52		 push	 edx
  0005d	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00063	50		 push	 eax
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _hmac_gosthash@20

; 304  : 	memcpy (u, j, GOSTHASH_DIGESTSIZE);

  00071	b9 08 00 00 00	 mov	 ecx, 8
  00076	8d b5 30 ff ff
	ff		 lea	 esi, DWORD PTR _j$[ebp]
  0007c	8b 7d 1c	 mov	 edi, DWORD PTR _u$[ebp]
  0007f	f3 a5		 rep movsd

; 305  : 
; 306  : 	/* remaining iterations */
; 307  : 	for (c = 1; c < iterations; c++)

  00081	c7 85 50 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _c$[ebp], 1
  0008b	eb 0f		 jmp	 SHORT $LN16@derive_u_g
$LN15@derive_u_g:
  0008d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _c$[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 85 50 ff ff
	ff		 mov	 DWORD PTR _c$[ebp], eax
$LN16@derive_u_g:
  0009c	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _c$[ebp]
  000a2	3b 4d 18	 cmp	 ecx, DWORD PTR _iterations$[ebp]
  000a5	7d 6e		 jge	 SHORT $LN10@derive_u_g

; 308  : 	{
; 309  : 		hmac_gosthash (pwd, pwd_len, j, GOSTHASH_DIGESTSIZE, k);

  000a7	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  000ad	52		 push	 edx
  000ae	6a 20		 push	 32			; 00000020H
  000b0	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  000ba	51		 push	 ecx
  000bb	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  000be	52		 push	 edx
  000bf	e8 00 00 00 00	 call	 _hmac_gosthash@20

; 310  : 		for (i = 0; i < GOSTHASH_DIGESTSIZE; i++)

  000c4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000cb	eb 09		 jmp	 SHORT $LN13@derive_u_g
$LN12@derive_u_g:
  000cd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d0	83 c0 01	 add	 eax, 1
  000d3	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@derive_u_g:
  000d6	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000da	7d 34		 jge	 SHORT $LN11@derive_u_g

; 311  : 		{
; 312  : 			u[i] ^= k[i];

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000df	0f be 94 0d 54
	ff ff ff	 movsx	 edx, BYTE PTR _k$[ebp+ecx]
  000e7	8b 45 1c	 mov	 eax, DWORD PTR _u$[ebp]
  000ea	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000ed	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f0	33 ca		 xor	 ecx, edx
  000f2	8b 55 1c	 mov	 edx, DWORD PTR _u$[ebp]
  000f5	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000f8	88 0a		 mov	 BYTE PTR [edx], cl

; 313  : 			j[i] = k[i];

  000fa	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000fd	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00100	8a 94 0d 54 ff
	ff ff		 mov	 dl, BYTE PTR _k$[ebp+ecx]
  00107	88 94 05 30 ff
	ff ff		 mov	 BYTE PTR _j$[ebp+eax], dl

; 314  : 		}

  0010e	eb bd		 jmp	 SHORT $LN12@derive_u_g
$LN11@derive_u_g:

; 315  : 	}

  00110	e9 78 ff ff ff	 jmp	 $LN15@derive_u_g
$LN10@derive_u_g:

; 316  : 
; 317  : 	/* Prevent possible leaks. */
; 318  : 	burn (j, sizeof(j));

  00115	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  0011b	89 85 28 ff ff
	ff		 mov	 DWORD PTR _burnm$25839[ebp], eax
  00121	c7 85 2c ff ff
	ff 20 00 00 00	 mov	 DWORD PTR _burnc$25841[ebp], 32 ; 00000020H
  0012b	6a 20		 push	 32			; 00000020H
  0012d	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00133	51		 push	 ecx
  00134	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@derive_u_g:
  00139	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _burnc$25841[ebp]
  0013f	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _burnc$25841[ebp]
  00145	83 e8 01	 sub	 eax, 1
  00148	89 85 2c ff ff
	ff		 mov	 DWORD PTR _burnc$25841[ebp], eax
  0014e	85 d2		 test	 edx, edx
  00150	74 1a		 je	 SHORT $LN9@derive_u_g
  00152	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _burnm$25839[ebp]
  00158	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0015b	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _burnm$25839[ebp]
  00161	83 c2 01	 add	 edx, 1
  00164	89 95 28 ff ff
	ff		 mov	 DWORD PTR _burnm$25839[ebp], edx
  0016a	eb cd		 jmp	 SHORT $LN7@derive_u_g
$LN9@derive_u_g:
  0016c	33 c0		 xor	 eax, eax
  0016e	75 a5		 jne	 SHORT $LN10@derive_u_g
$LN5@derive_u_g:

; 319  : 	burn (k, sizeof(k));

  00170	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  00176	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _burnm$25848[ebp], ecx
  0017c	c7 85 24 ff ff
	ff 20 00 00 00	 mov	 DWORD PTR _burnc$25850[ebp], 32 ; 00000020H
  00186	6a 20		 push	 32			; 00000020H
  00188	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  0018e	52		 push	 edx
  0018f	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_u_g:
  00194	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _burnc$25850[ebp]
  0019a	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _burnc$25850[ebp]
  001a0	83 e9 01	 sub	 ecx, 1
  001a3	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _burnc$25850[ebp], ecx
  001a9	85 c0		 test	 eax, eax
  001ab	74 1a		 je	 SHORT $LN4@derive_u_g
  001ad	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _burnm$25848[ebp]
  001b3	c6 02 00	 mov	 BYTE PTR [edx], 0
  001b6	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _burnm$25848[ebp]
  001bc	83 c0 01	 add	 eax, 1
  001bf	89 85 20 ff ff
	ff		 mov	 DWORD PTR _burnm$25848[ebp], eax
  001c5	eb cd		 jmp	 SHORT $LN2@derive_u_g
$LN4@derive_u_g:
  001c7	33 c9		 xor	 ecx, ecx
  001c9	75 a5		 jne	 SHORT $LN5@derive_u_g

; 320  : }

  001cb	5f		 pop	 edi
  001cc	5e		 pop	 esi
  001cd	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d0	33 cd		 xor	 ecx, ebp
  001d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_gosthash@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_gosthash@28
; Function compile flags: /Odtp
;	COMDAT _derive_key_gosthash@28
_TEXT	SEGMENT
_burnm$25881 = -56					; size = 4
_burnc$25883 = -52					; size = 4
_r$ = -48						; size = 4
_l$ = -44						; size = 4
_b$ = -40						; size = 4
_u$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_gosthash@28 PROC				; COMDAT

; 337  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 38	 sub	 esp, 56			; 00000038H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	57		 push	 edi

; 338  : 	char u[GOSTHASH_DIGESTSIZE];
; 339  : 	int b, l, r;
; 340  : 
; 341  : 	if (dklen % GOSTHASH_DIGESTSIZE)

  00014	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00017	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0001c	79 05		 jns	 SHORT $LN13@derive_key@2
  0001e	48		 dec	 eax
  0001f	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00022	40		 inc	 eax
$LN13@derive_key@2:
  00023	85 c0		 test	 eax, eax
  00025	74 14		 je	 SHORT $LN10@derive_key@2

; 342  : 	{
; 343  : 		l = 1 + dklen / GOSTHASH_DIGESTSIZE;

  00027	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0002a	99		 cdq
  0002b	83 e2 1f	 and	 edx, 31			; 0000001fH
  0002e	03 c2		 add	 eax, edx
  00030	c1 f8 05	 sar	 eax, 5
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 d4	 mov	 DWORD PTR _l$[ebp], eax

; 344  : 	}
; 345  : 	else

  00039	eb 0f		 jmp	 SHORT $LN9@derive_key@2
$LN10@derive_key@2:

; 346  : 	{
; 347  : 		l = dklen / GOSTHASH_DIGESTSIZE;

  0003b	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0003e	99		 cdq
  0003f	83 e2 1f	 and	 edx, 31			; 0000001fH
  00042	03 c2		 add	 eax, edx
  00044	c1 f8 05	 sar	 eax, 5
  00047	89 45 d4	 mov	 DWORD PTR _l$[ebp], eax
$LN9@derive_key@2:

; 348  : 	}
; 349  : 
; 350  : 	r = dklen - (l - 1) * GOSTHASH_DIGESTSIZE;

  0004a	8b 4d d4	 mov	 ecx, DWORD PTR _l$[ebp]
  0004d	83 e9 01	 sub	 ecx, 1
  00050	c1 e1 05	 shl	 ecx, 5
  00053	8b 55 20	 mov	 edx, DWORD PTR _dklen$[ebp]
  00056	2b d1		 sub	 edx, ecx
  00058	89 55 d0	 mov	 DWORD PTR _r$[ebp], edx

; 351  : 
; 352  : 	/* first l - 1 blocks */
; 353  : 	for (b = 1; b < l; b++)

  0005b	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _b$[ebp], 1
  00062	eb 09		 jmp	 SHORT $LN8@derive_key@2
$LN7@derive_key@2:
  00064	8b 45 d8	 mov	 eax, DWORD PTR _b$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 d8	 mov	 DWORD PTR _b$[ebp], eax
$LN8@derive_key@2:
  0006d	8b 4d d8	 mov	 ecx, DWORD PTR _b$[ebp]
  00070	3b 4d d4	 cmp	 ecx, DWORD PTR _l$[ebp]
  00073	7d 39		 jge	 SHORT $LN6@derive_key@2

; 354  : 	{
; 355  : 		derive_u_gosthash (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00075	8b 55 d8	 mov	 edx, DWORD PTR _b$[ebp]
  00078	52		 push	 edx
  00079	8d 45 dc	 lea	 eax, DWORD PTR _u$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 18	 mov	 ecx, DWORD PTR _iterations$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00084	52		 push	 edx
  00085	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  00088	50		 push	 eax
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _derive_u_gosthash@28

; 356  : 		memcpy (dk, u, GOSTHASH_DIGESTSIZE);

  00096	b9 08 00 00 00	 mov	 ecx, 8
  0009b	8d 75 dc	 lea	 esi, DWORD PTR _u$[ebp]
  0009e	8b 7d 1c	 mov	 edi, DWORD PTR _dk$[ebp]
  000a1	f3 a5		 rep movsd

; 357  : 		dk += GOSTHASH_DIGESTSIZE;

  000a3	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  000a6	83 c0 20	 add	 eax, 32			; 00000020H
  000a9	89 45 1c	 mov	 DWORD PTR _dk$[ebp], eax

; 358  : 	}

  000ac	eb b6		 jmp	 SHORT $LN7@derive_key@2
$LN6@derive_key@2:

; 359  : 
; 360  : 	/* last block */
; 361  : 	derive_u_gosthash (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _b$[ebp]
  000b1	51		 push	 ecx
  000b2	8d 55 dc	 lea	 edx, DWORD PTR _u$[ebp]
  000b5	52		 push	 edx
  000b6	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  000bd	51		 push	 ecx
  000be	8b 55 10	 mov	 edx, DWORD PTR _salt$[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _pwd_len$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _pwd$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _derive_u_gosthash@28

; 362  : 	memcpy (dk, u, r);

  000cf	8b 55 d0	 mov	 edx, DWORD PTR _r$[ebp]
  000d2	52		 push	 edx
  000d3	8d 45 dc	 lea	 eax, DWORD PTR _u$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 1c	 mov	 ecx, DWORD PTR _dk$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _memcpy
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@derive_key@2:

; 363  : 
; 364  : 
; 365  : 	/* Prevent possible leaks. */
; 366  : 	burn (u, sizeof(u));

  000e3	8d 55 dc	 lea	 edx, DWORD PTR _u$[ebp]
  000e6	89 55 c8	 mov	 DWORD PTR _burnm$25881[ebp], edx
  000e9	c7 45 cc 20 00
	00 00		 mov	 DWORD PTR _burnc$25883[ebp], 32 ; 00000020H
  000f0	6a 20		 push	 32			; 00000020H
  000f2	8d 45 dc	 lea	 eax, DWORD PTR _u$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_key@2:
  000fb	8b 4d cc	 mov	 ecx, DWORD PTR _burnc$25883[ebp]
  000fe	8b 55 cc	 mov	 edx, DWORD PTR _burnc$25883[ebp]
  00101	83 ea 01	 sub	 edx, 1
  00104	89 55 cc	 mov	 DWORD PTR _burnc$25883[ebp], edx
  00107	85 c9		 test	 ecx, ecx
  00109	74 11		 je	 SHORT $LN4@derive_key@2
  0010b	8b 45 c8	 mov	 eax, DWORD PTR _burnm$25881[ebp]
  0010e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00111	8b 4d c8	 mov	 ecx, DWORD PTR _burnm$25881[ebp]
  00114	83 c1 01	 add	 ecx, 1
  00117	89 4d c8	 mov	 DWORD PTR _burnm$25881[ebp], ecx
  0011a	eb df		 jmp	 SHORT $LN2@derive_key@2
$LN4@derive_key@2:
  0011c	33 d2		 xor	 edx, edx
  0011e	75 c3		 jne	 SHORT $LN5@derive_key@2

; 367  : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00125	33 cd		 xor	 ecx, ebp
  00127	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_gosthash@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_stribog@20
EXTRN	_STRIBOG_finalize@8:PROC
EXTRN	_STRIBOG_add@12:PROC
EXTRN	_STRIBOG_init@4:PROC
; Function compile flags: /Odtp
;	COMDAT _hmac_stribog@20
_TEXT	SEGMENT
_burnm$25975 = -704					; size = 4
_burnc$25977 = -700					; size = 4
_burnm$25966 = -696					; size = 4
_burnc$25968 = -692					; size = 4
_burnm$25957 = -688					; size = 4
_burnc$25959 = -684					; size = 4
_burnm$25948 = -680					; size = 4
_burnc$25950 = -676					; size = 4
_burnm$25939 = -672					; size = 4
_burnc$25941 = -668					; size = 4
_burnm$25910 = -664					; size = 4
_burnc$25912 = -660					; size = 4
_outer$ = -656						; size = 64
_buf$ = -592						; size = 64
_inner$ = -528						; size = 64
_ctx$ = -464						; size = 385
_key$ = -72						; size = 64
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_hmac_stribog@20 PROC					; COMDAT

; 379  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec c0 02 00
	00		 sub	 esp, 704		; 000002c0H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 380  : 	STRIBOG_CTX ctx;
; 381  : 	char inner[STRIBOG_DIGESTSIZE], outer[STRIBOG_DIGESTSIZE];
; 382  : 	char key[STRIBOG_DIGESTSIZE];
; 383  : 	char buf[STRIBOG_BLOCKSIZE];
; 384  : 	int32 i;
; 385  : 
; 386  :     /* If the key is longer than the hash algorithm block size,
; 387  : 	   let key = stribog(key), as per HMAC specifications. */
; 388  : 	if (lk > STRIBOG_BLOCKSIZE)

  00015	83 7d 0c 40	 cmp	 DWORD PTR _lk$[ebp], 64	; 00000040H
  00019	0f 8e 9b 00 00
	00		 jle	 $LN43@hmac_strib

; 389  : 	{
; 390  : 		STRIBOG_init (&ctx);

  0001f	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _STRIBOG_init@4

; 391  : 		STRIBOG_add (&ctx, (unsigned char *)k, lk);

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _lk$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _k$[ebp]
  00032	52		 push	 edx
  00033	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _STRIBOG_add@12

; 392  : 		STRIBOG_finalize (&ctx, (unsigned char *) key);

  0003f	8d 4d b8	 lea	 ecx, DWORD PTR _key$[ebp]
  00042	51		 push	 ecx
  00043	8d 95 30 fe ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 _STRIBOG_finalize@8

; 393  : 
; 394  : 		k = key;

  0004f	8d 45 b8	 lea	 eax, DWORD PTR _key$[ebp]
  00052	89 45 08	 mov	 DWORD PTR _k$[ebp], eax

; 395  : 		lk = STRIBOG_DIGESTSIZE;

  00055	c7 45 0c 40 00
	00 00		 mov	 DWORD PTR _lk$[ebp], 64	; 00000040H
$LN42@hmac_strib:

; 396  : 
; 397  : 		burn (&ctx, sizeof(ctx));		// Prevent leaks

  0005c	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  00062	89 8d 68 fd ff
	ff		 mov	 DWORD PTR _burnm$25910[ebp], ecx
  00068	c7 85 6c fd ff
	ff 81 01 00 00	 mov	 DWORD PTR _burnc$25912[ebp], 385 ; 00000181H
  00072	68 81 01 00 00	 push	 385			; 00000181H
  00077	8d 95 30 fe ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN39@hmac_strib:
  00083	8b 85 6c fd ff
	ff		 mov	 eax, DWORD PTR _burnc$25912[ebp]
  00089	8b 8d 6c fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$25912[ebp]
  0008f	83 e9 01	 sub	 ecx, 1
  00092	89 8d 6c fd ff
	ff		 mov	 DWORD PTR _burnc$25912[ebp], ecx
  00098	85 c0		 test	 eax, eax
  0009a	74 1a		 je	 SHORT $LN41@hmac_strib
  0009c	8b 95 68 fd ff
	ff		 mov	 edx, DWORD PTR _burnm$25910[ebp]
  000a2	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a5	8b 85 68 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$25910[ebp]
  000ab	83 c0 01	 add	 eax, 1
  000ae	89 85 68 fd ff
	ff		 mov	 DWORD PTR _burnm$25910[ebp], eax
  000b4	eb cd		 jmp	 SHORT $LN39@hmac_strib
$LN41@hmac_strib:
  000b6	33 c9		 xor	 ecx, ecx
  000b8	75 a2		 jne	 SHORT $LN42@hmac_strib
$LN43@hmac_strib:

; 398  : 	}
; 399  : 
; 400  : 	/**** Inner Digest ****/
; 401  : 
; 402  : 	STRIBOG_init (&ctx);

  000ba	8d 95 30 fe ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 _STRIBOG_init@4

; 403  : 
; 404  : 	/* Pad the key for inner digest */
; 405  : 	for (i = 0; i < lk; ++i)

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000cd	eb 09		 jmp	 SHORT $LN37@hmac_strib
$LN36@hmac_strib:
  000cf	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN37@hmac_strib:
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000db	3b 4d 0c	 cmp	 ecx, DWORD PTR _lk$[ebp]
  000de	7d 18		 jge	 SHORT $LN35@hmac_strib

; 406  : 		buf[i] = (char) (k[i] ^ 0x36);

  000e0	8b 55 08	 mov	 edx, DWORD PTR _k$[ebp]
  000e3	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000e6	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000e9	83 f0 36	 xor	 eax, 54			; 00000036H
  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000ef	88 84 0d b0 fd
	ff ff		 mov	 BYTE PTR _buf$[ebp+ecx], al
  000f6	eb d7		 jmp	 SHORT $LN36@hmac_strib
$LN35@hmac_strib:

; 407  : 	for (i = lk; i < STRIBOG_BLOCKSIZE; ++i)

  000f8	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  000fb	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  000fe	eb 09		 jmp	 SHORT $LN34@hmac_strib
$LN33@hmac_strib:
  00100	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00103	83 c0 01	 add	 eax, 1
  00106	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN34@hmac_strib:
  00109	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  0010d	7d 0d		 jge	 SHORT $LN32@hmac_strib

; 408  : 		buf[i] = 0x36;

  0010f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00112	c6 84 0d b0 fd
	ff ff 36	 mov	 BYTE PTR _buf$[ebp+ecx], 54 ; 00000036H
  0011a	eb e4		 jmp	 SHORT $LN33@hmac_strib
$LN32@hmac_strib:

; 409  : 
; 410  : 	STRIBOG_add (&ctx, (unsigned char *) buf, STRIBOG_BLOCKSIZE);

  0011c	6a 40		 push	 64			; 00000040H
  0011e	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR _buf$[ebp]
  00124	52		 push	 edx
  00125	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 _STRIBOG_add@12

; 411  : 	STRIBOG_add (&ctx, (unsigned char *) d, ld);

  00131	8b 4d 14	 mov	 ecx, DWORD PTR _ld$[ebp]
  00134	51		 push	 ecx
  00135	8b 55 10	 mov	 edx, DWORD PTR _d$[ebp]
  00138	52		 push	 edx
  00139	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _STRIBOG_add@12

; 412  : 
; 413  : 	STRIBOG_finalize (&ctx, (unsigned char *) inner);

  00145	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _inner$[ebp]
  0014b	51		 push	 ecx
  0014c	8d 95 30 fe ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  00152	52		 push	 edx
  00153	e8 00 00 00 00	 call	 _STRIBOG_finalize@8

; 414  : 
; 415  : 	/**** Outer Digest ****/
; 416  : 	
; 417  : 	STRIBOG_init (&ctx);

  00158	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 _STRIBOG_init@4

; 418  : 
; 419  : 	for (i = 0; i < lk; ++i)

  00164	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0016b	eb 09		 jmp	 SHORT $LN31@hmac_strib
$LN30@hmac_strib:
  0016d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00170	83 c1 01	 add	 ecx, 1
  00173	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN31@hmac_strib:
  00176	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00179	3b 55 0c	 cmp	 edx, DWORD PTR _lk$[ebp]
  0017c	7d 18		 jge	 SHORT $LN29@hmac_strib

; 420  : 		buf[i] = (char) (k[i] ^ 0x5C);

  0017e	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  00181	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00184	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00187	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  0018a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0018d	88 8c 15 b0 fd
	ff ff		 mov	 BYTE PTR _buf$[ebp+edx], cl
  00194	eb d7		 jmp	 SHORT $LN30@hmac_strib
$LN29@hmac_strib:

; 421  : 	for (i = lk; i < STRIBOG_BLOCKSIZE; ++i)

  00196	8b 45 0c	 mov	 eax, DWORD PTR _lk$[ebp]
  00199	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0019c	eb 09		 jmp	 SHORT $LN28@hmac_strib
$LN27@hmac_strib:
  0019e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001a1	83 c1 01	 add	 ecx, 1
  001a4	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN28@hmac_strib:
  001a7	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  001ab	7d 0d		 jge	 SHORT $LN26@hmac_strib

; 422  : 		buf[i] = 0x5C;

  001ad	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001b0	c6 84 15 b0 fd
	ff ff 5c	 mov	 BYTE PTR _buf$[ebp+edx], 92 ; 0000005cH
  001b8	eb e4		 jmp	 SHORT $LN27@hmac_strib
$LN26@hmac_strib:

; 423  : 
; 424  : 	STRIBOG_add (&ctx, (unsigned char *) buf, STRIBOG_BLOCKSIZE);

  001ba	6a 40		 push	 64			; 00000040H
  001bc	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  001c2	50		 push	 eax
  001c3	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  001c9	51		 push	 ecx
  001ca	e8 00 00 00 00	 call	 _STRIBOG_add@12

; 425  : 	STRIBOG_add (&ctx, (unsigned char *) inner, STRIBOG_DIGESTSIZE);

  001cf	6a 40		 push	 64			; 00000040H
  001d1	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR _inner$[ebp]
  001d7	52		 push	 edx
  001d8	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 _STRIBOG_add@12

; 426  : 
; 427  : 	STRIBOG_finalize (&ctx, (unsigned char *) out);

  001e4	8b 4d 18	 mov	 ecx, DWORD PTR _out$[ebp]
  001e7	51		 push	 ecx
  001e8	8d 95 30 fe ff
	ff		 lea	 edx, DWORD PTR _ctx$[ebp]
  001ee	52		 push	 edx
  001ef	e8 00 00 00 00	 call	 _STRIBOG_finalize@8
$LN25@hmac_strib:

; 428  : 
; 429  : 	/* Prevent possible leaks. */
; 430  : 	burn (&ctx, sizeof(ctx));

  001f4	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  001fa	89 85 60 fd ff
	ff		 mov	 DWORD PTR _burnm$25939[ebp], eax
  00200	c7 85 64 fd ff
	ff 81 01 00 00	 mov	 DWORD PTR _burnc$25941[ebp], 385 ; 00000181H
  0020a	68 81 01 00 00	 push	 385			; 00000181H
  0020f	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR _ctx$[ebp]
  00215	51		 push	 ecx
  00216	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN22@hmac_strib:
  0021b	8b 95 64 fd ff
	ff		 mov	 edx, DWORD PTR _burnc$25941[ebp]
  00221	8b 85 64 fd ff
	ff		 mov	 eax, DWORD PTR _burnc$25941[ebp]
  00227	83 e8 01	 sub	 eax, 1
  0022a	89 85 64 fd ff
	ff		 mov	 DWORD PTR _burnc$25941[ebp], eax
  00230	85 d2		 test	 edx, edx
  00232	74 1a		 je	 SHORT $LN24@hmac_strib
  00234	8b 8d 60 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$25939[ebp]
  0023a	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0023d	8b 95 60 fd ff
	ff		 mov	 edx, DWORD PTR _burnm$25939[ebp]
  00243	83 c2 01	 add	 edx, 1
  00246	89 95 60 fd ff
	ff		 mov	 DWORD PTR _burnm$25939[ebp], edx
  0024c	eb cd		 jmp	 SHORT $LN22@hmac_strib
$LN24@hmac_strib:
  0024e	33 c0		 xor	 eax, eax
  00250	75 a2		 jne	 SHORT $LN25@hmac_strib
$LN20@hmac_strib:

; 431  : 	burn (outer, sizeof(outer));

  00252	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR _outer$[ebp]
  00258	89 8d 58 fd ff
	ff		 mov	 DWORD PTR _burnm$25948[ebp], ecx
  0025e	c7 85 5c fd ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25950[ebp], 64 ; 00000040H
  00268	6a 40		 push	 64			; 00000040H
  0026a	8d 95 70 fd ff
	ff		 lea	 edx, DWORD PTR _outer$[ebp]
  00270	52		 push	 edx
  00271	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN17@hmac_strib:
  00276	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _burnc$25950[ebp]
  0027c	8b 8d 5c fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$25950[ebp]
  00282	83 e9 01	 sub	 ecx, 1
  00285	89 8d 5c fd ff
	ff		 mov	 DWORD PTR _burnc$25950[ebp], ecx
  0028b	85 c0		 test	 eax, eax
  0028d	74 1a		 je	 SHORT $LN19@hmac_strib
  0028f	8b 95 58 fd ff
	ff		 mov	 edx, DWORD PTR _burnm$25948[ebp]
  00295	c6 02 00	 mov	 BYTE PTR [edx], 0
  00298	8b 85 58 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$25948[ebp]
  0029e	83 c0 01	 add	 eax, 1
  002a1	89 85 58 fd ff
	ff		 mov	 DWORD PTR _burnm$25948[ebp], eax
  002a7	eb cd		 jmp	 SHORT $LN17@hmac_strib
$LN19@hmac_strib:
  002a9	33 c9		 xor	 ecx, ecx
  002ab	75 a5		 jne	 SHORT $LN20@hmac_strib
$LN15@hmac_strib:

; 432  : 	burn (inner, sizeof(inner));

  002ad	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR _inner$[ebp]
  002b3	89 95 50 fd ff
	ff		 mov	 DWORD PTR _burnm$25957[ebp], edx
  002b9	c7 85 54 fd ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25959[ebp], 64 ; 00000040H
  002c3	6a 40		 push	 64			; 00000040H
  002c5	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _inner$[ebp]
  002cb	50		 push	 eax
  002cc	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN12@hmac_strib:
  002d1	8b 8d 54 fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$25959[ebp]
  002d7	8b 95 54 fd ff
	ff		 mov	 edx, DWORD PTR _burnc$25959[ebp]
  002dd	83 ea 01	 sub	 edx, 1
  002e0	89 95 54 fd ff
	ff		 mov	 DWORD PTR _burnc$25959[ebp], edx
  002e6	85 c9		 test	 ecx, ecx
  002e8	74 1a		 je	 SHORT $LN14@hmac_strib
  002ea	8b 85 50 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$25957[ebp]
  002f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002f3	8b 8d 50 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$25957[ebp]
  002f9	83 c1 01	 add	 ecx, 1
  002fc	89 8d 50 fd ff
	ff		 mov	 DWORD PTR _burnm$25957[ebp], ecx
  00302	eb cd		 jmp	 SHORT $LN12@hmac_strib
$LN14@hmac_strib:
  00304	33 d2		 xor	 edx, edx
  00306	75 a5		 jne	 SHORT $LN15@hmac_strib
$LN10@hmac_strib:

; 433  : 	burn (buf, sizeof(buf));

  00308	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0030e	89 85 48 fd ff
	ff		 mov	 DWORD PTR _burnm$25966[ebp], eax
  00314	c7 85 4c fd ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25968[ebp], 64 ; 00000040H
  0031e	6a 40		 push	 64			; 00000040H
  00320	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  00326	51		 push	 ecx
  00327	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@hmac_strib:
  0032c	8b 95 4c fd ff
	ff		 mov	 edx, DWORD PTR _burnc$25968[ebp]
  00332	8b 85 4c fd ff
	ff		 mov	 eax, DWORD PTR _burnc$25968[ebp]
  00338	83 e8 01	 sub	 eax, 1
  0033b	89 85 4c fd ff
	ff		 mov	 DWORD PTR _burnc$25968[ebp], eax
  00341	85 d2		 test	 edx, edx
  00343	74 1a		 je	 SHORT $LN9@hmac_strib
  00345	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$25966[ebp]
  0034b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0034e	8b 95 48 fd ff
	ff		 mov	 edx, DWORD PTR _burnm$25966[ebp]
  00354	83 c2 01	 add	 edx, 1
  00357	89 95 48 fd ff
	ff		 mov	 DWORD PTR _burnm$25966[ebp], edx
  0035d	eb cd		 jmp	 SHORT $LN7@hmac_strib
$LN9@hmac_strib:
  0035f	33 c0		 xor	 eax, eax
  00361	75 a5		 jne	 SHORT $LN10@hmac_strib
$LN5@hmac_strib:

; 434  : 	burn (key, sizeof(key));

  00363	8d 4d b8	 lea	 ecx, DWORD PTR _key$[ebp]
  00366	89 8d 40 fd ff
	ff		 mov	 DWORD PTR _burnm$25975[ebp], ecx
  0036c	c7 85 44 fd ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$25977[ebp], 64 ; 00000040H
  00376	6a 40		 push	 64			; 00000040H
  00378	8d 55 b8	 lea	 edx, DWORD PTR _key$[ebp]
  0037b	52		 push	 edx
  0037c	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@hmac_strib:
  00381	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _burnc$25977[ebp]
  00387	8b 8d 44 fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$25977[ebp]
  0038d	83 e9 01	 sub	 ecx, 1
  00390	89 8d 44 fd ff
	ff		 mov	 DWORD PTR _burnc$25977[ebp], ecx
  00396	85 c0		 test	 eax, eax
  00398	74 1a		 je	 SHORT $LN4@hmac_strib
  0039a	8b 95 40 fd ff
	ff		 mov	 edx, DWORD PTR _burnm$25975[ebp]
  003a0	c6 02 00	 mov	 BYTE PTR [edx], 0
  003a3	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$25975[ebp]
  003a9	83 c0 01	 add	 eax, 1
  003ac	89 85 40 fd ff
	ff		 mov	 DWORD PTR _burnm$25975[ebp], eax
  003b2	eb cd		 jmp	 SHORT $LN2@hmac_strib
$LN4@hmac_strib:
  003b4	33 c9		 xor	 ecx, ecx
  003b6	75 ab		 jne	 SHORT $LN5@hmac_strib

; 435  : }

  003b8	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bb	33 cd		 xor	 ecx, ebp
  003bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c2	8b e5		 mov	 esp, ebp
  003c4	5d		 pop	 ebp
  003c5	c2 14 00	 ret	 20			; 00000014H
_hmac_stribog@20 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_stribog@28
; Function compile flags: /Odtp
;	COMDAT _derive_u_stribog@28
_TEXT	SEGMENT
_burnm$26021 = -296					; size = 4
_burnc$26023 = -292					; size = 4
_burnm$26012 = -288					; size = 4
_burnc$26014 = -284					; size = 4
_j$ = -280						; size = 64
_c$ = -212						; size = 4
_k$ = -208						; size = 64
_counter$ = -140					; size = 4
_init$ = -136						; size = 128
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_stribog@28 PROC				; COMDAT

; 452  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 453  : 	char j[STRIBOG_DIGESTSIZE], k[STRIBOG_DIGESTSIZE];
; 454  : 	char init[128];
; 455  : 	char counter[4];
; 456  : 	int c, i;
; 457  : 
; 458  : 	/* iteration 1 */
; 459  : 	memset (counter, 0, 4);

  00017	33 c0		 xor	 eax, eax
  00019	89 85 74 ff ff
	ff		 mov	 DWORD PTR _counter$[ebp], eax

; 460  : 	counter[3] = (char) b;

  0001f	8a 4d 20	 mov	 cl, BYTE PTR _b$[ebp]
  00022	88 8d 77 ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], cl

; 461  : 	memcpy (init, salt, salt_len);	/* salt */

  00028	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0002f	50		 push	 eax
  00030	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _init$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 462  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  0003f	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00042	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00048	89 84 15 78 ff
	ff ff		 mov	 DWORD PTR _init$[ebp+edx], eax

; 463  : 	hmac_stribog (pwd, pwd_len, init, salt_len + 4, j);

  0004f	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00055	51		 push	 ecx
  00056	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	52		 push	 edx
  0005d	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00063	50		 push	 eax
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _hmac_stribog@20

; 464  : 	memcpy (u, j, STRIBOG_DIGESTSIZE);

  00071	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00076	8d b5 e8 fe ff
	ff		 lea	 esi, DWORD PTR _j$[ebp]
  0007c	8b 7d 1c	 mov	 edi, DWORD PTR _u$[ebp]
  0007f	f3 a5		 rep movsd

; 465  : 
; 466  : 	/* remaining iterations */
; 467  : 	for (c = 1; c < iterations; c++)

  00081	c7 85 2c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _c$[ebp], 1
  0008b	eb 0f		 jmp	 SHORT $LN16@derive_u_s
$LN15@derive_u_s:
  0008d	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _c$[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 85 2c ff ff
	ff		 mov	 DWORD PTR _c$[ebp], eax
$LN16@derive_u_s:
  0009c	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _c$[ebp]
  000a2	3b 4d 18	 cmp	 ecx, DWORD PTR _iterations$[ebp]
  000a5	7d 6e		 jge	 SHORT $LN10@derive_u_s

; 468  : 	{
; 469  : 		hmac_stribog (pwd, pwd_len, j, STRIBOG_DIGESTSIZE, k);

  000a7	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  000ad	52		 push	 edx
  000ae	6a 40		 push	 64			; 00000040H
  000b0	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  000ba	51		 push	 ecx
  000bb	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  000be	52		 push	 edx
  000bf	e8 00 00 00 00	 call	 _hmac_stribog@20

; 470  : 		for (i = 0; i < STRIBOG_DIGESTSIZE; i++)

  000c4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000cb	eb 09		 jmp	 SHORT $LN13@derive_u_s
$LN12@derive_u_s:
  000cd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d0	83 c0 01	 add	 eax, 1
  000d3	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@derive_u_s:
  000d6	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  000da	7d 34		 jge	 SHORT $LN11@derive_u_s

; 471  : 		{
; 472  : 			u[i] ^= k[i];

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000df	0f be 94 0d 30
	ff ff ff	 movsx	 edx, BYTE PTR _k$[ebp+ecx]
  000e7	8b 45 1c	 mov	 eax, DWORD PTR _u$[ebp]
  000ea	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000ed	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f0	33 ca		 xor	 ecx, edx
  000f2	8b 55 1c	 mov	 edx, DWORD PTR _u$[ebp]
  000f5	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000f8	88 0a		 mov	 BYTE PTR [edx], cl

; 473  : 			j[i] = k[i];

  000fa	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000fd	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00100	8a 94 0d 30 ff
	ff ff		 mov	 dl, BYTE PTR _k$[ebp+ecx]
  00107	88 94 05 e8 fe
	ff ff		 mov	 BYTE PTR _j$[ebp+eax], dl

; 474  : 		}

  0010e	eb bd		 jmp	 SHORT $LN12@derive_u_s
$LN11@derive_u_s:

; 475  : 	}

  00110	e9 78 ff ff ff	 jmp	 $LN15@derive_u_s
$LN10@derive_u_s:

; 476  : 
; 477  : 	/* Prevent possible leaks. */
; 478  : 	burn (j, sizeof(j));

  00115	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  0011b	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _burnm$26012[ebp], eax
  00121	c7 85 e4 fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$26014[ebp], 64 ; 00000040H
  0012b	6a 40		 push	 64			; 00000040H
  0012d	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00133	51		 push	 ecx
  00134	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@derive_u_s:
  00139	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _burnc$26014[ebp]
  0013f	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _burnc$26014[ebp]
  00145	83 e8 01	 sub	 eax, 1
  00148	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _burnc$26014[ebp], eax
  0014e	85 d2		 test	 edx, edx
  00150	74 1a		 je	 SHORT $LN9@derive_u_s
  00152	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$26012[ebp]
  00158	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0015b	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$26012[ebp]
  00161	83 c2 01	 add	 edx, 1
  00164	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _burnm$26012[ebp], edx
  0016a	eb cd		 jmp	 SHORT $LN7@derive_u_s
$LN9@derive_u_s:
  0016c	33 c0		 xor	 eax, eax
  0016e	75 a5		 jne	 SHORT $LN10@derive_u_s
$LN5@derive_u_s:

; 479  : 	burn (k, sizeof(k));

  00170	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  00176	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _burnm$26021[ebp], ecx
  0017c	c7 85 dc fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$26023[ebp], 64 ; 00000040H
  00186	6a 40		 push	 64			; 00000040H
  00188	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  0018e	52		 push	 edx
  0018f	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_u_s:
  00194	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _burnc$26023[ebp]
  0019a	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$26023[ebp]
  001a0	83 e9 01	 sub	 ecx, 1
  001a3	89 8d dc fe ff
	ff		 mov	 DWORD PTR _burnc$26023[ebp], ecx
  001a9	85 c0		 test	 eax, eax
  001ab	74 1a		 je	 SHORT $LN4@derive_u_s
  001ad	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$26021[ebp]
  001b3	c6 02 00	 mov	 BYTE PTR [edx], 0
  001b6	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$26021[ebp]
  001bc	83 c0 01	 add	 eax, 1
  001bf	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _burnm$26021[ebp], eax
  001c5	eb cd		 jmp	 SHORT $LN2@derive_u_s
$LN4@derive_u_s:
  001c7	33 c9		 xor	 ecx, ecx
  001c9	75 a5		 jne	 SHORT $LN5@derive_u_s

; 480  : }

  001cb	5f		 pop	 edi
  001cc	5e		 pop	 esi
  001cd	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d0	33 cd		 xor	 ecx, ebp
  001d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_stribog@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_stribog@28
; Function compile flags: /Odtp
;	COMDAT _derive_key_stribog@28
_TEXT	SEGMENT
_burnm$26054 = -92					; size = 4
_burnc$26056 = -88					; size = 4
_r$ = -84						; size = 4
_l$ = -80						; size = 4
_b$ = -76						; size = 4
_u$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_stribog@28 PROC				; COMDAT

; 497  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	57		 push	 edi

; 498  : 	char u[STRIBOG_DIGESTSIZE];
; 499  : 	int b, l, r;
; 500  : 
; 501  : 	if (dklen % STRIBOG_DIGESTSIZE)

  00014	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00017	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0001c	79 05		 jns	 SHORT $LN13@derive_key@3
  0001e	48		 dec	 eax
  0001f	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00022	40		 inc	 eax
$LN13@derive_key@3:
  00023	85 c0		 test	 eax, eax
  00025	74 14		 je	 SHORT $LN10@derive_key@3

; 502  : 	{
; 503  : 		l = 1 + dklen / STRIBOG_DIGESTSIZE;

  00027	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0002a	99		 cdq
  0002b	83 e2 3f	 and	 edx, 63			; 0000003fH
  0002e	03 c2		 add	 eax, edx
  00030	c1 f8 06	 sar	 eax, 6
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 b0	 mov	 DWORD PTR _l$[ebp], eax

; 504  : 	}
; 505  : 	else

  00039	eb 0f		 jmp	 SHORT $LN9@derive_key@3
$LN10@derive_key@3:

; 506  : 	{
; 507  : 		l = dklen / STRIBOG_DIGESTSIZE;

  0003b	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0003e	99		 cdq
  0003f	83 e2 3f	 and	 edx, 63			; 0000003fH
  00042	03 c2		 add	 eax, edx
  00044	c1 f8 06	 sar	 eax, 6
  00047	89 45 b0	 mov	 DWORD PTR _l$[ebp], eax
$LN9@derive_key@3:

; 508  : 	}
; 509  : 
; 510  : 	r = dklen - (l - 1) * STRIBOG_DIGESTSIZE;

  0004a	8b 4d b0	 mov	 ecx, DWORD PTR _l$[ebp]
  0004d	83 e9 01	 sub	 ecx, 1
  00050	c1 e1 06	 shl	 ecx, 6
  00053	8b 55 20	 mov	 edx, DWORD PTR _dklen$[ebp]
  00056	2b d1		 sub	 edx, ecx
  00058	89 55 ac	 mov	 DWORD PTR _r$[ebp], edx

; 511  : 
; 512  : 	/* first l - 1 blocks */
; 513  : 	for (b = 1; b < l; b++)

  0005b	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _b$[ebp], 1
  00062	eb 09		 jmp	 SHORT $LN8@derive_key@3
$LN7@derive_key@3:
  00064	8b 45 b4	 mov	 eax, DWORD PTR _b$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 b4	 mov	 DWORD PTR _b$[ebp], eax
$LN8@derive_key@3:
  0006d	8b 4d b4	 mov	 ecx, DWORD PTR _b$[ebp]
  00070	3b 4d b0	 cmp	 ecx, DWORD PTR _l$[ebp]
  00073	7d 39		 jge	 SHORT $LN6@derive_key@3

; 514  : 	{
; 515  : 		derive_u_stribog (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00075	8b 55 b4	 mov	 edx, DWORD PTR _b$[ebp]
  00078	52		 push	 edx
  00079	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 18	 mov	 ecx, DWORD PTR _iterations$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00084	52		 push	 edx
  00085	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  00088	50		 push	 eax
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _derive_u_stribog@28

; 516  : 		memcpy (dk, u, STRIBOG_DIGESTSIZE);

  00096	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0009b	8d 75 b8	 lea	 esi, DWORD PTR _u$[ebp]
  0009e	8b 7d 1c	 mov	 edi, DWORD PTR _dk$[ebp]
  000a1	f3 a5		 rep movsd

; 517  : 		dk += STRIBOG_DIGESTSIZE;

  000a3	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  000a6	83 c0 40	 add	 eax, 64			; 00000040H
  000a9	89 45 1c	 mov	 DWORD PTR _dk$[ebp], eax

; 518  : 	}

  000ac	eb b6		 jmp	 SHORT $LN7@derive_key@3
$LN6@derive_key@3:

; 519  : 
; 520  : 	/* last block */
; 521  : 	derive_u_stribog (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000ae	8b 4d b4	 mov	 ecx, DWORD PTR _b$[ebp]
  000b1	51		 push	 ecx
  000b2	8d 55 b8	 lea	 edx, DWORD PTR _u$[ebp]
  000b5	52		 push	 edx
  000b6	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  000bd	51		 push	 ecx
  000be	8b 55 10	 mov	 edx, DWORD PTR _salt$[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _pwd_len$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _pwd$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _derive_u_stribog@28

; 522  : 	memcpy (dk, u, r);

  000cf	8b 55 ac	 mov	 edx, DWORD PTR _r$[ebp]
  000d2	52		 push	 edx
  000d3	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 1c	 mov	 ecx, DWORD PTR _dk$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _memcpy
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@derive_key@3:

; 523  : 
; 524  : 
; 525  : 	/* Prevent possible leaks. */
; 526  : 	burn (u, sizeof(u));

  000e3	8d 55 b8	 lea	 edx, DWORD PTR _u$[ebp]
  000e6	89 55 a4	 mov	 DWORD PTR _burnm$26054[ebp], edx
  000e9	c7 45 a8 40 00
	00 00		 mov	 DWORD PTR _burnc$26056[ebp], 64 ; 00000040H
  000f0	6a 40		 push	 64			; 00000040H
  000f2	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_key@3:
  000fb	8b 4d a8	 mov	 ecx, DWORD PTR _burnc$26056[ebp]
  000fe	8b 55 a8	 mov	 edx, DWORD PTR _burnc$26056[ebp]
  00101	83 ea 01	 sub	 edx, 1
  00104	89 55 a8	 mov	 DWORD PTR _burnc$26056[ebp], edx
  00107	85 c9		 test	 ecx, ecx
  00109	74 11		 je	 SHORT $LN4@derive_key@3
  0010b	8b 45 a4	 mov	 eax, DWORD PTR _burnm$26054[ebp]
  0010e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00111	8b 4d a4	 mov	 ecx, DWORD PTR _burnm$26054[ebp]
  00114	83 c1 01	 add	 ecx, 1
  00117	89 4d a4	 mov	 DWORD PTR _burnm$26054[ebp], ecx
  0011a	eb df		 jmp	 SHORT $LN2@derive_key@3
$LN4@derive_key@3:
  0011c	33 d2		 xor	 edx, edx
  0011e	75 c3		 jne	 SHORT $LN5@derive_key@3

; 527  : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00125	33 cd		 xor	 ecx, ebp
  00127	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_stribog@28 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_get_pkcs5_prf_name@4
;	COMDAT ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@ DB '(Unknown)', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@ DB 'HMAC-GOST '
	DB	'R 34.11-94', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@ DB 'HMAC-GOS'
	DB	'T R 34.11-2012', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@ DB 'HMAC-Whirlpool', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _get_pkcs5_prf_name@4
_TEXT	SEGMENT
tv64 = -4						; size = 4
_pkcs5_prf_id$ = 8					; size = 4
_get_pkcs5_prf_name@4 PROC				; COMDAT

; 538  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 539  : 	switch (pkcs5_prf_id)

  00006	8b 45 08	 mov	 eax, DWORD PTR _pkcs5_prf_id$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	83 7d fc 01	 cmp	 DWORD PTR tv64[ebp], 1
  00010	74 15		 je	 SHORT $LN3@get_pkcs5_
  00012	83 7d fc 02	 cmp	 DWORD PTR tv64[ebp], 2
  00016	74 16		 je	 SHORT $LN2@get_pkcs5_
  00018	83 7d fc 03	 cmp	 DWORD PTR tv64[ebp], 3
  0001c	74 02		 je	 SHORT $LN4@get_pkcs5_
  0001e	eb 15		 jmp	 SHORT $LN1@get_pkcs5_
$LN4@get_pkcs5_:

; 540  : 	{
; 541  : 	case WHIRLPOOL:	
; 542  : 		return "HMAC-Whirlpool";

  00020	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
  00025	eb 13		 jmp	 SHORT $LN7@get_pkcs5_
$LN3@get_pkcs5_:

; 543  : 	case STRIBOG:
; 544  : 		return "HMAC-GOST R 34.11-2012";

  00027	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@FNODOBFM@
  0002c	eb 0c		 jmp	 SHORT $LN7@get_pkcs5_
$LN2@get_pkcs5_:

; 545  : 	case GOSTHASH:
; 546  : 		return "HMAC-GOST R 34.11-94";

  0002e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@FNODOBFM@
  00033	eb 05		 jmp	 SHORT $LN7@get_pkcs5_
$LN1@get_pkcs5_:

; 547  : 	default:		
; 548  : 		return "(Unknown)";

  00035	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
$LN7@get_pkcs5_:

; 549  : 	}
; 550  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
_get_pkcs5_prf_name@4 ENDP
_TEXT	ENDS
PUBLIC	_get_pkcs5_iteration_count@8
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Odtp
;	COMDAT _get_pkcs5_iteration_count@8
_TEXT	SEGMENT
tv64 = -4						; size = 4
_pkcs5_prf_id$ = 8					; size = 4
_bBoot$ = 12						; size = 4
_get_pkcs5_iteration_count@8 PROC			; COMDAT

; 562  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 563  : 	switch (pkcs5_prf_id)

  00006	8b 45 08	 mov	 eax, DWORD PTR _pkcs5_prf_id$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	83 7d fc 01	 cmp	 DWORD PTR tv64[ebp], 1
  00010	74 15		 je	 SHORT $LN3@get_pkcs5_@2
  00012	83 7d fc 02	 cmp	 DWORD PTR tv64[ebp], 2
  00016	74 16		 je	 SHORT $LN2@get_pkcs5_@2
  00018	83 7d fc 03	 cmp	 DWORD PTR tv64[ebp], 3
  0001c	74 02		 je	 SHORT $LN4@get_pkcs5_@2
  0001e	eb 15		 jmp	 SHORT $LN1@get_pkcs5_@2
$LN4@get_pkcs5_@2:

; 564  : 	{
; 565  : 	case WHIRLPOOL:	
; 566  : 		return 1000;

  00020	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00025	eb 26		 jmp	 SHORT $LN8@get_pkcs5_@2
$LN3@get_pkcs5_@2:

; 567  : 	case STRIBOG:
; 568  : 		return 1000;

  00027	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0002c	eb 1f		 jmp	 SHORT $LN8@get_pkcs5_@2
$LN2@get_pkcs5_@2:

; 569  : 	case GOSTHASH:
; 570  : 		return 1000;

  0002e	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00033	eb 18		 jmp	 SHORT $LN8@get_pkcs5_@2
$LN1@get_pkcs5_@2:

; 571  : 	default:		
; 572  : 		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00035	68 54 53 47 00	 push	 4674388			; 00475354H
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	68 3c 02 00 00	 push	 572			; 0000023cH
  00043	6a 29		 push	 41			; 00000029H
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20

; 573  : 	}
; 574  : 	return 0;

  0004b	33 c0		 xor	 eax, eax
$LN8@get_pkcs5_@2:

; 575  : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
_get_pkcs5_iteration_count@8 ENDP
_TEXT	ENDS
END
