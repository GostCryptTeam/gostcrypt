; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\volumes.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ReadVolumeHeaderRecoveryMode
_BSS	SEGMENT
_ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_GetHeaderField16@8
EXTRN	_MirrorBytes16@4:PROC
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _GetHeaderField16@8
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField16@8 PROC				; COMDAT

; 143  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 144  : 	return BE16 (*(uint16 *) (header + offset));

  00005	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  00008	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  0000b	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _MirrorBytes16@4

; 145  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_GetHeaderField16@8 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField32@8
EXTRN	_MirrorBytes32@4:PROC
; Function compile flags: /Odtp
;	COMDAT _GetHeaderField32@8
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField32@8 PROC				; COMDAT

; 158  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 159  : 	return BE32 (*(uint32 *) (header + offset));

  00005	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  00008	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _MirrorBytes32@4

; 160  : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
_GetHeaderField32@8 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField64@8
EXTRN	_MirrorBytes64@8:PROC
; Function compile flags: /Odtp
;	COMDAT _GetHeaderField64@8
_TEXT	SEGMENT
_uint64Struct$ = -8					; size = 8
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField64@8 PROC				; COMDAT

; 173  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 174  : 	UINT64_STRUCT uint64Struct;
; 175  : 
; 176  : #ifndef GST_NO_COMPILER_INT64
; 177  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  00008	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  0000b	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  0000e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00011	51		 push	 ecx
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _MirrorBytes64@8
  0001a	89 45 f8	 mov	 DWORD PTR _uint64Struct$[ebp], eax
  0001d	89 55 fc	 mov	 DWORD PTR _uint64Struct$[ebp+4], edx

; 178  : #else
; 179  : 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; 180  : 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; 181  : #endif
; 182  : 	return uint64Struct;

  00020	8b 45 f8	 mov	 eax, DWORD PTR _uint64Struct$[ebp]
  00023	8b 55 fc	 mov	 edx, DWORD PTR _uint64Struct$[ebp+4]

; 183  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
_GetHeaderField64@8 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	__$ArrayPad$
PUBLIC	_ReadVolumeHeader@20
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	_crypto_close@4:PROC
EXTRN	_GetCrc32@8:PROC
EXTRN	_DecryptBuffer@16:PROC
EXTRN	_EAInitMode@4:PROC
EXTRN	_EAGetKeySize@4:PROC
EXTRN	_EAInit@12:PROC
EXTRN	_CipherGetBlockSize@4:PROC
EXTRN	_EAGetFirstCipher@4:PROC
EXTRN	_EAIsModeSupported@8:PROC
EXTRN	_EAGetNext@4:PROC
EXTRN	_EAGetFirst@0:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_derive_key_gosthash@28:PROC
EXTRN	_derive_key_stribog@28:PROC
EXTRN	_derive_key_whirlpool@28:PROC
EXTRN	_GetMaxPkcs5OutSize@0:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	_EncryptionThreadPoolBeginKeyDerivation@40:PROC
EXTRN	_get_pkcs5_iteration_count@8:PROC
EXTRN	_crypto_loadkey@12:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	_crypto_open@0:PROC
EXTRN	_GetEncryptionThreadCount@0:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT _ReadVolumeHeader@20
_TEXT	SEGMENT
tv439 = -1324						; size = 4
tv339 = -1320						; size = 4
tv666 = -1316						; size = 4
tv232 = -1312						; size = 4
tv191 = -1308						; size = 4
$T26812 = -1304						; size = 8
$T26811 = -1296						; size = 8
$T26810 = -1288						; size = 8
_burnm$26762 = -1276					; size = 4
_burnc$26764 = -1272					; size = 4
_burnm$26751 = -1268					; size = 4
_burnc$26753 = -1264					; size = 4
_burnm$26742 = -1260					; size = 4
_burnc$26744 = -1256					; size = 4
_blockSize$26706 = -1252				; size = 4
_header$ = -1248					; size = 512
_item$ = -736						; size = 4
_pkcs5_prf$ = -732					; size = 4
_pkcs5PrfCount$ = -728					; size = 4
_status$ = -724						; size = 4
_enqPkcs5Prf$ = -720					; size = 4
_queuedWorkItems$ = -716				; size = 4
_outstandingWorkItemCount$ = -712			; size = 4
_keyDerivationWorkItems$ = -708				; size = 4
_keyInfo$ = -704					; size = 392
_keyDerivationCompletedEvent$ = -312			; size = 16
_primaryKeyOffset$ = -296				; size = 4
_encryptionThreadCount$ = -292				; size = 4
_headerVersion$ = -288					; size = 2
_noOutstandingWorkItemEvent$ = -284			; size = 16
_i$ = -268						; size = 4
_dk$ = -264						; size = 256
__$ArrayPad$ = -8					; size = 4
_cryptoInfo$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_encryptedHeader$ = 12					; size = 4
_password$ = 16						; size = 4
_retInfo$ = 20						; size = 4
_retHeaderCryptoInfo$ = 24				; size = 4
_ReadVolumeHeader@20 PROC				; COMDAT

; 212  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 2c 05 00
	00		 sub	 esp, 1324		; 0000052cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 213  : 	char header[GST_VOLUME_HEADER_EFFECTIVE_SIZE];
; 214  : 	KEY_INFO keyInfo;
; 215  : 	PCRYPTO_INFO cryptoInfo;
; 216  : 	char dk[MASTER_KEYDATA_SIZE];
; 217  : 	int enqPkcs5Prf, pkcs5_prf;
; 218  : 	uint16 headerVersion;
; 219  : 	int status = ERR_PARAMETER_INCORRECT;

  00017	c7 85 2c fd ff
	ff 1e 00 00 00	 mov	 DWORD PTR _status$[ebp], 30 ; 0000001eH

; 220  : 	int primaryKeyOffset;
; 221  : 
; 222  : 	GST_EVENT keyDerivationCompletedEvent;
; 223  : 	GST_EVENT noOutstandingWorkItemEvent;
; 224  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 225  : 	KeyDerivationWorkItem *item;
; 226  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;

  00021	c7 85 28 fd ff
	ff 03 00 00 00	 mov	 DWORD PTR _pkcs5PrfCount$[ebp], 3

; 227  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  0002b	e8 00 00 00 00	 call	 _GetEncryptionThreadCount@0
  00030	89 85 dc fe ff
	ff		 mov	 DWORD PTR _encryptionThreadCount$[ebp], eax

; 228  : 	size_t queuedWorkItems = 0;

  00036	c7 85 34 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _queuedWorkItems$[ebp], 0

; 229  : 	LONG outstandingWorkItemCount = 0;

  00040	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _outstandingWorkItemCount$[ebp], 0

; 230  : 	int i;
; 231  : 
; 232  : 	if (retHeaderCryptoInfo != NULL)

  0004a	83 7d 18 00	 cmp	 DWORD PTR _retHeaderCryptoInfo$[ebp], 0
  0004e	74 08		 je	 SHORT $LN84@ReadVolume

; 233  : 	{
; 234  : 		cryptoInfo = retHeaderCryptoInfo;

  00050	8b 45 18	 mov	 eax, DWORD PTR _retHeaderCryptoInfo$[ebp]
  00053	89 45 fc	 mov	 DWORD PTR _cryptoInfo$[ebp], eax

; 235  : 	}
; 236  : 	else

  00056	eb 22		 jmp	 SHORT $LN83@ReadVolume
$LN84@ReadVolume:

; 237  : 	{
; 238  : 		cryptoInfo = *retInfo = crypto_open ();

  00058	e8 00 00 00 00	 call	 _crypto_open@0
  0005d	8b 4d 14	 mov	 ecx, DWORD PTR _retInfo$[ebp]
  00060	89 01		 mov	 DWORD PTR [ecx], eax
  00062	8b 55 14	 mov	 edx, DWORD PTR _retInfo$[ebp]
  00065	8b 02		 mov	 eax, DWORD PTR [edx]
  00067	89 45 fc	 mov	 DWORD PTR _cryptoInfo$[ebp], eax

; 239  : 		if (cryptoInfo == NULL)

  0006a	83 7d fc 00	 cmp	 DWORD PTR _cryptoInfo$[ebp], 0
  0006e	75 0a		 jne	 SHORT $LN83@ReadVolume

; 240  : 			return ERR_OUTOFMEMORY;

  00070	b8 02 00 00 00	 mov	 eax, 2
  00075	e9 92 0b 00 00	 jmp	 $LN86@ReadVolume
$LN83@ReadVolume:

; 241  : 	}
; 242  : 
; 243  : 	if (encryptionThreadCount > 1)

  0007a	83 bd dc fe ff
	ff 01		 cmp	 DWORD PTR _encryptionThreadCount$[ebp], 1
  00081	0f 86 9d 00 00
	00		 jbe	 $LN81@ReadVolume

; 244  : 	{
; 245  : 		keyDerivationWorkItems = GSTalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00087	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0008c	8b 8d 28 fd ff
	ff		 mov	 ecx, DWORD PTR _pkcs5PrfCount$[ebp]
  00092	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  00098	51		 push	 ecx
  00099	6a 00		 push	 0
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000a1	89 85 3c fd ff
	ff		 mov	 DWORD PTR _keyDerivationWorkItems$[ebp], eax

; 246  : 		if (!keyDerivationWorkItems)

  000a7	83 bd 3c fd ff
	ff 00		 cmp	 DWORD PTR _keyDerivationWorkItems$[ebp], 0
  000ae	75 0a		 jne	 SHORT $LN80@ReadVolume

; 247  : 			return ERR_OUTOFMEMORY;

  000b0	b8 02 00 00 00	 mov	 eax, 2
  000b5	e9 52 0b 00 00	 jmp	 $LN86@ReadVolume
$LN80@ReadVolume:

; 248  : 
; 249  : 		for (i = 0; i < pkcs5PrfCount; ++i)

  000ba	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  000c4	eb 0f		 jmp	 SHORT $LN79@ReadVolume
$LN78@ReadVolume:
  000c6	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  000cc	83 c2 01	 add	 edx, 1
  000cf	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN79@ReadVolume:
  000d5	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000db	3b 85 28 fd ff
	ff		 cmp	 eax, DWORD PTR _pkcs5PrfCount$[ebp]
  000e1	7d 1f		 jge	 SHORT $LN77@ReadVolume

; 250  : 			keyDerivationWorkItems[i].Free = TRUE;

  000e3	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000e9	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  000ef	8b 95 3c fd ff
	ff		 mov	 edx, DWORD PTR _keyDerivationWorkItems$[ebp]
  000f5	c7 84 0a 00 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [edx+ecx+256], 1
  00100	eb c4		 jmp	 SHORT $LN78@ReadVolume
$LN77@ReadVolume:

; 251  : 
; 252  : #ifdef DEVICE_DRIVER
; 253  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);

  00102	6a 00		 push	 0
  00104	6a 01		 push	 1
  00106	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  0010c	50		 push	 eax
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 254  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);

  00113	6a 01		 push	 1
  00115	6a 01		 push	 1
  00117	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  0011d	51		 push	 ecx
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12
$LN81@ReadVolume:

; 255  : #else
; 256  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 257  : 		if (!keyDerivationCompletedEvent)
; 258  : 		{
; 259  : 			GSTfree (keyDerivationWorkItems);
; 260  : 			return ERR_OUTOFMEMORY;
; 261  : 		}
; 262  : 
; 263  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);
; 264  : 		if (!noOutstandingWorkItemEvent)
; 265  : 		{
; 266  : 			CloseHandle (keyDerivationCompletedEvent);
; 267  : 			GSTfree (keyDerivationWorkItems);
; 268  : 			return ERR_OUTOFMEMORY;
; 269  : 		}
; 270  : #endif
; 271  : 	}
; 272  : 		
; 273  : #ifndef DEVICE_DRIVER
; 274  : 	VirtualLock (&keyInfo, sizeof (keyInfo));
; 275  : 	VirtualLock (&dk, sizeof (dk));
; 276  : #endif
; 277  : 
; 278  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  00124	8b 55 10	 mov	 edx, DWORD PTR _password$[ebp]
  00127	8b 02		 mov	 eax, DWORD PTR [edx]
  00129	50		 push	 eax
  0012a	8b 4d 10	 mov	 ecx, DWORD PTR _password$[ebp]
  0012d	83 c1 04	 add	 ecx, 4
  00130	51		 push	 ecx
  00131	8d 95 40 fd ff
	ff		 lea	 edx, DWORD PTR _keyInfo$[ebp]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _crypto_loadkey@12

; 279  : 
; 280  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 281  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  0013d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00142	8b 75 0c	 mov	 esi, DWORD PTR _encryptedHeader$[ebp]
  00145	8d bd 88 fd ff
	ff		 lea	 edi, DWORD PTR _keyInfo$[ebp+72]
  0014b	f3 a5		 rep movsd

; 282  : 
; 283  : 	// Test all available PKCS5 PRFs
; 284  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  0014d	c7 85 30 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _enqPkcs5Prf$[ebp], 1
  00157	eb 0f		 jmp	 SHORT $LN76@ReadVolume
$LN75@ReadVolume:
  00159	8b 85 30 fd ff
	ff		 mov	 eax, DWORD PTR _enqPkcs5Prf$[ebp]
  0015f	83 c0 01	 add	 eax, 1
  00162	89 85 30 fd ff
	ff		 mov	 DWORD PTR _enqPkcs5Prf$[ebp], eax
$LN76@ReadVolume:
  00168	83 bd 30 fd ff
	ff 03		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], 3
  0016f	7e 0d		 jle	 SHORT $LN73@ReadVolume
  00171	83 bd 34 fd ff
	ff 00		 cmp	 DWORD PTR _queuedWorkItems$[ebp], 0
  00178	0f 86 06 09 00
	00		 jbe	 $LN74@ReadVolume
$LN73@ReadVolume:

; 285  : 	{
; 286  : 
; 287  : 		if (encryptionThreadCount > 1)

  0017e	83 bd dc fe ff
	ff 01		 cmp	 DWORD PTR _encryptionThreadCount$[ebp], 1
  00185	0f 86 3e 02 00
	00		 jbe	 $LN72@ReadVolume

; 288  : 		{
; 289  : 			// Enqueue key derivation on thread pool
; 290  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  0018b	8b 8d 34 fd ff
	ff		 mov	 ecx, DWORD PTR _queuedWorkItems$[ebp]
  00191	3b 8d dc fe ff
	ff		 cmp	 ecx, DWORD PTR _encryptionThreadCount$[ebp]
  00197	0f 83 17 01 00
	00		 jae	 $LN71@ReadVolume
  0019d	83 bd 30 fd ff
	ff 03		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], 3
  001a4	0f 8f 0a 01 00
	00		 jg	 $LN71@ReadVolume

; 291  : 			{
; 292  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  001aa	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  001b4	eb 0f		 jmp	 SHORT $LN70@ReadVolume
$LN69@ReadVolume:
  001b6	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  001bc	83 c2 01	 add	 edx, 1
  001bf	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN70@ReadVolume:
  001c5	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  001cb	3b 85 28 fd ff
	ff		 cmp	 eax, DWORD PTR _pkcs5PrfCount$[ebp]
  001d1	0f 8d cd 00 00
	00		 jge	 $LN68@ReadVolume

; 293  : 				{
; 294  : 					item = &keyDerivationWorkItems[i];

  001d7	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  001dd	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  001e3	03 8d 3c fd ff
	ff		 add	 ecx, DWORD PTR _keyDerivationWorkItems$[ebp]
  001e9	89 8d 20 fd ff
	ff		 mov	 DWORD PTR _item$[ebp], ecx

; 295  : 					if (item->Free)

  001ef	8b 95 20 fd ff
	ff		 mov	 edx, DWORD PTR _item$[ebp]
  001f5	83 ba 00 01 00
	00 00		 cmp	 DWORD PTR [edx+256], 0
  001fc	0f 84 9d 00 00
	00		 je	 $LN67@ReadVolume

; 296  : 					{
; 297  : 						item->Free = FALSE;

  00202	8b 85 20 fd ff
	ff		 mov	 eax, DWORD PTR _item$[ebp]
  00208	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 298  : 						item->KeyReady = FALSE;

  00212	8b 8d 20 fd ff
	ff		 mov	 ecx, DWORD PTR _item$[ebp]
  00218	c7 81 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+260], 0

; 299  : 						item->Pkcs5Prf = enqPkcs5Prf;

  00222	8b 95 20 fd ff
	ff		 mov	 edx, DWORD PTR _item$[ebp]
  00228	8b 85 30 fd ff
	ff		 mov	 eax, DWORD PTR _enqPkcs5Prf$[ebp]
  0022e	89 82 08 01 00
	00		 mov	 DWORD PTR [edx+264], eax

; 300  : 
; 301  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 302  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 303  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  00234	8b 8d 20 fd ff
	ff		 mov	 ecx, DWORD PTR _item$[ebp]
  0023a	51		 push	 ecx
  0023b	8b 55 08	 mov	 edx, DWORD PTR _bBoot$[ebp]
  0023e	52		 push	 edx
  0023f	8b 85 30 fd ff
	ff		 mov	 eax, DWORD PTR _enqPkcs5Prf$[ebp]
  00245	50		 push	 eax
  00246	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8
  0024b	50		 push	 eax
  0024c	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp+72]
  00252	51		 push	 ecx
  00253	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _keyInfo$[ebp+4]
  00259	52		 push	 edx
  0025a	8d 85 48 fd ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00260	50		 push	 eax
  00261	8b 8d 30 fd ff
	ff		 mov	 ecx, DWORD PTR _enqPkcs5Prf$[ebp]
  00267	51		 push	 ecx
  00268	8d 95 38 fd ff
	ff		 lea	 edx, DWORD PTR _outstandingWorkItemCount$[ebp]
  0026e	52		 push	 edx
  0026f	8b 85 20 fd ff
	ff		 mov	 eax, DWORD PTR _item$[ebp]
  00275	05 04 01 00 00	 add	 eax, 260		; 00000104H
  0027a	50		 push	 eax
  0027b	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  00281	51		 push	 ecx
  00282	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  00288	52		 push	 edx
  00289	e8 00 00 00 00	 call	 _EncryptionThreadPoolBeginKeyDerivation@40

; 304  : 						
; 305  : 						++queuedWorkItems;

  0028e	8b 85 34 fd ff
	ff		 mov	 eax, DWORD PTR _queuedWorkItems$[ebp]
  00294	83 c0 01	 add	 eax, 1
  00297	89 85 34 fd ff
	ff		 mov	 DWORD PTR _queuedWorkItems$[ebp], eax

; 306  : 						break;

  0029d	eb 05		 jmp	 SHORT $LN68@ReadVolume
$LN67@ReadVolume:

; 307  : 					}
; 308  : 				}

  0029f	e9 12 ff ff ff	 jmp	 $LN69@ReadVolume
$LN68@ReadVolume:

; 309  : 
; 310  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  002a4	83 bd 30 fd ff
	ff 03		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], 3
  002ab	7d 05		 jge	 SHORT $LN66@ReadVolume

; 311  : 					continue;

  002ad	e9 a7 fe ff ff	 jmp	 $LN75@ReadVolume
$LN66@ReadVolume:

; 312  : 			}
; 313  : 			else

  002b2	eb 0f		 jmp	 SHORT $LN64@ReadVolume
$LN71@ReadVolume:

; 314  : 				--enqPkcs5Prf;

  002b4	8b 8d 30 fd ff
	ff		 mov	 ecx, DWORD PTR _enqPkcs5Prf$[ebp]
  002ba	83 e9 01	 sub	 ecx, 1
  002bd	89 8d 30 fd ff
	ff		 mov	 DWORD PTR _enqPkcs5Prf$[ebp], ecx
$LN64@ReadVolume:

; 315  : 
; 316  : 			// Wait for completion of a key derivation
; 317  : 			while (queuedWorkItems > 0)

  002c3	83 bd 34 fd ff
	ff 00		 cmp	 DWORD PTR _queuedWorkItems$[ebp], 0
  002ca	0f 86 ef 00 00
	00		 jbe	 $LN63@ReadVolume

; 318  : 			{
; 319  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  002d0	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  002da	eb 0f		 jmp	 SHORT $LN62@ReadVolume
$LN61@ReadVolume:
  002dc	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  002e2	83 c2 01	 add	 edx, 1
  002e5	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN62@ReadVolume:
  002eb	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  002f1	3b 85 28 fd ff
	ff		 cmp	 eax, DWORD PTR _pkcs5PrfCount$[ebp]
  002f7	0f 8d 9f 00 00
	00		 jge	 $LN60@ReadVolume

; 320  : 				{
; 321  : 					item = &keyDerivationWorkItems[i];

  002fd	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00303	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  00309	03 8d 3c fd ff
	ff		 add	 ecx, DWORD PTR _keyDerivationWorkItems$[ebp]
  0030f	89 8d 20 fd ff
	ff		 mov	 DWORD PTR _item$[ebp], ecx

; 322  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  00315	8b 95 20 fd ff
	ff		 mov	 edx, DWORD PTR _item$[ebp]
  0031b	83 ba 00 01 00
	00 00		 cmp	 DWORD PTR [edx+256], 0
  00322	75 73		 jne	 SHORT $LN59@ReadVolume
  00324	33 c0		 xor	 eax, eax
  00326	8b 8d 20 fd ff
	ff		 mov	 ecx, DWORD PTR _item$[ebp]
  0032c	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00332	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00336	83 f8 01	 cmp	 eax, 1
  00339	75 5c		 jne	 SHORT $LN59@ReadVolume

; 323  : 					{
; 324  : 						pkcs5_prf = item->Pkcs5Prf;

  0033b	8b 95 20 fd ff
	ff		 mov	 edx, DWORD PTR _item$[ebp]
  00341	8b 82 08 01 00
	00		 mov	 eax, DWORD PTR [edx+264]
  00347	89 85 24 fd ff
	ff		 mov	 DWORD PTR _pkcs5_prf$[ebp], eax

; 325  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  0034d	8b 4d 08	 mov	 ecx, DWORD PTR _bBoot$[ebp]
  00350	51		 push	 ecx
  00351	8b 95 24 fd ff
	ff		 mov	 edx, DWORD PTR _pkcs5_prf$[ebp]
  00357	52		 push	 edx
  00358	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8
  0035d	89 85 40 fd ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax

; 326  : 						memcpy (dk, item->DerivedKey, sizeof (dk));

  00363	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00368	8b b5 20 fd ff
	ff		 mov	 esi, DWORD PTR _item$[ebp]
  0036e	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _dk$[ebp]
  00374	f3 a5		 rep movsd

; 327  : 
; 328  : 						item->Free = TRUE;

  00376	8b 85 20 fd ff
	ff		 mov	 eax, DWORD PTR _item$[ebp]
  0037c	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+256], 1

; 329  : 						--queuedWorkItems;

  00386	8b 8d 34 fd ff
	ff		 mov	 ecx, DWORD PTR _queuedWorkItems$[ebp]
  0038c	83 e9 01	 sub	 ecx, 1
  0038f	89 8d 34 fd ff
	ff		 mov	 DWORD PTR _queuedWorkItems$[ebp], ecx

; 330  : 						goto KeyReady;

  00395	eb 2d		 jmp	 SHORT $KeyReady$26682
$LN59@ReadVolume:

; 331  : 					}
; 332  : 				}

  00397	e9 40 ff ff ff	 jmp	 $LN61@ReadVolume
$LN60@ReadVolume:

; 333  : 
; 334  : 				if (queuedWorkItems > 0)

  0039c	83 bd 34 fd ff
	ff 00		 cmp	 DWORD PTR _queuedWorkItems$[ebp], 0
  003a3	76 15		 jbe	 SHORT $LN58@ReadVolume

; 335  : 					GST_WAIT_EVENT (keyDerivationCompletedEvent);

  003a5	6a 00		 push	 0
  003a7	6a 00		 push	 0
  003a9	6a 00		 push	 0
  003ab	6a 00		 push	 0
  003ad	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  003b3	52		 push	 edx
  003b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN58@ReadVolume:

; 336  : 			}

  003ba	e9 04 ff ff ff	 jmp	 $LN64@ReadVolume
$LN63@ReadVolume:

; 337  : 			continue;

  003bf	e9 95 fd ff ff	 jmp	 $LN75@ReadVolume
$KeyReady$26682:

; 338  : KeyReady:	;
; 339  : 		}
; 340  : 		else

  003c4	e9 fa 00 00 00	 jmp	 $LN57@ReadVolume
$LN72@ReadVolume:

; 341  : 		{
; 342  : 			pkcs5_prf = enqPkcs5Prf;

  003c9	8b 85 30 fd ff
	ff		 mov	 eax, DWORD PTR _enqPkcs5Prf$[ebp]
  003cf	89 85 24 fd ff
	ff		 mov	 DWORD PTR _pkcs5_prf$[ebp], eax

; 343  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  003d5	8b 4d 08	 mov	 ecx, DWORD PTR _bBoot$[ebp]
  003d8	51		 push	 ecx
  003d9	8b 95 30 fd ff
	ff		 mov	 edx, DWORD PTR _enqPkcs5Prf$[ebp]
  003df	52		 push	 edx
  003e0	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8
  003e5	89 85 40 fd ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax

; 344  : 
; 345  : 			switch (pkcs5_prf)

  003eb	8b 85 24 fd ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$[ebp]
  003f1	89 85 e4 fa ff
	ff		 mov	 DWORD PTR tv191[ebp], eax
  003f7	83 bd e4 fa ff
	ff 01		 cmp	 DWORD PTR tv191[ebp], 1
  003fe	74 49		 je	 SHORT $LN53@ReadVolume
  00400	83 bd e4 fa ff
	ff 02		 cmp	 DWORD PTR tv191[ebp], 2
  00407	74 72		 je	 SHORT $LN52@ReadVolume
  00409	83 bd e4 fa ff
	ff 03		 cmp	 DWORD PTR tv191[ebp], 3
  00410	74 05		 je	 SHORT $LN54@ReadVolume
  00412	e9 96 00 00 00	 jmp	 $LN51@ReadVolume
$LN54@ReadVolume:

; 346  : 			{
; 347  : 			case WHIRLPOOL:
; 348  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 349  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00417	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  0041c	50		 push	 eax
  0041d	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _dk$[ebp]
  00423	51		 push	 ecx
  00424	8b 95 40 fd ff
	ff		 mov	 edx, DWORD PTR _keyInfo$[ebp]
  0042a	52		 push	 edx
  0042b	6a 40		 push	 64			; 00000040H
  0042d	8d 85 88 fd ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  00433	50		 push	 eax
  00434	8b 8d 44 fd ff
	ff		 mov	 ecx, DWORD PTR _keyInfo$[ebp+4]
  0043a	51		 push	 ecx
  0043b	8d 95 48 fd ff
	ff		 lea	 edx, DWORD PTR _keyInfo$[ebp+8]
  00441	52		 push	 edx
  00442	e8 00 00 00 00	 call	 _derive_key_whirlpool@28

; 350  : 				break;

  00447	eb 7a		 jmp	 SHORT $LN57@ReadVolume
$LN53@ReadVolume:

; 351  : 			case STRIBOG:
; 352  : 				derive_key_stribog (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 353  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00449	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  0044e	50		 push	 eax
  0044f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  00455	50		 push	 eax
  00456	8b 8d 40 fd ff
	ff		 mov	 ecx, DWORD PTR _keyInfo$[ebp]
  0045c	51		 push	 ecx
  0045d	6a 40		 push	 64			; 00000040H
  0045f	8d 95 88 fd ff
	ff		 lea	 edx, DWORD PTR _keyInfo$[ebp+72]
  00465	52		 push	 edx
  00466	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp+4]
  0046c	50		 push	 eax
  0046d	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp+8]
  00473	51		 push	 ecx
  00474	e8 00 00 00 00	 call	 _derive_key_stribog@28

; 354  : 				break;

  00479	eb 48		 jmp	 SHORT $LN57@ReadVolume
$LN52@ReadVolume:

; 355  : 			case GOSTHASH:
; 356  : 				derive_key_gosthash (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 357  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  0047b	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  00480	50		 push	 eax
  00481	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _dk$[ebp]
  00487	52		 push	 edx
  00488	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  0048e	50		 push	 eax
  0048f	6a 40		 push	 64			; 00000040H
  00491	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp+72]
  00497	51		 push	 ecx
  00498	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _keyInfo$[ebp+4]
  0049e	52		 push	 edx
  0049f	8d 85 48 fd ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  004a5	50		 push	 eax
  004a6	e8 00 00 00 00	 call	 _derive_key_gosthash@28

; 358  : 				break;

  004ab	eb 16		 jmp	 SHORT $LN57@ReadVolume
$LN51@ReadVolume:

; 359  : 			default:		
; 360  : 				// Unknown/wrong ID
; 361  : 				GST_THROW_FATAL_EXCEPTION;

  004ad	68 54 53 47 00	 push	 4674388			; 00475354H
  004b2	6a 00		 push	 0
  004b4	6a 00		 push	 0
  004b6	68 69 01 00 00	 push	 361			; 00000169H
  004bb	6a 29		 push	 41			; 00000029H
  004bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN57@ReadVolume:

; 362  : 			} 
; 363  : 		}
; 364  : 
; 365  : 		// Test all available modes of operation
; 366  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; 367  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 368  : 			cryptoInfo->mode++)

  004c3	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  004c6	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
  004cd	eb 0f		 jmp	 SHORT $LN50@ReadVolume
$LN49@ReadVolume:
  004cf	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  004d2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  004d5	83 c0 01	 add	 eax, 1
  004d8	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  004db	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN50@ReadVolume:
  004de	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  004e1	83 7a 04 02	 cmp	 DWORD PTR [edx+4], 2
  004e5	0f 8f 94 05 00
	00		 jg	 $LN48@ReadVolume

; 369  : 		{
; 370  : 			switch (cryptoInfo->mode)

  004eb	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  004ee	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004f1	89 8d e0 fa ff
	ff		 mov	 DWORD PTR tv232[ebp], ecx

; 371  : 			{
; 372  : 			default:
; 373  : 				primaryKeyOffset = 0;

  004f7	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _primaryKeyOffset$[ebp], 0

; 374  : 			}
; 375  : 
; 376  : 			// Test all available encryption algorithms
; 377  : 			for (cryptoInfo->ea = EAGetFirst ();
; 378  : 				cryptoInfo->ea != 0;
; 379  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  00501	e8 00 00 00 00	 call	 _EAGetFirst@0
  00506	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00509	89 02		 mov	 DWORD PTR [edx], eax
  0050b	eb 10		 jmp	 SHORT $LN44@ReadVolume
$LN43@ReadVolume:
  0050d	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00510	8b 08		 mov	 ecx, DWORD PTR [eax]
  00512	51		 push	 ecx
  00513	e8 00 00 00 00	 call	 _EAGetNext@4
  00518	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0051b	89 02		 mov	 DWORD PTR [edx], eax
$LN44@ReadVolume:
  0051d	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00520	83 38 00	 cmp	 DWORD PTR [eax], 0
  00523	0f 84 51 05 00
	00		 je	 $LN42@ReadVolume

; 380  : 			{
; 381  : 				int blockSize;
; 382  : 
; 383  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  00529	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0052c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0052f	52		 push	 edx
  00530	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00533	8b 08		 mov	 ecx, DWORD PTR [eax]
  00535	51		 push	 ecx
  00536	e8 00 00 00 00	 call	 _EAIsModeSupported@8
  0053b	85 c0		 test	 eax, eax
  0053d	75 02		 jne	 SHORT $LN41@ReadVolume

; 384  : 					continue;	// This encryption algorithm has never been available with this mode of operation

  0053f	eb cc		 jmp	 SHORT $LN43@ReadVolume
$LN41@ReadVolume:

; 385  : 
; 386  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));

  00541	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00544	8b 02		 mov	 eax, DWORD PTR [edx]
  00546	50		 push	 eax
  00547	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  0054c	50		 push	 eax
  0054d	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  00552	89 85 1c fb ff
	ff		 mov	 DWORD PTR _blockSize$26706[ebp], eax

; 387  : 
; 388  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  00558	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0055b	83 c1 08	 add	 ecx, 8
  0055e	51		 push	 ecx
  0055f	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _primaryKeyOffset$[ebp]
  00565	8d 84 15 f8 fe
	ff ff		 lea	 eax, DWORD PTR _dk$[ebp+edx]
  0056c	50		 push	 eax
  0056d	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00570	8b 11		 mov	 edx, DWORD PTR [ecx]
  00572	52		 push	 edx
  00573	e8 00 00 00 00	 call	 _EAInit@12
  00578	89 85 2c fd ff
	ff		 mov	 DWORD PTR _status$[ebp], eax

; 389  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  0057e	83 bd 2c fd ff
	ff 11		 cmp	 DWORD PTR _status$[ebp], 17 ; 00000011H
  00585	75 05		 jne	 SHORT $LN40@ReadVolume

; 390  : 					goto err;

  00587	e9 02 05 00 00	 jmp	 $err$26709
$LN40@ReadVolume:

; 391  : 
; 392  : 				// Init objects related to the mode of operation
; 393  : 
; 394  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  0058c	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0058f	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00593	74 09		 je	 SHORT $LN38@ReadVolume
  00595	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00598	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2
  0059c	75 4d		 jne	 SHORT $LN39@ReadVolume
$LN38@ReadVolume:

; 395  : 				{
; 396  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 397  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  0059e	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  005a1	8b 02		 mov	 eax, DWORD PTR [edx]
  005a3	50		 push	 eax
  005a4	e8 00 00 00 00	 call	 _EAGetKeySize@4
  005a9	50		 push	 eax
  005aa	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  005ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  005af	52		 push	 edx
  005b0	e8 00 00 00 00	 call	 _EAGetKeySize@4
  005b5	8d 84 05 f8 fe
	ff ff		 lea	 eax, DWORD PTR _dk$[ebp+eax]
  005bc	50		 push	 eax
  005bd	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  005c0	81 c1 50 1d 00
	00		 add	 ecx, 7504		; 00001d50H
  005c6	51		 push	 ecx
  005c7	e8 00 00 00 00	 call	 _memcpy
  005cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 398  : 
; 399  : 					// Secondary key schedule
; 400  : 					if (!EAInitMode (cryptoInfo))

  005cf	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  005d2	52		 push	 edx
  005d3	e8 00 00 00 00	 call	 _EAInitMode@4
  005d8	85 c0		 test	 eax, eax
  005da	75 0f		 jne	 SHORT $LN39@ReadVolume

; 401  : 					{
; 402  : 						status = ERR_MODE_INIT_FAILED;

  005dc	c7 85 2c fd ff
	ff 1b 00 00 00	 mov	 DWORD PTR _status$[ebp], 27 ; 0000001bH

; 403  : 						goto err;

  005e6	e9 a3 04 00 00	 jmp	 $err$26709
$LN39@ReadVolume:

; 404  : 					}
; 405  : 				}
; 406  : 
; 407  : 				// Copy the header for decryption
; 408  : 				memcpy (header, encryptedHeader, sizeof (header));

  005eb	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  005f0	8b 75 0c	 mov	 esi, DWORD PTR _encryptedHeader$[ebp]
  005f3	8d bd 20 fb ff
	ff		 lea	 edi, DWORD PTR _header$[ebp]
  005f9	f3 a5		 rep movsd

; 409  : 
; 410  : 				// Try to decrypt header 
; 411  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  005fb	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  005fe	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00602	74 09		 je	 SHORT $LN35@ReadVolume
  00604	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00607	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2
  0060b	75 17		 jne	 SHORT $LN36@ReadVolume
$LN35@ReadVolume:

; 412  : 					DecryptBuffer(header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  0060d	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00610	52		 push	 edx
  00611	6a 00		 push	 0
  00613	68 c0 01 00 00	 push	 448			; 000001c0H
  00618	8d 85 60 fb ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+64]
  0061e	50		 push	 eax
  0061f	e8 00 00 00 00	 call	 _DecryptBuffer@16
$LN36@ReadVolume:

; 413  : 
; 414  : 				// Magic 'TRUE'
; 415  : 				if (GetHeaderField32 (header, GST_HEADER_OFFSET_MAGIC) != 0x54525545)

  00624	6a 40		 push	 64			; 00000040H
  00626	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  0062c	51		 push	 ecx
  0062d	e8 00 00 00 00	 call	 _GetHeaderField32@8
  00632	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  00637	74 05		 je	 SHORT $LN34@ReadVolume

; 416  : 					continue;

  00639	e9 cf fe ff ff	 jmp	 $LN43@ReadVolume
$LN34@ReadVolume:

; 417  : 
; 418  : 				// Header version
; 419  : 				headerVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_VERSION);

  0063e	6a 44		 push	 68			; 00000044H
  00640	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  00646	52		 push	 edx
  00647	e8 00 00 00 00	 call	 _GetHeaderField16@8
  0064c	66 89 85 e0 fe
	ff ff		 mov	 WORD PTR _headerVersion$[ebp], ax

; 420  : 				
; 421  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  00653	0f b7 85 e0 fe
	ff ff		 movzx	 eax, WORD PTR _headerVersion$[ebp]
  0065a	3d 00 13 00 00	 cmp	 eax, 4864		; 00001300H
  0065f	7e 0f		 jle	 SHORT $LN33@ReadVolume

; 422  : 				{
; 423  : 					status = ERR_NEW_VERSION_REQUIRED;

  00661	c7 85 2c fd ff
	ff 10 00 00 00	 mov	 DWORD PTR _status$[ebp], 16 ; 00000010H

; 424  : 					goto err;

  0066b	e9 1e 04 00 00	 jmp	 $err$26709
$LN33@ReadVolume:

; 425  : 				}
; 426  : 
; 427  : 				// Check CRC of the header fields
; 428  : 				if (!ReadVolumeHeaderRecoveryMode
; 429  : 					&& headerVersion >= 4
; 430  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC))

  00670	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  00677	75 39		 jne	 SHORT $LN32@ReadVolume
  00679	0f b7 8d e0 fe
	ff ff		 movzx	 ecx, WORD PTR _headerVersion$[ebp]
  00680	83 f9 04	 cmp	 ecx, 4
  00683	7c 2d		 jl	 SHORT $LN32@ReadVolume
  00685	68 fc 00 00 00	 push	 252			; 000000fcH
  0068a	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  00690	52		 push	 edx
  00691	e8 00 00 00 00	 call	 _GetHeaderField32@8
  00696	8b f0		 mov	 esi, eax
  00698	68 bc 00 00 00	 push	 188			; 000000bcH
  0069d	8d 85 60 fb ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+64]
  006a3	50		 push	 eax
  006a4	e8 00 00 00 00	 call	 _GetCrc32@8
  006a9	3b f0		 cmp	 esi, eax
  006ab	74 05		 je	 SHORT $LN32@ReadVolume

; 431  : 					continue;

  006ad	e9 5b fe ff ff	 jmp	 $LN43@ReadVolume
$LN32@ReadVolume:

; 432  : 
; 433  : 				// Required program version
; 434  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_REQUIRED_VERSION);

  006b2	6a 46		 push	 70			; 00000046H
  006b4	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  006ba	51		 push	 ecx
  006bb	e8 00 00 00 00	 call	 _GetHeaderField16@8
  006c0	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  006c3	66 89 82 e0 1e
	00 00		 mov	 WORD PTR [edx+7904], ax

; 435  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  006ca	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  006cd	0f b7 88 e0 1e
	00 00		 movzx	 ecx, WORD PTR [eax+7904]
  006d4	33 d2		 xor	 edx, edx
  006d6	81 f9 00 06 00
	00		 cmp	 ecx, 1536		; 00000600H
  006dc	0f 9c c2	 setl	 dl
  006df	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  006e2	89 90 e4 1e 00
	00		 mov	 DWORD PTR [eax+7908], edx

; 436  : 
; 437  : 				// Check CRC of the key set
; 438  : 				if (!ReadVolumeHeaderRecoveryMode
; 439  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  006e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  006ef	75 2a		 jne	 SHORT $LN31@ReadVolume
  006f1	6a 48		 push	 72			; 00000048H
  006f3	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  006f9	51		 push	 ecx
  006fa	e8 00 00 00 00	 call	 _GetHeaderField32@8
  006ff	8b f0		 mov	 esi, eax
  00701	68 00 01 00 00	 push	 256			; 00000100H
  00706	8d 95 20 fc ff
	ff		 lea	 edx, DWORD PTR _header$[ebp+256]
  0070c	52		 push	 edx
  0070d	e8 00 00 00 00	 call	 _GetCrc32@8
  00712	3b f0		 cmp	 esi, eax
  00714	74 05		 je	 SHORT $LN31@ReadVolume

; 440  : 					continue;

  00716	e9 f2 fd ff ff	 jmp	 $LN43@ReadVolume
$LN31@ReadVolume:

; 441  : 
; 442  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 443  : 
; 444  : 				// Check the version required to handle this volume
; 445  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  0071b	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0071e	0f b7 88 e0 1e
	00 00		 movzx	 ecx, WORD PTR [eax+7904]
  00725	81 f9 00 13 00
	00		 cmp	 ecx, 4864		; 00001300H
  0072b	7e 0f		 jle	 SHORT $LN30@ReadVolume

; 446  : 				{
; 447  : 					status = ERR_NEW_VERSION_REQUIRED;

  0072d	c7 85 2c fd ff
	ff 10 00 00 00	 mov	 DWORD PTR _status$[ebp], 16 ; 00000010H

; 448  : 					goto err;

  00737	e9 52 03 00 00	 jmp	 $err$26709
$LN30@ReadVolume:

; 449  : 				}
; 450  : 
; 451  : 				// Header version
; 452  : 				cryptoInfo->HeaderVersion = headerVersion;

  0073c	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0073f	66 8b 85 e0 fe
	ff ff		 mov	 ax, WORD PTR _headerVersion$[ebp]
  00746	66 89 82 4c 04
	00 00		 mov	 WORD PTR [edx+1100], ax

; 453  : 
; 454  : 				// Volume creation time (legacy)
; 455  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  0074d	6a 4c		 push	 76			; 0000004cH
  0074f	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  00755	51		 push	 ecx
  00756	e8 00 00 00 00	 call	 _GetHeaderField64@8
  0075b	89 85 f8 fa ff
	ff		 mov	 DWORD PTR $T26810[ebp], eax
  00761	89 95 fc fa ff
	ff		 mov	 DWORD PTR $T26810[ebp+4], edx
  00767	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0076a	8b 85 f8 fa ff
	ff		 mov	 eax, DWORD PTR $T26810[ebp]
  00770	89 82 98 1e 00
	00		 mov	 DWORD PTR [edx+7832], eax
  00776	8b 8d fc fa ff
	ff		 mov	 ecx, DWORD PTR $T26810[ebp+4]
  0077c	89 8a 9c 1e 00
	00		 mov	 DWORD PTR [edx+7836], ecx

; 456  : 
; 457  : 				// Header creation time (legacy)
; 458  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_MODIFICATION_TIME).Value;

  00782	6a 54		 push	 84			; 00000054H
  00784	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  0078a	52		 push	 edx
  0078b	e8 00 00 00 00	 call	 _GetHeaderField64@8
  00790	89 85 f0 fa ff
	ff		 mov	 DWORD PTR $T26811[ebp], eax
  00796	89 95 f4 fa ff
	ff		 mov	 DWORD PTR $T26811[ebp+4], edx
  0079c	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0079f	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR $T26811[ebp]
  007a5	89 88 a0 1e 00
	00		 mov	 DWORD PTR [eax+7840], ecx
  007ab	8b 95 f4 fa ff
	ff		 mov	 edx, DWORD PTR $T26811[ebp+4]
  007b1	89 90 a4 1e 00
	00		 mov	 DWORD PTR [eax+7844], edx

; 459  : 
; 460  : 				// Hidden volume size (if any)
; 461  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  007b7	6a 5c		 push	 92			; 0000005cH
  007b9	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  007bf	50		 push	 eax
  007c0	e8 00 00 00 00	 call	 _GetHeaderField64@8
  007c5	89 85 e8 fa ff
	ff		 mov	 DWORD PTR $T26812[ebp], eax
  007cb	89 95 ec fa ff
	ff		 mov	 DWORD PTR $T26812[ebp+4], edx
  007d1	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  007d4	8b 95 e8 fa ff
	ff		 mov	 edx, DWORD PTR $T26812[ebp]
  007da	89 91 b8 1e 00
	00		 mov	 DWORD PTR [ecx+7864], edx
  007e0	8b 85 ec fa ff
	ff		 mov	 eax, DWORD PTR $T26812[ebp+4]
  007e6	89 81 bc 1e 00
	00		 mov	 DWORD PTR [ecx+7868], eax

; 462  : 
; 463  : 				// Hidden volume status
; 464  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  007ec	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  007ef	89 8d dc fa ff
	ff		 mov	 DWORD PTR tv666[ebp], ecx
  007f5	8b 95 dc fa ff
	ff		 mov	 edx, DWORD PTR tv666[ebp]
  007fb	8b 85 dc fa ff
	ff		 mov	 eax, DWORD PTR tv666[ebp]
  00801	8b 8a b8 1e 00
	00		 mov	 ecx, DWORD PTR [edx+7864]
  00807	0b 88 bc 1e 00
	00		 or	 ecx, DWORD PTR [eax+7868]
  0080d	74 0c		 je	 SHORT $LN87@ReadVolume
  0080f	c7 85 d8 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv339[ebp], 1
  00819	eb 0a		 jmp	 SHORT $LN88@ReadVolume
$LN87@ReadVolume:
  0081b	c7 85 d8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv339[ebp], 0
$LN88@ReadVolume:
  00825	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00828	8b 85 d8 fa ff
	ff		 mov	 eax, DWORD PTR tv339[ebp]
  0082e	89 82 48 04 00
	00		 mov	 DWORD PTR [edx+1096], eax

; 465  : 
; 466  : 				// Volume size
; 467  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_SIZE);

  00834	6a 64		 push	 100			; 00000064H
  00836	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  0083c	51		 push	 ecx
  0083d	e8 00 00 00 00	 call	 _GetHeaderField64@8
  00842	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00845	89 81 f0 1e 00
	00		 mov	 DWORD PTR [ecx+7920], eax
  0084b	89 91 f4 1e 00
	00		 mov	 DWORD PTR [ecx+7924], edx

; 468  : 				
; 469  : 				// Encrypted area size and length
; 470  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_START);

  00851	6a 6c		 push	 108			; 0000006cH
  00853	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  00859	52		 push	 edx
  0085a	e8 00 00 00 00	 call	 _GetHeaderField64@8
  0085f	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00862	89 81 f8 1e 00
	00		 mov	 DWORD PTR [ecx+7928], eax
  00868	89 91 fc 1e 00
	00		 mov	 DWORD PTR [ecx+7932], edx

; 471  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  0086e	6a 74		 push	 116			; 00000074H
  00870	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  00876	52		 push	 edx
  00877	e8 00 00 00 00	 call	 _GetHeaderField64@8
  0087c	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0087f	89 81 00 1f 00
	00		 mov	 DWORD PTR [ecx+7936], eax
  00885	89 91 04 1f 00
	00		 mov	 DWORD PTR [ecx+7940], edx

; 472  : 
; 473  : 				// Flags
; 474  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, GST_HEADER_OFFSET_FLAGS);

  0088b	6a 7c		 push	 124			; 0000007cH
  0088d	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  00893	52		 push	 edx
  00894	e8 00 00 00 00	 call	 _GetHeaderField32@8
  00899	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0089c	89 81 08 1f 00
	00		 mov	 DWORD PTR [ecx+7944], eax

; 475  : 
; 476  : 				// Sector size
; 477  : 				if (headerVersion >= 5)

  008a2	0f b7 95 e0 fe
	ff ff		 movzx	 edx, WORD PTR _headerVersion$[ebp]
  008a9	83 fa 05	 cmp	 edx, 5
  008ac	7c 1c		 jl	 SHORT $LN29@ReadVolume

; 478  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, GST_HEADER_OFFSET_SECTOR_SIZE);

  008ae	68 80 00 00 00	 push	 128			; 00000080H
  008b3	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  008b9	50		 push	 eax
  008ba	e8 00 00 00 00	 call	 _GetHeaderField32@8
  008bf	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  008c2	89 81 e8 1e 00
	00		 mov	 DWORD PTR [ecx+7912], eax

; 479  : 				else

  008c8	eb 0d		 jmp	 SHORT $LN28@ReadVolume
$LN29@ReadVolume:

; 480  : 					cryptoInfo->SectorSize = GST_SECTOR_SIZE_LEGACY;

  008ca	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  008cd	c7 82 e8 1e 00
	00 00 02 00 00	 mov	 DWORD PTR [edx+7912], 512 ; 00000200H
$LN28@ReadVolume:

; 481  : 
; 482  : 				if (cryptoInfo->SectorSize < GST_MIN_VOLUME_SECTOR_SIZE
; 483  : 					|| cryptoInfo->SectorSize > GST_MAX_VOLUME_SECTOR_SIZE
; 484  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  008d7	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  008da	81 b8 e8 1e 00
	00 00 02 00 00	 cmp	 DWORD PTR [eax+7912], 512 ; 00000200H
  008e4	72 25		 jb	 SHORT $LN26@ReadVolume
  008e6	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  008e9	81 b9 e8 1e 00
	00 00 10 00 00	 cmp	 DWORD PTR [ecx+7912], 4096 ; 00001000H
  008f3	77 16		 ja	 SHORT $LN26@ReadVolume
  008f5	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  008f8	8b 82 e8 1e 00
	00		 mov	 eax, DWORD PTR [edx+7912]
  008fe	33 d2		 xor	 edx, edx
  00900	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00905	f7 f1		 div	 ecx
  00907	85 d2		 test	 edx, edx
  00909	74 0f		 je	 SHORT $LN27@ReadVolume
$LN26@ReadVolume:

; 485  : 				{
; 486  : 					status = ERR_PARAMETER_INCORRECT;

  0090b	c7 85 2c fd ff
	ff 1e 00 00 00	 mov	 DWORD PTR _status$[ebp], 30 ; 0000001eH

; 487  : 					goto err;

  00915	e9 74 01 00 00	 jmp	 $err$26709
$LN27@ReadVolume:

; 488  : 				}
; 489  : 
; 490  : 				// Preserve scheduled header keys if requested			
; 491  : 				if (retHeaderCryptoInfo)

  0091a	83 7d 18 00	 cmp	 DWORD PTR _retHeaderCryptoInfo$[ebp], 0
  0091e	74 65		 je	 SHORT $LN25@ReadVolume

; 492  : 				{
; 493  : 					if (retInfo == NULL)

  00920	83 7d 14 00	 cmp	 DWORD PTR _retInfo$[ebp], 0
  00924	75 23		 jne	 SHORT $LN24@ReadVolume

; 494  : 					{
; 495  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  00926	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00929	8b 85 24 fd ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$[ebp]
  0092f	89 82 94 1e 00
	00		 mov	 DWORD PTR [edx+7828], eax

; 496  : 						cryptoInfo->noIterations = keyInfo.noIterations;

  00935	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00938	8b 95 40 fd ff
	ff		 mov	 edx, DWORD PTR _keyInfo$[ebp]
  0093e	89 91 90 1e 00
	00		 mov	 DWORD PTR [ecx+7824], edx

; 497  : 						goto ret;

  00944	e9 5f 01 00 00	 jmp	 $ret$26727
$LN24@ReadVolume:

; 498  : 					}
; 499  : 
; 500  : 					cryptoInfo = *retInfo = crypto_open ();

  00949	e8 00 00 00 00	 call	 _crypto_open@0
  0094e	8b 4d 14	 mov	 ecx, DWORD PTR _retInfo$[ebp]
  00951	89 01		 mov	 DWORD PTR [ecx], eax
  00953	8b 55 14	 mov	 edx, DWORD PTR _retInfo$[ebp]
  00956	8b 02		 mov	 eax, DWORD PTR [edx]
  00958	89 45 fc	 mov	 DWORD PTR _cryptoInfo$[ebp], eax

; 501  : 					if (cryptoInfo == NULL)

  0095b	83 7d fc 00	 cmp	 DWORD PTR _cryptoInfo$[ebp], 0
  0095f	75 0f		 jne	 SHORT $LN23@ReadVolume

; 502  : 					{
; 503  : 						status = ERR_OUTOFMEMORY;

  00961	c7 85 2c fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _status$[ebp], 2

; 504  : 						goto err;

  0096b	e9 1e 01 00 00	 jmp	 $err$26709
$LN23@ReadVolume:

; 505  : 					}
; 506  : 
; 507  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  00970	68 10 1f 00 00	 push	 7952			; 00001f10H
  00975	8b 4d 18	 mov	 ecx, DWORD PTR _retHeaderCryptoInfo$[ebp]
  00978	51		 push	 ecx
  00979	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0097c	52		 push	 edx
  0097d	e8 00 00 00 00	 call	 _memcpy
  00982	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@ReadVolume:

; 508  : 				}
; 509  : 
; 510  : 				// Master key data
; 511  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);

  00985	8d b5 20 fc ff
	ff		 lea	 esi, DWORD PTR _header$[ebp+256]
  0098b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00990	8d bd c8 fd ff
	ff		 lea	 edi, DWORD PTR _keyInfo$[ebp+136]
  00996	f3 a5		 rep movsd

; 512  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  00998	8b 7d fc	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]
  0099b	81 c7 50 1c 00
	00		 add	 edi, 7248		; 00001c50H
  009a1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  009a6	8d b5 c8 fd ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+136]
  009ac	f3 a5		 rep movsd

; 513  : 
; 514  : 				// PKCS #5
; 515  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);

  009ae	8b 7d fc	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]
  009b1	81 c7 50 1e 00
	00		 add	 edi, 7760		; 00001e50H
  009b7	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  009bc	8d b5 88 fd ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+72]
  009c2	f3 a5		 rep movsd

; 516  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  009c4	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  009c7	8b 8d 24 fd ff
	ff		 mov	 ecx, DWORD PTR _pkcs5_prf$[ebp]
  009cd	89 88 94 1e 00
	00		 mov	 DWORD PTR [eax+7828], ecx

; 517  : 				cryptoInfo->noIterations = keyInfo.noIterations;

  009d3	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  009d6	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  009dc	89 82 90 1e 00
	00		 mov	 DWORD PTR [edx+7824], eax

; 518  : 
; 519  : 				// Init the cipher with the decrypted master key
; 520  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  009e2	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  009e5	83 c1 08	 add	 ecx, 8
  009e8	51		 push	 ecx
  009e9	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _primaryKeyOffset$[ebp]
  009ef	8d 84 15 c8 fd
	ff ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+edx+136]
  009f6	50		 push	 eax
  009f7	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  009fa	8b 11		 mov	 edx, DWORD PTR [ecx]
  009fc	52		 push	 edx
  009fd	e8 00 00 00 00	 call	 _EAInit@12
  00a02	89 85 2c fd ff
	ff		 mov	 DWORD PTR _status$[ebp], eax

; 521  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00a08	83 bd 2c fd ff
	ff 11		 cmp	 DWORD PTR _status$[ebp], 17 ; 00000011H
  00a0f	75 02		 jne	 SHORT $LN22@ReadVolume

; 522  : 					goto err;

  00a11	eb 7b		 jmp	 SHORT $err$26709
$LN22@ReadVolume:

; 523  : 
; 524  : 				switch (cryptoInfo->mode)

  00a13	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00a16	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a19	89 8d d4 fa ff
	ff		 mov	 DWORD PTR tv439[ebp], ecx

; 525  : 				{
; 526  : 				default:
; 527  : 					// The secondary master key (if cascade, multiple concatenated)
; 528  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00a1f	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00a22	8b 02		 mov	 eax, DWORD PTR [edx]
  00a24	50		 push	 eax
  00a25	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00a2a	50		 push	 eax
  00a2b	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00a2e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a30	52		 push	 edx
  00a31	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00a36	8d 84 05 c8 fd
	ff ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+eax+136]
  00a3d	50		 push	 eax
  00a3e	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00a41	81 c1 50 1d 00
	00		 add	 ecx, 7504		; 00001d50H
  00a47	51		 push	 ecx
  00a48	e8 00 00 00 00	 call	 _memcpy
  00a4d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 529  : 
; 530  : 				}
; 531  : 
; 532  : 				if (!EAInitMode (cryptoInfo))

  00a50	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00a53	52		 push	 edx
  00a54	e8 00 00 00 00	 call	 _EAInitMode@4
  00a59	85 c0		 test	 eax, eax
  00a5b	75 0c		 jne	 SHORT $LN18@ReadVolume

; 533  : 				{
; 534  : 					status = ERR_MODE_INIT_FAILED;

  00a5d	c7 85 2c fd ff
	ff 1b 00 00 00	 mov	 DWORD PTR _status$[ebp], 27 ; 0000001bH

; 535  : 					goto err;

  00a67	eb 25		 jmp	 SHORT $err$26709
$LN18@ReadVolume:

; 536  : 				}
; 537  : 
; 538  : 				status = ERR_SUCCESS;

  00a69	c7 85 2c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _status$[ebp], 0

; 539  : 				goto ret;

  00a73	eb 33		 jmp	 SHORT $ret$26727

; 540  : 			}

  00a75	e9 93 fa ff ff	 jmp	 $LN43@ReadVolume
$LN42@ReadVolume:

; 541  : 		}

  00a7a	e9 50 fa ff ff	 jmp	 $LN49@ReadVolume
$LN48@ReadVolume:

; 542  : 	}

  00a7f	e9 d5 f6 ff ff	 jmp	 $LN75@ReadVolume
$LN74@ReadVolume:

; 543  : 	status = ERR_PASSWORD_WRONG;

  00a84	c7 85 2c fd ff
	ff 03 00 00 00	 mov	 DWORD PTR _status$[ebp], 3
$err$26709:

; 544  : 
; 545  : err:
; 546  : 	if (cryptoInfo != retHeaderCryptoInfo)

  00a8e	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00a91	3b 45 18	 cmp	 eax, DWORD PTR _retHeaderCryptoInfo$[ebp]
  00a94	74 12		 je	 SHORT $ret$26727

; 547  : 	{
; 548  : 		crypto_close(cryptoInfo);

  00a96	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00a99	51		 push	 ecx
  00a9a	e8 00 00 00 00	 call	 _crypto_close@4

; 549  : 		*retInfo = NULL; 

  00a9f	8b 55 14	 mov	 edx, DWORD PTR _retInfo$[ebp]
  00aa2	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$ret$26727:

; 550  : 	}
; 551  : 
; 552  : ret:
; 553  : 	burn (&keyInfo, sizeof (keyInfo));

  00aa8	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  00aae	89 85 14 fb ff
	ff		 mov	 DWORD PTR _burnm$26742[ebp], eax
  00ab4	c7 85 18 fb ff
	ff 88 01 00 00	 mov	 DWORD PTR _burnc$26744[ebp], 392 ; 00000188H
  00abe	68 88 01 00 00	 push	 392			; 00000188H
  00ac3	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp]
  00ac9	51		 push	 ecx
  00aca	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN13@ReadVolume:
  00acf	8b 95 18 fb ff
	ff		 mov	 edx, DWORD PTR _burnc$26744[ebp]
  00ad5	8b 85 18 fb ff
	ff		 mov	 eax, DWORD PTR _burnc$26744[ebp]
  00adb	83 e8 01	 sub	 eax, 1
  00ade	89 85 18 fb ff
	ff		 mov	 DWORD PTR _burnc$26744[ebp], eax
  00ae4	85 d2		 test	 edx, edx
  00ae6	74 1a		 je	 SHORT $LN15@ReadVolume
  00ae8	8b 8d 14 fb ff
	ff		 mov	 ecx, DWORD PTR _burnm$26742[ebp]
  00aee	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00af1	8b 95 14 fb ff
	ff		 mov	 edx, DWORD PTR _burnm$26742[ebp]
  00af7	83 c2 01	 add	 edx, 1
  00afa	89 95 14 fb ff
	ff		 mov	 DWORD PTR _burnm$26742[ebp], edx
  00b00	eb cd		 jmp	 SHORT $LN13@ReadVolume
$LN15@ReadVolume:
  00b02	33 c0		 xor	 eax, eax
  00b04	75 a2		 jne	 SHORT $ret$26727
$LN11@ReadVolume:

; 554  : 	burn (dk, sizeof(dk));

  00b06	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _dk$[ebp]
  00b0c	89 8d 0c fb ff
	ff		 mov	 DWORD PTR _burnm$26751[ebp], ecx
  00b12	c7 85 10 fb ff
	ff 00 01 00 00	 mov	 DWORD PTR _burnc$26753[ebp], 256 ; 00000100H
  00b1c	68 00 01 00 00	 push	 256			; 00000100H
  00b21	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _dk$[ebp]
  00b27	52		 push	 edx
  00b28	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN8@ReadVolume:
  00b2d	8b 85 10 fb ff
	ff		 mov	 eax, DWORD PTR _burnc$26753[ebp]
  00b33	8b 8d 10 fb ff
	ff		 mov	 ecx, DWORD PTR _burnc$26753[ebp]
  00b39	83 e9 01	 sub	 ecx, 1
  00b3c	89 8d 10 fb ff
	ff		 mov	 DWORD PTR _burnc$26753[ebp], ecx
  00b42	85 c0		 test	 eax, eax
  00b44	74 1a		 je	 SHORT $LN10@ReadVolume
  00b46	8b 95 0c fb ff
	ff		 mov	 edx, DWORD PTR _burnm$26751[ebp]
  00b4c	c6 02 00	 mov	 BYTE PTR [edx], 0
  00b4f	8b 85 0c fb ff
	ff		 mov	 eax, DWORD PTR _burnm$26751[ebp]
  00b55	83 c0 01	 add	 eax, 1
  00b58	89 85 0c fb ff
	ff		 mov	 DWORD PTR _burnm$26751[ebp], eax
  00b5e	eb cd		 jmp	 SHORT $LN8@ReadVolume
$LN10@ReadVolume:
  00b60	33 c9		 xor	 ecx, ecx
  00b62	75 a2		 jne	 SHORT $LN11@ReadVolume

; 555  : 
; 556  : #ifndef DEVICE_DRIVER
; 557  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));
; 558  : 	VirtualUnlock (&dk, sizeof (dk));
; 559  : #endif
; 560  : 
; 561  : 	if (encryptionThreadCount > 1)

  00b64	83 bd dc fe ff
	ff 01		 cmp	 DWORD PTR _encryptionThreadCount$[ebp], 1
  00b6b	0f 86 95 00 00
	00		 jbe	 $LN6@ReadVolume

; 562  : 	{
; 563  : 		GST_WAIT_EVENT (noOutstandingWorkItemEvent);

  00b71	6a 00		 push	 0
  00b73	6a 00		 push	 0
  00b75	6a 00		 push	 0
  00b77	6a 00		 push	 0
  00b79	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  00b7f	52		 push	 edx
  00b80	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN5@ReadVolume:

; 564  : 
; 565  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00b86	8b 85 3c fd ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$[ebp]
  00b8c	89 85 04 fb ff
	ff		 mov	 DWORD PTR _burnm$26762[ebp], eax
  00b92	8b 8d 28 fd ff
	ff		 mov	 ecx, DWORD PTR _pkcs5PrfCount$[ebp]
  00b98	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  00b9e	89 8d 08 fb ff
	ff		 mov	 DWORD PTR _burnc$26764[ebp], ecx
  00ba4	8b 95 28 fd ff
	ff		 mov	 edx, DWORD PTR _pkcs5PrfCount$[ebp]
  00baa	69 d2 0c 01 00
	00		 imul	 edx, 268		; 0000010cH
  00bb0	52		 push	 edx
  00bb1	8b 85 3c fd ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$[ebp]
  00bb7	50		 push	 eax
  00bb8	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@ReadVolume:
  00bbd	8b 8d 08 fb ff
	ff		 mov	 ecx, DWORD PTR _burnc$26764[ebp]
  00bc3	8b 95 08 fb ff
	ff		 mov	 edx, DWORD PTR _burnc$26764[ebp]
  00bc9	83 ea 01	 sub	 edx, 1
  00bcc	89 95 08 fb ff
	ff		 mov	 DWORD PTR _burnc$26764[ebp], edx
  00bd2	85 c9		 test	 ecx, ecx
  00bd4	74 1a		 je	 SHORT $LN4@ReadVolume
  00bd6	8b 85 04 fb ff
	ff		 mov	 eax, DWORD PTR _burnm$26762[ebp]
  00bdc	c6 00 00	 mov	 BYTE PTR [eax], 0
  00bdf	8b 8d 04 fb ff
	ff		 mov	 ecx, DWORD PTR _burnm$26762[ebp]
  00be5	83 c1 01	 add	 ecx, 1
  00be8	89 8d 04 fb ff
	ff		 mov	 DWORD PTR _burnm$26762[ebp], ecx
  00bee	eb cd		 jmp	 SHORT $LN2@ReadVolume
$LN4@ReadVolume:
  00bf0	33 d2		 xor	 edx, edx
  00bf2	75 92		 jne	 SHORT $LN5@ReadVolume

; 566  : 		GSTfree (keyDerivationWorkItems);

  00bf4	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00bf9	8b 85 3c fd ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$[ebp]
  00bff	50		 push	 eax
  00c00	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN6@ReadVolume:

; 567  : 
; 568  : #ifndef DEVICE_DRIVER
; 569  : 		CloseHandle (keyDerivationCompletedEvent);
; 570  : 		CloseHandle (noOutstandingWorkItemEvent);
; 571  : #endif
; 572  : 	}
; 573  : 
; 574  : 	return status;

  00c06	8b 85 2c fd ff
	ff		 mov	 eax, DWORD PTR _status$[ebp]
$LN86@ReadVolume:

; 575  : }

  00c0c	5f		 pop	 edi
  00c0d	5e		 pop	 esi
  00c0e	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c11	33 cd		 xor	 ecx, ebp
  00c13	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c18	8b e5		 mov	 esp, ebp
  00c1a	5d		 pop	 ebp
  00c1b	c2 14 00	 ret	 20			; 00000014H
_ReadVolumeHeader@20 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
END
