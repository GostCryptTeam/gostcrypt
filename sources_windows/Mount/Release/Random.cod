; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\Random.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_hMouse
PUBLIC	_hKeyboard
PUBLIC	_bThreadTerminate
PUBLIC	_hNetAPI32
PUBLIC	_CryptoAPIAvailable
PUBLIC	_bFastPollEnabled
PUBLIC	_bRandmixEnabled
PUBLIC	_pNetStatisticsGet
PUBLIC	_pNetApiBufferSize
PUBLIC	_pNetApiBufferFree
_BSS	SEGMENT
_hMouse	DD	01H DUP (?)
_hKeyboard DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_critRandProt:BYTE:018H
_DATA	ENDS
_BSS	SEGMENT
_bThreadTerminate DD 01H DUP (?)
_hNetAPI32 DD	01H DUP (?)
_CryptoAPIAvailable DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_hCryptProv:DWORD
_DATA	ENDS
_BSS	SEGMENT
_pNetStatisticsGet DD 01H DUP (?)
_pNetApiBufferSize DD 01H DUP (?)
_pNetApiBufferFree DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_bFastPollEnabled DD 01H
_bRandmixEnabled DD 01H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	_RandAddInt
PUBLIC	_Randinit
PUBLIC	_RandStop
PUBLIC	_IsRandomNumberGeneratorStarted
PUBLIC	_RandSetHashFunction
PUBLIC	_RandGetHashFunction
PUBLIC	_SetRandomPoolEnrichedByUserStatus
PUBLIC	_IsRandomPoolEnrichedByUser
PUBLIC	_Randmix
PUBLIC	_RandaddBuf
PUBLIC	_FastPoll
PUBLIC	_SlowPoll
PUBLIC	_RandpeekBytes
PUBLIC	_RandgetBytes
PUBLIC	_MouseProc@12
PUBLIC	_KeyboardProc@12
PUBLIC	??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@ ; `string'
PUBLIC	??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0M@GGPOPAAP@ProductType?$AA@		; `string'
PUBLIC	??_C@_05LELOMLIF@WinNT?$AA@			; `string'
PUBLIC	??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@		; `string'
PUBLIC	??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@	; `string'
PUBLIC	??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@	; `string'
PUBLIC	??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@	; `string'
PUBLIC	??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@ ; `string'
PUBLIC	__xmm@ffffffffffffffffffffffffffffffff
EXTRN	__stricmp:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetProcessTimes@20:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__GetThreadTimes@20:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryExA@12:PROC
EXTRN	__imp__GlobalMemoryStatus@4:PROC
EXTRN	__imp__GetProcessWorkingSetSize@12:PROC
EXTRN	__imp__GetStartupInfoA@4:PROC
EXTRN	__imp__GetProcessWindowStation@0:PROC
EXTRN	__imp__GetMessagePos@0:PROC
EXTRN	__imp__GetMessageTime@0:PROC
EXTRN	__imp__GetClipboardOwner@0:PROC
EXTRN	__imp__GetClipboardViewer@0:PROC
EXTRN	__imp__GetOpenClipboardWindow@0:PROC
EXTRN	__imp__GetActiveWindow@0:PROC
EXTRN	__imp__GetFocus@0:PROC
EXTRN	__imp__GetInputState@0:PROC
EXTRN	__imp__GetQueueStatus@4:PROC
EXTRN	__imp__GetCapture@0:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__GetCaretPos@4:PROC
EXTRN	__imp__GetDesktopWindow@0:PROC
EXTRN	__imp__SetWindowsHookExA@16:PROC
EXTRN	__imp__UnhookWindowsHookEx@4:PROC
EXTRN	__imp__CallNextHookEx@16:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__CryptAcquireContextA@20:PROC
EXTRN	__imp__CryptReleaseContext@8:PROC
EXTRN	__imp__CryptGenRandom@12:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__beginthreadex:PROC
EXTRN	__endthreadex:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_crc32int:PROC
EXTRN	_STRIBOG_init:PROC
EXTRN	_STRIBOG_add:PROC
EXTRN	_STRIBOG_finalize:PROC
EXTRN	_WHIRLPOOL_add:PROC
EXTRN	_WHIRLPOOL_finalize:PROC
EXTRN	_WHIRLPOOL_init:PROC
EXTRN	_GOSTHASH_init:PROC
EXTRN	_GOSTHASH_add:PROC
EXTRN	_GOSTHASH_finalize:PROC
EXTRN	_HashIsDeprecated:PROC
EXTRN	_GetMaxPkcs5OutSize:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	_Error:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_crc_32_tab:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_buffer	DB	0140H DUP (?)
_pRandPool DD	01H DUP (?)
_bRandDidInit DD 01H DUP (?)
_nRandIndex DD	01H DUP (?)
_randPoolReadIndex DD 01H DUP (?)
_bDidSlowPoll DD 01H DUP (?)
_RandomPoolEnrichedByUser DD 01H DUP (?)
_PeriodicFastPollThreadHandle DD 01H DUP (?)
?dwLastTimer@?1??MouseProc@@9@9 DD 01H DUP (?)		; `MouseProc'::`2'::dwLastTimer
?lastCrc@?1??MouseProc@@9@9 DD 01H DUP (?)		; `MouseProc'::`2'::lastCrc
?lastCrc2@?1??MouseProc@@9@9 DD 01H DUP (?)		; `MouseProc'::`2'::lastCrc2
?lLastKey@?1??KeyboardProc@@9@9 DD 01H DUP (?)		; `KeyboardProc'::`2'::lLastKey
?lLastKey2@?1??KeyboardProc@@9@9 DD 01H DUP (?)		; `KeyboardProc'::`2'::lLastKey2
?dwLastTimer@?1??KeyboardProc@@9@9 DD 01H DUP (?)	; `KeyboardProc'::`2'::dwLastTimer
?addedFixedItems@?1??FastPoll@@9@9 DD 01H DUP (?)	; `FastPoll'::`2'::addedFixedItems
_BSS	ENDS
;	COMDAT __xmm@ffffffffffffffffffffffffffffffff
CONST	SEGMENT
__xmm@ffffffffffffffffffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT ??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@ DB '\\.\PhysicalDrive%'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@ DB 'L'
	DB	00H, 'a', 00H, 'n', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'S', 00H
	DB	'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'L'
	DB	00H, 'a', 00H, 'n', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'W', 00H
	DB	'o', 00H, 'r', 00H, 'k', 00H, 's', 00H, 't', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@
CONST	SEGMENT
??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@ DB 'NetApiBufferFree', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@
CONST	SEGMENT
??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@ DB 'NetApiBufferSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@
CONST	SEGMENT
??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@ DB 'NetStatisticsGet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@
CONST	SEGMENT
??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@ DB 'NETAPI32.DLL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LELOMLIF@WinNT?$AA@
CONST	SEGMENT
??_C@_05LELOMLIF@WinNT?$AA@ DB 'WinNT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGPOPAAP@ProductType?$AA@
CONST	SEGMENT
??_C@_0M@GGPOPAAP@ProductType?$AA@ DB 'ProductType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\ProductOptions', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@
CONST	SEGMENT
??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@ DB 'ERR_NOT_ENOUGH_RAN'
	DB	'DOM_DATA', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_HashFunction DD 01H
?isWorkstation@?1??SlowPoll@@9@9 DD 0ffffffffH		; `SlowPoll'::`2'::isWorkstation
_DATA	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _PeriodicFastPollThreadProc@4
_TEXT	SEGMENT
_startupInfo$1 = -164					; size = 68
_performanceCount$2 = -96				; size = 8
_userTime$3 = -88					; size = 8
_kernelTime$4 = -80					; size = 8
_exitTime$5 = -72					; size = 8
_creationTime$6 = -64					; size = 8
_point$7 = -56						; size = 8
_dwTicks$8 = -48					; size = 4
_maximumWorkingSetSize$9 = -44				; size = 4
_minimumWorkingSetSize$10 = -40				; size = 4
_memoryStatus$11 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_dummy$ = 8						; size = 4
_PeriodicFastPollThreadProc@4 PROC			; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  0001b	57		 push	 edi
  0001c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__LeaveCriticalSection@4
$LL2@PeriodicFa:

; 626  : 	if (dummy);		/* Remove unused parameter warning */
; 627  : 
; 628  : 	for (;;)
; 629  : 	{
; 630  : 		EnterCriticalSection (&critRandProt);

  00022	68 00 00 00 00	 push	 OFFSET _critRandProt
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 631  : 
; 632  : 		if (bThreadTerminate)

  0002d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bThreadTerminate, 0
  00034	74 20		 je	 SHORT $LN6@PeriodicFa

; 633  : 		{
; 634  : 			bThreadTerminate = FALSE;
; 635  : 			LeaveCriticalSection (&critRandProt);

  00036	68 00 00 00 00	 push	 OFFSET _critRandProt
  0003b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bThreadTerminate, 0
  00045	ff d7		 call	 edi

; 636  : 			_endthreadex (0);

  00047	6a 00		 push	 0
  00049	e8 00 00 00 00	 call	 __endthreadex
  0004e	83 c4 04	 add	 esp, 4

; 637  : 		}

  00051	e9 e2 02 00 00	 jmp	 $LN8@PeriodicFa
$LN6@PeriodicFa:

; 638  : 		else if (bFastPollEnabled)

  00056	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bFastPollEnabled, 0
  0005d	0f 84 d5 02 00
	00		 je	 $LN8@PeriodicFa

; 639  : 		{
; 640  : 			FastPoll ();

  00063	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _nRandIndex
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetActiveWindow@0
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _RandAddInt
  00075	83 c4 04	 add	 esp, 4
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCapture@0
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _RandAddInt
  00084	83 c4 04	 add	 esp, 4
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardOwner@0
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _RandAddInt
  00093	83 c4 04	 add	 esp, 4
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardViewer@0
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _RandAddInt
  000a2	83 c4 04	 add	 esp, 4
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _RandAddInt
  000b1	83 c4 04	 add	 esp, 4
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _RandAddInt
  000c0	83 c4 04	 add	 esp, 4
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _RandAddInt
  000cf	83 c4 04	 add	 esp, 4
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _RandAddInt
  000de	83 c4 04	 add	 esp, 4
  000e1	ff d6		 call	 esi
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _RandAddInt
  000e9	83 c4 04	 add	 esp, 4
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDesktopWindow@0
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _RandAddInt
  000f8	83 c4 04	 add	 esp, 4
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _RandAddInt
  00107	83 c4 04	 add	 esp, 4
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetInputState@0
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _RandAddInt
  00116	83 c4 04	 add	 esp, 4
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 _RandAddInt
  00125	83 c4 04	 add	 esp, 4
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessageTime@0
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _RandAddInt
  00134	83 c4 04	 add	 esp, 4
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetOpenClipboardWindow@0
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 _RandAddInt
  00143	83 c4 04	 add	 esp, 4
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _RandAddInt
  00152	83 c4 04	 add	 esp, 4
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessWindowStation@0
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 _RandAddInt
  00161	83 c4 04	 add	 esp, 4
  00164	68 bf 04 00 00	 push	 1215			; 000004bfH
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetQueueStatus@4
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 _RandAddInt
  00175	83 c4 04	 add	 esp, 4
  00178	8d 45 c8	 lea	 eax, DWORD PTR _point$7[ebp]
  0017b	50		 push	 eax
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCaretPos@4
  00182	8d 45 c8	 lea	 eax, DWORD PTR _point$7[ebp]
  00185	6a 08		 push	 8
  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 _RandaddBuf
  0018d	83 c4 08	 add	 esp, 8
  00190	8d 45 c8	 lea	 eax, DWORD PTR _point$7[ebp]
  00193	50		 push	 eax
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4
  0019a	8d 45 c8	 lea	 eax, DWORD PTR _point$7[ebp]
  0019d	6a 08		 push	 8
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 _RandaddBuf
  001a5	83 c4 08	 add	 esp, 8
  001a8	c7 45 dc 20 00
	00 00		 mov	 DWORD PTR _memoryStatus$11[ebp], 32 ; 00000020H
  001af	8d 45 dc	 lea	 eax, DWORD PTR _memoryStatus$11[ebp]
  001b2	50		 push	 eax
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatus@4
  001b9	8d 45 dc	 lea	 eax, DWORD PTR _memoryStatus$11[ebp]
  001bc	6a 20		 push	 32			; 00000020H
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 _RandaddBuf
  001c4	83 c4 08	 add	 esp, 8
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  001cd	8d 4d a8	 lea	 ecx, DWORD PTR _userTime$3[ebp]
  001d0	51		 push	 ecx
  001d1	8d 4d b0	 lea	 ecx, DWORD PTR _kernelTime$4[ebp]
  001d4	51		 push	 ecx
  001d5	8d 4d b8	 lea	 ecx, DWORD PTR _exitTime$5[ebp]
  001d8	51		 push	 ecx
  001d9	8d 4d c0	 lea	 ecx, DWORD PTR _creationTime$6[ebp]
  001dc	51		 push	 ecx
  001dd	50		 push	 eax
  001de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadTimes@20
  001e4	8d 45 c0	 lea	 eax, DWORD PTR _creationTime$6[ebp]
  001e7	6a 08		 push	 8
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 _RandaddBuf
  001ef	8d 45 b8	 lea	 eax, DWORD PTR _exitTime$5[ebp]
  001f2	6a 08		 push	 8
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 _RandaddBuf
  001fa	8d 45 b0	 lea	 eax, DWORD PTR _kernelTime$4[ebp]
  001fd	6a 08		 push	 8
  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 _RandaddBuf
  00205	8d 45 a8	 lea	 eax, DWORD PTR _userTime$3[ebp]
  00208	6a 08		 push	 8
  0020a	50		 push	 eax
  0020b	e8 00 00 00 00	 call	 _RandaddBuf
  00210	83 c4 20	 add	 esp, 32			; 00000020H
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00219	8b f0		 mov	 esi, eax
  0021b	8d 45 a8	 lea	 eax, DWORD PTR _userTime$3[ebp]
  0021e	50		 push	 eax
  0021f	8d 45 b0	 lea	 eax, DWORD PTR _kernelTime$4[ebp]
  00222	50		 push	 eax
  00223	8d 45 b8	 lea	 eax, DWORD PTR _exitTime$5[ebp]
  00226	50		 push	 eax
  00227	8d 45 c0	 lea	 eax, DWORD PTR _creationTime$6[ebp]
  0022a	50		 push	 eax
  0022b	56		 push	 esi
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessTimes@20
  00232	8d 45 c0	 lea	 eax, DWORD PTR _creationTime$6[ebp]
  00235	6a 08		 push	 8
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 _RandaddBuf
  0023d	8d 45 b8	 lea	 eax, DWORD PTR _exitTime$5[ebp]
  00240	6a 08		 push	 8
  00242	50		 push	 eax
  00243	e8 00 00 00 00	 call	 _RandaddBuf
  00248	8d 45 b0	 lea	 eax, DWORD PTR _kernelTime$4[ebp]
  0024b	6a 08		 push	 8
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 _RandaddBuf
  00253	8d 45 a8	 lea	 eax, DWORD PTR _userTime$3[ebp]
  00256	6a 08		 push	 8
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 _RandaddBuf
  0025e	83 c4 20	 add	 esp, 32			; 00000020H
  00261	8d 45 d4	 lea	 eax, DWORD PTR _maximumWorkingSetSize$9[ebp]
  00264	50		 push	 eax
  00265	8d 45 d8	 lea	 eax, DWORD PTR _minimumWorkingSetSize$10[ebp]
  00268	50		 push	 eax
  00269	56		 push	 esi
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessWorkingSetSize@12
  00270	ff 75 d8	 push	 DWORD PTR _minimumWorkingSetSize$10[ebp]
  00273	e8 00 00 00 00	 call	 _RandAddInt
  00278	ff 75 d4	 push	 DWORD PTR _maximumWorkingSetSize$9[ebp]
  0027b	e8 00 00 00 00	 call	 _RandAddInt
  00280	83 c4 08	 add	 esp, 8
  00283	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?addedFixedItems@?1??FastPoll@@9@9, 0
  0028a	75 32		 jne	 SHORT $LN11@PeriodicFa
  0028c	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _startupInfo$1[ebp]
  00292	c7 85 5c ff ff
	ff 44 00 00 00	 mov	 DWORD PTR _startupInfo$1[ebp], 68 ; 00000044H
  0029c	50		 push	 eax
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStartupInfoA@4
  002a3	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _startupInfo$1[ebp]
  002a9	6a 44		 push	 68			; 00000044H
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 _RandaddBuf
  002b1	83 c4 08	 add	 esp, 8
  002b4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?addedFixedItems@?1??FastPoll@@9@9, 1
$LN11@PeriodicFa:
  002be	8d 45 a0	 lea	 eax, DWORD PTR _performanceCount$2[ebp]
  002c1	50		 push	 eax
  002c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  002c8	85 c0		 test	 eax, eax
  002ca	74 13		 je	 SHORT $LN12@PeriodicFa
  002cc	8d 45 a0	 lea	 eax, DWORD PTR _performanceCount$2[ebp]
  002cf	6a 08		 push	 8
  002d1	50		 push	 eax
  002d2	e8 00 00 00 00	 call	 _RandaddBuf
  002d7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  002dd	eb 16		 jmp	 SHORT $LN19@PeriodicFa
$LN12@PeriodicFa:
  002df	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  002e5	ff d6		 call	 esi
  002e7	89 45 d0	 mov	 DWORD PTR _dwTicks$8[ebp], eax
  002ea	8d 45 d0	 lea	 eax, DWORD PTR _dwTicks$8[ebp]
  002ed	6a 04		 push	 4
  002ef	50		 push	 eax
  002f0	e8 00 00 00 00	 call	 _RandaddBuf
$LN19@PeriodicFa:
  002f5	83 c4 08	 add	 esp, 8
  002f8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CryptoAPIAvailable, 0
  002ff	74 2c		 je	 SHORT $LN14@PeriodicFa
  00301	68 00 00 00 00	 push	 OFFSET _buffer
  00306	68 40 01 00 00	 push	 320			; 00000140H
  0030b	ff 35 00 00 00
	00		 push	 DWORD PTR _hCryptProv
  00311	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGenRandom@12
  00317	85 c0		 test	 eax, eax
  00319	74 12		 je	 SHORT $LN14@PeriodicFa
  0031b	68 40 01 00 00	 push	 320			; 00000140H
  00320	68 00 00 00 00	 push	 OFFSET _buffer
  00325	e8 00 00 00 00	 call	 _RandaddBuf
  0032a	83 c4 08	 add	 esp, 8
$LN14@PeriodicFa:
  0032d	e8 00 00 00 00	 call	 _Randmix
  00332	89 1d 00 00 00
	00		 mov	 DWORD PTR _nRandIndex, ebx
$LN8@PeriodicFa:

; 641  : 		}
; 642  : 
; 643  : 		LeaveCriticalSection (&critRandProt);

  00338	68 00 00 00 00	 push	 OFFSET _critRandProt
  0033d	ff d7		 call	 edi

; 644  : 
; 645  : 		Sleep (FASTPOLL_INTERVAL);

  0033f	68 f4 01 00 00	 push	 500			; 000001f4H
  00344	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 646  : 	}

  0034a	e9 d3 fc ff ff	 jmp	 $LL2@PeriodicFa
_PeriodicFastPollThreadProc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _KeyboardProc@12
_TEXT	SEGMENT
_dwTimer$1 = -4						; size = 4
_j$2 = 8						; size = 4
_nCode$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
_KeyboardProc@12 PROC					; COMDAT

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 570  : 	static int lLastKey, lLastKey2;
; 571  : 	static DWORD dwLastTimer;
; 572  : 	int nKey = (lParam & 0x00ff0000) >> 16;

  00004	8b 4d 10	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00007	8b c1		 mov	 eax, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 573  : 	int nCapture = 0;
; 574  : 
; 575  : 	if (nCode < 0)

  0000b	8b 7d 08	 mov	 edi, DWORD PTR _nCode$[ebp]
  0000e	c1 f8 10	 sar	 eax, 16			; 00000010H
  00011	0f b6 f0	 movzx	 esi, al
  00014	85 ff		 test	 edi, edi
  00016	0f 88 19 01 00
	00		 js	 $LN13@KeyboardPr
  0001c	66 83 f9 01	 cmp	 cx, 1

; 576  : 		return CallNextHookEx (hMouse, nCode, wParam, lParam);
; 577  : 
; 578  : 	if ((lParam & 0x0000ffff) == 1 && !(lParam & 0x20000000) &&

  00020	0f 85 0f 01 00
	00		 jne	 $LN13@KeyboardPr
  00026	8b c1		 mov	 eax, ecx
  00028	25 00 00 00 a0	 and	 eax, -1610612736	; a0000000H
  0002d	3d 00 00 00 80	 cmp	 eax, -2147483648	; 80000000H
  00032	0f 85 fd 00 00
	00		 jne	 $LN13@KeyboardPr

; 579  : 	    (lParam & 0x80000000))
; 580  : 	{
; 581  : 		if (nKey != lLastKey)

  00038	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lLastKey@?1??KeyboardProc@@9@9
  0003e	75 0c		 jne	 SHORT $LN31@KeyboardPr

; 582  : 			nCapture = 1;	/* Capture this key */
; 583  : 		else if (nKey != lLastKey2)

  00040	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lLastKey2@?1??KeyboardProc@@9@9
  00046	0f 84 e9 00 00
	00		 je	 $LN13@KeyboardPr
$LN31@KeyboardPr:
  0004c	53		 push	 ebx

; 584  : 			nCapture = 1;	/* Allow for one repeat */
; 585  : 	}
; 586  : 	if (nCapture)
; 587  : 	{
; 588  : 		DWORD dwTimer = GetTickCount ();

  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 589  : 		DWORD j = dwLastTimer - dwTimer;

  00053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwLastTimer@?1??KeyboardProc@@9@9
  00059	8b d8		 mov	 ebx, eax

; 590  : 		unsigned __int32 timeCrc = 0L;
; 591  : 		int i;
; 592  : 
; 593  : 		dwLastTimer = dwTimer;
; 594  : 		lLastKey2 = lLastKey;

  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lLastKey@?1??KeyboardProc@@9@9
  00061	2b d3		 sub	 edx, ebx

; 595  : 		lLastKey = nKey;

  00063	89 35 00 00 00
	00		 mov	 DWORD PTR ?lLastKey@?1??KeyboardProc@@9@9, esi

; 596  : 
; 597  : 		for (i = 0; i < 4; i++)
; 598  : 		{
; 599  : 			timeCrc = UPDC32 (((unsigned char *) &j)[i], timeCrc);

  00069	0f b6 c2	 movzx	 eax, dl
  0006c	89 55 08	 mov	 DWORD PTR _j$2[ebp], edx
  0006f	89 5d fc	 mov	 DWORD PTR _dwTimer$1[ebp], ebx

; 600  : 		}
; 601  : 
; 602  : 		for (i = 0; i < 4; i++)
; 603  : 		{
; 604  : 			timeCrc = UPDC32 (((unsigned char *) &dwTimer)[i], timeCrc);
; 605  : 		}
; 606  : 
; 607  : 		EnterCriticalSection (&critRandProt);

  00072	68 00 00 00 00	 push	 OFFSET _critRandProt
  00077	8b 34 85 00 00
	00 00		 mov	 esi, DWORD PTR _crc_32_tab[eax*4]
  0007e	0f b6 c6	 movzx	 eax, dh
  00081	33 c6		 xor	 eax, esi
  00083	89 1d 00 00 00
	00		 mov	 DWORD PTR ?dwLastTimer@?1??KeyboardProc@@9@9, ebx
  00089	0f b6 c0	 movzx	 eax, al
  0008c	c1 ee 08	 shr	 esi, 8
  0008f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lLastKey2@?1??KeyboardProc@@9@9, ecx
  00095	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  0009c	0f b6 45 0a	 movzx	 eax, BYTE PTR _j$2[ebp+2]
  000a0	33 c6		 xor	 eax, esi
  000a2	c1 ee 08	 shr	 esi, 8
  000a5	0f b6 c0	 movzx	 eax, al
  000a8	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  000af	0f b6 45 0b	 movzx	 eax, BYTE PTR _j$2[ebp+3]
  000b3	33 c6		 xor	 eax, esi
  000b5	c1 ee 08	 shr	 esi, 8
  000b8	0f b6 c0	 movzx	 eax, al
  000bb	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  000c2	0f b6 c3	 movzx	 eax, bl
  000c5	33 c6		 xor	 eax, esi
  000c7	c1 ee 08	 shr	 esi, 8
  000ca	0f b6 c0	 movzx	 eax, al
  000cd	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  000d4	0f b6 c7	 movzx	 eax, bh
  000d7	33 c6		 xor	 eax, esi
  000d9	c1 ee 08	 shr	 esi, 8
  000dc	0f b6 c0	 movzx	 eax, al
  000df	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  000e6	0f b6 45 fe	 movzx	 eax, BYTE PTR _dwTimer$1[ebp+2]
  000ea	33 c6		 xor	 eax, esi
  000ec	c1 ee 08	 shr	 esi, 8
  000ef	0f b6 c0	 movzx	 eax, al
  000f2	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  000f9	0f b6 45 ff	 movzx	 eax, BYTE PTR _dwTimer$1[ebp+3]
  000fd	33 c6		 xor	 eax, esi
  000ff	c1 ee 08	 shr	 esi, 8
  00102	0f b6 c0	 movzx	 eax, al
  00105	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 608  : 		RandaddInt32 ((unsigned __int32) (crc32int(&lParam) + timeCrc));

  00112	8d 45 10	 lea	 eax, DWORD PTR _lParam$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _crc32int
  0011b	03 c6		 add	 eax, esi
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 _RandAddInt
  00123	83 c4 08	 add	 esp, 8

; 609  : 		LeaveCriticalSection (&critRandProt);

  00126	68 00 00 00 00	 push	 OFFSET _critRandProt
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00131	8b 4d 10	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00134	5b		 pop	 ebx
$LN13@KeyboardPr:

; 610  : 	}
; 611  : 
; 612  : 	return CallNextHookEx (hMouse, nCode, wParam, lParam);

  00135	51		 push	 ecx
  00136	ff 75 0c	 push	 DWORD PTR _wParam$[ebp]
  00139	57		 push	 edi
  0013a	ff 35 00 00 00
	00		 push	 DWORD PTR _hMouse
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi

; 613  : }

  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c2 0c 00	 ret	 12			; 0000000cH
_KeyboardProc@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _MouseProc@12
_TEXT	SEGMENT
_j$1$ = -4						; size = 4
_j$1 = 8						; size = 4
_nCode$ = 8						; size = 4
_dwTimer$2 = 12						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
_MouseProc@12 PROC					; COMDAT

; 506  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 507  : 	static DWORD dwLastTimer;
; 508  : 	static unsigned __int32 lastCrc, lastCrc2;
; 509  : 	MOUSEHOOKSTRUCT *lpMouse = (MOUSEHOOKSTRUCT *) lParam;
; 510  : 
; 511  : 	if (nCode < 0)

  00004	8b 45 08	 mov	 eax, DWORD PTR _nCode$[ebp]
  00007	85 c0		 test	 eax, eax
  00009	79 19		 jns	 SHORT $LN11@MouseProc

; 512  : 		return CallNextHookEx (hMouse, nCode, wParam, lParam);

  0000b	ff 75 10	 push	 DWORD PTR _lParam$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR _wParam$[ebp]
  00011	50		 push	 eax
  00012	ff 35 00 00 00
	00		 push	 DWORD PTR _hMouse
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16

; 550  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
$LN11@MouseProc:
  00024	53		 push	 ebx
  00025	56		 push	 esi

; 513  : 	else
; 514  : 	{
; 515  : 		DWORD dwTimer = GetTickCount ();

  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _lParam$[ebp]
  0002f	8b d8		 mov	 ebx, eax

; 516  : 		DWORD j = dwLastTimer - dwTimer;

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwLastTimer@?1??MouseProc@@9@9

; 517  : 		unsigned __int32 crc = 0L;

  00036	33 f6		 xor	 esi, esi
  00038	2b c3		 sub	 eax, ebx
  0003a	89 5d 0c	 mov	 DWORD PTR _dwTimer$2[ebp], ebx
  0003d	89 45 fc	 mov	 DWORD PTR _j$1$[ebp], eax
  00040	41		 inc	 ecx
  00041	89 45 08	 mov	 DWORD PTR _j$1[ebp], eax

; 518  : 		int i;
; 519  : 
; 520  : 		dwLastTimer = dwTimer;

  00044	89 1d 00 00 00
	00		 mov	 DWORD PTR ?dwLastTimer@?1??MouseProc@@9@9, ebx
  0004a	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  0004d	0f 1f 00	 npad	 3
$LL4@MouseProc:

; 521  : 
; 522  : 		for (i = 0; i < sizeof (MOUSEHOOKSTRUCT); i++)
; 523  : 		{
; 524  : 			crc = UPDC32 (((unsigned char *) lpMouse)[i], crc);

  00050	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00054	8d 49 05	 lea	 ecx, DWORD PTR [ecx+5]
  00057	33 c6		 xor	 eax, esi
  00059	c1 ee 08	 shr	 esi, 8
  0005c	0f b6 c0	 movzx	 eax, al
  0005f	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  00066	0f b6 41 fb	 movzx	 eax, BYTE PTR [ecx-5]
  0006a	33 c6		 xor	 eax, esi
  0006c	c1 ee 08	 shr	 esi, 8
  0006f	0f b6 c0	 movzx	 eax, al
  00072	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  00079	0f b6 41 fc	 movzx	 eax, BYTE PTR [ecx-4]
  0007d	33 c6		 xor	 eax, esi
  0007f	c1 ee 08	 shr	 esi, 8
  00082	0f b6 c0	 movzx	 eax, al
  00085	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  0008c	0f b6 41 fd	 movzx	 eax, BYTE PTR [ecx-3]
  00090	33 c6		 xor	 eax, esi
  00092	c1 ee 08	 shr	 esi, 8
  00095	0f b6 c0	 movzx	 eax, al
  00098	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  0009f	0f b6 41 fe	 movzx	 eax, BYTE PTR [ecx-2]
  000a3	33 c6		 xor	 eax, esi
  000a5	c1 ee 08	 shr	 esi, 8
  000a8	0f b6 c0	 movzx	 eax, al
  000ab	33 34 85 00 00
	00 00		 xor	 esi, DWORD PTR _crc_32_tab[eax*4]
  000b2	83 ea 01	 sub	 edx, 1
  000b5	75 99		 jne	 SHORT $LL4@MouseProc

; 525  : 		}
; 526  : 
; 527  : 		if (crc != lastCrc && crc != lastCrc2)

  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lastCrc@?1??MouseProc@@9@9
  000bc	3b f0		 cmp	 esi, eax
  000be	0f 84 c4 00 00
	00		 je	 $LN13@MouseProc
  000c4	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lastCrc2@?1??MouseProc@@9@9
  000ca	0f 84 b8 00 00
	00		 je	 $LN13@MouseProc

; 528  : 		{
; 529  : 			unsigned __int32 timeCrc = 0L;
; 530  : 
; 531  : 			for (i = 0; i < 4; i++)
; 532  : 			{
; 533  : 				timeCrc = UPDC32 (((unsigned char *) &j)[i], timeCrc);

  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _j$1$[ebp]
  000d3	57		 push	 edi
  000d4	0f b6 c1	 movzx	 eax, cl

; 534  : 			}
; 535  : 
; 536  : 			for (i = 0; i < 4; i++)
; 537  : 			{
; 538  : 				timeCrc = UPDC32 (((unsigned char *) &dwTimer)[i], timeCrc);
; 539  : 			}
; 540  : 
; 541  : 			EnterCriticalSection (&critRandProt);

  000d7	68 00 00 00 00	 push	 OFFSET _critRandProt
  000dc	8b 3c 85 00 00
	00 00		 mov	 edi, DWORD PTR _crc_32_tab[eax*4]
  000e3	0f b6 c5	 movzx	 eax, ch
  000e6	33 c7		 xor	 eax, edi
  000e8	c1 ef 08	 shr	 edi, 8
  000eb	0f b6 c0	 movzx	 eax, al
  000ee	33 3c 85 00 00
	00 00		 xor	 edi, DWORD PTR _crc_32_tab[eax*4]
  000f5	0f b6 45 0a	 movzx	 eax, BYTE PTR _j$1[ebp+2]
  000f9	33 c7		 xor	 eax, edi
  000fb	c1 ef 08	 shr	 edi, 8
  000fe	0f b6 c0	 movzx	 eax, al
  00101	33 3c 85 00 00
	00 00		 xor	 edi, DWORD PTR _crc_32_tab[eax*4]
  00108	0f b6 45 0b	 movzx	 eax, BYTE PTR _j$1[ebp+3]
  0010c	33 c7		 xor	 eax, edi
  0010e	c1 ef 08	 shr	 edi, 8
  00111	0f b6 c0	 movzx	 eax, al
  00114	33 3c 85 00 00
	00 00		 xor	 edi, DWORD PTR _crc_32_tab[eax*4]
  0011b	0f b6 c3	 movzx	 eax, bl
  0011e	33 c7		 xor	 eax, edi
  00120	c1 ef 08	 shr	 edi, 8
  00123	0f b6 c0	 movzx	 eax, al
  00126	33 3c 85 00 00
	00 00		 xor	 edi, DWORD PTR _crc_32_tab[eax*4]
  0012d	0f b6 c7	 movzx	 eax, bh
  00130	33 c7		 xor	 eax, edi
  00132	c1 ef 08	 shr	 edi, 8
  00135	0f b6 c0	 movzx	 eax, al
  00138	33 3c 85 00 00
	00 00		 xor	 edi, DWORD PTR _crc_32_tab[eax*4]
  0013f	0f b6 45 0e	 movzx	 eax, BYTE PTR _dwTimer$2[ebp+2]
  00143	33 c7		 xor	 eax, edi
  00145	c1 ef 08	 shr	 edi, 8
  00148	0f b6 c0	 movzx	 eax, al
  0014b	33 3c 85 00 00
	00 00		 xor	 edi, DWORD PTR _crc_32_tab[eax*4]
  00152	0f b6 45 0f	 movzx	 eax, BYTE PTR _dwTimer$2[ebp+3]
  00156	33 c7		 xor	 eax, edi
  00158	c1 ef 08	 shr	 edi, 8
  0015b	0f b6 c0	 movzx	 eax, al
  0015e	33 3c 85 00 00
	00 00		 xor	 edi, DWORD PTR _crc_32_tab[eax*4]
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 542  : 			RandaddInt32 ((unsigned __int32) (crc + timeCrc));

  0016b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _RandAddInt
  00174	83 c4 04	 add	 esp, 4

; 543  : 			LeaveCriticalSection (&critRandProt);

  00177	68 00 00 00 00	 push	 OFFSET _critRandProt
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00182	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lastCrc@?1??MouseProc@@9@9
  00187	5f		 pop	 edi
$LN13@MouseProc:

; 544  : 		}
; 545  : 		lastCrc2 = lastCrc;
; 546  : 		lastCrc = crc;

  00188	89 35 00 00 00
	00		 mov	 DWORD PTR ?lastCrc@?1??MouseProc@@9@9, esi
  0018e	5e		 pop	 esi
  0018f	a3 00 00 00 00	 mov	 DWORD PTR ?lastCrc2@?1??MouseProc@@9@9, eax

; 547  : 
; 548  : 	}
; 549  : 	return 0;

  00194	33 c0		 xor	 eax, eax
  00196	5b		 pop	 ebx

; 550  : }

  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c2 0c 00	 ret	 12			; 0000000cH
_MouseProc@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _RandgetBytes
_TEXT	SEGMENT
_ret$2$ = -4						; size = 4
_buf$ = 8						; size = 4
_ret$3$ = 12						; size = 4
_len$ = 12						; size = 4
_forceSlowPoll$ = 16					; size = 4
_RandgetBytes PROC					; COMDAT

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 429  : 	int i;
; 430  : 	BOOL ret = TRUE;
; 431  : 
; 432  : 	if (!bRandDidInit || HashFunction == 0)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandDidInit, 0
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	be 01 00 00 00	 mov	 esi, 1
  00013	74 09		 je	 SHORT $LN12@RandgetByt
  00015	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HashFunction, 0
  0001c	75 07		 jne	 SHORT $LN11@RandgetByt
$LN12@RandgetByt:

; 433  : 		GST_THROW_FATAL_EXCEPTION;

  0001e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN11@RandgetByt:

; 434  : 
; 435  : 	EnterCriticalSection (&critRandProt);

  00025	68 00 00 00 00	 push	 OFFSET _critRandProt
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 436  : 
; 437  : 	if (bDidSlowPoll == FALSE || forceSlowPoll)

  00030	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDidSlowPoll, 0
  00037	74 06		 je	 SHORT $LN14@RandgetByt
  00039	83 7d 10 00	 cmp	 DWORD PTR _forceSlowPoll$[ebp], 0
  0003d	74 13		 je	 SHORT $LN16@RandgetByt
$LN14@RandgetByt:

; 438  : 	{
; 439  : 		if (!SlowPoll ())

  0003f	e8 00 00 00 00	 call	 _SlowPoll
  00044	85 c0		 test	 eax, eax
  00046	75 04		 jne	 SHORT $LN15@RandgetByt

; 440  : 			ret = FALSE;

  00048	33 f6		 xor	 esi, esi
  0004a	eb 06		 jmp	 SHORT $LN16@RandgetByt
$LN15@RandgetByt:

; 441  : 		else
; 442  : 			bDidSlowPoll = TRUE;

  0004c	89 35 00 00 00
	00		 mov	 DWORD PTR _bDidSlowPoll, esi
$LN16@RandgetByt:

; 443  : 	}
; 444  : 
; 445  : 	if (!FastPoll ())

  00052	e8 00 00 00 00	 call	 _FastPoll

; 446  : 		ret = FALSE;
; 447  : 
; 448  : 	/* There's never more than RNG_POOL_SIZE worth of randomess */
; 449  : 	if (len > RNG_POOL_SIZE)

  00057	8b 7d 0c	 mov	 edi, DWORD PTR _len$[ebp]
  0005a	8b d8		 mov	 ebx, eax
  0005c	f7 db		 neg	 ebx
  0005e	1b db		 sbb	 ebx, ebx
  00060	23 de		 and	 ebx, esi
  00062	89 5d fc	 mov	 DWORD PTR _ret$2$[ebp], ebx
  00065	81 ff 40 01 00
	00		 cmp	 edi, 320		; 00000140H
  0006b	7e 16		 jle	 SHORT $LN18@RandgetByt

; 450  : 	{
; 451  : 		Error ("ERR_NOT_ENOUGH_RANDOM_DATA");	

  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@
  00072	e8 00 00 00 00	 call	 _Error
  00077	83 c4 04	 add	 esp, 4

; 452  : 		len = RNG_POOL_SIZE;
; 453  : 		return FALSE;

  0007a	33 c0		 xor	 eax, eax
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx

; 487  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
$LN18@RandgetByt:

; 454  : 	}
; 455  : 
; 456  : 	// Requested number of bytes is copied from pool to output buffer,
; 457  : 	// pool is rehashed, and output buffer is XORed with new data from pool
; 458  : 	for (i = 0; i < len; i++)

  00083	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _pRandPool
  00089	33 d2		 xor	 edx, edx
  0008b	85 ff		 test	 edi, edi
  0008d	7e 29		 jle	 SHORT $LN3@RandgetByt
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _randPoolReadIndex
  00095	8b 5d 08	 mov	 ebx, DWORD PTR _buf$[ebp]
$LL4@RandgetByt:

; 459  : 	{
; 460  : 		buf[i] = pRandPool[randPoolReadIndex++];

  00098	8a 04 31	 mov	 al, BYTE PTR [ecx+esi]
  0009b	41		 inc	 ecx
  0009c	88 04 1a	 mov	 BYTE PTR [edx+ebx], al

; 461  : 		if (randPoolReadIndex == RNG_POOL_SIZE) randPoolReadIndex = 0;

  0009f	33 c0		 xor	 eax, eax
  000a1	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  000a7	0f 44 c8	 cmove	 ecx, eax
  000aa	42		 inc	 edx
  000ab	3b d7		 cmp	 edx, edi
  000ad	7c e9		 jl	 SHORT $LL4@RandgetByt
  000af	8b 5d fc	 mov	 ebx, DWORD PTR _ret$2$[ebp]
  000b2	89 0d 00 00 00
	00		 mov	 DWORD PTR _randPoolReadIndex, ecx
$LN3@RandgetByt:

; 462  : 	}
; 463  : 
; 464  : 	/* Invert the pool */
; 465  : 	for (i = 0; i < RNG_POOL_SIZE / 4; i++)

  000b8	0f 10 0d 00 00
	00 00		 movups	 xmm1, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  000bf	33 c0		 xor	 eax, eax
$LL7@RandgetByt:

; 466  : 	{
; 467  : 		((unsigned __int32 *) pRandPool)[i] = ~((unsigned __int32 *) pRandPool)[i];

  000c1	0f 10 04 86	 movups	 xmm0, XMMWORD PTR [esi+eax*4]
  000c5	66 0f df c1	 pandn	 xmm0, xmm1
  000c9	0f 11 04 86	 movups	 XMMWORD PTR [esi+eax*4], xmm0
  000cd	0f 10 44 86 10	 movups	 xmm0, XMMWORD PTR [esi+eax*4+16]
  000d2	66 0f df c1	 pandn	 xmm0, xmm1
  000d6	0f 11 44 86 10	 movups	 XMMWORD PTR [esi+eax*4+16], xmm0
  000db	83 c0 08	 add	 eax, 8
  000de	83 f8 50	 cmp	 eax, 80			; 00000050H
  000e1	7c de		 jl	 SHORT $LL7@RandgetByt

; 468  : 	}
; 469  : 
; 470  : 	// Mix the pool
; 471  : 	if (!FastPoll ())

  000e3	e8 00 00 00 00	 call	 _FastPoll
  000e8	8b f0		 mov	 esi, eax
  000ea	f7 de		 neg	 esi
  000ec	1b f6		 sbb	 esi, esi

; 472  : 		ret = FALSE;
; 473  : 
; 474  : 	// XOR the current pool content into the output buffer to prevent pool state leaks
; 475  : 	for (i = 0; i < len; i++)

  000ee	33 d2		 xor	 edx, edx
  000f0	23 f3		 and	 esi, ebx
  000f2	89 75 0c	 mov	 DWORD PTR _ret$3$[ebp], esi
  000f5	85 ff		 test	 edi, edi
  000f7	7e 2f		 jle	 SHORT $LN9@RandgetByt
  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _randPoolReadIndex
  000ff	8b 5d 08	 mov	 ebx, DWORD PTR _buf$[ebp]
  00102	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _pRandPool
$LL10@RandgetByt:

; 476  : 	{
; 477  : 		buf[i] ^= pRandPool[randPoolReadIndex++];

  00108	8a 04 31	 mov	 al, BYTE PTR [ecx+esi]
  0010b	41		 inc	 ecx
  0010c	30 04 1a	 xor	 BYTE PTR [edx+ebx], al

; 478  : 		if (randPoolReadIndex == RNG_POOL_SIZE) randPoolReadIndex = 0;

  0010f	33 c0		 xor	 eax, eax
  00111	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  00117	0f 44 c8	 cmove	 ecx, eax
  0011a	42		 inc	 edx
  0011b	3b d7		 cmp	 edx, edi
  0011d	7c e9		 jl	 SHORT $LL10@RandgetByt
  0011f	8b 75 0c	 mov	 esi, DWORD PTR _ret$3$[ebp]
  00122	89 0d 00 00 00
	00		 mov	 DWORD PTR _randPoolReadIndex, ecx
$LN9@RandgetByt:

; 479  : 	}
; 480  : 
; 481  : 	LeaveCriticalSection (&critRandProt);

  00128	68 00 00 00 00	 push	 OFFSET _critRandProt
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00133	85 f6		 test	 esi, esi

; 482  : 
; 483  : 	if (!ret)

  00135	75 07		 jne	 SHORT $LN22@RandgetByt

; 484  : 		GST_THROW_FATAL_EXCEPTION;

  00137	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN22@RandgetByt:
  0013e	5f		 pop	 edi

; 485  : 
; 486  : 	return ret;

  0013f	8b c6		 mov	 eax, esi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx

; 487  : }

  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c3		 ret	 0
_RandgetBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _RandpeekBytes
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_RandpeekBytes PROC					; COMDAT

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 398  : 	if (!bRandDidInit)

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandDidInit, 0
  0000a	75 04		 jne	 SHORT $LN2@RandpeekBy

; 399  : 		return FALSE;

  0000c	33 c0		 xor	 eax, eax

; 412  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN2@RandpeekBy:
  00010	56		 push	 esi

; 400  : 
; 401  : 	if (len > RNG_POOL_SIZE)

  00011	8b 75 0c	 mov	 esi, DWORD PTR _len$[ebp]
  00014	81 fe 40 01 00
	00		 cmp	 esi, 320		; 00000140H
  0001a	7e 12		 jle	 SHORT $LN3@RandpeekBy

; 402  : 	{
; 403  : 		Error ("ERR_NOT_ENOUGH_RANDOM_DATA");	

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@
  00021	e8 00 00 00 00	 call	 _Error
  00026	83 c4 04	 add	 esp, 4

; 404  : 		len = RNG_POOL_SIZE;

  00029	be 40 01 00 00	 mov	 esi, 320		; 00000140H
$LN3@RandpeekBy:

; 405  : 	}
; 406  : 
; 407  : 	EnterCriticalSection (&critRandProt);

  0002e	68 00 00 00 00	 push	 OFFSET _critRandProt
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 408  : 	memcpy (buf, pRandPool, len);

  00039	56		 push	 esi
  0003a	ff 35 00 00 00
	00		 push	 DWORD PTR _pRandPool
  00040	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00043	e8 00 00 00 00	 call	 _memcpy
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 409  : 	LeaveCriticalSection (&critRandProt);

  0004b	68 00 00 00 00	 push	 OFFSET _critRandProt
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 410  : 
; 411  : 	return TRUE;

  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	5e		 pop	 esi

; 412  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_RandpeekBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _SlowPoll
_TEXT	SEGMENT
_hKey$1 = -160						; size = 4
_lpBuffer$ = -156					; size = 4
_dwSize$ = -152						; size = 4
_diskPerformance$2 = -148				; size = 88
_szValue$3 = -60					; size = 32
_szDevice$4 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_SlowPoll PROC						; COMDAT

; 675  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 676  : 	static int isWorkstation = -1;
; 677  : 	static int cbPerfData = 0x10000;
; 678  : 	HANDLE hDevice;
; 679  : 	LPBYTE lpBuffer;
; 680  : 	DWORD dwSize, status;
; 681  : 	LPWSTR lpszLanW, lpszLanS;
; 682  : 	int nDrive;
; 683  : 
; 684  : 	/* Find out whether this is an NT server or workstation if necessary */
; 685  : 	if (isWorkstation == -1)

  00013	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@9, -1
  0001a	0f 85 8a 00 00
	00		 jne	 $LN46@SlowPoll

; 686  : 	{
; 687  : 		HKEY hKey;
; 688  : 
; 689  : 		if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
; 690  : 		       "SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
; 691  : 				  0, KEY_READ, &hKey) == ERROR_SUCCESS)

  00020	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _hKey$1[ebp]
  00026	50		 push	 eax
  00027	68 19 00 02 00	 push	 131097			; 00020019H
  0002c	6a 00		 push	 0
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@
  00033	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0003e	85 c0		 test	 eax, eax
  00040	75 68		 jne	 SHORT $LN46@SlowPoll

; 692  : 		{
; 693  : 			unsigned char szValue[32];
; 694  : 			dwSize = sizeof (szValue);
; 695  : 
; 696  : 			isWorkstation = TRUE;
; 697  : 			status = RegQueryValueEx (hKey, "ProductType", 0, NULL,

  00042	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _dwSize$[ebp]
  00048	c7 85 68 ff ff
	ff 20 00 00 00	 mov	 DWORD PTR _dwSize$[ebp], 32 ; 00000020H
  00052	50		 push	 eax
  00053	8d 45 c4	 lea	 eax, DWORD PTR _szValue$3[ebp]
  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@9, 1
  00060	50		 push	 eax
  00061	6a 00		 push	 0
  00063	6a 00		 push	 0
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GGPOPAAP@ProductType?$AA@
  0006a	ff b5 60 ff ff
	ff		 push	 DWORD PTR _hKey$1[ebp]
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24

; 698  : 						  szValue, &dwSize);
; 699  : 
; 700  : 			if (status == ERROR_SUCCESS && _stricmp ((char *) szValue, "WinNT"))

  00076	85 c0		 test	 eax, eax
  00078	75 24		 jne	 SHORT $LN12@SlowPoll
  0007a	8d 45 c4	 lea	 eax, DWORD PTR _szValue$3[ebp]
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_05LELOMLIF@WinNT?$AA@
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 __stricmp
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?isWorkstation@?1??SlowPoll@@9@9
  0008e	33 d2		 xor	 edx, edx
  00090	83 c4 08	 add	 esp, 8
  00093	85 c0		 test	 eax, eax
  00095	0f 45 ca	 cmovne	 ecx, edx
  00098	89 0d 00 00 00
	00		 mov	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@9, ecx
$LN12@SlowPoll:

; 701  : 				/* Note: There are (at least) three cases for
; 702  : 				   ProductType: WinNT = NT Workstation,
; 703  : 				   ServerNT = NT Server, LanmanNT = NT Server
; 704  : 				   acting as a Domain Controller */
; 705  : 				isWorkstation = FALSE;
; 706  : 
; 707  : 			RegCloseKey (hKey);

  0009e	ff b5 60 ff ff
	ff		 push	 DWORD PTR _hKey$1[ebp]
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN46@SlowPoll:

; 708  : 		}
; 709  : 	}
; 710  : 	/* Initialize the NetAPI32 function pointers if necessary */
; 711  : 	if (hNetAPI32 == NULL)

  000aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hNetAPI32, 0
  000b1	56		 push	 esi
  000b2	0f 85 90 00 00
	00		 jne	 $LN47@SlowPoll

; 712  : 	{
; 713  : 		/* Obtain a handle to the module containing the Lan Manager
; 714  : 		   functions */
; 715  : 		hNetAPI32 = LoadLibraryEx("NETAPI32.DLL", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);

  000b8	68 00 08 00 00	 push	 2048			; 00000800H
  000bd	6a 00		 push	 0
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryExA@12
  000ca	a3 00 00 00 00	 mov	 DWORD PTR _hNetAPI32, eax

; 716  : 		if (hNetAPI32 != NULL)

  000cf	85 c0		 test	 eax, eax
  000d1	0f 84 d2 00 00
	00		 je	 $LN17@SlowPoll

; 717  : 		{
; 718  : 			/* Now get pointers to the functions */
; 719  : 			pNetStatisticsGet = (NETSTATISTICSGET) GetProcAddress (hNetAPI32,

  000d7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetProcAddress@8
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@
  000e2	50		 push	 eax
  000e3	ff d6		 call	 esi

; 720  : 							"NetStatisticsGet");
; 721  : 			pNetApiBufferSize = (NETAPIBUFFERSIZE) GetProcAddress (hNetAPI32,

  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@
  000ea	ff 35 00 00 00
	00		 push	 DWORD PTR _hNetAPI32
  000f0	a3 00 00 00 00	 mov	 DWORD PTR _pNetStatisticsGet, eax
  000f5	ff d6		 call	 esi

; 722  : 							"NetApiBufferSize");
; 723  : 			pNetApiBufferFree = (NETAPIBUFFERFREE) GetProcAddress (hNetAPI32,

  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@
  000fc	ff 35 00 00 00
	00		 push	 DWORD PTR _hNetAPI32
  00102	a3 00 00 00 00	 mov	 DWORD PTR _pNetApiBufferSize, eax
  00107	ff d6		 call	 esi

; 724  : 							"NetApiBufferFree");
; 725  : 
; 726  : 			/* Make sure we got valid pointers for every NetAPI32
; 727  : 			   function */
; 728  : 			if (pNetStatisticsGet == NULL ||
; 729  : 			    pNetApiBufferSize == NULL ||

  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pNetStatisticsGet
  0010f	a3 00 00 00 00	 mov	 DWORD PTR _pNetApiBufferFree, eax
  00114	85 c9		 test	 ecx, ecx
  00116	74 18		 je	 SHORT $LN16@SlowPoll
  00118	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pNetApiBufferSize, 0
  0011f	74 0f		 je	 SHORT $LN16@SlowPoll
  00121	85 c0		 test	 eax, eax
  00123	74 0b		 je	 SHORT $LN16@SlowPoll

; 736  : 			}
; 737  : 		}
; 738  : 	}
; 739  : 
; 740  : 	/* Get network statistics.  Note: Both NT Workstation and NT Server
; 741  : 	   by default will be running both the workstation and server
; 742  : 	   services.  The heuristic below is probably useful though on the
; 743  : 	   assumption that the majority of the network traffic will be via
; 744  : 	   the appropriate service */
; 745  : 	lpszLanW = (LPWSTR) WIDE ("LanmanWorkstation");
; 746  : 	lpszLanS = (LPWSTR) WIDE ("LanmanServer");
; 747  : 	if (hNetAPI32 &&

  00125	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hNetAPI32, 0
  0012c	74 7b		 je	 SHORT $LN17@SlowPoll
  0012e	eb 1e		 jmp	 SHORT $LN42@SlowPoll
$LN16@SlowPoll:

; 730  : 			    pNetApiBufferFree == NULL)
; 731  : 			{
; 732  : 				/* Free the library reference and reset the
; 733  : 				   static handle */
; 734  : 				FreeLibrary (hNetAPI32);

  00130	ff 35 00 00 00
	00		 push	 DWORD PTR _hNetAPI32
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 735  : 				hNetAPI32 = NULL;

  0013c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hNetAPI32, 0

; 736  : 			}
; 737  : 		}
; 738  : 	}
; 739  : 
; 740  : 	/* Get network statistics.  Note: Both NT Workstation and NT Server
; 741  : 	   by default will be running both the workstation and server
; 742  : 	   services.  The heuristic below is probably useful though on the
; 743  : 	   assumption that the majority of the network traffic will be via
; 744  : 	   the appropriate service */
; 745  : 	lpszLanW = (LPWSTR) WIDE ("LanmanWorkstation");
; 746  : 	lpszLanS = (LPWSTR) WIDE ("LanmanServer");
; 747  : 	if (hNetAPI32 &&

  00146	eb 61		 jmp	 SHORT $LN17@SlowPoll
$LN47@SlowPoll:
  00148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pNetStatisticsGet
$LN42@SlowPoll:
  0014e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@9, 0
  00155	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _lpBuffer$[ebp]
  0015b	50		 push	 eax
  0015c	6a 00		 push	 0
  0015e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@
  00163	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
  00168	6a 00		 push	 0
  0016a	0f 44 c2	 cmove	 eax, edx
  0016d	50		 push	 eax
  0016e	6a 00		 push	 0
  00170	ff d1		 call	 ecx
  00172	85 c0		 test	 eax, eax
  00174	75 33		 jne	 SHORT $LN17@SlowPoll

; 748  : 	    pNetStatisticsGet (NULL,
; 749  : 			       isWorkstation ? lpszLanW : lpszLanS,
; 750  : 			       0, 0, &lpBuffer) == 0)
; 751  : 	{
; 752  : 		pNetApiBufferSize (lpBuffer, &dwSize);

  00176	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _dwSize$[ebp]
  0017c	50		 push	 eax
  0017d	ff b5 64 ff ff
	ff		 push	 DWORD PTR _lpBuffer$[ebp]
  00183	ff 15 00 00 00
	00		 call	 DWORD PTR _pNetApiBufferSize

; 753  : 		RandaddBuf ((unsigned char *) lpBuffer, dwSize);

  00189	ff b5 68 ff ff
	ff		 push	 DWORD PTR _dwSize$[ebp]
  0018f	ff b5 64 ff ff
	ff		 push	 DWORD PTR _lpBuffer$[ebp]
  00195	e8 00 00 00 00	 call	 _RandaddBuf
  0019a	83 c4 08	 add	 esp, 8

; 754  : 		pNetApiBufferFree (lpBuffer);

  0019d	ff b5 64 ff ff
	ff		 push	 DWORD PTR _lpBuffer$[ebp]
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR _pNetApiBufferFree
$LN17@SlowPoll:

; 755  : 	}
; 756  : 
; 757  : 	/* Get disk I/O statistics for all the hard drives */
; 758  : 	for (nDrive = 0;; nDrive++)

  001a9	53		 push	 ebx
  001aa	57		 push	 edi
  001ab	33 ff		 xor	 edi, edi

; 759  : 	{
; 760  : 		DISK_PERFORMANCE diskPerformance;
; 761  : 		char szDevice[24];
; 762  : 
; 763  : 		/* Check whether we can access this device */
; 764  : 		sprintf (szDevice, "\\\\.\\PhysicalDrive%d", nDrive);

  001ad	8d 45 e4	 lea	 eax, DWORD PTR _szDevice$4[ebp]
  001b0	57		 push	 edi
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _sprintf

; 765  : 		hDevice = CreateFile (szDevice, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,

  001bc	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateFileA@28
  001c2	8d 45 e4	 lea	 eax, DWORD PTR _szDevice$4[ebp]
  001c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c8	57		 push	 edi
  001c9	57		 push	 edi
  001ca	6a 03		 push	 3
  001cc	57		 push	 edi
  001cd	6a 03		 push	 3
  001cf	57		 push	 edi
  001d0	50		 push	 eax
  001d1	ff d3		 call	 ebx
  001d3	8b f0		 mov	 esi, eax

; 766  : 				      NULL, OPEN_EXISTING, 0, NULL);
; 767  : 		if (hDevice == INVALID_HANDLE_VALUE)

  001d5	83 fe ff	 cmp	 esi, -1
  001d8	74 74		 je	 SHORT $LN30@SlowPoll
  001da	66 0f 1f 44 00
	00		 npad	 6
$LL4@SlowPoll:

; 768  : 			break;
; 769  : 
; 770  : 
; 771  : 		/* Note: This only works if you have turned on the disk
; 772  : 		   performance counters with 'diskperf -y'.  These counters
; 773  : 		   are off by default */
; 774  : 		if (DeviceIoControl (hDevice, IOCTL_DISK_PERFORMANCE, NULL, 0,

  001e0	6a 00		 push	 0
  001e2	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _dwSize$[ebp]
  001e8	50		 push	 eax
  001e9	6a 58		 push	 88			; 00000058H
  001eb	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _diskPerformance$2[ebp]
  001f1	50		 push	 eax
  001f2	6a 00		 push	 0
  001f4	6a 00		 push	 0
  001f6	68 20 00 07 00	 push	 458784			; 00070020H
  001fb	56		 push	 esi
  001fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00202	85 c0		 test	 eax, eax
  00204	74 15		 je	 SHORT $LN19@SlowPoll

; 775  : 				&diskPerformance, sizeof (DISK_PERFORMANCE),
; 776  : 				     &dwSize, NULL))
; 777  : 		{
; 778  : 			RandaddBuf ((unsigned char *) &diskPerformance, dwSize);

  00206	ff b5 68 ff ff
	ff		 push	 DWORD PTR _dwSize$[ebp]
  0020c	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _diskPerformance$2[ebp]
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 _RandaddBuf
  00218	83 c4 08	 add	 esp, 8
$LN19@SlowPoll:

; 779  : 		}
; 780  : 		CloseHandle (hDevice);

  0021b	56		 push	 esi
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00222	47		 inc	 edi
  00223	8d 45 e4	 lea	 eax, DWORD PTR _szDevice$4[ebp]
  00226	57		 push	 edi
  00227	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 _sprintf
  00232	83 c4 0c	 add	 esp, 12			; 0000000cH
  00235	8d 45 e4	 lea	 eax, DWORD PTR _szDevice$4[ebp]
  00238	6a 00		 push	 0
  0023a	6a 00		 push	 0
  0023c	6a 03		 push	 3
  0023e	6a 00		 push	 0
  00240	6a 03		 push	 3
  00242	6a 00		 push	 0
  00244	50		 push	 eax
  00245	ff d3		 call	 ebx
  00247	8b f0		 mov	 esi, eax
  00249	83 fe ff	 cmp	 esi, -1
  0024c	75 92		 jne	 SHORT $LL4@SlowPoll
$LN30@SlowPoll:

; 781  : 	}
; 782  : 
; 783  : 	// CryptoAPI
; 784  : 	if (CryptoAPIAvailable && CryptGenRandom (hCryptProv, sizeof (buffer), buffer)) 

  0024e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CryptoAPIAvailable, 0
  00255	5f		 pop	 edi
  00256	5b		 pop	 ebx
  00257	74 2c		 je	 SHORT $LN7@SlowPoll
  00259	68 00 00 00 00	 push	 OFFSET _buffer
  0025e	68 40 01 00 00	 push	 320			; 00000140H
  00263	ff 35 00 00 00
	00		 push	 DWORD PTR _hCryptProv
  00269	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGenRandom@12
  0026f	85 c0		 test	 eax, eax
  00271	74 12		 je	 SHORT $LN7@SlowPoll

; 785  : 		RandaddBuf (buffer, sizeof (buffer));

  00273	68 40 01 00 00	 push	 320			; 00000140H
  00278	68 00 00 00 00	 push	 OFFSET _buffer
  0027d	e8 00 00 00 00	 call	 _RandaddBuf
  00282	83 c4 08	 add	 esp, 8
$LN7@SlowPoll:

; 786  : 
; 787  : 	burn(buffer, sizeof (buffer));

  00285	b8 00 00 00 00	 mov	 eax, OFFSET _buffer
  0028a	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  0028f	8b f1		 mov	 esi, ecx
  00291	8b d0		 mov	 edx, eax
$LL23@SlowPoll:
  00293	c6 02 00	 mov	 BYTE PTR [edx], 0
  00296	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00299	83 ee 01	 sub	 esi, 1
  0029c	75 f5		 jne	 SHORT $LL23@SlowPoll
  0029e	5e		 pop	 esi
  0029f	90		 npad	 1
$LL8@SlowPoll:
  002a0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002a3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002a6	83 e9 01	 sub	 ecx, 1
  002a9	75 f5		 jne	 SHORT $LL8@SlowPoll

; 788  : 	Randmix();

  002ab	e8 00 00 00 00	 call	 _Randmix

; 789  : 	return TRUE;
; 790  : }

  002b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b3	b8 01 00 00 00	 mov	 eax, 1
  002b8	33 cd		 xor	 ecx, ebp
  002ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bf	8b e5		 mov	 esp, ebp
  002c1	5d		 pop	 ebp
  002c2	c3		 ret	 0
_SlowPoll ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _FastPoll
_TEXT	SEGMENT
_startupInfo$1 = -168					; size = 68
_performanceCount$ = -100				; size = 8
_userTime$ = -92					; size = 8
_kernelTime$ = -84					; size = 8
_exitTime$ = -76					; size = 8
_creationTime$ = -68					; size = 8
_point$ = -60						; size = 8
_nOriginalRandIndex$1$ = -52				; size = 4
_dwTicks$2 = -48					; size = 4
_maximumWorkingSetSize$ = -44				; size = 4
_minimumWorkingSetSize$ = -40				; size = 4
_memoryStatus$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_FastPoll PROC						; COMDAT

; 802  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 803  : 	int nOriginalRandIndex = nRandIndex;

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  00018	56		 push	 esi
  00019	89 45 cc	 mov	 DWORD PTR _nOriginalRandIndex$1$[ebp], eax

; 804  : 	static BOOL addedFixedItems = FALSE;
; 805  : 	FILETIME creationTime, exitTime, kernelTime, userTime;
; 806  : 	DWORD minimumWorkingSetSize, maximumWorkingSetSize;
; 807  : 	LARGE_INTEGER performanceCount;
; 808  : 	MEMORYSTATUS memoryStatus;
; 809  : 	HANDLE handle;
; 810  : 	POINT point;
; 811  : 
; 812  : 	/* Get various basic pieces of system information */
; 813  : 	RandaddInt32 (GetActiveWindow ());	/* Handle of active window */

  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetActiveWindow@0
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _RandAddInt
  00028	83 c4 04	 add	 esp, 4

; 814  : 	RandaddInt32 (GetCapture ());	/* Handle of window with mouse

  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCapture@0
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _RandAddInt
  00037	83 c4 04	 add	 esp, 4

; 815  : 					   capture */
; 816  : 	RandaddInt32 (GetClipboardOwner ());	/* Handle of clipboard owner */

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardOwner@0
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _RandAddInt
  00046	83 c4 04	 add	 esp, 4

; 817  : 	RandaddInt32 (GetClipboardViewer ());	/* Handle of start of

  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardViewer@0
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _RandAddInt
  00055	83 c4 04	 add	 esp, 4

; 818  : 						   clpbd.viewer list */
; 819  : 	RandaddInt32 (GetCurrentProcess ());	/* Pseudohandle of current

  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _RandAddInt
  00064	83 c4 04	 add	 esp, 4

; 820  : 						   process */
; 821  : 	RandaddInt32 (GetCurrentProcessId ());	/* Current process ID */

  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _RandAddInt

; 822  : 	RandaddInt32 (GetCurrentThread ());	/* Pseudohandle of current

  00073	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetCurrentThread@0
  00079	83 c4 04	 add	 esp, 4
  0007c	ff d6		 call	 esi
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _RandAddInt
  00084	83 c4 04	 add	 esp, 4

; 823  : 						   thread */
; 824  : 	RandaddInt32 (GetCurrentThreadId ());	/* Current thread ID */

  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _RandAddInt
  00093	83 c4 04	 add	 esp, 4

; 825  : 	RandaddInt32 (GetCurrentTime ());	/* Milliseconds since Windows

  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _RandAddInt
  000a2	83 c4 04	 add	 esp, 4

; 826  : 						   started */
; 827  : 	RandaddInt32 (GetDesktopWindow ());	/* Handle of desktop window */

  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDesktopWindow@0
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _RandAddInt
  000b1	83 c4 04	 add	 esp, 4

; 828  : 	RandaddInt32 (GetFocus ());	/* Handle of window with kb.focus */

  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _RandAddInt
  000c0	83 c4 04	 add	 esp, 4

; 829  : 	RandaddInt32 (GetInputState ());	/* Whether sys.queue has any events */

  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetInputState@0
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _RandAddInt
  000cf	83 c4 04	 add	 esp, 4

; 830  : 	RandaddInt32 (GetMessagePos ());	/* Cursor pos.for last message */

  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _RandAddInt
  000de	83 c4 04	 add	 esp, 4

; 831  : 	RandaddInt32 (GetMessageTime ());	/* 1 ms time for last message */

  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessageTime@0
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _RandAddInt
  000ed	83 c4 04	 add	 esp, 4

; 832  : 	RandaddInt32 (GetOpenClipboardWindow ());	/* Handle of window with

  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetOpenClipboardWindow@0
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _RandAddInt
  000fc	83 c4 04	 add	 esp, 4

; 833  : 							   clpbd.open */
; 834  : 	RandaddInt32 (GetProcessHeap ());	/* Handle of process heap */

  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _RandAddInt
  0010b	83 c4 04	 add	 esp, 4

; 835  : 	RandaddInt32 (GetProcessWindowStation ());	/* Handle of procs

  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessWindowStation@0
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 _RandAddInt
  0011a	83 c4 04	 add	 esp, 4

; 836  : 							   window station */
; 837  : 	RandaddInt32 (GetQueueStatus (QS_ALLEVENTS));	/* Types of events in

  0011d	68 bf 04 00 00	 push	 1215			; 000004bfH
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetQueueStatus@4
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _RandAddInt
  0012e	83 c4 04	 add	 esp, 4

; 838  : 							   input queue */
; 839  : 
; 840  : 	/* Get multiword system information */
; 841  : 	GetCaretPos (&point);	/* Current caret position */

  00131	8d 45 c4	 lea	 eax, DWORD PTR _point$[ebp]
  00134	50		 push	 eax
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCaretPos@4

; 842  : 	RandaddBuf ((unsigned char *) &point, sizeof (POINT));

  0013b	6a 08		 push	 8
  0013d	8d 45 c4	 lea	 eax, DWORD PTR _point$[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _RandaddBuf
  00146	83 c4 08	 add	 esp, 8

; 843  : 	GetCursorPos (&point);	/* Current mouse cursor position */

  00149	8d 45 c4	 lea	 eax, DWORD PTR _point$[ebp]
  0014c	50		 push	 eax
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4

; 844  : 	RandaddBuf ((unsigned char *) &point, sizeof (POINT));

  00153	8d 45 c4	 lea	 eax, DWORD PTR _point$[ebp]
  00156	6a 08		 push	 8
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 _RandaddBuf
  0015e	83 c4 08	 add	 esp, 8

; 845  : 
; 846  : 	/* Get percent of memory in use, bytes of physical memory, bytes of
; 847  : 	   free physical memory, bytes in paging file, free bytes in paging
; 848  : 	   file, user bytes of address space, and free user bytes */
; 849  : 	memoryStatus.dwLength = sizeof (MEMORYSTATUS);

  00161	c7 45 dc 20 00
	00 00		 mov	 DWORD PTR _memoryStatus$[ebp], 32 ; 00000020H

; 850  : 	GlobalMemoryStatus (&memoryStatus);

  00168	8d 45 dc	 lea	 eax, DWORD PTR _memoryStatus$[ebp]
  0016b	50		 push	 eax
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatus@4

; 851  : 	RandaddBuf ((unsigned char *) &memoryStatus, sizeof (MEMORYSTATUS));

  00172	8d 45 dc	 lea	 eax, DWORD PTR _memoryStatus$[ebp]
  00175	6a 20		 push	 32			; 00000020H
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _RandaddBuf
  0017d	83 c4 08	 add	 esp, 8

; 852  : 
; 853  : 	/* Get thread and process creation time, exit time, time in kernel
; 854  : 	   mode, and time in user mode in 100ns intervals */
; 855  : 	handle = GetCurrentThread ();

  00180	ff d6		 call	 esi

; 856  : 	GetThreadTimes (handle, &creationTime, &exitTime, &kernelTime, &userTime);

  00182	8d 4d a4	 lea	 ecx, DWORD PTR _userTime$[ebp]
  00185	51		 push	 ecx
  00186	8d 4d ac	 lea	 ecx, DWORD PTR _kernelTime$[ebp]
  00189	51		 push	 ecx
  0018a	8d 4d b4	 lea	 ecx, DWORD PTR _exitTime$[ebp]
  0018d	51		 push	 ecx
  0018e	8d 4d bc	 lea	 ecx, DWORD PTR _creationTime$[ebp]
  00191	51		 push	 ecx
  00192	50		 push	 eax
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadTimes@20

; 857  : 	RandaddBuf ((unsigned char *) &creationTime, sizeof (FILETIME));

  00199	8d 45 bc	 lea	 eax, DWORD PTR _creationTime$[ebp]
  0019c	6a 08		 push	 8
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 _RandaddBuf

; 858  : 	RandaddBuf ((unsigned char *) &exitTime, sizeof (FILETIME));

  001a4	8d 45 b4	 lea	 eax, DWORD PTR _exitTime$[ebp]
  001a7	6a 08		 push	 8
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 _RandaddBuf

; 859  : 	RandaddBuf ((unsigned char *) &kernelTime, sizeof (FILETIME));

  001af	8d 45 ac	 lea	 eax, DWORD PTR _kernelTime$[ebp]
  001b2	6a 08		 push	 8
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 _RandaddBuf

; 860  : 	RandaddBuf ((unsigned char *) &userTime, sizeof (FILETIME));

  001ba	8d 45 a4	 lea	 eax, DWORD PTR _userTime$[ebp]
  001bd	6a 08		 push	 8
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 _RandaddBuf
  001c5	83 c4 20	 add	 esp, 32			; 00000020H

; 861  : 	handle = GetCurrentProcess ();

  001c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  001ce	8b f0		 mov	 esi, eax

; 862  : 	GetProcessTimes (handle, &creationTime, &exitTime, &kernelTime, &userTime);

  001d0	8d 45 a4	 lea	 eax, DWORD PTR _userTime$[ebp]
  001d3	50		 push	 eax
  001d4	8d 45 ac	 lea	 eax, DWORD PTR _kernelTime$[ebp]
  001d7	50		 push	 eax
  001d8	8d 45 b4	 lea	 eax, DWORD PTR _exitTime$[ebp]
  001db	50		 push	 eax
  001dc	8d 45 bc	 lea	 eax, DWORD PTR _creationTime$[ebp]
  001df	50		 push	 eax
  001e0	56		 push	 esi
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessTimes@20

; 863  : 	RandaddBuf ((unsigned char *) &creationTime, sizeof (FILETIME));

  001e7	8d 45 bc	 lea	 eax, DWORD PTR _creationTime$[ebp]
  001ea	6a 08		 push	 8
  001ec	50		 push	 eax
  001ed	e8 00 00 00 00	 call	 _RandaddBuf

; 864  : 	RandaddBuf ((unsigned char *) &exitTime, sizeof (FILETIME));

  001f2	8d 45 b4	 lea	 eax, DWORD PTR _exitTime$[ebp]
  001f5	6a 08		 push	 8
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 _RandaddBuf

; 865  : 	RandaddBuf ((unsigned char *) &kernelTime, sizeof (FILETIME));

  001fd	8d 45 ac	 lea	 eax, DWORD PTR _kernelTime$[ebp]
  00200	6a 08		 push	 8
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 _RandaddBuf

; 866  : 	RandaddBuf ((unsigned char *) &userTime, sizeof (FILETIME));

  00208	8d 45 a4	 lea	 eax, DWORD PTR _userTime$[ebp]
  0020b	6a 08		 push	 8
  0020d	50		 push	 eax
  0020e	e8 00 00 00 00	 call	 _RandaddBuf
  00213	83 c4 20	 add	 esp, 32			; 00000020H

; 867  : 
; 868  : 	/* Get the minimum and maximum working set size for the current
; 869  : 	   process */
; 870  : 	GetProcessWorkingSetSize (handle, &minimumWorkingSetSize,

  00216	8d 45 d4	 lea	 eax, DWORD PTR _maximumWorkingSetSize$[ebp]
  00219	50		 push	 eax
  0021a	8d 45 d8	 lea	 eax, DWORD PTR _minimumWorkingSetSize$[ebp]
  0021d	50		 push	 eax
  0021e	56		 push	 esi
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessWorkingSetSize@12

; 871  : 				  &maximumWorkingSetSize);
; 872  : 	RandaddInt32 (minimumWorkingSetSize);

  00225	ff 75 d8	 push	 DWORD PTR _minimumWorkingSetSize$[ebp]
  00228	e8 00 00 00 00	 call	 _RandAddInt

; 873  : 	RandaddInt32 (maximumWorkingSetSize);

  0022d	ff 75 d4	 push	 DWORD PTR _maximumWorkingSetSize$[ebp]
  00230	e8 00 00 00 00	 call	 _RandAddInt
  00235	83 c4 08	 add	 esp, 8

; 874  : 
; 875  : 	/* The following are fixed for the lifetime of the process so we only
; 876  : 	   add them once */
; 877  : 	if (addedFixedItems == 0)

  00238	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?addedFixedItems@?1??FastPoll@@9@9, 0
  0023f	5e		 pop	 esi
  00240	75 32		 jne	 SHORT $LN2@FastPoll

; 878  : 	{
; 879  : 		STARTUPINFO startupInfo;
; 880  : 
; 881  : 		/* Get name of desktop, console window title, new window
; 882  : 		   position and size, window flags, and handles for stdin,
; 883  : 		   stdout, and stderr */
; 884  : 		startupInfo.cb = sizeof (STARTUPINFO);
; 885  : 		GetStartupInfo (&startupInfo);

  00242	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _startupInfo$1[ebp]
  00248	c7 85 58 ff ff
	ff 44 00 00 00	 mov	 DWORD PTR _startupInfo$1[ebp], 68 ; 00000044H
  00252	50		 push	 eax
  00253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStartupInfoA@4

; 886  : 		RandaddBuf ((unsigned char *) &startupInfo, sizeof (STARTUPINFO));

  00259	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _startupInfo$1[ebp]
  0025f	6a 44		 push	 68			; 00000044H
  00261	50		 push	 eax
  00262	e8 00 00 00 00	 call	 _RandaddBuf
  00267	83 c4 08	 add	 esp, 8

; 887  : 		addedFixedItems = TRUE;

  0026a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?addedFixedItems@?1??FastPoll@@9@9, 1
$LN2@FastPoll:

; 888  : 	}
; 889  : 	/* The docs say QPC can fail if appropriate hardware is not
; 890  : 	   available. It works on 486 & Pentium boxes, but hasn't been tested
; 891  : 	   for 386 or RISC boxes */
; 892  : 	if (QueryPerformanceCounter (&performanceCount))

  00274	8d 45 9c	 lea	 eax, DWORD PTR _performanceCount$[ebp]
  00277	50		 push	 eax
  00278	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0027e	85 c0		 test	 eax, eax
  00280	74 07		 je	 SHORT $LN3@FastPoll

; 893  : 		RandaddBuf ((unsigned char *) &performanceCount, sizeof (LARGE_INTEGER));

  00282	6a 08		 push	 8
  00284	8d 45 9c	 lea	 eax, DWORD PTR _performanceCount$[ebp]
  00287	eb 0e		 jmp	 SHORT $LN7@FastPoll
$LN3@FastPoll:

; 894  : 	else
; 895  : 	{
; 896  : 		/* Millisecond accuracy at best... */
; 897  : 		DWORD dwTicks = GetTickCount ();

  00289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0028f	89 45 d0	 mov	 DWORD PTR _dwTicks$2[ebp], eax

; 898  : 		RandaddBuf ((unsigned char *) &dwTicks, sizeof (dwTicks));

  00292	8d 45 d0	 lea	 eax, DWORD PTR _dwTicks$2[ebp]
  00295	6a 04		 push	 4
$LN7@FastPoll:
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 _RandaddBuf
  0029d	83 c4 08	 add	 esp, 8

; 899  : 	}
; 900  : 
; 901  : 	// CryptoAPI
; 902  : 	if (CryptoAPIAvailable && CryptGenRandom (hCryptProv, sizeof (buffer), buffer)) 

  002a0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CryptoAPIAvailable, 0
  002a7	74 2c		 je	 SHORT $LN5@FastPoll
  002a9	68 00 00 00 00	 push	 OFFSET _buffer
  002ae	68 40 01 00 00	 push	 320			; 00000140H
  002b3	ff 35 00 00 00
	00		 push	 DWORD PTR _hCryptProv
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGenRandom@12
  002bf	85 c0		 test	 eax, eax
  002c1	74 12		 je	 SHORT $LN5@FastPoll

; 903  : 		RandaddBuf (buffer, sizeof (buffer));

  002c3	68 40 01 00 00	 push	 320			; 00000140H
  002c8	68 00 00 00 00	 push	 OFFSET _buffer
  002cd	e8 00 00 00 00	 call	 _RandaddBuf
  002d2	83 c4 08	 add	 esp, 8
$LN5@FastPoll:

; 904  : 
; 905  : 	/* Apply the pool mixing function */
; 906  : 	Randmix();

  002d5	e8 00 00 00 00	 call	 _Randmix

; 907  : 
; 908  : 	/* Restore the original pool cursor position. If this wasn't done, mouse coordinates
; 909  : 	   could be written to a limited area of the pool, especially when moving the mouse
; 910  : 	   uninterruptedly. The severity of the problem would depend on the length of data
; 911  : 	   written by FastPoll (if it was equal to the size of the pool, mouse coordinates
; 912  : 	   would be written only to a particular 4-byte area, whenever moving the mouse
; 913  : 	   uninterruptedly). */
; 914  : 	nRandIndex = nOriginalRandIndex;

  002da	8b 45 cc	 mov	 eax, DWORD PTR _nOriginalRandIndex$1$[ebp]

; 915  : 
; 916  : 	return TRUE;
; 917  : }

  002dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e0	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
  002e5	33 cd		 xor	 ecx, ebp
  002e7	b8 01 00 00 00	 mov	 eax, 1
  002ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f1	8b e5		 mov	 esp, ebp
  002f3	5d		 pop	 ebp
  002f4	c3		 ret	 0
_FastPoll ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _RandaddBuf
_TEXT	SEGMENT
_i$1$ = -732						; size = 4
_digestSize$1 = -732					; size = 4
_sctx$2 = -728						; size = 385
_wctx$3 = -340						; size = 168
_gctx$4 = -172						; size = 104
_hashOutputBuffer$5 = -68				; size = 64
__$ArrayPad$ = -4					; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_RandaddBuf PROC					; COMDAT

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 02 00
	00		 sub	 esp, 732		; 000002dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	57		 push	 edi

; 379  : 	int i;
; 380  : 	for (i = 0; i < len; i++)

  00014	33 ff		 xor	 edi, edi
  00016	89 bd 24 fd ff
	ff		 mov	 DWORD PTR _i$1$[ebp], edi
  0001c	39 7d 0c	 cmp	 DWORD PTR _len$[ebp], edi
  0001f	0f 8e f6 02 00
	00		 jle	 $LN3@RandaddBuf
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	8b b5 24 fd ff
	ff		 mov	 esi, DWORD PTR _digestSize$1[ebp]
  0002d	0f 1f 00	 npad	 3
$LL4@RandaddBuf:

; 381  : 	{
; 382  : 		RandaddByte (((unsigned char *) buf)[i]);

  00030	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nRandIndex
  00036	33 c0		 xor	 eax, eax
  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
  0003e	81 fa 40 01 00
	00		 cmp	 edx, 320		; 00000140H
  00044	0f 44 d0	 cmove	 edx, eax
  00047	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0004a	89 15 00 00 00
	00		 mov	 DWORD PTR _nRandIndex, edx
  00050	8a 04 07	 mov	 al, BYTE PTR [edi+eax]
  00053	00 04 11	 add	 BYTE PTR [ecx+edx], al
  00056	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  0005c	79 05		 jns	 SHORT $LN169@RandaddBuf
  0005e	4a		 dec	 edx
  0005f	83 ca f0	 or	 edx, -16		; fffffff0H
  00062	42		 inc	 edx
$LN169@RandaddBuf:
  00063	0f 85 92 02 00
	00		 jne	 $LN31@RandaddBuf
  00069	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandmixEnabled, 0
  00070	0f 84 85 02 00
	00		 je	 $LN31@RandaddBuf
  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  0007b	83 e8 01	 sub	 eax, 1
  0007e	74 1a		 je	 SHORT $LN43@RandaddBuf
  00080	83 e8 01	 sub	 eax, 1
  00083	74 0e		 je	 SHORT $LN44@RandaddBuf
  00085	83 e8 01	 sub	 eax, 1
  00088	74 10		 je	 SHORT $LN43@RandaddBuf
  0008a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00091	eb 0c		 jmp	 SHORT $LN9@RandaddBuf
$LN44@RandaddBuf:
  00093	be 20 00 00 00	 mov	 esi, 32			; 00000020H
  00098	eb 05		 jmp	 SHORT $LN9@RandaddBuf
$LN43@RandaddBuf:
  0009a	be 40 00 00 00	 mov	 esi, 64			; 00000040H
$LN9@RandaddBuf:
  0009f	b8 40 01 00 00	 mov	 eax, 320		; 00000140H
  000a4	99		 cdq
  000a5	f7 fe		 idiv	 esi
  000a7	85 d2		 test	 edx, edx
  000a9	74 07		 je	 SHORT $LN46@RandaddBuf
  000ab	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN46@RandaddBuf:
  000b2	33 ff		 xor	 edi, edi
  000b4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL13@RandaddBuf:
  000c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  000c5	83 e8 01	 sub	 eax, 1
  000c8	0f 84 80 00 00
	00		 je	 $LN48@RandaddBuf
  000ce	83 e8 01	 sub	 eax, 1
  000d1	74 46		 je	 SHORT $LN49@RandaddBuf
  000d3	83 e8 01	 sub	 eax, 1
  000d6	74 0c		 je	 SHORT $LN47@RandaddBuf
  000d8	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  000df	e9 a0 00 00 00	 jmp	 $LN14@RandaddBuf
$LN47@RandaddBuf:
  000e4	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _wctx$3[ebp]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 _WHIRLPOOL_init
  000f0	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _wctx$3[ebp]
  000f6	50		 push	 eax
  000f7	68 00 0a 00 00	 push	 2560			; 00000a00H
  000fc	ff 35 00 00 00
	00		 push	 DWORD PTR _pRandPool
  00102	e8 00 00 00 00	 call	 _WHIRLPOOL_add
  00107	8d 45 bc	 lea	 eax, DWORD PTR _hashOutputBuffer$5[ebp]
  0010a	50		 push	 eax
  0010b	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _wctx$3[ebp]
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize
  00117	eb 68		 jmp	 SHORT $LN172@RandaddBuf
$LN49@RandaddBuf:
  00119	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _gctx$4[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 _GOSTHASH_init
  00125	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _gctx$4[ebp]
  0012b	50		 push	 eax
  0012c	68 40 01 00 00	 push	 320			; 00000140H
  00131	ff 35 00 00 00
	00		 push	 DWORD PTR _pRandPool
  00137	e8 00 00 00 00	 call	 _GOSTHASH_add
  0013c	8d 45 bc	 lea	 eax, DWORD PTR _hashOutputBuffer$5[ebp]
  0013f	50		 push	 eax
  00140	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _gctx$4[ebp]
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 _GOSTHASH_finalize
  0014c	eb 33		 jmp	 SHORT $LN172@RandaddBuf
$LN48@RandaddBuf:
  0014e	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR _sctx$2[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 _STRIBOG_init
  0015a	68 00 0a 00 00	 push	 2560			; 00000a00H
  0015f	ff 35 00 00 00
	00		 push	 DWORD PTR _pRandPool
  00165	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR _sctx$2[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _STRIBOG_add
  00171	8d 45 bc	 lea	 eax, DWORD PTR _hashOutputBuffer$5[ebp]
  00174	50		 push	 eax
  00175	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR _sctx$2[ebp]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 _STRIBOG_finalize
$LN172@RandaddBuf:
  00181	83 c4 18	 add	 esp, 24			; 00000018H
$LN14@RandaddBuf:
  00184	33 c0		 xor	 eax, eax
  00186	85 f6		 test	 esi, esi
  00188	0f 8e 85 00 00
	00		 jle	 $LN11@RandaddBuf
  0018e	83 fe 20	 cmp	 esi, 32			; 00000020H
  00191	72 68		 jb	 SHORT $LN99@RandaddBuf
  00193	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
  00199	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  0019c	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]
  0019f	03 d6		 add	 edx, esi
  001a1	8d 4c 35 bb	 lea	 ecx, DWORD PTR _hashOutputBuffer$5[ebp+esi-1]
  001a5	03 d7		 add	 edx, edi
  001a7	3b d9		 cmp	 ebx, ecx
  001a9	77 07		 ja	 SHORT $LN100@RandaddBuf
  001ab	8d 4d bc	 lea	 ecx, DWORD PTR _hashOutputBuffer$5[ebp]
  001ae	3b d1		 cmp	 edx, ecx
  001b0	73 49		 jae	 SHORT $LN99@RandaddBuf
$LN100@RandaddBuf:
  001b2	8b ce		 mov	 ecx, esi
  001b4	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  001ba	79 05		 jns	 SHORT $LN170@RandaddBuf
  001bc	49		 dec	 ecx
  001bd	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  001c0	41		 inc	 ecx
$LN170@RandaddBuf:
  001c1	8b d6		 mov	 edx, esi
  001c3	2b d1		 sub	 edx, ecx
  001c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL18@RandaddBuf:
  001d0	0f 10 04 03	 movups	 xmm0, XMMWORD PTR [ebx+eax]
  001d4	0f 10 4c 05 bc	 movups	 xmm1, XMMWORD PTR _hashOutputBuffer$5[ebp+eax]
  001d9	66 0f ef c8	 pxor	 xmm1, xmm0
  001dd	0f 11 0c 03	 movups	 XMMWORD PTR [ebx+eax], xmm1
  001e1	0f 10 4c 05 cc	 movups	 xmm1, XMMWORD PTR _hashOutputBuffer$5[ebp+eax+16]
  001e6	0f 10 44 03 10	 movups	 xmm0, XMMWORD PTR [ebx+eax+16]
  001eb	66 0f ef c8	 pxor	 xmm1, xmm0
  001ef	0f 11 4c 03 10	 movups	 XMMWORD PTR [ebx+eax+16], xmm1
  001f4	83 c0 20	 add	 eax, 32			; 00000020H
  001f7	3b c2		 cmp	 eax, edx
  001f9	7c d5		 jl	 SHORT $LL18@RandaddBuf
$LN99@RandaddBuf:
  001fb	3b c6		 cmp	 eax, esi
  001fd	7d 14		 jge	 SHORT $LN11@RandaddBuf
  001ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pRandPool
  00205	03 d7		 add	 edx, edi
$LL98@RandaddBuf:
  00207	8a 4c 05 bc	 mov	 cl, BYTE PTR _hashOutputBuffer$5[ebp+eax]
  0020b	30 0c 02	 xor	 BYTE PTR [edx+eax], cl
  0020e	40		 inc	 eax
  0020f	3b c6		 cmp	 eax, esi
  00211	7c f4		 jl	 SHORT $LL98@RandaddBuf
$LN11@RandaddBuf:
  00213	03 fe		 add	 edi, esi
  00215	81 ff 40 01 00
	00		 cmp	 edi, 320		; 00000140H
  0021b	0f 8c 9f fe ff
	ff		 jl	 $LL13@RandaddBuf
  00221	8d 45 bc	 lea	 eax, DWORD PTR _hashOutputBuffer$5[ebp]
  00224	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00229	8b f9		 mov	 edi, ecx
  0022b	8b d0		 mov	 edx, eax
  0022d	0f 1f 00	 npad	 3
$LL57@RandaddBuf:
  00230	c6 02 00	 mov	 BYTE PTR [edx], 0
  00233	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00236	83 ef 01	 sub	 edi, 1
  00239	75 f5		 jne	 SHORT $LL57@RandaddBuf
  0023b	0f 1f 44 00 00	 npad	 5
$LL22@RandaddBuf:
  00240	c6 00 00	 mov	 BYTE PTR [eax], 0
  00243	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00246	83 e9 01	 sub	 ecx, 1
  00249	75 f5		 jne	 SHORT $LL22@RandaddBuf
  0024b	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  00250	83 e8 01	 sub	 eax, 1
  00253	74 78		 je	 SHORT $LN33@RandaddBuf
  00255	83 e8 01	 sub	 eax, 1
  00258	74 43		 je	 SHORT $LN38@RandaddBuf
  0025a	83 e8 01	 sub	 eax, 1
  0025d	74 0b		 je	 SHORT $LN28@RandaddBuf
  0025f	88 0d 00 00 00
	00		 mov	 BYTE PTR ds:0, cl
  00265	e9 91 00 00 00	 jmp	 $LN31@RandaddBuf
$LN28@RandaddBuf:
  0026a	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _wctx$3[ebp]
  00270	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00275	8b f9		 mov	 edi, ecx
  00277	8b d0		 mov	 edx, eax
  00279	0f 1f 80 00 00
	00 00		 npad	 7
$LL61@RandaddBuf:
  00280	c6 02 00	 mov	 BYTE PTR [edx], 0
  00283	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00286	83 ef 01	 sub	 edi, 1
  00289	75 f5		 jne	 SHORT $LL61@RandaddBuf
  0028b	0f 1f 44 00 00	 npad	 5
$LL29@RandaddBuf:
  00290	c6 00 00	 mov	 BYTE PTR [eax], 0
  00293	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00296	83 e9 01	 sub	 ecx, 1
  00299	75 f5		 jne	 SHORT $LL29@RandaddBuf
  0029b	eb 5e		 jmp	 SHORT $LN31@RandaddBuf
$LN38@RandaddBuf:
  0029d	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _gctx$4[ebp]
  002a3	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  002a8	8b f9		 mov	 edi, ecx
  002aa	8b d0		 mov	 edx, eax
  002ac	0f 1f 40 00	 npad	 4
$LL69@RandaddBuf:
  002b0	c6 02 00	 mov	 BYTE PTR [edx], 0
  002b3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  002b6	83 ef 01	 sub	 edi, 1
  002b9	75 f5		 jne	 SHORT $LL69@RandaddBuf
  002bb	0f 1f 44 00 00	 npad	 5
$LL39@RandaddBuf:
  002c0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002c3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002c6	83 e9 01	 sub	 ecx, 1
  002c9	75 f5		 jne	 SHORT $LL39@RandaddBuf
  002cb	eb 2e		 jmp	 SHORT $LN31@RandaddBuf
$LN33@RandaddBuf:
  002cd	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR _sctx$2[ebp]
  002d3	b9 81 01 00 00	 mov	 ecx, 385		; 00000181H
  002d8	8b f9		 mov	 edi, ecx
  002da	8b d0		 mov	 edx, eax
  002dc	0f 1f 40 00	 npad	 4
$LL65@RandaddBuf:
  002e0	c6 02 00	 mov	 BYTE PTR [edx], 0
  002e3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  002e6	83 ef 01	 sub	 edi, 1
  002e9	75 f5		 jne	 SHORT $LL65@RandaddBuf
  002eb	0f 1f 44 00 00	 npad	 5
$LL34@RandaddBuf:
  002f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002f3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002f6	83 e9 01	 sub	 ecx, 1
  002f9	75 f5		 jne	 SHORT $LL34@RandaddBuf
$LN31@RandaddBuf:
  002fb	8b 85 24 fd ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  00301	ff 05 00 00 00
	00		 inc	 DWORD PTR _nRandIndex
  00307	40		 inc	 eax
  00308	8b f8		 mov	 edi, eax
  0030a	89 85 24 fd ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  00310	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00313	0f 8c 17 fd ff
	ff		 jl	 $LL4@RandaddBuf
  00319	5e		 pop	 esi
  0031a	5b		 pop	 ebx
$LN3@RandaddBuf:

; 383  : 	}
; 384  : }

  0031b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0031e	33 cd		 xor	 ecx, ebp
  00320	5f		 pop	 edi
  00321	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00326	8b e5		 mov	 esp, ebp
  00328	5d		 pop	 ebp
  00329	c3		 ret	 0
_RandaddBuf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _Randmix
_TEXT	SEGMENT
_digestSize$1 = -732					; size = 4
_sctx$2 = -728						; size = 385
_wctx$3 = -340						; size = 168
_gctx$4 = -172						; size = 104
_hashOutputBuffer$5 = -68				; size = 64
__$ArrayPad$ = -4					; size = 4
_Randmix PROC						; COMDAT

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 02 00
	00		 sub	 esp, 732		; 000002dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 288  : 	if (bRandmixEnabled)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandmixEnabled, 0
  0001a	0f 84 9c 02 00
	00		 je	 $LN144@Randmix

; 289  : 	{
; 290  : 		unsigned char hashOutputBuffer [MAX_DIGESTSIZE];
; 291  : 		WHIRLPOOL_CTX	wctx;
; 292  : 		gost_hash_ctx	gctx;
; 293  : 		STRIBOG_CTX	sctx;
; 294  : 		int poolIndex, digestIndex, digestSize;
; 295  : 
; 296  : 		switch (HashFunction)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  00025	56		 push	 esi
  00026	83 e8 01	 sub	 eax, 1
  00029	74 20		 je	 SHORT $LN36@Randmix
  0002b	83 e8 01	 sub	 eax, 1
  0002e	74 14		 je	 SHORT $LN37@Randmix
  00030	83 e8 01	 sub	 eax, 1
  00033	74 16		 je	 SHORT $LN36@Randmix

; 307  : 		default:
; 308  : 			GST_THROW_FATAL_EXCEPTION;

  00035	8b b5 24 fd ff
	ff		 mov	 esi, DWORD PTR _digestSize$1[ebp]
  0003b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00042	eb 0c		 jmp	 SHORT $LN2@Randmix
$LN37@Randmix:

; 303  : 			break;
; 304  : 		case GOSTHASH:
; 305  : 			digestSize = GOSTHASH_DIGESTSIZE;

  00044	be 20 00 00 00	 mov	 esi, 32			; 00000020H

; 306  : 			break;

  00049	eb 05		 jmp	 SHORT $LN2@Randmix
$LN36@Randmix:

; 297  : 		{
; 298  : 		case WHIRLPOOL:
; 299  : 			digestSize = WHIRLPOOL_DIGESTSIZE;
; 300  : 			break;
; 301  : 		case STRIBOG:
; 302  : 			digestSize = STRIBOG_DIGESTSIZE;

  0004b	be 40 00 00 00	 mov	 esi, 64			; 00000040H
$LN2@Randmix:
  00050	53		 push	 ebx
  00051	57		 push	 edi

; 309  : 		}
; 310  : 
; 311  : 		if (RNG_POOL_SIZE % digestSize)
; 312  : 			GST_THROW_FATAL_EXCEPTION;
; 313  : 
; 314  : 		for (poolIndex = 0; poolIndex < RNG_POOL_SIZE; poolIndex += digestSize)		

  00052	33 db		 xor	 ebx, ebx
  00054	8d 7c 35 bb	 lea	 edi, DWORD PTR _hashOutputBuffer$5[ebp+esi-1]
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@Randmix:

; 315  : 		{
; 316  : 			/* Compute the message digest of the entire pool using the selected hash function. */
; 317  : 			switch (HashFunction)

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  00065	83 e8 01	 sub	 eax, 1
  00068	0f 84 80 00 00
	00		 je	 $LN41@Randmix
  0006e	83 e8 01	 sub	 eax, 1
  00071	74 46		 je	 SHORT $LN42@Randmix
  00073	83 e8 01	 sub	 eax, 1
  00076	74 0c		 je	 SHORT $LN40@Randmix

; 334  : 			default:		
; 335  : 				// Unknown/wrong ID
; 336  : 				GST_THROW_FATAL_EXCEPTION;

  00078	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  0007f	e9 a0 00 00 00	 jmp	 $LN7@Randmix
$LN40@Randmix:

; 318  : 			{
; 319  : 			case WHIRLPOOL:
; 320  : 				WHIRLPOOL_init (&wctx);

  00084	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _wctx$3[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _WHIRLPOOL_init

; 321  : 				WHIRLPOOL_add (pRandPool, RNG_POOL_SIZE * 8, &wctx);

  00090	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _wctx$3[ebp]
  00096	50		 push	 eax
  00097	68 00 0a 00 00	 push	 2560			; 00000a00H
  0009c	ff 35 00 00 00
	00		 push	 DWORD PTR _pRandPool
  000a2	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 322  : 				WHIRLPOOL_finalize (&wctx, hashOutputBuffer);

  000a7	8d 45 bc	 lea	 eax, DWORD PTR _hashOutputBuffer$5[ebp]
  000aa	50		 push	 eax
  000ab	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _wctx$3[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize

; 323  : 				break;

  000b7	eb 68		 jmp	 SHORT $LN162@Randmix
$LN42@Randmix:

; 328  : 				break;
; 329  : 			case GOSTHASH:
; 330  : 				GOSTHASH_init (&gctx);

  000b9	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _gctx$4[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 _GOSTHASH_init

; 331  : 				GOSTHASH_add (pRandPool, RNG_POOL_SIZE, &gctx);

  000c5	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _gctx$4[ebp]
  000cb	50		 push	 eax
  000cc	68 40 01 00 00	 push	 320			; 00000140H
  000d1	ff 35 00 00 00
	00		 push	 DWORD PTR _pRandPool
  000d7	e8 00 00 00 00	 call	 _GOSTHASH_add

; 332  : 				GOSTHASH_finalize (&gctx, hashOutputBuffer);

  000dc	8d 45 bc	 lea	 eax, DWORD PTR _hashOutputBuffer$5[ebp]
  000df	50		 push	 eax
  000e0	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _gctx$4[ebp]
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _GOSTHASH_finalize

; 333  : 				break;

  000ec	eb 33		 jmp	 SHORT $LN162@Randmix
$LN41@Randmix:

; 324  : 			case STRIBOG:
; 325  : 				STRIBOG_init (&sctx);

  000ee	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR _sctx$2[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _STRIBOG_init

; 326  : 				STRIBOG_add (&sctx, pRandPool, RNG_POOL_SIZE * 8);

  000fa	68 00 0a 00 00	 push	 2560			; 00000a00H
  000ff	ff 35 00 00 00
	00		 push	 DWORD PTR _pRandPool
  00105	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR _sctx$2[ebp]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _STRIBOG_add

; 327  : 				STRIBOG_finalize (&sctx, hashOutputBuffer);

  00111	8d 45 bc	 lea	 eax, DWORD PTR _hashOutputBuffer$5[ebp]
  00114	50		 push	 eax
  00115	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR _sctx$2[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 _STRIBOG_finalize
$LN162@Randmix:
  00121	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@Randmix:

; 341  : 			{
; 342  : 				pRandPool [poolIndex + digestIndex] ^= hashOutputBuffer [digestIndex];

  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
  0012a	33 c0		 xor	 eax, eax
  0012c	8d 14 19	 lea	 edx, DWORD PTR [ecx+ebx]
  0012f	49		 dec	 ecx
  00130	03 ce		 add	 ecx, esi
  00132	03 cb		 add	 ecx, ebx
  00134	3b d7		 cmp	 edx, edi
  00136	77 0b		 ja	 SHORT $LN91@Randmix
  00138	8d 7d bc	 lea	 edi, DWORD PTR _hashOutputBuffer$5[ebp]
  0013b	3b cf		 cmp	 ecx, edi
  0013d	8d 7c 35 bb	 lea	 edi, DWORD PTR _hashOutputBuffer$5[ebp+esi-1]
  00141	73 4c		 jae	 SHORT $LN90@Randmix
$LN91@Randmix:
  00143	8b ce		 mov	 ecx, esi
  00145	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  0014b	79 05		 jns	 SHORT $LN160@Randmix
  0014d	49		 dec	 ecx
  0014e	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  00151	41		 inc	 ecx
$LN160@Randmix:
  00152	8b fe		 mov	 edi, esi
  00154	2b f9		 sub	 edi, ecx
  00156	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL11@Randmix:
  00160	0f 10 04 02	 movups	 xmm0, XMMWORD PTR [edx+eax]
  00164	0f 10 4c 05 bc	 movups	 xmm1, XMMWORD PTR _hashOutputBuffer$5[ebp+eax]
  00169	66 0f ef c8	 pxor	 xmm1, xmm0
  0016d	0f 11 0c 02	 movups	 XMMWORD PTR [edx+eax], xmm1
  00171	0f 10 4c 05 cc	 movups	 xmm1, XMMWORD PTR _hashOutputBuffer$5[ebp+eax+16]
  00176	0f 10 44 02 10	 movups	 xmm0, XMMWORD PTR [edx+eax+16]
  0017b	66 0f ef c8	 pxor	 xmm1, xmm0
  0017f	0f 11 4c 02 10	 movups	 XMMWORD PTR [edx+eax+16], xmm1
  00184	83 c0 20	 add	 eax, 32			; 00000020H
  00187	3b c7		 cmp	 eax, edi
  00189	7c d5		 jl	 SHORT $LL11@Randmix
  0018b	8d 7c 35 bb	 lea	 edi, DWORD PTR _hashOutputBuffer$5[ebp+esi-1]
$LN90@Randmix:

; 337  : 			}
; 338  : 
; 339  : 			/* XOR the resultant message digest to the pool at the poolIndex position. */
; 340  : 			for (digestIndex = 0; digestIndex < digestSize; digestIndex++)

  0018f	3b c6		 cmp	 eax, esi
  00191	7d 0c		 jge	 SHORT $LN4@Randmix
$LL89@Randmix:

; 341  : 			{
; 342  : 				pRandPool [poolIndex + digestIndex] ^= hashOutputBuffer [digestIndex];

  00193	8a 4c 05 bc	 mov	 cl, BYTE PTR _hashOutputBuffer$5[ebp+eax]
  00197	30 0c 02	 xor	 BYTE PTR [edx+eax], cl
  0019a	40		 inc	 eax
  0019b	3b c6		 cmp	 eax, esi
  0019d	7c f4		 jl	 SHORT $LL89@Randmix
$LN4@Randmix:

; 309  : 		}
; 310  : 
; 311  : 		if (RNG_POOL_SIZE % digestSize)
; 312  : 			GST_THROW_FATAL_EXCEPTION;
; 313  : 
; 314  : 		for (poolIndex = 0; poolIndex < RNG_POOL_SIZE; poolIndex += digestSize)		

  0019f	03 de		 add	 ebx, esi
  001a1	81 fb 40 01 00
	00		 cmp	 ebx, 320		; 00000140H
  001a7	0f 8c b3 fe ff
	ff		 jl	 $LL6@Randmix

; 343  : 			}
; 344  : 		}
; 345  : 
; 346  : 		/* Prevent leaks */
; 347  : 		burn (hashOutputBuffer, MAX_DIGESTSIZE);	

  001ad	8d 45 bc	 lea	 eax, DWORD PTR _hashOutputBuffer$5[ebp]
  001b0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001b5	5f		 pop	 edi
  001b6	8b f1		 mov	 esi, ecx
  001b8	8b d0		 mov	 edx, eax
  001ba	5b		 pop	 ebx
  001bb	0f 1f 44 00 00	 npad	 5
$LL50@Randmix:
  001c0	c6 02 00	 mov	 BYTE PTR [edx], 0
  001c3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  001c6	83 ee 01	 sub	 esi, 1
  001c9	75 f5		 jne	 SHORT $LL50@Randmix
  001cb	0f 1f 44 00 00	 npad	 5
$LL15@Randmix:
  001d0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001d3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  001d6	83 e9 01	 sub	 ecx, 1
  001d9	75 f5		 jne	 SHORT $LL15@Randmix

; 348  : 		switch (HashFunction)

  001db	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  001e0	83 e8 01	 sub	 eax, 1
  001e3	0f 84 a4 00 00
	00		 je	 $LN26@Randmix
  001e9	83 e8 01	 sub	 eax, 1
  001ec	74 5f		 je	 SHORT $LN31@Randmix
  001ee	83 e8 01	 sub	 eax, 1
  001f1	74 18		 je	 SHORT $LN21@Randmix

; 358  : 			break;
; 359  : 		default:		
; 360  : 			// Unknown/wrong ID
; 361  : 			GST_THROW_FATAL_EXCEPTION;

  001f3	88 0d 00 00 00
	00		 mov	 BYTE PTR ds:0, cl

; 362  : 		}
; 363  : 	}
; 364  : 	return TRUE;

  001f9	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  001fc	5e		 pop	 esi

; 365  : }

  001fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00200	33 cd		 xor	 ecx, ebp
  00202	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c3		 ret	 0
$LN21@Randmix:

; 349  : 		{
; 350  : 		case WHIRLPOOL:
; 351  : 			burn (&wctx, sizeof(wctx));		

  0020b	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _wctx$3[ebp]
  00211	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00216	8b f1		 mov	 esi, ecx
  00218	8b d0		 mov	 edx, eax
  0021a	66 0f 1f 44 00
	00		 npad	 6
$LL54@Randmix:
  00220	c6 02 00	 mov	 BYTE PTR [edx], 0
  00223	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00226	83 ee 01	 sub	 esi, 1
  00229	75 f5		 jne	 SHORT $LL54@Randmix
  0022b	0f 1f 44 00 00	 npad	 5
$LL22@Randmix:
  00230	c6 00 00	 mov	 BYTE PTR [eax], 0
  00233	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00236	83 e9 01	 sub	 ecx, 1
  00239	75 f5		 jne	 SHORT $LL22@Randmix
  0023b	5e		 pop	 esi

; 362  : 		}
; 363  : 	}
; 364  : 	return TRUE;

  0023c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 365  : }

  0023f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00242	33 cd		 xor	 ecx, ebp
  00244	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00249	8b e5		 mov	 esp, ebp
  0024b	5d		 pop	 ebp
  0024c	c3		 ret	 0
$LN31@Randmix:

; 355  : 			break;
; 356  : 		case GOSTHASH:
; 357  : 			burn (&gctx, sizeof(gctx));

  0024d	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _gctx$4[ebp]
  00253	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00258	8b f1		 mov	 esi, ecx
  0025a	8b d0		 mov	 edx, eax
  0025c	0f 1f 40 00	 npad	 4
$LL62@Randmix:
  00260	c6 02 00	 mov	 BYTE PTR [edx], 0
  00263	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00266	83 ee 01	 sub	 esi, 1
  00269	75 f5		 jne	 SHORT $LL62@Randmix
  0026b	0f 1f 44 00 00	 npad	 5
$LL32@Randmix:
  00270	c6 00 00	 mov	 BYTE PTR [eax], 0
  00273	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00276	83 e9 01	 sub	 ecx, 1
  00279	75 f5		 jne	 SHORT $LL32@Randmix
  0027b	5e		 pop	 esi

; 362  : 		}
; 363  : 	}
; 364  : 	return TRUE;

  0027c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 365  : }

  0027f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00282	33 cd		 xor	 ecx, ebp
  00284	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c3		 ret	 0
$LN26@Randmix:

; 352  : 			break;
; 353  : 		case STRIBOG:
; 354  : 			burn (&sctx, sizeof(sctx));

  0028d	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR _sctx$2[ebp]
  00293	b9 81 01 00 00	 mov	 ecx, 385		; 00000181H
  00298	8b f1		 mov	 esi, ecx
  0029a	8b d0		 mov	 edx, eax
  0029c	0f 1f 40 00	 npad	 4
$LL58@Randmix:
  002a0	c6 02 00	 mov	 BYTE PTR [edx], 0
  002a3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  002a6	83 ee 01	 sub	 esi, 1
  002a9	75 f5		 jne	 SHORT $LL58@Randmix
  002ab	0f 1f 44 00 00	 npad	 5
$LL27@Randmix:
  002b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002b3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002b6	83 e9 01	 sub	 ecx, 1
  002b9	75 f5		 jne	 SHORT $LL27@Randmix
  002bb	5e		 pop	 esi
$LN144@Randmix:

; 365  : }

  002bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bf	b8 01 00 00 00	 mov	 eax, 1
  002c4	33 cd		 xor	 ecx, ebp
  002c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cb	8b e5		 mov	 esp, ebp
  002cd	5d		 pop	 ebp
  002ce	c3		 ret	 0
_Randmix ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _IsRandomPoolEnrichedByUser
_TEXT	SEGMENT
_IsRandomPoolEnrichedByUser PROC			; COMDAT

; 275  : 	return RandomPoolEnrichedByUser;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _RandomPoolEnrichedByUser

; 276  : }

  00005	c3		 ret	 0
_IsRandomPoolEnrichedByUser ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _SetRandomPoolEnrichedByUserStatus
_TEXT	SEGMENT
_enriched$ = 8						; size = 4
_SetRandomPoolEnrichedByUserStatus PROC			; COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 263  : 	RandomPoolEnrichedByUser = enriched;

  00003	8b 45 08	 mov	 eax, DWORD PTR _enriched$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR _RandomPoolEnrichedByUser, eax

; 264  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_SetRandomPoolEnrichedByUserStatus ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _RandGetHashFunction
_TEXT	SEGMENT
_RandGetHashFunction PROC				; COMDAT

; 250  : 	return HashFunction;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction

; 251  : }

  00005	c3		 ret	 0
_RandGetHashFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _RandSetHashFunction
_TEXT	SEGMENT
_hash_algo_id$ = 8					; size = 4
_RandSetHashFunction PROC				; COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 235  : 	if (HashIsDeprecated (hash_algo_id))

  00004	8b 75 08	 mov	 esi, DWORD PTR _hash_algo_id$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 _HashIsDeprecated
  0000d	83 c4 04	 add	 esp, 4
  00010	b9 01 00 00 00	 mov	 ecx, 1
  00015	85 c0		 test	 eax, eax
  00017	0f 45 f1	 cmovne	 esi, ecx

; 236  : 		hash_algo_id = DEFAULT_HASH_ALGORITHM;
; 237  : 
; 238  : 	HashFunction = hash_algo_id;

  0001a	89 35 00 00 00
	00		 mov	 DWORD PTR _HashFunction, esi
  00020	5e		 pop	 esi

; 239  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_RandSetHashFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _IsRandomNumberGeneratorStarted
_TEXT	SEGMENT
_IsRandomNumberGeneratorStarted PROC			; COMDAT

; 222  : 	return bRandDidInit;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _bRandDidInit

; 223  : }

  00005	c3		 ret	 0
_IsRandomNumberGeneratorStarted ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _RandStop
_TEXT	SEGMENT
_freePool$ = 8						; size = 4
_RandStop PROC						; COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 159  : 	if (!bRandDidInit && freePool && pRandPool)

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandDidInit, 0
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _freePool$[ebp]
  0000f	75 1a		 jne	 SHORT $LN30@RandStop
  00011	85 ff		 test	 edi, edi
  00013	0f 84 26 01 00
	00		 je	 $LN15@RandStop
  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _pRandPool
  0001f	85 f6		 test	 esi, esi
  00021	0f 85 c8 00 00
	00		 jne	 $freePool$38
  00027	5f		 pop	 edi
  00028	5e		 pop	 esi

; 209  : 		}
; 210  : 	}
; 211  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN30@RandStop:

; 160  : 		goto freePool;
; 161  : 
; 162  : 	if (bRandDidInit == FALSE)
; 163  : 		return;
; 164  : 
; 165  : 	EnterCriticalSection (&critRandProt);

  0002b	68 00 00 00 00	 push	 OFFSET _critRandProt
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 166  : 
; 167  : 	if (hMouse != 0)

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMouse
  0003b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__UnhookWindowsHookEx@4
  00041	85 c0		 test	 eax, eax
  00043	74 03		 je	 SHORT $LN9@RandStop

; 168  : 		UnhookWindowsHookEx (hMouse);

  00045	50		 push	 eax
  00046	ff d6		 call	 esi
$LN9@RandStop:

; 169  : 	if (hKeyboard != 0)

  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _hKeyboard
  0004d	85 c0		 test	 eax, eax
  0004f	74 03		 je	 SHORT $LN10@RandStop

; 170  : 		UnhookWindowsHookEx (hKeyboard);

  00051	50		 push	 eax
  00052	ff d6		 call	 esi
$LN10@RandStop:

; 171  : 
; 172  : 	bThreadTerminate = TRUE;
; 173  : 
; 174  : 	LeaveCriticalSection (&critRandProt);

  00054	68 00 00 00 00	 push	 OFFSET _critRandProt
  00059	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bThreadTerminate, 1
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 175  : 
; 176  : 	if (PeriodicFastPollThreadHandle)

  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _PeriodicFastPollThreadHandle
  0006e	85 c0		 test	 eax, eax
  00070	74 09		 je	 SHORT $LN11@RandStop

; 177  : 		WaitForSingleObject (PeriodicFastPollThreadHandle, INFINITE);

  00072	6a ff		 push	 -1
  00074	50		 push	 eax
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN11@RandStop:

; 178  : 
; 179  : 	if (hNetAPI32 != 0)

  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hNetAPI32
  00080	85 c0		 test	 eax, eax
  00082	74 11		 je	 SHORT $LN12@RandStop

; 180  : 	{
; 181  : 		FreeLibrary (hNetAPI32);

  00084	50		 push	 eax
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 182  : 		hNetAPI32 = NULL;

  0008b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hNetAPI32, 0
$LN12@RandStop:

; 183  : 	}
; 184  : 
; 185  : 	if (CryptoAPIAvailable)

  00095	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CryptoAPIAvailable, 0
  0009c	74 18		 je	 SHORT $LN13@RandStop

; 186  : 	{
; 187  : 		CryptReleaseContext (hCryptProv, 0);

  0009e	6a 00		 push	 0
  000a0	ff 35 00 00 00
	00		 push	 DWORD PTR _hCryptProv
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptReleaseContext@8

; 188  : 		CryptoAPIAvailable = FALSE;

  000ac	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CryptoAPIAvailable, 0
$LN13@RandStop:

; 189  : 	}
; 190  : 
; 191  : 	hMouse = NULL;

  000b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hMouse, 0

; 192  : 	hKeyboard = NULL;

  000c0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hKeyboard, 0

; 193  : 	bThreadTerminate = FALSE;
; 194  : 	DeleteCriticalSection (&critRandProt);

  000ca	68 00 00 00 00	 push	 OFFSET _critRandProt
  000cf	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bThreadTerminate, 0
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 195  : 
; 196  : 	bRandDidInit = FALSE;

  000df	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _pRandPool
  000e5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bRandDidInit, 0
$freePool$38:

; 197  : 
; 198  : freePool:
; 199  : 	if (freePool)

  000ef	85 ff		 test	 edi, edi
  000f1	74 4c		 je	 SHORT $LN15@RandStop

; 200  : 	{
; 201  : 		bDidSlowPoll = FALSE;

  000f3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bDidSlowPoll, 0

; 202  : 		RandomPoolEnrichedByUser = FALSE;

  000fd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _RandomPoolEnrichedByUser, 0

; 203  : 
; 204  : 		if (pRandPool != NULL)

  00107	85 f6		 test	 esi, esi
  00109	74 34		 je	 SHORT $LN15@RandStop

; 205  : 		{
; 206  : 			burn (pRandPool, RANDOMPOOL_ALLOCSIZE);

  0010b	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  00110	8b c6		 mov	 eax, esi
  00112	8b f9		 mov	 edi, ecx
  00114	8b d6		 mov	 edx, esi
$LL18@RandStop:
  00116	c6 02 00	 mov	 BYTE PTR [edx], 0
  00119	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0011c	83 ef 01	 sub	 edi, 1
  0011f	75 f5		 jne	 SHORT $LL18@RandStop
$LL5@RandStop:
  00121	c6 00 00	 mov	 BYTE PTR [eax], 0
  00124	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00127	83 e9 01	 sub	 ecx, 1
  0012a	75 f5		 jne	 SHORT $LL5@RandStop

; 207  : 			GSTfree (pRandPool);

  0012c	56		 push	 esi
  0012d	e8 00 00 00 00	 call	 _free
  00132	83 c4 04	 add	 esp, 4

; 208  : 			pRandPool = NULL;

  00135	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _pRandPool, 0
$LN15@RandStop:
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi

; 209  : 		}
; 210  : 	}
; 211  : }

  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
_RandStop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _Randinit
_TEXT	SEGMENT
_Randinit PROC						; COMDAT

; 99   : 	if (GetMaxPkcs5OutSize() > RNG_POOL_SIZE)

  00000	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00005	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0000a	7e 07		 jle	 SHORT $LN2@Randinit

; 100  : 		GST_THROW_FATAL_EXCEPTION;

  0000c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN2@Randinit:

; 101  : 
; 102  : 	if(bRandDidInit) 

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandDidInit, 0
  0001a	74 03		 je	 SHORT $LN3@Randinit

; 103  : 		return 0;

  0001c	33 c0		 xor	 eax, eax

; 146  : }

  0001e	c3		 ret	 0
$LN3@Randinit:
  0001f	56		 push	 esi

; 104  : 
; 105  : 	InitializeCriticalSection (&critRandProt);

  00020	68 00 00 00 00	 push	 OFFSET _critRandProt
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 106  : 
; 107  : 	bRandDidInit = TRUE;
; 108  : 
; 109  : 	if (pRandPool == NULL)

  0002b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pRandPool, 0
  00032	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bRandDidInit, 1
  0003c	75 4d		 jne	 SHORT $LN4@Randinit

; 110  : 	{
; 111  : 		pRandPool = (unsigned char *) GSTalloc (RANDOMPOOL_ALLOCSIZE);

  0003e	68 40 01 00 00	 push	 320			; 00000140H
  00043	e8 00 00 00 00	 call	 _malloc
  00048	8b f0		 mov	 esi, eax
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 35 00 00 00
	00		 mov	 DWORD PTR _pRandPool, esi

; 112  : 		if (pRandPool == NULL)

  00053	85 f6		 test	 esi, esi
  00055	0f 84 ec 00 00
	00		 je	 $error$14

; 113  : 			goto error;
; 114  : 
; 115  : 		bDidSlowPoll = FALSE;
; 116  : 		RandomPoolEnrichedByUser = FALSE;
; 117  : 
; 118  : 		memset (pRandPool, 0, RANDOMPOOL_ALLOCSIZE);

  0005b	68 40 01 00 00	 push	 320			; 00000140H
  00060	6a 00		 push	 0
  00062	56		 push	 esi
  00063	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bDidSlowPoll, 0
  0006d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _RandomPoolEnrichedByUser, 0
  00077	e8 00 00 00 00	 call	 _memset
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 119  : 		VirtualLock (pRandPool, RANDOMPOOL_ALLOCSIZE);

  0007f	68 40 01 00 00	 push	 320			; 00000140H
  00084	56		 push	 esi
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8
$LN4@Randinit:

; 120  : 	}
; 121  : 
; 122  : 	hKeyboard = SetWindowsHookEx (WH_KEYBOARD, (HOOKPROC)&KeyboardProc, NULL, GetCurrentThreadId ());

  0008b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetCurrentThreadId@0
  00091	ff d6		 call	 esi
  00093	50		 push	 eax
  00094	6a 00		 push	 0
  00096	68 00 00 00 00	 push	 OFFSET _KeyboardProc@12
  0009b	6a 02		 push	 2
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowsHookExA@16
  000a3	a3 00 00 00 00	 mov	 DWORD PTR _hKeyboard, eax

; 123  : 	if (hKeyboard == 0) handleWin32Error (0);

  000a8	85 c0		 test	 eax, eax
  000aa	75 09		 jne	 SHORT $LN6@Randinit
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _handleWin32Error
  000b2	83 c4 04	 add	 esp, 4
$LN6@Randinit:

; 124  : 
; 125  : 	hMouse = SetWindowsHookEx (WH_MOUSE, (HOOKPROC)&MouseProc, NULL, GetCurrentThreadId ());

  000b5	ff d6		 call	 esi
  000b7	50		 push	 eax
  000b8	6a 00		 push	 0
  000ba	68 00 00 00 00	 push	 OFFSET _MouseProc@12
  000bf	6a 07		 push	 7
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowsHookExA@16
  000c7	a3 00 00 00 00	 mov	 DWORD PTR _hMouse, eax

; 126  : 	if (hMouse == 0)
; 127  : 	{
; 128  : 		handleWin32Error (0);

  000cc	6a 00		 push	 0
  000ce	85 c0		 test	 eax, eax
  000d0	75 19		 jne	 SHORT $LN7@Randinit
  000d2	e8 00 00 00 00	 call	 _handleWin32Error
  000d7	83 c4 04	 add	 esp, 4

; 142  : 
; 143  : error:
; 144  : 	RandStop (TRUE);

  000da	6a 01		 push	 1
  000dc	e8 00 00 00 00	 call	 _RandStop
  000e1	83 c4 04	 add	 esp, 4

; 145  : 	return 1;

  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	5e		 pop	 esi

; 146  : }

  000ea	c3		 ret	 0
$LN7@Randinit:

; 129  : 		goto error;
; 130  : 	}
; 131  : 
; 132  : 	if (!CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL, 0)
; 133  : 		&& !CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))

  000eb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CryptAcquireContextA@20
  000f1	6a 01		 push	 1
  000f3	6a 00		 push	 0
  000f5	6a 00		 push	 0
  000f7	68 00 00 00 00	 push	 OFFSET _hCryptProv
  000fc	ff d6		 call	 esi
  000fe	85 c0		 test	 eax, eax
  00100	75 1b		 jne	 SHORT $LN8@Randinit
  00102	6a 08		 push	 8
  00104	6a 01		 push	 1
  00106	50		 push	 eax
  00107	50		 push	 eax
  00108	68 00 00 00 00	 push	 OFFSET _hCryptProv
  0010d	ff d6		 call	 esi

; 134  : 		CryptoAPIAvailable = FALSE;

  0010f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CryptoAPIAvailable, 0
  00119	85 c0		 test	 eax, eax
  0011b	74 0a		 je	 SHORT $LN9@Randinit
$LN8@Randinit:

; 135  : 	else
; 136  : 		CryptoAPIAvailable = TRUE;

  0011d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CryptoAPIAvailable, 1
$LN9@Randinit:

; 137  : 
; 138  : 	if (!(PeriodicFastPollThreadHandle = (HANDLE) _beginthreadex (NULL, 0, PeriodicFastPollThreadProc, NULL, 0, NULL)))

  00127	6a 00		 push	 0
  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	68 00 00 00 00	 push	 OFFSET _PeriodicFastPollThreadProc@4
  00132	6a 00		 push	 0
  00134	6a 00		 push	 0
  00136	e8 00 00 00 00	 call	 __beginthreadex
  0013b	83 c4 18	 add	 esp, 24			; 00000018H
  0013e	a3 00 00 00 00	 mov	 DWORD PTR _PeriodicFastPollThreadHandle, eax
  00143	85 c0		 test	 eax, eax
  00145	75 11		 jne	 SHORT $LN10@Randinit
$error$14:

; 142  : 
; 143  : error:
; 144  : 	RandStop (TRUE);

  00147	6a 01		 push	 1
  00149	e8 00 00 00 00	 call	 _RandStop
  0014e	83 c4 04	 add	 esp, 4

; 145  : 	return 1;

  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	5e		 pop	 esi

; 146  : }

  00157	c3		 ret	 0
$LN10@Randinit:

; 139  : 		goto error;
; 140  : 
; 141  : 	return 0;

  00158	33 c0		 xor	 eax, eax
  0015a	5e		 pop	 esi

; 146  : }

  0015b	c3		 ret	 0
_Randinit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\random.c
;	COMDAT _RandAddInt
_TEXT	SEGMENT
_x$ = 8							; size = 4
_RandAddInt PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	RandaddByte(x); 

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nRandIndex
  00009	33 c0		 xor	 eax, eax
  0000b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pRandPool
  00011	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _x$[ebp]
  0001b	0f 44 c8	 cmove	 ecx, eax
  0001e	00 1c 0a	 add	 BYTE PTR [edx+ecx], bl
  00021	89 0d 00 00 00
	00		 mov	 DWORD PTR _nRandIndex, ecx
  00027	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0002a	8b c1		 mov	 eax, ecx
  0002c	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  00031	79 05		 jns	 SHORT $LN12@RandAddInt
  00033	48		 dec	 eax
  00034	83 c8 f0	 or	 eax, -16		; fffffff0H
  00037	40		 inc	 eax
$LN12@RandAddInt:
  00038	75 11		 jne	 SHORT $LN3@RandAddInt
  0003a	e8 00 00 00 00	 call	 _Randmix
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nRandIndex
  00045	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pRandPool
$LN3@RandAddInt:

; 61   : 	RandaddByte((x >> 8)); 

  0004b	33 c0		 xor	 eax, eax
  0004d	41		 inc	 ecx
  0004e	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  00054	0f 44 c8	 cmove	 ecx, eax
  00057	8b c3		 mov	 eax, ebx
  00059	c1 e8 08	 shr	 eax, 8
  0005c	89 0d 00 00 00
	00		 mov	 DWORD PTR _nRandIndex, ecx
  00062	00 04 0a	 add	 BYTE PTR [edx+ecx], al
  00065	8b c1		 mov	 eax, ecx
  00067	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  0006c	79 05		 jns	 SHORT $LN13@RandAddInt
  0006e	48		 dec	 eax
  0006f	83 c8 f0	 or	 eax, -16		; fffffff0H
  00072	40		 inc	 eax
$LN13@RandAddInt:
  00073	75 11		 jne	 SHORT $LN5@RandAddInt
  00075	e8 00 00 00 00	 call	 _Randmix
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nRandIndex
  00080	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pRandPool
$LN5@RandAddInt:

; 62   : 	RandaddByte((x >> 16));

  00086	33 c0		 xor	 eax, eax
  00088	41		 inc	 ecx
  00089	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  0008f	0f 44 c8	 cmove	 ecx, eax
  00092	8b c3		 mov	 eax, ebx
  00094	c1 e8 10	 shr	 eax, 16			; 00000010H
  00097	89 0d 00 00 00
	00		 mov	 DWORD PTR _nRandIndex, ecx
  0009d	00 04 0a	 add	 BYTE PTR [edx+ecx], al
  000a0	8b c1		 mov	 eax, ecx
  000a2	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  000a7	79 05		 jns	 SHORT $LN14@RandAddInt
  000a9	48		 dec	 eax
  000aa	83 c8 f0	 or	 eax, -16		; fffffff0H
  000ad	40		 inc	 eax
$LN14@RandAddInt:
  000ae	75 11		 jne	 SHORT $LN7@RandAddInt
  000b0	e8 00 00 00 00	 call	 _Randmix
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nRandIndex
  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pRandPool
$LN7@RandAddInt:

; 63   : 	RandaddByte((x >> 24));

  000c1	33 c0		 xor	 eax, eax
  000c3	41		 inc	 ecx
  000c4	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  000ca	0f 44 c8	 cmove	 ecx, eax
  000cd	c1 eb 18	 shr	 ebx, 24			; 00000018H
  000d0	00 1c 0a	 add	 BYTE PTR [edx+ecx], bl
  000d3	89 0d 00 00 00
	00		 mov	 DWORD PTR _nRandIndex, ecx
  000d9	5b		 pop	 ebx
  000da	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  000dd	8b c1		 mov	 eax, ecx
  000df	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  000e4	79 05		 jns	 SHORT $LN15@RandAddInt
  000e6	48		 dec	 eax
  000e7	83 c8 f0	 or	 eax, -16		; fffffff0H
  000ea	40		 inc	 eax
$LN15@RandAddInt:
  000eb	75 0d		 jne	 SHORT $LN11@RandAddInt
  000ed	e8 00 00 00 00	 call	 _Randmix
  000f2	ff 05 00 00 00
	00		 inc	 DWORD PTR _nRandIndex

; 64   : }

  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
$LN11@RandAddInt:

; 63   : 	RandaddByte((x >> 24));

  000fa	41		 inc	 ecx
  000fb	89 0d 00 00 00
	00		 mov	 DWORD PTR _nRandIndex, ecx

; 64   : }

  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
_RandAddInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
