; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Desktop\Sources_GostCrypt_Windows_1.3.1_COMMENTED\Sources_GostCrypt_Windows_1.3.1é\Sources_GostCrypt_Windows_1.3.1\Common\Inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_mask_bits
_DATA	SEGMENT
COMM	_G:BYTE:02cH
COMM	_redirSlide:BYTE:08000H
_DATA	ENDS
CONST	SEGMENT
_cplens	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
_cplext	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	00H
	DW	063H
	DW	063H
	ORG $+2
_cpdist	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
_cpdext	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	06H
	DW	06H
	DW	07H
	DW	07H
	DW	08H
	DW	08H
	DW	09H
	DW	09H
	DW	0aH
	DW	0aH
	DW	0bH
	DW	0bH
	DW	0cH
	DW	0cH
	DW	0dH
	DW	0dH
_mask_bits DW	00H
	DW	01H
	DW	03H
	DW	07H
	DW	0fH
	DW	01fH
	DW	03fH
	DW	07fH
	DW	0ffH
	DW	01ffH
	DW	03ffH
	DW	07ffH
	DW	0fffH
	DW	01fffH
	DW	03fffH
	DW	07fffH
	DW	0ffffH
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_huft_free
PUBLIC	_huft_build
PUBLIC	_DecompressDeflatedData
PUBLIC	_inflate_codes
PUBLIC	_inflate
PUBLIC	_inflate_free
PUBLIC	??_C@_0BG@DPKBCABB@?$CIincomplete?5l?9tree?$CJ?5?5?$AA@ ; `string'
PUBLIC	??_C@_0BG@CMHGGAOF@?$CIincomplete?5d?9tree?$CJ?5?5?$AA@ ; `string'
PUBLIC	__xmm@00000005000000050000000500000005
PUBLIC	__xmm@00000007000000070000000700000007
PUBLIC	__xmm@00000008000000080000000800000008
EXTRN	___acrt_iob_func:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __xmm@00000008000000080000000800000008
CONST	SEGMENT
__xmm@00000008000000080000000800000008 DB 08H, 00H, 00H, 00H, 08H, 00H, 00H
	DB	00H, 08H, 00H, 00H, 00H, 08H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000007000000070000000700000007
CONST	SEGMENT
__xmm@00000007000000070000000700000007 DB 07H, 00H, 00H, 00H, 07H, 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 07H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000005000000050000000500000005
CONST	SEGMENT
__xmm@00000005000000050000000500000005 DB 05H, 00H, 00H, 00H, 05H, 00H, 00H
	DB	00H, 05H, 00H, 00H, 00H, 05H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT ??_C@_0BG@CMHGGAOF@?$CIincomplete?5d?9tree?$CJ?5?5?$AA@
CONST	SEGMENT
??_C@_0BG@CMHGGAOF@?$CIincomplete?5d?9tree?$CJ?5?5?$AA@ DB '(incomplete d'
	DB	'-tree)  ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DPKBCABB@?$CIincomplete?5l?9tree?$CJ?5?5?$AA@
CONST	SEGMENT
??_C@_0BG@DPKBCABB@?$CIincomplete?5l?9tree?$CJ?5?5?$AA@ DB '(incomplete l'
	DB	'-tree)  ', 00H				; `string'
CONST	ENDS
CONST	SEGMENT
	ORG $+6
_border	DD	010H
	DD	011H
	DD	012H
	DD	00H
	DD	08H
	DD	07H
	DD	09H
	DD	06H
	DD	0aH
	DD	05H
	DD	0bH
	DD	04H
	DD	0cH
	DD	03H
	DD	0dH
	DD	02H
	DD	0eH
	DD	01H
	DD	0fH
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\inflate.c
;	COMDAT _inflate_free
_TEXT	SEGMENT
_inflate_free PROC					; COMDAT

; 1050 :   if (G.fixed_tl != (struct huft *)NULL)

  00000	a1 10 00 00 00	 mov	 eax, DWORD PTR _G+16
  00005	85 c0		 test	 eax, eax
  00007	74 53		 je	 SHORT $LN20@inflate_fr

; 1051 :   {
; 1052 :     huft_free(G.fixed_td);

  00009	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _G+20
  0000f	56		 push	 esi
  00010	85 c9		 test	 ecx, ecx
  00012	74 1a		 je	 SHORT $LN6@inflate_fr
$LL5@inflate_fr:
  00014	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  00017	83 e9 08	 sub	 ecx, 8
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _free
  00020	83 c4 04	 add	 esp, 4
  00023	8b ce		 mov	 ecx, esi
  00025	85 f6		 test	 esi, esi
  00027	75 eb		 jne	 SHORT $LL5@inflate_fr
  00029	a1 10 00 00 00	 mov	 eax, DWORD PTR _G+16
$LN6@inflate_fr:

; 1053 :     huft_free(G.fixed_tl);

  0002e	85 c0		 test	 eax, eax
  00030	74 15		 je	 SHORT $LN10@inflate_fr
$LL9@inflate_fr:
  00032	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  00035	83 e8 08	 sub	 eax, 8
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _free
  0003e	83 c4 04	 add	 esp, 4
  00041	8b c6		 mov	 eax, esi
  00043	85 f6		 test	 esi, esi
  00045	75 eb		 jne	 SHORT $LL9@inflate_fr
$LN10@inflate_fr:

; 1054 :     G.fixed_td = G.fixed_tl = (struct huft *)NULL;

  00047	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+16, 0
  00051	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+20, 0
  0005b	5e		 pop	 esi
$LN20@inflate_fr:

; 1055 :   }
; 1056 :   return 0;

  0005c	33 c0		 xor	 eax, eax

; 1057 : }

  0005e	c3		 ret	 0
_inflate_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\inflate.c
;	COMDAT _inflate
_TEXT	SEGMENT
_e$1$ = -4						; size = 4
_inflate PROC						; COMDAT

; 1001 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1002 :   int e;                /* last block flag */
; 1003 :   int r;                /* result code */
; 1004 : //#ifdef DEBUG
; 1005 : //  unsigned h = 0;       /* maximum struct huft's malloc'ed */
; 1006 : //#endif
; 1007 : 
; 1008 : #if (defined(DLL) && !defined(NO_SLIDE_REDIR))
; 1009 :   if (G.redirect_slide)
; 1010 :     wsize = G.redirect_size, redirSlide = G.redirect_buffer;
; 1011 :   else
; 1012 :     wsize = WSIZE, redirSlide = slide;   /* how they're #defined if !DLL */
; 1013 : #endif
; 1014 : 
; 1015 :   /* initialize window, bit buffer */
; 1016 :   G.wp = 0;
; 1017 :   G.bk = 0;

  00006	33 f6		 xor	 esi, esi
  00008	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+36, 0
  00012	57		 push	 edi

; 1018 :   G.bb = 0;

  00013	33 ff		 xor	 edi, edi
  00015	89 35 20 00 00
	00		 mov	 DWORD PTR _G+32, esi
  0001b	89 3d 28 00 00
	00		 mov	 DWORD PTR _G+40, edi
$LL4@inflate:

; 1019 : 
; 1020 : 
; 1021 :   /* decompress until the last block */
; 1022 :   do {
; 1023 : //#ifdef DEBUG
; 1024 : //    G.hufts = 0;
; 1025 : //#endif
; 1026 :     if ((r = inflate_block(__G__ &e)) != 0)

  00021	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  00026	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _G
  0002c	83 fe 01	 cmp	 esi, 1
  0002f	73 31		 jae	 SHORT $LN9@inflate
$LL8@inflate:
  00031	8b c8		 mov	 ecx, eax
  00033	48		 dec	 eax
  00034	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  00039	85 c9		 test	 ecx, ecx
  0003b	0f 88 ad 00 00
	00		 js	 $LN18@inflate
  00041	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  00044	42		 inc	 edx
  00045	89 15 00 00 00
	00		 mov	 DWORD PTR _G, edx
  0004b	83 fb ff	 cmp	 ebx, -1
  0004e	0f 84 9a 00 00
	00		 je	 $LN18@inflate
  00054	8b ce		 mov	 ecx, esi
  00056	83 c6 08	 add	 esi, 8
  00059	d3 e3		 shl	 ebx, cl
  0005b	0b fb		 or	 edi, ebx
  0005d	83 fe 01	 cmp	 esi, 1
  00060	72 cf		 jb	 SHORT $LL8@inflate
$LN9@inflate:
  00062	8b df		 mov	 ebx, edi
  00064	4e		 dec	 esi
  00065	83 e3 01	 and	 ebx, 1
  00068	d1 ef		 shr	 edi, 1
  0006a	89 5d fc	 mov	 DWORD PTR _e$1$[ebp], ebx
  0006d	83 fe 02	 cmp	 esi, 2
  00070	73 2c		 jae	 SHORT $LN38@inflate
$LL10@inflate:
  00072	8b c8		 mov	 ecx, eax
  00074	48		 dec	 eax
  00075	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  0007a	85 c9		 test	 ecx, ecx
  0007c	78 70		 js	 SHORT $LN18@inflate
  0007e	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  00081	42		 inc	 edx
  00082	89 15 00 00 00
	00		 mov	 DWORD PTR _G, edx
  00088	83 fb ff	 cmp	 ebx, -1
  0008b	74 61		 je	 SHORT $LN18@inflate
  0008d	8b ce		 mov	 ecx, esi
  0008f	83 c6 08	 add	 esi, 8
  00092	d3 e3		 shl	 ebx, cl
  00094	0b fb		 or	 edi, ebx
  00096	83 fe 02	 cmp	 esi, 2
  00099	72 d7		 jb	 SHORT $LL10@inflate
  0009b	8b 5d fc	 mov	 ebx, DWORD PTR _e$1$[ebp]
$LN38@inflate:
  0009e	8b cf		 mov	 ecx, edi
  000a0	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  000a3	83 e1 03	 and	 ecx, 3
  000a6	c1 ef 02	 shr	 edi, 2
  000a9	89 3d 28 00 00
	00		 mov	 DWORD PTR _G+40, edi
  000af	a3 20 00 00 00	 mov	 DWORD PTR _G+32, eax
  000b4	83 f9 02	 cmp	 ecx, 2
  000b7	75 07		 jne	 SHORT $LN14@inflate
  000b9	e8 00 00 00 00	 call	 _inflate_dynamic
  000be	eb 15		 jmp	 SHORT $LN7@inflate
$LN14@inflate:
  000c0	85 c9		 test	 ecx, ecx
  000c2	75 07		 jne	 SHORT $LN15@inflate
  000c4	e8 00 00 00 00	 call	 _inflate_stored
  000c9	eb 0a		 jmp	 SHORT $LN7@inflate
$LN15@inflate:
  000cb	83 f9 01	 cmp	 ecx, 1
  000ce	75 5d		 jne	 SHORT $LN16@inflate
  000d0	e8 00 00 00 00	 call	 _inflate_fixed
$LN7@inflate:
  000d5	85 c0		 test	 eax, eax
  000d7	75 59		 jne	 SHORT $LN1@inflate

; 1027 :       return r;
; 1028 : //#ifdef DEBUG
; 1029 : //    if (G.hufts > h)
; 1030 : //      h = G.hufts;
; 1031 : //#endif
; 1032 :   } while (!e);

  000d9	85 db		 test	 ebx, ebx
  000db	75 1d		 jne	 SHORT $LN28@inflate
  000dd	8b 3d 28 00 00
	00		 mov	 edi, DWORD PTR _G+40
  000e3	8b 35 20 00 00
	00		 mov	 esi, DWORD PTR _G+32
  000e9	e9 33 ff ff ff	 jmp	 $LL4@inflate

; 1019 : 
; 1020 : 
; 1021 :   /* decompress until the last block */
; 1022 :   do {
; 1023 : //#ifdef DEBUG
; 1024 : //    G.hufts = 0;
; 1025 : //#endif
; 1026 :     if ((r = inflate_block(__G__ &e)) != 0)

$LN18@inflate:
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	b8 01 00 00 00	 mov	 eax, 1
  000f5	5b		 pop	 ebx

; 1043 : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
$LN28@inflate:

; 1033 : 
; 1034 : 
; 1035 :   /* flush out redirSlide */
; 1036 :   FLUSH(G.wp);

  000fa	ff 35 24 00 00
	00		 push	 DWORD PTR _G+36
  00100	68 00 00 00 00	 push	 OFFSET _redirSlide
  00105	ff 35 04 00 00
	00		 push	 DWORD PTR _G+4
  0010b	e8 00 00 00 00	 call	 _memcpy
  00110	a1 24 00 00 00	 mov	 eax, DWORD PTR _G+36
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH
  00118	01 05 04 00 00
	00		 add	 DWORD PTR _G+4, eax
  0011e	01 05 0c 00 00
	00		 add	 DWORD PTR _G+12, eax

; 1037 : 
; 1038 : 
; 1039 :   /* return success */
; 1040 :   //Trace((stderr, "\n%u bytes in Huffman tables (%d/entry)\n",
; 1041 :   //       h * sizeof(struct huft), sizeof(struct huft)));
; 1042 :   return 0;

  00124	33 c0		 xor	 eax, eax
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx

; 1043 : }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0

; 1019 : 
; 1020 : 
; 1021 :   /* decompress until the last block */
; 1022 :   do {
; 1023 : //#ifdef DEBUG
; 1024 : //    G.hufts = 0;
; 1025 : //#endif
; 1026 :     if ((r = inflate_block(__G__ &e)) != 0)

$LN16@inflate:
  0012d	b8 02 00 00 00	 mov	 eax, 2
$LN1@inflate:
  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	5b		 pop	 ebx

; 1043 : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
_inflate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\inflate.c
;	COMDAT _inflate_block
_TEXT	SEGMENT
_e$ = 8							; size = 4
_inflate_block PROC					; COMDAT

; 955  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 956  :   unsigned t;           /* block type */
; 957  :   register ulg b;       /* bit buffer */
; 958  :   register unsigned k;  /* number of bits in bit buffer */
; 959  : 
; 960  : 
; 961  :   /* make local bit buffer */
; 962  :   b = G.bb;
; 963  :   k = G.bk;

  00003	8b 15 20 00 00
	00		 mov	 edx, DWORD PTR _G+32
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 35 28 00 00
	00		 mov	 esi, DWORD PTR _G+40
  00011	57		 push	 edi

; 964  : 
; 965  : 
; 966  :   /* read in last block bit */
; 967  :   NEEDBITS(1)

  00012	83 fa 01	 cmp	 edx, 1
  00015	73 3a		 jae	 SHORT $LN3@inflate_bl
  00017	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR _G+8
  0001d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _G
$LL2@inflate_bl:
  00023	8b c7		 mov	 eax, edi
  00025	4f		 dec	 edi
  00026	89 3d 08 00 00
	00		 mov	 DWORD PTR _G+8, edi
  0002c	85 c0		 test	 eax, eax
  0002e	0f 88 8a 00 00
	00		 js	 $LN18@inflate_bl
  00034	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00037	43		 inc	 ebx
  00038	89 1d 00 00 00
	00		 mov	 DWORD PTR _G, ebx
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	74 7b		 je	 SHORT $LN18@inflate_bl
  00043	8b ca		 mov	 ecx, edx
  00045	83 c2 08	 add	 edx, 8
  00048	d3 e0		 shl	 eax, cl
  0004a	0b f0		 or	 esi, eax
  0004c	83 fa 01	 cmp	 edx, 1
  0004f	72 d2		 jb	 SHORT $LL2@inflate_bl
$LN3@inflate_bl:

; 968  :   *e = (int)b & 1;

  00051	8b 45 08	 mov	 eax, DWORD PTR _e$[ebp]
  00054	8b ce		 mov	 ecx, esi
  00056	83 e1 01	 and	 ecx, 1

; 969  :   DUMPBITS(1)

  00059	d1 ee		 shr	 esi, 1
  0005b	4a		 dec	 edx
  0005c	89 08		 mov	 DWORD PTR [eax], ecx

; 970  : 
; 971  : 
; 972  :   /* read in block type */
; 973  :   NEEDBITS(2)

  0005e	83 fa 02	 cmp	 edx, 2
  00061	73 37		 jae	 SHORT $LN5@inflate_bl
  00063	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR _G+8
  00069	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _G
  0006f	90		 npad	 1
$LL4@inflate_bl:
  00070	8b c7		 mov	 eax, edi
  00072	4f		 dec	 edi
  00073	89 3d 08 00 00
	00		 mov	 DWORD PTR _G+8, edi
  00079	85 c0		 test	 eax, eax
  0007b	78 41		 js	 SHORT $LN18@inflate_bl
  0007d	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00080	43		 inc	 ebx
  00081	89 1d 00 00 00
	00		 mov	 DWORD PTR _G, ebx
  00087	83 f8 ff	 cmp	 eax, -1
  0008a	74 32		 je	 SHORT $LN18@inflate_bl
  0008c	8b ca		 mov	 ecx, edx
  0008e	83 c2 08	 add	 edx, 8
  00091	d3 e0		 shl	 eax, cl
  00093	0b f0		 or	 esi, eax
  00095	83 fa 02	 cmp	 edx, 2
  00098	72 d6		 jb	 SHORT $LL4@inflate_bl
$LN5@inflate_bl:

; 974  :   t = (unsigned)b & 3;

  0009a	8b ce		 mov	 ecx, esi

; 975  :   DUMPBITS(2)

  0009c	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]
  0009f	83 e1 03	 and	 ecx, 3
  000a2	c1 ee 02	 shr	 esi, 2

; 976  : 
; 977  : 
; 978  :   /* restore the global bit buffer */
; 979  :   G.bb = b;

  000a5	89 35 28 00 00
	00		 mov	 DWORD PTR _G+40, esi

; 980  :   G.bk = k;

  000ab	a3 20 00 00 00	 mov	 DWORD PTR _G+32, eax

; 981  : 
; 982  : 
; 983  :   /* inflate that block type */
; 984  :   if (t == 2)

  000b0	83 f9 02	 cmp	 ecx, 2
  000b3	75 13		 jne	 SHORT $LN8@inflate_bl
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx

; 994  : }

  000b8	5d		 pop	 ebp

; 985  :     return inflate_dynamic(__G);

  000b9	e9 00 00 00 00	 jmp	 _inflate_dynamic
$LN18@inflate_bl:
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi

; 964  : 
; 965  : 
; 966  :   /* read in last block bit */
; 967  :   NEEDBITS(1)

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	5b		 pop	 ebx

; 994  : }

  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN8@inflate_bl:

; 986  :   if (t == 0)

  000c8	85 c9		 test	 ecx, ecx
  000ca	75 09		 jne	 SHORT $LN9@inflate_bl
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx

; 994  : }

  000cf	5d		 pop	 ebp

; 987  :     return inflate_stored(__G);

  000d0	e9 00 00 00 00	 jmp	 _inflate_stored
$LN9@inflate_bl:

; 988  :   if (t == 1)

  000d5	83 f9 01	 cmp	 ecx, 1
  000d8	75 09		 jne	 SHORT $LN10@inflate_bl
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx

; 994  : }

  000dd	5d		 pop	 ebp

; 989  :     return inflate_fixed(__G);

  000de	e9 00 00 00 00	 jmp	 _inflate_fixed
$LN10@inflate_bl:
  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi

; 990  : 
; 991  : 
; 992  :   /* bad block type */
; 993  :   return 2;

  000e5	b8 02 00 00 00	 mov	 eax, 2
  000ea	5b		 pop	 ebx

; 994  : }

  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
_inflate_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\inflate.c
;	COMDAT _inflate_dynamic
_TEXT	SEGMENT
_m$1$ = -1304						; size = 4
_nd$1$ = -1300						; size = 4
_nb$1$ = -1296						; size = 4
_td$ = -1296						; size = 4
_nl$1$ = -1292						; size = 4
_bd$ = -1292						; size = 4
_bl$ = -1288						; size = 4
_n$1$ = -1284						; size = 4
_j$1$ = -1284						; size = 4
_l$1$ = -1280						; size = 4
tv701 = -1280						; size = 4
tv700 = -1280						; size = 4
_tl$ = -1276						; size = 4
_i$2$ = -1272						; size = 4
tv702 = -1272						; size = 4
_ll$ = -1268						; size = 1264
__$ArrayPad$ = -4					; size = 4
_inflate_dynamic PROC					; COMDAT

; 773  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 05 00
	00		 sub	 esp, 1304		; 00000518H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 774  :   int i;                /* temporary variables */
; 775  :   unsigned j;
; 776  :   unsigned l;           /* last length */
; 777  :   unsigned m;           /* mask for bit lengths table */
; 778  :   unsigned n;           /* number of lengths to get */
; 779  :   struct huft *tl;      /* literal/length code table */
; 780  :   struct huft *td;      /* distance code table */
; 781  :   int bl;               /* lookup bits for tl */
; 782  :   int bd;               /* lookup bits for td */
; 783  :   unsigned nb;          /* number of bit length codes */
; 784  :   unsigned nl;          /* number of literal/length codes */
; 785  :   unsigned nd;          /* number of distance codes */
; 786  : #ifdef PKZIP_BUG_WORKAROUND
; 787  :   unsigned ll[288+32]; /* literal/length and distance code lengths */
; 788  : #else
; 789  :   unsigned ll[286+30]; /* literal/length and distance code lengths */
; 790  : #endif
; 791  :   register ulg b;       /* bit buffer */
; 792  :   register unsigned k;  /* number of bits in bit buffer */
; 793  : 
; 794  : 
; 795  :   /* make local bit buffer */
; 796  :   Trace((stderr, "\ndynamic block"));
; 797  :   b = G.bb;
; 798  :   k = G.bk;
; 799  : 
; 800  : 
; 801  :   /* read in table lengths */
; 802  :   NEEDBITS(5)

  00013	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _G+8
  00019	53		 push	 ebx
  0001a	8b 1d 28 00 00
	00		 mov	 ebx, DWORD PTR _G+40
  00020	56		 push	 esi
  00021	8b 35 20 00 00
	00		 mov	 esi, DWORD PTR _G+32
  00027	57		 push	 edi
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _G
  0002e	83 fe 05	 cmp	 esi, 5
  00031	73 32		 jae	 SHORT $LN3@inflate_dy
$LL2@inflate_dy:
  00033	8b c2		 mov	 eax, edx
  00035	4a		 dec	 edx
  00036	89 15 08 00 00
	00		 mov	 DWORD PTR _G+8, edx
  0003c	85 c0		 test	 eax, eax
  0003e	0f 88 62 05 00
	00		 js	 $LN36@inflate_dy
  00044	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00047	47		 inc	 edi
  00048	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  0004e	83 f8 ff	 cmp	 eax, -1
  00051	0f 84 4f 05 00
	00		 je	 $LN36@inflate_dy
  00057	8b ce		 mov	 ecx, esi
  00059	83 c6 08	 add	 esi, 8
  0005c	d3 e0		 shl	 eax, cl
  0005e	0b d8		 or	 ebx, eax
  00060	83 fe 05	 cmp	 esi, 5
  00063	72 ce		 jb	 SHORT $LL2@inflate_dy
$LN3@inflate_dy:

; 803  :   nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */

  00065	8b c3		 mov	 eax, ebx

; 804  :   DUMPBITS(5)

  00067	83 ee 05	 sub	 esi, 5
  0006a	83 e0 1f	 and	 eax, 31			; 0000001fH
  0006d	c1 eb 05	 shr	 ebx, 5
  00070	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00075	89 85 f4 fa ff
	ff		 mov	 DWORD PTR _nl$1$[ebp], eax

; 805  :   NEEDBITS(5)

  0007b	83 fe 05	 cmp	 esi, 5
  0007e	73 32		 jae	 SHORT $LN5@inflate_dy
$LL4@inflate_dy:
  00080	8b c2		 mov	 eax, edx
  00082	4a		 dec	 edx
  00083	89 15 08 00 00
	00		 mov	 DWORD PTR _G+8, edx
  00089	85 c0		 test	 eax, eax
  0008b	0f 88 15 05 00
	00		 js	 $LN36@inflate_dy
  00091	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00094	47		 inc	 edi
  00095	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	0f 84 02 05 00
	00		 je	 $LN36@inflate_dy
  000a4	8b ce		 mov	 ecx, esi
  000a6	83 c6 08	 add	 esi, 8
  000a9	d3 e0		 shl	 eax, cl
  000ab	0b d8		 or	 ebx, eax
  000ad	83 fe 05	 cmp	 esi, 5
  000b0	72 ce		 jb	 SHORT $LL4@inflate_dy
$LN5@inflate_dy:

; 806  :   nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */

  000b2	8b cb		 mov	 ecx, ebx

; 807  :   DUMPBITS(5)

  000b4	83 ee 05	 sub	 esi, 5
  000b7	83 e1 1f	 and	 ecx, 31			; 0000001fH
  000ba	c1 eb 05	 shr	 ebx, 5
  000bd	41		 inc	 ecx
  000be	89 8d ec fa ff
	ff		 mov	 DWORD PTR _nd$1$[ebp], ecx

; 808  :   NEEDBITS(4)

  000c4	83 fe 04	 cmp	 esi, 4
  000c7	73 3f		 jae	 SHORT $LN7@inflate_dy
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@inflate_dy:
  000d0	8b c2		 mov	 eax, edx
  000d2	4a		 dec	 edx
  000d3	89 15 08 00 00
	00		 mov	 DWORD PTR _G+8, edx
  000d9	85 c0		 test	 eax, eax
  000db	0f 88 c5 04 00
	00		 js	 $LN36@inflate_dy
  000e1	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000e4	47		 inc	 edi
  000e5	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  000eb	83 f8 ff	 cmp	 eax, -1
  000ee	0f 84 b2 04 00
	00		 je	 $LN36@inflate_dy
  000f4	8b ce		 mov	 ecx, esi
  000f6	83 c6 08	 add	 esi, 8
  000f9	d3 e0		 shl	 eax, cl
  000fb	0b d8		 or	 ebx, eax
  000fd	83 fe 04	 cmp	 esi, 4
  00100	72 ce		 jb	 SHORT $LL6@inflate_dy
  00102	8b 8d ec fa ff
	ff		 mov	 ecx, DWORD PTR _nd$1$[ebp]
$LN7@inflate_dy:

; 809  :   nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */

  00108	8b c3		 mov	 eax, ebx

; 810  :   DUMPBITS(4)

  0010a	83 ee 04	 sub	 esi, 4
  0010d	83 e0 0f	 and	 eax, 15			; 0000000fH
  00110	c1 eb 04	 shr	 ebx, 4
  00113	83 c0 04	 add	 eax, 4

; 811  : #ifdef PKZIP_BUG_WORKAROUND
; 812  :   if (nl > 288 || nd > 32)
; 813  : #else
; 814  :   if (nl > 286 || nd > 30)

  00116	81 bd f4 fa ff
	ff 1e 01 00 00	 cmp	 DWORD PTR _nl$1$[ebp], 286 ; 0000011eH
  00120	89 85 f0 fa ff
	ff		 mov	 DWORD PTR _nb$1$[ebp], eax
  00126	0f 87 7a 04 00
	00		 ja	 $LN36@inflate_dy
  0012c	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  0012f	0f 87 71 04 00
	00		 ja	 $LN36@inflate_dy

; 817  : 
; 818  : 
; 819  :   /* read in bit-length-code lengths */
; 820  :   for (j = 0; j < nb; j++)

  00135	33 c9		 xor	 ecx, ecx
  00137	89 8d fc fa ff
	ff		 mov	 DWORD PTR _j$1$[ebp], ecx
  0013d	85 c0		 test	 eax, eax
  0013f	74 70		 je	 SHORT $LL192@inflate_dy
$LL10@inflate_dy:

; 821  :   {
; 822  :     NEEDBITS(3)

  00141	83 fe 03	 cmp	 esi, 3
  00144	73 32		 jae	 SHORT $LN12@inflate_dy
$LL11@inflate_dy:
  00146	8b c2		 mov	 eax, edx
  00148	4a		 dec	 edx
  00149	89 15 08 00 00
	00		 mov	 DWORD PTR _G+8, edx
  0014f	85 c0		 test	 eax, eax
  00151	0f 88 4f 04 00
	00		 js	 $LN36@inflate_dy
  00157	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0015a	47		 inc	 edi
  0015b	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  00161	83 f8 ff	 cmp	 eax, -1
  00164	0f 84 3c 04 00
	00		 je	 $LN36@inflate_dy
  0016a	8b ce		 mov	 ecx, esi
  0016c	83 c6 08	 add	 esi, 8
  0016f	d3 e0		 shl	 eax, cl
  00171	0b d8		 or	 ebx, eax
  00173	83 fe 03	 cmp	 esi, 3
  00176	72 ce		 jb	 SHORT $LL11@inflate_dy
$LN12@inflate_dy:

; 823  :     ll[border[j]] = (unsigned)b & 7;

  00178	8b 85 fc fa ff
	ff		 mov	 eax, DWORD PTR _j$1$[ebp]
  0017e	8b cb		 mov	 ecx, ebx
  00180	83 e1 07	 and	 ecx, 7

; 824  :     DUMPBITS(3)

  00183	c1 eb 03	 shr	 ebx, 3
  00186	83 ee 03	 sub	 esi, 3
  00189	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _border[eax*4]
  00190	89 8c 85 0c fb
	ff ff		 mov	 DWORD PTR _ll$[ebp+eax*4], ecx
  00197	8b 8d fc fa ff
	ff		 mov	 ecx, DWORD PTR _j$1$[ebp]
  0019d	41		 inc	 ecx
  0019e	89 8d fc fa ff
	ff		 mov	 DWORD PTR _j$1$[ebp], ecx
  001a4	3b 8d f0 fa ff
	ff		 cmp	 ecx, DWORD PTR _nb$1$[ebp]
  001aa	72 95		 jb	 SHORT $LL10@inflate_dy

; 825  :   }
; 826  :   for (; j < 19; j++)

  001ac	83 f9 13	 cmp	 ecx, 19			; 00000013H
  001af	73 18		 jae	 SHORT $LN14@inflate_dy
$LL192@inflate_dy:

; 827  :     ll[border[j]] = 0;

  001b1	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR _border[ecx*4]
  001b8	41		 inc	 ecx
  001b9	c7 84 85 0c fb
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ll$[ebp+eax*4], 0
  001c4	83 f9 13	 cmp	 ecx, 19			; 00000013H
  001c7	72 e8		 jb	 SHORT $LL192@inflate_dy
$LN14@inflate_dy:

; 828  : 
; 829  : 
; 830  :   /* build decoding table for trees--single level, 7 bit lookup */
; 831  :   bl = 7;
; 832  :   i = huft_build(__G__ ll, 19, 19, NULL, NULL, &tl, &bl);

  001c9	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR _bl$[ebp]
  001cf	c7 85 f8 fa ff
	ff 07 00 00 00	 mov	 DWORD PTR _bl$[ebp], 7
  001d9	50		 push	 eax
  001da	8d 85 04 fb ff
	ff		 lea	 eax, DWORD PTR _tl$[ebp]
  001e0	50		 push	 eax
  001e1	6a 00		 push	 0
  001e3	6a 00		 push	 0
  001e5	6a 13		 push	 19			; 00000013H
  001e7	8d 85 0c fb ff
	ff		 lea	 eax, DWORD PTR _ll$[ebp]
  001ed	6a 13		 push	 19			; 00000013H
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _huft_build

; 833  :   if (bl == 0)                        /* no bit lengths */

  001f5	8b 8d f8 fa ff
	ff		 mov	 ecx, DWORD PTR _bl$[ebp]
  001fb	83 c4 1c	 add	 esp, 28			; 0000001cH
  001fe	8b f8		 mov	 edi, eax
  00200	85 c9		 test	 ecx, ecx
  00202	75 24		 jne	 SHORT $LN38@inflate_dy

; 838  :       huft_free(tl);

  00204	ff b5 04 fb ff
	ff		 push	 DWORD PTR _tl$[ebp]
  0020a	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0020d	e8 00 00 00 00	 call	 _huft_free
  00212	83 c4 04	 add	 esp, 4

; 839  :     return i;                   /* incomplete code set */

  00215	8b c7		 mov	 eax, edi
  00217	5f		 pop	 edi
  00218	5e		 pop	 esi
  00219	5b		 pop	 ebx

; 946  :   return 0;
; 947  : }

  0021a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021d	33 cd		 xor	 ecx, ebp
  0021f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
$LN38@inflate_dy:

; 834  :     i = 1;
; 835  :   if (i)

  00228	85 ff		 test	 edi, edi
  0022a	74 26		 je	 SHORT $LN39@inflate_dy

; 836  :   {
; 837  :     if (i == 1)

  0022c	83 ff 01	 cmp	 edi, 1
  0022f	75 0e		 jne	 SHORT $LN40@inflate_dy

; 838  :       huft_free(tl);

  00231	ff b5 04 fb ff
	ff		 push	 DWORD PTR _tl$[ebp]
  00237	e8 00 00 00 00	 call	 _huft_free
  0023c	83 c4 04	 add	 esp, 4
$LN40@inflate_dy:

; 839  :     return i;                   /* incomplete code set */

  0023f	8b c7		 mov	 eax, edi
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	5b		 pop	 ebx

; 946  :   return 0;
; 947  : }

  00244	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00247	33 cd		 xor	 ecx, ebp
  00249	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	c3		 ret	 0
$LN39@inflate_dy:

; 840  :   }
; 841  : 
; 842  : 
; 843  :   /* read in literal and distance code lengths */
; 844  :   n = nl + nd;

  00252	8b 85 f4 fa ff
	ff		 mov	 eax, DWORD PTR _nl$1$[ebp]
  00258	03 85 ec fa ff
	ff		 add	 eax, DWORD PTR _nd$1$[ebp]

; 845  :   m = mask_bits[bl];
; 846  :   i = l = 0;

  0025e	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _G+8
  00264	89 85 fc fa ff
	ff		 mov	 DWORD PTR _n$1$[ebp], eax
  0026a	0f b7 04 4d 00
	00 00 00	 movzx	 eax, WORD PTR _mask_bits[ecx*2]
  00272	89 85 e8 fa ff
	ff		 mov	 DWORD PTR _m$1$[ebp], eax
  00278	33 c0		 xor	 eax, eax
  0027a	89 85 00 fb ff
	ff		 mov	 DWORD PTR _l$1$[ebp], eax
  00280	89 85 08 fb ff
	ff		 mov	 DWORD PTR _i$2$[ebp], eax
$LL16@inflate_dy:

; 848  :   {
; 849  :     NEEDBITS((unsigned)bl)

  00286	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _G
  0028c	3b f1		 cmp	 esi, ecx
  0028e	73 35		 jae	 SHORT $LN19@inflate_dy
$LL18@inflate_dy:
  00290	8b c2		 mov	 eax, edx
  00292	4a		 dec	 edx
  00293	89 15 08 00 00
	00		 mov	 DWORD PTR _G+8, edx
  00299	85 c0		 test	 eax, eax
  0029b	0f 88 05 03 00
	00		 js	 $LN36@inflate_dy
  002a1	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002a4	47		 inc	 edi
  002a5	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  002ab	83 f8 ff	 cmp	 eax, -1
  002ae	0f 84 f2 02 00
	00		 je	 $LN36@inflate_dy
  002b4	8b ce		 mov	 ecx, esi
  002b6	83 c6 08	 add	 esi, 8
  002b9	d3 e0		 shl	 eax, cl
  002bb	0b d8		 or	 ebx, eax
  002bd	3b b5 f8 fa ff
	ff		 cmp	 esi, DWORD PTR _bl$[ebp]
  002c3	72 cb		 jb	 SHORT $LL18@inflate_dy
$LN19@inflate_dy:

; 850  :     j = (td = tl + ((unsigned)b & m))->b;

  002c5	8b 85 e8 fa ff
	ff		 mov	 eax, DWORD PTR _m$1$[ebp]
  002cb	8b 8d 04 fb ff
	ff		 mov	 ecx, DWORD PTR _tl$[ebp]
  002d1	23 c3		 and	 eax, ebx
  002d3	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  002d6	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002d9	89 85 f0 fa ff
	ff		 mov	 DWORD PTR _td$[ebp], eax

; 851  :     DUMPBITS(j)

  002df	2b f1		 sub	 esi, ecx

; 852  :     j = td->v.n;

  002e1	0f b7 40 04	 movzx	 eax, WORD PTR [eax+4]
  002e5	d3 eb		 shr	 ebx, cl

; 853  :     if (j < 16)                 /* length of code in bits (0..15) */

  002e7	83 f8 10	 cmp	 eax, 16			; 00000010H
  002ea	73 13		 jae	 SHORT $LN206@inflate_dy

; 854  :       ll[i++] = l = j;          /* save last length in l */

  002ec	8b 8d 08 fb ff
	ff		 mov	 ecx, DWORD PTR _i$2$[ebp]
  002f2	89 84 8d 0c fb
	ff ff		 mov	 DWORD PTR _ll$[ebp+ecx*4], eax
  002f9	41		 inc	 ecx
  002fa	e9 71 01 00 00	 jmp	 $LN207@inflate_dy
$LN206@inflate_dy:

; 855  :     else if (j == 16)           /* repeat last length 3 to 6 times */

  002ff	75 7c		 jne	 SHORT $LN44@inflate_dy

; 856  :     {
; 857  :       NEEDBITS(2)

  00301	83 fe 02	 cmp	 esi, 2
  00304	73 32		 jae	 SHORT $LN21@inflate_dy
$LL20@inflate_dy:
  00306	8b c2		 mov	 eax, edx
  00308	4a		 dec	 edx
  00309	89 15 08 00 00
	00		 mov	 DWORD PTR _G+8, edx
  0030f	85 c0		 test	 eax, eax
  00311	0f 88 8f 02 00
	00		 js	 $LN36@inflate_dy
  00317	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0031a	47		 inc	 edi
  0031b	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  00321	83 f8 ff	 cmp	 eax, -1
  00324	0f 84 7c 02 00
	00		 je	 $LN36@inflate_dy
  0032a	8b ce		 mov	 ecx, esi
  0032c	83 c6 08	 add	 esi, 8
  0032f	d3 e0		 shl	 eax, cl
  00331	0b d8		 or	 ebx, eax
  00333	83 fe 02	 cmp	 esi, 2
  00336	72 ce		 jb	 SHORT $LL20@inflate_dy
$LN21@inflate_dy:

; 859  :       DUMPBITS(2)
; 860  :       if ((unsigned)i + j > n)

  00338	8b bd 08 fb ff
	ff		 mov	 edi, DWORD PTR _i$2$[ebp]
  0033e	8b cb		 mov	 ecx, ebx
  00340	83 e1 03	 and	 ecx, 3
  00343	c1 eb 02	 shr	 ebx, 2
  00346	83 c1 03	 add	 ecx, 3
  00349	83 ee 02	 sub	 esi, 2
  0034c	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  0034f	89 85 08 fb ff
	ff		 mov	 DWORD PTR tv702[ebp], eax
  00355	3b 85 fc fa ff
	ff		 cmp	 eax, DWORD PTR _n$1$[ebp]
  0035b	0f 87 45 02 00
	00		 ja	 $LN36@inflate_dy

; 858  :       j = 3 + ((unsigned)b & 3);

  00361	8d 85 0c fb ff
	ff		 lea	 eax, DWORD PTR _ll$[ebp]
  00367	8d 3c b8	 lea	 edi, DWORD PTR [eax+edi*4]
  0036a	8b 85 00 fb ff
	ff		 mov	 eax, DWORD PTR _l$1$[ebp]
  00370	f3 ab		 rep stosd

; 861  :         return 1;
; 862  :       while (j--)

  00372	8b 8d 08 fb ff
	ff		 mov	 ecx, DWORD PTR tv702[ebp]

; 863  :         ll[i++] = l;
; 864  :     }

  00378	e9 f9 00 00 00	 jmp	 $LN208@inflate_dy
$LN44@inflate_dy:

; 865  :     else if (j == 17)           /* 3 to 10 zero length codes */

  0037d	83 f8 11	 cmp	 eax, 17			; 00000011H
  00380	75 75		 jne	 SHORT $LN90@inflate_dy

; 866  :     {
; 867  :       NEEDBITS(3)

  00382	83 fe 03	 cmp	 esi, 3
  00385	73 32		 jae	 SHORT $LN25@inflate_dy
$LL24@inflate_dy:
  00387	8b c2		 mov	 eax, edx
  00389	4a		 dec	 edx
  0038a	89 15 08 00 00
	00		 mov	 DWORD PTR _G+8, edx
  00390	85 c0		 test	 eax, eax
  00392	0f 88 0e 02 00
	00		 js	 $LN36@inflate_dy
  00398	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0039b	47		 inc	 edi
  0039c	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  003a2	83 f8 ff	 cmp	 eax, -1
  003a5	0f 84 fb 01 00
	00		 je	 $LN36@inflate_dy
  003ab	8b ce		 mov	 ecx, esi
  003ad	83 c6 08	 add	 esi, 8
  003b0	d3 e0		 shl	 eax, cl
  003b2	0b d8		 or	 ebx, eax
  003b4	83 fe 03	 cmp	 esi, 3
  003b7	72 ce		 jb	 SHORT $LL24@inflate_dy
$LN25@inflate_dy:

; 869  :       DUMPBITS(3)
; 870  :       if ((unsigned)i + j > n)

  003b9	8b bd 08 fb ff
	ff		 mov	 edi, DWORD PTR _i$2$[ebp]
  003bf	8b cb		 mov	 ecx, ebx
  003c1	83 e1 07	 and	 ecx, 7
  003c4	c1 eb 03	 shr	 ebx, 3
  003c7	83 c1 03	 add	 ecx, 3
  003ca	83 ee 03	 sub	 esi, 3
  003cd	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  003d0	89 85 00 fb ff
	ff		 mov	 DWORD PTR tv701[ebp], eax
  003d6	3b 85 fc fa ff
	ff		 cmp	 eax, DWORD PTR _n$1$[ebp]
  003dc	0f 87 c4 01 00
	00		 ja	 $LN36@inflate_dy

; 868  :       j = 3 + ((unsigned)b & 7);

  003e2	8d 85 0c fb ff
	ff		 lea	 eax, DWORD PTR _ll$[ebp]
  003e8	8d 3c b8	 lea	 edi, DWORD PTR [eax+edi*4]
  003eb	33 c0		 xor	 eax, eax
  003ed	f3 ab		 rep stosd

; 871  :         return 1;
; 872  :       while (j--)

  003ef	8b 8d 00 fb ff
	ff		 mov	 ecx, DWORD PTR tv701[ebp]

; 873  :         ll[i++] = 0;
; 874  :       l = 0;
; 875  :     }

  003f5	eb 77		 jmp	 SHORT $LN209@inflate_dy
$LN90@inflate_dy:

; 876  :     else                        /* j == 18: 11 to 138 zero length codes */
; 877  :     {
; 878  :       NEEDBITS(7)

  003f7	83 fe 07	 cmp	 esi, 7
  003fa	73 36		 jae	 SHORT $LN29@inflate_dy
  003fc	0f 1f 40 00	 npad	 4
$LL28@inflate_dy:
  00400	8b c2		 mov	 eax, edx
  00402	4a		 dec	 edx
  00403	89 15 08 00 00
	00		 mov	 DWORD PTR _G+8, edx
  00409	85 c0		 test	 eax, eax
  0040b	0f 88 95 01 00
	00		 js	 $LN36@inflate_dy
  00411	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00414	47		 inc	 edi
  00415	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  0041b	83 f8 ff	 cmp	 eax, -1
  0041e	0f 84 82 01 00
	00		 je	 $LN36@inflate_dy
  00424	8b ce		 mov	 ecx, esi
  00426	83 c6 08	 add	 esi, 8
  00429	d3 e0		 shl	 eax, cl
  0042b	0b d8		 or	 ebx, eax
  0042d	83 fe 07	 cmp	 esi, 7
  00430	72 ce		 jb	 SHORT $LL28@inflate_dy
$LN29@inflate_dy:

; 880  :       DUMPBITS(7)
; 881  :       if ((unsigned)i + j > n)

  00432	8b bd 08 fb ff
	ff		 mov	 edi, DWORD PTR _i$2$[ebp]
  00438	8b cb		 mov	 ecx, ebx
  0043a	83 e1 7f	 and	 ecx, 127		; 0000007fH
  0043d	c1 eb 07	 shr	 ebx, 7
  00440	83 c1 0b	 add	 ecx, 11			; 0000000bH
  00443	83 ee 07	 sub	 esi, 7
  00446	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  00449	89 85 00 fb ff
	ff		 mov	 DWORD PTR tv700[ebp], eax
  0044f	3b 85 fc fa ff
	ff		 cmp	 eax, DWORD PTR _n$1$[ebp]
  00455	0f 87 4b 01 00
	00		 ja	 $LN36@inflate_dy

; 879  :       j = 11 + ((unsigned)b & 0x7f);

  0045b	8d 85 0c fb ff
	ff		 lea	 eax, DWORD PTR _ll$[ebp]
  00461	8d 3c b8	 lea	 edi, DWORD PTR [eax+edi*4]
  00464	33 c0		 xor	 eax, eax
  00466	f3 ab		 rep stosd

; 882  :         return 1;
; 883  :       while (j--)

  00468	8b 8d 00 fb ff
	ff		 mov	 ecx, DWORD PTR tv700[ebp]
$LN209@inflate_dy:

; 884  :         ll[i++] = 0;
; 885  :       l = 0;

  0046e	33 c0		 xor	 eax, eax
$LN207@inflate_dy:
  00470	89 85 00 fb ff
	ff		 mov	 DWORD PTR _l$1$[ebp], eax
$LN208@inflate_dy:

; 882  :         return 1;
; 883  :       while (j--)

  00476	89 8d 08 fb ff
	ff		 mov	 DWORD PTR _i$2$[ebp], ecx
  0047c	3b 8d fc fa ff
	ff		 cmp	 ecx, DWORD PTR _n$1$[ebp]
  00482	73 0b		 jae	 SHORT $LN17@inflate_dy

; 847  :   while ((unsigned)i < n)

  00484	8b 8d f8 fa ff
	ff		 mov	 ecx, DWORD PTR _bl$[ebp]
  0048a	e9 f7 fd ff ff	 jmp	 $LL16@inflate_dy
$LN17@inflate_dy:

; 886  :     }
; 887  :   }
; 888  : 
; 889  : 
; 890  :   /* free decoding table for trees */
; 891  :   huft_free(tl);

  0048f	ff b5 04 fb ff
	ff		 push	 DWORD PTR _tl$[ebp]
  00495	e8 00 00 00 00	 call	 _huft_free

; 892  : 
; 893  : 
; 894  :   /* restore the global bit buffer */
; 895  :   G.bb = b;
; 896  :   G.bk = k;
; 897  : 
; 898  : 
; 899  :   /* build the decoding tables for literal/length and distance codes */
; 900  :   bl = lbits;
; 901  :   i = huft_build(__G__ ll, nl, 257, cplens, cplext, &tl, &bl);

  0049a	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR _bl$[ebp]
  004a0	89 1d 28 00 00
	00		 mov	 DWORD PTR _G+40, ebx
  004a6	8b 9d f4 fa ff
	ff		 mov	 ebx, DWORD PTR _nl$1$[ebp]
  004ac	50		 push	 eax
  004ad	8d 85 04 fb ff
	ff		 lea	 eax, DWORD PTR _tl$[ebp]
  004b3	89 35 20 00 00
	00		 mov	 DWORD PTR _G+32, esi
  004b9	50		 push	 eax
  004ba	68 00 00 00 00	 push	 OFFSET _cplext
  004bf	68 00 00 00 00	 push	 OFFSET _cplens
  004c4	68 01 01 00 00	 push	 257			; 00000101H
  004c9	8d 85 0c fb ff
	ff		 lea	 eax, DWORD PTR _ll$[ebp]
  004cf	c7 85 f8 fa ff
	ff 09 00 00 00	 mov	 DWORD PTR _bl$[ebp], 9
  004d9	53		 push	 ebx
  004da	50		 push	 eax
  004db	e8 00 00 00 00	 call	 _huft_build

; 902  :   if (bl == 0)                        /* no literals or lengths */

  004e0	8b bd f8 fa ff
	ff		 mov	 edi, DWORD PTR _bl$[ebp]
  004e6	83 c4 20	 add	 esp, 32			; 00000020H
  004e9	8b f0		 mov	 esi, eax
  004eb	85 ff		 test	 edi, edi
  004ed	75 05		 jne	 SHORT $LN54@inflate_dy

; 903  :     i = 1;

  004ef	8d 77 01	 lea	 esi, DWORD PTR [edi+1]

; 904  :   if (i)

  004f2	eb 09		 jmp	 SHORT $LN151@inflate_dy
$LN54@inflate_dy:
  004f4	85 f6		 test	 esi, esi
  004f6	74 3b		 je	 SHORT $LN55@inflate_dy

; 905  :   {
; 906  :     if (i == 1) {

  004f8	83 fe 01	 cmp	 esi, 1
  004fb	75 23		 jne	 SHORT $LN56@inflate_dy
$LN151@inflate_dy:

; 907  :       //if (!uO.qflag)
; 908  :         MESSAGE((uch *)"(incomplete l-tree)  ", 21L, 1);

  004fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DPKBCABB@?$CIincomplete?5l?9tree?$CJ?5?5?$AA@
  00502	6a 02		 push	 2
  00504	e8 00 00 00 00	 call	 ___acrt_iob_func
  00509	83 c4 04	 add	 esp, 4
  0050c	50		 push	 eax
  0050d	e8 00 00 00 00	 call	 _fprintf

; 909  :       huft_free(tl);

  00512	ff b5 04 fb ff
	ff		 push	 DWORD PTR _tl$[ebp]
  00518	e8 00 00 00 00	 call	 _huft_free
  0051d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN56@inflate_dy:

; 910  :     }
; 911  :     return i;                   /* incomplete code set */

  00520	5f		 pop	 edi
  00521	8b c6		 mov	 eax, esi
  00523	5e		 pop	 esi
  00524	5b		 pop	 ebx

; 946  :   return 0;
; 947  : }

  00525	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00528	33 cd		 xor	 ecx, ebp
  0052a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0052f	8b e5		 mov	 esp, ebp
  00531	5d		 pop	 ebp
  00532	c3		 ret	 0
$LN55@inflate_dy:

; 912  :   }
; 913  :   bd = dbits;
; 914  :   i = huft_build(__G__ ll + nl, nd, 0, cpdist, cpdext, &td, &bd);

  00533	8d 85 f4 fa ff
	ff		 lea	 eax, DWORD PTR _bd$[ebp]
  00539	c7 85 f4 fa ff
	ff 06 00 00 00	 mov	 DWORD PTR _bd$[ebp], 6
  00543	50		 push	 eax
  00544	8d 85 f0 fa ff
	ff		 lea	 eax, DWORD PTR _td$[ebp]
  0054a	50		 push	 eax
  0054b	68 00 00 00 00	 push	 OFFSET _cpdext
  00550	68 00 00 00 00	 push	 OFFSET _cpdist
  00555	6a 00		 push	 0
  00557	ff b5 ec fa ff
	ff		 push	 DWORD PTR _nd$1$[ebp]
  0055d	8d 85 0c fb ff
	ff		 lea	 eax, DWORD PTR _ll$[ebp]
  00563	8d 04 98	 lea	 eax, DWORD PTR [eax+ebx*4]
  00566	50		 push	 eax
  00567	e8 00 00 00 00	 call	 _huft_build
  0056c	8b f0		 mov	 esi, eax
  0056e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 915  :   if (bd == 0 && nl > 257)    /* lengths but no distances */

  00571	8b 85 f4 fa ff
	ff		 mov	 eax, DWORD PTR _bd$[ebp]
  00577	85 c0		 test	 eax, eax
  00579	75 41		 jne	 SHORT $LN57@inflate_dy
  0057b	81 fb 01 01 00
	00		 cmp	 ebx, 257		; 00000101H
  00581	76 39		 jbe	 SHORT $LN57@inflate_dy

; 916  :   {
; 917  :     //if (!uO.qflag)
; 918  :       MESSAGE((uch *)"(incomplete d-tree)  ", 21L, 1);

  00583	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CMHGGAOF@?$CIincomplete?5d?9tree?$CJ?5?5?$AA@
  00588	6a 02		 push	 2
  0058a	e8 00 00 00 00	 call	 ___acrt_iob_func
  0058f	83 c4 04	 add	 esp, 4
  00592	50		 push	 eax
  00593	e8 00 00 00 00	 call	 _fprintf

; 919  :     huft_free(tl);

  00598	ff b5 04 fb ff
	ff		 push	 DWORD PTR _tl$[ebp]
  0059e	e8 00 00 00 00	 call	 _huft_free
  005a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@inflate_dy:

; 815  : #endif
; 816  :     return 1;                   /* bad lengths */

  005a6	5f		 pop	 edi
  005a7	5e		 pop	 esi
  005a8	b8 01 00 00 00	 mov	 eax, 1
  005ad	5b		 pop	 ebx

; 946  :   return 0;
; 947  : }

  005ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b1	33 cd		 xor	 ecx, ebp
  005b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005b8	8b e5		 mov	 esp, ebp
  005ba	5d		 pop	 ebp
  005bb	c3		 ret	 0
$LN57@inflate_dy:

; 920  :     return 1;
; 921  :   }
; 922  :   if (i == 1) {

  005bc	83 fe 01	 cmp	 esi, 1
  005bf	75 44		 jne	 SHORT $LN58@inflate_dy

; 923  : #ifdef PKZIP_BUG_WORKAROUND
; 924  :     i = 0;
; 925  : #else
; 926  :     //if (!uO.qflag)
; 927  :       MESSAGE((uch *)"(incomplete d-tree)  ", 21L, 1);

  005c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CMHGGAOF@?$CIincomplete?5d?9tree?$CJ?5?5?$AA@
  005c6	6a 02		 push	 2
  005c8	e8 00 00 00 00	 call	 ___acrt_iob_func
  005cd	83 c4 04	 add	 esp, 4
  005d0	50		 push	 eax
  005d1	e8 00 00 00 00	 call	 _fprintf

; 928  :     huft_free(td);

  005d6	ff b5 f0 fa ff
	ff		 push	 DWORD PTR _td$[ebp]
  005dc	e8 00 00 00 00	 call	 _huft_free
  005e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 932  :   {
; 933  :     huft_free(tl);

  005e4	ff b5 04 fb ff
	ff		 push	 DWORD PTR _tl$[ebp]
  005ea	e8 00 00 00 00	 call	 _huft_free
  005ef	83 c4 04	 add	 esp, 4

; 934  :     return i;

  005f2	8b c6		 mov	 eax, esi
  005f4	5f		 pop	 edi
  005f5	5e		 pop	 esi
  005f6	5b		 pop	 ebx

; 946  :   return 0;
; 947  : }

  005f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005fa	33 cd		 xor	 ecx, ebp
  005fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00601	8b e5		 mov	 esp, ebp
  00603	5d		 pop	 ebp
  00604	c3		 ret	 0
$LN58@inflate_dy:

; 929  : #endif
; 930  :   }
; 931  :   if (i)

  00605	85 f6		 test	 esi, esi
  00607	74 21		 je	 SHORT $LN59@inflate_dy

; 932  :   {
; 933  :     huft_free(tl);

  00609	ff b5 04 fb ff
	ff		 push	 DWORD PTR _tl$[ebp]
  0060f	e8 00 00 00 00	 call	 _huft_free
  00614	83 c4 04	 add	 esp, 4

; 934  :     return i;

  00617	8b c6		 mov	 eax, esi
  00619	5f		 pop	 edi
  0061a	5e		 pop	 esi
  0061b	5b		 pop	 ebx

; 946  :   return 0;
; 947  : }

  0061c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0061f	33 cd		 xor	 ecx, ebp
  00621	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00626	8b e5		 mov	 esp, ebp
  00628	5d		 pop	 ebp
  00629	c3		 ret	 0
$LN59@inflate_dy:

; 935  :   }
; 936  : 
; 937  : 
; 938  :   /* decompress until an end-of-block code */
; 939  :   if (inflate_codes(__G__ tl, td, bl, bd))

  0062a	8b b5 f0 fa ff
	ff		 mov	 esi, DWORD PTR _td$[ebp]
  00630	50		 push	 eax
  00631	57		 push	 edi
  00632	8b bd 04 fb ff
	ff		 mov	 edi, DWORD PTR _tl$[ebp]
  00638	56		 push	 esi
  00639	57		 push	 edi
  0063a	e8 00 00 00 00	 call	 _inflate_codes
  0063f	83 c4 10	 add	 esp, 16			; 00000010H
  00642	85 c0		 test	 eax, eax
  00644	0f 85 5c ff ff
	ff		 jne	 $LN36@inflate_dy

; 940  :     return 1;
; 941  : 
; 942  : 
; 943  :   /* free the decoding tables, return */
; 944  :   huft_free(tl);

  0064a	57		 push	 edi
  0064b	e8 00 00 00 00	 call	 _huft_free

; 945  :   huft_free(td);

  00650	56		 push	 esi
  00651	e8 00 00 00 00	 call	 _huft_free

; 946  :   return 0;
; 947  : }

  00656	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00659	83 c4 08	 add	 esp, 8
  0065c	33 cd		 xor	 ecx, ebp
  0065e	33 c0		 xor	 eax, eax
  00660	5f		 pop	 edi
  00661	5e		 pop	 esi
  00662	5b		 pop	 ebx
  00663	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00668	8b e5		 mov	 esp, ebp
  0066a	5d		 pop	 ebp
  0066b	c3		 ret	 0
_inflate_dynamic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\inflate.c
;	COMDAT _inflate_fixed
_TEXT	SEGMENT
_l$1 = -1168						; size = 1152
__$ArrayPad$ = -4					; size = 4
_inflate_fixed PROC					; COMDAT

; 725  : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 98 04 00
	00		 sub	 esp, 1176		; 00000498H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 726  :   /* if first time, set up tables for fixed blocks */
; 727  :   Trace((stderr, "\nliteral block"));
; 728  :   if (G.fixed_tl == (struct huft *)NULL)

  00026	a1 10 00 00 00	 mov	 eax, DWORD PTR _G+16
  0002b	56		 push	 esi
  0002c	57		 push	 edi
  0002d	85 c0		 test	 eax, eax
  0002f	0f 85 68 01 00
	00		 jne	 $LN19@inflate_fi

; 729  :   {
; 730  :     int i;                /* temporary variable */
; 731  :     unsigned l[288];      /* length list for huft_build */
; 732  : 
; 733  :     /* literal table */
; 734  :     for (i = 0; i < 144; i++)
; 735  :       l[i] = 8;
; 736  :     for (; i < 256; i++)
; 737  :       l[i] = 9;
; 738  :     for (; i < 280; i++)
; 739  :       l[i] = 7;

  00035	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000007000000070000000700000007
  0003c	8d bd 70 fb ff
	ff		 lea	 edi, DWORD PTR _l$1[ebp]

; 740  :     for (; i < 288; i++)          /* make a complete, but wrong code set */
; 741  :       l[i] = 8;
; 742  :     G.fixed_bl = 7;
; 743  :     if ((i = huft_build(__G__ l, 288, 257, cplens, cplext,
; 744  :                         &G.fixed_tl, &G.fixed_bl)) != 0)

  00042	68 18 00 00 00	 push	 OFFSET _G+24
  00047	68 10 00 00 00	 push	 OFFSET _G+16
  0004c	68 00 00 00 00	 push	 OFFSET _cplext
  00051	b8 08 00 00 00	 mov	 eax, 8
  00056	c7 05 18 00 00
	00 07 00 00 00	 mov	 DWORD PTR _G+24, 7
  00060	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  00065	f3 ab		 rep stosd
  00067	68 00 00 00 00	 push	 OFFSET _cplens
  0006c	b8 09 00 00 00	 mov	 eax, 9
  00071	8d bd b0 fd ff
	ff		 lea	 edi, DWORD PTR _l$1[ebp+576]
  00077	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  0007c	f3 ab		 rep stosd
  0007e	68 01 01 00 00	 push	 257			; 00000101H
  00083	0f 11 85 70 ff
	ff ff		 movups	 XMMWORD PTR _l$1[ebp+1024], xmm0
  0008a	8d 85 70 fb ff
	ff		 lea	 eax, DWORD PTR _l$1[ebp]
  00090	0f 11 45 80	 movups	 XMMWORD PTR _l$1[ebp+1040], xmm0
  00094	68 20 01 00 00	 push	 288			; 00000120H
  00099	0f 11 45 90	 movups	 XMMWORD PTR _l$1[ebp+1056], xmm0
  0009d	50		 push	 eax
  0009e	0f 11 45 a0	 movups	 XMMWORD PTR _l$1[ebp+1072], xmm0
  000a2	0f 11 45 b0	 movups	 XMMWORD PTR _l$1[ebp+1088], xmm0
  000a6	0f 11 45 c0	 movups	 XMMWORD PTR _l$1[ebp+1104], xmm0
  000aa	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000008000000080000000800000008
  000b1	0f 11 45 d0	 movups	 XMMWORD PTR _l$1[ebp+1120], xmm0
  000b5	0f 11 45 e0	 movups	 XMMWORD PTR _l$1[ebp+1136], xmm0
  000b9	e8 00 00 00 00	 call	 _huft_build
  000be	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c1	85 c0		 test	 eax, eax
  000c3	74 1d		 je	 SHORT $LN18@inflate_fi

; 745  :     {
; 746  :       G.fixed_tl = (struct huft *)NULL;

  000c5	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+16, 0

; 765  :                              G.fixed_bl, G.fixed_bd) != 0;
; 766  : }

  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d4	33 cd		 xor	 ecx, ebp
  000d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	8b e3		 mov	 esp, ebx
  000e0	5b		 pop	 ebx
  000e1	c3		 ret	 0
$LN18@inflate_fi:

; 747  :       return i;
; 748  :     }
; 749  : 
; 750  :     /* distance table */
; 751  :     for (i = 0; i < 30; i++)      /* make an incomplete code set */
; 752  :       l[i] = 5;

  000e2	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000005000000050000000500000005

; 753  :     G.fixed_bd = 5;
; 754  :     if ((i = huft_build(__G__ l, 30, 0, cpdist, cpdext,
; 755  :                         &G.fixed_td, &G.fixed_bd)) > 1)

  000e9	8d 85 70 fb ff
	ff		 lea	 eax, DWORD PTR _l$1[ebp]
  000ef	68 1c 00 00 00	 push	 OFFSET _G+28
  000f4	68 14 00 00 00	 push	 OFFSET _G+20
  000f9	68 00 00 00 00	 push	 OFFSET _cpdext
  000fe	68 00 00 00 00	 push	 OFFSET _cpdist
  00103	6a 00		 push	 0
  00105	6a 1e		 push	 30			; 0000001eH
  00107	50		 push	 eax
  00108	0f 29 85 70 fb
	ff ff		 movaps	 XMMWORD PTR _l$1[ebp], xmm0
  0010f	0f 29 85 80 fb
	ff ff		 movaps	 XMMWORD PTR _l$1[ebp+16], xmm0
  00116	0f 29 85 90 fb
	ff ff		 movaps	 XMMWORD PTR _l$1[ebp+32], xmm0
  0011d	0f 29 85 a0 fb
	ff ff		 movaps	 XMMWORD PTR _l$1[ebp+48], xmm0
  00124	0f 29 85 b0 fb
	ff ff		 movaps	 XMMWORD PTR _l$1[ebp+64], xmm0
  0012b	0f 29 85 c0 fb
	ff ff		 movaps	 XMMWORD PTR _l$1[ebp+80], xmm0
  00132	0f 29 85 d0 fb
	ff ff		 movaps	 XMMWORD PTR _l$1[ebp+96], xmm0
  00139	66 0f d6 85 e0
	fb ff ff	 movq	 QWORD PTR _l$1[ebp+112], xmm0
  00141	c7 05 1c 00 00
	00 05 00 00 00	 mov	 DWORD PTR _G+28, 5
  0014b	e8 00 00 00 00	 call	 _huft_build
  00150	8b f8		 mov	 edi, eax
  00152	83 c4 1c	 add	 esp, 28			; 0000001cH
  00155	83 ff 01	 cmp	 edi, 1
  00158	7e 3e		 jle	 SHORT $LN51@inflate_fi

; 756  :     {
; 757  :       huft_free(G.fixed_tl);

  0015a	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _G+16
  00160	85 c9		 test	 ecx, ecx
  00162	74 15		 je	 SHORT $LN23@inflate_fi
$LL22@inflate_fi:
  00164	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  00167	83 e9 08	 sub	 ecx, 8
  0016a	51		 push	 ecx
  0016b	e8 00 00 00 00	 call	 _free
  00170	83 c4 04	 add	 esp, 4
  00173	8b ce		 mov	 ecx, esi
  00175	85 f6		 test	 esi, esi
  00177	75 eb		 jne	 SHORT $LL22@inflate_fi
$LN23@inflate_fi:

; 758  :       G.fixed_tl = (struct huft *)NULL;

  00179	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+16, 0

; 759  :       return i;

  00183	8b c7		 mov	 eax, edi

; 765  :                              G.fixed_bl, G.fixed_bd) != 0;
; 766  : }

  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018a	33 cd		 xor	 ecx, ebp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	8b e5		 mov	 esp, ebp
  00193	5d		 pop	 ebp
  00194	8b e3		 mov	 esp, ebx
  00196	5b		 pop	 ebx
  00197	c3		 ret	 0
$LN51@inflate_fi:

; 759  :       return i;

  00198	a1 10 00 00 00	 mov	 eax, DWORD PTR _G+16
$LN19@inflate_fi:

; 760  :     }
; 761  :   }
; 762  : 
; 763  :   /* decompress until an end-of-block code */
; 764  :   return inflate_codes(__G__ G.fixed_tl, G.fixed_td,

  0019d	ff 35 1c 00 00
	00		 push	 DWORD PTR _G+28
  001a3	ff 35 18 00 00
	00		 push	 DWORD PTR _G+24
  001a9	ff 35 14 00 00
	00		 push	 DWORD PTR _G+20
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _inflate_codes

; 765  :                              G.fixed_bl, G.fixed_bd) != 0;
; 766  : }

  001b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b8	83 c4 10	 add	 esp, 16			; 00000010H
  001bb	f7 d8		 neg	 eax
  001bd	1b c0		 sbb	 eax, eax
  001bf	33 cd		 xor	 ecx, ebp
  001c1	5f		 pop	 edi
  001c2	f7 d8		 neg	 eax
  001c4	5e		 pop	 esi
  001c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	8b e3		 mov	 esp, ebx
  001cf	5b		 pop	 ebx
  001d0	c3		 ret	 0
_inflate_fixed ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\inflate.c
;	COMDAT _inflate_stored
_TEXT	SEGMENT
_n$2$ = -8						; size = 4
_w$1$ = -4						; size = 4
_inflate_stored PROC					; COMDAT

; 661  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 662  :   unsigned n;           /* number of bytes in block */
; 663  :   unsigned w;           /* current window position */
; 664  :   register ulg b;       /* bit buffer */
; 665  :   register unsigned k;  /* number of bits in bit buffer */
; 666  : 
; 667  : 
; 668  :   /* make local copies of globals */
; 669  :   Trace((stderr, "\nstored block"));
; 670  :   b = G.bb;                       /* initialize bit buffer */
; 671  :   k = G.bk;
; 672  :   w = G.wp;                       /* initialize window position */

  00006	a1 24 00 00 00	 mov	 eax, DWORD PTR _G+36

; 673  : 
; 674  : 
; 675  :   /* go to byte boundary */
; 676  :   n = k & 7;
; 677  :   DUMPBITS(n);
; 678  : 
; 679  : 
; 680  :   /* get the length and its complement */
; 681  :   NEEDBITS(16)

  0000b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _G
  00011	53		 push	 ebx
  00012	8b 1d 28 00 00
	00		 mov	 ebx, DWORD PTR _G+40
  00018	56		 push	 esi
  00019	8b 35 20 00 00
	00		 mov	 esi, DWORD PTR _G+32
  0001f	8b ce		 mov	 ecx, esi
  00021	83 e1 07	 and	 ecx, 7
  00024	89 45 fc	 mov	 DWORD PTR _w$1$[ebp], eax
  00027	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  0002c	2b f1		 sub	 esi, ecx
  0002e	d3 eb		 shr	 ebx, cl
  00030	57		 push	 edi
  00031	83 fe 10	 cmp	 esi, 16			; 00000010H
  00034	73 31		 jae	 SHORT $LN3@inflate_st
$LL2@inflate_st:
  00036	8b c8		 mov	 ecx, eax
  00038	48		 dec	 eax
  00039	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  0003e	85 c9		 test	 ecx, ecx
  00040	0f 88 48 01 00
	00		 js	 $LN26@inflate_st
  00046	0f b6 3a	 movzx	 edi, BYTE PTR [edx]
  00049	42		 inc	 edx
  0004a	89 15 00 00 00
	00		 mov	 DWORD PTR _G, edx
  00050	83 ff ff	 cmp	 edi, -1
  00053	0f 84 35 01 00
	00		 je	 $LN26@inflate_st
  00059	8b ce		 mov	 ecx, esi
  0005b	83 c6 08	 add	 esi, 8
  0005e	d3 e7		 shl	 edi, cl
  00060	0b df		 or	 ebx, edi
  00062	83 fe 10	 cmp	 esi, 16			; 00000010H
  00065	72 cf		 jb	 SHORT $LL2@inflate_st
$LN3@inflate_st:

; 682  :   n = ((unsigned)b & 0xffff);

  00067	0f b7 fb	 movzx	 edi, bx

; 683  :   DUMPBITS(16)

  0006a	83 ee 10	 sub	 esi, 16			; 00000010H
  0006d	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00070	89 7d f8	 mov	 DWORD PTR _n$2$[ebp], edi

; 684  :   NEEDBITS(16)

  00073	83 fe 10	 cmp	 esi, 16			; 00000010H
  00076	73 34		 jae	 SHORT $LN5@inflate_st
$LL4@inflate_st:
  00078	8b c8		 mov	 ecx, eax
  0007a	48		 dec	 eax
  0007b	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  00080	85 c9		 test	 ecx, ecx
  00082	0f 88 06 01 00
	00		 js	 $LN26@inflate_st
  00088	0f b6 3a	 movzx	 edi, BYTE PTR [edx]
  0008b	42		 inc	 edx
  0008c	89 15 00 00 00
	00		 mov	 DWORD PTR _G, edx
  00092	83 ff ff	 cmp	 edi, -1
  00095	0f 84 f3 00 00
	00		 je	 $LN26@inflate_st
  0009b	8b ce		 mov	 ecx, esi
  0009d	83 c6 08	 add	 esi, 8
  000a0	d3 e7		 shl	 edi, cl
  000a2	0b df		 or	 ebx, edi
  000a4	83 fe 10	 cmp	 esi, 16			; 00000010H
  000a7	72 cf		 jb	 SHORT $LL4@inflate_st
  000a9	8b 7d f8	 mov	 edi, DWORD PTR _n$2$[ebp]
$LN5@inflate_st:

; 685  :   if (n != (unsigned)((~b) & 0xffff))

  000ac	8b cb		 mov	 ecx, ebx
  000ae	f7 d1		 not	 ecx
  000b0	0f b7 c9	 movzx	 ecx, cx
  000b3	3b f9		 cmp	 edi, ecx
  000b5	0f 85 d3 00 00
	00		 jne	 $LN26@inflate_st

; 686  :     return 1;                   /* error in compressed data */
; 687  :   DUMPBITS(16)

  000bb	c1 eb 10	 shr	 ebx, 16			; 00000010H
  000be	83 ee 10	 sub	 esi, 16			; 00000010H

; 688  : 
; 689  : 
; 690  :   /* read and output the compressed data */
; 691  :   while (n--)

  000c1	85 ff		 test	 edi, edi
  000c3	0f 84 a8 00 00
	00		 je	 $LN32@inflate_st
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@inflate_st:
  000d0	4f		 dec	 edi
  000d1	89 7d f8	 mov	 DWORD PTR _n$2$[ebp], edi

; 692  :   {
; 693  :     NEEDBITS(8)

  000d4	83 fe 08	 cmp	 esi, 8
  000d7	73 3b		 jae	 SHORT $LN9@inflate_st
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL8@inflate_st:
  000e0	8b c8		 mov	 ecx, eax
  000e2	48		 dec	 eax
  000e3	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  000e8	85 c9		 test	 ecx, ecx
  000ea	0f 88 9e 00 00
	00		 js	 $LN26@inflate_st
  000f0	0f b6 3a	 movzx	 edi, BYTE PTR [edx]
  000f3	42		 inc	 edx
  000f4	89 15 00 00 00
	00		 mov	 DWORD PTR _G, edx
  000fa	83 ff ff	 cmp	 edi, -1
  000fd	0f 84 8b 00 00
	00		 je	 $LN26@inflate_st
  00103	8b ce		 mov	 ecx, esi
  00105	83 c6 08	 add	 esi, 8
  00108	d3 e7		 shl	 edi, cl
  0010a	0b df		 or	 ebx, edi
  0010c	83 fe 08	 cmp	 esi, 8
  0010f	72 cf		 jb	 SHORT $LL8@inflate_st
  00111	8b 7d f8	 mov	 edi, DWORD PTR _n$2$[ebp]
$LN9@inflate_st:

; 694  :     redirSlide[w++] = (uch)b;

  00114	8b 4d fc	 mov	 ecx, DWORD PTR _w$1$[ebp]
  00117	88 99 00 00 00
	00		 mov	 BYTE PTR _redirSlide[ecx], bl
  0011d	41		 inc	 ecx
  0011e	89 4d fc	 mov	 DWORD PTR _w$1$[ebp], ecx

; 695  :     if (w == wsize)

  00121	81 f9 00 80 00
	00		 cmp	 ecx, 32768		; 00008000H
  00127	75 3a		 jne	 SHORT $LN14@inflate_st

; 696  :     {
; 697  :       FLUSH(w);

  00129	51		 push	 ecx
  0012a	68 00 00 00 00	 push	 OFFSET _redirSlide
  0012f	ff 35 04 00 00
	00		 push	 DWORD PTR _G+4
  00135	e8 00 00 00 00	 call	 _memcpy
  0013a	81 05 04 00 00
	00 00 80 00 00	 add	 DWORD PTR _G+4, 32768	; 00008000H
  00144	83 c4 0c	 add	 esp, 12			; 0000000cH
  00147	81 05 0c 00 00
	00 00 80 00 00	 add	 DWORD PTR _G+12, 32768	; 00008000H

; 698  :       w = 0;

  00151	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  00156	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _G
  0015c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _w$1$[ebp], 0
$LN14@inflate_st:

; 699  :     }
; 700  :     DUMPBITS(8)

  00163	c1 eb 08	 shr	 ebx, 8
  00166	83 ee 08	 sub	 esi, 8
  00169	85 ff		 test	 edi, edi
  0016b	0f 85 5f ff ff
	ff		 jne	 $LL6@inflate_st
$LN32@inflate_st:

; 701  :   }
; 702  : 
; 703  : 
; 704  :   /* restore the globals from the locals */
; 705  :   G.wp = w;                       /* restore global window pointer */

  00171	8b 45 fc	 mov	 eax, DWORD PTR _w$1$[ebp]
  00174	5f		 pop	 edi

; 706  :   G.bb = b;                       /* restore global bit buffer */
; 707  :   G.bk = k;

  00175	89 35 20 00 00
	00		 mov	 DWORD PTR _G+32, esi
  0017b	5e		 pop	 esi
  0017c	a3 24 00 00 00	 mov	 DWORD PTR _G+36, eax

; 708  :   return 0;

  00181	33 c0		 xor	 eax, eax
  00183	89 1d 28 00 00
	00		 mov	 DWORD PTR _G+40, ebx
  00189	5b		 pop	 ebx

; 709  : }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
$LN26@inflate_st:
  0018e	5f		 pop	 edi
  0018f	5e		 pop	 esi

; 673  : 
; 674  : 
; 675  :   /* go to byte boundary */
; 676  :   n = k & 7;
; 677  :   DUMPBITS(n);
; 678  : 
; 679  : 
; 680  :   /* get the length and its complement */
; 681  :   NEEDBITS(16)

  00190	b8 01 00 00 00	 mov	 eax, 1
  00195	5b		 pop	 ebx

; 709  : }

  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c3		 ret	 0
_inflate_stored ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\inflate.c
;	COMDAT _inflate_codes
_TEXT	SEGMENT
_md$1$ = -28						; size = 4
_ml$1$ = -24						; size = 4
_n$1$ = -20						; size = 4
_t$2$ = -16						; size = 4
_k$1$ = -16						; size = 4
_t$1$ = -12						; size = 4
_e$2$ = -12						; size = 4
_c$1$ = -12						; size = 4
_b$1$ = -12						; size = 4
_c$1$ = -8						; size = 4
_c$1$ = -8						; size = 4
_e$1$ = -8						; size = 4
_w$1$ = -4						; size = 4
_tl$ = 8						; size = 4
_td$ = 12						; size = 4
_bl$ = 16						; size = 4
_bd$ = 20						; size = 4
_inflate_codes PROC					; COMDAT

; 545  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 559  : 
; 560  : 
; 561  :   /* inflate the coded data */
; 562  :   ml = mask_bits[bl];           /* precompute masks for speed */

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _bl$[ebp]
  00009	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _G+36
  0000f	53		 push	 ebx
  00010	8b 1d 28 00 00
	00		 mov	 ebx, DWORD PTR _G+40
  00016	0f b7 04 4d 00
	00 00 00	 movzx	 eax, WORD PTR _mask_bits[ecx*2]
  0001e	89 45 e8	 mov	 DWORD PTR _ml$1$[ebp], eax

; 563  :   md = mask_bits[bd];

  00021	8b 45 14	 mov	 eax, DWORD PTR _bd$[ebp]
  00024	56		 push	 esi
  00025	8b 35 20 00 00
	00		 mov	 esi, DWORD PTR _G+32
  0002b	57		 push	 edi
  0002c	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR _mask_bits[eax*2]
  00034	89 45 e4	 mov	 DWORD PTR _md$1$[ebp], eax
$LN123@inflate_co:

; 546  :   register unsigned e;  /* table entry flag/number of extra bits */
; 547  :   unsigned n, d;        /* length and index for copy */
; 548  :   unsigned w;           /* current window position */
; 549  :   struct huft *t;       /* pointer to table entry */
; 550  :   unsigned ml, md;      /* masks for bl and bd bits */
; 551  :   register ulg b;       /* bit buffer */
; 552  :   register unsigned k;  /* number of bits in bit buffer */
; 553  : 
; 554  : 
; 555  :   /* make local copies of globals */
; 556  :   b = G.bb;                       /* initialize bit buffer */
; 557  :   k = G.bk;
; 558  :   w = G.wp;                       /* initialize window position */

  00037	89 55 fc	 mov	 DWORD PTR _w$1$[ebp], edx
$LN125@inflate_co:

; 563  :   md = mask_bits[bd];

  0003a	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  0003f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _G
$LL2@inflate_co:

; 564  :   while (1)                     /* do until end of block */
; 565  :   {
; 566  :     NEEDBITS((unsigned)bl)

  00045	3b f1		 cmp	 esi, ecx
  00047	73 3d		 jae	 SHORT $LN5@inflate_co
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@inflate_co:
  00050	8b c8		 mov	 ecx, eax
  00052	48		 dec	 eax
  00053	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  00058	85 c9		 test	 ecx, ecx
  0005a	0f 88 71 03 00
	00		 js	 $LN70@inflate_co
  00060	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00063	47		 inc	 edi
  00064	89 4d f4	 mov	 DWORD PTR _c$1$[ebp], ecx
  00067	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  0006d	83 f9 ff	 cmp	 ecx, -1
  00070	0f 84 5b 03 00
	00		 je	 $LN70@inflate_co
  00076	8b ce		 mov	 ecx, esi
  00078	83 c6 08	 add	 esi, 8
  0007b	d3 65 f4	 shl	 DWORD PTR _c$1$[ebp], cl
  0007e	0b 5d f4	 or	 ebx, DWORD PTR _c$1$[ebp]
  00081	3b 75 10	 cmp	 esi, DWORD PTR _bl$[ebp]
  00084	72 ca		 jb	 SHORT $LL4@inflate_co
$LN5@inflate_co:

; 567  :     if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)

  00086	8b 4d e8	 mov	 ecx, DWORD PTR _ml$1$[ebp]
  00089	8b 55 08	 mov	 edx, DWORD PTR _tl$[ebp]
  0008c	23 cb		 and	 ecx, ebx
  0008e	8d 0c ca	 lea	 ecx, DWORD PTR [edx+ecx*8]
  00091	8b 55 fc	 mov	 edx, DWORD PTR _w$1$[ebp]
  00094	89 4d f4	 mov	 DWORD PTR _t$1$[ebp], ecx
  00097	0f b6 49 01	 movzx	 ecx, BYTE PTR [ecx+1]
  0009b	89 4d f8	 mov	 DWORD PTR _e$1$[ebp], ecx
  0009e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000a1	8b 4d f4	 mov	 ecx, DWORD PTR _t$1$[ebp]
  000a4	0f 86 7e 00 00
	00		 jbe	 $LN7@inflate_co
  000aa	8b 55 f8	 mov	 edx, DWORD PTR _e$1$[ebp]
  000ad	0f 1f 00	 npad	 3
$LL8@inflate_co:

; 568  :       do {
; 569  :         if (e == 99)

  000b0	83 fa 63	 cmp	 edx, 99			; 00000063H
  000b3	0f 84 18 03 00
	00		 je	 $LN70@inflate_co

; 570  :           return 1;
; 571  :         DUMPBITS(t->b)

  000b9	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]

; 572  :         e -= 16;

  000bc	83 ea 10	 sub	 edx, 16			; 00000010H
  000bf	2b f1		 sub	 esi, ecx
  000c1	d3 eb		 shr	 ebx, cl
  000c3	89 55 f8	 mov	 DWORD PTR _e$1$[ebp], edx

; 573  :         NEEDBITS(e)

  000c6	3b f2		 cmp	 esi, edx
  000c8	73 39		 jae	 SHORT $LN6@inflate_co
  000ca	66 0f 1f 44 00
	00		 npad	 6
$LL9@inflate_co:
  000d0	8b c8		 mov	 ecx, eax
  000d2	48		 dec	 eax
  000d3	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  000d8	85 c9		 test	 ecx, ecx
  000da	0f 88 f1 02 00
	00		 js	 $LN70@inflate_co
  000e0	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  000e3	47		 inc	 edi
  000e4	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  000ea	83 fa ff	 cmp	 edx, -1
  000ed	0f 84 de 02 00
	00		 je	 $LN70@inflate_co
  000f3	8b ce		 mov	 ecx, esi
  000f5	83 c6 08	 add	 esi, 8
  000f8	d3 e2		 shl	 edx, cl
  000fa	0b da		 or	 ebx, edx
  000fc	8b 55 f8	 mov	 edx, DWORD PTR _e$1$[ebp]
  000ff	3b f2		 cmp	 esi, edx
  00101	72 cd		 jb	 SHORT $LL9@inflate_co
$LN6@inflate_co:

; 574  :       } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);

  00103	8b 4d f4	 mov	 ecx, DWORD PTR _t$1$[ebp]
  00106	0f b7 14 55 00
	00 00 00	 movzx	 edx, WORD PTR _mask_bits[edx*2]
  0010e	23 d3		 and	 edx, ebx
  00110	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00113	8d 0c d1	 lea	 ecx, DWORD PTR [ecx+edx*8]
  00116	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  0011a	89 4d f4	 mov	 DWORD PTR _t$1$[ebp], ecx
  0011d	89 55 f8	 mov	 DWORD PTR _e$1$[ebp], edx
  00120	83 fa 10	 cmp	 edx, 16			; 00000010H
  00123	77 8b		 ja	 SHORT $LL8@inflate_co
  00125	8b 55 fc	 mov	 edx, DWORD PTR _w$1$[ebp]
$LN7@inflate_co:

; 575  :     DUMPBITS(t->b)

  00128	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  0012b	d3 eb		 shr	 ebx, cl
  0012d	2b f1		 sub	 esi, ecx

; 576  :     if (e == 16)                /* then it's a literal */

  0012f	8b 4d f8	 mov	 ecx, DWORD PTR _e$1$[ebp]
  00132	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00135	75 55		 jne	 SHORT $LN32@inflate_co

; 577  :     {
; 578  :       redirSlide[w++] = (uch)t->v.n;

  00137	8b 4d f4	 mov	 ecx, DWORD PTR _t$1$[ebp]
  0013a	8a 49 04	 mov	 cl, BYTE PTR [ecx+4]
  0013d	88 8a 00 00 00
	00		 mov	 BYTE PTR _redirSlide[edx], cl
  00143	42		 inc	 edx

; 579  :       if (w == wsize)

  00144	8b 4d 10	 mov	 ecx, DWORD PTR _bl$[ebp]
  00147	89 55 fc	 mov	 DWORD PTR _w$1$[ebp], edx
  0014a	81 fa 00 80 00
	00		 cmp	 edx, 32768		; 00008000H
  00150	0f 85 ef fe ff
	ff		 jne	 $LL2@inflate_co

; 580  :       {
; 581  :         FLUSH(w);

  00156	68 00 80 00 00	 push	 32768			; 00008000H
  0015b	68 00 00 00 00	 push	 OFFSET _redirSlide
  00160	ff 35 04 00 00
	00		 push	 DWORD PTR _G+4
  00166	e8 00 00 00 00	 call	 _memcpy
  0016b	81 05 04 00 00
	00 00 80 00 00	 add	 DWORD PTR _G+4, 32768	; 00008000H
  00175	83 c4 0c	 add	 esp, 12			; 0000000cH
  00178	81 05 0c 00 00
	00 00 80 00 00	 add	 DWORD PTR _G+12, 32768	; 00008000H

; 582  :         w = 0;

  00182	33 d2		 xor	 edx, edx

; 583  :       }
; 584  :     }

  00184	8b 4d 10	 mov	 ecx, DWORD PTR _bl$[ebp]
  00187	e9 ab fe ff ff	 jmp	 $LN123@inflate_co
$LN32@inflate_co:

; 585  :     else                        /* it's an EOB or a length */
; 586  :     {
; 587  :       /* exit if end of block */
; 588  :       if (e == 15)

  0018c	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  0018f	0f 84 48 02 00
	00		 je	 $LN78@inflate_co

; 589  :         break;
; 590  : 
; 591  :       /* get length of block to copy */
; 592  :       NEEDBITS(e)

  00195	8b 55 f8	 mov	 edx, DWORD PTR _e$1$[ebp]
  00198	3b f2		 cmp	 esi, edx
  0019a	73 39		 jae	 SHORT $LN12@inflate_co
  0019c	0f 1f 40 00	 npad	 4
$LL11@inflate_co:
  001a0	8b c8		 mov	 ecx, eax
  001a2	48		 dec	 eax
  001a3	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  001a8	85 c9		 test	 ecx, ecx
  001aa	0f 88 21 02 00
	00		 js	 $LN70@inflate_co
  001b0	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  001b3	47		 inc	 edi
  001b4	89 4d f8	 mov	 DWORD PTR _c$1$[ebp], ecx
  001b7	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  001bd	83 f9 ff	 cmp	 ecx, -1
  001c0	0f 84 0b 02 00
	00		 je	 $LN70@inflate_co
  001c6	8b ce		 mov	 ecx, esi
  001c8	83 c6 08	 add	 esi, 8
  001cb	d3 65 f8	 shl	 DWORD PTR _c$1$[ebp], cl
  001ce	0b 5d f8	 or	 ebx, DWORD PTR _c$1$[ebp]
  001d1	3b f2		 cmp	 esi, edx
  001d3	72 cb		 jb	 SHORT $LL11@inflate_co
$LN12@inflate_co:

; 593  :       n = t->v.n + ((unsigned)b & mask_bits[e]);

  001d5	0f b7 0c 55 00
	00 00 00	 movzx	 ecx, WORD PTR _mask_bits[edx*2]

; 594  :       DUMPBITS(e);

  001dd	2b f2		 sub	 esi, edx
  001df	23 cb		 and	 ecx, ebx
  001e1	89 4d ec	 mov	 DWORD PTR _n$1$[ebp], ecx
  001e4	8b 4d f4	 mov	 ecx, DWORD PTR _t$1$[ebp]
  001e7	0f b7 49 04	 movzx	 ecx, WORD PTR [ecx+4]
  001eb	01 4d ec	 add	 DWORD PTR _n$1$[ebp], ecx
  001ee	8b ca		 mov	 ecx, edx
  001f0	d3 eb		 shr	 ebx, cl

; 595  : 
; 596  :       /* decode distance of block to copy */
; 597  :       NEEDBITS((unsigned)bd)

  001f2	3b 75 14	 cmp	 esi, DWORD PTR _bd$[ebp]
  001f5	73 31		 jae	 SHORT $LN14@inflate_co
$LL13@inflate_co:
  001f7	8b c8		 mov	 ecx, eax
  001f9	48		 dec	 eax
  001fa	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  001ff	85 c9		 test	 ecx, ecx
  00201	0f 88 ca 01 00
	00		 js	 $LN70@inflate_co
  00207	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  0020a	47		 inc	 edi
  0020b	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  00211	83 fa ff	 cmp	 edx, -1
  00214	0f 84 b7 01 00
	00		 je	 $LN70@inflate_co
  0021a	8b ce		 mov	 ecx, esi
  0021c	83 c6 08	 add	 esi, 8
  0021f	d3 e2		 shl	 edx, cl
  00221	0b da		 or	 ebx, edx
  00223	3b 75 14	 cmp	 esi, DWORD PTR _bd$[ebp]
  00226	72 cf		 jb	 SHORT $LL13@inflate_co
$LN14@inflate_co:

; 598  :       if ((e = (t = td + ((unsigned)b & md))->e) > 16)

  00228	8b 4d e4	 mov	 ecx, DWORD PTR _md$1$[ebp]
  0022b	8b 55 0c	 mov	 edx, DWORD PTR _td$[ebp]
  0022e	23 cb		 and	 ecx, ebx
  00230	8d 0c ca	 lea	 ecx, DWORD PTR [edx+ecx*8]
  00233	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00237	89 4d f0	 mov	 DWORD PTR _t$2$[ebp], ecx
  0023a	89 55 f4	 mov	 DWORD PTR _e$2$[ebp], edx
  0023d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00240	76 73		 jbe	 SHORT $LN16@inflate_co
$LL17@inflate_co:

; 599  :         do {
; 600  :           if (e == 99)

  00242	83 fa 63	 cmp	 edx, 99			; 00000063H
  00245	0f 84 86 01 00
	00		 je	 $LN70@inflate_co

; 601  :             return 1;
; 602  :           DUMPBITS(t->b)

  0024b	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]

; 603  :           e -= 16;

  0024e	83 ea 10	 sub	 edx, 16			; 00000010H
  00251	2b f1		 sub	 esi, ecx
  00253	d3 eb		 shr	 ebx, cl
  00255	89 55 f4	 mov	 DWORD PTR _e$2$[ebp], edx

; 604  :           NEEDBITS(e)

  00258	3b f2		 cmp	 esi, edx
  0025a	73 37		 jae	 SHORT $LN15@inflate_co
  0025c	0f 1f 40 00	 npad	 4
$LL18@inflate_co:
  00260	8b c8		 mov	 ecx, eax
  00262	48		 dec	 eax
  00263	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  00268	85 c9		 test	 ecx, ecx
  0026a	0f 88 61 01 00
	00		 js	 $LN70@inflate_co
  00270	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00273	47		 inc	 edi
  00274	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  0027a	83 fa ff	 cmp	 edx, -1
  0027d	0f 84 4e 01 00
	00		 je	 $LN70@inflate_co
  00283	8b ce		 mov	 ecx, esi
  00285	83 c6 08	 add	 esi, 8
  00288	d3 e2		 shl	 edx, cl
  0028a	0b da		 or	 ebx, edx
  0028c	8b 55 f4	 mov	 edx, DWORD PTR _e$2$[ebp]
  0028f	3b f2		 cmp	 esi, edx
  00291	72 cd		 jb	 SHORT $LL18@inflate_co
$LN15@inflate_co:

; 605  :         } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);

  00293	8b 4d f0	 mov	 ecx, DWORD PTR _t$2$[ebp]
  00296	0f b7 14 55 00
	00 00 00	 movzx	 edx, WORD PTR _mask_bits[edx*2]
  0029e	23 d3		 and	 edx, ebx
  002a0	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  002a3	8d 0c d1	 lea	 ecx, DWORD PTR [ecx+edx*8]
  002a6	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  002aa	89 4d f0	 mov	 DWORD PTR _t$2$[ebp], ecx
  002ad	89 55 f4	 mov	 DWORD PTR _e$2$[ebp], edx
  002b0	83 fa 10	 cmp	 edx, 16			; 00000010H
  002b3	77 8d		 ja	 SHORT $LL17@inflate_co
$LN16@inflate_co:

; 606  :       DUMPBITS(t->b)

  002b5	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  002b8	2b f1		 sub	 esi, ecx
  002ba	d3 eb		 shr	 ebx, cl

; 607  :       NEEDBITS(e)

  002bc	3b f2		 cmp	 esi, edx
  002be	73 35		 jae	 SHORT $LN21@inflate_co
$LL20@inflate_co:
  002c0	8b c8		 mov	 ecx, eax
  002c2	48		 dec	 eax
  002c3	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  002c8	85 c9		 test	 ecx, ecx
  002ca	0f 88 01 01 00
	00		 js	 $LN70@inflate_co
  002d0	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  002d3	47		 inc	 edi
  002d4	89 4d f8	 mov	 DWORD PTR _c$1$[ebp], ecx
  002d7	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  002dd	83 f9 ff	 cmp	 ecx, -1
  002e0	0f 84 eb 00 00
	00		 je	 $LN70@inflate_co
  002e6	8b ce		 mov	 ecx, esi
  002e8	83 c6 08	 add	 esi, 8
  002eb	d3 65 f8	 shl	 DWORD PTR _c$1$[ebp], cl
  002ee	0b 5d f8	 or	 ebx, DWORD PTR _c$1$[ebp]
  002f1	3b f2		 cmp	 esi, edx
  002f3	72 cb		 jb	 SHORT $LL20@inflate_co
$LN21@inflate_co:

; 608  :       d = w - t->v.n - ((unsigned)b & mask_bits[e]);

  002f5	8b 4d f0	 mov	 ecx, DWORD PTR _t$2$[ebp]
  002f8	0f b7 04 55 00
	00 00 00	 movzx	 eax, WORD PTR _mask_bits[edx*2]
  00300	8b 55 fc	 mov	 edx, DWORD PTR _w$1$[ebp]
  00303	23 c3		 and	 eax, ebx
  00305	8b fa		 mov	 edi, edx
  00307	2b f8		 sub	 edi, eax
  00309	0f b7 41 04	 movzx	 eax, WORD PTR [ecx+4]
  0030d	2b f8		 sub	 edi, eax

; 609  :       DUMPBITS(e)

  0030f	8b 45 f4	 mov	 eax, DWORD PTR _e$2$[ebp]
  00312	8b c8		 mov	 ecx, eax
  00314	d3 eb		 shr	 ebx, cl
  00316	2b f0		 sub	 esi, eax
  00318	89 75 f0	 mov	 DWORD PTR _k$1$[ebp], esi
  0031b	8b 75 ec	 mov	 esi, DWORD PTR _n$1$[ebp]
  0031e	89 5d f4	 mov	 DWORD PTR _b$1$[ebp], ebx
$LL24@inflate_co:

; 610  : 
; 611  :       /* do the copy */
; 612  :       do {
; 613  : #if (defined(DLL) && !defined(NO_SLIDE_REDIR))
; 614  :         if (G.redirect_slide) {/* &= w/ wsize unnecessary & wrong if redirect */
; 615  :           if (d >= wsize)
; 616  :             return 1;           /* invalid compressed data */
; 617  :           n -= (e = (e = wsize - (d > w ? d : w)) > n ? n : e);
; 618  :         }
; 619  :         else
; 620  : #endif
; 621  :           n -= (e = (e = wsize - ((d &= wsize-1) > w ? d : w)) > n ? n : e);

  00321	81 e7 ff 7f 00
	00		 and	 edi, 32767		; 00007fffH
  00327	8b c2		 mov	 eax, edx
  00329	3b fa		 cmp	 edi, edx
  0032b	bb 00 80 00 00	 mov	 ebx, 32768		; 00008000H
  00330	0f 47 c7	 cmova	 eax, edi
  00333	2b d8		 sub	 ebx, eax

; 622  : #ifndef NOMEMCPY
; 623  :         if (w - d >= e)         /* (this test assumes unsigned comparison) */

  00335	8b c2		 mov	 eax, edx
  00337	3b de		 cmp	 ebx, esi
  00339	0f 47 de	 cmova	 ebx, esi
  0033c	2b c7		 sub	 eax, edi
  0033e	2b f3		 sub	 esi, ebx
  00340	3b c3		 cmp	 eax, ebx
  00342	72 2c		 jb	 SHORT $LL27@inflate_co

; 624  :         {
; 625  :           memcpy(redirSlide + w, redirSlide + d, e);

  00344	53		 push	 ebx
  00345	8d 87 00 00 00
	00		 lea	 eax, DWORD PTR _redirSlide[edi]
  0034b	50		 push	 eax
  0034c	8d 82 00 00 00
	00		 lea	 eax, DWORD PTR _redirSlide[edx]
  00352	50		 push	 eax
  00353	e8 00 00 00 00	 call	 _memcpy

; 626  :           w += e;

  00358	8b 55 fc	 mov	 edx, DWORD PTR _w$1$[ebp]
  0035b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035e	03 d3		 add	 edx, ebx

; 627  :           d += e;

  00360	03 fb		 add	 edi, ebx

; 628  :         }

  00362	eb 1f		 jmp	 SHORT $LN124@inflate_co
  00364	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL27@inflate_co:

; 629  :         else                    /* do it slowly to avoid memcpy() overlap */
; 630  : #endif /* !NOMEMCPY */
; 631  :           do {
; 632  :             redirSlide[w++] = redirSlide[d++];

  00370	8a 87 00 00 00
	00		 mov	 al, BYTE PTR _redirSlide[edi]
  00376	47		 inc	 edi
  00377	88 82 00 00 00
	00		 mov	 BYTE PTR _redirSlide[edx], al
  0037d	42		 inc	 edx

; 633  :           } while (--e);

  0037e	83 eb 01	 sub	 ebx, 1
  00381	75 ed		 jne	 SHORT $LL27@inflate_co
$LN124@inflate_co:
  00383	89 55 fc	 mov	 DWORD PTR _w$1$[ebp], edx

; 634  :         if (w == wsize)

  00386	81 fa 00 80 00
	00		 cmp	 edx, 32768		; 00008000H
  0038c	75 2d		 jne	 SHORT $LN22@inflate_co

; 635  :         {
; 636  :           FLUSH(w);

  0038e	52		 push	 edx
  0038f	68 00 00 00 00	 push	 OFFSET _redirSlide
  00394	ff 35 04 00 00
	00		 push	 DWORD PTR _G+4
  0039a	e8 00 00 00 00	 call	 _memcpy
  0039f	81 05 04 00 00
	00 00 80 00 00	 add	 DWORD PTR _G+4, 32768	; 00008000H
  003a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ac	81 05 0c 00 00
	00 00 80 00 00	 add	 DWORD PTR _G+12, 32768	; 00008000H

; 637  :           w = 0;

  003b6	33 d2		 xor	 edx, edx
  003b8	89 55 fc	 mov	 DWORD PTR _w$1$[ebp], edx
$LN22@inflate_co:

; 638  :         }
; 639  :       } while (n);

  003bb	85 f6		 test	 esi, esi
  003bd	0f 85 5e ff ff
	ff		 jne	 $LL24@inflate_co

; 640  :     }
; 641  :   }

  003c3	8b 75 f0	 mov	 esi, DWORD PTR _k$1$[ebp]
  003c6	8b 5d f4	 mov	 ebx, DWORD PTR _b$1$[ebp]
  003c9	8b 4d 10	 mov	 ecx, DWORD PTR _bl$[ebp]
  003cc	e9 69 fc ff ff	 jmp	 $LN125@inflate_co
$LN70@inflate_co:
  003d1	5f		 pop	 edi
  003d2	5e		 pop	 esi

; 564  :   while (1)                     /* do until end of block */
; 565  :   {
; 566  :     NEEDBITS((unsigned)bl)

  003d3	b8 01 00 00 00	 mov	 eax, 1
  003d8	5b		 pop	 ebx

; 652  : }

  003d9	8b e5		 mov	 esp, ebp
  003db	5d		 pop	 ebp
  003dc	c3		 ret	 0
$LN78@inflate_co:
  003dd	5f		 pop	 edi

; 642  : 
; 643  : 
; 644  :   /* restore the globals from the locals */
; 645  :   G.wp = w;                       /* restore global window pointer */
; 646  :   G.bb = b;                       /* restore global bit buffer */
; 647  :   G.bk = k;

  003de	89 35 20 00 00
	00		 mov	 DWORD PTR _G+32, esi

; 648  : 
; 649  : 
; 650  :   /* done */
; 651  :   return 0;

  003e4	33 c0		 xor	 eax, eax
  003e6	5e		 pop	 esi
  003e7	89 1d 28 00 00
	00		 mov	 DWORD PTR _G+40, ebx
  003ed	89 15 24 00 00
	00		 mov	 DWORD PTR _G+36, edx
  003f3	5b		 pop	 ebx

; 652  : }

  003f4	8b e5		 mov	 esp, ebp
  003f6	5d		 pop	 ebp
  003f7	c3		 ret	 0
_inflate_codes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\inflate.c
;	COMDAT _DecompressDeflatedData
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_inLength$ = 16						; size = 4
_DecompressDeflatedData PROC				; COMDAT

; 1314 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1315 : 	G.outbufptr = out;

  00003	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  00006	a3 04 00 00 00	 mov	 DWORD PTR _G+4, eax

; 1316 :     G.inptr = in;

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  0000e	a3 00 00 00 00	 mov	 DWORD PTR _G, eax

; 1317 :     G.incnt = inLength;

  00013	8b 45 10	 mov	 eax, DWORD PTR _inLength$[ebp]
  00016	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax

; 1318 : 	G.outCounter = 0;

  0001b	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+12, 0

; 1319 : 
; 1320 : 	if (inflate(__G) != 0) 

  00025	e8 00 00 00 00	 call	 _inflate
  0002a	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _G+12
  00030	33 d2		 xor	 edx, edx
  00032	85 c0		 test	 eax, eax
  00034	0f 45 ca	 cmovne	 ecx, edx
  00037	8b c1		 mov	 eax, ecx

; 1321 : 	{
; 1322 : 		// Error decompressing
; 1323 : 		return 0;
; 1324 : 	}
; 1325 : 	return G.outCounter;
; 1326 : }

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
_DecompressDeflatedData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\inflate.c
;	COMDAT _huft_build
_TEXT	SEGMENT
_n$GSCopy$2$ = -1492					; size = 4
_a$1$ = -1488						; size = 4
_q$2$ = -1484						; size = 4
_t$GSCopy$1$ = -1480					; size = 4
_el$1$ = -1476						; size = 4
tv1197 = -1472						; size = 4
tv1176 = -1472						; size = 4
tv1173 = -1468						; size = 4
_p$3$ = -1464						; size = 4
_y$1$ = -1460						; size = 4
_m$GSCopy$1$ = -1456					; size = 4
_g$1$ = -1452						; size = 4
_r$ = -1448						; size = 8
_i$4$ = -1440						; size = 4
_w$1$ = -1436						; size = 4
_h$1$ = -1432						; size = 4
_k$1$ = -1428						; size = 4
_v$ = -1424						; size = 1152
_u$ = -272						; size = 64
_lx$ = -208						; size = 68
_x$ = -140						; size = 68
_c$ = -72						; size = 68
__$ArrayPad$ = -4					; size = 4
_b$ = 8							; size = 4
_n$ = 12						; size = 4
_s$ = 16						; size = 4
_d$ = 20						; size = 4
_e$ = 24						; size = 4
_t$ = 28						; size = 4
_m$ = 32						; size = 4
_huft_build PROC					; COMDAT

; 1091 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 05 00
	00		 sub	 esp, 1492		; 000005d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 20	 mov	 eax, DWORD PTR _m$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 1c	 mov	 ebx, DWORD PTR _t$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _b$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _n$[ebp]
  00022	89 9d 38 fa ff
	ff		 mov	 DWORD PTR _t$GSCopy$1$[ebp], ebx
  00028	89 85 50 fa ff
	ff		 mov	 DWORD PTR _m$GSCopy$1$[ebp], eax

; 1092 :   unsigned a;                   /* counter for codes of length k */
; 1093 :   unsigned c[BMAX+1];           /* bit length count table */
; 1094 :   unsigned el;                  /* length of EOB code (value 256) */
; 1095 :   unsigned f;                   /* i repeats in table every f entries */
; 1096 :   int g;                        /* maximum code length */
; 1097 :   int h;                        /* table level */
; 1098 :   register unsigned i;          /* counter, current code */
; 1099 :   register unsigned j;          /* counter */
; 1100 :   register int k;               /* number of bits in current code */
; 1101 :   int lx[BMAX+1];               /* memory for l[-1..BMAX-1] */
; 1102 :   int *l = lx+1;                /* stack of bits per table */
; 1103 :   register unsigned *p;         /* pointer into c[], b[], or v[] */
; 1104 :   register struct huft *q;      /* points to current table */
; 1105 :   struct huft r;                /* table entry for structure assignment */
; 1106 :   struct huft *u[BMAX];         /* table stack */
; 1107 :   unsigned v[N_MAX];            /* values in order of bit length */
; 1108 :   register int w;               /* bits before this table == (l * h) */
; 1109 :   unsigned x[BMAX+1];           /* bit offsets, then code stack */
; 1110 :   unsigned *xp;                 /* pointer into x */
; 1111 :   int y;                        /* number of dummy codes added */
; 1112 :   unsigned z;                   /* number of entries in current table */
; 1113 : 
; 1114 : 
; 1115 :   /* Generate counts for each bit length */
; 1116 :   el = n > 256 ? b[256] : BMAX; /* set length of EOB code, if any */

  0002e	81 ff 00 01 00
	00		 cmp	 edi, 256		; 00000100H
  00034	76 0e		 jbe	 SHORT $LN55@huft_build
  00036	8b 86 00 04 00
	00		 mov	 eax, DWORD PTR [esi+1024]
  0003c	89 85 3c fa ff
	ff		 mov	 DWORD PTR _el$1$[ebp], eax
  00042	eb 0a		 jmp	 SHORT $LN56@huft_build
$LN55@huft_build:
  00044	c7 85 3c fa ff
	ff 10 00 00 00	 mov	 DWORD PTR _el$1$[ebp], 16 ; 00000010H
$LN56@huft_build:

; 1117 :   memset(c, 0, sizeof(c));

  0004e	6a 44		 push	 68			; 00000044H
  00050	8d 45 b8	 lea	 eax, DWORD PTR _c$[ebp]
  00053	6a 00		 push	 0
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _memset
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1118 :   p = (unsigned *)b;  i = n;

  0005e	8b ce		 mov	 ecx, esi
  00060	8b d7		 mov	 edx, edi
$LL4@huft_build:

; 1119 :   do {
; 1120 :     c[*p]++; p++;               /* assume all entries <= BMAX */

  00062	8b 01		 mov	 eax, DWORD PTR [ecx]
  00064	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00067	ff 44 85 b8	 inc	 DWORD PTR _c$[ebp+eax*4]

; 1121 :   } while (--i);

  0006b	83 ea 01	 sub	 edx, 1
  0006e	75 f2		 jne	 SHORT $LL4@huft_build

; 1122 :   if (c[0] == n)                /* null input--all zero length codes */

  00070	39 7d b8	 cmp	 DWORD PTR _c$[ebp], edi
  00073	75 1d		 jne	 SHORT $LN36@huft_build

; 1123 :   {
; 1124 :     *t = (struct huft *)NULL;
; 1125 :     *m = 0;

  00075	8b 8d 50 fa ff
	ff		 mov	 ecx, DWORD PTR _m$GSCopy$1$[ebp]
  0007b	89 13		 mov	 DWORD PTR [ebx], edx
  0007d	89 11		 mov	 DWORD PTR [ecx], edx
$LN59@huft_build:

; 1266 :     }
; 1267 :   }
; 1268 : 
; 1269 : 
; 1270 :   /* return actual size of base table */
; 1271 :   *m = l[0];
; 1272 : 
; 1273 : 
; 1274 :   /* Return true (1) if we were given an incomplete table */
; 1275 :   return y != 0 && g != 1;

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	33 c0		 xor	 eax, eax
  00083	5b		 pop	 ebx

; 1276 : }

  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	33 cd		 xor	 ecx, ebp
  00089	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
$LN36@huft_build:

; 1126 :     return 0;
; 1127 :   }
; 1128 : 
; 1129 : 
; 1130 :   /* Find minimum and maximum length, bound *m by those */
; 1131 :   for (j = 1; j <= BMAX; j++)

  00092	b9 01 00 00 00	 mov	 ecx, 1
$LL7@huft_build:

; 1132 :     if (c[j])

  00097	83 7c 8d b8 00	 cmp	 DWORD PTR _c$[ebp+ecx*4], 0
  0009c	75 06		 jne	 SHORT $LN79@huft_build

; 1126 :     return 0;
; 1127 :   }
; 1128 : 
; 1129 : 
; 1130 :   /* Find minimum and maximum length, bound *m by those */
; 1131 :   for (j = 1; j <= BMAX; j++)

  0009e	41		 inc	 ecx
  0009f	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000a2	76 f3		 jbe	 SHORT $LL7@huft_build
$LN79@huft_build:

; 1133 :       break;
; 1134 :   k = j;                        /* minimum code length */
; 1135 :   if ((unsigned)*m < j)

  000a4	8b 85 50 fa ff
	ff		 mov	 eax, DWORD PTR _m$GSCopy$1$[ebp]
  000aa	89 8d 6c fa ff
	ff		 mov	 DWORD PTR _k$1$[ebp], ecx
  000b0	39 08		 cmp	 DWORD PTR [eax], ecx
  000b2	73 02		 jae	 SHORT $LN38@huft_build

; 1136 :     *m = j;

  000b4	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@huft_build:

; 1137 :   for (i = BMAX; i; i--)

  000b6	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000bb	0f 1f 44 00 00	 npad	 5
$LL10@huft_build:

; 1138 :     if (c[i])

  000c0	83 7c 95 b8 00	 cmp	 DWORD PTR _c$[ebp+edx*4], 0
  000c5	75 05		 jne	 SHORT $LN80@huft_build

; 1137 :   for (i = BMAX; i; i--)

  000c7	83 ea 01	 sub	 edx, 1
  000ca	75 f4		 jne	 SHORT $LL10@huft_build
$LN80@huft_build:

; 1139 :       break;
; 1140 :   g = i;                        /* maximum code length */

  000cc	89 95 54 fa ff
	ff		 mov	 DWORD PTR _g$1$[ebp], edx

; 1141 :   if ((unsigned)*m > i)

  000d2	39 10		 cmp	 DWORD PTR [eax], edx
  000d4	76 02		 jbe	 SHORT $LN40@huft_build

; 1142 :     *m = i;

  000d6	89 10		 mov	 DWORD PTR [eax], edx
$LN40@huft_build:

; 1143 : 
; 1144 : 
; 1145 :   /* Adjust last length count to fill out codes, if needed */
; 1146 :   for (y = 1 << j; j < i; j++, y <<= 1)

  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	d3 e0		 shl	 eax, cl
  000df	89 85 4c fa ff
	ff		 mov	 DWORD PTR _y$1$[ebp], eax
  000e5	3b ca		 cmp	 ecx, edx
  000e7	73 1e		 jae	 SHORT $LN12@huft_build
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@huft_build:

; 1147 :     if ((y -= c[j]) < 0)

  000f0	2b 44 8d b8	 sub	 eax, DWORD PTR _c$[ebp+ecx*4]
  000f4	0f 88 e8 02 00
	00		 js	 $LN81@huft_build

; 1143 : 
; 1144 : 
; 1145 :   /* Adjust last length count to fill out codes, if needed */
; 1146 :   for (y = 1 << j; j < i; j++, y <<= 1)

  000fa	41		 inc	 ecx
  000fb	03 c0		 add	 eax, eax
  000fd	89 85 4c fa ff
	ff		 mov	 DWORD PTR _y$1$[ebp], eax
  00103	3b ca		 cmp	 ecx, edx
  00105	72 e9		 jb	 SHORT $LL13@huft_build
$LN12@huft_build:

; 1149 :   if ((y -= c[i]) < 0)

  00107	8b 8d 4c fa ff
	ff		 mov	 ecx, DWORD PTR _y$1$[ebp]
  0010d	8d 1c 95 00 00
	00 00		 lea	 ebx, DWORD PTR [edx*4]
  00114	8b 44 1d b8	 mov	 eax, DWORD PTR _c$[ebp+ebx]
  00118	2b c8		 sub	 ecx, eax
  0011a	89 8d 4c fa ff
	ff		 mov	 DWORD PTR _y$1$[ebp], ecx
  00120	0f 88 bc 02 00
	00		 js	 $LN81@huft_build

; 1150 :     return 2;
; 1151 :   c[i] += y;

  00126	03 c1		 add	 eax, ecx

; 1152 : 
; 1153 : 
; 1154 :   /* Generate starting offsets into the value table for each length */
; 1155 :   x[1] = j = 0;

  00128	33 c9		 xor	 ecx, ecx
  0012a	89 44 1d b8	 mov	 DWORD PTR _c$[ebp+ebx], eax
  0012e	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _x$[ebp+4], ecx

; 1156 :   p = c + 1;  xp = x + 2;
; 1157 :   while (--i) {                 /* note that i == g from above */

  00134	83 ea 01	 sub	 edx, 1
  00137	74 1a		 je	 SHORT $LN15@huft_build
  00139	33 c0		 xor	 eax, eax
  0013b	0f 1f 44 00 00	 npad	 5
$LL14@huft_build:

; 1158 :     *xp++ = (j += *p++);

  00140	03 4c 05 bc	 add	 ecx, DWORD PTR _c$[ebp+eax+4]
  00144	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  00147	89 8c 05 78 ff
	ff ff		 mov	 DWORD PTR _x$[ebp+eax+4], ecx
  0014e	83 ea 01	 sub	 edx, 1
  00151	75 ed		 jne	 SHORT $LL14@huft_build
$LN15@huft_build:

; 1159 :   }
; 1160 : 
; 1161 : 
; 1162 :   /* Make a table of values in order of bit lengths */
; 1163 :   memset(v, 0, sizeof(v));

  00153	68 80 04 00 00	 push	 1152			; 00000480H
  00158	8d 85 70 fa ff
	ff		 lea	 eax, DWORD PTR _v$[ebp]
  0015e	6a 00		 push	 0
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 _memset
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1164 :   p = (unsigned *)b;  i = 0;

  00169	33 c9		 xor	 ecx, ecx
  0016b	0f 1f 44 00 00	 npad	 5
$LL18@huft_build:

; 1165 :   do {
; 1166 :     if ((j = *p++) != 0)

  00170	8b 16		 mov	 edx, DWORD PTR [esi]
  00172	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00175	85 d2		 test	 edx, edx
  00177	74 16		 je	 SHORT $LN16@huft_build

; 1167 :       v[x[j]++] = i;

  00179	8b 84 95 74 ff
	ff ff		 mov	 eax, DWORD PTR _x$[ebp+edx*4]
  00180	89 8c 85 70 fa
	ff ff		 mov	 DWORD PTR _v$[ebp+eax*4], ecx
  00187	40		 inc	 eax
  00188	89 84 95 74 ff
	ff ff		 mov	 DWORD PTR _x$[ebp+edx*4], eax
$LN16@huft_build:

; 1168 :   } while (++i < n);

  0018f	41		 inc	 ecx
  00190	3b cf		 cmp	 ecx, edi
  00192	72 dc		 jb	 SHORT $LL18@huft_build

; 1169 :   n = x[g];                     /* set n to length of v */

  00194	8b 84 1d 74 ff
	ff ff		 mov	 eax, DWORD PTR _x$[ebp+ebx]

; 1170 : 
; 1171 : 
; 1172 :   /* Generate the Huffman codes and for each, make the table entries */
; 1173 :   x[0] = i = 0;                 /* first Huffman code is zero */
; 1174 :   p = v;                        /* grab values in bit order */
; 1175 :   h = -1;                       /* no tables yet--level -1 */
; 1176 :   w = l[-1] = 0;                /* no bits decoded yet */

  0019b	33 d2		 xor	 edx, edx

; 1177 :   u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
; 1178 :   q = (struct huft *)NULL;      /* ditto */
; 1179 :   z = 0;                        /* ditto */
; 1180 : 
; 1181 :   /* go through the bit lengths (k already is bits in shortest code) */
; 1182 :   for (; k <= g; k++)

  0019d	8b b5 54 fa ff
	ff		 mov	 esi, DWORD PTR _g$1$[ebp]
  001a3	33 db		 xor	 ebx, ebx
  001a5	89 85 2c fa ff
	ff		 mov	 DWORD PTR _n$GSCopy$2$[ebp], eax
  001ab	83 c9 ff	 or	 ecx, -1
  001ae	8d 85 70 fa ff
	ff		 lea	 eax, DWORD PTR _v$[ebp]
  001b4	89 9d 60 fa ff
	ff		 mov	 DWORD PTR _i$4$[ebp], ebx
  001ba	89 85 48 fa ff
	ff		 mov	 DWORD PTR _p$3$[ebp], eax
  001c0	33 ff		 xor	 edi, edi
  001c2	8b 85 6c fa ff
	ff		 mov	 eax, DWORD PTR _k$1$[ebp]
  001c8	89 9d 74 ff ff
	ff		 mov	 DWORD PTR _x$[ebp], ebx
  001ce	89 8d 68 fa ff
	ff		 mov	 DWORD PTR _h$1$[ebp], ecx
  001d4	89 9d 30 ff ff
	ff		 mov	 DWORD PTR _lx$[ebp], ebx
  001da	89 95 64 fa ff
	ff		 mov	 DWORD PTR _w$1$[ebp], edx
  001e0	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _u$[ebp], edx
  001e6	89 95 34 fa ff
	ff		 mov	 DWORD PTR _q$2$[ebp], edx
  001ec	3b c6		 cmp	 eax, esi
  001ee	0f 8f 57 03 00
	00		 jg	 $LN125@huft_build

; 1169 :   n = x[g];                     /* set n to length of v */

  001f4	8d 75 b8	 lea	 esi, DWORD PTR _c$[ebp]
  001f7	8b da		 mov	 ebx, edx
  001f9	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]
  001fc	89 b5 44 fa ff
	ff		 mov	 DWORD PTR tv1173[ebp], esi
$LL21@huft_build:

; 1183 :   {
; 1184 :     a = c[k];

  00202	8b 36		 mov	 esi, DWORD PTR [esi]

; 1185 :     while (a--)

  00204	85 f6		 test	 esi, esi
  00206	0f 84 17 03 00
	00		 je	 $LN92@huft_build
  0020c	0f 1f 40 00	 npad	 4
$LL22@huft_build:
  00210	89 b5 40 fa ff
	ff		 mov	 DWORD PTR tv1197[ebp], esi
  00216	4e		 dec	 esi
  00217	89 b5 30 fa ff
	ff		 mov	 DWORD PTR _a$1$[ebp], esi

; 1186 :     {
; 1187 :       /* here i is the Huffman code of length k bits for value *p */
; 1188 :       /* make tables up to required level */
; 1189 :       while (k > w + l[h])

  0021d	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  00224	8b 84 35 34 ff
	ff ff		 mov	 eax, DWORD PTR _lx$[ebp+esi+4]
  0022b	03 c2		 add	 eax, edx
  0022d	39 85 6c fa ff
	ff		 cmp	 DWORD PTR _k$1$[ebp], eax
  00233	0f 8e 79 01 00
	00		 jle	 $LN25@huft_build
  00239	0f 1f 80 00 00
	00 00		 npad	 7
$LL24@huft_build:

; 1190 :       {
; 1191 :         w += l[h++];            /* add bits already decoded */
; 1192 : 
; 1193 :         /* compute minimum size table less than or equal to *m bits */
; 1194 :         z = (z = g - w) > (unsigned)*m ? *m : z;        /* upper limit */
; 1195 :         if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */

  00240	8b 9d 6c fa ff
	ff		 mov	 ebx, DWORD PTR _k$1$[ebp]
  00246	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _lx$[ebp+4]
  0024c	03 14 06	 add	 edx, DWORD PTR [esi+eax]
  0024f	41		 inc	 ecx
  00250	8b 85 50 fa ff
	ff		 mov	 eax, DWORD PTR _m$GSCopy$1$[ebp]
  00256	8b b5 54 fa ff
	ff		 mov	 esi, DWORD PTR _g$1$[ebp]
  0025c	2b f2		 sub	 esi, edx
  0025e	89 8d 68 fa ff
	ff		 mov	 DWORD PTR _h$1$[ebp], ecx
  00264	89 95 64 fa ff
	ff		 mov	 DWORD PTR _w$1$[ebp], edx
  0026a	8b 00		 mov	 eax, DWORD PTR [eax]
  0026c	3b f0		 cmp	 esi, eax
  0026e	0f 47 f0	 cmova	 esi, eax
  00271	2b da		 sub	 ebx, edx
  00273	b8 01 00 00 00	 mov	 eax, 1
  00278	8b cb		 mov	 ecx, ebx
  0027a	d3 e0		 shl	 eax, cl
  0027c	3b 85 40 fa ff
	ff		 cmp	 eax, DWORD PTR tv1197[ebp]
  00282	76 35		 jbe	 SHORT $LN82@huft_build

; 1196 :         {                       /* too few codes for k-w bit table */
; 1197 :           f -= a + 1;           /* deduct codes from patterns left */
; 1198 :           xp = c + k;

  00284	8b 95 44 fa ff
	ff		 mov	 edx, DWORD PTR tv1173[ebp]
  0028a	83 c9 ff	 or	 ecx, -1
  0028d	2b 8d 30 fa ff
	ff		 sub	 ecx, DWORD PTR _a$1$[ebp]

; 1199 :           while (++j < z)       /* try smaller tables up to z bits */

  00293	43		 inc	 ebx
  00294	03 c1		 add	 eax, ecx
  00296	3b de		 cmp	 ebx, esi
  00298	73 19		 jae	 SHORT $LN127@huft_build
  0029a	66 0f 1f 44 00
	00		 npad	 6
$LL26@huft_build:

; 1200 :           {
; 1201 :             if ((f <<= 1) <= *++xp)

  002a0	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  002a3	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  002a6	03 c0		 add	 eax, eax
  002a8	3b c1		 cmp	 eax, ecx
  002aa	76 07		 jbe	 SHORT $LN127@huft_build

; 1202 :               break;            /* enough codes to use up j bits */
; 1203 :             f -= *xp;           /* else deduct codes from patterns */

  002ac	43		 inc	 ebx
  002ad	2b c1		 sub	 eax, ecx
  002af	3b de		 cmp	 ebx, esi
  002b1	72 ed		 jb	 SHORT $LL26@huft_build
$LN127@huft_build:
  002b3	8b 95 64 fa ff
	ff		 mov	 edx, DWORD PTR _w$1$[ebp]
$LN82@huft_build:

; 1204 :           }
; 1205 :         }
; 1206 :         if ((unsigned)w + j > el && (unsigned)w < el)

  002b9	8b 8d 3c fa ff
	ff		 mov	 ecx, DWORD PTR _el$1$[ebp]
  002bf	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  002c2	3b c1		 cmp	 eax, ecx
  002c4	76 08		 jbe	 SHORT $LN46@huft_build
  002c6	3b d1		 cmp	 edx, ecx
  002c8	73 04		 jae	 SHORT $LN46@huft_build

; 1207 :           j = el - w;           /* make EOB code end at table */

  002ca	8b d9		 mov	 ebx, ecx
  002cc	2b da		 sub	 ebx, edx
$LN46@huft_build:

; 1208 :         z = 1 << j;             /* table entries for j-bit table */
; 1209 :         l[h] = j;               /* set table size in stack */

  002ce	8b b5 68 fa ff
	ff		 mov	 esi, DWORD PTR _h$1$[ebp]
  002d4	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _lx$[ebp+4]
  002da	8b cb		 mov	 ecx, ebx
  002dc	c1 e6 02	 shl	 esi, 2
  002df	bf 01 00 00 00	 mov	 edi, 1
  002e4	d3 e7		 shl	 edi, cl
  002e6	89 1c 06	 mov	 DWORD PTR [esi+eax], ebx

; 1210 : 
; 1211 :         /* allocate and link in new table */
; 1212 :         if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==

  002e9	8d 04 fd 08 00
	00 00		 lea	 eax, DWORD PTR [edi*8+8]
  002f0	50		 push	 eax
  002f1	e8 00 00 00 00	 call	 _malloc
  002f6	83 c4 04	 add	 esp, 4
  002f9	85 c0		 test	 eax, eax
  002fb	0f 84 84 02 00
	00		 je	 $LN83@huft_build

; 1217 :           return 3;             /* not enough memory */
; 1218 :         }
; 1219 : //#ifdef DEBUG
; 1220 : //        G.hufts += z + 1;         /* track memory usage */
; 1221 : //#endif
; 1222 :         *t = q + 1;             /* link to list for huft_free() */

  00301	8b 95 38 fa ff
	ff		 mov	 edx, DWORD PTR _t$GSCopy$1$[ebp]
  00307	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]

; 1223 :         *(t = &(q->v.t)) = (struct huft *)NULL;

  0030a	83 c0 04	 add	 eax, 4
  0030d	89 8d 34 fa ff
	ff		 mov	 DWORD PTR _q$2$[ebp], ecx

; 1224 :         u[h] = ++q;             /* table starts after link */
; 1225 : 
; 1226 :         /* connect to last table, if there is one */
; 1227 :         if (h)

  00313	83 bd 68 fa ff
	ff 00		 cmp	 DWORD PTR _h$1$[ebp], 0
  0031a	89 85 38 fa ff
	ff		 mov	 DWORD PTR _t$GSCopy$1$[ebp], eax
  00320	89 0a		 mov	 DWORD PTR [edx], ecx
  00322	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00328	89 8c 35 f0 fe
	ff ff		 mov	 DWORD PTR _u$[ebp+esi], ecx
  0032f	74 60		 je	 SHORT $LN49@huft_build

; 1228 :         {
; 1229 :           x[h] = i;             /* save pattern for backing up */

  00331	8b 85 60 fa ff
	ff		 mov	 eax, DWORD PTR _i$4$[ebp]

; 1230 :           r.b = (uch)l[h-1];    /* bits to dump before this table */
; 1231 :           r.e = (uch)(16 + j);  /* bits in this table */
; 1232 :           r.v.t = q;            /* pointer to this table */
; 1233 :           j = (i & ((1 << w) - 1)) >> (w - l[h-1]);

  00337	ba 01 00 00 00	 mov	 edx, 1
  0033c	89 8d 5c fa ff
	ff		 mov	 DWORD PTR _r$[ebp+4], ecx
  00342	8b 8d 64 fa ff
	ff		 mov	 ecx, DWORD PTR _w$1$[ebp]
  00348	d3 e2		 shl	 edx, cl
  0034a	2b 8c 35 30 ff
	ff ff		 sub	 ecx, DWORD PTR _lx$[ebp+esi]
  00351	4a		 dec	 edx
  00352	23 95 60 fa ff
	ff		 and	 edx, DWORD PTR _i$4$[ebp]
  00358	89 84 35 74 ff
	ff ff		 mov	 DWORD PTR _x$[ebp+esi], eax
  0035f	8a 84 35 30 ff
	ff ff		 mov	 al, BYTE PTR _lx$[ebp+esi]
  00366	d3 ea		 shr	 edx, cl

; 1234 :           u[h-1][j] = r;        /* connect to last table */

  00368	8b 8c 35 ec fe
	ff ff		 mov	 ecx, DWORD PTR _u$[ebp+esi-4]
  0036f	88 85 58 fa ff
	ff		 mov	 BYTE PTR _r$[ebp], al
  00375	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00378	88 85 59 fa ff
	ff		 mov	 BYTE PTR _r$[ebp+1], al
  0037e	8b 85 58 fa ff
	ff		 mov	 eax, DWORD PTR _r$[ebp]
  00384	89 04 d1	 mov	 DWORD PTR [ecx+edx*8], eax
  00387	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _r$[ebp+4]
  0038d	89 44 d1 04	 mov	 DWORD PTR [ecx+edx*8+4], eax
$LN49@huft_build:

; 1186 :     {
; 1187 :       /* here i is the Huffman code of length k bits for value *p */
; 1188 :       /* make tables up to required level */
; 1189 :       while (k > w + l[h])

  00391	8b 95 64 fa ff
	ff		 mov	 edx, DWORD PTR _w$1$[ebp]
  00397	8b 8d 68 fa ff
	ff		 mov	 ecx, DWORD PTR _h$1$[ebp]
  0039d	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  003a0	39 85 6c fa ff
	ff		 cmp	 DWORD PTR _k$1$[ebp], eax
  003a6	0f 8f 94 fe ff
	ff		 jg	 $LL24@huft_build
  003ac	8b 9d 60 fa ff
	ff		 mov	 ebx, DWORD PTR _i$4$[ebp]
$LN25@huft_build:

; 1235 :         }
; 1236 :       }
; 1237 : 
; 1238 :       /* set up table entry in r */
; 1239 :       r.b = (uch)(k - w);

  003b2	8a 85 6c fa ff
	ff		 mov	 al, BYTE PTR _k$1$[ebp]

; 1240 :       if (p >= v + n)

  003b8	8d b5 70 fa ff
	ff		 lea	 esi, DWORD PTR _v$[ebp]
  003be	2a c2		 sub	 al, dl
  003c0	88 85 58 fa ff
	ff		 mov	 BYTE PTR _r$[ebp], al
  003c6	8b 85 2c fa ff
	ff		 mov	 eax, DWORD PTR _n$GSCopy$2$[ebp]
  003cc	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  003cf	8b b5 48 fa ff
	ff		 mov	 esi, DWORD PTR _p$3$[ebp]
  003d5	3b f0		 cmp	 esi, eax
  003d7	72 1f		 jb	 SHORT $LN50@huft_build

; 1241 :         r.e = 99;               /* out of values--invalid code */

  003d9	c6 85 59 fa ff
	ff 63		 mov	 BYTE PTR _r$[ebp+1], 99	; 00000063H
  003e0	eb 5a		 jmp	 SHORT $LN53@huft_build
$LN81@huft_build:
  003e2	5f		 pop	 edi
  003e3	5e		 pop	 esi

; 1148 :       return 2;                 /* bad input: more codes than bits */

  003e4	b8 02 00 00 00	 mov	 eax, 2
  003e9	5b		 pop	 ebx

; 1276 : }

  003ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ed	33 cd		 xor	 ecx, ebp
  003ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f4	8b e5		 mov	 esp, ebp
  003f6	5d		 pop	 ebp
  003f7	c3		 ret	 0
$LN50@huft_build:

; 1242 :       else if (*p < s)

  003f8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003fa	8b 45 10	 mov	 eax, DWORD PTR _s$[ebp]
  003fd	3b c8		 cmp	 ecx, eax
  003ff	73 16		 jae	 SHORT $LN52@huft_build

; 1243 :       {
; 1244 :         r.e = (uch)(*p < 256 ? 16 : 15);  /* 256 is end-of-block code */

  00401	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00407	0f 92 c0	 setb	 al
  0040a	04 0f		 add	 al, 15			; 0000000fH
  0040c	88 85 59 fa ff
	ff		 mov	 BYTE PTR _r$[ebp+1], al

; 1245 :         r.v.n = (ush)*p++;                /* simple code is just the value */

  00412	66 8b c1	 mov	 ax, cx

; 1246 :       }

  00415	eb 15		 jmp	 SHORT $LN129@huft_build
$LN52@huft_build:

; 1247 :       else
; 1248 :       {
; 1249 :         r.e = (uch)e[*p - s];   /* non-simple--look up in lists */

  00417	2b c8		 sub	 ecx, eax
  00419	8b 45 18	 mov	 eax, DWORD PTR _e$[ebp]
  0041c	8a 04 48	 mov	 al, BYTE PTR [eax+ecx*2]
  0041f	88 85 59 fa ff
	ff		 mov	 BYTE PTR _r$[ebp+1], al

; 1250 :         r.v.n = d[*p++ - s];

  00425	8b 45 14	 mov	 eax, DWORD PTR _d$[ebp]
  00428	66 8b 04 48	 mov	 ax, WORD PTR [eax+ecx*2]
$LN129@huft_build:
  0042c	83 c6 04	 add	 esi, 4
  0042f	66 89 85 5c fa
	ff ff		 mov	 WORD PTR _r$[ebp+4], ax
  00436	89 b5 48 fa ff
	ff		 mov	 DWORD PTR _p$3$[ebp], esi
$LN53@huft_build:

; 1251 :       }
; 1252 : 
; 1253 :       /* fill code-like entries with r */
; 1254 :       f = 1 << (k - w);

  0043c	8b 8d 6c fa ff
	ff		 mov	 ecx, DWORD PTR _k$1$[ebp]
  00442	be 01 00 00 00	 mov	 esi, 1
  00447	2b ca		 sub	 ecx, edx

; 1255 :       for (j = i >> w; j < z; j += f)

  00449	8b c3		 mov	 eax, ebx
  0044b	d3 e6		 shl	 esi, cl
  0044d	8b ca		 mov	 ecx, edx
  0044f	d3 e8		 shr	 eax, cl
  00451	3b c7		 cmp	 eax, edi
  00453	73 3f		 jae	 SHORT $LN29@huft_build

; 1251 :       }
; 1252 : 
; 1253 :       /* fill code-like entries with r */
; 1254 :       f = 1 << (k - w);

  00455	8b 9d 58 fa ff
	ff		 mov	 ebx, DWORD PTR _r$[ebp]
  0045b	8d 0c f5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*8]
  00462	8b 95 5c fa ff
	ff		 mov	 edx, DWORD PTR _r$[ebp+4]
  00468	89 8d 40 fa ff
	ff		 mov	 DWORD PTR tv1176[ebp], ecx
  0046e	8b 8d 34 fa ff
	ff		 mov	 ecx, DWORD PTR _q$2$[ebp]
  00474	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
$LL30@huft_build:

; 1256 :         q[j] = r;

  00477	89 19		 mov	 DWORD PTR [ecx], ebx
  00479	03 c6		 add	 eax, esi
  0047b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0047e	03 8d 40 fa ff
	ff		 add	 ecx, DWORD PTR tv1176[ebp]
  00484	3b c7		 cmp	 eax, edi
  00486	72 ef		 jb	 SHORT $LL30@huft_build
  00488	8b 95 64 fa ff
	ff		 mov	 edx, DWORD PTR _w$1$[ebp]
  0048e	8b 9d 60 fa ff
	ff		 mov	 ebx, DWORD PTR _i$4$[ebp]
$LN29@huft_build:

; 1257 : 
; 1258 :       /* backwards increment the k-bit code i */
; 1259 :       for (j = 1 << (k - 1); i & j; j >>= 1)

  00494	8b 8d 6c fa ff
	ff		 mov	 ecx, DWORD PTR _k$1$[ebp]
  0049a	b8 01 00 00 00	 mov	 eax, 1
  0049f	8d 49 ff	 lea	 ecx, DWORD PTR [ecx-1]
  004a2	d3 e0		 shl	 eax, cl
  004a4	85 c3		 test	 eax, ebx
  004a6	74 08		 je	 SHORT $LN32@huft_build
$LL33@huft_build:

; 1260 :         i ^= j;

  004a8	33 d8		 xor	 ebx, eax
  004aa	d1 e8		 shr	 eax, 1
  004ac	85 c3		 test	 eax, ebx
  004ae	75 f8		 jne	 SHORT $LL33@huft_build
$LN32@huft_build:

; 1261 :       i ^= j;

  004b0	33 d8		 xor	 ebx, eax

; 1262 : 
; 1263 :       /* backup over finished tables */
; 1264 :       while ((i & ((1 << w) - 1)) != x[h])

  004b2	8b ca		 mov	 ecx, edx
  004b4	b8 01 00 00 00	 mov	 eax, 1
  004b9	89 9d 60 fa ff
	ff		 mov	 DWORD PTR _i$4$[ebp], ebx
  004bf	d3 e0		 shl	 eax, cl
  004c1	8b 8d 68 fa ff
	ff		 mov	 ecx, DWORD PTR _h$1$[ebp]
  004c7	48		 dec	 eax
  004c8	23 c3		 and	 eax, ebx
  004ca	3b 84 8d 74 ff
	ff ff		 cmp	 eax, DWORD PTR _x$[ebp+ecx*4]
  004d1	74 3c		 je	 SHORT $LN35@huft_build
  004d3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL34@huft_build:

; 1265 :         w -= l[--h];            /* don't need to update q */

  004e0	2b 94 8d 30 ff
	ff ff		 sub	 edx, DWORD PTR _lx$[ebp+ecx*4]
  004e7	49		 dec	 ecx
  004e8	89 8d 68 fa ff
	ff		 mov	 DWORD PTR _h$1$[ebp], ecx
  004ee	b8 01 00 00 00	 mov	 eax, 1
  004f3	8b ca		 mov	 ecx, edx
  004f5	d3 e0		 shl	 eax, cl
  004f7	8b 8d 68 fa ff
	ff		 mov	 ecx, DWORD PTR _h$1$[ebp]
  004fd	48		 dec	 eax
  004fe	23 c3		 and	 eax, ebx
  00500	3b 84 8d 74 ff
	ff ff		 cmp	 eax, DWORD PTR _x$[ebp+ecx*4]
  00507	75 d7		 jne	 SHORT $LL34@huft_build
  00509	89 95 64 fa ff
	ff		 mov	 DWORD PTR _w$1$[ebp], edx
$LN35@huft_build:

; 1185 :     while (a--)

  0050f	8b b5 30 fa ff
	ff		 mov	 esi, DWORD PTR _a$1$[ebp]
  00515	85 f6		 test	 esi, esi
  00517	0f 85 f3 fc ff
	ff		 jne	 $LL22@huft_build
  0051d	8b 85 6c fa ff
	ff		 mov	 eax, DWORD PTR _k$1$[ebp]
$LN92@huft_build:

; 1177 :   u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
; 1178 :   q = (struct huft *)NULL;      /* ditto */
; 1179 :   z = 0;                        /* ditto */
; 1180 : 
; 1181 :   /* go through the bit lengths (k already is bits in shortest code) */
; 1182 :   for (; k <= g; k++)

  00523	8b b5 44 fa ff
	ff		 mov	 esi, DWORD PTR tv1173[ebp]
  00529	40		 inc	 eax
  0052a	83 c6 04	 add	 esi, 4
  0052d	89 85 6c fa ff
	ff		 mov	 DWORD PTR _k$1$[ebp], eax
  00533	89 b5 44 fa ff
	ff		 mov	 DWORD PTR tv1173[ebp], esi
  00539	3b 85 54 fa ff
	ff		 cmp	 eax, DWORD PTR _g$1$[ebp]
  0053f	0f 8e bd fc ff
	ff		 jle	 $LL21@huft_build
  00545	8b b5 54 fa ff
	ff		 mov	 esi, DWORD PTR _g$1$[ebp]
$LN125@huft_build:

; 1266 :     }
; 1267 :   }
; 1268 : 
; 1269 : 
; 1270 :   /* return actual size of base table */
; 1271 :   *m = l[0];
; 1272 : 
; 1273 : 
; 1274 :   /* Return true (1) if we were given an incomplete table */
; 1275 :   return y != 0 && g != 1;

  0054b	83 bd 4c fa ff
	ff 00		 cmp	 DWORD PTR _y$1$[ebp], 0
  00552	8b 8d 50 fa ff
	ff		 mov	 ecx, DWORD PTR _m$GSCopy$1$[ebp]
  00558	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _lx$[ebp+4]
  0055e	89 01		 mov	 DWORD PTR [ecx], eax
  00560	0f 84 19 fb ff
	ff		 je	 $LN59@huft_build
  00566	83 fe 01	 cmp	 esi, 1
  00569	0f 84 10 fb ff
	ff		 je	 $LN59@huft_build
  0056f	5f		 pop	 edi
  00570	5e		 pop	 esi
  00571	b8 01 00 00 00	 mov	 eax, 1
  00576	5b		 pop	 ebx

; 1276 : }

  00577	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0057a	33 cd		 xor	 ecx, ebp
  0057c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00581	8b e5		 mov	 esp, ebp
  00583	5d		 pop	 ebp
  00584	c3		 ret	 0
$LN83@huft_build:

; 1213 :             (struct huft *)NULL)
; 1214 :         {
; 1215 :           if (h)

  00585	83 bd 68 fa ff
	ff 00		 cmp	 DWORD PTR _h$1$[ebp], 0
  0058c	74 1f		 je	 SHORT $LN63@huft_build

; 1216 :             huft_free(u[0]);

  0058e	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _u$[ebp]
  00594	85 c0		 test	 eax, eax
  00596	74 15		 je	 SHORT $LN63@huft_build
$LL62@huft_build:
  00598	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  0059b	83 e8 08	 sub	 eax, 8
  0059e	50		 push	 eax
  0059f	e8 00 00 00 00	 call	 _free
  005a4	83 c4 04	 add	 esp, 4
  005a7	8b c6		 mov	 eax, esi
  005a9	85 f6		 test	 esi, esi
  005ab	75 eb		 jne	 SHORT $LL62@huft_build
$LN63@huft_build:

; 1276 : }

  005ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b0	b8 03 00 00 00	 mov	 eax, 3
  005b5	5f		 pop	 edi
  005b6	5e		 pop	 esi
  005b7	33 cd		 xor	 ecx, ebp
  005b9	5b		 pop	 ebx
  005ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005bf	8b e5		 mov	 esp, ebp
  005c1	5d		 pop	 ebp
  005c2	c3		 ret	 0
_huft_build ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\inflate.c
;	COMDAT _huft_free
_TEXT	SEGMENT
_t$ = 8							; size = 4
_huft_free PROC						; COMDAT

; 1285 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 :   register struct huft *p, *q;
; 1287 : 
; 1288 : 
; 1289 :   /* Go through linked list, freeing from the malloced (t[-1]) address. */
; 1290 :   p = t;

  00003	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 1291 :   while (p != (struct huft *)NULL)

  00006	85 c0		 test	 eax, eax
  00008	74 1c		 je	 SHORT $LN9@huft_free
  0000a	56		 push	 esi
  0000b	0f 1f 44 00 00	 npad	 5
$LL2@huft_free:

; 1292 :   {
; 1293 :     q = (--p)->v.t;

  00010	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  00013	83 e8 08	 sub	 eax, 8

; 1294 :     free((zvoid *)p);

  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _free
  0001c	83 c4 04	 add	 esp, 4

; 1295 :     p = q;

  0001f	8b c6		 mov	 eax, esi
  00021	85 f6		 test	 esi, esi
  00023	75 eb		 jne	 SHORT $LL2@huft_free
  00025	5e		 pop	 esi
$LN9@huft_free:

; 1296 :   }
; 1297 :   return 0;

  00026	33 c0		 xor	 eax, eax

; 1298 : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_huft_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);
; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 836  :     __crt_va_end(_ArgList);
; 837  :     return _Result;
; 838  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 640  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
