; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Desktop\Sources_GostCrypt_Windows_1.3.1_COMMENTED\Sources_GostCrypt_Windows_1.3.1é\Sources_GostCrypt_Windows_1.3.1\Common\Xml.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_XmlNextNode
PUBLIC	_XmlFindElement
PUBLIC	_XmlGetAttributeText
PUBLIC	_XmlGetNodeText
PUBLIC	_XmlWriteHeader
PUBLIC	_XmlWriteHeaderW
PUBLIC	_XmlWriteFooter
PUBLIC	_XmlWriteFooterW
PUBLIC	_XmlFindElementByAttributeValue
PUBLIC	_XmlQuoteText
PUBLIC	??_C@_02ILLPBGAO@?$DN?$CC?$AA@			; `string'
PUBLIC	??_C@_03EDAFAAFP@?$DN?5?$CC?$AA@		; `string'
PUBLIC	??_C@_03PFIILPDO@?5?$DN?$CC?$AA@		; `string'
PUBLIC	??_C@_04GFKCAHFK@?5?$DN?5?$CC?$AA@		; `string'
PUBLIC	??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@		; `string'
PUBLIC	??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@		; `string'
PUBLIC	??_C@_05JKJFEODM@?$CGamp?$DL?$AA@		; `string'
PUBLIC	??_C@_0DD@PDCHELPA@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCut@ ; `string'
PUBLIC	??_C@_1GG@JPJAHMPP@?$AA?$DM?$AA?$DP?$AAx?$AAm?$AAl?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?4?$AA0?$AA?$CC?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$DN?$AA?$CC?$AAu?$AAt@ ; `string'
PUBLIC	??_C@_0O@ILHHEFOI@?6?$DM?1GostCrypt?$DO?$AA@	; `string'
PUBLIC	??_C@_1BM@DBOFCGBF@?$AA?6?$AA?$DM?$AA?1?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$DO?$AA?$AA@ ; `string'
EXTRN	_strchr:PROC
EXTRN	_strstr:PROC
EXTRN	_fputws:PROC
EXTRN	_fputs:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_1BM@DBOFCGBF@?$AA?6?$AA?$DM?$AA?1?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$DO?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@DBOFCGBF@?$AA?6?$AA?$DM?$AA?1?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$DO?$AA?$AA@ DB 0aH
	DB	00H, '<', 00H, '/', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H
	DB	'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H, 't', 00H, '>', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ILHHEFOI@?6?$DM?1GostCrypt?$DO?$AA@
CONST	SEGMENT
??_C@_0O@ILHHEFOI@?6?$DM?1GostCrypt?$DO?$AA@ DB 0aH, '</GostCrypt>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@JPJAHMPP@?$AA?$DM?$AA?$DP?$AAx?$AAm?$AAl?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?4?$AA0?$AA?$CC?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$DN?$AA?$CC?$AAu?$AAt@
CONST	SEGMENT
??_C@_1GG@JPJAHMPP@?$AA?$DM?$AA?$DP?$AAx?$AAm?$AAl?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?4?$AA0?$AA?$CC?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$DN?$AA?$CC?$AAu?$AAt@ DB '<'
	DB	00H, '?', 00H, 'x', 00H, 'm', 00H, 'l', 00H, ' ', 00H, 'v', 00H
	DB	'e', 00H, 'r', 00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '='
	DB	00H, '"', 00H, '1', 00H, '.', 00H, '0', 00H, '"', 00H, ' ', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, '=', 00H, '"', 00H, 'u', 00H, 't', 00H, 'f', 00H
	DB	'-', 00H, '8', 00H, '"', 00H, '?', 00H, '>', 00H, 0aH, 00H, '<'
	DB	00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r', 00H
	DB	'y', 00H, 'p', 00H, 't', 00H, '>', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@PDCHELPA@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCut@
CONST	SEGMENT
??_C@_0DD@PDCHELPA@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCut@ DB '<'
	DB	'?xml version="1.0" encoding="utf-8"?>', 0aH, '<GostCrypt>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@
CONST	SEGMENT
??_C@_05JKJFEODM@?$CGamp?$DL?$AA@ DB '&amp;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
CONST	SEGMENT
??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@ DB '&gt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@
CONST	SEGMENT
??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@ DB '&lt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GFKCAHFK@?5?$DN?5?$CC?$AA@
CONST	SEGMENT
??_C@_04GFKCAHFK@?5?$DN?5?$CC?$AA@ DB ' = "', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFIILPDO@?5?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_03PFIILPDO@?5?$DN?$CC?$AA@ DB ' ="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EDAFAAFP@?$DN?5?$CC?$AA@
CONST	SEGMENT
??_C@_03EDAFAAFP@?$DN?5?$CC?$AA@ DB '= "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_02ILLPBGAO@?$DN?$CC?$AA@ DB '="', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _BeginsWith
_TEXT	SEGMENT
_string$ = 8						; size = 4
_subString$ = 12					; size = 4
_BeginsWith PROC					; COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	while (*string++ == *subString++)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _subString$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _string$[ebp]
  0000a	8a 06		 mov	 al, BYTE PTR [esi]
  0000c	3a 01		 cmp	 al, BYTE PTR [ecx]
  0000e	75 17		 jne	 SHORT $LN10@BeginsWith
  00010	2b f1		 sub	 esi, ecx
$LL2@BeginsWith:

; 35   : 	{
; 36   : 		if (*subString == 0) return TRUE;

  00012	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00015	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00018	84 c0		 test	 al, al
  0001a	74 10		 je	 SHORT $LN8@BeginsWith

; 37   : 		if (*string == 0) return FALSE;

  0001c	8a 14 0e	 mov	 dl, BYTE PTR [esi+ecx]
  0001f	84 d2		 test	 dl, dl
  00021	74 04		 je	 SHORT $LN10@BeginsWith

; 34   : 	while (*string++ == *subString++)

  00023	3a d0		 cmp	 dl, al
  00025	74 eb		 je	 SHORT $LL2@BeginsWith
$LN10@BeginsWith:

; 38   : 	}
; 39   : 
; 40   : 	return FALSE;

  00027	33 c0		 xor	 eax, eax
  00029	5e		 pop	 esi

; 41   : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN8@BeginsWith:

; 35   : 	{
; 36   : 		if (*subString == 0) return TRUE;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	5e		 pop	 esi

; 41   : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_BeginsWith ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _XmlQuoteText
_TEXT	SEGMENT
_textSrc$ = 8						; size = 4
_textDst$ = 12						; size = 4
_textDstMaxSize$ = 16					; size = 4
_XmlQuoteText PROC					; COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 243  : 	char *textDstLast = textDst + textDstMaxSize - 1;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _textDstMaxSize$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _textDst$[ebp]
  00009	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  0000c	03 d0		 add	 edx, eax

; 244  : 
; 245  : 	if (textDstMaxSize == 0)

  0000e	85 c9		 test	 ecx, ecx
  00010	75 04		 jne	 SHORT $LN19@XmlQuoteTe

; 246  : 		return NULL;

  00012	33 c0		 xor	 eax, eax

; 283  : 	return textDst;
; 284  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN19@XmlQuoteTe:
  00016	53		 push	 ebx
  00017	56		 push	 esi

; 247  : 
; 248  : 	while (*textSrc != 0 && textDst <= textDstLast) 

  00018	8b 75 08	 mov	 esi, DWORD PTR _textSrc$[ebp]
  0001b	8a 1e		 mov	 bl, BYTE PTR [esi]
  0001d	84 db		 test	 bl, bl
  0001f	0f 84 8d 00 00
	00		 je	 $LN3@XmlQuoteTe
$LL2@XmlQuoteTe:
  00025	3b c2		 cmp	 eax, edx
  00027	0f 87 89 00 00
	00		 ja	 $LN26@XmlQuoteTe

; 249  : 	{
; 250  : 		char c = *textSrc++;
; 251  : 		switch (c)

  0002d	0f be cb	 movsx	 ecx, bl
  00030	46		 inc	 esi
  00031	83 e9 26	 sub	 ecx, 38			; 00000026H
  00034	74 51		 je	 SHORT $LN7@XmlQuoteTe
  00036	83 e9 16	 sub	 ecx, 22			; 00000016H
  00039	74 2d		 je	 SHORT $LN11@XmlQuoteTe
  0003b	83 e9 02	 sub	 ecx, 2
  0003e	74 09		 je	 SHORT $LN9@XmlQuoteTe

; 273  : 
; 274  : 		default:
; 275  : 			*textDst++ = c;

  00040	88 18		 mov	 BYTE PTR [eax], bl
  00042	b9 01 00 00 00	 mov	 ecx, 1

; 276  : 		}
; 277  : 	}

  00047	eb 5d		 jmp	 SHORT $LN23@XmlQuoteTe
$LN9@XmlQuoteTe:

; 258  : 			continue;
; 259  : 
; 260  : 		case '>':
; 261  : 			if (textDst + 5 > textDstLast)

  00049	8d 48 05	 lea	 ecx, DWORD PTR [eax+5]
  0004c	3b ca		 cmp	 ecx, edx
  0004e	77 66		 ja	 SHORT $LN26@XmlQuoteTe

; 262  : 				return NULL;
; 263  : 			strcpy (textDst, "&gt;");

  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
  00056	89 08		 mov	 DWORD PTR [eax], ecx
  00058	8a 0d 04 00 00
	00		 mov	 cl, BYTE PTR ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@+4
  0005e	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 264  : 			textDst += 4;

  00061	b9 04 00 00 00	 mov	 ecx, 4

; 265  : 			continue;

  00066	eb 3e		 jmp	 SHORT $LN23@XmlQuoteTe
$LN11@XmlQuoteTe:

; 266  : 
; 267  : 		case '<':
; 268  : 			if (textDst + 5 > textDstLast)

  00068	8d 48 05	 lea	 ecx, DWORD PTR [eax+5]
  0006b	3b ca		 cmp	 ecx, edx
  0006d	77 47		 ja	 SHORT $LN26@XmlQuoteTe

; 269  : 				return NULL;
; 270  : 			strcpy (textDst, "&lt;");

  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@
  00075	89 08		 mov	 DWORD PTR [eax], ecx
  00077	8a 0d 04 00 00
	00		 mov	 cl, BYTE PTR ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@+4
  0007d	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 271  : 			textDst += 4;

  00080	b9 04 00 00 00	 mov	 ecx, 4

; 272  : 			continue;

  00085	eb 1f		 jmp	 SHORT $LN23@XmlQuoteTe
$LN7@XmlQuoteTe:

; 252  : 		{
; 253  : 		case '&':
; 254  : 			if (textDst + 6 > textDstLast)

  00087	8d 48 06	 lea	 ecx, DWORD PTR [eax+6]
  0008a	3b ca		 cmp	 ecx, edx
  0008c	77 28		 ja	 SHORT $LN26@XmlQuoteTe

; 255  : 				return NULL;
; 256  : 			strcpy (textDst, "&amp;");

  0008e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@
  00094	89 08		 mov	 DWORD PTR [eax], ecx
  00096	66 8b 0d 04 00
	00 00		 mov	 cx, WORD PTR ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@+4
  0009d	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 257  : 			textDst += 5;

  000a1	b9 05 00 00 00	 mov	 ecx, 5
$LN23@XmlQuoteTe:

; 247  : 
; 248  : 	while (*textSrc != 0 && textDst <= textDstLast) 

  000a6	8a 1e		 mov	 bl, BYTE PTR [esi]
  000a8	03 c1		 add	 eax, ecx
  000aa	84 db		 test	 bl, bl
  000ac	0f 85 73 ff ff
	ff		 jne	 $LL2@XmlQuoteTe
$LN3@XmlQuoteTe:

; 278  : 
; 279  : 	if (textDst > textDstLast)

  000b2	3b c2		 cmp	 eax, edx
  000b4	76 06		 jbe	 SHORT $LN14@XmlQuoteTe
$LN26@XmlQuoteTe:
  000b6	5e		 pop	 esi

; 280  : 		return NULL;

  000b7	33 c0		 xor	 eax, eax
  000b9	5b		 pop	 ebx

; 283  : 	return textDst;
; 284  : }

  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
$LN14@XmlQuoteTe:
  000bc	5e		 pop	 esi

; 281  : 
; 282  : 	*textDst = 0;

  000bd	c6 00 00	 mov	 BYTE PTR [eax], 0
  000c0	5b		 pop	 ebx

; 283  : 	return textDst;
; 284  : }

  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_XmlQuoteText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _XmlFindElementByAttributeValue
_TEXT	SEGMENT
_attrName$GSCopy$1$ = -2056				; size = 4
_attr$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_xml$ = 8						; size = 4
_nodeName$ = 12						; size = 4
_attrName$ = 16						; size = 4
_attrValue$ = 20					; size = 4
_XmlFindElementByAttributeValue PROC			; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 08 00
	00		 sub	 esp, 2056		; 00000808H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _xml$[ebp]
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _attrName$[ebp]
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	8b 7d 0c	 mov	 edi, DWORD PTR _nodeName$[ebp]

; 106  : 	char attr[2048];
; 107  : 
; 108  : 	while (xml = XmlFindElement (xml, nodeName))

  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	89 8d f8 f7 ff
	ff		 mov	 DWORD PTR _attrName$GSCopy$1$[ebp], ecx
  00027	e8 00 00 00 00	 call	 _XmlFindElement
  0002c	8b f0		 mov	 esi, eax
  0002e	83 c4 08	 add	 esp, 8
  00031	85 f6		 test	 esi, esi
  00033	74 6a		 je	 SHORT $LN3@XmlFindEle
  00035	8b 5d 14	 mov	 ebx, DWORD PTR _attrValue$[ebp]
  00038	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@XmlFindEle:

; 109  : 	{
; 110  : 		XmlGetAttributeText (xml, attrName, attr, sizeof (attr));

  00040	68 00 08 00 00	 push	 2048			; 00000800H
  00045	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  0004b	50		 push	 eax
  0004c	ff b5 f8 f7 ff
	ff		 push	 DWORD PTR _attrName$GSCopy$1$[ebp]
  00052	56		 push	 esi
  00053	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00058	83 c4 10	 add	 esp, 16			; 00000010H

; 111  : 		if (strcmp (attr, attrValue) == 0)

  0005b	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _attr$[ebp]
  00061	8b c3		 mov	 eax, ebx
$LL11@XmlFindEle:
  00063	8a 11		 mov	 dl, BYTE PTR [ecx]
  00065	3a 10		 cmp	 dl, BYTE PTR [eax]
  00067	75 1a		 jne	 SHORT $LN12@XmlFindEle
  00069	84 d2		 test	 dl, dl
  0006b	74 12		 je	 SHORT $LN13@XmlFindEle
  0006d	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00070	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00073	75 0e		 jne	 SHORT $LN12@XmlFindEle
  00075	83 c1 02	 add	 ecx, 2
  00078	83 c0 02	 add	 eax, 2
  0007b	84 d2		 test	 dl, dl
  0007d	75 e4		 jne	 SHORT $LL11@XmlFindEle
$LN13@XmlFindEle:
  0007f	33 c0		 xor	 eax, eax
  00081	eb 05		 jmp	 SHORT $LN14@XmlFindEle
$LN12@XmlFindEle:
  00083	1b c0		 sbb	 eax, eax
  00085	83 c8 01	 or	 eax, 1
$LN14@XmlFindEle:
  00088	85 c0		 test	 eax, eax
  0008a	74 26		 je	 SHORT $LN7@XmlFindEle

; 112  : 			return xml;
; 113  : 
; 114  : 		xml++;

  0008c	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0008f	57		 push	 edi
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _XmlFindElement
  00096	8b f0		 mov	 esi, eax
  00098	83 c4 08	 add	 esp, 8
  0009b	85 f6		 test	 esi, esi
  0009d	75 a1		 jne	 SHORT $LL2@XmlFindEle
$LN3@XmlFindEle:
  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi

; 115  : 	}
; 116  : 
; 117  : 	return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	5b		 pop	 ebx

; 118  : }

  000a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a7	33 cd		 xor	 ecx, ebp
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
$LN7@XmlFindEle:
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	8b c6		 mov	 eax, esi
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	33 cd		 xor	 ecx, ebp
  000bb	5b		 pop	 ebx
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
_XmlFindElementByAttributeValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _XmlWriteFooterW
_TEXT	SEGMENT
_file$ = 8						; size = 4
_XmlWriteFooterW PROC					; COMDAT

; 338  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 339  : 	return fputws (L"\n</GostCrypt>", file);

  00003	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@DBOFCGBF@?$AA?6?$AA?$DM?$AA?1?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$DO?$AA?$AA@
  0000b	e8 00 00 00 00	 call	 _fputws
  00010	83 c4 08	 add	 esp, 8

; 340  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_XmlWriteFooterW ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _XmlWriteFooter
_TEXT	SEGMENT
_file$ = 8						; size = 4
_XmlWriteFooter PROC					; COMDAT

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 325  : 	return fputs ("\n</GostCrypt>", file);

  00003	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0O@ILHHEFOI@?6?$DM?1GostCrypt?$DO?$AA@
  0000b	e8 00 00 00 00	 call	 _fputs
  00010	83 c4 08	 add	 esp, 8

; 326  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_XmlWriteFooter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _XmlWriteHeaderW
_TEXT	SEGMENT
_file$ = 8						; size = 4
_XmlWriteHeaderW PROC					; COMDAT

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 	return fputws (L"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<GostCrypt>", file);

  00003	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_1GG@JPJAHMPP@?$AA?$DM?$AA?$DP?$AAx?$AAm?$AAl?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?4?$AA0?$AA?$CC?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$DN?$AA?$CC?$AAu?$AAt@
  0000b	e8 00 00 00 00	 call	 _fputws
  00010	83 c4 08	 add	 esp, 8

; 312  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_XmlWriteHeaderW ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _XmlWriteHeader
_TEXT	SEGMENT
_file$ = 8						; size = 4
_XmlWriteHeader PROC					; COMDAT

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 297  : 	return fputs ("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<GostCrypt>", file);

  00003	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@PDCHELPA@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCut@
  0000b	e8 00 00 00 00	 call	 _fputs
  00010	83 c4 08	 add	 esp, 8

; 298  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_XmlWriteHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _XmlGetNodeText
_TEXT	SEGMENT
_i$1$ = -4						; size = 4
_l$1$ = 8						; size = 4
_xmlNode$ = 8						; size = 4
_t$1$ = 12						; size = 4
_xmlText$ = 12						; size = 4
_xmlTextSize$ = 16					; size = 4
_XmlGetNodeText PROC					; COMDAT

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 187  : 	int l = 0, i = 0, j = 0;
; 188  : 
; 189  : 	xmlText[0] = 0;
; 190  : 
; 191  : 	if (t[0] != '<')

  00004	8b 45 08	 mov	 eax, DWORD PTR _xmlNode$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 0c	 mov	 ebx, DWORD PTR _xmlText$[ebp]
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	33 ff		 xor	 edi, edi
  0000f	33 f6		 xor	 esi, esi
  00011	c6 03 00	 mov	 BYTE PTR [ebx], 0
  00014	80 38 3c	 cmp	 BYTE PTR [eax], 60	; 0000003cH
  00017	89 7d fc	 mov	 DWORD PTR _i$1$[ebp], edi
  0001a	0f 85 c5 00 00
	00		 jne	 $LN8@XmlGetNode

; 192  : 		return NULL;
; 193  : 
; 194  : 	t = strchr (t, '>') + 1;

  00020	6a 3e		 push	 62			; 0000003eH
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _strchr
  00028	40		 inc	 eax
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 0c	 mov	 DWORD PTR _t$1$[ebp], eax

; 195  : 	if (t == (char *)1) return NULL;

  0002f	83 f8 01	 cmp	 eax, 1
  00032	0f 84 ad 00 00
	00		 je	 $LN8@XmlGetNode

; 185  : 	char *t = xmlNode;
; 186  : 	char *e = xmlNode + 1;

  00038	8b 45 08	 mov	 eax, DWORD PTR _xmlNode$[ebp]
  0003b	40		 inc	 eax

; 196  : 
; 197  : 	e = strchr (e, '<');

  0003c	6a 3c		 push	 60			; 0000003cH
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _strchr
  00044	8b c8		 mov	 ecx, eax
  00046	83 c4 08	 add	 esp, 8

; 198  : 	if (e == NULL) return NULL;

  00049	85 c9		 test	 ecx, ecx
  0004b	0f 84 94 00 00
	00		 je	 $LN8@XmlGetNode

; 199  : 
; 200  : 	l = (int)(e - t);

  00051	8b 45 0c	 mov	 eax, DWORD PTR _t$1$[ebp]
  00054	2b c8		 sub	 ecx, eax
  00056	89 4d 08	 mov	 DWORD PTR _l$1$[ebp], ecx

; 201  : 	if (e == NULL || l > xmlTextSize) return NULL;

  00059	3b 4d 10	 cmp	 ecx, DWORD PTR _xmlTextSize$[ebp]
  0005c	0f 8f 83 00 00
	00		 jg	 $LN8@XmlGetNode

; 202  : 
; 203  : 	while (i < l)

  00062	85 c9		 test	 ecx, ecx
  00064	7e 74		 jle	 SHORT $LN3@XmlGetNode
$LL2@XmlGetNode:

; 204  : 	{
; 205  : 		if (BeginsWith (&t[i], "&lt;"))

  00066	03 f8		 add	 edi, eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@
  0006d	57		 push	 edi
  0006e	e8 00 00 00 00	 call	 _BeginsWith
  00073	83 c4 08	 add	 esp, 8
  00076	85 c0		 test	 eax, eax
  00078	74 0b		 je	 SHORT $LN9@XmlGetNode

; 206  : 		{
; 207  : 			xmlText[j++] = '<';

  0007a	c6 04 1e 3c	 mov	 BYTE PTR [esi+ebx], 60	; 0000003cH

; 208  : 			i += 4;

  0007e	b8 04 00 00 00	 mov	 eax, 4

; 209  : 			continue;

  00083	eb 44		 jmp	 SHORT $LN17@XmlGetNode
$LN9@XmlGetNode:

; 210  : 		}
; 211  : 		if (BeginsWith (&t[i], "&gt;"))

  00085	68 00 00 00 00	 push	 OFFSET ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
  0008a	57		 push	 edi
  0008b	e8 00 00 00 00	 call	 _BeginsWith
  00090	83 c4 08	 add	 esp, 8
  00093	85 c0		 test	 eax, eax
  00095	74 0b		 je	 SHORT $LN10@XmlGetNode

; 212  : 		{
; 213  : 			xmlText[j++] = '>';

  00097	c6 04 1e 3e	 mov	 BYTE PTR [esi+ebx], 62	; 0000003eH

; 214  : 			i += 4;

  0009b	b8 04 00 00 00	 mov	 eax, 4

; 215  : 			continue;

  000a0	eb 27		 jmp	 SHORT $LN17@XmlGetNode
$LN10@XmlGetNode:

; 216  : 		}
; 217  : 		if (BeginsWith (&t[i], "&amp;"))

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@
  000a7	57		 push	 edi
  000a8	e8 00 00 00 00	 call	 _BeginsWith
  000ad	83 c4 08	 add	 esp, 8
  000b0	85 c0		 test	 eax, eax
  000b2	74 0b		 je	 SHORT $LN11@XmlGetNode

; 218  : 		{
; 219  : 			xmlText[j++] = '&';

  000b4	c6 04 1e 26	 mov	 BYTE PTR [esi+ebx], 38	; 00000026H

; 220  : 			i += 5;

  000b8	b8 05 00 00 00	 mov	 eax, 5

; 221  : 			continue;

  000bd	eb 0a		 jmp	 SHORT $LN17@XmlGetNode
$LN11@XmlGetNode:

; 222  : 		}
; 223  : 		xmlText[j++] = t[i++];

  000bf	8a 07		 mov	 al, BYTE PTR [edi]
  000c1	88 04 1e	 mov	 BYTE PTR [esi+ebx], al
  000c4	b8 01 00 00 00	 mov	 eax, 1
$LN17@XmlGetNode:

; 202  : 
; 203  : 	while (i < l)

  000c9	8b 7d fc	 mov	 edi, DWORD PTR _i$1$[ebp]
  000cc	46		 inc	 esi
  000cd	03 f8		 add	 edi, eax
  000cf	8b 45 0c	 mov	 eax, DWORD PTR _t$1$[ebp]
  000d2	89 7d fc	 mov	 DWORD PTR _i$1$[ebp], edi
  000d5	3b 7d 08	 cmp	 edi, DWORD PTR _l$1$[ebp]
  000d8	7c 8c		 jl	 SHORT $LL2@XmlGetNode
$LN3@XmlGetNode:
  000da	5f		 pop	 edi

; 224  : 	}
; 225  : 	xmlText[j] = 0;

  000db	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx

; 226  : 
; 227  : 	return t;
; 228  : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
$LN8@XmlGetNode:
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi

; 201  : 	if (e == NULL || l > xmlTextSize) return NULL;

  000e7	33 c0		 xor	 eax, eax
  000e9	5b		 pop	 ebx

; 226  : 
; 227  : 	return t;
; 228  : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
_XmlGetNodeText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _XmlGetAttributeText
_TEXT	SEGMENT
_e$1$ = -4						; size = 4
_t$1$ = 8						; size = 4
_xmlNode$ = 8						; size = 4
_xmlAttrName$ = 12					; size = 4
_xmlAttrValue$ = 16					; size = 4
_xmlAttrValueSize$ = 20					; size = 4
_XmlGetAttributeText PROC				; COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 134  : 	char *t = xmlNode;
; 135  : 	char *e = xmlNode;
; 136  : 	int l = 0;
; 137  : 
; 138  : 	xmlAttrValue[0] = 0;

  00004	8b 45 10	 mov	 eax, DWORD PTR _xmlAttrValue$[ebp]
  00007	56		 push	 esi

; 139  : 	if (t[0] != '<') return NULL;

  00008	8b 75 08	 mov	 esi, DWORD PTR _xmlNode$[ebp]
  0000b	c6 00 00	 mov	 BYTE PTR [eax], 0
  0000e	80 3e 3c	 cmp	 BYTE PTR [esi], 60	; 0000003cH
  00011	74 07		 je	 SHORT $LN4@XmlGetAttr
  00013	33 c0		 xor	 eax, eax
  00015	5e		 pop	 esi

; 170  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN4@XmlGetAttr:
  0001a	53		 push	 ebx

; 140  : 
; 141  : 	e = strchr (e, '>');

  0001b	6a 3e		 push	 62			; 0000003eH
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 _strchr
  00023	8b d8		 mov	 ebx, eax
  00025	83 c4 08	 add	 esp, 8
  00028	89 5d fc	 mov	 DWORD PTR _e$1$[ebp], ebx

; 142  : 	if (e == NULL) return NULL;

  0002b	85 db		 test	 ebx, ebx
  0002d	75 06		 jne	 SHORT $LN37@XmlGetAttr
  0002f	5b		 pop	 ebx
  00030	5e		 pop	 esi

; 170  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN37@XmlGetAttr:
  00035	57		 push	 edi

; 143  : 
; 144  : 	while ((t = strstr (t, xmlAttrName)) && t < e)

  00036	ff 75 0c	 push	 DWORD PTR _xmlAttrName$[ebp]
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 _strstr
  0003f	8b f8		 mov	 edi, eax
  00041	83 c4 08	 add	 esp, 8
  00044	89 7d 08	 mov	 DWORD PTR _t$1$[ebp], edi
  00047	85 ff		 test	 edi, edi
  00049	0f 84 de 00 00
	00		 je	 $LN9@XmlGetAttr
  0004f	90		 npad	 1
$LL2@XmlGetAttr:
  00050	3b fb		 cmp	 edi, ebx
  00052	0f 83 e4 00 00
	00		 jae	 $LN7@XmlGetAttr

; 145  : 	{
; 146  : 		char *o = t + strlen (xmlAttrName);

  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _xmlAttrName$[ebp]
  0005b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0005e	66 90		 npad	 2
$LL69@XmlGetAttr:
  00060	8a 01		 mov	 al, BYTE PTR [ecx]
  00062	41		 inc	 ecx
  00063	84 c0		 test	 al, al
  00065	75 f9		 jne	 SHORT $LL69@XmlGetAttr

; 147  : 		if (t[-1] == ' '
; 148  : 			&&

  00067	8b 45 08	 mov	 eax, DWORD PTR _t$1$[ebp]
  0006a	2b ca		 sub	 ecx, edx
  0006c	03 f9		 add	 edi, ecx
  0006e	80 78 ff 20	 cmp	 BYTE PTR [eax-1], 32	; 00000020H
  00072	0f 85 98 00 00
	00		 jne	 $LN49@XmlGetAttr
  00078	8a 1f		 mov	 bl, BYTE PTR [edi]
  0007a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
  0007f	80 fb 3d	 cmp	 bl, 61			; 0000003dH
  00082	75 1d		 jne	 SHORT $LN43@XmlGetAttr
  00084	8b f7		 mov	 esi, edi
  00086	2b f0		 sub	 esi, eax
$LL14@XmlGetAttr:
  00088	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0008b	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  0008e	84 c9		 test	 cl, cl
  00090	0f 84 a0 00 00
	00		 je	 $LN73@XmlGetAttr
  00096	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  00099	84 d2		 test	 dl, dl
  0009b	74 04		 je	 SHORT $LN43@XmlGetAttr
  0009d	3a d1		 cmp	 dl, cl
  0009f	74 e7		 je	 SHORT $LL14@XmlGetAttr
$LN43@XmlGetAttr:
  000a1	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03EDAFAAFP@?$DN?5?$CC?$AA@
  000a6	80 fb 3d	 cmp	 bl, 61			; 0000003dH
  000a9	75 1e		 jne	 SHORT $LN45@XmlGetAttr
  000ab	8b f7		 mov	 esi, edi
  000ad	2b f0		 sub	 esi, eax
  000af	90		 npad	 1
$LL20@XmlGetAttr:
  000b0	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000b3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000b6	84 c9		 test	 cl, cl
  000b8	0f 84 78 00 00
	00		 je	 $LN73@XmlGetAttr
  000be	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  000c1	84 d2		 test	 dl, dl
  000c3	74 04		 je	 SHORT $LN45@XmlGetAttr
  000c5	3a d1		 cmp	 dl, cl
  000c7	74 e7		 je	 SHORT $LL20@XmlGetAttr
$LN45@XmlGetAttr:
  000c9	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03PFIILPDO@?5?$DN?$CC?$AA@
  000ce	80 fb 20	 cmp	 bl, 32			; 00000020H
  000d1	75 19		 jne	 SHORT $LN47@XmlGetAttr
  000d3	8b f7		 mov	 esi, edi
  000d5	2b f0		 sub	 esi, eax
$LL26@XmlGetAttr:
  000d7	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000da	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000dd	84 c9		 test	 cl, cl
  000df	74 55		 je	 SHORT $LN73@XmlGetAttr
  000e1	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  000e4	84 d2		 test	 dl, dl
  000e6	74 04		 je	 SHORT $LN47@XmlGetAttr
  000e8	3a d1		 cmp	 dl, cl
  000ea	74 eb		 je	 SHORT $LL26@XmlGetAttr
$LN47@XmlGetAttr:
  000ec	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04GFKCAHFK@?5?$DN?5?$CC?$AA@
  000f1	80 fb 20	 cmp	 bl, 32			; 00000020H
  000f4	75 17		 jne	 SHORT $LN75@XmlGetAttr
  000f6	2b f8		 sub	 edi, eax
$LL32@XmlGetAttr:
  000f8	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000fb	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000fe	84 c9		 test	 cl, cl
  00100	74 34		 je	 SHORT $LN73@XmlGetAttr
  00102	8a 14 07	 mov	 dl, BYTE PTR [edi+eax]
  00105	84 d2		 test	 dl, dl
  00107	74 04		 je	 SHORT $LN75@XmlGetAttr
  00109	3a d1		 cmp	 dl, cl
  0010b	74 eb		 je	 SHORT $LL32@XmlGetAttr
$LN75@XmlGetAttr:
  0010d	8b 5d fc	 mov	 ebx, DWORD PTR _e$1$[ebp]
$LN49@XmlGetAttr:

; 149  : 			(BeginsWith (o, "=\"")
; 150  : 			|| BeginsWith (o, "= \"")
; 151  : 			|| BeginsWith (o, " =\"")
; 152  : 			|| BeginsWith (o, " = \""))
; 153  : 			)
; 154  : 			break;
; 155  : 
; 156  : 		t++;

  00110	8b 45 08	 mov	 eax, DWORD PTR _t$1$[ebp]
  00113	ff 75 0c	 push	 DWORD PTR _xmlAttrName$[ebp]
  00116	40		 inc	 eax
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _strstr
  0011d	8b f8		 mov	 edi, eax
  0011f	89 45 08	 mov	 DWORD PTR _t$1$[ebp], eax
  00122	83 c4 08	 add	 esp, 8
  00125	85 ff		 test	 edi, edi
  00127	0f 85 23 ff ff
	ff		 jne	 $LL2@XmlGetAttr
$LN9@XmlGetAttr:
  0012d	5f		 pop	 edi
  0012e	5b		 pop	 ebx

; 157  : 	}
; 158  : 
; 159  : 	if (t == NULL || t > e) return NULL;

  0012f	33 c0		 xor	 eax, eax
  00131	5e		 pop	 esi

; 170  : }

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
$LN73@XmlGetAttr:
  00136	8b 5d fc	 mov	 ebx, DWORD PTR _e$1$[ebp]
  00139	8b 7d 08	 mov	 edi, DWORD PTR _t$1$[ebp]
$LN7@XmlGetAttr:

; 157  : 	}
; 158  : 
; 159  : 	if (t == NULL || t > e) return NULL;

  0013c	85 ff		 test	 edi, edi
  0013e	74 ed		 je	 SHORT $LN9@XmlGetAttr
  00140	3b fb		 cmp	 edi, ebx
  00142	77 e9		 ja	 SHORT $LN9@XmlGetAttr

; 160  : 
; 161  : 	t = strchr (t, '"') + 1;

  00144	6a 22		 push	 34			; 00000022H
  00146	57		 push	 edi
  00147	e8 00 00 00 00	 call	 _strchr

; 162  : 	e = strchr (t, '"');

  0014c	6a 22		 push	 34			; 00000022H
  0014e	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  00151	57		 push	 edi
  00152	e8 00 00 00 00	 call	 _strchr

; 163  : 	l = (int)(e - t);

  00157	8b f0		 mov	 esi, eax
  00159	83 c4 10	 add	 esp, 16			; 00000010H
  0015c	2b f7		 sub	 esi, edi

; 164  : 	if (e == NULL || l > xmlAttrValueSize) return NULL;

  0015e	85 c0		 test	 eax, eax
  00160	74 cb		 je	 SHORT $LN9@XmlGetAttr
  00162	3b 75 14	 cmp	 esi, DWORD PTR _xmlAttrValueSize$[ebp]
  00165	7f c6		 jg	 SHORT $LN9@XmlGetAttr

; 165  : 
; 166  : 	memcpy (xmlAttrValue, t, l);

  00167	8b 5d 10	 mov	 ebx, DWORD PTR _xmlAttrValue$[ebp]
  0016a	56		 push	 esi
  0016b	57		 push	 edi
  0016c	53		 push	 ebx
  0016d	e8 00 00 00 00	 call	 _memcpy
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : 	xmlAttrValue[l] = 0;

  00175	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 168  : 
; 169  : 	return xmlAttrValue;

  00179	8b c3		 mov	 eax, ebx
  0017b	5f		 pop	 edi
  0017c	5b		 pop	 ebx
  0017d	5e		 pop	 esi

; 170  : }

  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
_XmlGetAttributeText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _XmlFindElement
_TEXT	SEGMENT
_nameLen$1$ = 8						; size = 4
_xmlNode$ = 8						; size = 4
_nodeName$ = 12						; size = 4
_XmlFindElement PROC					; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   : 	char *t = xmlNode;

  00003	8b 45 08	 mov	 eax, DWORD PTR _xmlNode$[ebp]
  00006	53		 push	 ebx

; 79   : 	size_t nameLen = strlen (nodeName);

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _nodeName$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  0000f	90		 npad	 1
$LL36@XmlFindEle:
  00010	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00012	43		 inc	 ebx
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL36@XmlFindEle
  00017	2b da		 sub	 ebx, edx
  00019	89 5d 08	 mov	 DWORD PTR _nameLen$1$[ebp], ebx
  0001c	8b 5d 0c	 mov	 ebx, DWORD PTR _nodeName$[ebp]
  0001f	90		 npad	 1
$LL4@XmlFindEle:

; 80   : 
; 81   : 	do
; 82   : 	{
; 83   : 		if (BeginsWith (t + 1, nodeName)
; 84   : 			&& (t[nameLen + 1] == '>'

  00020	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00023	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  00026	8b d3		 mov	 edx, ebx
  00028	3a 0b		 cmp	 cl, BYTE PTR [ebx]
  0002a	75 2f		 jne	 SHORT $LN2@XmlFindEle
  0002c	8b f7		 mov	 esi, edi
  0002e	2b f3		 sub	 esi, ebx
$LL9@XmlFindEle:
  00030	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  00033	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00036	84 c9		 test	 cl, cl
  00038	74 0d		 je	 SHORT $LN35@XmlFindEle
  0003a	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  0003d	84 db		 test	 bl, bl
  0003f	74 17		 je	 SHORT $LN38@XmlFindEle
  00041	3a d9		 cmp	 bl, cl
  00043	74 eb		 je	 SHORT $LL9@XmlFindEle

; 85   : 			|| t[nameLen + 1] == ' ')) return t;
; 86   : 
; 87   : 	} while (t = XmlNextNode (t));

  00045	eb 11		 jmp	 SHORT $LN38@XmlFindEle
$LN35@XmlFindEle:

; 80   : 
; 81   : 	do
; 82   : 	{
; 83   : 		if (BeginsWith (t + 1, nodeName)
; 84   : 			&& (t[nameLen + 1] == '>'

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _nameLen$1$[ebp]
  0004a	8a 4c 01 01	 mov	 cl, BYTE PTR [ecx+eax+1]
  0004e	80 f9 3e	 cmp	 cl, 62			; 0000003eH
  00051	74 37		 je	 SHORT $LN1@XmlFindEle
  00053	80 f9 20	 cmp	 cl, 32			; 00000020H
  00056	74 32		 je	 SHORT $LN1@XmlFindEle
$LN38@XmlFindEle:
  00058	8b 5d 0c	 mov	 ebx, DWORD PTR _nodeName$[ebp]
$LN2@XmlFindEle:

; 85   : 			|| t[nameLen + 1] == ' ')) return t;
; 86   : 
; 87   : 	} while (t = XmlNextNode (t));

  0005b	6a 3c		 push	 60			; 0000003cH
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 _strchr
  00063	83 c4 08	 add	 esp, 8
  00066	85 c0		 test	 eax, eax
  00068	74 1e		 je	 SHORT $LN25@XmlFindEle
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL15@XmlFindEle:
  00070	80 78 01 2f	 cmp	 BYTE PTR [eax+1], 47	; 0000002fH
  00074	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00077	75 a7		 jne	 SHORT $LL4@XmlFindEle
  00079	6a 3c		 push	 60			; 0000003cH
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 _strchr
  00081	83 c4 08	 add	 esp, 8
  00084	85 c0		 test	 eax, eax
  00086	75 e8		 jne	 SHORT $LL15@XmlFindEle
$LN25@XmlFindEle:

; 88   : 
; 89   : 	return NULL;

  00088	33 c0		 xor	 eax, eax
$LN1@XmlFindEle:
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 90   : }

  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_XmlFindElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\xml.c
;	COMDAT _XmlNextNode
_TEXT	SEGMENT
_xmlNode$ = 8						; size = 4
_XmlNextNode PROC					; COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   : 	char *t = xmlNode + 1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _xmlNode$[ebp]
  00006	40		 inc	 eax

; 55   : 	while ((t = strchr (t, '<')) != NULL)

  00007	6a 3c		 push	 60			; 0000003cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _strchr
  0000f	83 c4 08	 add	 esp, 8
  00012	85 c0		 test	 eax, eax
  00014	74 18		 je	 SHORT $LN3@XmlNextNod
$LL2@XmlNextNod:

; 56   : 	{
; 57   : 		if (t[1] != '/')

  00016	80 78 01 2f	 cmp	 BYTE PTR [eax+1], 47	; 0000002fH
  0001a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0001d	75 11		 jne	 SHORT $LN1@XmlNextNod

; 55   : 	while ((t = strchr (t, '<')) != NULL)

  0001f	6a 3c		 push	 60			; 0000003cH
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _strchr
  00027	83 c4 08	 add	 esp, 8
  0002a	85 c0		 test	 eax, eax
  0002c	75 e8		 jne	 SHORT $LL2@XmlNextNod
$LN3@XmlNextNod:

; 58   : 			return t;
; 59   : 
; 60   : 		t++;
; 61   : 	}
; 62   : 
; 63   : 	return NULL;

  0002e	33 c0		 xor	 eax, eax
$LN1@XmlNextNod:

; 64   : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_XmlNextNode ENDP
_TEXT	ENDS
END
