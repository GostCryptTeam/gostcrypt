; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\Xts.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_EncryptBufferXTS
PUBLIC	_EncryptBufferXTS8Byte
PUBLIC	_DecryptBufferXTS
PUBLIC	_DecryptBufferXTS8Byte
EXTRN	_CipherGetKeyScheduleSize:PROC
EXTRN	_CipherSupportsIntraDataUnitParallelization:PROC
EXTRN	_XorKeySchedule:PROC
EXTRN	_EncipherBlock:PROC
EXTRN	_DecipherBlock:PROC
EXTRN	_EncipherBlocks:PROC
EXTRN	_DecipherBlocks:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\xts.c
;	COMDAT _DecryptBufferXTS8Byte
_TEXT	SEGMENT
_ks2$GSCopy$1$ = -592					; size = 4
_dataUnitNo$1$ = -588					; size = 4
_blockCount$2$ = -584					; size = 4
_blockCount$1$ = -580					; size = 4
_ks$GSCopy$1$ = -576					; size = 4
_dataUnitNo$2$ = -572					; size = 4
_endBlock$1$ = -568					; size = 4
_xor_ks$ = -564						; size = 544
_byteBufUnitNo$ = -20					; size = 8
_whiteningValue$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTS8Byte PROC				; COMDAT

; 518  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00016	8b 4d 1c	 mov	 ecx, DWORD PTR _ks$[ebp]
  00019	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _ks$GSCopy$1$[ebp], ecx
  0001f	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00022	53		 push	 ebx

; 519  : 	unsigned __int8 finalCarry;
; 520  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
; 521  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
; 522  : 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
; 523  : 	unsigned __int32 *bufPtr = (unsigned __int32 *) buffer;
; 524  : 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;
; 525  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 526  : 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
; 527  : 
; 528  : 	dataUnitNo = startDataUnitNo->Value;
; 529  : 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);
; 530  : 
; 531  : 	if (length % BYTES_PER_XTS_BLOCK_SMALL)

  00023	8b 5d 0c	 mov	 ebx, DWORD PTR _length$[ebp]
  00026	89 8d b0 fd ff
	ff		 mov	 DWORD PTR _ks2$GSCopy$1$[ebp], ecx
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$2$[ebp], eax
  00037	89 45 f0	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], eax
  0003a	8b c3		 mov	 eax, ebx
  0003c	56		 push	 esi
  0003d	83 e0 07	 and	 eax, 7
  00040	89 8d b4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$1$[ebp], ecx
  00046	83 c8 00	 or	 eax, 0
  00049	89 4d ec	 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  0004c	57		 push	 edi
  0004d	8b 7d 08	 mov	 edi, DWORD PTR _buffer$[ebp]
  00050	74 07		 je	 SHORT $LN12@DecryptBuf

; 532  : 		GST_THROW_FATAL_EXCEPTION;

  00052	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN12@DecryptBuf:

; 533  : 
; 534  : 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;

  00059	8b 75 10	 mov	 esi, DWORD PTR _length$[ebp+4]

; 535  : 
; 536  : 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));

  0005c	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  0005f	0f ac f3 03	 shrd	 ebx, esi, 3
  00063	c1 ee 03	 shr	 esi, 3
  00066	89 9d bc fd ff
	ff		 mov	 DWORD PTR _blockCount$1$[ebp], ebx
  0006c	89 b5 b8 fd ff
	ff		 mov	 DWORD PTR _blockCount$2$[ebp], esi
  00072	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize
  00077	50		 push	 eax
  00078	ff b5 c0 fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$1$[ebp]
  0007e	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _memcpy
  0008a	83 c4 10	 add	 esp, 16			; 00000010H

; 537  : 
; 538  : 	while (blockCount > 0)

  0008d	85 f6		 test	 esi, esi
  0008f	75 18		 jne	 SHORT $LN37@DecryptBuf
  00091	85 db		 test	 ebx, ebx
  00093	75 14		 jne	 SHORT $LN37@DecryptBuf

; 608  : 	}
; 609  : 
; 610  : 	FAST_ERASE32 (whiteningValue, sizeof (whiteningValue));

  00095	5f		 pop	 edi
  00096	89 75 f4	 mov	 DWORD PTR _whiteningValue$[ebp], esi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx

; 611  : }

  0009b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009e	33 cd		 xor	 ecx, ebp
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
$LN37@DecryptBuf:

; 537  : 
; 538  : 	while (blockCount > 0)

  000a9	8b 4d f0	 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp+4]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR _byteBufUnitNo$[ebp]
  000af	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
$LL2@DecryptBuf:

; 539  : 	{
; 540  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)

  000b2	85 f6		 test	 esi, esi
  000b4	77 11		 ja	 SHORT $LN13@DecryptBuf
  000b6	72 05		 jb	 SHORT $LN33@DecryptBuf
  000b8	83 fb 40	 cmp	 ebx, 64			; 00000040H
  000bb	73 0a		 jae	 SHORT $LN13@DecryptBuf
$LN33@DecryptBuf:

; 541  : 			endBlock = startBlock + (unsigned __int32) blockCount;

  000bd	03 c3		 add	 eax, ebx
  000bf	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _endBlock$1$[ebp], eax
  000c5	eb 0a		 jmp	 SHORT $LN14@DecryptBuf
$LN13@DecryptBuf:

; 542  : 		else
; 543  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;

  000c7	c7 85 c8 fd ff
	ff 40 00 00 00	 mov	 DWORD PTR _endBlock$1$[ebp], 64 ; 00000040H
$LN14@DecryptBuf:

; 544  : 
; 545  : 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
; 546  : 
; 547  : 		//Encrypt data unit using the second key to generate the first whitening value
; 548  : 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);
; 549  : 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);
; 550  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000d1	ff b5 b0 fd ff
	ff		 push	 DWORD PTR _ks2$GSCopy$1$[ebp]
  000d7	8b 5d 24	 mov	 ebx, DWORD PTR _cipher$[ebp]
  000da	8d 75 f4	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000dd	8b c6		 mov	 eax, esi
  000df	89 55 f4	 mov	 DWORD PTR _whiteningValue$[ebp], edx
  000e2	50		 push	 eax
  000e3	53		 push	 ebx
  000e4	89 4d f8	 mov	 DWORD PTR _whiteningValue$[ebp+4], ecx
  000e7	e8 00 00 00 00	 call	 _EncipherBlock

; 551  : 
; 552  : 		//XOR ks with the current DataUnitNo
; 553  : 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);

  000ec	6a 08		 push	 8
  000ee	8d 45 ec	 lea	 eax, DWORD PTR _byteBufUnitNo$[ebp]
  000f1	50		 push	 eax
  000f2	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  000f8	50		 push	 eax
  000f9	ff b5 c0 fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$1$[ebp]
  000ff	53		 push	 ebx
  00100	e8 00 00 00 00	 call	 _XorKeySchedule

; 554  : 
; 555  : 		for (block = 0; block < endBlock; block++)

  00105	8b 95 c8 fd ff
	ff		 mov	 edx, DWORD PTR _endBlock$1$[ebp]
  0010b	83 c4 20	 add	 esp, 32			; 00000020H
  0010e	33 db		 xor	 ebx, ebx
  00110	85 d2		 test	 edx, edx
  00112	74 66		 je	 SHORT $LN5@DecryptBuf
$LL6@DecryptBuf:

; 556  : 		{
; 557  : 			if (block >= startBlock)

  00114	3b 5d 18	 cmp	 ebx, DWORD PTR _startCipherBlockNo$[ebp]
  00117	72 34		 jb	 SHORT $LN15@DecryptBuf

; 558  : 			{
; 559  : 				//Post-whitening
; 560  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  00119	8b 06		 mov	 eax, DWORD PTR [esi]
  0011b	83 c6 04	 add	 esi, 4
  0011e	31 07		 xor	 DWORD PTR [edi], eax

; 561  : 				*bufPtr-- ^= *whiteningValuePtr32--;

  00120	8b 06		 mov	 eax, DWORD PTR [esi]
  00122	31 47 04	 xor	 DWORD PTR [edi+4], eax

; 562  : 
; 563  : 				//Actual decryption
; 564  : 				DecipherBlock (cipher, bufPtr, xor_ks);

  00125	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  0012b	50		 push	 eax
  0012c	57		 push	 edi
  0012d	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00130	e8 00 00 00 00	 call	 _DecipherBlock

; 565  : 
; 566  : 				//Pre-whitening
; 567  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  00135	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	31 07		 xor	 DWORD PTR [edi], eax

; 568  : 				*bufPtr++ ^= *whiteningValuePtr32;

  0013d	8b 06		 mov	 eax, DWORD PTR [esi]
  0013f	31 47 04	 xor	 DWORD PTR [edi+4], eax
  00142	83 c7 08	 add	 edi, 8

; 569  : 			}

  00145	8b 95 c8 fd ff
	ff		 mov	 edx, DWORD PTR _endBlock$1$[ebp]
  0014b	eb 03		 jmp	 SHORT $LN16@DecryptBuf
$LN15@DecryptBuf:

; 570  : 			else
; 571  : 				whiteningValuePtr32++;

  0014d	83 c6 04	 add	 esi, 4
$LN16@DecryptBuf:

; 572  : 
; 573  : 			//Derive the next whitening value
; 574  : 
; 575  : #if BYTE_ORDER == LITTLE_ENDIAN
; 576  : 
; 577  : 			//Little-endian platforms
; 578  : 
; 579  : 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;

  00150	8b 06		 mov	 eax, DWORD PTR [esi]
  00152	85 c0		 test	 eax, eax
  00154	0f 99 c1	 setns	 cl

; 580  : 
; 581  : 			*whiteningValuePtr32-- <<= 1;

  00157	03 c0		 add	 eax, eax
  00159	89 06		 mov	 DWORD PTR [esi], eax
  0015b	fe c9		 dec	 cl

; 582  : 
; 583  : 			if (*whiteningValuePtr32 & 0x80000000)

  0015d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00160	83 ee 04	 sub	 esi, 4
  00163	80 e1 1b	 and	 cl, 27			; 0000001bH
  00166	85 c0		 test	 eax, eax
  00168	79 04		 jns	 SHORT $LN17@DecryptBuf

; 584  : 				*(whiteningValuePtr32 + 1) |= 1;

  0016a	83 4e 04 01	 or	 DWORD PTR [esi+4], 1
$LN17@DecryptBuf:

; 585  : 
; 586  : 			*whiteningValuePtr32 <<= 1;

  0016e	03 c0		 add	 eax, eax
  00170	43		 inc	 ebx
  00171	89 06		 mov	 DWORD PTR [esi], eax

; 587  : #else
; 588  : 			//Big-endian platforms
; 589  : 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
; 590  : 
; 591  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 592  : 
; 593  : 			whiteningValuePtr32--;
; 594  : 
; 595  : 			if (*whiteningValuePtr32 & 0x80)
; 596  : 				*(whiteningValuePtr32 + 1) |= 0x1000000;
; 597  : 
; 598  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 599  : #endif
; 600  : 
; 601  : 			whiteningValue[0] ^= finalCarry;

  00173	30 4d f4	 xor	 BYTE PTR _whiteningValue$[ebp], cl
  00176	3b da		 cmp	 ebx, edx
  00178	72 9a		 jb	 SHORT $LL6@DecryptBuf
$LN5@DecryptBuf:

; 602  : 		}
; 603  : 
; 604  : 		blockCount -= endBlock - startBlock;

  0017a	2b 55 18	 sub	 edx, DWORD PTR _startCipherBlockNo$[ebp]
  0017d	8b 9d bc fd ff
	ff		 mov	 ebx, DWORD PTR _blockCount$1$[ebp]
  00183	8b b5 b8 fd ff
	ff		 mov	 esi, DWORD PTR _blockCount$2$[ebp]
  00189	2b da		 sub	 ebx, edx

; 605  : 		startBlock = 0;
; 606  : 		dataUnitNo++;

  0018b	8b 8d b4 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$1$[ebp]
  00191	83 de 00	 sbb	 esi, 0
  00194	89 9d bc fd ff
	ff		 mov	 DWORD PTR _blockCount$1$[ebp], ebx
  0019a	33 c0		 xor	 eax, eax
  0019c	89 b5 b8 fd ff
	ff		 mov	 DWORD PTR _blockCount$2$[ebp], esi
  001a2	83 c1 01	 add	 ecx, 1
  001a5	89 45 18	 mov	 DWORD PTR _startCipherBlockNo$[ebp], eax

; 607  : 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  001a8	8b d1		 mov	 edx, ecx
  001aa	89 8d b4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$1$[ebp], ecx
  001b0	11 85 c4 fd ff
	ff		 adc	 DWORD PTR _dataUnitNo$2$[ebp], eax
  001b6	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$2$[ebp]
  001bc	89 55 ec	 mov	 DWORD PTR _byteBufUnitNo$[ebp], edx
  001bf	89 4d f0	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx
  001c2	85 f6		 test	 esi, esi
  001c4	0f 87 fd fe ff
	ff		 ja	 $LN13@DecryptBuf

; 537  : 
; 538  : 	while (blockCount > 0)

  001ca	72 08		 jb	 SHORT $LN40@DecryptBuf
  001cc	85 db		 test	 ebx, ebx
  001ce	0f 85 de fe ff
	ff		 jne	 $LL2@DecryptBuf
$LN40@DecryptBuf:
  001d4	5f		 pop	 edi

; 608  : 	}
; 609  : 
; 610  : 	FAST_ERASE32 (whiteningValue, sizeof (whiteningValue));

  001d5	89 45 f4	 mov	 DWORD PTR _whiteningValue$[ebp], eax

; 611  : }

  001d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001db	5e		 pop	 esi
  001dc	33 cd		 xor	 ecx, ebp
  001de	5b		 pop	 ebx
  001df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e4	8b e5		 mov	 esp, ebp
  001e6	5d		 pop	 ebp
  001e7	c3		 ret	 0
_DecryptBufferXTS8Byte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\xts.c
;	COMDAT _DecryptBufferXTSNonParallel
_TEXT	SEGMENT
_ks$GSCopy$1$ = -52					; size = 4
_ks2$GSCopy$1$ = -48					; size = 4
_blockCount$2$ = -44					; size = 4
_blockCount$1$ = -40					; size = 4
_endBlock$1$ = -36					; size = 4
_block$1$ = -32						; size = 4
_dataUnitNo$2$ = -28					; size = 4
_dataUnitNo$1$ = -24					; size = 4
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTSNonParallel PROC			; COMDAT

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  00013	89 45 cc	 mov	 DWORD PTR _ks$GSCopy$1$[ebp], eax
  00016	8b 45 20	 mov	 eax, DWORD PTR _ks2$[ebp]
  00019	89 45 d0	 mov	 DWORD PTR _ks2$GSCopy$1$[ebp], eax

; 781  : 	unsigned __int8 finalCarry;
; 782  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 783  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 784  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 785  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 786  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 787  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 788  : 
; 789  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 790  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 791  : 	dataUnitNo = startDataUnitNo->Value;

  0001c	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  0001f	57		 push	 edi
  00020	8b 7d 08	 mov	 edi, DWORD PTR _buffer$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00028	89 45 e4	 mov	 DWORD PTR _dataUnitNo$2$[ebp], eax
  0002b	89 4d e8	 mov	 DWORD PTR _dataUnitNo$1$[ebp], ecx

; 792  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 793  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 794  : 
; 795  : 	if (length % BYTES_PER_XTS_BLOCK)

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00031	8b c1		 mov	 eax, ecx
  00033	83 e0 0f	 and	 eax, 15			; 0000000fH
  00036	83 c8 00	 or	 eax, 0
  00039	74 07		 je	 SHORT $LN12@DecryptBuf

; 796  : 		GST_THROW_FATAL_EXCEPTION;

  0003b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN12@DecryptBuf:

; 797  : 
; 798  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00042	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00045	0f ac d1 04	 shrd	 ecx, edx, 4
  00049	c1 ea 04	 shr	 edx, 4
  0004c	89 4d d8	 mov	 DWORD PTR _blockCount$1$[ebp], ecx
  0004f	89 55 d4	 mov	 DWORD PTR _blockCount$2$[ebp], edx

; 799  : 
; 800  : 	// Process all blocks in the buffer
; 801  : 	while (blockCount > 0)

  00052	85 d2		 test	 edx, edx
  00054	75 08		 jne	 SHORT $LN42@DecryptBuf
  00056	85 c9		 test	 ecx, ecx
  00058	0f 84 2c 01 00
	00		 je	 $LN9@DecryptBuf
$LN42@DecryptBuf:
  0005e	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00061	53		 push	 ebx
  00062	56		 push	 esi
$LL2@DecryptBuf:

; 802  : 	{
; 803  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00063	85 d2		 test	 edx, edx
  00065	77 0c		 ja	 SHORT $LN13@DecryptBuf
  00067	72 05		 jb	 SHORT $LN35@DecryptBuf
  00069	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0006c	73 05		 jae	 SHORT $LN13@DecryptBuf
$LN35@DecryptBuf:

; 804  : 			endBlock = startBlock + (unsigned int) blockCount;

  0006e	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]
  00071	eb 05		 jmp	 SHORT $LN48@DecryptBuf
$LN13@DecryptBuf:

; 805  : 		else
; 806  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00073	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
$LN48@DecryptBuf:

; 807  : 
; 808  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 809  : 
; 810  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 811  : 		// whitening value for this data unit)
; 812  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  00078	8b 45 e8	 mov	 eax, DWORD PTR _dataUnitNo$1$[ebp]
  0007b	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]

; 813  : 		*(whiteningValuePtr64 + 1) = 0;
; 814  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0007e	ff 75 d0	 push	 DWORD PTR _ks2$GSCopy$1$[ebp]
  00081	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  00084	0f 57 c0	 xorps	 xmm0, xmm0
  00087	8b 45 e4	 mov	 eax, DWORD PTR _dataUnitNo$2$[ebp]
  0008a	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  0008d	8b c6		 mov	 eax, esi
  0008f	50		 push	 eax
  00090	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00093	89 5d dc	 mov	 DWORD PTR _endBlock$1$[ebp], ebx
  00096	66 0f 13 45 f4	 movlpd	 QWORD PTR _whiteningValue$[ebp+8], xmm0
  0009b	e8 00 00 00 00	 call	 _EncipherBlock

; 815  : 
; 816  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 817  : 		// decrypt all relevant blocks in this data unit
; 818  : 		for (block = 0; block < endBlock; block++)

  000a0	33 c0		 xor	 eax, eax
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a5	89 45 e0	 mov	 DWORD PTR _block$1$[ebp], eax
  000a8	85 db		 test	 ebx, ebx
  000aa	0f 84 a6 00 00
	00		 je	 $LN5@DecryptBuf
$LL6@DecryptBuf:

; 819  : 		{
; 820  : 			if (block >= startBlock)

  000b0	3b 45 18	 cmp	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  000b3	72 42		 jb	 SHORT $LN15@DecryptBuf

; 821  : 			{
; 822  : 				// Post-whitening
; 823  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000b5	8b 06		 mov	 eax, DWORD PTR [esi]
  000b7	31 07		 xor	 DWORD PTR [edi], eax
  000b9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000bc	83 c6 08	 add	 esi, 8
  000bf	31 47 04	 xor	 DWORD PTR [edi+4], eax

; 824  : 				*bufPtr-- ^= *whiteningValuePtr64--;
; 825  : 
; 826  : 				// Actual decryption
; 827  : 				DecipherBlock (cipher, bufPtr, ks);

  000c2	ff 75 cc	 push	 DWORD PTR _ks$GSCopy$1$[ebp]
  000c5	8b 06		 mov	 eax, DWORD PTR [esi]
  000c7	31 47 08	 xor	 DWORD PTR [edi+8], eax
  000ca	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000cd	31 47 0c	 xor	 DWORD PTR [edi+12], eax
  000d0	57		 push	 edi
  000d1	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  000d4	e8 00 00 00 00	 call	 _DecipherBlock

; 828  : 
; 829  : 				// Pre-whitening
; 830  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000d9	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000df	31 07		 xor	 DWORD PTR [edi], eax
  000e1	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  000e4	31 47 04	 xor	 DWORD PTR [edi+4], eax

; 831  : 				*bufPtr++ ^= *whiteningValuePtr64;

  000e7	8b 06		 mov	 eax, DWORD PTR [esi]
  000e9	31 47 08	 xor	 DWORD PTR [edi+8], eax
  000ec	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ef	31 47 0c	 xor	 DWORD PTR [edi+12], eax
  000f2	83 c7 10	 add	 edi, 16			; 00000010H

; 832  : 			}

  000f5	eb 03		 jmp	 SHORT $LN16@DecryptBuf
$LN15@DecryptBuf:

; 833  : 			else
; 834  : 				whiteningValuePtr64++;

  000f7	83 c6 08	 add	 esi, 8
$LN16@DecryptBuf:

; 835  : 
; 836  : 			// Derive the next whitening value
; 837  : 
; 838  : #if BYTE_ORDER == LITTLE_ENDIAN
; 839  : 
; 840  : 			// Little-endian platforms
; 841  : 
; 842  : 			finalCarry = 

  000fa	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000fd	8b 06		 mov	 eax, DWORD PTR [esi]
  000ff	85 c9		 test	 ecx, ecx
  00101	7f 0a		 jg	 SHORT $LN19@DecryptBuf
  00103	7c 04		 jl	 SHORT $LN36@DecryptBuf
  00105	85 c0		 test	 eax, eax
  00107	73 04		 jae	 SHORT $LN19@DecryptBuf
$LN36@DecryptBuf:
  00109	b3 87		 mov	 bl, 135			; 00000087H
  0010b	eb 02		 jmp	 SHORT $LN20@DecryptBuf
$LN19@DecryptBuf:
  0010d	32 db		 xor	 bl, bl
$LN20@DecryptBuf:

; 843  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 844  : 				135 : 0;
; 845  : 
; 846  : 			*whiteningValuePtr64-- <<= 1;

  0010f	0f a4 c1 01	 shld	 ecx, eax, 1
  00113	03 c0		 add	 eax, eax
  00115	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00118	89 06		 mov	 DWORD PTR [esi], eax
  0011a	83 ee 08	 sub	 esi, 8

; 847  : 
; 848  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  0011d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00120	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00122	85 d2		 test	 edx, edx
  00124	7f 10		 jg	 SHORT $LN17@DecryptBuf
  00126	7c 04		 jl	 SHORT $LN37@DecryptBuf
  00128	85 c9		 test	 ecx, ecx
  0012a	73 0a		 jae	 SHORT $LN17@DecryptBuf
$LN37@DecryptBuf:

; 849  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0012c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0012f	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00133	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN17@DecryptBuf:

; 850  : 
; 851  : 			*whiteningValuePtr64 <<= 1;

  00136	8b 45 e0	 mov	 eax, DWORD PTR _block$1$[ebp]
  00139	0f a4 ca 01	 shld	 edx, ecx, 1
  0013d	40		 inc	 eax
  0013e	03 c9		 add	 ecx, ecx
  00140	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00143	89 0e		 mov	 DWORD PTR [esi], ecx

; 852  : 
; 853  : #else
; 854  : 			// Big-endian platforms
; 855  : 
; 856  : 			finalCarry = 
; 857  : 				(*whiteningValuePtr64 & 0x80) ?
; 858  : 				135 : 0;
; 859  : 
; 860  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 861  : 
; 862  : 			whiteningValuePtr64--;
; 863  : 
; 864  : 			if (*whiteningValuePtr64 & 0x80)
; 865  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 866  : 
; 867  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 868  : #endif
; 869  : 
; 870  : 			whiteningValue[0] ^= finalCarry;

  00145	30 5d ec	 xor	 BYTE PTR _whiteningValue$[ebp], bl
  00148	8b 5d dc	 mov	 ebx, DWORD PTR _endBlock$1$[ebp]
  0014b	89 45 e0	 mov	 DWORD PTR _block$1$[ebp], eax
  0014e	3b c3		 cmp	 eax, ebx
  00150	0f 82 5a ff ff
	ff		 jb	 $LL6@DecryptBuf
$LN5@DecryptBuf:

; 871  : 		}
; 872  : 
; 873  : 		blockCount -= endBlock - startBlock;

  00156	2b 5d 18	 sub	 ebx, DWORD PTR _startCipherBlockNo$[ebp]
  00159	8b 4d d8	 mov	 ecx, DWORD PTR _blockCount$1$[ebp]
  0015c	8b 55 d4	 mov	 edx, DWORD PTR _blockCount$2$[ebp]
  0015f	2b cb		 sub	 ecx, ebx
  00161	89 4d d8	 mov	 DWORD PTR _blockCount$1$[ebp], ecx
  00164	83 da 00	 sbb	 edx, 0

; 874  : 		startBlock = 0;

  00167	33 c0		 xor	 eax, eax

; 875  : 		dataUnitNo++;

  00169	83 45 e8 01	 add	 DWORD PTR _dataUnitNo$1$[ebp], 1
  0016d	89 55 d4	 mov	 DWORD PTR _blockCount$2$[ebp], edx
  00170	11 45 e4	 adc	 DWORD PTR _dataUnitNo$2$[ebp], eax
  00173	89 45 18	 mov	 DWORD PTR _startCipherBlockNo$[ebp], eax
  00176	85 d2		 test	 edx, edx
  00178	0f 87 f5 fe ff
	ff		 ja	 $LN13@DecryptBuf

; 799  : 
; 800  : 	// Process all blocks in the buffer
; 801  : 	while (blockCount > 0)

  0017e	72 08		 jb	 SHORT $LN46@DecryptBuf
  00180	85 c9		 test	 ecx, ecx
  00182	0f 85 db fe ff
	ff		 jne	 $LL2@DecryptBuf
$LN46@DecryptBuf:
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx
$LN9@DecryptBuf:

; 876  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 877  : 	}
; 878  : 
; 879  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  0018a	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  0018d	b9 02 00 00 00	 mov	 ecx, 2
  00192	5f		 pop	 edi
  00193	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL10@DecryptBuf:
  001a0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001a6	8d 40 08	 lea	 eax, DWORD PTR [eax+8]
  001a9	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [eax-4], 0
  001b0	83 e9 01	 sub	 ecx, 1
  001b3	75 eb		 jne	 SHORT $LL10@DecryptBuf

; 880  : }

  001b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b8	33 cd		 xor	 ecx, ebp
  001ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
_DecryptBufferXTSNonParallel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\xts.c
;	COMDAT _DecryptBufferXTSParallel
_TEXT	SEGMENT
_ks$GSCopy$1$ = -572					; size = 4
_ks2$GSCopy$1$ = -568					; size = 4
_blockCount$2$ = -564					; size = 4
_blockCount$1$ = -560					; size = 4
_block$1$ = -556					; size = 4
_dataUnitNo$2$ = -552					; size = 4
_dataUnitNo$1$ = -548					; size = 4
_bufPtr$1$ = -544					; size = 4
_endBlock$1$ = -540					; size = 4
_finalCarry$1$ = -533					; size = 1
_whiteningValues$ = -532				; size = 512
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTSParallel PROC				; COMDAT

; 634  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 02 00
	00		 sub	 esp, 572		; 0000023cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  00016	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _ks$GSCopy$1$[ebp], eax
  0001c	8b 45 20	 mov	 eax, DWORD PTR _ks2$[ebp]
  0001f	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _ks2$GSCopy$1$[ebp], eax

; 635  : 	unsigned __int8 finalCarry;
; 636  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 637  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 638  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 639  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 640  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 641  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 642  : 	unsigned __int64 *dataUnitBufPtr;
; 643  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 644  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 645  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 646  : 
; 647  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 648  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 649  : 	dataUnitNo = startDataUnitNo->Value;

  00025	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00028	57		 push	 edi
  00029	8b 7d 08	 mov	 edi, DWORD PTR _buffer$[ebp]
  0002c	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _bufPtr$1$[ebp], edi
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00037	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$2$[ebp], eax
  0003d	89 8d dc fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$1$[ebp], ecx

; 650  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 651  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 652  : 
; 653  : 	if (length % BYTES_PER_XTS_BLOCK)

  00043	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00046	8b c1		 mov	 eax, ecx
  00048	83 e0 0f	 and	 eax, 15			; 0000000fH
  0004b	83 c8 00	 or	 eax, 0
  0004e	74 07		 je	 SHORT $LN23@DecryptBuf

; 654  : 		GST_THROW_FATAL_EXCEPTION;

  00050	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN23@DecryptBuf:

; 655  : 
; 656  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00057	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  0005a	0f ac d1 04	 shrd	 ecx, edx, 4
  0005e	c1 ea 04	 shr	 edx, 4
  00061	89 8d d0 fd ff
	ff		 mov	 DWORD PTR _blockCount$1$[ebp], ecx
  00067	89 95 cc fd ff
	ff		 mov	 DWORD PTR _blockCount$2$[ebp], edx

; 657  : 
; 658  : 	// Process all blocks in the buffer
; 659  : 	while (blockCount > 0)

  0006d	85 d2		 test	 edx, edx
  0006f	75 08		 jne	 SHORT $LN89@DecryptBuf
  00071	85 c9		 test	 ecx, ecx
  00073	0f 84 e6 01 00
	00		 je	 $LN15@DecryptBuf
$LN89@DecryptBuf:
  00079	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  0007c	53		 push	 ebx
  0007d	56		 push	 esi
  0007e	66 90		 npad	 2
$LL2@DecryptBuf:

; 660  : 	{
; 661  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00080	85 d2		 test	 edx, edx
  00082	77 11		 ja	 SHORT $LN24@DecryptBuf
  00084	72 05		 jb	 SHORT $LN79@DecryptBuf
  00086	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00089	73 0a		 jae	 SHORT $LN24@DecryptBuf
$LN79@DecryptBuf:

; 662  : 			endBlock = startBlock + (unsigned int) blockCount;

  0008b	03 c1		 add	 eax, ecx
  0008d	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _endBlock$1$[ebp], eax
  00093	eb 0a		 jmp	 SHORT $LN25@DecryptBuf
$LN24@DecryptBuf:

; 663  : 		else
; 664  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00095	c7 85 e4 fd ff
	ff 20 00 00 00	 mov	 DWORD PTR _endBlock$1$[ebp], 32 ; 00000020H
$LN25@DecryptBuf:

; 665  : 
; 666  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 667  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 668  : 
; 669  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 670  : 		// whitening value for this data unit)
; 671  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0009f	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$1$[ebp]
  000a5	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]

; 672  : 		*(whiteningValuePtr64 + 1) = 0;
; 673  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000a8	ff b5 c8 fd ff
	ff		 push	 DWORD PTR _ks2$GSCopy$1$[ebp]
  000ae	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000b1	8d 5d e4	 lea	 ebx, DWORD PTR _whiteningValues$[ebp+504]
  000b4	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$2$[ebp]
  000ba	0f 57 c0	 xorps	 xmm0, xmm0
  000bd	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000c0	8b c6		 mov	 eax, esi
  000c2	50		 push	 eax
  000c3	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  000c6	66 0f 13 45 f4	 movlpd	 QWORD PTR _whiteningValue$[ebp+8], xmm0
  000cb	e8 00 00 00 00	 call	 _EncipherBlock

; 674  : 
; 675  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 676  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 677  : 		for (block = 0; block < endBlock; block++)

  000d0	33 c0		 xor	 eax, eax
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d5	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _block$1$[ebp], eax
  000db	39 85 e4 fd ff
	ff		 cmp	 DWORD PTR _endBlock$1$[ebp], eax
  000e1	0f 86 a6 00 00
	00		 jbe	 $LN5@DecryptBuf
  000e7	8b 7d 18	 mov	 edi, DWORD PTR _startCipherBlockNo$[ebp]
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL6@DecryptBuf:

; 678  : 		{
; 679  : 			if (block >= startBlock)

  000f0	3b c7		 cmp	 eax, edi
  000f2	72 1d		 jb	 SHORT $LN26@DecryptBuf

; 680  : 			{
; 681  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  000f4	8b 06		 mov	 eax, DWORD PTR [esi]
  000f6	89 03		 mov	 DWORD PTR [ebx], eax
  000f8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000fb	83 c6 08	 add	 esi, 8
  000fe	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 682  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  00101	8b 06		 mov	 eax, DWORD PTR [esi]
  00103	89 43 f8	 mov	 DWORD PTR [ebx-8], eax
  00106	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00109	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  0010c	83 eb 10	 sub	 ebx, 16			; 00000010H

; 683  : 			}

  0010f	eb 03		 jmp	 SHORT $LN27@DecryptBuf
$LN26@DecryptBuf:

; 684  : 			else
; 685  : 				whiteningValuePtr64++;

  00111	83 c6 08	 add	 esi, 8
$LN27@DecryptBuf:

; 686  : 
; 687  : 			// Derive the next whitening value
; 688  : 
; 689  : #if BYTE_ORDER == LITTLE_ENDIAN
; 690  : 
; 691  : 			// Little-endian platforms
; 692  : 
; 693  : 			finalCarry = 

  00114	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00117	8b 06		 mov	 eax, DWORD PTR [esi]
  00119	85 c9		 test	 ecx, ecx
  0011b	7f 0f		 jg	 SHORT $LN30@DecryptBuf
  0011d	7c 04		 jl	 SHORT $LN80@DecryptBuf
  0011f	85 c0		 test	 eax, eax
  00121	73 09		 jae	 SHORT $LN30@DecryptBuf
$LN80@DecryptBuf:
  00123	c6 85 eb fd ff
	ff 87		 mov	 BYTE PTR _finalCarry$1$[ebp], 135 ; 00000087H
  0012a	eb 07		 jmp	 SHORT $LN31@DecryptBuf
$LN30@DecryptBuf:
  0012c	c6 85 eb fd ff
	ff 00		 mov	 BYTE PTR _finalCarry$1$[ebp], 0
$LN31@DecryptBuf:

; 694  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 695  : 				135 : 0;
; 696  : 
; 697  : 			*whiteningValuePtr64-- <<= 1;

  00133	0f a4 c1 01	 shld	 ecx, eax, 1
  00137	03 c0		 add	 eax, eax
  00139	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0013c	89 06		 mov	 DWORD PTR [esi], eax
  0013e	83 ee 08	 sub	 esi, 8

; 698  : 
; 699  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00141	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00144	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00146	85 d2		 test	 edx, edx
  00148	7f 10		 jg	 SHORT $LN28@DecryptBuf
  0014a	7c 04		 jl	 SHORT $LN81@DecryptBuf
  0014c	85 c9		 test	 ecx, ecx
  0014e	73 0a		 jae	 SHORT $LN28@DecryptBuf
$LN81@DecryptBuf:

; 700  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00150	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00153	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00157	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN28@DecryptBuf:

; 701  : 
; 702  : 			*whiteningValuePtr64 <<= 1;
; 703  : 
; 704  : #else
; 705  : 			// Big-endian platforms
; 706  : 
; 707  : 			finalCarry = 
; 708  : 				(*whiteningValuePtr64 & 0x80) ?
; 709  : 				135 : 0;
; 710  : 
; 711  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 712  : 
; 713  : 			whiteningValuePtr64--;
; 714  : 
; 715  : 			if (*whiteningValuePtr64 & 0x80)
; 716  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 717  : 
; 718  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 719  : #endif
; 720  : 
; 721  : 			whiteningValue[0] ^= finalCarry;

  0015a	8a 85 eb fd ff
	ff		 mov	 al, BYTE PTR _finalCarry$1$[ebp]
  00160	0f a4 ca 01	 shld	 edx, ecx, 1
  00164	03 c9		 add	 ecx, ecx
  00166	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00169	89 0e		 mov	 DWORD PTR [esi], ecx
  0016b	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  0016e	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _block$1$[ebp]
  00174	40		 inc	 eax
  00175	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _block$1$[ebp], eax
  0017b	3b 85 e4 fd ff
	ff		 cmp	 eax, DWORD PTR _endBlock$1$[ebp]
  00181	0f 82 69 ff ff
	ff		 jb	 $LL6@DecryptBuf
  00187	8b bd e0 fd ff
	ff		 mov	 edi, DWORD PTR _bufPtr$1$[ebp]
$LN5@DecryptBuf:

; 725  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 726  : 
; 727  : 		// Decrypt blocks in this data unit
; 728  : 
; 729  : 		for (block = startBlock; block < endBlock; block++)

  0018d	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00190	8d 4d e4	 lea	 ecx, DWORD PTR _whiteningValues$[ebp+504]
  00193	8b b5 e4 fd ff
	ff		 mov	 esi, DWORD PTR _endBlock$1$[ebp]
  00199	8b df		 mov	 ebx, edi
  0019b	3b c6		 cmp	 eax, esi
  0019d	73 29		 jae	 SHORT $LN8@DecryptBuf

; 722  : 		}
; 723  : 
; 724  : 		dataUnitBufPtr = bufPtr;

  0019f	8b d6		 mov	 edx, esi
  001a1	2b d0		 sub	 edx, eax
$LL9@DecryptBuf:

; 730  : 		{
; 731  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001a3	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a5	8d 7f 10	 lea	 edi, DWORD PTR [edi+16]
  001a8	31 47 f0	 xor	 DWORD PTR [edi-16], eax
  001ab	8d 49 f0	 lea	 ecx, DWORD PTR [ecx-16]
  001ae	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  001b1	31 47 f4	 xor	 DWORD PTR [edi-12], eax
  001b4	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001b7	31 47 f8	 xor	 DWORD PTR [edi-8], eax
  001ba	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  001bd	31 47 fc	 xor	 DWORD PTR [edi-4], eax
  001c0	83 ea 01	 sub	 edx, 1
  001c3	75 de		 jne	 SHORT $LL9@DecryptBuf
  001c5	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
$LN8@DecryptBuf:

; 732  : 			*bufPtr++ ^= *whiteningValuesPtr64--;
; 733  : 		}
; 734  : 
; 735  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  001c8	2b f0		 sub	 esi, eax
  001ca	56		 push	 esi
  001cb	ff b5 c4 fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$1$[ebp]
  001d1	53		 push	 ebx
  001d2	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  001d5	e8 00 00 00 00	 call	 _DecipherBlocks

; 736  : 
; 737  : 		bufPtr = dataUnitBufPtr;
; 738  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 739  : 
; 740  : 		for (block = startBlock; block < endBlock; block++)

  001da	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _endBlock$1$[ebp]
  001e0	8d 4d e4	 lea	 ecx, DWORD PTR _whiteningValues$[ebp+504]
  001e3	83 c4 10	 add	 esp, 16			; 00000010H
  001e6	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _bufPtr$1$[ebp], ebx
  001ec	8b fb		 mov	 edi, ebx
  001ee	39 45 18	 cmp	 DWORD PTR _startCipherBlockNo$[ebp], eax
  001f1	73 29		 jae	 SHORT $LN11@DecryptBuf

; 732  : 			*bufPtr++ ^= *whiteningValuesPtr64--;
; 733  : 		}
; 734  : 
; 735  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  001f3	8b d6		 mov	 edx, esi
$LL12@DecryptBuf:

; 741  : 		{
; 742  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001f5	8b 01		 mov	 eax, DWORD PTR [ecx]
  001f7	8d 49 f0	 lea	 ecx, DWORD PTR [ecx-16]
  001fa	31 07		 xor	 DWORD PTR [edi], eax
  001fc	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  001ff	31 47 04	 xor	 DWORD PTR [edi+4], eax
  00202	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00205	31 47 08	 xor	 DWORD PTR [edi+8], eax
  00208	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0020b	31 47 0c	 xor	 DWORD PTR [edi+12], eax
  0020e	83 c7 10	 add	 edi, 16			; 00000010H
  00211	83 ea 01	 sub	 edx, 1
  00214	75 df		 jne	 SHORT $LL12@DecryptBuf
  00216	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _bufPtr$1$[ebp], edi
$LN11@DecryptBuf:

; 743  : 			*bufPtr++ ^= *whiteningValuesPtr64--;
; 744  : 		}
; 745  : 
; 746  : 		blockCount -= endBlock - startBlock;

  0021c	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$1$[ebp]
  00222	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _blockCount$2$[ebp]
  00228	2b ce		 sub	 ecx, esi
  0022a	89 8d d0 fd ff
	ff		 mov	 DWORD PTR _blockCount$1$[ebp], ecx
  00230	83 da 00	 sbb	 edx, 0

; 747  : 		startBlock = 0;

  00233	33 c0		 xor	 eax, eax

; 748  : 		dataUnitNo++;

  00235	83 85 dc fd ff
	ff 01		 add	 DWORD PTR _dataUnitNo$1$[ebp], 1
  0023c	89 95 cc fd ff
	ff		 mov	 DWORD PTR _blockCount$2$[ebp], edx
  00242	11 85 d8 fd ff
	ff		 adc	 DWORD PTR _dataUnitNo$2$[ebp], eax
  00248	89 45 18	 mov	 DWORD PTR _startCipherBlockNo$[ebp], eax
  0024b	85 d2		 test	 edx, edx
  0024d	0f 87 42 fe ff
	ff		 ja	 $LN24@DecryptBuf

; 657  : 
; 658  : 	// Process all blocks in the buffer
; 659  : 	while (blockCount > 0)

  00253	72 08		 jb	 SHORT $LN96@DecryptBuf
  00255	85 c9		 test	 ecx, ecx
  00257	0f 85 23 fe ff
	ff		 jne	 $LL2@DecryptBuf
$LN96@DecryptBuf:
  0025d	5e		 pop	 esi
  0025e	5b		 pop	 ebx
$LN15@DecryptBuf:

; 749  : 
; 750  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 751  : 	}
; 752  : 
; 753  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  0025f	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00262	b9 02 00 00 00	 mov	 ecx, 2
  00267	5f		 pop	 edi
  00268	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL16@DecryptBuf:
  00270	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00276	8d 40 08	 lea	 eax, DWORD PTR [eax+8]
  00279	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [eax-4], 0
  00280	83 e9 01	 sub	 ecx, 1
  00283	75 eb		 jne	 SHORT $LL16@DecryptBuf

; 754  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  00285	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  0028b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
$LL21@DecryptBuf:
  00290	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00296	8d 40 08	 lea	 eax, DWORD PTR [eax+8]
  00299	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [eax-4], 0
  002a0	83 e9 01	 sub	 ecx, 1
  002a3	75 eb		 jne	 SHORT $LL21@DecryptBuf

; 755  : }

  002a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a8	33 cd		 xor	 ecx, ebp
  002aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002af	8b e5		 mov	 esp, ebp
  002b1	5d		 pop	 ebp
  002b2	c3		 ret	 0
_DecryptBufferXTSParallel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\xts.c
;	COMDAT _DecryptBufferXTS
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTS PROC					; COMDAT

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 505  : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00004	8b 75 24	 mov	 esi, DWORD PTR _cipher$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization
  0000d	83 c4 04	 add	 esp, 4

; 506  : 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00010	56		 push	 esi
  00011	ff 75 20	 push	 DWORD PTR _ks2$[ebp]
  00014	ff 75 1c	 push	 DWORD PTR _ks$[ebp]
  00017	ff 75 18	 push	 DWORD PTR _startCipherBlockNo$[ebp]
  0001a	ff 75 14	 push	 DWORD PTR _startDataUnitNo$[ebp]
  0001d	ff 75 10	 push	 DWORD PTR _length$[ebp+4]
  00020	ff 75 0c	 push	 DWORD PTR _length$[ebp]
  00023	ff 75 08	 push	 DWORD PTR _buffer$[ebp]
  00026	85 c0		 test	 eax, eax
  00028	74 0b		 je	 SHORT $LN2@DecryptBuf
  0002a	e8 00 00 00 00	 call	 _DecryptBufferXTSParallel

; 507  : 	else
; 508  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0002f	83 c4 20	 add	 esp, 32			; 00000020H
  00032	5e		 pop	 esi

; 509  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN2@DecryptBuf:

; 507  : 	else
; 508  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00035	e8 00 00 00 00	 call	 _DecryptBufferXTSNonParallel
  0003a	83 c4 20	 add	 esp, 32			; 00000020H
  0003d	5e		 pop	 esi

; 509  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_DecryptBufferXTS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\xts.c
;	COMDAT _EncryptBufferXTS8Byte
_TEXT	SEGMENT
_ks2$GSCopy$1$ = -592					; size = 4
_dataUnitNo$1$ = -588					; size = 4
_blockCount$2$ = -584					; size = 4
_blockCount$1$ = -580					; size = 4
_ks$GSCopy$1$ = -576					; size = 4
_dataUnitNo$2$ = -572					; size = 4
_endBlock$1$ = -568					; size = 4
_xor_ks$ = -564						; size = 544
_byteBufUnitNo$ = -20					; size = 8
_whiteningValue$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTS8Byte PROC				; COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00016	8b 4d 1c	 mov	 ecx, DWORD PTR _ks$[ebp]
  00019	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _ks$GSCopy$1$[ebp], ecx
  0001f	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00022	53		 push	 ebx

; 103  : 	unsigned __int8 finalCarry;
; 104  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
; 105  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
; 106  : 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *)whiteningValue;
; 107  : 	unsigned __int32 *bufPtr = (unsigned __int32 *)buffer;
; 108  : 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;
; 109  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 110  : 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
; 111  : 
; 112  : 	dataUnitNo = startDataUnitNo->Value;
; 113  : 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64(dataUnitNo);
; 114  : 
; 115  : 	if (length % BYTES_PER_XTS_BLOCK_SMALL)

  00023	8b 5d 0c	 mov	 ebx, DWORD PTR _length$[ebp]
  00026	89 8d b0 fd ff
	ff		 mov	 DWORD PTR _ks2$GSCopy$1$[ebp], ecx
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$2$[ebp], eax
  00037	89 45 f0	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], eax
  0003a	8b c3		 mov	 eax, ebx
  0003c	56		 push	 esi
  0003d	83 e0 07	 and	 eax, 7
  00040	89 8d b4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$1$[ebp], ecx
  00046	83 c8 00	 or	 eax, 0
  00049	89 4d ec	 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  0004c	57		 push	 edi
  0004d	8b 7d 08	 mov	 edi, DWORD PTR _buffer$[ebp]
  00050	74 07		 je	 SHORT $LN12@EncryptBuf

; 116  : 		GST_THROW_FATAL_EXCEPTION;

  00052	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN12@EncryptBuf:

; 117  : 
; 118  : 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;

  00059	8b 75 10	 mov	 esi, DWORD PTR _length$[ebp+4]

; 119  : 
; 120  : 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));

  0005c	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  0005f	0f ac f3 03	 shrd	 ebx, esi, 3
  00063	c1 ee 03	 shr	 esi, 3
  00066	89 9d bc fd ff
	ff		 mov	 DWORD PTR _blockCount$1$[ebp], ebx
  0006c	89 b5 b8 fd ff
	ff		 mov	 DWORD PTR _blockCount$2$[ebp], esi
  00072	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize
  00077	50		 push	 eax
  00078	ff b5 c0 fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$1$[ebp]
  0007e	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _memcpy
  0008a	83 c4 10	 add	 esp, 16			; 00000010H

; 121  : 
; 122  : 	while (blockCount > 0)

  0008d	85 f6		 test	 esi, esi
  0008f	75 18		 jne	 SHORT $LN37@EncryptBuf
  00091	85 db		 test	 ebx, ebx
  00093	75 14		 jne	 SHORT $LN37@EncryptBuf

; 189  : 	}
; 190  : 	FAST_ERASE32(whiteningValue, sizeof(whiteningValue));

  00095	5f		 pop	 edi
  00096	89 75 f4	 mov	 DWORD PTR _whiteningValue$[ebp], esi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx

; 191  : }

  0009b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009e	33 cd		 xor	 ecx, ebp
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
$LN37@EncryptBuf:

; 121  : 
; 122  : 	while (blockCount > 0)

  000a9	8b 4d f0	 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp+4]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR _byteBufUnitNo$[ebp]
  000af	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
$LL2@EncryptBuf:

; 123  : 	{
; 124  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)

  000b2	85 f6		 test	 esi, esi
  000b4	77 11		 ja	 SHORT $LN13@EncryptBuf
  000b6	72 05		 jb	 SHORT $LN33@EncryptBuf
  000b8	83 fb 40	 cmp	 ebx, 64			; 00000040H
  000bb	73 0a		 jae	 SHORT $LN13@EncryptBuf
$LN33@EncryptBuf:

; 125  : 			endBlock = startBlock + (unsigned __int32) blockCount;

  000bd	03 c3		 add	 eax, ebx
  000bf	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _endBlock$1$[ebp], eax
  000c5	eb 0a		 jmp	 SHORT $LN14@EncryptBuf
$LN13@EncryptBuf:

; 126  : 		else
; 127  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;

  000c7	c7 85 c8 fd ff
	ff 40 00 00 00	 mov	 DWORD PTR _endBlock$1$[ebp], 64 ; 00000040H
$LN14@EncryptBuf:

; 128  : 
; 129  : 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
; 130  : 
; 131  : 		//Generate first whitening value
; 132  : 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);
; 133  : 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);
; 134  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000d1	ff b5 b0 fd ff
	ff		 push	 DWORD PTR _ks2$GSCopy$1$[ebp]
  000d7	8b 5d 24	 mov	 ebx, DWORD PTR _cipher$[ebp]
  000da	8d 75 f4	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000dd	8b c6		 mov	 eax, esi
  000df	89 55 f4	 mov	 DWORD PTR _whiteningValue$[ebp], edx
  000e2	50		 push	 eax
  000e3	53		 push	 ebx
  000e4	89 4d f8	 mov	 DWORD PTR _whiteningValue$[ebp+4], ecx
  000e7	e8 00 00 00 00	 call	 _EncipherBlock

; 135  : 
; 136  : 		//XOR ks with the current DataUnitNo
; 137  : 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);

  000ec	6a 08		 push	 8
  000ee	8d 45 ec	 lea	 eax, DWORD PTR _byteBufUnitNo$[ebp]
  000f1	50		 push	 eax
  000f2	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  000f8	50		 push	 eax
  000f9	ff b5 c0 fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$1$[ebp]
  000ff	53		 push	 ebx
  00100	e8 00 00 00 00	 call	 _XorKeySchedule

; 138  : 
; 139  : 		//Generate subsequent whitening values for blocks
; 140  : 		for (block = 0; block < endBlock; block++)

  00105	8b 95 c8 fd ff
	ff		 mov	 edx, DWORD PTR _endBlock$1$[ebp]
  0010b	83 c4 20	 add	 esp, 32			; 00000020H
  0010e	33 db		 xor	 ebx, ebx
  00110	85 d2		 test	 edx, edx
  00112	74 66		 je	 SHORT $LN5@EncryptBuf
$LL6@EncryptBuf:

; 141  : 		{
; 142  : 			if (block >= startBlock)

  00114	3b 5d 18	 cmp	 ebx, DWORD PTR _startCipherBlockNo$[ebp]
  00117	72 34		 jb	 SHORT $LN15@EncryptBuf

; 143  : 			{
; 144  : 				//Pre-whitening
; 145  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  00119	8b 06		 mov	 eax, DWORD PTR [esi]
  0011b	83 c6 04	 add	 esi, 4
  0011e	31 07		 xor	 DWORD PTR [edi], eax

; 146  : 				*bufPtr-- ^= *whiteningValuePtr32--;

  00120	8b 06		 mov	 eax, DWORD PTR [esi]
  00122	31 47 04	 xor	 DWORD PTR [edi+4], eax

; 147  : 
; 148  : 				//Actual encryption
; 149  : 				EncipherBlock(cipher, bufPtr, xor_ks);

  00125	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _xor_ks$[ebp]
  0012b	50		 push	 eax
  0012c	57		 push	 edi
  0012d	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00130	e8 00 00 00 00	 call	 _EncipherBlock

; 150  : 
; 151  : 				//Post-whitening
; 152  : 				*bufPtr++ ^= *whiteningValuePtr32++;

  00135	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	31 07		 xor	 DWORD PTR [edi], eax

; 153  : 				*bufPtr++ ^= *whiteningValuePtr32;

  0013d	8b 06		 mov	 eax, DWORD PTR [esi]
  0013f	31 47 04	 xor	 DWORD PTR [edi+4], eax
  00142	83 c7 08	 add	 edi, 8

; 154  : 			}

  00145	8b 95 c8 fd ff
	ff		 mov	 edx, DWORD PTR _endBlock$1$[ebp]
  0014b	eb 03		 jmp	 SHORT $LN16@EncryptBuf
$LN15@EncryptBuf:

; 155  : 			else
; 156  : 				whiteningValuePtr32++;

  0014d	83 c6 04	 add	 esi, 4
$LN16@EncryptBuf:

; 157  : 
; 158  : 			//Derive the next whitening value
; 159  : #if BYTE_ORDER == LITTLE_ENDIAN
; 160  : 
; 161  : 			//Little-endian platforms
; 162  : 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;

  00150	8b 06		 mov	 eax, DWORD PTR [esi]
  00152	85 c0		 test	 eax, eax
  00154	0f 99 c1	 setns	 cl

; 163  : 
; 164  : 			*whiteningValuePtr32-- <<= 1;

  00157	03 c0		 add	 eax, eax
  00159	89 06		 mov	 DWORD PTR [esi], eax
  0015b	fe c9		 dec	 cl

; 165  : 
; 166  : 			if (*whiteningValuePtr32 & 0x80000000)

  0015d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00160	83 ee 04	 sub	 esi, 4
  00163	80 e1 1b	 and	 cl, 27			; 0000001bH
  00166	85 c0		 test	 eax, eax
  00168	79 04		 jns	 SHORT $LN17@EncryptBuf

; 167  : 				*(whiteningValuePtr32 + 1) |= 1;

  0016a	83 4e 04 01	 or	 DWORD PTR [esi+4], 1
$LN17@EncryptBuf:

; 168  : 
; 169  : 			*whiteningValuePtr32 <<= 1;

  0016e	03 c0		 add	 eax, eax
  00170	43		 inc	 ebx
  00171	89 06		 mov	 DWORD PTR [esi], eax

; 170  : #else
; 171  : 			//Big-endian platforms
; 172  : 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
; 173  : 
; 174  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 175  : 
; 176  : 			whiteningValuePtr32--;
; 177  : 
; 178  : 			if (*whiteningValuePtr32 & 0x80)
; 179  : 				*(whiteningValuePtr32 + 1) |= 0x01000000;
; 180  : 
; 181  : 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
; 182  : #endif
; 183  : 			whiteningValue[0] ^= finalCarry;

  00173	30 4d f4	 xor	 BYTE PTR _whiteningValue$[ebp], cl
  00176	3b da		 cmp	 ebx, edx
  00178	72 9a		 jb	 SHORT $LL6@EncryptBuf
$LN5@EncryptBuf:

; 184  : 		}
; 185  : 		blockCount -= endBlock - startBlock;

  0017a	2b 55 18	 sub	 edx, DWORD PTR _startCipherBlockNo$[ebp]
  0017d	8b 9d bc fd ff
	ff		 mov	 ebx, DWORD PTR _blockCount$1$[ebp]
  00183	8b b5 b8 fd ff
	ff		 mov	 esi, DWORD PTR _blockCount$2$[ebp]
  00189	2b da		 sub	 ebx, edx

; 186  : 		startBlock = 0;
; 187  : 		dataUnitNo++;

  0018b	8b 8d b4 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$1$[ebp]
  00191	83 de 00	 sbb	 esi, 0
  00194	89 9d bc fd ff
	ff		 mov	 DWORD PTR _blockCount$1$[ebp], ebx
  0019a	33 c0		 xor	 eax, eax
  0019c	89 b5 b8 fd ff
	ff		 mov	 DWORD PTR _blockCount$2$[ebp], esi
  001a2	83 c1 01	 add	 ecx, 1
  001a5	89 45 18	 mov	 DWORD PTR _startCipherBlockNo$[ebp], eax

; 188  : 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);

  001a8	8b d1		 mov	 edx, ecx
  001aa	89 8d b4 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$1$[ebp], ecx
  001b0	11 85 c4 fd ff
	ff		 adc	 DWORD PTR _dataUnitNo$2$[ebp], eax
  001b6	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$2$[ebp]
  001bc	89 55 ec	 mov	 DWORD PTR _byteBufUnitNo$[ebp], edx
  001bf	89 4d f0	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx
  001c2	85 f6		 test	 esi, esi
  001c4	0f 87 fd fe ff
	ff		 ja	 $LN13@EncryptBuf

; 121  : 
; 122  : 	while (blockCount > 0)

  001ca	72 08		 jb	 SHORT $LN40@EncryptBuf
  001cc	85 db		 test	 ebx, ebx
  001ce	0f 85 de fe ff
	ff		 jne	 $LL2@EncryptBuf
$LN40@EncryptBuf:
  001d4	5f		 pop	 edi

; 189  : 	}
; 190  : 	FAST_ERASE32(whiteningValue, sizeof(whiteningValue));

  001d5	89 45 f4	 mov	 DWORD PTR _whiteningValue$[ebp], eax

; 191  : }

  001d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001db	5e		 pop	 esi
  001dc	33 cd		 xor	 ecx, ebp
  001de	5b		 pop	 ebx
  001df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e4	8b e5		 mov	 esp, ebp
  001e6	5d		 pop	 ebp
  001e7	c3		 ret	 0
_EncryptBufferXTS8Byte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\xts.c
;	COMDAT _EncryptBufferXTSNonParallel
_TEXT	SEGMENT
_ks$GSCopy$1$ = -52					; size = 4
_ks2$GSCopy$1$ = -48					; size = 4
_blockCount$2$ = -44					; size = 4
_blockCount$1$ = -40					; size = 4
_endBlock$1$ = -36					; size = 4
_block$1$ = -32						; size = 4
_dataUnitNo$2$ = -28					; size = 4
_dataUnitNo$1$ = -24					; size = 4
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTSNonParallel PROC			; COMDAT

; 373  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  00013	89 45 cc	 mov	 DWORD PTR _ks$GSCopy$1$[ebp], eax
  00016	8b 45 20	 mov	 eax, DWORD PTR _ks2$[ebp]
  00019	89 45 d0	 mov	 DWORD PTR _ks2$GSCopy$1$[ebp], eax

; 374  : 	unsigned __int8 finalCarry;
; 375  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 376  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 377  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 378  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 379  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 380  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 381  : 
; 382  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 383  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 384  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 385  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 386  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 387  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 388  : 
; 389  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 390  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 391  : 	dataUnitNo = startDataUnitNo->Value;

  0001c	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  0001f	57		 push	 edi
  00020	8b 7d 08	 mov	 edi, DWORD PTR _buffer$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00028	89 45 e4	 mov	 DWORD PTR _dataUnitNo$2$[ebp], eax
  0002b	89 4d e8	 mov	 DWORD PTR _dataUnitNo$1$[ebp], ecx

; 392  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 393  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 394  : 
; 395  : 	if (length % BYTES_PER_XTS_BLOCK)

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00031	8b c1		 mov	 eax, ecx
  00033	83 e0 0f	 and	 eax, 15			; 0000000fH
  00036	83 c8 00	 or	 eax, 0
  00039	74 07		 je	 SHORT $LN12@EncryptBuf

; 396  : 		GST_THROW_FATAL_EXCEPTION;

  0003b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN12@EncryptBuf:

; 397  : 
; 398  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00042	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00045	0f ac d1 04	 shrd	 ecx, edx, 4
  00049	c1 ea 04	 shr	 edx, 4
  0004c	89 4d d8	 mov	 DWORD PTR _blockCount$1$[ebp], ecx
  0004f	89 55 d4	 mov	 DWORD PTR _blockCount$2$[ebp], edx

; 399  : 
; 400  : 	// Process all blocks in the buffer
; 401  : 	while (blockCount > 0)

  00052	85 d2		 test	 edx, edx
  00054	75 08		 jne	 SHORT $LN42@EncryptBuf
  00056	85 c9		 test	 ecx, ecx
  00058	0f 84 2c 01 00
	00		 je	 $LN9@EncryptBuf
$LN42@EncryptBuf:
  0005e	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00061	53		 push	 ebx
  00062	56		 push	 esi
$LL2@EncryptBuf:

; 402  : 	{
; 403  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00063	85 d2		 test	 edx, edx
  00065	77 0c		 ja	 SHORT $LN13@EncryptBuf
  00067	72 05		 jb	 SHORT $LN35@EncryptBuf
  00069	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0006c	73 05		 jae	 SHORT $LN13@EncryptBuf
$LN35@EncryptBuf:

; 404  : 			endBlock = startBlock + (unsigned int) blockCount;

  0006e	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]
  00071	eb 05		 jmp	 SHORT $LN48@EncryptBuf
$LN13@EncryptBuf:

; 405  : 		else
; 406  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00073	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
$LN48@EncryptBuf:

; 407  : 
; 408  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 409  : 
; 410  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 411  : 		// whitening value for this data unit)
; 412  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  00078	8b 45 e8	 mov	 eax, DWORD PTR _dataUnitNo$1$[ebp]
  0007b	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]

; 413  : 		*(whiteningValuePtr64 + 1) = 0;
; 414  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0007e	ff 75 d0	 push	 DWORD PTR _ks2$GSCopy$1$[ebp]
  00081	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  00084	0f 57 c0	 xorps	 xmm0, xmm0
  00087	8b 45 e4	 mov	 eax, DWORD PTR _dataUnitNo$2$[ebp]
  0008a	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  0008d	8b c6		 mov	 eax, esi
  0008f	50		 push	 eax
  00090	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00093	89 5d dc	 mov	 DWORD PTR _endBlock$1$[ebp], ebx
  00096	66 0f 13 45 f4	 movlpd	 QWORD PTR _whiteningValue$[ebp+8], xmm0
  0009b	e8 00 00 00 00	 call	 _EncipherBlock

; 415  : 
; 416  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 417  : 		// encrypt all relevant blocks in this data unit
; 418  : 		for (block = 0; block < endBlock; block++)

  000a0	33 c0		 xor	 eax, eax
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a5	89 45 e0	 mov	 DWORD PTR _block$1$[ebp], eax
  000a8	85 db		 test	 ebx, ebx
  000aa	0f 84 a6 00 00
	00		 je	 $LN5@EncryptBuf
$LL6@EncryptBuf:

; 419  : 		{
; 420  : 			if (block >= startBlock)

  000b0	3b 45 18	 cmp	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  000b3	72 42		 jb	 SHORT $LN15@EncryptBuf

; 421  : 			{
; 422  : 				// Pre-whitening
; 423  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000b5	8b 06		 mov	 eax, DWORD PTR [esi]
  000b7	31 07		 xor	 DWORD PTR [edi], eax
  000b9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000bc	83 c6 08	 add	 esi, 8
  000bf	31 47 04	 xor	 DWORD PTR [edi+4], eax

; 424  : 				*bufPtr-- ^= *whiteningValuePtr64--;
; 425  : 
; 426  : 				// Actual encryption
; 427  : 				EncipherBlock (cipher, bufPtr, ks);

  000c2	ff 75 cc	 push	 DWORD PTR _ks$GSCopy$1$[ebp]
  000c5	8b 06		 mov	 eax, DWORD PTR [esi]
  000c7	31 47 08	 xor	 DWORD PTR [edi+8], eax
  000ca	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000cd	31 47 0c	 xor	 DWORD PTR [edi+12], eax
  000d0	57		 push	 edi
  000d1	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  000d4	e8 00 00 00 00	 call	 _EncipherBlock

; 428  : 
; 429  : 				// Post-whitening
; 430  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000d9	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000df	31 07		 xor	 DWORD PTR [edi], eax
  000e1	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  000e4	31 47 04	 xor	 DWORD PTR [edi+4], eax

; 431  : 				*bufPtr++ ^= *whiteningValuePtr64;

  000e7	8b 06		 mov	 eax, DWORD PTR [esi]
  000e9	31 47 08	 xor	 DWORD PTR [edi+8], eax
  000ec	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ef	31 47 0c	 xor	 DWORD PTR [edi+12], eax
  000f2	83 c7 10	 add	 edi, 16			; 00000010H

; 432  : 			}

  000f5	eb 03		 jmp	 SHORT $LN16@EncryptBuf
$LN15@EncryptBuf:

; 433  : 			else
; 434  : 				whiteningValuePtr64++;

  000f7	83 c6 08	 add	 esi, 8
$LN16@EncryptBuf:

; 435  : 
; 436  : 			// Derive the next whitening value
; 437  : 
; 438  : #if BYTE_ORDER == LITTLE_ENDIAN
; 439  : 
; 440  : 			// Little-endian platforms
; 441  : 
; 442  : 			finalCarry = 

  000fa	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000fd	8b 06		 mov	 eax, DWORD PTR [esi]
  000ff	85 c9		 test	 ecx, ecx
  00101	7f 0a		 jg	 SHORT $LN19@EncryptBuf
  00103	7c 04		 jl	 SHORT $LN36@EncryptBuf
  00105	85 c0		 test	 eax, eax
  00107	73 04		 jae	 SHORT $LN19@EncryptBuf
$LN36@EncryptBuf:
  00109	b3 87		 mov	 bl, 135			; 00000087H
  0010b	eb 02		 jmp	 SHORT $LN20@EncryptBuf
$LN19@EncryptBuf:
  0010d	32 db		 xor	 bl, bl
$LN20@EncryptBuf:

; 443  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 444  : 				135 : 0;
; 445  : 
; 446  : 			*whiteningValuePtr64-- <<= 1;

  0010f	0f a4 c1 01	 shld	 ecx, eax, 1
  00113	03 c0		 add	 eax, eax
  00115	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00118	89 06		 mov	 DWORD PTR [esi], eax
  0011a	83 ee 08	 sub	 esi, 8

; 447  : 
; 448  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  0011d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00120	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00122	85 d2		 test	 edx, edx
  00124	7f 10		 jg	 SHORT $LN17@EncryptBuf
  00126	7c 04		 jl	 SHORT $LN37@EncryptBuf
  00128	85 c9		 test	 ecx, ecx
  0012a	73 0a		 jae	 SHORT $LN17@EncryptBuf
$LN37@EncryptBuf:

; 449  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0012c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0012f	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00133	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN17@EncryptBuf:

; 450  : 
; 451  : 			*whiteningValuePtr64 <<= 1;

  00136	8b 45 e0	 mov	 eax, DWORD PTR _block$1$[ebp]
  00139	0f a4 ca 01	 shld	 edx, ecx, 1
  0013d	40		 inc	 eax
  0013e	03 c9		 add	 ecx, ecx
  00140	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00143	89 0e		 mov	 DWORD PTR [esi], ecx

; 452  : #else
; 453  : 
; 454  : 			// Big-endian platforms
; 455  : 
; 456  : 			finalCarry = 
; 457  : 				(*whiteningValuePtr64 & 0x80) ?
; 458  : 				135 : 0;
; 459  : 
; 460  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 461  : 
; 462  : 			whiteningValuePtr64--;
; 463  : 
; 464  : 			if (*whiteningValuePtr64 & 0x80)
; 465  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 466  : 
; 467  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 468  : #endif
; 469  : 
; 470  : 			whiteningValue[0] ^= finalCarry;

  00145	30 5d ec	 xor	 BYTE PTR _whiteningValue$[ebp], bl
  00148	8b 5d dc	 mov	 ebx, DWORD PTR _endBlock$1$[ebp]
  0014b	89 45 e0	 mov	 DWORD PTR _block$1$[ebp], eax
  0014e	3b c3		 cmp	 eax, ebx
  00150	0f 82 5a ff ff
	ff		 jb	 $LL6@EncryptBuf
$LN5@EncryptBuf:

; 471  : 		}
; 472  : 
; 473  : 		blockCount -= endBlock - startBlock;

  00156	2b 5d 18	 sub	 ebx, DWORD PTR _startCipherBlockNo$[ebp]
  00159	8b 4d d8	 mov	 ecx, DWORD PTR _blockCount$1$[ebp]
  0015c	8b 55 d4	 mov	 edx, DWORD PTR _blockCount$2$[ebp]
  0015f	2b cb		 sub	 ecx, ebx
  00161	89 4d d8	 mov	 DWORD PTR _blockCount$1$[ebp], ecx
  00164	83 da 00	 sbb	 edx, 0

; 474  : 		startBlock = 0;

  00167	33 c0		 xor	 eax, eax

; 475  : 		dataUnitNo++;

  00169	83 45 e8 01	 add	 DWORD PTR _dataUnitNo$1$[ebp], 1
  0016d	89 55 d4	 mov	 DWORD PTR _blockCount$2$[ebp], edx
  00170	11 45 e4	 adc	 DWORD PTR _dataUnitNo$2$[ebp], eax
  00173	89 45 18	 mov	 DWORD PTR _startCipherBlockNo$[ebp], eax
  00176	85 d2		 test	 edx, edx
  00178	0f 87 f5 fe ff
	ff		 ja	 $LN13@EncryptBuf

; 399  : 
; 400  : 	// Process all blocks in the buffer
; 401  : 	while (blockCount > 0)

  0017e	72 08		 jb	 SHORT $LN46@EncryptBuf
  00180	85 c9		 test	 ecx, ecx
  00182	0f 85 db fe ff
	ff		 jne	 $LL2@EncryptBuf
$LN46@EncryptBuf:
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx
$LN9@EncryptBuf:

; 476  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 477  : 	}
; 478  : 
; 479  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  0018a	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  0018d	b9 02 00 00 00	 mov	 ecx, 2
  00192	5f		 pop	 edi
  00193	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL10@EncryptBuf:
  001a0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001a6	8d 40 08	 lea	 eax, DWORD PTR [eax+8]
  001a9	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [eax-4], 0
  001b0	83 e9 01	 sub	 ecx, 1
  001b3	75 eb		 jne	 SHORT $LL10@EncryptBuf

; 480  : }

  001b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b8	33 cd		 xor	 ecx, ebp
  001ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
_EncryptBufferXTSNonParallel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\xts.c
;	COMDAT _EncryptBufferXTSParallel
_TEXT	SEGMENT
_ks$GSCopy$1$ = -572					; size = 4
_ks2$GSCopy$1$ = -568					; size = 4
_blockCount$2$ = -564					; size = 4
_blockCount$1$ = -560					; size = 4
_block$1$ = -556					; size = 4
_dataUnitNo$2$ = -552					; size = 4
_dataUnitNo$1$ = -548					; size = 4
_bufPtr$1$ = -544					; size = 4
_endBlock$1$ = -540					; size = 4
_finalCarry$1$ = -533					; size = 1
_whiteningValues$ = -532				; size = 512
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTSParallel PROC				; COMDAT

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 02 00
	00		 sub	 esp, 572		; 0000023cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  00016	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _ks$GSCopy$1$[ebp], eax
  0001c	8b 45 20	 mov	 eax, DWORD PTR _ks2$[ebp]
  0001f	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _ks2$GSCopy$1$[ebp], eax

; 218  : 	unsigned __int8 finalCarry;
; 219  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 220  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 221  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 222  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 223  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 224  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 225  : 	unsigned __int64 *dataUnitBufPtr;
; 226  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 227  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 228  : 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 229  : 
; 230  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 231  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 232  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 233  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 234  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 235  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 236  : 
; 237  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 238  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 239  : 	dataUnitNo = startDataUnitNo->Value;

  00025	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00028	57		 push	 edi
  00029	8b 7d 08	 mov	 edi, DWORD PTR _buffer$[ebp]
  0002c	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _bufPtr$1$[ebp], edi
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00037	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$2$[ebp], eax
  0003d	89 8d dc fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$1$[ebp], ecx

; 240  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 241  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 242  : 
; 243  : 	if (length % BYTES_PER_XTS_BLOCK)

  00043	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00046	8b c1		 mov	 eax, ecx
  00048	83 e0 0f	 and	 eax, 15			; 0000000fH
  0004b	83 c8 00	 or	 eax, 0
  0004e	74 07		 je	 SHORT $LN23@EncryptBuf

; 244  : 		GST_THROW_FATAL_EXCEPTION;

  00050	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN23@EncryptBuf:

; 245  : 
; 246  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00057	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  0005a	0f ac d1 04	 shrd	 ecx, edx, 4
  0005e	c1 ea 04	 shr	 edx, 4
  00061	89 8d d0 fd ff
	ff		 mov	 DWORD PTR _blockCount$1$[ebp], ecx
  00067	89 95 cc fd ff
	ff		 mov	 DWORD PTR _blockCount$2$[ebp], edx

; 247  : 
; 248  : 	// Process all blocks in the buffer
; 249  : 	while (blockCount > 0)

  0006d	85 d2		 test	 edx, edx
  0006f	75 08		 jne	 SHORT $LN89@EncryptBuf
  00071	85 c9		 test	 ecx, ecx
  00073	0f 84 e6 01 00
	00		 je	 $LN15@EncryptBuf
$LN89@EncryptBuf:
  00079	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  0007c	53		 push	 ebx
  0007d	56		 push	 esi
  0007e	66 90		 npad	 2
$LL2@EncryptBuf:

; 250  : 	{
; 251  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00080	85 d2		 test	 edx, edx
  00082	77 11		 ja	 SHORT $LN24@EncryptBuf
  00084	72 05		 jb	 SHORT $LN79@EncryptBuf
  00086	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00089	73 0a		 jae	 SHORT $LN24@EncryptBuf
$LN79@EncryptBuf:

; 252  : 			endBlock = startBlock + (unsigned int) blockCount;

  0008b	03 c1		 add	 eax, ecx
  0008d	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _endBlock$1$[ebp], eax
  00093	eb 0a		 jmp	 SHORT $LN25@EncryptBuf
$LN24@EncryptBuf:

; 253  : 		else
; 254  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00095	c7 85 e4 fd ff
	ff 20 00 00 00	 mov	 DWORD PTR _endBlock$1$[ebp], 32 ; 00000020H
$LN25@EncryptBuf:

; 255  : 
; 256  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 257  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 258  : 
; 259  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 260  : 		// whitening value for this data unit)
; 261  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0009f	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$1$[ebp]
  000a5	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]

; 262  : 		*(whiteningValuePtr64 + 1) = 0;
; 263  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000a8	ff b5 c8 fd ff
	ff		 push	 DWORD PTR _ks2$GSCopy$1$[ebp]
  000ae	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000b1	8d 5d e4	 lea	 ebx, DWORD PTR _whiteningValues$[ebp+504]
  000b4	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$2$[ebp]
  000ba	0f 57 c0	 xorps	 xmm0, xmm0
  000bd	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000c0	8b c6		 mov	 eax, esi
  000c2	50		 push	 eax
  000c3	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  000c6	66 0f 13 45 f4	 movlpd	 QWORD PTR _whiteningValue$[ebp+8], xmm0
  000cb	e8 00 00 00 00	 call	 _EncipherBlock

; 264  : 
; 265  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 266  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 267  : 		for (block = 0; block < endBlock; block++)

  000d0	33 c0		 xor	 eax, eax
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d5	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _block$1$[ebp], eax
  000db	39 85 e4 fd ff
	ff		 cmp	 DWORD PTR _endBlock$1$[ebp], eax
  000e1	0f 86 a6 00 00
	00		 jbe	 $LN5@EncryptBuf
  000e7	8b 7d 18	 mov	 edi, DWORD PTR _startCipherBlockNo$[ebp]
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL6@EncryptBuf:

; 268  : 		{
; 269  : 			if (block >= startBlock)

  000f0	3b c7		 cmp	 eax, edi
  000f2	72 1d		 jb	 SHORT $LN26@EncryptBuf

; 270  : 			{
; 271  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  000f4	8b 06		 mov	 eax, DWORD PTR [esi]
  000f6	89 03		 mov	 DWORD PTR [ebx], eax
  000f8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000fb	83 c6 08	 add	 esi, 8
  000fe	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 272  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  00101	8b 06		 mov	 eax, DWORD PTR [esi]
  00103	89 43 f8	 mov	 DWORD PTR [ebx-8], eax
  00106	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00109	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  0010c	83 eb 10	 sub	 ebx, 16			; 00000010H

; 273  : 			}

  0010f	eb 03		 jmp	 SHORT $LN27@EncryptBuf
$LN26@EncryptBuf:

; 274  : 			else
; 275  : 				whiteningValuePtr64++;

  00111	83 c6 08	 add	 esi, 8
$LN27@EncryptBuf:

; 276  : 
; 277  : 			// Derive the next whitening value
; 278  : 
; 279  : #if BYTE_ORDER == LITTLE_ENDIAN
; 280  : 
; 281  : 			// Little-endian platforms
; 282  : 
; 283  : 			finalCarry = 

  00114	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00117	8b 06		 mov	 eax, DWORD PTR [esi]
  00119	85 c9		 test	 ecx, ecx
  0011b	7f 0f		 jg	 SHORT $LN30@EncryptBuf
  0011d	7c 04		 jl	 SHORT $LN80@EncryptBuf
  0011f	85 c0		 test	 eax, eax
  00121	73 09		 jae	 SHORT $LN30@EncryptBuf
$LN80@EncryptBuf:
  00123	c6 85 eb fd ff
	ff 87		 mov	 BYTE PTR _finalCarry$1$[ebp], 135 ; 00000087H
  0012a	eb 07		 jmp	 SHORT $LN31@EncryptBuf
$LN30@EncryptBuf:
  0012c	c6 85 eb fd ff
	ff 00		 mov	 BYTE PTR _finalCarry$1$[ebp], 0
$LN31@EncryptBuf:

; 284  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 285  : 				135 : 0;
; 286  : 
; 287  : 			*whiteningValuePtr64-- <<= 1;

  00133	0f a4 c1 01	 shld	 ecx, eax, 1
  00137	03 c0		 add	 eax, eax
  00139	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0013c	89 06		 mov	 DWORD PTR [esi], eax
  0013e	83 ee 08	 sub	 esi, 8

; 288  : 
; 289  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00141	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00144	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00146	85 d2		 test	 edx, edx
  00148	7f 10		 jg	 SHORT $LN28@EncryptBuf
  0014a	7c 04		 jl	 SHORT $LN81@EncryptBuf
  0014c	85 c9		 test	 ecx, ecx
  0014e	73 0a		 jae	 SHORT $LN28@EncryptBuf
$LN81@EncryptBuf:

; 290  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00150	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00153	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00157	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN28@EncryptBuf:

; 291  : 
; 292  : 			*whiteningValuePtr64 <<= 1;
; 293  : #else
; 294  : 
; 295  : 			// Big-endian platforms
; 296  : 
; 297  : 			finalCarry = 
; 298  : 				(*whiteningValuePtr64 & 0x80) ?
; 299  : 				135 : 0;
; 300  : 
; 301  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 302  : 
; 303  : 			whiteningValuePtr64--;
; 304  : 
; 305  : 			if (*whiteningValuePtr64 & 0x80)
; 306  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 307  : 
; 308  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 309  : #endif
; 310  : 
; 311  : 			whiteningValue[0] ^= finalCarry;

  0015a	8a 85 eb fd ff
	ff		 mov	 al, BYTE PTR _finalCarry$1$[ebp]
  00160	0f a4 ca 01	 shld	 edx, ecx, 1
  00164	03 c9		 add	 ecx, ecx
  00166	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00169	89 0e		 mov	 DWORD PTR [esi], ecx
  0016b	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  0016e	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _block$1$[ebp]
  00174	40		 inc	 eax
  00175	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _block$1$[ebp], eax
  0017b	3b 85 e4 fd ff
	ff		 cmp	 eax, DWORD PTR _endBlock$1$[ebp]
  00181	0f 82 69 ff ff
	ff		 jb	 $LL6@EncryptBuf
  00187	8b bd e0 fd ff
	ff		 mov	 edi, DWORD PTR _bufPtr$1$[ebp]
$LN5@EncryptBuf:

; 315  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 316  : 
; 317  : 		// Encrypt all blocks in this data unit
; 318  : 
; 319  : 		for (block = startBlock; block < endBlock; block++)

  0018d	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00190	8d 4d e4	 lea	 ecx, DWORD PTR _whiteningValues$[ebp+504]
  00193	8b b5 e4 fd ff
	ff		 mov	 esi, DWORD PTR _endBlock$1$[ebp]
  00199	8b df		 mov	 ebx, edi
  0019b	3b c6		 cmp	 eax, esi
  0019d	73 29		 jae	 SHORT $LN8@EncryptBuf

; 312  : 		}
; 313  : 
; 314  : 		dataUnitBufPtr = bufPtr;

  0019f	8b d6		 mov	 edx, esi
  001a1	2b d0		 sub	 edx, eax
$LL9@EncryptBuf:

; 320  : 		{
; 321  : 			// Pre-whitening
; 322  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001a3	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a5	8d 7f 10	 lea	 edi, DWORD PTR [edi+16]
  001a8	31 47 f0	 xor	 DWORD PTR [edi-16], eax
  001ab	8d 49 f0	 lea	 ecx, DWORD PTR [ecx-16]
  001ae	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  001b1	31 47 f4	 xor	 DWORD PTR [edi-12], eax
  001b4	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001b7	31 47 f8	 xor	 DWORD PTR [edi-8], eax
  001ba	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  001bd	31 47 fc	 xor	 DWORD PTR [edi-4], eax
  001c0	83 ea 01	 sub	 edx, 1
  001c3	75 de		 jne	 SHORT $LL9@EncryptBuf
  001c5	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
$LN8@EncryptBuf:

; 323  : 			*bufPtr++ ^= *whiteningValuesPtr64--;
; 324  : 		}
; 325  : 
; 326  : 		// Actual encryption
; 327  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  001c8	2b f0		 sub	 esi, eax
  001ca	56		 push	 esi
  001cb	ff b5 c4 fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$1$[ebp]
  001d1	53		 push	 ebx
  001d2	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  001d5	e8 00 00 00 00	 call	 _EncipherBlocks

; 328  : 		
; 329  : 		bufPtr = dataUnitBufPtr;
; 330  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 331  : 
; 332  : 		for (block = startBlock; block < endBlock; block++)

  001da	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _endBlock$1$[ebp]
  001e0	8d 4d e4	 lea	 ecx, DWORD PTR _whiteningValues$[ebp+504]
  001e3	83 c4 10	 add	 esp, 16			; 00000010H
  001e6	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _bufPtr$1$[ebp], ebx
  001ec	8b fb		 mov	 edi, ebx
  001ee	39 45 18	 cmp	 DWORD PTR _startCipherBlockNo$[ebp], eax
  001f1	73 29		 jae	 SHORT $LN11@EncryptBuf

; 323  : 			*bufPtr++ ^= *whiteningValuesPtr64--;
; 324  : 		}
; 325  : 
; 326  : 		// Actual encryption
; 327  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  001f3	8b d6		 mov	 edx, esi
$LL12@EncryptBuf:

; 333  : 		{
; 334  : 			// Post-whitening
; 335  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001f5	8b 01		 mov	 eax, DWORD PTR [ecx]
  001f7	8d 49 f0	 lea	 ecx, DWORD PTR [ecx-16]
  001fa	31 07		 xor	 DWORD PTR [edi], eax
  001fc	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  001ff	31 47 04	 xor	 DWORD PTR [edi+4], eax
  00202	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00205	31 47 08	 xor	 DWORD PTR [edi+8], eax
  00208	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0020b	31 47 0c	 xor	 DWORD PTR [edi+12], eax
  0020e	83 c7 10	 add	 edi, 16			; 00000010H
  00211	83 ea 01	 sub	 edx, 1
  00214	75 df		 jne	 SHORT $LL12@EncryptBuf
  00216	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _bufPtr$1$[ebp], edi
$LN11@EncryptBuf:

; 336  : 			*bufPtr++ ^= *whiteningValuesPtr64--;
; 337  : 		}
; 338  : 
; 339  : 		blockCount -= endBlock - startBlock;

  0021c	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$1$[ebp]
  00222	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _blockCount$2$[ebp]
  00228	2b ce		 sub	 ecx, esi
  0022a	89 8d d0 fd ff
	ff		 mov	 DWORD PTR _blockCount$1$[ebp], ecx
  00230	83 da 00	 sbb	 edx, 0

; 340  : 		startBlock = 0;

  00233	33 c0		 xor	 eax, eax

; 341  : 		dataUnitNo++;

  00235	83 85 dc fd ff
	ff 01		 add	 DWORD PTR _dataUnitNo$1$[ebp], 1
  0023c	89 95 cc fd ff
	ff		 mov	 DWORD PTR _blockCount$2$[ebp], edx
  00242	11 85 d8 fd ff
	ff		 adc	 DWORD PTR _dataUnitNo$2$[ebp], eax
  00248	89 45 18	 mov	 DWORD PTR _startCipherBlockNo$[ebp], eax
  0024b	85 d2		 test	 edx, edx
  0024d	0f 87 42 fe ff
	ff		 ja	 $LN24@EncryptBuf

; 247  : 
; 248  : 	// Process all blocks in the buffer
; 249  : 	while (blockCount > 0)

  00253	72 08		 jb	 SHORT $LN96@EncryptBuf
  00255	85 c9		 test	 ecx, ecx
  00257	0f 85 23 fe ff
	ff		 jne	 $LL2@EncryptBuf
$LN96@EncryptBuf:
  0025d	5e		 pop	 esi
  0025e	5b		 pop	 ebx
$LN15@EncryptBuf:

; 342  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 343  : 	}
; 344  : 
; 345  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  0025f	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00262	b9 02 00 00 00	 mov	 ecx, 2
  00267	5f		 pop	 edi
  00268	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL16@EncryptBuf:
  00270	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00276	8d 40 08	 lea	 eax, DWORD PTR [eax+8]
  00279	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [eax-4], 0
  00280	83 e9 01	 sub	 ecx, 1
  00283	75 eb		 jne	 SHORT $LL16@EncryptBuf

; 346  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  00285	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  0028b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
$LL21@EncryptBuf:
  00290	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00296	8d 40 08	 lea	 eax, DWORD PTR [eax+8]
  00299	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [eax-4], 0
  002a0	83 e9 01	 sub	 ecx, 1
  002a3	75 eb		 jne	 SHORT $LL21@EncryptBuf

; 347  : }

  002a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a8	33 cd		 xor	 ecx, ebp
  002aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002af	8b e5		 mov	 esp, ebp
  002b1	5d		 pop	 ebp
  002b2	c3		 ret	 0
_EncryptBufferXTSParallel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\xts.c
;	COMDAT _EncryptBufferXTS
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTS PROC					; COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 73   : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00004	8b 75 24	 mov	 esi, DWORD PTR _cipher$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization
  0000d	83 c4 04	 add	 esp, 4

; 74   : 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00010	56		 push	 esi
  00011	ff 75 20	 push	 DWORD PTR _ks2$[ebp]
  00014	ff 75 1c	 push	 DWORD PTR _ks$[ebp]
  00017	ff 75 18	 push	 DWORD PTR _startCipherBlockNo$[ebp]
  0001a	ff 75 14	 push	 DWORD PTR _startDataUnitNo$[ebp]
  0001d	ff 75 10	 push	 DWORD PTR _length$[ebp+4]
  00020	ff 75 0c	 push	 DWORD PTR _length$[ebp]
  00023	ff 75 08	 push	 DWORD PTR _buffer$[ebp]
  00026	85 c0		 test	 eax, eax
  00028	74 0b		 je	 SHORT $LN2@EncryptBuf
  0002a	e8 00 00 00 00	 call	 _EncryptBufferXTSParallel

; 75   : 	else
; 76   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0002f	83 c4 20	 add	 esp, 32			; 00000020H
  00032	5e		 pop	 esi

; 77   : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN2@EncryptBuf:

; 75   : 	else
; 76   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00035	e8 00 00 00 00	 call	 _EncryptBufferXTSNonParallel
  0003a	83 c4 20	 add	 esp, 32			; 00000020H
  0003d	5e		 pop	 esi

; 77   : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_EncryptBufferXTS ENDP
_TEXT	ENDS
END
