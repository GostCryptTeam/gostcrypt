; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\Pkcs5.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_hmac_whirlpool
PUBLIC	_derive_u_whirlpool
PUBLIC	_derive_key_whirlpool
PUBLIC	_hmac_gosthash
PUBLIC	_derive_u_gosthash
PUBLIC	_derive_key_gosthash
PUBLIC	_hmac_stribog
PUBLIC	_derive_u_stribog
PUBLIC	_derive_key_stribog
PUBLIC	_get_pkcs5_iteration_count
PUBLIC	_get_pkcs5_prf_name
PUBLIC	_hmac_truncate
PUBLIC	??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@		; `string'
PUBLIC	??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@ ; `string'
PUBLIC	??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@ ; `string'
PUBLIC	??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@		; `string'
PUBLIC	__xmm@36363636363636363636363636363636
PUBLIC	__xmm@5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
EXTRN	_WHIRLPOOL_add:PROC
EXTRN	_WHIRLPOOL_finalize:PROC
EXTRN	_WHIRLPOOL_init:PROC
EXTRN	_GOSTHASH_init:PROC
EXTRN	_GOSTHASH_add:PROC
EXTRN	_GOSTHASH_finalize:PROC
EXTRN	_STRIBOG_init:PROC
EXTRN	_STRIBOG_add:PROC
EXTRN	_STRIBOG_finalize:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT __xmm@5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
CONST	SEGMENT
__xmm@5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c DB '\\\\\\\\\\\\\\\\'
CONST	ENDS
;	COMDAT __xmm@36363636363636363636363636363636
CONST	SEGMENT
__xmm@36363636363636363636363636363636 DB '6666666666666666'
CONST	ENDS
;	COMDAT ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@
CONST	SEGMENT
??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@ DB '(Unknown)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@
CONST	SEGMENT
??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@ DB 'HMAC-GOST R 34.11-9'
	DB	'4', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@
CONST	SEGMENT
??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@ DB 'HMAC-GOST R 34.11'
	DB	'-2012', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@
CONST	SEGMENT
??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@ DB 'HMAC-Whirlpool', 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _hmac_truncate
_TEXT	SEGMENT
_d1$ = 8						; size = 4
_d2$ = 12						; size = 4
_len$ = 16						; size = 4
_hmac_truncate PROC					; COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 53   : 	int i;
; 54   : 	for (i = 0; i < len; i++)

  00003	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	7e 18		 jle	 SHORT $LN3@hmac_trunc
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _d2$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _d1$[ebp]
  00011	2b f0		 sub	 esi, eax
$LL8@hmac_trunc:

; 55   : 		d2[i] = d1[i];

  00013	8a 0c 06	 mov	 cl, BYTE PTR [esi+eax]
  00016	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00019	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  0001c	83 ea 01	 sub	 edx, 1
  0001f	75 f2		 jne	 SHORT $LL8@hmac_trunc
  00021	5e		 pop	 esi
$LN3@hmac_trunc:

; 56   : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_hmac_truncate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _get_pkcs5_prf_name
_TEXT	SEGMENT
_pkcs5_prf_id$ = 8					; size = 4
_get_pkcs5_prf_name PROC				; COMDAT

; 592  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 	switch (pkcs5_prf_id)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pkcs5_prf_id$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	74 1f		 je	 SHORT $LN5@get_pkcs5_
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 13		 je	 SHORT $LN6@get_pkcs5_
  00010	83 e8 01	 sub	 eax, 1
  00013	74 07		 je	 SHORT $LN4@get_pkcs5_

; 601  : 	default:		
; 602  : 		return "(Unknown)";

  00015	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@

; 603  : 	}
; 604  : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
$LN4@get_pkcs5_:

; 594  : 	{
; 595  : 	case WHIRLPOOL:	
; 596  : 		return "HMAC-Whirlpool";

  0001c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@

; 603  : 	}
; 604  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN6@get_pkcs5_:

; 599  : 	case GOSTHASH:
; 600  : 		return "HMAC-GOST R 34.11-94";

  00023	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@KKLIMNLF@HMAC?9GOST?5R?534?411?994?$AA@

; 603  : 	}
; 604  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN5@get_pkcs5_:

; 597  : 	case STRIBOG:
; 598  : 		return "HMAC-GOST R 34.11-2012";

  0002a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BH@EMAMDDNI@HMAC?9GOST?5R?534?411?92012?$AA@

; 603  : 	}
; 604  : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_get_pkcs5_prf_name ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _get_pkcs5_iteration_count
_TEXT	SEGMENT
_pkcs5_prf_id$ = 8					; size = 4
_bBoot$ = 12						; size = 4
_get_pkcs5_iteration_count PROC				; COMDAT

; 617  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 618  : 	switch (pkcs5_prf_id)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pkcs5_prf_id$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	74 15		 je	 SHORT $LN5@get_pkcs5_
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 10		 je	 SHORT $LN5@get_pkcs5_
  00010	83 e8 01	 sub	 eax, 1
  00013	74 0b		 je	 SHORT $LN5@get_pkcs5_

; 624  : 	case GOSTHASH:
; 625  : 		return 1000;
; 626  : 	default:		
; 627  : 		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00015	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0

; 628  : 	}
; 629  : 	return 0;

  0001c	33 c0		 xor	 eax, eax

; 630  : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN5@get_pkcs5_:

; 619  : 	{
; 620  : 	case WHIRLPOOL:	
; 621  : 		return 1000;
; 622  : 	case STRIBOG:
; 623  : 		return 1000;

  00020	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H

; 630  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_get_pkcs5_iteration_count ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _derive_key_stribog
_TEXT	SEGMENT
_pwd$GSCopy$1$ = -76					; size = 4
_salt$GSCopy$1$ = -72					; size = 4
_u$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_stribog PROC				; COMDAT

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]

; 549  : 	char u[STRIBOG_DIGESTSIZE];
; 550  : 	int b, l, r;
; 551  : 
; 552  : 	if (dklen % STRIBOG_DIGESTSIZE)

  00013	8b 4d 20	 mov	 ecx, DWORD PTR _dklen$[ebp]
  00016	89 45 b4	 mov	 DWORD PTR _pwd$GSCopy$1$[ebp], eax
  00019	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0001c	89 45 b8	 mov	 DWORD PTR _salt$GSCopy$1$[ebp], eax
  0001f	8b c1		 mov	 eax, ecx
  00021	56		 push	 esi
  00022	8b 75 1c	 mov	 esi, DWORD PTR _dk$[ebp]
  00025	57		 push	 edi
  00026	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0002b	79 05		 jns	 SHORT $LN36@derive_key
  0002d	48		 dec	 eax
  0002e	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00031	40		 inc	 eax
$LN36@derive_key:

; 553  : 	{
; 554  : 		l = 1 + dklen / STRIBOG_DIGESTSIZE;

  00032	8b c1		 mov	 eax, ecx
  00034	99		 cdq
  00035	74 0c		 je	 SHORT $LN10@derive_key
  00037	83 e2 3f	 and	 edx, 63			; 0000003fH
  0003a	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  0003d	c1 ff 06	 sar	 edi, 6
  00040	47		 inc	 edi

; 555  : 	}

  00041	eb 09		 jmp	 SHORT $LN11@derive_key
$LN10@derive_key:

; 556  : 	else
; 557  : 	{
; 558  : 		l = dklen / STRIBOG_DIGESTSIZE;

  00043	83 e2 3f	 and	 edx, 63			; 0000003fH
  00046	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  00049	c1 ff 06	 sar	 edi, 6
$LN11@derive_key:

; 559  : 	}
; 560  : 
; 561  : 	r = dklen - (l - 1) * STRIBOG_DIGESTSIZE;
; 562  : 
; 563  : 	/* first l - 1 blocks */
; 564  : 	for (b = 1; b < l; b++)

  0004c	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
  0004f	8b c7		 mov	 eax, edi
  00051	c1 e0 06	 shl	 eax, 6
  00054	2b c8		 sub	 ecx, eax
  00056	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  00059	83 c1 40	 add	 ecx, 64			; 00000040H
  0005c	53		 push	 ebx
  0005d	bb 01 00 00 00	 mov	 ebx, 1
  00062	89 4d 20	 mov	 DWORD PTR _dklen$[ebp], ecx
  00065	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  00068	3b fb		 cmp	 edi, ebx
  0006a	7e 4d		 jle	 SHORT $LN3@derive_key
  0006c	0f 1f 40 00	 npad	 4
$LL4@derive_key:

; 565  : 	{
; 566  : 		derive_u_stribog (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00070	53		 push	 ebx
  00071	8d 55 bc	 lea	 edx, DWORD PTR _u$[ebp]
  00074	52		 push	 edx
  00075	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
  00078	50		 push	 eax
  00079	51		 push	 ecx
  0007a	ff 75 b8	 push	 DWORD PTR _salt$GSCopy$1$[ebp]
  0007d	52		 push	 edx
  0007e	ff 75 b4	 push	 DWORD PTR _pwd$GSCopy$1$[ebp]
  00081	e8 00 00 00 00	 call	 _derive_u_stribog

; 567  : 		memcpy (dk, u, STRIBOG_DIGESTSIZE);

  00086	0f 10 45 bc	 movups	 xmm0, XMMWORD PTR _u$[ebp]
  0008a	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0008d	43		 inc	 ebx
  0008e	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  00091	83 c4 1c	 add	 esp, 28			; 0000001cH
  00094	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00097	0f 10 45 cc	 movups	 xmm0, XMMWORD PTR _u$[ebp+16]
  0009b	0f 11 46 10	 movups	 XMMWORD PTR [esi+16], xmm0
  0009f	0f 10 45 dc	 movups	 xmm0, XMMWORD PTR _u$[ebp+32]
  000a3	0f 11 46 20	 movups	 XMMWORD PTR [esi+32], xmm0
  000a7	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _u$[ebp+48]
  000ab	0f 11 46 30	 movups	 XMMWORD PTR [esi+48], xmm0

; 568  : 		dk += STRIBOG_DIGESTSIZE;

  000af	83 c6 40	 add	 esi, 64			; 00000040H
  000b2	3b df		 cmp	 ebx, edi
  000b4	7c ba		 jl	 SHORT $LL4@derive_key
  000b6	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
$LN3@derive_key:

; 569  : 	}
; 570  : 
; 571  : 	/* last block */
; 572  : 	derive_u_stribog (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000b9	53		 push	 ebx
  000ba	8d 7d bc	 lea	 edi, DWORD PTR _u$[ebp]
  000bd	57		 push	 edi
  000be	50		 push	 eax
  000bf	51		 push	 ecx
  000c0	ff 75 b8	 push	 DWORD PTR _salt$GSCopy$1$[ebp]
  000c3	52		 push	 edx
  000c4	ff 75 b4	 push	 DWORD PTR _pwd$GSCopy$1$[ebp]
  000c7	e8 00 00 00 00	 call	 _derive_u_stribog

; 573  : 	memcpy (dk, u, r);

  000cc	ff 75 20	 push	 DWORD PTR _dklen$[ebp]
  000cf	8b c7		 mov	 eax, edi
  000d1	50		 push	 eax
  000d2	56		 push	 esi
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 28	 add	 esp, 40			; 00000028H

; 574  : 
; 575  : 
; 576  : 	/* Prevent possible leaks. */
; 577  : 	burn (u, sizeof(u));

  000db	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000e0	8b c7		 mov	 eax, edi
  000e2	8b f1		 mov	 esi, ecx
  000e4	8b d7		 mov	 edx, edi
  000e6	5b		 pop	 ebx
$LL14@derive_key:
  000e7	c6 02 00	 mov	 BYTE PTR [edx], 0
  000ea	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000ed	83 ee 01	 sub	 esi, 1
  000f0	75 f5		 jne	 SHORT $LL14@derive_key
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
$LL8@derive_key:
  000f4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000f7	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000fa	83 e9 01	 sub	 ecx, 1
  000fd	75 f5		 jne	 SHORT $LL8@derive_key

; 578  : }

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
_derive_key_stribog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _derive_u_stribog
_TEXT	SEGMENT
_pwd$GSCopy$1$ = -276					; size = 4
_counter$ = -272					; size = 4
_init$ = -268						; size = 128
_k$ = -140						; size = 64
_j$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_stribog PROC					; COMDAT

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 504  : 	char j[STRIBOG_DIGESTSIZE], k[STRIBOG_DIGESTSIZE];
; 505  : 	char init[128];
; 506  : 	char counter[4];
; 507  : 	int c, i;
; 508  : 
; 509  : 	/* iteration 1 */
; 510  : 	memset (counter, 0, 4);
; 511  : 	counter[3] = (char) b;

  00013	8a 45 20	 mov	 al, BYTE PTR _b$[ebp]
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  00019	53		 push	 ebx
  0001a	8b 5d 08	 mov	 ebx, DWORD PTR _pwd$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 14	 mov	 esi, DWORD PTR _salt_len$[ebp]
  00021	57		 push	 edi
  00022	8b 7d 1c	 mov	 edi, DWORD PTR _u$[ebp]

; 512  : 	memcpy (init, salt, salt_len);	/* salt */

  00025	56		 push	 esi
  00026	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _counter$[ebp], 0
  00030	88 85 f3 fe ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], al
  00036	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  0003c	51		 push	 ecx
  0003d	50		 push	 eax
  0003e	89 9d ec fe ff
	ff		 mov	 DWORD PTR _pwd$GSCopy$1$[ebp], ebx
  00044	e8 00 00 00 00	 call	 _memcpy

; 513  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00049	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  0004f	89 84 35 f4 fe
	ff ff		 mov	 DWORD PTR _init$[ebp+esi], eax

; 514  : 	hmac_stribog (pwd, pwd_len, init, salt_len + 4, j);

  00056	8d 45 b8	 lea	 eax, DWORD PTR _j$[ebp]
  00059	50		 push	 eax
  0005a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0005d	50		 push	 eax
  0005e	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00064	50		 push	 eax
  00065	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  00068	53		 push	 ebx
  00069	e8 00 00 00 00	 call	 _hmac_stribog

; 515  : 	memcpy (u, j, STRIBOG_DIGESTSIZE);

  0006e	0f 10 45 b8	 movups	 xmm0, XMMWORD PTR _j$[ebp]

; 516  : 
; 517  : 	/* remaining iterations */
; 518  : 	for (c = 1; c < iterations; c++)

  00072	8b 5d 18	 mov	 ebx, DWORD PTR _iterations$[ebp]
  00075	83 c4 20	 add	 esp, 32			; 00000020H
  00078	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0007b	0f 10 45 c8	 movups	 xmm0, XMMWORD PTR _j$[ebp+16]
  0007f	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  00083	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR _j$[ebp+32]
  00087	0f 11 47 20	 movups	 XMMWORD PTR [edi+32], xmm0
  0008b	0f 10 45 e8	 movups	 xmm0, XMMWORD PTR _j$[ebp+48]
  0008f	0f 11 47 30	 movups	 XMMWORD PTR [edi+48], xmm0
  00093	83 fb 01	 cmp	 ebx, 1
  00096	0f 8e c0 00 00
	00		 jle	 $LN10@derive_u_s
  0009c	8b f7		 mov	 esi, edi
  0009e	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  000a4	2b f0		 sub	 esi, eax
  000a6	4b		 dec	 ebx
$LL4@derive_u_s:

; 519  : 	{
; 520  : 		hmac_stribog (pwd, pwd_len, j, STRIBOG_DIGESTSIZE, k);

  000a7	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  000ad	50		 push	 eax
  000ae	6a 40		 push	 64			; 00000040H
  000b0	8d 45 b8	 lea	 eax, DWORD PTR _j$[ebp]
  000b3	50		 push	 eax
  000b4	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000b7	ff b5 ec fe ff
	ff		 push	 DWORD PTR _pwd$GSCopy$1$[ebp]
  000bd	e8 00 00 00 00	 call	 _hmac_stribog

; 524  : 			j[i] = k[i];

  000c2	8d 55 b8	 lea	 edx, DWORD PTR _j$[ebp]
  000c5	83 c4 14	 add	 esp, 20			; 00000014H
  000c8	8d 4f 3f	 lea	 ecx, DWORD PTR [edi+63]
  000cb	33 c0		 xor	 eax, eax
  000cd	3b d1		 cmp	 edx, ecx
  000cf	77 07		 ja	 SHORT $LN43@derive_u_s
  000d1	8d 55 f7	 lea	 edx, DWORD PTR _j$[ebp+63]
  000d4	3b d7		 cmp	 edx, edi
  000d6	73 18		 jae	 SHORT $LL90@derive_u_s
$LN43@derive_u_s:
  000d8	8d 55 b3	 lea	 edx, DWORD PTR _k$[ebp+63]
  000db	3b fa		 cmp	 edi, edx
  000dd	77 2c		 ja	 SHORT $LN61@derive_u_s
  000df	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  000e5	3b ca		 cmp	 ecx, edx
  000e7	72 22		 jb	 SHORT $LN61@derive_u_s
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL90@derive_u_s:

; 522  : 		{
; 523  : 			u[i] ^= k[i];

  000f0	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  000f6	03 c8		 add	 ecx, eax
  000f8	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  000fb	8a 09		 mov	 cl, BYTE PTR [ecx]
  000fd	30 0a		 xor	 BYTE PTR [edx], cl

; 524  : 			j[i] = k[i];

  000ff	88 4c 05 b8	 mov	 BYTE PTR _j$[ebp+eax], cl
  00103	40		 inc	 eax
  00104	83 f8 40	 cmp	 eax, 64			; 00000040H
  00107	7c e7		 jl	 SHORT $LL90@derive_u_s

; 521  : 		for (i = 0; i < STRIBOG_DIGESTSIZE; i++)

  00109	eb 48		 jmp	 SHORT $LN2@derive_u_s
$LN61@derive_u_s:

; 524  : 			j[i] = k[i];

  0010b	8d 55 b8	 lea	 edx, DWORD PTR _j$[ebp]
  0010e	2b d7		 sub	 edx, edi
$LL44@derive_u_s:

; 522  : 		{
; 523  : 			u[i] ^= k[i];

  00110	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  00116	03 c8		 add	 ecx, eax
  00118	0f 10 11	 movups	 xmm2, XMMWORD PTR [ecx]
  0011b	0f 10 04 0e	 movups	 xmm0, XMMWORD PTR [esi+ecx]
  0011f	0f 28 ca	 movaps	 xmm1, xmm2
  00122	66 0f ef c8	 pxor	 xmm1, xmm0
  00126	0f 11 0c 0e	 movups	 XMMWORD PTR [esi+ecx], xmm1
  0012a	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0012d	0f 10 41 10	 movups	 xmm0, XMMWORD PTR [ecx+16]
  00131	0f 11 54 05 b8	 movups	 XMMWORD PTR _j$[ebp+eax], xmm2
  00136	0f 10 54 05 84	 movups	 xmm2, XMMWORD PTR _k$[ebp+eax+16]
  0013b	83 c0 20	 add	 eax, 32			; 00000020H
  0013e	0f 28 ca	 movaps	 xmm1, xmm2
  00141	66 0f ef c8	 pxor	 xmm1, xmm0
  00145	0f 11 49 10	 movups	 XMMWORD PTR [ecx+16], xmm1
  00149	0f 11 54 0a 10	 movups	 XMMWORD PTR [edx+ecx+16], xmm2
  0014e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00151	7c bd		 jl	 SHORT $LL44@derive_u_s
$LN2@derive_u_s:

; 516  : 
; 517  : 	/* remaining iterations */
; 518  : 	for (c = 1; c < iterations; c++)

  00153	83 eb 01	 sub	 ebx, 1
  00156	0f 85 4b ff ff
	ff		 jne	 $LL4@derive_u_s
$LN10@derive_u_s:

; 525  : 		}
; 526  : 	}
; 527  : 
; 528  : 	/* Prevent possible leaks. */
; 529  : 	burn (j, sizeof(j));

  0015c	8d 45 b8	 lea	 eax, DWORD PTR _j$[ebp]
  0015f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00164	8b f1		 mov	 esi, ecx
  00166	8b d0		 mov	 edx, eax
  00168	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL20@derive_u_s:
  00170	c6 02 00	 mov	 BYTE PTR [edx], 0
  00173	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00176	83 ee 01	 sub	 esi, 1
  00179	75 f5		 jne	 SHORT $LL20@derive_u_s
  0017b	0f 1f 44 00 00	 npad	 5
$LL11@derive_u_s:
  00180	c6 00 00	 mov	 BYTE PTR [eax], 0
  00183	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00186	83 e9 01	 sub	 ecx, 1
  00189	75 f5		 jne	 SHORT $LL11@derive_u_s

; 530  : 	burn (k, sizeof(k));

  0018b	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  00191	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00196	8b f1		 mov	 esi, ecx
  00198	8b d0		 mov	 edx, eax
  0019a	66 0f 1f 44 00
	00		 npad	 6
$LL24@derive_u_s:
  001a0	c6 02 00	 mov	 BYTE PTR [edx], 0
  001a3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  001a6	83 ee 01	 sub	 esi, 1
  001a9	75 f5		 jne	 SHORT $LL24@derive_u_s
  001ab	5f		 pop	 edi
  001ac	5e		 pop	 esi
  001ad	5b		 pop	 ebx
  001ae	66 90		 npad	 2
$LL16@derive_u_s:
  001b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001b3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  001b6	83 e9 01	 sub	 ecx, 1
  001b9	75 f5		 jne	 SHORT $LL16@derive_u_s

; 531  : }

  001bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001be	33 cd		 xor	 ecx, ebp
  001c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c5	8b e5		 mov	 esp, ebp
  001c7	5d		 pop	 ebp
  001c8	c3		 ret	 0
_derive_u_stribog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _hmac_stribog
_TEXT	SEGMENT
_out$GSCopy$1$ = -656					; size = 4
_d$GSCopy$1$ = -652					; size = 4
_ctx$ = -648						; size = 385
_outer$ = -260						; size = 64
_key$ = -196						; size = 64
_inner$ = -132						; size = 64
_buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_hmac_stribog PROC					; COMDAT

; 430  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 02 00
	00		 sub	 esp, 656		; 00000290H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _k$[ebp]
  0001a	56		 push	 esi

; 431  : 	STRIBOG_CTX ctx;
; 432  : 	char inner[STRIBOG_DIGESTSIZE], outer[STRIBOG_DIGESTSIZE];
; 433  : 	char key[STRIBOG_DIGESTSIZE];
; 434  : 	char buf[STRIBOG_BLOCKSIZE];
; 435  : 	int32 i;
; 436  : 
; 437  :     /* If the key is longer than the hash algorithm block size,
; 438  : 	   let key = stribog(key), as per HMAC specifications. */
; 439  : 	if (lk > STRIBOG_BLOCKSIZE)

  0001b	8b 75 0c	 mov	 esi, DWORD PTR _lk$[ebp]
  0001e	89 85 74 fd ff
	ff		 mov	 DWORD PTR _d$GSCopy$1$[ebp], eax
  00024	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00027	89 85 70 fd ff
	ff		 mov	 DWORD PTR _out$GSCopy$1$[ebp], eax
  0002d	57		 push	 edi
  0002e	83 fe 40	 cmp	 esi, 64			; 00000040H
  00031	7e 68		 jle	 SHORT $LN3@hmac_strib

; 440  : 	{
; 441  : 		STRIBOG_init (&ctx);

  00033	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _STRIBOG_init

; 442  : 		STRIBOG_add (&ctx, (unsigned char *)k, lk);

  0003f	56		 push	 esi
  00040	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00046	53		 push	 ebx
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _STRIBOG_add

; 443  : 		STRIBOG_finalize (&ctx, (unsigned char *) key);

  0004d	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  00053	50		 push	 eax
  00054	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _STRIBOG_finalize

; 444  : 
; 445  : 		k = key;
; 446  : 		lk = STRIBOG_DIGESTSIZE;
; 447  : 
; 448  : 		burn (&ctx, sizeof(ctx));		// Prevent leaks

  00060	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00066	b9 81 01 00 00	 mov	 ecx, 385		; 00000181H
  0006b	83 c4 18	 add	 esp, 24			; 00000018H
  0006e	8d 9d 3c ff ff
	ff		 lea	 ebx, DWORD PTR _key$[ebp]
  00074	be 40 00 00 00	 mov	 esi, 64			; 00000040H
  00079	8b f9		 mov	 edi, ecx
  0007b	8b d0		 mov	 edx, eax
  0007d	0f 1f 00	 npad	 3
$LL47@hmac_strib:
  00080	c6 02 00	 mov	 BYTE PTR [edx], 0
  00083	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00086	83 ef 01	 sub	 edi, 1
  00089	75 f5		 jne	 SHORT $LL47@hmac_strib
  0008b	0f 1f 44 00 00	 npad	 5
$LL5@hmac_strib:
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0
  00093	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00096	83 e9 01	 sub	 ecx, 1
  00099	75 f5		 jne	 SHORT $LL5@hmac_strib
$LN3@hmac_strib:

; 449  : 	}
; 450  : 
; 451  : 	/**** Inner Digest ****/
; 452  : 
; 453  : 	STRIBOG_init (&ctx);

  0009b	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _STRIBOG_init
  000a7	83 c4 04	 add	 esp, 4

; 454  : 
; 455  : 	/* Pad the key for inner digest */
; 456  : 	for (i = 0; i < lk; ++i)

  000aa	33 d2		 xor	 edx, edx
  000ac	85 f6		 test	 esi, esi
  000ae	0f 8e 7e 00 00
	00		 jle	 $LN8@hmac_strib
  000b4	83 fe 20	 cmp	 esi, 32			; 00000020H
  000b7	72 5d		 jb	 SHORT $LN109@hmac_strib

; 457  : 		buf[i] = (char) (k[i] ^ 0x36);

  000b9	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  000bc	03 c6		 add	 eax, esi
  000be	8d 7d bc	 lea	 edi, DWORD PTR _buf$[ebp]
  000c1	8d 4c 35 bb	 lea	 ecx, DWORD PTR _buf$[ebp+esi-1]
  000c5	3b f8		 cmp	 edi, eax
  000c7	77 04		 ja	 SHORT $LN110@hmac_strib
  000c9	3b cb		 cmp	 ecx, ebx
  000cb	73 49		 jae	 SHORT $LN109@hmac_strib
$LN110@hmac_strib:
  000cd	8b c6		 mov	 eax, esi
  000cf	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  000d4	79 05		 jns	 SHORT $LN244@hmac_strib
  000d6	48		 dec	 eax
  000d7	83 c8 e0	 or	 eax, -32		; ffffffe0H
  000da	40		 inc	 eax
$LN244@hmac_strib:
  000db	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@36363636363636363636363636363636
  000e2	8b ce		 mov	 ecx, esi
  000e4	2b c8		 sub	 ecx, eax

; 454  : 
; 455  : 	/* Pad the key for inner digest */
; 456  : 	for (i = 0; i < lk; ++i)

  000e6	8b fb		 mov	 edi, ebx
  000e8	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  000eb	2b f8		 sub	 edi, eax
  000ed	0f 1f 00	 npad	 3
$LL9@hmac_strib:
  000f0	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  000f3	0f 10 44 05 bc	 movups	 xmm0, XMMWORD PTR _buf$[ebp+eax]

; 457  : 		buf[i] = (char) (k[i] ^ 0x36);

  000f8	66 0f ef c1	 pxor	 xmm0, xmm1
  000fc	0f 11 44 15 bc	 movups	 XMMWORD PTR _buf$[ebp+edx], xmm0
  00101	0f 10 44 13 10	 movups	 xmm0, XMMWORD PTR [ebx+edx+16]
  00106	66 0f ef c1	 pxor	 xmm0, xmm1
  0010a	0f 11 44 15 cc	 movups	 XMMWORD PTR _buf$[ebp+edx+16], xmm0
  0010f	83 c2 20	 add	 edx, 32			; 00000020H
  00112	3b d1		 cmp	 edx, ecx
  00114	7c da		 jl	 SHORT $LL9@hmac_strib
$LN109@hmac_strib:

; 454  : 
; 455  : 	/* Pad the key for inner digest */
; 456  : 	for (i = 0; i < lk; ++i)

  00116	3b d6		 cmp	 edx, esi
  00118	7d 18		 jge	 SHORT $LN8@hmac_strib
  0011a	8b fb		 mov	 edi, ebx
  0011c	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  0011f	2b f8		 sub	 edi, eax
$LL108@hmac_strib:

; 457  : 		buf[i] = (char) (k[i] ^ 0x36);

  00121	8d 4d bc	 lea	 ecx, DWORD PTR _buf$[ebp]
  00124	03 ca		 add	 ecx, edx
  00126	42		 inc	 edx
  00127	8a 04 0f	 mov	 al, BYTE PTR [edi+ecx]
  0012a	34 36		 xor	 al, 54			; 00000036H
  0012c	88 01		 mov	 BYTE PTR [ecx], al
  0012e	3b d6		 cmp	 edx, esi
  00130	7c ef		 jl	 SHORT $LL108@hmac_strib
$LN8@hmac_strib:

; 458  : 	for (i = lk; i < STRIBOG_BLOCKSIZE; ++i)

  00132	83 fe 40	 cmp	 esi, 64			; 00000040H
  00135	7d 1f		 jge	 SHORT $LN11@hmac_strib
  00137	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H

; 459  : 		buf[i] = 0x36;

  0013c	8d 7d bc	 lea	 edi, DWORD PTR _buf$[ebp]
  0013f	2b ce		 sub	 ecx, esi
  00141	03 fe		 add	 edi, esi
  00143	8b d1		 mov	 edx, ecx
  00145	b8 36 36 36 36	 mov	 eax, 909522486		; 36363636H
  0014a	c1 e9 02	 shr	 ecx, 2
  0014d	f3 ab		 rep stosd
  0014f	8b ca		 mov	 ecx, edx
  00151	83 e1 03	 and	 ecx, 3
  00154	f3 aa		 rep stosb
$LN11@hmac_strib:

; 460  : 
; 461  : 	STRIBOG_add (&ctx, (unsigned char *) buf, STRIBOG_BLOCKSIZE);

  00156	6a 40		 push	 64			; 00000040H
  00158	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  0015b	50		 push	 eax
  0015c	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 _STRIBOG_add

; 462  : 	STRIBOG_add (&ctx, (unsigned char *) d, ld);

  00168	ff 75 14	 push	 DWORD PTR _ld$[ebp]
  0016b	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00171	ff b5 74 fd ff
	ff		 push	 DWORD PTR _d$GSCopy$1$[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _STRIBOG_add

; 463  : 
; 464  : 	STRIBOG_finalize (&ctx, (unsigned char *) inner);

  0017d	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _inner$[ebp]
  00183	50		 push	 eax
  00184	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _STRIBOG_finalize

; 465  : 
; 466  : 	/**** Outer Digest ****/
; 467  : 	
; 468  : 	STRIBOG_init (&ctx);

  00190	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _STRIBOG_init
  0019c	83 c4 24	 add	 esp, 36			; 00000024H

; 469  : 
; 470  : 	for (i = 0; i < lk; ++i)

  0019f	33 d2		 xor	 edx, edx
  001a1	85 f6		 test	 esi, esi
  001a3	0f 8e 79 00 00
	00		 jle	 $LN14@hmac_strib
  001a9	83 fe 20	 cmp	 esi, 32			; 00000020H
  001ac	72 5a		 jb	 SHORT $LN112@hmac_strib

; 471  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001ae	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  001b1	03 c6		 add	 eax, esi
  001b3	8d 7d bc	 lea	 edi, DWORD PTR _buf$[ebp]
  001b6	8d 4c 35 bb	 lea	 ecx, DWORD PTR _buf$[ebp+esi-1]
  001ba	3b f8		 cmp	 edi, eax
  001bc	77 04		 ja	 SHORT $LN113@hmac_strib
  001be	3b cb		 cmp	 ecx, ebx
  001c0	73 46		 jae	 SHORT $LN112@hmac_strib
$LN113@hmac_strib:
  001c2	8b c6		 mov	 eax, esi
  001c4	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  001c9	79 05		 jns	 SHORT $LN245@hmac_strib
  001cb	48		 dec	 eax
  001cc	83 c8 e0	 or	 eax, -32		; ffffffe0H
  001cf	40		 inc	 eax
$LN245@hmac_strib:
  001d0	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
  001d7	8b ce		 mov	 ecx, esi
  001d9	2b c8		 sub	 ecx, eax

; 469  : 
; 470  : 	for (i = 0; i < lk; ++i)

  001db	8b fb		 mov	 edi, ebx
  001dd	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  001e0	2b f8		 sub	 edi, eax
$LL15@hmac_strib:
  001e2	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  001e5	0f 10 44 05 bc	 movups	 xmm0, XMMWORD PTR _buf$[ebp+eax]

; 471  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001ea	66 0f ef c1	 pxor	 xmm0, xmm1
  001ee	0f 11 44 15 bc	 movups	 XMMWORD PTR _buf$[ebp+edx], xmm0
  001f3	0f 10 44 13 10	 movups	 xmm0, XMMWORD PTR [ebx+edx+16]
  001f8	66 0f ef c1	 pxor	 xmm0, xmm1
  001fc	0f 11 44 15 cc	 movups	 XMMWORD PTR _buf$[ebp+edx+16], xmm0
  00201	83 c2 20	 add	 edx, 32			; 00000020H
  00204	3b d1		 cmp	 edx, ecx
  00206	7c da		 jl	 SHORT $LL15@hmac_strib
$LN112@hmac_strib:

; 469  : 
; 470  : 	for (i = 0; i < lk; ++i)

  00208	3b d6		 cmp	 edx, esi
  0020a	7d 16		 jge	 SHORT $LN14@hmac_strib
  0020c	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  0020f	2b d8		 sub	 ebx, eax
$LL111@hmac_strib:

; 471  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00211	8d 4d bc	 lea	 ecx, DWORD PTR _buf$[ebp]
  00214	03 ca		 add	 ecx, edx
  00216	42		 inc	 edx
  00217	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  0021a	34 5c		 xor	 al, 92			; 0000005cH
  0021c	88 01		 mov	 BYTE PTR [ecx], al
  0021e	3b d6		 cmp	 edx, esi
  00220	7c ef		 jl	 SHORT $LL111@hmac_strib
$LN14@hmac_strib:

; 472  : 	for (i = lk; i < STRIBOG_BLOCKSIZE; ++i)

  00222	83 fe 40	 cmp	 esi, 64			; 00000040H
  00225	7d 1f		 jge	 SHORT $LN17@hmac_strib
  00227	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H

; 473  : 		buf[i] = 0x5C;

  0022c	8d 7d bc	 lea	 edi, DWORD PTR _buf$[ebp]
  0022f	2b ce		 sub	 ecx, esi
  00231	03 fe		 add	 edi, esi
  00233	8b d1		 mov	 edx, ecx
  00235	b8 5c 5c 5c 5c	 mov	 eax, 1549556828		; 5c5c5c5cH
  0023a	c1 e9 02	 shr	 ecx, 2
  0023d	f3 ab		 rep stosd
  0023f	8b ca		 mov	 ecx, edx
  00241	83 e1 03	 and	 ecx, 3
  00244	f3 aa		 rep stosb
$LN17@hmac_strib:

; 474  : 
; 475  : 	STRIBOG_add (&ctx, (unsigned char *) buf, STRIBOG_BLOCKSIZE);

  00246	6a 40		 push	 64			; 00000040H
  00248	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  0024b	50		 push	 eax
  0024c	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 _STRIBOG_add

; 476  : 	STRIBOG_add (&ctx, (unsigned char *) inner, STRIBOG_DIGESTSIZE);

  00258	6a 40		 push	 64			; 00000040H
  0025a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _inner$[ebp]
  00260	50		 push	 eax
  00261	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00267	50		 push	 eax
  00268	e8 00 00 00 00	 call	 _STRIBOG_add

; 477  : 
; 478  : 	STRIBOG_finalize (&ctx, (unsigned char *) out);

  0026d	ff b5 70 fd ff
	ff		 push	 DWORD PTR _out$GSCopy$1$[ebp]
  00273	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 _STRIBOG_finalize

; 479  : 
; 480  : 	/* Prevent possible leaks. */
; 481  : 	burn (&ctx, sizeof(ctx));

  0027f	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00285	b9 81 01 00 00	 mov	 ecx, 385		; 00000181H
  0028a	83 c4 20	 add	 esp, 32			; 00000020H
  0028d	8b f1		 mov	 esi, ecx
  0028f	8b d0		 mov	 edx, eax
$LL51@hmac_strib:
  00291	c6 02 00	 mov	 BYTE PTR [edx], 0
  00294	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00297	83 ee 01	 sub	 esi, 1
  0029a	75 f5		 jne	 SHORT $LL51@hmac_strib
  0029c	0f 1f 40 00	 npad	 4
$LL22@hmac_strib:
  002a0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002a3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002a6	83 e9 01	 sub	 ecx, 1
  002a9	75 f5		 jne	 SHORT $LL22@hmac_strib

; 482  : 	burn (outer, sizeof(outer));

  002ab	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _outer$[ebp]
  002b1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002b6	8b f1		 mov	 esi, ecx
  002b8	8b d0		 mov	 edx, eax
  002ba	66 0f 1f 44 00
	00		 npad	 6
$LL55@hmac_strib:
  002c0	c6 02 00	 mov	 BYTE PTR [edx], 0
  002c3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  002c6	83 ee 01	 sub	 esi, 1
  002c9	75 f5		 jne	 SHORT $LL55@hmac_strib
  002cb	0f 1f 44 00 00	 npad	 5
$LL27@hmac_strib:
  002d0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002d3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002d6	83 e9 01	 sub	 ecx, 1
  002d9	75 f5		 jne	 SHORT $LL27@hmac_strib

; 483  : 	burn (inner, sizeof(inner));

  002db	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _inner$[ebp]
  002e1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002e6	8b f1		 mov	 esi, ecx
  002e8	8b d0		 mov	 edx, eax
  002ea	66 0f 1f 44 00
	00		 npad	 6
$LL59@hmac_strib:
  002f0	c6 02 00	 mov	 BYTE PTR [edx], 0
  002f3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  002f6	83 ee 01	 sub	 esi, 1
  002f9	75 f5		 jne	 SHORT $LL59@hmac_strib
  002fb	0f 1f 44 00 00	 npad	 5
$LL32@hmac_strib:
  00300	c6 00 00	 mov	 BYTE PTR [eax], 0
  00303	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00306	83 e9 01	 sub	 ecx, 1
  00309	75 f5		 jne	 SHORT $LL32@hmac_strib

; 484  : 	burn (buf, sizeof(buf));

  0030b	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  0030e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00313	8b f1		 mov	 esi, ecx
  00315	8b d0		 mov	 edx, eax
$LL63@hmac_strib:
  00317	c6 02 00	 mov	 BYTE PTR [edx], 0
  0031a	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0031d	83 ee 01	 sub	 esi, 1
  00320	75 f5		 jne	 SHORT $LL63@hmac_strib
$LL37@hmac_strib:
  00322	c6 00 00	 mov	 BYTE PTR [eax], 0
  00325	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00328	83 e9 01	 sub	 ecx, 1
  0032b	75 f5		 jne	 SHORT $LL37@hmac_strib

; 485  : 	burn (key, sizeof(key));

  0032d	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  00333	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00338	8b f1		 mov	 esi, ecx
  0033a	8b d0		 mov	 edx, eax
  0033c	0f 1f 40 00	 npad	 4
$LL67@hmac_strib:
  00340	c6 02 00	 mov	 BYTE PTR [edx], 0
  00343	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00346	83 ee 01	 sub	 esi, 1
  00349	75 f5		 jne	 SHORT $LL67@hmac_strib
  0034b	5f		 pop	 edi
  0034c	5e		 pop	 esi
  0034d	5b		 pop	 ebx
  0034e	66 90		 npad	 2
$LL42@hmac_strib:
  00350	c6 00 00	 mov	 BYTE PTR [eax], 0
  00353	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00356	83 e9 01	 sub	 ecx, 1
  00359	75 f5		 jne	 SHORT $LL42@hmac_strib

; 486  : }

  0035b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0035e	33 cd		 xor	 ecx, ebp
  00360	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00365	8b e5		 mov	 esp, ebp
  00367	5d		 pop	 ebp
  00368	c3		 ret	 0
_hmac_stribog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _derive_key_gosthash
_TEXT	SEGMENT
_pwd$GSCopy$1$ = -44					; size = 4
_salt$GSCopy$1$ = -40					; size = 4
_u$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_gosthash PROC				; COMDAT

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]

; 377  : 	char u[GOSTHASH_DIGESTSIZE];
; 378  : 	int b, l, r;
; 379  : 
; 380  : 	if (dklen % GOSTHASH_DIGESTSIZE)

  00013	8b 4d 20	 mov	 ecx, DWORD PTR _dklen$[ebp]
  00016	89 45 d4	 mov	 DWORD PTR _pwd$GSCopy$1$[ebp], eax
  00019	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0001c	53		 push	 ebx
  0001d	89 45 d8	 mov	 DWORD PTR _salt$GSCopy$1$[ebp], eax
  00020	8b c1		 mov	 eax, ecx
  00022	56		 push	 esi
  00023	8b 75 1c	 mov	 esi, DWORD PTR _dk$[ebp]
  00026	57		 push	 edi
  00027	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0002c	79 05		 jns	 SHORT $LN36@derive_key
  0002e	48		 dec	 eax
  0002f	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00032	40		 inc	 eax
$LN36@derive_key:

; 381  : 	{
; 382  : 		l = 1 + dklen / GOSTHASH_DIGESTSIZE;

  00033	8b c1		 mov	 eax, ecx
  00035	99		 cdq
  00036	74 0c		 je	 SHORT $LN10@derive_key
  00038	83 e2 1f	 and	 edx, 31			; 0000001fH
  0003b	8d 1c 02	 lea	 ebx, DWORD PTR [edx+eax]
  0003e	c1 fb 05	 sar	 ebx, 5
  00041	43		 inc	 ebx

; 383  : 	}

  00042	eb 09		 jmp	 SHORT $LN11@derive_key
$LN10@derive_key:

; 384  : 	else
; 385  : 	{
; 386  : 		l = dklen / GOSTHASH_DIGESTSIZE;

  00044	83 e2 1f	 and	 edx, 31			; 0000001fH
  00047	8d 1c 02	 lea	 ebx, DWORD PTR [edx+eax]
  0004a	c1 fb 05	 sar	 ebx, 5
$LN11@derive_key:

; 387  : 	}
; 388  : 
; 389  : 	r = dklen - (l - 1) * GOSTHASH_DIGESTSIZE;
; 390  : 
; 391  : 	/* first l - 1 blocks */
; 392  : 	for (b = 1; b < l; b++)

  0004d	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
  00050	8b c3		 mov	 eax, ebx
  00052	c1 e0 05	 shl	 eax, 5
  00055	bf 01 00 00 00	 mov	 edi, 1
  0005a	2b c8		 sub	 ecx, eax
  0005c	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0005f	83 c1 20	 add	 ecx, 32			; 00000020H
  00062	89 4d 20	 mov	 DWORD PTR _dklen$[ebp], ecx
  00065	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  00068	3b df		 cmp	 ebx, edi
  0006a	7e 3d		 jle	 SHORT $LN3@derive_key
  0006c	0f 1f 40 00	 npad	 4
$LL4@derive_key:

; 393  : 	{
; 394  : 		derive_u_gosthash (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00070	57		 push	 edi
  00071	8d 55 dc	 lea	 edx, DWORD PTR _u$[ebp]
  00074	52		 push	 edx
  00075	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
  00078	50		 push	 eax
  00079	51		 push	 ecx
  0007a	ff 75 d8	 push	 DWORD PTR _salt$GSCopy$1$[ebp]
  0007d	52		 push	 edx
  0007e	ff 75 d4	 push	 DWORD PTR _pwd$GSCopy$1$[ebp]
  00081	e8 00 00 00 00	 call	 _derive_u_gosthash

; 395  : 		memcpy (dk, u, GOSTHASH_DIGESTSIZE);

  00086	0f 10 45 dc	 movups	 xmm0, XMMWORD PTR _u$[ebp]
  0008a	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0008d	47		 inc	 edi
  0008e	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  00091	83 c4 1c	 add	 esp, 28			; 0000001cH
  00094	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00097	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _u$[ebp+16]
  0009b	0f 11 46 10	 movups	 XMMWORD PTR [esi+16], xmm0

; 396  : 		dk += GOSTHASH_DIGESTSIZE;

  0009f	83 c6 20	 add	 esi, 32			; 00000020H
  000a2	3b fb		 cmp	 edi, ebx
  000a4	7c ca		 jl	 SHORT $LL4@derive_key
  000a6	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
$LN3@derive_key:

; 397  : 	}
; 398  : 
; 399  : 	/* last block */
; 400  : 	derive_u_gosthash (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000a9	57		 push	 edi
  000aa	8d 7d dc	 lea	 edi, DWORD PTR _u$[ebp]
  000ad	57		 push	 edi
  000ae	50		 push	 eax
  000af	51		 push	 ecx
  000b0	ff 75 d8	 push	 DWORD PTR _salt$GSCopy$1$[ebp]
  000b3	52		 push	 edx
  000b4	ff 75 d4	 push	 DWORD PTR _pwd$GSCopy$1$[ebp]
  000b7	e8 00 00 00 00	 call	 _derive_u_gosthash

; 401  : 	memcpy (dk, u, r);

  000bc	ff 75 20	 push	 DWORD PTR _dklen$[ebp]
  000bf	8b c7		 mov	 eax, edi
  000c1	50		 push	 eax
  000c2	56		 push	 esi
  000c3	e8 00 00 00 00	 call	 _memcpy

; 402  : 
; 403  : 
; 404  : 	/* Prevent possible leaks. */
; 405  : 	burn (u, sizeof(u));

  000c8	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000cd	83 c4 28	 add	 esp, 40			; 00000028H
  000d0	8b c7		 mov	 eax, edi
  000d2	8b f1		 mov	 esi, ecx
  000d4	8b d7		 mov	 edx, edi
$LL14@derive_key:
  000d6	c6 02 00	 mov	 BYTE PTR [edx], 0
  000d9	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000dc	83 ee 01	 sub	 esi, 1
  000df	75 f5		 jne	 SHORT $LL14@derive_key
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
$LL8@derive_key:
  000e4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e7	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	75 f5		 jne	 SHORT $LL8@derive_key

; 406  : }

  000ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f2	33 cd		 xor	 ecx, ebp
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
_derive_key_gosthash ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _derive_u_gosthash
_TEXT	SEGMENT
_pwd$GSCopy$1$ = -212					; size = 4
_counter$ = -208					; size = 4
_init$ = -204						; size = 128
_k$ = -76						; size = 32
_j$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_gosthash PROC					; COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 332  : 	char j[GOSTHASH_DIGESTSIZE], k[GOSTHASH_DIGESTSIZE];
; 333  : 	char init[128];
; 334  : 	char counter[4];
; 335  : 	int c, i;
; 336  : 
; 337  : 	/* iteration 1 */
; 338  : 	memset (counter, 0, 4);
; 339  : 	counter[3] = (char) b;

  00013	8a 45 20	 mov	 al, BYTE PTR _b$[ebp]
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  00019	53		 push	 ebx
  0001a	8b 5d 08	 mov	 ebx, DWORD PTR _pwd$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 14	 mov	 esi, DWORD PTR _salt_len$[ebp]
  00021	57		 push	 edi
  00022	8b 7d 1c	 mov	 edi, DWORD PTR _u$[ebp]

; 340  : 	memcpy (init, salt, salt_len);	/* salt */

  00025	56		 push	 esi
  00026	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _counter$[ebp], 0
  00030	88 85 33 ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], al
  00036	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  0003c	51		 push	 ecx
  0003d	50		 push	 eax
  0003e	89 9d 2c ff ff
	ff		 mov	 DWORD PTR _pwd$GSCopy$1$[ebp], ebx
  00044	e8 00 00 00 00	 call	 _memcpy

; 341  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00049	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  0004f	89 84 35 34 ff
	ff ff		 mov	 DWORD PTR _init$[ebp+esi], eax

; 342  : 	hmac_gosthash (pwd, pwd_len, init, salt_len + 4, j);

  00056	8d 45 d8	 lea	 eax, DWORD PTR _j$[ebp]
  00059	50		 push	 eax
  0005a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0005d	50		 push	 eax
  0005e	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00064	50		 push	 eax
  00065	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  00068	53		 push	 ebx
  00069	e8 00 00 00 00	 call	 _hmac_gosthash

; 343  : 	memcpy (u, j, GOSTHASH_DIGESTSIZE);

  0006e	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR _j$[ebp]

; 344  : 
; 345  : 	/* remaining iterations */
; 346  : 	for (c = 1; c < iterations; c++)

  00072	8b 5d 18	 mov	 ebx, DWORD PTR _iterations$[ebp]
  00075	83 c4 20	 add	 esp, 32			; 00000020H
  00078	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0007b	0f 10 45 e8	 movups	 xmm0, XMMWORD PTR _j$[ebp+16]
  0007f	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  00083	83 fb 01	 cmp	 ebx, 1
  00086	0f 8e 91 00 00
	00		 jle	 $LN10@derive_u_g
  0008c	8d 77 1f	 lea	 esi, DWORD PTR [edi+31]
  0008f	4b		 dec	 ebx
$LL4@derive_u_g:

; 347  : 	{
; 348  : 		hmac_gosthash (pwd, pwd_len, j, GOSTHASH_DIGESTSIZE, k);

  00090	8d 45 b4	 lea	 eax, DWORD PTR _k$[ebp]
  00093	50		 push	 eax
  00094	6a 20		 push	 32			; 00000020H
  00096	8d 45 d8	 lea	 eax, DWORD PTR _j$[ebp]
  00099	50		 push	 eax
  0009a	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0009d	ff b5 2c ff ff
	ff		 push	 DWORD PTR _pwd$GSCopy$1$[ebp]
  000a3	e8 00 00 00 00	 call	 _hmac_gosthash

; 352  : 			j[i] = k[i];

  000a8	8d 4d d8	 lea	 ecx, DWORD PTR _j$[ebp]
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	33 c0		 xor	 eax, eax
  000b0	3b ce		 cmp	 ecx, esi
  000b2	77 07		 ja	 SHORT $LN43@derive_u_g
  000b4	8d 4d f7	 lea	 ecx, DWORD PTR _j$[ebp+31]
  000b7	3b cf		 cmp	 ecx, edi
  000b9	73 0e		 jae	 SHORT $LN62@derive_u_g
$LN43@derive_u_g:
  000bb	8d 4d d3	 lea	 ecx, DWORD PTR _k$[ebp+31]
  000be	3b f9		 cmp	 edi, ecx
  000c0	77 29		 ja	 SHORT $LN61@derive_u_g
  000c2	8d 4d b4	 lea	 ecx, DWORD PTR _k$[ebp]
  000c5	3b f1		 cmp	 esi, ecx
  000c7	72 22		 jb	 SHORT $LN61@derive_u_g
$LN62@derive_u_g:
  000c9	8b f7		 mov	 esi, edi
  000cb	8d 4d b4	 lea	 ecx, DWORD PTR _k$[ebp]
  000ce	2b f1		 sub	 esi, ecx
$LL60@derive_u_g:

; 350  : 		{
; 351  : 			u[i] ^= k[i];

  000d0	8d 4d b4	 lea	 ecx, DWORD PTR _k$[ebp]
  000d3	03 c8		 add	 ecx, eax
  000d5	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  000d8	8a 09		 mov	 cl, BYTE PTR [ecx]
  000da	30 0a		 xor	 BYTE PTR [edx], cl

; 352  : 			j[i] = k[i];

  000dc	88 4c 05 d8	 mov	 BYTE PTR _j$[ebp+eax], cl
  000e0	40		 inc	 eax
  000e1	83 f8 20	 cmp	 eax, 32			; 00000020H
  000e4	7c ea		 jl	 SHORT $LL60@derive_u_g

; 349  : 		for (i = 0; i < GOSTHASH_DIGESTSIZE; i++)

  000e6	8d 77 1f	 lea	 esi, DWORD PTR [edi+31]
  000e9	eb 29		 jmp	 SHORT $LN2@derive_u_g
$LN61@derive_u_g:
  000eb	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]

; 350  : 		{
; 351  : 			u[i] ^= k[i];

  000ee	0f 10 4d b4	 movups	 xmm1, XMMWORD PTR _k$[ebp]
  000f2	0f 10 55 c4	 movups	 xmm2, XMMWORD PTR _k$[ebp+16]
  000f6	66 0f ef c1	 pxor	 xmm0, xmm1
  000fa	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  000fd	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [edi+16]

; 352  : 			j[i] = k[i];

  00101	0f 11 4d d8	 movups	 XMMWORD PTR _j$[ebp], xmm1
  00105	0f 28 ca	 movaps	 xmm1, xmm2
  00108	66 0f ef c8	 pxor	 xmm1, xmm0
  0010c	0f 11 4f 10	 movups	 XMMWORD PTR [edi+16], xmm1
  00110	0f 11 55 e8	 movups	 XMMWORD PTR _j$[ebp+16], xmm2
$LN2@derive_u_g:

; 344  : 
; 345  : 	/* remaining iterations */
; 346  : 	for (c = 1; c < iterations; c++)

  00114	83 eb 01	 sub	 ebx, 1
  00117	0f 85 73 ff ff
	ff		 jne	 $LL4@derive_u_g
$LN10@derive_u_g:

; 353  : 		}
; 354  : 	}
; 355  : 
; 356  : 	/* Prevent possible leaks. */
; 357  : 	burn (j, sizeof(j));

  0011d	8d 45 d8	 lea	 eax, DWORD PTR _j$[ebp]
  00120	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00125	8b f1		 mov	 esi, ecx
  00127	8b d0		 mov	 edx, eax
  00129	0f 1f 80 00 00
	00 00		 npad	 7
$LL20@derive_u_g:
  00130	c6 02 00	 mov	 BYTE PTR [edx], 0
  00133	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00136	83 ee 01	 sub	 esi, 1
  00139	75 f5		 jne	 SHORT $LL20@derive_u_g
  0013b	0f 1f 44 00 00	 npad	 5
$LL11@derive_u_g:
  00140	c6 00 00	 mov	 BYTE PTR [eax], 0
  00143	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00146	83 e9 01	 sub	 ecx, 1
  00149	75 f5		 jne	 SHORT $LL11@derive_u_g

; 358  : 	burn (k, sizeof(k));

  0014b	8d 45 b4	 lea	 eax, DWORD PTR _k$[ebp]
  0014e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00153	8b f1		 mov	 esi, ecx
  00155	8b d0		 mov	 edx, eax
$LL24@derive_u_g:
  00157	c6 02 00	 mov	 BYTE PTR [edx], 0
  0015a	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0015d	83 ee 01	 sub	 esi, 1
  00160	75 f5		 jne	 SHORT $LL24@derive_u_g
  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx
$LL16@derive_u_g:
  00165	c6 00 00	 mov	 BYTE PTR [eax], 0
  00168	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  0016b	83 e9 01	 sub	 ecx, 1
  0016e	75 f5		 jne	 SHORT $LL16@derive_u_g

; 359  : }

  00170	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	33 cd		 xor	 ecx, ebp
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
_derive_u_gosthash ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _hmac_gosthash
_TEXT	SEGMENT
_out$GSCopy$1$ = -244					; size = 4
_d$GSCopy$1$ = -240					; size = 4
_ctx$ = -236						; size = 104
_outer$ = -132						; size = 32
_key$ = -100						; size = 32
_inner$ = -68						; size = 32
_buf$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_hmac_gosthash PROC					; COMDAT

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _k$[ebp]
  0001a	56		 push	 esi

; 259  : 	gost_hash_ctx ctx;
; 260  : 	char inner[GOSTHASH_DIGESTSIZE], outer[GOSTHASH_DIGESTSIZE];
; 261  : 	char key[GOSTHASH_DIGESTSIZE];
; 262  : 	char buf[GOSTHASH_BLOCKSIZE];
; 263  : 	int32 i;
; 264  : 
; 265  :     /* If the key is longer than the hash algorithm block size,
; 266  : 	   let key = gosthash(key), as per HMAC specifications. */
; 267  : 	if (lk > GOSTHASH_BLOCKSIZE)

  0001b	8b 75 0c	 mov	 esi, DWORD PTR _lk$[ebp]
  0001e	89 85 10 ff ff
	ff		 mov	 DWORD PTR _d$GSCopy$1$[ebp], eax
  00024	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00027	89 85 0c ff ff
	ff		 mov	 DWORD PTR _out$GSCopy$1$[ebp], eax
  0002d	57		 push	 edi
  0002e	83 fe 20	 cmp	 esi, 32			; 00000020H
  00031	7e 5a		 jle	 SHORT $LN3@hmac_gosth

; 268  : 	{
; 269  : 		GOSTHASH_init (&ctx);

  00033	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _GOSTHASH_init

; 270  : 		GOSTHASH_add ((unsigned char *)k, lk, &ctx);

  0003f	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00045	50		 push	 eax
  00046	56		 push	 esi
  00047	53		 push	 ebx
  00048	e8 00 00 00 00	 call	 _GOSTHASH_add

; 271  : 		GOSTHASH_finalize (&ctx, (unsigned char *) key);

  0004d	8d 45 9c	 lea	 eax, DWORD PTR _key$[ebp]
  00050	50		 push	 eax
  00051	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _GOSTHASH_finalize

; 272  : 
; 273  : 		k = key;
; 274  : 		lk = GOSTHASH_DIGESTSIZE;
; 275  : 
; 276  : 		burn (&ctx, sizeof(ctx));		// Prevent leaks

  0005d	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00063	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00068	83 c4 18	 add	 esp, 24			; 00000018H
  0006b	8d 5d 9c	 lea	 ebx, DWORD PTR _key$[ebp]
  0006e	be 20 00 00 00	 mov	 esi, 32			; 00000020H
  00073	8b f9		 mov	 edi, ecx
  00075	8b d0		 mov	 edx, eax
$LL47@hmac_gosth:
  00077	c6 02 00	 mov	 BYTE PTR [edx], 0
  0007a	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0007d	83 ef 01	 sub	 edi, 1
  00080	75 f5		 jne	 SHORT $LL47@hmac_gosth
$LL5@hmac_gosth:
  00082	c6 00 00	 mov	 BYTE PTR [eax], 0
  00085	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00088	83 e9 01	 sub	 ecx, 1
  0008b	75 f5		 jne	 SHORT $LL5@hmac_gosth
$LN3@hmac_gosth:

; 277  : 	}
; 278  : 
; 279  : 	/**** Inner Digest ****/
; 280  : 
; 281  : 	GOSTHASH_init (&ctx);

  0008d	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _GOSTHASH_init
  00099	83 c4 04	 add	 esp, 4

; 282  : 
; 283  : 	/* Pad the key for inner digest */
; 284  : 	for (i = 0; i < lk; ++i)

  0009c	33 d2		 xor	 edx, edx
  0009e	85 f6		 test	 esi, esi
  000a0	0f 8e 7c 00 00
	00		 jle	 $LN8@hmac_gosth
  000a6	83 fe 20	 cmp	 esi, 32			; 00000020H
  000a9	72 5b		 jb	 SHORT $LN109@hmac_gosth

; 285  : 		buf[i] = (char) (k[i] ^ 0x36);

  000ab	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  000ae	03 c6		 add	 eax, esi
  000b0	8d 7d dc	 lea	 edi, DWORD PTR _buf$[ebp]
  000b3	8d 4c 35 db	 lea	 ecx, DWORD PTR _buf$[ebp+esi-1]
  000b7	3b f8		 cmp	 edi, eax
  000b9	77 04		 ja	 SHORT $LN110@hmac_gosth
  000bb	3b cb		 cmp	 ecx, ebx
  000bd	73 47		 jae	 SHORT $LN109@hmac_gosth
$LN110@hmac_gosth:
  000bf	8b c6		 mov	 eax, esi
  000c1	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  000c6	79 05		 jns	 SHORT $LN244@hmac_gosth
  000c8	48		 dec	 eax
  000c9	83 c8 e0	 or	 eax, -32		; ffffffe0H
  000cc	40		 inc	 eax
$LN244@hmac_gosth:
  000cd	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@36363636363636363636363636363636
  000d4	8b ce		 mov	 ecx, esi
  000d6	2b c8		 sub	 ecx, eax

; 282  : 
; 283  : 	/* Pad the key for inner digest */
; 284  : 	for (i = 0; i < lk; ++i)

  000d8	8b fb		 mov	 edi, ebx
  000da	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  000dd	2b f8		 sub	 edi, eax
  000df	90		 npad	 1
$LL9@hmac_gosth:
  000e0	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  000e3	0f 10 44 05 dc	 movups	 xmm0, XMMWORD PTR _buf$[ebp+eax]

; 285  : 		buf[i] = (char) (k[i] ^ 0x36);

  000e8	66 0f ef c1	 pxor	 xmm0, xmm1
  000ec	0f 11 44 15 dc	 movups	 XMMWORD PTR _buf$[ebp+edx], xmm0
  000f1	0f 10 44 13 10	 movups	 xmm0, XMMWORD PTR [ebx+edx+16]
  000f6	66 0f ef c1	 pxor	 xmm0, xmm1
  000fa	0f 11 44 15 ec	 movups	 XMMWORD PTR _buf$[ebp+edx+16], xmm0
  000ff	83 c2 20	 add	 edx, 32			; 00000020H
  00102	3b d1		 cmp	 edx, ecx
  00104	7c da		 jl	 SHORT $LL9@hmac_gosth
$LN109@hmac_gosth:

; 282  : 
; 283  : 	/* Pad the key for inner digest */
; 284  : 	for (i = 0; i < lk; ++i)

  00106	3b d6		 cmp	 edx, esi
  00108	7d 18		 jge	 SHORT $LN8@hmac_gosth
  0010a	8b fb		 mov	 edi, ebx
  0010c	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  0010f	2b f8		 sub	 edi, eax
$LL108@hmac_gosth:

; 285  : 		buf[i] = (char) (k[i] ^ 0x36);

  00111	8d 4d dc	 lea	 ecx, DWORD PTR _buf$[ebp]
  00114	03 ca		 add	 ecx, edx
  00116	42		 inc	 edx
  00117	8a 04 0f	 mov	 al, BYTE PTR [edi+ecx]
  0011a	34 36		 xor	 al, 54			; 00000036H
  0011c	88 01		 mov	 BYTE PTR [ecx], al
  0011e	3b d6		 cmp	 edx, esi
  00120	7c ef		 jl	 SHORT $LL108@hmac_gosth
$LN8@hmac_gosth:

; 286  : 	for (i = lk; i < GOSTHASH_BLOCKSIZE; ++i)

  00122	83 fe 20	 cmp	 esi, 32			; 00000020H
  00125	7d 1f		 jge	 SHORT $LN11@hmac_gosth
  00127	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H

; 287  : 		buf[i] = 0x36;

  0012c	8d 7d dc	 lea	 edi, DWORD PTR _buf$[ebp]
  0012f	2b ce		 sub	 ecx, esi
  00131	03 fe		 add	 edi, esi
  00133	8b d1		 mov	 edx, ecx
  00135	b8 36 36 36 36	 mov	 eax, 909522486		; 36363636H
  0013a	c1 e9 02	 shr	 ecx, 2
  0013d	f3 ab		 rep stosd
  0013f	8b ca		 mov	 ecx, edx
  00141	83 e1 03	 and	 ecx, 3
  00144	f3 aa		 rep stosb
$LN11@hmac_gosth:

; 288  : 
; 289  : 	GOSTHASH_add ((unsigned char *) buf, GOSTHASH_BLOCKSIZE, &ctx);

  00146	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0014c	50		 push	 eax
  0014d	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  00150	6a 20		 push	 32			; 00000020H
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 _GOSTHASH_add

; 290  : 	GOSTHASH_add ((unsigned char *) d, ld, &ctx);

  00158	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0015e	50		 push	 eax
  0015f	ff 75 14	 push	 DWORD PTR _ld$[ebp]
  00162	ff b5 10 ff ff
	ff		 push	 DWORD PTR _d$GSCopy$1$[ebp]
  00168	e8 00 00 00 00	 call	 _GOSTHASH_add

; 291  : 
; 292  : 	GOSTHASH_finalize (&ctx, (unsigned char *) inner);

  0016d	8d 45 bc	 lea	 eax, DWORD PTR _inner$[ebp]
  00170	50		 push	 eax
  00171	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _GOSTHASH_finalize

; 293  : 
; 294  : 	/**** Outer Digest ****/
; 295  : 	
; 296  : 	GOSTHASH_init (&ctx);

  0017d	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 _GOSTHASH_init
  00189	83 c4 24	 add	 esp, 36			; 00000024H

; 297  : 
; 298  : 	for (i = 0; i < lk; ++i)

  0018c	33 d2		 xor	 edx, edx
  0018e	85 f6		 test	 esi, esi
  00190	0f 8e 7b 00 00
	00		 jle	 $LN14@hmac_gosth
  00196	83 fe 20	 cmp	 esi, 32			; 00000020H
  00199	72 5b		 jb	 SHORT $LN112@hmac_gosth

; 299  : 		buf[i] = (char) (k[i] ^ 0x5C);

  0019b	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0019e	03 c6		 add	 eax, esi
  001a0	8d 7d dc	 lea	 edi, DWORD PTR _buf$[ebp]
  001a3	8d 4c 35 db	 lea	 ecx, DWORD PTR _buf$[ebp+esi-1]
  001a7	3b f8		 cmp	 edi, eax
  001a9	77 04		 ja	 SHORT $LN113@hmac_gosth
  001ab	3b cb		 cmp	 ecx, ebx
  001ad	73 47		 jae	 SHORT $LN112@hmac_gosth
$LN113@hmac_gosth:
  001af	8b c6		 mov	 eax, esi
  001b1	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  001b6	79 05		 jns	 SHORT $LN245@hmac_gosth
  001b8	48		 dec	 eax
  001b9	83 c8 e0	 or	 eax, -32		; ffffffe0H
  001bc	40		 inc	 eax
$LN245@hmac_gosth:
  001bd	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
  001c4	8b ce		 mov	 ecx, esi
  001c6	2b c8		 sub	 ecx, eax

; 297  : 
; 298  : 	for (i = 0; i < lk; ++i)

  001c8	8b fb		 mov	 edi, ebx
  001ca	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  001cd	2b f8		 sub	 edi, eax
  001cf	90		 npad	 1
$LL15@hmac_gosth:
  001d0	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  001d3	0f 10 44 05 dc	 movups	 xmm0, XMMWORD PTR _buf$[ebp+eax]

; 299  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001d8	66 0f ef c1	 pxor	 xmm0, xmm1
  001dc	0f 11 44 15 dc	 movups	 XMMWORD PTR _buf$[ebp+edx], xmm0
  001e1	0f 10 44 13 10	 movups	 xmm0, XMMWORD PTR [ebx+edx+16]
  001e6	66 0f ef c1	 pxor	 xmm0, xmm1
  001ea	0f 11 44 15 ec	 movups	 XMMWORD PTR _buf$[ebp+edx+16], xmm0
  001ef	83 c2 20	 add	 edx, 32			; 00000020H
  001f2	3b d1		 cmp	 edx, ecx
  001f4	7c da		 jl	 SHORT $LL15@hmac_gosth
$LN112@hmac_gosth:

; 297  : 
; 298  : 	for (i = 0; i < lk; ++i)

  001f6	3b d6		 cmp	 edx, esi
  001f8	7d 17		 jge	 SHORT $LN14@hmac_gosth
  001fa	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  001fd	2b d8		 sub	 ebx, eax
  001ff	90		 npad	 1
$LL111@hmac_gosth:

; 299  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00200	8d 4d dc	 lea	 ecx, DWORD PTR _buf$[ebp]
  00203	03 ca		 add	 ecx, edx
  00205	42		 inc	 edx
  00206	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  00209	34 5c		 xor	 al, 92			; 0000005cH
  0020b	88 01		 mov	 BYTE PTR [ecx], al
  0020d	3b d6		 cmp	 edx, esi
  0020f	7c ef		 jl	 SHORT $LL111@hmac_gosth
$LN14@hmac_gosth:

; 300  : 	for (i = lk; i < GOSTHASH_BLOCKSIZE; ++i)

  00211	83 fe 20	 cmp	 esi, 32			; 00000020H
  00214	7d 1f		 jge	 SHORT $LN17@hmac_gosth
  00216	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H

; 301  : 		buf[i] = 0x5C;

  0021b	8d 7d dc	 lea	 edi, DWORD PTR _buf$[ebp]
  0021e	2b ce		 sub	 ecx, esi
  00220	03 fe		 add	 edi, esi
  00222	8b d1		 mov	 edx, ecx
  00224	b8 5c 5c 5c 5c	 mov	 eax, 1549556828		; 5c5c5c5cH
  00229	c1 e9 02	 shr	 ecx, 2
  0022c	f3 ab		 rep stosd
  0022e	8b ca		 mov	 ecx, edx
  00230	83 e1 03	 and	 ecx, 3
  00233	f3 aa		 rep stosb
$LN17@hmac_gosth:

; 302  : 
; 303  : 	GOSTHASH_add ((unsigned char *) buf, GOSTHASH_BLOCKSIZE, &ctx);

  00235	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0023b	50		 push	 eax
  0023c	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  0023f	6a 20		 push	 32			; 00000020H
  00241	50		 push	 eax
  00242	e8 00 00 00 00	 call	 _GOSTHASH_add

; 304  : 	GOSTHASH_add ((unsigned char *) inner, GOSTHASH_DIGESTSIZE, &ctx);

  00247	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  0024d	50		 push	 eax
  0024e	8d 45 bc	 lea	 eax, DWORD PTR _inner$[ebp]
  00251	6a 20		 push	 32			; 00000020H
  00253	50		 push	 eax
  00254	e8 00 00 00 00	 call	 _GOSTHASH_add

; 305  : 
; 306  : 	GOSTHASH_finalize (&ctx, (unsigned char *) out);

  00259	ff b5 0c ff ff
	ff		 push	 DWORD PTR _out$GSCopy$1$[ebp]
  0025f	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 _GOSTHASH_finalize

; 307  : 
; 308  : 	/* Prevent possible leaks. */
; 309  : 	burn (&ctx, sizeof(ctx));

  0026b	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _ctx$[ebp]
  00271	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00276	83 c4 20	 add	 esp, 32			; 00000020H
  00279	8b f1		 mov	 esi, ecx
  0027b	8b d0		 mov	 edx, eax
  0027d	0f 1f 00	 npad	 3
$LL51@hmac_gosth:
  00280	c6 02 00	 mov	 BYTE PTR [edx], 0
  00283	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00286	83 ee 01	 sub	 esi, 1
  00289	75 f5		 jne	 SHORT $LL51@hmac_gosth
  0028b	0f 1f 44 00 00	 npad	 5
$LL22@hmac_gosth:
  00290	c6 00 00	 mov	 BYTE PTR [eax], 0
  00293	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00296	83 e9 01	 sub	 ecx, 1
  00299	75 f5		 jne	 SHORT $LL22@hmac_gosth

; 310  : 	burn (outer, sizeof(outer));

  0029b	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _outer$[ebp]
  002a1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002a6	8b f1		 mov	 esi, ecx
  002a8	8b d0		 mov	 edx, eax
  002aa	66 0f 1f 44 00
	00		 npad	 6
$LL55@hmac_gosth:
  002b0	c6 02 00	 mov	 BYTE PTR [edx], 0
  002b3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  002b6	83 ee 01	 sub	 esi, 1
  002b9	75 f5		 jne	 SHORT $LL55@hmac_gosth
  002bb	0f 1f 44 00 00	 npad	 5
$LL27@hmac_gosth:
  002c0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002c3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002c6	83 e9 01	 sub	 ecx, 1
  002c9	75 f5		 jne	 SHORT $LL27@hmac_gosth

; 311  : 	burn (inner, sizeof(inner));

  002cb	8d 45 bc	 lea	 eax, DWORD PTR _inner$[ebp]
  002ce	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002d3	8b f1		 mov	 esi, ecx
  002d5	8b d0		 mov	 edx, eax
$LL59@hmac_gosth:
  002d7	c6 02 00	 mov	 BYTE PTR [edx], 0
  002da	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  002dd	83 ee 01	 sub	 esi, 1
  002e0	75 f5		 jne	 SHORT $LL59@hmac_gosth
$LL32@hmac_gosth:
  002e2	c6 00 00	 mov	 BYTE PTR [eax], 0
  002e5	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002e8	83 e9 01	 sub	 ecx, 1
  002eb	75 f5		 jne	 SHORT $LL32@hmac_gosth

; 312  : 	burn (buf, sizeof(buf));

  002ed	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  002f0	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002f5	8b f1		 mov	 esi, ecx
  002f7	8b d0		 mov	 edx, eax
  002f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL63@hmac_gosth:
  00300	c6 02 00	 mov	 BYTE PTR [edx], 0
  00303	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00306	83 ee 01	 sub	 esi, 1
  00309	75 f5		 jne	 SHORT $LL63@hmac_gosth
  0030b	0f 1f 44 00 00	 npad	 5
$LL37@hmac_gosth:
  00310	c6 00 00	 mov	 BYTE PTR [eax], 0
  00313	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00316	83 e9 01	 sub	 ecx, 1
  00319	75 f5		 jne	 SHORT $LL37@hmac_gosth

; 313  : 	burn (key, sizeof(key));

  0031b	8d 45 9c	 lea	 eax, DWORD PTR _key$[ebp]
  0031e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00323	8b f1		 mov	 esi, ecx
  00325	8b d0		 mov	 edx, eax
$LL67@hmac_gosth:
  00327	c6 02 00	 mov	 BYTE PTR [edx], 0
  0032a	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0032d	83 ee 01	 sub	 esi, 1
  00330	75 f5		 jne	 SHORT $LL67@hmac_gosth
  00332	5f		 pop	 edi
  00333	5e		 pop	 esi
  00334	5b		 pop	 ebx
$LL42@hmac_gosth:
  00335	c6 00 00	 mov	 BYTE PTR [eax], 0
  00338	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  0033b	83 e9 01	 sub	 ecx, 1
  0033e	75 f5		 jne	 SHORT $LL42@hmac_gosth

; 314  : }

  00340	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00343	33 cd		 xor	 ecx, ebp
  00345	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034a	8b e5		 mov	 esp, ebp
  0034c	5d		 pop	 ebp
  0034d	c3		 ret	 0
_hmac_gosthash ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _derive_key_whirlpool
_TEXT	SEGMENT
_pwd$GSCopy$1$ = -76					; size = 4
_salt$GSCopy$1$ = -72					; size = 4
_u$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_whirlpool PROC				; COMDAT

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]

; 207  : 	char u[WHIRLPOOL_DIGESTSIZE];
; 208  : 	int b, l, r;
; 209  : 
; 210  : 	if (dklen % WHIRLPOOL_DIGESTSIZE)

  00013	8b 4d 20	 mov	 ecx, DWORD PTR _dklen$[ebp]
  00016	89 45 b4	 mov	 DWORD PTR _pwd$GSCopy$1$[ebp], eax
  00019	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0001c	89 45 b8	 mov	 DWORD PTR _salt$GSCopy$1$[ebp], eax
  0001f	8b c1		 mov	 eax, ecx
  00021	56		 push	 esi
  00022	8b 75 1c	 mov	 esi, DWORD PTR _dk$[ebp]
  00025	57		 push	 edi
  00026	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0002b	79 05		 jns	 SHORT $LN36@derive_key
  0002d	48		 dec	 eax
  0002e	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00031	40		 inc	 eax
$LN36@derive_key:

; 211  : 	{
; 212  : 		l = 1 + dklen / WHIRLPOOL_DIGESTSIZE;

  00032	8b c1		 mov	 eax, ecx
  00034	99		 cdq
  00035	74 0c		 je	 SHORT $LN10@derive_key
  00037	83 e2 3f	 and	 edx, 63			; 0000003fH
  0003a	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  0003d	c1 ff 06	 sar	 edi, 6
  00040	47		 inc	 edi

; 213  : 	}

  00041	eb 09		 jmp	 SHORT $LN11@derive_key
$LN10@derive_key:

; 214  : 	else
; 215  : 	{
; 216  : 		l = dklen / WHIRLPOOL_DIGESTSIZE;

  00043	83 e2 3f	 and	 edx, 63			; 0000003fH
  00046	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  00049	c1 ff 06	 sar	 edi, 6
$LN11@derive_key:

; 217  : 	}
; 218  : 
; 219  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;
; 220  : 
; 221  : 	/* first l - 1 blocks */
; 222  : 	for (b = 1; b < l; b++)

  0004c	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
  0004f	8b c7		 mov	 eax, edi
  00051	c1 e0 06	 shl	 eax, 6
  00054	2b c8		 sub	 ecx, eax
  00056	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  00059	83 c1 40	 add	 ecx, 64			; 00000040H
  0005c	53		 push	 ebx
  0005d	bb 01 00 00 00	 mov	 ebx, 1
  00062	89 4d 20	 mov	 DWORD PTR _dklen$[ebp], ecx
  00065	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  00068	3b fb		 cmp	 edi, ebx
  0006a	7e 4d		 jle	 SHORT $LN3@derive_key
  0006c	0f 1f 40 00	 npad	 4
$LL4@derive_key:

; 223  : 	{
; 224  : 		derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00070	53		 push	 ebx
  00071	8d 55 bc	 lea	 edx, DWORD PTR _u$[ebp]
  00074	52		 push	 edx
  00075	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
  00078	50		 push	 eax
  00079	51		 push	 ecx
  0007a	ff 75 b8	 push	 DWORD PTR _salt$GSCopy$1$[ebp]
  0007d	52		 push	 edx
  0007e	ff 75 b4	 push	 DWORD PTR _pwd$GSCopy$1$[ebp]
  00081	e8 00 00 00 00	 call	 _derive_u_whirlpool

; 225  : 		memcpy (dk, u, WHIRLPOOL_DIGESTSIZE);

  00086	0f 10 45 bc	 movups	 xmm0, XMMWORD PTR _u$[ebp]
  0008a	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0008d	43		 inc	 ebx
  0008e	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  00091	83 c4 1c	 add	 esp, 28			; 0000001cH
  00094	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00097	0f 10 45 cc	 movups	 xmm0, XMMWORD PTR _u$[ebp+16]
  0009b	0f 11 46 10	 movups	 XMMWORD PTR [esi+16], xmm0
  0009f	0f 10 45 dc	 movups	 xmm0, XMMWORD PTR _u$[ebp+32]
  000a3	0f 11 46 20	 movups	 XMMWORD PTR [esi+32], xmm0
  000a7	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _u$[ebp+48]
  000ab	0f 11 46 30	 movups	 XMMWORD PTR [esi+48], xmm0

; 226  : 		dk += WHIRLPOOL_DIGESTSIZE;

  000af	83 c6 40	 add	 esi, 64			; 00000040H
  000b2	3b df		 cmp	 ebx, edi
  000b4	7c ba		 jl	 SHORT $LL4@derive_key
  000b6	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
$LN3@derive_key:

; 227  : 	}
; 228  : 
; 229  : 	/* last block */
; 230  : 	derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000b9	53		 push	 ebx
  000ba	8d 7d bc	 lea	 edi, DWORD PTR _u$[ebp]
  000bd	57		 push	 edi
  000be	50		 push	 eax
  000bf	51		 push	 ecx
  000c0	ff 75 b8	 push	 DWORD PTR _salt$GSCopy$1$[ebp]
  000c3	52		 push	 edx
  000c4	ff 75 b4	 push	 DWORD PTR _pwd$GSCopy$1$[ebp]
  000c7	e8 00 00 00 00	 call	 _derive_u_whirlpool

; 231  : 	memcpy (dk, u, r);

  000cc	ff 75 20	 push	 DWORD PTR _dklen$[ebp]
  000cf	8b c7		 mov	 eax, edi
  000d1	50		 push	 eax
  000d2	56		 push	 esi
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 28	 add	 esp, 40			; 00000028H

; 232  : 
; 233  : 
; 234  : 	/* Prevent possible leaks. */
; 235  : 	burn (u, sizeof(u));

  000db	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000e0	8b c7		 mov	 eax, edi
  000e2	8b f1		 mov	 esi, ecx
  000e4	8b d7		 mov	 edx, edi
  000e6	5b		 pop	 ebx
$LL14@derive_key:
  000e7	c6 02 00	 mov	 BYTE PTR [edx], 0
  000ea	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000ed	83 ee 01	 sub	 esi, 1
  000f0	75 f5		 jne	 SHORT $LL14@derive_key
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
$LL8@derive_key:
  000f4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000f7	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000fa	83 e9 01	 sub	 ecx, 1
  000fd	75 f5		 jne	 SHORT $LL8@derive_key

; 236  : }

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
_derive_key_whirlpool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _derive_u_whirlpool
_TEXT	SEGMENT
_pwd$GSCopy$1$ = -276					; size = 4
_counter$ = -272					; size = 4
_init$ = -268						; size = 128
_k$ = -140						; size = 64
_j$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_whirlpool PROC				; COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 162  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 163  : 	char init[128];
; 164  : 	char counter[4];
; 165  : 	int c, i;
; 166  : 
; 167  : 	/* iteration 1 */
; 168  : 	memset (counter, 0, 4);
; 169  : 	counter[3] = (char) b;

  00013	8a 45 20	 mov	 al, BYTE PTR _b$[ebp]
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  00019	53		 push	 ebx
  0001a	8b 5d 08	 mov	 ebx, DWORD PTR _pwd$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 14	 mov	 esi, DWORD PTR _salt_len$[ebp]
  00021	57		 push	 edi
  00022	8b 7d 1c	 mov	 edi, DWORD PTR _u$[ebp]

; 170  : 	memcpy (init, salt, salt_len);	/* salt */

  00025	56		 push	 esi
  00026	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _counter$[ebp], 0
  00030	88 85 f3 fe ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], al
  00036	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  0003c	51		 push	 ecx
  0003d	50		 push	 eax
  0003e	89 9d ec fe ff
	ff		 mov	 DWORD PTR _pwd$GSCopy$1$[ebp], ebx
  00044	e8 00 00 00 00	 call	 _memcpy

; 171  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00049	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  0004f	89 84 35 f4 fe
	ff ff		 mov	 DWORD PTR _init$[ebp+esi], eax

; 172  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);

  00056	8d 45 b8	 lea	 eax, DWORD PTR _j$[ebp]
  00059	6a 40		 push	 64			; 00000040H
  0005b	50		 push	 eax
  0005c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0005f	50		 push	 eax
  00060	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00066	50		 push	 eax
  00067	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _hmac_whirlpool

; 173  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);

  00070	0f 10 45 b8	 movups	 xmm0, XMMWORD PTR _j$[ebp]

; 174  : 
; 175  : 	/* remaining iterations */
; 176  : 	for (c = 1; c < iterations; c++)

  00074	8b 5d 18	 mov	 ebx, DWORD PTR _iterations$[ebp]
  00077	83 c4 24	 add	 esp, 36			; 00000024H
  0007a	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0007d	0f 10 45 c8	 movups	 xmm0, XMMWORD PTR _j$[ebp+16]
  00081	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  00085	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR _j$[ebp+32]
  00089	0f 11 47 20	 movups	 XMMWORD PTR [edi+32], xmm0
  0008d	0f 10 45 e8	 movups	 xmm0, XMMWORD PTR _j$[ebp+48]
  00091	0f 11 47 30	 movups	 XMMWORD PTR [edi+48], xmm0
  00095	83 fb 01	 cmp	 ebx, 1
  00098	0f 8e c2 00 00
	00		 jle	 $LN10@derive_u_w
  0009e	8b f7		 mov	 esi, edi
  000a0	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  000a6	2b f0		 sub	 esi, eax
  000a8	4b		 dec	 ebx
  000a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@derive_u_w:

; 177  : 	{
; 178  : 		hmac_whirlpool (pwd, pwd_len, j, WHIRLPOOL_DIGESTSIZE, k, WHIRLPOOL_DIGESTSIZE);

  000b0	6a 40		 push	 64			; 00000040H
  000b2	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  000b8	50		 push	 eax
  000b9	6a 40		 push	 64			; 00000040H
  000bb	8d 45 b8	 lea	 eax, DWORD PTR _j$[ebp]
  000be	50		 push	 eax
  000bf	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000c2	ff b5 ec fe ff
	ff		 push	 DWORD PTR _pwd$GSCopy$1$[ebp]
  000c8	e8 00 00 00 00	 call	 _hmac_whirlpool

; 182  : 			j[i] = k[i];

  000cd	8d 55 b8	 lea	 edx, DWORD PTR _j$[ebp]
  000d0	83 c4 18	 add	 esp, 24			; 00000018H
  000d3	8d 4f 3f	 lea	 ecx, DWORD PTR [edi+63]
  000d6	33 c0		 xor	 eax, eax
  000d8	3b d1		 cmp	 edx, ecx
  000da	77 07		 ja	 SHORT $LN43@derive_u_w
  000dc	8d 55 f7	 lea	 edx, DWORD PTR _j$[ebp+63]
  000df	3b d7		 cmp	 edx, edi
  000e1	73 11		 jae	 SHORT $LL90@derive_u_w
$LN43@derive_u_w:
  000e3	8d 55 b3	 lea	 edx, DWORD PTR _k$[ebp+63]
  000e6	3b fa		 cmp	 edi, edx
  000e8	77 25		 ja	 SHORT $LN61@derive_u_w
  000ea	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  000f0	3b ca		 cmp	 ecx, edx
  000f2	72 1b		 jb	 SHORT $LN61@derive_u_w
$LL90@derive_u_w:

; 180  : 		{
; 181  : 			u[i] ^= k[i];

  000f4	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  000fa	03 c8		 add	 ecx, eax
  000fc	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  000ff	8a 09		 mov	 cl, BYTE PTR [ecx]
  00101	30 0a		 xor	 BYTE PTR [edx], cl

; 182  : 			j[i] = k[i];

  00103	88 4c 05 b8	 mov	 BYTE PTR _j$[ebp+eax], cl
  00107	40		 inc	 eax
  00108	83 f8 40	 cmp	 eax, 64			; 00000040H
  0010b	7c e7		 jl	 SHORT $LL90@derive_u_w

; 179  : 		for (i = 0; i < WHIRLPOOL_DIGESTSIZE; i++)

  0010d	eb 48		 jmp	 SHORT $LN2@derive_u_w
$LN61@derive_u_w:

; 182  : 			j[i] = k[i];

  0010f	8d 55 b8	 lea	 edx, DWORD PTR _j$[ebp]
  00112	2b d7		 sub	 edx, edi
$LL44@derive_u_w:

; 180  : 		{
; 181  : 			u[i] ^= k[i];

  00114	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  0011a	03 c8		 add	 ecx, eax
  0011c	0f 10 11	 movups	 xmm2, XMMWORD PTR [ecx]
  0011f	0f 10 04 0e	 movups	 xmm0, XMMWORD PTR [esi+ecx]
  00123	0f 28 ca	 movaps	 xmm1, xmm2
  00126	66 0f ef c8	 pxor	 xmm1, xmm0
  0012a	0f 11 0c 0e	 movups	 XMMWORD PTR [esi+ecx], xmm1
  0012e	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00131	0f 10 41 10	 movups	 xmm0, XMMWORD PTR [ecx+16]
  00135	0f 11 54 05 b8	 movups	 XMMWORD PTR _j$[ebp+eax], xmm2
  0013a	0f 10 54 05 84	 movups	 xmm2, XMMWORD PTR _k$[ebp+eax+16]
  0013f	83 c0 20	 add	 eax, 32			; 00000020H
  00142	0f 28 ca	 movaps	 xmm1, xmm2
  00145	66 0f ef c8	 pxor	 xmm1, xmm0
  00149	0f 11 49 10	 movups	 XMMWORD PTR [ecx+16], xmm1
  0014d	0f 11 54 0a 10	 movups	 XMMWORD PTR [edx+ecx+16], xmm2
  00152	83 f8 40	 cmp	 eax, 64			; 00000040H
  00155	7c bd		 jl	 SHORT $LL44@derive_u_w
$LN2@derive_u_w:

; 174  : 
; 175  : 	/* remaining iterations */
; 176  : 	for (c = 1; c < iterations; c++)

  00157	83 eb 01	 sub	 ebx, 1
  0015a	0f 85 50 ff ff
	ff		 jne	 $LL4@derive_u_w
$LN10@derive_u_w:

; 183  : 		}
; 184  : 	}
; 185  : 
; 186  : 	/* Prevent possible leaks. */
; 187  : 	burn (j, sizeof(j));

  00160	8d 45 b8	 lea	 eax, DWORD PTR _j$[ebp]
  00163	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00168	8b f1		 mov	 esi, ecx
  0016a	8b d0		 mov	 edx, eax
  0016c	0f 1f 40 00	 npad	 4
$LL20@derive_u_w:
  00170	c6 02 00	 mov	 BYTE PTR [edx], 0
  00173	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00176	83 ee 01	 sub	 esi, 1
  00179	75 f5		 jne	 SHORT $LL20@derive_u_w
  0017b	0f 1f 44 00 00	 npad	 5
$LL11@derive_u_w:
  00180	c6 00 00	 mov	 BYTE PTR [eax], 0
  00183	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00186	83 e9 01	 sub	 ecx, 1
  00189	75 f5		 jne	 SHORT $LL11@derive_u_w

; 188  : 	burn (k, sizeof(k));

  0018b	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  00191	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00196	8b f1		 mov	 esi, ecx
  00198	8b d0		 mov	 edx, eax
  0019a	66 0f 1f 44 00
	00		 npad	 6
$LL24@derive_u_w:
  001a0	c6 02 00	 mov	 BYTE PTR [edx], 0
  001a3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  001a6	83 ee 01	 sub	 esi, 1
  001a9	75 f5		 jne	 SHORT $LL24@derive_u_w
  001ab	5f		 pop	 edi
  001ac	5e		 pop	 esi
  001ad	5b		 pop	 ebx
  001ae	66 90		 npad	 2
$LL16@derive_u_w:
  001b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001b3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  001b6	83 e9 01	 sub	 ecx, 1
  001b9	75 f5		 jne	 SHORT $LL16@derive_u_w

; 189  : }

  001bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001be	33 cd		 xor	 ecx, ebp
  001c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c5	8b e5		 mov	 esp, ebp
  001c7	5d		 pop	 ebp
  001c8	c3		 ret	 0
_derive_u_whirlpool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\pkcs5.c
;	COMDAT _hmac_whirlpool
_TEXT	SEGMENT
_out$GSCopy$1$ = -772					; size = 4
_d$GSCopy$1$ = -768					; size = 4
_tctx$1 = -764						; size = 168
_octx$ = -596						; size = 168
_ictx$ = -428						; size = 168
_key$ = -260						; size = 64
_iwhi$ = -196						; size = 64
_owhi$ = -132						; size = 64
_buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_whirlpool PROC					; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 03 00
	00		 sub	 esp, 772		; 00000304H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _k$[ebp]
  0001a	56		 push	 esi

; 82   : 	WHIRLPOOL_CTX ictx, octx;
; 83   : 	char iwhi[WHIRLPOOL_DIGESTSIZE], owhi[WHIRLPOOL_DIGESTSIZE];
; 84   : 	char key[WHIRLPOOL_DIGESTSIZE];
; 85   : 	char buf[WHIRLPOOL_BLOCKSIZE];
; 86   : 	int i;
; 87   : 
; 88   :     /* If the key is longer than the hash algorithm block size,
; 89   : 	   let key = whirlpool(key), as per HMAC specifications. */
; 90   : 	if (lk > WHIRLPOOL_BLOCKSIZE)

  0001b	8b 75 0c	 mov	 esi, DWORD PTR _lk$[ebp]
  0001e	89 85 00 fd ff
	ff		 mov	 DWORD PTR _d$GSCopy$1$[ebp], eax
  00024	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00027	89 85 fc fc ff
	ff		 mov	 DWORD PTR _out$GSCopy$1$[ebp], eax
  0002d	57		 push	 edi
  0002e	83 fe 40	 cmp	 esi, 64			; 00000040H
  00031	7e 68		 jle	 SHORT $LN3@hmac_whirl

; 91   : 	{
; 92   : 		WHIRLPOOL_CTX tctx;
; 93   : 
; 94   : 		WHIRLPOOL_init (&tctx);

  00033	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$1[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _WHIRLPOOL_init

; 95   : 		WHIRLPOOL_add ((unsigned char *) k, lk * 8, &tctx);

  0003f	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$1[ebp]
  00045	50		 push	 eax
  00046	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  0004d	50		 push	 eax
  0004e	53		 push	 ebx
  0004f	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 96   : 		WHIRLPOOL_finalize (&tctx, (unsigned char *) key);

  00054	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  0005a	50		 push	 eax
  0005b	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$1[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize

; 97   : 
; 98   : 		k = key;
; 99   : 		lk = WHIRLPOOL_DIGESTSIZE;
; 100  : 
; 101  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  00067	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$1[ebp]
  0006d	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00072	83 c4 18	 add	 esp, 24			; 00000018H
  00075	8d 9d fc fe ff
	ff		 lea	 ebx, DWORD PTR _key$[ebp]
  0007b	be 40 00 00 00	 mov	 esi, 64			; 00000040H
  00080	8b f9		 mov	 edi, ecx
  00082	8b d0		 mov	 edx, eax
$LL52@hmac_whirl:
  00084	c6 02 00	 mov	 BYTE PTR [edx], 0
  00087	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0008a	83 ef 01	 sub	 edi, 1
  0008d	75 f5		 jne	 SHORT $LL52@hmac_whirl
  0008f	90		 npad	 1
$LL5@hmac_whirl:
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0
  00093	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00096	83 e9 01	 sub	 ecx, 1
  00099	75 f5		 jne	 SHORT $LL5@hmac_whirl
$LN3@hmac_whirl:

; 102  : 	}
; 103  : 
; 104  : 	/**** Inner Digest ****/
; 105  : 
; 106  : 	WHIRLPOOL_init (&ictx);

  0009b	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _WHIRLPOOL_init
  000a7	83 c4 04	 add	 esp, 4

; 107  : 
; 108  : 	/* Pad the key for inner digest */
; 109  : 	for (i = 0; i < lk; ++i)

  000aa	33 d2		 xor	 edx, edx
  000ac	85 f6		 test	 esi, esi
  000ae	0f 8e 7e 00 00
	00		 jle	 $LN8@hmac_whirl
  000b4	83 fe 20	 cmp	 esi, 32			; 00000020H
  000b7	72 5d		 jb	 SHORT $LN130@hmac_whirl

; 110  : 		buf[i] = (char) (k[i] ^ 0x36);

  000b9	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  000bc	03 c6		 add	 eax, esi
  000be	8d 7d bc	 lea	 edi, DWORD PTR _buf$[ebp]
  000c1	8d 4c 35 bb	 lea	 ecx, DWORD PTR _buf$[ebp+esi-1]
  000c5	3b f8		 cmp	 edi, eax
  000c7	77 04		 ja	 SHORT $LN131@hmac_whirl
  000c9	3b cb		 cmp	 ecx, ebx
  000cb	73 49		 jae	 SHORT $LN130@hmac_whirl
$LN131@hmac_whirl:
  000cd	8b c6		 mov	 eax, esi
  000cf	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  000d4	79 05		 jns	 SHORT $LN287@hmac_whirl
  000d6	48		 dec	 eax
  000d7	83 c8 e0	 or	 eax, -32		; ffffffe0H
  000da	40		 inc	 eax
$LN287@hmac_whirl:
  000db	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@36363636363636363636363636363636
  000e2	8b ce		 mov	 ecx, esi
  000e4	2b c8		 sub	 ecx, eax

; 107  : 
; 108  : 	/* Pad the key for inner digest */
; 109  : 	for (i = 0; i < lk; ++i)

  000e6	8b fb		 mov	 edi, ebx
  000e8	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  000eb	2b f8		 sub	 edi, eax
  000ed	0f 1f 00	 npad	 3
$LL9@hmac_whirl:
  000f0	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  000f3	0f 10 44 05 bc	 movups	 xmm0, XMMWORD PTR _buf$[ebp+eax]

; 110  : 		buf[i] = (char) (k[i] ^ 0x36);

  000f8	66 0f ef c1	 pxor	 xmm0, xmm1
  000fc	0f 11 44 15 bc	 movups	 XMMWORD PTR _buf$[ebp+edx], xmm0
  00101	0f 10 44 13 10	 movups	 xmm0, XMMWORD PTR [ebx+edx+16]
  00106	66 0f ef c1	 pxor	 xmm0, xmm1
  0010a	0f 11 44 15 cc	 movups	 XMMWORD PTR _buf$[ebp+edx+16], xmm0
  0010f	83 c2 20	 add	 edx, 32			; 00000020H
  00112	3b d1		 cmp	 edx, ecx
  00114	7c da		 jl	 SHORT $LL9@hmac_whirl
$LN130@hmac_whirl:

; 107  : 
; 108  : 	/* Pad the key for inner digest */
; 109  : 	for (i = 0; i < lk; ++i)

  00116	3b d6		 cmp	 edx, esi
  00118	7d 18		 jge	 SHORT $LN8@hmac_whirl
  0011a	8b fb		 mov	 edi, ebx
  0011c	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  0011f	2b f8		 sub	 edi, eax
$LL129@hmac_whirl:

; 110  : 		buf[i] = (char) (k[i] ^ 0x36);

  00121	8d 4d bc	 lea	 ecx, DWORD PTR _buf$[ebp]
  00124	03 ca		 add	 ecx, edx
  00126	42		 inc	 edx
  00127	8a 04 0f	 mov	 al, BYTE PTR [edi+ecx]
  0012a	34 36		 xor	 al, 54			; 00000036H
  0012c	88 01		 mov	 BYTE PTR [ecx], al
  0012e	3b d6		 cmp	 edx, esi
  00130	7c ef		 jl	 SHORT $LL129@hmac_whirl
$LN8@hmac_whirl:

; 111  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  00132	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00137	3b f0		 cmp	 esi, eax
  00139	7d 1c		 jge	 SHORT $LN11@hmac_whirl
  0013b	8b c8		 mov	 ecx, eax

; 112  : 		buf[i] = 0x36;

  0013d	8d 7d bc	 lea	 edi, DWORD PTR _buf$[ebp]
  00140	2b ce		 sub	 ecx, esi
  00142	03 fe		 add	 edi, esi
  00144	8b d1		 mov	 edx, ecx
  00146	b8 36 36 36 36	 mov	 eax, 909522486		; 36363636H
  0014b	c1 e9 02	 shr	 ecx, 2
  0014e	f3 ab		 rep stosd
  00150	8b ca		 mov	 ecx, edx
  00152	83 e1 03	 and	 ecx, 3
  00155	f3 aa		 rep stosb
$LN11@hmac_whirl:

; 113  : 
; 114  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &ictx);

  00157	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  0015d	50		 push	 eax
  0015e	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  00161	68 00 02 00 00	 push	 512			; 00000200H
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 115  : 	WHIRLPOOL_add ((unsigned char *) d, ld * 8, &ictx);

  0016c	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00172	50		 push	 eax
  00173	8b 45 14	 mov	 eax, DWORD PTR _ld$[ebp]
  00176	c1 e0 03	 shl	 eax, 3
  00179	50		 push	 eax
  0017a	ff b5 00 fd ff
	ff		 push	 DWORD PTR _d$GSCopy$1$[ebp]
  00180	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 116  : 
; 117  : 	WHIRLPOOL_finalize (&ictx, (unsigned char *) iwhi);

  00185	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  0018b	50		 push	 eax
  0018c	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize

; 118  : 
; 119  : 	/**** Outer Digest ****/
; 120  : 
; 121  : 	WHIRLPOOL_init (&octx);

  00198	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 _WHIRLPOOL_init
  001a4	83 c4 24	 add	 esp, 36			; 00000024H

; 122  : 
; 123  : 	for (i = 0; i < lk; ++i)

  001a7	33 d2		 xor	 edx, edx
  001a9	85 f6		 test	 esi, esi
  001ab	0f 8e 80 00 00
	00		 jle	 $LN14@hmac_whirl
  001b1	83 fe 20	 cmp	 esi, 32			; 00000020H
  001b4	72 60		 jb	 SHORT $LN133@hmac_whirl

; 124  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001b6	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  001b9	03 c6		 add	 eax, esi
  001bb	8d 7d bc	 lea	 edi, DWORD PTR _buf$[ebp]
  001be	8d 4c 35 bb	 lea	 ecx, DWORD PTR _buf$[ebp+esi-1]
  001c2	3b f8		 cmp	 edi, eax
  001c4	77 04		 ja	 SHORT $LN134@hmac_whirl
  001c6	3b cb		 cmp	 ecx, ebx
  001c8	73 4c		 jae	 SHORT $LN133@hmac_whirl
$LN134@hmac_whirl:
  001ca	8b c6		 mov	 eax, esi
  001cc	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  001d1	79 05		 jns	 SHORT $LN288@hmac_whirl
  001d3	48		 dec	 eax
  001d4	83 c8 e0	 or	 eax, -32		; ffffffe0H
  001d7	40		 inc	 eax
$LN288@hmac_whirl:
  001d8	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
  001df	8b ce		 mov	 ecx, esi
  001e1	2b c8		 sub	 ecx, eax

; 122  : 
; 123  : 	for (i = 0; i < lk; ++i)

  001e3	8b fb		 mov	 edi, ebx
  001e5	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  001e8	2b f8		 sub	 edi, eax
  001ea	66 0f 1f 44 00
	00		 npad	 6
$LL15@hmac_whirl:
  001f0	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  001f3	0f 10 44 05 bc	 movups	 xmm0, XMMWORD PTR _buf$[ebp+eax]

; 124  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001f8	66 0f ef c1	 pxor	 xmm0, xmm1
  001fc	0f 11 44 15 bc	 movups	 XMMWORD PTR _buf$[ebp+edx], xmm0
  00201	0f 10 44 13 10	 movups	 xmm0, XMMWORD PTR [ebx+edx+16]
  00206	66 0f ef c1	 pxor	 xmm0, xmm1
  0020a	0f 11 44 15 cc	 movups	 XMMWORD PTR _buf$[ebp+edx+16], xmm0
  0020f	83 c2 20	 add	 edx, 32			; 00000020H
  00212	3b d1		 cmp	 edx, ecx
  00214	7c da		 jl	 SHORT $LL15@hmac_whirl
$LN133@hmac_whirl:

; 122  : 
; 123  : 	for (i = 0; i < lk; ++i)

  00216	3b d6		 cmp	 edx, esi
  00218	7d 17		 jge	 SHORT $LN14@hmac_whirl
  0021a	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  0021d	2b d8		 sub	 ebx, eax
  0021f	90		 npad	 1
$LL132@hmac_whirl:

; 124  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00220	8d 4d bc	 lea	 ecx, DWORD PTR _buf$[ebp]
  00223	03 ca		 add	 ecx, edx
  00225	42		 inc	 edx
  00226	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  00229	34 5c		 xor	 al, 92			; 0000005cH
  0022b	88 01		 mov	 BYTE PTR [ecx], al
  0022d	3b d6		 cmp	 edx, esi
  0022f	7c ef		 jl	 SHORT $LL132@hmac_whirl
$LN14@hmac_whirl:

; 125  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  00231	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00236	3b f3		 cmp	 esi, ebx
  00238	7d 1c		 jge	 SHORT $LN17@hmac_whirl
  0023a	8b cb		 mov	 ecx, ebx

; 126  : 		buf[i] = 0x5C;

  0023c	8d 7d bc	 lea	 edi, DWORD PTR _buf$[ebp]
  0023f	2b ce		 sub	 ecx, esi
  00241	03 fe		 add	 edi, esi
  00243	8b d1		 mov	 edx, ecx
  00245	b8 5c 5c 5c 5c	 mov	 eax, 1549556828		; 5c5c5c5cH
  0024a	c1 e9 02	 shr	 ecx, 2
  0024d	f3 ab		 rep stosd
  0024f	8b ca		 mov	 ecx, edx
  00251	83 e1 03	 and	 ecx, 3
  00254	f3 aa		 rep stosb
$LN17@hmac_whirl:

; 127  : 
; 128  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  00256	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  0025c	50		 push	 eax
  0025d	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  00260	68 00 02 00 00	 push	 512			; 00000200H
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 129  : 	WHIRLPOOL_add ((unsigned char *) iwhi, WHIRLPOOL_DIGESTSIZE * 8, &octx);

  0026b	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00271	50		 push	 eax
  00272	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  00278	68 00 02 00 00	 push	 512			; 00000200H
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 130  : 
; 131  : 	WHIRLPOOL_finalize (&octx, (unsigned char *) owhi);

  00283	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _owhi$[ebp]
  00289	50		 push	 eax
  0028a	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00290	50		 push	 eax
  00291	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize

; 132  : 
; 133  : 	/* truncate and print the results */
; 134  : 	t = t > WHIRLPOOL_DIGESTSIZE ? WHIRLPOOL_DIGESTSIZE : t;

  00296	8b 45 1c	 mov	 eax, DWORD PTR _t$[ebp]
  00299	83 c4 20	 add	 esp, 32			; 00000020H
  0029c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0029f	0f 4f c3	 cmovg	 eax, ebx

; 135  : 	hmac_truncate (owhi, out, t);

  002a2	85 c0		 test	 eax, eax
  002a4	7e 16		 jle	 SHORT $LN21@hmac_whirl

; 127  : 
; 128  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  002a6	50		 push	 eax
  002a7	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _owhi$[ebp]
  002ad	50		 push	 eax
  002ae	ff b5 fc fc ff
	ff		 push	 DWORD PTR _out$GSCopy$1$[ebp]
  002b4	e8 00 00 00 00	 call	 _memcpy
  002b9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@hmac_whirl:

; 136  : 
; 137  : 	/* Prevent possible leaks. */
; 138  : 	burn (&ictx, sizeof(ictx));

  002bc	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  002c2	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  002c7	8b f1		 mov	 esi, ecx
  002c9	8b d0		 mov	 edx, eax
  002cb	0f 1f 44 00 00	 npad	 5
$LL61@hmac_whirl:
  002d0	c6 02 00	 mov	 BYTE PTR [edx], 0
  002d3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  002d6	83 ee 01	 sub	 esi, 1
  002d9	75 f5		 jne	 SHORT $LL61@hmac_whirl
  002db	0f 1f 44 00 00	 npad	 5
$LL22@hmac_whirl:
  002e0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002e3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002e6	83 e9 01	 sub	 ecx, 1
  002e9	75 f5		 jne	 SHORT $LL22@hmac_whirl

; 139  : 	burn (&octx, sizeof(octx));

  002eb	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  002f1	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  002f6	8b f1		 mov	 esi, ecx
  002f8	8b d0		 mov	 edx, eax
  002fa	66 0f 1f 44 00
	00		 npad	 6
$LL65@hmac_whirl:
  00300	c6 02 00	 mov	 BYTE PTR [edx], 0
  00303	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00306	83 ee 01	 sub	 esi, 1
  00309	75 f5		 jne	 SHORT $LL65@hmac_whirl
  0030b	0f 1f 44 00 00	 npad	 5
$LL27@hmac_whirl:
  00310	c6 00 00	 mov	 BYTE PTR [eax], 0
  00313	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00316	83 e9 01	 sub	 ecx, 1
  00319	75 f5		 jne	 SHORT $LL27@hmac_whirl

; 140  : 	burn (owhi, sizeof(owhi));

  0031b	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _owhi$[ebp]
  00321	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00326	8b f1		 mov	 esi, ecx
  00328	8b d0		 mov	 edx, eax
  0032a	66 0f 1f 44 00
	00		 npad	 6
$LL69@hmac_whirl:
  00330	c6 02 00	 mov	 BYTE PTR [edx], 0
  00333	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00336	83 ee 01	 sub	 esi, 1
  00339	75 f5		 jne	 SHORT $LL69@hmac_whirl
  0033b	0f 1f 44 00 00	 npad	 5
$LL32@hmac_whirl:
  00340	c6 00 00	 mov	 BYTE PTR [eax], 0
  00343	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00346	83 e9 01	 sub	 ecx, 1
  00349	75 f5		 jne	 SHORT $LL32@hmac_whirl

; 141  : 	burn (iwhi, sizeof(iwhi));

  0034b	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  00351	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00356	8b f1		 mov	 esi, ecx
  00358	8b d0		 mov	 edx, eax
  0035a	66 0f 1f 44 00
	00		 npad	 6
$LL73@hmac_whirl:
  00360	c6 02 00	 mov	 BYTE PTR [edx], 0
  00363	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00366	83 ee 01	 sub	 esi, 1
  00369	75 f5		 jne	 SHORT $LL73@hmac_whirl
  0036b	0f 1f 44 00 00	 npad	 5
$LL37@hmac_whirl:
  00370	c6 00 00	 mov	 BYTE PTR [eax], 0
  00373	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00376	83 e9 01	 sub	 ecx, 1
  00379	75 f5		 jne	 SHORT $LL37@hmac_whirl

; 142  : 	burn (buf, sizeof(buf));

  0037b	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  0037e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00383	8b f1		 mov	 esi, ecx
  00385	8b d0		 mov	 edx, eax
$LL77@hmac_whirl:
  00387	c6 02 00	 mov	 BYTE PTR [edx], 0
  0038a	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0038d	83 ee 01	 sub	 esi, 1
  00390	75 f5		 jne	 SHORT $LL77@hmac_whirl
$LL42@hmac_whirl:
  00392	c6 00 00	 mov	 BYTE PTR [eax], 0
  00395	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00398	83 e9 01	 sub	 ecx, 1
  0039b	75 f5		 jne	 SHORT $LL42@hmac_whirl

; 143  : 	burn (key, sizeof(key));

  0039d	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  003a3	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  003a8	8b f1		 mov	 esi, ecx
  003aa	8b d0		 mov	 edx, eax
  003ac	0f 1f 40 00	 npad	 4
$LL81@hmac_whirl:
  003b0	c6 02 00	 mov	 BYTE PTR [edx], 0
  003b3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  003b6	83 ee 01	 sub	 esi, 1
  003b9	75 f5		 jne	 SHORT $LL81@hmac_whirl
  003bb	5f		 pop	 edi
  003bc	5e		 pop	 esi
  003bd	5b		 pop	 ebx
  003be	66 90		 npad	 2
$LL47@hmac_whirl:
  003c0	c6 00 00	 mov	 BYTE PTR [eax], 0
  003c3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  003c6	83 e9 01	 sub	 ecx, 1
  003c9	75 f5		 jne	 SHORT $LL47@hmac_whirl

; 144  : }

  003cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ce	33 cd		 xor	 ecx, ebp
  003d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d5	8b e5		 mov	 esp, ebp
  003d7	5d		 pop	 ebp
  003d8	c3		 ret	 0
_hmac_whirlpool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
