; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Format\InPlace.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	_sscanf
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
PUBLIC	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
PUBLIC	_CheckRequirementsForNonSysInPlaceEnc
PUBLIC	_EncryptPartitionInPlaceBegin
PUBLIC	_EncryptPartitionInPlaceResume
PUBLIC	_ShowInPlaceEncErrMsgWAltSteps
PUBLIC	_SetNonSysInplaceEncUIStatus
PUBLIC	_FastVolumeHeaderUpdate
PUBLIC	_SaveNonSysInPlaceEncSettings
PUBLIC	_ZeroUnreadableSectors
PUBLIC	_MoveClustersBeforeThreshold
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@ABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0CI@PMIJHGDI@OS_NOT_SUPPORTED_FOR_NONSYS_INPL@ ; `string'
PUBLIC	??_C@_0BJ@IDFJMMLD@?2Device?2HarddiskVolume?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BP@MDCLODBD@?2Device?2Harddisk?$CFd?2Partition?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BJ@KPKOCMJM@INPLACE_ENC_INVALID_PATH?$AA@ ; `string'
PUBLIC	??_C@_0CG@BBECDHBI@RAW_DEV_NOT_SUPPORTED_FOR_INPLAC@ ; `string'
PUBLIC	??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@ ; `string'
PUBLIC	??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@ ; `string'
PUBLIC	??_C@_04HPPAIJNK@NTFS?$AA@			; `string'
PUBLIC	??_C@_0CL@COOAAIGJ@ONLY_NTFS_SUPPORTED_FOR_NONSYS_I@ ; `string'
PUBLIC	??_C@_0DC@BPGKKGKD@ONLY_MOUNTED_VOL_SUPPORTED_FOR_N@ ; `string'
PUBLIC	??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@ ; `string'
PUBLIC	??_C@_0CL@EKBFECDJ@PARTITION_TOO_SMALL_FOR_NONSYS_I@ ; `string'
PUBLIC	??_C@_0CJ@DJNLKEPP@NOT_ENOUGH_FREE_FILESYS_SPACE_FO@ ; `string'
PUBLIC	??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@	; `string'
PUBLIC	??_C@_0BG@EBLNDPCA@CANNOT_RESIZE_FILESYS?$AA@	; `string'
PUBLIC	??_C@_0L@DLEMDKJB@?1prinplace?$AA@		; `string'
PUBLIC	??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@ ; `string'
PUBLIC	??_C@_0BI@KOHPIJFG@ZEROED_BAD_SECTOR_COUNT?$AA@	; `string'
PUBLIC	??_C@_0BK@KFDNCGEE@DEVICE_IN_USE_INPLACE_ENC?$AA@ ; `string'
PUBLIC	??_C@_0CK@OMIEFGPE@INPLACE_ENC_CANT_LOCK_OR_DISMOUN@ ; `string'
PUBLIC	??_C@_0CG@LMIKKFBM@VOL_LOCK_FAILED_OFFER_FORCED_DIS@ ; `string'
PUBLIC	??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@	; `string'
PUBLIC	??_C@_0BO@LGBJGGOF@INPLACE_ENC_ALTERNATIVE_STEPS?$AA@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@ ; `string'
PUBLIC	??_C@_0BE@NLGDPAAC@In?9Place?5Encryption?$AA@	; `string'
PUBLIC	??_C@_15PKPONJIK@?$AA?2?$AA?$CK?$AA?$AA@	; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_19MJCDBCKE@?$AA?2?$AA?2?$AA?$DP?$AA?2?$AA?$AA@ ; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@		; `string'
PUBLIC	??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@		; `string'
PUBLIC	??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@		; `string'
PUBLIC	??_C@_15DBHGMMAD@?$AAX?$AA?3?$AA?$AA@		; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	__xmm@ffffffffffffffffffffffffffffffff
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_memmove:PROC
EXTRN	_strncmp:PROC
EXTRN	_remove:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___stdio_common_vsscanf:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileW@8:PROC
EXTRN	__imp__FindNextFileW@8:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	__imp__VirtualUnlock@8:PROC
EXTRN	__imp__GetVolumeInformationA@32:PROC
EXTRN	__imp__wsprintfW:PROC
EXTRN	_crypto_open:PROC
EXTRN	_crypto_close:PROC
EXTRN	_EncryptDataUnits:PROC
EXTRN	_DecryptDataUnits:PROC
EXTRN	_EncryptBuffer:PROC
EXTRN	_DecryptBuffer:PROC
EXTRN	_GetCrc32:PROC
EXTRN	_GetHeaderField32:PROC
EXTRN	_ReadVolumeHeader:PROC
EXTRN	_CreateVolumeHeaderInMemory:PROC
EXTRN	_ReadEffectiveVolumeHeader:PROC
EXTRN	_WriteEffectiveVolumeHeader:PROC
EXTRN	_WriteRandomDataToReservedHeaderAreas:PROC
EXTRN	_GetWipePassCount:PROC
EXTRN	_WipeBuffer:PROC
EXTRN	_FakeDosNameForDevice:PROC
EXTRN	_RemoveFakeDosName:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	_IsDiskReadError:PROC
EXTRN	_ToUNICODE:PROC
EXTRN	_LoadNonSysInPlaceEncSettings:PROC
EXTRN	_RemoveNonSysInPlaceEncNotifications:PROC
EXTRN	_CloseVolumeExplorerWindows:PROC
EXTRN	_IsDeviceMounted:PROC
EXTRN	_IsAdmin:PROC
EXTRN	_GetDiskDeviceDriveLetter:PROC
EXTRN	_GetDeviceSize:PROC
EXTRN	_FileExists:PROC
EXTRN	_SaveBufferToFile:PROC
EXTRN	_IsNonInstallMode:PROC
EXTRN	_ManageStartupSeqWiz:PROC
EXTRN	_GetSizeString:PROC
EXTRN	_GetConfigPath:PROC
EXTRN	_Warning:PROC
EXTRN	_WarningDirect:PROC
EXTRN	_Error:PROC
EXTRN	_ErrorDirect:PROC
EXTRN	_AskWarnYesNo:PROC
EXTRN	_AskWarnNoYes:PROC
EXTRN	_GetString:PROC
EXTRN	_GetVolumeDataAreaSize:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_MainDlg:DWORD
EXTRN	_CurrentOSMajor:DWORD
EXTRN	_bVolTransformThreadCancel:DWORD
EXTRN	_bInPlaceEncNonSysResumed:DWORD
EXTRN	_bFirstNonSysInPlaceEncResumeDone:DWORD
EXTRN	_NonSysInplaceEncBytesDone:QWORD
EXTRN	_NonSysInplaceEncTotalSize:QWORD
EXTRN	_NonSysInplaceEncStatus:DWORD
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __xmm@ffffffffffffffffffffffffffffffff
CONST	SEGMENT
__xmm@ffffffffffffffffffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15DBHGMMAD@?$AAX?$AA?3?$AA?$AA@
CONST	SEGMENT
??_C@_15DBHGMMAD@?$AAX?$AA?3?$AA?$AA@ DB 'X', 00H, ':', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@ DB '\', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@
CONST	SEGMENT
??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@ DB '.', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@ DB '.', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19MJCDBCKE@?$AA?2?$AA?2?$AA?$DP?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_19MJCDBCKE@?$AA?2?$AA?2?$AA?$DP?$AA?2?$AA?$AA@ DB '\', 00H, '\', 00H
	DB	'?', 00H, '\', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15PKPONJIK@?$AA?2?$AA?$CK?$AA?$AA@
CONST	SEGMENT
??_C@_15PKPONJIK@?$AA?2?$AA?$CK?$AA?$AA@ DB '\', 00H, '*', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLGDPAAC@In?9Place?5Encryption?$AA@
CONST	SEGMENT
??_C@_0BE@NLGDPAAC@In?9Place?5Encryption?$AA@ DB 'In-Place Encryption', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@
CONST	SEGMENT
??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@ DB 'In-Place En'
	DB	'cryption Wipe Algo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LGBJGGOF@INPLACE_ENC_ALTERNATIVE_STEPS?$AA@
CONST	SEGMENT
??_C@_0BO@LGBJGGOF@INPLACE_ENC_ALTERNATIVE_STEPS?$AA@ DB 'INPLACE_ENC_ALT'
	DB	'ERNATIVE_STEPS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@ DB 0aH, 00H, 0aH, 00H, 0aH, 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LMIKKFBM@VOL_LOCK_FAILED_OFFER_FORCED_DIS@
CONST	SEGMENT
??_C@_0CG@LMIKKFBM@VOL_LOCK_FAILED_OFFER_FORCED_DIS@ DB 'VOL_LOCK_FAILED_'
	DB	'OFFER_FORCED_DISMOUNT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OMIEFGPE@INPLACE_ENC_CANT_LOCK_OR_DISMOUN@
CONST	SEGMENT
??_C@_0CK@OMIEFGPE@INPLACE_ENC_CANT_LOCK_OR_DISMOUN@ DB 'INPLACE_ENC_CANT'
	DB	'_LOCK_OR_DISMOUNT_FILESYS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KFDNCGEE@DEVICE_IN_USE_INPLACE_ENC?$AA@
CONST	SEGMENT
??_C@_0BK@KFDNCGEE@DEVICE_IN_USE_INPLACE_ENC?$AA@ DB 'DEVICE_IN_USE_INPLA'
	DB	'CE_ENC', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KOHPIJFG@ZEROED_BAD_SECTOR_COUNT?$AA@
CONST	SEGMENT
??_C@_0BI@KOHPIJFG@ZEROED_BAD_SECTOR_COUNT?$AA@ DB 'ZEROED_BAD_SECTOR_COU'
	DB	'NT', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@
CONST	SEGMENT
??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@ DB 'ENABLE_BAD_SECTOR_Z'
	DB	'EROING', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DLEMDKJB@?1prinplace?$AA@
CONST	SEGMENT
??_C@_0L@DLEMDKJB@?1prinplace?$AA@ DB '/prinplace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EBLNDPCA@CANNOT_RESIZE_FILESYS?$AA@
CONST	SEGMENT
??_C@_0BG@EBLNDPCA@CANNOT_RESIZE_FILESYS?$AA@ DB 'CANNOT_RESIZE_FILESYS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
CONST	SEGMENT
??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@ DB 'SECTOR_SIZE_UNSUPPORT'
	DB	'ED', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DJNLKEPP@NOT_ENOUGH_FREE_FILESYS_SPACE_FO@
CONST	SEGMENT
??_C@_0CJ@DJNLKEPP@NOT_ENOUGH_FREE_FILESYS_SPACE_FO@ DB 'NOT_ENOUGH_FREE_'
	DB	'FILESYS_SPACE_FOR_SHRINK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EKBFECDJ@PARTITION_TOO_SMALL_FOR_NONSYS_I@
CONST	SEGMENT
??_C@_0CL@EKBFECDJ@PARTITION_TOO_SMALL_FOR_NONSYS_I@ DB 'PARTITION_TOO_SM'
	DB	'ALL_FOR_NONSYS_INPLACE_ENC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
CONST	SEGMENT
??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@ DB 'INPLACE_ENC_CANT'
	DB	'_ACCESS_OR_GET_INFO_ON_VOL_ALT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BPGKKGKD@ONLY_MOUNTED_VOL_SUPPORTED_FOR_N@
CONST	SEGMENT
??_C@_0DC@BPGKKGKD@ONLY_MOUNTED_VOL_SUPPORTED_FOR_N@ DB 'ONLY_MOUNTED_VOL'
	DB	'_SUPPORTED_FOR_NONSYS_INPLACE_ENC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@COOAAIGJ@ONLY_NTFS_SUPPORTED_FOR_NONSYS_I@
CONST	SEGMENT
??_C@_0CL@COOAAIGJ@ONLY_NTFS_SUPPORTED_FOR_NONSYS_I@ DB 'ONLY_NTFS_SUPPOR'
	DB	'TED_FOR_NONSYS_INPLACE_ENC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPPAIJNK@NTFS?$AA@
CONST	SEGMENT
??_C@_04HPPAIJNK@NTFS?$AA@ DB 'NTFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
CONST	SEGMENT
??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@ DB 'INPLACE_ENC_CANT'
	DB	'_ACCESS_OR_GET_INFO_ON_VOL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@
CONST	SEGMENT
??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@ DB 'ADMIN_PRIVILEGE'
	DB	'S_WARN_DEVICES', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BBECDHBI@RAW_DEV_NOT_SUPPORTED_FOR_INPLAC@
CONST	SEGMENT
??_C@_0CG@BBECDHBI@RAW_DEV_NOT_SUPPORTED_FOR_INPLAC@ DB 'RAW_DEV_NOT_SUPP'
	DB	'ORTED_FOR_INPLACE_ENC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KPKOCMJM@INPLACE_ENC_INVALID_PATH?$AA@
CONST	SEGMENT
??_C@_0BJ@KPKOCMJM@INPLACE_ENC_INVALID_PATH?$AA@ DB 'INPLACE_ENC_INVALID_'
	DB	'PATH', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MDCLODBD@?2Device?2Harddisk?$CFd?2Partition?$CFd?$AA@
CONST	SEGMENT
??_C@_0BP@MDCLODBD@?2Device?2Harddisk?$CFd?2Partition?$CFd?$AA@ DB '\Devi'
	DB	'ce\Harddisk%d\Partition%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IDFJMMLD@?2Device?2HarddiskVolume?$CFd?$AA@
CONST	SEGMENT
??_C@_0BJ@IDFJMMLD@?2Device?2HarddiskVolume?$CFd?$AA@ DB '\Device\Harddis'
	DB	'kVolume%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PMIJHGDI@OS_NOT_SUPPORTED_FOR_NONSYS_INPL@
CONST	SEGMENT
??_C@_0CI@PMIJHGDI@OS_NOT_SUPPORTED_FOR_NONSYS_INPL@ DB 'OS_NOT_SUPPORTED'
	DB	'_FOR_NONSYS_INPLACE_ENC', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z$0
__ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$0
__ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT ??1Finally1862@?5??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally1862@?5??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ PROC ; `MoveClustersBeforeThresholdInDir'::`6'::Finally1862::~Finally1862, COMDAT
; _this$ = ecx

; 1862 : 		finally_do_arg (HANDLE, fsObject, { CloseHandle (finally_arg); });

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00008	c3		 ret	 0
??1Finally1862@?5??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ENDP ; `MoveClustersBeforeThresholdInDir'::`6'::Finally1862::~Finally1862
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT ??0Finally1862@?5??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally1862@?5??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z PROC ; `MoveClustersBeforeThresholdInDir'::`6'::Finally1862::Finally1862, COMDAT
; _this$ = ecx

; 1862 : 		finally_do_arg (HANDLE, fsObject, { CloseHandle (finally_arg); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally1862@?5??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z ENDP ; `MoveClustersBeforeThresholdInDir'::`6'::Finally1862::Finally1862
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@ABV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@ABV10@@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2393 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2394 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00007	56		 push	 esi
  00008	6a ff		 push	 -1
  0000a	6a 00		 push	 0
  0000c	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00016	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0001b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	33 c9		 xor	 ecx, ecx
  00020	50		 push	 eax
  00021	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00028	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002f	66 89 0e	 mov	 WORD PTR [esi], cx
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi

; 2395 : 	}

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@ABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z PROC ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2479 : 	{	// test for string vs. NTCS equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2480 : 	return (_Left.compare(_Right) == 0);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000b	75 04		 jne	 SHORT $LN7@operator
  0000d	33 c0		 xor	 eax, eax
  0000f	eb 14		 jmp	 SHORT $LN8@operator
$LN7@operator:
  00011	8b c2		 mov	 eax, edx
  00013	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
$LL32@operator:
  00016	66 8b 08	 mov	 cx, WORD PTR [eax]
  00019	83 c0 02	 add	 eax, 2
  0001c	66 85 c9	 test	 cx, cx
  0001f	75 f5		 jne	 SHORT $LL32@operator
  00021	2b c6		 sub	 eax, esi
  00023	d1 f8		 sar	 eax, 1
$LN8@operator:
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00028	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  0002c	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]
  0002f	72 02		 jb	 SHORT $LN28@operator
  00031	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN28@operator:
  00033	50		 push	 eax
  00034	52		 push	 edx
  00035	ff 36		 push	 DWORD PTR [esi]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
  0003d	83 c4 10	 add	 esp, 16			; 00000010H
  00040	85 c0		 test	 eax, eax
  00042	0f 94 c0	 sete	 al
  00045	5e		 pop	 esi

; 2481 : 	}

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ENDP ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT ??1Finally1837@?1??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally1837@?1??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ PROC ; `MoveClustersBeforeThresholdInDir'::`2'::Finally1837::~Finally1837, COMDAT
; _this$ = ecx

; 1837 : 	finally_do_arg (HANDLE, findHandle, { FindClose (finally_arg); });

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  00008	c3		 ret	 0
??1Finally1837@?1??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ENDP ; `MoveClustersBeforeThresholdInDir'::`2'::Finally1837::~Finally1837
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT ??0Finally1837@?1??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally1837@?1??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z PROC ; `MoveClustersBeforeThresholdInDir'::`2'::Finally1837::Finally1837, COMDAT
; _this$ = ecx

; 1837 : 	finally_do_arg (HANDLE, findHandle, { FindClose (finally_arg); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally1837@?1??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z ENDP ; `MoveClustersBeforeThresholdInDir'::`2'::Finally1837::Finally1837
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2355 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 2356 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

  0002d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00030	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00037	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0003e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00045	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00049	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00050	72 04		 jb	 SHORT $LN107@operator
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	eb 02		 jmp	 SHORT $LN108@operator
$LN107@operator:
  00056	8b c6		 mov	 eax, esi
$LN108@operator:
  00058	33 c9		 xor	 ecx, ecx
  0005a	66 89 08	 mov	 WORD PTR [eax], cx

; 2360 : 	return (_Ans);

  0005d	8b 7d 10	 mov	 edi, DWORD PTR __Right$[ebp]
  00060	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00063	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ecx
  00066	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0006d	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  00070	66 39 0f	 cmp	 WORD PTR [edi], cx
  00073	74 1a		 je	 SHORT $LN129@operator

; 2357 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));

$LN128@operator:
  00075	8b cf		 mov	 ecx, edi
  00077	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL190@operator:
  00080	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00083	83 c1 02	 add	 ecx, 2
  00086	66 85 c0	 test	 ax, ax
  00089	75 f5		 jne	 SHORT $LL190@operator
  0008b	2b ca		 sub	 ecx, edx
  0008d	d1 f9		 sar	 ecx, 1
$LN129@operator:
  0008f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00092	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00095	3b d8		 cmp	 ebx, eax
  00097	77 28		 ja	 SHORT $LN176@operator
  00099	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  0009c	74 23		 je	 SHORT $LN176@operator
  0009e	6a 01		 push	 1
  000a0	50		 push	 eax
  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
  000a8	84 c0		 test	 al, al
  000aa	74 15		 je	 SHORT $LN176@operator
  000ac	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b0	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000b3	72 04		 jb	 SHORT $LN171@operator
  000b5	8b 06		 mov	 eax, DWORD PTR [esi]
  000b7	eb 02		 jmp	 SHORT $LN172@operator
$LN171@operator:
  000b9	8b c6		 mov	 eax, esi
$LN172@operator:
  000bb	33 c9		 xor	 ecx, ecx
  000bd	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN176@operator:

; 2358 : 	_Ans += _Left;

  000c1	6a ff		 push	 -1
  000c3	6a 00		 push	 0
  000c5	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  000c8	8b ce		 mov	 ecx, esi
  000ca	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2359 : 	_Ans += _Right;

  000cf	66 83 3f 00	 cmp	 WORD PTR [edi], 0
  000d3	75 04		 jne	 SHORT $LN188@operator
  000d5	33 c9		 xor	 ecx, ecx
  000d7	eb 16		 jmp	 SHORT $LN189@operator
$LN188@operator:
  000d9	8b cf		 mov	 ecx, edi
  000db	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  000de	66 90		 npad	 2
$LL191@operator:
  000e0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000e3	83 c1 02	 add	 ecx, 2
  000e6	66 85 c0	 test	 ax, ax
  000e9	75 f5		 jne	 SHORT $LL191@operator
  000eb	2b ca		 sub	 ecx, edx
  000ed	d1 f9		 sar	 ecx, 1
$LN189@operator:
  000ef	51		 push	 ecx
  000f0	57		 push	 edi
  000f1	8b ce		 mov	 ecx, esi
  000f3	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2360 : 	return (_Ans);

  000f8	8b c6		 mov	 eax, esi

; 2361 : 	}

  000fa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00104	59		 pop	 ecx
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2439 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2440 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  00013	75 04		 jne	 SHORT $LN9@operator
  00015	33 c0		 xor	 eax, eax
  00017	eb 16		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00019	8b c2		 mov	 eax, edx
  0001b	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0001e	66 90		 npad	 2
$LL141@operator:
  00020	66 8b 08	 mov	 cx, WORD PTR [eax]
  00023	83 c0 02	 add	 eax, 2
  00026	66 85 c9	 test	 cx, cx
  00029	75 f5		 jne	 SHORT $LL141@operator
  0002b	2b c6		 sub	 eax, esi
  0002d	d1 f8		 sar	 eax, 1
$LN10@operator:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00032	50		 push	 eax
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00039	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	33 c9		 xor	 ecx, ecx
  0003e	50		 push	 eax
  0003f	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	66 89 0e	 mov	 WORD PTR [esi], cx
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi

; 2441 : 	}

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2327 : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 2328 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

  0002d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00030	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00037	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0003e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00045	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00049	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00050	72 04		 jb	 SHORT $LN107@operator
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	eb 02		 jmp	 SHORT $LN108@operator
$LN107@operator:
  00056	8b c6		 mov	 eax, esi
$LN108@operator:
  00058	33 c9		 xor	 ecx, ecx
  0005a	66 89 08	 mov	 WORD PTR [eax], cx

; 2332 : 	return (_Ans);

  0005d	8b 7d 0c	 mov	 edi, DWORD PTR __Left$[ebp]
  00060	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ecx
  00063	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0006a	66 39 0f	 cmp	 WORD PTR [edi], cx
  0006d	74 14		 je	 SHORT $LN117@operator

; 2329 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());

$LN116@operator:
  0006f	8b cf		 mov	 ecx, edi
  00071	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL190@operator:
  00074	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00077	83 c1 02	 add	 ecx, 2
  0007a	66 85 c0	 test	 ax, ax
  0007d	75 f5		 jne	 SHORT $LL190@operator
  0007f	2b ca		 sub	 ecx, edx
  00081	d1 f9		 sar	 ecx, 1
$LN117@operator:
  00083	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00086	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00089	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0008c	03 c1		 add	 eax, ecx
  0008e	3b d8		 cmp	 ebx, eax
  00090	77 28		 ja	 SHORT $LN176@operator
  00092	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00095	74 23		 je	 SHORT $LN176@operator
  00097	6a 01		 push	 1
  00099	50		 push	 eax
  0009a	8b ce		 mov	 ecx, esi
  0009c	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
  000a1	84 c0		 test	 al, al
  000a3	74 15		 je	 SHORT $LN176@operator
  000a5	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000a9	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000ac	72 04		 jb	 SHORT $LN171@operator
  000ae	8b 06		 mov	 eax, DWORD PTR [esi]
  000b0	eb 02		 jmp	 SHORT $LN172@operator
$LN171@operator:
  000b2	8b c6		 mov	 eax, esi
$LN172@operator:
  000b4	33 c9		 xor	 ecx, ecx
  000b6	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN176@operator:

; 2330 : 	_Ans += _Left;

  000ba	66 83 3f 00	 cmp	 WORD PTR [edi], 0
  000be	75 04		 jne	 SHORT $LN184@operator
  000c0	33 c9		 xor	 ecx, ecx
  000c2	eb 1b		 jmp	 SHORT $LN185@operator
$LN184@operator:
  000c4	8b cf		 mov	 ecx, edi
  000c6	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL191@operator:
  000d0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000d3	83 c1 02	 add	 ecx, 2
  000d6	66 85 c0	 test	 ax, ax
  000d9	75 f5		 jne	 SHORT $LL191@operator
  000db	2b ca		 sub	 ecx, edx
  000dd	d1 f9		 sar	 ecx, 1
$LN185@operator:
  000df	51		 push	 ecx
  000e0	57		 push	 edi
  000e1	8b ce		 mov	 ecx, esi
  000e3	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2331 : 	_Ans += _Right;

  000e8	6a ff		 push	 -1
  000ea	6a 00		 push	 0
  000ec	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  000ef	8b ce		 mov	 ecx, esi
  000f1	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2332 : 	return (_Ans);

  000f6	8b c6		 mov	 eax, esi

; 2333 : 	}

  000f8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00102	59		 pop	 ecx
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT ?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z
_TEXT	SEGMENT
_startVcn$2 = -820					; size = 8
_finally1837$ = -812					; size = 4
_findHandle$1$ = -808					; size = 4
_bytesReturned$3 = -804					; size = 4
_extentStartCluster$2$ = -800				; size = 4
_extentStartCluster$1$ = -796				; size = 4
_finally1862$4 = -792					; size = 4
_fsObject$1$ = -788					; size = 4
_directory$GSCopy$1$ = -784				; size = 4
_extentEndCluster$1$ = -780				; size = 4
_volumeHandle$GSCopy$1$ = -776				; size = 4
_extentEndCluster$2$ = -772				; size = 4
_findData$ = -768					; size = 592
$T5 = -176						; size = 24
$T6 = -152						; size = 24
_moveData$7 = -128					; size = 32
$T8 = -120						; size = 24
_retPointers$9 = -96					; size = 32
$T10 = -64						; size = 24
$T11 = -64						; size = 24
$T12 = -40						; size = 24
_subDir$13 = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_volumeHandle$ = 8					; size = 4
_directory$ = 12					; size = 4
_clusterThreshold$ = 16					; size = 8
?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z PROC ; MoveClustersBeforeThresholdInDir, COMDAT

; 1830 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 28 03 00
	00		 sub	 esp, 808		; 00000328H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _directory$[ebp]

; 1831 : 	WIN32_FIND_DATAW findData;
; 1832 : 
; 1833 : 	HANDLE findHandle = FindFirstFileW (((directory.size() <= 3 ? L"" : L"\\\\?\\") + directory + L"\\*").c_str(), &findData);

  00031	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_19MJCDBCKE@?$AA?2?$AA?2?$AA?$DP?$AA?2?$AA?$AA@
  00036	8b 45 08	 mov	 eax, DWORD PTR _volumeHandle$[ebp]
  00039	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _volumeHandle$GSCopy$1$[ebp], eax
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  00044	51		 push	 ecx
  00045	83 79 10 03	 cmp	 DWORD PTR [ecx+16], 3
  00049	89 8d f0 fc ff
	ff		 mov	 DWORD PTR _directory$GSCopy$1$[ebp], ecx
  0004f	0f 47 c2	 cmova	 eax, edx
  00052	50		 push	 eax
  00053	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_15PKPONJIK@?$AA?2?$AA?$CK?$AA?$AA@
  00064	50		 push	 eax
  00065	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00078	83 c4 18	 add	 esp, 24			; 00000018H
  0007b	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0007f	72 02		 jb	 SHORT $LN67@MoveCluste
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
$LN67@MoveCluste:
  00083	8d 8d 00 fd ff
	ff		 lea	 ecx, DWORD PTR _findData$[ebp]
  00089	51		 push	 ecx
  0008a	50		 push	 eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileW@8
  00091	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp+20]
  00097	8b d8		 mov	 ebx, eax
  00099	89 9d d8 fc ff
	ff		 mov	 DWORD PTR _findHandle$1$[ebp], ebx
  0009f	83 f9 08	 cmp	 ecx, 8
  000a2	72 13		 jb	 SHORT $LN76@MoveCluste
  000a4	41		 inc	 ecx
  000a5	51		 push	 ecx
  000a6	ff b5 68 ff ff
	ff		 push	 DWORD PTR $T6[ebp]
  000ac	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000b2	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN76@MoveCluste:
  000b7	33 c0		 xor	 eax, eax
  000b9	c7 85 7c ff ff
	ff 07 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 7
  000c3	66 89 85 68 ff
	ff ff		 mov	 WORD PTR $T6[ebp], ax
  000ca	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp+20]
  000d0	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0
  000da	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000e1	83 f8 08	 cmp	 eax, 8
  000e4	72 13		 jb	 SHORT $LN179@MoveCluste
  000e6	40		 inc	 eax
  000e7	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000ed	50		 push	 eax
  000ee	ff b5 50 ff ff
	ff		 push	 DWORD PTR $T5[ebp]
  000f4	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN179@MoveCluste:
  000f9	33 c0		 xor	 eax, eax
  000fb	c7 85 64 ff ff
	ff 07 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 7
  00105	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0
  0010f	66 89 85 50 ff
	ff ff		 mov	 WORD PTR $T5[ebp], ax

; 1834 : 	if (findHandle == INVALID_HANDLE_VALUE)

  00116	83 fb ff	 cmp	 ebx, -1
  00119	75 0a		 jne	 SHORT $LN13@MoveCluste

; 1835 : 		return TRUE;	// Error ignored

  0011b	b8 01 00 00 00	 mov	 eax, 1
  00120	e9 82 04 00 00	 jmp	 $LN1@MoveCluste
$LN13@MoveCluste:

; 1836 : 
; 1837 : 	finally_do_arg (HANDLE, findHandle, { FindClose (finally_arg); });

  00125	89 9d d4 fc ff
	ff		 mov	 DWORD PTR _finally1837$[ebp], ebx
  0012b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
$LL4@MoveCluste:

; 1838 : 
; 1839 : 	// Find all files and directories
; 1840 : 	do
; 1841 : 	{
; 1842 : 		if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)

  00132	f6 85 00 fd ff
	ff 10		 test	 BYTE PTR _findData$[ebp], 16 ; 00000010H
  00139	0f 84 76 01 00
	00		 je	 $LN882@MoveCluste

; 1843 : 		{
; 1844 : 			wstring subDir = findData.cFileName;

  0013f	33 c0		 xor	 eax, eax
  00141	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR _subDir$13[ebp+20], 7
  00148	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _subDir$13[ebp+16], 0
  0014f	66 89 45 d8	 mov	 WORD PTR _subDir$13[ebp], ax
  00153	66 39 85 2c fd
	ff ff		 cmp	 WORD PTR _findData$[ebp+44], ax
  0015a	75 04		 jne	 SHORT $LN390@MoveCluste
  0015c	33 c9		 xor	 ecx, ecx
  0015e	eb 1f		 jmp	 SHORT $LN391@MoveCluste
$LN390@MoveCluste:
  00160	8d 8d 2c fd ff
	ff		 lea	 ecx, DWORD PTR _findData$[ebp+44]
  00166	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  00169	0f 1f 80 00 00
	00 00		 npad	 7
$LL1237@MoveCluste:
  00170	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00173	83 c1 02	 add	 ecx, 2
  00176	66 85 c0	 test	 ax, ax
  00179	75 f5		 jne	 SHORT $LL1237@MoveCluste
  0017b	2b ca		 sub	 ecx, edx
  0017d	d1 f9		 sar	 ecx, 1
$LN391@MoveCluste:
  0017f	51		 push	 ecx
  00180	8d 85 2c fd ff
	ff		 lea	 eax, DWORD PTR _findData$[ebp+44]
  00186	50		 push	 eax
  00187	8d 4d d8	 lea	 ecx, DWORD PTR _subDir$13[ebp]
  0018a	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1845 : 
; 1846 : 			if (subDir == L"." || subDir == L"..")

  0018f	8b 5d ec	 mov	 ebx, DWORD PTR _subDir$13[ebp+20]
  00192	8d 4d d8	 lea	 ecx, DWORD PTR _subDir$13[ebp]
  00195	8b 55 d8	 mov	 edx, DWORD PTR _subDir$13[ebp]
  00198	83 fb 08	 cmp	 ebx, 8
  0019b	8b 7d e8	 mov	 edi, DWORD PTR _subDir$13[ebp+16]
  0019e	be 01 00 00 00	 mov	 esi, 1
  001a3	0f 43 ca	 cmovae	 ecx, edx
  001a6	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001aa	3b fe		 cmp	 edi, esi
  001ac	0f 42 f7	 cmovb	 esi, edi
  001af	85 f6		 test	 esi, esi
  001b1	74 27		 je	 SHORT $LN1255@MoveCluste
  001b3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
  001b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL435@MoveCluste:
  001c0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  001c3	66 3b 02	 cmp	 ax, WORD PTR [edx]
  001c6	0f 85 81 02 00
	00		 jne	 $LN1217@MoveCluste
  001cc	83 c1 02	 add	 ecx, 2
  001cf	83 c2 02	 add	 edx, 2
  001d2	83 ee 01	 sub	 esi, 1
  001d5	75 e9		 jne	 SHORT $LL435@MoveCluste
  001d7	8b 55 d8	 mov	 edx, DWORD PTR _subDir$13[ebp]
$LN1255@MoveCluste:
  001da	33 c0		 xor	 eax, eax
$LN432@MoveCluste:
  001dc	85 c0		 test	 eax, eax
  001de	75 0b		 jne	 SHORT $LN423@MoveCluste
  001e0	83 ff 01	 cmp	 edi, 1
  001e3	72 06		 jb	 SHORT $LN423@MoveCluste
  001e5	0f 86 76 02 00
	00		 jbe	 $LN16@MoveCluste
$LN423@MoveCluste:
  001eb	6a 02		 push	 2
  001ed	83 fb 08	 cmp	 ebx, 8
  001f0	8d 45 d8	 lea	 eax, DWORD PTR _subDir$13[ebp]
  001f3	68 00 00 00 00	 push	 OFFSET ??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@
  001f8	0f 43 c2	 cmovae	 eax, edx
  001fb	57		 push	 edi
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
  00202	83 c4 10	 add	 esp, 16			; 00000010H
  00205	85 c0		 test	 eax, eax
  00207	0f 84 54 02 00
	00		 je	 $LN16@MoveCluste

; 1848 : 
; 1849 : 			if (!MoveClustersBeforeThresholdInDir (volumeHandle, directory + L"\\" + subDir, clusterThreshold))

  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
  00212	ff b5 f0 fc ff
	ff		 push	 DWORD PTR _directory$GSCopy$1$[ebp]
  00218	8d 45 88	 lea	 eax, DWORD PTR $T8[ebp]
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00221	8d 4d d8	 lea	 ecx, DWORD PTR _subDir$13[ebp]
  00224	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00228	51		 push	 ecx
  00229	50		 push	 eax
  0022a	8d 45 c0	 lea	 eax, DWORD PTR $T11[ebp]
  0022d	50		 push	 eax
  0022e	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@ABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00233	ff 75 14	 push	 DWORD PTR _clusterThreshold$[ebp+4]
  00236	8b 7d 10	 mov	 edi, DWORD PTR _clusterThreshold$[ebp]
  00239	57		 push	 edi
  0023a	50		 push	 eax
  0023b	ff b5 f8 fc ff
	ff		 push	 DWORD PTR _volumeHandle$GSCopy$1$[ebp]
  00241	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00245	e8 00 00 00 00	 call	 ?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z ; MoveClustersBeforeThresholdInDir
  0024a	83 c4 28	 add	 esp, 40			; 00000028H
  0024d	85 c0		 test	 eax, eax
  0024f	8b 45 d4	 mov	 eax, DWORD PTR $T11[ebp+20]
  00252	0f 94 c3	 sete	 bl
  00255	83 f8 08	 cmp	 eax, 8
  00258	72 0d		 jb	 SHORT $LN578@MoveCluste
  0025a	40		 inc	 eax
  0025b	8d 4d c0	 lea	 ecx, DWORD PTR $T11[ebp]
  0025e	50		 push	 eax
  0025f	ff 75 c0	 push	 DWORD PTR $T11[ebp]
  00262	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN578@MoveCluste:
  00267	33 c0		 xor	 eax, eax
  00269	c7 45 d4 07 00
	00 00		 mov	 DWORD PTR $T11[ebp+20], 7
  00270	66 89 45 c0	 mov	 WORD PTR $T11[ebp], ax
  00274	8b 45 9c	 mov	 eax, DWORD PTR $T8[ebp+20]
  00277	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T11[ebp+16], 0
  0027e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00282	83 f8 08	 cmp	 eax, 8
  00285	72 0d		 jb	 SHORT $LN681@MoveCluste
  00287	40		 inc	 eax
  00288	8d 4d 88	 lea	 ecx, DWORD PTR $T8[ebp]
  0028b	50		 push	 eax
  0028c	ff 75 88	 push	 DWORD PTR $T8[ebp]
  0028f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN681@MoveCluste:

; 1851 : 		}

  00294	8b 45 ec	 mov	 eax, DWORD PTR _subDir$13[ebp+20]
  00297	84 db		 test	 bl, bl
  00299	0f 85 24 03 00
	00		 jne	 $LN1221@MoveCluste
  0029f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  002a3	83 f8 08	 cmp	 eax, 8
  002a6	72 0d		 jb	 SHORT $LN882@MoveCluste
  002a8	40		 inc	 eax
  002a9	8d 4d d8	 lea	 ecx, DWORD PTR _subDir$13[ebp]
  002ac	50		 push	 eax
  002ad	ff 75 d8	 push	 DWORD PTR _subDir$13[ebp]
  002b0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN882@MoveCluste:

; 1852 : 
; 1853 : 		DWORD access = FILE_READ_ATTRIBUTES;
; 1854 : 
; 1855 : 		if (findData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)

  002b5	8b b5 00 fd ff
	ff		 mov	 esi, DWORD PTR _findData$[ebp]

; 1856 : 			access = FILE_READ_DATA;
; 1857 : 
; 1858 : 		HANDLE fsObject = CreateFileW ((directory + L"\\" + findData.cFileName).c_str(), access, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

  002bb	8d 45 d8	 lea	 eax, DWORD PTR $T12[ebp]
  002be	81 e6 00 40 00
	00		 and	 esi, 16384		; 00004000H
  002c4	f7 de		 neg	 esi
  002c6	68 00 00 00 00	 push	 OFFSET ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
  002cb	ff b5 f0 fc ff
	ff		 push	 DWORD PTR _directory$GSCopy$1$[ebp]
  002d1	1b f6		 sbb	 esi, esi
  002d3	83 e6 81	 and	 esi, -127		; ffffff81H
  002d6	50		 push	 eax
  002d7	83 ee 80	 sub	 esi, -128		; ffffff80H
  002da	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  002df	8d 8d 2c fd ff
	ff		 lea	 ecx, DWORD PTR _findData$[ebp+44]
  002e5	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  002e9	51		 push	 ecx
  002ea	50		 push	 eax
  002eb	8d 45 c0	 lea	 eax, DWORD PTR $T10[ebp]
  002ee	50		 push	 eax
  002ef	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  002f4	83 c4 18	 add	 esp, 24			; 00000018H
  002f7	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  002fb	72 02		 jb	 SHORT $LN998@MoveCluste
  002fd	8b 00		 mov	 eax, DWORD PTR [eax]
$LN998@MoveCluste:
  002ff	6a 00		 push	 0
  00301	68 00 00 00 02	 push	 33554432		; 02000000H
  00306	6a 03		 push	 3
  00308	6a 00		 push	 0
  0030a	6a 07		 push	 7
  0030c	56		 push	 esi
  0030d	50		 push	 eax
  0030e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileW@28
  00314	8b 4d d4	 mov	 ecx, DWORD PTR $T10[ebp+20]
  00317	8b d8		 mov	 ebx, eax
  00319	89 9d ec fc ff
	ff		 mov	 DWORD PTR _fsObject$1$[ebp], ebx
  0031f	83 f9 08	 cmp	 ecx, 8
  00322	72 0d		 jb	 SHORT $LN1007@MoveCluste
  00324	41		 inc	 ecx
  00325	51		 push	 ecx
  00326	ff 75 c0	 push	 DWORD PTR $T10[ebp]
  00329	8d 4d c0	 lea	 ecx, DWORD PTR $T10[ebp]
  0032c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1007@MoveCluste:
  00331	33 c0		 xor	 eax, eax
  00333	c7 45 d4 07 00
	00 00		 mov	 DWORD PTR $T10[ebp+20], 7
  0033a	66 89 45 c0	 mov	 WORD PTR $T10[ebp], ax
  0033e	8b 45 ec	 mov	 eax, DWORD PTR $T12[ebp+20]
  00341	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T10[ebp+16], 0
  00348	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0034c	83 f8 08	 cmp	 eax, 8
  0034f	72 0d		 jb	 SHORT $LN1110@MoveCluste
  00351	40		 inc	 eax
  00352	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  00355	50		 push	 eax
  00356	ff 75 d8	 push	 DWORD PTR $T12[ebp]
  00359	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1110@MoveCluste:
  0035e	33 c0		 xor	 eax, eax
  00360	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T12[ebp+20], 7
  00367	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T12[ebp+16], 0
  0036e	66 89 45 d8	 mov	 WORD PTR $T12[ebp], ax

; 1859 : 		if (fsObject == INVALID_HANDLE_VALUE)

  00372	83 fb ff	 cmp	 ebx, -1
  00375	0f 84 00 02 00
	00		 je	 $LN2@MoveCluste

; 1860 : 			continue;
; 1861 : 
; 1862 : 		finally_do_arg (HANDLE, fsObject, { CloseHandle (finally_arg); });

  0037b	0f 57 c0	 xorps	 xmm0, xmm0
  0037e	89 9d e8 fc ff
	ff		 mov	 DWORD PTR _finally1862$4[ebp], ebx

; 1863 : 
; 1864 : 		STARTING_VCN_INPUT_BUFFER startVcn;
; 1865 : 		startVcn.StartingVcn.QuadPart = 0;

  00384	66 0f 13 85 cc
	fc ff ff	 movlpd	 QWORD PTR _startVcn$2[ebp], xmm0
  0038c	0f 1f 40 00	 npad	 4
$LL5@MoveCluste:

; 1866 : 		RETRIEVAL_POINTERS_BUFFER retPointers;
; 1867 : 		DWORD bytesReturned;
; 1868 : 
; 1869 : 		// Find clusters allocated beyond the threshold
; 1870 : 		while (DeviceIoControl (fsObject, FSCTL_GET_RETRIEVAL_POINTERS, &startVcn, sizeof (startVcn), &retPointers, sizeof (retPointers), &bytesReturned, NULL)
; 1871 : 			|| GetLastError() == ERROR_MORE_DATA)

  00390	6a 00		 push	 0
  00392	8d 85 dc fc ff
	ff		 lea	 eax, DWORD PTR _bytesReturned$3[ebp]
  00398	50		 push	 eax
  00399	6a 20		 push	 32			; 00000020H
  0039b	8d 45 a0	 lea	 eax, DWORD PTR _retPointers$9[ebp]
  0039e	50		 push	 eax
  0039f	6a 08		 push	 8
  003a1	8d 85 cc fc ff
	ff		 lea	 eax, DWORD PTR _startVcn$2[ebp]
  003a7	50		 push	 eax
  003a8	68 73 00 09 00	 push	 589939			; 00090073H
  003ad	53		 push	 ebx
  003ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  003b4	85 c0		 test	 eax, eax
  003b6	75 11		 jne	 SHORT $LN20@MoveCluste
  003b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  003be	3d ea 00 00 00	 cmp	 eax, 234		; 000000eaH
  003c3	0f 85 a7 01 00
	00		 jne	 $LN1220@MoveCluste
$LN20@MoveCluste:

; 1872 : 		{
; 1873 : 			if (retPointers.ExtentCount == 0)

  003c9	83 7d a0 00	 cmp	 DWORD PTR _retPointers$9[ebp], 0
  003cd	0f 84 9d 01 00
	00		 je	 $LN1220@MoveCluste

; 1874 : 				break;
; 1875 : 
; 1876 : 			if (retPointers.Extents[0].Lcn.QuadPart != -1)

  003d3	8b 55 b8	 mov	 edx, DWORD PTR _retPointers$9[ebp+24]
  003d6	8b c2		 mov	 eax, edx
  003d8	8b 5d bc	 mov	 ebx, DWORD PTR _retPointers$9[ebp+28]
  003db	23 c3		 and	 eax, ebx
  003dd	89 95 e4 fc ff
	ff		 mov	 DWORD PTR _extentStartCluster$1$[ebp], edx
  003e3	89 9d e0 fc ff
	ff		 mov	 DWORD PTR _extentStartCluster$2$[ebp], ebx
  003e9	83 f8 ff	 cmp	 eax, -1
  003ec	0f 84 61 01 00
	00		 je	 $LN1253@MoveCluste

; 1877 : 			{
; 1878 : 				int64 extentStartCluster = retPointers.Extents[0].Lcn.QuadPart;
; 1879 : 				int64 extentLen = retPointers.Extents[0].NextVcn.QuadPart - retPointers.StartingVcn.QuadPart;
; 1880 : 				int64 extentEndCluster = extentStartCluster + extentLen - 1;

  003f2	8b 45 b0	 mov	 eax, DWORD PTR _retPointers$9[ebp+16]
  003f5	8b f0		 mov	 esi, eax
  003f7	2b 75 a8	 sub	 esi, DWORD PTR _retPointers$9[ebp+8]
  003fa	8b 4d b4	 mov	 ecx, DWORD PTR _retPointers$9[ebp+20]
  003fd	8b f9		 mov	 edi, ecx
  003ff	1b 7d ac	 sbb	 edi, DWORD PTR _retPointers$9[ebp+12]
  00402	03 f2		 add	 esi, edx
  00404	13 fb		 adc	 edi, ebx
  00406	83 ee 01	 sub	 esi, 1
  00409	89 bd fc fc ff
	ff		 mov	 DWORD PTR _extentEndCluster$2$[ebp], edi
  0040f	83 9d fc fc ff
	ff 00		 sbb	 DWORD PTR _extentEndCluster$2$[ebp], 0

; 1881 : 
; 1882 : 				if (extentEndCluster >= clusterThreshold)

  00416	8b 7d 10	 mov	 edi, DWORD PTR _clusterThreshold$[ebp]
  00419	89 b5 f4 fc ff
	ff		 mov	 DWORD PTR _extentEndCluster$1$[ebp], esi
  0041f	8b 75 14	 mov	 esi, DWORD PTR _clusterThreshold$[ebp+4]
  00422	39 b5 fc fc ff
	ff		 cmp	 DWORD PTR _extentEndCluster$2$[ebp], esi
  00428	0f 8c 2b 01 00
	00		 jl	 $LN1247@MoveCluste
  0042e	7f 0c		 jg	 SHORT $LN1238@MoveCluste
  00430	39 bd f4 fc ff
	ff		 cmp	 DWORD PTR _extentEndCluster$1$[ebp], edi
  00436	0f 82 1d 01 00
	00		 jb	 $LN1247@MoveCluste
$LN1238@MoveCluste:

; 1883 : 				{
; 1884 : 					// Move clusters before the threshold
; 1885 : 					for (int64 movedCluster = max (extentStartCluster, clusterThreshold); movedCluster <= extentEndCluster; ++movedCluster)

  0043c	3b de		 cmp	 ebx, esi
  0043e	7c 42		 jl	 SHORT $LN28@MoveCluste
  00440	7f 04		 jg	 SHORT $LN1239@MoveCluste
  00442	3b d7		 cmp	 edx, edi
  00444	76 3c		 jbe	 SHORT $LN28@MoveCluste
$LN1239@MoveCluste:
  00446	8b fa		 mov	 edi, edx
  00448	8b 55 10	 mov	 edx, DWORD PTR _clusterThreshold$[ebp]
  0044b	eb 3c		 jmp	 SHORT $LN29@MoveCluste
$LN1217@MoveCluste:

; 1845 : 
; 1846 : 			if (subDir == L"." || subDir == L"..")

  0044d	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00450	66 3b 02	 cmp	 ax, WORD PTR [edx]
  00453	8b 55 d8	 mov	 edx, DWORD PTR _subDir$13[ebp]
  00456	1b c0		 sbb	 eax, eax
  00458	83 e0 fe	 and	 eax, -2			; fffffffeH
  0045b	40		 inc	 eax
  0045c	e9 7b fd ff ff	 jmp	 $LN432@MoveCluste
$LN16@MoveCluste:

; 1847 : 				continue;

  00461	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00465	83 fb 08	 cmp	 ebx, 8
  00468	0f 82 0d 01 00
	00		 jb	 $LN2@MoveCluste
  0046e	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00471	50		 push	 eax
  00472	ff 75 d8	 push	 DWORD PTR _subDir$13[ebp]
  00475	8d 4d d8	 lea	 ecx, DWORD PTR _subDir$13[ebp]
  00478	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  0047d	e9 f9 00 00 00	 jmp	 $LN2@MoveCluste
$LN28@MoveCluste:

; 1883 : 				{
; 1884 : 					// Move clusters before the threshold
; 1885 : 					for (int64 movedCluster = max (extentStartCluster, clusterThreshold); movedCluster <= extentEndCluster; ++movedCluster)

  00482	8b 55 10	 mov	 edx, DWORD PTR _clusterThreshold$[ebp]
  00485	8b de		 mov	 ebx, esi
  00487	8b fa		 mov	 edi, edx
$LN29@MoveCluste:
  00489	3b 9d fc fc ff
	ff		 cmp	 ebx, DWORD PTR _extentEndCluster$2$[ebp]
  0048f	0f 8f c4 00 00
	00		 jg	 $LN1247@MoveCluste
  00495	7c 0c		 jl	 SHORT $LL1244@MoveCluste
  00497	3b bd f4 fc ff
	ff		 cmp	 edi, DWORD PTR _extentEndCluster$1$[ebp]
  0049d	0f 87 b6 00 00
	00		 ja	 $LN1247@MoveCluste
$LL1244@MoveCluste:

; 1886 : 					{
; 1887 : 						for (int retry = 0; ; ++retry)

  004a3	33 f6		 xor	 esi, esi
$LL12@MoveCluste:

; 1888 : 						{
; 1889 : 							MOVE_FILE_DATA moveData;
; 1890 : 
; 1891 : 							if (GetFreeClusterBeforeThreshold (volumeHandle, &moveData.StartingLcn.QuadPart, clusterThreshold))

  004a5	ff 75 14	 push	 DWORD PTR _clusterThreshold$[ebp+4]
  004a8	8d 45 90	 lea	 eax, DWORD PTR _moveData$7[ebp+16]
  004ab	52		 push	 edx
  004ac	50		 push	 eax
  004ad	ff b5 f8 fc ff
	ff		 push	 DWORD PTR _volumeHandle$GSCopy$1$[ebp]
  004b3	e8 00 00 00 00	 call	 ?GetFreeClusterBeforeThreshold@@YAHPAXPA_J_J@Z ; GetFreeClusterBeforeThreshold
  004b8	83 c4 10	 add	 esp, 16			; 00000010H
  004bb	85 c0		 test	 eax, eax
  004bd	74 54		 je	 SHORT $LN25@MoveCluste

; 1892 : 							{
; 1893 : 								moveData.FileHandle = fsObject;

  004bf	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _fsObject$1$[ebp]

; 1894 : 								moveData.StartingVcn.QuadPart = movedCluster - extentStartCluster + retPointers.StartingVcn.QuadPart;

  004c5	8b cf		 mov	 ecx, edi
  004c7	2b 8d e4 fc ff
	ff		 sub	 ecx, DWORD PTR _extentStartCluster$1$[ebp]
  004cd	89 45 80	 mov	 DWORD PTR _moveData$7[ebp], eax
  004d0	8b c3		 mov	 eax, ebx
  004d2	1b 85 e0 fc ff
	ff		 sbb	 eax, DWORD PTR _extentStartCluster$2$[ebp]
  004d8	03 4d a8	 add	 ecx, DWORD PTR _retPointers$9[ebp+8]

; 1895 : 								moveData.ClusterCount = 1;
; 1896 : 
; 1897 : 								if (DeviceIoControl (volumeHandle, FSCTL_MOVE_FILE, &moveData, sizeof (moveData), NULL, 0, &bytesReturned, NULL))

  004db	6a 00		 push	 0
  004dd	13 45 ac	 adc	 eax, DWORD PTR _retPointers$9[ebp+12]
  004e0	89 45 8c	 mov	 DWORD PTR _moveData$7[ebp+12], eax
  004e3	8d 85 dc fc ff
	ff		 lea	 eax, DWORD PTR _bytesReturned$3[ebp]
  004e9	50		 push	 eax
  004ea	6a 00		 push	 0
  004ec	6a 00		 push	 0
  004ee	6a 20		 push	 32			; 00000020H
  004f0	8d 45 80	 lea	 eax, DWORD PTR _moveData$7[ebp]
  004f3	89 4d 88	 mov	 DWORD PTR _moveData$7[ebp+8], ecx
  004f6	50		 push	 eax
  004f7	68 74 00 09 00	 push	 589940			; 00090074H
  004fc	ff b5 f8 fc ff
	ff		 push	 DWORD PTR _volumeHandle$GSCopy$1$[ebp]
  00502	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _moveData$7[ebp+24], 1
  00509	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0050f	85 c0		 test	 eax, eax
  00511	75 1d		 jne	 SHORT $LN7@MoveCluste
$LN25@MoveCluste:

; 1898 : 									break;
; 1899 : 							}
; 1900 : 
; 1901 : 							if (retry > 600)

  00513	81 fe 58 02 00
	00		 cmp	 esi, 600		; 00000258H
  00519	0f 8f ba 00 00
	00		 jg	 $LN1219@MoveCluste

; 1903 : 
; 1904 : 							// There are possible race conditions as we work on a live filesystem
; 1905 : 							Sleep (100);

  0051f	6a 64		 push	 100			; 00000064H
  00521	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  00527	8b 55 10	 mov	 edx, DWORD PTR _clusterThreshold$[ebp]
  0052a	46		 inc	 esi
  0052b	e9 75 ff ff ff	 jmp	 $LL12@MoveCluste
$LN7@MoveCluste:

; 1883 : 				{
; 1884 : 					// Move clusters before the threshold
; 1885 : 					for (int64 movedCluster = max (extentStartCluster, clusterThreshold); movedCluster <= extentEndCluster; ++movedCluster)

  00530	8b 55 10	 mov	 edx, DWORD PTR _clusterThreshold$[ebp]
  00533	83 c7 01	 add	 edi, 1
  00536	83 d3 00	 adc	 ebx, 0
  00539	3b 9d fc fc ff
	ff		 cmp	 ebx, DWORD PTR _extentEndCluster$2$[ebp]
  0053f	0f 8c 5e ff ff
	ff		 jl	 $LL1244@MoveCluste
  00545	7f 0c		 jg	 SHORT $LN1253@MoveCluste
  00547	3b bd f4 fc ff
	ff		 cmp	 edi, DWORD PTR _extentEndCluster$1$[ebp]
  0054d	0f 86 50 ff ff
	ff		 jbe	 $LL1244@MoveCluste
$LN1253@MoveCluste:
  00553	8b 4d b4	 mov	 ecx, DWORD PTR _retPointers$9[ebp+20]
  00556	8b 45 b0	 mov	 eax, DWORD PTR _retPointers$9[ebp+16]
$LN1247@MoveCluste:

; 1906 : 						}
; 1907 : 					}
; 1908 : 				}
; 1909 : 			}
; 1910 : 
; 1911 : 			startVcn.StartingVcn = retPointers.Extents[0].NextVcn;
; 1912 : 		}

  00559	8b 9d ec fc ff
	ff		 mov	 ebx, DWORD PTR _fsObject$1$[ebp]
  0055f	89 85 cc fc ff
	ff		 mov	 DWORD PTR _startVcn$2[ebp], eax
  00565	89 8d d0 fc ff
	ff		 mov	 DWORD PTR _startVcn$2[ebp+4], ecx
  0056b	e9 20 fe ff ff	 jmp	 $LL5@MoveCluste
$LN1220@MoveCluste:

; 1913 : 
; 1914 : 	} while (FindNextFileW (findHandle, &findData));

  00570	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR _finally1862$4[ebp]
  00576	e8 00 00 00 00	 call	 ??1Finally1862@?5??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ; `MoveClustersBeforeThresholdInDir'::`6'::Finally1862::~Finally1862
$LN2@MoveCluste:
  0057b	8b 9d d8 fc ff
	ff		 mov	 ebx, DWORD PTR _findHandle$1$[ebp]
  00581	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR _findData$[ebp]
  00587	50		 push	 eax
  00588	53		 push	 ebx
  00589	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileW@8
  0058f	85 c0		 test	 eax, eax
  00591	0f 85 9b fb ff
	ff		 jne	 $LL4@MoveCluste

; 1915 : 
; 1916 : 	return TRUE;

  00597	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LN40@MoveCluste:
  0059a	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR _finally1837$[ebp]
  005a0	e8 00 00 00 00	 call	 ??1Finally1837@?1??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ; `MoveClustersBeforeThresholdInDir'::`2'::Finally1837::~Finally1837
  005a5	8b c6		 mov	 eax, esi
$LN1@MoveCluste:

; 1917 : }

  005a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005b1	59		 pop	 ecx
  005b2	5f		 pop	 edi
  005b3	5e		 pop	 esi
  005b4	5b		 pop	 ebx
  005b5	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b8	33 cd		 xor	 ecx, ebp
  005ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005bf	8b e5		 mov	 esp, ebp
  005c1	5d		 pop	 ebp
  005c2	c3		 ret	 0
$LN1221@MoveCluste:

; 1850 : 				return FALSE;

  005c3	83 f8 08	 cmp	 eax, 8
  005c6	72 0d		 jb	 SHORT $LN784@MoveCluste
  005c8	40		 inc	 eax
  005c9	8d 4d d8	 lea	 ecx, DWORD PTR _subDir$13[ebp]
  005cc	50		 push	 eax
  005cd	ff 75 d8	 push	 DWORD PTR _subDir$13[ebp]
  005d0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN784@MoveCluste:
  005d5	33 f6		 xor	 esi, esi
  005d7	eb c1		 jmp	 SHORT $LN40@MoveCluste
$LN1219@MoveCluste:

; 1902 : 								return FALSE;

  005d9	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR _finally1862$4[ebp]
  005df	e8 00 00 00 00	 call	 ??1Finally1862@?5??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ; `MoveClustersBeforeThresholdInDir'::`6'::Finally1862::~Finally1862
  005e4	33 f6		 xor	 esi, esi
  005e6	eb b2		 jmp	 SHORT $LN40@MoveCluste
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$0:
  00000	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$2:
  0000b	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR _finally1837$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Finally1837@?1??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ; `MoveClustersBeforeThresholdInDir'::`2'::Finally1837::~Finally1837
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$3:
  00016	8d 4d d8	 lea	 ecx, DWORD PTR _subDir$13[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$4:
  0001e	8d 4d 88	 lea	 ecx, DWORD PTR $T8[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$5:
  00026	8d 4d c0	 lea	 ecx, DWORD PTR $T11[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$6:
  0002e	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  00031	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z:
  00036	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003d	8b 8a c8 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-824]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004d	33 c8		 xor	 ecx, eax
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z
  00059	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z ENDP ; MoveClustersBeforeThresholdInDir
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT ?GetFreeClusterBeforeThreshold@@YAHPAXPA_J_J@Z
_TEXT	SEGMENT
_bytesReturned$ = -65604				; size = 4
_bitmapIndex$1 = -65600					; size = 8
_freeCluster$GSCopy$1$ = -65592				; size = 4
_volumeHandle$GSCopy$1$ = -65588			; size = 4
_bitmapBuffer$2$ = -65584				; size = 4
tv215 = -65580						; size = 4
_startLcn$ = -65576					; size = 8
_bitmapBuffer$1$ = -65568				; size = 4
_bitmapBuffer$ = -65564					; size = 65560
__$ArrayPad$ = -4					; size = 4
_volumeHandle$ = 8					; size = 4
_freeCluster$ = 12					; size = 4
_clusterThreshold$ = 16					; size = 8
?GetFreeClusterBeforeThreshold@@YAHPAXPA_J_J@Z PROC	; GetFreeClusterBeforeThreshold, COMDAT

; 1775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 44 00 01 00	 mov	 eax, 65604		; 00010044H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _volumeHandle$[ebp]
  0001a	0f 57 c0	 xorps	 xmm0, xmm0
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _freeCluster$[ebp]
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	89 85 cc ff fe
	ff		 mov	 DWORD PTR _volumeHandle$GSCopy$1$[ebp], eax
  00028	89 8d c8 ff fe
	ff		 mov	 DWORD PTR _freeCluster$GSCopy$1$[ebp], ecx

; 1776 : 	const int bitmapSize = 65536;
; 1777 : 	byte bitmapBuffer[bitmapSize + sizeof (VOLUME_BITMAP_BUFFER)];
; 1778 : 	VOLUME_BITMAP_BUFFER *bitmap = (VOLUME_BITMAP_BUFFER *) bitmapBuffer;
; 1779 : 	STARTING_LCN_INPUT_BUFFER startLcn;
; 1780 : 	startLcn.StartingLcn.QuadPart = 0;

  0002e	66 0f 13 85 d8
	ff fe ff	 movlpd	 QWORD PTR _startLcn$[ebp], xmm0
  00036	57		 push	 edi
$LL2@GetFreeClu:

; 1781 : 
; 1782 : 	DWORD bytesReturned;
; 1783 : 	while (DeviceIoControl (volumeHandle, FSCTL_GET_VOLUME_BITMAP, &startLcn, sizeof (startLcn), &bitmapBuffer, sizeof (bitmapBuffer), &bytesReturned, NULL)
; 1784 : 		|| GetLastError() == ERROR_MORE_DATA)

  00037	6a 00		 push	 0
  00039	8d 8d bc ff fe
	ff		 lea	 ecx, DWORD PTR _bytesReturned$[ebp]
  0003f	51		 push	 ecx
  00040	68 18 00 01 00	 push	 65560			; 00010018H
  00045	8d 8d e4 ff fe
	ff		 lea	 ecx, DWORD PTR _bitmapBuffer$[ebp]
  0004b	51		 push	 ecx
  0004c	6a 08		 push	 8
  0004e	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR _startLcn$[ebp]
  00054	51		 push	 ecx
  00055	68 6f 00 09 00	 push	 589935			; 0009006fH
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00061	85 c0		 test	 eax, eax
  00063	75 11		 jne	 SHORT $LN10@GetFreeClu
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0006b	3d ea 00 00 00	 cmp	 eax, 234		; 000000eaH
  00070	0f 85 6a 01 00
	00		 jne	 $err$44
$LN10@GetFreeClu:
  00076	8b 85 f0 ff fe
	ff		 mov	 eax, DWORD PTR _bitmapBuffer$[ebp+12]
  0007c	0f 57 c0	 xorps	 xmm0, xmm0
  0007f	6a 00		 push	 0
  00081	6a 08		 push	 8
  00083	50		 push	 eax
  00084	89 85 d0 ff fe
	ff		 mov	 DWORD PTR _bitmapBuffer$2$[ebp], eax
  0008a	8b 85 ec ff fe
	ff		 mov	 eax, DWORD PTR _bitmapBuffer$[ebp+8]
  00090	50		 push	 eax

; 1785 : 	{
; 1786 : 		for (int64 bitmapIndex = 0; bitmapIndex < min (bitmapSize, (bitmap->BitmapSize.QuadPart / 8)); ++bitmapIndex)

  00091	66 0f 13 85 c0
	ff fe ff	 movlpd	 QWORD PTR _bitmapIndex$1[ebp], xmm0
  00099	89 85 e0 ff fe
	ff		 mov	 DWORD PTR _bitmapBuffer$1$[ebp], eax
  0009f	e8 00 00 00 00	 call	 __alldiv
  000a4	8b bd c4 ff fe
	ff		 mov	 edi, DWORD PTR _bitmapIndex$1[ebp+4]
  000aa	8b d8		 mov	 ebx, eax
  000ac	8b b5 c0 ff fe
	ff		 mov	 esi, DWORD PTR _bitmapIndex$1[ebp]
  000b2	8b c2		 mov	 eax, edx
  000b4	89 85 d4 ff fe
	ff		 mov	 DWORD PTR tv215[ebp], eax
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL6@GetFreeClu:
  000c0	85 c0		 test	 eax, eax
  000c2	7c 13		 jl	 SHORT $LN18@GetFreeClu
  000c4	7f 08		 jg	 SHORT $LN36@GetFreeClu
  000c6	81 fb 00 00 01
	00		 cmp	 ebx, 65536		; 00010000H
  000cc	76 09		 jbe	 SHORT $LN18@GetFreeClu
$LN36@GetFreeClu:
  000ce	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  000d3	33 c0		 xor	 eax, eax
  000d5	eb 02		 jmp	 SHORT $LN19@GetFreeClu
$LN18@GetFreeClu:
  000d7	8b cb		 mov	 ecx, ebx
$LN19@GetFreeClu:
  000d9	3b f8		 cmp	 edi, eax
  000db	7f 67		 jg	 SHORT $LN5@GetFreeClu
  000dd	7c 04		 jl	 SHORT $LN37@GetFreeClu
  000df	3b f1		 cmp	 esi, ecx
  000e1	73 61		 jae	 SHORT $LN5@GetFreeClu
$LN37@GetFreeClu:

; 1787 : 		{
; 1788 : 			if (bitmap->StartingLcn.QuadPart + bitmapIndex * 8 >= clusterThreshold)

  000e3	8b ce		 mov	 ecx, esi
  000e5	8b c7		 mov	 eax, edi
  000e7	0f a4 c8 03	 shld	 eax, ecx, 3
  000eb	c1 e1 03	 shl	 ecx, 3
  000ee	03 8d e4 ff fe
	ff		 add	 ecx, DWORD PTR _bitmapBuffer$[ebp]
  000f4	13 85 e8 ff fe
	ff		 adc	 eax, DWORD PTR _bitmapBuffer$[ebp+4]
  000fa	3b 45 14	 cmp	 eax, DWORD PTR _clusterThreshold$[ebp+4]
  000fd	0f 8f dd 00 00
	00		 jg	 $err$44
  00103	7c 09		 jl	 SHORT $LN38@GetFreeClu
  00105	3b 4d 10	 cmp	 ecx, DWORD PTR _clusterThreshold$[ebp]
  00108	0f 83 d2 00 00
	00		 jae	 $err$44
$LN38@GetFreeClu:

; 1789 : 				goto err;
; 1790 : 
; 1791 : 			if (bitmap->Buffer[bitmapIndex] != 0xff)

  0010e	80 bc 35 f4 ff
	fe ff ff	 cmp	 BYTE PTR _bitmapBuffer$[ebp+esi+16], 255 ; 000000ffH
  00116	74 1b		 je	 SHORT $LN4@GetFreeClu

; 1792 : 			{
; 1793 : 				for (int bit = 0; bit < 8; ++bit)

  00118	0f b6 94 35 f4
	ff fe ff	 movzx	 edx, BYTE PTR _bitmapBuffer$[ebp+esi+16]
  00120	33 c9		 xor	 ecx, ecx
$LL9@GetFreeClu:

; 1794 : 				{
; 1795 : 					if ((bitmap->Buffer[bitmapIndex] & (1 << bit)) == 0)

  00122	b8 01 00 00 00	 mov	 eax, 1
  00127	d3 e0		 shl	 eax, cl
  00129	85 c2		 test	 eax, edx
  0012b	74 6c		 je	 SHORT $LN26@GetFreeClu

; 1792 : 			{
; 1793 : 				for (int bit = 0; bit < 8; ++bit)

  0012d	41		 inc	 ecx
  0012e	83 f9 08	 cmp	 ecx, 8
  00131	7c ef		 jl	 SHORT $LL9@GetFreeClu
$LN4@GetFreeClu:

; 1785 : 	{
; 1786 : 		for (int64 bitmapIndex = 0; bitmapIndex < min (bitmapSize, (bitmap->BitmapSize.QuadPart / 8)); ++bitmapIndex)

  00133	8b 85 d4 ff fe
	ff		 mov	 eax, DWORD PTR tv215[ebp]
  00139	83 c6 01	 add	 esi, 1
  0013c	83 d7 00	 adc	 edi, 0
  0013f	e9 7c ff ff ff	 jmp	 $LL6@GetFreeClu
$LN5@GetFreeClu:

; 1803 : 					}
; 1804 : 				}
; 1805 : 			}
; 1806 : 		}
; 1807 : 
; 1808 : 		startLcn.StartingLcn.QuadPart += min (bitmapSize * 8, bitmap->BitmapSize.QuadPart);

  00144	8b 85 d0 ff fe
	ff		 mov	 eax, DWORD PTR _bitmapBuffer$2$[ebp]
  0014a	85 c0		 test	 eax, eax
  0014c	7c 2e		 jl	 SHORT $LN42@GetFreeClu
  0014e	7f 0e		 jg	 SHORT $LN39@GetFreeClu
  00150	8b 8d e0 ff fe
	ff		 mov	 ecx, DWORD PTR _bitmapBuffer$1$[ebp]
  00156	81 f9 00 00 08
	00		 cmp	 ecx, 524288		; 00080000H
  0015c	76 24		 jbe	 SHORT $LN20@GetFreeClu
$LN39@GetFreeClu:
  0015e	33 c0		 xor	 eax, eax
  00160	b9 00 00 08 00	 mov	 ecx, 524288		; 00080000H
  00165	01 8d d8 ff fe
	ff		 add	 DWORD PTR _startLcn$[ebp], ecx
  0016b	11 85 dc ff fe
	ff		 adc	 DWORD PTR _startLcn$[ebp+4], eax

; 1809 : 	}

  00171	8b 85 cc ff fe
	ff		 mov	 eax, DWORD PTR _volumeHandle$GSCopy$1$[ebp]
  00177	e9 bb fe ff ff	 jmp	 $LL2@GetFreeClu
$LN42@GetFreeClu:
  0017c	8b 8d e0 ff fe
	ff		 mov	 ecx, DWORD PTR _bitmapBuffer$1$[ebp]
$LN20@GetFreeClu:

; 1803 : 					}
; 1804 : 				}
; 1805 : 			}
; 1806 : 		}
; 1807 : 
; 1808 : 		startLcn.StartingLcn.QuadPart += min (bitmapSize * 8, bitmap->BitmapSize.QuadPart);

  00182	01 8d d8 ff fe
	ff		 add	 DWORD PTR _startLcn$[ebp], ecx
  00188	11 85 dc ff fe
	ff		 adc	 DWORD PTR _startLcn$[ebp+4], eax

; 1809 : 	}

  0018e	8b 85 cc ff fe
	ff		 mov	 eax, DWORD PTR _volumeHandle$GSCopy$1$[ebp]
  00194	e9 9e fe ff ff	 jmp	 $LL2@GetFreeClu
$LN26@GetFreeClu:

; 1796 : 					{
; 1797 : 						*freeCluster = bitmap->StartingLcn.QuadPart + bitmapIndex * 8 + bit;

  00199	0f a4 f7 03	 shld	 edi, esi, 3
  0019d	8b c1		 mov	 eax, ecx
  0019f	8b 8d c8 ff fe
	ff		 mov	 ecx, DWORD PTR _freeCluster$GSCopy$1$[ebp]
  001a5	c1 e6 03	 shl	 esi, 3
  001a8	99		 cdq
  001a9	03 f0		 add	 esi, eax
  001ab	13 fa		 adc	 edi, edx
  001ad	03 b5 e4 ff fe
	ff		 add	 esi, DWORD PTR _bitmapBuffer$[ebp]
  001b3	89 31		 mov	 DWORD PTR [ecx], esi
  001b5	13 bd e8 ff fe
	ff		 adc	 edi, DWORD PTR _bitmapBuffer$[ebp+4]
  001bb	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 1798 : 
; 1799 : 						if (*freeCluster >= clusterThreshold)

  001be	3b 7d 14	 cmp	 edi, DWORD PTR _clusterThreshold$[ebp+4]
  001c1	7f 1d		 jg	 SHORT $err$44
  001c3	7c 05		 jl	 SHORT $LN40@GetFreeClu
  001c5	3b 75 10	 cmp	 esi, DWORD PTR _clusterThreshold$[ebp]
  001c8	73 16		 jae	 SHORT $err$44
$LN40@GetFreeClu:
  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi

; 1800 : 							goto err;
; 1801 : 
; 1802 : 						return TRUE;

  001cc	b8 01 00 00 00	 mov	 eax, 1
  001d1	5b		 pop	 ebx

; 1813 : 	return FALSE;
; 1814 : }

  001d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d5	33 cd		 xor	 ecx, ebp
  001d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c3		 ret	 0
$err$44:

; 1810 : 	
; 1811 : err:
; 1812 : 	SetLastError (ERROR_DISK_FULL);

  001e0	6a 70		 push	 112			; 00000070H
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 1813 : 	return FALSE;
; 1814 : }

  001e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001eb	33 c0		 xor	 eax, eax
  001ed	5f		 pop	 edi
  001ee	5e		 pop	 esi
  001ef	33 cd		 xor	 ecx, ebp
  001f1	5b		 pop	 ebx
  001f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c3		 ret	 0
?GetFreeClusterBeforeThreshold@@YAHPAXPA_J_J@Z ENDP	; GetFreeClusterBeforeThreshold
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT ?NewFileSysSizeAfterShrink@@YA_JPAXPBDPA_JPAKH@Z
_TEXT	SEGMENT
_nBytesReturned$ = -104					; size = 4
_ntfsVolData$ = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
_dev$ = 8						; size = 4
_devicePath$ = 12					; size = 4
_totalClusterCount$ = 16				; size = 4
_bytesPerCluster$ = 20					; size = 4
_silent$ = 24						; size = 4
?NewFileSysSizeAfterShrink@@YA_JPAXPBDPA_JPAKH@Z PROC	; NewFileSysSizeAfterShrink, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _dev$[ebp]

; 81   : 	NTFS_VOLUME_DATA_BUFFER ntfsVolData;
; 82   : 	DWORD nBytesReturned;
; 83   : 	__int64 fileSysSize, desiredNbrSectors;
; 84   : 
; 85   : 	// Filesystem size and sector size
; 86   : 
; 87   : 	if (!DeviceIoControl (dev,

  00013	8d 4d 98	 lea	 ecx, DWORD PTR _nBytesReturned$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 14	 mov	 ebx, DWORD PTR _bytesPerCluster$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 10	 mov	 edi, DWORD PTR _totalClusterCount$[ebp]
  0001e	6a 00		 push	 0
  00020	51		 push	 ecx
  00021	6a 60		 push	 96			; 00000060H
  00023	8d 4d 9c	 lea	 ecx, DWORD PTR _ntfsVolData$[ebp]
  00026	51		 push	 ecx
  00027	6a 00		 push	 0
  00029	6a 00		 push	 0
  0002b	68 64 00 09 00	 push	 589924			; 00090064H
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00037	85 c0		 test	 eax, eax
  00039	75 28		 jne	 SHORT $LN2@NewFileSys

; 88   : 		FSCTL_GET_NTFS_VOLUME_DATA,
; 89   : 		NULL,
; 90   : 		0,
; 91   : 		(LPVOID) &ntfsVolData,
; 92   : 		sizeof (ntfsVolData),   
; 93   : 		&nBytesReturned,
; 94   : 		NULL))
; 95   : 	{
; 96   : 		if (!silent)

  0003b	39 45 18	 cmp	 DWORD PTR _silent$[ebp], eax
  0003e	75 0e		 jne	 SHORT $LN3@NewFileSys

; 97   : 			handleWin32Error (MainDlg);

  00040	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00046	e8 00 00 00 00	 call	 _handleWin32Error
  0004b	83 c4 04	 add	 esp, 4
$LN3@NewFileSys:

; 98   : 
; 99   : 		return -1;

  0004e	83 c8 ff	 or	 eax, -1
  00051	5f		 pop	 edi
  00052	0b d0		 or	 edx, eax
  00054	5b		 pop	 ebx

; 115  : }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	33 cd		 xor	 ecx, ebp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
$LN2@NewFileSys:

; 100  : 	}
; 101  : 
; 102  : 	fileSysSize = ntfsVolData.NumberSectors.QuadPart * ntfsVolData.BytesPerSector;

  00063	ff 75 a8	 push	 DWORD PTR _ntfsVolData$[ebp+12]
  00066	ff 75 a4	 push	 DWORD PTR _ntfsVolData$[ebp+8]
  00069	6a 00		 push	 0
  0006b	ff 75 c4	 push	 DWORD PTR _ntfsVolData$[ebp+40]
  0006e	e8 00 00 00 00	 call	 __allmul

; 103  : 
; 104  : 	desiredNbrSectors = (fileSysSize - GST_TOTAL_VOLUME_HEADERS_SIZE) / ntfsVolData.BytesPerSector;

  00073	6a 00		 push	 0
  00075	ff 75 c4	 push	 DWORD PTR _ntfsVolData$[ebp+40]
  00078	2d 00 00 04 00	 sub	 eax, 262144		; 00040000H
  0007d	83 da 00	 sbb	 edx, 0
  00080	52		 push	 edx
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 __alldiv
  00087	8b c8		 mov	 ecx, eax

; 105  : 
; 106  : 	if (desiredNbrSectors <= 0)

  00089	85 d2		 test	 edx, edx
  0008b	7f 06		 jg	 SHORT $LN4@NewFileSys
  0008d	7c bf		 jl	 SHORT $LN3@NewFileSys
  0008f	85 c9		 test	 ecx, ecx
  00091	74 bb		 je	 SHORT $LN3@NewFileSys
$LN4@NewFileSys:

; 107  : 		return -1;
; 108  : 	
; 109  : 	if (totalClusterCount)

  00093	85 ff		 test	 edi, edi
  00095	74 0b		 je	 SHORT $LN5@NewFileSys

; 110  : 		*totalClusterCount = ntfsVolData.TotalClusters.QuadPart;

  00097	8b 45 ac	 mov	 eax, DWORD PTR _ntfsVolData$[ebp+16]
  0009a	89 07		 mov	 DWORD PTR [edi], eax
  0009c	8b 45 b0	 mov	 eax, DWORD PTR _ntfsVolData$[ebp+20]
  0009f	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN5@NewFileSys:

; 111  : 	if (bytesPerCluster)

  000a2	85 db		 test	 ebx, ebx
  000a4	74 05		 je	 SHORT $LN6@NewFileSys

; 112  : 		*bytesPerCluster = ntfsVolData.BytesPerCluster;

  000a6	8b 45 c8	 mov	 eax, DWORD PTR _ntfsVolData$[ebp+44]
  000a9	89 03		 mov	 DWORD PTR [ebx], eax
$LN6@NewFileSys:

; 113  : 
; 114  : 	return desiredNbrSectors;

  000ab	8b c1		 mov	 eax, ecx

; 115  : }

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	5f		 pop	 edi
  000b1	33 cd		 xor	 ecx, ebp
  000b3	5b		 pop	 ebx
  000b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?NewFileSysSizeAfterShrink@@YA_JPAXPBDPA_JPAKH@Z ENDP	; NewFileSysSizeAfterShrink
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _MoveClustersBeforeThreshold
_TEXT	SEGMENT
_volumeRoot$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_volumeHandle$ = 8					; size = 4
_volumeDevicePath$ = 12					; size = 4
_clusterThreshold$ = 16					; size = 8
_MoveClustersBeforeThreshold PROC			; COMDAT

; 1932 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _volumeDevicePath$[ebp]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _volumeHandle$[ebp]

; 1933 : 	int drive = GetDiskDeviceDriveLetter (volumeDevicePath);

  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  0001e	8b f0		 mov	 esi, eax
  00020	83 c4 04	 add	 esp, 4

; 1934 : 	if (drive == -1)

  00023	83 fe ff	 cmp	 esi, -1
  00026	75 1a		 jne	 SHORT $LN2@MoveCluste

; 1935 : 	{
; 1936 : 		SetLastError (ERROR_INVALID_PARAMETER);

  00028	6a 57		 push	 87			; 00000057H
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  00030	5f		 pop	 edi

; 1937 : 		return FALSE;

  00031	33 c0		 xor	 eax, eax
  00033	5e		 pop	 esi

; 1944 : }

  00034	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00037	33 cd		 xor	 ecx, ebp
  00039	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN2@MoveCluste:

; 1938 : 	}
; 1939 : 
; 1940 : 	wstring volumeRoot = L"X:";

  00042	6a 02		 push	 2
  00044	33 c0		 xor	 eax, eax
  00046	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR _volumeRoot$[ebp+20], 7
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_15DBHGMMAD@?$AAX?$AA?3?$AA?$AA@
  00052	8d 4d e4	 lea	 ecx, DWORD PTR _volumeRoot$[ebp]
  00055	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _volumeRoot$[ebp+16], 0
  0005c	66 89 45 e4	 mov	 WORD PTR _volumeRoot$[ebp], ax
  00060	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1941 : 	volumeRoot[0] = L'A' + (wchar_t) drive;

  00065	83 7d f8 08	 cmp	 DWORD PTR _volumeRoot$[ebp+20], 8
  00069	8d 4d e4	 lea	 ecx, DWORD PTR _volumeRoot$[ebp]

; 1942 : 
; 1943 : 	return MoveClustersBeforeThresholdInDir (volumeHandle, volumeRoot, clusterThreshold);

  0006c	ff 75 14	 push	 DWORD PTR _clusterThreshold$[ebp+4]
  0006f	0f 43 4d e4	 cmovae	 ecx, DWORD PTR _volumeRoot$[ebp]
  00073	8d 46 41	 lea	 eax, DWORD PTR [esi+65]
  00076	ff 75 10	 push	 DWORD PTR _clusterThreshold$[ebp]
  00079	66 89 01	 mov	 WORD PTR [ecx], ax
  0007c	8d 45 e4	 lea	 eax, DWORD PTR _volumeRoot$[ebp]
  0007f	50		 push	 eax
  00080	57		 push	 edi
  00081	e8 00 00 00 00	 call	 ?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z ; MoveClustersBeforeThresholdInDir
  00086	8b 4d f8	 mov	 ecx, DWORD PTR _volumeRoot$[ebp+20]
  00089	83 c4 10	 add	 esp, 16			; 00000010H
  0008c	8b f0		 mov	 esi, eax
  0008e	83 f9 08	 cmp	 ecx, 8
  00091	72 0d		 jb	 SHORT $LN140@MoveCluste
  00093	41		 inc	 ecx
  00094	51		 push	 ecx
  00095	ff 75 e4	 push	 DWORD PTR _volumeRoot$[ebp]
  00098	8d 4d e4	 lea	 ecx, DWORD PTR _volumeRoot$[ebp]
  0009b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN140@MoveCluste:

; 1944 : }

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a3	8b c6		 mov	 eax, esi
  000a5	5f		 pop	 edi
  000a6	33 cd		 xor	 ecx, ebp
  000a8	5e		 pop	 esi
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
_MoveClustersBeforeThreshold ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _OpenBackupHeader
_TEXT	SEGMENT
_n$ = -4						; size = 4
_dev$ = 8						; size = 4
_devicePath$ = 12					; size = 4
_password$ = 16						; size = 4
_retMasterCryptoInfo$ = 20				; size = 4
_headerCryptoInfo$ = 24					; size = 4
_deviceSize$ = 28					; size = 8
_OpenBackupHeader PROC					; COMDAT

; 1716 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1717 : 	LARGE_INTEGER offset;
; 1718 : 	DWORD n;
; 1719 : 	int nStatus = ERR_SUCCESS;
; 1720 : 	char *header;
; 1721 : 	DWORD dwError;
; 1722 : 
; 1723 : 	header = (char *) GSTalloc (GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00005	68 00 02 00 00	 push	 512			; 00000200H
  0000a	e8 00 00 00 00	 call	 _malloc
  0000f	8b f0		 mov	 esi, eax
  00011	83 c4 04	 add	 esp, 4

; 1724 : 	if (!header)

  00014	85 f6		 test	 esi, esi
  00016	75 08		 jne	 SHORT $LN7@OpenBackup

; 1725 : 		return ERR_OUTOFMEMORY;

  00018	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  0001b	5e		 pop	 esi

; 1760 : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN7@OpenBackup:
  00020	53		 push	 ebx
  00021	57		 push	 edi

; 1726 : 
; 1727 : 	VirtualLock (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00022	68 00 02 00 00	 push	 512			; 00000200H
  00027	56		 push	 esi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 1728 : 
; 1729 : 
; 1730 : 
; 1731 : 	offset.QuadPart = deviceSize - GST_VOLUME_HEADER_GROUP_SIZE;

  0002e	8b 4d 1c	 mov	 ecx, DWORD PTR _deviceSize$[ebp]
  00031	8b 45 20	 mov	 eax, DWORD PTR _deviceSize$[ebp+4]
  00034	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H

; 1732 : 
; 1733 : 	if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 1734 : 		|| !ReadEffectiveVolumeHeader (TRUE, dev, (byte *) header, &n) || n < GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  0003a	8b 7d 08	 mov	 edi, DWORD PTR _dev$[ebp]
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	83 d8 00	 sbb	 eax, 0
  00044	50		 push	 eax
  00045	51		 push	 ecx
  00046	57		 push	 edi
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0004d	85 c0		 test	 eax, eax
  0004f	74 35		 je	 SHORT $LN9@OpenBackup
  00051	8d 45 fc	 lea	 eax, DWORD PTR _n$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	57		 push	 edi
  00057	6a 01		 push	 1
  00059	e8 00 00 00 00	 call	 _ReadEffectiveVolumeHeader
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	85 c0		 test	 eax, eax
  00063	74 21		 je	 SHORT $LN9@OpenBackup
  00065	81 7d fc 00 02
	00 00		 cmp	 DWORD PTR _n$[ebp], 512	; 00000200H
  0006c	72 18		 jb	 SHORT $LN9@OpenBackup

; 1737 : 		goto closing_seq;
; 1738 : 	}
; 1739 : 
; 1740 : 
; 1741 : 	nStatus = ReadVolumeHeader (FALSE, header, password, retMasterCryptoInfo, headerCryptoInfo);

  0006e	ff 75 18	 push	 DWORD PTR _headerCryptoInfo$[ebp]
  00071	ff 75 14	 push	 DWORD PTR _retMasterCryptoInfo$[ebp]
  00074	ff 75 10	 push	 DWORD PTR _password$[ebp]
  00077	56		 push	 esi
  00078	6a 00		 push	 0
  0007a	e8 00 00 00 00	 call	 _ReadVolumeHeader
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	8b d8		 mov	 ebx, eax

; 1742 : 	if (nStatus != ERR_SUCCESS)
; 1743 : 		goto closing_seq;
; 1744 : 
; 1745 : 
; 1746 : closing_seq:

  00084	eb 05		 jmp	 SHORT $closing_seq$35
$LN9@OpenBackup:

; 1735 : 	{
; 1736 : 		nStatus = ERR_OS_ERROR;

  00086	bb 01 00 00 00	 mov	 ebx, 1
$closing_seq$35:

; 1747 : 
; 1748 : 	dwError = GetLastError();

  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1749 : 
; 1750 : 	burn (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00091	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00096	8b c6		 mov	 eax, esi
  00098	8b f9		 mov	 edi, ecx
  0009a	8b d6		 mov	 edx, esi
  0009c	0f 1f 40 00	 npad	 4
$LL16@OpenBackup:
  000a0	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000a6	83 ef 01	 sub	 edi, 1
  000a9	75 f5		 jne	 SHORT $LL16@OpenBackup
  000ab	0f 1f 44 00 00	 npad	 5
$LL5@OpenBackup:
  000b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  000b3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000b6	83 e9 01	 sub	 ecx, 1
  000b9	75 f5		 jne	 SHORT $LL5@OpenBackup

; 1751 : 	VirtualUnlock (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  000bb	68 00 02 00 00	 push	 512			; 00000200H
  000c0	56		 push	 esi
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 1752 : 	GSTfree (header);

  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 _free
  000cd	83 c4 04	 add	 esp, 4

; 1753 : 
; 1754 : 	dwError = GetLastError();

  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1755 : 
; 1756 : 	if (nStatus != ERR_SUCCESS)

  000d6	85 db		 test	 ebx, ebx
  000d8	74 07		 je	 SHORT $LN13@OpenBackup

; 1757 : 		SetLastError (dwError);

  000da	50		 push	 eax
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN13@OpenBackup:

; 1758 : 
; 1759 : 	return nStatus;

  000e1	5f		 pop	 edi
  000e2	8b c3		 mov	 eax, ebx
  000e4	5b		 pop	 ebx
  000e5	5e		 pop	 esi

; 1760 : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
_OpenBackupHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _ZeroUnreadableSectors
_TEXT	SEGMENT
_sectorCount$2$ = -16					; size = 4
_n$ = -12						; size = 4
_workOffset$2$ = -8					; size = 4
_workOffset$1$ = -4					; size = 4
_dev$ = 8						; size = 4
_startOffset$ = 12					; size = 8
_size$ = 20						; size = 8
_sectorSize$ = 28					; size = 4
_zeroedSectorCount$ = 32				; size = 4
_ZeroUnreadableSectors PROC				; COMDAT

; 1639 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1640 : 	int nStatus;
; 1641 : 	DWORD n;
; 1642 : 	int64 sectorCount;
; 1643 : 	LARGE_INTEGER workOffset;
; 1644 : 	byte *sectorBuffer = NULL;
; 1645 : 	DWORD dwError;
; 1646 : 
; 1647 : 	workOffset.QuadPart = startOffset.QuadPart;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _startOffset$[ebp]
  00009	53		 push	 ebx

; 1648 : 
; 1649 : 	sectorBuffer = (byte *) GSTalloc (sectorSize);

  0000a	8b 5d 1c	 mov	 ebx, DWORD PTR _sectorSize$[ebp]
  0000d	57		 push	 edi
  0000e	89 45 fc	 mov	 DWORD PTR _workOffset$1$[ebp], eax
  00011	8b 45 10	 mov	 eax, DWORD PTR _startOffset$[ebp+4]
  00014	53		 push	 ebx
  00015	89 45 f8	 mov	 DWORD PTR _workOffset$2$[ebp], eax
  00018	e8 00 00 00 00	 call	 _malloc
  0001d	8b f8		 mov	 edi, eax
  0001f	83 c4 04	 add	 esp, 4

; 1650 : 
; 1651 : 	if (!sectorBuffer)

  00022	85 ff		 test	 edi, edi
  00024	75 09		 jne	 SHORT $LN5@ZeroUnread

; 1652 : 		return ERR_OUTOFMEMORY;

  00026	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00029	5f		 pop	 edi
  0002a	5b		 pop	 ebx

; 1697 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN5@ZeroUnread:
  0002f	56		 push	 esi

; 1653 : 
; 1654 : 	if (SetFilePointerEx (dev, startOffset, NULL, FILE_BEGIN) == 0)

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	ff 75 10	 push	 DWORD PTR _startOffset$[ebp+4]
  00037	ff 75 0c	 push	 DWORD PTR _startOffset$[ebp]
  0003a	ff 75 08	 push	 DWORD PTR _dev$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00043	85 c0		 test	 eax, eax
  00045	75 0a		 jne	 SHORT $LN6@ZeroUnread
$LN17@ZeroUnread:

; 1655 : 	{
; 1656 : 		nStatus = ERR_OS_ERROR;

  00047	be 01 00 00 00	 mov	 esi, 1

; 1685 : 
; 1686 : closing_seq:

  0004c	e9 99 00 00 00	 jmp	 $closing_seq$28
$LN6@ZeroUnread:

; 1657 : 		goto closing_seq;
; 1658 : 	}
; 1659 : 
; 1660 : 
; 1661 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount)

  00051	8b c3		 mov	 eax, ebx
  00053	99		 cdq
  00054	52		 push	 edx
  00055	50		 push	 eax
  00056	ff 75 18	 push	 DWORD PTR _size$[ebp+4]
  00059	ff 75 14	 push	 DWORD PTR _size$[ebp]
  0005c	e8 00 00 00 00	 call	 __alldiv
  00061	89 55 f0	 mov	 DWORD PTR _sectorCount$2$[ebp], edx
  00064	8b d8		 mov	 ebx, eax
  00066	85 d2		 test	 edx, edx
  00068	7c 7e		 jl	 SHORT $LN22@ZeroUnread
  0006a	7f 04		 jg	 SHORT $LN26@ZeroUnread
  0006c	85 db		 test	 ebx, ebx
  0006e	74 78		 je	 SHORT $LN22@ZeroUnread
$LN26@ZeroUnread:
  00070	8b 75 20	 mov	 esi, DWORD PTR _zeroedSectorCount$[ebp]
$LL25@ZeroUnread:

; 1662 : 	{
; 1663 : 		if (ReadFile (dev, sectorBuffer, sectorSize, &n, NULL) == 0)

  00073	6a 00		 push	 0
  00075	8d 45 f4	 lea	 eax, DWORD PTR _n$[ebp]
  00078	50		 push	 eax
  00079	ff 75 1c	 push	 DWORD PTR _sectorSize$[ebp]
  0007c	57		 push	 edi
  0007d	ff 75 08	 push	 DWORD PTR _dev$[ebp]
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00086	85 c0		 test	 eax, eax
  00088	75 42		 jne	 SHORT $LN8@ZeroUnread

; 1664 : 		{
; 1665 : 			memset (sectorBuffer, 0, sectorSize);

  0008a	ff 75 1c	 push	 DWORD PTR _sectorSize$[ebp]
  0008d	50		 push	 eax
  0008e	57		 push	 edi
  0008f	e8 00 00 00 00	 call	 _memset
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1666 : 
; 1667 : 			if (SetFilePointerEx (dev, workOffset, NULL, FILE_BEGIN) == 0)

  00097	6a 00		 push	 0
  00099	6a 00		 push	 0
  0009b	ff 75 f8	 push	 DWORD PTR _workOffset$2$[ebp]
  0009e	ff 75 fc	 push	 DWORD PTR _workOffset$1$[ebp]
  000a1	ff 75 08	 push	 DWORD PTR _dev$[ebp]
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000aa	85 c0		 test	 eax, eax
  000ac	74 99		 je	 SHORT $LN17@ZeroUnread

; 1668 : 			{
; 1669 : 				nStatus = ERR_OS_ERROR;
; 1670 : 				goto closing_seq;
; 1671 : 			}
; 1672 : 
; 1673 : 			if (WriteFile (dev, sectorBuffer, sectorSize, &n, NULL) == 0)

  000ae	6a 00		 push	 0
  000b0	8d 45 f4	 lea	 eax, DWORD PTR _n$[ebp]
  000b3	50		 push	 eax
  000b4	ff 75 1c	 push	 DWORD PTR _sectorSize$[ebp]
  000b7	57		 push	 edi
  000b8	ff 75 08	 push	 DWORD PTR _dev$[ebp]
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  000c1	85 c0		 test	 eax, eax
  000c3	74 82		 je	 SHORT $LN17@ZeroUnread

; 1674 : 			{
; 1675 : 				nStatus = ERR_OS_ERROR;
; 1676 : 				goto closing_seq;
; 1677 : 			}
; 1678 : 			++(*zeroedSectorCount);

  000c5	83 06 01	 add	 DWORD PTR [esi], 1
  000c8	83 56 04 00	 adc	 DWORD PTR [esi+4], 0
$LN8@ZeroUnread:

; 1679 : 		}
; 1680 : 
; 1681 : 		workOffset.QuadPart += n;

  000cc	8b 45 fc	 mov	 eax, DWORD PTR _workOffset$1$[ebp]
  000cf	03 45 f4	 add	 eax, DWORD PTR _n$[ebp]
  000d2	89 45 fc	 mov	 DWORD PTR _workOffset$1$[ebp], eax
  000d5	83 55 f8 00	 adc	 DWORD PTR _workOffset$2$[ebp], 0
  000d9	83 c3 ff	 add	 ebx, -1
  000dc	83 55 f0 ff	 adc	 DWORD PTR _sectorCount$2$[ebp], -1
  000e0	78 06		 js	 SHORT $LN22@ZeroUnread

; 1657 : 		goto closing_seq;
; 1658 : 	}
; 1659 : 
; 1660 : 
; 1661 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount)

  000e2	7f 8f		 jg	 SHORT $LL25@ZeroUnread
  000e4	85 db		 test	 ebx, ebx
  000e6	75 8b		 jne	 SHORT $LL25@ZeroUnread
$LN22@ZeroUnread:

; 1682 : 	}
; 1683 : 
; 1684 : 	nStatus = ERR_SUCCESS;

  000e8	33 f6		 xor	 esi, esi
$closing_seq$28:

; 1687 : 
; 1688 : 	dwError = GetLastError();

  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1689 : 
; 1690 : 	if (sectorBuffer != NULL)
; 1691 : 		GSTfree (sectorBuffer);

  000f0	57		 push	 edi
  000f1	8b d8		 mov	 ebx, eax
  000f3	e8 00 00 00 00	 call	 _free
  000f8	83 c4 04	 add	 esp, 4
  000fb	85 f6		 test	 esi, esi

; 1692 : 
; 1693 : 	if (nStatus != ERR_SUCCESS)

  000fd	74 07		 je	 SHORT $LN14@ZeroUnread

; 1694 : 		SetLastError (dwError);

  000ff	53		 push	 ebx
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN14@ZeroUnread:

; 1695 : 
; 1696 : 	return nStatus;

  00106	8b c6		 mov	 eax, esi
  00108	5e		 pop	 esi
  00109	5f		 pop	 edi
  0010a	5b		 pop	 ebx

; 1697 : }

  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
_ZeroUnreadableSectors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _ExportProgressStats
_TEXT	SEGMENT
_bytesDone$ = 8						; size = 8
_totalSize$ = 16					; size = 8
_ExportProgressStats PROC				; COMDAT

; 1554 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1555 : 	NonSysInplaceEncBytesDone = bytesDone;

  00003	8b 45 08	 mov	 eax, DWORD PTR _bytesDone$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncBytesDone, eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _bytesDone$[ebp+4]
  0000e	a3 04 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncBytesDone+4, eax

; 1556 : 	NonSysInplaceEncTotalSize = totalSize;

  00013	8b 45 10	 mov	 eax, DWORD PTR _totalSize$[ebp]
  00016	a3 00 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncTotalSize, eax
  0001b	8b 45 14	 mov	 eax, DWORD PTR _totalSize$[ebp+4]
  0001e	a3 04 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncTotalSize+4, eax

; 1557 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_ExportProgressStats ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _SaveNonSysInPlaceEncSettings
_TEXT	SEGMENT
_savedWipeAlgorithm$ = -40				; size = 4
_str$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_delta$ = 8						; size = 4
_newWipeAlgorithm$ = 12					; size = 4
_SaveNonSysInPlaceEncSettings PROC			; COMDAT

; 1586 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1587 : 	int count;
; 1588 : 	char str[32];
; 1589 : 	WipeAlgorithmId savedWipeAlgorithm = GST_WIPE_NONE;
; 1590 : 
; 1591 : 	if (delta == 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR _delta$[ebp], 0
  00014	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _savedWipeAlgorithm$[ebp], 0
  0001b	75 13		 jne	 SHORT $LN2@SaveNonSys

; 1592 : 		return TRUE;

  0001d	b8 01 00 00 00	 mov	 eax, 1

; 1617 : 	}
; 1618 : }

  00022	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00025	33 cd		 xor	 ecx, ebp
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN2@SaveNonSys:

; 1593 : 
; 1594 : 	count = LoadNonSysInPlaceEncSettings (&savedWipeAlgorithm) + delta;

  00030	8d 45 d8	 lea	 eax, DWORD PTR _savedWipeAlgorithm$[ebp]
  00033	57		 push	 edi
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _LoadNonSysInPlaceEncSettings
  0003a	8b f8		 mov	 edi, eax
  0003c	83 c4 04	 add	 esp, 4
  0003f	03 7d 08	 add	 edi, DWORD PTR _delta$[ebp]

; 1595 : 
; 1596 : 	if (count < 1)

  00042	83 ff 01	 cmp	 edi, 1
  00045	7d 19		 jge	 SHORT $LN3@SaveNonSys

; 1597 : 	{
; 1598 : 		RemoveNonSysInPlaceEncNotifications();

  00047	e8 00 00 00 00	 call	 _RemoveNonSysInPlaceEncNotifications

; 1599 : 		return TRUE;

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	5f		 pop	 edi

; 1617 : 	}
; 1618 : }

  00052	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00055	33 cd		 xor	 ecx, ebp
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN3@SaveNonSys:

; 1600 : 	}
; 1601 : 	else
; 1602 : 	{
; 1603 : 		if (newWipeAlgorithm != GST_WIPE_NONE)

  00060	8b 45 0c	 mov	 eax, DWORD PTR _newWipeAlgorithm$[ebp]
  00063	85 c0		 test	 eax, eax
  00065	74 41		 je	 SHORT $LN5@SaveNonSys

; 1604 : 		{
; 1605 : 			sprintf (str, "%d", (int) newWipeAlgorithm);

  00067	50		 push	 eax
  00068	8d 45 dc	 lea	 eax, DWORD PTR _str$[ebp]
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _sprintf

; 1606 : 
; 1607 : 			SaveBufferToFile (str, GetConfigPath (GST_APPD_FILENAME_NONSYS_INPLACE_ENC_WIPE), strlen(str), FALSE);

  00076	8d 4d dc	 lea	 ecx, DWORD PTR _str$[ebp]
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007c	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0007f	90		 npad	 1
$LL9@SaveNonSys:
  00080	8a 01		 mov	 al, BYTE PTR [ecx]
  00082	41		 inc	 ecx
  00083	84 c0		 test	 al, al
  00085	75 f9		 jne	 SHORT $LL9@SaveNonSys
  00087	2b ca		 sub	 ecx, edx
  00089	6a 00		 push	 0
  0008b	51		 push	 ecx
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@
  00091	e8 00 00 00 00	 call	 _GetConfigPath
  00096	83 c4 04	 add	 esp, 4
  00099	50		 push	 eax
  0009a	8d 45 dc	 lea	 eax, DWORD PTR _str$[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _SaveBufferToFile
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
  000a6	eb 2a		 jmp	 SHORT $LN7@SaveNonSys
$LN5@SaveNonSys:

; 1608 : 		} 
; 1609 : 		else if (FileExists (GetConfigPath (GST_APPD_FILENAME_NONSYS_INPLACE_ENC_WIPE)))

  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@
  000ad	e8 00 00 00 00	 call	 _GetConfigPath
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _FileExists
  000b8	83 c4 08	 add	 esp, 8
  000bb	85 c0		 test	 eax, eax
  000bd	74 13		 je	 SHORT $LN7@SaveNonSys

; 1610 : 		{
; 1611 : 			remove (GetConfigPath (GST_APPD_FILENAME_NONSYS_INPLACE_ENC_WIPE));

  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@
  000c4	e8 00 00 00 00	 call	 _GetConfigPath
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _remove
  000cf	83 c4 08	 add	 esp, 8
$LN7@SaveNonSys:

; 1612 : 		}
; 1613 : 
; 1614 : 		sprintf (str, "%d", count);

  000d2	57		 push	 edi
  000d3	8d 45 dc	 lea	 eax, DWORD PTR _str$[ebp]
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _sprintf

; 1615 : 
; 1616 : 		return SaveBufferToFile (str, GetConfigPath (GST_APPD_FILENAME_NONSYS_INPLACE_ENC), strlen(str), FALSE);

  000e1	8d 4d dc	 lea	 ecx, DWORD PTR _str$[ebp]
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e7	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL10@SaveNonSys:
  000f0	8a 01		 mov	 al, BYTE PTR [ecx]
  000f2	41		 inc	 ecx
  000f3	84 c0		 test	 al, al
  000f5	75 f9		 jne	 SHORT $LL10@SaveNonSys
  000f7	2b ca		 sub	 ecx, edx
  000f9	6a 00		 push	 0
  000fb	51		 push	 ecx
  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NLGDPAAC@In?9Place?5Encryption?$AA@
  00101	e8 00 00 00 00	 call	 _GetConfigPath
  00106	83 c4 04	 add	 esp, 4
  00109	50		 push	 eax
  0010a	8d 45 dc	 lea	 eax, DWORD PTR _str$[ebp]
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 _SaveBufferToFile

; 1617 : 	}
; 1618 : }

  00113	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00116	83 c4 10	 add	 esp, 16			; 00000010H
  00119	33 cd		 xor	 ecx, ebp
  0011b	5f		 pop	 edi
  0011c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c3		 ret	 0
_SaveNonSysInPlaceEncSettings ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _ConcealNTFS
_TEXT	SEGMENT
_nbrBytesProcessed2$ = -8216				; size = 4
_dwError$1$ = -8212					; size = 4
_nbrBytesProcessed$ = -8208				; size = 4
_offset$ = -8204					; size = 8
_buf$ = -8196						; size = 8192
__$ArrayPad$ = -4					; size = 4
_dev$ = 8						; size = 4
_ConcealNTFS PROC					; COMDAT

; 1468 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 18 20 00 00	 mov	 eax, 8216		; 00002018H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _dev$[ebp]
  0001b	0f 57 c0	 xorps	 xmm0, xmm0
  0001e	57		 push	 edi

; 1469 : 	char buf [GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE];
; 1470 : 	DWORD nbrBytesProcessed, nbrBytesProcessed2;
; 1471 : 	int i;
; 1472 : 	LARGE_INTEGER offset;
; 1473 : 	DWORD dwError;
; 1474 : 
; 1475 : 	offset.QuadPart = 0;
; 1476 :  
; 1477 : 	if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0)

  0001f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetFilePointerEx@20
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	66 0f 13 85 f4
	df ff ff	 movlpd	 QWORD PTR _offset$[ebp], xmm0
  00031	ff b5 f8 df ff
	ff		 push	 DWORD PTR _offset$[ebp+4]
  00037	ff b5 f4 df ff
	ff		 push	 DWORD PTR _offset$[ebp]
  0003d	56		 push	 esi
  0003e	ff d7		 call	 edi
  00040	85 c0		 test	 eax, eax
  00042	0f 84 53 01 00
	00		 je	 $LN38@ConcealNTF

; 1478 : 		return ERR_OS_ERROR;
; 1479 : 
; 1480 : 	if (ReadFile (dev, buf, GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE, &nbrBytesProcessed, NULL) == 0)

  00048	6a 00		 push	 0
  0004a	8d 85 f0 df ff
	ff		 lea	 eax, DWORD PTR _nbrBytesProcessed$[ebp]
  00050	50		 push	 eax
  00051	68 00 20 00 00	 push	 8192			; 00002000H
  00056	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0005c	50		 push	 eax
  0005d	56		 push	 esi
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00064	85 c0		 test	 eax, eax
  00066	0f 84 2f 01 00
	00		 je	 $LN38@ConcealNTF

; 1481 : 		return ERR_OS_ERROR;
; 1482 : 
; 1483 : 	for (i = 0; i < GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE; i++)

  0006c	0f 10 0d 00 00
	00 00		 movups	 xmm1, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  00073	33 c0		 xor	 eax, eax
  00075	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@ConcealNTF:

; 1484 : 		buf[i] ^= GST_NTFS_CONCEAL_CONSTANT;

  00080	0f 10 84 05 fc
	df ff ff	 movups	 xmm0, XMMWORD PTR _buf$[ebp+eax]
  00088	66 0f df c1	 pandn	 xmm0, xmm1
  0008c	0f 11 84 05 fc
	df ff ff	 movups	 XMMWORD PTR _buf$[ebp+eax], xmm0
  00094	0f 10 84 05 0c
	e0 ff ff	 movups	 xmm0, XMMWORD PTR _buf$[ebp+eax+16]
  0009c	66 0f df c1	 pandn	 xmm0, xmm1
  000a0	0f 11 84 05 0c
	e0 ff ff	 movups	 XMMWORD PTR _buf$[ebp+eax+16], xmm0
  000a8	83 c0 20	 add	 eax, 32			; 00000020H
  000ab	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  000b0	7c ce		 jl	 SHORT $LL4@ConcealNTF

; 1485 : 
; 1486 : 	offset.QuadPart = 0;
; 1487 : 
; 1488 : 	if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0)

  000b2	6a 00		 push	 0
  000b4	6a 00		 push	 0
  000b6	0f 57 c0	 xorps	 xmm0, xmm0
  000b9	66 0f 13 85 f4
	df ff ff	 movlpd	 QWORD PTR _offset$[ebp], xmm0
  000c1	ff b5 f8 df ff
	ff		 push	 DWORD PTR _offset$[ebp+4]
  000c7	ff b5 f4 df ff
	ff		 push	 DWORD PTR _offset$[ebp]
  000cd	56		 push	 esi
  000ce	ff d7		 call	 edi
  000d0	85 c0		 test	 eax, eax
  000d2	0f 84 c3 00 00
	00		 je	 $LN38@ConcealNTF

; 1489 : 		return ERR_OS_ERROR;
; 1490 : 
; 1491 : 	if (WriteFile (dev, buf, GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE, &nbrBytesProcessed, NULL) == 0)

  000d8	6a 00		 push	 0
  000da	8d 85 f0 df ff
	ff		 lea	 eax, DWORD PTR _nbrBytesProcessed$[ebp]
  000e0	50		 push	 eax
  000e1	68 00 20 00 00	 push	 8192			; 00002000H
  000e6	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  000ec	50		 push	 eax
  000ed	56		 push	 esi
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  000f4	85 c0		 test	 eax, eax
  000f6	0f 85 b4 00 00
	00		 jne	 $LN14@ConcealNTF

; 1492 : 	{
; 1493 : 		// One or more of the sectors is/are probably damaged and cause write errors.
; 1494 : 		// We must undo the modifications we made.
; 1495 : 
; 1496 : 		dwError = GetLastError();

  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00102	0f 10 0d 00 00
	00 00		 movups	 xmm1, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  00109	89 85 ec df ff
	ff		 mov	 DWORD PTR _dwError$1$[ebp], eax

; 1497 : 
; 1498 : 		for (i = 0; i < GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE; i++)

  0010f	33 c9		 xor	 ecx, ecx
$LL7@ConcealNTF:

; 1499 : 			buf[i] ^= GST_NTFS_CONCEAL_CONSTANT;

  00111	0f 10 84 0d fc
	df ff ff	 movups	 xmm0, XMMWORD PTR _buf$[ebp+ecx]
  00119	66 0f df c1	 pandn	 xmm0, xmm1
  0011d	0f 11 84 0d fc
	df ff ff	 movups	 XMMWORD PTR _buf$[ebp+ecx], xmm0
  00125	0f 10 84 0d 0c
	e0 ff ff	 movups	 xmm0, XMMWORD PTR _buf$[ebp+ecx+16]
  0012d	66 0f df c1	 pandn	 xmm0, xmm1
  00131	0f 11 84 0d 0c
	e0 ff ff	 movups	 XMMWORD PTR _buf$[ebp+ecx+16], xmm0
  00139	83 c1 20	 add	 ecx, 32			; 00000020H
  0013c	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  00142	7c cd		 jl	 SHORT $LL7@ConcealNTF

; 1500 : 
; 1501 : 		offset.QuadPart = 0;

  00144	0f 57 c0	 xorps	 xmm0, xmm0
  00147	66 0f 13 85 f4
	df ff ff	 movlpd	 QWORD PTR _offset$[ebp], xmm0
  0014f	90		 npad	 1
$LL10@ConcealNTF:

; 1502 : 
; 1503 : 		do
; 1504 : 		{
; 1505 : 			Sleep (1);

  00150	6a 01		 push	 1
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 1506 : 		}
; 1507 : 		while (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 1508 : 			|| WriteFile (dev, buf, GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE, &nbrBytesProcessed2, NULL) == 0);

  00158	6a 00		 push	 0
  0015a	6a 00		 push	 0
  0015c	ff b5 f8 df ff
	ff		 push	 DWORD PTR _offset$[ebp+4]
  00162	ff b5 f4 df ff
	ff		 push	 DWORD PTR _offset$[ebp]
  00168	56		 push	 esi
  00169	ff d7		 call	 edi
  0016b	85 c0		 test	 eax, eax
  0016d	74 e1		 je	 SHORT $LL10@ConcealNTF
  0016f	6a 00		 push	 0
  00171	8d 85 e8 df ff
	ff		 lea	 eax, DWORD PTR _nbrBytesProcessed2$[ebp]
  00177	50		 push	 eax
  00178	68 00 20 00 00	 push	 8192			; 00002000H
  0017d	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00183	50		 push	 eax
  00184	56		 push	 esi
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0018b	85 c0		 test	 eax, eax
  0018d	74 c1		 je	 SHORT $LL10@ConcealNTF

; 1509 : 
; 1510 : 		SetLastError (dwError);

  0018f	ff b5 ec df ff
	ff		 push	 DWORD PTR _dwError$1$[ebp]
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN38@ConcealNTF:

; 1511 : 
; 1512 : 		return ERR_OS_ERROR;

  0019b	5f		 pop	 edi
  0019c	b8 01 00 00 00	 mov	 eax, 1
  001a1	5e		 pop	 esi

; 1513 : 	}
; 1514 : 
; 1515 : 	return ERR_SUCCESS;
; 1516 : }

  001a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a5	33 cd		 xor	 ecx, ebp
  001a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ac	8b e5		 mov	 esp, ebp
  001ae	5d		 pop	 ebp
  001af	c3		 ret	 0
$LN14@ConcealNTF:
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b3	33 c0		 xor	 eax, eax
  001b5	5f		 pop	 edi
  001b6	33 cd		 xor	 ecx, ebp
  001b8	5e		 pop	 esi
  001b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c3		 ret	 0
_ConcealNTFS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _DismountFileSystem
_TEXT	SEGMENT
_dwResult$ = -4						; size = 4
_dev$ = 8						; size = 4
_driveLetter$ = 12					; size = 4
_bForcedAllowed$ = 16					; size = 4
_bForcedRequiresConfirmation$ = 20			; size = 4
_bSilent$ = 24						; size = 4
_DismountFileSystem PROC				; COMDAT

; 1395 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 1396 : 	int attempt;
; 1397 : 	BOOL bResult;
; 1398 : 	DWORD dwResult;
; 1399 : 
; 1400 : 	CloseVolumeExplorerWindows (MainDlg, driveLetter);

  00007	ff 75 0c	 push	 DWORD PTR _driveLetter$[ebp]
  0000a	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00010	e8 00 00 00 00	 call	 _CloseVolumeExplorerWindows

; 1401 : 
; 1402 : 	attempt = UNMOUNT_MAX_AUTO_RETRIES * 10;
; 1403 : 
; 1404 : 	while (!(bResult = DeviceIoControl (dev, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0, &dwResult, NULL)) 
; 1405 : 		&& attempt > 0)

  00015	8b 7d 08	 mov	 edi, DWORD PTR _dev$[ebp]
  00018	8d 45 fc	 lea	 eax, DWORD PTR _dwResult$[ebp]
  0001b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DeviceIoControl@32
  00021	83 c4 08	 add	 esp, 8
  00024	be 2c 01 00 00	 mov	 esi, 300		; 0000012cH
  00029	6a 00		 push	 0
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	68 18 00 09 00	 push	 589848			; 00090018H
  00039	57		 push	 edi
  0003a	ff d3		 call	 ebx
  0003c	85 c0		 test	 eax, eax
  0003e	75 71		 jne	 SHORT $LN9@DismountFi
$LL2@DismountFi:
  00040	85 f6		 test	 esi, esi
  00042	7e 25		 jle	 SHORT $LN3@DismountFi

; 1406 : 	{
; 1407 : 		Sleep (UNMOUNT_AUTO_RETRY_DELAY);

  00044	6a 32		 push	 50			; 00000032H
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0004c	6a 00		 push	 0
  0004e	8d 45 fc	 lea	 eax, DWORD PTR _dwResult$[ebp]

; 1408 : 		attempt--;

  00051	4e		 dec	 esi
  00052	50		 push	 eax
  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	68 18 00 09 00	 push	 589848			; 00090018H
  00060	57		 push	 edi
  00061	ff d3		 call	 ebx
  00063	85 c0		 test	 eax, eax
  00065	74 d9		 je	 SHORT $LL2@DismountFi

; 1409 : 	}
; 1410 : 
; 1411 : 	if (!bResult)

  00067	eb 48		 jmp	 SHORT $LN9@DismountFi
$LN3@DismountFi:
  00069	85 c0		 test	 eax, eax
  0006b	75 44		 jne	 SHORT $LN9@DismountFi

; 1412 : 	{
; 1413 : 		if (!bForcedAllowed)

  0006d	39 45 10	 cmp	 DWORD PTR _bForcedAllowed$[ebp], eax
  00070	75 21		 jne	 SHORT $LN7@DismountFi
$LN21@DismountFi:

; 1414 : 		{
; 1415 : 			if (!bSilent)

  00072	83 7d 18 00	 cmp	 DWORD PTR _bSilent$[ebp], 0
  00076	75 0f		 jne	 SHORT $LN8@DismountFi

; 1416 : 				ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_LOCK_OR_DISMOUNT_FILESYS", TRUE);

  00078	6a 01		 push	 1
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@OMIEFGPE@INPLACE_ENC_CANT_LOCK_OR_DISMOUN@
  0007f	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  00084	83 c4 08	 add	 esp, 8
$LN8@DismountFi:

; 1417 : 
; 1418 : 			return ERR_DONT_REPORT;

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  0008e	5b		 pop	 ebx

; 1449 : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN7@DismountFi:

; 1419 : 		}
; 1420 : 
; 1421 : 		if (bForcedRequiresConfirmation
; 1422 : 			&& !bSilent
; 1423 : 			&& AskWarnYesNo ("VOL_LOCK_FAILED_OFFER_FORCED_DISMOUNT") == IDNO)

  00093	83 7d 14 00	 cmp	 DWORD PTR _bForcedRequiresConfirmation$[ebp], 0
  00097	74 18		 je	 SHORT $LN9@DismountFi
  00099	83 7d 18 00	 cmp	 DWORD PTR _bSilent$[ebp], 0
  0009d	75 12		 jne	 SHORT $LN9@DismountFi
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LMIKKFBM@VOL_LOCK_FAILED_OFFER_FORCED_DIS@
  000a4	e8 00 00 00 00	 call	 _AskWarnYesNo
  000a9	83 c4 04	 add	 esp, 4
  000ac	83 f8 07	 cmp	 eax, 7
  000af	74 d6		 je	 SHORT $LN8@DismountFi
$LN9@DismountFi:

; 1424 : 		{
; 1425 : 			return ERR_DONT_REPORT;
; 1426 : 		}
; 1427 : 	}
; 1428 : 
; 1429 : 	// Dismount the volume
; 1430 : 
; 1431 : 	attempt = UNMOUNT_MAX_AUTO_RETRIES * 10;
; 1432 : 
; 1433 : 	while (!(bResult = DeviceIoControl (dev, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &dwResult, NULL)) 
; 1434 : 		&& attempt > 0)

  000b1	6a 00		 push	 0
  000b3	8d 45 fc	 lea	 eax, DWORD PTR _dwResult$[ebp]
  000b6	be 2c 01 00 00	 mov	 esi, 300		; 0000012cH
  000bb	50		 push	 eax
  000bc	6a 00		 push	 0
  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	68 20 00 09 00	 push	 589856			; 00090020H
  000c9	57		 push	 edi
  000ca	ff d3		 call	 ebx
  000cc	85 c0		 test	 eax, eax
  000ce	75 38		 jne	 SHORT $LN10@DismountFi
$LL4@DismountFi:
  000d0	85 f6		 test	 esi, esi
  000d2	7e 2c		 jle	 SHORT $LN5@DismountFi

; 1435 : 	{
; 1436 : 		Sleep (UNMOUNT_AUTO_RETRY_DELAY);

  000d4	6a 32		 push	 50			; 00000032H
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  000dc	6a 00		 push	 0
  000de	8d 45 fc	 lea	 eax, DWORD PTR _dwResult$[ebp]

; 1437 : 		attempt--;

  000e1	4e		 dec	 esi
  000e2	50		 push	 eax
  000e3	6a 00		 push	 0
  000e5	6a 00		 push	 0
  000e7	6a 00		 push	 0
  000e9	6a 00		 push	 0
  000eb	68 20 00 09 00	 push	 589856			; 00090020H
  000f0	57		 push	 edi
  000f1	ff d3		 call	 ebx
  000f3	85 c0		 test	 eax, eax
  000f5	74 d9		 je	 SHORT $LL4@DismountFi

; 1441 : 	{
; 1442 : 		if (!bSilent)
; 1443 : 			ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_LOCK_OR_DISMOUNT_FILESYS", TRUE);
; 1444 : 
; 1445 : 		return ERR_DONT_REPORT; 
; 1446 : 	}
; 1447 : 
; 1448 : 	return ERR_SUCCESS; 

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	33 c0		 xor	 eax, eax
  000fb	5b		 pop	 ebx

; 1449 : }

  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
$LN5@DismountFi:

; 1438 : 	}
; 1439 : 
; 1440 : 	if (!bResult)

  00100	85 c0		 test	 eax, eax
  00102	0f 84 6a ff ff
	ff		 je	 $LN21@DismountFi
$LN10@DismountFi:
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi

; 1441 : 	{
; 1442 : 		if (!bSilent)
; 1443 : 			ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_LOCK_OR_DISMOUNT_FILESYS", TRUE);
; 1444 : 
; 1445 : 		return ERR_DONT_REPORT; 
; 1446 : 	}
; 1447 : 
; 1448 : 	return ERR_SUCCESS; 

  0010a	33 c0		 xor	 eax, eax
  0010c	5b		 pop	 ebx

; 1449 : }

  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
_DismountFileSystem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _OpenPartitionVolume
_TEXT	SEGMENT
_devName$ = 8						; size = 4
_bExclusiveRequired$ = 12				; size = 4
_bSharedRequired$ = 16					; size = 4
_bSharedRequiresConfirmation$ = 20			; size = 4
_bShowAlternativeSteps$ = 24				; size = 4
_bSilent$ = 28						; size = 4
_OpenPartitionVolume PROC				; COMDAT

; 1310 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1311 : 	HANDLE dev = INVALID_HANDLE_VALUE;
; 1312 : 	int retryCount = 0;
; 1313 : 
; 1314 : 	if (bExclusiveRequired)
; 1315 : 		bSharedRequired = FALSE;
; 1316 : 
; 1317 : 	if (bExclusiveRequired || !bSharedRequired)

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp__CreateFileA@28
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _devName$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	33 ff		 xor	 edi, edi
  00011	83 ce ff	 or	 esi, -1
  00014	39 7d 0c	 cmp	 DWORD PTR _bExclusiveRequired$[ebp], edi
  00017	75 09		 jne	 SHORT $LL2@OpenPartit
  00019	39 7d 10	 cmp	 DWORD PTR _bSharedRequired$[ebp], edi
  0001c	0f 85 91 00 00
	00		 jne	 $LN9@OpenPartit
$LL2@OpenPartit:

; 1318 : 	{
; 1319 : 		// Exclusive access
; 1320 : 		// Note that when exclusive access is denied, it is worth retrying (usually succeeds after a few tries).
; 1321 : 		while (dev == INVALID_HANDLE_VALUE && retryCount++ < EXCL_ACCESS_MAX_AUTO_RETRIES)

  00022	8b c7		 mov	 eax, edi
  00024	47		 inc	 edi
  00025	3d f4 01 00 00	 cmp	 eax, 500		; 000001f4H
  0002a	7d 36		 jge	 SHORT $LN3@OpenPartit

; 1322 : 		{
; 1323 : 			dev = CreateFile (devName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_WRITE_THROUGH, NULL);

  0002c	6a 00		 push	 0
  0002e	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00033	6a 03		 push	 3
  00035	6a 00		 push	 0
  00037	6a 00		 push	 0
  00039	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  0003e	53		 push	 ebx
  0003f	ff d1		 call	 ecx
  00041	8b f0		 mov	 esi, eax

; 1324 : 
; 1325 : 			if (retryCount > 1)

  00043	83 ff 01	 cmp	 edi, 1
  00046	7e 08		 jle	 SHORT $LN7@OpenPartit

; 1326 : 				Sleep (EXCL_ACCESS_AUTO_RETRY_DELAY);

  00048	6a 0a		 push	 10			; 0000000aH
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN7@OpenPartit:

; 1318 : 	{
; 1319 : 		// Exclusive access
; 1320 : 		// Note that when exclusive access is denied, it is worth retrying (usually succeeds after a few tries).
; 1321 : 		while (dev == INVALID_HANDLE_VALUE && retryCount++ < EXCL_ACCESS_MAX_AUTO_RETRIES)

  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp__CreateFileA@28
  00056	83 fe ff	 cmp	 esi, -1
  00059	74 c7		 je	 SHORT $LL2@OpenPartit
$LN14@OpenPartit:
  0005b	5f		 pop	 edi

; 1356 : 			}
; 1357 : 		}
; 1358 : 		else
; 1359 : 		{
; 1360 : 			if (!bSilent)
; 1361 : 			{
; 1362 : 				handleWin32Error (MainDlg);
; 1363 : 
; 1364 : 				if (bShowAlternativeSteps)
; 1365 : 					ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL_ALT", TRUE);
; 1366 : 				else
; 1367 : 					Error ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL");
; 1368 : 			}
; 1369 : 			return INVALID_HANDLE_VALUE;
; 1370 : 		}
; 1371 : 	}
; 1372 : 
; 1373 : 	return dev;

  0005c	8b c6		 mov	 eax, esi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 1374 : }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN3@OpenPartit:

; 1327 : 		}
; 1328 : 	}
; 1329 : 
; 1330 : 	if (dev == INVALID_HANDLE_VALUE)

  00062	83 fe ff	 cmp	 esi, -1
  00065	75 f4		 jne	 SHORT $LN14@OpenPartit

; 1331 : 	{
; 1332 : 		if (bExclusiveRequired)

  00067	83 7d 0c 00	 cmp	 DWORD PTR _bExclusiveRequired$[ebp], 0
  0006b	74 46		 je	 SHORT $LN9@OpenPartit
$LN13@OpenPartit:

; 1333 : 		{
; 1334 : 			if (!bSilent)

  0006d	83 7d 1c 00	 cmp	 DWORD PTR _bSilent$[ebp], 0
  00071	75 38		 jne	 SHORT $LN12@OpenPartit

; 1335 : 			{
; 1336 : 				handleWin32Error (MainDlg);

  00073	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00079	e8 00 00 00 00	 call	 _handleWin32Error
  0007e	83 c4 04	 add	 esp, 4

; 1337 : 
; 1338 : 				if (bShowAlternativeSteps)

  00081	83 7d 18 00	 cmp	 DWORD PTR _bShowAlternativeSteps$[ebp], 0
  00085	74 17		 je	 SHORT $LN11@OpenPartit

; 1339 : 					ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL_ALT", TRUE);

  00087	6a 01		 push	 1
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  0008e	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  00093	83 c4 08	 add	 esp, 8

; 1342 : 			}
; 1343 : 			return INVALID_HANDLE_VALUE;

  00096	83 c8 ff	 or	 eax, -1
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 1374 : }

  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
$LN11@OpenPartit:

; 1340 : 				else
; 1341 : 					Error ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL");

  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  000a3	e8 00 00 00 00	 call	 _Error
  000a8	83 c4 04	 add	 esp, 4
$LN12@OpenPartit:

; 1342 : 			}
; 1343 : 			return INVALID_HANDLE_VALUE;

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	83 c8 ff	 or	 eax, -1
  000b0	5b		 pop	 ebx

; 1374 : }

  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
$LN9@OpenPartit:

; 1344 : 		}
; 1345 : 
; 1346 : 		// Shared mode
; 1347 : 		dev = CreateFile (devName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_WRITE_THROUGH, NULL);

  000b3	6a 00		 push	 0
  000b5	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000ba	6a 03		 push	 3
  000bc	6a 00		 push	 0
  000be	6a 03		 push	 3
  000c0	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  000c5	53		 push	 ebx
  000c6	ff d1		 call	 ecx
  000c8	8b f0		 mov	 esi, eax

; 1348 : 		if (dev != INVALID_HANDLE_VALUE)

  000ca	83 fe ff	 cmp	 esi, -1
  000cd	74 9e		 je	 SHORT $LN13@OpenPartit

; 1349 : 		{
; 1350 : 			if (bSharedRequiresConfirmation 
; 1351 : 				&& !bSilent
; 1352 : 				&& AskWarnNoYes ("DEVICE_IN_USE_INPLACE_ENC") == IDNO)

  000cf	83 7d 14 00	 cmp	 DWORD PTR _bSharedRequiresConfirmation$[ebp], 0
  000d3	74 86		 je	 SHORT $LN14@OpenPartit
  000d5	83 7d 1c 00	 cmp	 DWORD PTR _bSilent$[ebp], 0
  000d9	75 80		 jne	 SHORT $LN14@OpenPartit
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@KFDNCGEE@DEVICE_IN_USE_INPLACE_ENC?$AA@
  000e0	e8 00 00 00 00	 call	 _AskWarnNoYes
  000e5	83 c4 04	 add	 esp, 4
  000e8	83 f8 07	 cmp	 eax, 7
  000eb	0f 85 6a ff ff
	ff		 jne	 $LN14@OpenPartit

; 1353 : 			{
; 1354 : 				CloseHandle (dev);

  000f1	56		 push	 esi
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 1355 : 				return INVALID_HANDLE_VALUE;

  000fa	83 c8 ff	 or	 eax, -1
  000fd	5b		 pop	 ebx

; 1374 : }

  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
_OpenPartitionVolume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _FastVolumeHeaderUpdate
_TEXT	SEGMENT
_offset$1$ = -12					; size = 4
_dwError$1$ = -12					; size = 4
_offset$2$ = -8						; size = 4
_n$ = -4						; size = 4
_dev$ = 8						; size = 4
_headerCryptoInfo$ = 12					; size = 4
_masterCryptoInfo$ = 16					; size = 4
_deviceSize$ = 20					; size = 8
_FastVolumeHeaderUpdate PROC				; COMDAT

; 1216 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1217 : 	LARGE_INTEGER offset;
; 1218 : 	DWORD n;
; 1219 : 	int nStatus = ERR_SUCCESS;
; 1220 : 	byte *header;
; 1221 : 	DWORD dwError;
; 1222 : 	uint32 headerCrc32;
; 1223 : 	byte *fieldPos;
; 1224 : 
; 1225 : 	header = (byte *) GSTalloc (GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00008	68 00 02 00 00	 push	 512			; 00000200H
  0000d	33 db		 xor	 ebx, ebx
  0000f	e8 00 00 00 00	 call	 _malloc
  00014	8b f0		 mov	 esi, eax
  00016	83 c4 04	 add	 esp, 4

; 1226 : 
; 1227 : 	if (!header)

  00019	85 f6		 test	 esi, esi
  0001b	75 09		 jne	 SHORT $LN7@FastVolume

; 1228 : 		return ERR_OUTOFMEMORY;

  0001d	5e		 pop	 esi
  0001e	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00021	5b		 pop	 ebx

; 1284 : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN7@FastVolume:
  00026	57		 push	 edi

; 1229 : 
; 1230 : 	VirtualLock (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00027	68 00 02 00 00	 push	 512			; 00000200H
  0002c	56		 push	 esi
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 1231 : 
; 1232 : 
; 1233 : 	fieldPos = (byte *) header + GST_HEADER_OFFSET_ENCRYPTED_AREA_START;
; 1234 : 
; 1235 : 	offset.QuadPart = deviceSize - GST_VOLUME_HEADER_GROUP_SIZE;

  00033	8b 45 14	 mov	 eax, DWORD PTR _deviceSize$[ebp]
  00036	8b 4d 18	 mov	 ecx, DWORD PTR _deviceSize$[ebp+4]
  00039	2d 00 00 02 00	 sub	 eax, 131072		; 00020000H

; 1236 : 
; 1237 : 	if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 1238 : 		|| !ReadEffectiveVolumeHeader (TRUE, dev, header, &n) || n < GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	1b cb		 sbb	 ecx, ebx
  00044	89 45 f4	 mov	 DWORD PTR _offset$1$[ebp], eax
  00047	51		 push	 ecx
  00048	50		 push	 eax
  00049	ff 75 08	 push	 DWORD PTR _dev$[ebp]
  0004c	89 4d f8	 mov	 DWORD PTR _offset$2$[ebp], ecx
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00055	85 c0		 test	 eax, eax
  00057	0f 84 69 01 00
	00		 je	 $LN9@FastVolume
  0005d	8d 45 fc	 lea	 eax, DWORD PTR _n$[ebp]
  00060	50		 push	 eax
  00061	56		 push	 esi
  00062	ff 75 08	 push	 DWORD PTR _dev$[ebp]
  00065	6a 01		 push	 1
  00067	e8 00 00 00 00	 call	 _ReadEffectiveVolumeHeader
  0006c	83 c4 10	 add	 esp, 16			; 00000010H
  0006f	85 c0		 test	 eax, eax
  00071	0f 84 4f 01 00
	00		 je	 $LN9@FastVolume
  00077	81 7d fc 00 02
	00 00		 cmp	 DWORD PTR _n$[ebp], 512	; 00000200H
  0007e	0f 82 42 01 00
	00		 jb	 $LN9@FastVolume

; 1241 : 		goto closing_seq;
; 1242 : 	}
; 1243 : 
; 1244 : 
; 1245 : 	DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, headerCryptoInfo);

  00084	ff 75 0c	 push	 DWORD PTR _headerCryptoInfo$[ebp]
  00087	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  0008a	6a 00		 push	 0
  0008c	68 c0 01 00 00	 push	 448			; 000001c0H
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _DecryptBuffer

; 1246 : 
; 1247 : 	if (GetHeaderField32 (header, GST_HEADER_OFFSET_MAGIC) != 0x54525545)

  00097	6a 40		 push	 64			; 00000040H
  00099	56		 push	 esi
  0009a	e8 00 00 00 00	 call	 _GetHeaderField32
  0009f	83 c4 18	 add	 esp, 24			; 00000018H
  000a2	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  000a7	74 0a		 je	 SHORT $LN11@FastVolume

; 1248 : 	{
; 1249 : 		nStatus = ERR_PARAMETER_INCORRECT;

  000a9	bb 1e 00 00 00	 mov	 ebx, 30			; 0000001eH

; 1266 : 	{
; 1267 : 		nStatus = ERR_OS_ERROR;
; 1268 : 		goto closing_seq;
; 1269 : 	}
; 1270 : 
; 1271 : 
; 1272 : closing_seq:

  000ae	e9 18 01 00 00	 jmp	 $closing_seq$38
$LN11@FastVolume:

; 1250 : 		goto closing_seq;
; 1251 : 	}
; 1252 : 
; 1253 : 	mputInt64 (fieldPos, (masterCryptoInfo->EncryptedAreaStart.Value));

  000b3	8b 4d 10	 mov	 ecx, DWORD PTR _masterCryptoInfo$[ebp]

; 1254 : 	mputInt64 (fieldPos, (masterCryptoInfo->EncryptedAreaLength.Value));
; 1255 : 
; 1256 : 
; 1257 : 	headerCrc32 = GetCrc32 (header + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC);

  000b6	8d 7e 40	 lea	 edi, DWORD PTR [esi+64]
  000b9	68 bc 00 00 00	 push	 188			; 000000bcH
  000be	57		 push	 edi
  000bf	0f b6 81 ff 1e
	00 00		 movzx	 eax, BYTE PTR [ecx+7935]
  000c6	88 46 6c	 mov	 BYTE PTR [esi+108], al
  000c9	0f b6 81 fe 1e
	00 00		 movzx	 eax, BYTE PTR [ecx+7934]
  000d0	88 46 6d	 mov	 BYTE PTR [esi+109], al
  000d3	0f b6 81 fd 1e
	00 00		 movzx	 eax, BYTE PTR [ecx+7933]
  000da	88 46 6e	 mov	 BYTE PTR [esi+110], al
  000dd	0f b6 81 fc 1e
	00 00		 movzx	 eax, BYTE PTR [ecx+7932]
  000e4	88 46 6f	 mov	 BYTE PTR [esi+111], al
  000e7	0f b6 81 fb 1e
	00 00		 movzx	 eax, BYTE PTR [ecx+7931]
  000ee	88 46 70	 mov	 BYTE PTR [esi+112], al
  000f1	0f b6 81 fa 1e
	00 00		 movzx	 eax, BYTE PTR [ecx+7930]
  000f8	88 46 71	 mov	 BYTE PTR [esi+113], al
  000fb	0f b6 81 f9 1e
	00 00		 movzx	 eax, BYTE PTR [ecx+7929]
  00102	88 46 72	 mov	 BYTE PTR [esi+114], al
  00105	0f b6 81 f8 1e
	00 00		 movzx	 eax, BYTE PTR [ecx+7928]
  0010c	88 46 73	 mov	 BYTE PTR [esi+115], al
  0010f	0f b6 81 07 1f
	00 00		 movzx	 eax, BYTE PTR [ecx+7943]
  00116	88 46 74	 mov	 BYTE PTR [esi+116], al
  00119	0f b6 81 06 1f
	00 00		 movzx	 eax, BYTE PTR [ecx+7942]
  00120	88 46 75	 mov	 BYTE PTR [esi+117], al
  00123	0f b6 81 05 1f
	00 00		 movzx	 eax, BYTE PTR [ecx+7941]
  0012a	88 46 76	 mov	 BYTE PTR [esi+118], al
  0012d	0f b6 81 04 1f
	00 00		 movzx	 eax, BYTE PTR [ecx+7940]
  00134	88 46 77	 mov	 BYTE PTR [esi+119], al
  00137	0f b6 81 03 1f
	00 00		 movzx	 eax, BYTE PTR [ecx+7939]
  0013e	88 46 78	 mov	 BYTE PTR [esi+120], al
  00141	0f b6 81 02 1f
	00 00		 movzx	 eax, BYTE PTR [ecx+7938]
  00148	88 46 79	 mov	 BYTE PTR [esi+121], al
  0014b	0f b6 81 01 1f
	00 00		 movzx	 eax, BYTE PTR [ecx+7937]
  00152	88 46 7a	 mov	 BYTE PTR [esi+122], al
  00155	0f b6 81 00 1f
	00 00		 movzx	 eax, BYTE PTR [ecx+7936]
  0015c	88 46 7b	 mov	 BYTE PTR [esi+123], al
  0015f	e8 00 00 00 00	 call	 _GetCrc32

; 1258 : 	fieldPos = (byte *) header + GST_HEADER_OFFSET_HEADER_CRC;
; 1259 : 	mputLong (fieldPos, headerCrc32);
; 1260 : 
; 1261 : 	EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, headerCryptoInfo);

  00164	ff 75 0c	 push	 DWORD PTR _headerCryptoInfo$[ebp]
  00167	8b d0		 mov	 edx, eax
  00169	c1 e8 18	 shr	 eax, 24			; 00000018H
  0016c	88 86 fc 00 00
	00		 mov	 BYTE PTR [esi+252], al
  00172	8b c2		 mov	 eax, edx
  00174	c1 e8 10	 shr	 eax, 16			; 00000010H
  00177	88 86 fd 00 00
	00		 mov	 BYTE PTR [esi+253], al
  0017d	8b c2		 mov	 eax, edx
  0017f	6a 00		 push	 0
  00181	c1 e8 08	 shr	 eax, 8
  00184	68 c0 01 00 00	 push	 448			; 000001c0H
  00189	88 86 fe 00 00
	00		 mov	 BYTE PTR [esi+254], al
  0018f	57		 push	 edi
  00190	88 96 ff 00 00
	00		 mov	 BYTE PTR [esi+255], dl
  00196	e8 00 00 00 00	 call	 _EncryptBuffer

; 1262 : 
; 1263 : 
; 1264 : 	if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 1265 : 		|| !WriteEffectiveVolumeHeader (TRUE, dev, header))

  0019b	8b 7d 08	 mov	 edi, DWORD PTR _dev$[ebp]
  0019e	83 c4 18	 add	 esp, 24			; 00000018H
  001a1	6a 00		 push	 0
  001a3	6a 00		 push	 0
  001a5	ff 75 f8	 push	 DWORD PTR _offset$2$[ebp]
  001a8	ff 75 f4	 push	 DWORD PTR _offset$1$[ebp]
  001ab	57		 push	 edi
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  001b2	85 c0		 test	 eax, eax
  001b4	74 10		 je	 SHORT $LN9@FastVolume
  001b6	56		 push	 esi
  001b7	57		 push	 edi
  001b8	6a 01		 push	 1
  001ba	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  001bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c2	85 c0		 test	 eax, eax
  001c4	75 05		 jne	 SHORT $closing_seq$38
$LN9@FastVolume:

; 1239 : 	{
; 1240 : 		nStatus = ERR_OS_ERROR;

  001c6	bb 01 00 00 00	 mov	 ebx, 1
$closing_seq$38:

; 1273 : 
; 1274 : 	dwError = GetLastError();

  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001d1	89 45 f4	 mov	 DWORD PTR _dwError$1$[ebp], eax

; 1275 : 
; 1276 : 	burn (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  001d4	8b ce		 mov	 ecx, esi
  001d6	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  001db	8b d6		 mov	 edx, esi
  001dd	8b f8		 mov	 edi, eax
  001df	90		 npad	 1
$LL19@FastVolume:
  001e0	c6 02 00	 mov	 BYTE PTR [edx], 0
  001e3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  001e6	83 ef 01	 sub	 edi, 1
  001e9	75 f5		 jne	 SHORT $LL19@FastVolume
  001eb	5f		 pop	 edi
  001ec	0f 1f 40 00	 npad	 4
$LL5@FastVolume:
  001f0	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001f3	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  001f6	83 e8 01	 sub	 eax, 1
  001f9	75 f5		 jne	 SHORT $LL5@FastVolume

; 1277 : 	VirtualUnlock (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  001fb	68 00 02 00 00	 push	 512			; 00000200H
  00200	56		 push	 esi
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 1278 : 	GSTfree (header);

  00207	56		 push	 esi
  00208	e8 00 00 00 00	 call	 _free
  0020d	83 c4 04	 add	 esp, 4
  00210	85 db		 test	 ebx, ebx

; 1279 : 
; 1280 : 	if (nStatus != ERR_SUCCESS)

  00212	74 09		 je	 SHORT $LN16@FastVolume

; 1281 : 		SetLastError (dwError);

  00214	ff 75 f4	 push	 DWORD PTR _dwError$1$[ebp]
  00217	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN16@FastVolume:

; 1282 : 
; 1283 : 	return nStatus;

  0021d	5e		 pop	 esi
  0021e	8b c3		 mov	 eax, ebx
  00220	5b		 pop	 ebx

; 1284 : }

  00221	8b e5		 mov	 esp, ebp
  00223	5d		 pop	 ebp
  00224	c3		 ret	 0
_FastVolumeHeaderUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _SetNonSysInplaceEncUIStatus
_TEXT	SEGMENT
_nonSysInplaceEncStatus$ = 8				; size = 4
_SetNonSysInplaceEncUIStatus PROC			; COMDAT

; 1569 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1570 : 	NonSysInplaceEncStatus = nonSysInplaceEncStatus;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nonSysInplaceEncStatus$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, eax

; 1571 : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_SetNonSysInplaceEncUIStatus ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _ShowInPlaceEncErrMsgWAltSteps
_TEXT	SEGMENT
_msg$ = -60004						; size = 60000
__$ArrayPad$ = -4					; size = 4
_iniStrId$ = 8						; size = 4
_bErr$ = 12						; size = 4
_ShowInPlaceEncErrMsgWAltSteps PROC			; COMDAT

; 1529 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 64 ea 00 00	 mov	 eax, 60004		; 0000ea64H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _iniStrId$[ebp]

; 1530 : 	wchar_t msg[30000];
; 1531 : 
; 1532 : 	wcscpy (msg, GetString (iniStrId));

  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _GetString
  00020	8d 95 9c 15 ff
	ff		 lea	 edx, DWORD PTR _msg$[ebp]
  00026	83 c4 04	 add	 esp, 4
  00029	2b d0		 sub	 edx, eax
  0002b	0f 1f 44 00 00	 npad	 5
$LL5@ShowInPlac:
  00030	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00033	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00036	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0003b	66 85 c9	 test	 cx, cx
  0003e	75 f0		 jne	 SHORT $LL5@ShowInPlac

; 1533 : 
; 1534 : 	wcscat (msg, L"\n\n\n");

  00040	8d 8d 9c 15 ff
	ff		 lea	 ecx, DWORD PTR _msg$[ebp]
  00046	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@ShowInPlac:
  00050	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  00054	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00057	66 85 c0	 test	 ax, ax
  0005a	75 f4		 jne	 SHORT $LL9@ShowInPlac
  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@
  00061	56		 push	 esi
  00062	89 01		 mov	 DWORD PTR [ecx], eax
  00064	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@+4
  00069	57		 push	 edi

; 1535 : 	wcscat (msg, GetString ("INPLACE_ENC_ALTERNATIVE_STEPS"));

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LGBJGGOF@INPLACE_ENC_ALTERNATIVE_STEPS?$AA@
  0006f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00072	e8 00 00 00 00	 call	 _GetString
  00077	8b d0		 mov	 edx, eax
  00079	83 c4 04	 add	 esp, 4
  0007c	8b f2		 mov	 esi, edx
  0007e	66 90		 npad	 2
$LL10@ShowInPlac:
  00080	66 8b 02	 mov	 ax, WORD PTR [edx]
  00083	83 c2 02	 add	 edx, 2
  00086	66 85 c0	 test	 ax, ax
  00089	75 f5		 jne	 SHORT $LL10@ShowInPlac
  0008b	8d bd 9c 15 ff
	ff		 lea	 edi, DWORD PTR _msg$[ebp]
  00091	2b d6		 sub	 edx, esi
  00093	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL11@ShowInPlac:
  00096	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  0009a	83 c7 02	 add	 edi, 2
  0009d	66 85 c0	 test	 ax, ax
  000a0	75 f4		 jne	 SHORT $LL11@ShowInPlac
  000a2	8b ca		 mov	 ecx, edx

; 1536 : 
; 1537 : 	if (bErr)
; 1538 : 		ErrorDirect (msg);

  000a4	8d 85 9c 15 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  000aa	c1 e9 02	 shr	 ecx, 2
  000ad	f3 a5		 rep movsd
  000af	8b ca		 mov	 ecx, edx
  000b1	83 e1 03	 and	 ecx, 3
  000b4	83 7d 0c 00	 cmp	 DWORD PTR _bErr$[ebp], 0
  000b8	f3 a4		 rep movsb
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	50		 push	 eax
  000bd	74 16		 je	 SHORT $LN2@ShowInPlac
  000bf	e8 00 00 00 00	 call	 _ErrorDirect

; 1539 : 	else
; 1540 : 		WarningDirect (msg);

  000c4	83 c4 04	 add	 esp, 4

; 1541 : }

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ca	33 cd		 xor	 ecx, ebp
  000cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
$LN2@ShowInPlac:

; 1539 : 	else
; 1540 : 		WarningDirect (msg);

  000d5	e8 00 00 00 00	 call	 _WarningDirect

; 1541 : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	83 c4 04	 add	 esp, 4
  000e0	33 cd		 xor	 ecx, ebp
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
_ShowInPlaceEncErrMsgWAltSteps ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _EncryptPartitionInPlaceResume
_TEXT	SEGMENT
tv1095 = -62240						; size = 16
_dwResult$ = -62220					; size = 4
_zeroedSectorCount$ = -62216				; size = 8
_unitNo$ = -62208					; size = 8
_sectorSize$ = -62200					; size = 4
_bEncryptedAreaSizeChanged$1$ = -62196			; size = 4
_offset$ = -62192					; size = 8
_bPause$1$ = -62188					; size = 4
tv1062 = -62180						; size = 4
_tmpCryptoInfo$ = -62176				; size = 4
_lastHeaderUpdateDistance$2$ = -62172			; size = 4
_lastHeaderUpdateDistance$1$ = -62168			; size = 4
_devicePath$1$ = -62164					; size = 4
_workChunkSize$1$ = -62160				; size = 4
_n$ = -62156						; size = 4
_masterCryptoInfo$5$ = -62152				; size = 4
tv1063 = -62152						; size = 4
_header$1$ = -62148					; size = 4
_dwError$2$ = -62144					; size = 4
_password$1$ = -62144					; size = 4
_wipeRandCharsUpdate$1$ = -62138			; size = 2
_wipeRandCharsUpdate$ = -62136				; size = 3
_wipeRandChars$ = -62136				; size = 3
_headerCryptoInfo$1$ = -62132				; size = 4
_deviceSize$2$ = -62128					; size = 4
_deviceSize$1$ = -62124					; size = 4
_deviceSize$ = -62120					; size = 8
_lastHeaderUpdateDistance$ = -62120			; size = 8
_offset$8$ = -62116					; size = 4
_dwError$3$ = -62116					; size = 4
tv1087 = -62116						; size = 4
tv1084 = -62116						; size = 4
_wipeBuffer$1$ = -62112					; size = 4
_wipeRandCharsUpdate$2$ = -62105			; size = 1
$T1 = -62104						; size = 4
_offset$7$ = -62104					; size = 4
_remainingBytes$2$ = -62104				; size = 4
$T2 = -62100						; size = 4
_offset$3$ = -62100					; size = 4
_remainingBytes$1$ = -62100				; size = 4
_buf$1$ = -62096					; size = 4
_wipePass$1$ = -62089					; size = 1
_masterCryptoInfo$ = -62088				; size = 4
_dev$GSCopy$1$ = -62084					; size = 4
_driveGeometry$ = -62080				; size = 24
_msg$3 = -62056						; size = 60000
_deviceName$ = -2056					; size = 520
_sizeStr$4 = -1536					; size = 1000
_devName$ = -536					; size = 260
_dosDev$ = -272						; size = 260
__$ArrayPad$ = -4					; size = 4
_dev$ = 8						; size = 4
_volParams$ = 12					; size = 4
_wipeAlgorithm$ = 16					; size = 4
_bTryToCorrectReadErrors$ = 20				; size = 4
_EncryptPartitionInPlaceResume PROC			; COMDAT

; 741  : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	b8 28 f3 00 00	 mov	 eax, 62248		; 0000f328H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	56		 push	 esi
  0002b	8b 73 0c	 mov	 esi, DWORD PTR _volParams$[ebx]
  0002e	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  00034	57		 push	 edi
  00035	8b 7b 08	 mov	 edi, DWORD PTR _dev$[ebx]
  00038	68 04 01 00 00	 push	 260			; 00000104H
  0003d	6a 00		 push	 0
  0003f	50		 push	 eax
  00040	89 bd 7c 0d ff
	ff		 mov	 DWORD PTR _dev$GSCopy$1$[ebp], edi

; 742  : 	PCRYPTO_INFO masterCryptoInfo = NULL, headerCryptoInfo = NULL, tmpCryptoInfo = NULL;

  00046	c7 85 78 0d ff
	ff 00 00 00 00	 mov	 DWORD PTR _masterCryptoInfo$[ebp], 0
  00050	c7 85 4c 0d ff
	ff 00 00 00 00	 mov	 DWORD PTR _headerCryptoInfo$1$[ebp], 0
  0005a	c7 85 20 0d ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpCryptoInfo$[ebp], 0

; 743  : 	UINT64_STRUCT unitNo;
; 744  : 	char *buf = NULL, *header = NULL;

  00064	c7 85 3c 0d ff
	ff 00 00 00 00	 mov	 DWORD PTR _header$1$[ebp], 0

; 745  : 	byte *wipeBuffer = NULL;

  0006e	c7 85 60 0d ff
	ff 00 00 00 00	 mov	 DWORD PTR _wipeBuffer$1$[ebp], 0
  00078	e8 00 00 00 00	 call	 _memset
  0007d	68 04 01 00 00	 push	 260			; 00000104H
  00082	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  00088	6a 00		 push	 0
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _memset

; 746  : 	byte wipeRandChars [GST_WIPE_RAND_CHAR_COUNT];
; 747  : 	byte wipeRandCharsUpdate [GST_WIPE_RAND_CHAR_COUNT];
; 748  : 	char dosDev[GST_MAX_PATH] = {0};
; 749  : 	char devName[MAX_PATH] = {0};
; 750  : 	WCHAR deviceName[MAX_PATH];
; 751  : 	int nStatus = ERR_SUCCESS;
; 752  : 	__int64 deviceSize;
; 753  : 	uint64 remainingBytes, lastHeaderUpdateDistance = 0, zeroedSectorCount = 0;
; 754  : 	uint32 workChunkSize;
; 755  : 	DWORD dwError, dwResult;
; 756  : 	BOOL bPause = FALSE, bEncryptedAreaSizeChanged = FALSE;
; 757  : 	LARGE_INTEGER offset;
; 758  : 	int sectorSize;
; 759  : 	int i;
; 760  : 	DWORD n;
; 761  : 	char *devicePath = volParams->volumePath;

  00090	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00093	0f 57 c0	 xorps	 xmm0, xmm0
  00096	89 85 2c 0d ff
	ff		 mov	 DWORD PTR _devicePath$1$[ebp], eax

; 762  : 	Password *password = volParams->password;

  0009c	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0009f	66 0f 13 85 f8
	0c ff ff	 movlpd	 QWORD PTR _zeroedSectorCount$[ebp], xmm0

; 763  : 	DISK_GEOMETRY driveGeometry;
; 764  : 
; 765  : 
; 766  : 	bInPlaceEncNonSysResumed = TRUE;
; 767  : 
; 768  : 	buf = (char *) GSTalloc (GST_MAX_NONSYS_INPLACE_ENC_WORK_CHUNK_SIZE);

  000a7	68 00 00 20 00	 push	 2097152			; 00200000H
  000ac	c7 85 14 0d ff
	ff 00 00 00 00	 mov	 DWORD PTR _bPause$1$[ebp], 0
  000b6	c7 85 0c 0d ff
	ff 00 00 00 00	 mov	 DWORD PTR _bEncryptedAreaSizeChanged$1$[ebp], 0
  000c0	89 85 40 0d ff
	ff		 mov	 DWORD PTR _password$1$[ebp], eax
  000c6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSysResumed, 1
  000d0	e8 00 00 00 00	 call	 _malloc
  000d5	83 c4 1c	 add	 esp, 28			; 0000001cH
  000d8	89 85 70 0d ff
	ff		 mov	 DWORD PTR _buf$1$[ebp], eax

; 769  : 	if (!buf)

  000de	85 c0		 test	 eax, eax
  000e0	75 22		 jne	 SHORT $LN21@EncryptPar
$LN264@EncryptPar:

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  000e2	8b 85 5c 0d ff
	ff		 mov	 eax, DWORD PTR _deviceSize$[ebp+4]
  000e8	be 02 00 00 00	 mov	 esi, 2
  000ed	89 85 50 0d ff
	ff		 mov	 DWORD PTR _deviceSize$2$[ebp], eax
  000f3	8b 85 58 0d ff
	ff		 mov	 eax, DWORD PTR _deviceSize$[ebp]
  000f9	89 85 54 0d ff
	ff		 mov	 DWORD PTR _deviceSize$1$[ebp], eax
  000ff	e9 ef 0b 00 00	 jmp	 $closing_seq$266
$LN21@EncryptPar:

; 770  : 	{
; 771  : 		nStatus = ERR_OUTOFMEMORY;
; 772  : 		goto closing_seq;
; 773  : 	}
; 774  : 
; 775  : 	header = (char *) GSTalloc (GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00104	68 00 02 00 00	 push	 512			; 00000200H
  00109	e8 00 00 00 00	 call	 _malloc
  0010e	83 c4 04	 add	 esp, 4
  00111	89 85 3c 0d ff
	ff		 mov	 DWORD PTR _header$1$[ebp], eax

; 776  : 	if (!header)

  00117	85 c0		 test	 eax, eax
  00119	74 c7		 je	 SHORT $LN264@EncryptPar

; 777  : 	{
; 778  : 		nStatus = ERR_OUTOFMEMORY;
; 779  : 		goto closing_seq;
; 780  : 	}
; 781  : 
; 782  : 	VirtualLock (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  0011b	68 00 02 00 00	 push	 512			; 00000200H
  00120	50		 push	 eax
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 783  : 
; 784  : 	if (wipeAlgorithm != GST_WIPE_NONE)

  00127	83 7b 10 00	 cmp	 DWORD PTR _wipeAlgorithm$[ebx], 0
  0012b	74 17		 je	 SHORT $LN26@EncryptPar

; 785  : 	{
; 786  : 		wipeBuffer = (byte *) GSTalloc (GST_MAX_NONSYS_INPLACE_ENC_WORK_CHUNK_SIZE);

  0012d	68 00 00 20 00	 push	 2097152			; 00200000H
  00132	e8 00 00 00 00	 call	 _malloc
  00137	83 c4 04	 add	 esp, 4
  0013a	89 85 60 0d ff
	ff		 mov	 DWORD PTR _wipeBuffer$1$[ebp], eax

; 787  : 		if (!wipeBuffer)

  00140	85 c0		 test	 eax, eax
  00142	74 9e		 je	 SHORT $LN264@EncryptPar
$LN26@EncryptPar:

; 788  : 		{
; 789  : 			nStatus = ERR_OUTOFMEMORY;
; 790  : 			goto closing_seq;
; 791  : 		}
; 792  : 	}
; 793  : 
; 794  : 	headerCryptoInfo = crypto_open();

  00144	e8 00 00 00 00	 call	 _crypto_open
  00149	89 85 4c 0d ff
	ff		 mov	 DWORD PTR _headerCryptoInfo$1$[ebp], eax

; 795  : 
; 796  : 	if (headerCryptoInfo == NULL)

  0014f	85 c0		 test	 eax, eax
  00151	74 8f		 je	 SHORT $LN264@EncryptPar

; 797  : 	{
; 798  : 		nStatus = ERR_OUTOFMEMORY;
; 799  : 		goto closing_seq;
; 800  : 	}
; 801  : 
; 802  : 	deviceSize = GetDeviceSize (devicePath);

  00153	8b b5 2c 0d ff
	ff		 mov	 esi, DWORD PTR _devicePath$1$[ebp]
  00159	56		 push	 esi
  0015a	e8 00 00 00 00	 call	 _GetDeviceSize
  0015f	8b ca		 mov	 ecx, edx
  00161	89 85 54 0d ff
	ff		 mov	 DWORD PTR _deviceSize$1$[ebp], eax
  00167	83 c4 04	 add	 esp, 4
  0016a	89 8d 50 0d ff
	ff		 mov	 DWORD PTR _deviceSize$2$[ebp], ecx

; 803  : 	if (deviceSize < 0)

  00170	85 c9		 test	 ecx, ecx
  00172	7f 10		 jg	 SHORT $LN30@EncryptPar
  00174	7c 04		 jl	 SHORT $LN205@EncryptPar
  00176	85 c0		 test	 eax, eax
  00178	73 0a		 jae	 SHORT $LN30@EncryptPar
$LN205@EncryptPar:

; 804  : 	{
; 805  : 		// Cannot determine the size of the partition
; 806  : 		nStatus = ERR_OS_ERROR;

  0017a	be 01 00 00 00	 mov	 esi, 1

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  0017f	e9 6f 0b 00 00	 jmp	 $closing_seq$266
$LN30@EncryptPar:

; 807  : 		goto closing_seq;
; 808  : 	}
; 809  : 
; 810  : 	if (dev == INVALID_HANDLE_VALUE)

  00184	83 ff ff	 cmp	 edi, -1
  00187	0f 85 29 01 00
	00		 jne	 $LN35@EncryptPar

; 811  : 	{
; 812  : 		strcpy ((char *)deviceName, devicePath);

  0018d	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _deviceName$[ebp]
  00193	8b ce		 mov	 ecx, esi
  00195	2b d6		 sub	 edx, esi
$LL91@EncryptPar:
  00197	8a 01		 mov	 al, BYTE PTR [ecx]
  00199	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0019c	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  001a0	84 c0		 test	 al, al
  001a2	75 f3		 jne	 SHORT $LL91@EncryptPar

; 813  : 		ToUNICODE ((char *)deviceName);

  001a4	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 _ToUNICODE

; 814  : 
; 815  : 		if (FakeDosNameForDevice (devicePath, dosDev, devName, FALSE) != 0)

  001b0	6a 00		 push	 0
  001b2	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  001b8	50		 push	 eax
  001b9	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  001bf	50		 push	 eax
  001c0	56		 push	 esi
  001c1	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  001c6	83 c4 14	 add	 esp, 20			; 00000014H
  001c9	85 c0		 test	 eax, eax
  001cb	74 0a		 je	 SHORT $LN33@EncryptPar

; 816  : 		{
; 817  : 			nStatus = ERR_OS_ERROR;

  001cd	be 01 00 00 00	 mov	 esi, 1

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  001d2	e9 1c 0b 00 00	 jmp	 $closing_seq$266
$LN33@EncryptPar:

; 818  : 			goto closing_seq;
; 819  : 		}
; 820  : 
; 821  : 		dev = OpenPartitionVolume (devName,

  001d7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CreateFileA@28
  001dd	83 c9 ff	 or	 ecx, -1
  001e0	89 8d 7c 0d ff
	ff		 mov	 DWORD PTR _dev$GSCopy$1$[ebp], ecx
  001e6	33 f6		 xor	 esi, esi
$LL97@EncryptPar:
  001e8	8b c6		 mov	 eax, esi
  001ea	46		 inc	 esi
  001eb	3d f4 01 00 00	 cmp	 eax, 500		; 000001f4H
  001f0	7d 50		 jge	 SHORT $LN98@EncryptPar
  001f2	6a 00		 push	 0
  001f4	68 00 00 00 80	 push	 -2147483648		; 80000000H
  001f9	6a 03		 push	 3
  001fb	6a 00		 push	 0
  001fd	6a 00		 push	 0
  001ff	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00204	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  0020a	50		 push	 eax
  0020b	ff d7		 call	 edi
  0020d	8b c8		 mov	 ecx, eax
  0020f	89 8d 7c 0d ff
	ff		 mov	 DWORD PTR _dev$GSCopy$1$[ebp], ecx
  00215	83 fe 01	 cmp	 esi, 1
  00218	7e 0e		 jle	 SHORT $LN102@EncryptPar
  0021a	6a 0a		 push	 10			; 0000000aH
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  00222	8b 8d 7c 0d ff
	ff		 mov	 ecx, DWORD PTR _dev$GSCopy$1$[ebp]
$LN102@EncryptPar:
  00228	83 f9 ff	 cmp	 ecx, -1
  0022b	74 bb		 je	 SHORT $LL97@EncryptPar
$LN258@EncryptPar:
  0022d	8b bd 7c 0d ff
	ff		 mov	 edi, DWORD PTR _dev$GSCopy$1$[ebp]
$LN109@EncryptPar:

; 822  : 			FALSE,	// Do not require exclusive access
; 823  : 			FALSE,	// Do not require shared access
; 824  : 			TRUE,	// Ask the user to confirm shared access (if exclusive fails)
; 825  : 			FALSE,	// Do not append alternative instructions how to encrypt the data (to applicable error messages)
; 826  : 			FALSE);	// Non-silent mode
; 827  : 
; 828  : 		if (dev == INVALID_HANDLE_VALUE)

  00233	83 ff ff	 cmp	 edi, -1
  00236	75 7e		 jne	 SHORT $LN35@EncryptPar

; 829  : 		{
; 830  : 			nStatus = ERR_DONT_REPORT; 

  00238	be 1c 00 00 00	 mov	 esi, 28			; 0000001cH

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  0023d	e9 b1 0a 00 00	 jmp	 $closing_seq$266

; 818  : 			goto closing_seq;
; 819  : 		}
; 820  : 
; 821  : 		dev = OpenPartitionVolume (devName,

$LN98@EncryptPar:
  00242	83 f9 ff	 cmp	 ecx, -1
  00245	75 e6		 jne	 SHORT $LN258@EncryptPar
  00247	6a 00		 push	 0
  00249	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0024e	6a 03		 push	 3
  00250	6a 00		 push	 0
  00252	6a 03		 push	 3
  00254	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00259	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  0025f	50		 push	 eax
  00260	ff d7		 call	 edi
  00262	8b f8		 mov	 edi, eax
  00264	89 bd 7c 0d ff
	ff		 mov	 DWORD PTR _dev$GSCopy$1$[ebp], edi
  0026a	83 ff ff	 cmp	 edi, -1
  0026d	74 24		 je	 SHORT $LN108@EncryptPar
  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@KFDNCGEE@DEVICE_IN_USE_INPLACE_ENC?$AA@
  00274	e8 00 00 00 00	 call	 _AskWarnNoYes
  00279	83 c4 04	 add	 esp, 4
  0027c	83 f8 07	 cmp	 eax, 7
  0027f	75 b2		 jne	 SHORT $LN109@EncryptPar
  00281	57		 push	 edi
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00288	83 cf ff	 or	 edi, -1

; 829  : 		{
; 830  : 			nStatus = ERR_DONT_REPORT; 

  0028b	8d 77 1d	 lea	 esi, DWORD PTR [edi+29]

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  0028e	e9 60 0a 00 00	 jmp	 $closing_seq$266

; 818  : 			goto closing_seq;
; 819  : 		}
; 820  : 
; 821  : 		dev = OpenPartitionVolume (devName,

$LN108@EncryptPar:
  00293	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00299	e8 00 00 00 00	 call	 _handleWin32Error
  0029e	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  002a3	e8 00 00 00 00	 call	 _Error
  002a8	83 c4 08	 add	 esp, 8
  002ab	83 cf ff	 or	 edi, -1

; 829  : 		{
; 830  : 			nStatus = ERR_DONT_REPORT; 

  002ae	8d 77 1d	 lea	 esi, DWORD PTR [edi+29]

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  002b1	e9 3d 0a 00 00	 jmp	 $closing_seq$266
$LN35@EncryptPar:

; 831  : 			goto closing_seq;
; 832  : 		}
; 833  : 	}
; 834  : 
; 835  : 	// This should never be needed, but is still performed for extra safety (without checking the result)
; 836  : 	DeviceIoControl (dev,

  002b6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceIoControl@32
  002bc	8d 85 f4 0c ff
	ff		 lea	 eax, DWORD PTR _dwResult$[ebp]
  002c2	6a 00		 push	 0
  002c4	50		 push	 eax
  002c5	6a 00		 push	 0
  002c7	6a 00		 push	 0
  002c9	6a 00		 push	 0
  002cb	6a 00		 push	 0
  002cd	68 83 00 09 00	 push	 589955			; 00090083H
  002d2	57		 push	 edi
  002d3	ff d6		 call	 esi

; 837  : 		FSCTL_ALLOW_EXTENDED_DASD_IO,
; 838  : 		NULL,
; 839  : 		0,   
; 840  : 		NULL,
; 841  : 		0,
; 842  : 		&dwResult,
; 843  : 		NULL);
; 844  : 
; 845  : 
; 846  : 	if (!DeviceIoControl (dev, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &driveGeometry, sizeof (driveGeometry), &dwResult, NULL))

  002d5	6a 00		 push	 0
  002d7	8d 85 f4 0c ff
	ff		 lea	 eax, DWORD PTR _dwResult$[ebp]
  002dd	50		 push	 eax
  002de	6a 18		 push	 24			; 00000018H
  002e0	8d 85 80 0d ff
	ff		 lea	 eax, DWORD PTR _driveGeometry$[ebp]
  002e6	50		 push	 eax
  002e7	6a 00		 push	 0
  002e9	6a 00		 push	 0
  002eb	68 00 00 07 00	 push	 458752			; 00070000H
  002f0	57		 push	 edi
  002f1	ff d6		 call	 esi
  002f3	85 c0		 test	 eax, eax
  002f5	75 08		 jne	 SHORT $LN37@EncryptPar

; 847  : 	{
; 848  : 		nStatus = ERR_OS_ERROR;

  002f7	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  002fa	e9 f4 09 00 00	 jmp	 $closing_seq$266
$LN37@EncryptPar:

; 849  : 		goto closing_seq;
; 850  : 	}
; 851  : 
; 852  : 	sectorSize = driveGeometry.BytesPerSector;
; 853  : 
; 854  : 
; 855  : 	nStatus = OpenBackupHeader (dev, devicePath, password, &masterCryptoInfo, headerCryptoInfo, deviceSize);

  002ff	ff b5 50 0d ff
	ff		 push	 DWORD PTR _deviceSize$2$[ebp]
  00305	8b 85 94 0d ff
	ff		 mov	 eax, DWORD PTR _driveGeometry$[ebp+20]
  0030b	ff b5 54 0d ff
	ff		 push	 DWORD PTR _deviceSize$1$[ebp]
  00311	89 85 08 0d ff
	ff		 mov	 DWORD PTR _sectorSize$[ebp], eax
  00317	8d 85 78 0d ff
	ff		 lea	 eax, DWORD PTR _masterCryptoInfo$[ebp]
  0031d	ff b5 4c 0d ff
	ff		 push	 DWORD PTR _headerCryptoInfo$1$[ebp]
  00323	50		 push	 eax
  00324	ff b5 40 0d ff
	ff		 push	 DWORD PTR _password$1$[ebp]
  0032a	ff b5 2c 0d ff
	ff		 push	 DWORD PTR _devicePath$1$[ebp]
  00330	57		 push	 edi
  00331	e8 00 00 00 00	 call	 _OpenBackupHeader
  00336	8b f0		 mov	 esi, eax
  00338	83 c4 1c	 add	 esp, 28			; 0000001cH

; 856  : 
; 857  : 	if (nStatus != ERR_SUCCESS)

  0033b	85 f6		 test	 esi, esi
  0033d	0f 85 b0 09 00
	00		 jne	 $closing_seq$266

; 858  : 		goto closing_seq;
; 859  : 
; 860  : 
; 861  : 
; 862  :     remainingBytes = masterCryptoInfo->VolumeSize.Value - masterCryptoInfo->EncryptedAreaLength.Value;

  00343	8b bd 78 0d ff
	ff		 mov	 edi, DWORD PTR _masterCryptoInfo$[ebp]
  00349	0f 57 c0	 xorps	 xmm0, xmm0
  0034c	89 bd 38 0d ff
	ff		 mov	 DWORD PTR _masterCryptoInfo$5$[ebp], edi

; 863  : 
; 864  : 	lastHeaderUpdateDistance = 0;

  00352	66 0f 13 85 58
	0d ff ff	 movlpd	 QWORD PTR _lastHeaderUpdateDistance$[ebp], xmm0
  0035a	8b 97 f0 1e 00
	00		 mov	 edx, DWORD PTR [edi+7920]
  00360	8b 87 00 1f 00
	00		 mov	 eax, DWORD PTR [edi+7936]
  00366	8b b7 f4 1e 00
	00		 mov	 esi, DWORD PTR [edi+7924]
  0036c	8b 8f 04 1f 00
	00		 mov	 ecx, DWORD PTR [edi+7940]
  00372	89 95 6c 0d ff
	ff		 mov	 DWORD PTR _remainingBytes$1$[ebp], edx
  00378	29 85 6c 0d ff
	ff		 sub	 DWORD PTR _remainingBytes$1$[ebp], eax

; 865  : 
; 866  : 
; 867  : 	ExportProgressStats (masterCryptoInfo->EncryptedAreaLength.Value, masterCryptoInfo->VolumeSize.Value);

  0037e	a3 00 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncBytesDone, eax

; 868  : 
; 869  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_ENCRYPTING);
; 870  : 
; 871  : 	bFirstNonSysInPlaceEncResumeDone = TRUE;
; 872  : 
; 873  : 
; 874  : 	/* The in-place encryption core */
; 875  : 
; 876  : 	while (remainingBytes > 0)

  00383	8b 85 6c 0d ff
	ff		 mov	 eax, DWORD PTR _remainingBytes$1$[ebp]
  00389	89 0d 04 00 00
	00		 mov	 DWORD PTR _NonSysInplaceEncBytesDone+4, ecx
  0038f	89 15 00 00 00
	00		 mov	 DWORD PTR _NonSysInplaceEncTotalSize, edx
  00395	89 35 04 00 00
	00		 mov	 DWORD PTR _NonSysInplaceEncTotalSize+4, esi
  0039b	89 b5 68 0d ff
	ff		 mov	 DWORD PTR _remainingBytes$2$[ebp], esi
  003a1	19 8d 68 0d ff
	ff		 sbb	 DWORD PTR _remainingBytes$2$[ebp], ecx
  003a7	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 3
  003b1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bFirstNonSysInPlaceEncResumeDone, 1
  003bb	75 08		 jne	 SHORT $LN228@EncryptPar
  003bd	85 c0		 test	 eax, eax
  003bf	0f 84 d5 06 00
	00		 je	 $LN3@EncryptPar
$LN228@EncryptPar:
  003c5	8b 8d 5c 0d ff
	ff		 mov	 ecx, DWORD PTR _lastHeaderUpdateDistance$[ebp+4]
  003cb	8b 95 38 0d ff
	ff		 mov	 edx, DWORD PTR _masterCryptoInfo$5$[ebp]
  003d1	89 8d 24 0d ff
	ff		 mov	 DWORD PTR _lastHeaderUpdateDistance$2$[ebp], ecx
  003d7	8b 8d 58 0d ff
	ff		 mov	 ecx, DWORD PTR _lastHeaderUpdateDistance$[ebp]
  003dd	89 8d 28 0d ff
	ff		 mov	 DWORD PTR _lastHeaderUpdateDistance$1$[ebp], ecx
  003e3	8a 8d 4a 0d ff
	ff		 mov	 cl, BYTE PTR _wipeRandCharsUpdate$[ebp+2]
  003e9	88 8d 67 0d ff
	ff		 mov	 BYTE PTR _wipeRandCharsUpdate$2$[ebp], cl
  003ef	66 8b 8d 48 0d
	ff ff		 mov	 cx, WORD PTR _wipeRandCharsUpdate$[ebp]
  003f6	66 89 8d 46 0d
	ff ff		 mov	 WORD PTR _wipeRandCharsUpdate$1$[ebp], cx
  003fd	8b 8d 68 0d ff
	ff		 mov	 ecx, DWORD PTR _remainingBytes$2$[ebp]
$LL2@EncryptPar:

; 877  : 	{
; 878  : 		workChunkSize = (uint32) min (remainingBytes, GST_MAX_NONSYS_INPLACE_ENC_WORK_CHUNK_SIZE);

  00403	85 c9		 test	 ecx, ecx
  00405	77 13		 ja	 SHORT $LN92@EncryptPar
  00407	72 07		 jb	 SHORT $LN207@EncryptPar
  00409	3d 00 00 20 00	 cmp	 eax, 2097152		; 00200000H
  0040e	73 0a		 jae	 SHORT $LN92@EncryptPar
$LN207@EncryptPar:
  00410	8b f8		 mov	 edi, eax
  00412	89 85 30 0d ff
	ff		 mov	 DWORD PTR _workChunkSize$1$[ebp], eax
  00418	eb 0b		 jmp	 SHORT $LN93@EncryptPar
$LN92@EncryptPar:
  0041a	bf 00 00 20 00	 mov	 edi, 2097152		; 00200000H
  0041f	89 bd 30 0d ff
	ff		 mov	 DWORD PTR _workChunkSize$1$[ebp], edi
$LN93@EncryptPar:

; 879  : 
; 880  : 		if (workChunkSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  00425	f7 c7 ff 01 00
	00		 test	 edi, 511		; 000001ffH
  0042b	0f 85 b7 08 00
	00		 jne	 $LN144@EncryptPar

; 883  : 			goto closing_seq;
; 884  : 		}
; 885  : 
; 886  : 		unitNo.Value = (remainingBytes - workChunkSize + GST_VOLUME_DATA_OFFSET) / ENCRYPTION_DATA_UNIT_SIZE;

  00431	2b c7		 sub	 eax, edi
  00433	8b f1		 mov	 esi, ecx
  00435	8b c8		 mov	 ecx, eax
  00437	89 85 1c 0d ff
	ff		 mov	 DWORD PTR tv1062[ebp], eax
  0043d	83 de 00	 sbb	 esi, 0
  00440	81 c1 00 00 02
	00		 add	 ecx, 131072		; 00020000H
  00446	8b c6		 mov	 eax, esi
  00448	89 b5 38 0d ff
	ff		 mov	 DWORD PTR tv1063[ebp], esi
  0044e	8b b5 7c 0d ff
	ff		 mov	 esi, DWORD PTR _dev$GSCopy$1$[ebp]
  00454	83 d0 00	 adc	 eax, 0
  00457	0f ac c1 09	 shrd	 ecx, eax, 9
  0045b	c1 e8 09	 shr	 eax, 9
  0045e	89 8d 00 0d ff
	ff		 mov	 DWORD PTR _unitNo$[ebp], ecx
  00464	89 85 04 0d ff
	ff		 mov	 DWORD PTR _unitNo$[ebp+4], eax
  0046a	66 0f 1f 44 00
	00		 npad	 6
$inplace_enc_read$267:

; 887  : 
; 888  : 
; 889  : 		// Read the plaintext into RAM
; 890  : 
; 891  : inplace_enc_read:
; 892  : 
; 893  : 		offset.QuadPart = masterCryptoInfo->EncryptedAreaStart.Value - workChunkSize - GST_VOLUME_DATA_OFFSET;

  00470	8b 8a f8 1e 00
	00		 mov	 ecx, DWORD PTR [edx+7928]
  00476	8b 82 fc 1e 00
	00		 mov	 eax, DWORD PTR [edx+7932]
  0047c	2b cf		 sub	 ecx, edi

; 894  : 
; 895  : 		if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0)

  0047e	6a 00		 push	 0
  00480	83 d8 00	 sbb	 eax, 0
  00483	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H
  00489	6a 00		 push	 0
  0048b	83 d8 00	 sbb	 eax, 0
  0048e	50		 push	 eax
  0048f	51		 push	 ecx
  00490	56		 push	 esi
  00491	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00497	85 c0		 test	 eax, eax
  00499	0f 84 39 05 00
	00		 je	 $LN142@EncryptPar

; 896  : 		{
; 897  : 			nStatus = ERR_OS_ERROR;
; 898  : 			goto closing_seq;
; 899  : 		}
; 900  : 
; 901  : 		if (ReadFile (dev, buf, workChunkSize, &n, NULL) == 0)

  0049f	6a 00		 push	 0
  004a1	8d 85 34 0d ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  004a7	50		 push	 eax
  004a8	57		 push	 edi
  004a9	ff b5 70 0d ff
	ff		 push	 DWORD PTR _buf$1$[ebp]
  004af	56		 push	 esi
  004b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  004b6	85 c0		 test	 eax, eax
  004b8	0f 85 a5 00 00
	00		 jne	 $LN45@EncryptPar

; 902  : 		{
; 903  : 			// Read error
; 904  : 
; 905  : 			DWORD dwTmpErr = GetLastError ();

  004be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  004c4	8b f0		 mov	 esi, eax

; 906  : 
; 907  : 			if (IsDiskReadError (dwTmpErr) && !bVolTransformThreadCancel)

  004c6	56		 push	 esi
  004c7	e8 00 00 00 00	 call	 _IsDiskReadError
  004cc	83 c4 04	 add	 esp, 4
  004cf	85 c0		 test	 eax, eax
  004d1	0f 84 f9 04 00
	00		 je	 $LN48@EncryptPar
  004d7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bVolTransformThreadCancel, 0
  004de	0f 85 ec 04 00
	00		 jne	 $LN48@EncryptPar

; 908  : 			{
; 909  : 				// Physical defect or data corruption
; 910  : 
; 911  : 				if (!*bTryToCorrectReadErrors)

  004e4	8b 43 14	 mov	 eax, DWORD PTR _bTryToCorrectReadErrors$[ebx]
  004e7	83 38 00	 cmp	 DWORD PTR [eax], 0
  004ea	75 23		 jne	 SHORT $LN262@EncryptPar

; 912  : 				{
; 913  : 					*bTryToCorrectReadErrors = (AskWarnYesNo ("ENABLE_BAD_SECTOR_ZEROING") == IDYES);

  004ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@
  004f1	e8 00 00 00 00	 call	 _AskWarnYesNo
  004f6	33 c9		 xor	 ecx, ecx
  004f8	83 c4 04	 add	 esp, 4
  004fb	83 f8 06	 cmp	 eax, 6
  004fe	8b 43 14	 mov	 eax, DWORD PTR _bTryToCorrectReadErrors$[ebx]
  00501	0f 94 c1	 sete	 cl
  00504	89 08		 mov	 DWORD PTR [eax], ecx

; 914  : 				}
; 915  : 
; 916  : 				if (*bTryToCorrectReadErrors)

  00506	83 38 00	 cmp	 DWORD PTR [eax], 0
  00509	0f 84 c1 04 00
	00		 je	 $LN48@EncryptPar
$LN262@EncryptPar:

; 917  : 				{
; 918  : 					// Try to correct the read errors physically
; 919  : 
; 920  : 					offset.QuadPart = masterCryptoInfo->EncryptedAreaStart.Value - workChunkSize - GST_VOLUME_DATA_OFFSET;

  0050f	8b 85 78 0d ff
	ff		 mov	 eax, DWORD PTR _masterCryptoInfo$[ebp]

; 921  : 
; 922  : 					nStatus = ZeroUnreadableSectors (dev, offset, workChunkSize, sectorSize, &zeroedSectorCount);

  00515	8d 95 f8 0c ff
	ff		 lea	 edx, DWORD PTR _zeroedSectorCount$[ebp]
  0051b	8b b5 7c 0d ff
	ff		 mov	 esi, DWORD PTR _dev$GSCopy$1$[ebp]
  00521	52		 push	 edx
  00522	ff b5 08 0d ff
	ff		 push	 DWORD PTR _sectorSize$[ebp]
  00528	8b 88 f8 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7928]
  0052e	8b 80 fc 1e 00
	00		 mov	 eax, DWORD PTR [eax+7932]
  00534	2b cf		 sub	 ecx, edi
  00536	6a 00		 push	 0
  00538	83 d8 00	 sbb	 eax, 0
  0053b	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H
  00541	57		 push	 edi
  00542	83 d8 00	 sbb	 eax, 0
  00545	50		 push	 eax
  00546	51		 push	 ecx
  00547	56		 push	 esi
  00548	e8 00 00 00 00	 call	 _ZeroUnreadableSectors
  0054d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 923  : 
; 924  : 					if (nStatus != ERR_SUCCESS)

  00550	85 c0		 test	 eax, eax
  00552	0f 85 80 04 00
	00		 jne	 $LN142@EncryptPar

; 925  : 					{
; 926  : 						// Due to write errors, we can't correct the read errors
; 927  : 						nStatus = ERR_OS_ERROR;
; 928  : 						goto closing_seq;
; 929  : 					}
; 930  : 
; 931  : 					goto inplace_enc_read;

  00558	8b 95 78 0d ff
	ff		 mov	 edx, DWORD PTR _masterCryptoInfo$[ebp]
  0055e	e9 0d ff ff ff	 jmp	 $inplace_enc_read$267
$LN45@EncryptPar:

; 938  : 			goto closing_seq;
; 939  : 		}
; 940  : 
; 941  : 		if (remainingBytes - workChunkSize < GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE)

  00563	83 bd 38 0d ff
	ff 00		 cmp	 DWORD PTR tv1063[ebp], 0
  0056a	0f 87 cd 00 00
	00		 ja	 $LN213@EncryptPar
  00570	72 10		 jb	 SHORT $LN208@EncryptPar
  00572	81 bd 1c 0d ff
	ff 00 20 00 00	 cmp	 DWORD PTR tv1062[ebp], 8192 ; 00002000H
  0057c	0f 83 bb 00 00
	00		 jae	 $LN213@EncryptPar
$LN208@EncryptPar:

; 942  : 		{
; 943  : 			// We reached the inital portion of the filesystem, which we had concealed (in order to prevent
; 944  : 			// Windows from interfering with the volume). Now we need to undo that modification. 
; 945  : 
; 946  : 			for (i = 0; i < GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE - (remainingBytes - workChunkSize); i++)

  00582	8b f7		 mov	 esi, edi
  00584	b8 00 00 00 00	 mov	 eax, 0
  00589	2b b5 6c 0d ff
	ff		 sub	 esi, DWORD PTR _remainingBytes$1$[ebp]
  0058f	1b 85 68 0d ff
	ff		 sbb	 eax, DWORD PTR _remainingBytes$2$[ebp]
  00595	81 c6 00 20 00
	00		 add	 esi, 8192		; 00002000H
  0059b	89 b5 6c 0d ff
	ff		 mov	 DWORD PTR $T2[ebp], esi
  005a1	83 d0 00	 adc	 eax, 0
  005a4	33 c9		 xor	 ecx, ecx
  005a6	89 85 68 0d ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  005ac	85 c0		 test	 eax, eax
  005ae	72 5b		 jb	 SHORT $LN211@EncryptPar
  005b0	77 0d		 ja	 SHORT $LN210@EncryptPar
  005b2	85 f6		 test	 esi, esi
  005b4	74 55		 je	 SHORT $LN211@EncryptPar
  005b6	85 c0		 test	 eax, eax
  005b8	75 05		 jne	 SHORT $LN210@EncryptPar
  005ba	83 fe 20	 cmp	 esi, 32			; 00000020H
  005bd	72 4c		 jb	 SHORT $LN211@EncryptPar
$LN210@EncryptPar:
  005bf	0f 10 0d 00 00
	00 00		 movups	 xmm1, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  005c6	8b bd 70 0d ff
	ff		 mov	 edi, DWORD PTR _buf$1$[ebp]
  005cc	33 c9		 xor	 ecx, ecx
  005ce	83 e6 e0	 and	 esi, -32		; ffffffe0H
$LL6@EncryptPar:

; 947  : 				buf[i] ^= GST_NTFS_CONCEAL_CONSTANT;

  005d1	0f 10 04 0f	 movups	 xmm0, XMMWORD PTR [edi+ecx]
  005d5	66 0f df c1	 pandn	 xmm0, xmm1
  005d9	0f 11 04 0f	 movups	 XMMWORD PTR [edi+ecx], xmm0
  005dd	0f 10 44 0f 10	 movups	 xmm0, XMMWORD PTR [edi+ecx+16]
  005e2	66 0f df c1	 pandn	 xmm0, xmm1
  005e6	0f 11 44 0f 10	 movups	 XMMWORD PTR [edi+ecx+16], xmm0
  005eb	83 c1 20	 add	 ecx, 32			; 00000020H

; 970  : 					{
; 971  : 						wipeBuffer[i] = buf[i] + wipePass;

  005ee	8b c1		 mov	 eax, ecx
  005f0	99		 cdq
  005f1	3b 95 68 0d ff
	ff		 cmp	 edx, DWORD PTR $T1[ebp]
  005f7	72 d8		 jb	 SHORT $LL6@EncryptPar

; 942  : 		{
; 943  : 			// We reached the inital portion of the filesystem, which we had concealed (in order to prevent
; 944  : 			// Windows from interfering with the volume). Now we need to undo that modification. 
; 945  : 
; 946  : 			for (i = 0; i < GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE - (remainingBytes - workChunkSize); i++)

  005f9	77 04		 ja	 SHORT $LN248@EncryptPar
  005fb	3b c6		 cmp	 eax, esi
  005fd	72 d2		 jb	 SHORT $LL6@EncryptPar
$LN248@EncryptPar:
  005ff	8b bd 30 0d ff
	ff		 mov	 edi, DWORD PTR _workChunkSize$1$[ebp]
  00605	8b b5 6c 0d ff
	ff		 mov	 esi, DWORD PTR $T2[ebp]
$LN211@EncryptPar:

; 970  : 					{
; 971  : 						wipeBuffer[i] = buf[i] + wipePass;

  0060b	8b c1		 mov	 eax, ecx
  0060d	99		 cdq
  0060e	3b 95 68 0d ff
	ff		 cmp	 edx, DWORD PTR $T1[ebp]
  00614	77 27		 ja	 SHORT $LN213@EncryptPar

; 942  : 		{
; 943  : 			// We reached the inital portion of the filesystem, which we had concealed (in order to prevent
; 944  : 			// Windows from interfering with the volume). Now we need to undo that modification. 
; 945  : 
; 946  : 			for (i = 0; i < GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE - (remainingBytes - workChunkSize); i++)

  00616	72 04		 jb	 SHORT $LN241@EncryptPar
  00618	3b c6		 cmp	 eax, esi
  0061a	73 21		 jae	 SHORT $LN213@EncryptPar
$LN241@EncryptPar:
  0061c	8b bd 70 0d ff
	ff		 mov	 edi, DWORD PTR _buf$1$[ebp]
$LL231@EncryptPar:

; 947  : 				buf[i] ^= GST_NTFS_CONCEAL_CONSTANT;

  00622	f6 14 39	 not	 BYTE PTR [ecx+edi]
  00625	41		 inc	 ecx

; 970  : 					{
; 971  : 						wipeBuffer[i] = buf[i] + wipePass;

  00626	8b c1		 mov	 eax, ecx
  00628	99		 cdq
  00629	3b 95 68 0d ff
	ff		 cmp	 edx, DWORD PTR $T1[ebp]
  0062f	72 f1		 jb	 SHORT $LL231@EncryptPar

; 942  : 		{
; 943  : 			// We reached the inital portion of the filesystem, which we had concealed (in order to prevent
; 944  : 			// Windows from interfering with the volume). Now we need to undo that modification. 
; 945  : 
; 946  : 			for (i = 0; i < GST_INITIAL_NTFS_CONCEAL_PORTION_SIZE - (remainingBytes - workChunkSize); i++)

  00631	77 04		 ja	 SHORT $LN249@EncryptPar
  00633	3b c6		 cmp	 eax, esi
  00635	72 eb		 jb	 SHORT $LL231@EncryptPar
$LN249@EncryptPar:
  00637	8b bd 30 0d ff
	ff		 mov	 edi, DWORD PTR _workChunkSize$1$[ebp]
$LN213@EncryptPar:

; 948  : 		}
; 949  : 
; 950  : 
; 951  : 		// Encrypt the plaintext in RAM
; 952  : 
; 953  : 		EncryptDataUnits ((byte *) buf, &unitNo, workChunkSize / ENCRYPTION_DATA_UNIT_SIZE, masterCryptoInfo);

  0063d	ff b5 78 0d ff
	ff		 push	 DWORD PTR _masterCryptoInfo$[ebp]
  00643	8b c7		 mov	 eax, edi
  00645	c1 e8 09	 shr	 eax, 9
  00648	50		 push	 eax
  00649	89 85 5c 0d ff
	ff		 mov	 DWORD PTR tv1087[ebp], eax
  0064f	8d 85 00 0d ff
	ff		 lea	 eax, DWORD PTR _unitNo$[ebp]
  00655	50		 push	 eax
  00656	ff b5 70 0d ff
	ff		 push	 DWORD PTR _buf$1$[ebp]
  0065c	e8 00 00 00 00	 call	 _EncryptDataUnits

; 954  : 
; 955  : 
; 956  : 		// If enabled, wipe the area to which we will write the ciphertext
; 957  : 
; 958  : 		if (wipeAlgorithm != GST_WIPE_NONE)

  00661	8b 53 10	 mov	 edx, DWORD PTR _wipeAlgorithm$[ebx]
  00664	83 c4 10	 add	 esp, 16			; 00000010H
  00667	85 d2		 test	 edx, edx
  00669	0f 84 e8 01 00
	00		 je	 $LN53@EncryptPar

; 959  : 		{
; 960  : 			byte wipePass;
; 961  : 
; 962  : 			offset.QuadPart = masterCryptoInfo->EncryptedAreaStart.Value - workChunkSize;

  0066f	8b 85 78 0d ff
	ff		 mov	 eax, DWORD PTR _masterCryptoInfo$[ebp]

; 963  : 
; 964  : 			for (wipePass = 1; wipePass <= GetWipePassCount (wipeAlgorithm); ++wipePass)

  00675	52		 push	 edx
  00676	c6 85 77 0d ff
	ff 01		 mov	 BYTE PTR _wipePass$1$[ebp], 1
  0067d	8b 88 f8 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7928]
  00683	8b 80 fc 1e 00
	00		 mov	 eax, DWORD PTR [eax+7932]
  00689	2b cf		 sub	 ecx, edi
  0068b	89 8d 6c 0d ff
	ff		 mov	 DWORD PTR _offset$3$[ebp], ecx
  00691	83 d8 00	 sbb	 eax, 0
  00694	89 85 68 0d ff
	ff		 mov	 DWORD PTR _offset$7$[ebp], eax
  0069a	e8 00 00 00 00	 call	 _GetWipePassCount
  0069f	83 c4 04	 add	 esp, 4
  006a2	83 f8 01	 cmp	 eax, 1
  006a5	0f 8c 92 01 00
	00		 jl	 $LN8@EncryptPar
  006ab	be 01 00 00 00	 mov	 esi, 1
$LL9@EncryptPar:
  006b0	0f be 85 77 0d
	ff ff		 movsx	 eax, BYTE PTR _wipePass$1$[ebp]

; 965  : 			{
; 966  : 				if (!WipeBuffer (wipeAlgorithm, wipeRandChars, wipePass, wipeBuffer, workChunkSize))

  006b7	57		 push	 edi
  006b8	ff b5 60 0d ff
	ff		 push	 DWORD PTR _wipeBuffer$1$[ebp]
  006be	66 0f 6e c0	 movd	 xmm0, eax
  006c2	8d 85 48 0d ff
	ff		 lea	 eax, DWORD PTR _wipeRandChars$[ebp]
  006c8	66 0f 60 c0	 punpcklbw xmm0, xmm0
  006cc	56		 push	 esi
  006cd	66 0f 61 c0	 punpcklwd xmm0, xmm0
  006d1	50		 push	 eax
  006d2	ff 73 10	 push	 DWORD PTR _wipeAlgorithm$[ebx]
  006d5	66 0f 70 c0 00	 pshufd	 xmm0, xmm0, 0
  006da	0f 29 85 e0 0c
	ff ff		 movaps	 XMMWORD PTR tv1095[ebp], xmm0
  006e1	e8 00 00 00 00	 call	 _WipeBuffer
  006e6	83 c4 14	 add	 esp, 20			; 00000014H
  006e9	85 c0		 test	 eax, eax
  006eb	0f 85 e4 00 00
	00		 jne	 $LN54@EncryptPar

; 967  : 				{
; 968  : 					ULONG i;
; 969  : 					for (i = 0; i < workChunkSize; ++i)

  006f1	33 c9		 xor	 ecx, ecx
  006f3	85 ff		 test	 edi, edi
  006f5	0f 84 a5 00 00
	00		 je	 $LN11@EncryptPar

; 970  : 					{
; 971  : 						wipeBuffer[i] = buf[i] + wipePass;

  006fb	8b b5 60 0d ff
	ff		 mov	 esi, DWORD PTR _wipeBuffer$1$[ebp]
  00701	83 ff 20	 cmp	 edi, 32			; 00000020H
  00704	0f 82 69 00 00
	00		 jb	 $LN162@EncryptPar
  0070a	8b 85 70 0d ff
	ff		 mov	 eax, DWORD PTR _buf$1$[ebp]
  00710	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  00713	48		 dec	 eax
  00714	03 d7		 add	 edx, edi
  00716	03 c7		 add	 eax, edi
  00718	3b f0		 cmp	 esi, eax
  0071a	77 08		 ja	 SHORT $LN163@EncryptPar
  0071c	3b 95 70 0d ff
	ff		 cmp	 edx, DWORD PTR _buf$1$[ebp]
  00722	73 4f		 jae	 SHORT $LN162@EncryptPar
$LN163@EncryptPar:
  00724	0f 28 8d e0 0c
	ff ff		 movaps	 xmm1, XMMWORD PTR tv1095[ebp]
  0072b	8b d7		 mov	 edx, edi
  0072d	8b bd 70 0d ff
	ff		 mov	 edi, DWORD PTR _buf$1$[ebp]
  00733	8b c6		 mov	 eax, esi

; 967  : 				{
; 968  : 					ULONG i;
; 969  : 					for (i = 0; i < workChunkSize; ++i)

  00735	8b b5 70 0d ff
	ff		 mov	 esi, DWORD PTR _buf$1$[ebp]
  0073b	83 e2 e0	 and	 edx, -32		; ffffffe0H
  0073e	2b b5 60 0d ff
	ff		 sub	 esi, DWORD PTR _wipeBuffer$1$[ebp]
$LL12@EncryptPar:
  00744	0f 10 04 06	 movups	 xmm0, XMMWORD PTR [esi+eax]
  00748	8d 40 20	 lea	 eax, DWORD PTR [eax+32]

; 970  : 					{
; 971  : 						wipeBuffer[i] = buf[i] + wipePass;

  0074b	66 0f fc c1	 paddb	 xmm0, xmm1
  0074f	0f 11 40 e0	 movups	 XMMWORD PTR [eax-32], xmm0
  00753	0f 10 44 0f 10	 movups	 xmm0, XMMWORD PTR [edi+ecx+16]
  00758	83 c1 20	 add	 ecx, 32			; 00000020H
  0075b	66 0f fc c1	 paddb	 xmm0, xmm1
  0075f	0f 11 40 f0	 movups	 XMMWORD PTR [eax-16], xmm0
  00763	3b ca		 cmp	 ecx, edx
  00765	72 dd		 jb	 SHORT $LL12@EncryptPar
  00767	8b bd 30 0d ff
	ff		 mov	 edi, DWORD PTR _workChunkSize$1$[ebp]
  0076d	8b b5 60 0d ff
	ff		 mov	 esi, DWORD PTR _wipeBuffer$1$[ebp]
$LN162@EncryptPar:

; 967  : 				{
; 968  : 					ULONG i;
; 969  : 					for (i = 0; i < workChunkSize; ++i)

  00773	3b cf		 cmp	 ecx, edi
  00775	73 29		 jae	 SHORT $LN11@EncryptPar
  00777	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  0077a	8b d7		 mov	 edx, edi
  0077c	8b b5 70 0d ff
	ff		 mov	 esi, DWORD PTR _buf$1$[ebp]
  00782	2b b5 60 0d ff
	ff		 sub	 esi, DWORD PTR _wipeBuffer$1$[ebp]
  00788	2b d1		 sub	 edx, ecx
  0078a	8a ad 77 0d ff
	ff		 mov	 ch, BYTE PTR _wipePass$1$[ebp]
$LL161@EncryptPar:

; 970  : 					{
; 971  : 						wipeBuffer[i] = buf[i] + wipePass;

  00790	8a 0c 30	 mov	 cl, BYTE PTR [eax+esi]
  00793	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00796	02 cd		 add	 cl, ch
  00798	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  0079b	83 ea 01	 sub	 edx, 1
  0079e	75 f0		 jne	 SHORT $LL161@EncryptPar
$LN11@EncryptPar:

; 972  : 					}
; 973  : 
; 974  : 					EncryptDataUnits (wipeBuffer, &unitNo, workChunkSize / ENCRYPTION_DATA_UNIT_SIZE, masterCryptoInfo);

  007a0	ff b5 78 0d ff
	ff		 push	 DWORD PTR _masterCryptoInfo$[ebp]
  007a6	8b b5 60 0d ff
	ff		 mov	 esi, DWORD PTR _wipeBuffer$1$[ebp]
  007ac	8d 85 00 0d ff
	ff		 lea	 eax, DWORD PTR _unitNo$[ebp]
  007b2	ff b5 5c 0d ff
	ff		 push	 DWORD PTR tv1087[ebp]
  007b8	50		 push	 eax
  007b9	56		 push	 esi
  007ba	e8 00 00 00 00	 call	 _EncryptDataUnits

; 975  : 					memcpy (wipeRandCharsUpdate, wipeBuffer, sizeof (wipeRandCharsUpdate)); 

  007bf	66 8b 06	 mov	 ax, WORD PTR [esi]
  007c2	83 c4 10	 add	 esp, 16			; 00000010H
  007c5	66 89 85 46 0d
	ff ff		 mov	 WORD PTR _wipeRandCharsUpdate$1$[ebp], ax
  007cc	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  007cf	88 85 67 0d ff
	ff		 mov	 BYTE PTR _wipeRandCharsUpdate$2$[ebp], al
$LN54@EncryptPar:

; 976  : 				}
; 977  : 
; 978  : 				if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 979  : 					|| WriteFile (dev, wipeBuffer, workChunkSize, &n, NULL) == 0)

  007d5	8b b5 7c 0d ff
	ff		 mov	 esi, DWORD PTR _dev$GSCopy$1$[ebp]
  007db	6a 00		 push	 0
  007dd	6a 00		 push	 0
  007df	ff b5 68 0d ff
	ff		 push	 DWORD PTR _offset$7$[ebp]
  007e5	ff b5 6c 0d ff
	ff		 push	 DWORD PTR _offset$3$[ebp]
  007eb	56		 push	 esi
  007ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  007f2	85 c0		 test	 eax, eax
  007f4	0f 84 e8 01 00
	00		 je	 $LN143@EncryptPar
  007fa	6a 00		 push	 0
  007fc	8d 85 34 0d ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  00802	50		 push	 eax
  00803	57		 push	 edi
  00804	ff b5 60 0d ff
	ff		 push	 DWORD PTR _wipeBuffer$1$[ebp]
  0080a	56		 push	 esi
  0080b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00811	85 c0		 test	 eax, eax
  00813	0f 84 c9 01 00
	00		 je	 $LN143@EncryptPar

; 963  : 
; 964  : 			for (wipePass = 1; wipePass <= GetWipePassCount (wipeAlgorithm); ++wipePass)

  00819	8a 85 77 0d ff
	ff		 mov	 al, BYTE PTR _wipePass$1$[ebp]
  0081f	ff 73 10	 push	 DWORD PTR _wipeAlgorithm$[ebx]
  00822	fe c0		 inc	 al
  00824	88 85 77 0d ff
	ff		 mov	 BYTE PTR _wipePass$1$[ebp], al
  0082a	0f b6 f0	 movzx	 esi, al
  0082d	e8 00 00 00 00	 call	 _GetWipePassCount
  00832	83 c4 04	 add	 esp, 4
  00835	3b f0		 cmp	 esi, eax
  00837	0f 8e 73 fe ff
	ff		 jle	 $LL9@EncryptPar
$LN8@EncryptPar:

; 993  : 					goto closing_seq;
; 994  : 				}
; 995  : 			}
; 996  : 
; 997  : 			memcpy (wipeRandChars, wipeRandCharsUpdate, sizeof (wipeRandCharsUpdate)); 

  0083d	66 8b 85 46 0d
	ff ff		 mov	 ax, WORD PTR _wipeRandCharsUpdate$1$[ebp]
  00844	66 89 85 48 0d
	ff ff		 mov	 WORD PTR _wipeRandChars$[ebp], ax
  0084b	8a 85 67 0d ff
	ff		 mov	 al, BYTE PTR _wipeRandCharsUpdate$2$[ebp]
  00851	88 85 4a 0d ff
	ff		 mov	 BYTE PTR _wipeRandChars$[ebp+2], al
$LN53@EncryptPar:

; 998  : 		}
; 999  : 
; 1000 : 
; 1001 : 		// Write the ciphertext
; 1002 : 
; 1003 : 		offset.QuadPart = masterCryptoInfo->EncryptedAreaStart.Value - workChunkSize;

  00857	8b 85 78 0d ff
	ff		 mov	 eax, DWORD PTR _masterCryptoInfo$[ebp]

; 1004 : 
; 1005 : 		if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0)

  0085d	6a 00		 push	 0
  0085f	6a 00		 push	 0
  00861	8b b0 f8 1e 00
	00		 mov	 esi, DWORD PTR [eax+7928]
  00867	8b 80 fc 1e 00
	00		 mov	 eax, DWORD PTR [eax+7932]
  0086d	2b f7		 sub	 esi, edi
  0086f	83 d8 00	 sbb	 eax, 0
  00872	50		 push	 eax
  00873	56		 push	 esi
  00874	ff b5 7c 0d ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  0087a	89 85 5c 0d ff
	ff		 mov	 DWORD PTR _offset$8$[ebp], eax
  00880	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00886	85 c0		 test	 eax, eax
  00888	0f 84 4a 01 00
	00		 je	 $LN142@EncryptPar

; 1006 : 		{
; 1007 : 			nStatus = ERR_OS_ERROR;
; 1008 : 			goto closing_seq;
; 1009 : 		}
; 1010 : 
; 1011 : 		if (WriteFile (dev, buf, workChunkSize, &n, NULL) == 0)

  0088e	6a 00		 push	 0
  00890	8d 85 34 0d ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  00896	50		 push	 eax
  00897	57		 push	 edi
  00898	ff b5 70 0d ff
	ff		 push	 DWORD PTR _buf$1$[ebp]
  0089e	ff b5 7c 0d ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  008a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  008aa	85 c0		 test	 eax, eax
  008ac	0f 84 8d 03 00
	00		 je	 $LN146@EncryptPar

; 1025 : 			goto closing_seq;
; 1026 : 		}
; 1027 : 
; 1028 : 
; 1029 : 		masterCryptoInfo->EncryptedAreaStart.Value -= workChunkSize;

  008b2	8b 85 78 0d ff
	ff		 mov	 eax, DWORD PTR _masterCryptoInfo$[ebp]

; 1030 : 		masterCryptoInfo->EncryptedAreaLength.Value += workChunkSize;
; 1031 : 
; 1032 : 		remainingBytes -= workChunkSize;
; 1033 : 		lastHeaderUpdateDistance += workChunkSize;
; 1034 : 
; 1035 : 		bEncryptedAreaSizeChanged = TRUE;

  008b8	c7 85 0c 0d ff
	ff 01 00 00 00	 mov	 DWORD PTR _bEncryptedAreaSizeChanged$1$[ebp], 1
  008c2	29 b8 f8 1e 00
	00		 sub	 DWORD PTR [eax+7928], edi
  008c8	83 98 fc 1e 00
	00 00		 sbb	 DWORD PTR [eax+7932], 0
  008cf	8b 85 78 0d ff
	ff		 mov	 eax, DWORD PTR _masterCryptoInfo$[ebp]
  008d5	01 b8 00 1f 00
	00		 add	 DWORD PTR [eax+7936], edi
  008db	83 90 04 1f 00
	00 00		 adc	 DWORD PTR [eax+7940], 0
  008e2	8b 85 1c 0d ff
	ff		 mov	 eax, DWORD PTR tv1062[ebp]
  008e8	89 85 6c 0d ff
	ff		 mov	 DWORD PTR _remainingBytes$1$[ebp], eax
  008ee	8b 85 38 0d ff
	ff		 mov	 eax, DWORD PTR tv1063[ebp]
  008f4	89 85 68 0d ff
	ff		 mov	 DWORD PTR _remainingBytes$2$[ebp], eax
  008fa	8b 85 28 0d ff
	ff		 mov	 eax, DWORD PTR _lastHeaderUpdateDistance$1$[ebp]
  00900	03 c7		 add	 eax, edi
  00902	89 85 28 0d ff
	ff		 mov	 DWORD PTR _lastHeaderUpdateDistance$1$[ebp], eax
  00908	83 95 24 0d ff
	ff 00		 adc	 DWORD PTR _lastHeaderUpdateDistance$2$[ebp], 0

; 1036 : 
; 1037 : 		if (lastHeaderUpdateDistance >= GST_NONSYS_INPLACE_ENC_HEADER_UPDATE_INTERVAL)

  0090f	75 07		 jne	 SHORT $LN214@EncryptPar
  00911	3d 00 00 00 04	 cmp	 eax, 67108864		; 04000000H
  00916	72 54		 jb	 SHORT $LN64@EncryptPar
$LN214@EncryptPar:

; 1038 : 		{
; 1039 : 			nStatus = FastVolumeHeaderUpdate (dev, headerCryptoInfo, masterCryptoInfo, deviceSize);

  00918	ff b5 50 0d ff
	ff		 push	 DWORD PTR _deviceSize$2$[ebp]
  0091e	8b bd 7c 0d ff
	ff		 mov	 edi, DWORD PTR _dev$GSCopy$1$[ebp]
  00924	ff b5 54 0d ff
	ff		 push	 DWORD PTR _deviceSize$1$[ebp]
  0092a	ff b5 78 0d ff
	ff		 push	 DWORD PTR _masterCryptoInfo$[ebp]
  00930	ff b5 4c 0d ff
	ff		 push	 DWORD PTR _headerCryptoInfo$1$[ebp]
  00936	57		 push	 edi
  00937	e8 00 00 00 00	 call	 _FastVolumeHeaderUpdate
  0093c	8b f0		 mov	 esi, eax
  0093e	83 c4 14	 add	 esp, 20			; 00000014H

; 1040 : 
; 1041 : 			if (nStatus != ERR_SUCCESS)

  00941	85 f6		 test	 esi, esi
  00943	0f 85 aa 03 00
	00		 jne	 $closing_seq$266

; 1042 : 				goto closing_seq;
; 1043 : 
; 1044 : 			lastHeaderUpdateDistance = 0;

  00949	0f 57 c0	 xorps	 xmm0, xmm0
  0094c	66 0f 13 85 58
	0d ff ff	 movlpd	 QWORD PTR _lastHeaderUpdateDistance$[ebp], xmm0
  00954	8b 8d 5c 0d ff
	ff		 mov	 ecx, DWORD PTR _lastHeaderUpdateDistance$[ebp+4]
  0095a	89 8d 24 0d ff
	ff		 mov	 DWORD PTR _lastHeaderUpdateDistance$2$[ebp], ecx
  00960	8b 8d 58 0d ff
	ff		 mov	 ecx, DWORD PTR _lastHeaderUpdateDistance$[ebp]
  00966	89 8d 28 0d ff
	ff		 mov	 DWORD PTR _lastHeaderUpdateDistance$1$[ebp], ecx
$LN64@EncryptPar:

; 1045 : 		}
; 1046 : 
; 1047 : 		ExportProgressStats (masterCryptoInfo->EncryptedAreaLength.Value, masterCryptoInfo->VolumeSize.Value);
; 1048 : 
; 1049 : 		if (bVolTransformThreadCancel)

  0096c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bVolTransformThreadCancel, 0
  00973	8b 8d 78 0d ff
	ff		 mov	 ecx, DWORD PTR _masterCryptoInfo$[ebp]
  00979	8b 81 00 1f 00
	00		 mov	 eax, DWORD PTR [ecx+7936]
  0097f	8b 91 f0 1e 00
	00		 mov	 edx, DWORD PTR [ecx+7920]
  00985	8b b1 f4 1e 00
	00		 mov	 esi, DWORD PTR [ecx+7924]
  0098b	a3 00 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncBytesDone, eax
  00990	8b 81 04 1f 00
	00		 mov	 eax, DWORD PTR [ecx+7940]
  00996	a3 04 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncBytesDone+4, eax
  0099b	89 15 00 00 00
	00		 mov	 DWORD PTR _NonSysInplaceEncTotalSize, edx
  009a1	89 35 04 00 00
	00		 mov	 DWORD PTR _NonSysInplaceEncTotalSize+4, esi
  009a7	0f 85 dd 00 00
	00		 jne	 $LN148@EncryptPar

; 868  : 
; 869  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_ENCRYPTING);
; 870  : 
; 871  : 	bFirstNonSysInPlaceEncResumeDone = TRUE;
; 872  : 
; 873  : 
; 874  : 	/* The in-place encryption core */
; 875  : 
; 876  : 	while (remainingBytes > 0)

  009ad	8b 8d 68 0d ff
	ff		 mov	 ecx, DWORD PTR _remainingBytes$2$[ebp]
  009b3	8b 85 6c 0d ff
	ff		 mov	 eax, DWORD PTR _remainingBytes$1$[ebp]
  009b9	85 c9		 test	 ecx, ecx
  009bb	75 08		 jne	 SHORT $LN215@EncryptPar
  009bd	85 c0		 test	 eax, eax
  009bf	0f 84 cf 00 00
	00		 je	 $LN204@EncryptPar
$LN215@EncryptPar:
  009c5	8b 95 78 0d ff
	ff		 mov	 edx, DWORD PTR _masterCryptoInfo$[ebp]
  009cb	e9 33 fa ff ff	 jmp	 $LL2@EncryptPar
$LN48@EncryptPar:

; 932  : 				}
; 933  : 			}
; 934  : 
; 935  : 			SetLastError (dwTmpErr);		// Preserve the original error code

  009d0	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__SetLastError@4
  009d5	56		 push	 esi
  009d6	ff d0		 call	 eax
$LN142@EncryptPar:

; 936  : 
; 937  : 			nStatus = ERR_OS_ERROR;

  009d8	be 01 00 00 00	 mov	 esi, 1

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  009dd	e9 0b 03 00 00	 jmp	 $LN254@EncryptPar
$LN143@EncryptPar:

; 980  : 				{
; 981  : 					// Write error
; 982  : 					dwError = GetLastError();

  009e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  009e8	8b f0		 mov	 esi, eax

; 983  : 
; 984  : 					// Undo failed write operation
; 985  : 					if (workChunkSize > GST_VOLUME_DATA_OFFSET && SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  009ea	81 ff 00 00 02
	00		 cmp	 edi, 131072		; 00020000H
  009f0	0f 86 7c 00 00
	00		 jbe	 $LN257@EncryptPar
  009f6	6a 00		 push	 0
  009f8	6a 00		 push	 0
  009fa	ff b5 68 0d ff
	ff		 push	 DWORD PTR _offset$7$[ebp]
  00a00	ff b5 6c 0d ff
	ff		 push	 DWORD PTR _offset$3$[ebp]
  00a06	ff b5 7c 0d ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  00a0c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00a12	85 c0		 test	 eax, eax
  00a14	74 5c		 je	 SHORT $LN257@EncryptPar

; 986  : 					{
; 987  : 						DecryptDataUnits ((byte *) buf, &unitNo, workChunkSize / ENCRYPTION_DATA_UNIT_SIZE, masterCryptoInfo);

  00a16	ff b5 78 0d ff
	ff		 push	 DWORD PTR _masterCryptoInfo$[ebp]
  00a1c	8b c7		 mov	 eax, edi
  00a1e	c1 e8 09	 shr	 eax, 9
  00a21	50		 push	 eax
  00a22	8d 85 00 0d ff
	ff		 lea	 eax, DWORD PTR _unitNo$[ebp]
  00a28	50		 push	 eax
  00a29	ff b5 70 0d ff
	ff		 push	 DWORD PTR _buf$1$[ebp]
  00a2f	e8 00 00 00 00	 call	 _DecryptDataUnits
  00a34	83 c4 10	 add	 esp, 16			; 00000010H

; 988  : 						WriteFile (dev, buf + GST_VOLUME_DATA_OFFSET, workChunkSize - GST_VOLUME_DATA_OFFSET, &n, NULL);

  00a37	8d 85 34 0d ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  00a3d	6a 00		 push	 0
  00a3f	50		 push	 eax
  00a40	8d 87 00 00 fe
	ff		 lea	 eax, DWORD PTR [edi-131072]
  00a46	8b bd 7c 0d ff
	ff		 mov	 edi, DWORD PTR _dev$GSCopy$1$[ebp]
  00a4c	50		 push	 eax
  00a4d	8b 85 70 0d ff
	ff		 mov	 eax, DWORD PTR _buf$1$[ebp]
  00a53	05 00 00 02 00	 add	 eax, 131072		; 00020000H
  00a58	50		 push	 eax
  00a59	57		 push	 edi
  00a5a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 989  : 					}
; 990  : 
; 991  : 					SetLastError (dwError);

  00a60	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__SetLastError@4
  00a65	56		 push	 esi
  00a66	ff d0		 call	 eax

; 992  : 					nStatus = ERR_OS_ERROR;

  00a68	be 01 00 00 00	 mov	 esi, 1

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  00a6d	e9 81 02 00 00	 jmp	 $closing_seq$266
$LN257@EncryptPar:

; 989  : 					}
; 990  : 
; 991  : 					SetLastError (dwError);

  00a72	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__SetLastError@4
  00a77	8b bd 7c 0d ff
	ff		 mov	 edi, DWORD PTR _dev$GSCopy$1$[ebp]
  00a7d	56		 push	 esi
  00a7e	ff d0		 call	 eax

; 992  : 					nStatus = ERR_OS_ERROR;

  00a80	be 01 00 00 00	 mov	 esi, 1

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  00a85	e9 69 02 00 00	 jmp	 $closing_seq$266
$LN148@EncryptPar:

; 1050 : 		{
; 1051 : 			bPause = TRUE;

  00a8a	c7 85 14 0d ff
	ff 01 00 00 00	 mov	 DWORD PTR _bPause$1$[ebp], 1
$LN204@EncryptPar:
  00a94	8b bd 78 0d ff
	ff		 mov	 edi, DWORD PTR _masterCryptoInfo$[ebp]
$LN3@EncryptPar:

; 1052 : 			break;
; 1053 : 		}
; 1054 : 	}
; 1055 : 
; 1056 : 	nStatus = FastVolumeHeaderUpdate (dev, headerCryptoInfo, masterCryptoInfo, deviceSize);

  00a9a	ff b5 50 0d ff
	ff		 push	 DWORD PTR _deviceSize$2$[ebp]
  00aa0	ff b5 54 0d ff
	ff		 push	 DWORD PTR _deviceSize$1$[ebp]
  00aa6	57		 push	 edi
  00aa7	ff b5 4c 0d ff
	ff		 push	 DWORD PTR _headerCryptoInfo$1$[ebp]
  00aad	8b bd 7c 0d ff
	ff		 mov	 edi, DWORD PTR _dev$GSCopy$1$[ebp]
  00ab3	57		 push	 edi
  00ab4	e8 00 00 00 00	 call	 _FastVolumeHeaderUpdate
  00ab9	8b f0		 mov	 esi, eax
  00abb	83 c4 14	 add	 esp, 20			; 00000014H

; 1057 : 
; 1058 : 
; 1059 : 	if (nStatus != ERR_SUCCESS)

  00abe	85 f6		 test	 esi, esi
  00ac0	0f 85 2d 02 00
	00		 jne	 $closing_seq$266
  00ac6	39 85 14 0d ff
	ff		 cmp	 DWORD PTR _bPause$1$[ebp], eax

; 1060 : 		goto closing_seq;
; 1061 : 
; 1062 : 
; 1063 : 	if (!bPause)

  00acc	0f 85 59 01 00
	00		 jne	 $LN70@EncryptPar

; 1064 : 	{
; 1065 : 		/* The data area has been fully encrypted; create and write the primary volume header */
; 1066 : 
; 1067 : 		SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_FINALIZING);
; 1068 : 
; 1069 : 		for (int wipePass = 0; wipePass < (wipeAlgorithm == GST_WIPE_NONE ? 1 : PRAND_DISK_WIPE_PASSES); wipePass++)

  00ad2	8b 4b 10	 mov	 ecx, DWORD PTR _wipeAlgorithm$[ebx]
  00ad5	33 ff		 xor	 edi, edi
  00ad7	85 c9		 test	 ecx, ecx
  00ad9	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 4
  00ae3	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00ae8	ba 01 00 00 00	 mov	 edx, 1
  00aed	0f 44 c2	 cmove	 eax, edx
  00af0	89 85 5c 0d ff
	ff		 mov	 DWORD PTR tv1084[ebp], eax
$LL15@EncryptPar:

; 1070 : 		{
; 1071 : 			nStatus = CreateVolumeHeaderInMemory (FALSE,

  00af6	33 c0		 xor	 eax, eax
  00af8	85 c9		 test	 ecx, ecx
  00afa	74 09		 je	 SHORT $LN95@EncryptPar
  00afc	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  00b02	0f 9c c0	 setl	 al
$LN95@EncryptPar:
  00b05	8b 8d 78 0d ff
	ff		 mov	 ecx, DWORD PTR _masterCryptoInfo$[ebp]
  00b0b	50		 push	 eax
  00b0c	ff b1 e8 1e 00
	00		 push	 DWORD PTR [ecx+7912]
  00b12	8b 81 08 1f 00
	00		 mov	 eax, DWORD PTR [ecx+7944]
  00b18	83 c8 02	 or	 eax, 2
  00b1b	50		 push	 eax
  00b1c	0f b7 81 e0 1e
	00 00		 movzx	 eax, WORD PTR [ecx+7904]
  00b23	50		 push	 eax
  00b24	ff b1 04 1f 00
	00		 push	 DWORD PTR [ecx+7940]
  00b2a	8d 85 20 0d ff
	ff		 lea	 eax, DWORD PTR _tmpCryptoInfo$[ebp]
  00b30	ff b1 00 1f 00
	00		 push	 DWORD PTR [ecx+7936]
  00b36	ff b1 fc 1e 00
	00		 push	 DWORD PTR [ecx+7932]
  00b3c	ff b1 f8 1e 00
	00		 push	 DWORD PTR [ecx+7928]
  00b42	6a 00		 push	 0
  00b44	6a 00		 push	 0
  00b46	ff b1 f4 1e 00
	00		 push	 DWORD PTR [ecx+7924]
  00b4c	ff b1 f0 1e 00
	00		 push	 DWORD PTR [ecx+7920]
  00b52	50		 push	 eax
  00b53	8d 81 50 1c 00
	00		 lea	 eax, DWORD PTR [ecx+7248]
  00b59	50		 push	 eax
  00b5a	ff b1 94 1e 00
	00		 push	 DWORD PTR [ecx+7828]
  00b60	8b 85 4c 0d ff
	ff		 mov	 eax, DWORD PTR _headerCryptoInfo$1$[ebp]
  00b66	ff b5 40 0d ff
	ff		 push	 DWORD PTR _password$1$[ebp]
  00b6c	ff 70 04	 push	 DWORD PTR [eax+4]
  00b6f	ff 30		 push	 DWORD PTR [eax]
  00b71	ff b5 3c 0d ff
	ff		 push	 DWORD PTR _header$1$[ebp]
  00b77	6a 00		 push	 0
  00b79	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  00b7e	8b f0		 mov	 esi, eax
  00b80	83 c4 50	 add	 esp, 80			; 00000050H

; 1072 : 				header,
; 1073 : 				headerCryptoInfo->ea,
; 1074 : 				headerCryptoInfo->mode,
; 1075 : 				password,
; 1076 : 				masterCryptoInfo->pkcs5,
; 1077 : 				(char *) masterCryptoInfo->master_keydata,
; 1078 : 				&tmpCryptoInfo,
; 1079 : 				masterCryptoInfo->VolumeSize.Value,
; 1080 : 				0,
; 1081 : 				masterCryptoInfo->EncryptedAreaStart.Value,
; 1082 : 				masterCryptoInfo->EncryptedAreaLength.Value,
; 1083 : 				masterCryptoInfo->RequiredProgramVersion,
; 1084 : 				masterCryptoInfo->HeaderFlags | GST_HEADER_FLAG_NONSYS_INPLACE_ENC,
; 1085 : 				masterCryptoInfo->SectorSize,
; 1086 : 				wipeAlgorithm == GST_WIPE_NONE ? FALSE : (wipePass < PRAND_DISK_WIPE_PASSES - 1));
; 1087 : 
; 1088 : 			if (nStatus != ERR_SUCCESS)

  00b83	85 f6		 test	 esi, esi
  00b85	0f 85 62 01 00
	00		 jne	 $LN254@EncryptPar

; 1089 : 				goto closing_seq;
; 1090 : 
; 1091 : 
; 1092 : 			offset.QuadPart = GST_VOLUME_HEADER_OFFSET;
; 1093 : 
; 1094 : 			if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 1095 : 				|| !WriteEffectiveVolumeHeader (TRUE, dev, (byte *) header))

  00b8b	8b b5 7c 0d ff
	ff		 mov	 esi, DWORD PTR _dev$GSCopy$1$[ebp]
  00b91	0f 57 c0	 xorps	 xmm0, xmm0
  00b94	50		 push	 eax
  00b95	50		 push	 eax
  00b96	66 0f 13 85 10
	0d ff ff	 movlpd	 QWORD PTR _offset$[ebp], xmm0
  00b9e	ff b5 14 0d ff
	ff		 push	 DWORD PTR _offset$[ebp+4]
  00ba4	ff b5 10 0d ff
	ff		 push	 DWORD PTR _offset$[ebp]
  00baa	56		 push	 esi
  00bab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00bb1	85 c0		 test	 eax, eax
  00bb3	0f 84 1f fe ff
	ff		 je	 $LN142@EncryptPar
  00bb9	ff b5 3c 0d ff
	ff		 push	 DWORD PTR _header$1$[ebp]
  00bbf	56		 push	 esi
  00bc0	6a 01		 push	 1
  00bc2	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  00bc7	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bca	85 c0		 test	 eax, eax
  00bcc	0f 84 06 fe ff
	ff		 je	 $LN142@EncryptPar

; 1096 : 			{
; 1097 : 				nStatus = ERR_OS_ERROR;
; 1098 : 				goto closing_seq;
; 1099 : 			}
; 1100 : 
; 1101 : 			// Fill the reserved sectors of the header area with random data
; 1102 : 			nStatus = WriteRandomDataToReservedHeaderAreas (dev, headerCryptoInfo, masterCryptoInfo->VolumeSize.Value, TRUE, FALSE);

  00bd2	8b 85 78 0d ff
	ff		 mov	 eax, DWORD PTR _masterCryptoInfo$[ebp]
  00bd8	6a 00		 push	 0
  00bda	6a 01		 push	 1
  00bdc	ff b0 f4 1e 00
	00		 push	 DWORD PTR [eax+7924]
  00be2	ff b0 f0 1e 00
	00		 push	 DWORD PTR [eax+7920]
  00be8	ff b5 4c 0d ff
	ff		 push	 DWORD PTR _headerCryptoInfo$1$[ebp]
  00bee	56		 push	 esi
  00bef	e8 00 00 00 00	 call	 _WriteRandomDataToReservedHeaderAreas
  00bf4	8b f0		 mov	 esi, eax
  00bf6	83 c4 18	 add	 esp, 24			; 00000018H

; 1103 : 
; 1104 : 			if (nStatus != ERR_SUCCESS)

  00bf9	85 f6		 test	 esi, esi
  00bfb	0f 85 ec 00 00
	00		 jne	 $LN254@EncryptPar

; 1064 : 	{
; 1065 : 		/* The data area has been fully encrypted; create and write the primary volume header */
; 1066 : 
; 1067 : 		SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_FINALIZING);
; 1068 : 
; 1069 : 		for (int wipePass = 0; wipePass < (wipeAlgorithm == GST_WIPE_NONE ? 1 : PRAND_DISK_WIPE_PASSES); wipePass++)

  00c01	8b 4b 10	 mov	 ecx, DWORD PTR _wipeAlgorithm$[ebx]
  00c04	47		 inc	 edi
  00c05	3b bd 5c 0d ff
	ff		 cmp	 edi, DWORD PTR tv1084[ebp]
  00c0b	0f 8c e5 fe ff
	ff		 jl	 $LL15@EncryptPar

; 1105 : 				goto closing_seq;
; 1106 : 		}
; 1107 : 
; 1108 : 		// Update the configuration files
; 1109 : 
; 1110 : 		SaveNonSysInPlaceEncSettings (-1, wipeAlgorithm);

  00c11	51		 push	 ecx
  00c12	6a ff		 push	 -1
  00c14	e8 00 00 00 00	 call	 _SaveNonSysInPlaceEncSettings
  00c19	83 c4 08	 add	 esp, 8

; 1111 : 
; 1112 : 
; 1113 : 
; 1114 : 		SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_FINISHED);

  00c1c	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 6

; 1115 : 
; 1116 : 		nStatus = ERR_SUCCESS;
; 1117 : 	}
; 1118 : 	else

  00c26	e9 c2 00 00 00	 jmp	 $LN254@EncryptPar
$LN70@EncryptPar:

; 1119 : 	{
; 1120 : 		// The process has been paused by the user or aborted by the wizard (e.g. on app exit)
; 1121 : 
; 1122 : 		nStatus = ERR_USER_ABORT;

  00c2b	be 21 00 00 00	 mov	 esi, 33			; 00000021H

; 1123 : 
; 1124 : 		SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PAUSED);

  00c30	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 5
  00c3a	e9 b4 00 00 00	 jmp	 $closing_seq$266
$LN146@EncryptPar:

; 1012 : 		{
; 1013 : 			// Write error
; 1014 : 			dwError = GetLastError();

  00c3f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00c45	89 85 40 0d ff
	ff		 mov	 DWORD PTR _dwError$2$[ebp], eax

; 1015 : 
; 1016 : 			// Undo failed write operation
; 1017 : 			if (workChunkSize > GST_VOLUME_DATA_OFFSET && SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  00c4b	81 ff 00 00 02
	00		 cmp	 edi, 131072		; 00020000H
  00c51	0f 86 7c 00 00
	00		 jbe	 $LN255@EncryptPar
  00c57	6a 00		 push	 0
  00c59	6a 00		 push	 0
  00c5b	ff b5 5c 0d ff
	ff		 push	 DWORD PTR _offset$8$[ebp]
  00c61	56		 push	 esi
  00c62	ff b5 7c 0d ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  00c68	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00c6e	85 c0		 test	 eax, eax
  00c70	74 5b		 je	 SHORT $LN250@EncryptPar

; 1018 : 			{
; 1019 : 				DecryptDataUnits ((byte *) buf, &unitNo, workChunkSize / ENCRYPTION_DATA_UNIT_SIZE, masterCryptoInfo);

  00c72	ff b5 78 0d ff
	ff		 push	 DWORD PTR _masterCryptoInfo$[ebp]
  00c78	8b b5 70 0d ff
	ff		 mov	 esi, DWORD PTR _buf$1$[ebp]
  00c7e	8b c7		 mov	 eax, edi
  00c80	c1 e8 09	 shr	 eax, 9
  00c83	50		 push	 eax
  00c84	8d 85 00 0d ff
	ff		 lea	 eax, DWORD PTR _unitNo$[ebp]
  00c8a	50		 push	 eax
  00c8b	56		 push	 esi
  00c8c	e8 00 00 00 00	 call	 _DecryptDataUnits
  00c91	83 c4 10	 add	 esp, 16			; 00000010H

; 1020 : 				WriteFile (dev, buf + GST_VOLUME_DATA_OFFSET, workChunkSize - GST_VOLUME_DATA_OFFSET, &n, NULL);

  00c94	8d 85 34 0d ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  00c9a	6a 00		 push	 0
  00c9c	50		 push	 eax
  00c9d	8d 87 00 00 fe
	ff		 lea	 eax, DWORD PTR [edi-131072]
  00ca3	8b bd 7c 0d ff
	ff		 mov	 edi, DWORD PTR _dev$GSCopy$1$[ebp]
  00ca9	50		 push	 eax
  00caa	8d 86 00 00 02
	00		 lea	 eax, DWORD PTR [esi+131072]
  00cb0	50		 push	 eax
  00cb1	57		 push	 edi
  00cb2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00cb8	8b 85 40 0d ff
	ff		 mov	 eax, DWORD PTR _dwError$2$[ebp]

; 1021 : 			}
; 1022 : 
; 1023 : 			SetLastError (dwError);

  00cbe	50		 push	 eax
  00cbf	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__SetLastError@4
  00cc4	ff d0		 call	 eax

; 1024 : 			nStatus = ERR_OS_ERROR;

  00cc6	be 01 00 00 00	 mov	 esi, 1

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  00ccb	eb 26		 jmp	 SHORT $closing_seq$266
$LN250@EncryptPar:
  00ccd	8b 85 40 0d ff
	ff		 mov	 eax, DWORD PTR _dwError$2$[ebp]
$LN255@EncryptPar:
  00cd3	8b bd 7c 0d ff
	ff		 mov	 edi, DWORD PTR _dev$GSCopy$1$[ebp]

; 1021 : 			}
; 1022 : 
; 1023 : 			SetLastError (dwError);

  00cd9	50		 push	 eax
  00cda	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__SetLastError@4
  00cdf	ff d0		 call	 eax

; 1024 : 			nStatus = ERR_OS_ERROR;

  00ce1	be 01 00 00 00	 mov	 esi, 1

; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : closing_seq:

  00ce6	eb 0b		 jmp	 SHORT $closing_seq$266
$LN144@EncryptPar:

; 881  : 		{
; 882  : 			nStatus = ERR_PARAMETER_INCORRECT;

  00ce8	be 1e 00 00 00	 mov	 esi, 30			; 0000001eH
$LN254@EncryptPar:
  00ced	8b bd 7c 0d ff
	ff		 mov	 edi, DWORD PTR _dev$GSCopy$1$[ebp]
$closing_seq$266:

; 1129 : 
; 1130 : 	dwError = GetLastError();

  00cf3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1131 : 
; 1132 : 	if (bEncryptedAreaSizeChanged
; 1133 : 		&& dev != INVALID_HANDLE_VALUE
; 1134 : 		&& masterCryptoInfo != NULL
; 1135 : 		&& headerCryptoInfo != NULL
; 1136 : 		&& deviceSize > 0)

  00cf9	83 bd 0c 0d ff
	ff 00		 cmp	 DWORD PTR _bEncryptedAreaSizeChanged$1$[ebp], 0
  00d00	89 85 5c 0d ff
	ff		 mov	 DWORD PTR _dwError$3$[ebp], eax
  00d06	74 40		 je	 SHORT $LN240@EncryptPar
  00d08	83 ff ff	 cmp	 edi, -1
  00d0b	74 3b		 je	 SHORT $LN240@EncryptPar
  00d0d	8b 8d 78 0d ff
	ff		 mov	 ecx, DWORD PTR _masterCryptoInfo$[ebp]
  00d13	85 c9		 test	 ecx, ecx
  00d15	74 4e		 je	 SHORT $LN80@EncryptPar
  00d17	8b 85 4c 0d ff
	ff		 mov	 eax, DWORD PTR _headerCryptoInfo$1$[ebp]
  00d1d	85 c0		 test	 eax, eax
  00d1f	74 2d		 je	 SHORT $LN79@EncryptPar
  00d21	83 bd 50 0d ff
	ff 00		 cmp	 DWORD PTR _deviceSize$2$[ebp], 0
  00d28	7c 24		 jl	 SHORT $LN79@EncryptPar
  00d2a	8b 95 54 0d ff
	ff		 mov	 edx, DWORD PTR _deviceSize$1$[ebp]
  00d30	7f 04		 jg	 SHORT $LN216@EncryptPar
  00d32	85 d2		 test	 edx, edx
  00d34	74 18		 je	 SHORT $LN79@EncryptPar
$LN216@EncryptPar:

; 1137 : 	{
; 1138 : 		// Execution of the core loop may have been interrupted due to an error or user action without updating the header
; 1139 : 		FastVolumeHeaderUpdate (dev, headerCryptoInfo, masterCryptoInfo, deviceSize);

  00d36	ff b5 50 0d ff
	ff		 push	 DWORD PTR _deviceSize$2$[ebp]
  00d3c	52		 push	 edx
  00d3d	51		 push	 ecx
  00d3e	50		 push	 eax
  00d3f	57		 push	 edi
  00d40	e8 00 00 00 00	 call	 _FastVolumeHeaderUpdate
  00d45	83 c4 14	 add	 esp, 20			; 00000014H
$LN240@EncryptPar:
  00d48	8b 8d 78 0d ff
	ff		 mov	 ecx, DWORD PTR _masterCryptoInfo$[ebp]
$LN79@EncryptPar:

; 1140 : 	}
; 1141 : 
; 1142 : 	if (masterCryptoInfo != NULL)

  00d4e	85 c9		 test	 ecx, ecx
  00d50	74 13		 je	 SHORT $LN80@EncryptPar

; 1143 : 	{
; 1144 : 		crypto_close (masterCryptoInfo);

  00d52	51		 push	 ecx
  00d53	e8 00 00 00 00	 call	 _crypto_close
  00d58	83 c4 04	 add	 esp, 4

; 1145 : 		masterCryptoInfo = NULL;

  00d5b	c7 85 78 0d ff
	ff 00 00 00 00	 mov	 DWORD PTR _masterCryptoInfo$[ebp], 0
$LN80@EncryptPar:

; 1146 : 	}
; 1147 : 
; 1148 : 	if (headerCryptoInfo != NULL)

  00d65	8b 85 4c 0d ff
	ff		 mov	 eax, DWORD PTR _headerCryptoInfo$1$[ebp]
  00d6b	85 c0		 test	 eax, eax
  00d6d	74 09		 je	 SHORT $LN81@EncryptPar

; 1149 : 	{
; 1150 : 		crypto_close (headerCryptoInfo);

  00d6f	50		 push	 eax
  00d70	e8 00 00 00 00	 call	 _crypto_close
  00d75	83 c4 04	 add	 esp, 4
$LN81@EncryptPar:

; 1151 : 		headerCryptoInfo = NULL;
; 1152 : 	}
; 1153 : 
; 1154 : 	if (tmpCryptoInfo != NULL)

  00d78	8b 85 20 0d ff
	ff		 mov	 eax, DWORD PTR _tmpCryptoInfo$[ebp]
  00d7e	85 c0		 test	 eax, eax
  00d80	74 13		 je	 SHORT $LN82@EncryptPar

; 1155 : 	{
; 1156 : 		crypto_close (tmpCryptoInfo);

  00d82	50		 push	 eax
  00d83	e8 00 00 00 00	 call	 _crypto_close
  00d88	83 c4 04	 add	 esp, 4

; 1157 : 		tmpCryptoInfo = NULL;

  00d8b	c7 85 20 0d ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpCryptoInfo$[ebp], 0
$LN82@EncryptPar:

; 1158 : 	}
; 1159 : 
; 1160 : 	if (dosDev[0])

  00d95	80 bd f0 fe ff
	ff 00		 cmp	 BYTE PTR _dosDev$[ebp], 0
  00d9c	74 15		 je	 SHORT $LN83@EncryptPar

; 1161 : 		RemoveFakeDosName (devicePath, dosDev);

  00d9e	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  00da4	50		 push	 eax
  00da5	ff b5 2c 0d ff
	ff		 push	 DWORD PTR _devicePath$1$[ebp]
  00dab	e8 00 00 00 00	 call	 _RemoveFakeDosName
  00db0	83 c4 08	 add	 esp, 8
$LN83@EncryptPar:

; 1162 : 
; 1163 : 	if (dev != INVALID_HANDLE_VALUE)

  00db3	83 ff ff	 cmp	 edi, -1
  00db6	74 07		 je	 SHORT $LN84@EncryptPar

; 1164 : 	{
; 1165 : 		CloseHandle (dev);

  00db8	57		 push	 edi
  00db9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN84@EncryptPar:

; 1166 : 		dev = INVALID_HANDLE_VALUE;
; 1167 : 	}
; 1168 : 
; 1169 : 	if (buf != NULL)

  00dbf	8b 85 70 0d ff
	ff		 mov	 eax, DWORD PTR _buf$1$[ebp]
  00dc5	85 c0		 test	 eax, eax
  00dc7	74 09		 je	 SHORT $LN85@EncryptPar

; 1170 : 		GSTfree (buf);

  00dc9	50		 push	 eax
  00dca	e8 00 00 00 00	 call	 _free
  00dcf	83 c4 04	 add	 esp, 4
$LN85@EncryptPar:

; 1171 : 
; 1172 : 	if (header != NULL)

  00dd2	8b 95 3c 0d ff
	ff		 mov	 edx, DWORD PTR _header$1$[ebp]
  00dd8	85 d2		 test	 edx, edx
  00dda	74 3a		 je	 SHORT $LN86@EncryptPar

; 1173 : 	{
; 1174 : 		burn (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00ddc	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00de1	8b c2		 mov	 eax, edx
  00de3	8b f9		 mov	 edi, ecx
$LL128@EncryptPar:
  00de5	c6 02 00	 mov	 BYTE PTR [edx], 0
  00de8	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00deb	83 ef 01	 sub	 edi, 1
  00dee	75 f5		 jne	 SHORT $LL128@EncryptPar
$LL19@EncryptPar:
  00df0	c6 00 00	 mov	 BYTE PTR [eax], 0
  00df3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00df6	83 e9 01	 sub	 ecx, 1
  00df9	75 f5		 jne	 SHORT $LL19@EncryptPar

; 1175 : 		VirtualUnlock (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00dfb	8b bd 3c 0d ff
	ff		 mov	 edi, DWORD PTR _header$1$[ebp]
  00e01	68 00 02 00 00	 push	 512			; 00000200H
  00e06	57		 push	 edi
  00e07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 1176 : 		GSTfree (header);

  00e0d	57		 push	 edi
  00e0e	e8 00 00 00 00	 call	 _free
  00e13	83 c4 04	 add	 esp, 4
$LN86@EncryptPar:

; 1177 : 	}
; 1178 : 
; 1179 : 	if (wipeBuffer != NULL)

  00e16	8b 85 60 0d ff
	ff		 mov	 eax, DWORD PTR _wipeBuffer$1$[ebp]
  00e1c	85 c0		 test	 eax, eax
  00e1e	74 09		 je	 SHORT $LN87@EncryptPar

; 1180 : 		GSTfree (wipeBuffer);

  00e20	50		 push	 eax
  00e21	e8 00 00 00 00	 call	 _free
  00e26	83 c4 04	 add	 esp, 4
$LN87@EncryptPar:

; 1181 : 
; 1182 : 	if (zeroedSectorCount > 0)

  00e29	83 bd fc 0c ff
	ff 00		 cmp	 DWORD PTR _zeroedSectorCount$[ebp+4], 0
  00e30	8b bd f8 0c ff
	ff		 mov	 edi, DWORD PTR _zeroedSectorCount$[ebp]
  00e36	77 08		 ja	 SHORT $LN217@EncryptPar
  00e38	85 ff		 test	 edi, edi
  00e3a	0f 84 87 00 00
	00		 je	 $LN88@EncryptPar
$LN217@EncryptPar:
  00e40	68 60 ea 00 00	 push	 60000			; 0000ea60H
  00e45	8d 85 98 0d ff
	ff		 lea	 eax, DWORD PTR _msg$3[ebp]
  00e4b	6a 00		 push	 0
  00e4d	50		 push	 eax
  00e4e	e8 00 00 00 00	 call	 _memset
  00e53	68 e8 03 00 00	 push	 1000			; 000003e8H
  00e58	8d 85 00 fa ff
	ff		 lea	 eax, DWORD PTR _sizeStr$4[ebp]
  00e5e	6a 00		 push	 0
  00e60	50		 push	 eax
  00e61	e8 00 00 00 00	 call	 _memset
  00e66	83 c4 18	 add	 esp, 24			; 00000018H

; 1183 : 	{
; 1184 : 		wchar_t msg[30000] = {0};
; 1185 : 		wchar_t sizeStr[500] = {0};
; 1186 : 
; 1187 : 		GetSizeString (zeroedSectorCount * sectorSize, sizeStr);

  00e69	8d 85 00 fa ff
	ff		 lea	 eax, DWORD PTR _sizeStr$4[ebp]
  00e6f	50		 push	 eax
  00e70	ff b5 fc 0c ff
	ff		 push	 DWORD PTR _zeroedSectorCount$[ebp+4]
  00e76	8b 85 08 0d ff
	ff		 mov	 eax, DWORD PTR _sectorSize$[ebp]
  00e7c	99		 cdq
  00e7d	57		 push	 edi
  00e7e	52		 push	 edx
  00e7f	50		 push	 eax
  00e80	e8 00 00 00 00	 call	 __allmul
  00e85	52		 push	 edx
  00e86	50		 push	 eax
  00e87	e8 00 00 00 00	 call	 _GetSizeString
  00e8c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1188 : 
; 1189 : 		wsprintfW (msg, 

  00e8f	8d 85 00 fa ff
	ff		 lea	 eax, DWORD PTR _sizeStr$4[ebp]
  00e95	50		 push	 eax
  00e96	ff b5 fc 0c ff
	ff		 push	 DWORD PTR _zeroedSectorCount$[ebp+4]
  00e9c	57		 push	 edi
  00e9d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KOHPIJFG@ZEROED_BAD_SECTOR_COUNT?$AA@
  00ea2	e8 00 00 00 00	 call	 _GetString
  00ea7	83 c4 04	 add	 esp, 4
  00eaa	50		 push	 eax
  00eab	8d 85 98 0d ff
	ff		 lea	 eax, DWORD PTR _msg$3[ebp]
  00eb1	50		 push	 eax
  00eb2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW

; 1190 : 			GetString ("ZEROED_BAD_SECTOR_COUNT"),
; 1191 : 			zeroedSectorCount,
; 1192 : 			sizeStr);
; 1193 : 
; 1194 : 		WarningDirect (msg);

  00eb8	8d 85 98 0d ff
	ff		 lea	 eax, DWORD PTR _msg$3[ebp]
  00ebe	50		 push	 eax
  00ebf	e8 00 00 00 00	 call	 _WarningDirect
  00ec4	83 c4 18	 add	 esp, 24			; 00000018H
$LN88@EncryptPar:

; 1195 : 	}
; 1196 : 
; 1197 : 	if (nStatus != ERR_SUCCESS && nStatus != ERR_USER_ABORT)

  00ec7	85 f6		 test	 esi, esi
  00ec9	74 11		 je	 SHORT $LN238@EncryptPar
  00ecb	83 fe 21	 cmp	 esi, 33			; 00000021H
  00ece	74 0c		 je	 SHORT $LN238@EncryptPar

; 1198 : 		SetLastError (dwError);

  00ed0	ff b5 5c 0d ff
	ff		 push	 DWORD PTR _dwError$3$[ebp]
  00ed6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN238@EncryptPar:

; 1199 : 
; 1200 : 	return nStatus;
; 1201 : }

  00edc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00edf	8b c6		 mov	 eax, esi
  00ee1	5f		 pop	 edi
  00ee2	33 cd		 xor	 ecx, ebp
  00ee4	5e		 pop	 esi
  00ee5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00eea	8b e5		 mov	 esp, ebp
  00eec	5d		 pop	 ebp
  00eed	8b e3		 mov	 esp, ebx
  00eef	5b		 pop	 ebx
  00ef0	c3		 ret	 0
_EncryptPartitionInPlaceResume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _EncryptPartitionInPlaceBegin
_TEXT	SEGMENT
_totalClusterCount$ = -1128				; size = 8
_deviceSize$2$ = -1120					; size = 4
tv499 = -1116						; size = 4
_bytesPerCluster$ = -1112				; size = 4
_offset$2$ = -1108					; size = 4
_deviceSize$1$ = -1104					; size = 4
_dwError$1$ = -1104					; size = 4
_dataAreaSize$1$ = -1100				; size = 4
_dataAreaSize$2$ = -1096				; size = 4
_dwResult$ = -1092					; size = 4
_offset$1$ = -1088					; size = 4
_driveLetter$1$ = -1088					; size = 4
_volParams$GSCopy$1$ = -1084				; size = 4
_header$1$ = -1080					; size = 4
_cryptoInfo2$ = -1076					; size = 4
_cryptoInfo$ = -1072					; size = 4
_shrinkVolInfo$ = -1068					; size = 24
_deviceName$ = -1044					; size = 520
_dosDev$ = -524						; size = 260
_devName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_volParams$ = 8						; size = 4
_outHandle$ = 12					; size = 4
_wipeAlgorithm$ = 16					; size = 4
_EncryptPartitionInPlaceBegin PROC			; COMDAT

; 377  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 04 00
	00		 sub	 esp, 1128		; 00000468H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _volParams$[ebp]
  00017	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  0001d	57		 push	 edi
  0001e	68 04 01 00 00	 push	 260			; 00000104H
  00023	6a 00		 push	 0
  00025	50		 push	 eax
  00026	89 9d c4 fb ff
	ff		 mov	 DWORD PTR _volParams$GSCopy$1$[ebp], ebx

; 378  : 	SHRINK_VOLUME_INFORMATION shrinkVolInfo;
; 379  : 	signed __int64 sizeToShrinkTo;
; 380  : 	int nStatus = ERR_SUCCESS;
; 381  : 	PCRYPTO_INFO cryptoInfo = NULL;
; 382  : 	PCRYPTO_INFO cryptoInfo2 = NULL;
; 383  : 	HANDLE dev = INVALID_HANDLE_VALUE;

  0002c	83 cf ff	 or	 edi, -1
  0002f	c7 85 d0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _cryptoInfo$[ebp], 0
  00039	c7 85 cc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _cryptoInfo2$[ebp], 0
  00043	e8 00 00 00 00	 call	 _memset
  00048	68 04 01 00 00	 push	 260			; 00000104H
  0004d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  00053	6a 00		 push	 0
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _memset

; 384  : 	DWORD dwError;
; 385  : 	char *header;
; 386  : 	char dosDev[GST_MAX_PATH] = {0};
; 387  : 	char devName[MAX_PATH] = {0};
; 388  : 	int driveLetter = -1;
; 389  : 	WCHAR deviceName[MAX_PATH];
; 390  : 	uint64 dataAreaSize;
; 391  : 	__int64 deviceSize;
; 392  : 	LARGE_INTEGER offset;
; 393  : 	DWORD dwResult;
; 394  : 	int dwModeOfOperatioID = FIRST_MODE_OF_OPERATION_ID;
; 395  : 
; 396  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PREPARING);

  0005b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 1

; 397  : 
; 398  : 
; 399  : 	if (!CheckRequirementsForNonSysInPlaceEnc (volParams->volumePath, FALSE))

  00065	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00068	6a 00		 push	 0
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _CheckRequirementsForNonSysInPlaceEnc
  00070	83 c4 20	 add	 esp, 32			; 00000020H
  00073	85 c0		 test	 eax, eax
  00075	75 13		 jne	 SHORT $LN14@EncryptPar

; 400  : 		return ERR_DONT_REPORT;

  00077	8d 47 1d	 lea	 eax, DWORD PTR [edi+29]
  0007a	5f		 pop	 edi
  0007b	5b		 pop	 ebx

; 725  : 
; 726  : 	return nStatus;
; 727  : }

  0007c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007f	33 cd		 xor	 ecx, ebp
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN14@EncryptPar:

; 401  : 
; 402  : 
; 403  : 	header = (char *) GSTalloc (GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  0008a	68 00 02 00 00	 push	 512			; 00000200H
  0008f	e8 00 00 00 00	 call	 _malloc
  00094	83 c4 04	 add	 esp, 4
  00097	89 85 c8 fb ff
	ff		 mov	 DWORD PTR _header$1$[ebp], eax

; 404  : 	if (!header)

  0009d	85 c0		 test	 eax, eax
  0009f	75 15		 jne	 SHORT $LN15@EncryptPar

; 405  : 		return ERR_OUTOFMEMORY;

  000a1	5f		 pop	 edi
  000a2	b8 02 00 00 00	 mov	 eax, 2
  000a7	5b		 pop	 ebx

; 725  : 
; 726  : 	return nStatus;
; 727  : }

  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ab	33 cd		 xor	 ecx, ebp
  000ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
$LN15@EncryptPar:
  000b6	56		 push	 esi

; 406  : 
; 407  : 	VirtualLock (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  000b7	68 00 02 00 00	 push	 512			; 00000200H
  000bc	50		 push	 eax
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 408  : 
; 409  : 	deviceSize = GetDeviceSize (volParams->volumePath);

  000c3	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _GetDeviceSize
  000cc	8b ca		 mov	 ecx, edx
  000ce	89 85 b0 fb ff
	ff		 mov	 DWORD PTR _deviceSize$1$[ebp], eax
  000d4	83 c4 04	 add	 esp, 4
  000d7	89 8d a0 fb ff
	ff		 mov	 DWORD PTR _deviceSize$2$[ebp], ecx

; 410  : 	if (deviceSize < 0)

  000dd	85 c9		 test	 ecx, ecx
  000df	7f 31		 jg	 SHORT $LN18@EncryptPar
  000e1	7c 04		 jl	 SHORT $LN132@EncryptPar
  000e3	85 c0		 test	 eax, eax
  000e5	73 0a		 jae	 SHORT $LN16@EncryptPar
$LN132@EncryptPar:

; 411  : 	{
; 412  : 		// Cannot determine the size of the partition
; 413  : 		nStatus = ERR_PARAMETER_INCORRECT;

  000e7	be 1e 00 00 00	 mov	 esi, 30			; 0000001eH

; 696  : 
; 697  : 
; 698  : closing_seq:

  000ec	e9 18 05 00 00	 jmp	 $closing_seq$141
$LN16@EncryptPar:

; 414  : 		goto closing_seq;
; 415  : 	}
; 416  : 
; 417  : 	if (deviceSize < GST_NONSYS_INPLACE_ENC_MIN_VOL_SIZE)

  000f1	85 c9		 test	 ecx, ecx
  000f3	7f 1d		 jg	 SHORT $LN18@EncryptPar
  000f5	7c 07		 jl	 SHORT $LN133@EncryptPar
  000f7	3d 00 80 72 00	 cmp	 eax, 7503872		; 00728000H
  000fc	73 14		 jae	 SHORT $LN18@EncryptPar
$LN133@EncryptPar:

; 418  : 	{
; 419  : 		ShowInPlaceEncErrMsgWAltSteps ("PARTITION_TOO_SMALL_FOR_NONSYS_INPLACE_ENC", TRUE);

  000fe	6a 01		 push	 1
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@EKBFECDJ@PARTITION_TOO_SMALL_FOR_NONSYS_I@
  00105	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  0010a	83 c4 08	 add	 esp, 8

; 696  : 
; 697  : 
; 698  : closing_seq:

  0010d	e9 f2 04 00 00	 jmp	 $LN139@EncryptPar
$LN18@EncryptPar:

; 420  : 		nStatus = ERR_DONT_REPORT;
; 421  : 		goto closing_seq;
; 422  : 	}
; 423  : 
; 424  : 	dataAreaSize = GetVolumeDataAreaSize (volParams->hiddenVol, deviceSize);

  00112	51		 push	 ecx
  00113	50		 push	 eax
  00114	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize

; 425  : 
; 426  : 	strcpy ((char *)deviceName, volParams->volumePath);

  0011d	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00120	8d b5 ec fb ff
	ff		 lea	 esi, DWORD PTR _deviceName$[ebp]
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH
  00129	89 85 b4 fb ff
	ff		 mov	 DWORD PTR _dataAreaSize$1$[ebp], eax
  0012f	89 95 b8 fb ff
	ff		 mov	 DWORD PTR _dataAreaSize$2$[ebp], edx
  00135	2b f1		 sub	 esi, ecx
$LL64@EncryptPar:
  00137	8a 01		 mov	 al, BYTE PTR [ecx]
  00139	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0013c	88 44 0e ff	 mov	 BYTE PTR [esi+ecx-1], al
  00140	84 c0		 test	 al, al
  00142	75 f3		 jne	 SHORT $LL64@EncryptPar

; 427  : 	ToUNICODE ((char *)deviceName);

  00144	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 _ToUNICODE

; 428  : 
; 429  : 	driveLetter = GetDiskDeviceDriveLetter (deviceName);

  00150	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  0015c	89 85 c0 fb ff
	ff		 mov	 DWORD PTR _driveLetter$1$[ebp], eax

; 430  : 
; 431  : 
; 432  : 	if (FakeDosNameForDevice (volParams->volumePath, dosDev, devName, FALSE) != 0)

  00162	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  00168	6a 00		 push	 0
  0016a	50		 push	 eax
  0016b	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  00171	50		 push	 eax
  00172	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  0017b	83 c4 18	 add	 esp, 24			; 00000018H
  0017e	85 c0		 test	 eax, eax
  00180	74 0a		 je	 SHORT $LN20@EncryptPar
$LN107@EncryptPar:

; 433  : 	{
; 434  : 		nStatus = ERR_OS_ERROR;

  00182	be 01 00 00 00	 mov	 esi, 1

; 696  : 
; 697  : 
; 698  : closing_seq:

  00187	e9 7d 04 00 00	 jmp	 $closing_seq$141
$LN20@EncryptPar:

; 435  : 		goto closing_seq;
; 436  : 	}
; 437  : 
; 438  : 	if (IsDeviceMounted (devName))

  0018c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 _IsDeviceMounted
  00198	83 c4 04	 add	 esp, 4
  0019b	85 c0		 test	 eax, eax
  0019d	0f 84 54 04 00
	00		 je	 $LN22@EncryptPar

; 439  : 	{
; 440  : 		dev = OpenPartitionVolume (devName,

  001a3	6a 00		 push	 0
  001a5	68 00 00 00 80	 push	 -2147483648		; 80000000H
  001aa	6a 03		 push	 3
  001ac	6a 00		 push	 0
  001ae	6a 03		 push	 3
  001b0	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  001b5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  001bb	50		 push	 eax
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  001c2	8b f8		 mov	 edi, eax
  001c4	83 ff ff	 cmp	 edi, -1
  001c7	75 1f		 jne	 SHORT $LN86@EncryptPar
  001c9	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  001cf	e8 00 00 00 00	 call	 _handleWin32Error
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  001d9	e8 00 00 00 00	 call	 _Error
  001de	83 c4 08	 add	 esp, 8
  001e1	0b ff		 or	 edi, edi

; 696  : 
; 697  : 
; 698  : closing_seq:

  001e3	e9 1c 04 00 00	 jmp	 $LN139@EncryptPar

; 439  : 	{
; 440  : 		dev = OpenPartitionVolume (devName,

$LN86@EncryptPar:

; 458  : 		goto closing_seq;
; 459  : 	}
; 460  : 
; 461  : 
; 462  : 	/* Gain "raw" access to the partition (the NTFS driver guards hidden sectors). */
; 463  : 
; 464  : 	if (!DeviceIoControl (dev,

  001e8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceIoControl@32
  001ee	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _dwResult$[ebp]
  001f4	6a 00		 push	 0
  001f6	50		 push	 eax
  001f7	6a 00		 push	 0
  001f9	6a 00		 push	 0
  001fb	6a 00		 push	 0
  001fd	6a 00		 push	 0
  001ff	68 83 00 09 00	 push	 589955			; 00090083H
  00204	57		 push	 edi
  00205	ff d6		 call	 esi
  00207	85 c0		 test	 eax, eax
  00209	75 1f		 jne	 SHORT $LN27@EncryptPar

; 465  : 		FSCTL_ALLOW_EXTENDED_DASD_IO,
; 466  : 		NULL,
; 467  : 		0,   
; 468  : 		NULL,
; 469  : 		0,
; 470  : 		&dwResult,
; 471  : 		NULL))
; 472  : 	{
; 473  : 		handleWin32Error (MainDlg);

  0020b	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00211	e8 00 00 00 00	 call	 _handleWin32Error

; 474  : 		ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL_ALT", TRUE);

  00216	6a 01		 push	 1
  00218	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  0021d	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  00222	83 c4 0c	 add	 esp, 12			; 0000000cH

; 696  : 
; 697  : 
; 698  : closing_seq:

  00225	e9 da 03 00 00	 jmp	 $LN139@EncryptPar
$LN27@EncryptPar:

; 475  : 		nStatus = ERR_DONT_REPORT; 
; 476  : 		goto closing_seq;
; 477  : 	}
; 478  : 
; 479  : 
; 480  : 
; 481  : 	/* Shrink the filesystem */
; 482  : 
; 483  : 	int64 totalClusterCount;
; 484  : 	DWORD bytesPerCluster;
; 485  : 
; 486  : 	sizeToShrinkTo = NewFileSysSizeAfterShrink (dev, volParams->volumePath, &totalClusterCount, &bytesPerCluster, FALSE);

  0022a	6a 00		 push	 0
  0022c	8d 85 a8 fb ff
	ff		 lea	 eax, DWORD PTR _bytesPerCluster$[ebp]
  00232	50		 push	 eax
  00233	8d 85 98 fb ff
	ff		 lea	 eax, DWORD PTR _totalClusterCount$[ebp]
  00239	50		 push	 eax
  0023a	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0023d	50		 push	 eax
  0023e	57		 push	 edi
  0023f	e8 00 00 00 00	 call	 ?NewFileSysSizeAfterShrink@@YA_JPAXPBDPA_JPAKH@Z ; NewFileSysSizeAfterShrink

; 487  : 
; 488  : 	if (sizeToShrinkTo == -1)

  00244	8b c8		 mov	 ecx, eax
  00246	83 c4 14	 add	 esp, 20			; 00000014H
  00249	23 ca		 and	 ecx, edx
  0024b	83 f9 ff	 cmp	 ecx, -1
  0024e	75 14		 jne	 SHORT $LN29@EncryptPar

; 489  : 	{
; 490  : 		ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL_ALT", TRUE);

  00250	6a 01		 push	 1
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  00257	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  0025c	83 c4 08	 add	 esp, 8

; 696  : 
; 697  : 
; 698  : closing_seq:

  0025f	e9 a0 03 00 00	 jmp	 $LN139@EncryptPar
$LN29@EncryptPar:

; 491  : 		nStatus = ERR_DONT_REPORT; 
; 492  : 		goto closing_seq;
; 493  : 	}
; 494  : 
; 495  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_RESIZING);
; 496  : 
; 497  : 	memset (&shrinkVolInfo, 0, sizeof (shrinkVolInfo));
; 498  : 
; 499  : 	shrinkVolInfo.ShrinkRequestType = ShrinkPrepare;
; 500  : 	shrinkVolInfo.NewNumberOfSectors = sizeToShrinkTo;
; 501  : 
; 502  : 	if (!DeviceIoControl (dev,

  00264	6a 00		 push	 0
  00266	0f 57 c0	 xorps	 xmm0, xmm0
  00269	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 2
  00273	66 0f d6 85 e4
	fb ff ff	 movq	 QWORD PTR _shrinkVolInfo$[ebp+16], xmm0
  0027b	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _shrinkVolInfo$[ebp+16], eax
  00281	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _dwResult$[ebp]
  00287	50		 push	 eax
  00288	6a 00		 push	 0
  0028a	6a 00		 push	 0
  0028c	6a 18		 push	 24			; 00000018H
  0028e	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR _shrinkVolInfo$[ebp]
  00294	89 95 e8 fb ff
	ff		 mov	 DWORD PTR _shrinkVolInfo$[ebp+20], edx
  0029a	50		 push	 eax
  0029b	68 b0 01 09 00	 push	 590256			; 000901b0H
  002a0	0f 11 85 d4 fb
	ff ff		 movups	 XMMWORD PTR _shrinkVolInfo$[ebp], xmm0
  002a7	57		 push	 edi
  002a8	c7 85 d4 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _shrinkVolInfo$[ebp], 1
  002b2	ff d6		 call	 esi
  002b4	85 c0		 test	 eax, eax
  002b6	75 1f		 jne	 SHORT $LN31@EncryptPar

; 503  : 		FSCTL_SHRINK_VOLUME,
; 504  : 
; 505  : 		(LPVOID) &shrinkVolInfo,
; 506  : 		sizeof (shrinkVolInfo),   
; 507  : 		NULL,
; 508  : 		0,
; 509  : 		&dwResult,
; 510  : 		NULL))
; 511  : 	{
; 512  : 		handleWin32Error (MainDlg);

  002b8	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  002be	e8 00 00 00 00	 call	 _handleWin32Error

; 513  : 		ShowInPlaceEncErrMsgWAltSteps ("CANNOT_RESIZE_FILESYS", TRUE);

  002c3	6a 01		 push	 1
  002c5	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EBLNDPCA@CANNOT_RESIZE_FILESYS?$AA@
  002ca	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  002cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 696  : 
; 697  : 
; 698  : closing_seq:

  002d2	e9 2d 03 00 00	 jmp	 $LN139@EncryptPar
$LN31@EncryptPar:

; 514  : 		nStatus = ERR_DONT_REPORT; 
; 515  : 		goto closing_seq;
; 516  : 	}
; 517  : 
; 518  : 	BOOL clustersMovedBeforeVolumeEnd = FALSE;

  002d7	33 f6		 xor	 esi, esi

; 519  : 
; 520  : 	while (true)
; 521  : 	{
; 522  : 		shrinkVolInfo.ShrinkRequestType = ShrinkCommit;

  002d9	c7 85 d4 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR _shrinkVolInfo$[ebp], 2

; 523  : 		shrinkVolInfo.NewNumberOfSectors = 0;
; 524  : 
; 525  : 		if (!DeviceIoControl (dev, FSCTL_SHRINK_VOLUME, &shrinkVolInfo, sizeof (shrinkVolInfo), NULL, 0, &dwResult, NULL))

  002e3	56		 push	 esi
  002e4	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _dwResult$[ebp]
  002ea	0f 57 c0	 xorps	 xmm0, xmm0
  002ed	50		 push	 eax
  002ee	56		 push	 esi
  002ef	56		 push	 esi
  002f0	6a 18		 push	 24			; 00000018H
  002f2	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR _shrinkVolInfo$[ebp]
  002f8	66 0f 13 85 e4
	fb ff ff	 movlpd	 QWORD PTR _shrinkVolInfo$[ebp+16], xmm0
  00300	50		 push	 eax
  00301	68 b0 01 09 00	 push	 590256			; 000901b0H
  00306	57		 push	 edi
  00307	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0030d	85 c0		 test	 eax, eax
  0030f	0f 85 a7 00 00
	00		 jne	 $LN33@EncryptPar
  00315	8b 9d a8 fb ff
	ff		 mov	 ebx, DWORD PTR _bytesPerCluster$[ebp]
  0031b	0f 1f 44 00 00	 npad	 5
$LL2@EncryptPar:

; 526  : 		{
; 527  : 			// If there are any occupied clusters beyond the new desired end of the volume, the call fails with
; 528  : 			// ERROR_ACCESS_DENIED (STATUS_ALREADY_COMMITTED). 
; 529  : 			if (GetLastError () == ERROR_ACCESS_DENIED)

  00320	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00326	83 f8 05	 cmp	 eax, 5
  00329	0f 85 09 01 00
	00		 jne	 $LN34@EncryptPar
  0032f	85 f6		 test	 esi, esi

; 530  : 			{
; 531  : 				if (!clustersMovedBeforeVolumeEnd)

  00331	0f 85 0f 01 00
	00		 jne	 $LN35@EncryptPar

; 532  : 				{
; 533  : 					if (MoveClustersBeforeThreshold (dev, deviceName, totalClusterCount - (bytesPerCluster > GST_TOTAL_VOLUME_HEADERS_SIZE ? 1 : GST_TOTAL_VOLUME_HEADERS_SIZE / bytesPerCluster)))

  00337	81 fb 00 00 04
	00		 cmp	 ebx, 262144		; 00040000H
  0033d	76 05		 jbe	 SHORT $LN65@EncryptPar
  0033f	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00342	eb 09		 jmp	 SHORT $LN66@EncryptPar
$LN65@EncryptPar:
  00344	b8 00 00 04 00	 mov	 eax, 262144		; 00040000H
  00349	33 d2		 xor	 edx, edx
  0034b	f7 f3		 div	 ebx
$LN66@EncryptPar:
  0034d	8b 8d 98 fb ff
	ff		 mov	 ecx, DWORD PTR _totalClusterCount$[ebp]
  00353	2b c8		 sub	 ecx, eax
  00355	8b 85 9c fb ff
	ff		 mov	 eax, DWORD PTR _totalClusterCount$[ebp+4]
  0035b	83 d8 00	 sbb	 eax, 0
  0035e	50		 push	 eax
  0035f	51		 push	 ecx
  00360	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  00366	50		 push	 eax
  00367	57		 push	 edi
  00368	e8 00 00 00 00	 call	 _MoveClustersBeforeThreshold
  0036d	83 c4 10	 add	 esp, 16			; 00000010H
  00370	85 c0		 test	 eax, eax
  00372	0f 84 c0 00 00
	00		 je	 $LN34@EncryptPar

; 523  : 		shrinkVolInfo.NewNumberOfSectors = 0;
; 524  : 
; 525  : 		if (!DeviceIoControl (dev, FSCTL_SHRINK_VOLUME, &shrinkVolInfo, sizeof (shrinkVolInfo), NULL, 0, &dwResult, NULL))

  00378	6a 00		 push	 0
  0037a	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _dwResult$[ebp]
  00380	c7 85 d4 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR _shrinkVolInfo$[ebp], 2
  0038a	50		 push	 eax
  0038b	6a 00		 push	 0
  0038d	6a 00		 push	 0
  0038f	6a 18		 push	 24			; 00000018H
  00391	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR _shrinkVolInfo$[ebp]
  00397	0f 57 c0	 xorps	 xmm0, xmm0
  0039a	50		 push	 eax
  0039b	68 b0 01 09 00	 push	 590256			; 000901b0H
  003a0	57		 push	 edi

; 534  : 					{
; 535  : 						clustersMovedBeforeVolumeEnd = TRUE;

  003a1	be 01 00 00 00	 mov	 esi, 1
  003a6	66 0f 13 85 e4
	fb ff ff	 movlpd	 QWORD PTR _shrinkVolInfo$[ebp+16], xmm0
  003ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  003b4	85 c0		 test	 eax, eax
  003b6	0f 84 64 ff ff
	ff		 je	 $LL2@EncryptPar
$LN33@EncryptPar:

; 546  : 			nStatus = ERR_DONT_REPORT; 
; 547  : 			goto closing_seq;
; 548  : 		}
; 549  : 
; 550  : 		break;
; 551  : 	}
; 552  : 
; 553  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PREPARING);
; 554  : 
; 555  : 
; 556  : 	/* Gain exclusive access to the volume */
; 557  : 
; 558  : 	nStatus = DismountFileSystem (dev,

  003bc	6a 00		 push	 0
  003be	6a 01		 push	 1
  003c0	6a 01		 push	 1
  003c2	ff b5 c0 fb ff
	ff		 push	 DWORD PTR _driveLetter$1$[ebp]
  003c8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 1
  003d2	57		 push	 edi
  003d3	e8 00 00 00 00	 call	 _DismountFileSystem
  003d8	83 c4 14	 add	 esp, 20			; 00000014H

; 559  : 		driveLetter,
; 560  : 		TRUE,
; 561  : 		TRUE,
; 562  : 		FALSE);
; 563  : 
; 564  : 	if (nStatus != ERR_SUCCESS)

  003db	85 c0		 test	 eax, eax
  003dd	0f 85 21 02 00
	00		 jne	 $LN139@EncryptPar

; 565  : 	{
; 566  : 		nStatus = ERR_DONT_REPORT; 
; 567  : 		goto closing_seq;
; 568  : 	}
; 569  : 
; 570  : 
; 571  : 
; 572  : 	/* Create header backup on the partition. Until the volume is fully encrypted, the backup header will provide 
; 573  : 	us with the master key, encrypted range, and other data for pause/resume operations. We cannot create the 
; 574  : 	primary header until the entire partition is encrypted (because we encrypt backwards and the primary header 
; 575  : 	area is occuppied by data until the very end of the process). */
; 576  : 
; 577  : 	
; 578  : 
; 579  : 	// Prepare the backup header
; 580  : 	for (int wipePass = 0; wipePass < (wipeAlgorithm == GST_WIPE_NONE ? 1 : PRAND_DISK_WIPE_PASSES); wipePass++)

  003e3	8b 4d 10	 mov	 ecx, DWORD PTR _wipeAlgorithm$[ebp]
  003e6	33 db		 xor	 ebx, ebx
  003e8	85 c9		 test	 ecx, ecx
  003ea	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  003ef	ba 01 00 00 00	 mov	 edx, 1
  003f4	0f 44 c2	 cmove	 eax, edx
  003f7	89 85 a4 fb ff
	ff		 mov	 DWORD PTR tv499[ebp], eax
  003fd	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _dataAreaSize$1$[ebp]
  00403	05 00 00 02 00	 add	 eax, 131072		; 00020000H
  00408	89 85 c0 fb ff
	ff		 mov	 DWORD PTR _offset$1$[ebp], eax
  0040e	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR _dataAreaSize$2$[ebp]
  00414	13 c3		 adc	 eax, ebx
  00416	89 85 ac fb ff
	ff		 mov	 DWORD PTR _offset$2$[ebp], eax
  0041c	0f 1f 40 00	 npad	 4
$LL6@EncryptPar:

; 581  : 	{
; 582  : 		/* Switch between ea for choosen the right mode of operation */
; 583  : 		switch (volParams->ea)

  00420	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _volParams$GSCopy$1$[ebp]
  00426	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00429	83 e8 01	 sub	 eax, 1
  0042c	74 2c		 je	 SHORT $LN41@EncryptPar
  0042e	83 e8 01	 sub	 eax, 1

; 587  : 			break;
; 588  : 		case GRASSHOPPER:
; 589  : 			dwModeOfOperatioID = XTS;
; 590  : 			break;
; 591  : 		default:
; 592  : 			dwModeOfOperatioID = FIRST_MODE_OF_OPERATION_ID;

  00431	ba 01 00 00 00	 mov	 edx, 1
  00436	eb 27		 jmp	 SHORT $LN7@EncryptPar
$LN34@EncryptPar:

; 536  : 						continue;
; 537  : 					}
; 538  : 
; 539  : 					handleWin32Error (MainDlg);
; 540  : 				}
; 541  : 			}
; 542  : 			else
; 543  : 				handleWin32Error (MainDlg);

  00438	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0043e	e8 00 00 00 00	 call	 _handleWin32Error
  00443	83 c4 04	 add	 esp, 4
$LN35@EncryptPar:

; 544  : 
; 545  : 			ShowInPlaceEncErrMsgWAltSteps ("CANNOT_RESIZE_FILESYS", TRUE);

  00446	6a 01		 push	 1
  00448	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EBLNDPCA@CANNOT_RESIZE_FILESYS?$AA@
  0044d	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  00452	83 c4 08	 add	 esp, 8

; 696  : 
; 697  : 
; 698  : closing_seq:

  00455	e9 aa 01 00 00	 jmp	 $LN139@EncryptPar
$LN41@EncryptPar:

; 584  : 		{
; 585  : 		case GOST:
; 586  : 			dwModeOfOperatioID = XTS8;

  0045a	ba 02 00 00 00	 mov	 edx, 2
$LN7@EncryptPar:

; 593  : 			break;
; 594  : 		}
; 595  : 
; 596  : 		nStatus = CreateVolumeHeaderInMemory (FALSE,

  0045f	85 c9		 test	 ecx, ecx
  00461	74 0b		 je	 SHORT $LN68@EncryptPar
$LN67@EncryptPar:
  00463	33 c9		 xor	 ecx, ecx
  00465	81 fb ff 00 00
	00		 cmp	 ebx, 255		; 000000ffH
  0046b	0f 9c c1	 setl	 cl
$LN68@EncryptPar:
  0046e	85 db		 test	 ebx, ebx
  00470	75 04		 jne	 SHORT $LN69@EncryptPar
  00472	33 f6		 xor	 esi, esi
  00474	eb 0c		 jmp	 SHORT $LN70@EncryptPar
$LN69@EncryptPar:
  00476	8b b5 d0 fb ff
	ff		 mov	 esi, DWORD PTR _cryptoInfo$[ebp]
  0047c	81 c6 50 1c 00
	00		 add	 esi, 7248		; 00001c50H
$LN70@EncryptPar:
  00482	51		 push	 ecx
  00483	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _volParams$GSCopy$1$[ebp]
  00489	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  0048c	50		 push	 eax
  0048d	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00490	83 c8 02	 or	 eax, 2
  00493	50		 push	 eax
  00494	6a 00		 push	 0
  00496	6a 00		 push	 0
  00498	6a 00		 push	 0
  0049a	ff b5 ac fb ff
	ff		 push	 DWORD PTR _offset$2$[ebp]
  004a0	8d 85 d0 fb ff
	ff		 lea	 eax, DWORD PTR _cryptoInfo$[ebp]
  004a6	ff b5 c0 fb ff
	ff		 push	 DWORD PTR _offset$1$[ebp]
  004ac	6a 00		 push	 0
  004ae	6a 00		 push	 0
  004b0	ff b5 b8 fb ff
	ff		 push	 DWORD PTR _dataAreaSize$2$[ebp]
  004b6	ff b5 b4 fb ff
	ff		 push	 DWORD PTR _dataAreaSize$1$[ebp]
  004bc	50		 push	 eax
  004bd	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  004c0	56		 push	 esi
  004c1	50		 push	 eax
  004c2	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  004c5	50		 push	 eax
  004c6	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  004c9	52		 push	 edx
  004ca	50		 push	 eax
  004cb	ff b5 c8 fb ff
	ff		 push	 DWORD PTR _header$1$[ebp]
  004d1	6a 00		 push	 0
  004d3	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  004d8	8b f0		 mov	 esi, eax
  004da	83 c4 50	 add	 esp, 80			; 00000050H

; 597  : 			header,
; 598  : 			volParams->ea,
; 599  : 			dwModeOfOperatioID,
; 600  : 			volParams->password,
; 601  : 			volParams->pkcs5,
; 602  : 			wipePass == 0 ? NULL : (char *) cryptoInfo->master_keydata,
; 603  : 			&cryptoInfo,
; 604  : 			dataAreaSize,
; 605  : 			0,
; 606  : 			GST_VOLUME_DATA_OFFSET + dataAreaSize,	// Start of the encrypted area = the first byte of the backup heeader (encrypting from the end)
; 607  : 			0,	// No data is encrypted yet
; 608  : 			0,
; 609  : 			volParams->headerFlags | GST_HEADER_FLAG_NONSYS_INPLACE_ENC,
; 610  : 			volParams->sectorSize,
; 611  : 			wipeAlgorithm == GST_WIPE_NONE ? FALSE : (wipePass < PRAND_DISK_WIPE_PASSES - 1));
; 612  : 
; 613  : 		if (nStatus != 0)

  004dd	85 f6		 test	 esi, esi
  004df	0f 85 24 01 00
	00		 jne	 $closing_seq$141

; 614  : 			goto closing_seq;
; 615  : 
; 616  : 		offset.QuadPart = GST_VOLUME_DATA_OFFSET + dataAreaSize;
; 617  : 
; 618  : 		if (!SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  004e5	50		 push	 eax
  004e6	50		 push	 eax
  004e7	ff b5 ac fb ff
	ff		 push	 DWORD PTR _offset$2$[ebp]
  004ed	ff b5 c0 fb ff
	ff		 push	 DWORD PTR _offset$1$[ebp]
  004f3	57		 push	 edi
  004f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  004fa	85 c0		 test	 eax, eax
  004fc	0f 84 80 fc ff
	ff		 je	 $LN107@EncryptPar

; 619  : 		{
; 620  : 			nStatus = ERR_OS_ERROR;
; 621  : 			goto closing_seq;
; 622  : 		}
; 623  : 
; 624  : 		// Write the backup header to the partition
; 625  : 		if (!WriteEffectiveVolumeHeader (TRUE, dev, (byte *) header))

  00502	ff b5 c8 fb ff
	ff		 push	 DWORD PTR _header$1$[ebp]
  00508	57		 push	 edi
  00509	6a 01		 push	 1
  0050b	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  00510	83 c4 0c	 add	 esp, 12			; 0000000cH
  00513	85 c0		 test	 eax, eax
  00515	0f 84 67 fc ff
	ff		 je	 $LN107@EncryptPar

; 626  : 		{
; 627  : 			nStatus = ERR_OS_ERROR;
; 628  : 			goto closing_seq;
; 629  : 		}
; 630  : 
; 631  : 		// Fill the reserved sectors of the backup header area with random data
; 632  : 		nStatus = WriteRandomDataToReservedHeaderAreas (dev, cryptoInfo, dataAreaSize, FALSE, TRUE);

  0051b	6a 01		 push	 1
  0051d	56		 push	 esi
  0051e	ff b5 b8 fb ff
	ff		 push	 DWORD PTR _dataAreaSize$2$[ebp]
  00524	ff b5 b4 fb ff
	ff		 push	 DWORD PTR _dataAreaSize$1$[ebp]
  0052a	ff b5 d0 fb ff
	ff		 push	 DWORD PTR _cryptoInfo$[ebp]
  00530	57		 push	 edi
  00531	e8 00 00 00 00	 call	 _WriteRandomDataToReservedHeaderAreas
  00536	8b f0		 mov	 esi, eax
  00538	83 c4 18	 add	 esp, 24			; 00000018H

; 633  : 
; 634  : 		if (nStatus != ERR_SUCCESS)

  0053b	85 f6		 test	 esi, esi
  0053d	0f 85 c6 00 00
	00		 jne	 $closing_seq$141

; 565  : 	{
; 566  : 		nStatus = ERR_DONT_REPORT; 
; 567  : 		goto closing_seq;
; 568  : 	}
; 569  : 
; 570  : 
; 571  : 
; 572  : 	/* Create header backup on the partition. Until the volume is fully encrypted, the backup header will provide 
; 573  : 	us with the master key, encrypted range, and other data for pause/resume operations. We cannot create the 
; 574  : 	primary header until the entire partition is encrypted (because we encrypt backwards and the primary header 
; 575  : 	area is occuppied by data until the very end of the process). */
; 576  : 
; 577  : 	
; 578  : 
; 579  : 	// Prepare the backup header
; 580  : 	for (int wipePass = 0; wipePass < (wipeAlgorithm == GST_WIPE_NONE ? 1 : PRAND_DISK_WIPE_PASSES); wipePass++)

  00543	8b 4d 10	 mov	 ecx, DWORD PTR _wipeAlgorithm$[ebp]
  00546	43		 inc	 ebx
  00547	3b 9d a4 fb ff
	ff		 cmp	 ebx, DWORD PTR tv499[ebp]
  0054d	0f 8c cd fe ff
	ff		 jl	 $LL6@EncryptPar

; 635  : 			goto closing_seq;
; 636  : 	}
; 637  : 
; 638  : 
; 639  : 	/* Now we will try to decrypt the backup header to verify it has been correctly written. */
; 640  : 
; 641  : 	nStatus = OpenBackupHeader (dev, volParams->volumePath, volParams->password, &cryptoInfo2, NULL, deviceSize);

  00553	ff b5 a0 fb ff
	ff		 push	 DWORD PTR _deviceSize$2$[ebp]
  00559	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _volParams$GSCopy$1$[ebp]
  0055f	ff b5 b0 fb ff
	ff		 push	 DWORD PTR _deviceSize$1$[ebp]
  00565	50		 push	 eax
  00566	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR _cryptoInfo2$[ebp]
  0056c	50		 push	 eax
  0056d	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00570	50		 push	 eax
  00571	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00574	50		 push	 eax
  00575	57		 push	 edi
  00576	e8 00 00 00 00	 call	 _OpenBackupHeader
  0057b	8b f0		 mov	 esi, eax
  0057d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 642  : 
; 643  : 	if (nStatus != ERR_SUCCESS
; 644  : 		|| cryptoInfo->EncryptedAreaStart.Value != cryptoInfo2->EncryptedAreaStart.Value
; 645  : 		|| cryptoInfo2->EncryptedAreaStart.Value == 0)

  00580	85 f6		 test	 esi, esi
  00582	0f 85 81 00 00
	00		 jne	 $closing_seq$141
  00588	8b 85 cc fb ff
	ff		 mov	 eax, DWORD PTR _cryptoInfo2$[ebp]
  0058e	8b 95 d0 fb ff
	ff		 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00594	8b 88 f8 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7928]
  0059a	8b 80 fc 1e 00
	00		 mov	 eax, DWORD PTR [eax+7932]
  005a0	39 8a f8 1e 00
	00		 cmp	 DWORD PTR [edx+7928], ecx
  005a6	0f 85 3b fb ff
	ff		 jne	 $LN132@EncryptPar
  005ac	39 82 fc 1e 00
	00		 cmp	 DWORD PTR [edx+7932], eax
  005b2	0f 85 2f fb ff
	ff		 jne	 $LN132@EncryptPar
  005b8	0b c8		 or	 ecx, eax
  005ba	0f 84 27 fb ff
	ff		 je	 $LN132@EncryptPar

; 646  : 	{
; 647  : 		if (nStatus == ERR_SUCCESS)
; 648  : 			nStatus = ERR_PARAMETER_INCORRECT;
; 649  : 
; 650  : 		goto closing_seq;
; 651  : 	}
; 652  : 
; 653  : 	// The backup header is valid so we know we should be able to safely resume in-place encryption 
; 654  : 	// of this partition even if the system/app crashes.
; 655  : 
; 656  : 
; 657  : 
; 658  : 	/* Conceal the NTFS filesystem (by performing an easy-to-undo modification). This will prevent Windows 
; 659  : 	and apps from interfering with the volume until it has been fully encrypted. */
; 660  : 
; 661  : 	nStatus = ConcealNTFS (dev);

  005c0	57		 push	 edi
  005c1	e8 00 00 00 00	 call	 _ConcealNTFS
  005c6	8b f0		 mov	 esi, eax
  005c8	83 c4 04	 add	 esp, 4

; 662  : 
; 663  : 	if (nStatus != ERR_SUCCESS)

  005cb	85 f6		 test	 esi, esi
  005cd	75 3a		 jne	 SHORT $closing_seq$141

; 664  : 		goto closing_seq;
; 665  : 
; 666  : 
; 667  : 
; 668  : 	// /* If a drive letter is assigned to the device, remove it (so that users do not try to open it, which
; 669  : 	//would cause Windows to ask them if they want to format the volume and other dangerous things). */
; 670  : 
; 671  : 	//if (driveLetter >= 0) 
; 672  : 	//{
; 673  : 	//	char rootPath[] = { driveLetter + 'A', ':', '\\', 0 };
; 674  : 
; 675  : 	//	// Try to remove the assigned drive letter
; 676  : 	//	if (DeleteVolumeMountPoint (rootPath))
; 677  : 	//		driveLetter = -1;
; 678  : 	//}
; 679  : 
; 680  : 
; 681  : 
; 682  : 	/* Update config files and app data */
; 683  : 
; 684  : 	// In the config file, increase the number of partitions where in-place encryption is in progress
; 685  : 
; 686  : 	SaveNonSysInPlaceEncSettings (1, wipeAlgorithm);

  005cf	ff 75 10	 push	 DWORD PTR _wipeAlgorithm$[ebp]
  005d2	6a 01		 push	 1
  005d4	e8 00 00 00 00	 call	 _SaveNonSysInPlaceEncSettings
  005d9	83 c4 08	 add	 esp, 8

; 687  : 
; 688  : 
; 689  : 	// Add the wizard to the system startup sequence if appropriate
; 690  : 
; 691  : 	if (!IsNonInstallMode ())

  005dc	e8 00 00 00 00	 call	 _IsNonInstallMode
  005e1	85 c0		 test	 eax, eax
  005e3	75 0e		 jne	 SHORT $LN58@EncryptPar

; 692  : 		ManageStartupSeqWiz (FALSE, "/prinplace");

  005e5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DLEMDKJB@?1prinplace?$AA@
  005ea	50		 push	 eax
  005eb	e8 00 00 00 00	 call	 _ManageStartupSeqWiz
  005f0	83 c4 08	 add	 esp, 8
$LN58@EncryptPar:

; 693  : 
; 694  : 
; 695  : 	nStatus = ERR_SUCCESS;

  005f3	33 f6		 xor	 esi, esi

; 696  : 
; 697  : 
; 698  : closing_seq:

  005f5	eb 12		 jmp	 SHORT $closing_seq$141
$LN22@EncryptPar:

; 441  : 			FALSE,	// Do not require exclusive access (must be FALSE; otherwise, it will not be possible to dismount the volume or obtain its properties and FSCTL_ALLOW_EXTENDED_DASD_IO will fail too)
; 442  : 			TRUE,	// Require shared access (must be TRUE; otherwise, it will not be possible to dismount the volume or obtain its properties and FSCTL_ALLOW_EXTENDED_DASD_IO will fail too)
; 443  : 			FALSE,	// Do not ask the user to confirm shared access (if exclusive fails)
; 444  : 			FALSE,	// Do not append alternative instructions how to encrypt the data (to applicable error messages)
; 445  : 			FALSE);	// Non-silent mode
; 446  : 
; 447  : 		if (dev == INVALID_HANDLE_VALUE)
; 448  : 		{
; 449  : 			nStatus = ERR_DONT_REPORT; 
; 450  : 			goto closing_seq;
; 451  : 		}
; 452  : 	}
; 453  : 	else
; 454  : 	{
; 455  : 		// The volume is not mounted so we can't work with the filesystem.
; 456  : 		Error ("ONLY_MOUNTED_VOL_SUPPORTED_FOR_NONSYS_INPLACE_ENC");

  005f7	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@BPGKKGKD@ONLY_MOUNTED_VOL_SUPPORTED_FOR_N@
  005fc	e8 00 00 00 00	 call	 _Error
  00601	83 c4 04	 add	 esp, 4
$LN139@EncryptPar:

; 457  : 		nStatus = ERR_DONT_REPORT; 

  00604	be 1c 00 00 00	 mov	 esi, 28			; 0000001cH
$closing_seq$141:

; 699  : 
; 700  : 	dwError = GetLastError();

  00609	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 701  : 
; 702  : 	if (cryptoInfo != NULL)

  0060f	8b 8d d0 fb ff
	ff		 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00615	89 85 b0 fb ff
	ff		 mov	 DWORD PTR _dwError$1$[ebp], eax
  0061b	85 c9		 test	 ecx, ecx
  0061d	74 13		 je	 SHORT $LN59@EncryptPar

; 703  : 	{
; 704  : 		crypto_close (cryptoInfo);

  0061f	51		 push	 ecx
  00620	e8 00 00 00 00	 call	 _crypto_close
  00625	83 c4 04	 add	 esp, 4

; 705  : 		cryptoInfo = NULL;

  00628	c7 85 d0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _cryptoInfo$[ebp], 0
$LN59@EncryptPar:

; 706  : 	}
; 707  : 
; 708  : 	if (cryptoInfo2 != NULL)

  00632	8b 85 cc fb ff
	ff		 mov	 eax, DWORD PTR _cryptoInfo2$[ebp]
  00638	85 c0		 test	 eax, eax
  0063a	74 13		 je	 SHORT $LN11@EncryptPar

; 709  : 	{
; 710  : 		crypto_close (cryptoInfo2);

  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 _crypto_close
  00642	83 c4 04	 add	 esp, 4

; 711  : 		cryptoInfo2 = NULL;

  00645	c7 85 cc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _cryptoInfo2$[ebp], 0
$LN11@EncryptPar:

; 712  : 	}
; 713  : 
; 714  : 	burn (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  0064f	8b 95 c8 fb ff
	ff		 mov	 edx, DWORD PTR _header$1$[ebp]
  00655	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0065a	8b c2		 mov	 eax, edx
  0065c	8b d9		 mov	 ebx, ecx
  0065e	66 90		 npad	 2
$LL97@EncryptPar:
  00660	c6 02 00	 mov	 BYTE PTR [edx], 0
  00663	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00666	83 eb 01	 sub	 ebx, 1
  00669	75 f5		 jne	 SHORT $LL97@EncryptPar
  0066b	0f 1f 44 00 00	 npad	 5
$LL12@EncryptPar:
  00670	c6 00 00	 mov	 BYTE PTR [eax], 0
  00673	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00676	83 e9 01	 sub	 ecx, 1
  00679	75 f5		 jne	 SHORT $LL12@EncryptPar

; 715  : 	VirtualUnlock (header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  0067b	8b 9d c8 fb ff
	ff		 mov	 ebx, DWORD PTR _header$1$[ebp]
  00681	68 00 02 00 00	 push	 512			; 00000200H
  00686	53		 push	 ebx
  00687	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 716  : 	GSTfree (header);

  0068d	53		 push	 ebx
  0068e	e8 00 00 00 00	 call	 _free
  00693	83 c4 04	 add	 esp, 4

; 717  : 
; 718  : 	if (dosDev[0])

  00696	80 bd f4 fd ff
	ff 00		 cmp	 BYTE PTR _dosDev$[ebp], 0
  0069d	74 19		 je	 SHORT $LN61@EncryptPar

; 719  : 		RemoveFakeDosName (volParams->volumePath, dosDev);

  0069f	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  006a5	50		 push	 eax
  006a6	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _volParams$GSCopy$1$[ebp]
  006ac	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  006af	50		 push	 eax
  006b0	e8 00 00 00 00	 call	 _RemoveFakeDosName
  006b5	83 c4 08	 add	 esp, 8
$LN61@EncryptPar:

; 720  : 
; 721  : 	*outHandle = dev;

  006b8	8b 45 0c	 mov	 eax, DWORD PTR _outHandle$[ebp]
  006bb	89 38		 mov	 DWORD PTR [eax], edi

; 722  : 
; 723  : 	if (nStatus != ERR_SUCCESS)

  006bd	85 f6		 test	 esi, esi
  006bf	74 0c		 je	 SHORT $LN62@EncryptPar

; 724  : 		SetLastError (dwError);

  006c1	ff b5 b0 fb ff
	ff		 push	 DWORD PTR _dwError$1$[ebp]
  006c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN62@EncryptPar:

; 725  : 
; 726  : 	return nStatus;
; 727  : }

  006cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006d0	8b c6		 mov	 eax, esi
  006d2	5e		 pop	 esi
  006d3	5f		 pop	 edi
  006d4	33 cd		 xor	 ecx, ebp
  006d6	5b		 pop	 ebx
  006d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006dc	8b e5		 mov	 esp, ebp
  006de	5d		 pop	 ebp
  006df	c3		 ret	 0
_EncryptPartitionInPlaceBegin ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\format\inplace.c
;	COMDAT _CheckRequirementsForNonSysInPlaceEnc
_TEXT	SEGMENT
_nBytesReturned$ = -1412				; size = 4
_driveNumber$ = -1408					; size = 4
_partitionNumber$ = -1404				; size = 4
_szRootPath$ = -1400					; size = 4
_ntfsVolData$ = -1396					; size = 96
_devPath$ = -1300					; size = 520
_dosDev$ = -780						; size = 260
_szFileSysName$ = -520					; size = 256
_devName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_devicePath$ = 8					; size = 4
_silent$ = 12						; size = 4
_CheckRequirementsForNonSysInPlaceEnc PROC		; COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 05 00
	00		 sub	 esp, 1412		; 00000584H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _devicePath$[ebp]
  00017	8d 85 f4 fc ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  0001d	68 04 01 00 00	 push	 260			; 00000104H
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _memset
  0002a	68 04 01 00 00	 push	 260			; 00000104H
  0002f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  00035	6a 00		 push	 0
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _memset
  0003d	83 c4 18	 add	 esp, 24			; 00000018H

; 145  : 	NTFS_VOLUME_DATA_BUFFER ntfsVolData;
; 146  : 	DWORD nBytesReturned;
; 147  : 	HANDLE dev;
; 148  : 	char szFileSysName [256];
; 149  : 	WCHAR devPath [MAX_PATH];
; 150  : 	char dosDev [GST_MAX_PATH] = {0};
; 151  : 	char devName [MAX_PATH] = {0};
; 152  : 	int driveLetterNo = -1;
; 153  : 	char szRootPath[4] = {0, ':', '\\', 0};

  00040	c7 85 88 fa ff
	ff 00 3a 5c 00	 mov	 DWORD PTR _szRootPath$[ebp], 6044160 ; 005c3a00H

; 154  : 	__int64 deviceSize;
; 155  : 	int partitionNumber = -1, driveNumber = -1;
; 156  : 
; 157  : 
; 158  : 	/* ---------- Checks that do not require admin rights ----------- */
; 159  : 
; 160  : 
; 161  : 	/* Operating system */
; 162  : 
; 163  : 	if (CurrentOSMajor < 6)

  0004a	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _CurrentOSMajor, 6
  00051	c7 85 84 fa ff
	ff ff ff ff ff	 mov	 DWORD PTR _partitionNumber$[ebp], -1
  0005b	c7 85 80 fa ff
	ff ff ff ff ff	 mov	 DWORD PTR _driveNumber$[ebp], -1
  00065	7d 26		 jge	 SHORT $LN2@CheckRequi

; 164  : 	{
; 165  : 		if (!silent)

  00067	83 7d 0c 00	 cmp	 DWORD PTR _silent$[ebp], 0
  0006b	75 0f		 jne	 SHORT $LN3@CheckRequi

; 166  : 			ShowInPlaceEncErrMsgWAltSteps ("OS_NOT_SUPPORTED_FOR_NONSYS_INPLACE_ENC", FALSE);

  0006d	6a 00		 push	 0
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PMIJHGDI@OS_NOT_SUPPORTED_FOR_NONSYS_INPL@
  00074	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  00079	83 c4 08	 add	 esp, 8
$LN3@CheckRequi:

; 167  : 
; 168  : 		return FALSE;

  0007c	33 c0		 xor	 eax, eax
  0007e	5b		 pop	 ebx

; 353  : 
; 354  : }

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00082	33 cd		 xor	 ecx, ebp
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN2@CheckRequi:

; 169  : 	}
; 170  : 
; 171  : 
; 172  : 	/* Volume type (must be a partition or a dynamic volume) */
; 173  : 
; 174  : 	if (sscanf (devicePath, "\\Device\\HarddiskVolume%d", &partitionNumber) != 1
; 175  : 		&& sscanf (devicePath, "\\Device\\Harddisk%d\\Partition%d", &driveNumber, &partitionNumber) != 2)

  0008d	8d 85 84 fa ff
	ff		 lea	 eax, DWORD PTR _partitionNumber$[ebp]
  00093	50		 push	 eax
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IDFJMMLD@?2Device?2HarddiskVolume?$CFd?$AA@
  00099	53		 push	 ebx
  0009a	e8 00 00 00 00	 call	 _sscanf
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a2	83 f8 01	 cmp	 eax, 1
  000a5	74 45		 je	 SHORT $LN4@CheckRequi
  000a7	8d 85 84 fa ff
	ff		 lea	 eax, DWORD PTR _partitionNumber$[ebp]
  000ad	50		 push	 eax
  000ae	8d 85 80 fa ff
	ff		 lea	 eax, DWORD PTR _driveNumber$[ebp]
  000b4	50		 push	 eax
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@MDCLODBD@?2Device?2Harddisk?$CFd?2Partition?$CFd?$AA@
  000ba	53		 push	 ebx
  000bb	e8 00 00 00 00	 call	 _sscanf
  000c0	83 c4 10	 add	 esp, 16			; 00000010H
  000c3	83 f8 02	 cmp	 eax, 2
  000c6	74 24		 je	 SHORT $LN4@CheckRequi

; 176  : 	{
; 177  : 		if (!silent)

  000c8	83 7d 0c 00	 cmp	 DWORD PTR _silent$[ebp], 0
  000cc	75 0d		 jne	 SHORT $LN5@CheckRequi

; 178  : 			Error ("INPLACE_ENC_INVALID_PATH");

  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KPKOCMJM@INPLACE_ENC_INVALID_PATH?$AA@
  000d3	e8 00 00 00 00	 call	 _Error
  000d8	83 c4 04	 add	 esp, 4
$LN5@CheckRequi:

; 179  : 
; 180  : 		return FALSE;

  000db	33 c0		 xor	 eax, eax
  000dd	5b		 pop	 ebx

; 353  : 
; 354  : }

  000de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	33 cd		 xor	 ecx, ebp
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
$LN4@CheckRequi:

; 181  : 	}
; 182  : 
; 183  : 	if (partitionNumber == 0)

  000ec	83 bd 84 fa ff
	ff 00		 cmp	 DWORD PTR _partitionNumber$[ebp], 0
  000f3	75 24		 jne	 SHORT $LN6@CheckRequi

; 184  : 	{
; 185  : 		if (!silent)

  000f5	83 7d 0c 00	 cmp	 DWORD PTR _silent$[ebp], 0
  000f9	75 e0		 jne	 SHORT $LN5@CheckRequi

; 186  : 			Warning ("RAW_DEV_NOT_SUPPORTED_FOR_INPLACE_ENC");

  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BBECDHBI@RAW_DEV_NOT_SUPPORTED_FOR_INPLAC@
  00100	e8 00 00 00 00	 call	 _Warning
  00105	83 c4 04	 add	 esp, 4

; 187  : 
; 188  : 		return FALSE;

  00108	33 c0		 xor	 eax, eax
  0010a	5b		 pop	 ebx

; 353  : 
; 354  : }

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c3		 ret	 0
$LN6@CheckRequi:
  00119	56		 push	 esi

; 189  : 	}
; 190  : 
; 191  : 
; 192  : 	/* Admin rights */
; 193  : 
; 194  : 	if (!IsAdmin())

  0011a	e8 00 00 00 00	 call	 _IsAdmin
  0011f	8b 75 0c	 mov	 esi, DWORD PTR _silent$[ebp]
  00122	85 c0		 test	 eax, eax
  00124	75 11		 jne	 SHORT $LN9@CheckRequi

; 195  : 	{
; 196  : 		// We rely on the wizard process to call us only when the whole wizard process has been elevated (so UAC 
; 197  : 		// status can be ignored). In case the IsAdmin() detection somehow fails, we allow the user to continue.
; 198  : 
; 199  : 		if (!silent)

  00126	85 f6		 test	 esi, esi
  00128	75 0d		 jne	 SHORT $LN9@CheckRequi

; 200  : 			Warning ("ADMIN_PRIVILEGES_WARN_DEVICES");

  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@
  0012f	e8 00 00 00 00	 call	 _Warning
  00134	83 c4 04	 add	 esp, 4
$LN9@CheckRequi:

; 201  : 	}
; 202  : 
; 203  : 
; 204  : 	/* ---------- Checks that may require admin rights ----------- */
; 205  : 
; 206  : 
; 207  : 	/* Access to the partition */
; 208  : 
; 209  : 	strcpy ((char *) devPath, devicePath);

  00137	8d 95 ec fa ff
	ff		 lea	 edx, DWORD PTR _devPath$[ebp]
  0013d	8b cb		 mov	 ecx, ebx
  0013f	2b d3		 sub	 edx, ebx
$LL33@CheckRequi:
  00141	8a 01		 mov	 al, BYTE PTR [ecx]
  00143	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00146	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  0014a	84 c0		 test	 al, al
  0014c	75 f3		 jne	 SHORT $LL33@CheckRequi

; 210  : 	ToUNICODE ((char *) devPath);

  0014e	8d 85 ec fa ff
	ff		 lea	 eax, DWORD PTR _devPath$[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 _ToUNICODE

; 211  : 
; 212  : 	driveLetterNo = GetDiskDeviceDriveLetter (devPath);

  0015a	8d 85 ec fa ff
	ff		 lea	 eax, DWORD PTR _devPath$[ebp]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  00166	83 c4 08	 add	 esp, 8

; 213  : 
; 214  : 	if (driveLetterNo >= 0)

  00169	85 c0		 test	 eax, eax
  0016b	78 08		 js	 SHORT $LN10@CheckRequi

; 215  : 		szRootPath[0] = (char) driveLetterNo + 'A';

  0016d	04 41		 add	 al, 65			; 00000041H
  0016f	88 85 88 fa ff
	ff		 mov	 BYTE PTR _szRootPath$[ebp], al
$LN10@CheckRequi:

; 216  : 
; 217  : 	if (FakeDosNameForDevice (devicePath, dosDev, devName, FALSE) != 0)

  00175	6a 00		 push	 0
  00177	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  0017d	50		 push	 eax
  0017e	8d 85 f4 fc ff
	ff		 lea	 eax, DWORD PTR _dosDev$[ebp]
  00184	50		 push	 eax
  00185	53		 push	 ebx
  00186	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  0018b	83 c4 10	 add	 esp, 16			; 00000010H
  0018e	85 c0		 test	 eax, eax
  00190	74 2e		 je	 SHORT $LN11@CheckRequi

; 218  : 	{
; 219  : 		if (!silent)

  00192	85 f6		 test	 esi, esi
  00194	75 18		 jne	 SHORT $LN12@CheckRequi

; 220  : 		{
; 221  : 			handleWin32Error (MainDlg);

  00196	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0019c	e8 00 00 00 00	 call	 _handleWin32Error

; 222  : 			Error ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL");

  001a1	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  001a6	e8 00 00 00 00	 call	 _Error
  001ab	83 c4 08	 add	 esp, 8
$LN12@CheckRequi:

; 223  : 		}
; 224  : 		return FALSE;

  001ae	5e		 pop	 esi
  001af	33 c0		 xor	 eax, eax
  001b1	5b		 pop	 ebx

; 353  : 
; 354  : }

  001b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b5	33 cd		 xor	 ecx, ebp
  001b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c3		 ret	 0
$LN11@CheckRequi:
  001c0	57		 push	 edi

; 225  : 	}
; 226  : 
; 227  : 	dev = OpenPartitionVolume (devName,

  001c1	6a 00		 push	 0
  001c3	68 00 00 00 80	 push	 -2147483648		; 80000000H
  001c8	6a 03		 push	 3
  001ca	6a 00		 push	 0
  001cc	6a 03		 push	 3
  001ce	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  001d3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  001d9	50		 push	 eax
  001da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  001e0	8b f8		 mov	 edi, eax
  001e2	83 ff ff	 cmp	 edi, -1
  001e5	75 33		 jne	 SHORT $LN13@CheckRequi
  001e7	85 f6		 test	 esi, esi
  001e9	0f 85 f2 01 00
	00		 jne	 $LN51@CheckRequi
  001ef	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  001f5	e8 00 00 00 00	 call	 _handleWin32Error
  001fa	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  001ff	e8 00 00 00 00	 call	 _Error
  00204	83 c4 08	 add	 esp, 8

; 348  : 		return FALSE;

  00207	33 c0		 xor	 eax, eax
  00209	5f		 pop	 edi
  0020a	5e		 pop	 esi
  0020b	5b		 pop	 ebx

; 353  : 
; 354  : }

  0020c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020f	33 cd		 xor	 ecx, ebp
  00211	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00216	8b e5		 mov	 esp, ebp
  00218	5d		 pop	 ebp
  00219	c3		 ret	 0
$LN13@CheckRequi:

; 228  : 		FALSE,	// Do not require exclusive access
; 229  : 		TRUE,	// Require shared access (must be TRUE; otherwise, volume properties will not be possible to obtain)
; 230  : 		FALSE,	// Do not ask the user to confirm shared access (if exclusive fails)
; 231  : 		FALSE,	// Do not append alternative instructions how to encrypt the data (to applicable error messages)
; 232  : 		silent);	// Silent mode
; 233  : 
; 234  : 	if (dev == INVALID_HANDLE_VALUE)
; 235  : 		return FALSE;
; 236  : 
; 237  : 
; 238  : 	/* File system type */
; 239  : 
; 240  : 	GetVolumeInformation (szRootPath, NULL, 0, NULL, NULL, NULL, szFileSysName, sizeof(szFileSysName));

  0021a	68 00 01 00 00	 push	 256			; 00000100H
  0021f	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _szFileSysName$[ebp]
  00225	50		 push	 eax
  00226	6a 00		 push	 0
  00228	6a 00		 push	 0
  0022a	6a 00		 push	 0
  0022c	6a 00		 push	 0
  0022e	6a 00		 push	 0
  00230	8d 85 88 fa ff
	ff		 lea	 eax, DWORD PTR _szRootPath$[ebp]
  00236	50		 push	 eax
  00237	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeInformationA@32

; 241  : 
; 242  : 	if (strncmp (szFileSysName, "NTFS", 4))

  0023d	6a 04		 push	 4
  0023f	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _szFileSysName$[ebp]
  00245	68 00 00 00 00	 push	 OFFSET ??_C@_04HPPAIJNK@NTFS?$AA@
  0024a	50		 push	 eax
  0024b	e8 00 00 00 00	 call	 _strncmp
  00250	83 c4 0c	 add	 esp, 12			; 0000000cH
  00253	85 c0		 test	 eax, eax
  00255	74 5e		 je	 SHORT $LN15@CheckRequi

; 243  : 	{
; 244  : 		// The previous filesystem type detection method failed (or it's not NTFS) -- try an alternative method
; 245  : 
; 246  : 		if (!DeviceIoControl (dev,

  00257	6a 00		 push	 0
  00259	8d 85 7c fa ff
	ff		 lea	 eax, DWORD PTR _nBytesReturned$[ebp]
  0025f	50		 push	 eax
  00260	6a 60		 push	 96			; 00000060H
  00262	8d 85 8c fa ff
	ff		 lea	 eax, DWORD PTR _ntfsVolData$[ebp]
  00268	50		 push	 eax
  00269	6a 00		 push	 0
  0026b	6a 00		 push	 0
  0026d	68 64 00 09 00	 push	 589924			; 00090064H
  00272	57		 push	 edi
  00273	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00279	85 c0		 test	 eax, eax
  0027b	75 38		 jne	 SHORT $LN15@CheckRequi

; 247  : 			FSCTL_GET_NTFS_VOLUME_DATA,
; 248  : 			NULL,
; 249  : 			0,
; 250  : 			(LPVOID) &ntfsVolData,
; 251  : 			sizeof (ntfsVolData),   
; 252  : 			&nBytesReturned,
; 253  : 			NULL))
; 254  : 		{
; 255  : 			if (!silent)

  0027d	85 f6		 test	 esi, esi
  0027f	0f 85 55 01 00
	00		 jne	 $LN31@CheckRequi

; 256  : 			{
; 257  : 				// The filesystem is not NTFS or the filesystem type could not be determined (or the NTFS filesystem
; 258  : 				// is dismounted).
; 259  : 
; 260  : 				if (IsDeviceMounted (devName))

  00285	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  0028b	50		 push	 eax
  0028c	e8 00 00 00 00	 call	 _IsDeviceMounted
  00291	83 c4 04	 add	 esp, 4
  00294	85 c0		 test	 eax, eax
  00296	74 0b		 je	 SHORT $LN17@CheckRequi

; 261  : 					ShowInPlaceEncErrMsgWAltSteps ("ONLY_NTFS_SUPPORTED_FOR_NONSYS_INPLACE_ENC", FALSE);

  00298	56		 push	 esi
  00299	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@COOAAIGJ@ONLY_NTFS_SUPPORTED_FOR_NONSYS_I@

; 262  : 				else

  0029e	e9 2f 01 00 00	 jmp	 $LN66@CheckRequi
$LN17@CheckRequi:

; 263  : 					Warning ("ONLY_MOUNTED_VOL_SUPPORTED_FOR_NONSYS_INPLACE_ENC");

  002a3	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@BPGKKGKD@ONLY_MOUNTED_VOL_SUPPORTED_FOR_N@
  002a8	e8 00 00 00 00	 call	 _Warning
  002ad	83 c4 04	 add	 esp, 4

; 264  : 			}
; 265  : 
; 266  : 			CloseHandle (dev);
; 267  : 			return FALSE;

  002b0	e9 25 01 00 00	 jmp	 $LN31@CheckRequi
$LN15@CheckRequi:

; 268  : 		}
; 269  : 	}
; 270  : 
; 271  : 
; 272  : 	/* Attempt to determine whether the filesystem can be safely shrunk */
; 273  : 
; 274  : 	if (NewFileSysSizeAfterShrink (dev, devicePath, NULL, NULL, silent) == -1)

  002b5	56		 push	 esi
  002b6	6a 00		 push	 0
  002b8	6a 00		 push	 0
  002ba	53		 push	 ebx
  002bb	57		 push	 edi
  002bc	e8 00 00 00 00	 call	 ?NewFileSysSizeAfterShrink@@YA_JPAXPBDPA_JPAKH@Z ; NewFileSysSizeAfterShrink
  002c1	23 c2		 and	 eax, edx
  002c3	83 c4 14	 add	 esp, 20			; 00000014H
  002c6	83 f8 ff	 cmp	 eax, -1
  002c9	75 14		 jne	 SHORT $LN19@CheckRequi

; 275  : 	{
; 276  : 		// Cannot determine whether shrinking is required
; 277  : 		if (!silent)

  002cb	85 f6		 test	 esi, esi
  002cd	0f 85 07 01 00
	00		 jne	 $LN31@CheckRequi

; 278  : 			ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL_ALT", TRUE);

  002d3	6a 01		 push	 1
  002d5	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@

; 279  : 
; 280  : 		CloseHandle (dev);
; 281  : 		return FALSE;

  002da	e9 f3 00 00 00	 jmp	 $LN66@CheckRequi
$LN19@CheckRequi:

; 282  : 	}
; 283  : 
; 284  : 
; 285  : 	/* Partition size */
; 286  : 
; 287  : 	deviceSize = GetDeviceSize (devicePath);

  002df	53		 push	 ebx
  002e0	e8 00 00 00 00	 call	 _GetDeviceSize
  002e5	83 c4 04	 add	 esp, 4

; 288  : 	if (deviceSize < 0)

  002e8	85 d2		 test	 edx, edx
  002ea	7f 40		 jg	 SHORT $LN23@CheckRequi
  002ec	7c 04		 jl	 SHORT $LN61@CheckRequi
  002ee	85 c0		 test	 eax, eax
  002f0	73 1a		 jae	 SHORT $LN21@CheckRequi
$LN61@CheckRequi:

; 289  : 	{
; 290  : 		// Cannot determine the size of the partition
; 291  : 		if (!silent)

  002f2	85 f6		 test	 esi, esi
  002f4	0f 85 e0 00 00
	00		 jne	 $LN31@CheckRequi

; 292  : 			Error ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL");

  002fa	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  002ff	e8 00 00 00 00	 call	 _Error
  00304	83 c4 04	 add	 esp, 4

; 293  : 
; 294  : 		CloseHandle (dev);
; 295  : 		return FALSE;

  00307	e9 ce 00 00 00	 jmp	 $LN31@CheckRequi
$LN21@CheckRequi:

; 296  : 	}
; 297  : 
; 298  : 	if (deviceSize < GST_NONSYS_INPLACE_ENC_MIN_VOL_SIZE)

  0030c	85 d2		 test	 edx, edx
  0030e	7f 1c		 jg	 SHORT $LN23@CheckRequi
  00310	7c 07		 jl	 SHORT $LN62@CheckRequi
  00312	3d 00 80 72 00	 cmp	 eax, 7503872		; 00728000H
  00317	73 13		 jae	 SHORT $LN23@CheckRequi
$LN62@CheckRequi:

; 299  : 	{
; 300  : 		// The partition is too small
; 301  : 		if (!silent)

  00319	85 f6		 test	 esi, esi
  0031b	0f 85 b9 00 00
	00		 jne	 $LN31@CheckRequi

; 302  : 		{
; 303  : 			ShowInPlaceEncErrMsgWAltSteps ("PARTITION_TOO_SMALL_FOR_NONSYS_INPLACE_ENC", FALSE);

  00321	56		 push	 esi
  00322	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@EKBFECDJ@PARTITION_TOO_SMALL_FOR_NONSYS_I@

; 304  : 		}
; 305  : 
; 306  : 		CloseHandle (dev);
; 307  : 		return FALSE;

  00327	e9 a6 00 00 00	 jmp	 $LN66@CheckRequi
$LN23@CheckRequi:

; 308  : 	}
; 309  : 
; 310  : 
; 311  : 	/* Free space on the filesystem */
; 312  : 
; 313  : 	if (!DeviceIoControl (dev,

  0032c	6a 00		 push	 0
  0032e	8d 85 7c fa ff
	ff		 lea	 eax, DWORD PTR _nBytesReturned$[ebp]
  00334	50		 push	 eax
  00335	6a 60		 push	 96			; 00000060H
  00337	8d 85 8c fa ff
	ff		 lea	 eax, DWORD PTR _ntfsVolData$[ebp]
  0033d	50		 push	 eax
  0033e	6a 00		 push	 0
  00340	6a 00		 push	 0
  00342	68 64 00 09 00	 push	 589924			; 00090064H
  00347	57		 push	 edi
  00348	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0034e	85 c0		 test	 eax, eax
  00350	75 11		 jne	 SHORT $LN25@CheckRequi

; 314  : 		FSCTL_GET_NTFS_VOLUME_DATA,
; 315  : 		NULL,
; 316  : 		0,
; 317  : 		(LPVOID) &ntfsVolData,
; 318  : 		sizeof (ntfsVolData),   
; 319  : 		&nBytesReturned,
; 320  : 		NULL))
; 321  : 	{
; 322  : 		if (!silent)

  00352	85 f6		 test	 esi, esi
  00354	0f 85 80 00 00
	00		 jne	 $LN31@CheckRequi

; 323  : 			ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL", TRUE);

  0035a	6a 01		 push	 1
  0035c	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@

; 324  : 
; 325  : 		CloseHandle (dev);
; 326  : 		return FALSE;

  00361	eb 6f		 jmp	 SHORT $LN66@CheckRequi
$LN25@CheckRequi:

; 327  : 	}
; 328  : 
; 329  : 	if (ntfsVolData.FreeClusters.QuadPart * ntfsVolData.BytesPerCluster < GST_TOTAL_VOLUME_HEADERS_SIZE)

  00363	ff b5 a8 fa ff
	ff		 push	 DWORD PTR _ntfsVolData$[ebp+28]
  00369	ff b5 a4 fa ff
	ff		 push	 DWORD PTR _ntfsVolData$[ebp+24]
  0036f	6a 00		 push	 0
  00371	ff b5 b8 fa ff
	ff		 push	 DWORD PTR _ntfsVolData$[ebp+44]
  00377	e8 00 00 00 00	 call	 __allmul
  0037c	85 d2		 test	 edx, edx
  0037e	7f 16		 jg	 SHORT $LN27@CheckRequi
  00380	7c 07		 jl	 SHORT $LN63@CheckRequi
  00382	3d 00 00 04 00	 cmp	 eax, 262144		; 00040000H
  00387	73 0d		 jae	 SHORT $LN27@CheckRequi
$LN63@CheckRequi:

; 330  : 	{
; 331  : 		if (!silent)

  00389	85 f6		 test	 esi, esi
  0038b	75 4d		 jne	 SHORT $LN31@CheckRequi

; 332  : 			ShowInPlaceEncErrMsgWAltSteps ("NOT_ENOUGH_FREE_FILESYS_SPACE_FOR_SHRINK", TRUE);

  0038d	6a 01		 push	 1
  0038f	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DJNLKEPP@NOT_ENOUGH_FREE_FILESYS_SPACE_FO@

; 333  : 
; 334  : 		CloseHandle (dev);
; 335  : 		return FALSE;

  00394	eb 3c		 jmp	 SHORT $LN66@CheckRequi
$LN27@CheckRequi:

; 336  : 	}
; 337  : 
; 338  : 
; 339  : 	/* Filesystem sector size */
; 340  : 
; 341  : 	if (ntfsVolData.BytesPerSector > GST_MAX_VOLUME_SECTOR_SIZE
; 342  : 		|| ntfsVolData.BytesPerSector % ENCRYPTION_DATA_UNIT_SIZE != 0)

  00396	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _ntfsVolData$[ebp+40]
  0039c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  003a1	77 24		 ja	 SHORT $LN30@CheckRequi
  003a3	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  003a8	75 1d		 jne	 SHORT $LN30@CheckRequi

; 349  : 	}
; 350  : 
; 351  : 	CloseHandle (dev);

  003aa	57		 push	 edi
  003ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  003b1	5f		 pop	 edi
  003b2	5e		 pop	 esi

; 352  : 	return TRUE;

  003b3	b8 01 00 00 00	 mov	 eax, 1
  003b8	5b		 pop	 ebx

; 353  : 
; 354  : }

  003b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bc	33 cd		 xor	 ecx, ebp
  003be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c3	8b e5		 mov	 esp, ebp
  003c5	5d		 pop	 ebp
  003c6	c3		 ret	 0
$LN30@CheckRequi:

; 343  : 	{
; 344  : 		if (!silent)

  003c7	85 f6		 test	 esi, esi
  003c9	75 0f		 jne	 SHORT $LN31@CheckRequi

; 345  : 			ShowInPlaceEncErrMsgWAltSteps ("SECTOR_SIZE_UNSUPPORTED", TRUE);

  003cb	6a 01		 push	 1
  003cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
$LN66@CheckRequi:
  003d2	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  003d7	83 c4 08	 add	 esp, 8
$LN31@CheckRequi:

; 346  : 
; 347  : 		CloseHandle (dev);

  003da	57		 push	 edi
  003db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN51@CheckRequi:

; 353  : 
; 354  : }

  003e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e4	33 c0		 xor	 eax, eax
  003e6	5f		 pop	 edi
  003e7	5e		 pop	 esi
  003e8	33 cd		 xor	 ecx, ebp
  003ea	5b		 pop	 ebx
  003eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f0	8b e5		 mov	 esp, ebp
  003f2	5d		 pop	 ebp
  003f3	c3		 ret	 0
_CheckRequirementsForNonSysInPlaceEnc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 29		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00014	72 23		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0e		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00020	50		 push	 eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 _memcpy
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0002b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002e	8b ce		 mov	 ecx, esi
  00030	40		 inc	 eax
  00031	50		 push	 eax
  00032	53		 push	 ebx
  00033	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  00038	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00039	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7

; 2261 : 		_Eos(_Newsize);

  00040	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00044	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00047	72 0e		 jb	 SHORT $LN94@Tidy
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	33 c9		 xor	 ecx, ecx
  0004d	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 2262 : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN94@Tidy:
  00057	33 c0		 xor	 eax, eax
  00059	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 2262 : 		}

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2e		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 08	 cmp	 eax, 8
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1c		 jb	 SHORT $LN4@Inside
  0001d	83 f8 08	 cmp	 eax, 8
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  0002e	3b c2		 cmp	 eax, edx
  00030	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00032	b0 01		 mov	 al, 1
  00034	5e		 pop	 esi

; 2244 : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 2244 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0000d	77 5b		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000f	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  00012	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00014	ff 71 10	 push	 DWORD PTR [ecx+16]
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0001d	85 f6		 test	 esi, esi
  0001f	5e		 pop	 esi
  00020	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00027	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0002b	74 1f		 je	 SHORT $LN5@Grow
  0002d	83 fe 08	 cmp	 esi, 8
  00030	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  00032	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00035	3b f0		 cmp	 esi, eax
  00037	0f 42 c6	 cmovb	 eax, esi
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00042	85 f6		 test	 esi, esi
  00044	5e		 pop	 esi
  00045	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  0004c	85 f6		 test	 esi, esi
  0004e	75 12		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  00050	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00054	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00057	72 02		 jb	 SHORT $LN80@Grow
  00059	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 f6		 test	 esi, esi
  0005f	66 89 01	 mov	 WORD PTR [ecx], ax
$LN88@Grow:
  00062	0f 95 c0	 setne	 al
  00065	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  00074	cc		 int	 3
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0c		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	33 c9		 xor	 ecx, ecx
  00013	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 2220 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  0001b	33 c0		 xor	 eax, eax
  0001d	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 2220 : 		}

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 07	 or	 edi, 7

; 2184 : 		if (max_size() < _Newres)

  00038	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  0003e	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  00040	8b f8		 mov	 edi, eax
  00042	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00044	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00047	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0004c	f7 e7		 mul	 edi
  0004e	8b cb		 mov	 ecx, ebx
  00050	d1 e9		 shr	 ecx, 1
  00052	d1 ea		 shr	 edx, 1
  00054	3b ca		 cmp	 ecx, edx
  00056	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00058	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005d	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  00060	2b c1		 sub	 eax, ecx
  00062	3b d8		 cmp	 ebx, eax
  00064	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00066	bf fe ff ff 7f	 mov	 edi, 2147483646		; 7ffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  0006b	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00075	50		 push	 eax
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  0007d	8b d0		 mov	 edx, eax
  0007f	eb 29		 jmp	 SHORT $LN429@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00081	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  0008a	40		 inc	 eax
  0008b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0008e	50		 push	 eax
  0008f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00093	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  00098	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  0009b	b8 00 00 00 00	 mov	 eax, $LN426@Copy
  000a0	c3		 ret	 0
$LN426@Copy:
  000a1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000a4	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000a7	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN429@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000aa	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000ad	89 55 e8	 mov	 DWORD PTR __Ptr$1$[ebp], edx
  000b0	85 db		 test	 ebx, ebx
  000b2	74 1e		 je	 SHORT $LN260@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000b4	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b8	72 04		 jb	 SHORT $LN251@Copy
  000ba	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000bc	eb 02		 jmp	 SHORT $LN252@Copy
$LN251@Copy:
  000be	8b ce		 mov	 ecx, esi
$LN252@Copy:
  000c0	85 db		 test	 ebx, ebx
  000c2	74 0e		 je	 SHORT $LN260@Copy
  000c4	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  000c7	50		 push	 eax
  000c8	51		 push	 ecx
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _memcpy
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN260@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  000d2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000d5	83 f8 08	 cmp	 eax, 8
  000d8	72 0b		 jb	 SHORT $LN266@Copy
  000da	40		 inc	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	50		 push	 eax
  000de	ff 36		 push	 DWORD PTR [esi]
  000e0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN266@Copy:
  000e5	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  000ec	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000f0	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000f7	72 04		 jb	 SHORT $LN356@Copy
  000f9	8b 06		 mov	 eax, DWORD PTR [esi]
  000fb	eb 02		 jmp	 SHORT $LN357@Copy
$LN356@Copy:
  000fd	8b c6		 mov	 eax, esi
$LN357@Copy:
  000ff	33 c9		 xor	 ecx, ecx
  00101	66 89 08	 mov	 WORD PTR [eax], cx

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);

  00104	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00107	89 06		 mov	 DWORD PTR [esi], eax

; 2212 : 		this->_Myres() = _Newres;

  00109	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 2213 : 		_Eos(_Oldlen);

  0010c	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00110	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00113	72 02		 jb	 SHORT $LN420@Copy
  00115	8b f0		 mov	 esi, eax
$LN420@Copy:
  00117	33 c0		 xor	 eax, eax
  00119	66 89 04 5e	 mov	 WORD PTR [esi+ebx*2], ax

; 2214 : 		}

  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00120	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00127	59		 pop	 ecx
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00131	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00134	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00137	83 f8 08	 cmp	 eax, 8
  0013a	72 0b		 jb	 SHORT $LN144@Copy
  0013c	40		 inc	 eax
  0013d	8b ce		 mov	 ecx, esi
  0013f	50		 push	 eax
  00140	ff 36		 push	 DWORD PTR [esi]
  00142	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN144@Copy:
  00147	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0014e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00152	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00159	72 02		 jb	 SHORT $LN235@Copy
  0015b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN235@Copy:
  0015d	33 c0		 xor	 eax, eax

; 2203 : 			_RERAISE;

  0015f	50		 push	 eax
  00160	50		 push	 eax
  00161	66 89 06	 mov	 WORD PTR [esi], ax
  00164	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN430@Copy:
$LN428@Copy:
  00169	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare, COMDAT
; _this$ = ecx

; 2144 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  0000b	75 04		 jne	 SHORT $LN5@compare
  0000d	33 d2		 xor	 edx, edx
  0000f	eb 16		 jmp	 SHORT $LN6@compare
$LN5@compare:
  00011	8b d6		 mov	 edx, esi
  00013	57		 push	 edi
  00014	8d 7a 02	 lea	 edi, DWORD PTR [edx+2]
$LL30@compare:
  00017	66 8b 02	 mov	 ax, WORD PTR [edx]
  0001a	83 c2 02	 add	 edx, 2
  0001d	66 85 c0	 test	 ax, ax
  00020	75 f5		 jne	 SHORT $LL30@compare
  00022	2b d7		 sub	 edx, edi
  00024	d1 fa		 sar	 edx, 1
  00026	5f		 pop	 edi
$LN6@compare:
  00027	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  0002b	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  0002e	72 02		 jb	 SHORT $LN26@compare
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN26@compare:
  00032	52		 push	 edx
  00033	56		 push	 esi
  00034	ff 30		 push	 DWORD PTR [eax]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 ?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	5e		 pop	 esi

; 2147 : 			_Ptr, _Traits::length(_Ptr)));
; 2148 : 		}

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare, COMDAT

; 2094 : 		{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Left_size$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 14	 mov	 edi, DWORD PTR __Right_size$[ebp]
  0000b	3b df		 cmp	 ebx, edi
  0000d	8b cf		 mov	 ecx, edi
  0000f	0f 42 cb	 cmovb	 ecx, ebx

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

  00012	85 c9		 test	 ecx, ecx
  00014	75 04		 jne	 SHORT $LN8@Traits_com
  00016	33 c0		 xor	 eax, eax
  00018	eb 21		 jmp	 SHORT $LN10@Traits_com
$LN8@Traits_com:
  0001a	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 08	 mov	 esi, DWORD PTR __Left$[ebp]
  00021	85 c9		 test	 ecx, ecx
  00023	74 13		 je	 SHORT $LN12@Traits_com
$LL13@Traits_com:
  00025	66 8b 06	 mov	 ax, WORD PTR [esi]
  00028	66 3b 02	 cmp	 ax, WORD PTR [edx]
  0002b	75 1d		 jne	 SHORT $LN17@Traits_com
  0002d	83 c6 02	 add	 esi, 2
  00030	83 c2 02	 add	 edx, 2
  00033	83 e9 01	 sub	 ecx, 1
  00036	75 ed		 jne	 SHORT $LL13@Traits_com
$LN12@Traits_com:
  00038	33 c0		 xor	 eax, eax
$LN21@Traits_com:
  0003a	5e		 pop	 esi
$LN10@Traits_com:

; 2097 : 
; 2098 : 		if (_Ans != 0)

  0003b	85 c0		 test	 eax, eax
  0003d	75 1d		 jne	 SHORT $LN4@Traits_com

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

  0003f	3b fb		 cmp	 edi, ebx
  00041	76 15		 jbe	 SHORT $LN22@Traits_com

; 2102 : 			return (-1);

  00043	5f		 pop	 edi
  00044	83 c8 ff	 or	 eax, -1
  00047	5b		 pop	 ebx

; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN17@Traits_com:

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

  0004a	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0004d	66 3b 02	 cmp	 ax, WORD PTR [edx]
  00050	1b c0		 sbb	 eax, eax
  00052	83 e0 fe	 and	 eax, -2			; fffffffeH
  00055	40		 inc	 eax
  00056	eb e2		 jmp	 SHORT $LN21@Traits_com
$LN22@Traits_com:

; 2103 : 
; 2104 : 		if (_Left_size > _Right_size)

  00058	1b c0		 sbb	 eax, eax
  0005a	f7 d8		 neg	 eax
$LN4@Traits_com:
  0005c	5f		 pop	 edi
  0005d	5b		 pop	 ebx

; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve, COMDAT
; _this$ = ecx

; 1793 : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcap$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f8		 cmp	 edi, eax
  0000f	77 22		 ja	 SHORT $LN47@reserve
  00011	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00014	74 1d		 je	 SHORT $LN47@reserve

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

  00016	6a 01		 push	 1
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
  0001e	84 c0		 test	 al, al
  00020	74 11		 je	 SHORT $LN47@reserve

; 1798 : 				_Eos(_Size);

  00022	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00026	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00029	72 02		 jb	 SHORT $LN42@reserve
  0002b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN42@reserve:
  0002d	33 c0		 xor	 eax, eax
  0002f	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax
$LN47@reserve:
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 1799 : 			}
; 1800 : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1766 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1680 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1681 : 		if (this->_Mysize() < _Off)	// sic
; 1682 : 			_DEBUG_ERROR("string subscript out of range");
; 1683 : 
; 1684 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1685 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1686 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1687 : 
; 1688 : 		return (this->_Myptr()[_Off]);

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	72 02		 jb	 SHORT $LN13@operator
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@operator:
  0000e	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 1689 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	0f 82 88 00 00
	00		 jb	 $LN95@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00018	8b c7		 mov	 eax, edi
  0001a	2b c1		 sub	 eax, ecx
  0001c	3b c2		 cmp	 eax, edx
  0001e	77 27		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00027	72 10		 jb	 SHORT $LN41@erase
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	33 d2		 xor	 edx, edx
  0002d	5f		 pop	 edi
  0002e	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1357 : 			}
; 1358 : 		return (*this);

  00032	8b c6		 mov	 eax, esi
  00034	5e		 pop	 esi

; 1359 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00039	8b c6		 mov	 eax, esi
  0003b	33 d2		 xor	 edx, edx
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1359 : 		}

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  00047	85 d2		 test	 edx, edx
  00049	74 4a		 je	 SHORT $LN92@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  0004b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004f	72 04		 jb	 SHORT $LN58@erase
  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  00055	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  00057	2b fa		 sub	 edi, edx
  00059	53		 push	 ebx
  0005a	8d 1c 48	 lea	 ebx, DWORD PTR [eax+ecx*2]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  0005d	8b c7		 mov	 eax, edi
  0005f	2b c1		 sub	 eax, ecx
  00061	74 10		 je	 SHORT $LN74@erase
  00063	03 c0		 add	 eax, eax
  00065	50		 push	 eax
  00066	8d 04 53	 lea	 eax, DWORD PTR [ebx+edx*2]
  00069	50		 push	 eax
  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _memmove
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00073	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	5b		 pop	 ebx
  0007b	72 10		 jb	 SHORT $LN87@erase
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	33 c9		 xor	 ecx, ecx
  00081	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1357 : 			}
; 1358 : 		return (*this);

  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 1359 : 		}

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN87@erase:
  0008d	8b c6		 mov	 eax, esi
  0008f	33 c9		 xor	 ecx, ecx
  00091	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN92@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00095	5f		 pop	 edi
  00096	8b c6		 mov	 eax, esi
  00098	5e		 pop	 esi

; 1359 : 		}

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
$LN95@erase:

; 1348 : 		_Check_offset(_Off);

  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000a2	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN97@erase:
$LN94@erase:
  000a7	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 29		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00012	72 10		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	56		 push	 esi
  00017	33 f6		 xor	 esi, esi
  00019	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0001d	8b c1		 mov	 eax, ecx
  0001f	5e		 pop	 esi

; 1344 : 		}

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00024	8b d1		 mov	 edx, ecx
  00026	56		 push	 esi
  00027	33 f6		 xor	 esi, esi
  00029	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0002d	8b c1		 mov	 eax, ecx
  0002f	5e		 pop	 esi

; 1344 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00039	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  0003e	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN5@assign
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00018	5e		 pop	 esi

; 1183 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL7@assign:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL7@assign
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003c	5e		 pop	 esi

; 1183 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 48		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 08	 cmp	 ecx, 8
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 36		 jb	 SHORT $LN2@assign
  00020	83 f9 08	 cmp	 ecx, 8
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00031	3b c3		 cmp	 eax, ebx
  00033	76 21		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00035	83 f9 08	 cmp	 ecx, 8
  00038	72 04		 jb	 SHORT $LN57@assign
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN58@assign
$LN57@assign:
  0003e	8b c6		 mov	 eax, esi
$LN58@assign:
  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	2b d8		 sub	 ebx, eax
  00045	8b ce		 mov	 ecx, esi
  00047	d1 fb		 sar	 ebx, 1
  00049	53		 push	 ebx
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 1177 : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN2@assign:
  00056	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00057	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 88 00 00
	00		 ja	 $LN189@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 19		 jae	 SHORT $LN63@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	85 ff		 test	 edi, edi
  00078	74 6b		 je	 SHORT $LN183@assign
$LN188@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 2f		 jb	 SHORT $LN158@assign
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	eb 2d		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  00084	85 ff		 test	 edi, edi
  00086	75 f2		 jne	 SHORT $LN188@assign
  00088	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0008c	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0008f	72 10		 jb	 SHORT $LN140@assign
  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	33 c9		 xor	 ecx, ecx
  00095	5f		 pop	 edi
  00096	66 89 08	 mov	 WORD PTR [eax], cx

; 1175 : 			}
; 1176 : 		return (*this);

  00099	8b c6		 mov	 eax, esi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx

; 1177 : 		}

  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a1	8b c6		 mov	 eax, esi
  000a3	33 c9		 xor	 ecx, ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	66 89 08	 mov	 WORD PTR [eax], cx

; 1177 : 		}

  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000af	8b ce		 mov	 ecx, esi
$LN159@assign:
  000b1	85 ff		 test	 edi, edi
  000b3	74 0e		 je	 SHORT $LN165@assign
  000b5	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000b8	50		 push	 eax
  000b9	53		 push	 ebx
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c3	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c7	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ca	72 11		 jb	 SHORT $LN178@assign
  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
  000ce	33 c9		 xor	 ecx, ecx
  000d0	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1175 : 			}
; 1176 : 		return (*this);

  000d4	8b c6		 mov	 eax, esi
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 1177 : 		}

  000d9	5d		 pop	 ebp
  000da	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN178@assign:
  000dd	8b c6		 mov	 eax, esi
  000df	33 c9		 xor	 ecx, ecx
  000e1	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN183@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e5	5f		 pop	 edi
  000e6	8b c6		 mov	 eax, esi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 1177 : 		}

  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
$LN189@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN191@assign:
$LN186@assign:
  000f8	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e3 00 00
	00		 jb	 $LN210@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 33		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d3 00 00
	00		 jb	 $LN212@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0003a	72 04		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	eb 02		 jmp	 SHORT $LN64@assign
$LN63@assign:
  00040	8b d6		 mov	 edx, esi
$LN64@assign:
  00042	33 ff		 xor	 edi, edi
  00044	51		 push	 ecx
  00045	57		 push	 edi
  00046	8b ce		 mov	 ecx, esi
  00048	66 89 3c 42	 mov	 WORD PTR [edx+eax*2], di
  0004c	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
  00051	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00052	8b c6		 mov	 eax, esi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 1162 : 		}

  00056	5d		 pop	 ebp
  00057	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 aa 00 00
	00		 ja	 $LN213@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 24		 jae	 SHORT $LN72@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00079	85 ff		 test	 edi, edi
  0007b	74 76		 je	 SHORT $LN205@assign
$LN209@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0007d	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00081	72 02		 jb	 SHORT $LN166@assign
  00083	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00085	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00089	72 2f		 jb	 SHORT $LN180@assign
  0008b	8b 16		 mov	 edx, DWORD PTR [esi]
  0008d	eb 2d		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  0008f	85 ff		 test	 edi, edi
  00091	75 ea		 jne	 SHORT $LN209@assign
  00093	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00097	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0009a	72 10		 jb	 SHORT $LN149@assign
  0009c	8b 06		 mov	 eax, DWORD PTR [esi]
  0009e	33 c9		 xor	 ecx, ecx
  000a0	5f		 pop	 edi
  000a1	66 89 08	 mov	 WORD PTR [eax], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 1162 : 		}

  000a8	5d		 pop	 ebp
  000a9	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000ac	8b c6		 mov	 eax, esi
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	66 89 08	 mov	 WORD PTR [eax], cx

; 1162 : 		}

  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000ba	8b d6		 mov	 edx, esi
$LN181@assign:
  000bc	85 ff		 test	 edi, edi
  000be	74 11		 je	 SHORT $LN187@assign
  000c0	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000c3	50		 push	 eax
  000c4	8d 04 4b	 lea	 eax, DWORD PTR [ebx+ecx*2]
  000c7	50		 push	 eax
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _memcpy
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000d1	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d8	72 11		 jb	 SHORT $LN200@assign
  000da	8b 06		 mov	 eax, DWORD PTR [esi]
  000dc	33 c9		 xor	 ecx, ecx
  000de	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000e2	8b c6		 mov	 eax, esi
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1162 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN200@assign:
  000eb	8b c6		 mov	 eax, esi
  000ed	33 c9		 xor	 ecx, ecx
  000ef	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN205@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f3	5f		 pop	 edi
  000f4	8b c6		 mov	 eax, esi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx

; 1162 : 		}

  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
$LN210@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00101	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN214@assign:
$LN212@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0010b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN215@assign:
$LN213@assign:

; 1155 : 		else if (_Grow(_Count))

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00115	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN216@assign:
$LN207@assign:
  0011a	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN5@append
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00018	5e		 pop	 esi

; 1108 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

$LN5@append:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL7@append:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL7@append
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0003c	5e		 pop	 esi

; 1108 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1088 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1089 : 		if (_Inside(_Ptr))

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	74 48		 je	 SHORT $LN2@append
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 08	 cmp	 ecx, 8
  00014	72 04		 jb	 SHORT $LN21@append
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN22@append
$LN21@append:
  0001a	8b c6		 mov	 eax, esi
$LN22@append:
  0001c	3b f8		 cmp	 edi, eax
  0001e	72 36		 jb	 SHORT $LN2@append
  00020	83 f9 08	 cmp	 ecx, 8
  00023	72 04		 jb	 SHORT $LN35@append
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN36@append
$LN35@append:
  00029	8b d6		 mov	 edx, esi
$LN36@append:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00031	3b c7		 cmp	 eax, edi
  00033	76 21		 jbe	 SHORT $LN2@append

; 1090 : 			return (append(*this,

  00035	83 f9 08	 cmp	 ecx, 8
  00038	72 04		 jb	 SHORT $LN58@append
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN59@append
$LN58@append:
  0003e	8b c6		 mov	 eax, esi
$LN59@append:
  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	2b f8		 sub	 edi, eax
  00045	8b ce		 mov	 ecx, esi
  00047	d1 ff		 sar	 edi, 1
  00049	57		 push	 edi
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 1102 : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

  00056	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00059	8b c2		 mov	 eax, edx
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005e	f7 d0		 not	 eax
  00060	3b c1		 cmp	 eax, ecx
  00062	0f 86 a7 00 00
	00		 jbe	 $LN219@append

; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

  00068	53		 push	 ebx
  00069	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

  0006c	85 c9		 test	 ecx, ecx
  0006e	0f 84 92 00 00
	00		 je	 $LN213@append
  00074	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  0007a	0f 87 99 00 00
	00		 ja	 $LN221@append
  00080	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00083	73 1a		 jae	 SHORT $LN85@append
  00085	52		 push	 edx
  00086	53		 push	 ebx
  00087	8b ce		 mov	 ecx, esi
  00089	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00091	85 db		 test	 ebx, ebx
  00093	74 71		 je	 SHORT $LN213@append
$LN218@append:

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

  00095	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00099	72 2f		 jb	 SHORT $LN179@append
  0009b	8b 16		 mov	 edx, DWORD PTR [esi]
  0009d	eb 2d		 jmp	 SHORT $LN180@append

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN85@append:
  0009f	85 db		 test	 ebx, ebx
  000a1	75 f2		 jne	 SHORT $LN218@append
  000a3	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000a6	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000aa	72 10		 jb	 SHORT $LN162@append
  000ac	8b 06		 mov	 eax, DWORD PTR [esi]
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5b		 pop	 ebx
  000b1	5f		 pop	 edi
  000b2	66 89 08	 mov	 WORD PTR [eax], cx

; 1100 : 			}
; 1101 : 		return (*this);

  000b5	8b c6		 mov	 eax, esi
  000b7	5e		 pop	 esi

; 1102 : 		}

  000b8	5d		 pop	 ebp
  000b9	c2 08 00	 ret	 8

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN162@append:
  000bc	8b c6		 mov	 eax, esi
  000be	33 c9		 xor	 ecx, ecx
  000c0	5b		 pop	 ebx
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	66 89 08	 mov	 WORD PTR [eax], cx

; 1102 : 		}

  000c6	5d		 pop	 ebp
  000c7	c2 08 00	 ret	 8

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

$LN179@append:
  000ca	8b d6		 mov	 edx, esi
$LN180@append:
  000cc	85 c9		 test	 ecx, ecx
  000ce	74 14		 je	 SHORT $LN195@append
  000d0	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  000d3	50		 push	 eax
  000d4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d7	57		 push	 edi
  000d8	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _memcpy
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN195@append:

; 1099 : 			_Eos(_Num);

  000e4	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000e8	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000eb	72 11		 jb	 SHORT $LN208@append
  000ed	8b 06		 mov	 eax, DWORD PTR [esi]
  000ef	33 c9		 xor	 ecx, ecx
  000f1	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx

; 1100 : 			}
; 1101 : 		return (*this);

  000f5	8b c6		 mov	 eax, esi
  000f7	5b		 pop	 ebx
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 1102 : 		}

  000fa	5d		 pop	 ebp
  000fb	c2 08 00	 ret	 8

; 1099 : 			_Eos(_Num);

$LN208@append:
  000fe	8b c6		 mov	 eax, esi
  00100	33 c9		 xor	 ecx, ecx
  00102	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN213@append:

; 1100 : 			}
; 1101 : 		return (*this);

  00106	5b		 pop	 ebx
  00107	5f		 pop	 edi
  00108	8b c6		 mov	 eax, esi
  0010a	5e		 pop	 esi

; 1102 : 		}

  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
$LN219@append:

; 1093 : 			_Xlen();	// result too long

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00114	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN222@append:
$LN221@append:

; 1096 : 		if (0 < _Count && _Grow(_Num))

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN223@append:
$LN216@append:
  00123	cc		 int	 3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1071 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 d0 00 00
	00		 jb	 $LN203@append

; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

  00019	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	3b c8		 cmp	 ecx, eax
  00023	0f 47 c8	 cmova	 ecx, eax
  00026	8b c2		 mov	 eax, edx
  00028	f7 d0		 not	 eax
  0002a	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx
  0002d	3b c1		 cmp	 eax, ecx
  0002f	0f 86 be 00 00
	00		 jbe	 $LN205@append

; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

  00035	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

  00038	85 c9		 test	 ecx, ecx
  0003a	0f 84 a0 00 00
	00		 je	 $LN198@append
  00040	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00046	0f 87 b1 00 00
	00		 ja	 $LN206@append
  0004c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0004f	73 22		 jae	 SHORT $LN56@append
  00051	52		 push	 edx
  00052	57		 push	 edi
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0005a	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005d	85 ff		 test	 edi, edi
  0005f	74 7f		 je	 SHORT $LN198@append
$LN202@append:

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

  00061	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00065	72 02		 jb	 SHORT $LN150@append
  00067	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN150@append:
  00069	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0006d	72 2f		 jb	 SHORT $LN164@append
  0006f	8b 16		 mov	 edx, DWORD PTR [esi]
  00071	eb 2d		 jmp	 SHORT $LN165@append

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN56@append:
  00073	85 ff		 test	 edi, edi
  00075	75 ea		 jne	 SHORT $LN202@append
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 10		 jb	 SHORT $LN133@append
  00080	8b 06		 mov	 eax, DWORD PTR [esi]
  00082	33 c9		 xor	 ecx, ecx
  00084	5f		 pop	 edi
  00085	66 89 08	 mov	 WORD PTR [eax], cx

; 1082 : 			}
; 1083 : 		return (*this);

  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1084 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 0c 00	 ret	 12			; 0000000cH

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN133@append:
  00090	8b c6		 mov	 eax, esi
  00092	33 c9		 xor	 ecx, ecx
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	66 89 08	 mov	 WORD PTR [eax], cx

; 1084 : 		}

  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

$LN164@append:
  0009e	8b d6		 mov	 edx, esi
$LN165@append:
  000a0	85 c9		 test	 ecx, ecx
  000a2	74 1a		 je	 SHORT $LN180@append
  000a4	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  000a7	50		 push	 eax
  000a8	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000ab	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  000ae	50		 push	 eax
  000af	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b2	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _memcpy
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@append:

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

  000be	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c2	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000c5	72 11		 jb	 SHORT $LN193@append
  000c7	8b 06		 mov	 eax, DWORD PTR [esi]
  000c9	33 c9		 xor	 ecx, ecx
  000cb	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1082 : 			}
; 1083 : 		return (*this);

  000cf	8b c6		 mov	 eax, esi
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 1084 : 		}

  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

$LN193@append:
  000d8	8b c6		 mov	 eax, esi
  000da	33 c9		 xor	 ecx, ecx
  000dc	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN198@append:

; 1082 : 			}
; 1083 : 		return (*this);

  000e0	5f		 pop	 edi
  000e1	8b c6		 mov	 eax, esi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx

; 1084 : 		}

  000e5	5d		 pop	 ebp
  000e6	c2 0c 00	 ret	 12			; 0000000cH
$LN203@append:

; 1071 : 		_Right._Check_offset(_Roff);

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000ee	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN207@append:
$LN205@append:

; 1074 : 			_Xlen();	// result too long

  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f8	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN208@append:
$LN206@append:

; 1077 : 		if (0 < _Count && _Grow(_Num))

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00102	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN209@append:
$LN200@append:
  00107	cc		 int	 3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1064 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1066 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 1054 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1055 : 		return (append(_Ptr));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN7@operator
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00018	5e		 pop	 esi

; 1056 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1055 : 		return (append(_Ptr));

$LN7@operator:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL9@operator:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL9@operator
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0003c	5e		 pop	 esi

; 1056 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 1049 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1050 : 		return (append(_Right));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1051 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 08	 cmp	 eax, 8
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 09		 jb	 SHORT $LN96@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	5e		 pop	 esi
  0002d	66 89 08	 mov	 WORD PTR [eax], cx

; 1018 : 		}

  00030	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN96@basic_stri:
  00031	33 c0		 xor	 eax, eax
  00033	66 89 06	 mov	 WORD PTR [esi], ax
  00036	5e		 pop	 esi

; 1018 : 		}

  00037	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0000e	73 17		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1d		 je	 SHORT $LN3@Assign_rv
  00018	03 c0		 add	 eax, eax
  0001a	50		 push	 eax
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00025	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00027	85 ff		 test	 edi, edi
  00029	74 04		 je	 SHORT $LN86@Assign_rv
  0002b	8b 06		 mov	 eax, DWORD PTR [esi]
  0002d	89 07		 mov	 DWORD PTR [edi], eax
$LN86@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00035	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00038	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  0003b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003e	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00053	72 0d		 jb	 SHORT $LN231@Assign_rv
  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	33 c9		 xor	 ecx, ecx
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	66 89 08	 mov	 WORD PTR [eax], cx

; 973  : 		}

  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN231@Assign_rv:
  00062	33 c0		 xor	 eax, eax
  00064	5f		 pop	 edi
  00065	66 89 06	 mov	 WORD PTR [esi], ax
  00068	5e		 pop	 esi

; 973  : 		}

  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv

; 914  : 		}

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	66 39 02	 cmp	 WORD PTR [edx], ax
  0001f	75 12		 jne	 SHORT $LN113@basic_stri
  00021	33 c9		 xor	 ecx, ecx
  00023	51		 push	 ecx
  00024	52		 push	 edx
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN113@basic_stri:
  00033	8b ca		 mov	 ecx, edx
  00035	57		 push	 edi
  00036	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL115@basic_stri:
  00040	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00043	83 c1 02	 add	 ecx, 2
  00046	66 85 c0	 test	 ax, ax
  00049	75 f5		 jne	 SHORT $LL115@basic_stri
  0004b	2b cf		 sub	 ecx, edi
  0004d	d1 f9		 sar	 ecx, 1
  0004f	5f		 pop	 edi
  00050	51		 push	 ecx
  00051	52		 push	 edx
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 795  : 		_Tidy();

  00000	33 c0		 xor	 eax, eax
  00002	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	66 89 01	 mov	 WORD PTR [ecx], ax

; 796  : 		}

  00013	8b c1		 mov	 eax, ecx
  00015	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN16@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN7@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN18@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN19@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN20@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN21@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  00059	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00013	77 3b		 ja	 SHORT $LN14@allocate
  00015	03 c0		 add	 eax, eax
  00017	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001c	72 23		 jb	 SHORT $LN6@allocate
  0001e	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00021	3b c8		 cmp	 ecx, eax
  00023	76 30		 jbe	 SHORT $LN16@allocate
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	8b c8		 mov	 ecx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c9		 test	 ecx, ecx
  00032	74 26		 je	 SHORT $LN17@allocate
  00034	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00037	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003a	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00047	83 c4 04	 add	 esp, 4
  0004a	85 c0		 test	 eax, eax
  0004c	75 bc		 jne	 SHORT $LN12@allocate
  0004e	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00050	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00055	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN13@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN5@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN15@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN16@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN17@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN18@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00059	cc		 int	 3
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 95   : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 133  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 67   : 			_Xbad_alloc();	// report no memory
; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 344  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 345  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	66 89 08	 mov	 WORD PTR [eax], cx

; 346  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 332  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 333  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  00014	5d		 pop	 ebp

; 333  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 309  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 310  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  00014	5d		 pop	 ebp

; 310  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIPB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 302  : 		{	// find length of null-terminated sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 303  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0000a	75 04		 jne	 SHORT $LN3@length
  0000c	33 c0		 xor	 eax, eax

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN3@length:

; 303  : 		return (*_First == 0 ? 0

  00010	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL5@length:
  00013	66 8b 08	 mov	 cx, WORD PTR [eax]
  00016	83 c0 02	 add	 eax, 2
  00019	66 85 c9	 test	 cx, cx
  0001c	75 f5		 jne	 SHORT $LL5@length
  0001e	2b c2		 sub	 eax, edx
  00020	d1 f8		 sar	 eax, 1

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?length@?$char_traits@_W@std@@SAIPB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@_W@std@@SAHPB_W0I@Z PROC		; std::char_traits<wchar_t>::compare, COMDAT

; 296  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 297  : 		return (_Count == 0 ? 0

  00004	8b 75 10	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 19		 je	 SHORT $LN7@compare
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000e	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
$LL8@compare:
  00011	66 8b 02	 mov	 ax, WORD PTR [edx]
  00014	66 3b 01	 cmp	 ax, WORD PTR [ecx]
  00017	75 10		 jne	 SHORT $LN12@compare
  00019	83 c2 02	 add	 edx, 2
  0001c	83 c1 02	 add	 ecx, 2
  0001f	83 ee 01	 sub	 esi, 1
  00022	75 ed		 jne	 SHORT $LL8@compare
$LN7@compare:
  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi

; 298  : 			: _CSTD wmemcmp(_First1, _First2, _Count));
; 299  : 		}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN12@compare:

; 297  : 		return (_Count == 0 ? 0

  00029	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0002c	66 3b 01	 cmp	 ax, WORD PTR [ecx]
  0002f	5e		 pop	 esi
  00030	1b c0		 sbb	 eax, eax
  00032	83 e0 fe	 and	 eax, -2			; fffffffeH
  00035	40		 inc	 eax

; 298  : 			: _CSTD wmemcmp(_First1, _First2, _Count));
; 299  : 		}

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ENDP		; std::char_traits<wchar_t>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC						; COMDAT

; 244  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 248  :         #pragma warning(pop)
; 249  :     }

  0000b	5d		 pop	 ebp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memmove
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 231  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 235  :         #pragma warning(pop)
; 236  :     }

  0000b	5d		 pop	 ebp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memcpy
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcmp
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcmp PROC						; COMDAT

; 215  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

  00004	8b 75 10	 mov	 esi, DWORD PTR __N$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 19		 je	 SHORT $LN3@wmemcmp
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  0000e	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
$LL4@wmemcmp:

; 217  :             if (*_S1 != *_S2)

  00011	66 8b 02	 mov	 ax, WORD PTR [edx]
  00014	66 3b 01	 cmp	 ax, WORD PTR [ecx]
  00017	75 10		 jne	 SHORT $LN8@wmemcmp

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

  00019	83 c2 02	 add	 edx, 2
  0001c	83 c1 02	 add	 ecx, 2
  0001f	83 ee 01	 sub	 esi, 1
  00022	75 ed		 jne	 SHORT $LL4@wmemcmp
$LN3@wmemcmp:

; 219  : 
; 220  :         return 0;

  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi

; 221  :     }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN8@wmemcmp:

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

  00029	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0002c	66 3b 01	 cmp	 ax, WORD PTR [ecx]
  0002f	5e		 pop	 esi
  00030	1b c0		 sbb	 eax, eax
  00032	83 e0 fe	 and	 eax, -2			; fffffffeH
  00035	40		 inc	 eax

; 221  :     }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_wmemcmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2262 :     int _Result;
; 2263 :     va_list _ArgList;
; 2264 :     __crt_va_start(_ArgList, _Format);
; 2265 :     _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vsscanf
  00020	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2266 :     __crt_va_end(_ArgList);
; 2267 :     return _Result;
; 2268 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2166 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2167 :     return __stdio_common_vsscanf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vsscanf
  00020	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2168 :         _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2169 :         _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2170 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 83   :     static unsigned __int64 _OptionsStorage;
; 84   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 85   : }

  00005	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
