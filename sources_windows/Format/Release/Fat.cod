; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\Fat.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_GetFatParams
PUBLIC	_PutBoot
PUBLIC	_FormatFat
PUBLIC	??_C@_08PGBLPCGG@MSDOS5?40?$AA@			; `string'
PUBLIC	??_C@_08JPOPGMJJ@FAT12?5?5?5?$AA@		; `string'
PUBLIC	??_C@_08GKGPMKFJ@FAT16?5?5?5?$AA@		; `string'
PUBLIC	??_C@_08NCCHMNJC@FAT32?5?5?5?$AA@		; `string'
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	_EAInit:PROC
EXTRN	_EAInitMode:PROC
EXTRN	_EAGetKeySize:PROC
EXTRN	_WriteSector:PROC
EXTRN	_FlushFormatWriteBuffer:PROC
EXTRN	_UpdateProgressBar:PROC
EXTRN	_RandgetBytes:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__aulldiv:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_FormatWriteBufferSize:DWORD
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_08NCCHMNJC@FAT32?5?5?5?$AA@
CONST	SEGMENT
??_C@_08NCCHMNJC@FAT32?5?5?5?$AA@ DB 'FAT32   ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GKGPMKFJ@FAT16?5?5?5?$AA@
CONST	SEGMENT
??_C@_08GKGPMKFJ@FAT16?5?5?5?$AA@ DB 'FAT16   ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPOPGMJJ@FAT12?5?5?5?$AA@
CONST	SEGMENT
??_C@_08JPOPGMJJ@FAT12?5?5?5?$AA@ DB 'FAT12   ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PGBLPCGG@MSDOS5?40?$AA@
CONST	SEGMENT
??_C@_08PGBLPCGG@MSDOS5?40?$AA@ DB 'MSDOS5.0', 00H	; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\fat.c
;	COMDAT _PutFSInfo
_TEXT	SEGMENT
_sector$ = 8						; size = 4
_ft$ = 12						; size = 4
_PutFSInfo PROC						; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 269  : 	memset (sector, 0, ft->sector_size);

  00004	8b 75 0c	 mov	 esi, DWORD PTR _ft$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR _sector$[ebp]
  0000b	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  0000f	50		 push	 eax
  00010	6a 00		 push	 0
  00012	57		 push	 edi
  00013	e8 00 00 00 00	 call	 _memset

; 270  : 	sector[3]=0x41; /* LeadSig */
; 271  : 	sector[2]=0x61; 
; 272  : 	sector[1]=0x52; 
; 273  : 	sector[0]=0x52; 

  00018	c7 07 52 52 61
	41		 mov	 DWORD PTR [edi], 1096897106 ; 41615252H
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 274  : 	sector[484+3]=0x61; /* StrucSig */
; 275  : 	sector[484+2]=0x41; 
; 276  : 	sector[484+1]=0x72; 
; 277  : 	sector[484+0]=0x72; 

  00021	c7 87 e4 01 00
	00 72 72 41 61	 mov	 DWORD PTR [edi+484], 1631679090 ; 61417272H

; 278  : 
; 279  : 	// Free cluster count
; 280  : 	*(uint32 *)(sector + 488) = LE32 (ft->cluster_count - ft->size_root_dir / ft->sector_size / ft->cluster_size);

  0002b	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0002e	0f b7 4e 32	 movzx	 ecx, WORD PTR [esi+50]
  00032	99		 cdq
  00033	f7 f9		 idiv	 ecx
  00035	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00038	99		 cdq
  00039	f7 7e 28	 idiv	 DWORD PTR [esi+40]

; 281  : 
; 282  : 	// Next free cluster
; 283  : 	*(uint32 *)(sector + 492) = LE32 (2);

  0003c	c7 87 ec 01 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+492], 2
  00046	2b c8		 sub	 ecx, eax

; 284  : 
; 285  : 	sector[508+3]=0xaa; /* TrailSig */
; 286  : 	sector[508+2]=0x55;
; 287  : 	sector[508+1]=0x00;
; 288  : 	sector[508+0]=0x00;

  00048	c7 87 fc 01 00
	00 00 00 55 aa	 mov	 DWORD PTR [edi+508], -1437270016 ; aa550000H
  00052	89 8f e8 01 00
	00		 mov	 DWORD PTR [edi+488], ecx
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi

; 289  : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_PutFSInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\fat.c
;	COMDAT _FormatFat
_TEXT	SEGMENT
_newOffset$ = -4404					; size = 8
tv738 = -4396						; size = 8
_startOffset$1$ = -4392					; size = 4
_x$3$ = -4392						; size = 4
_x$1$ = -4392						; size = 4
_startOffset$2$ = -4388					; size = 4
_write_buf$1$ = -4388					; size = 4
_nSecNo$ = -4384					; size = 8
_dev$GSCopy$1$ = -4376					; size = 4
_write_buf_cnt$ = -4372					; size = 4
_sector$ = -4368					; size = 4096
_temporaryKey$ = -272					; size = 256
_fat_sig$1 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_startSector$ = 8					; size = 8
_ft$ = 16						; size = 4
_dev$ = 20						; size = 4
_cryptoInfo$ = 24					; size = 4
_quickFormat$ = 28					; size = 4
_FormatFat PROC						; COMDAT

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 34 11 00 00	 mov	 eax, 4404		; 00001134H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 312  : 	int write_buf_cnt = 0;
; 313  : 	char sector[GST_MAX_VOLUME_SECTOR_SIZE], *write_buf;
; 314  : 	unsigned __int64 nSecNo = startSector;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _startSector$[ebp+4]
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _startSector$[ebp]
  0001d	53		 push	 ebx
  0001e	8b 5d 18	 mov	 ebx, DWORD PTR _cryptoInfo$[ebp]
  00021	56		 push	 esi
  00022	8b 75 10	 mov	 esi, DWORD PTR _ft$[ebp]
  00025	57		 push	 edi

; 315  : 	int x, n;
; 316  : 	int retVal;
; 317  : 	char temporaryKey[MASTER_KEYDATA_SIZE];
; 318  : 
; 319  : 	LARGE_INTEGER startOffset;
; 320  : 	LARGE_INTEGER newOffset;
; 321  : 
; 322  : 	// Seek to start sector
; 323  : 	startOffset.QuadPart = startSector * ft->sector_size;

  00026	ff 75 0c	 push	 DWORD PTR _startSector$[ebp+4]
  00029	8b 7d 14	 mov	 edi, DWORD PTR _dev$[ebp]
  0002c	89 85 e4 ee ff
	ff		 mov	 DWORD PTR _nSecNo$[ebp+4], eax
  00032	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  00036	99		 cdq
  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	50		 push	 eax
  0003a	89 bd e8 ee ff
	ff		 mov	 DWORD PTR _dev$GSCopy$1$[ebp], edi
  00040	c7 85 ec ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _write_buf_cnt$[ebp], 0
  0004a	89 8d e0 ee ff
	ff		 mov	 DWORD PTR _nSecNo$[ebp], ecx
  00050	e8 00 00 00 00	 call	 __allmul
  00055	8b ca		 mov	 ecx, edx
  00057	89 85 d8 ee ff
	ff		 mov	 DWORD PTR _startOffset$1$[ebp], eax

; 324  : 	if (!SetFilePointerEx ((HANDLE) dev, startOffset, &newOffset, FILE_BEGIN)
; 325  : 		|| newOffset.QuadPart != startOffset.QuadPart)

  0005d	6a 00		 push	 0
  0005f	8d 95 cc ee ff
	ff		 lea	 edx, DWORD PTR _newOffset$[ebp]
  00065	89 8d dc ee ff
	ff		 mov	 DWORD PTR _startOffset$2$[ebp], ecx
  0006b	52		 push	 edx
  0006c	51		 push	 ecx
  0006d	50		 push	 eax
  0006e	57		 push	 edi
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00075	85 c0		 test	 eax, eax
  00077	0f 84 52 06 00
	00		 je	 $LN38@FormatFat
  0007d	8b 85 d8 ee ff
	ff		 mov	 eax, DWORD PTR _startOffset$1$[ebp]
  00083	39 85 cc ee ff
	ff		 cmp	 DWORD PTR _newOffset$[ebp], eax
  00089	0f 85 40 06 00
	00		 jne	 $LN38@FormatFat
  0008f	8b 85 dc ee ff
	ff		 mov	 eax, DWORD PTR _startOffset$2$[ebp]
  00095	39 85 d0 ee ff
	ff		 cmp	 DWORD PTR _newOffset$[ebp+4], eax
  0009b	0f 85 2e 06 00
	00		 jne	 $LN38@FormatFat

; 326  : 	{
; 327  : 		return ERR_VOL_SEEKING;
; 328  : 	}
; 329  : 
; 330  : 	/* Write the data area */
; 331  : 
; 332  : 	write_buf = (char *)GSTalloc (FormatWriteBufferSize);

  000a1	ff 35 00 00 00
	00		 push	 DWORD PTR _FormatWriteBufferSize
  000a7	e8 00 00 00 00	 call	 _malloc
  000ac	8b f8		 mov	 edi, eax
  000ae	83 c4 04	 add	 esp, 4
  000b1	89 bd dc ee ff
	ff		 mov	 DWORD PTR _write_buf$1$[ebp], edi

; 333  : 	if (!write_buf)

  000b7	85 ff		 test	 edi, edi
  000b9	75 14		 jne	 SHORT $LN39@FormatFat

; 334  : 		return ERR_OUTOFMEMORY;

  000bb	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx

; 499  : }

  000c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c4	33 cd		 xor	 ecx, ebp
  000c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
$LN39@FormatFat:

; 335  : 
; 336  : 	memset (sector, 0, ft->sector_size);

  000cf	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  000d3	50		 push	 eax
  000d4	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  000da	6a 00		 push	 0
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _memset

; 337  : 
; 338  : 	RandgetBytes (ft->volume_id, sizeof (ft->volume_id), FALSE);

  000e2	6a 00		 push	 0
  000e4	8d 46 0b	 lea	 eax, DWORD PTR [esi+11]
  000e7	6a 04		 push	 4
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _RandgetBytes

; 339  : 
; 340  : 	PutBoot (ft, (unsigned char *) sector);

  000ef	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  000f5	50		 push	 eax
  000f6	56		 push	 esi
  000f7	e8 00 00 00 00	 call	 _PutBoot

; 341  : 	if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 342  : 		cryptoInfo) == FALSE)

  000fc	53		 push	 ebx
  000fd	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  00103	50		 push	 eax
  00104	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  0010a	50		 push	 eax
  0010b	57		 push	 edi
  0010c	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  00112	50		 push	 eax
  00113	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  00119	e8 00 00 00 00	 call	 _WriteSector
  0011e	83 c4 38	 add	 esp, 56			; 00000038H
  00121	85 c0		 test	 eax, eax
  00123	0f 84 5b 05 00
	00		 je	 $fail$227

; 343  : 		goto fail;
; 344  : 
; 345  : 	/* fat32 boot area */
; 346  : 	if (ft->size_fat == 32)				

  00129	83 7e 1c 20	 cmp	 DWORD PTR [esi+28], 32	; 00000020H
  0012d	0f 85 4c 01 00
	00		 jne	 $LN84@FormatFat

; 347  : 	{
; 348  : 		/* fsinfo */
; 349  : 		PutFSInfo((unsigned char *) sector, ft);

  00133	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  00139	56		 push	 esi
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 _PutFSInfo

; 350  : 		if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 351  : 			cryptoInfo) == FALSE)

  00140	53		 push	 ebx
  00141	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  00147	50		 push	 eax
  00148	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  0014e	50		 push	 eax
  0014f	57		 push	 edi
  00150	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  00156	50		 push	 eax
  00157	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  0015d	e8 00 00 00 00	 call	 _WriteSector
  00162	83 c4 20	 add	 esp, 32			; 00000020H
  00165	85 c0		 test	 eax, eax
  00167	0f 84 17 05 00
	00		 je	 $fail$227

; 352  : 			goto fail;
; 353  : 
; 354  : 		/* reserved */
; 355  : 		while (nSecNo - startSector < 6)

  0016d	8b 8d e0 ee ff
	ff		 mov	 ecx, DWORD PTR _nSecNo$[ebp]
  00173	2b 4d 08	 sub	 ecx, DWORD PTR _startSector$[ebp]
  00176	8b 85 e4 ee ff
	ff		 mov	 eax, DWORD PTR _nSecNo$[ebp+4]
  0017c	1b 45 0c	 sbb	 eax, DWORD PTR _startSector$[ebp+4]
  0017f	85 c0		 test	 eax, eax
  00181	77 75		 ja	 SHORT $LN163@FormatFat
  00183	72 0b		 jb	 SHORT $LL2@FormatFat
  00185	83 f9 06	 cmp	 ecx, 6
  00188	73 6e		 jae	 SHORT $LN163@FormatFat
  0018a	66 0f 1f 44 00
	00		 npad	 6
$LL2@FormatFat:

; 356  : 		{
; 357  : 			memset (sector, 0, ft->sector_size);

  00190	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  00194	50		 push	 eax
  00195	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  0019b	6a 00		 push	 0
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 _memset

; 358  : 			sector[508+3]=0xaa; /* TrailSig */
; 359  : 			sector[508+2]=0x55;
; 360  : 			if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 361  : 				cryptoInfo) == FALSE)

  001a3	53		 push	 ebx
  001a4	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  001aa	66 c7 85 ee f0
	ff ff 55 aa	 mov	 WORD PTR _sector$[ebp+510], 43605 ; 0000aa55H
  001b3	50		 push	 eax
  001b4	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  001ba	50		 push	 eax
  001bb	57		 push	 edi
  001bc	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  001c2	50		 push	 eax
  001c3	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  001c9	e8 00 00 00 00	 call	 _WriteSector
  001ce	83 c4 24	 add	 esp, 36			; 00000024H
  001d1	85 c0		 test	 eax, eax
  001d3	0f 84 ab 04 00
	00		 je	 $fail$227

; 352  : 			goto fail;
; 353  : 
; 354  : 		/* reserved */
; 355  : 		while (nSecNo - startSector < 6)

  001d9	8b 8d e0 ee ff
	ff		 mov	 ecx, DWORD PTR _nSecNo$[ebp]
  001df	2b 4d 08	 sub	 ecx, DWORD PTR _startSector$[ebp]
  001e2	8b 85 e4 ee ff
	ff		 mov	 eax, DWORD PTR _nSecNo$[ebp+4]
  001e8	1b 45 0c	 sbb	 eax, DWORD PTR _startSector$[ebp+4]
  001eb	89 85 d8 ee ff
	ff		 mov	 DWORD PTR tv738[ebp+4], eax
  001f1	75 05		 jne	 SHORT $LN163@FormatFat
  001f3	83 f9 06	 cmp	 ecx, 6
  001f6	72 98		 jb	 SHORT $LL2@FormatFat
$LN163@FormatFat:

; 362  : 				goto fail;
; 363  : 		}
; 364  : 		
; 365  : 		/* bootsector backup */
; 366  : 		memset (sector, 0, ft->sector_size);

  001f8	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  001fc	50		 push	 eax
  001fd	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  00203	6a 00		 push	 0
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 _memset

; 367  : 		PutBoot (ft, (unsigned char *) sector);

  0020b	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  00211	50		 push	 eax
  00212	56		 push	 esi
  00213	e8 00 00 00 00	 call	 _PutBoot

; 368  : 		if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 369  : 				 cryptoInfo) == FALSE)

  00218	53		 push	 ebx
  00219	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  0021f	50		 push	 eax
  00220	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  00226	50		 push	 eax
  00227	57		 push	 edi
  00228	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  0022e	50		 push	 eax
  0022f	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  00235	e8 00 00 00 00	 call	 _WriteSector
  0023a	83 c4 2c	 add	 esp, 44			; 0000002cH
  0023d	85 c0		 test	 eax, eax
  0023f	0f 84 3f 04 00
	00		 je	 $fail$227

; 370  : 			goto fail;
; 371  : 
; 372  : 		PutFSInfo((unsigned char *) sector, ft);

  00245	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  0024b	56		 push	 esi
  0024c	50		 push	 eax
  0024d	e8 00 00 00 00	 call	 _PutFSInfo

; 373  : 		if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 374  : 			cryptoInfo) == FALSE)

  00252	53		 push	 ebx
  00253	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  00259	50		 push	 eax
  0025a	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  00260	50		 push	 eax
  00261	57		 push	 edi
  00262	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  00268	50		 push	 eax
  00269	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  0026f	e8 00 00 00 00	 call	 _WriteSector
  00274	83 c4 20	 add	 esp, 32			; 00000020H
  00277	85 c0		 test	 eax, eax
  00279	0f 84 05 04 00
	00		 je	 $fail$227
$LN84@FormatFat:

; 375  : 			goto fail;
; 376  : 	}
; 377  : 
; 378  : 	/* reserved */
; 379  : 	while (nSecNo - startSector < (unsigned int)ft->reserved)

  0027f	8b 8d e0 ee ff
	ff		 mov	 ecx, DWORD PTR _nSecNo$[ebp]
  00285	2b 4d 08	 sub	 ecx, DWORD PTR _startSector$[ebp]
  00288	8b 85 e4 ee ff
	ff		 mov	 eax, DWORD PTR _nSecNo$[ebp+4]
  0028e	1b 45 0c	 sbb	 eax, DWORD PTR _startSector$[ebp+4]
  00291	0f bf 56 38	 movsx	 edx, WORD PTR [esi+56]
  00295	85 c0		 test	 eax, eax
  00297	77 67		 ja	 SHORT $LN165@FormatFat
  00299	72 05		 jb	 SHORT $LL4@FormatFat
  0029b	3b ca		 cmp	 ecx, edx
  0029d	73 61		 jae	 SHORT $LN165@FormatFat
  0029f	90		 npad	 1
$LL4@FormatFat:

; 380  : 	{
; 381  : 		memset (sector, 0, ft->sector_size);

  002a0	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  002a4	50		 push	 eax
  002a5	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  002ab	6a 00		 push	 0
  002ad	50		 push	 eax
  002ae	e8 00 00 00 00	 call	 _memset

; 382  : 		if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 383  : 			cryptoInfo) == FALSE)

  002b3	53		 push	 ebx
  002b4	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  002ba	50		 push	 eax
  002bb	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  002c1	50		 push	 eax
  002c2	57		 push	 edi
  002c3	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  002c9	50		 push	 eax
  002ca	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  002d0	e8 00 00 00 00	 call	 _WriteSector
  002d5	83 c4 24	 add	 esp, 36			; 00000024H
  002d8	85 c0		 test	 eax, eax
  002da	0f 84 a4 03 00
	00		 je	 $fail$227

; 375  : 			goto fail;
; 376  : 	}
; 377  : 
; 378  : 	/* reserved */
; 379  : 	while (nSecNo - startSector < (unsigned int)ft->reserved)

  002e0	8b 8d e0 ee ff
	ff		 mov	 ecx, DWORD PTR _nSecNo$[ebp]
  002e6	2b 4d 08	 sub	 ecx, DWORD PTR _startSector$[ebp]
  002e9	8b 85 e4 ee ff
	ff		 mov	 eax, DWORD PTR _nSecNo$[ebp+4]
  002ef	1b 45 0c	 sbb	 eax, DWORD PTR _startSector$[ebp+4]
  002f2	0f bf 56 38	 movsx	 edx, WORD PTR [esi+56]
  002f6	85 c0		 test	 eax, eax
  002f8	72 a6		 jb	 SHORT $LL4@FormatFat
  002fa	77 04		 ja	 SHORT $LN165@FormatFat
  002fc	3b ca		 cmp	 ecx, edx
  002fe	72 a0		 jb	 SHORT $LL4@FormatFat
$LN165@FormatFat:

; 384  : 			goto fail;
; 385  : 	}
; 386  : 
; 387  : 	/* write fat */
; 388  : 	for (x = 1; x <= ft->fats; x++)

  00300	b8 01 00 00 00	 mov	 eax, 1
  00305	89 85 d8 ee ff
	ff		 mov	 DWORD PTR _x$3$[ebp], eax
  0030b	39 46 20	 cmp	 DWORD PTR [esi+32], eax
  0030e	0f 8c e5 00 00
	00		 jl	 $LN7@FormatFat
$LL8@FormatFat:

; 389  : 	{
; 390  : 		for (n = 0; n < ft->fat_length; n++)

  00314	33 ff		 xor	 edi, edi
  00316	39 7e 2c	 cmp	 DWORD PTR [esi+44], edi
  00319	0f 8e c4 00 00
	00		 jle	 $LN6@FormatFat
  0031f	90		 npad	 1
$LL11@FormatFat:

; 391  : 		{
; 392  : 			memset (sector, 0, ft->sector_size);

  00320	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  00324	50		 push	 eax
  00325	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  0032b	6a 00		 push	 0
  0032d	50		 push	 eax
  0032e	e8 00 00 00 00	 call	 _memset
  00333	83 c4 0c	 add	 esp, 12			; 0000000cH

; 393  : 
; 394  : 			if (n == 0)

  00336	85 ff		 test	 edi, edi
  00338	75 67		 jne	 SHORT $LN52@FormatFat

; 395  : 			{
; 396  : 				unsigned char fat_sig[12];
; 397  : 				if (ft->size_fat == 32)

  0033a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0033d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00340	75 36		 jne	 SHORT $LN48@FormatFat

; 398  : 				{
; 399  : 					fat_sig[0] = (unsigned char) ft->media;

  00342	8a 46 24	 mov	 al, BYTE PTR [esi+36]
  00345	88 45 f0	 mov	 BYTE PTR _fat_sig$1[ebp], al

; 400  : 					fat_sig[1] = fat_sig[2] = 0xff;
; 401  : 					fat_sig[3] = 0x0f;
; 402  : 					fat_sig[4] = fat_sig[5] = fat_sig[6] = 0xff;

  00348	c7 45 f5 ff ff
	0f ff		 mov	 DWORD PTR _fat_sig$1[ebp+5], -15728641 ; ff0fffffH
  0034f	c7 45 f1 ff ff
	0f ff		 mov	 DWORD PTR _fat_sig$1[ebp+1], -15728641 ; ff0fffffH

; 403  : 					fat_sig[7] = 0x0f;
; 404  : 					fat_sig[8] = fat_sig[9] = fat_sig[10] = 0xff;
; 405  : 					fat_sig[11] = 0x0f;
; 406  : 					memcpy (sector, fat_sig, 12);

  00356	f3 0f 7e 45 f0	 movq	 xmm0, QWORD PTR _fat_sig$1[ebp]
  0035b	66 c7 45 f9 ff
	ff		 mov	 WORD PTR _fat_sig$1[ebp+9], 65535 ; 0000ffffH
  00361	c6 45 fb 0f	 mov	 BYTE PTR _fat_sig$1[ebp+11], 15 ; 0000000fH
  00365	8b 45 f8	 mov	 eax, DWORD PTR _fat_sig$1[ebp+8]
  00368	66 0f d6 85 f0
	ee ff ff	 movq	 QWORD PTR _sector$[ebp], xmm0
  00370	89 85 f8 ee ff
	ff		 mov	 DWORD PTR _sector$[ebp+8], eax

; 407  : 				}				

  00376	eb 29		 jmp	 SHORT $LN52@FormatFat
$LN48@FormatFat:

; 408  : 				else if (ft->size_fat == 16)

  00378	83 f8 10	 cmp	 eax, 16			; 00000010H
  0037b	75 06		 jne	 SHORT $LN50@FormatFat

; 409  : 				{
; 410  : 					fat_sig[0] = (unsigned char) ft->media;
; 411  : 					fat_sig[1] = 0xff;
; 412  : 					fat_sig[2] = 0xff;
; 413  : 					fat_sig[3] = 0xff;

  0037d	c6 45 f3 ff	 mov	 BYTE PTR _fat_sig$1[ebp+3], 255 ; 000000ffH

; 414  : 					memcpy (sector, fat_sig, 4);
; 415  : 				}

  00381	eb 09		 jmp	 SHORT $LN224@FormatFat
$LN50@FormatFat:

; 416  : 				else if (ft->size_fat == 12)

  00383	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00386	75 19		 jne	 SHORT $LN52@FormatFat

; 420  : 					fat_sig[2] = 0xff;
; 421  : 					fat_sig[3] = 0x00;

  00388	c6 45 f3 00	 mov	 BYTE PTR _fat_sig$1[ebp+3], 0
$LN224@FormatFat:

; 417  : 				{
; 418  : 					fat_sig[0] = (unsigned char) ft->media;

  0038c	8a 46 24	 mov	 al, BYTE PTR [esi+36]
  0038f	88 45 f0	 mov	 BYTE PTR _fat_sig$1[ebp], al

; 419  : 					fat_sig[1] = 0xff;

  00392	66 c7 45 f1 ff
	ff		 mov	 WORD PTR _fat_sig$1[ebp+1], 65535 ; 0000ffffH

; 422  : 					memcpy (sector, fat_sig, 4);

  00398	8b 45 f0	 mov	 eax, DWORD PTR _fat_sig$1[ebp]
  0039b	89 85 f0 ee ff
	ff		 mov	 DWORD PTR _sector$[ebp], eax
$LN52@FormatFat:

; 423  : 				}
; 424  : 			}
; 425  : 
; 426  : 			if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 427  : 				    cryptoInfo) == FALSE)

  003a1	53		 push	 ebx
  003a2	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  003a8	50		 push	 eax
  003a9	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  003af	50		 push	 eax
  003b0	ff b5 dc ee ff
	ff		 push	 DWORD PTR _write_buf$1$[ebp]
  003b6	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  003bc	50		 push	 eax
  003bd	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  003c3	e8 00 00 00 00	 call	 _WriteSector
  003c8	83 c4 18	 add	 esp, 24			; 00000018H
  003cb	85 c0		 test	 eax, eax
  003cd	0f 84 ab 02 00
	00		 je	 $LN209@FormatFat

; 389  : 	{
; 390  : 		for (n = 0; n < ft->fat_length; n++)

  003d3	47		 inc	 edi
  003d4	3b 7e 2c	 cmp	 edi, DWORD PTR [esi+44]
  003d7	0f 8c 43 ff ff
	ff		 jl	 $LL11@FormatFat
  003dd	8b 85 d8 ee ff
	ff		 mov	 eax, DWORD PTR _x$3$[ebp]
$LN6@FormatFat:

; 384  : 			goto fail;
; 385  : 	}
; 386  : 
; 387  : 	/* write fat */
; 388  : 	for (x = 1; x <= ft->fats; x++)

  003e3	40		 inc	 eax
  003e4	89 85 d8 ee ff
	ff		 mov	 DWORD PTR _x$3$[ebp], eax
  003ea	3b 46 20	 cmp	 eax, DWORD PTR [esi+32]
  003ed	0f 8e 21 ff ff
	ff		 jle	 $LL8@FormatFat
  003f3	8b bd dc ee ff
	ff		 mov	 edi, DWORD PTR _write_buf$1$[ebp]
$LN7@FormatFat:

; 428  : 				goto fail;
; 429  : 		}
; 430  : 	}
; 431  : 
; 432  : 
; 433  : 	/* write rootdir */
; 434  : 	for (x = 0; x < ft->size_root_dir / ft->sector_size; x++)

  003f9	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  003fc	33 d2		 xor	 edx, edx
  003fe	0f b7 4e 32	 movzx	 ecx, WORD PTR [esi+50]
  00402	89 95 d8 ee ff
	ff		 mov	 DWORD PTR _x$1$[ebp], edx
  00408	99		 cdq
  00409	f7 f9		 idiv	 ecx
  0040b	85 c0		 test	 eax, eax
  0040d	7e 55		 jle	 SHORT $LN13@FormatFat
  0040f	90		 npad	 1
$LL14@FormatFat:

; 435  : 	{
; 436  : 		memset (sector, 0, ft->sector_size);

  00410	51		 push	 ecx
  00411	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  00417	6a 00		 push	 0
  00419	50		 push	 eax
  0041a	e8 00 00 00 00	 call	 _memset

; 437  : 		if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 438  : 				 cryptoInfo) == FALSE)

  0041f	53		 push	 ebx
  00420	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  00426	50		 push	 eax
  00427	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  0042d	50		 push	 eax
  0042e	57		 push	 edi
  0042f	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  00435	50		 push	 eax
  00436	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  0043c	e8 00 00 00 00	 call	 _WriteSector
  00441	83 c4 24	 add	 esp, 36			; 00000024H
  00444	85 c0		 test	 eax, eax
  00446	0f 84 38 02 00
	00		 je	 $fail$227

; 428  : 				goto fail;
; 429  : 		}
; 430  : 	}
; 431  : 
; 432  : 
; 433  : 	/* write rootdir */
; 434  : 	for (x = 0; x < ft->size_root_dir / ft->sector_size; x++)

  0044c	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0044f	0f b7 4e 32	 movzx	 ecx, WORD PTR [esi+50]
  00453	99		 cdq
  00454	f7 f9		 idiv	 ecx
  00456	ff 85 d8 ee ff
	ff		 inc	 DWORD PTR _x$1$[ebp]
  0045c	39 85 d8 ee ff
	ff		 cmp	 DWORD PTR _x$1$[ebp], eax
  00462	7c ac		 jl	 SHORT $LL14@FormatFat
$LN13@FormatFat:

; 439  : 			goto fail;
; 440  : 
; 441  : 	}
; 442  : 
; 443  : 	/* Fill the rest of the data area with random data */
; 444  : 
; 445  : 	if(!quickFormat)

  00464	83 7d 1c 00	 cmp	 DWORD PTR _quickFormat$[ebp], 0
  00468	0f 85 90 01 00
	00		 jne	 $LN55@FormatFat

; 446  : 	{
; 447  : 		if (!FlushFormatWriteBuffer (dev, write_buf, &write_buf_cnt, &nSecNo, cryptoInfo))

  0046e	53		 push	 ebx
  0046f	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  00475	50		 push	 eax
  00476	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  0047c	50		 push	 eax
  0047d	57		 push	 edi
  0047e	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  00484	e8 00 00 00 00	 call	 _FlushFormatWriteBuffer
  00489	83 c4 14	 add	 esp, 20			; 00000014H
  0048c	85 c0		 test	 eax, eax
  0048e	0f 84 f0 01 00
	00		 je	 $fail$227

; 448  : 			goto fail;
; 449  : 
; 450  : 		/* Generate a random temporary key set to be used for "dummy" encryption that will fill
; 451  : 		the free disk space (data area) with random data.  This is necessary for plausible
; 452  : 		deniability of hidden volumes (and also reduces the amount of predictable plaintext
; 453  : 		within the volume). */
; 454  : 
; 455  : 		// Temporary master key
; 456  : 		if (!RandgetBytes (temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE))

  00494	6a 00		 push	 0
  00496	ff 33		 push	 DWORD PTR [ebx]
  00498	e8 00 00 00 00	 call	 _EAGetKeySize
  0049d	83 c4 04	 add	 esp, 4
  004a0	50		 push	 eax
  004a1	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  004a7	50		 push	 eax
  004a8	e8 00 00 00 00	 call	 _RandgetBytes
  004ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b0	85 c0		 test	 eax, eax
  004b2	0f 84 cc 01 00
	00		 je	 $fail$227

; 457  : 			goto fail;
; 458  : 
; 459  : 		// Temporary secondary key (XTS mode)
; 460  : 		if (!RandgetBytes (cryptoInfo->k2, sizeof cryptoInfo->k2, FALSE))		

  004b8	6a 00		 push	 0
  004ba	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  004c0	68 00 01 00 00	 push	 256			; 00000100H
  004c5	50		 push	 eax
  004c6	e8 00 00 00 00	 call	 _RandgetBytes
  004cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ce	85 c0		 test	 eax, eax
  004d0	0f 84 ae 01 00
	00		 je	 $fail$227

; 461  : 			goto fail;
; 462  : 
; 463  : 		retVal = EAInit (cryptoInfo->ea, temporaryKey, cryptoInfo->ks);

  004d6	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  004d9	50		 push	 eax
  004da	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  004e0	50		 push	 eax
  004e1	ff 33		 push	 DWORD PTR [ebx]
  004e3	e8 00 00 00 00	 call	 _EAInit
  004e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 464  : 		if (retVal != ERR_SUCCESS)

  004eb	85 c0		 test	 eax, eax
  004ed	74 3d		 je	 SHORT $LN60@FormatFat

; 465  : 		{
; 466  : 			burn (temporaryKey, sizeof(temporaryKey));

  004ef	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _temporaryKey$[ebp]
  004f5	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  004fa	8b fa		 mov	 edi, edx
  004fc	8b f1		 mov	 esi, ecx
  004fe	66 90		 npad	 2
$LL68@FormatFat:
  00500	c6 06 00	 mov	 BYTE PTR [esi], 0
  00503	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00506	83 ef 01	 sub	 edi, 1
  00509	75 f5		 jne	 SHORT $LL68@FormatFat
  0050b	0f 1f 44 00 00	 npad	 5
$LL18@FormatFat:
  00510	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00513	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00516	83 ea 01	 sub	 edx, 1
  00519	75 f5		 jne	 SHORT $LL18@FormatFat
  0051b	5f		 pop	 edi
  0051c	5e		 pop	 esi
  0051d	5b		 pop	 ebx

; 499  : }

  0051e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00521	33 cd		 xor	 ecx, ebp
  00523	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00528	8b e5		 mov	 esp, ebp
  0052a	5d		 pop	 ebp
  0052b	c3		 ret	 0
$LN60@FormatFat:

; 467  : 			return retVal;
; 468  : 		}
; 469  : 		if (!EAInitMode (cryptoInfo))

  0052c	53		 push	 ebx
  0052d	e8 00 00 00 00	 call	 _EAInitMode
  00532	83 c4 04	 add	 esp, 4
  00535	85 c0		 test	 eax, eax
  00537	75 46		 jne	 SHORT $LN61@FormatFat

; 470  : 		{
; 471  : 			burn (temporaryKey, sizeof(temporaryKey));

  00539	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  0053f	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00544	8b f1		 mov	 esi, ecx
  00546	8b d0		 mov	 edx, eax
  00548	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL72@FormatFat:
  00550	c6 02 00	 mov	 BYTE PTR [edx], 0
  00553	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00556	83 ee 01	 sub	 esi, 1
  00559	75 f5		 jne	 SHORT $LL72@FormatFat
  0055b	0f 1f 44 00 00	 npad	 5
$LL23@FormatFat:
  00560	c6 00 00	 mov	 BYTE PTR [eax], 0
  00563	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00566	83 e9 01	 sub	 ecx, 1
  00569	75 f5		 jne	 SHORT $LL23@FormatFat

; 472  : 			return ERR_MODE_INIT_FAILED;

  0056b	5f		 pop	 edi
  0056c	5e		 pop	 esi
  0056d	8d 41 1b	 lea	 eax, DWORD PTR [ecx+27]
  00570	5b		 pop	 ebx

; 499  : }

  00571	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00574	33 cd		 xor	 ecx, ebp
  00576	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0057b	8b e5		 mov	 esp, ebp
  0057d	5d		 pop	 ebp
  0057e	c3		 ret	 0
$LN61@FormatFat:

; 473  : 		}
; 474  : 
; 475  : 		x = ft->num_sectors - ft->reserved - ft->size_root_dir / ft->sector_size - ft->fat_length * 2;

  0057f	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00582	0f b7 4e 32	 movzx	 ecx, WORD PTR [esi+50]
  00586	99		 cdq
  00587	f7 f9		 idiv	 ecx
  00589	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  0058c	f7 df		 neg	 edi
  0058e	03 ff		 add	 edi, edi
  00590	2b f8		 sub	 edi, eax
  00592	0f bf 46 38	 movsx	 eax, WORD PTR [esi+56]
  00596	03 7e 10	 add	 edi, DWORD PTR [esi+16]
  00599	2b f8		 sub	 edi, eax

; 476  : 		while (x--)

  0059b	74 3a		 je	 SHORT $LN111@FormatFat
  0059d	0f 1f 00	 npad	 3
$LL25@FormatFat:

; 477  : 		{
; 478  : 			if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 479  : 				cryptoInfo) == FALSE)

  005a0	53		 push	 ebx
  005a1	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  005a7	4f		 dec	 edi
  005a8	50		 push	 eax
  005a9	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  005af	50		 push	 eax
  005b0	ff b5 dc ee ff
	ff		 push	 DWORD PTR _write_buf$1$[ebp]
  005b6	8d 85 f0 ee ff
	ff		 lea	 eax, DWORD PTR _sector$[ebp]
  005bc	50		 push	 eax
  005bd	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  005c3	e8 00 00 00 00	 call	 _WriteSector
  005c8	83 c4 18	 add	 esp, 24			; 00000018H
  005cb	85 c0		 test	 eax, eax
  005cd	0f 84 ab 00 00
	00		 je	 $LN209@FormatFat

; 476  : 		while (x--)

  005d3	85 ff		 test	 edi, edi
  005d5	75 c9		 jne	 SHORT $LL25@FormatFat
$LN111@FormatFat:

; 480  : 				goto fail;
; 481  : 		}
; 482  : 		UpdateProgressBar (nSecNo * ft->sector_size);

  005d7	ff b5 e4 ee ff
	ff		 push	 DWORD PTR _nSecNo$[ebp+4]
  005dd	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  005e1	ff b5 e0 ee ff
	ff		 push	 DWORD PTR _nSecNo$[ebp]
  005e7	99		 cdq
  005e8	52		 push	 edx
  005e9	50		 push	 eax
  005ea	e8 00 00 00 00	 call	 __allmul
  005ef	52		 push	 edx
  005f0	50		 push	 eax
  005f1	e8 00 00 00 00	 call	 _UpdateProgressBar

; 483  : 	}

  005f6	8b bd dc ee ff
	ff		 mov	 edi, DWORD PTR _write_buf$1$[ebp]
  005fc	eb 18		 jmp	 SHORT $LN225@FormatFat
$LN55@FormatFat:

; 484  : 	else
; 485  : 		UpdateProgressBar ((uint64) ft->num_sectors * ft->sector_size);

  005fe	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  00602	99		 cdq
  00603	52		 push	 edx
  00604	50		 push	 eax
  00605	6a 00		 push	 0
  00607	ff 76 10	 push	 DWORD PTR [esi+16]
  0060a	e8 00 00 00 00	 call	 __allmul
  0060f	52		 push	 edx
  00610	50		 push	 eax
  00611	e8 00 00 00 00	 call	 _UpdateProgressBar
$LN225@FormatFat:
  00616	83 c4 08	 add	 esp, 8

; 486  : 
; 487  : 	if (!FlushFormatWriteBuffer (dev, write_buf, &write_buf_cnt, &nSecNo, cryptoInfo))

  00619	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _nSecNo$[ebp]
  0061f	53		 push	 ebx
  00620	50		 push	 eax
  00621	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _write_buf_cnt$[ebp]
  00627	50		 push	 eax
  00628	57		 push	 edi
  00629	ff b5 e8 ee ff
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  0062f	e8 00 00 00 00	 call	 _FlushFormatWriteBuffer
  00634	83 c4 14	 add	 esp, 20			; 00000014H
  00637	85 c0		 test	 eax, eax
  00639	74 49		 je	 SHORT $fail$227

; 488  : 		goto fail;
; 489  : 
; 490  : 	GSTfree (write_buf);

  0063b	57		 push	 edi
  0063c	e8 00 00 00 00	 call	 _free

; 491  : 	burn (temporaryKey, sizeof(temporaryKey));

  00641	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  00647	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0064c	83 c4 04	 add	 esp, 4
  0064f	8b f1		 mov	 esi, ecx
  00651	8b d0		 mov	 edx, eax
$LL76@FormatFat:
  00653	c6 02 00	 mov	 BYTE PTR [edx], 0
  00656	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00659	83 ee 01	 sub	 esi, 1
  0065c	75 f5		 jne	 SHORT $LL76@FormatFat
  0065e	66 90		 npad	 2
$LL30@FormatFat:
  00660	c6 00 00	 mov	 BYTE PTR [eax], 0
  00663	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00666	83 e9 01	 sub	 ecx, 1
  00669	75 f5		 jne	 SHORT $LL30@FormatFat

; 492  : 	return 0;

  0066b	5f		 pop	 edi
  0066c	5e		 pop	 esi
  0066d	33 c0		 xor	 eax, eax
  0066f	5b		 pop	 ebx

; 499  : }

  00670	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00673	33 cd		 xor	 ecx, ebp
  00675	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0067a	8b e5		 mov	 esp, ebp
  0067c	5d		 pop	 ebp
  0067d	c3		 ret	 0
$LN209@FormatFat:
  0067e	8b bd dc ee ff
	ff		 mov	 edi, DWORD PTR _write_buf$1$[ebp]
$fail$227:

; 493  : 
; 494  : fail:
; 495  : 
; 496  : 	GSTfree (write_buf);

  00684	57		 push	 edi
  00685	e8 00 00 00 00	 call	 _free

; 497  : 	burn (temporaryKey, sizeof(temporaryKey));

  0068a	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  00690	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00695	83 c4 04	 add	 esp, 4
  00698	8b f1		 mov	 esi, ecx
  0069a	8b d0		 mov	 edx, eax
  0069c	0f 1f 40 00	 npad	 4
$LL80@FormatFat:
  006a0	c6 02 00	 mov	 BYTE PTR [edx], 0
  006a3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  006a6	83 ee 01	 sub	 esi, 1
  006a9	75 f5		 jne	 SHORT $LL80@FormatFat
  006ab	0f 1f 44 00 00	 npad	 5
$LL35@FormatFat:
  006b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  006b3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  006b6	83 e9 01	 sub	 ecx, 1
  006b9	75 f5		 jne	 SHORT $LL35@FormatFat

; 498  : 	return ERR_OS_ERROR;

  006bb	5f		 pop	 edi
  006bc	5e		 pop	 esi
  006bd	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  006c0	5b		 pop	 ebx

; 499  : }

  006c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006c4	33 cd		 xor	 ecx, ebp
  006c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006cb	8b e5		 mov	 esp, ebp
  006cd	5d		 pop	 ebp
  006ce	c3		 ret	 0
$LN38@FormatFat:
  006cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006d2	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  006d7	5f		 pop	 edi
  006d8	5e		 pop	 esi
  006d9	33 cd		 xor	 ecx, ebp
  006db	5b		 pop	 ebx
  006dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006e1	8b e5		 mov	 esp, ebp
  006e3	5d		 pop	 ebp
  006e4	c3		 ret	 0
_FormatFat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\fat.c
;	COMDAT _PutBoot
_TEXT	SEGMENT
_ft$ = 8						; size = 4
_boot$ = 12						; size = 4
_PutBoot PROC						; COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 166  : 	int cnt = 0;
; 167  : 
; 168  : 	boot[cnt++] = 0xeb;	/* boot jump */
; 169  : 	boot[cnt++] = 0x3c;
; 170  : 	boot[cnt++] = 0x90;
; 171  : 	memcpy (boot + cnt, "MSDOS5.0", 8); /* system id */
; 172  : 	cnt += 8;
; 173  : 	*(__int16 *)(boot + cnt) = LE16(ft->sector_size);	/* bytes per sector */

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _ft$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR _boot$[ebp]
  0000c	66 c7 07 eb 3c	 mov	 WORD PTR [edi], 15595	; 00003cebH
  00011	c6 47 02 90	 mov	 BYTE PTR [edi+2], 144	; 00000090H
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_08PGBLPCGG@MSDOS5?40?$AA@
  0001a	89 47 03	 mov	 DWORD PTR [edi+3], eax
  0001d	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_08PGBLPCGG@MSDOS5?40?$AA@+4
  00022	89 47 07	 mov	 DWORD PTR [edi+7], eax
  00025	0f b7 41 32	 movzx	 eax, WORD PTR [ecx+50]
  00029	66 89 47 0b	 mov	 WORD PTR [edi+11], ax

; 174  : 	cnt += 2;
; 175  : 	boot[cnt++] = (__int8) ft->cluster_size;			/* sectors per cluster */

  0002d	0f b6 41 28	 movzx	 eax, BYTE PTR [ecx+40]
  00031	88 47 0d	 mov	 BYTE PTR [edi+13], al

; 176  : 	*(__int16 *)(boot + cnt) = LE16(ft->reserved);		/* reserved sectors */

  00034	0f b7 41 38	 movzx	 eax, WORD PTR [ecx+56]
  00038	66 89 47 0e	 mov	 WORD PTR [edi+14], ax

; 177  : 	cnt += 2;
; 178  : 	boot[cnt++] = (__int8) ft->fats;					/* 2 fats */

  0003c	0f b6 41 20	 movzx	 eax, BYTE PTR [ecx+32]
  00040	88 47 10	 mov	 BYTE PTR [edi+16], al

; 179  : 
; 180  : 	if(ft->size_fat == 32)

  00043	83 79 1c 20	 cmp	 DWORD PTR [ecx+28], 32	; 00000020H
  00047	75 08		 jne	 SHORT $LN4@PutBoot

; 181  : 	{
; 182  : 		boot[cnt++] = 0x00;

  00049	66 c7 47 11 00
	00		 mov	 WORD PTR [edi+17], 0

; 183  : 		boot[cnt++] = 0x00;
; 184  : 	}

  0004f	eb 08		 jmp	 SHORT $LN5@PutBoot
$LN4@PutBoot:

; 185  : 	else
; 186  : 	{
; 187  : 		*(__int16 *)(boot + cnt) = LE16(ft->dir_entries);	/* 512 root entries */

  00051	66 8b 41 30	 mov	 ax, WORD PTR [ecx+48]
  00055	66 89 47 11	 mov	 WORD PTR [edi+17], ax
$LN5@PutBoot:

; 188  : 		cnt += 2;
; 189  : 	}
; 190  : 
; 191  : 	*(__int16 *)(boot + cnt) = LE16(ft->sectors);		/* # sectors */

  00059	66 8b 41 3a	 mov	 ax, WORD PTR [ecx+58]
  0005d	66 89 47 13	 mov	 WORD PTR [edi+19], ax

; 192  : 	cnt += 2;
; 193  : 	boot[cnt++] = (__int8) ft->media;					/* media byte */

  00061	8a 41 24	 mov	 al, BYTE PTR [ecx+36]
  00064	88 47 15	 mov	 BYTE PTR [edi+21], al

; 194  : 
; 195  : 	if(ft->size_fat == 32)	

  00067	83 79 1c 20	 cmp	 DWORD PTR [ecx+28], 32	; 00000020H
  0006b	75 08		 jne	 SHORT $LN6@PutBoot

; 196  : 	{
; 197  : 		boot[cnt++] = 0x00;

  0006d	66 c7 47 16 00
	00		 mov	 WORD PTR [edi+22], 0

; 198  : 		boot[cnt++] = 0x00;
; 199  : 	}

  00073	eb 08		 jmp	 SHORT $LN7@PutBoot
$LN6@PutBoot:

; 200  : 	else 
; 201  : 	{ 
; 202  : 		*(__int16 *)(boot + cnt) = LE16((uint16) ft->fat_length);	/* fat size */

  00075	66 8b 41 2c	 mov	 ax, WORD PTR [ecx+44]
  00079	66 89 47 16	 mov	 WORD PTR [edi+22], ax
$LN7@PutBoot:

; 203  : 		cnt += 2;
; 204  : 	}
; 205  : 
; 206  : 	*(__int16 *)(boot + cnt) = LE16(ft->secs_track);	/* # sectors per track */

  0007d	0f b7 41 42	 movzx	 eax, WORD PTR [ecx+66]

; 207  : 	cnt += 2;
; 208  : 	*(__int16 *)(boot + cnt) = LE16(ft->heads);			/* # heads */
; 209  : 	cnt += 2;
; 210  : 	*(__int32 *)(boot + cnt) = LE32(ft->hidden);		/* # hidden sectors */
; 211  : 	cnt += 4;
; 212  : 	*(__int32 *)(boot + cnt) = LE32(ft->total_sect);	/* # huge sectors */
; 213  : 	cnt += 4;

  00081	bb 24 00 00 00	 mov	 ebx, 36			; 00000024H
  00086	66 89 47 18	 mov	 WORD PTR [edi+24], ax
  0008a	0f b7 41 40	 movzx	 eax, WORD PTR [ecx+64]
  0008e	66 89 47 1a	 mov	 WORD PTR [edi+26], ax
  00092	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00095	89 47 1c	 mov	 DWORD PTR [edi+28], eax
  00098	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  0009b	89 47 20	 mov	 DWORD PTR [edi+32], eax

; 214  : 
; 215  : 	if(ft->size_fat == 32)

  0009e	83 79 1c 20	 cmp	 DWORD PTR [ecx+28], 32	; 00000020H
  000a2	75 2f		 jne	 SHORT $LN8@PutBoot

; 216  : 	{
; 217  : 		*(__int32 *)(boot + cnt) = LE32(ft->fat_length); cnt += 4;	/* fat size 32 */

  000a4	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  000a7	0f 57 c0	 xorps	 xmm0, xmm0
  000aa	89 47 24	 mov	 DWORD PTR [edi+36], eax

; 218  : 		boot[cnt++] = 0x00;	/* ExtFlags */
; 219  : 		boot[cnt++] = 0x00;
; 220  : 		boot[cnt++] = 0x00;	/* FSVer */
; 221  : 		boot[cnt++] = 0x00;
; 222  : 		boot[cnt++] = 0x02;	/* RootClus */
; 223  : 		boot[cnt++] = 0x00;
; 224  : 		boot[cnt++] = 0x00;
; 225  : 		boot[cnt++] = 0x00;
; 226  : 		boot[cnt++] = 0x01;	/* FSInfo */
; 227  : 		boot[cnt++] = 0x00;
; 228  : 		boot[cnt++] = 0x06;	/* BkBootSec */
; 229  : 		boot[cnt++] = 0x00;
; 230  : 		memset(boot+cnt, 0, 12); cnt+=12;	/* Reserved */

  000ad	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  000b2	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
  000b9	c7 47 2c 02 00
	00 00		 mov	 DWORD PTR [edi+44], 2
  000c0	c7 47 30 01 00
	06 00		 mov	 DWORD PTR [edi+48], 393217 ; 00060001H
  000c7	66 0f d6 47 34	 movq	 QWORD PTR [edi+52], xmm0
  000cc	c7 47 3c 00 00
	00 00		 mov	 DWORD PTR [edi+60], 0
$LN8@PutBoot:

; 231  : 	}
; 232  : 
; 233  : 	boot[cnt++] = 0x00;	/* drive number */   // FIXED 80 > 00

  000d3	66 c7 04 3b 00
	00		 mov	 WORD PTR [ebx+edi], 0

; 234  : 	boot[cnt++] = 0x00;	/* reserved */
; 235  : 	boot[cnt++] = 0x29;	/* boot sig */

  000d9	c6 44 3b 02 29	 mov	 BYTE PTR [ebx+edi+2], 41 ; 00000029H

; 236  : 
; 237  : 	memcpy (boot + cnt, ft->volume_id, 4);		/* vol id */

  000de	8b 41 0b	 mov	 eax, DWORD PTR [ecx+11]
  000e1	89 44 3b 03	 mov	 DWORD PTR [ebx+edi+3], eax

; 238  : 	cnt += 4;
; 239  : 
; 240  : 	memcpy (boot + cnt, ft->volume_name, 11);	/* vol title */

  000e5	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  000e9	66 0f d6 44 3b
	07		 movq	 QWORD PTR [ebx+edi+7], xmm0
  000ef	66 8b 41 08	 mov	 ax, WORD PTR [ecx+8]
  000f3	66 89 44 3b 0f	 mov	 WORD PTR [ebx+edi+15], ax
  000f8	8a 41 0a	 mov	 al, BYTE PTR [ecx+10]
  000fb	88 44 3b 11	 mov	 BYTE PTR [ebx+edi+17], al

; 241  : 	cnt += 11;
; 242  : 
; 243  : 	switch(ft->size_fat) /* filesystem type */

  000ff	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00102	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00105	74 2a		 je	 SHORT $LN9@PutBoot
  00107	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010a	74 15		 je	 SHORT $LN10@PutBoot
  0010c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0010f	75 32		 jne	 SHORT $LN2@PutBoot

; 247  : 		case 32: memcpy (boot + cnt, "FAT32   ", 8); break;

  00111	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_08NCCHMNJC@FAT32?5?5?5?$AA@
  00116	89 44 3b 12	 mov	 DWORD PTR [ebx+edi+18], eax
  0011a	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_08NCCHMNJC@FAT32?5?5?5?$AA@+4
  0011f	eb 1e		 jmp	 SHORT $LN13@PutBoot
$LN10@PutBoot:

; 246  : 		case 16: memcpy (boot + cnt, "FAT16   ", 8); break;

  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_08GKGPMKFJ@FAT16?5?5?5?$AA@
  00126	89 44 3b 12	 mov	 DWORD PTR [ebx+edi+18], eax
  0012a	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_08GKGPMKFJ@FAT16?5?5?5?$AA@+4
  0012f	eb 0e		 jmp	 SHORT $LN13@PutBoot
$LN9@PutBoot:

; 244  : 	{
; 245  : 		case 12: memcpy (boot + cnt, "FAT12   ", 8); break;

  00131	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_08JPOPGMJJ@FAT12?5?5?5?$AA@
  00136	89 44 3b 12	 mov	 DWORD PTR [ebx+edi+18], eax
  0013a	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_08JPOPGMJJ@FAT12?5?5?5?$AA@+4
$LN13@PutBoot:
  0013f	89 44 3b 16	 mov	 DWORD PTR [ebx+edi+22], eax
$LN2@PutBoot:

; 248  : 	}
; 249  : 	cnt += 8;

  00143	83 c3 1a	 add	 ebx, 26			; 0000001aH

; 250  : 
; 251  : 	memset (boot + cnt, 0, ft->size_fat==32 ? 420:448);	/* boot code */

  00146	be c0 01 00 00	 mov	 esi, 448		; 000001c0H
  0014b	83 79 1c 20	 cmp	 DWORD PTR [ecx+28], 32	; 00000020H
  0014f	ba a4 01 00 00	 mov	 edx, 420		; 000001a4H
  00154	8b c6		 mov	 eax, esi
  00156	0f 44 c2	 cmove	 eax, edx
  00159	50		 push	 eax
  0015a	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  0015d	6a 00		 push	 0
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _memset

; 252  : 	cnt += ft->size_fat==32 ? 420:448;

  00165	8b 45 08	 mov	 eax, DWORD PTR _ft$[ebp]
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016b	83 78 1c 20	 cmp	 DWORD PTR [eax+28], 32	; 00000020H
  0016f	b8 a4 01 00 00	 mov	 eax, 420		; 000001a4H
  00174	0f 44 f0	 cmove	 esi, eax
  00177	03 de		 add	 ebx, esi

; 253  : 	boot[cnt++] = 0x55;

  00179	66 c7 04 3b 55
	aa		 mov	 WORD PTR [ebx+edi], 43605 ; 0000aa55H
  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx

; 254  : 	boot[cnt++] = 0xaa;	/* boot sig */
; 255  : }

  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
_PutBoot ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\fat.c
;	COMDAT _GetFatParams
_TEXT	SEGMENT
tv622 = -12						; size = 4
tv631 = -8						; size = 4
tv613 = -8						; size = 4
tv637 = -4						; size = 4
tv583 = -4						; size = 4
tv612 = 8						; size = 4
tv582 = 8						; size = 4
_ft$ = 8						; size = 4
_GetFatParams PROC					; COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 49   : 	uint64 volumeSize = (uint64) ft->num_sectors * ft->sector_size;

  00008	8b 75 08	 mov	 esi, DWORD PTR _ft$[ebp]
  0000b	57		 push	 edi
  0000c	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  00010	89 45 f8	 mov	 DWORD PTR tv631[ebp], eax
  00013	0f b7 c0	 movzx	 eax, ax
  00016	99		 cdq
  00017	8b ca		 mov	 ecx, edx
  00019	8b d8		 mov	 ebx, eax
  0001b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0001e	51		 push	 ecx
  0001f	53		 push	 ebx
  00020	6a 00		 push	 0
  00022	50		 push	 eax
  00023	89 5d fc	 mov	 DWORD PTR tv583[ebp], ebx
  00026	89 4d 08	 mov	 DWORD PTR tv582[ebp], ecx
  00029	e8 00 00 00 00	 call	 __allmul

; 50   : 	unsigned int fatsecs;
; 51   : 
; 52   : 	if(ft->cluster_size == 0)	// 'Default' cluster size

  0002e	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00032	8b d8		 mov	 ebx, eax
  00034	8b fa		 mov	 edi, edx
  00036	0f 85 fa 00 00
	00		 jne	 $LN26@GetFatPara

; 53   : 	{
; 54   : 		uint32 clusterSize;
; 55   : 
; 56   : 		// Determine optimal cluster size to minimize FAT size (mounting delay), maximize number of files, keep 4 KB alignment, etc.
; 57   : 		if (volumeSize >= 2 * BYTES_PER_TB)

  0003c	81 ff 00 02 00
	00		 cmp	 edi, 512		; 00000200H
  00042	72 10		 jb	 SHORT $LN6@GetFatPara
  00044	77 04		 ja	 SHORT $LN38@GetFatPara
  00046	85 db		 test	 ebx, ebx
  00048	72 0a		 jb	 SHORT $LN6@GetFatPara
$LN38@GetFatPara:

; 58   : 			clusterSize = 256 * BYTES_PER_KB;

  0004a	b8 00 00 04 00	 mov	 eax, 262144		; 00040000H
  0004f	e9 9e 00 00 00	 jmp	 $LN23@GetFatPara
$LN6@GetFatPara:

; 59   : 		else if (volumeSize >= 512 * BYTES_PER_GB)

  00054	81 ff 80 00 00
	00		 cmp	 edi, 128		; 00000080H
  0005a	72 10		 jb	 SHORT $LN8@GetFatPara
  0005c	77 04		 ja	 SHORT $LN39@GetFatPara
  0005e	85 db		 test	 ebx, ebx
  00060	72 0a		 jb	 SHORT $LN8@GetFatPara
$LN39@GetFatPara:

; 60   : 			clusterSize = 128 * BYTES_PER_KB;

  00062	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
  00067	e9 86 00 00 00	 jmp	 $LN23@GetFatPara
$LN8@GetFatPara:

; 61   : 		else if (volumeSize >= 128 * BYTES_PER_GB)

  0006c	83 ff 20	 cmp	 edi, 32			; 00000020H
  0006f	72 0d		 jb	 SHORT $LN10@GetFatPara
  00071	77 04		 ja	 SHORT $LN40@GetFatPara
  00073	85 db		 test	 ebx, ebx
  00075	72 07		 jb	 SHORT $LN10@GetFatPara
$LN40@GetFatPara:

; 62   : 			clusterSize = 64 * BYTES_PER_KB;

  00077	b8 00 00 01 00	 mov	 eax, 65536		; 00010000H
  0007c	eb 74		 jmp	 SHORT $LN23@GetFatPara
$LN10@GetFatPara:

; 63   : 		else if (volumeSize >= 64 * BYTES_PER_GB)

  0007e	83 ff 10	 cmp	 edi, 16			; 00000010H
  00081	72 0d		 jb	 SHORT $LN12@GetFatPara
  00083	77 04		 ja	 SHORT $LN41@GetFatPara
  00085	85 db		 test	 ebx, ebx
  00087	72 07		 jb	 SHORT $LN12@GetFatPara
$LN41@GetFatPara:

; 64   : 			clusterSize = 32 * BYTES_PER_KB;

  00089	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  0008e	eb 62		 jmp	 SHORT $LN23@GetFatPara
$LN12@GetFatPara:

; 65   : 		else if (volumeSize >= 32 * BYTES_PER_GB)

  00090	83 ff 08	 cmp	 edi, 8
  00093	72 0d		 jb	 SHORT $LN14@GetFatPara
  00095	77 04		 ja	 SHORT $LN42@GetFatPara
  00097	85 db		 test	 ebx, ebx
  00099	72 07		 jb	 SHORT $LN14@GetFatPara
$LN42@GetFatPara:

; 66   : 			clusterSize = 16 * BYTES_PER_KB;

  0009b	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  000a0	eb 50		 jmp	 SHORT $LN23@GetFatPara
$LN14@GetFatPara:

; 67   : 		else if (volumeSize >= 16 * BYTES_PER_GB)

  000a2	83 ff 04	 cmp	 edi, 4
  000a5	72 0d		 jb	 SHORT $LN16@GetFatPara
  000a7	77 04		 ja	 SHORT $LN43@GetFatPara
  000a9	85 db		 test	 ebx, ebx
  000ab	72 07		 jb	 SHORT $LN16@GetFatPara
$LN43@GetFatPara:

; 68   : 			clusterSize = 8 * BYTES_PER_KB;

  000ad	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  000b2	eb 3e		 jmp	 SHORT $LN23@GetFatPara
$LN16@GetFatPara:

; 69   : 		else if (volumeSize >= 512 * BYTES_PER_MB)

  000b4	85 ff		 test	 edi, edi
  000b6	75 35		 jne	 SHORT $LN44@GetFatPara
  000b8	81 fb 00 00 00
	20		 cmp	 ebx, 536870912		; 20000000H
  000be	73 2d		 jae	 SHORT $LN44@GetFatPara

; 71   : 		else if (volumeSize >= 256 * BYTES_PER_MB)

  000c0	85 ff		 test	 edi, edi
  000c2	75 22		 jne	 SHORT $LN45@GetFatPara
  000c4	81 fb 00 00 00
	10		 cmp	 ebx, 268435456		; 10000000H
  000ca	73 1a		 jae	 SHORT $LN45@GetFatPara

; 73   : 		else if (volumeSize >= 1 * BYTES_PER_MB)

  000cc	85 ff		 test	 edi, edi
  000ce	75 0f		 jne	 SHORT $LN46@GetFatPara
  000d0	81 fb 00 00 10
	00		 cmp	 ebx, 1048576		; 00100000H
  000d6	73 07		 jae	 SHORT $LN46@GetFatPara

; 75   : 		else
; 76   : 			clusterSize = 512;

  000d8	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  000dd	eb 13		 jmp	 SHORT $LN23@GetFatPara
$LN46@GetFatPara:

; 74   : 			clusterSize = 1 * BYTES_PER_KB;

  000df	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  000e4	eb 0c		 jmp	 SHORT $LN23@GetFatPara
$LN45@GetFatPara:

; 72   : 			clusterSize = 2 * BYTES_PER_KB;

  000e6	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  000eb	eb 05		 jmp	 SHORT $LN23@GetFatPara
$LN44@GetFatPara:

; 70   : 			clusterSize = 4 * BYTES_PER_KB;

  000ed	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
$LN23@GetFatPara:

; 77   : 
; 78   : 		ft->cluster_size = clusterSize / ft->sector_size;

  000f2	0f b7 4e 32	 movzx	 ecx, WORD PTR [esi+50]
  000f6	33 d2		 xor	 edx, edx
  000f8	f7 f1		 div	 ecx

; 79   : 		
; 80   : 		if (ft->cluster_size == 0)

  000fa	ba 01 00 00 00	 mov	 edx, 1
  000ff	85 c0		 test	 eax, eax
  00101	0f 44 c2	 cmove	 eax, edx
  00104	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 81   : 			ft->cluster_size = 1;
; 82   : 
; 83   : 		if (ft->cluster_size * ft->sector_size > GST_MAX_FAT_CLUSTER_SIZE)

  00107	0f af c1	 imul	 eax, ecx
  0010a	3d 00 00 04 00	 cmp	 eax, 262144		; 00040000H
  0010f	7e 15		 jle	 SHORT $LN25@GetFatPara

; 84   : 			ft->cluster_size = GST_MAX_FAT_CLUSTER_SIZE / ft->sector_size;

  00111	ff 75 08	 push	 DWORD PTR tv582[ebp]
  00114	ff 75 fc	 push	 DWORD PTR tv583[ebp]
  00117	6a 00		 push	 0
  00119	68 00 00 04 00	 push	 262144			; 00040000H
  0011e	e8 00 00 00 00	 call	 __aulldiv
  00123	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN25@GetFatPara:

; 85   : 
; 86   : 		if (ft->cluster_size > 128)

  00126	81 7e 28 80 00
	00 00		 cmp	 DWORD PTR [esi+40], 128	; 00000080H
  0012d	7e 07		 jle	 SHORT $LN26@GetFatPara

; 87   : 			ft->cluster_size = 128;

  0012f	c7 46 28 80 00
	00 00		 mov	 DWORD PTR [esi+40], 128	; 00000080H
$LN26@GetFatPara:

; 88   : 	}
; 89   : 
; 90   : 	if (volumeSize <= GST_MAX_FAT_CLUSTER_SIZE * 4)

  00136	85 ff		 test	 edi, edi
  00138	77 11		 ja	 SHORT $LN27@GetFatPara
  0013a	72 08		 jb	 SHORT $LN47@GetFatPara
  0013c	81 fb 00 00 10
	00		 cmp	 ebx, 1048576		; 00100000H
  00142	77 07		 ja	 SHORT $LN27@GetFatPara
$LN47@GetFatPara:

; 91   : 		ft->cluster_size = 1;

  00144	c7 46 28 01 00
	00 00		 mov	 DWORD PTR [esi+40], 1
$LN27@GetFatPara:

; 92   : 
; 93   : 	// Geometry always set to SECTORS/1/1
; 94   : 	ft->secs_track = 1; 
; 95   : 	ft->heads = 1; 
; 96   : 
; 97   : 	ft->dir_entries = 512;

  0014b	b8 00 02 00 00	 mov	 eax, 512		; 00000200H

; 98   : 	ft->fats = 2;
; 99   : 	ft->media = 0xf8;
; 100  : 	ft->hidden = 0;
; 101  : 
; 102  : 	ft->size_root_dir = ft->dir_entries * 32;
; 103  : 
; 104  : 	// FAT12
; 105  : 	ft->size_fat = 12;
; 106  : 	ft->reserved = 2;
; 107  : 	fatsecs = ft->num_sectors - (ft->size_root_dir + ft->sector_size - 1) / ft->sector_size - ft->reserved;
; 108  : 	ft->cluster_count = (int) (((__int64) fatsecs * ft->sector_size) / (ft->cluster_size * ft->sector_size));

  00150	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00153	89 45 f4	 mov	 DWORD PTR tv622[ebp], eax
  00156	66 89 46 30	 mov	 WORD PTR [esi+48], ax
  0015a	b8 02 00 00 00	 mov	 eax, 2
  0015f	66 89 46 38	 mov	 WORD PTR [esi+56], ax
  00163	8b 45 f8	 mov	 eax, DWORD PTR tv631[ebp]
  00166	0f b7 d8	 movzx	 ebx, ax
  00169	ff 75 08	 push	 DWORD PTR tv582[ebp]
  0016c	c7 46 40 01 00
	01 00		 mov	 DWORD PTR [esi+64], 65537 ; 00010001H
  00173	ff 75 fc	 push	 DWORD PTR tv583[ebp]
  00176	8d 83 ff 3f 00
	00		 lea	 eax, DWORD PTR [ebx+16383]
  0017c	c7 46 20 02 00
	00 00		 mov	 DWORD PTR [esi+32], 2
  00183	99		 cdq
  00184	f7 fb		 idiv	 ebx
  00186	6a 00		 push	 0
  00188	2b c8		 sub	 ecx, eax
  0018a	c7 46 24 f8 00
	00 00		 mov	 DWORD PTR [esi+36], 248	; 000000f8H
  00191	83 e9 02	 sub	 ecx, 2
  00194	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  0019b	51		 push	 ecx
  0019c	c7 46 18 00 40
	00 00		 mov	 DWORD PTR [esi+24], 16384 ; 00004000H
  001a3	c7 46 1c 0c 00
	00 00		 mov	 DWORD PTR [esi+28], 12	; 0000000cH
  001aa	e8 00 00 00 00	 call	 __allmul
  001af	8b f8		 mov	 edi, eax
  001b1	8b ca		 mov	 ecx, edx
  001b3	8b c3		 mov	 eax, ebx
  001b5	0f af 46 28	 imul	 eax, DWORD PTR [esi+40]
  001b9	99		 cdq
  001ba	52		 push	 edx
  001bb	50		 push	 eax
  001bc	51		 push	 ecx
  001bd	57		 push	 edi
  001be	e8 00 00 00 00	 call	 __alldiv
  001c3	8b f8		 mov	 edi, eax

; 109  : 	ft->fat_length = (((ft->cluster_count * 3 + 1) >> 1) + ft->sector_size - 1) / ft->sector_size;

  001c5	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  001c8	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  001cb	8d 0c 7d 01 00
	00 00		 lea	 ecx, DWORD PTR [edi*2+1]
  001d2	03 cf		 add	 ecx, edi
  001d4	d1 f9		 sar	 ecx, 1
  001d6	03 c1		 add	 eax, ecx
  001d8	99		 cdq
  001d9	f7 fb		 idiv	 ebx
  001db	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 110  : 
; 111  : 	if (ft->cluster_count >= 4085) // FAT16

  001de	81 ff f5 0f 00
	00		 cmp	 edi, 4085		; 00000ff5H
  001e4	7c 1f		 jl	 SHORT $LN28@GetFatPara

; 112  : 	{
; 113  : 		ft->size_fat = 16;
; 114  : 		ft->reserved = 2;

  001e6	b8 02 00 00 00	 mov	 eax, 2
  001eb	c7 46 1c 10 00
	00 00		 mov	 DWORD PTR [esi+28], 16	; 00000010H
  001f2	66 89 46 38	 mov	 WORD PTR [esi+56], ax

; 115  : 		fatsecs = ft->num_sectors - (ft->size_root_dir + ft->sector_size - 1) / ft->sector_size - ft->reserved;
; 116  : 		ft->cluster_count = (int) (((__int64) fatsecs * ft->sector_size) / (ft->cluster_size * ft->sector_size));
; 117  : 		ft->fat_length = (ft->cluster_count * 2 + ft->sector_size - 1) / ft->sector_size;

  001f6	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  001f9	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  001fc	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  001ff	99		 cdq
  00200	f7 fb		 idiv	 ebx
  00202	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$LN28@GetFatPara:

; 118  : 	}
; 119  : 	
; 120  : 	if(ft->cluster_count >= 65525) // FAT32

  00205	81 ff f5 ff 00
	00		 cmp	 edi, 65525		; 0000fff5H
  0020b	0f 8c 92 00 00
	00		 jl	 $LN3@GetFatPara

; 121  : 	{
; 122  : 		ft->size_fat = 32;
; 123  : 		ft->reserved = 32 - 1;

  00211	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  00216	c7 46 1c 20 00
	00 00		 mov	 DWORD PTR [esi+28], 32	; 00000020H
  0021d	66 89 46 38	 mov	 WORD PTR [esi+56], ax

; 130  : 			ft->size_root_dir = ft->cluster_size * ft->sector_size;

  00221	8b 45 f8	 mov	 eax, DWORD PTR tv631[ebp]
  00224	0f b7 d8	 movzx	 ebx, ax
  00227	8b fb		 mov	 edi, ebx
  00229	0f af 7e 28	 imul	 edi, DWORD PTR [esi+40]
  0022d	8b c7		 mov	 eax, edi
  0022f	89 7d fc	 mov	 DWORD PTR tv637[ebp], edi
  00232	99		 cdq
  00233	89 45 f8	 mov	 DWORD PTR tv613[ebp], eax
  00236	89 55 08	 mov	 DWORD PTR tv612[ebp], edx
  00239	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@GetFatPara:

; 124  : 
; 125  : 		do
; 126  : 		{
; 127  : 			ft->reserved++;
; 128  : 
; 129  : 			fatsecs = ft->num_sectors - ft->reserved;

  00240	66 ff 46 38	 inc	 WORD PTR [esi+56]
  00244	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 131  : 			ft->cluster_count = (int) (((__int64) fatsecs * ft->sector_size) / (ft->cluster_size * ft->sector_size));

  00247	6a 00		 push	 0
  00249	53		 push	 ebx
  0024a	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0024d	0f bf 7e 38	 movsx	 edi, WORD PTR [esi+56]
  00251	2b cf		 sub	 ecx, edi
  00253	6a 00		 push	 0
  00255	51		 push	 ecx
  00256	e8 00 00 00 00	 call	 __allmul
  0025b	ff 75 08	 push	 DWORD PTR tv612[ebp]
  0025e	ff 75 f8	 push	 DWORD PTR tv613[ebp]
  00261	52		 push	 edx
  00262	50		 push	 eax
  00263	e8 00 00 00 00	 call	 __alldiv
  00268	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 132  : 			ft->fat_length = (ft->cluster_count * 4 + ft->sector_size - 1) / ft->sector_size;

  0026b	8d 04 85 ff ff
	ff ff		 lea	 eax, DWORD PTR [eax*4-1]
  00272	03 c3		 add	 eax, ebx
  00274	99		 cdq
  00275	f7 fb		 idiv	 ebx

; 133  : 
; 134  : 		// Align data area on GST_MAX_VOLUME_SECTOR_SIZE
; 135  : 
; 136  : 		} while (ft->sector_size == GST_SECTOR_SIZE_LEGACY
; 137  : 				&& (ft->reserved * ft->sector_size + ft->fat_length * ft->fats * ft->sector_size) % GST_MAX_VOLUME_SECTOR_SIZE != 0);

  00277	0f b7 56 32	 movzx	 edx, WORD PTR [esi+50]
  0027b	0f b7 ca	 movzx	 ecx, dx
  0027e	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00281	66 3b 4d f4	 cmp	 cx, WORD PTR tv622[ebp]
  00285	75 1c		 jne	 SHORT $LN3@GetFatPara
  00287	8d 04 47	 lea	 eax, DWORD PTR [edi+eax*2]
  0028a	0f b7 ca	 movzx	 ecx, dx
  0028d	0f af c1	 imul	 eax, ecx
  00290	25 ff 0f 00 80	 and	 eax, -2147479553	; 80000fffH
  00295	79 07		 jns	 SHORT $LN49@GetFatPara
  00297	48		 dec	 eax
  00298	0d 00 f0 ff ff	 or	 eax, -4096		; fffff000H
  0029d	40		 inc	 eax
$LN49@GetFatPara:
  0029e	8b 7d fc	 mov	 edi, DWORD PTR tv637[ebp]
  002a1	75 9d		 jne	 SHORT $LL4@GetFatPara
$LN3@GetFatPara:

; 138  : 	}
; 139  : 
; 140  : 	ft->cluster_count -= ft->fat_length * ft->fats / ft->cluster_size;

  002a3	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  002a6	f7 d8		 neg	 eax
  002a8	03 c0		 add	 eax, eax
  002aa	99		 cdq
  002ab	f7 7e 28	 idiv	 DWORD PTR [esi+40]
  002ae	01 46 14	 add	 DWORD PTR [esi+20], eax

; 141  : 
; 142  : 	if (ft->num_sectors >= 65536 || ft->size_fat == 32)

  002b1	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  002b4	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  002b9	73 18		 jae	 SHORT $LN33@GetFatPara
  002bb	83 7e 1c 20	 cmp	 DWORD PTR [esi+28], 32	; 00000020H
  002bf	74 12		 je	 SHORT $LN33@GetFatPara

; 146  : 	}
; 147  : 	else
; 148  : 	{
; 149  : 		ft->sectors = (uint16) ft->num_sectors;

  002c1	5f		 pop	 edi
  002c2	66 89 46 3a	 mov	 WORD PTR [esi+58], ax

; 150  : 		ft->total_sect = 0;

  002c6	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  002cd	5e		 pop	 esi
  002ce	5b		 pop	 ebx

; 151  : 	}
; 152  : }

  002cf	8b e5		 mov	 esp, ebp
  002d1	5d		 pop	 ebp
  002d2	c3		 ret	 0
$LN33@GetFatPara:

; 143  : 	{
; 144  : 		ft->sectors = 0;

  002d3	33 c9		 xor	 ecx, ecx

; 145  : 		ft->total_sect = ft->num_sectors;

  002d5	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  002d8	5f		 pop	 edi
  002d9	66 89 4e 3a	 mov	 WORD PTR [esi+58], cx
  002dd	5e		 pop	 esi
  002de	5b		 pop	 ebx

; 151  : 	}
; 152  : }

  002df	8b e5		 mov	 esp, ebp
  002e1	5d		 pop	 ebp
  002e2	c3		 ret	 0
_GetFatParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
