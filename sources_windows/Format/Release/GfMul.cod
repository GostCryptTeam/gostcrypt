; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\GfMul.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_GfMul128
PUBLIC	_GfMul128Tab
PUBLIC	_Gf128Tab64Init
PUBLIC	_Gf128MulBy64Tab
PUBLIC	_Gf64TabInit
PUBLIC	_Gf64MulTab
PUBLIC	_MirrorBits128
PUBLIC	_MirrorBits64
PUBLIC	_GfMulSelfTest
PUBLIC	_mul_x
PUBLIC	_mul_x64
PUBLIC	_compile_8k_table
PUBLIC	_compile_4k_table64
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
CONST	SEGMENT
_gft_le	DW	00H
	DW	0c201H
	DW	08403H
	DW	04602H
	DW	0807H
	DW	0ca06H
	DW	08c04H
	DW	04e05H
	DW	0100eH
	DW	0d20fH
	DW	0940dH
	DW	0560cH
	DW	01809H
	DW	0da08H
	DW	09c0aH
	DW	05e0bH
	DW	0201cH
	DW	0e21dH
	DW	0a41fH
	DW	0661eH
	DW	0281bH
	DW	0ea1aH
	DW	0ac18H
	DW	06e19H
	DW	03012H
	DW	0f213H
	DW	0b411H
	DW	07610H
	DW	03815H
	DW	0fa14H
	DW	0bc16H
	DW	07e17H
	DW	04038H
	DW	08239H
	DW	0c43bH
	DW	063aH
	DW	0483fH
	DW	08a3eH
	DW	0cc3cH
	DW	0e3dH
	DW	05036H
	DW	09237H
	DW	0d435H
	DW	01634H
	DW	05831H
	DW	09a30H
	DW	0dc32H
	DW	01e33H
	DW	06024H
	DW	0a225H
	DW	0e427H
	DW	02626H
	DW	06823H
	DW	0aa22H
	DW	0ec20H
	DW	02e21H
	DW	0702aH
	DW	0b22bH
	DW	0f429H
	DW	03628H
	DW	0782dH
	DW	0ba2cH
	DW	0fc2eH
	DW	03e2fH
	DW	08070H
	DW	04271H
	DW	0473H
	DW	0c672H
	DW	08877H
	DW	04a76H
	DW	0c74H
	DW	0ce75H
	DW	0907eH
	DW	0527fH
	DW	0147dH
	DW	0d67cH
	DW	09879H
	DW	05a78H
	DW	01c7aH
	DW	0de7bH
	DW	0a06cH
	DW	0626dH
	DW	0246fH
	DW	0e66eH
	DW	0a86bH
	DW	06a6aH
	DW	02c68H
	DW	0ee69H
	DW	0b062H
	DW	07263H
	DW	03461H
	DW	0f660H
	DW	0b865H
	DW	07a64H
	DW	03c66H
	DW	0fe67H
	DW	0c048H
	DW	0249H
	DW	0444bH
	DW	0864aH
	DW	0c84fH
	DW	0a4eH
	DW	04c4cH
	DW	08e4dH
	DW	0d046H
	DW	01247H
	DW	05445H
	DW	09644H
	DW	0d841H
	DW	01a40H
	DW	05c42H
	DW	09e43H
	DW	0e054H
	DW	02255H
	DW	06457H
	DW	0a656H
	DW	0e853H
	DW	02a52H
	DW	06c50H
	DW	0ae51H
	DW	0f05aH
	DW	0325bH
	DW	07459H
	DW	0b658H
	DW	0f85dH
	DW	03a5cH
	DW	07c5eH
	DW	0be5fH
	DW	0e1H
	DW	0c2e0H
	DW	084e2H
	DW	046e3H
	DW	08e6H
	DW	0cae7H
	DW	08ce5H
	DW	04ee4H
	DW	010efH
	DW	0d2eeH
	DW	094ecH
	DW	056edH
	DW	018e8H
	DW	0dae9H
	DW	09cebH
	DW	05eeaH
	DW	020fdH
	DW	0e2fcH
	DW	0a4feH
	DW	066ffH
	DW	028faH
	DW	0eafbH
	DW	0acf9H
	DW	06ef8H
	DW	030f3H
	DW	0f2f2H
	DW	0b4f0H
	DW	076f1H
	DW	038f4H
	DW	0faf5H
	DW	0bcf7H
	DW	07ef6H
	DW	040d9H
	DW	082d8H
	DW	0c4daH
	DW	06dbH
	DW	048deH
	DW	08adfH
	DW	0ccddH
	DW	0edcH
	DW	050d7H
	DW	092d6H
	DW	0d4d4H
	DW	016d5H
	DW	058d0H
	DW	09ad1H
	DW	0dcd3H
	DW	01ed2H
	DW	060c5H
	DW	0a2c4H
	DW	0e4c6H
	DW	026c7H
	DW	068c2H
	DW	0aac3H
	DW	0ecc1H
	DW	02ec0H
	DW	070cbH
	DW	0b2caH
	DW	0f4c8H
	DW	036c9H
	DW	078ccH
	DW	0bacdH
	DW	0fccfH
	DW	03eceH
	DW	08091H
	DW	04290H
	DW	0492H
	DW	0c693H
	DW	08896H
	DW	04a97H
	DW	0c95H
	DW	0ce94H
	DW	0909fH
	DW	0529eH
	DW	0149cH
	DW	0d69dH
	DW	09898H
	DW	05a99H
	DW	01c9bH
	DW	0de9aH
	DW	0a08dH
	DW	0628cH
	DW	0248eH
	DW	0e68fH
	DW	0a88aH
	DW	06a8bH
	DW	02c89H
	DW	0ee88H
	DW	0b083H
	DW	07282H
	DW	03480H
	DW	0f681H
	DW	0b884H
	DW	07a85H
	DW	03c87H
	DW	0fe86H
	DW	0c0a9H
	DW	02a8H
	DW	044aaH
	DW	086abH
	DW	0c8aeH
	DW	0aafH
	DW	04cadH
	DW	08eacH
	DW	0d0a7H
	DW	012a6H
	DW	054a4H
	DW	096a5H
	DW	0d8a0H
	DW	01aa1H
	DW	05ca3H
	DW	09ea2H
	DW	0e0b5H
	DW	022b4H
	DW	064b6H
	DW	0a6b7H
	DW	0e8b2H
	DW	02ab3H
	DW	06cb1H
	DW	0aeb0H
	DW	0f0bbH
	DW	032baH
	DW	074b8H
	DW	0b6b9H
	DW	0f8bcH
	DW	03abdH
	DW	07cbfH
	DW	0bebeH
_gft_le64 DW	00H
	DW	0b001H
	DW	06003H
	DW	0d002H
	DW	0c006H
	DW	07007H
	DW	0a005H
	DW	01004H
	DW	0800dH
	DW	0300cH
	DW	0e00eH
	DW	0500fH
	DW	0400bH
	DW	0f00aH
	DW	02008H
	DW	09009H
	DW	01bH
	DW	0b01aH
	DW	06018H
	DW	0d019H
	DW	0c01dH
	DW	0701cH
	DW	0a01eH
	DW	0101fH
	DW	08016H
	DW	03017H
	DW	0e015H
	DW	05014H
	DW	04010H
	DW	0f011H
	DW	02013H
	DW	09012H
	DW	036H
	DW	0b037H
	DW	06035H
	DW	0d034H
	DW	0c030H
	DW	07031H
	DW	0a033H
	DW	01032H
	DW	0803bH
	DW	0303aH
	DW	0e038H
	DW	05039H
	DW	0403dH
	DW	0f03cH
	DW	0203eH
	DW	0903fH
	DW	02dH
	DW	0b02cH
	DW	0602eH
	DW	0d02fH
	DW	0c02bH
	DW	0702aH
	DW	0a028H
	DW	01029H
	DW	08020H
	DW	03021H
	DW	0e023H
	DW	05022H
	DW	04026H
	DW	0f027H
	DW	02025H
	DW	09024H
	DW	06cH
	DW	0b06dH
	DW	0606fH
	DW	0d06eH
	DW	0c06aH
	DW	0706bH
	DW	0a069H
	DW	01068H
	DW	08061H
	DW	03060H
	DW	0e062H
	DW	05063H
	DW	04067H
	DW	0f066H
	DW	02064H
	DW	09065H
	DW	077H
	DW	0b076H
	DW	06074H
	DW	0d075H
	DW	0c071H
	DW	07070H
	DW	0a072H
	DW	01073H
	DW	0807aH
	DW	0307bH
	DW	0e079H
	DW	05078H
	DW	0407cH
	DW	0f07dH
	DW	0207fH
	DW	0907eH
	DW	05aH
	DW	0b05bH
	DW	06059H
	DW	0d058H
	DW	0c05cH
	DW	0705dH
	DW	0a05fH
	DW	0105eH
	DW	08057H
	DW	03056H
	DW	0e054H
	DW	05055H
	DW	04051H
	DW	0f050H
	DW	02052H
	DW	09053H
	DW	041H
	DW	0b040H
	DW	06042H
	DW	0d043H
	DW	0c047H
	DW	07046H
	DW	0a044H
	DW	01045H
	DW	0804cH
	DW	0304dH
	DW	0e04fH
	DW	0504eH
	DW	0404aH
	DW	0f04bH
	DW	02049H
	DW	09048H
	DW	0d8H
	DW	0b0d9H
	DW	060dbH
	DW	0d0daH
	DW	0c0deH
	DW	070dfH
	DW	0a0ddH
	DW	010dcH
	DW	080d5H
	DW	030d4H
	DW	0e0d6H
	DW	050d7H
	DW	040d3H
	DW	0f0d2H
	DW	020d0H
	DW	090d1H
	DW	0c3H
	DW	0b0c2H
	DW	060c0H
	DW	0d0c1H
	DW	0c0c5H
	DW	070c4H
	DW	0a0c6H
	DW	010c7H
	DW	080ceH
	DW	030cfH
	DW	0e0cdH
	DW	050ccH
	DW	040c8H
	DW	0f0c9H
	DW	020cbH
	DW	090caH
	DW	0eeH
	DW	0b0efH
	DW	060edH
	DW	0d0ecH
	DW	0c0e8H
	DW	070e9H
	DW	0a0ebH
	DW	010eaH
	DW	080e3H
	DW	030e2H
	DW	0e0e0H
	DW	050e1H
	DW	040e5H
	DW	0f0e4H
	DW	020e6H
	DW	090e7H
	DW	0f5H
	DW	0b0f4H
	DW	060f6H
	DW	0d0f7H
	DW	0c0f3H
	DW	070f2H
	DW	0a0f0H
	DW	010f1H
	DW	080f8H
	DW	030f9H
	DW	0e0fbH
	DW	050faH
	DW	040feH
	DW	0f0ffH
	DW	020fdH
	DW	090fcH
	DW	0b4H
	DW	0b0b5H
	DW	060b7H
	DW	0d0b6H
	DW	0c0b2H
	DW	070b3H
	DW	0a0b1H
	DW	010b0H
	DW	080b9H
	DW	030b8H
	DW	0e0baH
	DW	050bbH
	DW	040bfH
	DW	0f0beH
	DW	020bcH
	DW	090bdH
	DW	0afH
	DW	0b0aeH
	DW	060acH
	DW	0d0adH
	DW	0c0a9H
	DW	070a8H
	DW	0a0aaH
	DW	010abH
	DW	080a2H
	DW	030a3H
	DW	0e0a1H
	DW	050a0H
	DW	040a4H
	DW	0f0a5H
	DW	020a7H
	DW	090a6H
	DW	082H
	DW	0b083H
	DW	06081H
	DW	0d080H
	DW	0c084H
	DW	07085H
	DW	0a087H
	DW	01086H
	DW	0808fH
	DW	0308eH
	DW	0e08cH
	DW	0508dH
	DW	04089H
	DW	0f088H
	DW	0208aH
	DW	0908bH
	DW	099H
	DW	0b098H
	DW	0609aH
	DW	0d09bH
	DW	0c09fH
	DW	0709eH
	DW	0a09cH
	DW	0109dH
	DW	08094H
	DW	03095H
	DW	0e097H
	DW	05096H
	DW	04092H
	DW	0f093H
	DW	02091H
	DW	09090H
_gft_be	DW	00H
	DW	01c2H
	DW	0384H
	DW	0246H
	DW	0708H
	DW	06caH
	DW	048cH
	DW	054eH
	DW	0e10H
	DW	0fd2H
	DW	0d94H
	DW	0c56H
	DW	0918H
	DW	08daH
	DW	0a9cH
	DW	0b5eH
	DW	01c20H
	DW	01de2H
	DW	01fa4H
	DW	01e66H
	DW	01b28H
	DW	01aeaH
	DW	018acH
	DW	0196eH
	DW	01230H
	DW	013f2H
	DW	011b4H
	DW	01076H
	DW	01538H
	DW	014faH
	DW	016bcH
	DW	0177eH
	DW	03840H
	DW	03982H
	DW	03bc4H
	DW	03a06H
	DW	03f48H
	DW	03e8aH
	DW	03cccH
	DW	03d0eH
	DW	03650H
	DW	03792H
	DW	035d4H
	DW	03416H
	DW	03158H
	DW	0309aH
	DW	032dcH
	DW	0331eH
	DW	02460H
	DW	025a2H
	DW	027e4H
	DW	02626H
	DW	02368H
	DW	022aaH
	DW	020ecH
	DW	0212eH
	DW	02a70H
	DW	02bb2H
	DW	029f4H
	DW	02836H
	DW	02d78H
	DW	02cbaH
	DW	02efcH
	DW	02f3eH
	DW	07080H
	DW	07142H
	DW	07304H
	DW	072c6H
	DW	07788H
	DW	0764aH
	DW	0740cH
	DW	075ceH
	DW	07e90H
	DW	07f52H
	DW	07d14H
	DW	07cd6H
	DW	07998H
	DW	0785aH
	DW	07a1cH
	DW	07bdeH
	DW	06ca0H
	DW	06d62H
	DW	06f24H
	DW	06ee6H
	DW	06ba8H
	DW	06a6aH
	DW	0682cH
	DW	069eeH
	DW	062b0H
	DW	06372H
	DW	06134H
	DW	060f6H
	DW	065b8H
	DW	0647aH
	DW	0663cH
	DW	067feH
	DW	048c0H
	DW	04902H
	DW	04b44H
	DW	04a86H
	DW	04fc8H
	DW	04e0aH
	DW	04c4cH
	DW	04d8eH
	DW	046d0H
	DW	04712H
	DW	04554H
	DW	04496H
	DW	041d8H
	DW	0401aH
	DW	0425cH
	DW	0439eH
	DW	054e0H
	DW	05522H
	DW	05764H
	DW	056a6H
	DW	053e8H
	DW	0522aH
	DW	0506cH
	DW	051aeH
	DW	05af0H
	DW	05b32H
	DW	05974H
	DW	058b6H
	DW	05df8H
	DW	05c3aH
	DW	05e7cH
	DW	05fbeH
	DW	0e100H
	DW	0e0c2H
	DW	0e284H
	DW	0e346H
	DW	0e608H
	DW	0e7caH
	DW	0e58cH
	DW	0e44eH
	DW	0ef10H
	DW	0eed2H
	DW	0ec94H
	DW	0ed56H
	DW	0e818H
	DW	0e9daH
	DW	0eb9cH
	DW	0ea5eH
	DW	0fd20H
	DW	0fce2H
	DW	0fea4H
	DW	0ff66H
	DW	0fa28H
	DW	0fbeaH
	DW	0f9acH
	DW	0f86eH
	DW	0f330H
	DW	0f2f2H
	DW	0f0b4H
	DW	0f176H
	DW	0f438H
	DW	0f5faH
	DW	0f7bcH
	DW	0f67eH
	DW	0d940H
	DW	0d882H
	DW	0dac4H
	DW	0db06H
	DW	0de48H
	DW	0df8aH
	DW	0ddccH
	DW	0dc0eH
	DW	0d750H
	DW	0d692H
	DW	0d4d4H
	DW	0d516H
	DW	0d058H
	DW	0d19aH
	DW	0d3dcH
	DW	0d21eH
	DW	0c560H
	DW	0c4a2H
	DW	0c6e4H
	DW	0c726H
	DW	0c268H
	DW	0c3aaH
	DW	0c1ecH
	DW	0c02eH
	DW	0cb70H
	DW	0cab2H
	DW	0c8f4H
	DW	0c936H
	DW	0cc78H
	DW	0cdbaH
	DW	0cffcH
	DW	0ce3eH
	DW	09180H
	DW	09042H
	DW	09204H
	DW	093c6H
	DW	09688H
	DW	0974aH
	DW	0950cH
	DW	094ceH
	DW	09f90H
	DW	09e52H
	DW	09c14H
	DW	09dd6H
	DW	09898H
	DW	0995aH
	DW	09b1cH
	DW	09adeH
	DW	08da0H
	DW	08c62H
	DW	08e24H
	DW	08fe6H
	DW	08aa8H
	DW	08b6aH
	DW	0892cH
	DW	088eeH
	DW	083b0H
	DW	08272H
	DW	08034H
	DW	081f6H
	DW	084b8H
	DW	0857aH
	DW	0873cH
	DW	086feH
	DW	0a9c0H
	DW	0a802H
	DW	0aa44H
	DW	0ab86H
	DW	0aec8H
	DW	0af0aH
	DW	0ad4cH
	DW	0ac8eH
	DW	0a7d0H
	DW	0a612H
	DW	0a454H
	DW	0a596H
	DW	0a0d8H
	DW	0a11aH
	DW	0a35cH
	DW	0a29eH
	DW	0b5e0H
	DW	0b422H
	DW	0b664H
	DW	0b7a6H
	DW	0b2e8H
	DW	0b32aH
	DW	0b16cH
	DW	0b0aeH
	DW	0bbf0H
	DW	0ba32H
	DW	0b874H
	DW	0b9b6H
	DW	0bcf8H
	DW	0bd3aH
	DW	0bf7cH
	DW	0bebeH
CONST	ENDS
_DATA	SEGMENT
_gf_poly DD	00H
	DD	0e1000000H
_gf_poly64 DD	00H
	DD	0d8000000H
_DATA	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _GfMul64Basic
_TEXT	SEGMENT
_la$2$ = -16						; size = 4
_la$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_p$ = 16						; size = 4
_GfMul64Basic PROC					; COMDAT

; 1104 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 10	 mov	 edi, DWORD PTR _p$[ebp]

; 1105 : 	/* Deprecated/legacy */
; 1106 : 
; 1107 : 	int i;
; 1108 : 	unsigned __int8 la[8];
; 1109 : 	memcpy (la, a, 8);
; 1110 : 	memset (p, 0, 8);
; 1111 : 
; 1112 : 	for (i = 0; i < 64; i++)

  0001c	33 f6		 xor	 esi, esi
  0001e	8b 18		 mov	 ebx, DWORD PTR [eax]
  00020	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00023	89 5d f4	 mov	 DWORD PTR _la$[ebp], ebx
  00026	89 45 f8	 mov	 DWORD PTR _la$[ebp+4], eax
  00029	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0
$LN21@GfMul64Bas:

; 1113 : 	{
; 1114 : 		if (IsBitSet64 (i, b))

  0002d	89 45 f0	 mov	 DWORD PTR _la$2$[ebp], eax
  00030	8b ce		 mov	 ecx, esi
  00032	f7 d1		 not	 ecx
  00034	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00039	83 e1 07	 and	 ecx, 7
  0003c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00041	2b c6		 sub	 eax, esi
  00043	d3 fa		 sar	 edx, cl
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  00048	c1 e8 03	 shr	 eax, 3
  0004b	84 14 08	 test	 dl, BYTE PTR [eax+ecx]
  0004e	74 08		 je	 SHORT $LN11@GfMul64Bas

; 1115 : 			xor64 ((uint64 *)p, (uint64 *)la);

  00050	31 1f		 xor	 DWORD PTR [edi], ebx
  00052	8b 45 f0	 mov	 eax, DWORD PTR _la$2$[ebp]
  00055	31 47 04	 xor	 DWORD PTR [edi+4], eax
$LN11@GfMul64Bas:

; 1116 : 
; 1117 : 		if (la[0] & 0x80)

  00058	f6 45 f4 80	 test	 BYTE PTR _la$[ebp], 128	; 00000080H

; 1118 : 		{
; 1119 : 			shl64 (la);

  0005c	8d 45 f4	 lea	 eax, DWORD PTR _la$[ebp]
  0005f	50		 push	 eax
  00060	74 0e		 je	 SHORT $LN6@GfMul64Bas
  00062	e8 00 00 00 00	 call	 _shl64
  00067	83 c4 04	 add	 esp, 4

; 1120 : 			la[7] ^= 0x1b;

  0006a	80 75 fb 1b	 xor	 BYTE PTR _la$[ebp+7], 27 ; 0000001bH

; 1121 : 		}

  0006e	eb 08		 jmp	 SHORT $LN2@GfMul64Bas
$LN6@GfMul64Bas:

; 1122 : 		else
; 1123 : 		{
; 1124 : 			shl64 (la);

  00070	e8 00 00 00 00	 call	 _shl64
  00075	83 c4 04	 add	 esp, 4
$LN2@GfMul64Bas:

; 1105 : 	/* Deprecated/legacy */
; 1106 : 
; 1107 : 	int i;
; 1108 : 	unsigned __int8 la[8];
; 1109 : 	memcpy (la, a, 8);
; 1110 : 	memset (p, 0, 8);
; 1111 : 
; 1112 : 	for (i = 0; i < 64; i++)

  00078	46		 inc	 esi
  00079	83 fe 40	 cmp	 esi, 64			; 00000040H
  0007c	7d 08		 jge	 SHORT $LN20@GfMul64Bas
  0007e	8b 45 f8	 mov	 eax, DWORD PTR _la$[ebp+4]
  00081	8b 5d f4	 mov	 ebx, DWORD PTR _la$[ebp]
  00084	eb a7		 jmp	 SHORT $LN21@GfMul64Bas
$LN20@GfMul64Bas:

; 1125 : 		}
; 1126 : 	}
; 1127 : }

  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	33 cd		 xor	 ecx, ebp
  0008d	5b		 pop	 ebx
  0008e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_GfMul64Basic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _shl64
_TEXT	SEGMENT
_a$ = 8							; size = 4
_shl64	PROC						; COMDAT

; 1083 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1084 : 	int i, x = 0, xx;
; 1085 : 	for (i = 7; i >= 0; i--)
; 1086 : 	{
; 1087 : 		xx = (a[i] & 0x80) >> 7;

  00004	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  00007	8a 46 07	 mov	 al, BYTE PTR [esi+7]
  0000a	0f b6 c8	 movzx	 ecx, al

; 1088 : 		a[i] = (char) ((a[i] << 1) | x);

  0000d	02 c0		 add	 al, al
  0000f	88 46 07	 mov	 BYTE PTR [esi+7], al
  00012	8a 46 06	 mov	 al, BYTE PTR [esi+6]
  00015	0f b6 d0	 movzx	 edx, al
  00018	02 c0		 add	 al, al
  0001a	c1 e9 07	 shr	 ecx, 7
  0001d	0a c1		 or	 al, cl
  0001f	c1 ea 07	 shr	 edx, 7
  00022	88 46 06	 mov	 BYTE PTR [esi+6], al
  00025	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00028	0f b6 c8	 movzx	 ecx, al
  0002b	02 c0		 add	 al, al
  0002d	0a c2		 or	 al, dl
  0002f	c1 e9 07	 shr	 ecx, 7
  00032	88 46 05	 mov	 BYTE PTR [esi+5], al
  00035	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  00038	0f b6 d0	 movzx	 edx, al
  0003b	02 c0		 add	 al, al
  0003d	0a c1		 or	 al, cl
  0003f	c1 ea 07	 shr	 edx, 7
  00042	88 46 04	 mov	 BYTE PTR [esi+4], al
  00045	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  00048	0f b6 c8	 movzx	 ecx, al
  0004b	02 c0		 add	 al, al
  0004d	0a c2		 or	 al, dl
  0004f	c1 e9 07	 shr	 ecx, 7
  00052	88 46 03	 mov	 BYTE PTR [esi+3], al
  00055	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  00058	0f b6 d0	 movzx	 edx, al
  0005b	02 c0		 add	 al, al
  0005d	0a c1		 or	 al, cl
  0005f	c1 ea 07	 shr	 edx, 7
  00062	88 46 02	 mov	 BYTE PTR [esi+2], al
  00065	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  00068	0f b6 c8	 movzx	 ecx, al
  0006b	02 c0		 add	 al, al
  0006d	0a c2		 or	 al, dl
  0006f	c1 e9 07	 shr	 ecx, 7
  00072	88 46 01	 mov	 BYTE PTR [esi+1], al
  00075	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00078	02 c0		 add	 al, al
  0007a	0a c1		 or	 al, cl
  0007c	88 06		 mov	 BYTE PTR [esi], al
  0007e	5e		 pop	 esi

; 1089 : 		x = xx;
; 1090 : 	}
; 1091 : }

  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_shl64	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _xor64
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_xor64	PROC						; COMDAT

; 1070 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1071 : 	*a ^= *b;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	31 01		 xor	 DWORD PTR [ecx], eax
  0000d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00010	31 41 04	 xor	 DWORD PTR [ecx+4], eax

; 1072 : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_xor64	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _GfMul128Basic
_TEXT	SEGMENT
_la$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_p$ = 16						; size = 4
_GfMul128Basic PROC					; COMDAT

; 1037 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00013	53		 push	 ebx

; 1038 : 	int i;
; 1039 : 	unsigned __int8 la[16];
; 1040 : 	memcpy (la, a, 16);
; 1041 : 	memset (p, 0, 16);
; 1042 : 
; 1043 : 	for (i = 0; i < 128; i++)

  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _b$[ebp]
  00017	56		 push	 esi
  00018	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0001b	57		 push	 edi
  0001c	8b 7d 10	 mov	 edi, DWORD PTR _p$[ebp]
  0001f	33 f6		 xor	 esi, esi
  00021	0f 11 45 ec	 movups	 XMMWORD PTR _la$[ebp], xmm0
  00025	0f 57 c0	 xorps	 xmm0, xmm0
  00028	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0002b	0f 1f 44 00 00	 npad	 5
$LL4@GfMul128Ba:

; 1044 : 	{
; 1045 : 		if (IsBitSet128 (i, b))

  00030	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00035	8b ce		 mov	 ecx, esi
  00037	2b c6		 sub	 eax, esi
  00039	f7 d1		 not	 ecx
  0003b	83 e1 07	 and	 ecx, 7
  0003e	c1 e8 03	 shr	 eax, 3
  00041	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00046	d3 fa		 sar	 edx, cl
  00048	84 14 18	 test	 dl, BYTE PTR [eax+ebx]
  0004b	74 17		 je	 SHORT $LN11@GfMul128Ba

; 1046 : 			xor128 ((uint64 *)p, (uint64 *)la);

  0004d	8b 45 ec	 mov	 eax, DWORD PTR _la$[ebp]
  00050	31 07		 xor	 DWORD PTR [edi], eax
  00052	8b 45 f0	 mov	 eax, DWORD PTR _la$[ebp+4]
  00055	31 47 04	 xor	 DWORD PTR [edi+4], eax
  00058	8b 45 f4	 mov	 eax, DWORD PTR _la$[ebp+8]
  0005b	31 47 08	 xor	 DWORD PTR [edi+8], eax
  0005e	8b 45 f8	 mov	 eax, DWORD PTR _la$[ebp+12]
  00061	31 47 0c	 xor	 DWORD PTR [edi+12], eax
$LN11@GfMul128Ba:

; 1047 : 
; 1048 : 		if (la[0] & 0x80)

  00064	f6 45 ec 80	 test	 BYTE PTR _la$[ebp], 128	; 00000080H

; 1049 : 		{
; 1050 : 			shl128 (la);

  00068	8d 45 ec	 lea	 eax, DWORD PTR _la$[ebp]
  0006b	50		 push	 eax
  0006c	74 0e		 je	 SHORT $LN6@GfMul128Ba
  0006e	e8 00 00 00 00	 call	 _shl128
  00073	83 c4 04	 add	 esp, 4

; 1051 : 			la[15] ^= 0x87;

  00076	80 75 fb 87	 xor	 BYTE PTR _la$[ebp+15], 135 ; 00000087H

; 1052 : 		}

  0007a	eb 08		 jmp	 SHORT $LN2@GfMul128Ba
$LN6@GfMul128Ba:

; 1053 : 		else
; 1054 : 		{
; 1055 : 			shl128 (la);

  0007c	e8 00 00 00 00	 call	 _shl128
  00081	83 c4 04	 add	 esp, 4
$LN2@GfMul128Ba:

; 1038 : 	int i;
; 1039 : 	unsigned __int8 la[16];
; 1040 : 	memcpy (la, a, 16);
; 1041 : 	memset (p, 0, 16);
; 1042 : 
; 1043 : 	for (i = 0; i < 128; i++)

  00084	46		 inc	 esi
  00085	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  0008b	7c a3		 jl	 SHORT $LL4@GfMul128Ba

; 1056 : 		}
; 1057 : 	}
; 1058 : }

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	33 cd		 xor	 ecx, ebp
  00094	5b		 pop	 ebx
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
_GfMul128Basic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _shl128
_TEXT	SEGMENT
_a$ = 8							; size = 4
_shl128	PROC						; COMDAT

; 1016 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1017 : 	int i, x = 0, xx;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	53		 push	 ebx
  00007	33 db		 xor	 ebx, ebx
  00009	83 c0 0e	 add	 eax, 14			; 0000000eH
  0000c	56		 push	 esi
  0000d	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
$LL4@shl128:

; 1018 : 	for (i = 15; i >= 0; i--)
; 1019 : 	{
; 1020 : 		xx = (a[i] & 0x80) >> 7;

  00010	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 1021 : 		a[i] = (char) ((a[i] << 1) | x);
; 1022 : 		x = xx;

  00013	8d 40 fc	 lea	 eax, DWORD PTR [eax-4]
  00016	0f b6 d1	 movzx	 edx, cl
  00019	02 c9		 add	 cl, cl
  0001b	0a cb		 or	 cl, bl
  0001d	c1 ea 07	 shr	 edx, 7
  00020	88 48 05	 mov	 BYTE PTR [eax+5], cl
  00023	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  00026	0f b6 d9	 movzx	 ebx, cl
  00029	02 c9		 add	 cl, cl
  0002b	0a ca		 or	 cl, dl
  0002d	c1 eb 07	 shr	 ebx, 7
  00030	88 48 04	 mov	 BYTE PTR [eax+4], cl
  00033	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00036	0f b6 d1	 movzx	 edx, cl
  00039	02 c9		 add	 cl, cl
  0003b	0a cb		 or	 cl, bl
  0003d	c1 ea 07	 shr	 edx, 7
  00040	88 48 03	 mov	 BYTE PTR [eax+3], cl
  00043	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00046	0f b6 d9	 movzx	 ebx, cl
  00049	02 c9		 add	 cl, cl
  0004b	0a ca		 or	 cl, dl
  0004d	c1 eb 07	 shr	 ebx, 7
  00050	88 48 02	 mov	 BYTE PTR [eax+2], cl
  00053	83 ee 01	 sub	 esi, 1
  00056	75 b8		 jne	 SHORT $LL4@shl128
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx

; 1023 : 	}
; 1024 : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_shl128	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _xor128
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_xor128	PROC						; COMDAT

; 1002 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1003 : 	*a++ ^= *b++;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	31 01		 xor	 DWORD PTR [ecx], eax
  0000d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00010	31 41 04	 xor	 DWORD PTR [ecx+4], eax

; 1004 : 	*a ^= *b;

  00013	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00016	31 41 08	 xor	 DWORD PTR [ecx+8], eax
  00019	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001c	31 41 0c	 xor	 DWORD PTR [ecx+12], eax

; 1005 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_xor128	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _SetBit64
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_a$ = 12						; size = 4
_SetBit64 PROC						; COMDAT

; 771  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 772  : 	a[(63 - bit) / 8] |= 0x80 >> ((63 - bit) % 8);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _bit$[ebp]
  00006	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0000b	2b d1		 sub	 edx, ecx
  0000d	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00012	c1 ea 03	 shr	 edx, 3
  00015	f7 d1		 not	 ecx
  00017	03 55 0c	 add	 edx, DWORD PTR _a$[ebp]
  0001a	83 e1 07	 and	 ecx, 7
  0001d	d3 f8		 sar	 eax, cl
  0001f	08 02		 or	 BYTE PTR [edx], al

; 773  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_SetBit64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _SetBit128
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_a$ = 12						; size = 4
_SetBit128 PROC						; COMDAT

; 757  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 758  : 	a[(127 - bit) / 8] |= 0x80 >> ((127 - bit) % 8);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _bit$[ebp]
  00006	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0000b	2b d1		 sub	 edx, ecx
  0000d	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00012	c1 ea 03	 shr	 edx, 3
  00015	f7 d1		 not	 ecx
  00017	03 55 0c	 add	 edx, DWORD PTR _a$[ebp]
  0001a	83 e1 07	 and	 ecx, 7
  0001d	d3 f8		 sar	 eax, cl
  0001f	08 02		 or	 BYTE PTR [edx], al

; 759  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_SetBit128 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _IsBitSet64
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_a$ = 12						; size = 4
_IsBitSet64 PROC					; COMDAT

; 743  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  : 	return a[(63 - bit) / 8] & (0x80 >> ((63 - bit) % 8));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _bit$[ebp]
  00006	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0000b	2b 55 08	 sub	 edx, DWORD PTR _bit$[ebp]
  0000e	f7 d1		 not	 ecx
  00010	83 e1 07	 and	 ecx, 7
  00013	c1 ea 03	 shr	 edx, 3
  00016	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0001b	d3 f8		 sar	 eax, cl
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00020	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00024	23 c1		 and	 eax, ecx

; 745  : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_IsBitSet64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _IsBitSet128
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_a$ = 12						; size = 4
_IsBitSet128 PROC					; COMDAT

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 730  : 	return a[(127 - bit) / 8] & (0x80 >> ((127 - bit) % 8));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _bit$[ebp]
  00006	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0000b	2b 55 08	 sub	 edx, DWORD PTR _bit$[ebp]
  0000e	f7 d1		 not	 ecx
  00010	83 e1 07	 and	 ecx, 7
  00013	c1 ea 03	 shr	 edx, 3
  00016	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0001b	d3 f8		 sar	 eax, cl
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00020	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00024	23 c1		 and	 eax, ecx

; 731  : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_IsBitSet128 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _compile_4k_table64
_TEXT	SEGMENT
tv497 = -16						; size = 4
tv482 = -16						; size = 4
tv498 = -12						; size = 4
tv490 = -12						; size = 4
tv496 = -8						; size = 4
_j$3$ = -8						; size = 4
_i$1$ = -4						; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_compile_4k_table64 PROC				; COMDAT

; 674  : {   int i, j, k;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 675  : 
; 676  :     memset(ctx->gf_t4k, 0, sizeof(ctx->gf_t4k));

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _ctx$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	68 00 10 00 00	 push	 4096			; 00001000H
  00011	6a 00		 push	 0
  00013	53		 push	 ebx
  00014	e8 00 00 00 00	 call	 _memset
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 677  :     for(i = 0; i < 2 * CBLK_LEN8; ++i)

  0001c	33 ff		 xor	 edi, edi
  0001e	89 7d fc	 mov	 DWORD PTR _i$1$[ebp], edi
$LL4@compile_4k:

; 678  :     {
; 679  :         if(i == 0)

  00021	85 ff		 test	 edi, edi
  00023	0f 85 90 00 00
	00		 jne	 $LN20@compile_4k

; 680  :         {
; 681  :             memcpy(ctx->gf_t4k[1][8], a, CBLK_LEN8);

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]

; 682  :             for(j = 4; j > 0; j >>= 1)

  0002c	be 04 00 00 00	 mov	 esi, 4
  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	89 83 80 01 00
	00		 mov	 DWORD PTR [ebx+384], eax
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	89 83 84 01 00
	00		 mov	 DWORD PTR [ebx+388], eax
$LL7@compile_4k:

; 683  :             {
; 684  :                 memcpy(ctx->gf_t4k[1][j], ctx->gf_t4k[1][j + j], CBLK_LEN8);

  00042	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  00045	c1 e2 04	 shl	 edx, 4
  00048	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0004b	03 d3		 add	 edx, ebx
  0004d	c1 e1 05	 shl	 ecx, 5

; 685  :                 mul_x64(ctx->gf_t4k[1][j]);

  00050	52		 push	 edx
  00051	8b 04 19	 mov	 eax, DWORD PTR [ecx+ebx]
  00054	89 02		 mov	 DWORD PTR [edx], eax
  00056	8b 44 19 04	 mov	 eax, DWORD PTR [ecx+ebx+4]
  0005a	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0005d	e8 00 00 00 00	 call	 _mul_x64
  00062	d1 fe		 sar	 esi, 1
  00064	83 c4 04	 add	 esp, 4
  00067	85 f6		 test	 esi, esi
  00069	7f d7		 jg	 SHORT $LL7@compile_4k

; 686  :             }
; 687  :             memcpy(ctx->gf_t4k[0][8], ctx->gf_t4k[1][1], CBLK_LEN8);

  0006b	8b 83 10 01 00
	00		 mov	 eax, DWORD PTR [ebx+272]
  00071	8d 8b 80 00 00
	00		 lea	 ecx, DWORD PTR [ebx+128]
  00077	89 01		 mov	 DWORD PTR [ecx], eax
  00079	8b 83 14 01 00
	00		 mov	 eax, DWORD PTR [ebx+276]

; 688  :             mul_x64(ctx->gf_t4k[0][8]);

  0007f	51		 push	 ecx
  00080	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00083	e8 00 00 00 00	 call	 _mul_x64
  00088	83 c4 04	 add	 esp, 4

; 689  :             for(j = 4; j > 0; j >>= 1)

  0008b	be 04 00 00 00	 mov	 esi, 4
$LL10@compile_4k:

; 690  :             {
; 691  :                 memcpy(ctx->gf_t4k[0][j], ctx->gf_t4k[0][j + j], CBLK_LEN8);

  00090	8b d6		 mov	 edx, esi
  00092	8b ce		 mov	 ecx, esi
  00094	c1 e2 04	 shl	 edx, 4
  00097	03 d3		 add	 edx, ebx
  00099	c1 e1 05	 shl	 ecx, 5

; 692  :                 mul_x64(ctx->gf_t4k[0][j]);

  0009c	52		 push	 edx
  0009d	8b 04 19	 mov	 eax, DWORD PTR [ecx+ebx]
  000a0	89 02		 mov	 DWORD PTR [edx], eax
  000a2	8b 44 19 04	 mov	 eax, DWORD PTR [ecx+ebx+4]
  000a6	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000a9	e8 00 00 00 00	 call	 _mul_x64
  000ae	d1 fe		 sar	 esi, 1
  000b0	83 c4 04	 add	 esp, 4
  000b3	85 f6		 test	 esi, esi
  000b5	7f d9		 jg	 SHORT $LL10@compile_4k

; 693  :             }
; 694  :         }

  000b7	eb 70		 jmp	 SHORT $LN12@compile_4k
$LN20@compile_4k:

; 695  :         else if(i > 1)

  000b9	83 ff 01	 cmp	 edi, 1
  000bc	7e 6b		 jle	 SHORT $LN12@compile_4k

; 696  :             for(j = 8; j > 0; j >>= 1)

  000be	8d 57 fe	 lea	 edx, DWORD PTR [edi-2]
  000c1	8b c7		 mov	 eax, edi
  000c3	c1 e2 04	 shl	 edx, 4
  000c6	b9 08 00 00 00	 mov	 ecx, 8
  000cb	c1 e0 04	 shl	 eax, 4
  000ce	89 4d f8	 mov	 DWORD PTR _j$3$[ebp], ecx
  000d1	89 55 f4	 mov	 DWORD PTR tv498[ebp], edx
  000d4	89 45 f0	 mov	 DWORD PTR tv497[ebp], eax
$LL13@compile_4k:

; 697  :             {
; 698  :                 memcpy(ctx->gf_t4k[i][j], ctx->gf_t4k[i - 2][j], CBLK_LEN8);

  000d7	8d 3c 01	 lea	 edi, DWORD PTR [ecx+eax]
  000da	03 ca		 add	 ecx, edx
  000dc	03 c9		 add	 ecx, ecx
  000de	c1 e7 04	 shl	 edi, 4
  000e1	03 fb		 add	 edi, ebx
  000e3	8b 04 cb	 mov	 eax, DWORD PTR [ebx+ecx*8]
  000e6	89 07		 mov	 DWORD PTR [edi], eax
  000e8	8b 44 cb 04	 mov	 eax, DWORD PTR [ebx+ecx*8+4]

; 699  :                 mul_x8_64(ctx->gf_t4k[i][j]);

  000ec	8b c8		 mov	 ecx, eax
  000ee	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000f1	8b d1		 mov	 edx, ecx
  000f3	8b 37		 mov	 esi, DWORD PTR [edi]
  000f5	8b c6		 mov	 eax, esi
  000f7	c1 e8 18	 shr	 eax, 24			; 00000018H
  000fa	c1 e1 08	 shl	 ecx, 8
  000fd	0b c1		 or	 eax, ecx
  000ff	c1 ea 18	 shr	 edx, 24			; 00000018H
  00102	8b 4d f8	 mov	 ecx, DWORD PTR _j$3$[ebp]
  00105	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00108	c1 e6 08	 shl	 esi, 8
  0010b	0f b7 04 55 00
	00 00 00	 movzx	 eax, WORD PTR _gft_le64[edx*2]
  00113	8b 55 f4	 mov	 edx, DWORD PTR tv498[ebp]
  00116	33 c6		 xor	 eax, esi
  00118	d1 f9		 sar	 ecx, 1
  0011a	89 07		 mov	 DWORD PTR [edi], eax
  0011c	8b 45 f0	 mov	 eax, DWORD PTR tv497[ebp]
  0011f	89 4d f8	 mov	 DWORD PTR _j$3$[ebp], ecx
  00122	85 c9		 test	 ecx, ecx
  00124	7f b1		 jg	 SHORT $LL13@compile_4k
  00126	8b 7d fc	 mov	 edi, DWORD PTR _i$1$[ebp]
$LN12@compile_4k:
  00129	8b c7		 mov	 eax, edi
  0012b	8b cf		 mov	 ecx, edi
  0012d	c1 e1 04	 shl	 ecx, 4
  00130	8d 7b 10	 lea	 edi, DWORD PTR [ebx+16]
  00133	c1 e0 08	 shl	 eax, 8

; 700  :             }
; 701  : 
; 702  :         for(j = 2; j < 16; j += j)

  00136	be 02 00 00 00	 mov	 esi, 2
  0013b	03 f8		 add	 edi, eax
  0013d	89 4d f8	 mov	 DWORD PTR tv496[ebp], ecx
  00140	89 7d f4	 mov	 DWORD PTR tv490[ebp], edi
$LL16@compile_4k:

; 703  :         {
; 704  :             mode(32t) *pj = ctx->gf_t4k[i][j];

  00143	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]

; 705  :             mode(32t) *pk = ctx->gf_t4k[i][1];

  00146	8b c7		 mov	 eax, edi
  00148	c1 e2 04	 shl	 edx, 4
  0014b	03 d3		 add	 edx, ebx

; 706  :             mode(32t) *pl = ctx->gf_t4k[i][j + 1];

  0014d	8d 4a 10	 lea	 ecx, DWORD PTR [edx+16]

; 707  : 
; 708  :             for(k = 1; k < j; ++k)

  00150	83 fe 01	 cmp	 esi, 1
  00153	7e 3f		 jle	 SHORT $LN14@compile_4k
  00155	2b cf		 sub	 ecx, edi
  00157	8d 7e ff	 lea	 edi, DWORD PTR [esi-1]
  0015a	89 4d f0	 mov	 DWORD PTR tv482[ebp], ecx
  0015d	8b d9		 mov	 ebx, ecx
  0015f	90		 npad	 1
$LL19@compile_4k:

; 709  :             {
; 710  :                 *pl++ = pj[0] ^ *pk++;

  00160	8b 08		 mov	 ecx, DWORD PTR [eax]
  00162	8d 40 10	 lea	 eax, DWORD PTR [eax+16]
  00165	33 0a		 xor	 ecx, DWORD PTR [edx]
  00167	89 4c 03 f0	 mov	 DWORD PTR [ebx+eax-16], ecx
  0016b	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  0016e	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  00171	89 4c 03 f4	 mov	 DWORD PTR [ebx+eax-12], ecx
  00175	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00178	33 4a 08	 xor	 ecx, DWORD PTR [edx+8]
  0017b	89 4c 03 f8	 mov	 DWORD PTR [ebx+eax-8], ecx
  0017f	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00182	33 4a 0c	 xor	 ecx, DWORD PTR [edx+12]
  00185	89 4c 03 fc	 mov	 DWORD PTR [ebx+eax-4], ecx
  00189	83 ef 01	 sub	 edi, 1
  0018c	75 d2		 jne	 SHORT $LL19@compile_4k
  0018e	8b 5d 0c	 mov	 ebx, DWORD PTR _ctx$[ebp]
  00191	8b 7d f4	 mov	 edi, DWORD PTR tv490[ebp]
$LN14@compile_4k:

; 700  :             }
; 701  : 
; 702  :         for(j = 2; j < 16; j += j)

  00194	8b 4d f8	 mov	 ecx, DWORD PTR tv496[ebp]
  00197	03 f6		 add	 esi, esi
  00199	83 fe 10	 cmp	 esi, 16			; 00000010H
  0019c	7c a5		 jl	 SHORT $LL16@compile_4k

; 677  :     for(i = 0; i < 2 * CBLK_LEN8; ++i)

  0019e	8b 7d fc	 mov	 edi, DWORD PTR _i$1$[ebp]
  001a1	47		 inc	 edi
  001a2	89 7d fc	 mov	 DWORD PTR _i$1$[ebp], edi
  001a5	83 ff 10	 cmp	 edi, 16			; 00000010H
  001a8	0f 8c 73 fe ff
	ff		 jl	 $LL4@compile_4k
  001ae	5f		 pop	 edi
  001af	5e		 pop	 esi
  001b0	5b		 pop	 ebx

; 711  :                 *pl++ = pj[1] ^ *pk++;
; 712  :                 *pl++ = pj[2] ^ *pk++;
; 713  :                 *pl++ = pj[3] ^ *pk++;
; 714  :             }
; 715  :         }
; 716  :     }
; 717  : }

  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c3		 ret	 0
_compile_4k_table64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _compile_8k_table
_TEXT	SEGMENT
tv527 = -16						; size = 4
tv506 = -16						; size = 4
tv528 = -12						; size = 4
tv516 = -12						; size = 4
tv526 = -8						; size = 4
_j$3$ = -8						; size = 4
_i$1$ = -4						; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_compile_8k_table PROC					; COMDAT

; 618  : {   int i, j, k;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 619  : 
; 620  :     memset(ctx->gf_t8k, 0, 32 * 16 * 16);

  00008	8b 75 0c	 mov	 esi, DWORD PTR _ctx$[ebp]
  0000b	57		 push	 edi
  0000c	68 00 20 00 00	 push	 8192			; 00002000H
  00011	6a 00		 push	 0
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 _memset
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 621  :     for(i = 0; i < 2 * CBLK_LEN; ++i)

  0001c	33 c0		 xor	 eax, eax
  0001e	89 45 fc	 mov	 DWORD PTR _i$1$[ebp], eax
$LL4@compile_8k:

; 622  :     {
; 623  :         if(i == 0)

  00021	85 c0		 test	 eax, eax
  00023	0f 85 80 00 00
	00		 jne	 $LN20@compile_8k

; 624  :         {
; 625  :             memcpy(ctx->gf_t8k[1][8], a, CBLK_LEN);

  00029	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]

; 626  :             for(j = 4; j > 0; j >>= 1)

  0002c	bf 04 00 00 00	 mov	 edi, 4
  00031	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00034	0f 11 86 80 01
	00 00		 movups	 XMMWORD PTR [esi+384], xmm0
  0003b	0f 1f 44 00 00	 npad	 5
$LL7@compile_8k:

; 627  :             {
; 628  :                 memcpy(ctx->gf_t8k[1][j], ctx->gf_t8k[1][j + j], CBLK_LEN);

  00040	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00043	c1 e0 05	 shl	 eax, 5
  00046	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00049	c1 e1 04	 shl	 ecx, 4
  0004c	03 ce		 add	 ecx, esi

; 629  :                 mul_x(ctx->gf_t8k[1][j]);

  0004e	51		 push	 ecx
  0004f	0f 10 04 30	 movups	 xmm0, XMMWORD PTR [eax+esi]
  00053	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00056	e8 00 00 00 00	 call	 _mul_x
  0005b	d1 ff		 sar	 edi, 1
  0005d	83 c4 04	 add	 esp, 4
  00060	85 ff		 test	 edi, edi
  00062	7f dc		 jg	 SHORT $LL7@compile_8k

; 630  :             }
; 631  :             memcpy(ctx->gf_t8k[0][8], ctx->gf_t8k[1][1], CBLK_LEN);

  00064	0f 10 86 10 01
	00 00		 movups	 xmm0, XMMWORD PTR [esi+272]
  0006b	8d 86 80 00 00
	00		 lea	 eax, DWORD PTR [esi+128]

; 632  :             mul_x(ctx->gf_t8k[0][8]);

  00071	50		 push	 eax
  00072	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00075	e8 00 00 00 00	 call	 _mul_x
  0007a	83 c4 04	 add	 esp, 4

; 633  :             for(j = 4; j > 0; j >>= 1)

  0007d	bf 04 00 00 00	 mov	 edi, 4
$LL10@compile_8k:

; 634  :             {
; 635  :                 memcpy(ctx->gf_t8k[0][j], ctx->gf_t8k[0][j + j], CBLK_LEN);

  00082	8b c7		 mov	 eax, edi
  00084	8b cf		 mov	 ecx, edi
  00086	c1 e0 05	 shl	 eax, 5
  00089	c1 e1 04	 shl	 ecx, 4
  0008c	03 ce		 add	 ecx, esi

; 636  :                 mul_x(ctx->gf_t8k[0][j]);

  0008e	51		 push	 ecx
  0008f	0f 10 04 30	 movups	 xmm0, XMMWORD PTR [eax+esi]
  00093	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00096	e8 00 00 00 00	 call	 _mul_x
  0009b	d1 ff		 sar	 edi, 1
  0009d	83 c4 04	 add	 esp, 4
  000a0	85 ff		 test	 edi, edi
  000a2	7f de		 jg	 SHORT $LL10@compile_8k

; 637  :             }
; 638  :         }

  000a4	e9 96 00 00 00	 jmp	 $LN65@compile_8k
$LN20@compile_8k:

; 639  :         else if(i > 1)

  000a9	83 f8 01	 cmp	 eax, 1
  000ac	0f 8e 90 00 00
	00		 jle	 $LN12@compile_8k

; 640  :             for(j = 8; j > 0; j >>= 1)

  000b2	8d 50 fe	 lea	 edx, DWORD PTR [eax-2]
  000b5	b9 08 00 00 00	 mov	 ecx, 8
  000ba	c1 e2 04	 shl	 edx, 4
  000bd	c1 e0 04	 shl	 eax, 4
  000c0	89 4d f8	 mov	 DWORD PTR _j$3$[ebp], ecx
  000c3	89 55 f4	 mov	 DWORD PTR tv528[ebp], edx
  000c6	89 45 f0	 mov	 DWORD PTR tv527[ebp], eax
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@compile_8k:

; 641  :             {
; 642  :                 memcpy(ctx->gf_t8k[i][j], ctx->gf_t8k[i - 2][j], CBLK_LEN);

  000d0	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]
  000d3	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  000d6	c1 e3 04	 shl	 ebx, 4
  000d9	03 c0		 add	 eax, eax
  000db	03 de		 add	 ebx, esi
  000dd	0f 10 04 c6	 movups	 xmm0, XMMWORD PTR [esi+eax*8]
  000e1	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0

; 643  :                 mul_x8(ctx->gf_t8k[i][j]);

  000e4	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  000e7	8b c6		 mov	 eax, esi
  000e9	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  000ec	8b f9		 mov	 edi, ecx
  000ee	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  000f1	c1 e8 18	 shr	 eax, 24			; 00000018H
  000f4	c1 e1 08	 shl	 ecx, 8
  000f7	0b c1		 or	 eax, ecx
  000f9	c1 e6 08	 shl	 esi, 8
  000fc	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000fe	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00101	8b c2		 mov	 eax, edx
  00103	c1 e8 18	 shr	 eax, 24			; 00000018H
  00106	0b c6		 or	 eax, esi
  00108	c1 e2 08	 shl	 edx, 8
  0010b	8b 75 0c	 mov	 esi, DWORD PTR _ctx$[ebp]
  0010e	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00111	8b c1		 mov	 eax, ecx
  00113	c1 e8 18	 shr	 eax, 24			; 00000018H
  00116	0b c2		 or	 eax, edx
  00118	c1 ef 18	 shr	 edi, 24			; 00000018H
  0011b	8b 55 f4	 mov	 edx, DWORD PTR tv528[ebp]
  0011e	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00121	c1 e1 08	 shl	 ecx, 8
  00124	0f b7 04 7d 00
	00 00 00	 movzx	 eax, WORD PTR _gft_le[edi*2]
  0012c	33 c1		 xor	 eax, ecx
  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _j$3$[ebp]
  00131	d1 f9		 sar	 ecx, 1
  00133	89 03		 mov	 DWORD PTR [ebx], eax
  00135	8b 45 f0	 mov	 eax, DWORD PTR tv527[ebp]
  00138	89 4d f8	 mov	 DWORD PTR _j$3$[ebp], ecx
  0013b	85 c9		 test	 ecx, ecx
  0013d	7f 91		 jg	 SHORT $LL13@compile_8k
$LN65@compile_8k:
  0013f	8b 45 fc	 mov	 eax, DWORD PTR _i$1$[ebp]
$LN12@compile_8k:
  00142	8b c8		 mov	 ecx, eax
  00144	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  00147	c1 e1 04	 shl	 ecx, 4

; 644  :             }
; 645  : 
; 646  :         for(j = 2; j < 16; j += j)

  0014a	bb 02 00 00 00	 mov	 ebx, 2
  0014f	c1 e0 08	 shl	 eax, 8
  00152	03 f8		 add	 edi, eax
  00154	89 4d f8	 mov	 DWORD PTR tv526[ebp], ecx
  00157	89 7d f4	 mov	 DWORD PTR tv516[ebp], edi
  0015a	66 0f 1f 44 00
	00		 npad	 6
$LL16@compile_8k:

; 647  :         {
; 648  :             mode(32t) *pj = ctx->gf_t8k[i][j];

  00160	8d 14 19	 lea	 edx, DWORD PTR [ecx+ebx]

; 649  :             mode(32t) *pk = ctx->gf_t8k[i][1];

  00163	8b c7		 mov	 eax, edi
  00165	c1 e2 04	 shl	 edx, 4
  00168	03 d6		 add	 edx, esi

; 650  :             mode(32t) *pl = ctx->gf_t8k[i][j + 1];

  0016a	8d 4a 10	 lea	 ecx, DWORD PTR [edx+16]

; 651  : 
; 652  :             for(k = 1; k < j; ++k)

  0016d	83 fb 01	 cmp	 ebx, 1
  00170	7e 42		 jle	 SHORT $LN14@compile_8k
  00172	2b cf		 sub	 ecx, edi
  00174	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
  00177	89 4d f0	 mov	 DWORD PTR tv506[ebp], ecx
  0017a	8b f1		 mov	 esi, ecx
  0017c	0f 1f 40 00	 npad	 4
$LL19@compile_8k:

; 653  :             {
; 654  :                 *pl++ = pj[0] ^ *pk++;

  00180	8b 08		 mov	 ecx, DWORD PTR [eax]
  00182	8d 40 10	 lea	 eax, DWORD PTR [eax+16]
  00185	33 0a		 xor	 ecx, DWORD PTR [edx]
  00187	89 4c 06 f0	 mov	 DWORD PTR [esi+eax-16], ecx
  0018b	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  0018e	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  00191	89 4c 06 f4	 mov	 DWORD PTR [esi+eax-12], ecx
  00195	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00198	33 4a 08	 xor	 ecx, DWORD PTR [edx+8]
  0019b	89 4c 06 f8	 mov	 DWORD PTR [esi+eax-8], ecx
  0019f	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  001a2	33 4a 0c	 xor	 ecx, DWORD PTR [edx+12]
  001a5	89 4c 06 fc	 mov	 DWORD PTR [esi+eax-4], ecx
  001a9	83 ef 01	 sub	 edi, 1
  001ac	75 d2		 jne	 SHORT $LL19@compile_8k
  001ae	8b 75 0c	 mov	 esi, DWORD PTR _ctx$[ebp]
  001b1	8b 7d f4	 mov	 edi, DWORD PTR tv516[ebp]
$LN14@compile_8k:

; 644  :             }
; 645  : 
; 646  :         for(j = 2; j < 16; j += j)

  001b4	8b 4d f8	 mov	 ecx, DWORD PTR tv526[ebp]
  001b7	03 db		 add	 ebx, ebx
  001b9	83 fb 10	 cmp	 ebx, 16			; 00000010H
  001bc	7c a2		 jl	 SHORT $LL16@compile_8k

; 621  :     for(i = 0; i < 2 * CBLK_LEN; ++i)

  001be	8b 45 fc	 mov	 eax, DWORD PTR _i$1$[ebp]
  001c1	40		 inc	 eax
  001c2	89 45 fc	 mov	 DWORD PTR _i$1$[ebp], eax
  001c5	83 f8 20	 cmp	 eax, 32			; 00000020H
  001c8	0f 8c 53 fe ff
	ff		 jl	 $LL4@compile_8k
  001ce	5f		 pop	 edi
  001cf	5e		 pop	 esi
  001d0	5b		 pop	 ebx

; 655  :                 *pl++ = pj[1] ^ *pk++;
; 656  :                 *pl++ = pj[2] ^ *pk++;
; 657  :                 *pl++ = pj[3] ^ *pk++;
; 658  :             }
; 659  :         }
; 660  :     }
; 661  : }

  001d1	8b e5		 mov	 esp, ebp
  001d3	5d		 pop	 ebp
  001d4	c3		 ret	 0
_compile_8k_table ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _mul_bex8
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_bex8 PROC						; COMDAT

; 468  : {   mode(32t)   t = (x[3] & 0xff);      /* in big endian format     */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _x$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi

; 469  :     x[3] = (x[3] >> 8) | (x[2] << 24);

  00009	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  0000c	8b c6		 mov	 eax, esi
  0000e	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 470  :     x[2] = (x[2] >> 8) | (x[1] << 24);

  00011	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00014	c1 e0 18	 shl	 eax, 24			; 00000018H
  00017	0f b6 f9	 movzx	 edi, cl
  0001a	c1 e9 08	 shr	 ecx, 8
  0001d	0b c1		 or	 eax, ecx
  0001f	c1 ee 08	 shr	 esi, 8

; 471  :     x[1] = (x[1] >> 8) | (x[0] << 24);

  00022	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00024	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00027	8b c2		 mov	 eax, edx
  00029	c1 e0 18	 shl	 eax, 24			; 00000018H
  0002c	0b c6		 or	 eax, esi
  0002e	c1 ea 08	 shr	 edx, 8
  00031	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00034	8b c1		 mov	 eax, ecx
  00036	c1 e0 18	 shl	 eax, 24			; 00000018H
  00039	0b c2		 or	 eax, edx

; 472  :     x[0] = (x[0] >> 8) ^ (((mode(32t))gft_be[t]) << 16);

  0003b	c1 e9 08	 shr	 ecx, 8
  0003e	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00041	0f b7 04 7d 00
	00 00 00	 movzx	 eax, WORD PTR _gft_be[edi*2]
  00049	c1 e0 10	 shl	 eax, 16			; 00000010H
  0004c	5f		 pop	 edi
  0004d	33 c1		 xor	 eax, ecx
  0004f	5e		 pop	 esi
  00050	89 03		 mov	 DWORD PTR [ebx], eax
  00052	5b		 pop	 ebx

; 473  : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_mul_bex8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _mul_lex8_64
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_lex8_64 PROC					; COMDAT

; 445  : {   mode(32t)   t = (x[1] >> 24);       /* in little endian format  */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR _x$[ebp]
  00008	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000b	8b d1		 mov	 edx, ecx

; 446  :     x[1] = (x[1] << 8) | (x[0] >> 24);

  0000d	8b 37		 mov	 esi, DWORD PTR [edi]
  0000f	8b c6		 mov	 eax, esi
  00011	c1 e8 18	 shr	 eax, 24			; 00000018H
  00014	c1 ea 18	 shr	 edx, 24			; 00000018H
  00017	c1 e1 08	 shl	 ecx, 8
  0001a	0b c1		 or	 eax, ecx

; 447  :     x[0] = (x[0] << 8) ^ gft_le64[t];

  0001c	c1 e6 08	 shl	 esi, 8
  0001f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00022	0f b7 04 55 00
	00 00 00	 movzx	 eax, WORD PTR _gft_le64[edx*2]
  0002a	33 c6		 xor	 eax, esi
  0002c	89 07		 mov	 DWORD PTR [edi], eax
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 448  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_mul_lex8_64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _mul_lex8
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_lex8 PROC						; COMDAT

; 429  : {   mode(32t)   t = (x[3] >> 24);       /* in little endian format  */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _x$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi

; 430  :     x[3] = (x[3] << 8) | (x[2] >> 24);

  00009	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  0000c	8b c6		 mov	 eax, esi
  0000e	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00011	8b f9		 mov	 edi, ecx

; 431  :     x[2] = (x[2] << 8) | (x[1] >> 24);

  00013	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00016	c1 e8 18	 shr	 eax, 24			; 00000018H
  00019	c1 e1 08	 shl	 ecx, 8
  0001c	0b c1		 or	 eax, ecx
  0001e	c1 e6 08	 shl	 esi, 8

; 432  :     x[1] = (x[1] << 8) | (x[0] >> 24);

  00021	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00023	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00026	8b c2		 mov	 eax, edx
  00028	c1 e8 18	 shr	 eax, 24			; 00000018H
  0002b	0b c6		 or	 eax, esi
  0002d	c1 ef 18	 shr	 edi, 24			; 00000018H
  00030	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00033	8b c1		 mov	 eax, ecx
  00035	c1 e8 18	 shr	 eax, 24			; 00000018H
  00038	c1 e2 08	 shl	 edx, 8
  0003b	0b c2		 or	 eax, edx

; 433  :     x[0] = (x[0] << 8) ^ gft_le[t];

  0003d	c1 e1 08	 shl	 ecx, 8
  00040	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00043	0f b7 04 7d 00
	00 00 00	 movzx	 eax, WORD PTR _gft_le[edi*2]
  0004b	5f		 pop	 edi
  0004c	33 c1		 xor	 eax, ecx
  0004e	5e		 pop	 esi
  0004f	89 03		 mov	 DWORD PTR [ebx], eax
  00051	5b		 pop	 ebx

; 434  : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_mul_lex8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _mul_x64
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_x64 PROC						; COMDAT

; 391  : {   mode(32t)   t;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 392  : 
; 393  :     bsw_32(x, 2);

  00004	8b 7d 08	 mov	 edi, DWORD PTR _x$[ebp]
  00007	b8 02 00 00 00	 mov	 eax, 2
  0000c	0f 1f 40 00	 npad	 4
$LL4@mul_x64:
  00010	8b 54 87 fc	 mov	 edx, DWORD PTR [edi+eax*4-4]
  00014	48		 dec	 eax
  00015	8b ca		 mov	 ecx, edx
  00017	c1 c2 08	 rol	 edx, 8
  0001a	c1 c9 08	 ror	 ecx, 8
  0001d	81 e2 ff 00 ff
	00		 and	 edx, 16711935		; 00ff00ffH
  00023	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  00029	0b ca		 or	 ecx, edx
  0002b	89 0c 87	 mov	 DWORD PTR [edi+eax*4], ecx
  0002e	85 c0		 test	 eax, eax
  00030	75 de		 jne	 SHORT $LL4@mul_x64

; 394  : 
; 395  :     /* at this point the filed element bits 0..127 are set out  */
; 396  :     /* as follows in 32-bit words (where the most significant   */
; 397  :     /* (ms) numeric bits are to the left)                       */
; 398  :     /*                                                          */
; 399  :     /*            x[0]      x[1]      x[2]      x[3]            */
; 400  :     /*          ms    ls  ms    ls  ms    ls  ms     ls         */
; 401  :     /* field:   0 ... 31  32 .. 63  64 .. 95  96 .. 127         */
; 402  : 
; 403  :     t = gf_poly64[x[1] & 1];          /* bit 127 of the element   */

  00032	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00035	8b c1		 mov	 eax, ecx
  00037	83 e0 01	 and	 eax, 1

; 404  : 										/* shift bits up by one */
; 405  : 										/* position             */
; 406  :     x[1] = (x[1] >> 1) | (x[0] << 31);  /* if bit 7 is 1 xor in */

  0003a	d1 e9		 shr	 ecx, 1
  0003c	56		 push	 esi
  0003d	8b 37		 mov	 esi, DWORD PTR [edi]
  0003f	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _gf_poly64[eax*4]
  00046	8b c6		 mov	 eax, esi
  00048	c1 e0 1f	 shl	 eax, 31			; 0000001fH

; 407  :     x[0] = (x[0] >> 1) ^ t;             /* the field polynomial */

  0004b	d1 ee		 shr	 esi, 1
  0004d	0b c1		 or	 eax, ecx
  0004f	33 f2		 xor	 esi, edx
  00051	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00054	89 37		 mov	 DWORD PTR [edi], esi

; 408  :     bsw_32(x, 2);

  00056	ba 02 00 00 00	 mov	 edx, 2
  0005b	5e		 pop	 esi
  0005c	0f 1f 40 00	 npad	 4
$LL8@mul_x64:
  00060	8b 4c 97 fc	 mov	 ecx, DWORD PTR [edi+edx*4-4]
  00064	4a		 dec	 edx
  00065	8b c1		 mov	 eax, ecx
  00067	c1 c1 08	 rol	 ecx, 8
  0006a	c1 c8 08	 ror	 eax, 8
  0006d	81 e1 ff 00 ff
	00		 and	 ecx, 16711935		; 00ff00ffH
  00073	25 00 ff 00 ff	 and	 eax, -16711936		; ff00ff00H
  00078	0b c1		 or	 eax, ecx
  0007a	89 04 97	 mov	 DWORD PTR [edi+edx*4], eax
  0007d	85 d2		 test	 edx, edx
  0007f	75 df		 jne	 SHORT $LL8@mul_x64
  00081	5f		 pop	 edi

; 409  : }

  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_mul_x64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _mul_x
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_x	PROC						; COMDAT

; 362  : {   mode(32t)   t;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 363  : 
; 364  :     bsw_32(x, 4);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _x$[ebp]
  00007	b8 04 00 00 00	 mov	 eax, 4
  0000c	0f 1f 40 00	 npad	 4
$LL4@mul_x:
  00010	8b 54 83 fc	 mov	 edx, DWORD PTR [ebx+eax*4-4]
  00014	48		 dec	 eax
  00015	8b ca		 mov	 ecx, edx
  00017	c1 c2 08	 rol	 edx, 8
  0001a	c1 c9 08	 ror	 ecx, 8
  0001d	81 e2 ff 00 ff
	00		 and	 edx, 16711935		; 00ff00ffH
  00023	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  00029	0b ca		 or	 ecx, edx
  0002b	89 0c 83	 mov	 DWORD PTR [ebx+eax*4], ecx
  0002e	85 c0		 test	 eax, eax
  00030	75 de		 jne	 SHORT $LL4@mul_x

; 365  : 
; 366  :     /* at this point the filed element bits 0..127 are set out  */
; 367  :     /* as follows in 32-bit words (where the most significant   */
; 368  :     /* (ms) numeric bits are to the left)                       */
; 369  :     /*                                                          */
; 370  :     /*            x[0]      x[1]      x[2]      x[3]            */
; 371  :     /*          ms    ls  ms    ls  ms    ls  ms     ls         */
; 372  :     /* field:   0 ... 31  32 .. 63  64 .. 95  96 .. 127         */
; 373  : 
; 374  :     t = gf_poly[x[3] & 1];          /* bit 127 of the element   */

  00032	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00035	8b c1		 mov	 eax, ecx

; 375  :     x[3] = (x[3] >> 1) | (x[2] << 31);  /* shift bits up by one */
; 376  :     x[2] = (x[2] >> 1) | (x[1] << 31);  /* position             */

  00037	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0003a	83 e0 01	 and	 eax, 1
  0003d	56		 push	 esi
  0003e	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00041	57		 push	 edi
  00042	8b 3c 85 00 00
	00 00		 mov	 edi, DWORD PTR _gf_poly[eax*4]
  00049	8b c6		 mov	 eax, esi
  0004b	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  0004e	d1 e9		 shr	 ecx, 1
  00050	0b c1		 or	 eax, ecx
  00052	d1 ee		 shr	 esi, 1

; 377  :     x[1] = (x[1] >> 1) | (x[0] << 31);  /* if bit 7 is 1 xor in */

  00054	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00056	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  0005e	0b c6		 or	 eax, esi
  00060	d1 ea		 shr	 edx, 1
  00062	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00065	8b c1		 mov	 eax, ecx
  00067	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  0006a	0b c2		 or	 eax, edx

; 378  :     x[0] = (x[0] >> 1) ^ t;             /* the field polynomial */

  0006c	d1 e9		 shr	 ecx, 1
  0006e	33 cf		 xor	 ecx, edi
  00070	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00073	5f		 pop	 edi
  00074	89 0b		 mov	 DWORD PTR [ebx], ecx

; 379  :     bsw_32(x, 4);

  00076	ba 04 00 00 00	 mov	 edx, 4
  0007b	5e		 pop	 esi
  0007c	0f 1f 40 00	 npad	 4
$LL8@mul_x:
  00080	8b 4c 93 fc	 mov	 ecx, DWORD PTR [ebx+edx*4-4]
  00084	4a		 dec	 edx
  00085	8b c1		 mov	 eax, ecx
  00087	c1 c1 08	 rol	 ecx, 8
  0008a	c1 c8 08	 ror	 eax, 8
  0008d	81 e1 ff 00 ff
	00		 and	 ecx, 16711935		; 00ff00ffH
  00093	25 00 ff 00 ff	 and	 eax, -16711936		; ff00ff00H
  00098	0b c1		 or	 eax, ecx
  0009a	89 04 93	 mov	 DWORD PTR [ebx+edx*4], eax
  0009d	85 d2		 test	 edx, edx
  0009f	75 df		 jne	 SHORT $LL8@mul_x
  000a1	5b		 pop	 ebx

; 380  : }

  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_mul_x	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _xor_block_aligned64
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_xor_block_aligned64 PROC				; COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  :     lp32(p)[0] ^= lp32(q)[0], lp32(p)[1] ^= lp32(q)[1];

  00003	8b 55 0c	 mov	 edx, DWORD PTR _q$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	31 01		 xor	 DWORD PTR [ecx], eax
  0000d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00010	31 41 04	 xor	 DWORD PTR [ecx+4], eax

; 235  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_xor_block_aligned64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _xor_block_aligned
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_xor_block_aligned PROC					; COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 219  :     lp32(p)[0] ^= lp32(q)[0], lp32(p)[1] ^= lp32(q)[1],
; 220  :     lp32(p)[2] ^= lp32(q)[2], lp32(p)[3] ^= lp32(q)[3];

  00003	8b 55 0c	 mov	 edx, DWORD PTR _q$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	31 01		 xor	 DWORD PTR [ecx], eax
  0000d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00010	31 41 04	 xor	 DWORD PTR [ecx+4], eax
  00013	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00016	31 41 08	 xor	 DWORD PTR [ecx+8], eax
  00019	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001c	31 41 0c	 xor	 DWORD PTR [ecx+12], eax

; 221  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_xor_block_aligned ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _move_block_aligned64
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_move_block_aligned64 PROC				; COMDAT

; 204  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  :     lp32(p)[0] = lp32(q)[0], lp32(p)[1] = lp32(q)[1];

  00003	8b 55 0c	 mov	 edx, DWORD PTR _q$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00010	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 206  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_move_block_aligned64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _move_block_aligned
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_move_block_aligned PROC				; COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  :     lp32(p)[0] = lp32(q)[0], lp32(p)[1] = lp32(q)[1],
; 191  :     lp32(p)[2] = lp32(q)[2], lp32(p)[3] = lp32(q)[3];

  00003	8b 55 0c	 mov	 edx, DWORD PTR _q$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00010	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00013	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00016	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00019	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 192  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_move_block_aligned ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _bsw_32
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$ = 12						; size = 4
_bsw_32	PROC						; COMDAT

; 140  : {   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 141  : 	unsigned int i = n;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]

; 142  :     while(i--)

  00006	85 c0		 test	 eax, eax
  00008	74 29		 je	 SHORT $LN6@bsw_32
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  0000e	66 90		 npad	 2
$LL2@bsw_32:

; 143  :         ((mode(32t)*)p)[i] = bswap_32(((mode(32t)*)p)[i]);

  00010	8b 54 86 fc	 mov	 edx, DWORD PTR [esi+eax*4-4]
  00014	48		 dec	 eax
  00015	8b ca		 mov	 ecx, edx
  00017	c1 c2 08	 rol	 edx, 8
  0001a	c1 c9 08	 ror	 ecx, 8
  0001d	81 e2 ff 00 ff
	00		 and	 edx, 16711935		; 00ff00ffH
  00023	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  00029	0b ca		 or	 ecx, edx
  0002b	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  0002e	85 c0		 test	 eax, eax
  00030	75 de		 jne	 SHORT $LL2@bsw_32
  00032	5e		 pop	 esi
$LN6@bsw_32:

; 144  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_bsw_32	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _GfMulSelfTest
_TEXT	SEGMENT
_gfCtx$1$ = -72						; size = 4
_p2$ = -68						; size = 16
_p1$ = -52						; size = 16
_b$ = -36						; size = 16
_a$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_GfMulSelfTest PROC					; COMDAT

; 1139 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 1140 : 	BOOL result = TRUE;
; 1141 : 	unsigned __int8 a[16];
; 1142 : 	unsigned __int8 b[16];
; 1143 : 	unsigned __int8 p1[16];
; 1144 : 	unsigned __int8 p2[16];
; 1145 : 	GfCtx *gfCtx = (GfCtx *) GSTalloc (sizeof (GfCtx));

  00012	68 00 18 00 00	 push	 6144			; 00001800H
  00017	bf 01 00 00 00	 mov	 edi, 1
  0001c	e8 00 00 00 00	 call	 _malloc
  00021	8b f0		 mov	 esi, eax
  00023	83 c4 04	 add	 esp, 4
  00026	89 75 b8	 mov	 DWORD PTR _gfCtx$1$[ebp], esi

; 1146 : 	int i, j;
; 1147 : 
; 1148 : 	if (!gfCtx)

  00029	85 f6		 test	 esi, esi
  0002b	75 10		 jne	 SHORT $LN14@GfMulSelfT
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi

; 1188 : 	return result;
; 1189 : }

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00032	33 cd		 xor	 ecx, ebp
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN14@GfMulSelfT:
  0003d	53		 push	 ebx

; 1149 : 		return FALSE;
; 1150 : 
; 1151 : 	/* GF(2^64) - deprecated/legacy */
; 1152 : 	for (i = 0; i < 0x100; i++)

  0003e	33 db		 xor	 ebx, ebx
$LL4@GfMulSelfT:

; 1153 : 	{
; 1154 : 		for (j = 0; j < 8; j++)
; 1155 : 		{
; 1156 : 			a[j] = (unsigned __int8) i;
; 1157 : 			b[j] = a[j] ^ 0xff;
; 1158 : 		}
; 1159 : 
; 1160 : 		GfMul64Basic (a, b, p1);

  00040	8a cb		 mov	 cl, bl
  00042	8d 45 cc	 lea	 eax, DWORD PTR _p1$[ebp]
  00045	f6 d1		 not	 cl
  00047	0f b6 c9	 movzx	 ecx, cl
  0004a	69 c9 01 01 01
	01		 imul	 ecx, 16843009		; 01010101H
  00050	50		 push	 eax
  00051	8d 45 dc	 lea	 eax, DWORD PTR _b$[ebp]
  00054	50		 push	 eax
  00055	8d 45 ec	 lea	 eax, DWORD PTR _a$[ebp]
  00058	89 4d dc	 mov	 DWORD PTR _b$[ebp], ecx
  0005b	89 4d e0	 mov	 DWORD PTR _b$[ebp+4], ecx
  0005e	8a cb		 mov	 cl, bl
  00060	0f b6 c9	 movzx	 ecx, cl
  00063	69 c9 01 01 01
	01		 imul	 ecx, 16843009		; 01010101H
  00069	50		 push	 eax
  0006a	89 4d ec	 mov	 DWORD PTR _a$[ebp], ecx
  0006d	89 4d f0	 mov	 DWORD PTR _a$[ebp+4], ecx
  00070	e8 00 00 00 00	 call	 _GfMul64Basic

; 1161 : 	
; 1162 : 		Gf64TabInit (a, gfCtx);

  00075	8d 45 ec	 lea	 eax, DWORD PTR _a$[ebp]
  00078	56		 push	 esi
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _Gf64TabInit

; 1163 : 		Gf64MulTab (b, p2, gfCtx);

  0007f	56		 push	 esi
  00080	8d 45 bc	 lea	 eax, DWORD PTR _p2$[ebp]
  00083	50		 push	 eax
  00084	8d 45 dc	 lea	 eax, DWORD PTR _b$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _Gf64MulTab

; 1164 : 
; 1165 : 		if (memcmp (p1, p2, 8) != 0)

  0008d	8d 4d cc	 lea	 ecx, DWORD PTR _p1$[ebp]
  00090	83 c4 20	 add	 esp, 32			; 00000020H
  00093	8b 01		 mov	 eax, DWORD PTR [ecx]
  00095	8d 55 bc	 lea	 edx, DWORD PTR _p2$[ebp]
  00098	3b 02		 cmp	 eax, DWORD PTR [edx]
  0009a	75 08		 jne	 SHORT $LN36@GfMulSelfT
  0009c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0009f	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  000a2	74 02		 je	 SHORT $LN37@GfMulSelfT
$LN36@GfMulSelfT:
  000a4	33 ff		 xor	 edi, edi
$LN37@GfMulSelfT:

; 1149 : 		return FALSE;
; 1150 : 
; 1151 : 	/* GF(2^64) - deprecated/legacy */
; 1152 : 	for (i = 0; i < 0x100; i++)

  000a6	43		 inc	 ebx
  000a7	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  000ad	7c 91		 jl	 SHORT $LL4@GfMulSelfT

; 1166 : 			result = FALSE;
; 1167 : 	}
; 1168 : 
; 1169 : 	/* GF(2^128) */
; 1170 : 	for (i = 0; i < 0x100; i++)

  000af	33 db		 xor	 ebx, ebx
$LL10@GfMulSelfT:

; 1171 : 	{
; 1172 : 		for (j = 0; j < 16; j++)
; 1173 : 		{
; 1174 : 			a[j] = (unsigned __int8) i;

  000b1	8a d3		 mov	 dl, bl
  000b3	33 c0		 xor	 eax, eax
  000b5	0f b6 d2	 movzx	 edx, dl
  000b8	69 d2 01 01 01
	01		 imul	 edx, 16843009		; 01010101H
  000be	89 55 ec	 mov	 DWORD PTR _a$[ebp], edx
  000c1	89 55 f0	 mov	 DWORD PTR _a$[ebp+4], edx
  000c4	89 55 f4	 mov	 DWORD PTR _a$[ebp+8], edx
  000c7	89 55 f8	 mov	 DWORD PTR _a$[ebp+12], edx
  000ca	66 0f 1f 44 00
	00		 npad	 6
$LL13@GfMulSelfT:

; 1175 : 			b[j] = j < 8 ? 0 : a[j] ^ 0xff;

  000d0	83 f8 08	 cmp	 eax, 8
  000d3	7d 04		 jge	 SHORT $LN18@GfMulSelfT
  000d5	33 c9		 xor	 ecx, ecx
  000d7	eb 07		 jmp	 SHORT $LN19@GfMulSelfT
$LN18@GfMulSelfT:
  000d9	8a cb		 mov	 cl, bl
  000db	f6 d1		 not	 cl
  000dd	0f b6 c9	 movzx	 ecx, cl
$LN19@GfMulSelfT:
  000e0	88 4c 05 dc	 mov	 BYTE PTR _b$[ebp+eax], cl
  000e4	40		 inc	 eax
  000e5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e8	7c e6		 jl	 SHORT $LL13@GfMulSelfT

; 1176 : 		}
; 1177 : 
; 1178 : 		GfMul128Basic (a, b, p1);

  000ea	8d 45 cc	 lea	 eax, DWORD PTR _p1$[ebp]
  000ed	50		 push	 eax
  000ee	8d 45 dc	 lea	 eax, DWORD PTR _b$[ebp]
  000f1	50		 push	 eax
  000f2	8d 45 ec	 lea	 eax, DWORD PTR _a$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _GfMul128Basic

; 1179 : 	
; 1180 : 		Gf128Tab64Init (a, gfCtx);

  000fb	8d 45 ec	 lea	 eax, DWORD PTR _a$[ebp]
  000fe	56		 push	 esi
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _Gf128Tab64Init

; 1181 : 		Gf128MulBy64Tab (b + 8, p2, gfCtx);

  00105	56		 push	 esi
  00106	8d 45 bc	 lea	 eax, DWORD PTR _p2$[ebp]
  00109	50		 push	 eax
  0010a	8d 45 e4	 lea	 eax, DWORD PTR _b$[ebp+8]
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 _Gf128MulBy64Tab
  00113	83 c4 20	 add	 esp, 32			; 00000020H

; 1182 : 
; 1183 : 		if (memcmp (p1, p2, 16) != 0)

  00116	8d 4d cc	 lea	 ecx, DWORD PTR _p1$[ebp]
  00119	8d 55 bc	 lea	 edx, DWORD PTR _p2$[ebp]
  0011c	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
$LL40@GfMulSelfT:
  00121	8b 01		 mov	 eax, DWORD PTR [ecx]
  00123	3b 02		 cmp	 eax, DWORD PTR [edx]
  00125	75 0d		 jne	 SHORT $LN39@GfMulSelfT
  00127	83 c1 04	 add	 ecx, 4
  0012a	83 c2 04	 add	 edx, 4
  0012d	83 ee 04	 sub	 esi, 4
  00130	73 ef		 jae	 SHORT $LL40@GfMulSelfT
  00132	eb 02		 jmp	 SHORT $LN41@GfMulSelfT
$LN39@GfMulSelfT:
  00134	33 ff		 xor	 edi, edi
$LN41@GfMulSelfT:

; 1166 : 			result = FALSE;
; 1167 : 	}
; 1168 : 
; 1169 : 	/* GF(2^128) */
; 1170 : 	for (i = 0; i < 0x100; i++)

  00136	8b 75 b8	 mov	 esi, DWORD PTR _gfCtx$1$[ebp]
  00139	43		 inc	 ebx
  0013a	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  00140	0f 8c 6b ff ff
	ff		 jl	 $LL10@GfMulSelfT

; 1184 : 			result = FALSE;
; 1185 : 	}
; 1186 : 
; 1187 : 	GSTfree (gfCtx);

  00146	56		 push	 esi
  00147	e8 00 00 00 00	 call	 _free

; 1188 : 	return result;
; 1189 : }

  0014c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014f	83 c4 04	 add	 esp, 4
  00152	8b c7		 mov	 eax, edi
  00154	33 cd		 xor	 ecx, ebp
  00156	5b		 pop	 ebx
  00157	5f		 pop	 edi
  00158	5e		 pop	 esi
  00159	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c3		 ret	 0
_GfMulSelfTest ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _MirrorBits64
_TEXT	SEGMENT
_t$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_MirrorBits64 PROC					; COMDAT

; 806  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _a$[ebp]
  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	56		 push	 esi
  00018	57		 push	 edi

; 807  : 	unsigned __int8 t[64 / 8];
; 808  : 	int i;
; 809  : 	memset (t,0,8);

  00019	66 0f d6 45 f4	 movq	 QWORD PTR _t$[ebp], xmm0

; 810  : 	for (i = 0; i < 64; i++)

  0001e	33 c0		 xor	 eax, eax
$LL4@MirrorBits:

; 811  : 	{
; 812  : 		if (IsBitSet64(i, a))

  00020	8b c8		 mov	 ecx, eax
  00022	bf 3f 00 00 00	 mov	 edi, 63			; 0000003fH
  00027	f7 d1		 not	 ecx
  00029	2b f8		 sub	 edi, eax
  0002b	83 e1 07	 and	 ecx, 7
  0002e	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00033	d3 fa		 sar	 edx, cl
  00035	8b cf		 mov	 ecx, edi
  00037	c1 e9 03	 shr	 ecx, 3
  0003a	84 14 19	 test	 dl, BYTE PTR [ecx+ebx]
  0003d	74 1a		 je	 SHORT $LN2@MirrorBits

; 813  : 			SetBit64 (63 - i, t);

  0003f	8b d0		 mov	 edx, eax
  00041	8d 75 f4	 lea	 esi, DWORD PTR _t$[ebp]
  00044	c1 ea 03	 shr	 edx, 3
  00047	f7 d7		 not	 edi
  00049	03 f2		 add	 esi, edx
  0004b	83 e7 07	 and	 edi, 7
  0004e	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00053	8b cf		 mov	 ecx, edi
  00055	d3 fa		 sar	 edx, cl
  00057	08 16		 or	 BYTE PTR [esi], dl
$LN2@MirrorBits:

; 810  : 	for (i = 0; i < 64; i++)

  00059	40		 inc	 eax
  0005a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0005d	7c c1		 jl	 SHORT $LL4@MirrorBits

; 814  : 	}
; 815  : 	memcpy (a, t, sizeof (t));

  0005f	8b 45 f4	 mov	 eax, DWORD PTR _t$[ebp]

; 816  : 	burn (t,sizeof (t));

  00062	b9 08 00 00 00	 mov	 ecx, 8
  00067	89 03		 mov	 DWORD PTR [ebx], eax
  00069	8b f1		 mov	 esi, ecx
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp+4]
  0006e	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00071	8d 45 f4	 lea	 eax, DWORD PTR _t$[ebp]
  00074	8b d0		 mov	 edx, eax
$LL17@MirrorBits:
  00076	c6 02 00	 mov	 BYTE PTR [edx], 0
  00079	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0007c	83 ee 01	 sub	 esi, 1
  0007f	75 f5		 jne	 SHORT $LL17@MirrorBits
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
$LL8@MirrorBits:
  00084	c6 00 00	 mov	 BYTE PTR [eax], 0
  00087	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  0008a	83 e9 01	 sub	 ecx, 1
  0008d	75 f5		 jne	 SHORT $LL8@MirrorBits

; 817  : }

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00092	33 cd		 xor	 ecx, ebp
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_MirrorBits64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _MirrorBits128
_TEXT	SEGMENT
_t$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_MirrorBits128 PROC					; COMDAT

; 784  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _a$[ebp]
  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	56		 push	 esi
  00018	57		 push	 edi

; 785  : 	unsigned __int8 t[128 / 8];
; 786  : 	int i;
; 787  : 	memset (t,0,16);

  00019	0f 11 45 ec	 movups	 XMMWORD PTR _t$[ebp], xmm0

; 788  : 	for (i = 0; i < 128; i++)

  0001d	33 c0		 xor	 eax, eax
  0001f	90		 npad	 1
$LL4@MirrorBits:

; 789  : 	{
; 790  : 		if (IsBitSet128(i, a))

  00020	8b c8		 mov	 ecx, eax
  00022	bf 7f 00 00 00	 mov	 edi, 127		; 0000007fH
  00027	f7 d1		 not	 ecx
  00029	2b f8		 sub	 edi, eax
  0002b	83 e1 07	 and	 ecx, 7
  0002e	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00033	d3 fa		 sar	 edx, cl
  00035	8b cf		 mov	 ecx, edi
  00037	c1 e9 03	 shr	 ecx, 3
  0003a	84 14 19	 test	 dl, BYTE PTR [ecx+ebx]
  0003d	74 1a		 je	 SHORT $LN2@MirrorBits

; 791  : 			SetBit128 (127 - i, t);

  0003f	8b d0		 mov	 edx, eax
  00041	8d 75 ec	 lea	 esi, DWORD PTR _t$[ebp]
  00044	c1 ea 03	 shr	 edx, 3
  00047	f7 d7		 not	 edi
  00049	03 f2		 add	 esi, edx
  0004b	83 e7 07	 and	 edi, 7
  0004e	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00053	8b cf		 mov	 ecx, edi
  00055	d3 fa		 sar	 edx, cl
  00057	08 16		 or	 BYTE PTR [esi], dl
$LN2@MirrorBits:

; 788  : 	for (i = 0; i < 128; i++)

  00059	40		 inc	 eax
  0005a	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0005f	7c bf		 jl	 SHORT $LL4@MirrorBits

; 792  : 	}
; 793  : 	memcpy (a, t, sizeof (t));

  00061	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _t$[ebp]

; 794  : 	burn (t,sizeof (t));

  00065	8d 45 ec	 lea	 eax, DWORD PTR _t$[ebp]
  00068	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0006d	8b f1		 mov	 esi, ecx
  0006f	8b d0		 mov	 edx, eax
  00071	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
$LL17@MirrorBits:
  00074	c6 02 00	 mov	 BYTE PTR [edx], 0
  00077	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0007a	83 ee 01	 sub	 esi, 1
  0007d	75 f5		 jne	 SHORT $LL17@MirrorBits
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
$LL8@MirrorBits:
  00082	c6 00 00	 mov	 BYTE PTR [eax], 0
  00085	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00088	83 e9 01	 sub	 ecx, 1
  0008b	75 f5		 jne	 SHORT $LL8@MirrorBits

; 795  : }

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00090	33 cd		 xor	 ecx, ebp
  00092	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_MirrorBits128 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _Gf64MulTab
_TEXT	SEGMENT
_a$ = 8							; size = 4
_p$ = 12						; size = 4
_ctx$ = 16						; size = 4
_Gf64MulTab PROC					; COMDAT

; 967  : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 968  : 	/* Deprecated/legacy */
; 969  : 
; 970  : 	unsigned __int32 r[CBLK_LEN8 >> 2];
; 971  : 
; 972  : 	move_block_aligned64(r, ctx->gf_t64[7*2][a[7] & 15]);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _a$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 10	 mov	 edi, DWORD PTR _ctx$[ebp]
  0000c	0f b6 4b 07	 movzx	 ecx, BYTE PTR [ebx+7]
  00010	8b c1		 mov	 eax, ecx

; 973  :     xor_block_aligned64(r,  ctx->gf_t64[7*2+1][a[7] >> 4]);

  00012	c1 e9 04	 shr	 ecx, 4
  00015	83 e0 0f	 and	 eax, 15			; 0000000fH
  00018	8b 94 c7 00 17
	00 00		 mov	 edx, DWORD PTR [edi+eax*8+5888]
  0001f	8b b4 c7 04 17
	00 00		 mov	 esi, DWORD PTR [edi+eax*8+5892]
  00026	33 94 cf 80 17
	00 00		 xor	 edx, DWORD PTR [edi+ecx*8+6016]
  0002d	33 b4 cf 84 17
	00 00		 xor	 esi, DWORD PTR [edi+ecx*8+6020]

; 974  : 
; 975  : 	if (*(unsigned __int16 *)a)

  00034	66 83 3b 00	 cmp	 WORD PTR [ebx], 0
  00038	74 4f		 je	 SHORT $LN15@Gf64MulTab

; 976  : 	{
; 977  : 		xor_8k64(0);

  0003a	0f b6 0b	 movzx	 ecx, BYTE PTR [ebx]
  0003d	8b c1		 mov	 eax, ecx
  0003f	c1 e9 04	 shr	 ecx, 4
  00042	83 e0 0f	 and	 eax, 15			; 0000000fH
  00045	33 94 c7 00 10
	00 00		 xor	 edx, DWORD PTR [edi+eax*8+4096]
  0004c	33 b4 c7 04 10
	00 00		 xor	 esi, DWORD PTR [edi+eax*8+4100]
  00053	33 94 cf 80 10
	00 00		 xor	 edx, DWORD PTR [edi+ecx*8+4224]
  0005a	33 b4 cf 84 10
	00 00		 xor	 esi, DWORD PTR [edi+ecx*8+4228]

; 978  : 		xor_8k64(1);

  00061	0f b6 4b 01	 movzx	 ecx, BYTE PTR [ebx+1]
  00065	8b c1		 mov	 eax, ecx
  00067	c1 e9 04	 shr	 ecx, 4
  0006a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0006d	33 94 c7 00 11
	00 00		 xor	 edx, DWORD PTR [edi+eax*8+4352]
  00074	33 b4 c7 04 11
	00 00		 xor	 esi, DWORD PTR [edi+eax*8+4356]
  0007b	33 94 cf 80 11
	00 00		 xor	 edx, DWORD PTR [edi+ecx*8+4480]
  00082	33 b4 cf 84 11
	00 00		 xor	 esi, DWORD PTR [edi+ecx*8+4484]
$LN15@Gf64MulTab:

; 979  : 	}
; 980  : 	if (a[2])

  00089	8a 43 02	 mov	 al, BYTE PTR [ebx+2]
  0008c	84 c0		 test	 al, al
  0008e	74 27		 je	 SHORT $LN19@Gf64MulTab

; 981  : 	{
; 982  : 		xor_8k64(2);

  00090	0f b6 c8	 movzx	 ecx, al
  00093	8b c1		 mov	 eax, ecx
  00095	c1 e9 04	 shr	 ecx, 4
  00098	83 e0 0f	 and	 eax, 15			; 0000000fH
  0009b	33 94 c7 00 12
	00 00		 xor	 edx, DWORD PTR [edi+eax*8+4608]
  000a2	33 b4 c7 04 12
	00 00		 xor	 esi, DWORD PTR [edi+eax*8+4612]
  000a9	33 94 cf 80 12
	00 00		 xor	 edx, DWORD PTR [edi+ecx*8+4736]
  000b0	33 b4 cf 84 12
	00 00		 xor	 esi, DWORD PTR [edi+ecx*8+4740]
$LN19@Gf64MulTab:

; 983  : 	}
; 984  : 	xor_8k64(3);

  000b7	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  000bb	8b c1		 mov	 eax, ecx
  000bd	c1 e9 04	 shr	 ecx, 4
  000c0	83 e0 0f	 and	 eax, 15			; 0000000fH
  000c3	33 94 c7 00 13
	00 00		 xor	 edx, DWORD PTR [edi+eax*8+4864]
  000ca	33 b4 c7 04 13
	00 00		 xor	 esi, DWORD PTR [edi+eax*8+4868]
  000d1	33 94 cf 80 13
	00 00		 xor	 edx, DWORD PTR [edi+ecx*8+4992]
  000d8	33 b4 cf 84 13
	00 00		 xor	 esi, DWORD PTR [edi+ecx*8+4996]

; 985  :     xor_8k64(4);

  000df	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  000e3	8b c1		 mov	 eax, ecx
  000e5	c1 e9 04	 shr	 ecx, 4
  000e8	83 e0 0f	 and	 eax, 15			; 0000000fH
  000eb	33 94 c7 00 14
	00 00		 xor	 edx, DWORD PTR [edi+eax*8+5120]
  000f2	33 b4 c7 04 14
	00 00		 xor	 esi, DWORD PTR [edi+eax*8+5124]
  000f9	33 94 cf 80 14
	00 00		 xor	 edx, DWORD PTR [edi+ecx*8+5248]
  00100	33 b4 cf 84 14
	00 00		 xor	 esi, DWORD PTR [edi+ecx*8+5252]

; 986  : 	xor_8k64(5);

  00107	0f b6 4b 05	 movzx	 ecx, BYTE PTR [ebx+5]
  0010b	8b c1		 mov	 eax, ecx
  0010d	c1 e9 04	 shr	 ecx, 4
  00110	83 e0 0f	 and	 eax, 15			; 0000000fH
  00113	33 94 c7 00 15
	00 00		 xor	 edx, DWORD PTR [edi+eax*8+5376]
  0011a	33 b4 c7 04 15
	00 00		 xor	 esi, DWORD PTR [edi+eax*8+5380]
  00121	33 94 cf 80 15
	00 00		 xor	 edx, DWORD PTR [edi+ecx*8+5504]
  00128	33 b4 cf 84 15
	00 00		 xor	 esi, DWORD PTR [edi+ecx*8+5508]

; 987  : 	xor_8k64(6);

  0012f	0f b6 4b 06	 movzx	 ecx, BYTE PTR [ebx+6]
  00133	8b c1		 mov	 eax, ecx
  00135	c1 e9 04	 shr	 ecx, 4
  00138	83 e0 0f	 and	 eax, 15			; 0000000fH
  0013b	33 94 c7 00 16
	00 00		 xor	 edx, DWORD PTR [edi+eax*8+5632]
  00142	33 b4 c7 04 16
	00 00		 xor	 esi, DWORD PTR [edi+eax*8+5636]
  00149	33 94 cf 80 16
	00 00		 xor	 edx, DWORD PTR [edi+ecx*8+5760]

; 988  : 
; 989  :     move_block_aligned64(p, r);

  00150	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00153	33 b4 cf 84 16
	00 00		 xor	 esi, DWORD PTR [edi+ecx*8+5764]
  0015a	5f		 pop	 edi
  0015b	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0015e	5e		 pop	 esi
  0015f	89 10		 mov	 DWORD PTR [eax], edx
  00161	5b		 pop	 ebx

; 990  : }

  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
_Gf64MulTab ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _Gf64TabInit
_TEXT	SEGMENT
_ctx4k$1$ = -24						; size = 4
_ctx$GSCopy$1$ = -20					; size = 4
tv522 = -16						; size = 4
_am$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_Gf64TabInit PROC					; COMDAT

; 877  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _a$[ebp]

; 878  : 	/* Deprecated/legacy */
; 879  : 
; 880  : 	GfCtx4k64 *ctx4k;
; 881  : 	unsigned __int8 am[8];
; 882  : 	int i, j;
; 883  : 
; 884  : 	ctx4k = (GfCtx4k64 *) GSTalloc (sizeof (GfCtx4k64));

  00018	68 00 10 00 00	 push	 4096			; 00001000H
  0001d	89 45 ec	 mov	 DWORD PTR _ctx$GSCopy$1$[ebp], eax
  00020	e8 00 00 00 00	 call	 _malloc
  00025	8b f0		 mov	 esi, eax
  00027	83 c4 04	 add	 esp, 4
  0002a	89 75 e8	 mov	 DWORD PTR _ctx4k$1$[ebp], esi

; 885  : 	if (!ctx4k)

  0002d	85 f6		 test	 esi, esi
  0002f	75 10		 jne	 SHORT $LN18@Gf64TabIni
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 911  : 	return TRUE;
; 912  : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN18@Gf64TabIni:

; 886  : 		return FALSE;
; 887  : 
; 888  : 	memcpy (am, a, 8);

  00041	8b 07		 mov	 eax, DWORD PTR [edi]
  00043	89 45 f4	 mov	 DWORD PTR _am$[ebp], eax
  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	89 45 f8	 mov	 DWORD PTR _am$[ebp+4], eax

; 889  : 	MirrorBits64 (am);

  0004c	8d 45 f4	 lea	 eax, DWORD PTR _am$[ebp]
  0004f	53		 push	 ebx
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _MirrorBits64

; 890  :     compile_4k_table64 (am, ctx4k);

  00056	8d 45 f4	 lea	 eax, DWORD PTR _am$[ebp]
  00059	56		 push	 esi
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _compile_4k_table64
  00060	8d 86 00 0f 00
	00		 lea	 eax, DWORD PTR [esi+3840]
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	bb 00 02 00 00	 mov	 ebx, 512		; 00000200H
  0006e	89 45 f0	 mov	 DWORD PTR tv522[ebp], eax
$LL4@Gf64TabIni:

; 894  : 	{
; 895  : 		for (j = 0; j < 16; j++) 

  00071	33 f6		 xor	 esi, esi
  00073	8b f8		 mov	 edi, eax
$LL7@Gf64TabIni:

; 896  : 		{
; 897  : 			int jm = 0;
; 898  : 			jm |= (j & 0x1) << 3;
; 899  : 			jm |= (j & 0x2) << 1;
; 900  : 			jm |= (j & 0x4) >> 1;
; 901  : 			jm |= (j & 0x8) >> 3;
; 902  : 
; 903  : 			memcpy (&ctx->gf_t64[i][jm], (unsigned char *)&ctx4k->gf_t4k[15-i][j], 8);

  00075	8b d6		 mov	 edx, esi
  00077	8b c6		 mov	 eax, esi
  00079	c1 fa 02	 sar	 edx, 2
  0007c	83 e0 04	 and	 eax, 4
  0007f	83 e2 02	 and	 edx, 2
  00082	8b ce		 mov	 ecx, esi
  00084	0b d0		 or	 edx, eax
  00086	83 e1 01	 and	 ecx, 1
  00089	c1 e1 02	 shl	 ecx, 2
  0008c	8b c6		 mov	 eax, esi
  0008e	83 e0 02	 and	 eax, 2
  00091	d1 ea		 shr	 edx, 1
  00093	0b c8		 or	 ecx, eax
  00095	8b 45 ec	 mov	 eax, DWORD PTR _ctx$GSCopy$1$[ebp]
  00098	03 c9		 add	 ecx, ecx
  0009a	0b d1		 or	 edx, ecx
  0009c	03 d3		 add	 edx, ebx
  0009e	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  000a1	8b 07		 mov	 eax, DWORD PTR [edi]
  000a3	89 01		 mov	 DWORD PTR [ecx], eax
  000a5	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 904  : 			MirrorBits64 ((unsigned char *)&ctx->gf_t64[i][jm]);

  000a8	51		 push	 ecx
  000a9	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000ac	e8 00 00 00 00	 call	 _MirrorBits64
  000b1	46		 inc	 esi
  000b2	8d 7f 10	 lea	 edi, DWORD PTR [edi+16]
  000b5	83 c4 04	 add	 esp, 4
  000b8	83 fe 10	 cmp	 esi, 16			; 00000010H
  000bb	7c b8		 jl	 SHORT $LL7@Gf64TabIni

; 891  : 
; 892  : 	/* Convert LSB-first table to MSB-first */
; 893  : 	for (i = 0; i < 16; i++) 

  000bd	8b 45 f0	 mov	 eax, DWORD PTR tv522[ebp]
  000c0	83 c3 10	 add	 ebx, 16			; 00000010H
  000c3	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  000c8	89 45 f0	 mov	 DWORD PTR tv522[ebp], eax
  000cb	81 fb 00 03 00
	00		 cmp	 ebx, 768		; 00000300H
  000d1	7c 9e		 jl	 SHORT $LL4@Gf64TabIni

; 905  : 		}
; 906  : 	}
; 907  : 
; 908  : 	burn (ctx4k,sizeof (*ctx4k));

  000d3	8b 7d e8	 mov	 edi, DWORD PTR _ctx4k$1$[ebp]
  000d6	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000db	8b c7		 mov	 eax, edi
  000dd	8b f1		 mov	 esi, ecx
  000df	8b d7		 mov	 edx, edi
  000e1	5b		 pop	 ebx
$LL21@Gf64TabIni:
  000e2	c6 02 00	 mov	 BYTE PTR [edx], 0
  000e5	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000e8	83 ee 01	 sub	 esi, 1
  000eb	75 f5		 jne	 SHORT $LL21@Gf64TabIni
  000ed	0f 1f 00	 npad	 3
$LL11@Gf64TabIni:
  000f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  000f3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000f6	83 e9 01	 sub	 ecx, 1
  000f9	75 f5		 jne	 SHORT $LL11@Gf64TabIni

; 909  : 	burn (am, sizeof (am));

  000fb	8d 45 f4	 lea	 eax, DWORD PTR _am$[ebp]
  000fe	b9 08 00 00 00	 mov	 ecx, 8
  00103	8b f1		 mov	 esi, ecx
  00105	8b d0		 mov	 edx, eax
$LL25@Gf64TabIni:
  00107	c6 02 00	 mov	 BYTE PTR [edx], 0
  0010a	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0010d	83 ee 01	 sub	 esi, 1
  00110	75 f5		 jne	 SHORT $LL25@Gf64TabIni
$LL16@Gf64TabIni:
  00112	c6 00 00	 mov	 BYTE PTR [eax], 0
  00115	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00118	83 e9 01	 sub	 ecx, 1
  0011b	75 f5		 jne	 SHORT $LL16@Gf64TabIni

; 910  : 	GSTfree (ctx4k);

  0011d	57		 push	 edi
  0011e	e8 00 00 00 00	 call	 _free

; 911  : 	return TRUE;
; 912  : }

  00123	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00126	83 c4 04	 add	 esp, 4
  00129	33 cd		 xor	 ecx, ebp
  0012b	b8 01 00 00 00	 mov	 eax, 1
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
_Gf64TabInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _Gf128MulBy64Tab
_TEXT	SEGMENT
tv3521 = -16						; size = 4
tv3519 = -16						; size = 4
_r$4$ = -12						; size = 4
tv3517 = -12						; size = 4
tv3515 = -12						; size = 4
tv3513 = -12						; size = 4
_r$3$ = -8						; size = 4
_r$1$ = -4						; size = 4
tv3523 = 8						; size = 4
_a$ = 8							; size = 4
_p$ = 12						; size = 4
_ctx$ = 16						; size = 4
_Gf128MulBy64Tab PROC					; COMDAT

; 929  : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 930  : 	unsigned __int32 r[CBLK_LEN >> 2];
; 931  : 
; 932  : 	move_block_aligned(r, ctx->gf_t128[7*2][a[7] & 15]);

  00006	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 10	 mov	 ebx, DWORD PTR _ctx$[ebp]
  0000d	56		 push	 esi
  0000e	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  00012	8b c1		 mov	 eax, ecx

; 933  :     xor_block_aligned(r,  ctx->gf_t128[7*2+1][a[7] >> 4]);

  00014	c1 e9 04	 shr	 ecx, 4
  00017	83 e0 0f	 and	 eax, 15			; 0000000fH
  0001a	81 c1 f0 00 00
	00		 add	 ecx, 240		; 000000f0H
  00020	05 e0 00 00 00	 add	 eax, 224		; 000000e0H
  00025	c1 e1 04	 shl	 ecx, 4
  00028	03 c0		 add	 eax, eax
  0002a	57		 push	 edi
  0002b	8b 14 c3	 mov	 edx, DWORD PTR [ebx+eax*8]
  0002e	8b 74 c3 04	 mov	 esi, DWORD PTR [ebx+eax*8+4]
  00032	8b 7c c3 08	 mov	 edi, DWORD PTR [ebx+eax*8+8]
  00036	8b 5c c3 0c	 mov	 ebx, DWORD PTR [ebx+eax*8+12]
  0003a	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  0003d	33 74 01 04	 xor	 esi, DWORD PTR [ecx+eax+4]
  00041	33 7c 01 08	 xor	 edi, DWORD PTR [ecx+eax+8]
  00045	33 5c 01 0c	 xor	 ebx, DWORD PTR [ecx+eax+12]
  00049	33 14 01	 xor	 edx, DWORD PTR [ecx+eax]

; 934  : 
; 935  : 	if (*(unsigned __int16 *)a)

  0004c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0004f	89 75 fc	 mov	 DWORD PTR _r$1$[ebp], esi
  00052	89 7d f8	 mov	 DWORD PTR _r$3$[ebp], edi
  00055	89 5d f4	 mov	 DWORD PTR _r$4$[ebp], ebx
  00058	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0005c	0f 84 94 00 00
	00		 je	 $LN134@Gf128MulBy

; 936  : 	{
; 937  : 		xor_8kt64(0);

  00062	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00065	8b 75 10	 mov	 esi, DWORD PTR _ctx$[ebp]
  00068	8b c1		 mov	 eax, ecx
  0006a	8b 7d 10	 mov	 edi, DWORD PTR _ctx$[ebp]
  0006d	83 e0 0f	 and	 eax, 15			; 0000000fH
  00070	8b 5d 10	 mov	 ebx, DWORD PTR _ctx$[ebp]
  00073	03 c0		 add	 eax, eax
  00075	c1 e9 04	 shr	 ecx, 4
  00078	83 c1 10	 add	 ecx, 16			; 00000010H
  0007b	03 c9		 add	 ecx, ecx
  0007d	33 14 c6	 xor	 edx, DWORD PTR [esi+eax*8]
  00080	8b 75 fc	 mov	 esi, DWORD PTR _r$1$[ebp]
  00083	33 74 c7 04	 xor	 esi, DWORD PTR [edi+eax*8+4]
  00087	8b 7d f8	 mov	 edi, DWORD PTR _r$3$[ebp]
  0008a	33 7c c3 08	 xor	 edi, DWORD PTR [ebx+eax*8+8]
  0008e	8b 5d f4	 mov	 ebx, DWORD PTR _r$4$[ebp]
  00091	89 75 fc	 mov	 DWORD PTR _r$1$[ebp], esi
  00094	8b 75 10	 mov	 esi, DWORD PTR _ctx$[ebp]
  00097	33 5c c6 0c	 xor	 ebx, DWORD PTR [esi+eax*8+12]
  0009b	8b c6		 mov	 eax, esi
  0009d	8b 75 fc	 mov	 esi, DWORD PTR _r$1$[ebp]
  000a0	33 14 c8	 xor	 edx, DWORD PTR [eax+ecx*8]
  000a3	33 74 c8 04	 xor	 esi, DWORD PTR [eax+ecx*8+4]
  000a7	33 7c c8 08	 xor	 edi, DWORD PTR [eax+ecx*8+8]
  000ab	33 5c c8 0c	 xor	 ebx, DWORD PTR [eax+ecx*8+12]

; 938  : 		xor_8kt64(1);

  000af	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000b2	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000b6	8b c1		 mov	 eax, ecx
  000b8	89 4d f4	 mov	 DWORD PTR tv3513[ebp], ecx
  000bb	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000be	83 e0 0f	 and	 eax, 15			; 0000000fH
  000c1	83 c0 20	 add	 eax, 32			; 00000020H
  000c4	03 c0		 add	 eax, eax
  000c6	33 14 c1	 xor	 edx, DWORD PTR [ecx+eax*8]
  000c9	33 74 c1 04	 xor	 esi, DWORD PTR [ecx+eax*8+4]
  000cd	33 7c c1 08	 xor	 edi, DWORD PTR [ecx+eax*8+8]
  000d1	33 5c c1 0c	 xor	 ebx, DWORD PTR [ecx+eax*8+12]
  000d5	8b 4d f4	 mov	 ecx, DWORD PTR tv3513[ebp]
  000d8	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  000db	c1 e9 04	 shr	 ecx, 4
  000de	83 c1 30	 add	 ecx, 48			; 00000030H
  000e1	c1 e1 04	 shl	 ecx, 4
  000e4	33 14 01	 xor	 edx, DWORD PTR [ecx+eax]
  000e7	33 74 01 04	 xor	 esi, DWORD PTR [ecx+eax+4]
  000eb	33 7c 01 08	 xor	 edi, DWORD PTR [ecx+eax+8]
  000ef	33 5c 01 0c	 xor	 ebx, DWORD PTR [ecx+eax+12]
  000f3	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
$LN134@Gf128MulBy:

; 939  : 	}
; 940  : 	if (a[2])

  000f6	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  000f9	84 c9		 test	 cl, cl
  000fb	74 42		 je	 SHORT $LN144@Gf128MulBy

; 941  : 	{
; 942  : 		xor_8kt64(2);

  000fd	0f b6 c9	 movzx	 ecx, cl
  00100	8b c1		 mov	 eax, ecx
  00102	89 4d f4	 mov	 DWORD PTR tv3515[ebp], ecx
  00105	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00108	83 e0 0f	 and	 eax, 15			; 0000000fH
  0010b	83 c0 40	 add	 eax, 64			; 00000040H
  0010e	03 c0		 add	 eax, eax
  00110	33 14 c1	 xor	 edx, DWORD PTR [ecx+eax*8]
  00113	33 74 c1 04	 xor	 esi, DWORD PTR [ecx+eax*8+4]
  00117	33 7c c1 08	 xor	 edi, DWORD PTR [ecx+eax*8+8]
  0011b	33 5c c1 0c	 xor	 ebx, DWORD PTR [ecx+eax*8+12]
  0011f	8b 4d f4	 mov	 ecx, DWORD PTR tv3515[ebp]
  00122	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00125	c1 e9 04	 shr	 ecx, 4
  00128	83 c1 50	 add	 ecx, 80			; 00000050H
  0012b	03 c9		 add	 ecx, ecx
  0012d	33 14 c8	 xor	 edx, DWORD PTR [eax+ecx*8]
  00130	33 74 c8 04	 xor	 esi, DWORD PTR [eax+ecx*8+4]
  00134	33 7c c8 08	 xor	 edi, DWORD PTR [eax+ecx*8+8]
  00138	33 5c c8 0c	 xor	 ebx, DWORD PTR [eax+ecx*8+12]
  0013c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
$LN144@Gf128MulBy:

; 943  : 	}
; 944  : 	xor_8kt64(3);

  0013f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00143	8b c1		 mov	 eax, ecx
  00145	89 4d f4	 mov	 DWORD PTR tv3517[ebp], ecx
  00148	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0014b	83 e0 0f	 and	 eax, 15			; 0000000fH
  0014e	83 c0 60	 add	 eax, 96			; 00000060H
  00151	03 c0		 add	 eax, eax
  00153	33 74 c1 04	 xor	 esi, DWORD PTR [ecx+eax*8+4]
  00157	33 7c c1 08	 xor	 edi, DWORD PTR [ecx+eax*8+8]
  0015b	33 5c c1 0c	 xor	 ebx, DWORD PTR [ecx+eax*8+12]
  0015f	33 14 c1	 xor	 edx, DWORD PTR [ecx+eax*8]
  00162	8b 4d f4	 mov	 ecx, DWORD PTR tv3517[ebp]
  00165	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00168	c1 e9 04	 shr	 ecx, 4
  0016b	83 c1 70	 add	 ecx, 112		; 00000070H
  0016e	03 c9		 add	 ecx, ecx
  00170	33 74 c8 04	 xor	 esi, DWORD PTR [eax+ecx*8+4]
  00174	33 7c c8 08	 xor	 edi, DWORD PTR [eax+ecx*8+8]
  00178	33 5c c8 0c	 xor	 ebx, DWORD PTR [eax+ecx*8+12]
  0017c	33 14 c8	 xor	 edx, DWORD PTR [eax+ecx*8]

; 945  :     xor_8kt64(4);

  0017f	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00182	89 75 fc	 mov	 DWORD PTR _r$1$[ebp], esi
  00185	8b 75 10	 mov	 esi, DWORD PTR _ctx$[ebp]
  00188	89 7d f8	 mov	 DWORD PTR _r$3$[ebp], edi
  0018b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0018f	8b 7d 10	 mov	 edi, DWORD PTR _ctx$[ebp]
  00192	8b c1		 mov	 eax, ecx
  00194	83 e0 0f	 and	 eax, 15			; 0000000fH
  00197	89 5d f4	 mov	 DWORD PTR _r$4$[ebp], ebx
  0019a	8b 5d 10	 mov	 ebx, DWORD PTR _ctx$[ebp]
  0019d	83 e8 80	 sub	 eax, -128		; ffffff80H
  001a0	03 c0		 add	 eax, eax
  001a2	89 4d f0	 mov	 DWORD PTR tv3519[ebp], ecx
  001a5	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  001a8	33 14 c6	 xor	 edx, DWORD PTR [esi+eax*8]
  001ab	8b 75 fc	 mov	 esi, DWORD PTR _r$1$[ebp]
  001ae	33 74 c7 04	 xor	 esi, DWORD PTR [edi+eax*8+4]
  001b2	8b 7d f8	 mov	 edi, DWORD PTR _r$3$[ebp]
  001b5	33 7c c3 08	 xor	 edi, DWORD PTR [ebx+eax*8+8]
  001b9	8b 5d f4	 mov	 ebx, DWORD PTR _r$4$[ebp]
  001bc	33 5c c1 0c	 xor	 ebx, DWORD PTR [ecx+eax*8+12]
  001c0	8b 4d f0	 mov	 ecx, DWORD PTR tv3519[ebp]
  001c3	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  001c6	c1 e9 04	 shr	 ecx, 4
  001c9	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  001cf	03 c9		 add	 ecx, ecx
  001d1	33 74 c8 04	 xor	 esi, DWORD PTR [eax+ecx*8+4]
  001d5	33 7c c8 08	 xor	 edi, DWORD PTR [eax+ecx*8+8]
  001d9	33 5c c8 0c	 xor	 ebx, DWORD PTR [eax+ecx*8+12]
  001dd	33 14 c8	 xor	 edx, DWORD PTR [eax+ecx*8]

; 946  : 	xor_8kt64(5);

  001e0	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001e3	89 75 fc	 mov	 DWORD PTR _r$1$[ebp], esi
  001e6	8b 75 10	 mov	 esi, DWORD PTR _ctx$[ebp]
  001e9	89 7d f8	 mov	 DWORD PTR _r$3$[ebp], edi
  001ec	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  001f0	8b 7d 10	 mov	 edi, DWORD PTR _ctx$[ebp]
  001f3	8b c1		 mov	 eax, ecx
  001f5	83 e0 0f	 and	 eax, 15			; 0000000fH
  001f8	89 5d f4	 mov	 DWORD PTR _r$4$[ebp], ebx
  001fb	8b 5d 10	 mov	 ebx, DWORD PTR _ctx$[ebp]
  001fe	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00203	03 c0		 add	 eax, eax
  00205	89 4d f0	 mov	 DWORD PTR tv3521[ebp], ecx
  00208	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0020b	33 14 c6	 xor	 edx, DWORD PTR [esi+eax*8]
  0020e	8b 75 fc	 mov	 esi, DWORD PTR _r$1$[ebp]
  00211	33 74 c7 04	 xor	 esi, DWORD PTR [edi+eax*8+4]
  00215	8b 7d f8	 mov	 edi, DWORD PTR _r$3$[ebp]
  00218	33 7c c3 08	 xor	 edi, DWORD PTR [ebx+eax*8+8]
  0021c	8b 5d f4	 mov	 ebx, DWORD PTR _r$4$[ebp]
  0021f	33 5c c1 0c	 xor	 ebx, DWORD PTR [ecx+eax*8+12]
  00223	8b 4d f0	 mov	 ecx, DWORD PTR tv3521[ebp]
  00226	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00229	c1 e9 04	 shr	 ecx, 4
  0022c	81 c1 b0 00 00
	00		 add	 ecx, 176		; 000000b0H
  00232	03 c9		 add	 ecx, ecx
  00234	33 14 c8	 xor	 edx, DWORD PTR [eax+ecx*8]
  00237	33 74 c8 04	 xor	 esi, DWORD PTR [eax+ecx*8+4]
  0023b	33 7c c8 08	 xor	 edi, DWORD PTR [eax+ecx*8+8]
  0023f	33 5c c8 0c	 xor	 ebx, DWORD PTR [eax+ecx*8+12]

; 947  : 	xor_8kt64(6);

  00243	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00246	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0024a	8b c1		 mov	 eax, ecx
  0024c	89 4d 08	 mov	 DWORD PTR tv3523[ebp], ecx
  0024f	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00252	83 e0 0f	 and	 eax, 15			; 0000000fH
  00255	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  0025a	03 c0		 add	 eax, eax
  0025c	33 74 c1 04	 xor	 esi, DWORD PTR [ecx+eax*8+4]
  00260	33 7c c1 08	 xor	 edi, DWORD PTR [ecx+eax*8+8]
  00264	33 14 c1	 xor	 edx, DWORD PTR [ecx+eax*8]
  00267	33 5c c1 0c	 xor	 ebx, DWORD PTR [ecx+eax*8+12]
  0026b	8b 4d 08	 mov	 ecx, DWORD PTR tv3523[ebp]
  0026e	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00271	c1 e9 04	 shr	 ecx, 4
  00274	81 c1 d0 00 00
	00		 add	 ecx, 208		; 000000d0H
  0027a	03 c9		 add	 ecx, ecx
  0027c	33 74 c8 04	 xor	 esi, DWORD PTR [eax+ecx*8+4]
  00280	33 7c c8 08	 xor	 edi, DWORD PTR [eax+ecx*8+8]
  00284	33 14 c8	 xor	 edx, DWORD PTR [eax+ecx*8]
  00287	33 5c c8 0c	 xor	 ebx, DWORD PTR [eax+ecx*8+12]

; 948  : 
; 949  :     move_block_aligned(p, r);

  0028b	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  0028e	89 10		 mov	 DWORD PTR [eax], edx
  00290	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00293	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00296	5f		 pop	 edi
  00297	5e		 pop	 esi
  00298	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  0029b	5b		 pop	 ebx

; 950  : }

  0029c	8b e5		 mov	 esp, ebp
  0029e	5d		 pop	 ebp
  0029f	c3		 ret	 0
_Gf128MulBy64Tab ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _Gf128Tab64Init
_TEXT	SEGMENT
_ctx8k$1$ = -32						; size = 4
_ctx$GSCopy$1$ = -28					; size = 4
tv549 = -24						; size = 4
_am$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_Gf128Tab64Init PROC					; COMDAT

; 830  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _a$[ebp]

; 831  : 	GfCtx8k *ctx8k;
; 832  : 	unsigned __int8 am[16];
; 833  : 	int i, j;
; 834  : 
; 835  : 	ctx8k = (GfCtx8k *) GSTalloc (sizeof (GfCtx8k));

  00018	68 00 20 00 00	 push	 8192			; 00002000H
  0001d	89 45 e4	 mov	 DWORD PTR _ctx$GSCopy$1$[ebp], eax
  00020	e8 00 00 00 00	 call	 _malloc
  00025	8b f0		 mov	 esi, eax
  00027	83 c4 04	 add	 esp, 4
  0002a	89 75 e0	 mov	 DWORD PTR _ctx8k$1$[ebp], esi

; 836  : 	if (!ctx8k)

  0002d	85 f6		 test	 esi, esi
  0002f	75 10		 jne	 SHORT $LN18@Gf128Tab64
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 862  : 	return TRUE;
; 863  : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN18@Gf128Tab64:

; 837  : 		return FALSE;
; 838  : 
; 839  : 	memcpy (am, a, 16);

  00041	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]

; 840  : 	MirrorBits128 (am);

  00044	8d 45 ec	 lea	 eax, DWORD PTR _am$[ebp]
  00047	53		 push	 ebx
  00048	50		 push	 eax
  00049	0f 11 45 ec	 movups	 XMMWORD PTR _am$[ebp], xmm0
  0004d	e8 00 00 00 00	 call	 _MirrorBits128

; 841  :     compile_8k_table (am, ctx8k);

  00052	8d 45 ec	 lea	 eax, DWORD PTR _am$[ebp]
  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _compile_8k_table
  0005c	8d 86 00 0f 00
	00		 lea	 eax, DWORD PTR [esi+3840]
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	33 db		 xor	 ebx, ebx
  00067	89 45 e8	 mov	 DWORD PTR tv549[ebp], eax
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Gf128Tab64:

; 845  : 	{
; 846  : 		for (j = 0; j < 16; j++) 

  00070	33 f6		 xor	 esi, esi
  00072	8b f8		 mov	 edi, eax
$LL7@Gf128Tab64:

; 847  : 		{
; 848  : 			int jm = 0;
; 849  : 			jm |= (j & 0x1) << 3;
; 850  : 			jm |= (j & 0x2) << 1;
; 851  : 			jm |= (j & 0x4) >> 1;
; 852  : 			jm |= (j & 0x8) >> 3;
; 853  : 
; 854  : 			memcpy (&ctx->gf_t128[i-16][jm], (unsigned char *)&ctx8k->gf_t8k[31-i][j], 16);

  00074	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00077	8b d6		 mov	 edx, esi
  00079	8b c6		 mov	 eax, esi
  0007b	c1 fa 02	 sar	 edx, 2
  0007e	83 e0 04	 and	 eax, 4
  00081	83 e2 02	 and	 edx, 2
  00084	8b ce		 mov	 ecx, esi
  00086	0b d0		 or	 edx, eax
  00088	83 e1 01	 and	 ecx, 1
  0008b	c1 e1 02	 shl	 ecx, 2
  0008e	8b c6		 mov	 eax, esi
  00090	83 e0 02	 and	 eax, 2
  00093	d1 ea		 shr	 edx, 1
  00095	0b c8		 or	 ecx, eax
  00097	8b 45 e4	 mov	 eax, DWORD PTR _ctx$GSCopy$1$[ebp]
  0009a	03 c9		 add	 ecx, ecx
  0009c	0b d1		 or	 edx, ecx
  0009e	03 d3		 add	 edx, ebx
  000a0	c1 e2 04	 shl	 edx, 4
  000a3	03 c2		 add	 eax, edx

; 855  : 			MirrorBits128 ((unsigned char *)&ctx->gf_t128[i-16][jm]);

  000a5	50		 push	 eax
  000a6	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  000a9	e8 00 00 00 00	 call	 _MirrorBits128
  000ae	46		 inc	 esi
  000af	8d 7f 10	 lea	 edi, DWORD PTR [edi+16]
  000b2	83 c4 04	 add	 esp, 4
  000b5	83 fe 10	 cmp	 esi, 16			; 00000010H
  000b8	7c ba		 jl	 SHORT $LL7@Gf128Tab64

; 842  : 
; 843  : 	/* Convert 8k LSB-first table to 4k MSB-first */
; 844  : 	for (i = 16; i < 32; i++) 

  000ba	8b 45 e8	 mov	 eax, DWORD PTR tv549[ebp]
  000bd	83 c3 10	 add	 ebx, 16			; 00000010H
  000c0	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  000c5	89 45 e8	 mov	 DWORD PTR tv549[ebp], eax
  000c8	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  000ce	7c a0		 jl	 SHORT $LL4@Gf128Tab64

; 856  : 		}
; 857  : 	}
; 858  : 
; 859  : 	burn (ctx8k ,sizeof (*ctx8k));

  000d0	8b 7d e0	 mov	 edi, DWORD PTR _ctx8k$1$[ebp]
  000d3	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  000d8	8b c7		 mov	 eax, edi
  000da	8b f1		 mov	 esi, ecx
  000dc	8b d7		 mov	 edx, edi
  000de	5b		 pop	 ebx
  000df	90		 npad	 1
$LL21@Gf128Tab64:
  000e0	c6 02 00	 mov	 BYTE PTR [edx], 0
  000e3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000e6	83 ee 01	 sub	 esi, 1
  000e9	75 f5		 jne	 SHORT $LL21@Gf128Tab64
  000eb	0f 1f 44 00 00	 npad	 5
$LL11@Gf128Tab64:
  000f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  000f3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000f6	83 e9 01	 sub	 ecx, 1
  000f9	75 f5		 jne	 SHORT $LL11@Gf128Tab64

; 860  : 	burn (am, sizeof (am));

  000fb	8d 45 ec	 lea	 eax, DWORD PTR _am$[ebp]
  000fe	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00103	8b f1		 mov	 esi, ecx
  00105	8b d0		 mov	 edx, eax
$LL25@Gf128Tab64:
  00107	c6 02 00	 mov	 BYTE PTR [edx], 0
  0010a	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0010d	83 ee 01	 sub	 esi, 1
  00110	75 f5		 jne	 SHORT $LL25@Gf128Tab64
$LL16@Gf128Tab64:
  00112	c6 00 00	 mov	 BYTE PTR [eax], 0
  00115	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00118	83 e9 01	 sub	 ecx, 1
  0011b	75 f5		 jne	 SHORT $LL16@Gf128Tab64

; 861  : 	GSTfree (ctx8k);

  0011d	57		 push	 edi
  0011e	e8 00 00 00 00	 call	 _free

; 862  : 	return TRUE;
; 863  : }

  00123	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00126	83 c4 04	 add	 esp, 4
  00129	33 cd		 xor	 ecx, ebp
  0012b	b8 01 00 00 00	 mov	 eax, 1
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
_Gf128Tab64Init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _GfMul128Tab
_TEXT	SEGMENT
tv6791 = -4						; size = 4
tv6789 = -4						; size = 4
tv6787 = -4						; size = 4
tv6785 = -4						; size = 4
tv6783 = -4						; size = 4
tv6781 = -4						; size = 4
tv6779 = -4						; size = 4
tv6777 = -4						; size = 4
tv6775 = -4						; size = 4
tv6773 = -4						; size = 4
tv6771 = -4						; size = 4
tv6769 = -4						; size = 4
tv6767 = -4						; size = 4
tv6765 = -4						; size = 4
tv6763 = -4						; size = 4
_a$ = 8							; size = 4
_r$4$ = 12						; size = 4
_ctx$ = 12						; size = 4
_GfMul128Tab PROC					; COMDAT

; 569  : {   unsigned __int32 r[CBLK_LEN >> 2];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 570  : 
; 571  :     move_block_aligned(r, ctx->gf_t8k[0][a[0] & 15]);

  00004	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  00007	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00010	8b c1		 mov	 eax, ecx

; 572  :     xor_block_aligned(r, ctx->gf_t8k[1][a[0] >> 4]);

  00012	c1 e9 04	 shr	 ecx, 4
  00015	83 e0 0f	 and	 eax, 15			; 0000000fH
  00018	83 c1 10	 add	 ecx, 16			; 00000010H
  0001b	03 c0		 add	 eax, eax
  0001d	03 c9		 add	 ecx, ecx
  0001f	8b 34 c2	 mov	 esi, DWORD PTR [edx+eax*8]
  00022	8b 7c c2 04	 mov	 edi, DWORD PTR [edx+eax*8+4]
  00026	8b 5c c2 08	 mov	 ebx, DWORD PTR [edx+eax*8+8]
  0002a	8b 44 c2 0c	 mov	 eax, DWORD PTR [edx+eax*8+12]
  0002e	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  00032	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  00035	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  00039	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  0003d	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax

; 573  :                 xor_8k( 1); xor_8k( 2); xor_8k( 3);

  00040	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00043	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00047	8b c1		 mov	 eax, ecx
  00049	89 4d fc	 mov	 DWORD PTR tv6763[ebp], ecx
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  0004f	83 e0 0f	 and	 eax, 15			; 0000000fH
  00052	83 c0 20	 add	 eax, 32			; 00000020H
  00055	03 c0		 add	 eax, eax
  00057	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  0005b	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  0005e	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  00062	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  00066	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR tv6763[ebp]
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  0006f	c1 e9 04	 shr	 ecx, 4
  00072	83 c1 30	 add	 ecx, 48			; 00000030H
  00075	03 c9		 add	 ecx, ecx
  00077	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  0007b	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  0007e	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  00082	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  00086	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  00089	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0008c	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00090	8b c1		 mov	 eax, ecx
  00092	89 4d fc	 mov	 DWORD PTR tv6765[ebp], ecx
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  00098	83 e0 0f	 and	 eax, 15			; 0000000fH
  0009b	83 c0 40	 add	 eax, 64			; 00000040H
  0009e	03 c0		 add	 eax, eax
  000a0	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  000a4	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  000a7	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  000ab	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  000af	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR tv6765[ebp]
  000b5	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  000b8	c1 e9 04	 shr	 ecx, 4
  000bb	83 c1 50	 add	 ecx, 80			; 00000050H
  000be	03 c9		 add	 ecx, ecx
  000c0	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  000c4	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  000c7	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  000cb	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  000cf	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  000d2	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000d5	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000d9	8b c1		 mov	 eax, ecx
  000db	89 4d fc	 mov	 DWORD PTR tv6767[ebp], ecx
  000de	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  000e1	83 e0 0f	 and	 eax, 15			; 0000000fH
  000e4	83 c0 60	 add	 eax, 96			; 00000060H
  000e7	03 c0		 add	 eax, eax
  000e9	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  000ec	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  000f0	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  000f4	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  000f8	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  000fb	8b 4d fc	 mov	 ecx, DWORD PTR tv6767[ebp]
  000fe	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  00101	c1 e9 04	 shr	 ecx, 4
  00104	83 c1 70	 add	 ecx, 112		; 00000070H
  00107	03 c9		 add	 ecx, ecx
  00109	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  0010d	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  00110	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  00114	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  00118	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax

; 574  :     xor_8k( 4); xor_8k( 5); xor_8k( 6); xor_8k( 7);

  0011b	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0011e	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00122	8b c1		 mov	 eax, ecx
  00124	89 4d fc	 mov	 DWORD PTR tv6769[ebp], ecx
  00127	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  0012a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0012d	83 e8 80	 sub	 eax, -128		; ffffff80H
  00130	03 c0		 add	 eax, eax
  00132	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  00136	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  00139	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  0013d	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  00141	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  00144	8b 4d fc	 mov	 ecx, DWORD PTR tv6769[ebp]
  00147	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  0014a	c1 e9 04	 shr	 ecx, 4
  0014d	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00153	03 c9		 add	 ecx, ecx
  00155	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  00159	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  0015c	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  00160	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  00164	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  00167	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0016a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0016e	8b c1		 mov	 eax, ecx
  00170	89 4d fc	 mov	 DWORD PTR tv6771[ebp], ecx
  00173	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  00176	83 e0 0f	 and	 eax, 15			; 0000000fH
  00179	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  0017e	03 c0		 add	 eax, eax
  00180	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  00184	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  00187	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  0018b	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  0018f	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  00192	8b 4d fc	 mov	 ecx, DWORD PTR tv6771[ebp]
  00195	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  00198	c1 e9 04	 shr	 ecx, 4
  0019b	81 c1 b0 00 00
	00		 add	 ecx, 176		; 000000b0H
  001a1	03 c9		 add	 ecx, ecx
  001a3	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  001a7	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  001aa	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  001ae	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  001b2	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  001b5	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001b8	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  001bc	8b c1		 mov	 eax, ecx
  001be	89 4d fc	 mov	 DWORD PTR tv6773[ebp], ecx
  001c1	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  001c4	83 e0 0f	 and	 eax, 15			; 0000000fH
  001c7	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  001cc	03 c0		 add	 eax, eax
  001ce	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  001d2	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  001d5	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  001d9	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  001dd	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  001e0	8b 4d fc	 mov	 ecx, DWORD PTR tv6773[ebp]
  001e3	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  001e6	c1 e9 04	 shr	 ecx, 4
  001e9	81 c1 d0 00 00
	00		 add	 ecx, 208		; 000000d0H
  001ef	03 c9		 add	 ecx, ecx
  001f1	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  001f4	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  001f8	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  001fc	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  00200	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  00203	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00206	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0020a	89 4d fc	 mov	 DWORD PTR tv6775[ebp], ecx
  0020d	8b c1		 mov	 eax, ecx
  0020f	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  00212	83 e0 0f	 and	 eax, 15			; 0000000fH
  00215	05 e0 00 00 00	 add	 eax, 224		; 000000e0H
  0021a	03 c0		 add	 eax, eax
  0021c	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  00220	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  00223	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  00227	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  0022b	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  0022e	8b 4d fc	 mov	 ecx, DWORD PTR tv6775[ebp]
  00231	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  00234	c1 e9 04	 shr	 ecx, 4
  00237	81 c1 f0 00 00
	00		 add	 ecx, 240		; 000000f0H
  0023d	03 c9		 add	 ecx, ecx
  0023f	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  00243	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  00246	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  0024a	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  0024e	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax

; 575  :     xor_8k( 8); xor_8k( 9); xor_8k(10); xor_8k(11);

  00251	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00254	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00258	8b c1		 mov	 eax, ecx
  0025a	89 4d fc	 mov	 DWORD PTR tv6777[ebp], ecx
  0025d	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  00260	83 e0 0f	 and	 eax, 15			; 0000000fH
  00263	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00268	03 c0		 add	 eax, eax
  0026a	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  0026e	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  00271	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  00275	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  00279	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  0027c	8b 4d fc	 mov	 ecx, DWORD PTR tv6777[ebp]
  0027f	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  00282	c1 e9 04	 shr	 ecx, 4
  00285	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  0028b	03 c9		 add	 ecx, ecx
  0028d	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  00291	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  00294	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  00298	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  0029c	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  0029f	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  002a2	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  002a6	8b c1		 mov	 eax, ecx
  002a8	89 4d fc	 mov	 DWORD PTR tv6779[ebp], ecx
  002ab	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  002ae	83 e0 0f	 and	 eax, 15			; 0000000fH
  002b1	05 20 01 00 00	 add	 eax, 288		; 00000120H
  002b6	03 c0		 add	 eax, eax
  002b8	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  002bc	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  002bf	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  002c3	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  002c7	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  002ca	8b 4d fc	 mov	 ecx, DWORD PTR tv6779[ebp]
  002cd	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  002d0	c1 e9 04	 shr	 ecx, 4
  002d3	81 c1 30 01 00
	00		 add	 ecx, 304		; 00000130H
  002d9	03 c9		 add	 ecx, ecx
  002db	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  002df	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  002e2	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  002e6	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  002ea	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  002ed	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  002f0	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  002f4	8b c1		 mov	 eax, ecx
  002f6	89 4d fc	 mov	 DWORD PTR tv6781[ebp], ecx
  002f9	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  002fc	83 e0 0f	 and	 eax, 15			; 0000000fH
  002ff	05 40 01 00 00	 add	 eax, 320		; 00000140H
  00304	03 c0		 add	 eax, eax
  00306	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  0030a	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  0030d	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  00311	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  00315	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  00318	8b 4d fc	 mov	 ecx, DWORD PTR tv6781[ebp]
  0031b	c1 e9 04	 shr	 ecx, 4
  0031e	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  00321	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  00327	03 c9		 add	 ecx, ecx
  00329	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  0032d	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  00330	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  00334	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  00338	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  0033b	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0033e	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  00342	8b c1		 mov	 eax, ecx
  00344	89 4d fc	 mov	 DWORD PTR tv6783[ebp], ecx
  00347	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  0034a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0034d	05 60 01 00 00	 add	 eax, 352		; 00000160H
  00352	03 c0		 add	 eax, eax
  00354	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  00358	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  0035b	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  0035f	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  00363	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  00366	8b 4d fc	 mov	 ecx, DWORD PTR tv6783[ebp]
  00369	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  0036c	c1 e9 04	 shr	 ecx, 4
  0036f	81 c1 70 01 00
	00		 add	 ecx, 368		; 00000170H
  00375	03 c9		 add	 ecx, ecx
  00377	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  0037b	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  0037e	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  00382	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  00386	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax

; 576  :     xor_8k(12); xor_8k(13); xor_8k(14); xor_8k(15);

  00389	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0038c	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  00390	8b c1		 mov	 eax, ecx
  00392	89 4d fc	 mov	 DWORD PTR tv6785[ebp], ecx
  00395	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  00398	83 e0 0f	 and	 eax, 15			; 0000000fH
  0039b	05 80 01 00 00	 add	 eax, 384		; 00000180H
  003a0	03 c0		 add	 eax, eax
  003a2	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  003a6	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  003a9	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  003ad	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  003b1	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  003b4	8b 4d fc	 mov	 ecx, DWORD PTR tv6785[ebp]
  003b7	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  003ba	c1 e9 04	 shr	 ecx, 4
  003bd	81 c1 90 01 00
	00		 add	 ecx, 400		; 00000190H
  003c3	03 c9		 add	 ecx, ecx
  003c5	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  003c9	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  003cc	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  003d0	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  003d4	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  003d7	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  003da	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  003de	8b c1		 mov	 eax, ecx
  003e0	89 4d fc	 mov	 DWORD PTR tv6787[ebp], ecx
  003e3	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  003e6	83 e0 0f	 and	 eax, 15			; 0000000fH
  003e9	05 a0 01 00 00	 add	 eax, 416		; 000001a0H
  003ee	03 c0		 add	 eax, eax
  003f0	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  003f4	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  003f7	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  003fb	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  003ff	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  00402	8b 4d fc	 mov	 ecx, DWORD PTR tv6787[ebp]
  00405	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  00408	c1 e9 04	 shr	 ecx, 4
  0040b	81 c1 b0 01 00
	00		 add	 ecx, 432		; 000001b0H
  00411	03 c9		 add	 ecx, ecx
  00413	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  00416	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  0041a	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  0041e	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  00422	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  00425	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00428	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0042c	89 4d fc	 mov	 DWORD PTR tv6789[ebp], ecx
  0042f	8b c1		 mov	 eax, ecx
  00431	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  00434	83 e0 0f	 and	 eax, 15			; 0000000fH
  00437	05 c0 01 00 00	 add	 eax, 448		; 000001c0H
  0043c	03 c0		 add	 eax, eax
  0043e	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  00442	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  00445	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  00449	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  0044d	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  00450	8b 4d fc	 mov	 ecx, DWORD PTR tv6789[ebp]
  00453	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  00456	c1 e9 04	 shr	 ecx, 4
  00459	81 c1 d0 01 00
	00		 add	 ecx, 464		; 000001d0H
  0045f	03 c9		 add	 ecx, ecx
  00461	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]
  00465	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  00468	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  0046c	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  00470	89 45 0c	 mov	 DWORD PTR _r$4$[ebp], eax
  00473	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00476	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  0047a	8b c1		 mov	 eax, ecx
  0047c	89 4d fc	 mov	 DWORD PTR tv6791[ebp], ecx
  0047f	8b 4d 0c	 mov	 ecx, DWORD PTR _r$4$[ebp]
  00482	83 e0 0f	 and	 eax, 15			; 0000000fH
  00485	05 e0 01 00 00	 add	 eax, 480		; 000001e0H
  0048a	03 c0		 add	 eax, eax
  0048c	33 4c c2 0c	 xor	 ecx, DWORD PTR [edx+eax*8+12]
  00490	33 34 c2	 xor	 esi, DWORD PTR [edx+eax*8]
  00493	33 7c c2 04	 xor	 edi, DWORD PTR [edx+eax*8+4]
  00497	33 5c c2 08	 xor	 ebx, DWORD PTR [edx+eax*8+8]
  0049b	89 4d 0c	 mov	 DWORD PTR _r$4$[ebp], ecx
  0049e	8b 4d fc	 mov	 ecx, DWORD PTR tv6791[ebp]
  004a1	8b 45 0c	 mov	 eax, DWORD PTR _r$4$[ebp]
  004a4	c1 e9 04	 shr	 ecx, 4
  004a7	81 c1 f0 01 00
	00		 add	 ecx, 496		; 000001f0H
  004ad	03 c9		 add	 ecx, ecx
  004af	33 34 ca	 xor	 esi, DWORD PTR [edx+ecx*8]
  004b2	33 7c ca 04	 xor	 edi, DWORD PTR [edx+ecx*8+4]
  004b6	33 5c ca 08	 xor	 ebx, DWORD PTR [edx+ecx*8+8]
  004ba	33 44 ca 0c	 xor	 eax, DWORD PTR [edx+ecx*8+12]

; 577  :     move_block_aligned(a, r);

  004be	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  004c1	89 31		 mov	 DWORD PTR [ecx], esi
  004c3	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  004c6	5f		 pop	 edi
  004c7	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
  004ca	5e		 pop	 esi
  004cb	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  004ce	5b		 pop	 ebx

; 578  : }

  004cf	8b e5		 mov	 esp, ebp
  004d1	5d		 pop	 ebp
  004d2	c3		 ret	 0
_GfMul128Tab ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\gfmul.c
;	COMDAT _GfMul128
_TEXT	SEGMENT
_a$GSCopy$1$ = -272					; size = 4
_p$16$ = -268						; size = 4
_p$32$ = -264						; size = 4
_p$31$ = -260						; size = 4
_p$30$ = -256						; size = 4
_p$7$ = -252						; size = 4
_p$29$ = -248						; size = 4
_p$4$ = -244						; size = 4
_p$28$ = -240						; size = 4
_p$27$ = -236						; size = 4
_p$23$ = -232						; size = 4
_p$24$ = -228						; size = 4
_p$25$ = -224						; size = 4
_p$26$ = -220						; size = 4
_i$1$ = -216						; size = 4
tv4235 = -212						; size = 4
_p$18$ = -208						; size = 4
_p$17$ = -204						; size = 4
_p$14$ = -200						; size = 4
_p$13$ = -196						; size = 4
_p$11$ = -192						; size = 4
_p$10$ = -188						; size = 4
_p$8$ = -184						; size = 4
_p$5$ = -180						; size = 4
_p$2$ = -176						; size = 4
_p$1$ = -172						; size = 4
_p$3$ = -168						; size = 4
_p$15$ = -164						; size = 4
_p$12$ = -160						; size = 4
_p$9$ = -156						; size = 4
_p$6$ = -152						; size = 4
_p$ = -148						; size = 128
_r$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_GfMul128 PROC						; COMDAT

; 513  : {   mode(32t) r[CBLK_LEN >> 2], p[8][CBLK_LEN >> 2];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 514  :     int i;
; 515  : 
; 516  :     move_block_aligned(p[0], b);

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]

; 517  :     bsw_32(p[0], 4);

  00016	ba 04 00 00 00	 mov	 edx, 4
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	89 85 6c ff ff
	ff		 mov	 DWORD PTR _p$[ebp], eax
  00028	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002b	89 85 70 ff ff
	ff		 mov	 DWORD PTR _p$[ebp+4], eax
  00031	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00034	89 85 74 ff ff
	ff		 mov	 DWORD PTR _p$[ebp+8], eax
  0003a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003d	57		 push	 edi
  0003e	89 b5 f0 fe ff
	ff		 mov	 DWORD PTR _a$GSCopy$1$[ebp], esi
  00044	89 85 78 ff ff
	ff		 mov	 DWORD PTR _p$[ebp+12], eax
  0004a	66 0f 1f 44 00
	00		 npad	 6
$LL21@GfMul128:
  00050	8b 8c 95 68 ff
	ff ff		 mov	 ecx, DWORD PTR _p$[ebp+edx*4-4]
  00057	4a		 dec	 edx
  00058	8b c1		 mov	 eax, ecx
  0005a	c1 c1 08	 rol	 ecx, 8
  0005d	c1 c8 08	 ror	 eax, 8
  00060	81 e1 ff 00 ff
	00		 and	 ecx, 16711935		; 00ff00ffH
  00066	25 00 ff 00 ff	 and	 eax, -16711936		; ff00ff00H
  0006b	0b c1		 or	 eax, ecx
  0006d	89 84 95 6c ff
	ff ff		 mov	 DWORD PTR _p$[ebp+edx*4], eax
  00074	85 d2		 test	 edx, edx
  00076	75 d8		 jne	 SHORT $LL21@GfMul128

; 518  :     for(i = 0; i < 7; ++i)
; 519  :     {
; 520  :         p[i + 1][3] = (p[i][3] >> 1) | (p[i][2] << 31);

  00078	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _p$[ebp+8]
  0007e	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp+12]
  00084	d1 e8		 shr	 eax, 1

; 521  :         p[i + 1][2] = (p[i][2] >> 1) | (p[i][1] << 31);

  00086	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _p$[ebp+4]

; 522  :         p[i + 1][1] = (p[i][1] >> 1) | (p[i][0] << 31);

  0008c	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _p$[ebp]

; 523  :         p[i + 1][0] = (p[i][0] >> 1) ^ gf_poly[p[i][3] & 1];

  00092	8b bd 6c ff ff
	ff		 mov	 edi, DWORD PTR _p$[ebp]
  00098	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  0009b	0b c8		 or	 ecx, eax
  0009d	c1 e2 1f	 shl	 edx, 31			; 0000001fH
  000a0	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp+8]
  000a6	d1 e8		 shr	 eax, 1
  000a8	0b d0		 or	 edx, eax
  000aa	c1 e3 1f	 shl	 ebx, 31			; 0000001fH
  000ad	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp+4]
  000b3	d1 e8		 shr	 eax, 1
  000b5	0b d8		 or	 ebx, eax
  000b7	d1 ef		 shr	 edi, 1
  000b9	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp+12]
  000bf	83 e0 01	 and	 eax, 1
  000c2	89 95 1c ff ff
	ff		 mov	 DWORD PTR _p$24$[ebp], edx
  000c8	89 9d 20 ff ff
	ff		 mov	 DWORD PTR _p$25$[ebp], ebx
  000ce	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _p$23$[ebp], ecx
  000d4	33 3c 85 00 00
	00 00		 xor	 edi, DWORD PTR _gf_poly[eax*4]
  000db	8b c2		 mov	 eax, edx
  000dd	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  000e0	89 85 58 ff ff
	ff		 mov	 DWORD PTR _p$3$[ebp], eax
  000e6	8b c1		 mov	 eax, ecx
  000e8	d1 e8		 shr	 eax, 1
  000ea	83 e1 01	 and	 ecx, 1
  000ed	09 85 58 ff ff
	ff		 or	 DWORD PTR _p$3$[ebp], eax
  000f3	8b c3		 mov	 eax, ebx
  000f5	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  000f8	89 85 50 ff ff
	ff		 mov	 DWORD PTR _p$2$[ebp], eax
  000fe	8b c2		 mov	 eax, edx
  00100	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _p$2$[ebp]
  00106	d1 e8		 shr	 eax, 1
  00108	0b d0		 or	 edx, eax
  0010a	89 bd 24 ff ff
	ff		 mov	 DWORD PTR _p$26$[ebp], edi
  00110	8b c7		 mov	 eax, edi
  00112	89 95 50 ff ff
	ff		 mov	 DWORD PTR _p$2$[ebp], edx
  00118	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  0011b	89 85 54 ff ff
	ff		 mov	 DWORD PTR _p$1$[ebp], eax
  00121	8b c3		 mov	 eax, ebx
  00123	8b 9d 54 ff ff
	ff		 mov	 ebx, DWORD PTR _p$1$[ebp]
  00129	d1 e8		 shr	 eax, 1
  0012b	0b d8		 or	 ebx, eax
  0012d	d1 ef		 shr	 edi, 1
  0012f	33 3c 8d 00 00
	00 00		 xor	 edi, DWORD PTR _gf_poly[ecx*4]
  00136	8b c2		 mov	 eax, edx
  00138	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _p$3$[ebp]
  0013e	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  00141	89 85 68 ff ff
	ff		 mov	 DWORD PTR _p$6$[ebp], eax
  00147	8b c1		 mov	 eax, ecx
  00149	d1 e8		 shr	 eax, 1
  0014b	83 e1 01	 and	 ecx, 1
  0014e	09 85 68 ff ff
	ff		 or	 DWORD PTR _p$6$[ebp], eax
  00154	8b c3		 mov	 eax, ebx
  00156	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  00159	89 85 4c ff ff
	ff		 mov	 DWORD PTR _p$5$[ebp], eax
  0015f	8b c2		 mov	 eax, edx
  00161	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _p$5$[ebp]
  00167	d1 e8		 shr	 eax, 1
  00169	0b d0		 or	 edx, eax
  0016b	89 9d 54 ff ff
	ff		 mov	 DWORD PTR _p$1$[ebp], ebx
  00171	8b c7		 mov	 eax, edi
  00173	d1 eb		 shr	 ebx, 1
  00175	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  00178	0b d8		 or	 ebx, eax
  0017a	89 bd 14 ff ff
	ff		 mov	 DWORD PTR _p$27$[ebp], edi
  00180	d1 ef		 shr	 edi, 1
  00182	8b c2		 mov	 eax, edx
  00184	33 3c 8d 00 00
	00 00		 xor	 edi, DWORD PTR _gf_poly[ecx*4]
  0018b	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _p$6$[ebp]
  00191	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  00194	89 85 64 ff ff
	ff		 mov	 DWORD PTR _p$9$[ebp], eax
  0019a	8b c1		 mov	 eax, ecx
  0019c	d1 e8		 shr	 eax, 1
  0019e	09 85 64 ff ff
	ff		 or	 DWORD PTR _p$9$[ebp], eax
  001a4	89 95 4c ff ff
	ff		 mov	 DWORD PTR _p$5$[ebp], edx
  001aa	89 9d 0c ff ff
	ff		 mov	 DWORD PTR _p$4$[ebp], ebx
  001b0	89 bd 10 ff ff
	ff		 mov	 DWORD PTR _p$28$[ebp], edi
  001b6	8b c3		 mov	 eax, ebx
  001b8	83 e1 01	 and	 ecx, 1
  001bb	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  001be	89 85 48 ff ff
	ff		 mov	 DWORD PTR _p$8$[ebp], eax
  001c4	8b c2		 mov	 eax, edx
  001c6	d1 e8		 shr	 eax, 1
  001c8	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _p$8$[ebp]
  001ce	0b d0		 or	 edx, eax
  001d0	d1 eb		 shr	 ebx, 1
  001d2	8b c7		 mov	 eax, edi
  001d4	89 95 48 ff ff
	ff		 mov	 DWORD PTR _p$8$[ebp], edx
  001da	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  001dd	0b d8		 or	 ebx, eax
  001df	d1 ef		 shr	 edi, 1
  001e1	33 3c 8d 00 00
	00 00		 xor	 edi, DWORD PTR _gf_poly[ecx*4]
  001e8	8b c2		 mov	 eax, edx
  001ea	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _p$9$[ebp]
  001f0	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  001f3	89 85 60 ff ff
	ff		 mov	 DWORD PTR _p$12$[ebp], eax
  001f9	8b c1		 mov	 eax, ecx
  001fb	d1 e8		 shr	 eax, 1
  001fd	83 e1 01	 and	 ecx, 1
  00200	09 85 60 ff ff
	ff		 or	 DWORD PTR _p$12$[ebp], eax
  00206	8b c3		 mov	 eax, ebx
  00208	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  0020b	89 85 40 ff ff
	ff		 mov	 DWORD PTR _p$11$[ebp], eax
  00211	8b c2		 mov	 eax, edx
  00213	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _p$11$[ebp]
  00219	d1 e8		 shr	 eax, 1
  0021b	0b d0		 or	 edx, eax
  0021d	89 9d 04 ff ff
	ff		 mov	 DWORD PTR _p$7$[ebp], ebx
  00223	8b c7		 mov	 eax, edi
  00225	89 bd 08 ff ff
	ff		 mov	 DWORD PTR _p$29$[ebp], edi
  0022b	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  0022e	89 85 44 ff ff
	ff		 mov	 DWORD PTR _p$10$[ebp], eax
  00234	8b c3		 mov	 eax, ebx
  00236	8b 9d 44 ff ff
	ff		 mov	 ebx, DWORD PTR _p$10$[ebp]
  0023c	d1 e8		 shr	 eax, 1
  0023e	0b d8		 or	 ebx, eax
  00240	d1 ef		 shr	 edi, 1
  00242	33 3c 8d 00 00
	00 00		 xor	 edi, DWORD PTR _gf_poly[ecx*4]
  00249	8b c2		 mov	 eax, edx
  0024b	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _p$12$[ebp]
  00251	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  00254	89 85 5c ff ff
	ff		 mov	 DWORD PTR _p$15$[ebp], eax
  0025a	8b c1		 mov	 eax, ecx
  0025c	d1 e8		 shr	 eax, 1
  0025e	83 e1 01	 and	 ecx, 1
  00261	09 85 5c ff ff
	ff		 or	 DWORD PTR _p$15$[ebp], eax
  00267	8b c3		 mov	 eax, ebx
  00269	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  0026c	89 85 38 ff ff
	ff		 mov	 DWORD PTR _p$14$[ebp], eax
  00272	8b c2		 mov	 eax, edx
  00274	d1 e8		 shr	 eax, 1
  00276	89 95 40 ff ff
	ff		 mov	 DWORD PTR _p$11$[ebp], edx
  0027c	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _p$14$[ebp]
  00282	0b d0		 or	 edx, eax
  00284	89 9d 44 ff ff
	ff		 mov	 DWORD PTR _p$10$[ebp], ebx
  0028a	8b c7		 mov	 eax, edi
  0028c	89 bd 00 ff ff
	ff		 mov	 DWORD PTR _p$30$[ebp], edi
  00292	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  00295	89 85 3c ff ff
	ff		 mov	 DWORD PTR _p$13$[ebp], eax
  0029b	8b c3		 mov	 eax, ebx
  0029d	8b 9d 3c ff ff
	ff		 mov	 ebx, DWORD PTR _p$13$[ebp]
  002a3	d1 e8		 shr	 eax, 1
  002a5	0b d8		 or	 ebx, eax
  002a7	d1 ef		 shr	 edi, 1
  002a9	33 3c 8d 00 00
	00 00		 xor	 edi, DWORD PTR _gf_poly[ecx*4]
  002b0	8b c2		 mov	 eax, edx
  002b2	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  002b5	89 85 30 ff ff
	ff		 mov	 DWORD PTR _p$18$[ebp], eax
  002bb	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _p$15$[ebp]
  002c1	d1 e8		 shr	 eax, 1
  002c3	09 85 30 ff ff
	ff		 or	 DWORD PTR _p$18$[ebp], eax
  002c9	8b c3		 mov	 eax, ebx
  002cb	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  002ce	89 85 34 ff ff
	ff		 mov	 DWORD PTR _p$17$[ebp], eax
  002d4	8b c2		 mov	 eax, edx
  002d6	89 95 38 ff ff
	ff		 mov	 DWORD PTR _p$14$[ebp], edx
  002dc	89 9d 3c ff ff
	ff		 mov	 DWORD PTR _p$13$[ebp], ebx
  002e2	89 bd fc fe ff
	ff		 mov	 DWORD PTR _p$31$[ebp], edi

; 522  :         p[i + 1][1] = (p[i][1] >> 1) | (p[i][0] << 31);

  002e8	d1 e8		 shr	 eax, 1
  002ea	8b d7		 mov	 edx, edi
  002ec	09 85 34 ff ff
	ff		 or	 DWORD PTR _p$17$[ebp], eax

; 523  :         p[i + 1][0] = (p[i][0] >> 1) ^ gf_poly[p[i][3] & 1];

  002f2	8b cf		 mov	 ecx, edi
  002f4	8b c3		 mov	 eax, ebx
  002f6	c1 e2 1f	 shl	 edx, 31			; 0000001fH
  002f9	d1 e8		 shr	 eax, 1
  002fb	0f 57 c0	 xorps	 xmm0, xmm0
  002fe	0b d0		 or	 edx, eax
  00300	d1 e9		 shr	 ecx, 1
  00302	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _p$15$[ebp]
  00308	83 e0 01	 and	 eax, 1
  0030b	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _p$16$[ebp], edx

; 524  :     }
; 525  : 
; 526  :     memset(r, 0, CBLK_LEN);

  00311	0f 11 45 ec	 movups	 XMMWORD PTR _r$[ebp], xmm0
  00315	8b 55 f8	 mov	 edx, DWORD PTR _r$[ebp+12]
  00318	8b 7d f0	 mov	 edi, DWORD PTR _r$[ebp+4]
  0031b	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR _gf_poly[eax*4]
  00322	8d 46 0f	 lea	 eax, DWORD PTR [esi+15]
  00325	8b 75 f4	 mov	 esi, DWORD PTR _r$[ebp+8]
  00328	8b 5d ec	 mov	 ebx, DWORD PTR _r$[ebp]
  0032b	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _p$32$[ebp], ecx

; 527  :     for(i = 0; i < 16; ++i)

  00331	33 c9		 xor	 ecx, ecx
  00333	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ecx
  00339	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv4235[ebp], eax
  0033f	90		 npad	 1
$LL7@GfMul128:

; 528  :     {
; 529  :         if(i) mul_bex8(r);  /* order is always big endian here */

  00340	85 c9		 test	 ecx, ecx
  00342	74 49		 je	 SHORT $LN24@GfMul128
  00344	0f b6 ca	 movzx	 ecx, dl
  00347	8b c6		 mov	 eax, esi
  00349	c1 e0 18	 shl	 eax, 24			; 00000018H
  0034c	c1 ea 08	 shr	 edx, 8
  0034f	0b d0		 or	 edx, eax
  00351	c1 ee 08	 shr	 esi, 8
  00354	8b c7		 mov	 eax, edi
  00356	89 55 f8	 mov	 DWORD PTR _r$[ebp+12], edx
  00359	c1 e0 18	 shl	 eax, 24			; 00000018H
  0035c	0b f0		 or	 esi, eax
  0035e	c1 ef 08	 shr	 edi, 8
  00361	8b c3		 mov	 eax, ebx
  00363	89 75 f4	 mov	 DWORD PTR _r$[ebp+8], esi
  00366	c1 e0 18	 shl	 eax, 24			; 00000018H
  00369	0b f8		 or	 edi, eax
  0036b	c1 eb 08	 shr	 ebx, 8
  0036e	0f b7 04 4d 00
	00 00 00	 movzx	 eax, WORD PTR _gft_be[ecx*2]
  00376	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _i$1$[ebp]
  0037c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0037f	33 d8		 xor	 ebx, eax
  00381	89 7d f0	 mov	 DWORD PTR _r$[ebp+4], edi
  00384	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv4235[ebp]
  0038a	89 5d ec	 mov	 DWORD PTR _r$[ebp], ebx
$LN24@GfMul128:

; 530  : 
; 531  :         if(((unsigned char*)a)[15 - i] & 0x80)

  0038d	8a 00		 mov	 al, BYTE PTR [eax]
  0038f	84 c0		 test	 al, al
  00391	79 24		 jns	 SHORT $LN119@GfMul128

; 532  :             xor_block_aligned(r, p[0]);

  00393	33 9d 6c ff ff
	ff		 xor	 ebx, DWORD PTR _p$[ebp]
  00399	33 bd 70 ff ff
	ff		 xor	 edi, DWORD PTR _p$[ebp+4]
  0039f	33 b5 74 ff ff
	ff		 xor	 esi, DWORD PTR _p$[ebp+8]
  003a5	33 95 78 ff ff
	ff		 xor	 edx, DWORD PTR _p$[ebp+12]
  003ab	89 5d ec	 mov	 DWORD PTR _r$[ebp], ebx
  003ae	89 7d f0	 mov	 DWORD PTR _r$[ebp+4], edi
  003b1	89 75 f4	 mov	 DWORD PTR _r$[ebp+8], esi
  003b4	89 55 f8	 mov	 DWORD PTR _r$[ebp+12], edx
$LN119@GfMul128:

; 533  :         if(((unsigned char*)a)[15 - i] & 0x40)

  003b7	a8 40		 test	 al, 64			; 00000040H
  003b9	74 24		 je	 SHORT $LN124@GfMul128

; 534  :             xor_block_aligned(r, p[1]);

  003bb	33 9d 24 ff ff
	ff		 xor	 ebx, DWORD PTR _p$26$[ebp]
  003c1	33 bd 20 ff ff
	ff		 xor	 edi, DWORD PTR _p$25$[ebp]
  003c7	33 b5 1c ff ff
	ff		 xor	 esi, DWORD PTR _p$24$[ebp]
  003cd	33 95 18 ff ff
	ff		 xor	 edx, DWORD PTR _p$23$[ebp]
  003d3	89 5d ec	 mov	 DWORD PTR _r$[ebp], ebx
  003d6	89 7d f0	 mov	 DWORD PTR _r$[ebp+4], edi
  003d9	89 75 f4	 mov	 DWORD PTR _r$[ebp+8], esi
  003dc	89 55 f8	 mov	 DWORD PTR _r$[ebp+12], edx
$LN124@GfMul128:

; 535  :         if(((unsigned char*)a)[15 - i] & 0x20)

  003df	a8 20		 test	 al, 32			; 00000020H
  003e1	74 24		 je	 SHORT $LN129@GfMul128

; 536  :             xor_block_aligned(r, p[2]);

  003e3	33 9d 14 ff ff
	ff		 xor	 ebx, DWORD PTR _p$27$[ebp]
  003e9	33 bd 54 ff ff
	ff		 xor	 edi, DWORD PTR _p$1$[ebp]
  003ef	33 b5 50 ff ff
	ff		 xor	 esi, DWORD PTR _p$2$[ebp]
  003f5	33 95 58 ff ff
	ff		 xor	 edx, DWORD PTR _p$3$[ebp]
  003fb	89 5d ec	 mov	 DWORD PTR _r$[ebp], ebx
  003fe	89 7d f0	 mov	 DWORD PTR _r$[ebp+4], edi
  00401	89 75 f4	 mov	 DWORD PTR _r$[ebp+8], esi
  00404	89 55 f8	 mov	 DWORD PTR _r$[ebp+12], edx
$LN129@GfMul128:

; 537  :         if(((unsigned char*)a)[15 - i] & 0x10)

  00407	a8 10		 test	 al, 16			; 00000010H
  00409	74 24		 je	 SHORT $LN134@GfMul128

; 538  :             xor_block_aligned(r, p[3]);

  0040b	33 9d 10 ff ff
	ff		 xor	 ebx, DWORD PTR _p$28$[ebp]
  00411	33 bd 0c ff ff
	ff		 xor	 edi, DWORD PTR _p$4$[ebp]
  00417	33 b5 4c ff ff
	ff		 xor	 esi, DWORD PTR _p$5$[ebp]
  0041d	33 95 68 ff ff
	ff		 xor	 edx, DWORD PTR _p$6$[ebp]
  00423	89 5d ec	 mov	 DWORD PTR _r$[ebp], ebx
  00426	89 7d f0	 mov	 DWORD PTR _r$[ebp+4], edi
  00429	89 75 f4	 mov	 DWORD PTR _r$[ebp+8], esi
  0042c	89 55 f8	 mov	 DWORD PTR _r$[ebp+12], edx
$LN134@GfMul128:

; 539  :         if(((unsigned char*)a)[15 - i] & 0x08)

  0042f	a8 08		 test	 al, 8
  00431	74 24		 je	 SHORT $LN139@GfMul128

; 540  :             xor_block_aligned(r, p[4]);

  00433	33 9d 08 ff ff
	ff		 xor	 ebx, DWORD PTR _p$29$[ebp]
  00439	33 bd 04 ff ff
	ff		 xor	 edi, DWORD PTR _p$7$[ebp]
  0043f	33 b5 48 ff ff
	ff		 xor	 esi, DWORD PTR _p$8$[ebp]
  00445	33 95 64 ff ff
	ff		 xor	 edx, DWORD PTR _p$9$[ebp]
  0044b	89 5d ec	 mov	 DWORD PTR _r$[ebp], ebx
  0044e	89 7d f0	 mov	 DWORD PTR _r$[ebp+4], edi
  00451	89 75 f4	 mov	 DWORD PTR _r$[ebp+8], esi
  00454	89 55 f8	 mov	 DWORD PTR _r$[ebp+12], edx
$LN139@GfMul128:

; 541  :         if(((unsigned char*)a)[15 - i] & 0x04)

  00457	a8 04		 test	 al, 4
  00459	74 24		 je	 SHORT $LN144@GfMul128

; 542  :             xor_block_aligned(r, p[5]);

  0045b	33 9d 00 ff ff
	ff		 xor	 ebx, DWORD PTR _p$30$[ebp]
  00461	33 bd 44 ff ff
	ff		 xor	 edi, DWORD PTR _p$10$[ebp]
  00467	33 b5 40 ff ff
	ff		 xor	 esi, DWORD PTR _p$11$[ebp]
  0046d	33 95 60 ff ff
	ff		 xor	 edx, DWORD PTR _p$12$[ebp]
  00473	89 5d ec	 mov	 DWORD PTR _r$[ebp], ebx
  00476	89 7d f0	 mov	 DWORD PTR _r$[ebp+4], edi
  00479	89 75 f4	 mov	 DWORD PTR _r$[ebp+8], esi
  0047c	89 55 f8	 mov	 DWORD PTR _r$[ebp+12], edx
$LN144@GfMul128:

; 543  :         if(((unsigned char*)a)[15 - i] & 0x02)

  0047f	a8 02		 test	 al, 2
  00481	74 24		 je	 SHORT $LN149@GfMul128

; 544  :             xor_block_aligned(r, p[6]);

  00483	33 9d fc fe ff
	ff		 xor	 ebx, DWORD PTR _p$31$[ebp]
  00489	33 bd 3c ff ff
	ff		 xor	 edi, DWORD PTR _p$13$[ebp]
  0048f	33 b5 38 ff ff
	ff		 xor	 esi, DWORD PTR _p$14$[ebp]
  00495	33 95 5c ff ff
	ff		 xor	 edx, DWORD PTR _p$15$[ebp]
  0049b	89 5d ec	 mov	 DWORD PTR _r$[ebp], ebx
  0049e	89 7d f0	 mov	 DWORD PTR _r$[ebp+4], edi
  004a1	89 75 f4	 mov	 DWORD PTR _r$[ebp+8], esi
  004a4	89 55 f8	 mov	 DWORD PTR _r$[ebp+12], edx
$LN149@GfMul128:

; 545  :         if(((unsigned char*)a)[15 - i] & 0x01)

  004a7	a8 01		 test	 al, 1
  004a9	74 24		 je	 SHORT $LN5@GfMul128

; 546  :             xor_block_aligned(r, p[7]);

  004ab	33 9d f8 fe ff
	ff		 xor	 ebx, DWORD PTR _p$32$[ebp]
  004b1	33 bd f4 fe ff
	ff		 xor	 edi, DWORD PTR _p$16$[ebp]
  004b7	33 b5 34 ff ff
	ff		 xor	 esi, DWORD PTR _p$17$[ebp]
  004bd	33 95 30 ff ff
	ff		 xor	 edx, DWORD PTR _p$18$[ebp]
  004c3	89 5d ec	 mov	 DWORD PTR _r$[ebp], ebx
  004c6	89 7d f0	 mov	 DWORD PTR _r$[ebp+4], edi
  004c9	89 75 f4	 mov	 DWORD PTR _r$[ebp+8], esi
  004cc	89 55 f8	 mov	 DWORD PTR _r$[ebp+12], edx
$LN5@GfMul128:

; 527  :     for(i = 0; i < 16; ++i)

  004cf	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv4235[ebp]
  004d5	41		 inc	 ecx
  004d6	48		 dec	 eax
  004d7	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ecx
  004dd	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv4235[ebp], eax
  004e3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  004e6	0f 8c 54 fe ff
	ff		 jl	 $LL7@GfMul128

; 547  :     }
; 548  :     bsw_32(r, 4);

  004ec	5f		 pop	 edi
  004ed	5e		 pop	 esi
  004ee	ba 04 00 00 00	 mov	 edx, 4
  004f3	5b		 pop	 ebx
$LL43@GfMul128:
  004f4	8b 4c 95 e8	 mov	 ecx, DWORD PTR _r$[ebp+edx*4-4]
  004f8	4a		 dec	 edx
  004f9	8b c1		 mov	 eax, ecx
  004fb	c1 c1 08	 rol	 ecx, 8
  004fe	c1 c8 08	 ror	 eax, 8
  00501	81 e1 ff 00 ff
	00		 and	 ecx, 16711935		; 00ff00ffH
  00507	25 00 ff 00 ff	 and	 eax, -16711936		; ff00ff00H
  0050c	0b c1		 or	 eax, ecx
  0050e	89 44 95 ec	 mov	 DWORD PTR _r$[ebp+edx*4], eax
  00512	85 d2		 test	 edx, edx
  00514	75 de		 jne	 SHORT $LL43@GfMul128

; 549  :     move_block_aligned(a, r);

  00516	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _a$GSCopy$1$[ebp]
  0051c	8b 45 ec	 mov	 eax, DWORD PTR _r$[ebp]
  0051f	89 01		 mov	 DWORD PTR [ecx], eax
  00521	8b 45 f0	 mov	 eax, DWORD PTR _r$[ebp+4]
  00524	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00527	8b 45 f4	 mov	 eax, DWORD PTR _r$[ebp+8]
  0052a	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0052d	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp+12]
  00530	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 550  : }

  00533	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00536	33 cd		 xor	 ecx, ebp
  00538	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0053d	8b e5		 mov	 esp, ebp
  0053f	5d		 pop	 ebp
  00540	c3		 ret	 0
_GfMul128 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
