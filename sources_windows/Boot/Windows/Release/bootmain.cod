;	Static Name Aliases
;
	TITLE   ..\bootmain.cpp
	.MODEL  SMALL
	.386p
	.387
_TEXT	SEGMENT  WORD USE16 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD USE16 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD USE16 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD USE16 PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ??_C@_0BH@CKJE@Bootable?5Partitions?3?$AN?6?$AA@
PUBLIC  ??_C@_02PIMC@?$AN?6?$AA@
PUBLIC  ??_C@_03NMHE@y?$AN?6?$AA@
PUBLIC  ??_C@_03EDHP@n?$AN?6?$AA@
PUBLIC  ??_C@_0N@BNAP@?$ANRemaining?3?5?$AA@
PUBLIC  ??_C@_07MCKD@Drive?3?5?$AA@
PUBLIC  ??_C@_0O@LEMN@?0?5Partition?3?5?$AA@
PUBLIC  ??_C@_0BE@KCNB@?$ANCopying?5completed?4?$AA@
PUBLIC  ??_C@_08PFEJ@?0?5Size?3?5?$AA@
PUBLIC  ??_C@_0CA@HAB@Press?51?99?5to?5select?5partition?3?5?$AA@
PUBLIC  ??_C@_01KHLB@?$FL?$AA@
PUBLIC  ??_C@_05EFLO@?$FN?5?5?5?5?$AA@
PUBLIC  ??_C@_0BC@DHAO@?$FLEsc?$FN?5?5Cancel?$AN?6?$AN?6?$AA@
PUBLIC  ??_C@_0CA@FBFB@BIOS?5reserved?5too?5much?5memory?3?5?$AA@
PUBLIC  ??_C@_0DM@HBD@?9?5Upgrade?5BIOS?$AN?6?9?5Use?5a?5differen@
PUBLIC  ??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@
PUBLIC  ??_C@_0P@EOMF@Enter?5password?$AA@
PUBLIC  ??_C@_0BG@GEFN@?5for?5hidden?5system?3?$AN?6?$AA@
PUBLIC  ??_C@_02HFBK@?3?5?$AA@
PUBLIC  ??_C@_0CI@CHP@Your?5BIOS?5does?5not?5support?5large@
PUBLIC  ??_C@_0O@PLFN@?5due?5to?5a?5bug?$AA@
PUBLIC  ??_C@_0BM@NMNK@Warning?3?5Caps?5Lock?5is?5on?4?$AN?6?$AA@
PUBLIC  ??_C@_0BH@EGEK@?$AN?6?9?5Enable?5LBA?5in?5BIOS?$AA@
PUBLIC  ??_C@_0BI@KFOG@Incorrect?5password?4?$AN?6?$AN?6?$AA@
PUBLIC  ??_C@_0JN@DAOA@If?5you?5are?5sure?5the?5password?5is?5@
PUBLIC  ??_C@_0DM@NDEP@?$AN?6Copying?5system?5to?5hidden?5volum@
PUBLIC  ??_C@_0BP@OLOK@?5GostCrypt?5Boot?5Loader?51?43?41?$AN?6?$AA@
PUBLIC  ??_C@_0FD@OPN@?$ANIf?5aborted?0?5copying?5will?5have?5t@
PUBLIC  ??_C@_0BJ@CIJ@?5?5?5?5Keyboard?5Controls?3?$AN?6?$AA@
PUBLIC  ??_C@_0M@NCBA@?5?5?5?5?$FLEsc?$FN?5?5?$AA@
PUBLIC  ??_C@_05DILO@Abort?$AA@
PUBLIC  ??_C@_0CG@HLF@Boot?5Non?9Hidden?5System?5?$CIBoot?5Man@
PUBLIC  ??_C@_0CD@GJAD@Skip?5Authentication?5?$CIBoot?5Manage@
PUBLIC  ??_C@_0N@DGHN@Booting?4?4?4?$AN?6?$AA@
PUBLIC  ??_C@_0FB@DHKC@To?5fix?5bad?5sectors?3?51?$CJ?5Terminate@
PUBLIC  ??_C@_09LGPG@?$DP?5?$CIy?1n?$CJ?3?5?$AA@
EXTRN	__acrtused:ABS
EXTRN	_ReadVolumeHeader:NEAR
EXTRN	??H@YA?ATUINT64_STRUCT@@ABT0@0@Z:NEAR
EXTRN	??H@YA?ATUINT64_STRUCT@@ABT0@K@Z:NEAR
EXTRN	?Beep@@YAXXZ:NEAR
EXTRN	?ReadBootSectorUserConfiguration@@YAXXZ:NEAR
EXTRN	?PrintSectorCountInMB@@YAXABTUINT64_STRUCT@@@Z:NEAR
EXTRN	?ClearBiosKeystrokeBuffer@@YAXXZ:NEAR
EXTRN	??Y@YAAATUINT64_STRUCT@@AAT0@ABT0@@Z:NEAR
EXTRN	?UpdateBootSectorConfiguration@@YAEE@Z:NEAR
EXTRN	?ClearScreen@@YAXXZ:NEAR
EXTRN	?ReadWriteMBR@@YAEDED@Z:NEAR
EXTRN	_GetCrc32:NEAR
EXTRN	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z:NEAR
EXTRN	?EscKeyPressed@@YADXZ:NEAR
EXTRN	?GetKeyboardChar@@YAEXZ:NEAR
EXTRN	_EncryptDataUnits:NEAR
EXTRN	?GetKeyboardChar@@YAEPAE@Z:NEAR
EXTRN	??5@YA?ATUINT64_STRUCT@@ABT0@H@Z:NEAR
EXTRN	?GetShiftFlags@@YAEXZ:NEAR
EXTRN	??6@YA?ATUINT64_STRUCT@@ABT0@H@Z:NEAR
EXTRN	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z:NEAR
EXTRN	?GetString@@YAHPADI@Z:NEAR
EXTRN	?InitVideoMode@@YAXXZ:NEAR
EXTRN	??8@YADABTUINT64_STRUCT@@0@Z:NEAR
EXTRN	?IsPrintable@@YADD@Z:NEAR
EXTRN	?Print@@YAXPBD@Z:NEAR
EXTRN	?Print@@YAXK@Z:NEAR
EXTRN	_ThrowFatalException:NEAR
EXTRN	?PrintBackspace@@YAXXZ:NEAR
EXTRN	?ReadWriteSectors@@YAEDIIEABTUINT64_STRUCT@@ID@Z:NEAR
EXTRN	_EraseMemory:NEAR
EXTRN	?InstallInterruptFilters@@YADXZ:NEAR
EXTRN	?PrintChar@@YAXD@Z:NEAR
EXTRN	??N@YADABTUINT64_STRUCT@@0@Z:NEAR
EXTRN	?PrintCharAtCursor@@YAXD@Z:NEAR
EXTRN	?GetActivePartition@@YADE@Z:NEAR
EXTRN	?PrintEndl@@YAXXZ:NEAR
EXTRN	?CopyMemory@@YAXPAXIII@Z:NEAR
EXTRN	?PrintEndl@@YAXH@Z:NEAR
EXTRN	?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z:NEAR
EXTRN	?PrintRepeatedChar@@YAXDH@Z:NEAR
EXTRN	?CopyMemory@@YAXIIPAXI@Z:NEAR
EXTRN	?PrintError@@YAXPBD@Z:NEAR
EXTRN	?PrintErrorNoEndl@@YAXPBD@Z:NEAR
EXTRN	?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z:NEAR
EXTRN	?IsLbaSupported@@YADE@Z:NEAR
EXTRN	_crypto_close:NEAR
EXTRN	?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A:WORD
EXTRN	?EncryptedVirtualPartition@@3UPartition@@A:BYTE
EXTRN	?ActivePartition@@3UPartition@@A:BYTE
EXTRN	?PartitionFollowingActive@@3UPartition@@A:BYTE
EXTRN	?ExtraBootPartitionPresent@@3DA:BYTE
EXTRN	?HiddenVolumeStartUnitNo@@3TUINT64_STRUCT@@A:QWORD
EXTRN	?HiddenVolumeStartSector@@3TUINT64_STRUCT@@A:QWORD
EXTRN	?SectorBuffer@@3QAEA:BYTE
EXTRN	?BootSectorFlags@@3EA:BYTE
EXTRN	?BootLoaderDrive@@3EA:BYTE
EXTRN	?BootDrive@@3EA:BYTE
EXTRN	?BootDriveGeometryValid@@3DA:BYTE
EXTRN	?BootDriveGeometry@@3UDriveGeometry@@A:DWORD
EXTRN	?PreventNormalSystemBoot@@3DA:BYTE
EXTRN	?PreventBootMenu@@3DA:BYTE
EXTRN	?CustomUserMessage@@3QADA:BYTE
EXTRN	?OuterVolumeBackupHeaderCrc@@3KA:DWORD
EXTRN	?BootStarted@@3DA:BYTE
_DATA      SEGMENT
??_C@_0BP@OLOK@?5GostCrypt?5Boot?5Loader?51?43?41?$AN?6?$AA@	DB	' GostCrypt Boot Loader 1.3.1',  0dH,  0aH,  00H
	ORG	$-31
??_C@_0BJ@CIJ@?5?5?5?5Keyboard?5Controls?3?$AN?6?$AA@	DB	'    Keyboard Controls:',  0dH,  0aH,  00H
	ORG	$-25
??_C@_0M@NCBA@?5?5?5?5?$FLEsc?$FN?5?5?$AA@	DB	'    [Esc]  ',  00H
	ORG	$-12
??_C@_0CG@HLF@Boot?5Non?9Hidden?5System?5?$CIBoot?5Man@	DB	'Boot Non-Hidden System (Boot Manager)',  00H
	ORG	$-38
??_C@_0CD@GJAD@Skip?5Authentication?5?$CIBoot?5Manage@	DB	'Skip Authentication (Boot Manager)',  00H
	ORG	$-35
??_C@_09LGPG@?$DP?5?$CIy?1n?$CJ?3?5?$AA@	DB	'? (y/n): ',  00H
	ORG	$-10
??_C@_03NMHE@y?$AN?6?$AA@	DB	'y',  0dH,  0aH,  00H
	ORG	$-4
??_C@_03EDHP@n?$AN?6?$AA@	DB	'n',  0dH,  0aH,  00H
	ORG	$-4
??_C@_01KHLB@?$FL?$AA@	DB	'[',  00H
	ORG	$-2
??_C@_05EFLO@?$FN?5?5?5?5?$AA@	DB	']    ',  00H
	ORG	$-6
??_C@_0BC@DHAO@?$FLEsc?$FN?5?5Cancel?$AN?6?$AN?6?$AA@	DB	'[Esc]  Cancel',  0dH,  0aH,  0dH,  0aH,  00H
	ORG	$-18
??_C@_0P@EOMF@Enter?5password?$AA@	DB	'Enter password',  00H
	ORG	$-15
??_C@_0BG@GEFN@?5for?5hidden?5system?3?$AN?6?$AA@	DB	' for hidden system:',  0dH,  0aH,  00H
	ORG	$-22
??_C@_02HFBK@?3?5?$AA@	DB	': ',  00H
	ORG	$-3
??_C@_0N@DGHN@Booting?4?4?4?$AN?6?$AA@	DB	'Booting...',  0dH,  0aH,  00H
	ORG	$-13
??_C@_0CA@FBFB@BIOS?5reserved?5too?5much?5memory?3?5?$AA@	DB	'BIOS reserved too much memory: ',  00H
	ORG	$-32
??_C@_0DM@HBD@?9?5Upgrade?5BIOS?$AN?6?9?5Use?5a?5differen@	DB	'- Upgrade BIOS',  0dH,  0aH, '- Use a different motherboard '
	DB	'model/brand',  0dH,  0aH,  00H
	ORG	$-60
??_C@_0BM@NMNK@Warning?3?5Caps?5Lock?5is?5on?4?$AN?6?$AA@	DB	'Warning: Caps Lock is on.',  0dH,  0aH,  00H
	ORG	$-28
??_C@_0BI@KFOG@Incorrect?5password?4?$AN?6?$AN?6?$AA@	DB	'Incorrect password.',  0dH,  0aH,  0dH,  0aH,  00H
	ORG	$-24
??_C@_0JN@DAOA@If?5you?5are?5sure?5the?5password?5is?5@	DB	'If you are sure the password is correct, the key data may be'
	DB	' damaged. Boot your',  0dH,  0aH, 'GostCrypt Rescue Disk and'
	DB	' select ''Repair Options'' > ''Restore key data''.',  0dH,  0aH
	DB	0dH,  0aH,  00H
	ORG	$-157
??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@	DB	'No bootable partition found',  00H
	ORG	$-28
??_C@_0BH@CKJE@Bootable?5Partitions?3?$AN?6?$AA@	DB	'Bootable Partitions:',  0dH,  0aH,  00H
	ORG	$-23
??_C@_02PIMC@?$AN?6?$AA@	DB	0dH,  0aH,  00H
	ORG	$-3
??_C@_07MCKD@Drive?3?5?$AA@	DB	'Drive: ',  00H
	ORG	$-8
??_C@_0O@LEMN@?0?5Partition?3?5?$AA@	DB	', Partition: ',  00H
	ORG	$-14
??_C@_08PFEJ@?0?5Size?3?5?$AA@	DB	', Size: ',  00H
	ORG	$-9
??_C@_0CA@HAB@Press?51?99?5to?5select?5partition?3?5?$AA@	DB	'Press 1-9 to select partition: ',  00H
	ORG	$-32
??_C@_0CI@CHP@Your?5BIOS?5does?5not?5support?5large@	DB	'Your BIOS does not support large drives',  00H
	ORG	$-40
??_C@_0O@PLFN@?5due?5to?5a?5bug?$AA@	DB	' due to a bug',  00H
	ORG	$-14
??_C@_0BH@EGEK@?$AN?6?9?5Enable?5LBA?5in?5BIOS?$AA@	DB	0dH,  0aH, '- Enable LBA in BIOS',  00H
	ORG	$-23
??_C@_0DM@NDEP@?$AN?6Copying?5system?5to?5hidden?5volum@	DB	0dH,  0aH, 'Copying system to hidden volume. To abort, press'
	DB	' Esc.',  0dH,  0aH,  0dH,  0aH,  00H
	ORG	$-60
??_C@_0FD@OPN@?$ANIf?5aborted?0?5copying?5will?5have?5t@	DB	0dH, 'If aborted, copying will have to start from the beginn'
	DB	'ing (if attempted again).',  0dH,  0aH,  00H
	ORG	$-83
??_C@_05DILO@Abort?$AA@	DB	'Abort',  00H
	ORG	$-6
??_C@_0FB@DHKC@To?5fix?5bad?5sectors?3?51?$CJ?5Terminate@	DB	'To fix bad sectors: 1) Terminate 2) Encrypt and decrypt sys '
	DB	'partition 3) Retry',  0dH,  0aH,  00H
	ORG	$-81
??_C@_0N@BNAP@?$ANRemaining?3?5?$AA@	DB	0dH, 'Remaining: ',  00H
	ORG	$-13
??_C@_0BE@KCNB@?$ANCopying?5completed?4?$AA@	DB	0dH, 'Copying completed.',  00H
_DATA      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT

?InitScreen@@YAXXZ	PROC NEAR	; InitScreen COMDAT
;|*** /**
;|***  *
;|***  *	\file BootMain.cpp
;|***  *	\brief Graphical interface and main boot functions
;|***  *	\version 1.3.1
;|***  *	\date 13/12/2016
;|***  *
;|***  */
;|*** 
;|*** /**
;|***  *	
;|***  *	Copyright (c) 2008-2011 TrueCrypt Developers Association. All rights reserved.
;|***  *	
;|***  *	Governed by the TrueCrypt License 3.0 the full text of which is contained in
;|***  *	the file License.txt included in TrueCrypt binary and source code distribution
;|***  *	packages.
;|***  *	
;|***  */
;|*** 
;|*** #include "Crc.h"
;|*** #include "Crypto.h"
;|*** #include "Password.h"
;|*** #include "Volumes.h"
;|*** 
;|*** #include "Platform.h"
;|*** #include "Bios.h"
;|*** #include "BootConfig.h"
;|*** #include "BootMain.h"
;|*** #include "BootDefs.h"
;|*** #include "BootCommon.h"
;|*** #include "BootConsoleIo.h"
;|*** #include "BootDebug.h"
;|*** #include "BootDiskIo.h"
;|*** #include "BootEncryptedIo.h"
;|*** #include "BootMemory.h"
;|*** #include "BootStrings.h"
;|*** #include "IntFilter.h"
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void InitScreen ()
;|***  *	\brief Clear the screen, print title and print a delimitation bar
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void InitScreen ()
;|*** {
; Line 47
;	title = -2
;|*** 	ClearScreen();
; Line 48
	*** 000000	e8 00 00 		call	?ClearScreen@@YAXXZ	; ClearScreen
;|*** 
;|*** 	const char *title =
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 		" GostCrypt Boot Loader "
;|*** #else
;|*** 		" GostCrypt Rescue Disk "
;|*** #endif
;|*** 		VERSION_STRING "\r\n";
;|*** 
;|*** 	Print (title);
; Line 58
	*** 000003	68 00 00 		push	OFFSET DGROUP:??_C@_0BP@OLOK@?5GostCrypt?5Boot?5Loader?51?43?41?$AN?6?$AA@
	*** 000006	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000009	5b 			pop	bx
;|*** 
;|*** 	PrintRepeatedChar ('\xDC', GST_BIOS_MAX_CHARS_PER_LINE);
; Line 60
	*** 00000a	6a 50 			push	80	;0050H
	*** 00000c	6a dc 			push	-36	;ffdcH
	*** 00000e	e8 00 00 		call	?PrintRepeatedChar@@YAXDH@Z	; PrintRepeatedChar
	*** 000011	83 c4 04 		add	sp,4
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 	if (CustomUserMessage[0])
; Line 63
	*** 000014	80 3e 00 00 00 		cmp	BYTE PTR ?CustomUserMessage@@3QADA,0	;CustomUserMessage
	*** 000019	74 0a 			je	SHORT $I1453
;|*** 	{
;|*** 		PrintEndl();
; Line 65
	*** 00001b	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 		Print (CustomUserMessage);
; Line 66
	*** 00001e	68 00 00 		push	OFFSET ?CustomUserMessage@@3QADA	;CustomUserMessage
	*** 000021	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000024	5b 			pop	bx
;|*** 	}
;|*** #endif
;|*** 
;|*** 	PrintEndl (2);
; Line 70
					$I1453:
	*** 000025	6a 02 			push	2
	*** 000027	e8 00 00 		call	?PrintEndl@@YAXH@Z	; PrintEndl
	*** 00002a	5b 			pop	bx
;|*** }
; Line 71
	*** 00002b	c3 			ret	

?InitScreen@@YAXXZ	ENDP

?PrintMainMenu@@YAXXZ	PROC NEAR	; PrintMainMenu COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void PrintMainMenu ()
;|***  *	\brief Print the main menu (Boot manager and repair options)
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void PrintMainMenu ()
;|*** {
;|*** 	if (PreventBootMenu)
; Line 83
	*** 000000	80 3e 00 00 00 		cmp	BYTE PTR ?PreventBootMenu@@3DA,0	;PreventBootMenu
	*** 000005	75 28 			jne	SHORT $EX1455
;|*** 		return;
;|*** 
;|*** 	Print ("    Keyboard Controls:\r\n");
; Line 86
	*** 000007	68 00 00 		push	OFFSET DGROUP:??_C@_0BJ@CIJ@?5?5?5?5Keyboard?5Controls?3?$AN?6?$AA@
	*** 00000a	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00000d	5b 			pop	bx
;|*** 	Print ("    [Esc]  ");
; Line 87
	*** 00000e	68 00 00 		push	OFFSET DGROUP:??_C@_0M@NCBA@?5?5?5?5?$FLEsc?$FN?5?5?$AA@
	*** 000011	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000014	5b 			pop	bx
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 	Print ((BootSectorFlags & GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE) != GST_HIDDEN_OS_CREATION_PHASE_NONE
;|*** 		? "Boot Non-Hidden System (Boot Manager)"
;|*** 		: "Skip Authentication (Boot Manager)");
; Line 93
	*** 000015	f6 06 00 00 c0 		test	BYTE PTR ?BootSectorFlags@@3EA,192	;00c0H	;BootSectorFlags
	*** 00001a	74 05 			je	SHORT $L1767
	*** 00001c	b8 00 00 		mov	ax,OFFSET DGROUP:??_C@_0CG@HLF@Boot?5Non?9Hidden?5System?5?$CIBoot?5Man@
	*** 00001f	eb 03 			jmp	SHORT $L1768
					$L1767:
	*** 000021	b8 00 00 		mov	ax,OFFSET DGROUP:??_C@_0CD@GJAD@Skip?5Authentication?5?$CIBoot?5Manage@
					$L1768:
	*** 000024	50 			push	ax
	*** 000025	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000028	5b 			pop	bx
;|*** 	
;|*** #else // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 	Print ("Skip Authentication (Boot Manager)");
;|*** 	Print ("\r\n    [F8]   "); Print ("Repair Options");
;|*** 
;|*** #endif // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 	PrintEndl (3);
; Line 102
	*** 000029	6a 03 			push	3
	*** 00002b	e8 00 00 		call	?PrintEndl@@YAXH@Z	; PrintEndl
	*** 00002e	5b 			pop	bx
;|*** }
; Line 103
					$EX1455:
	*** 00002f	c3 			ret	

?PrintMainMenu@@YAXXZ	ENDP

?IsMenuKey@@YADE@Z	PROC NEAR	; IsMenuKey COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool IsMenuKey (byte scanCode)
;|***  *	\brief Check if it is a menu key (F8)
;|***  *	\param[in] byte scanCode
;|***  *	\return static bool scanCode == GST_MENU_KEY_REPAIR
;|***  *			false if !GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|***  *
;|***  */
;|*** static bool IsMenuKey (byte scanCode)
;|*** {
; Line 116
;	scanCode = 4
;|*** #ifdef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 	return scanCode == GST_MENU_KEY_REPAIR;
;|*** #else
;|*** 	return false;
; Line 120
	*** 000000	32 c0 			xor	al,al
;|*** #endif
;|*** }
; Line 122
	*** 000002	c3 			ret	

?IsMenuKey@@YADE@Z	ENDP

?AskYesNo@@YADPBD@Z	PROC NEAR	; AskYesNo COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool AskYesNo (const char *message)
;|***  *	\brief Ask yes or no to user
;|***  *	\param[in] const char * message
;|***  *	\return static bool true if 'yes' is entered
;|***  *			false if 'no'
;|***  *
;|***  */
;|*** static bool AskYesNo (const char *message)
;|*** {
; Line 135
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	message = 4
;|*** 	Print (message);
; Line 136
	*** 000003	ff 76 04 		push	WORD PTR [bp+4]	;message
	*** 000006	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000009	5b 			pop	bx
;|*** 	Print ("? (y/n): ");
; Line 137
	*** 00000a	68 00 00 		push	OFFSET DGROUP:??_C@_09LGPG@?$DP?5?$CIy?1n?$CJ?3?5?$AA@
	*** 00000d	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000010	5b 			pop	bx
;|*** 	while (true)
; Line 138
	*** 000011	eb 1a 			jmp	SHORT $L1808
					$FC1467:
;|*** 	{
;|*** 		switch (GetKeyboardChar())
; Line 140
	*** 000013	2d 0b 00 		sub	ax,11	;000bH
	*** 000016	7c 12 			jl	SHORT $SD1477
	*** 000018	70 10 			jo	SHORT $SD1477
	*** 00001a	48 			dec	ax
	*** 00001b	7e 25 			jle	SHORT $SC1473
	*** 00001d	2d 14 00 		sub	ax,20	;0014H
	*** 000020	74 15 			je	SHORT $SC1475
	*** 000022	2d 0b 00 		sub	ax,11	;000bH
	*** 000025	7c 03 			jl	SHORT $SD1477
	*** 000027	48 			dec	ax
	*** 000028	7e 18 			jle	SHORT $SC1473
;|*** 		{
;|*** 		case 'y':
;|*** 		case 'Y':
;|*** 		case 'z':
;|*** 		case 'Z':
;|*** 			Print ("y\r\n");
;|*** 			return true;
;|*** 
;|*** 		case 'n':
;|*** 		case 'N':
;|*** 			Print ("n\r\n");
;|*** 			return false;
;|*** 
;|*** 		default:
; Line 154
					$SD1477:
;|*** 			Beep();
; Line 155
	*** 00002a	e8 00 00 		call	?Beep@@YAXXZ	; Beep
;|*** 		}
; Line 156
					$L1808:
	*** 00002d	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
	*** 000030	2a e4 			sub	ah,ah
	*** 000032	2d 4e 00 		sub	ax,78	;004eH
	*** 000035	75 dc 			jne	SHORT $FC1467
;|*** 		case 'n':
; Line 149
					$SC1475:
;|*** 		case 'N':
;|*** 			Print ("n\r\n");
; Line 151
	*** 000037	68 00 00 		push	OFFSET DGROUP:??_C@_03EDHP@n?$AN?6?$AA@
	*** 00003a	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00003d	5b 			pop	bx
;|*** 			return false;
; Line 152
	*** 00003e	32 c0 			xor	al,al
	*** 000040	c9 			leave	
	*** 000041	c3 			ret	
;|*** 		case 'y':
; Line 142
					$SC1473:
;|*** 		case 'Y':
;|*** 		case 'z':
;|*** 		case 'Z':
;|*** 			Print ("y\r\n");
; Line 146
	*** 000042	68 00 00 		push	OFFSET DGROUP:??_C@_03NMHE@y?$AN?6?$AA@
	*** 000045	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000048	5b 			pop	bx
;|*** 			return true;
; Line 147
	*** 000049	b0 01 			mov	al,1
;|*** 
;|*** 		case 'n':
;|*** 		case 'N':
;|*** 			Print ("n\r\n");
;|*** 			return false;
;|*** 
;|*** 		default:
;|*** 			Beep();
;|*** 		}
;|*** 	}
;|*** }
; Line 158
	*** 00004b	c9 			leave	
	*** 00004c	c3 			ret	

?AskYesNo@@YADPBD@Z	ENDP

?AskPassword@@YAEAAUPassword@@@Z	PROC NEAR	; AskPassword COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static int AskSelection (const char *options[], size_t optionCount)
;|***  *	\brief Print options and wait for selection
;|***  *	\param[in] size_t optionCount
;|***  *	\param[in] const char * options[]
;|***  *	\return static int 0 if (GetString (&str, 1) == 0)
;|***  *			(str - '0') else
;|***  *
;|***  */
;|*** static int AskSelection (const char *options[], size_t optionCount)
;|*** {
;|*** 	for (int i = 0; i < optionCount; ++i)
;|*** 	{
;|*** 		Print ("["); Print (i + 1); Print ("]    ");
;|*** 		Print (options[i]);
;|*** 		PrintEndl();
;|*** 	}
;|*** 	Print ("[Esc]  Cancel\r\n\r\n");
;|*** 
;|*** 	Print ("To select, press 1-9: ");
;|*** 
;|*** 	char str;
;|*** 
;|*** 	while (true)
;|*** 	{
;|*** 		if (GetString (&str, 1) == 0)
;|*** 			return 0;
;|*** 
;|*** 		if (str >= '1' && str <= optionCount + '0')
;|*** 			return str - '0';
;|*** 
;|*** 		Beep();
;|*** 		PrintBackspace();
;|*** 	}
;|*** }
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static byte AskPassword (Password &password)
;|***  *	\brief Ask password to user
;|***  *	\param[in] Password & password
;|***  *	\return static byte
;|***  *
;|***  */
;|*** static byte AskPassword (Password &password)
;|*** {
; Line 208
	*** 000000	c8 02 00 00 		enter	2,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	password = 4
;	register si = pos
;	scanCode = -2
;	asciiCode = -1
;|*** 	size_t pos = 0;
; Line 209
	*** 000006	33 f6 			xor	si,si
;|*** 	byte scanCode;
;|*** 	byte asciiCode;
;|*** 
;|*** 	Print ("Enter password");
; Line 213
	*** 000008	68 00 00 		push	OFFSET DGROUP:??_C@_0P@EOMF@Enter?5password?$AA@
	*** 00000b	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00000e	5b 			pop	bx
;|*** 	Print (PreventNormalSystemBoot ? " for hidden system:\r\n" : ": ");
; Line 214
	*** 00000f	80 3e 00 00 00 		cmp	BYTE PTR ?PreventNormalSystemBoot@@3DA,0	;PreventNormalSystemBoot
	*** 000014	74 05 			je	SHORT $L1771
	*** 000016	b8 00 00 		mov	ax,OFFSET DGROUP:??_C@_0BG@GEFN@?5for?5hidden?5system?3?$AN?6?$AA@
	*** 000019	eb 03 			jmp	SHORT $L1772
					$L1771:
	*** 00001b	b8 00 00 		mov	ax,OFFSET DGROUP:??_C@_02HFBK@?3?5?$AA@
					$L1772:
	*** 00001e	50 			push	ax
	*** 00001f	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000022	5b 			pop	bx
	*** 000023	8b 7e 04 		mov	di,WORD PTR [bp+4]	;password
;|*** 
;|*** 	while (true)
; Line 216
	*** 000026	eb 4c 			jmp	SHORT $L1810
					$FC1504:
;|*** 	{
;|*** 		asciiCode = GetKeyboardChar (&scanCode);
; Line 218
	*** 000028	2d 0e 00 		sub	ax,14	;000eH
	*** 00002b	0f 84 85 00 		je	$SC1510
;|*** 
;|*** 		switch (scanCode)
;|*** 		{
;|*** 		case GST_BIOS_KEY_ENTER:
;|*** 			ClearBiosKeystrokeBuffer();
;|*** 			PrintEndl();
;|*** 
;|*** 			password.Length = pos;
;|*** 			return scanCode;
;|*** 
;|*** 		case GST_BIOS_KEY_BACKSPACE:
;|*** 			if (pos > 0)
;|*** 			{
;|*** 				if (pos < MAX_PASSWORD)
;|*** 					PrintBackspace();
;|*** 				else
;|*** 					PrintCharAtCursor (' ');
;|*** 
;|*** 				--pos;
;|*** 			}
;|*** 			continue;
;|*** 
;|*** 		default:
;|*** 			if (scanCode == GST_BIOS_KEY_ESC || IsMenuKey (scanCode))
; Line 242
	*** 00002f	80 7e fe 01 		cmp	BYTE PTR [bp-2],1	;scanCode
	*** 000033	74 6b 			je	SHORT $I1517
	*** 000035	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;scanCode
	*** 000038	50 			push	ax
	*** 000039	e8 00 00 		call	?IsMenuKey@@YADE@Z	; IsMenuKey
	*** 00003c	5b 			pop	bx
	*** 00003d	0a c0 			or	al,al
	*** 00003f	75 5f 			jne	SHORT $I1517
;|*** 			{
;|*** 				burn (password.Text, sizeof (password.Text));
;|*** 				ClearBiosKeystrokeBuffer();
;|*** 
;|*** 				PrintEndl();
;|*** 				return scanCode;
;|*** 			}
;|*** 		}
;|*** 
;|*** 		if (!IsPrintable (asciiCode) || pos == MAX_PASSWORD)
; Line 252
	*** 000041	8a 46 ff 		mov	al,BYTE PTR [bp-1]	;asciiCode
	*** 000044	50 			push	ax
	*** 000045	e8 00 00 		call	?IsPrintable@@YADD@Z	; IsPrintable
	*** 000048	5b 			pop	bx
	*** 000049	0a c0 			or	al,al
	*** 00004b	74 24 			je	SHORT $I1519
	*** 00004d	83 fe 40 		cmp	si,64	;0040H
	*** 000050	74 1f 			je	SHORT $I1519
;|*** 		{
;|*** 			Beep();
;|*** 			continue;
;|*** 		}
;|*** 
;|*** 		password.Text[pos++] = asciiCode;
; Line 258
	*** 000052	8a 46 ff 		mov	al,BYTE PTR [bp-1]	;asciiCode
	*** 000055	8b de 			mov	bx,si
	*** 000057	03 df 			add	bx,di
	*** 000059	46 			inc	si
	*** 00005a	88 47 04 		mov	BYTE PTR [bx+4],al
;|*** 		if (pos < MAX_PASSWORD)
; Line 259
	*** 00005d	83 fe 40 		cmp	si,64	;0040H
	*** 000060	73 08 			jae	SHORT $I1520
;|*** 			PrintChar ('*');
; Line 260
	*** 000062	6a 2a 			push	42	;002aH
	*** 000064	e8 00 00 		call	?PrintChar@@YAXD@Z	; PrintChar
					$L1809:
	*** 000067	5b 			pop	bx
;|*** 		else
; Line 261
	*** 000068	eb 0a 			jmp	SHORT $L1810
					$I1520:
;|*** 			PrintCharAtCursor ('*');
; Line 262
	*** 00006a	6a 2a 			push	42	;002aH
	*** 00006c	e8 00 00 		call	?PrintCharAtCursor@@YAXD@Z	; PrintCharAtCursor
	*** 00006f	eb f6 			jmp	SHORT $L1809
;|*** 		if (!IsPrintable (asciiCode) || pos == MAX_PASSWORD)
; Line 252
					$I1519:
;|*** 		{
;|*** 			Beep();
; Line 254
	*** 000071	e8 00 00 		call	?Beep@@YAXXZ	; Beep
;|*** 			continue;
; Line 255
					$L1810:
	*** 000074	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;scanCode
	*** 000077	50 			push	ax
	*** 000078	e8 00 00 		call	?GetKeyboardChar@@YAEPAE@Z	; GetKeyboardChar
	*** 00007b	5b 			pop	bx
	*** 00007c	88 46 ff 		mov	BYTE PTR [bp-1],al	;asciiCode
;|*** 		switch (scanCode)
; Line 220
	*** 00007f	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;scanCode
	*** 000082	2a e4 			sub	ah,ah
;|*** 		{
;|*** 		case GST_BIOS_KEY_ENTER:
;|*** 			ClearBiosKeystrokeBuffer();
;|*** 			PrintEndl();
;|*** 
;|*** 			password.Length = pos;
;|*** 			return scanCode;
;|*** 
;|*** 		case GST_BIOS_KEY_BACKSPACE:
;|*** 			if (pos > 0)
;|*** 			{
;|*** 				if (pos < MAX_PASSWORD)
;|*** 					PrintBackspace();
;|*** 				else
;|*** 					PrintCharAtCursor (' ');
;|*** 
;|*** 				--pos;
;|*** 			}
;|*** 			continue;
;|*** 
;|*** 		default:
;|*** 			if (scanCode == GST_BIOS_KEY_ESC || IsMenuKey (scanCode))
;|*** 			{
;|*** 				burn (password.Text, sizeof (password.Text));
;|*** 				ClearBiosKeystrokeBuffer();
;|*** 
;|*** 				PrintEndl();
;|*** 				return scanCode;
;|*** 			}
;|*** 		}
; Line 250
	*** 000084	2d 0e 00 		sub	ax,14	;000eH
	*** 000087	75 9f 			jne	SHORT $FC1504
;|*** 			if (pos > 0)
; Line 230
	*** 000089	0b f6 			or	si,si
	*** 00008b	74 e7 			je	SHORT $L1810
;|*** 			{
;|*** 				if (pos < MAX_PASSWORD)
; Line 232
	*** 00008d	83 fe 40 		cmp	si,64	;0040H
	*** 000090	73 05 			jae	SHORT $I1513
;|*** 					PrintBackspace();
; Line 233
	*** 000092	e8 00 00 		call	?PrintBackspace@@YAXXZ	; PrintBackspace
;|*** 				else
; Line 234
	*** 000095	eb 06 			jmp	SHORT $I1514
					$I1513:
;|*** 					PrintCharAtCursor (' ');
; Line 235
	*** 000097	6a 20 			push	32	;0020H
	*** 000099	e8 00 00 		call	?PrintCharAtCursor@@YAXD@Z	; PrintCharAtCursor
	*** 00009c	5b 			pop	bx
					$I1514:
;|*** 
;|*** 				--pos;
; Line 237
	*** 00009d	4e 			dec	si
;|*** 			}
;|*** 			continue;
; Line 239
	*** 00009e	eb d4 			jmp	SHORT $L1810
;|*** 
;|*** 		default:
;|*** 			if (scanCode == GST_BIOS_KEY_ESC || IsMenuKey (scanCode))
; Line 242
					$I1517:
;|*** 			{
;|*** 				burn (password.Text, sizeof (password.Text));
; Line 244
	*** 0000a0	6a 41 			push	65	;0041H
	*** 0000a2	8d 45 04 		lea	ax,WORD PTR [di+4]
	*** 0000a5	50 			push	ax
	*** 0000a6	e8 00 00 		call	_EraseMemory
	*** 0000a9	83 c4 04 		add	sp,4
;|*** 				ClearBiosKeystrokeBuffer();
; Line 245
	*** 0000ac	e8 00 00 		call	?ClearBiosKeystrokeBuffer@@YAXXZ	; ClearBiosKeystrokeBuffer
;|*** 
;|*** 				PrintEndl();
; Line 247
	*** 0000af	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
	*** 0000b2	eb 0d 			jmp	SHORT $L1811
;|*** 		case GST_BIOS_KEY_ENTER:
; Line 222
					$SC1510:
;|*** 			ClearBiosKeystrokeBuffer();
; Line 223
	*** 0000b4	e8 00 00 		call	?ClearBiosKeystrokeBuffer@@YAXXZ	; ClearBiosKeystrokeBuffer
;|*** 			PrintEndl();
; Line 224
	*** 0000b7	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 
;|*** 			password.Length = pos;
; Line 226
	*** 0000ba	89 35 			mov	WORD PTR [di],si
	*** 0000bc	c7 45 02 00 00 		mov	WORD PTR [di+2],0
;|*** 			return scanCode;
; Line 227
					$L1811:
	*** 0000c1	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;scanCode
;|*** 
;|*** 		case GST_BIOS_KEY_BACKSPACE:
;|*** 			if (pos > 0)
;|*** 			{
;|*** 				if (pos < MAX_PASSWORD)
;|*** 					PrintBackspace();
;|*** 				else
;|*** 					PrintCharAtCursor (' ');
;|*** 
;|*** 				--pos;
;|*** 			}
;|*** 			continue;
;|*** 
;|*** 		default:
;|*** 			if (scanCode == GST_BIOS_KEY_ESC || IsMenuKey (scanCode))
;|*** 			{
;|*** 				burn (password.Text, sizeof (password.Text));
;|*** 				ClearBiosKeystrokeBuffer();
;|*** 
;|*** 				PrintEndl();
;|*** 				return scanCode;
;|*** 			}
;|*** 		}
;|*** 
;|*** 		if (!IsPrintable (asciiCode) || pos == MAX_PASSWORD)
;|*** 		{
;|*** 			Beep();
;|*** 			continue;
;|*** 		}
;|*** 
;|*** 		password.Text[pos++] = asciiCode;
;|*** 		if (pos < MAX_PASSWORD)
;|*** 			PrintChar ('*');
;|*** 		else
;|*** 			PrintCharAtCursor ('*');
;|*** 	}
;|*** }
; Line 264
	*** 0000c4	5e 			pop	si
	*** 0000c5	5f 			pop	di
	*** 0000c6	c9 			leave	
	*** 0000c7	c3 			ret	

?AskPassword@@YAEAAUPassword@@@Z	ENDP

?ExecuteBootSector@@YAXEPAE@Z	PROC NEAR	; ExecuteBootSector COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void ExecuteBootSector (byte drive, byte *sectorBuffer)
;|***  *	\brief Execute the boot sector (MBR)
;|***  *	\param[in] byte * sectorBuffer
;|***  *	\param[in] byte drive
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void ExecuteBootSector (byte drive, byte *sectorBuffer)
;|*** {
; Line 277
	*** 000000	c8 04 00 00 		enter	4,0
	*** 000004	56 			push	si
;	addr = -4
;	sectorBuffer = 6
;	drive = 4
;|*** 	Print ("Booting...\r\n");
; Line 278
	*** 000005	68 00 00 		push	OFFSET DGROUP:??_C@_0N@DGHN@Booting?4?4?4?$AN?6?$AA@
	*** 000008	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00000b	5b 			pop	bx
;|*** 	CopyMemory (sectorBuffer, 0x0000, 0x7c00, GST_LB_SIZE);
; Line 279
	*** 00000c	66 68 00 7c 00 02 	push	DWORD PTR 33586176	;02007c00H
	*** 000012	6a 00 			push	0
	*** 000014	ff 76 06 		push	WORD PTR [bp+6]	;sectorBuffer
	*** 000017	e8 00 00 		call	?CopyMemory@@YAXPAXIII@Z	; CopyMemory
	*** 00001a	83 c4 08 		add	sp,8
;|*** 
;|*** 	BootStarted = true;
; Line 281
	*** 00001d	c6 06 00 00 01 		mov	BYTE PTR ?BootStarted@@3DA,1	;BootStarted
;|*** 
;|*** 	uint32 addr = 0x7c00;
; Line 283
	*** 000022	66 c7 46 fc 00 7c 00 00 mov	DWORD PTR [bp-4],31744	;00007c00H	;addr
;|*** 	__asm
;|*** 	{
;|*** 		cli
; Line 286
	*** 00002a	fa 			cli	
;|*** 		mov dl, drive	// Boot drive
; Line 287
	*** 00002b	8a 56 04 		mov	dl,BYTE PTR [bp+4]	;drive
;|*** 		mov dh, 0
; Line 288
	*** 00002e	b6 00 			mov	dh,0
;|*** 		xor ax, ax
; Line 289
	*** 000030	33 c0 			xor	ax,ax
;|*** 		mov si, ax
; Line 290
	*** 000032	8b f0 			mov	si,ax
;|*** 		mov ds, ax
; Line 291
	*** 000034	8e d8 			mov	ds,ax
;|*** 		mov es, ax
; Line 292
	*** 000036	8e c0 			mov	es,ax
;|*** 		mov ss, ax
; Line 293
	*** 000038	8e d0 			mov	ss,ax
;|*** 		mov sp, 0x7c00
; Line 294
	*** 00003a	bc 00 7c 		mov	sp,31744	;7c00H
;|*** 		sti
; Line 295
	*** 00003d	fb 			sti	
;|*** 
;|*** 		jmp cs:addr
; Line 297
	*** 00003e	2e ff 6e fc 		jmp	DWORD PTR cs:[bp-4]	;addr
;|*** 	}
; Line 298
;|*** }
; Line 299
	*** 000042	5e 			pop	si
	*** 000043	c9 			leave	
	*** 000044	c3 			ret	

?ExecuteBootSector@@YAXEPAE@Z	ENDP

?OpenVolume@@YADEAAUPassword@@PAPAUCRYPTO_INFO_t@@PAKDD@Z	PROC NEAR	; OpenVolume COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool OpenVolume (byte drive, Password &password, CRYPTO_INFO **cryptoInfo, uint32 *headerSaltCrc32, bool skipNormal, bool skipHidden)
;|***  *	\brief Open a Volume
;|***  *	\param[in] bool skipHidden
;|***  *	\param[in] bool skipNormal
;|***  *	\param[in] uint32 * headerSaltCrc32
;|***  *	\param[in] CRYPTO_INFO ** cryptoInfo
;|***  *	\param[in] Password & password
;|***  *	\param[in] byte drive
;|***  *	\return static bool (volumeType != 3)
;|***  *
;|***  */
;|*** static bool OpenVolume (byte drive, Password &password, CRYPTO_INFO **cryptoInfo, uint32 *headerSaltCrc32, bool skipNormal, bool skipHidden)
;|*** {
; Line 315
	*** 000000	c8 14 00 00 		enter	20,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	headerSec = -12
;	drive = 4
;	password = 6
;	cryptoInfo = 8
;	headerSaltCrc32 = 10
;	skipNormal = 12
;	skipHidden = 14
;	volumeType = -4
;	hiddenVolume = -1
;|*** 	int volumeType;
;|*** 	bool hiddenVolume;
;|*** 	uint64 headerSec;
;|*** 
;|*** 	AcquireSectorBuffer();
;|*** 
;|*** 	for (volumeType = 1; volumeType <= 2; ++volumeType)
; Line 322
	*** 000006	c7 46 fc 01 00 		mov	WORD PTR [bp-4],1	;volumeType
					$F1537:
	*** 00000b	83 7e fc 02 		cmp	WORD PTR [bp-4],2	;volumeType
	*** 00000f	0f 8f d5 00 		jg	$FB1539
;|*** 	{
;|*** 		hiddenVolume = (volumeType == 2);
;|*** 
;|*** 		if (hiddenVolume)
; Line 326
	*** 000013	75 04 			jne	SHORT $L1775
	*** 000015	b0 01 			mov	al,1
	*** 000017	eb 02 			jmp	SHORT $L1776
					$L1775:
	*** 000019	32 c0 			xor	al,al
					$L1776:
	*** 00001b	88 46 ff 		mov	BYTE PTR [bp-1],al	;hiddenVolume
	*** 00001e	0a c0 			or	al,al
	*** 000020	74 43 			je	SHORT $I1540
;|*** 		{
;|*** 			if (skipHidden || PartitionFollowingActive.Drive != drive || PartitionFollowingActive.SectorCount <= ActivePartition.SectorCount)
; Line 328
	*** 000022	80 7e 0e 00 		cmp	BYTE PTR [bp+14],0	;skipHidden
	*** 000026	0f 85 a0 00 		jne	$FC1538
	*** 00002a	a0 01 00 		mov	al,BYTE PTR ?PartitionFollowingActive@@3UPartition@@A+1	;PartitionFollowingActive
	*** 00002d	38 46 04 		cmp	BYTE PTR [bp+4],al	;drive
	*** 000030	0f 85 96 00 		jne	$FC1538
	*** 000034	68 0e 00 		push	OFFSET ?ActivePartition@@3UPartition@@A+14	;ActivePartition
	*** 000037	68 0e 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A+14	;PartitionFollowingActive
	*** 00003a	e8 00 00 		call	??N@YADABTUINT64_STRUCT@@0@Z	; operator<=
	*** 00003d	83 c4 04 		add	sp,4
	*** 000040	0a c0 			or	al,al
	*** 000042	0f 85 84 00 		jne	$FC1538
;|*** 				continue;
;|*** 
;|*** 			headerSec = PartitionFollowingActive.StartSector + GST_HIDDEN_VOLUME_HEADER_OFFSET / GST_LB_SIZE;
; Line 331
	*** 000046	6a 00 			push	0
	*** 000048	68 80 00 		push	128	;0080H
	*** 00004b	68 16 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A+22	;PartitionFollowingActive
	*** 00004e	8d 46 ec 		lea	ax,WORD PTR [bp-20]
	*** 000051	50 			push	ax
	*** 000052	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator+
	*** 000055	83 c4 08 		add	sp,8
	*** 000058	8d 7e f4 		lea	di,WORD PTR [bp-12]	;headerSec
	*** 00005b	8b f0 			mov	si,ax
	*** 00005d	16 			push	ss
	*** 00005e	07 			pop	es
	*** 00005f	66 a5 			movsd
	*** 000061	66 a5 			movsd
;|*** 		}
;|*** 		else
; Line 333
	*** 000063	eb 15 			jmp	SHORT $I1544
					$I1540:
;|*** 		{
;|*** 			if (skipNormal)
; Line 335
	*** 000065	80 7e 0c 00 		cmp	BYTE PTR [bp+12],0	;skipNormal
	*** 000069	75 5f 			jne	SHORT $FC1538
;|*** 				continue;
;|*** 
;|*** 			headerSec.HighPart = 0;
; Line 338
	*** 00006b	66 2b c0 		sub	eax,eax
	*** 00006e	66 89 46 f8 		mov	DWORD PTR [bp-8],eax
;|*** 			headerSec.LowPart = GST_BOOT_VOLUME_HEADER_SECTOR;
; Line 339
	*** 000072	c7 46 f4 3e 00 		mov	WORD PTR [bp-12],62	;003eH	;headerSec
	*** 000077	89 46 f6 		mov	WORD PTR [bp-10],ax
;|*** 		}
; Line 340
					$I1544:
;|*** 
;|*** 		if (ReadSectors (SectorBuffer, drive, headerSec, 1) != BiosResultSuccess)
; Line 342
	*** 00007a	6a 00 			push	0
	*** 00007c	6a 01 			push	1
	*** 00007e	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;headerSec
	*** 000081	50 			push	ax
	*** 000082	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000085	50 			push	ax
	*** 000086	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000089	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 00008c	83 c4 0a 		add	sp,10	;000aH
	*** 00008f	0a c0 			or	al,al
	*** 000091	75 37 			jne	SHORT $FC1538
;|*** 			continue;
;|*** 
;|*** 		if (ReadVolumeHeader (!hiddenVolume, (char *) SectorBuffer, &password, cryptoInfo, nullptr) == ERR_SUCCESS)
; Line 345
	*** 000093	6a 00 			push	0
	*** 000095	66 ff 76 06 		push	DWORD PTR [bp+6]	;password
	*** 000099	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 00009c	80 7e ff 01 		cmp	BYTE PTR [bp-1],1	;hiddenVolume
	*** 0000a0	1a c0 			sbb	al,al
	*** 0000a2	f6 d8 			neg	al
	*** 0000a4	50 			push	ax
	*** 0000a5	e8 00 00 		call	_ReadVolumeHeader
	*** 0000a8	83 c4 0a 		add	sp,10	;000aH
	*** 0000ab	0b c0 			or	ax,ax
	*** 0000ad	75 1b 			jne	SHORT $FC1538
;|*** 		{
;|*** 			// Prevent opening a non-system hidden volume
;|*** 			if (hiddenVolume && !((*cryptoInfo)->HeaderFlags & GST_HEADER_FLAG_ENCRYPTED_SYSTEM))
; Line 348
	*** 0000af	80 7e ff 00 		cmp	BYTE PTR [bp-1],0	;hiddenVolume
	*** 0000b3	74 1b 			je	SHORT $I1549
	*** 0000b5	8b 5e 08 		mov	bx,WORD PTR [bp+8]	;cryptoInfo
	*** 0000b8	8b 1f 			mov	bx,WORD PTR [bx]
	*** 0000ba	f6 87 5e 04 01 		test	BYTE PTR [bx+1118],1
	*** 0000bf	75 0f 			jne	SHORT $I1549
;|*** 			{
;|*** 				crypto_close (*cryptoInfo);
; Line 350
	*** 0000c1	8b 5e 08 		mov	bx,WORD PTR [bp+8]	;cryptoInfo
	*** 0000c4	ff 37 			push	WORD PTR [bx]
	*** 0000c6	e8 00 00 		call	_crypto_close
	*** 0000c9	5b 			pop	bx
;|*** 	for (volumeType = 1; volumeType <= 2; ++volumeType)
; Line 322
					$FC1538:
	*** 0000ca	ff 46 fc 		inc	WORD PTR [bp-4]	;volumeType
	*** 0000cd	e9 3b ff 		jmp	$F1537
;|*** 	{
;|*** 		hiddenVolume = (volumeType == 2);
;|*** 
;|*** 		if (hiddenVolume)
;|*** 		{
;|*** 			if (skipHidden || PartitionFollowingActive.Drive != drive || PartitionFollowingActive.SectorCount <= ActivePartition.SectorCount)
;|*** 				continue;
;|*** 
;|*** 			headerSec = PartitionFollowingActive.StartSector + GST_HIDDEN_VOLUME_HEADER_OFFSET / GST_LB_SIZE;
;|*** 		}
;|*** 		else
;|*** 		{
;|*** 			if (skipNormal)
;|*** 				continue;
;|*** 
;|*** 			headerSec.HighPart = 0;
;|*** 			headerSec.LowPart = GST_BOOT_VOLUME_HEADER_SECTOR;
;|*** 		}
;|*** 
;|*** 		if (ReadSectors (SectorBuffer, drive, headerSec, 1) != BiosResultSuccess)
;|*** 			continue;
;|*** 
;|*** 		if (ReadVolumeHeader (!hiddenVolume, (char *) SectorBuffer, &password, cryptoInfo, nullptr) == ERR_SUCCESS)
;|*** 		{
;|*** 			// Prevent opening a non-system hidden volume
;|*** 			if (hiddenVolume && !((*cryptoInfo)->HeaderFlags & GST_HEADER_FLAG_ENCRYPTED_SYSTEM))
;|*** 			{
;|*** 				crypto_close (*cryptoInfo);
;|*** 				continue;
;|*** 			}
;|*** 
;|*** 			if (headerSaltCrc32)
; Line 354
					$I1549:
	*** 0000d0	39 46 0a 		cmp	WORD PTR [bp+10],ax	;headerSaltCrc32
	*** 0000d3	74 13 			je	SHORT $FB1539
;|*** 				*headerSaltCrc32 = GetCrc32 (SectorBuffer, PKCS5_SALT_SIZE);
; Line 355
	*** 0000d5	6a 40 			push	64	;0040H
	*** 0000d7	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 0000da	e8 00 00 		call	_GetCrc32
	*** 0000dd	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;headerSaltCrc32
	*** 0000e0	83 c4 04 		add	sp,4
	*** 0000e3	89 07 			mov	WORD PTR [bx],ax
	*** 0000e5	89 57 02 		mov	WORD PTR [bx+2],dx
;|*** 
;|*** 			break;
;|*** 		}
;|*** 	}
; Line 359
					$FB1539:
;|*** 
;|*** 	ReleaseSectorBuffer();
;|*** 	return volumeType != 3;
; Line 362
	*** 0000e8	83 7e fc 03 		cmp	WORD PTR [bp-4],3	;volumeType
	*** 0000ec	74 04 			je	SHORT $L1779
	*** 0000ee	b0 01 			mov	al,1
	*** 0000f0	eb 02 			jmp	SHORT $L1780
					$L1779:
	*** 0000f2	32 c0 			xor	al,al
					$L1780:
;|*** }
; Line 363
	*** 0000f4	5e 			pop	si
	*** 0000f5	5f 			pop	di
	*** 0000f6	c9 			leave	
	*** 0000f7	c3 			ret	

?OpenVolume@@YADEAAUPassword@@PAPAUCRYPTO_INFO_t@@PAKDD@Z	ENDP

?CheckMemoryRequirements@@YADXZ	PROC NEAR	; CheckMemoryRequirements COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool CheckMemoryRequirements ()
;|***  *	\brief Check the memory requirements and print it
;|***  *	\return static bool false if codeSeg == GST_BOOT_LOADER_LOWMEM_SEGMENT
;|***  *			true else
;|***  *
;|***  */
;|*** static bool CheckMemoryRequirements ()
;|*** {
; Line 375
	*** 000000	c8 04 00 00 		enter	4,0
;	codeSeg = -2
;|*** 	uint16 codeSeg;
;|*** 	__asm mov codeSeg, cs
; Line 377
	*** 000004	8c 4e fe 		mov	WORD PTR [bp-2],cs	;codeSeg
;|*** 	if (codeSeg == GST_BOOT_LOADER_LOWMEM_SEGMENT)
; Line 378
	*** 000007	81 7e fe 00 20 		cmp	WORD PTR [bp-2],8192	;2000H	;codeSeg
	*** 00000c	75 2e 			jne	SHORT $I1555
;|*** 	{
; Line 379
;	memFree = -4
;|*** 		PrintErrorNoEndl ("BIOS reserved too much memory: ");
; Line 380
	*** 00000e	68 00 00 		push	OFFSET DGROUP:??_C@_0CA@FBFB@BIOS?5reserved?5too?5much?5memory?3?5?$AA@
	*** 000011	e8 00 00 		call	?PrintErrorNoEndl@@YAXPBD@Z	; PrintErrorNoEndl
	*** 000014	5b 			pop	bx
;|*** 
;|*** 		uint16 memFree;
;|*** 		__asm
;|*** 		{
;|*** 			push es
; Line 385
	*** 000015	06 			push	es
;|*** 			xor ax, ax
; Line 386
	*** 000016	33 c0 			xor	ax,ax
;|*** 			mov es, ax
; Line 387
	*** 000018	8e c0 			mov	es,ax
;|*** 			mov ax, es:[0x413]
; Line 388
	*** 00001a	26 8b 06 13 04 		mov	ax,WORD PTR es:1043
;|*** 			mov memFree, ax
; Line 389
	*** 00001f	89 46 fc 		mov	WORD PTR [bp-4],ax	;memFree
;|*** 			pop es
; Line 390
	*** 000022	07 			pop	es
;|*** 		}
; Line 391
;|*** 
;|*** 		Print (memFree);
; Line 393
	*** 000023	6a 00 			push	0
	*** 000025	ff 76 fc 		push	WORD PTR [bp-4]	;memFree
	*** 000028	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 00002b	83 c4 04 		add	sp,4
;|*** 		PrintEndl();
; Line 394
	*** 00002e	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 		Print (GST_BOOT_STR_UPGRADE_BIOS);
; Line 395
	*** 000031	68 00 00 		push	OFFSET DGROUP:??_C@_0DM@HBD@?9?5Upgrade?5BIOS?$AN?6?9?5Use?5a?5differen@
	*** 000034	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000037	5b 			pop	bx
;|*** 
;|*** 		return false;
; Line 397
	*** 000038	32 c0 			xor	al,al
	*** 00003a	c9 			leave	
	*** 00003b	c3 			ret	
;|*** 	}
;|*** 
;|*** 	return true;
; Line 400
					$I1555:
	*** 00003c	b0 01 			mov	al,1
;|*** }
; Line 401
	*** 00003e	c9 			leave	
	*** 00003f	c3 			ret	

?CheckMemoryRequirements@@YADXZ	ENDP

?MountVolume@@YADEAAEDD@Z	PROC NEAR	; MountVolume COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool MountVolume (byte drive, byte &exitKey, bool skipNormal, bool skipHidden)
;|***  *	\brief Mount a volume and print Errors/Warnings
;|***  *	\param[in] bool skipHidden
;|***  *	\param[in] bool skipNormal
;|***  *	\param[in] byte & exitKey
;|***  *	\param[in] byte drive
;|***  *	\return static bool false if exitKey != GST_BIOS_KEY_ENTER
;|***  *			true else
;|***  *
;|***  */
;|*** static bool MountVolume (byte drive, byte &exitKey, bool skipNormal, bool skipHidden)
;|*** {
; Line 417
	*** 000000	c8 0a 00 00 		enter	10,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	drive = 4
;	exitKey = 6
;	skipNormal = 8
;	skipHidden = 10
;	bootArguments = -2
;	register di = incorrectPasswordCount
;|*** 	BootArguments *bootArguments = (BootArguments *) GST_BOOT_LOADER_ARGS_OFFSET;
;|*** 	int incorrectPasswordCount = 0;
; Line 419
	*** 000006	33 ff 			xor	di,di
;|*** 
;|*** 	EraseMemory (bootArguments, sizeof (*bootArguments));
; Line 421
	*** 000008	6a 76 			push	118	;0076H
	*** 00000a	b8 10 00 		mov	ax,16	;0010H
	*** 00000d	89 46 fe 		mov	WORD PTR [bp-2],ax	;bootArguments
	*** 000010	50 			push	ax
	*** 000011	e8 00 00 		call	_EraseMemory
	*** 000014	83 c4 04 		add	sp,4
	*** 000017	8b 76 06 		mov	si,WORD PTR [bp+6]	;exitKey
;|*** 
;|*** 	// Open volume header
;|*** 	while (true)
; Line 424
	*** 00001a	eb 3f 			jmp	SHORT $L1812
					$FC1569:
;|*** 	{
;|*** 		exitKey = AskPassword (bootArguments->BootPassword);
;|*** 
;|*** 		if (exitKey != GST_BIOS_KEY_ENTER)
;|*** 			return false;
;|*** 
;|*** 		if (OpenVolume (BootDrive, bootArguments->BootPassword, &BootCryptoInfo, &bootArguments->HeaderSaltCrc32, skipNormal, skipHidden))
; Line 431
	*** 00001c	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;skipHidden
	*** 00001f	50 			push	ax
	*** 000020	8a 46 08 		mov	al,BYTE PTR [bp+8]	;skipNormal
	*** 000023	50 			push	ax
	*** 000024	6a 1e 			push	30	;001eH
	*** 000026	68 00 00 		push	OFFSET ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000029	6a 22 			push	34	;0022H
	*** 00002b	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 00002e	50 			push	ax
	*** 00002f	e8 00 00 		call	?OpenVolume@@YADEAAUPassword@@PAPAUCRYPTO_INFO_t@@PAKDD@Z	; OpenVolume
	*** 000032	83 c4 0c 		add	sp,12	;000cH
	*** 000035	0a c0 			or	al,al
	*** 000037	75 33 			jne	SHORT $L1785
;|*** 			break;
;|*** 
;|*** 		if (GetShiftFlags() & GST_BIOS_SHIFTMASK_CAPSLOCK)
; Line 434
	*** 000039	e8 00 00 		call	?GetShiftFlags@@YAEXZ	; GetShiftFlags
	*** 00003c	a8 40 			test	al,64	;0040H
	*** 00003e	74 07 			je	SHORT $I1573
;|*** 			Print ("Warning: Caps Lock is on.\r\n");
; Line 435
	*** 000040	68 00 00 		push	OFFSET DGROUP:??_C@_0BM@NMNK@Warning?3?5Caps?5Lock?5is?5on?4?$AN?6?$AA@
	*** 000043	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000046	5b 			pop	bx
;|*** 
;|*** 		Print ("Incorrect password.\r\n\r\n");
; Line 437
					$I1573:
	*** 000047	68 00 00 		push	OFFSET DGROUP:??_C@_0BI@KFOG@Incorrect?5password?4?$AN?6?$AN?6?$AA@
	*** 00004a	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00004d	5b 			pop	bx
;|*** 
;|*** 		if (++incorrectPasswordCount == 4)
; Line 439
	*** 00004e	47 			inc	di
	*** 00004f	83 ff 04 		cmp	di,4
	*** 000052	75 07 			jne	SHORT $L1812
;|*** 		{
;|*** #ifdef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 			Print ("If you are sure the password is correct, the key data may be damaged.\r\n"
;|*** 				   "If so, use 'Repair Options' > 'Restore key data'.\r\n\r\n");
;|*** #else
;|*** 			Print ("If you are sure the password is correct, the key data may be damaged. Boot your\r\n"
;|*** 				   "GostCrypt Rescue Disk and select 'Repair Options' > 'Restore key data'.\r\n\r\n");
; Line 446
	*** 000054	68 00 00 		push	OFFSET DGROUP:??_C@_0JN@DAOA@If?5you?5are?5sure?5the?5password?5is?5@
	*** 000057	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00005a	5b 			pop	bx
;|*** #endif
;|*** 		}
;|*** 	}
; Line 449
					$L1812:
	*** 00005b	6a 22 			push	34	;0022H
	*** 00005d	e8 00 00 		call	?AskPassword@@YAEAAUPassword@@@Z	; AskPassword
	*** 000060	5b 			pop	bx
	*** 000061	88 04 			mov	BYTE PTR [si],al
;|*** 		if (exitKey != GST_BIOS_KEY_ENTER)
; Line 428
	*** 000063	3c 1c 			cmp	al,28	;001cH
	*** 000065	74 b5 			je	SHORT $FC1569
;|*** 			return false;
; Line 429
	*** 000067	32 c0 			xor	al,al
	*** 000069	e9 17 01 		jmp	$EX1564
					$L1785:
;|*** 
;|*** 		if (OpenVolume (BootDrive, bootArguments->BootPassword, &BootCryptoInfo, &bootArguments->HeaderSaltCrc32, skipNormal, skipHidden))
;|*** 			break;
;|*** 
;|*** 		if (GetShiftFlags() & GST_BIOS_SHIFTMASK_CAPSLOCK)
;|*** 			Print ("Warning: Caps Lock is on.\r\n");
;|*** 
;|*** 		Print ("Incorrect password.\r\n\r\n");
;|*** 
;|*** 		if (++incorrectPasswordCount == 4)
;|*** 		{
;|*** #ifdef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 			Print ("If you are sure the password is correct, the key data may be damaged.\r\n"
;|*** 				   "If so, use 'Repair Options' > 'Restore key data'.\r\n\r\n");
;|*** #else
;|*** 			Print ("If you are sure the password is correct, the key data may be damaged. Boot your\r\n"
;|*** 				   "GostCrypt Rescue Disk and select 'Repair Options' > 'Restore key data'.\r\n\r\n");
;|*** #endif
;|*** 		}
;|*** 	}
;|*** 
;|*** 	// Setup boot arguments
;|*** 	bootArguments->BootLoaderVersion = VERSION_NUM;
; Line 452
	*** 00006c	c7 06 18 00 00 13 	mov	WORD PTR 24,4864	;1300H
;|*** 	bootArguments->CryptoInfoOffset = (uint16) BootCryptoInfo;
; Line 453
	*** 000072	a1 00 00 		mov	ax,WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000075	89 06 1a 00 		mov	WORD PTR 26,ax
;|*** 	bootArguments->CryptoInfoLength = sizeof (*BootCryptoInfo);
; Line 454
	*** 000079	c7 06 1c 00 62 04 	mov	WORD PTR 28,1122	;0462H
;|*** 
;|*** 	if (BootCryptoInfo->hiddenVolume)
; Line 456
	*** 00007f	8b 1e 00 00 		mov	bx,WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000083	80 bf 44 04 00 		cmp	BYTE PTR [bx+1092],0
	*** 000088	74 1c 			je	SHORT $I1579
;|*** 		bootArguments->HiddenSystemPartitionStart = PartitionFollowingActive.StartSector << GST_LB_SIZE_BIT_SHIFT_DIVISOR;
; Line 457
	*** 00008a	6a 09 			push	9
	*** 00008c	68 16 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A+22	;PartitionFollowingActive
	*** 00008f	8d 46 f6 		lea	ax,WORD PTR [bp-10]
	*** 000092	50 			push	ax
	*** 000093	e8 00 00 		call	??6@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator<<
	*** 000096	83 c4 06 		add	sp,6
	*** 000099	ba 6a 00 		mov	dx,106	;006aH
	*** 00009c	8b fa 			mov	di,dx
	*** 00009e	8b f0 			mov	si,ax
	*** 0000a0	1e 			push	ds
	*** 0000a1	07 			pop	es
	*** 0000a2	66 a5 			movsd
	*** 0000a4	66 a5 			movsd
;|*** 
;|*** 	if (ExtraBootPartitionPresent)
; Line 459
					$I1579:
	*** 0000a6	80 3e 00 00 00 		cmp	BYTE PTR ?ExtraBootPartitionPresent@@3DA,0	;ExtraBootPartitionPresent
	*** 0000ab	74 05 			je	SHORT $D1582
;|*** 		bootArguments->Flags |= GST_BOOT_ARGS_FLAG_EXTRA_BOOT_PARTITION;
; Line 460
	*** 0000ad	80 0e 7a 00 01 		or	BYTE PTR 122,1
;|*** 
;|*** 	GST_SET_BOOT_ARGUMENTS_SIGNATURE	(bootArguments->Signature);
; Line 462
					$D1582:
	*** 0000b2	c6 06 10 00 54 		mov	BYTE PTR 16,84	;0054H
	*** 0000b7	c6 06 11 00 52 		mov	BYTE PTR 17,82	;0052H
	*** 0000bc	c6 06 12 00 55 		mov	BYTE PTR 18,85	;0055H
	*** 0000c1	c6 06 13 00 45 		mov	BYTE PTR 19,69	;0045H
	*** 0000c6	c6 06 14 00 11 		mov	BYTE PTR 20,17	;0011H
	*** 0000cb	c6 06 15 00 23 		mov	BYTE PTR 21,35	;0023H
	*** 0000d0	c6 06 16 00 45 		mov	BYTE PTR 22,69	;0045H
	*** 0000d5	c6 06 17 00 66 		mov	BYTE PTR 23,102	;0066H
;|*** 
;|*** 	// Setup virtual encrypted partition
;|*** 	if (BootCryptoInfo->EncryptedAreaLength.HighPart != 0 || BootCryptoInfo->EncryptedAreaLength.LowPart != 0)
; Line 465
	*** 0000da	8b 1e 00 00 		mov	bx,WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 0000de	66 83 bf 5a 04 00 	cmp	DWORD PTR [bx+1114],0
	*** 0000e4	75 12 			jne	SHORT $I1586
	*** 0000e6	8b 87 58 04 		mov	ax,WORD PTR [bx+1112]
	*** 0000ea	0b 87 56 04 		or	ax,WORD PTR [bx+1110]
	*** 0000ee	75 08 			jne	SHORT $I1586
;|*** 	{
;|*** 		EncryptedVirtualPartition.Drive = BootDrive;
;|*** 
;|*** 		EncryptedVirtualPartition.StartSector = BootCryptoInfo->EncryptedAreaStart >> GST_LB_SIZE_BIT_SHIFT_DIVISOR;
;|*** 		
;|*** 		HiddenVolumeStartUnitNo = EncryptedVirtualPartition.StartSector;
;|*** 		HiddenVolumeStartSector = PartitionFollowingActive.StartSector;
;|*** 		HiddenVolumeStartSector += EncryptedVirtualPartition.StartSector;
;|*** 
;|*** 		EncryptedVirtualPartition.SectorCount = BootCryptoInfo->EncryptedAreaLength >> GST_LB_SIZE_BIT_SHIFT_DIVISOR;
;|*** 
;|*** 		EncryptedVirtualPartition.EndSector = EncryptedVirtualPartition.SectorCount - 1;
;|*** 		EncryptedVirtualPartition.EndSector += EncryptedVirtualPartition.StartSector;
;|*** 	}
;|*** 	else
;|*** 	{
;|*** 		// Drive not encrypted
;|*** 		EncryptedVirtualPartition.Drive = GST_INVALID_BIOS_DRIVE;
; Line 483
	*** 0000f0	c6 06 01 00 7f 		mov	BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1,127	;007fH	;EncryptedVirtualPartition
	*** 0000f5	e9 89 00 		jmp	$I1590
;|*** 	if (BootCryptoInfo->EncryptedAreaLength.HighPart != 0 || BootCryptoInfo->EncryptedAreaLength.LowPart != 0)
; Line 465
					$I1586:
;|*** 	{
;|*** 		EncryptedVirtualPartition.Drive = BootDrive;
; Line 467
	*** 0000f8	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 0000fb	a2 01 00 		mov	BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1,al	;EncryptedVirtualPartition
;|*** 
;|*** 		EncryptedVirtualPartition.StartSector = BootCryptoInfo->EncryptedAreaStart >> GST_LB_SIZE_BIT_SHIFT_DIVISOR;
; Line 469
	*** 0000fe	6a 09 			push	9
	*** 000100	8d 87 4e 04 		lea	ax,WORD PTR [bx+1102]
	*** 000104	50 			push	ax
	*** 000105	8d 46 f6 		lea	ax,WORD PTR [bp-10]
	*** 000108	50 			push	ax
	*** 000109	e8 00 00 		call	??5@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator>>
	*** 00010c	83 c4 06 		add	sp,6
	*** 00010f	ba 16 00 		mov	dx,OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+22	;EncryptedVirtualPartition
	*** 000112	8b fa 			mov	di,dx
	*** 000114	8b f0 			mov	si,ax
	*** 000116	1e 			push	ds
	*** 000117	07 			pop	es
	*** 000118	66 a5 			movsd
	*** 00011a	66 a5 			movsd
;|*** 		
;|*** 		HiddenVolumeStartUnitNo = EncryptedVirtualPartition.StartSector;
; Line 471
	*** 00011c	b8 00 00 		mov	ax,OFFSET ?HiddenVolumeStartUnitNo@@3TUINT64_STRUCT@@A	;HiddenVolumeStartUnitNo
	*** 00011f	8b f8 			mov	di,ax
	*** 000121	8b f2 			mov	si,dx
	*** 000123	66 a5 			movsd
	*** 000125	66 a5 			movsd
;|*** 		HiddenVolumeStartSector = PartitionFollowingActive.StartSector;
; Line 472
	*** 000127	b8 00 00 		mov	ax,OFFSET ?HiddenVolumeStartSector@@3TUINT64_STRUCT@@A	;HiddenVolumeStartSector
	*** 00012a	8b f8 			mov	di,ax
	*** 00012c	be 16 00 		mov	si,OFFSET ?PartitionFollowingActive@@3UPartition@@A+22	;PartitionFollowingActive
	*** 00012f	66 a5 			movsd
	*** 000131	66 a5 			movsd
;|*** 		HiddenVolumeStartSector += EncryptedVirtualPartition.StartSector;
; Line 473
	*** 000133	52 			push	dx
	*** 000134	50 			push	ax
	*** 000135	e8 00 00 		call	??Y@YAAATUINT64_STRUCT@@AAT0@ABT0@@Z	; operator+=
	*** 000138	83 c4 04 		add	sp,4
;|*** 
;|*** 		EncryptedVirtualPartition.SectorCount = BootCryptoInfo->EncryptedAreaLength >> GST_LB_SIZE_BIT_SHIFT_DIVISOR;
; Line 475
	*** 00013b	6a 09 			push	9
	*** 00013d	a1 00 00 		mov	ax,WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000140	05 56 04 		add	ax,1110	;0456H
	*** 000143	50 			push	ax
	*** 000144	8d 46 f6 		lea	ax,WORD PTR [bp-10]
	*** 000147	50 			push	ax
	*** 000148	e8 00 00 		call	??5@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator>>
	*** 00014b	83 c4 06 		add	sp,6
	*** 00014e	ba 0e 00 		mov	dx,OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+14	;EncryptedVirtualPartition
	*** 000151	8b fa 			mov	di,dx
	*** 000153	8b f0 			mov	si,ax
	*** 000155	1e 			push	ds
	*** 000156	07 			pop	es
	*** 000157	66 a5 			movsd
	*** 000159	66 a5 			movsd
;|*** 
;|*** 		EncryptedVirtualPartition.EndSector = EncryptedVirtualPartition.SectorCount - 1;
; Line 477
	*** 00015b	6a 00 			push	0
	*** 00015d	6a 01 			push	1
	*** 00015f	52 			push	dx
	*** 000160	8d 46 f6 		lea	ax,WORD PTR [bp-10]
	*** 000163	50 			push	ax
	*** 000164	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator-
	*** 000167	83 c4 08 		add	sp,8
	*** 00016a	ba 04 00 		mov	dx,OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+4	;EncryptedVirtualPartition
	*** 00016d	8b fa 			mov	di,dx
	*** 00016f	8b f0 			mov	si,ax
	*** 000171	1e 			push	ds
	*** 000172	07 			pop	es
	*** 000173	66 a5 			movsd
	*** 000175	66 a5 			movsd
;|*** 		EncryptedVirtualPartition.EndSector += EncryptedVirtualPartition.StartSector;
; Line 478
	*** 000177	68 16 00 		push	OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+22	;EncryptedVirtualPartition
	*** 00017a	52 			push	dx
	*** 00017b	e8 00 00 		call	??Y@YAAATUINT64_STRUCT@@AAT0@ABT0@@Z	; operator+=
	*** 00017e	83 c4 04 		add	sp,4
;|*** 	}
;|*** 	else
;|*** 	{
;|*** 		// Drive not encrypted
;|*** 		EncryptedVirtualPartition.Drive = GST_INVALID_BIOS_DRIVE;
;|*** 	}
; Line 484
					$I1590:
;|*** 
;|*** 	return true;
; Line 486
	*** 000181	b0 01 			mov	al,1
;|*** }
; Line 487
					$EX1564:
	*** 000183	5e 			pop	si
	*** 000184	5f 			pop	di
	*** 000185	c9 			leave	
	*** 000186	c3 			ret	

?MountVolume@@YADEAAEDD@Z	ENDP

?GetSystemPartitions@@YADE@Z	PROC NEAR	; GetSystemPartitions COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool GetSystemPartitions (byte drive)
;|***  *	\brief Get drive partition (system partitions)
;|***  *	\param[in] byte drive
;|***  *	\return static bool false if !GetActivePartition (drive)
;|***  *			true else
;|***  *
;|***  */
;|*** static bool GetSystemPartitions (byte drive)
;|*** {
; Line 500
	*** 000000	c8 02 00 00 		enter	2,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	drive = 4
;	partCount = -2
;|*** 	size_t partCount;
;|*** 
;|*** 	if (!GetActivePartition (drive))
; Line 503
	*** 000006	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000009	50 			push	ax
	*** 00000a	e8 00 00 		call	?GetActivePartition@@YADE@Z	; GetActivePartition
	*** 00000d	5b 			pop	bx
	*** 00000e	0a c0 			or	al,al
	*** 000010	74 63 			je	SHORT $EX1593
;|*** 		return false;
;|*** 
;|*** 	// Find partition following the active one
;|*** 	GetDrivePartitions (drive, &PartitionFollowingActive, 1, partCount, false, &ActivePartition);
; Line 507
	*** 000012	6a 00 			push	0
	*** 000014	68 00 00 		push	OFFSET ?ActivePartition@@3UPartition@@A	;ActivePartition
	*** 000017	6a 00 			push	0
	*** 000019	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;partCount
	*** 00001c	50 			push	ax
	*** 00001d	6a 01 			push	1
	*** 00001f	68 00 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A	;PartitionFollowingActive
	*** 000022	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000025	50 			push	ax
	*** 000026	e8 00 00 		call	?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z	; GetDrivePartitions
	*** 000029	83 c4 0e 		add	sp,14	;000eH
;|*** 
;|*** 	// If there is an extra boot partition, use the partitions following it.
;|*** 	// The real boot partition is determined in BootEncryptedDrive().
;|*** 	if (ActivePartition.SectorCount.HighPart == 0 && ActivePartition.SectorCount.LowPart <= GST_MAX_EXTRA_BOOT_PARTITION_SIZE / GST_LB_SIZE
;|*** 		&& PartitionFollowingActive.Drive != GST_INVALID_BIOS_DRIVE)
; Line 512
	*** 00002c	a1 14 00 		mov	ax,WORD PTR ?ActivePartition@@3UPartition@@A+20	;ActivePartition
	*** 00002f	0b 06 12 00 		or	ax,WORD PTR ?ActivePartition@@3UPartition@@A+18	;ActivePartition
	*** 000033	75 3e 			jne	SHORT $I1596
	*** 000035	66 81 3e 0e 00 00 00 10 00 cmp	DWORD PTR ?ActivePartition@@3UPartition@@A+14,1048576	;00100000H	;ActivePartition
	*** 00003e	77 33 			ja	SHORT $I1596
					$L1786:
	*** 000040	80 3e 01 00 7f 		cmp	BYTE PTR ?PartitionFollowingActive@@3UPartition@@A+1,127	;007fH	;PartitionFollowingActive
	*** 000045	74 2c 			je	SHORT $I1596
;|*** 	{
;|*** 		ExtraBootPartitionPresent = true;
; Line 514
	*** 000047	c6 06 00 00 01 		mov	BYTE PTR ?ExtraBootPartitionPresent@@3DA,1	;ExtraBootPartitionPresent
;|*** 
;|*** 		ActivePartition = PartitionFollowingActive;
; Line 516
	*** 00004c	b8 00 00 		mov	ax,OFFSET ?ActivePartition@@3UPartition@@A	;ActivePartition
	*** 00004f	8b f8 			mov	di,ax
	*** 000051	be 00 00 		mov	si,OFFSET ?PartitionFollowingActive@@3UPartition@@A	;PartitionFollowingActive
	*** 000054	1e 			push	ds
	*** 000055	07 			pop	es
	*** 000056	b9 10 00 		mov	cx,16	;0010H
	*** 000059	f3 			rep
	*** 00005a	a5 			movsw
;|*** 		GetDrivePartitions (drive, &PartitionFollowingActive, 1, partCount, false, &ActivePartition);
; Line 517
	*** 00005b	6a 00 			push	0
	*** 00005d	50 			push	ax
	*** 00005e	6a 00 			push	0
	*** 000060	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;partCount
	*** 000063	50 			push	ax
	*** 000064	6a 01 			push	1
	*** 000066	68 00 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A	;PartitionFollowingActive
	*** 000069	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 00006c	50 			push	ax
	*** 00006d	e8 00 00 		call	?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z	; GetDrivePartitions
	*** 000070	83 c4 0e 		add	sp,14	;000eH
;|*** 	}
;|*** 
;|*** 	return true;
; Line 520
					$I1596:
	*** 000073	b0 01 			mov	al,1
;|*** }
; Line 521
					$EX1593:
	*** 000075	5e 			pop	si
	*** 000076	5f 			pop	di
	*** 000077	c9 			leave	
	*** 000078	c3 			ret	

?GetSystemPartitions@@YADE@Z	ENDP

?BootEncryptedDrive@@YAEXZ	PROC NEAR	; BootEncryptedDrive COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static byte BootEncryptedDrive ()
;|***  *	\brief Execute boot sector of the active partition if no errors
;|***  *	\return static byte, exitKey if !MountVolume (BootDrive, exitKey, PreventNormalSystemBoot, false)
;|***  *			scanCode else
;|***  *
;|***  */
;|*** static byte BootEncryptedDrive ()
;|*** {
; Line 532
	*** 000000	c8 0c 00 00 		enter	12,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	exitKey = -1
;	scanCode = -2
;	bootArguments = -4
;|*** 	BootArguments *bootArguments = (BootArguments *) GST_BOOT_LOADER_ARGS_OFFSET;
; Line 533
	*** 000006	c7 46 fc 10 00 		mov	WORD PTR [bp-4],16	;0010H	;bootArguments
;|*** 	byte exitKey;
;|*** 	BootCryptoInfo = NULL;
; Line 535
	*** 00000b	c7 06 00 00 00 00 	mov	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A,0	;BootCryptoInfo
;|*** 
;|*** 	if (!GetSystemPartitions (BootDrive))
; Line 537
	*** 000011	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 000014	50 			push	ax
	*** 000015	e8 00 00 		call	?GetSystemPartitions@@YADE@Z	; GetSystemPartitions
	*** 000018	5b 			pop	bx
	*** 000019	0a c0 			or	al,al
	*** 00001b	0f 84 90 00 		je	$err1603
;|*** 		goto err;
;|*** 
;|*** 	if (!MountVolume (BootDrive, exitKey, PreventNormalSystemBoot, false))
; Line 540
	*** 00001f	6a 00 			push	0
	*** 000021	a0 00 00 		mov	al,BYTE PTR ?PreventNormalSystemBoot@@3DA	;PreventNormalSystemBoot
	*** 000024	50 			push	ax
	*** 000025	8d 46 ff 		lea	ax,WORD PTR [bp-1]	;exitKey
	*** 000028	50 			push	ax
	*** 000029	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 00002c	50 			push	ax
	*** 00002d	e8 00 00 		call	?MountVolume@@YADEAAEDD@Z	; MountVolume
	*** 000030	83 c4 08 		add	sp,8
	*** 000033	0a c0 			or	al,al
	*** 000035	75 06 			jne	SHORT $I1605
;|*** 		return exitKey;
; Line 541
	*** 000037	8a 46 ff 		mov	al,BYTE PTR [bp-1]	;exitKey
	*** 00003a	e9 f1 00 		jmp	$EX1598
;|*** 	
;|*** 	if (!CheckMemoryRequirements ())
; Line 543
					$I1605:
	*** 00003d	e8 00 00 		call	?CheckMemoryRequirements@@YADXZ	; CheckMemoryRequirements
	*** 000040	0a c0 			or	al,al
	*** 000042	74 6b 			je	SHORT $err1603
;|*** 		goto err;
;|*** 
;|*** 	if (BootCryptoInfo->hiddenVolume)
; Line 546
	*** 000044	8b 1e 00 00 		mov	bx,WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000048	80 bf 44 04 00 		cmp	BYTE PTR [bx+1092],0
	*** 00004d	74 2b 			je	SHORT $I1608
;|*** 	{
;|*** 		EncryptedVirtualPartition = ActivePartition;
; Line 548
	*** 00004f	b8 00 00 		mov	ax,OFFSET ?EncryptedVirtualPartition@@3UPartition@@A	;EncryptedVirtualPartition
	*** 000052	8b f8 			mov	di,ax
	*** 000054	be 00 00 		mov	si,OFFSET ?ActivePartition@@3UPartition@@A	;ActivePartition
	*** 000057	1e 			push	ds
	*** 000058	07 			pop	es
	*** 000059	b9 10 00 		mov	cx,16	;0010H
	*** 00005c	f3 			rep
	*** 00005d	a5 			movsw
;|*** 		bootArguments->DecoySystemPartitionStart = ActivePartition.StartSector << GST_LB_SIZE_BIT_SHIFT_DIVISOR;
; Line 549
	*** 00005e	6a 09 			push	9
	*** 000060	68 16 00 		push	OFFSET ?ActivePartition@@3UPartition@@A+22	;ActivePartition
	*** 000063	8d 46 f4 		lea	ax,WORD PTR [bp-12]
	*** 000066	50 			push	ax
	*** 000067	e8 00 00 		call	??6@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator<<
	*** 00006a	83 c4 06 		add	sp,6
	*** 00006d	ba 72 00 		mov	dx,114	;0072H
	*** 000070	8b fa 			mov	di,dx
	*** 000072	8b f0 			mov	si,ax
	*** 000074	1e 			push	ds
	*** 000075	07 			pop	es
	*** 000076	66 a5 			movsd
	*** 000078	66 a5 			movsd
;|*** 	}
;|*** 
;|*** 	if (ExtraBootPartitionPresent && !GetActivePartition (BootDrive))
; Line 552
					$I1608:
	*** 00007a	80 3e 00 00 00 		cmp	BYTE PTR ?ExtraBootPartitionPresent@@3DA,0	;ExtraBootPartitionPresent
	*** 00007f	74 0c 			je	SHORT $I1610
	*** 000081	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 000084	50 			push	ax
	*** 000085	e8 00 00 		call	?GetActivePartition@@YADE@Z	; GetActivePartition
	*** 000088	5b 			pop	bx
	*** 000089	0a c0 			or	al,al
	*** 00008b	74 22 			je	SHORT $err1603
;|*** 		goto err;
;|*** 
;|*** 	if (ReadWriteMBR (false, ActivePartition.Drive) != BiosResultSuccess)
; Line 555
					$I1610:
	*** 00008d	6a 00 			push	0
	*** 00008f	a0 01 00 		mov	al,BYTE PTR ?ActivePartition@@3UPartition@@A+1	;ActivePartition
	*** 000092	50 			push	ax
	*** 000093	6a 00 			push	0
	*** 000095	e8 00 00 		call	?ReadWriteMBR@@YAEDED@Z	; ReadWriteMBR
	*** 000098	83 c4 06 		add	sp,6
	*** 00009b	0a c0 			or	al,al
	*** 00009d	75 10 			jne	SHORT $err1603
;|*** 		goto err;
;|*** 
;|*** 	bootArguments->BootDriveSignature = *(uint32 *) (SectorBuffer + 0x1b8);
; Line 558
	*** 00009f	66 a1 b8 01 		mov	eax,DWORD PTR ?SectorBuffer@@3QAEA+440	;SectorBuffer
	*** 0000a3	66 89 06 7e 00 		mov	DWORD PTR 126,eax
;|*** 
;|*** 	if (!InstallInterruptFilters())
; Line 560
	*** 0000a8	e8 00 00 		call	?InstallInterruptFilters@@YADXZ	; InstallInterruptFilters
	*** 0000ab	0a c0 			or	al,al
	*** 0000ad	75 31 			jne	SHORT $I1615
;|*** 		goto err;
;|*** 
;|*** 	bootArguments->BootArgumentsCrc32 = GetCrc32 ((byte *) bootArguments, (byte *) &bootArguments->BootArgumentsCrc32 - (byte *) bootArguments);
;|*** 
;|*** 	while (true)
;|*** 	{
;|*** 		// Execute boot sector of the active partition
;|*** 		if (ReadSectors (SectorBuffer, ActivePartition.Drive, ActivePartition.StartSector, 1) == BiosResultSuccess)
;|*** 		{
;|*** 			if (*(uint16 *) (SectorBuffer + 510) != 0xaa55)
;|*** 			{
;|*** 				PrintError (GST_BOOT_STR_NO_BOOT_PARTITION);
;|*** 				GetKeyboardChar();
;|*** 			}
;|*** 
;|*** 			ExecuteBootSector (ActivePartition.Drive, SectorBuffer);
;|*** 		}
;|*** 
;|*** 		GetKeyboardChar();
;|*** 	}
;|*** 
;|*** err:
; Line 582
					$err1603:
;|*** 	if (BootCryptoInfo)
; Line 583
	*** 0000af	83 3e 00 00 00 		cmp	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A,0	;BootCryptoInfo
	*** 0000b4	74 0e 			je	SHORT $I1627
;|*** 	{
;|*** 		crypto_close (BootCryptoInfo);
; Line 585
	*** 0000b6	ff 36 00 00 		push	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 0000ba	e8 00 00 		call	_crypto_close
	*** 0000bd	5b 			pop	bx
;|*** 		BootCryptoInfo = NULL;
; Line 586
	*** 0000be	c7 06 00 00 00 00 	mov	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A,0	;BootCryptoInfo
;|*** 	}
;|*** 
;|*** 	EncryptedVirtualPartition.Drive = GST_INVALID_BIOS_DRIVE;
; Line 589
					$I1627:
	*** 0000c4	c6 06 01 00 7f 		mov	BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1,127	;007fH	;EncryptedVirtualPartition
;|*** 	EraseMemory ((void *) GST_BOOT_LOADER_ARGS_OFFSET, sizeof (BootArguments));
; Line 590
	*** 0000c9	6a 76 			push	118	;0076H
	*** 0000cb	6a 10 			push	16	;0010H
	*** 0000cd	e8 00 00 		call	_EraseMemory
	*** 0000d0	83 c4 04 		add	sp,4
;|*** 
;|*** 	byte scanCode;
;|*** 	GetKeyboardChar (&scanCode);
; Line 593
	*** 0000d3	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;scanCode
	*** 0000d6	50 			push	ax
	*** 0000d7	e8 00 00 		call	?GetKeyboardChar@@YAEPAE@Z	; GetKeyboardChar
	*** 0000da	5b 			pop	bx
;|*** 	return scanCode;
; Line 594
	*** 0000db	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;scanCode
	*** 0000de	eb 4e 			jmp	SHORT $EX1598
;|*** 	bootArguments->BootArgumentsCrc32 = GetCrc32 ((byte *) bootArguments, (byte *) &bootArguments->BootArgumentsCrc32 - (byte *) bootArguments);
; Line 563
					$I1615:
	*** 0000e0	6a 72 			push	114	;0072H
	*** 0000e2	6a 10 			push	16	;0010H
	*** 0000e4	e8 00 00 		call	_GetCrc32
	*** 0000e7	83 c4 04 		add	sp,4
	*** 0000ea	89 06 82 00 		mov	WORD PTR 130,ax
	*** 0000ee	89 16 84 00 		mov	WORD PTR 132,dx
;|*** 
;|*** 	while (true)
; Line 565
					$FC1621:
;|*** 	{
;|*** 		// Execute boot sector of the active partition
;|*** 		if (ReadSectors (SectorBuffer, ActivePartition.Drive, ActivePartition.StartSector, 1) == BiosResultSuccess)
; Line 568
	*** 0000f2	6a 00 			push	0
	*** 0000f4	6a 01 			push	1
	*** 0000f6	68 16 00 		push	OFFSET ?ActivePartition@@3UPartition@@A+22	;ActivePartition
	*** 0000f9	a0 01 00 		mov	al,BYTE PTR ?ActivePartition@@3UPartition@@A+1	;ActivePartition
	*** 0000fc	50 			push	ax
	*** 0000fd	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000100	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 000103	83 c4 0a 		add	sp,10	;000aH
	*** 000106	0a c0 			or	al,al
	*** 000108	75 1f 			jne	SHORT $I1623
;|*** 		{
;|*** 			if (*(uint16 *) (SectorBuffer + 510) != 0xaa55)
; Line 570
	*** 00010a	81 3e fe 01 55 aa 	cmp	WORD PTR ?SectorBuffer@@3QAEA+510,-21931	;aa55H	;SectorBuffer
	*** 000110	74 0a 			je	SHORT $I1625
;|*** 			{
;|*** 				PrintError (GST_BOOT_STR_NO_BOOT_PARTITION);
; Line 572
	*** 000112	68 00 00 		push	OFFSET DGROUP:??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@
	*** 000115	e8 00 00 		call	?PrintError@@YAXPBD@Z	; PrintError
	*** 000118	5b 			pop	bx
;|*** 				GetKeyboardChar();
; Line 573
	*** 000119	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** 			}
;|*** 
;|*** 			ExecuteBootSector (ActivePartition.Drive, SectorBuffer);
; Line 576
					$I1625:
	*** 00011c	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 00011f	a0 01 00 		mov	al,BYTE PTR ?ActivePartition@@3UPartition@@A+1	;ActivePartition
	*** 000122	50 			push	ax
	*** 000123	e8 00 00 		call	?ExecuteBootSector@@YAXEPAE@Z	; ExecuteBootSector
	*** 000126	83 c4 04 		add	sp,4
;|*** 		}
;|*** 
;|*** 		GetKeyboardChar();
; Line 579
					$I1623:
	*** 000129	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** 	}
; Line 580
	*** 00012c	eb c4 			jmp	SHORT $FC1621
;|*** 
;|*** err:
;|*** 	if (BootCryptoInfo)
;|*** 	{
;|*** 		crypto_close (BootCryptoInfo);
;|*** 		BootCryptoInfo = NULL;
;|*** 	}
;|*** 
;|*** 	EncryptedVirtualPartition.Drive = GST_INVALID_BIOS_DRIVE;
;|*** 	EraseMemory ((void *) GST_BOOT_LOADER_ARGS_OFFSET, sizeof (BootArguments));
;|*** 
;|*** 	byte scanCode;
;|*** 	GetKeyboardChar (&scanCode);
;|*** 	return scanCode;
;|*** }
; Line 595
					$EX1598:
	*** 00012e	5e 			pop	si
	*** 00012f	5f 			pop	di
	*** 000130	c9 			leave	
	*** 000131	c3 			ret	

?BootEncryptedDrive@@YAEXZ	ENDP

?BootMenu@@YAXXZ	PROC NEAR	; BootMenu COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void BootMenu ()
;|***  *	\brief Find partition, print them, ask user and execute boot sector
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void BootMenu ()
;|*** {
; Line 606
	*** 000000	c8 2e 03 00 		enter	814,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	register si = i
;	partition = -2
;	register si = partition
;	result = -2
;	partitions = -812
;	bootablePartitions = -300
;	partitionCount = -12
;	bootablePartitionCount = -10
;	drive = -7
;	i = -6
;	partition = -2
;	partChar = -8
;|*** 	BiosResult result;
;|*** 	Partition partitions[16];
;|*** 	Partition bootablePartitions[9];
;|*** 	size_t partitionCount;
;|*** 	size_t bootablePartitionCount = 0;
; Line 611
	*** 000006	33 ff 			xor	di,di
;|*** 
;|*** 	for (byte drive = GST_FIRST_BIOS_DRIVE; drive <= GST_LAST_BIOS_DRIVE; ++drive)
; Line 613
	*** 000008	c6 46 f9 80 		mov	BYTE PTR [bp-7],128	;0080H	;drive
					$F1639:
;|*** 	{
;|*** 		if (GetDrivePartitions (drive, partitions, array_capacity (partitions), partitionCount, false, nullptr, true) == BiosResultSuccess)
; Line 615
	*** 00000c	6a 01 			push	1
	*** 00000e	6a 00 			push	0
	*** 000010	6a 00 			push	0
	*** 000012	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;partitionCount
	*** 000015	50 			push	ax
	*** 000016	6a 10 			push	16	;0010H
	*** 000018	8d 86 d4 fc 		lea	ax,WORD PTR [bp-812]	;partitions
	*** 00001c	50 			push	ax
	*** 00001d	8a 46 f9 		mov	al,BYTE PTR [bp-7]	;drive
	*** 000020	50 			push	ax
	*** 000021	e8 00 00 		call	?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z	; GetDrivePartitions
	*** 000024	83 c4 0e 		add	sp,14	;000eH
	*** 000027	0a c0 			or	al,al
	*** 000029	0f 85 b1 00 		jne	$FC1640
	*** 00002d	89 7e f6 		mov	WORD PTR [bp-10],di	;bootablePartitionCount
;|*** 		{
;|*** 			for (size_t i = 0; i < partitionCount; ++i)
; Line 617
	*** 000030	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;i
	*** 000035	e9 99 00 		jmp	$L1815
					$F1644:
;|*** 			{
;|*** 				const Partition &partition = partitions[i];
;|*** 				result = ReadSectors (SectorBuffer, drive, partition.StartSector, 1);
;|*** 
;|*** 				if (result == BiosResultSuccess && *(uint16 *) (SectorBuffer + GST_LB_SIZE - 2) == 0xaa55)
; Line 622
	*** 000038	6a 00 			push	0
	*** 00003a	6a 01 			push	1
	*** 00003c	8b 76 fa 		mov	si,WORD PTR [bp-6]	;i
	*** 00003f	c1 e6 05 		shl	si,5
	*** 000042	8d 82 d4 fc 		lea	ax,WORD PTR [bp-812][si]
	*** 000046	89 46 fe 		mov	WORD PTR [bp-2],ax	;partition
	*** 000049	05 16 00 		add	ax,22	;0016H
	*** 00004c	50 			push	ax
	*** 00004d	8a 46 f9 		mov	al,BYTE PTR [bp-7]	;drive
	*** 000050	50 			push	ax
	*** 000051	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000054	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 000057	83 c4 0a 		add	sp,10	;000aH
	*** 00005a	0a c0 			or	al,al
	*** 00005c	75 70 			jne	SHORT $FC1645
	*** 00005e	81 3e fe 01 55 aa 	cmp	WORD PTR ?SectorBuffer@@3QAEA+510,-21931	;aa55H	;SectorBuffer
	*** 000064	75 68 			jne	SHORT $FC1645
;|*** 				{
;|*** 					// Windows writes boot loader on all NTFS/FAT filesytems it creates and, therefore,
;|*** 					// NTFS/FAT partitions must have the boot indicator set to be considered bootable.
;|*** 					if (!partition.Active
;|*** 						&& (*(uint32 *) (SectorBuffer + 3) == 0x5346544e  // 'NTFS'
;|*** 							|| *(uint32 *) (SectorBuffer + 3) == 0x41465845	&& SectorBuffer[7] == 'T' // 'exFAT'
;|*** 							|| *(uint16 *) (SectorBuffer + 54) == 0x4146 && SectorBuffer[56] == 'T' // 'FAT'
;|*** 							|| *(uint16 *) (SectorBuffer + 82) == 0x4146 && SectorBuffer[84] == 'T'))
; Line 630
	*** 000066	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;partition
	*** 000069	38 47 02 		cmp	BYTE PTR [bx+2],al
	*** 00006c	75 3b 			jne	SHORT $I1654
	*** 00006e	66 81 3e 03 00 4e 54 46 53 cmp	DWORD PTR ?SectorBuffer@@3QAEA+3,1397118030	;5346544eH	;SectorBuffer
	*** 000077	74 55 			je	SHORT $FC1645
					$L1798:
	*** 000079	66 81 3e 03 00 45 58 46 41 cmp	DWORD PTR ?SectorBuffer@@3QAEA+3,1095129157	;41465845H	;SectorBuffer
	*** 000082	75 07 			jne	SHORT $I1656
	*** 000084	80 3e 07 00 54 		cmp	BYTE PTR ?SectorBuffer@@3QAEA+7,84	;0054H	;SectorBuffer
	*** 000089	74 43 			je	SHORT $FC1645
					$I1656:
	*** 00008b	81 3e 36 00 46 41 	cmp	WORD PTR ?SectorBuffer@@3QAEA+54,16710	;4146H	;SectorBuffer
	*** 000091	75 07 			jne	SHORT $I1657
	*** 000093	80 3e 38 00 54 		cmp	BYTE PTR ?SectorBuffer@@3QAEA+56,84	;0054H	;SectorBuffer
	*** 000098	74 34 			je	SHORT $FC1645
					$I1657:
	*** 00009a	81 3e 52 00 46 41 	cmp	WORD PTR ?SectorBuffer@@3QAEA+82,16710	;4146H	;SectorBuffer
	*** 0000a0	75 07 			jne	SHORT $I1654
	*** 0000a2	80 3e 54 00 54 		cmp	BYTE PTR ?SectorBuffer@@3QAEA+84,84	;0054H	;SectorBuffer
	*** 0000a7	74 25 			je	SHORT $FC1645
;|*** 					{
;|*** 						continue;
;|*** 					}
;|*** 
;|*** 					// Bootable sector found
;|*** 					if (bootablePartitionCount < array_capacity (bootablePartitions))
; Line 636
					$I1654:
	*** 0000a9	83 7e f6 09 		cmp	WORD PTR [bp-10],9	;bootablePartitionCount
	*** 0000ad	73 1f 			jae	SHORT $FC1645
;|*** 						bootablePartitions[bootablePartitionCount++] = partition;
; Line 637
	*** 0000af	8b 76 f6 		mov	si,WORD PTR [bp-10]	;bootablePartitionCount
	*** 0000b2	c1 e6 05 		shl	si,5
	*** 0000b5	8d 82 d4 fe 		lea	ax,WORD PTR [bp-300][si]
	*** 0000b9	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 0000bc	ff 46 f6 		inc	WORD PTR [bp-10]	;bootablePartitionCount
	*** 0000bf	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;partition
	*** 0000c2	8b f0 			mov	si,ax
	*** 0000c4	1e 			push	ds
	*** 0000c5	07 			pop	es
	*** 0000c6	8b 7e fc 		mov	di,WORD PTR [bp-4]
	*** 0000c9	b9 10 00 		mov	cx,16	;0010H
	*** 0000cc	f3 			rep
	*** 0000cd	a5 			movsw
;|*** 			for (size_t i = 0; i < partitionCount; ++i)
; Line 617
					$FC1645:
	*** 0000ce	ff 46 fa 		inc	WORD PTR [bp-6]	;i
					$L1815:
	*** 0000d1	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;partitionCount
	*** 0000d4	39 46 fa 		cmp	WORD PTR [bp-6],ax	;i
	*** 0000d7	0f 82 5d ff 		jb	$F1644
	*** 0000db	8b 7e f6 		mov	di,WORD PTR [bp-10]	;bootablePartitionCount
;|*** 	for (byte drive = GST_FIRST_BIOS_DRIVE; drive <= GST_LAST_BIOS_DRIVE; ++drive)
; Line 613
					$FC1640:
	*** 0000de	fe 46 f9 		inc	BYTE PTR [bp-7]	;drive
	*** 0000e1	80 7e f9 8f 		cmp	BYTE PTR [bp-7],143	;008fH	;drive
	*** 0000e5	0f 86 23 ff 		jbe	$F1639
;|*** 	{
;|*** 		if (GetDrivePartitions (drive, partitions, array_capacity (partitions), partitionCount, false, nullptr, true) == BiosResultSuccess)
;|*** 		{
;|*** 			for (size_t i = 0; i < partitionCount; ++i)
;|*** 			{
;|*** 				const Partition &partition = partitions[i];
;|*** 				result = ReadSectors (SectorBuffer, drive, partition.StartSector, 1);
;|*** 
;|*** 				if (result == BiosResultSuccess && *(uint16 *) (SectorBuffer + GST_LB_SIZE - 2) == 0xaa55)
;|*** 				{
;|*** 					// Windows writes boot loader on all NTFS/FAT filesytems it creates and, therefore,
;|*** 					// NTFS/FAT partitions must have the boot indicator set to be considered bootable.
;|*** 					if (!partition.Active
;|*** 						&& (*(uint32 *) (SectorBuffer + 3) == 0x5346544e  // 'NTFS'
;|*** 							|| *(uint32 *) (SectorBuffer + 3) == 0x41465845	&& SectorBuffer[7] == 'T' // 'exFAT'
;|*** 							|| *(uint16 *) (SectorBuffer + 54) == 0x4146 && SectorBuffer[56] == 'T' // 'FAT'
;|*** 							|| *(uint16 *) (SectorBuffer + 82) == 0x4146 && SectorBuffer[84] == 'T'))
;|*** 					{
;|*** 						continue;
;|*** 					}
;|*** 
;|*** 					// Bootable sector found
;|*** 					if (bootablePartitionCount < array_capacity (bootablePartitions))
;|*** 						bootablePartitions[bootablePartitionCount++] = partition;
;|*** 				}
;|*** 			}
;|*** 		}
;|*** 	}
;|*** 
;|*** 	if (bootablePartitionCount < 1)
; Line 643
	*** 0000e9	83 ff 01 		cmp	di,1
	*** 0000ec	73 0d 			jae	SHORT $L1797
;|*** 	{
;|*** 		PrintError (GST_BOOT_STR_NO_BOOT_PARTITION);
; Line 645
	*** 0000ee	68 00 00 		push	OFFSET DGROUP:??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@
	*** 0000f1	e8 00 00 		call	?PrintError@@YAXPBD@Z	; PrintError
	*** 0000f4	5b 			pop	bx
;|*** 		GetKeyboardChar();
; Line 646
	*** 0000f5	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** 		return;
; Line 647
	*** 0000f8	e9 21 01 		jmp	$EX1632
					$L1797:
	*** 0000fb	89 7e f6 		mov	WORD PTR [bp-10],di	;bootablePartitionCount
;|*** 	}
;|*** 
;|*** 	char partChar;
;|*** 	while (true)
; Line 651
					$FC1662:
;|*** 	{
;|*** 		InitScreen();
; Line 653
	*** 0000fe	e8 00 00 		call	?InitScreen@@YAXXZ	; InitScreen
;|*** 		Print ("Bootable Partitions:\r\n");
; Line 654
	*** 000101	68 00 00 		push	OFFSET DGROUP:??_C@_0BH@CKJE@Bootable?5Partitions?3?$AN?6?$AA@
	*** 000104	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000107	5b 			pop	bx
;|*** 		PrintRepeatedChar ('\xC4', 20);
; Line 655
	*** 000108	6a 14 			push	20	;0014H
	*** 00010a	6a c4 			push	-60	;ffc4H
	*** 00010c	e8 00 00 		call	?PrintRepeatedChar@@YAXDH@Z	; PrintRepeatedChar
	*** 00010f	83 c4 04 		add	sp,4
;|*** 		Print ("\r\n");
; Line 656
	*** 000112	68 00 00 		push	OFFSET DGROUP:??_C@_02PIMC@?$AN?6?$AA@
	*** 000115	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000118	5b 			pop	bx
;|*** 
;|*** 		for (size_t i = 0; i < bootablePartitionCount; ++i)
; Line 658
	*** 000119	33 f6 			xor	si,si
	*** 00011b	eb 7c 			jmp	SHORT $L1814
					$F1667:
;|*** 		{
;|*** 			const Partition &partition = bootablePartitions[i];
; Line 660
	*** 00011d	8b c6 			mov	ax,si
	*** 00011f	c1 e0 05 		shl	ax,5
	*** 000122	8d 8e d4 fe 		lea	cx,WORD PTR [bp-300]	;bootablePartitions
	*** 000126	03 c1 			add	ax,cx
	*** 000128	89 46 fe 		mov	WORD PTR [bp-2],ax	;partition
;|*** 			Print ("["); Print (i + 1); Print ("]    ");
; Line 661
	*** 00012b	68 00 00 		push	OFFSET DGROUP:??_C@_01KHLB@?$FL?$AA@
	*** 00012e	89 86 d2 fc 		mov	WORD PTR [bp-814],ax
	*** 000132	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000135	5b 			pop	bx
	*** 000136	8d 44 01 		lea	ax,WORD PTR [si+1]
	*** 000139	6a 00 			push	0
	*** 00013b	50 			push	ax
	*** 00013c	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 00013f	83 c4 04 		add	sp,4
	*** 000142	68 00 00 		push	OFFSET DGROUP:??_C@_05EFLO@?$FN?5?5?5?5?$AA@
	*** 000145	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000148	5b 			pop	bx
;|*** 			Print ("Drive: "); Print (partition.Drive - GST_FIRST_BIOS_DRIVE);
; Line 662
	*** 000149	68 00 00 		push	OFFSET DGROUP:??_C@_07MCKD@Drive?3?5?$AA@
	*** 00014c	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00014f	5b 			pop	bx
	*** 000150	8b 9e d2 fc 		mov	bx,WORD PTR [bp-814]
	*** 000154	2a e4 			sub	ah,ah
	*** 000156	8a 47 01 		mov	al,BYTE PTR [bx+1]
	*** 000159	2d 80 00 		sub	ax,128	;0080H
	*** 00015c	99 			cwd	
	*** 00015d	52 			push	dx
	*** 00015e	50 			push	ax
	*** 00015f	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 000162	83 c4 04 		add	sp,4
;|*** 			Print (", Partition: "); Print (partition.Number + 1);
; Line 663
	*** 000165	68 00 00 		push	OFFSET DGROUP:??_C@_0O@LEMN@?0?5Partition?3?5?$AA@
	*** 000168	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00016b	5b 			pop	bx
	*** 00016c	8b 9e d2 fc 		mov	bx,WORD PTR [bp-814]
	*** 000170	2a e4 			sub	ah,ah
	*** 000172	8a 07 			mov	al,BYTE PTR [bx]
	*** 000174	40 			inc	ax
	*** 000175	99 			cwd	
	*** 000176	52 			push	dx
	*** 000177	50 			push	ax
	*** 000178	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 00017b	83 c4 04 		add	sp,4
;|*** 			Print (", Size: "); PrintSectorCountInMB (partition.SectorCount); PrintEndl();
; Line 664
	*** 00017e	68 00 00 		push	OFFSET DGROUP:??_C@_08PFEJ@?0?5Size?3?5?$AA@
	*** 000181	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000184	5b 			pop	bx
	*** 000185	8b 86 d2 fc 		mov	ax,WORD PTR [bp-814]
	*** 000189	05 0e 00 		add	ax,14	;000eH
	*** 00018c	50 			push	ax
	*** 00018d	e8 00 00 		call	?PrintSectorCountInMB@@YAXABTUINT64_STRUCT@@@Z	; PrintSectorCountInMB
	*** 000190	5b 			pop	bx
	*** 000191	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 		for (size_t i = 0; i < bootablePartitionCount; ++i)
; Line 658
	*** 000194	8d 44 01 		lea	ax,WORD PTR [si+1]
	*** 000197	8b f0 			mov	si,ax
					$L1814:
	*** 000199	3b f7 			cmp	si,di
	*** 00019b	0f 82 7e ff 		jb	$F1667
;|*** 		{
;|*** 			const Partition &partition = bootablePartitions[i];
;|*** 			Print ("["); Print (i + 1); Print ("]    ");
;|*** 			Print ("Drive: "); Print (partition.Drive - GST_FIRST_BIOS_DRIVE);
;|*** 			Print (", Partition: "); Print (partition.Number + 1);
;|*** 			Print (", Size: "); PrintSectorCountInMB (partition.SectorCount); PrintEndl();
;|*** 		}
;|*** 
;|*** 		if (bootablePartitionCount == 1)
; Line 667
	*** 00019f	83 ff 01 		cmp	di,1
	*** 0001a2	75 06 			jne	SHORT $I1674
;|*** 		{
;|*** 			// There's only one bootable partition so we'll boot it directly instead of showing boot manager
;|*** 			partChar = '1';
; Line 670
	*** 0001a4	c6 46 f8 31 		mov	BYTE PTR [bp-8],49	;0031H	;partChar
;|*** 		}
;|*** 		else
; Line 672
	*** 0001a8	eb 32 			jmp	SHORT $I1675
					$I1674:
;|*** 		{
;|*** 			Print ("[Esc]  Cancel\r\n\r\n");
; Line 674
	*** 0001aa	68 00 00 		push	OFFSET DGROUP:??_C@_0BC@DHAO@?$FLEsc?$FN?5?5Cancel?$AN?6?$AN?6?$AA@
	*** 0001ad	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 0001b0	5b 			pop	bx
;|*** 			Print ("Press 1-9 to select partition: ");
; Line 675
	*** 0001b1	68 00 00 		push	OFFSET DGROUP:??_C@_0CA@HAB@Press?51?99?5to?5select?5partition?3?5?$AA@
	*** 0001b4	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 0001b7	5b 			pop	bx
;|*** 
;|*** 			if (GetString (&partChar, 1) == 0)
; Line 677
	*** 0001b8	6a 01 			push	1
	*** 0001ba	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;partChar
	*** 0001bd	50 			push	ax
	*** 0001be	e8 00 00 		call	?GetString@@YAHPADI@Z	; GetString
	*** 0001c1	83 c4 04 		add	sp,4
	*** 0001c4	0b c0 			or	ax,ax
	*** 0001c6	74 54 			je	SHORT $EX1632
;|*** 				return;
;|*** 
;|*** 			PrintEndl();
; Line 680
	*** 0001c8	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 
;|*** 			if (partChar < '1' || partChar > '0' + bootablePartitionCount)
; Line 682
	*** 0001cb	80 7e f8 31 		cmp	BYTE PTR [bp-8],49	;0031H	;partChar
	*** 0001cf	7c 45 			jl	SHORT $I1679
	*** 0001d1	8a 46 f8 		mov	al,BYTE PTR [bp-8]	;partChar
	*** 0001d4	98 			cbw	
	*** 0001d5	8d 4d 30 		lea	cx,WORD PTR [di+48]
	*** 0001d8	3b c8 			cmp	cx,ax
	*** 0001da	72 3a 			jb	SHORT $I1679
;|*** 			{
;|*** 				Beep();
;|*** 				continue;
;|*** 			}
;|*** 		}
; Line 687
					$I1675:
;|*** 
;|*** 		const Partition &partition = bootablePartitions[partChar - '0' - 1];
; Line 689
	*** 0001dc	8a 46 f8 		mov	al,BYTE PTR [bp-8]	;partChar
	*** 0001df	98 			cbw	
	*** 0001e0	8b f0 			mov	si,ax
	*** 0001e2	c1 e6 05 		shl	si,5
	*** 0001e5	8d 86 b4 f8 		lea	ax,WORD PTR [bp-1868]
	*** 0001e9	03 f0 			add	si,ax
;|*** 
;|*** 		if (ReadSectors (SectorBuffer, partition.Drive, partition.StartSector, 1) == BiosResultSuccess)
; Line 691
	*** 0001eb	6a 00 			push	0
	*** 0001ed	6a 01 			push	1
	*** 0001ef	8d 44 16 		lea	ax,WORD PTR [si+22]
	*** 0001f2	50 			push	ax
	*** 0001f3	8a 44 01 		mov	al,BYTE PTR [si+1]
	*** 0001f6	50 			push	ax
	*** 0001f7	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 0001fa	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 0001fd	83 c4 0a 		add	sp,10	;000aH
	*** 000200	0a c0 			or	al,al
	*** 000202	0f 85 f8 fe 		jne	$FC1662
;|*** 		{
;|*** 			ExecuteBootSector (partition.Drive, SectorBuffer);
; Line 693
	*** 000206	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000209	8a 44 01 		mov	al,BYTE PTR [si+1]
	*** 00020c	50 			push	ax
	*** 00020d	e8 00 00 		call	?ExecuteBootSector@@YAXEPAE@Z	; ExecuteBootSector
	*** 000210	83 c4 04 		add	sp,4
;|*** 		}
;|*** 	}
; Line 695
	*** 000213	e9 e8 fe 		jmp	$FC1662
;|*** 			if (partChar < '1' || partChar > '0' + bootablePartitionCount)
; Line 682
					$I1679:
;|*** 			{
;|*** 				Beep();
; Line 684
	*** 000216	e8 00 00 		call	?Beep@@YAXXZ	; Beep
;|*** 				continue;
; Line 685
	*** 000219	e9 e2 fe 		jmp	$FC1662
;|*** 			}
;|*** 		}
;|*** 
;|*** 		const Partition &partition = bootablePartitions[partChar - '0' - 1];
;|*** 
;|*** 		if (ReadSectors (SectorBuffer, partition.Drive, partition.StartSector, 1) == BiosResultSuccess)
;|*** 		{
;|*** 			ExecuteBootSector (partition.Drive, SectorBuffer);
;|*** 		}
;|*** 	}
;|*** }
; Line 696
					$EX1632:
	*** 00021c	5e 			pop	si
	*** 00021d	5f 			pop	di
	*** 00021e	c9 			leave	
	*** 00021f	c3 			ret	

?BootMenu@@YAXXZ	ENDP

?CopySystemPartitionToHiddenVolume@@YADEAAE@Z	PROC NEAR	; CopySystemPartitionToHiddenVolume COMDAT
;|*** 
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool CopySystemPartitionToHiddenVolume (byte drive, byte &exitKey)
;|***  *	\brief Copy the system partition to the hidden volume
;|***  *	\param[in] byte & exitKey
;|***  *	\param[in] byte drive
;|***  *	\return static bool false if !MountVolume (drive, exitKey, true, false)
;|***  *			status else
;|***  *
;|***  */
;|*** static bool CopySystemPartitionToHiddenVolume (byte drive, byte &exitKey)
;|*** {
; Line 712
	*** 000000	c8 30 00 00 		enter	48,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	drive = 4
;	exitKey = 6
;	status = -5
;	sectorsRemaining = -24
;	sectorOffset = -32
;	fragmentSectorCount = -4
;	statCount = -8
;	i = -2
;	s = -16
;|*** 	bool status = false;
; Line 713
	*** 000006	c6 46 fb 00 		mov	BYTE PTR [bp-5],0	;status
;|*** 
;|*** 	uint64 sectorsRemaining;
;|*** 	uint64 sectorOffset;
;|*** 	sectorOffset.LowPart = 0;
; Line 717
	*** 00000a	66 2b c0 		sub	eax,eax
	*** 00000d	66 89 46 e0 		mov	DWORD PTR [bp-32],eax	;sectorOffset
;|*** 	sectorOffset.HighPart = 0;
; Line 718
	*** 000011	66 89 46 e4 		mov	DWORD PTR [bp-28],eax
;|*** 
;|*** 	int fragmentSectorCount = 0x7f; // Maximum safe value supported by BIOS
; Line 720
	*** 000015	c7 46 fc 7f 00 		mov	WORD PTR [bp-4],127	;007fH	;fragmentSectorCount
;|*** 	int statCount;
;|*** 
;|*** 	if (!CheckMemoryRequirements ())
; Line 723
	*** 00001a	e8 00 00 		call	?CheckMemoryRequirements@@YADXZ	; CheckMemoryRequirements
	*** 00001d	0a c0 			or	al,al
	*** 00001f	74 0c 			je	SHORT $L1821
;|*** 		goto err;
;|*** 
;|*** 	if (!GetSystemPartitions (drive))
; Line 726
	*** 000021	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000024	50 			push	ax
	*** 000025	e8 00 00 		call	?GetSystemPartitions@@YADE@Z	; GetSystemPartitions
	*** 000028	5b 			pop	bx
	*** 000029	0a c0 			or	al,al
	*** 00002b	75 03 			jne	SHORT $L1820
;|*** 		goto err;
;|*** 
;|*** 	if (PartitionFollowingActive.Drive == GST_INVALID_BIOS_DRIVE)
; Line 729
					$L1821:
	*** 00002d	e9 73 02 		jmp	$err1692
					$L1820:
	*** 000030	80 3e 01 00 7f 		cmp	BYTE PTR ?PartitionFollowingActive@@3UPartition@@A+1,127	;007fH	;PartitionFollowingActive
	*** 000035	75 07 			jne	SHORT $I1696
;|*** 		GST_THROW_FATAL_EXCEPTION;
; Line 730
	*** 000037	68 da 02 		push	730	;02daH
	*** 00003a	e8 00 00 		call	_ThrowFatalException
	*** 00003d	5b 			pop	bx
;|*** 
;|*** 	// Check if BIOS can read the last sector of the hidden system
;|*** 	AcquireSectorBuffer();
; Line 733
					$I1696:
;|*** 
;|*** 	if (ReadSectors (SectorBuffer, PartitionFollowingActive.Drive, PartitionFollowingActive.EndSector - (GST_VOLUME_HEADER_GROUP_SIZE / GST_LB_SIZE - 2), 1) != BiosResultSuccess
;|*** 		|| GetCrc32 (SectorBuffer, sizeof (SectorBuffer)) != OuterVolumeBackupHeaderCrc)
; Line 736
	*** 00003e	6a 00 			push	0
	*** 000040	6a 01 			push	1
	*** 000042	6a 00 			push	0
	*** 000044	68 fe 00 		push	254	;00feH
	*** 000047	68 04 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A+4	;PartitionFollowingActive
	*** 00004a	8d 46 d8 		lea	ax,WORD PTR [bp-40]
	*** 00004d	50 			push	ax
	*** 00004e	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator-
	*** 000051	83 c4 08 		add	sp,8
	*** 000054	50 			push	ax
	*** 000055	a0 01 00 		mov	al,BYTE PTR ?PartitionFollowingActive@@3UPartition@@A+1	;PartitionFollowingActive
	*** 000058	50 			push	ax
	*** 000059	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 00005c	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 00005f	83 c4 0a 		add	sp,10	;000aH
	*** 000062	0a c0 			or	al,al
	*** 000064	75 18 			jne	SHORT $L1823
	*** 000066	68 00 02 		push	512	;0200H
	*** 000069	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 00006c	e8 00 00 		call	_GetCrc32
	*** 00006f	83 c4 04 		add	sp,4
	*** 000072	3b 06 00 00 		cmp	ax,WORD PTR ?OuterVolumeBackupHeaderCrc@@3KA	;OuterVolumeBackupHeaderCrc
	*** 000076	75 06 			jne	SHORT $L1823
	*** 000078	3b 16 02 00 		cmp	dx,WORD PTR ?OuterVolumeBackupHeaderCrc@@3KA+2	;OuterVolumeBackupHeaderCrc
	*** 00007c	74 03 			je	SHORT $L1822
;|*** 	{
;|*** 		PrintErrorNoEndl ("Your BIOS does not support large drives");
;|*** 		Print (IsLbaSupported (PartitionFollowingActive.Drive) ? " due to a bug" : "\r\n- Enable LBA in BIOS");
;|*** 		PrintEndl();
;|*** 		Print (GST_BOOT_STR_UPGRADE_BIOS);
;|*** 
;|*** 		ReleaseSectorBuffer();
;|*** 		goto err;
;|*** 	}
;|*** 
;|*** 	ReleaseSectorBuffer();
;|*** 
;|*** 	if (!MountVolume (drive, exitKey, true, false))
; Line 749
					$L1823:
	*** 00007e	e9 f8 01 		jmp	$I1699
					$L1822:
	*** 000081	6a 00 			push	0
	*** 000083	6a 01 			push	1
	*** 000085	ff 76 06 		push	WORD PTR [bp+6]	;exitKey
	*** 000088	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 00008b	50 			push	ax
	*** 00008c	e8 00 00 		call	?MountVolume@@YADEAAEDD@Z	; MountVolume
	*** 00008f	83 c4 08 		add	sp,8
	*** 000092	0a c0 			or	al,al
	*** 000094	0f 84 21 02 		je	$EX1685
;|*** 		return false;
;|*** 
;|*** 	sectorsRemaining = EncryptedVirtualPartition.SectorCount;
; Line 752
	*** 000098	8d 7e e8 		lea	di,WORD PTR [bp-24]	;sectorsRemaining
	*** 00009b	be 0e 00 		mov	si,OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+14	;EncryptedVirtualPartition
	*** 00009e	16 			push	ss
	*** 00009f	07 			pop	es
	*** 0000a0	66 a5 			movsd
	*** 0000a2	66 a5 			movsd
;|*** 
;|*** 	if (!(sectorsRemaining == ActivePartition.SectorCount))
; Line 754
	*** 0000a4	68 0e 00 		push	OFFSET ?ActivePartition@@3UPartition@@A+14	;ActivePartition
	*** 0000a7	8d 46 e8 		lea	ax,WORD PTR [bp-24]	;sectorsRemaining
	*** 0000aa	50 			push	ax
	*** 0000ab	e8 00 00 		call	??8@YADABTUINT64_STRUCT@@0@Z	; operator==
	*** 0000ae	83 c4 04 		add	sp,4
	*** 0000b1	0a c0 			or	al,al
	*** 0000b3	75 07 			jne	SHORT $I1705
;|*** 		GST_THROW_FATAL_EXCEPTION;
; Line 755
	*** 0000b5	68 f3 02 		push	755	;02f3H
	*** 0000b8	e8 00 00 		call	_ThrowFatalException
	*** 0000bb	5b 			pop	bx
;|*** 
;|*** 	InitScreen();
; Line 757
					$I1705:
	*** 0000bc	e8 00 00 		call	?InitScreen@@YAXXZ	; InitScreen
;|*** 	Print ("\r\nCopying system to hidden volume. To abort, press Esc.\r\n\r\n");
; Line 758
	*** 0000bf	68 00 00 		push	OFFSET DGROUP:??_C@_0DM@NDEP@?$AN?6Copying?5system?5to?5hidden?5volum@
	*** 0000c2	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
					$L1817:
	*** 0000c5	5b 			pop	bx
;|*** 
;|*** 	while (sectorsRemaining.HighPart != 0 || sectorsRemaining.LowPart != 0)
; Line 760
					$FC1708:
	*** 0000c6	66 83 7e ec 00 		cmp	DWORD PTR [bp-20],0
	*** 0000cb	75 09 			jne	SHORT $FB1710
	*** 0000cd	66 83 7e e8 00 		cmp	DWORD PTR [bp-24],0	;sectorsRemaining
	*** 0000d2	0f 84 6a 01 		je	$FB1709
					$FB1710:
;|*** 	{
;|*** 		if (EscKeyPressed())
; Line 762
	*** 0000d6	e8 00 00 		call	?EscKeyPressed@@YADXZ	; EscKeyPressed
	*** 0000d9	0a c0 			or	al,al
	*** 0000db	74 14 			je	SHORT $I1711
;|*** 		{
;|*** 			Print ("\rIf aborted, copying will have to start from the beginning (if attempted again).\r\n");
; Line 764
	*** 0000dd	68 00 00 		push	OFFSET DGROUP:??_C@_0FD@OPN@?$ANIf?5aborted?0?5copying?5will?5have?5t@
	*** 0000e0	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 0000e3	5b 			pop	bx
;|*** 			if (AskYesNo ("Abort"))
; Line 765
	*** 0000e4	68 00 00 		push	OFFSET DGROUP:??_C@_05DILO@Abort?$AA@
	*** 0000e7	e8 00 00 		call	?AskYesNo@@YADPBD@Z	; AskYesNo
	*** 0000ea	5b 			pop	bx
	*** 0000eb	0a c0 			or	al,al
	*** 0000ed	0f 85 4f 01 		jne	$FB1709
;|*** 				break;
;|*** 		}
;|*** 
;|*** 		if (sectorsRemaining.HighPart == 0 && sectorsRemaining.LowPart < fragmentSectorCount)
; Line 769
					$I1711:
	*** 0000f1	66 83 7e ec 00 		cmp	DWORD PTR [bp-20],0
	*** 0000f6	75 11 			jne	SHORT $I1715
	*** 0000f8	66 0f bf 46 fc 		movsx	eax,WORD PTR [bp-4]	;fragmentSectorCount
	*** 0000fd	66 3b 46 e8 		cmp	eax,DWORD PTR [bp-24]	;sectorsRemaining
	*** 000101	76 06 			jbe	SHORT $I1715
					$L1807:
;|*** 			fragmentSectorCount = (int) sectorsRemaining.LowPart;
; Line 770
	*** 000103	8b 46 e8 		mov	ax,WORD PTR [bp-24]	;sectorsRemaining
	*** 000106	89 46 fc 		mov	WORD PTR [bp-4],ax	;fragmentSectorCount
;|*** 
;|*** 		if (ReadWriteSectors (false, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, ActivePartition.StartSector + sectorOffset, fragmentSectorCount, false) != BiosResultSuccess)
; Line 772
					$I1715:
	*** 000109	6a 00 			push	0
	*** 00010b	ff 76 fc 		push	WORD PTR [bp-4]	;fragmentSectorCount
	*** 00010e	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;sectorOffset
	*** 000111	50 			push	ax
	*** 000112	68 16 00 		push	OFFSET ?ActivePartition@@3UPartition@@A+22	;ActivePartition
	*** 000115	8d 46 d8 		lea	ax,WORD PTR [bp-40]
	*** 000118	50 			push	ax
	*** 000119	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@0@Z	; operator+
	*** 00011c	83 c4 06 		add	sp,6
	*** 00011f	50 			push	ax
	*** 000120	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000123	50 			push	ax
	*** 000124	6a 00 			push	0
	*** 000126	68 00 40 		push	16384	;4000H
	*** 000129	6a 00 			push	0
	*** 00012b	e8 00 00 		call	?ReadWriteSectors@@YAEDIIEABTUINT64_STRUCT@@ID@Z	; ReadWriteSectors
	*** 00012e	83 c4 0e 		add	sp,14	;000eH
	*** 000131	0a c0 			or	al,al
	*** 000133	0f 85 32 01 		jne	$L1803
;|*** 		{
;|*** 			Print ("To fix bad sectors: 1) Terminate 2) Encrypt and decrypt sys partition 3) Retry\r\n");
;|*** 			crypto_close (BootCryptoInfo);
;|*** 			goto err;
;|*** 		}
;|*** 
;|*** 		AcquireSectorBuffer();
;|*** 
;|*** 		for (int i = 0; i < fragmentSectorCount; ++i)
; Line 781
	*** 000137	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 00013c	eb 6f 			jmp	SHORT $L1816
					$F1722:
;|*** 		{
;|*** 			CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, SectorBuffer, GST_LB_SIZE);
; Line 783
	*** 00013e	68 00 02 		push	512	;0200H
	*** 000141	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000144	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 000147	c1 e0 09 		shl	ax,9
	*** 00014a	50 			push	ax
	*** 00014b	68 00 40 		push	16384	;4000H
	*** 00014e	8b f0 			mov	si,ax
	*** 000150	e8 00 00 		call	?CopyMemory@@YAXIIPAXI@Z	; CopyMemory
	*** 000153	83 c4 08 		add	sp,8
;|*** 
;|*** 			uint64 s = HiddenVolumeStartUnitNo + sectorOffset + i;
; Line 785
	*** 000156	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 000159	99 			cwd	
	*** 00015a	52 			push	dx
	*** 00015b	50 			push	ax
	*** 00015c	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;sectorOffset
	*** 00015f	50 			push	ax
	*** 000160	68 00 00 		push	OFFSET ?HiddenVolumeStartUnitNo@@3TUINT64_STRUCT@@A	;HiddenVolumeStartUnitNo
	*** 000163	8d 46 d8 		lea	ax,WORD PTR [bp-40]
	*** 000166	50 			push	ax
	*** 000167	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@0@Z	; operator+
	*** 00016a	83 c4 06 		add	sp,6
	*** 00016d	50 			push	ax
	*** 00016e	8d 46 d0 		lea	ax,WORD PTR [bp-48]
	*** 000171	50 			push	ax
	*** 000172	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator+
	*** 000175	83 c4 08 		add	sp,8
	*** 000178	56 			push	si
	*** 000179	8d 7e f0 		lea	di,WORD PTR [bp-16]	;s
	*** 00017c	8b f0 			mov	si,ax
	*** 00017e	16 			push	ss
	*** 00017f	07 			pop	es
	*** 000180	66 a5 			movsd
	*** 000182	66 a5 			movsd
	*** 000184	5e 			pop	si
;|*** 			EncryptDataUnits (SectorBuffer, &s, 1, BootCryptoInfo);
; Line 786
	*** 000185	ff 36 00 00 		push	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000189	6a 00 			push	0
	*** 00018b	6a 01 			push	1
	*** 00018d	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;s
	*** 000190	50 			push	ax
	*** 000191	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000194	e8 00 00 		call	_EncryptDataUnits
	*** 000197	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|*** 			CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, GST_LB_SIZE);
; Line 788
	*** 00019a	68 00 02 		push	512	;0200H
	*** 00019d	56 			push	si
	*** 00019e	68 00 40 		push	16384	;4000H
	*** 0001a1	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 0001a4	e8 00 00 		call	?CopyMemory@@YAXPAXIII@Z	; CopyMemory
	*** 0001a7	83 c4 08 		add	sp,8
;|*** 		for (int i = 0; i < fragmentSectorCount; ++i)
; Line 781
	*** 0001aa	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$L1816:
	*** 0001ad	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;fragmentSectorCount
	*** 0001b0	39 46 fe 		cmp	WORD PTR [bp-2],ax	;i
	*** 0001b3	7c 89 			jl	SHORT $F1722
;|*** 		{
;|*** 			CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, SectorBuffer, GST_LB_SIZE);
;|*** 
;|*** 			uint64 s = HiddenVolumeStartUnitNo + sectorOffset + i;
;|*** 			EncryptDataUnits (SectorBuffer, &s, 1, BootCryptoInfo);
;|*** 
;|*** 			CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, GST_LB_SIZE);
;|*** 		} 
;|*** 
;|*** 		ReleaseSectorBuffer();
;|*** 
;|*** 		if (ReadWriteSectors (true, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, HiddenVolumeStartSector + sectorOffset, fragmentSectorCount, false) != BiosResultSuccess)
; Line 793
	*** 0001b5	6a 00 			push	0
	*** 0001b7	50 			push	ax
	*** 0001b8	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;sectorOffset
	*** 0001bb	50 			push	ax
	*** 0001bc	68 00 00 		push	OFFSET ?HiddenVolumeStartSector@@3TUINT64_STRUCT@@A	;HiddenVolumeStartSector
	*** 0001bf	8d 46 d0 		lea	ax,WORD PTR [bp-48]
	*** 0001c2	50 			push	ax
	*** 0001c3	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@0@Z	; operator+
	*** 0001c6	83 c4 06 		add	sp,6
	*** 0001c9	50 			push	ax
	*** 0001ca	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 0001cd	50 			push	ax
	*** 0001ce	6a 00 			push	0
	*** 0001d0	68 00 40 		push	16384	;4000H
	*** 0001d3	6a 01 			push	1
	*** 0001d5	e8 00 00 		call	?ReadWriteSectors@@YAEDIIEABTUINT64_STRUCT@@ID@Z	; ReadWriteSectors
	*** 0001d8	83 c4 0e 		add	sp,14	;000eH
	*** 0001db	0a c0 			or	al,al
	*** 0001dd	0f 85 8f 00 		jne	$L1804
;|*** 		{
;|*** 			crypto_close (BootCryptoInfo);
;|*** 			goto err;
;|*** 		}
;|*** 
;|*** 		sectorsRemaining = sectorsRemaining - fragmentSectorCount;
; Line 799
	*** 0001e1	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;fragmentSectorCount
	*** 0001e4	99 			cwd	
	*** 0001e5	52 			push	dx
	*** 0001e6	50 			push	ax
	*** 0001e7	8d 4e e8 		lea	cx,WORD PTR [bp-24]	;sectorsRemaining
	*** 0001ea	51 			push	cx
	*** 0001eb	8d 5e d8 		lea	bx,WORD PTR [bp-40]
	*** 0001ee	53 			push	bx
	*** 0001ef	8b f0 			mov	si,ax
	*** 0001f1	8b fa 			mov	di,dx
	*** 0001f3	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator-
	*** 0001f6	83 c4 08 		add	sp,8
	*** 0001f9	56 			push	si
	*** 0001fa	57 			push	di
	*** 0001fb	8d 7e e8 		lea	di,WORD PTR [bp-24]	;sectorsRemaining
	*** 0001fe	8b f0 			mov	si,ax
	*** 000200	16 			push	ss
	*** 000201	07 			pop	es
	*** 000202	66 a5 			movsd
	*** 000204	66 a5 			movsd
	*** 000206	5f 			pop	di
	*** 000207	5e 			pop	si
;|*** 		sectorOffset = sectorOffset + fragmentSectorCount;
; Line 800
	*** 000208	57 			push	di
	*** 000209	56 			push	si
	*** 00020a	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;sectorOffset
	*** 00020d	50 			push	ax
	*** 00020e	8d 4e d0 		lea	cx,WORD PTR [bp-48]
	*** 000211	51 			push	cx
	*** 000212	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator+
	*** 000215	83 c4 08 		add	sp,8
	*** 000218	8d 7e e0 		lea	di,WORD PTR [bp-32]	;sectorOffset
	*** 00021b	8b f0 			mov	si,ax
	*** 00021d	16 			push	ss
	*** 00021e	07 			pop	es
	*** 00021f	66 a5 			movsd
	*** 000221	66 a5 			movsd
;|*** 
;|*** 		if (!(statCount++ & 0xf))
; Line 802
	*** 000223	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;statCount
	*** 000226	ff 46 f8 		inc	WORD PTR [bp-8]	;statCount
	*** 000229	a8 0f 			test	al,15	;000fH
	*** 00022b	0f 85 97 fe 		jne	$FC1708
;|*** 		{
;|*** 			Print ("\rRemaining: ");
; Line 804
	*** 00022f	68 00 00 		push	OFFSET DGROUP:??_C@_0N@BNAP@?$ANRemaining?3?5?$AA@
	*** 000232	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000235	5b 			pop	bx
;|*** 			PrintSectorCountInMB (sectorsRemaining);
; Line 805
	*** 000236	8d 46 e8 		lea	ax,WORD PTR [bp-24]	;sectorsRemaining
	*** 000239	50 			push	ax
	*** 00023a	e8 00 00 		call	?PrintSectorCountInMB@@YAXABTUINT64_STRUCT@@@Z	; PrintSectorCountInMB
	*** 00023d	e9 85 fe 		jmp	$L1817
					$FB1709:
;|*** 		}
;|*** 	}
;|*** 
;|*** 	crypto_close (BootCryptoInfo);
; Line 809
	*** 000240	ff 36 00 00 		push	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000244	e8 00 00 		call	_crypto_close
	*** 000247	5b 			pop	bx
;|*** 
;|*** 	if (sectorsRemaining.HighPart == 0 && sectorsRemaining.LowPart == 0)
; Line 811
	*** 000248	66 83 7e ec 00 		cmp	DWORD PTR [bp-20],0
	*** 00024d	75 12 			jne	SHORT $I1735
	*** 00024f	66 83 7e e8 00 		cmp	DWORD PTR [bp-24],0	;sectorsRemaining
	*** 000254	75 0b 			jne	SHORT $I1735
;|*** 	{
;|*** 		status = true;
; Line 813
	*** 000256	c6 46 fb 01 		mov	BYTE PTR [bp-5],1	;status
;|*** 		Print ("\rCopying completed.");
; Line 814
	*** 00025a	68 00 00 		push	OFFSET DGROUP:??_C@_0BE@KCNB@?$ANCopying?5completed?4?$AA@
	*** 00025d	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000260	5b 			pop	bx
;|*** 	}
;|*** 
;|*** 	PrintEndl (2);
; Line 817
					$I1735:
	*** 000261	6a 02 			push	2
	*** 000263	e8 00 00 		call	?PrintEndl@@YAXH@Z	; PrintEndl
	*** 000266	5b 			pop	bx
;|*** 	goto ret;
; Line 818
	*** 000267	eb 43 			jmp	SHORT $ret1737
					$L1803:
;|*** 			Print ("To fix bad sectors: 1) Terminate 2) Encrypt and decrypt sys partition 3) Retry\r\n");
; Line 774
	*** 000269	68 00 00 		push	OFFSET DGROUP:??_C@_0FB@DHKC@To?5fix?5bad?5sectors?3?51?$CJ?5Terminate@
	*** 00026c	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00026f	5b 			pop	bx
					$L1804:
;|*** 			crypto_close (BootCryptoInfo);
;|*** 			goto err;
;|*** 		}
;|*** 
;|*** 		AcquireSectorBuffer();
;|*** 
;|*** 		for (int i = 0; i < fragmentSectorCount; ++i)
;|*** 		{
;|*** 			CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, SectorBuffer, GST_LB_SIZE);
;|*** 
;|*** 			uint64 s = HiddenVolumeStartUnitNo + sectorOffset + i;
;|*** 			EncryptDataUnits (SectorBuffer, &s, 1, BootCryptoInfo);
;|*** 
;|*** 			CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, GST_LB_SIZE);
;|*** 		} 
;|*** 
;|*** 		ReleaseSectorBuffer();
;|*** 
;|*** 		if (ReadWriteSectors (true, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, HiddenVolumeStartSector + sectorOffset, fragmentSectorCount, false) != BiosResultSuccess)
;|*** 		{
;|*** 			crypto_close (BootCryptoInfo);
; Line 795
	*** 000270	ff 36 00 00 		push	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000274	e8 00 00 		call	_crypto_close
	*** 000277	eb 29 			jmp	SHORT $L1818
;|*** 		|| GetCrc32 (SectorBuffer, sizeof (SectorBuffer)) != OuterVolumeBackupHeaderCrc)
; Line 736
					$I1699:
;|*** 	{
;|*** 		PrintErrorNoEndl ("Your BIOS does not support large drives");
; Line 738
	*** 000279	68 00 00 		push	OFFSET DGROUP:??_C@_0CI@CHP@Your?5BIOS?5does?5not?5support?5large@
	*** 00027c	e8 00 00 		call	?PrintErrorNoEndl@@YAXPBD@Z	; PrintErrorNoEndl
	*** 00027f	5b 			pop	bx
;|*** 		Print (IsLbaSupported (PartitionFollowingActive.Drive) ? " due to a bug" : "\r\n- Enable LBA in BIOS");
; Line 739
	*** 000280	a0 01 00 		mov	al,BYTE PTR ?PartitionFollowingActive@@3UPartition@@A+1	;PartitionFollowingActive
	*** 000283	50 			push	ax
	*** 000284	e8 00 00 		call	?IsLbaSupported@@YADE@Z	; IsLbaSupported
	*** 000287	5b 			pop	bx
	*** 000288	0a c0 			or	al,al
	*** 00028a	74 05 			je	SHORT $L1805
	*** 00028c	b8 00 00 		mov	ax,OFFSET DGROUP:??_C@_0O@PLFN@?5due?5to?5a?5bug?$AA@
	*** 00028f	eb 03 			jmp	SHORT $L1806
					$L1805:
	*** 000291	b8 00 00 		mov	ax,OFFSET DGROUP:??_C@_0BH@EGEK@?$AN?6?9?5Enable?5LBA?5in?5BIOS?$AA@
					$L1806:
	*** 000294	50 			push	ax
	*** 000295	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000298	5b 			pop	bx
;|*** 		PrintEndl();
; Line 740
	*** 000299	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 		Print (GST_BOOT_STR_UPGRADE_BIOS);
; Line 741
	*** 00029c	68 00 00 		push	OFFSET DGROUP:??_C@_0DM@HBD@?9?5Upgrade?5BIOS?$AN?6?9?5Use?5a?5differen@
	*** 00029f	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
					$L1818:
	*** 0002a2	5b 			pop	bx
;|*** 
;|*** 		ReleaseSectorBuffer();
;|*** 		goto err;
;|*** 	}
;|*** 
;|*** 	ReleaseSectorBuffer();
;|*** 
;|*** 	if (!MountVolume (drive, exitKey, true, false))
;|*** 		return false;
;|*** 
;|*** 	sectorsRemaining = EncryptedVirtualPartition.SectorCount;
;|*** 
;|*** 	if (!(sectorsRemaining == ActivePartition.SectorCount))
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	InitScreen();
;|*** 	Print ("\r\nCopying system to hidden volume. To abort, press Esc.\r\n\r\n");
;|*** 
;|*** 	while (sectorsRemaining.HighPart != 0 || sectorsRemaining.LowPart != 0)
;|*** 	{
;|*** 		if (EscKeyPressed())
;|*** 		{
;|*** 			Print ("\rIf aborted, copying will have to start from the beginning (if attempted again).\r\n");
;|*** 			if (AskYesNo ("Abort"))
;|*** 				break;
;|*** 		}
;|*** 
;|*** 		if (sectorsRemaining.HighPart == 0 && sectorsRemaining.LowPart < fragmentSectorCount)
;|*** 			fragmentSectorCount = (int) sectorsRemaining.LowPart;
;|*** 
;|*** 		if (ReadWriteSectors (false, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, ActivePartition.StartSector + sectorOffset, fragmentSectorCount, false) != BiosResultSuccess)
;|*** 		{
;|*** 			Print ("To fix bad sectors: 1) Terminate 2) Encrypt and decrypt sys partition 3) Retry\r\n");
;|*** 			crypto_close (BootCryptoInfo);
;|*** 			goto err;
;|*** 		}
;|*** 
;|*** 		AcquireSectorBuffer();
;|*** 
;|*** 		for (int i = 0; i < fragmentSectorCount; ++i)
;|*** 		{
;|*** 			CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, SectorBuffer, GST_LB_SIZE);
;|*** 
;|*** 			uint64 s = HiddenVolumeStartUnitNo + sectorOffset + i;
;|*** 			EncryptDataUnits (SectorBuffer, &s, 1, BootCryptoInfo);
;|*** 
;|*** 			CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, GST_LB_SIZE);
;|*** 		} 
;|*** 
;|*** 		ReleaseSectorBuffer();
;|*** 
;|*** 		if (ReadWriteSectors (true, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, HiddenVolumeStartSector + sectorOffset, fragmentSectorCount, false) != BiosResultSuccess)
;|*** 		{
;|*** 			crypto_close (BootCryptoInfo);
;|*** 			goto err;
;|*** 		}
;|*** 
;|*** 		sectorsRemaining = sectorsRemaining - fragmentSectorCount;
;|*** 		sectorOffset = sectorOffset + fragmentSectorCount;
;|*** 
;|*** 		if (!(statCount++ & 0xf))
;|*** 		{
;|*** 			Print ("\rRemaining: ");
;|*** 			PrintSectorCountInMB (sectorsRemaining);
;|*** 		}
;|*** 	}
;|*** 
;|*** 	crypto_close (BootCryptoInfo);
;|*** 
;|*** 	if (sectorsRemaining.HighPart == 0 && sectorsRemaining.LowPart == 0)
;|*** 	{
;|*** 		status = true;
;|*** 		Print ("\rCopying completed.");
;|*** 	}
;|*** 
;|*** 	PrintEndl (2);
;|*** 	goto ret;
;|*** 
;|*** err:
; Line 820
					$err1692:
;|*** 	exitKey = GST_BIOS_KEY_ESC;
; Line 821
	*** 0002a3	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;exitKey
	*** 0002a6	c6 07 01 		mov	BYTE PTR [bx],1
;|*** 	GetKeyboardChar();
; Line 822
	*** 0002a9	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** 
;|*** ret:
; Line 824
					$ret1737:
;|*** 	EraseMemory ((void *) GST_BOOT_LOADER_ARGS_OFFSET, sizeof (BootArguments));
; Line 825
	*** 0002ac	6a 76 			push	118	;0076H
	*** 0002ae	6a 10 			push	16	;0010H
	*** 0002b0	e8 00 00 		call	_EraseMemory
	*** 0002b3	83 c4 04 		add	sp,4
;|*** 	return status;
; Line 826
	*** 0002b6	8a 46 fb 		mov	al,BYTE PTR [bp-5]	;status
;|*** }
; Line 827
					$EX1685:
	*** 0002b9	5e 			pop	si
	*** 0002ba	5f 			pop	di
	*** 0002bb	c9 			leave	
	*** 0002bc	c3 			ret	

?CopySystemPartitionToHiddenVolume@@YADEAAE@Z	ENDP
	PUBLIC	__acrtused
__acrtused	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** #else // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void DecryptDrive (byte drive)
;|***  *	\brief Decrypt the drive
;|***  *	\param[in] byte drive
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void DecryptDrive (byte drive)
;|*** {
;|*** 	byte exitKey;
;|*** 	if (!MountVolume (drive, exitKey, false, true))
;|*** 		return;
;|*** 
;|*** 	BootArguments *bootArguments = (BootArguments *) GST_BOOT_LOADER_ARGS_OFFSET;
;|*** 
;|*** 	bool headerUpdateRequired = false;
;|*** 	uint64 sectorsRemaining = EncryptedVirtualPartition.EndSector + 1 - EncryptedVirtualPartition.StartSector;
;|*** 	uint64 sector = EncryptedVirtualPartition.EndSector + 1;
;|*** 
;|*** 	int fragmentSectorCount = 0x7f; // Maximum safe value supported by BIOS
;|*** 	int statCount;
;|*** 
;|*** 	bool skipBadSectors = false;
;|*** 
;|*** 	Print ("\r\nUse only if Windows cannot start. Decryption under Windows is much faster\r\n"
;|*** 			"(in GostCrypt, select 'System' > 'Permanently Decrypt').\r\n\r\n");
;|*** 
;|*** 	if (!AskYesNo ("Decrypt now"))
;|*** 	{
;|*** 		crypto_close (BootCryptoInfo);
;|*** 		goto ret;
;|*** 	}
;|*** 
;|*** 	if (EncryptedVirtualPartition.Drive == GST_INVALID_BIOS_DRIVE)
;|*** 	{
;|*** 		// Drive already decrypted
;|*** 		sectorsRemaining.HighPart = 0;
;|*** 		sectorsRemaining.LowPart = 0;
;|*** 	}
;|*** 	else
;|*** 	{
;|*** 		Print ("\r\nTo safely interrupt and defer decryption, press Esc.\r\n"
;|*** 			"WARNING: You can turn off power only after you press Esc.\r\n\r\n");
;|*** 	}
;|*** 
;|*** 	while (sectorsRemaining.HighPart != 0 || sectorsRemaining.LowPart != 0)
;|*** 	{
;|*** 		if (EscKeyPressed())
;|*** 			break;
;|*** 
;|*** 		if (sectorsRemaining.HighPart == 0 && sectorsRemaining.LowPart < fragmentSectorCount)
;|*** 			fragmentSectorCount = (int) sectorsRemaining.LowPart;
;|*** 
;|*** 		sector = sector - fragmentSectorCount;
;|*** 
;|*** 		if (!(statCount++ & 0xf))
;|*** 		{
;|*** 			Print ("\rRemaining: ");
;|*** 			PrintSectorCountInMB (sectorsRemaining);
;|*** 		}
;|*** 
;|*** 		if (ReadWriteSectors (false, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, sector, fragmentSectorCount, skipBadSectors) == BiosResultSuccess)
;|*** 		{
;|*** 			AcquireSectorBuffer();
;|*** 
;|*** 			for (int i = 0; i < fragmentSectorCount; ++i)
;|*** 			{
;|*** 				CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, SectorBuffer, GST_LB_SIZE);
;|*** 
;|*** 				uint64 s = sector + i;
;|*** 				DecryptDataUnits (SectorBuffer, &s, 1, BootCryptoInfo);
;|*** 
;|*** 				CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, GST_LB_SIZE);
;|*** 			} 
;|*** 
;|*** 			ReleaseSectorBuffer();
;|*** 
;|*** 			if (ReadWriteSectors (true, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, sector, fragmentSectorCount, skipBadSectors) != BiosResultSuccess && !skipBadSectors)
;|*** 				goto askBadSectorSkip;
;|*** 		}
;|*** 		else if (!skipBadSectors)
;|*** 			goto askBadSectorSkip;
;|*** 
;|*** 		sectorsRemaining = sectorsRemaining - fragmentSectorCount;
;|*** 		headerUpdateRequired = true;
;|*** 		continue;
;|*** 
;|*** askBadSectorSkip:
;|*** 		if (!AskYesNo ("Skip all bad sectors"))
;|*** 			break;
;|*** 
;|*** 		skipBadSectors = true;
;|*** 		sector = sector + fragmentSectorCount;
;|*** 		fragmentSectorCount = 1;
;|*** 	}
;|*** 
;|*** 	crypto_close (BootCryptoInfo);
;|*** 
;|*** 	if (headerUpdateRequired)
;|*** 	{
;|*** 		AcquireSectorBuffer();
;|*** 		uint64 headerSector;
;|*** 		headerSector.HighPart = 0;
;|*** 		headerSector.LowPart = GST_BOOT_VOLUME_HEADER_SECTOR;
;|*** 
;|*** 		// Update encrypted area size in volume header
;|*** 
;|*** 		CRYPTO_INFO *headerCryptoInfo = crypto_open();
;|*** 		while (ReadSectors (SectorBuffer, drive, headerSector, 1) != BiosResultSuccess);
;|*** 
;|*** 		if (ReadVolumeHeader (TRUE, (char *) SectorBuffer, &bootArguments->BootPassword, NULL, headerCryptoInfo) == 0)
;|*** 		{
;|*** 			DecryptBuffer (SectorBuffer + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, headerCryptoInfo);
;|*** 
;|*** 			uint64 encryptedAreaLength = sectorsRemaining << GST_LB_SIZE_BIT_SHIFT_DIVISOR;
;|*** 
;|*** 			for (int i = 7; i >= 0; --i)
;|*** 			{
;|*** 				SectorBuffer[GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH + i] = (byte) encryptedAreaLength.LowPart;
;|*** 				encryptedAreaLength = encryptedAreaLength >> 8;
;|*** 			}
;|*** 
;|*** 			uint32 headerCrc32 = GetCrc32 (SectorBuffer + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC);
;|*** 
;|*** 			for (i = 3; i >= 0; --i)
;|*** 			{
;|*** 				SectorBuffer[GST_HEADER_OFFSET_HEADER_CRC + i] = (byte) headerCrc32;
;|*** 				headerCrc32 >>= 8;
;|*** 			}
;|*** 
;|*** 			EncryptBuffer (SectorBuffer + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, headerCryptoInfo);
;|*** 		}
;|*** 
;|*** 		crypto_close (headerCryptoInfo);
;|*** 
;|*** 		while (WriteSectors (SectorBuffer, drive, headerSector, 1) != BiosResultSuccess);
;|*** 		ReleaseSectorBuffer();
;|*** 	}
;|*** 
;|*** 	if (sectorsRemaining.HighPart == 0 && sectorsRemaining.LowPart == 0)
;|*** 		Print ("\rDrive decrypted.\r\n");
;|*** 	else
;|*** 		Print ("\r\nDecryption deferred.\r\n");
;|*** 
;|*** 	GetKeyboardChar();
;|*** ret:
;|*** 	EraseMemory (bootArguments, sizeof (*bootArguments));
;|*** }
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void RepairMenu ()
;|***  *	\brief When repair is pressed, print the repair menu and wait for instructions
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void RepairMenu ()
;|*** {
;|*** 	DriveGeometry bootLoaderDriveGeometry;
;|*** 
;|*** 	if (GetDriveGeometry (BootLoaderDrive, bootLoaderDriveGeometry, true) != BiosResultSuccess)
;|*** 	{
;|*** 		// Some BIOSes may fail to get the geometry of an emulated floppy drive
;|*** 		bootLoaderDriveGeometry.Cylinders = 80;
;|*** 		bootLoaderDriveGeometry.Heads = 2;
;|*** 		bootLoaderDriveGeometry.Sectors = 18;
;|*** 	}
;|*** 
;|*** 	while (true)
;|*** 	{
;|*** 		InitScreen();
;|*** 		Print ("Available "); Print ("Repair Options"); Print (":\r\n");
;|*** 		PrintRepeatedChar ('\xC4', 25);
;|*** 		PrintEndl();
;|*** 
;|*** 		enum
;|*** 		{
;|*** 			RestoreNone = 0,
;|*** 			DecryptVolume,
;|*** 			RestoreGostCryptLoader,
;|*** 			RestoreVolumeHeader,
;|*** 			RestoreOriginalSystemLoader
;|*** 		};
;|*** 
;|*** 		static const char *options[] = { "Permanently decrypt system partition/drive", "Restore GostCrypt Boot Loader", "Restore key data (volume header)", "Restore original system loader" };
;|*** 
;|*** 		int selection = AskSelection (options,
;|*** 			(BootSectorFlags & GST_BOOT_CFG_FLAG_RESCUE_DISK_ORIG_SYS_LOADER) ? array_capacity (options) : array_capacity (options) - 1);
;|*** 
;|*** 		PrintEndl();
;|*** 
;|*** 		switch (selection)
;|*** 		{
;|*** 			case RestoreNone:
;|*** 				return;
;|*** 
;|*** 			case DecryptVolume:
;|*** 				DecryptDrive (BootDrive);
;|*** 				continue;
;|*** 
;|*** 			case RestoreOriginalSystemLoader:
;|*** 				if (!AskYesNo ("Is the system partition/drive decrypted"))
;|*** 				{
;|*** 					Print ("Please decrypt it first.\r\n");
;|*** 					GetKeyboardChar();
;|*** 					continue;
;|*** 				}
;|*** 				break;
;|*** 		}
;|*** 
;|*** 		bool writeConfirmed = false;
;|*** 		BiosResult result;
;|*** 
;|*** 		uint64 sector;
;|*** 		sector.HighPart = 0;
;|*** 		ChsAddress chs;
;|*** 
;|*** 		byte mbrPartTable[GST_LB_SIZE - GST_MAX_MBR_BOOT_CODE_SIZE];
;|*** 		AcquireSectorBuffer();
;|*** 
;|*** 		for (int i = (selection == RestoreVolumeHeader ? GST_BOOT_VOLUME_HEADER_SECTOR : GST_MBR_SECTOR);
;|*** 			i < GST_BOOT_LOADER_AREA_SECTOR_COUNT; ++i)
;|*** 		{
;|*** 			sector.LowPart = i;
;|*** 
;|*** 			if (selection == RestoreOriginalSystemLoader)
;|*** 				sector.LowPart += GST_ORIG_BOOT_LOADER_BACKUP_SECTOR;
;|*** 			else if (selection == RestoreGostCryptLoader)
;|*** 				sector.LowPart += GST_BOOT_LOADER_BACKUP_RESCUE_DISK_SECTOR;
;|*** 
;|*** 			// The backup medium may be a floppy-emulated bootable CD. The emulation may fail if LBA addressing is used.
;|*** 			// Therefore, only CHS addressing can be used.
;|*** 			LbaToChs (bootLoaderDriveGeometry, sector, chs);
;|*** 			sector.LowPart = i;
;|*** 
;|*** 			if (i == GST_MBR_SECTOR)
;|*** 			{
;|*** 				// Read current partition table
;|*** 				result = ReadSectors (SectorBuffer, GST_FIRST_BIOS_DRIVE, sector, 1);
;|*** 				if (result != BiosResultSuccess)
;|*** 					goto err;
;|*** 
;|*** 				memcpy (mbrPartTable, SectorBuffer + GST_MAX_MBR_BOOT_CODE_SIZE, sizeof (mbrPartTable));
;|*** 			}
;|*** 
;|*** 			result = ReadSectors (SectorBuffer, BootLoaderDrive, chs, 1);
;|*** 			if (result != BiosResultSuccess)
;|*** 				goto err;
;|*** 
;|*** 			if (i == GST_MBR_SECTOR)
;|*** 			{
;|*** 				// Preserve current partition table
;|*** 				memcpy (SectorBuffer + GST_MAX_MBR_BOOT_CODE_SIZE, mbrPartTable, sizeof (mbrPartTable));
;|*** 			}
;|*** 
;|*** 			// Volume header
;|*** 			if (i == GST_BOOT_VOLUME_HEADER_SECTOR)
;|*** 			{
;|*** 				if (selection == RestoreGostCryptLoader)
;|*** 					continue;
;|*** 
;|*** 				if (selection == RestoreVolumeHeader)
;|*** 				{
;|*** 					while (true)
;|*** 					{
;|*** 						bool validHeaderPresent = false;
;|*** 						uint32 masterKeyScheduleCrc;
;|*** 
;|*** 						Password password;
;|*** 						byte exitKey = AskPassword (password);
;|*** 
;|*** 						if (exitKey != GST_BIOS_KEY_ENTER)
;|*** 							goto abort;
;|*** 
;|*** 						CRYPTO_INFO *cryptoInfo;
;|*** 
;|*** 						CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, GST_LB_SIZE);
;|*** 						ReleaseSectorBuffer();
;|*** 
;|*** 						// Restore volume header only if the current one cannot be used
;|*** 						if (OpenVolume (GST_FIRST_BIOS_DRIVE, password, &cryptoInfo, nullptr, false, true))
;|*** 						{
;|*** 							validHeaderPresent = true;
;|*** 							masterKeyScheduleCrc = GetCrc32 (cryptoInfo->ks, sizeof (cryptoInfo->ks));
;|*** 							crypto_close (cryptoInfo);
;|*** 						}
;|*** 
;|*** 						AcquireSectorBuffer();
;|*** 						CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, 0, SectorBuffer, GST_LB_SIZE);
;|*** 
;|*** 						if (ReadVolumeHeader (TRUE, (char *) SectorBuffer, &password, &cryptoInfo, nullptr) == 0)
;|*** 						{
;|*** 							if (validHeaderPresent)
;|*** 							{
;|*** 								if (masterKeyScheduleCrc == GetCrc32 (cryptoInfo->ks, sizeof (cryptoInfo->ks)))
;|*** 								{
;|*** 									Print ("Original header preserved.\r\n");
;|*** 									goto err;
;|*** 								}
;|*** 
;|*** 								Print ("WARNING: Drive 0 contains a valid header!\r\n");
;|*** 							}
;|*** 
;|*** 							crypto_close (cryptoInfo);
;|*** 							break;
;|*** 						}
;|*** 
;|*** 						Print ("Incorrect password.\r\n\r\n");
;|*** 					}
;|*** 				}
;|*** 			}
;|*** 
;|*** 			if (!writeConfirmed && !AskYesNo ("Modify drive 0"))
;|*** 				goto abort;
;|*** 			writeConfirmed = true;
;|*** 
;|*** 			if (WriteSectors (SectorBuffer, GST_FIRST_BIOS_DRIVE, sector, 1) != BiosResultSuccess)
;|*** 				goto err;
;|*** 		}
;|*** done:
;|*** 		switch (selection)
;|*** 		{
;|*** 		case RestoreGostCryptLoader:
;|*** 			Print ("GostCrypt Boot Loader");
;|*** 			break;
;|*** 
;|*** 		case RestoreVolumeHeader:
;|*** 			Print ("Header");
;|*** 			break;
;|*** 
;|*** 		case RestoreOriginalSystemLoader:
;|*** 			Print ("System loader");
;|*** 			break;
;|*** 		}
;|*** 		Print (" restored.\r\n");
;|*** 
;|*** err:	GetKeyboardChar();
;|*** abort:	ReleaseSectorBuffer();
;|*** 	}
;|*** }
;|*** 
;|*** #endif // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 
;|*** #ifndef DEBUG
;|*** /**
;|***  *
;|***  *	\fn extern "C" void _acrtused ()
;|***  *	\brief Required by linker
;|***  *	\return void
;|***  *
;|***  */
;|*** extern "C" void _acrtused () { }  // Required by linker
; Line 1187
	*** 000000	c3 			ret	

__acrtused	ENDP
	PUBLIC	_main
_main	PROC NEAR	;  COMDAT
;|*** #endif
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void main ()
;|***  *	\brief Initialize video mode and screen, determine boot drive and its geometry and print the main menu
;|***  *	\return void
;|***  *
;|***  */
;|*** void main ()
;|*** {
; Line 1198
	*** 000000	c8 04 00 00 		enter	4,0
;|*** 	__asm mov BootLoaderDrive, dl
; Line 1199
	*** 000004	88 16 00 00 		mov	BYTE PTR ?BootLoaderDrive@@3EA,dl	;BootLoaderDrive
;|*** 	__asm mov BootSectorFlags, dh
; Line 1200
	*** 000008	88 36 00 00 		mov	BYTE PTR ?BootSectorFlags@@3EA,dh	;BootSectorFlags
;|*** 
;|*** #ifdef GST_BOOT_TRACING_ENABLED
;|*** 	InitDebugPort();
;|*** #endif
;|*** 
;|*** #ifdef GST_BOOT_STACK_CHECKING_ENABLED
;|*** 	InitStackChecker();
;|*** #endif
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 	ReadBootSectorUserConfiguration();
; Line 1211
	*** 00000c	e8 00 00 		call	?ReadBootSectorUserConfiguration@@YAXXZ	; ReadBootSectorUserConfiguration
;|*** #endif
;|*** 
;|*** 	InitVideoMode();
; Line 1214
	*** 00000f	e8 00 00 		call	?InitVideoMode@@YAXXZ	; InitVideoMode
;|*** 	InitScreen();
; Line 1215
	*** 000012	e8 00 00 		call	?InitScreen@@YAXXZ	; InitScreen
;|*** 
;|*** 	// Determine boot drive
;|*** 	BootDrive = BootLoaderDrive;
;|*** 	if (BootDrive < GST_FIRST_BIOS_DRIVE)
; Line 1219
	*** 000015	a0 00 00 		mov	al,BYTE PTR ?BootLoaderDrive@@3EA	;BootLoaderDrive
	*** 000018	a2 00 00 		mov	BYTE PTR ?BootDrive@@3EA,al	;BootDrive
	*** 00001b	3c 80 			cmp	al,128	;0080H
	*** 00001d	73 05 			jae	SHORT $I1747
;|*** 		BootDrive = GST_FIRST_BIOS_DRIVE;
; Line 1220
	*** 00001f	c6 06 00 00 80 		mov	BYTE PTR ?BootDrive@@3EA,128	;0080H	;BootDrive
;|*** 
;|*** 	// Query boot drive geometry
;|*** 	if (GetDriveGeometry (BootDrive, BootDriveGeometry) != BiosResultSuccess)
; Line 1223
					$I1747:
	*** 000024	6a 00 			push	0
	*** 000026	68 00 00 		push	OFFSET ?BootDriveGeometry@@3UDriveGeometry@@A	;BootDriveGeometry
	*** 000029	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 00002c	50 			push	ax
	*** 00002d	e8 00 00 		call	?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z	; GetDriveGeometry
	*** 000030	83 c4 06 		add	sp,6
	*** 000033	0a c0 			or	al,al
	*** 000035	74 1a 			je	SHORT $I1748
;|*** 	{
;|*** 		BootDrive = GST_FIRST_BIOS_DRIVE;
;|*** 		if (GetDriveGeometry (BootDrive, BootDriveGeometry) != BiosResultSuccess)
; Line 1226
	*** 000037	6a 00 			push	0
	*** 000039	68 00 00 		push	OFFSET ?BootDriveGeometry@@3UDriveGeometry@@A	;BootDriveGeometry
	*** 00003c	b0 80 			mov	al,128	;0080H
	*** 00003e	a2 00 00 		mov	BYTE PTR ?BootDrive@@3EA,al	;BootDrive
	*** 000041	50 			push	ax
	*** 000042	e8 00 00 		call	?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z	; GetDriveGeometry
	*** 000045	83 c4 06 		add	sp,6
	*** 000048	0a c0 			or	al,al
	*** 00004a	74 05 			je	SHORT $I1748
;|*** 		{
;|*** #ifdef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 			Print ("- Connect system drive to (SATA) port 1\r\n");
;|*** #endif
;|*** 			GetKeyboardChar();
; Line 1231
	*** 00004c	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** 		}
;|*** 		else
; Line 1233
	*** 00004f	eb 05 			jmp	SHORT $I1751
					$I1748:
;|*** 			BootDriveGeometryValid = true;
;|*** 	}
;|*** 	else
;|*** 		BootDriveGeometryValid = true;
; Line 1237
	*** 000051	c6 06 00 00 01 		mov	BYTE PTR ?BootDriveGeometryValid@@3DA,1	;BootDriveGeometryValid
					$I1751:
;|*** 
;|*** #ifdef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 	// Check whether the user is not using the Rescue Disk to create a hidden system
;|*** 
;|*** 	if (ReadWriteMBR (false, BootDrive, true) == BiosResultSuccess
;|*** 		&& *(uint32 *) (SectorBuffer + 6) == 0x65757254
;|*** 		&& *(uint32 *) (SectorBuffer + 10) == 0x70797243
;|*** 		&& (SectorBuffer[GST_BOOT_SECTOR_CONFIG_OFFSET] & GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE) != GST_HIDDEN_OS_CREATION_PHASE_NONE)
;|*** 	{
;|*** 		PrintError ("It appears you are creating a hidden OS.");
;|*** 		if (AskYesNo ("Is this correct"))
;|*** 		{
;|*** 			Print ("Please remove the Rescue Disk from the drive and restart.");
;|*** 			while (true);
;|*** 		}
;|*** 	}
;|*** 
;|*** #endif // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 
;|*** 	// Main menu
;|*** 
;|*** 	while (true)
;|*** 	{
; Line 1262
;	exitKey = -2
;	hiddenSystemCreationPhase = -4
;|*** 		byte exitKey;
;|*** 		InitScreen();
; Line 1264
	*** 000056	e8 00 00 		call	?InitScreen@@YAXXZ	; InitScreen
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 		// Hidden system setup
;|*** 		byte hiddenSystemCreationPhase = BootSectorFlags & GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE;
;|*** 
;|*** 		if (hiddenSystemCreationPhase != GST_HIDDEN_OS_CREATION_PHASE_NONE)
; Line 1271
	*** 000059	a0 00 00 		mov	al,BYTE PTR ?BootSectorFlags@@3EA	;BootSectorFlags
	*** 00005c	24 c0 			and	al,192	;00c0H
	*** 00005e	88 46 fc 		mov	BYTE PTR [bp-4],al	;hiddenSystemCreationPhase
	*** 000061	0a c0 			or	al,al
	*** 000063	74 3c 			je	SHORT $I1757
;|*** 		{
;|*** 			PreventNormalSystemBoot = true;
; Line 1273
	*** 000065	c6 06 00 00 01 		mov	BYTE PTR ?PreventNormalSystemBoot@@3DA,1	;PreventNormalSystemBoot
;|*** 			PrintMainMenu();
; Line 1274
	*** 00006a	e8 00 00 		call	?PrintMainMenu@@YAXXZ	; PrintMainMenu
;|*** 
;|*** 			if (hiddenSystemCreationPhase == GST_HIDDEN_OS_CREATION_PHASE_CLONING)
; Line 1276
	*** 00006d	80 7e fc 40 		cmp	BYTE PTR [bp-4],64	;0040H	;hiddenSystemCreationPhase
	*** 000071	75 31 			jne	SHORT $I1765
;|*** 			{
;|*** 				if (CopySystemPartitionToHiddenVolume (BootDrive, exitKey))
; Line 1278
	*** 000073	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;exitKey
	*** 000076	50 			push	ax
	*** 000077	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 00007a	50 			push	ax
	*** 00007b	e8 00 00 		call	?CopySystemPartitionToHiddenVolume@@YADEAAE@Z	; CopySystemPartitionToHiddenVolume
	*** 00007e	83 c4 04 		add	sp,4
	*** 000081	0a c0 			or	al,al
	*** 000083	74 14 			je	SHORT $I1759
;|*** 				{
;|*** 					BootSectorFlags = (BootSectorFlags & ~GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE) | GST_HIDDEN_OS_CREATION_PHASE_WIPING;
; Line 1280
	*** 000085	a0 00 00 		mov	al,BYTE PTR ?BootSectorFlags@@3EA	;BootSectorFlags
	*** 000088	24 3f 			and	al,63	;003fH
	*** 00008a	0c 80 			or	al,128	;0080H
	*** 00008c	a2 00 00 		mov	BYTE PTR ?BootSectorFlags@@3EA,al	;BootSectorFlags
;|*** 					UpdateBootSectorConfiguration (BootLoaderDrive);
; Line 1281
	*** 00008f	a0 00 00 		mov	al,BYTE PTR ?BootLoaderDrive@@3EA	;BootLoaderDrive
	*** 000092	50 			push	ax
	*** 000093	e8 00 00 		call	?UpdateBootSectorConfiguration@@YAEE@Z	; UpdateBootSectorConfiguration
	*** 000096	5b 			pop	bx
;|*** 				}
;|*** 				else if (exitKey == GST_BIOS_KEY_ESC)
;|*** 					goto bootMenu;
;|*** 				else
;|*** 					continue;
;|*** 			}
;|*** 		}
;|*** 		else
; Line 1289
	*** 000097	eb 0b 			jmp	SHORT $I1765
					$I1759:
	*** 000099	80 7e fe 01 		cmp	BYTE PTR [bp-2],1	;exitKey
	*** 00009d	75 b7 			jne	SHORT $I1751
;|*** 					goto bootMenu;
; Line 1284
	*** 00009f	eb 09 			jmp	SHORT $bootMenu1762
					$I1757:
;|*** 				else
;|*** 					continue;
;|*** 			}
;|*** 		}
;|*** 		else
;|*** 			PrintMainMenu();
; Line 1290
	*** 0000a1	e8 00 00 		call	?PrintMainMenu@@YAXXZ	; PrintMainMenu
					$I1765:
;|*** 
;|*** 		exitKey = BootEncryptedDrive();
; Line 1292
	*** 0000a4	e8 00 00 		call	?BootEncryptedDrive@@YAEXZ	; BootEncryptedDrive
	*** 0000a7	88 46 fe 		mov	BYTE PTR [bp-2],al	;exitKey
;|*** 
;|*** #else // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 		
;|*** 		PrintMainMenu();
;|*** 		exitKey = BootEncryptedDrive();
;|*** 
;|*** 		if (exitKey == GST_MENU_KEY_REPAIR)
;|*** 		{
;|*** 			RepairMenu();
;|*** 			continue;
;|*** 		}
;|*** 
;|*** #endif // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** bootMenu:
; Line 1307
					$bootMenu1762:
;|*** 		if (!PreventBootMenu)
; Line 1308
	*** 0000aa	80 3e 00 00 00 		cmp	BYTE PTR ?PreventBootMenu@@3DA,0	;PreventBootMenu
	*** 0000af	75 a5 			jne	SHORT $I1751
;|*** 			BootMenu();
; Line 1309
	*** 0000b1	e8 00 00 		call	?BootMenu@@YAXXZ	; BootMenu
;|*** 	}
; Line 1310
	*** 0000b4	eb a0 			jmp	SHORT $I1751

_main	ENDP
_TEXT	ENDS
END
;|*** }
