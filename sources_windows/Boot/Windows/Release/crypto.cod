;	Static Name Aliases
;
;	$S1033_CryptoInfoBufferInUse	EQU	CryptoInfoBufferInUse
;	$S787_Ciphers	EQU	Ciphers
;	$S790_EncryptionAlgorithms	EQU	EncryptionAlgorithms
;	$S791_Hashes	EQU	Hashes
	TITLE   ..\..\..\common\crypto.c
	.MODEL  SMALL
	.386p
	.387
_TEXT	SEGMENT  WORD USE16 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD USE16 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD USE16 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD USE16 PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ??_C@_0O@NADH@GOST?528147?989?$AA@
PUBLIC  ??_C@_0BB@EHBL@Gost?5Grasshopper?$AA@
PUBLIC  ??_C@_0BC@JHLA@GOST?5R?534?411?92012?$AA@
PUBLIC  ??_C@_0BA@HHFE@GOST?5R?534?411?994?$AA@
PUBLIC  ??_C@_09FKOH@Whirlpool?$AA@
EXTRN	_grasshopper_decrypt:NEAR
EXTRN	_gost_decrypt:NEAR
EXTRN	_gost_set_key:NEAR
EXTRN	_grasshopper_xor_ks:NEAR
EXTRN	_gost_xor_ks:NEAR
EXTRN	_DecryptBufferXTS8Byte:NEAR
EXTRN	__aNlshl:NEAR
EXTRN	_EncryptBufferXTS8Byte:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_DecryptBufferXTS:NEAR
EXTRN	_ThrowFatalException:NEAR
EXTRN	_strcmp:NEAR
EXTRN	_grasshopper_set_key:NEAR
EXTRN	_EncryptBufferXTS:NEAR
EXTRN	_EraseMemory:NEAR
EXTRN	_grasshopper_encrypt:NEAR
EXTRN	_gost_encrypt:NEAR
_BSS      SEGMENT
COMM NEAR	_CryptoInfoBuffer:	BYTE:	 1122
_BSS      ENDS
_DATA      SEGMENT
??_C@_0O@NADH@GOST?528147?989?$AA@	DB	'GOST 28147-89',  00H
	ORG	$-14
??_C@_0BB@EHBL@Gost?5Grasshopper?$AA@	DB	'Gost Grasshopper',  00H
	ORG	$-17
$S787_Ciphers	DW	01H
	DW	DGROUP:??_C@_0O@NADH@GOST?528147?989?$AA@
	DW	08H
	DW	020H
	DW	0220H
	DW	02H
	DW	DGROUP:??_C@_0BB@EHBL@Gost?5Grasshopper?$AA@
	DW	010H
	DW	020H
	DW	0a0H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
$S790_EncryptionAlgorithms	DW	00H
	DW	00H
 	DB	4 DUP(0)

	DW	00H
	DW	00H
 	DB	2 DUP(0)

	DW	00H
	DW	01H
	DW	00H
 	DB	4 DUP(0)

	DW	02H
	DW	00H
 	DB	2 DUP(0)

	DW	01H
	DW	02H
	DW	00H
 	DB	4 DUP(0)

	DW	01H
	DW	00H
 	DB	2 DUP(0)

	DW	01H
	DW	00H
	DW	00H
 	DB	4 DUP(0)

	DW	00H
	DW	00H
 	DB	2 DUP(0)

	DW	00H
	ORG	$-94
??_C@_0BC@JHLA@GOST?5R?534?411?92012?$AA@	DB	'GOST R 34.11-2012',  00H
	ORG	$-18
??_C@_0BA@HHFE@GOST?5R?534?411?994?$AA@	DB	'GOST R 34.11-94',  00H
	ORG	$-16
??_C@_09FKOH@Whirlpool?$AA@	DB	'Whirlpool',  00H
	ORG	$+84
$S791_Hashes	DW	01H
	DW	DGROUP:??_C@_0BC@JHLA@GOST?5R?534?411?92012?$AA@
	DB	00H
	DB	01H
	DW	02H
	DW	DGROUP:??_C@_0BA@HHFE@GOST?5R?534?411?994?$AA@
	DB	00H
	DB	00H
	DW	03H
	DW	DGROUP:??_C@_09FKOH@Whirlpool?$AA@
	DB	00H
	DB	00H
	DW	00H
	DW	00H
	DB	00H
 	DB	1 DUP(0)

$S1033_CryptoInfoBufferInUse	DB	00H
_DATA      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	PUBLIC	_CipherInit
_CipherInit	PROC NEAR	;  COMDAT
;|*** /**
;|***  *
;|***  *	\file Crypto.c
;|***  *	\brief Used for encryption and decryption (cipher, keys...)
;|***  *	\version 1.3.1
;|***  *	\date 15/12/2016
;|***  *
;|***  */
;|*** 
;|*** /**
;|***  *	Legal Notice: Some portions of the source code contained in this file were
;|***  *	derived from the source code of Encryption for the Masses 2.02a, which is
;|***  *	Copyright (c) 1998-2000 Paul Le Roux and which is governed by the 'License
;|***  *	Agreement for Encryption for the Masses'. Modifications and additions to
;|***  *	the original source code (contained in this file) and all other portions
;|***  *	of this file are Copyright (c) 2003-2010 TrueCrypt Developers Association
;|***  *	and are governed by the TrueCrypt License 3.0 the full text of which is
;|***  *	contained in the file License.txt included in TrueCrypt binary and source
;|***  *	code distribution packages. 
;|***  */
;|*** 
;|*** #include "Gstdefs.h"
;|*** #include "Crypto.h"
;|*** #include "Xts.h"
;|*** #include "Crc.h"
;|*** #include "Common/Endian.h"
;|*** #include <string.h>
;|*** #ifndef GST_WINDOWS_BOOT
;|*** #include "EncryptionThreadPool.h"
;|*** #endif
;|*** #include "Volumes.h"
;|*** 
;|*** /* Update the following when adding a new cipher or EA:
;|*** 
;|***    Crypto.h:
;|***      ID #define
;|***      MAX_EXPANDED_KEY #define
;|*** 
;|***    Crypto.c:
;|***      Ciphers[]
;|***      EncryptionAlgorithms[]
;|***      CipherInit()
;|***      EncipherBlock()
;|***      DecipherBlock()
;|*** 
;|*** */
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_SINGLE_CIPHER_MODE
;|*** 
;|*** // Cipher configuration
;|*** static Cipher Ciphers[] =
;|*** {
;|*** //								Block Size	Key Size	Key Schedule Size
;|*** //	  ID		Name			(Bytes)		(Bytes)		(Bytes)
;|*** 	{ GOST,     "GOST 28147-89",         8,         32,         GOST_KS           },
;|*** 	{ GRASSHOPPER, "Gost Grasshopper",   16,        32,         GRASSHOPPER_KS    },
;|*** 	{ 0,		0,				0,			0,			0					}
;|*** };
;|*** 
;|*** 
;|*** // Encryption algorithm configuration
;|*** static EncryptionAlgorithm EncryptionAlgorithms[] =
;|*** {
;|*** 	//  Cipher(s)                     Modes						FormatEnabled
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT
;|*** 
;|*** 	{ { 0,						0 },	{ 0, 0 },				0 },	// Must be all-zero
;|*** 	{ { GOST,					0 },	{ XTS8, 0 }, 1 },
;|*** 	{ { GRASSHOPPER,			0 },	{ XTS, 0 }, 1 },
;|*** 	{ { 0,						0 },	{ 0, 0 },				0 }		// Must be all-zero
;|*** 
;|*** #else // GST_WINDOWS_BOOT
;|*** 
;|*** 	// Encryption algorithms available for boot drive encryption
;|*** 	{ { 0,						0 }, { 0, 0 },		0 },	// Must be all-zero
;|*** 	{ { GOST,               0 }, { XTS8, 0 },  1 },
;|*** 	{ { GRASSHOPPER,        0 }, { XTS, 0 }, 1 },
;|*** 	{ { 0,						0 }, { 0, 0 },		0 },	// Must be all-zero
;|*** 
;|*** #endif
;|*** 
;|*** };
;|*** 
;|*** 
;|*** 
;|*** // Hash algorithms
;|*** static Hash Hashes[] =
;|*** {	// ID			Name			Deprecated		System Encryption
;|*** 	{ STRIBOG,		"GOST R 34.11-2012", FALSE,	TRUE },
;|*** 	{ GOSTHASH,		"GOST R 34.11-94",	FALSE,	FALSE },
;|*** 	{ WHIRLPOOL,	"Whirlpool",			FALSE,	FALSE },
;|*** 	{ 0, 0, 0 }
;|*** };
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int CipherInit (int cipher, unsigned char *key, unsigned __int8 *ks)
;|***  *	\brief Initialise cipher
;|***  *			Return values: 0 = success, ERR_CIPHER_INIT_FAILURE (fatal), ERR_CIPHER_INIT_WEAK_KEY (non-fatal)
;|***  *	\param[in] unsigned __int8* ks
;|***  *	\param[in] unsigned char* key
;|***  *	\param[in] int cipher
;|***  *	\return int 0 if success
;|***  *			ERR_CIPHER_INIT_FAILURE if unknown/wrong cipher ID (fatal)
;|***  *			ERR_CIPHER_INIT_WEAK_KEY (non-fatal)
;|***  *
;|***  */
;|*** int CipherInit (int cipher, unsigned char *key, unsigned __int8 *ks)
;|*** {
; Line 110
	*** 000000	c8 02 00 00 		enter	2,0
;	cipher = 4
;	key = 6
;	ks = 8
;	retVal = -2
;|*** 	int retVal = ERR_SUCCESS;
;|*** 
;|*** 	switch (cipher)
; Line 113
	*** 000004	8b 46 04 		mov	ax,WORD PTR [bp+4]	;cipher
;|*** 	{
;|*** 	case GOST:
;|*** 		gost_set_key(key, (gost_kds *)ks);
;|*** 		break;
;|*** 	case GRASSHOPPER:
;|*** 		grasshopper_set_key((unsigned long *)key, (grasshopper_kds*)ks);
;|*** 		break;
;|*** 	default:
;|*** 		// Unknown/wrong cipher ID
;|*** 		return ERR_CIPHER_INIT_FAILURE;
;|*** 	}
; Line 124
	*** 000007	48 			dec	ax
	*** 000008	74 08 			je	SHORT $SC807
	*** 00000a	48 			dec	ax
	*** 00000b	74 0e 			je	SHORT $SC808
;|*** 		return ERR_CIPHER_INIT_FAILURE;
; Line 123
	*** 00000d	b8 11 00 		mov	ax,17	;0011H
	*** 000010	c9 			leave	
	*** 000011	c3 			ret	
;|*** 	case GOST:
; Line 115
					$SC807:
;|*** 		gost_set_key(key, (gost_kds *)ks);
; Line 116
	*** 000012	66 ff 76 06 		push	DWORD PTR [bp+6]	;key
	*** 000016	e8 00 00 		call	_gost_set_key
	*** 000019	eb 07 			jmp	SHORT $L1206
;|*** 		break;
;|*** 	case GRASSHOPPER:
; Line 118
					$SC808:
;|*** 		grasshopper_set_key((unsigned long *)key, (grasshopper_kds*)ks);
; Line 119
	*** 00001b	66 ff 76 06 		push	DWORD PTR [bp+6]	;key
	*** 00001f	e8 00 00 		call	_grasshopper_set_key
					$L1206:
;|*** 		break;
;|*** 	default:
;|*** 		// Unknown/wrong cipher ID
;|*** 		return ERR_CIPHER_INIT_FAILURE;
;|*** 	}
;|*** 
;|*** 	return retVal;
; Line 126
	*** 000022	33 c0 			xor	ax,ax
;|*** }
; Line 127
	*** 000024	c9 			leave	
	*** 000025	c3 			ret	

_CipherInit	ENDP
	PUBLIC	_EncipherBlock
_EncipherBlock	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncipherBlock(int cipher, void *data, void *ks)
;|***  *	\brief Encipher one block
;|***  *	\param[in] void * ks
;|***  *	\param[in] void * data
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncipherBlock(int cipher, void *data, void *ks)
;|*** {
; Line 140
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	56 			push	si
;	cipher = 4
;	data = 6
;	ks = 8
;|*** 	switch (cipher)
; Line 141
	*** 000004	8b 46 04 		mov	ax,WORD PTR [bp+4]	;cipher
;|*** 	{
;|*** 	case GOST:
;|*** 		gost_encrypt((byte *)data, (byte *)data, ks);
;|*** 		break;
;|*** 	case GRASSHOPPER:
;|*** 		grasshopper_encrypt(ks, (unsigned long *)data, (unsigned long *)data);
;|*** 		break;
;|*** 	default:			GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID
;|*** 	}
; Line 150
	*** 000007	48 			dec	ax
	*** 000008	74 0d 			je	SHORT $SC821
	*** 00000a	48 			dec	ax
	*** 00000b	74 17 			je	SHORT $SC822
;|*** 	default:			GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID
; Line 149
	*** 00000d	68 95 00 		push	149	;0095H
	*** 000010	e8 00 00 		call	_ThrowFatalException
	*** 000013	5b 			pop	bx
;|*** 	}
; Line 150
	*** 000014	5e 			pop	si
	*** 000015	c9 			leave	
	*** 000016	c3 			ret	
;|*** 	case GOST:
; Line 143
					$SC821:
	*** 000017	8b 76 06 		mov	si,WORD PTR [bp+6]	;data
;|*** 		gost_encrypt((byte *)data, (byte *)data, ks);
; Line 144
	*** 00001a	ff 76 08 		push	WORD PTR [bp+8]	;ks
	*** 00001d	56 			push	si
	*** 00001e	56 			push	si
	*** 00001f	e8 00 00 		call	_gost_encrypt
	*** 000022	eb 0b 			jmp	SHORT $L1207
;|*** 		break;
;|*** 	case GRASSHOPPER:
; Line 146
					$SC822:
	*** 000024	8b 76 06 		mov	si,WORD PTR [bp+6]	;data
;|*** 		grasshopper_encrypt(ks, (unsigned long *)data, (unsigned long *)data);
; Line 147
	*** 000027	56 			push	si
	*** 000028	56 			push	si
	*** 000029	ff 76 08 		push	WORD PTR [bp+8]	;ks
	*** 00002c	e8 00 00 		call	_grasshopper_encrypt
					$L1207:
	*** 00002f	83 c4 06 		add	sp,6
;|*** 		break;
;|*** 	default:			GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID
;|*** 	}
;|*** }
; Line 151
	*** 000032	5e 			pop	si
	*** 000033	c9 			leave	
	*** 000034	c3 			ret	

_EncipherBlock	ENDP
	PUBLIC	_DecipherBlock
_DecipherBlock	PROC NEAR	;  COMDAT
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncipherBlocks (int cipher, void *dataPtr, void *ks, size_t blockCount)
;|***  *	\brief Encipher blocks
;|***  *	\param[in] size_t blockCount
;|***  *	\param[in] void * ks
;|***  *	\param[in] void * dataPtr
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncipherBlocks (int cipher, void *dataPtr, void *ks, size_t blockCount)
;|*** {
;|*** 	byte *data = dataPtr;
;|*** 	size_t blockSize = CipherGetBlockSize (cipher);
;|*** 	while (blockCount-- > 0)
;|*** 	{
;|*** 		EncipherBlock (cipher, data, ks);
;|*** 		data += blockSize;
;|*** 	}
;|*** }
;|*** 
;|*** #endif // !GST_WINDOWS_BOOT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecipherBlock(int cipher, void *data, void *ks)
;|***  *	\brief Decipher one block
;|***  *	\param[in] void * ks
;|***  *	\param[in] void * data
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecipherBlock(int cipher, void *data, void *ks)
;|*** {
; Line 190
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	56 			push	si
;	cipher = 4
;	data = 6
;	ks = 8
;|*** 	switch (cipher)
; Line 191
	*** 000004	8b 46 04 		mov	ax,WORD PTR [bp+4]	;cipher
;|*** 	{
;|*** 	case GOST:
;|*** 		gost_decrypt((byte *)data, (byte *)data, ks);
;|*** 		break;
;|*** 	case GRASSHOPPER:
;|*** 		grasshopper_decrypt(ks, (unsigned long*)data, (unsigned long*)data);
;|*** 		break;
;|*** 	default:		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID
;|*** 	}
; Line 200
	*** 000007	48 			dec	ax
	*** 000008	74 0d 			je	SHORT $SC835
	*** 00000a	48 			dec	ax
	*** 00000b	74 17 			je	SHORT $SC836
;|*** 	default:		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID
; Line 199
	*** 00000d	68 c7 00 		push	199	;00c7H
	*** 000010	e8 00 00 		call	_ThrowFatalException
	*** 000013	5b 			pop	bx
;|*** 	}
; Line 200
	*** 000014	5e 			pop	si
	*** 000015	c9 			leave	
	*** 000016	c3 			ret	
;|*** 	case GOST:
; Line 193
					$SC835:
	*** 000017	8b 76 06 		mov	si,WORD PTR [bp+6]	;data
;|*** 		gost_decrypt((byte *)data, (byte *)data, ks);
; Line 194
	*** 00001a	ff 76 08 		push	WORD PTR [bp+8]	;ks
	*** 00001d	56 			push	si
	*** 00001e	56 			push	si
	*** 00001f	e8 00 00 		call	_gost_decrypt
	*** 000022	eb 0b 			jmp	SHORT $L1208
;|*** 		break;
;|*** 	case GRASSHOPPER:
; Line 196
					$SC836:
	*** 000024	8b 76 06 		mov	si,WORD PTR [bp+6]	;data
;|*** 		grasshopper_decrypt(ks, (unsigned long*)data, (unsigned long*)data);
; Line 197
	*** 000027	56 			push	si
	*** 000028	56 			push	si
	*** 000029	ff 76 08 		push	WORD PTR [bp+8]	;ks
	*** 00002c	e8 00 00 		call	_grasshopper_decrypt
					$L1208:
	*** 00002f	83 c4 06 		add	sp,6
;|*** 		break;
;|*** 	default:		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID
;|*** 	}
;|*** }
; Line 201
	*** 000032	5e 			pop	si
	*** 000033	c9 			leave	
	*** 000034	c3 			ret	

_DecipherBlock	ENDP
	PUBLIC	_CipherGet
_CipherGet	PROC NEAR	;  COMDAT
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecipherBlocks (int cipher, void *dataPtr, void *ks, size_t blockCount)
;|***  *	\brief Decipher blocks
;|***  *	\param[in] size_t blockCount
;|***  *	\param[in] void * ks
;|***  *	\param[in] void * dataPtr
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecipherBlocks (int cipher, void *dataPtr, void *ks, size_t blockCount)
;|*** {
;|*** 	byte *data = dataPtr;
;|*** 	size_t blockSize = CipherGetBlockSize (cipher);
;|*** 	while (blockCount-- > 0)
;|*** 	{
;|*** 		DecipherBlock (cipher, data, ks);
;|*** 		data += blockSize;
;|*** 	}
;|*** }
;|*** 
;|*** #endif // !GST_WINDOWS_BOOT
;|*** 
;|*** 
;|*** // Ciphers support
;|*** 
;|*** /**
;|***  *
;|***  *	\fn Cipher *CipherGet (int id)
;|***  *	\brief Get cipher at id, return null if there is no cipher with this id
;|***  *	\param[in] int id
;|***  *	\return Cipher * if success
;|***  *			NULL if no cipher at id
;|***  *
;|***  */
;|*** Cipher *CipherGet (int id)
;|*** {
; Line 242
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	id = 4
;	register bx = i
;|*** 	int i;
;|*** 	for (i = 0; Ciphers[i].Id != 0; i++)
; Line 244
	*** 000005	33 db 			xor	bx,bx
	*** 000007	8b 7e 04 		mov	di,WORD PTR [bp+4]	;id
					$F843:
	*** 00000a	6b f3 0a 		imul	si,bx,10	;000aH
	*** 00000d	83 bc 00 00 00 		cmp	WORD PTR $S787_Ciphers[si],0
	*** 000012	74 14 			je	SHORT $FB845
;|*** 		if (Ciphers[i].Id == id)
; Line 245
	*** 000014	6b f3 0a 		imul	si,bx,10	;000aH
	*** 000017	39 bc 00 00 		cmp	WORD PTR $S787_Ciphers[si],di
	*** 00001b	74 03 			je	SHORT $L1157
;|*** 	for (i = 0; Ciphers[i].Id != 0; i++)
; Line 244
	*** 00001d	43 			inc	bx
	*** 00001e	eb ea 			jmp	SHORT $F843
					$L1157:
;|*** 		if (Ciphers[i].Id == id)
;|*** 			return &Ciphers[i];
; Line 246
	*** 000020	6b c3 0a 		imul	ax,bx,10	;000aH
	*** 000023	05 00 00 		add	ax,OFFSET DGROUP:$S787_Ciphers
	*** 000026	eb 02 			jmp	SHORT $EX841
;|*** 
;|*** 	return NULL;
; Line 248
					$FB845:
	*** 000028	33 c0 			xor	ax,ax
;|*** }
; Line 249
					$EX841:
	*** 00002a	5e 			pop	si
	*** 00002b	5f 			pop	di
	*** 00002c	c9 			leave	
	*** 00002d	c3 			ret	

_CipherGet	ENDP
	PUBLIC	_CipherGetName
_CipherGetName	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn char *CipherGetName (int cipherId)
;|***  *	\brief Get the name of a cipher at id
;|***  *	\param[in] int cipherId
;|***  *	\return char * name if success
;|***  *			NULL if no cipher at id
;|***  *
;|***  */
;|*** char *CipherGetName (int cipherId)
;|*** {
; Line 261
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	cipherId = 4
;|*** 	return CipherGet (cipherId) -> Name;
; Line 262
	*** 000003	ff 76 04 		push	WORD PTR [bp+4]	;cipherId
	*** 000006	e8 00 00 		call	_CipherGet
	*** 000009	5b 			pop	bx
	*** 00000a	8b d8 			mov	bx,ax
	*** 00000c	8b 47 02 		mov	ax,WORD PTR [bx+2]
;|*** }
; Line 263
	*** 00000f	c9 			leave	
	*** 000010	c3 			ret	

_CipherGetName	ENDP
	PUBLIC	_CipherGetBlockSize
_CipherGetBlockSize	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int CipherGetBlockSize (int cipherId)
;|***  *	\brief Get the block size of a cipher at id
;|***  *	\param[in] int cipherId
;|***  *	\return int block size if success
;|***  *			NULL if no cipher at id
;|***  *
;|***  */
;|*** int CipherGetBlockSize (int cipherId)
;|*** {
; Line 275
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	cipherId = 4
;|*** 	return CipherGet (cipherId) -> BlockSize;
; Line 276
	*** 000003	ff 76 04 		push	WORD PTR [bp+4]	;cipherId
	*** 000006	e8 00 00 		call	_CipherGet
	*** 000009	5b 			pop	bx
	*** 00000a	8b d8 			mov	bx,ax
	*** 00000c	8b 47 04 		mov	ax,WORD PTR [bx+4]
;|*** }
; Line 277
	*** 00000f	c9 			leave	
	*** 000010	c3 			ret	

_CipherGetBlockSize	ENDP
	PUBLIC	_CipherGetKeySize
_CipherGetKeySize	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int CipherGetKeySize (int cipherId)
;|***  *	\brief Get the key size of a cipher at id
;|***  *	\param[in] int cipherId
;|***  *	\return int key size if success
;|***  *			NULL if no cipher at id
;|***  *
;|***  */
;|*** int CipherGetKeySize (int cipherId)
;|*** {
; Line 289
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	cipherId = 4
;|*** 	return CipherGet (cipherId) -> KeySize;
; Line 290
	*** 000003	ff 76 04 		push	WORD PTR [bp+4]	;cipherId
	*** 000006	e8 00 00 		call	_CipherGet
	*** 000009	5b 			pop	bx
	*** 00000a	8b d8 			mov	bx,ax
	*** 00000c	8b 47 06 		mov	ax,WORD PTR [bx+6]
;|*** }
; Line 291
	*** 00000f	c9 			leave	
	*** 000010	c3 			ret	

_CipherGetKeySize	ENDP
	PUBLIC	_CipherGetKeyScheduleSize
_CipherGetKeyScheduleSize	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int CipherGetKeyScheduleSize (int cipherId)
;|***  *	\brief Get the key schedule size of a cipher at id
;|***  *	\param[in] int cipherId
;|***  *	\return int key schedul size if success
;|***  *			NULL if no cipher at id
;|***  *
;|***  */
;|*** int CipherGetKeyScheduleSize (int cipherId)
;|*** {
; Line 303
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	cipherId = 4
;|*** 	return CipherGet (cipherId) -> KeyScheduleSize;
; Line 304
	*** 000003	ff 76 04 		push	WORD PTR [bp+4]	;cipherId
	*** 000006	e8 00 00 		call	_CipherGet
	*** 000009	5b 			pop	bx
	*** 00000a	8b d8 			mov	bx,ax
	*** 00000c	8b 47 08 		mov	ax,WORD PTR [bx+8]
;|*** }
; Line 305
	*** 00000f	c9 			leave	
	*** 000010	c3 			ret	

_CipherGetKeyScheduleSize	ENDP
	PUBLIC	_XorKeySchedule
_XorKeySchedule	PROC NEAR	;  COMDAT
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn BOOL CipherSupportsIntraDataUnitParallelization (int cipher)
;|***  *	\brief useless
;|***  *	\param[in] int cipher
;|***  *	\return BOOL 0
;|***  *
;|***  */
;|*** BOOL CipherSupportsIntraDataUnitParallelization (int cipher)
;|*** {
;|*** 	return 0;
;|*** }
;|*** 
;|*** #endif
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void XorKeySchedule(int cipher, void *ks, void *out_ks, void *data, int len)
;|***  *	\brief Start a crypting function depending on the algorithm.
;|***  *	\param[in] int len
;|***  *	\param[in] void * data
;|***  *	\param[in] void * out_ks
;|***  *	\param[in] void * ks
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void XorKeySchedule(int cipher, void *ks, void *out_ks, void *data, int len)
;|*** {
; Line 337
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	cipher = 4
;	ks = 6
;	out_ks = 8
;	data = 10
;	len = 12
;|*** 	switch (cipher)
; Line 338
	*** 000003	8b 46 04 		mov	ax,WORD PTR [bp+4]	;cipher
;|*** 	{
;|*** 	case GOST:
;|*** 		gost_xor_ks(ks, out_ks, data, len / sizeof(__int32));
;|*** 		break;
;|*** 	case GRASSHOPPER:
;|*** 		grasshopper_xor_ks(ks, out_ks, data, len / sizeof(__int32));
;|*** 		break;
;|*** 	default:
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
; Line 348
	*** 000006	48 			dec	ax
	*** 000007	74 0c 			je	SHORT $SC874
	*** 000009	48 			dec	ax
	*** 00000a	74 20 			je	SHORT $SC875
;|*** 		GST_THROW_FATAL_EXCEPTION;
; Line 347
	*** 00000c	68 5b 01 		push	347	;015bH
	*** 00000f	e8 00 00 		call	_ThrowFatalException
	*** 000012	5b 			pop	bx
;|*** 	}
; Line 348
	*** 000013	c9 			leave	
	*** 000014	c3 			ret	
;|*** 	case GOST:
; Line 340
					$SC874:
;|*** 		gost_xor_ks(ks, out_ks, data, len / sizeof(__int32));
; Line 341
	*** 000015	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;len
	*** 000018	c1 e8 02 		shr	ax,2
	*** 00001b	6a 00 			push	0
	*** 00001d	50 			push	ax
	*** 00001e	66 ff 76 08 		push	DWORD PTR [bp+8]	;out_ks
	*** 000022	ff 76 06 		push	WORD PTR [bp+6]	;ks
	*** 000025	e8 00 00 		call	_gost_xor_ks
	*** 000028	8b e5 			mov	sp,bp
;|*** 		break;
; Line 342
	*** 00002a	c9 			leave	
	*** 00002b	c3 			ret	
;|*** 	case GRASSHOPPER:
; Line 343
					$SC875:
;|*** 		grasshopper_xor_ks(ks, out_ks, data, len / sizeof(__int32));
; Line 344
	*** 00002c	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;len
	*** 00002f	c1 e8 02 		shr	ax,2
	*** 000032	50 			push	ax
	*** 000033	66 ff 76 08 		push	DWORD PTR [bp+8]	;out_ks
	*** 000037	ff 76 06 		push	WORD PTR [bp+6]	;ks
	*** 00003a	e8 00 00 		call	_grasshopper_xor_ks
;|*** 		break;
;|*** 	default:
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
;|*** }
; Line 349
	*** 00003d	c9 			leave	
	*** 00003e	c3 			ret	

_XorKeySchedule	ENDP
	PUBLIC	_EAGetFirst
_EAGetFirst	PROC NEAR	;  COMDAT
;|*** 
;|*** // Encryption algorithms support
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetFirst ()
;|***  *	\brief Get first EA (half useless)
;|***  *	\return int 1
;|***  *
;|***  */
;|*** int EAGetFirst ()
;|*** {
;|*** 	return 1;
; Line 362
	*** 000000	b8 01 00 		mov	ax,1
;|*** }
; Line 363
	*** 000003	c3 			ret	

_EAGetFirst	ENDP
	PUBLIC	_EAGetCount
_EAGetCount	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetCount (void)
;|***  *	\brief Returns number of EAs
;|***  *	\return int count
;|***  *
;|***  */
;|*** int EAGetCount (void)
;|*** {
; Line 374
	*** 000000	57 			push	di
	*** 000001	56 			push	si
;	register si = ea
;	register di = count
;|*** 	int ea, count = 0;
; Line 375
	*** 000002	33 ff 			xor	di,di
;|*** 
;|*** 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))
; Line 377
	*** 000004	e8 00 00 		call	_EAGetFirst
	*** 000007	eb 06 			jmp	SHORT $L1210
					$F881:
;|*** 	{
;|*** 		count++;
; Line 379
	*** 000009	47 			inc	di
;|*** 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))
; Line 377
	*** 00000a	56 			push	si
	*** 00000b	e8 00 00 		call	_EAGetNext
	*** 00000e	5b 			pop	bx
					$L1210:
	*** 00000f	8b f0 			mov	si,ax
	*** 000011	0b f0 			or	si,ax
	*** 000013	75 f4 			jne	SHORT $F881
;|*** 	{
;|*** 		count++;
;|*** 	}
;|*** 	return count;
; Line 381
	*** 000015	8b c7 			mov	ax,di
;|*** }
; Line 382
	*** 000017	5e 			pop	si
	*** 000018	5f 			pop	di
	*** 000019	c3 			ret	

_EAGetCount	ENDP
	PUBLIC	_EAGetNext
_EAGetNext	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetNext (int previousEA)
;|***  *	\brief Get the next EA
;|***  *	\param[in] int previousEA
;|***  *	\return id int if there is a next EA
;|***  *			else return 0
;|***  *
;|***  */
;|*** int EAGetNext (int previousEA)
;|*** {
; Line 394
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	56 			push	si
;	previousEA = 4
;	register bx = id
;|*** 	int id = previousEA + 1;
;|*** 	if (EncryptionAlgorithms[id].Ciphers[0] != 0) return id;
; Line 396
	*** 000004	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;previousEA
	*** 000007	43 			inc	bx
	*** 000008	8b f3 			mov	si,bx
	*** 00000a	c1 e6 04 		shl	si,4
	*** 00000d	83 bc 00 00 00 		cmp	WORD PTR $S790_EncryptionAlgorithms[si],0
	*** 000012	74 05 			je	SHORT $I888
	*** 000014	8b c3 			mov	ax,bx
	*** 000016	5e 			pop	si
	*** 000017	c9 			leave	
	*** 000018	c3 			ret	
					$I888:
	*** 000019	33 c0 			xor	ax,ax
;|*** 	return 0;
;|*** }
; Line 398
	*** 00001b	5e 			pop	si
	*** 00001c	c9 			leave	
	*** 00001d	c3 			ret	

_EAGetNext	ENDP
	PUBLIC	_EAInit
_EAInit	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAInit (int ea, unsigned char *key, unsigned __int8 *ks)
;|***  *	\brief Return values: 0 = success, ERR_CIPHER_INIT_FAILURE (fatal), ERR_CIPHER_INIT_WEAK_KEY (non-fatal)
;|***  *	\param[in] unsigned __int8* ks
;|***  *	\param[in] unsigned char* key
;|***  *	\param[in] int ea
;|***  *	\return retVal int 0 if success
;|***  *			ERR_CIPHER_INIT_FAILURE(fatal)
;|***  *			ERR_CIPHER_INIT_WEAK_KEY(non-fatal)
;|***  *
;|***  */
;|*** int EAInit (int ea, unsigned char *key, unsigned __int8 *ks)
;|*** {
; Line 414
	*** 000000	c8 02 00 00 		enter	2,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	register si = c
;	retVal = -2
;	ea = 4
;	key = 6
;	ks = 8
	*** 000006	8b 7e 04 		mov	di,WORD PTR [bp+4]	;ea
;|*** 	int c, retVal = ERR_SUCCESS;
; Line 415
	*** 000009	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;retVal
;|*** 
;|*** 	if (ea == 0)
; Line 417
	*** 00000e	0b ff 			or	di,di
	*** 000010	75 05 			jne	SHORT $I898
;|*** 		return ERR_CIPHER_INIT_FAILURE;
; Line 418
					$L1211:
	*** 000012	b8 11 00 		mov	ax,17	;0011H
	*** 000015	eb 46 			jmp	SHORT $EX895
;|*** 
;|*** 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))
; Line 420
					$I898:
	*** 000017	57 			push	di
	*** 000018	e8 00 00 		call	_EAGetFirstCipher
	*** 00001b	5b 			pop	bx
	*** 00001c	8b f0 			mov	si,ax
	*** 00001e	8b 7e 08 		mov	di,WORD PTR [bp+8]	;ks
	*** 000021	eb 33 			jmp	SHORT $L1212
					$F899:
;|*** 	{
;|*** 		switch (CipherInit (c, key, ks))
; Line 422
	*** 000023	57 			push	di
	*** 000024	ff 76 06 		push	WORD PTR [bp+6]	;key
	*** 000027	56 			push	si
	*** 000028	e8 00 00 		call	_CipherInit
	*** 00002b	83 c4 06 		add	sp,6
;|*** 		{
;|*** 		case ERR_CIPHER_INIT_FAILURE:
;|*** 			return ERR_CIPHER_INIT_FAILURE;
;|*** 
;|*** 		case ERR_CIPHER_INIT_WEAK_KEY:
;|*** 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error
;|*** 			break;
;|*** 		}
; Line 430
	*** 00002e	2d 11 00 		sub	ax,17	;0011H
	*** 000031	74 df 			je	SHORT $L1211
	*** 000033	48 			dec	ax
	*** 000034	75 05 			jne	SHORT $SB903
;|*** 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error
; Line 428
	*** 000036	c7 46 fe 12 00 		mov	WORD PTR [bp-2],18	;0012H	;retVal
;|*** 			break;
;|*** 		}
; Line 430
					$SB903:
;|*** 
;|*** 		key += CipherGetKeySize (c);
; Line 432
	*** 00003b	56 			push	si
	*** 00003c	e8 00 00 		call	_CipherGetKeySize
	*** 00003f	5b 			pop	bx
	*** 000040	01 46 06 		add	WORD PTR [bp+6],ax	;key
;|*** 		ks += CipherGetKeyScheduleSize (c);
; Line 433
	*** 000043	56 			push	si
	*** 000044	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 000047	5b 			pop	bx
	*** 000048	03 f8 			add	di,ax
;|*** 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))
; Line 420
	*** 00004a	56 			push	si
	*** 00004b	ff 76 04 		push	WORD PTR [bp+4]	;ea
	*** 00004e	e8 00 00 		call	_EAGetNextCipher
	*** 000051	83 c4 04 		add	sp,4
	*** 000054	8b f0 			mov	si,ax
					$L1212:
	*** 000056	0b f0 			or	si,ax
	*** 000058	75 c9 			jne	SHORT $F899
;|*** 	{
;|*** 		switch (CipherInit (c, key, ks))
;|*** 		{
;|*** 		case ERR_CIPHER_INIT_FAILURE:
;|*** 			return ERR_CIPHER_INIT_FAILURE;
;|*** 
;|*** 		case ERR_CIPHER_INIT_WEAK_KEY:
;|*** 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error
;|*** 			break;
;|*** 		}
;|*** 
;|*** 		key += CipherGetKeySize (c);
;|*** 		ks += CipherGetKeyScheduleSize (c);
;|*** 	}
;|*** 	return retVal;
; Line 435
	*** 00005a	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;retVal
;|*** }
; Line 436
					$EX895:
	*** 00005d	5e 			pop	si
	*** 00005e	5f 			pop	di
	*** 00005f	c9 			leave	
	*** 000060	c3 			ret	

_EAInit	ENDP
	PUBLIC	_EAGetKeySize
_EAGetKeySize	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn BOOL EAInitMode (PCRYPTO_INFO ci)
;|***  *	\brief Initialize EA mode
;|***  *	\param[in] PCRYPTO_INFO ci
;|***  *	\return BOOL FALSE if (EAInit (ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)
;|***  *			FALSE if (EAInit(ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)
;|***  *			TRUE otherwise
;|***  *
;|***  */
;|*** BOOL EAInitMode (PCRYPTO_INFO ci)
;|*** {
;|*** 	switch (ci->mode)
;|*** 	{
;|*** 	case XTS:
;|*** 		// Secondary key schedule
;|*** 		if (EAInit (ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)
;|*** 			return FALSE;
;|*** 
;|*** 		/* Note: XTS mode could potentially be initialized with a weak key causing all blocks in one data unit
;|*** 		on the volume to be tweaked with zero tweaks (i.e. 512 bytes of the volume would be encrypted in ECB
;|*** 		mode). However, to create a GostCrypt volume with such a weak key, each human being on Earth would have
;|*** 		to create approximately 11,378,125,361,078,862 (about eleven quadrillion) GostCrypt volumes (provided 
;|*** 		that the size of each of the volumes is 1024 terabytes). */
;|*** 		break;
;|*** 	case XTS8:
;|*** 		if (EAInit(ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)
;|*** 			return FALSE;
;|*** 		break;
;|*** 
;|*** 	default:		
;|*** 		// Unknown/wrong ID
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
;|*** 	return TRUE;
;|*** }
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn char *EAGetName (char *buf, int ea)
;|***  *	\brief Returns name of EA, cascaded cipher names are separated by hyphens
;|***  *	\param[in] int ea
;|***  *	\param[in] char * buf
;|***  *	\return char * buf
;|***  *
;|***  */
;|*** char *EAGetName (char *buf, int ea)
;|*** {
;|*** 	int i = EAGetLastCipher(ea);
;|*** 	strcpy (buf, (i != 0) ? CipherGetName (i) : "?");
;|*** 
;|*** 	while (i = EAGetPreviousCipher(ea, i))
;|*** 	{
;|*** 		strcat (buf, "-");
;|*** 		strcat (buf, CipherGetName (i));
;|*** 	}
;|*** 
;|*** 	return buf;
;|*** }
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetByName (char *name)
;|***  *	\brief Get the EA by name
;|***  *	\param[in] char* name
;|***  *	\return int ea if (strcmp (n, name) == 0)
;|***  *			0 else
;|***  *
;|***  */
;|*** int EAGetByName (char *name)
;|*** {
;|*** 	int ea = EAGetFirst ();
;|*** 	char n[128];
;|*** 
;|*** 	do
;|*** 	{
;|*** 		EAGetName (n, ea);
;|*** 		if (strcmp (n, name) == 0)
;|*** 			return ea;
;|*** 	}
;|*** 	while (ea = EAGetNext (ea));
;|*** 
;|*** 	return 0;
;|*** }
;|*** 
;|*** #endif // GST_WINDOWS_BOOT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetKeySize (int ea)
;|***  *	\brief Returns sum of key sizes of all ciphers of the EA (in bytes)
;|***  *	\param[in] int ea
;|***  *	\return int size
;|***  *
;|***  */
;|*** int EAGetKeySize (int ea)
;|*** {
; Line 540
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	ea = 4
;	register si = i
;	register di = size
;|*** 	int i = EAGetFirstCipher (ea);
;|*** 	int size = CipherGetKeySize (i);
; Line 542
	*** 000005	ff 76 04 		push	WORD PTR [bp+4]	;ea
	*** 000008	e8 00 00 		call	_EAGetFirstCipher
	*** 00000b	5b 			pop	bx
	*** 00000c	8b f0 			mov	si,ax
	*** 00000e	50 			push	ax
	*** 00000f	e8 00 00 		call	_CipherGetKeySize
	*** 000012	5b 			pop	bx
	*** 000013	8b f8 			mov	di,ax
;|*** 
;|*** 	while (i = EAGetNextCipher (ea, i))
; Line 544
	*** 000015	eb 07 			jmp	SHORT $L1213
					$FC914:
;|*** 	{
;|*** 		size += CipherGetKeySize (i);
; Line 546
	*** 000017	50 			push	ax
	*** 000018	e8 00 00 		call	_CipherGetKeySize
	*** 00001b	5b 			pop	bx
	*** 00001c	03 f8 			add	di,ax
;|*** 	}
; Line 547
					$L1213:
	*** 00001e	56 			push	si
	*** 00001f	ff 76 04 		push	WORD PTR [bp+4]	;ea
	*** 000022	e8 00 00 		call	_EAGetNextCipher
	*** 000025	83 c4 04 		add	sp,4
	*** 000028	8b f0 			mov	si,ax
	*** 00002a	0b f0 			or	si,ax
	*** 00002c	75 e9 			jne	SHORT $FC914
;|*** 
;|*** 	return size;
; Line 549
	*** 00002e	8b c7 			mov	ax,di
;|*** }
; Line 550
	*** 000030	5e 			pop	si
	*** 000031	5f 			pop	di
	*** 000032	c9 			leave	
	*** 000033	c3 			ret	

_EAGetKeySize	ENDP
	PUBLIC	_EAGetFirstMode
_EAGetFirstMode	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetFirstMode (int ea)
;|***  *	\brief Returns the first mode of operation of EA
;|***  *	\param[in] int ea
;|***  *	\return int encryptionAlgorithm[].modes[]
;|***  *
;|***  */
;|*** int EAGetFirstMode (int ea)
;|*** {
; Line 562
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	ea = 4
;|*** 	return (EncryptionAlgorithms[ea].Modes[0]);
; Line 563
	*** 000003	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;ea
	*** 000006	c1 e3 04 		shl	bx,4
	*** 000009	8b 87 08 00 		mov	ax,WORD PTR $S790_EncryptionAlgorithms[bx+8]
;|*** }
; Line 564
	*** 00000d	c9 			leave	
	*** 00000e	c3 			ret	

_EAGetFirstMode	ENDP
	PUBLIC	_EAGetNextMode
_EAGetNextMode	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetNextMode (int ea, int previousModeId)
;|***  *	\brief Returns the next mode of operation of EA
;|***  *	\param[in] int previousModeId
;|***  *	\param[in] int ea
;|***  *	\return int encryptionAlgorithm[].modes[] if (c == previousModeId) 
;|***  *			0 else
;|***  *
;|***  */
;|*** int EAGetNextMode (int ea, int previousModeId)
;|*** {
; Line 578
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	ea = 4
;	previousModeId = 6
;	register dx = c
;	register bx = i
;|*** 	int c, i = 0;
; Line 579
	*** 000005	33 db 			xor	bx,bx
	*** 000007	8b 4e 06 		mov	cx,WORD PTR [bp+6]	;previousModeId
	*** 00000a	8b 7e 04 		mov	di,WORD PTR [bp+4]	;ea
;|*** 	while (c = EncryptionAlgorithms[ea].Modes[i++])
; Line 580
					$FC927:
	*** 00000d	8b f7 			mov	si,di
	*** 00000f	c1 e6 03 		shl	si,3
	*** 000012	03 f3 			add	si,bx
	*** 000014	03 f6 			add	si,si
	*** 000016	43 			inc	bx
	*** 000017	8b 94 08 00 		mov	dx,WORD PTR $S790_EncryptionAlgorithms[si+8]
	*** 00001b	0b d2 			or	dx,dx
	*** 00001d	74 11 			je	SHORT $FB928
;|*** 	{
;|*** 		if (c == previousModeId) 
; Line 582
	*** 00001f	3b d1 			cmp	dx,cx
	*** 000021	75 ea 			jne	SHORT $FC927
;|*** 			return EncryptionAlgorithms[ea].Modes[i];
; Line 583
	*** 000023	c1 e7 03 		shl	di,3
	*** 000026	03 fb 			add	di,bx
	*** 000028	03 ff 			add	di,di
	*** 00002a	8b 85 08 00 		mov	ax,WORD PTR $S790_EncryptionAlgorithms[di+8]
	*** 00002e	eb 02 			jmp	SHORT $EX923
;|*** 	}
; Line 584
					$FB928:
;|*** 
;|*** 	return 0;
; Line 586
	*** 000030	33 c0 			xor	ax,ax
;|*** }
; Line 587
					$EX923:
	*** 000032	5e 			pop	si
	*** 000033	5f 			pop	di
	*** 000034	c9 			leave	
	*** 000035	c3 			ret	

_EAGetNextMode	ENDP
	PUBLIC	_EAGetKeyScheduleSize
_EAGetKeyScheduleSize	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn char *EAGetModeName (int ea, int mode, BOOL capitalLetters)
;|***  *	\brief Returns the name of the mode of operation of the whole EA
;|***  *	\param[in] BOOL capitalLetters
;|***  *	\param[in] int mode
;|***  *	\param[in] int ea
;|***  *	\return char * string "XTS" switch (mode) case XTS:
;|***  *			"XTS 64-bit version" switch (mode) case XTS8:
;|***  *			"[unknown]"
;|***  *
;|***  */
;|*** char *EAGetModeName (int ea, int mode, BOOL capitalLetters)
;|*** {
;|*** 	switch (mode)
;|*** 	{
;|*** 	case XTS:
;|*** 		return "XTS";
;|*** 	case XTS8:
;|*** 		return "XTS 64-bit version";
;|*** 	}
;|*** 	return "[unknown]";
;|*** }
;|*** 
;|*** #endif // GST_WINDOWS_BOOT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetKeyScheduleSize (int ea)
;|***  *	\brief Returns sum of key schedule sizes of all ciphers of the EA
;|***  *	\param[in] int ea
;|***  *	\return int size
;|***  *
;|***  */
;|*** int EAGetKeyScheduleSize (int ea)
;|*** {
; Line 627
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	ea = 4
;	register si = i
;	register di = size
;|*** 	int i = EAGetFirstCipher(ea);
;|*** 	int size = CipherGetKeyScheduleSize (i);
; Line 629
	*** 000005	ff 76 04 		push	WORD PTR [bp+4]	;ea
	*** 000008	e8 00 00 		call	_EAGetFirstCipher
	*** 00000b	5b 			pop	bx
	*** 00000c	8b f0 			mov	si,ax
	*** 00000e	50 			push	ax
	*** 00000f	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 000012	5b 			pop	bx
	*** 000013	8b f8 			mov	di,ax
;|*** 
;|*** 	while (i = EAGetNextCipher(ea, i))
; Line 631
	*** 000015	eb 07 			jmp	SHORT $L1214
					$FC936:
;|*** 	{
;|*** 		size += CipherGetKeyScheduleSize (i);
; Line 633
	*** 000017	50 			push	ax
	*** 000018	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 00001b	5b 			pop	bx
	*** 00001c	03 f8 			add	di,ax
;|*** 	}
; Line 634
					$L1214:
	*** 00001e	56 			push	si
	*** 00001f	ff 76 04 		push	WORD PTR [bp+4]	;ea
	*** 000022	e8 00 00 		call	_EAGetNextCipher
	*** 000025	83 c4 04 		add	sp,4
	*** 000028	8b f0 			mov	si,ax
	*** 00002a	0b f0 			or	si,ax
	*** 00002c	75 e9 			jne	SHORT $FC936
;|*** 
;|*** 	return size;
; Line 636
	*** 00002e	8b c7 			mov	ax,di
;|*** }
; Line 637
	*** 000030	5e 			pop	si
	*** 000031	5f 			pop	di
	*** 000032	c9 			leave	
	*** 000033	c3 			ret	

_EAGetKeyScheduleSize	ENDP
	PUBLIC	_EAGetLargestKeyForMode
_EAGetLargestKeyForMode	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetLargestKeyForMode (int mode)
;|***  *	\brief Returns the largest key size needed by an EA for the specified mode of operation
;|***  *	\param[in] int mode
;|***  *	\returnint key
;|***  *
;|***  */
;|*** int EAGetLargestKeyForMode (int mode)
;|*** {
; Line 648
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	mode = 4
;	register si = ea
;	register di = key
;|*** 	int ea, key = 0;
; Line 649
	*** 000005	33 ff 			xor	di,di
;|*** 
;|*** 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))
; Line 651
	*** 000007	e8 00 00 		call	_EAGetFirst
	*** 00000a	eb 23 			jmp	SHORT $L1216
					$F943:
;|*** 	{
;|*** 		if (!EAIsModeSupported (ea, mode))
; Line 653
	*** 00000c	ff 76 04 		push	WORD PTR [bp+4]	;mode
	*** 00000f	56 			push	si
	*** 000010	e8 00 00 		call	_EAIsModeSupported
	*** 000013	83 c4 04 		add	sp,4
	*** 000016	0a c0 			or	al,al
	*** 000018	74 10 			je	SHORT $FC944
;|*** 			continue;
;|*** 
;|*** 		if (EAGetKeySize (ea) >= key)
; Line 656
	*** 00001a	56 			push	si
	*** 00001b	e8 00 00 		call	_EAGetKeySize
	*** 00001e	5b 			pop	bx
	*** 00001f	3b c7 			cmp	ax,di
	*** 000021	7c 07 			jl	SHORT $FC944
;|*** 			key = EAGetKeySize (ea);
; Line 657
	*** 000023	56 			push	si
	*** 000024	e8 00 00 		call	_EAGetKeySize
	*** 000027	5b 			pop	bx
	*** 000028	8b f8 			mov	di,ax
;|*** 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))
; Line 651
					$FC944:
	*** 00002a	56 			push	si
	*** 00002b	e8 00 00 		call	_EAGetNext
	*** 00002e	5b 			pop	bx
					$L1216:
	*** 00002f	8b f0 			mov	si,ax
	*** 000031	0b f0 			or	si,ax
	*** 000033	75 d7 			jne	SHORT $F943
;|*** 	{
;|*** 		if (!EAIsModeSupported (ea, mode))
;|*** 			continue;
;|*** 
;|*** 		if (EAGetKeySize (ea) >= key)
;|*** 			key = EAGetKeySize (ea);
;|*** 	}
;|*** 	return key;
; Line 659
	*** 000035	8b c7 			mov	ax,di
;|*** }
; Line 660
	*** 000037	5e 			pop	si
	*** 000038	5f 			pop	di
	*** 000039	c9 			leave	
	*** 00003a	c3 			ret	

_EAGetLargestKeyForMode	ENDP
	PUBLIC	_EAGetLargestKey
_EAGetLargestKey	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetLargestKey ()
;|***  *	\brief Returns the largest key needed by any EA for any mode
;|***  *	\return int key
;|***  *
;|***  */
;|*** int EAGetLargestKey ()
;|*** {
; Line 670
	*** 000000	57 			push	di
	*** 000001	56 			push	si
;	register si = ea
;	register di = key
;|*** 	int ea, key = 0;
; Line 671
	*** 000002	33 ff 			xor	di,di
;|*** 
;|*** 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))
; Line 673
	*** 000004	e8 00 00 		call	_EAGetFirst
	*** 000007	eb 15 			jmp	SHORT $L1218
					$F951:
;|*** 	{
;|*** 		if (EAGetKeySize (ea) >= key)
; Line 675
	*** 000009	56 			push	si
	*** 00000a	e8 00 00 		call	_EAGetKeySize
	*** 00000d	5b 			pop	bx
	*** 00000e	3b c7 			cmp	ax,di
	*** 000010	7c 07 			jl	SHORT $FC952
;|*** 			key = EAGetKeySize (ea);
; Line 676
	*** 000012	56 			push	si
	*** 000013	e8 00 00 		call	_EAGetKeySize
	*** 000016	5b 			pop	bx
	*** 000017	8b f8 			mov	di,ax
;|*** 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))
; Line 673
					$FC952:
	*** 000019	56 			push	si
	*** 00001a	e8 00 00 		call	_EAGetNext
	*** 00001d	5b 			pop	bx
					$L1218:
	*** 00001e	8b f0 			mov	si,ax
	*** 000020	0b f0 			or	si,ax
	*** 000022	75 e5 			jne	SHORT $F951
;|*** 	{
;|*** 		if (EAGetKeySize (ea) >= key)
;|*** 			key = EAGetKeySize (ea);
;|*** 	}
;|*** 
;|*** 	return key;
; Line 679
	*** 000024	8b c7 			mov	ax,di
;|*** }
; Line 680
	*** 000026	5e 			pop	si
	*** 000027	5f 			pop	di
	*** 000028	c3 			ret	

_EAGetLargestKey	ENDP
	PUBLIC	_EAGetCipherCount
_EAGetCipherCount	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetCipherCount (int ea)
;|***  *	\brief Returns number of ciphers in EA
;|***  *	\param[in] int ea
;|***  *	\return int i-1
;|***  *
;|***  */
;|*** int EAGetCipherCount (int ea)
;|*** {
; Line 691
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	ea = 4
;	register bx = i
;|*** 	int i = 0;
; Line 692
	*** 000005	33 db 			xor	bx,bx
	*** 000007	8b 7e 04 		mov	di,WORD PTR [bp+4]	;ea
;|*** 	while (EncryptionAlgorithms[ea].Ciphers[i++]);
; Line 693
					$FC960:
	*** 00000a	8b f7 			mov	si,di
	*** 00000c	c1 e6 03 		shl	si,3
	*** 00000f	8b c3 			mov	ax,bx
	*** 000011	43 			inc	bx
	*** 000012	03 f0 			add	si,ax
	*** 000014	03 f6 			add	si,si
	*** 000016	83 bc 00 00 00 		cmp	WORD PTR $S790_EncryptionAlgorithms[si],0
	*** 00001b	75 ed 			jne	SHORT $FC960
;|*** 
;|*** 	return i - 1;
; Line 695
	*** 00001d	8d 47 ff 		lea	ax,WORD PTR [bx-1]
;|*** }
; Line 696
	*** 000020	5e 			pop	si
	*** 000021	5f 			pop	di
	*** 000022	c9 			leave	
	*** 000023	c3 			ret	

_EAGetCipherCount	ENDP
	PUBLIC	_EAGetFirstCipher
_EAGetFirstCipher	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetFirstCipher (int ea)
;|***  *	\brief Return the first EA
;|***  *	\param[in] int ea
;|***  *	\return int encryptionAlgorithm[].modes[].Ciphers[0]
;|***  *
;|***  */
;|*** int EAGetFirstCipher (int ea)
;|*** {
; Line 708
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	ea = 4
;|*** 	return EncryptionAlgorithms[ea].Ciphers[0];
; Line 709
	*** 000003	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;ea
	*** 000006	c1 e3 04 		shl	bx,4
	*** 000009	8b 87 00 00 		mov	ax,WORD PTR $S790_EncryptionAlgorithms[bx]
;|*** }
; Line 710
	*** 00000d	c9 			leave	
	*** 00000e	c3 			ret	

_EAGetFirstCipher	ENDP
	PUBLIC	_EAGetLastCipher
_EAGetLastCipher	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetLastCipher (int ea)
;|***  *	\brief Get last EA cipher
;|***  *	\param[in] int ea
;|***  *	\return int EncryptionAlgorithms[ea].Ciphers[i - 2]
;|***  *
;|***  */
;|*** int EAGetLastCipher (int ea)
;|*** {
; Line 722
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	ea = 4
;	register dx = c
;	register bx = i
;|*** 	int c, i = 0;
; Line 723
	*** 000005	33 db 			xor	bx,bx
	*** 000007	8b 7e 04 		mov	di,WORD PTR [bp+4]	;ea
;|*** 	while (c = EncryptionAlgorithms[ea].Ciphers[i++]);
; Line 724
					$FC971:
	*** 00000a	8b f7 			mov	si,di
	*** 00000c	c1 e6 03 		shl	si,3
	*** 00000f	03 f3 			add	si,bx
	*** 000011	03 f6 			add	si,si
	*** 000013	43 			inc	bx
	*** 000014	8b 94 00 00 		mov	dx,WORD PTR $S790_EncryptionAlgorithms[si]
	*** 000018	0b d2 			or	dx,dx
	*** 00001a	75 ee 			jne	SHORT $FC971
;|*** 
;|*** 	return EncryptionAlgorithms[ea].Ciphers[i - 2];
; Line 726
	*** 00001c	c1 e7 03 		shl	di,3
	*** 00001f	03 fb 			add	di,bx
	*** 000021	03 ff 			add	di,di
	*** 000023	8b 85 fc ff 		mov	ax,WORD PTR $S790_EncryptionAlgorithms[di-4]
;|*** }
; Line 727
	*** 000027	5e 			pop	si
	*** 000028	5f 			pop	di
	*** 000029	c9 			leave	
	*** 00002a	c3 			ret	

_EAGetLastCipher	ENDP
	PUBLIC	_EAGetNextCipher
_EAGetNextCipher	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetNextCipher (int ea, int previousCipherId)
;|***  *	\brief Return next cipher if exists
;|***  *	\param[in] int previousCipherId
;|***  *	\param[in] int ea
;|***  *	\return int EncryptionAlgorithms[ea].Ciphers[i]
;|***  *			0 if no next cipher
;|***  *
;|***  */
;|*** int EAGetNextCipher (int ea, int previousCipherId)
;|*** {
; Line 741
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	ea = 4
;	previousCipherId = 6
;	register dx = c
;	register bx = i
;|*** 	int c, i = 0;
; Line 742
	*** 000005	33 db 			xor	bx,bx
	*** 000007	8b 4e 06 		mov	cx,WORD PTR [bp+6]	;previousCipherId
	*** 00000a	8b 7e 04 		mov	di,WORD PTR [bp+4]	;ea
;|*** 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])
; Line 743
					$FC981:
	*** 00000d	8b f7 			mov	si,di
	*** 00000f	c1 e6 03 		shl	si,3
	*** 000012	03 f3 			add	si,bx
	*** 000014	03 f6 			add	si,si
	*** 000016	43 			inc	bx
	*** 000017	8b 94 00 00 		mov	dx,WORD PTR $S790_EncryptionAlgorithms[si]
	*** 00001b	0b d2 			or	dx,dx
	*** 00001d	74 11 			je	SHORT $FB982
;|*** 	{
;|*** 		if (c == previousCipherId) 
; Line 745
	*** 00001f	3b d1 			cmp	dx,cx
	*** 000021	75 ea 			jne	SHORT $FC981
;|*** 			return EncryptionAlgorithms[ea].Ciphers[i];
; Line 746
	*** 000023	c1 e7 03 		shl	di,3
	*** 000026	03 fb 			add	di,bx
	*** 000028	03 ff 			add	di,di
	*** 00002a	8b 85 00 00 		mov	ax,WORD PTR $S790_EncryptionAlgorithms[di]
	*** 00002e	eb 02 			jmp	SHORT $EX977
;|*** 	}
; Line 747
					$FB982:
;|*** 
;|*** 	return 0;
; Line 749
	*** 000030	33 c0 			xor	ax,ax
;|*** }
; Line 750
					$EX977:
	*** 000032	5e 			pop	si
	*** 000033	5f 			pop	di
	*** 000034	c9 			leave	
	*** 000035	c3 			ret	

_EAGetNextCipher	ENDP
	PUBLIC	_EAGetPreviousCipher
_EAGetPreviousCipher	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetPreviousCipher (int ea, int previousCipherId)
;|***  *	\brief Return next cipher if exists
;|***  *	\param[in] int previousCipherId
;|***  *	\param[in] int ea
;|***  *	\return int EncryptionAlgorithms[ea].Ciphers[i - 2]
;|***  *			0 if no next cipher
;|***  *
;|***  */
;|*** int EAGetPreviousCipher (int ea, int previousCipherId)
;|*** {
; Line 764
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	ea = 4
;	previousCipherId = 6
;	register dx = c
;	register bx = i
	*** 000005	8b 7e 04 		mov	di,WORD PTR [bp+4]	;ea
	*** 000008	8b 4e 06 		mov	cx,WORD PTR [bp+6]	;previousCipherId
;|*** 	int c, i = 0;
;|*** 
;|*** 	if (EncryptionAlgorithms[ea].Ciphers[i++] == previousCipherId)
; Line 767
	*** 00000b	bb 01 00 		mov	bx,1
	*** 00000e	8b f7 			mov	si,di
	*** 000010	c1 e6 04 		shl	si,4
	*** 000013	39 8c 00 00 		cmp	WORD PTR $S790_EncryptionAlgorithms[si],cx
	*** 000017	74 23 			je	SHORT $FB994
					$L1168:
;|*** 		return 0;
;|*** 
;|*** 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])
; Line 770
	*** 000019	8b f7 			mov	si,di
	*** 00001b	c1 e6 03 		shl	si,3
	*** 00001e	03 f3 			add	si,bx
	*** 000020	03 f6 			add	si,si
	*** 000022	43 			inc	bx
	*** 000023	8b 94 00 00 		mov	dx,WORD PTR $S790_EncryptionAlgorithms[si]
	*** 000027	0b d2 			or	dx,dx
	*** 000029	74 11 			je	SHORT $FB994
;|*** 	{
;|*** 		if (c == previousCipherId) 
; Line 772
	*** 00002b	3b d1 			cmp	dx,cx
	*** 00002d	75 ea 			jne	SHORT $L1168
;|*** 			return EncryptionAlgorithms[ea].Ciphers[i - 2];
; Line 773
	*** 00002f	c1 e7 03 		shl	di,3
	*** 000032	03 fb 			add	di,bx
	*** 000034	03 ff 			add	di,di
	*** 000036	8b 85 fc ff 		mov	ax,WORD PTR $S790_EncryptionAlgorithms[di-4]
	*** 00003a	eb 02 			jmp	SHORT $EX988
;|*** 	}
; Line 774
					$FB994:
;|*** 
;|*** 	return 0;
; Line 776
	*** 00003c	33 c0 			xor	ax,ax
;|*** }
; Line 777
					$EX988:
	*** 00003e	5e 			pop	si
	*** 00003f	5f 			pop	di
	*** 000040	c9 			leave	
	*** 000041	c3 			ret	

_EAGetPreviousCipher	ENDP
	PUBLIC	_EAIsFormatEnabled
_EAIsFormatEnabled	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAIsFormatEnabled (int ea)
;|***  *	\brief Return the state of format
;|***  *	\param[in] int ea
;|***  *	\return int EncryptionAlgorithms[ea].FormatEnabled
;|***  *
;|***  */
;|*** int EAIsFormatEnabled (int ea)
;|*** {
; Line 789
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	ea = 4
;|*** 	return EncryptionAlgorithms[ea].FormatEnabled;
; Line 790
	*** 000003	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;ea
	*** 000006	c1 e3 04 		shl	bx,4
	*** 000009	8b 87 0e 00 		mov	ax,WORD PTR $S790_EncryptionAlgorithms[bx+14]
;|*** }
; Line 791
	*** 00000d	c9 			leave	
	*** 00000e	c3 			ret	

_EAIsFormatEnabled	ENDP
	PUBLIC	_EAIsModeSupported
_EAIsModeSupported	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn BOOL EAIsModeSupported (int ea, int testedMode)
;|***  *	\brief Returns TRUE if the mode of operation is supported for the encryption algorithm
;|***  *	\param[in] int testedMode
;|***  *	\param[in] int ea
;|***  *	\return BOOL TRUE if (mode == testedMode)
;|***  *			FALSE otherwise
;|***  *
;|***  */
;|*** BOOL EAIsModeSupported (int ea, int testedMode)
;|*** {
; Line 804
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	ea = 4
;	testedMode = 6
;	register si = mode
	*** 000005	8b 7e 04 		mov	di,WORD PTR [bp+4]	;ea
;|*** 	int mode;
;|*** 
;|*** 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))
; Line 807
	*** 000008	57 			push	di
	*** 000009	e8 00 00 		call	_EAGetFirstMode
	*** 00000c	5b 			pop	bx
					$L1220:
	*** 00000d	8b f0 			mov	si,ax
	*** 00000f	0b f0 			or	si,ax
	*** 000011	74 13 			je	SHORT $FB1007
;|*** 	{
;|*** 		if (mode == testedMode)
; Line 809
	*** 000013	39 76 06 		cmp	WORD PTR [bp+6],si	;testedMode
	*** 000016	74 0a 			je	SHORT $L1170
;|*** 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))
; Line 807
	*** 000018	56 			push	si
	*** 000019	57 			push	di
	*** 00001a	e8 00 00 		call	_EAGetNextMode
	*** 00001d	83 c4 04 		add	sp,4
	*** 000020	eb eb 			jmp	SHORT $L1220
					$L1170:
;|*** 	{
;|*** 		if (mode == testedMode)
;|*** 			return TRUE;
; Line 810
	*** 000022	b0 01 			mov	al,1
	*** 000024	eb 02 			jmp	SHORT $EX1003
;|*** 	}
; Line 811
					$FB1007:
;|*** 	return FALSE;
; Line 812
	*** 000026	32 c0 			xor	al,al
;|*** }
; Line 813
					$EX1003:
	*** 000028	5e 			pop	si
	*** 000029	5f 			pop	di
	*** 00002a	c9 			leave	
	*** 00002b	c3 			ret	

_EAIsModeSupported	ENDP
	PUBLIC	_HashGet
_HashGet	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn Hash *HashGet (int id)
;|***  *	\brief Returns hash by id or 0 if no hash
;|***  *	\param[in] int id
;|***  *	\return Hash &Hashes[i] if (Hashes[i].Id == id)
;|***  *			0 otherwise
;|***  *
;|***  */
;|*** Hash *HashGet (int id)
;|*** {
; Line 826
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	id = 4
;	register bx = i
;|*** 	int i;
;|*** 	for (i = 0; Hashes[i].Id != 0; i++)
; Line 828
	*** 000005	33 db 			xor	bx,bx
	*** 000007	8b 7e 04 		mov	di,WORD PTR [bp+4]	;id
					$F1014:
	*** 00000a	6b f3 06 		imul	si,bx,6
	*** 00000d	83 bc 00 00 00 		cmp	WORD PTR $S791_Hashes[si],0
	*** 000012	74 14 			je	SHORT $FB1016
;|*** 		if (Hashes[i].Id == id)
; Line 829
	*** 000014	6b f3 06 		imul	si,bx,6
	*** 000017	39 bc 00 00 		cmp	WORD PTR $S791_Hashes[si],di
	*** 00001b	74 03 			je	SHORT $L1172
;|*** 	for (i = 0; Hashes[i].Id != 0; i++)
; Line 828
	*** 00001d	43 			inc	bx
	*** 00001e	eb ea 			jmp	SHORT $F1014
					$L1172:
;|*** 		if (Hashes[i].Id == id)
;|*** 			return &Hashes[i];
; Line 830
	*** 000020	6b c3 06 		imul	ax,bx,6
	*** 000023	05 00 00 		add	ax,OFFSET DGROUP:$S791_Hashes
	*** 000026	eb 02 			jmp	SHORT $EX1012
;|*** 
;|*** 	return 0;
; Line 832
					$FB1016:
	*** 000028	33 c0 			xor	ax,ax
;|*** }
; Line 833
					$EX1012:
	*** 00002a	5e 			pop	si
	*** 00002b	5f 			pop	di
	*** 00002c	c9 			leave	
	*** 00002d	c3 			ret	

_HashGet	ENDP
	PUBLIC	_HashGetIdByName
_HashGetIdByName	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int HashGetIdByName (char *name)
;|***  *	\brief Returns hash by name or 0 if no hash
;|***  *	\param[in] char * name
;|***  *	\return int Hashes[i].Id if (strcmp (Hashes[i].Name, name) == 0)
;|***  *			0 otherwise
;|***  *
;|***  */
;|*** int HashGetIdByName (char *name)
;|*** {
; Line 846
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	name = 4
;	register si = i
;|*** 	int i;
;|*** 	for (i = 0; Hashes[i].Id != 0; i++)
; Line 848
	*** 000005	33 f6 			xor	si,si
	*** 000007	8b 7e 04 		mov	di,WORD PTR [bp+4]	;name
					$F1023:
	*** 00000a	6b de 06 		imul	bx,si,6
	*** 00000d	83 bf 00 00 00 		cmp	WORD PTR $S791_Hashes[bx],0
	*** 000012	74 1e 			je	SHORT $FB1025
;|*** 		if (strcmp (Hashes[i].Name, name) == 0)
; Line 849
	*** 000014	57 			push	di
	*** 000015	6b de 06 		imul	bx,si,6
	*** 000018	ff b7 02 00 		push	WORD PTR $S791_Hashes[bx+2]
	*** 00001c	e8 00 00 		call	_strcmp
	*** 00001f	83 c4 04 		add	sp,4
	*** 000022	0b c0 			or	ax,ax
	*** 000024	74 03 			je	SHORT $L1174
;|*** 	for (i = 0; Hashes[i].Id != 0; i++)
; Line 848
	*** 000026	46 			inc	si
	*** 000027	eb e1 			jmp	SHORT $F1023
					$L1174:
;|*** 		if (strcmp (Hashes[i].Name, name) == 0)
;|*** 			return Hashes[i].Id;
; Line 850
	*** 000029	6b de 06 		imul	bx,si,6
	*** 00002c	8b 87 00 00 		mov	ax,WORD PTR $S791_Hashes[bx]
	*** 000030	eb 02 			jmp	SHORT $EX1021
;|*** 
;|*** 	return 0;
; Line 852
					$FB1025:
	*** 000032	33 c0 			xor	ax,ax
;|*** }
; Line 853
					$EX1021:
	*** 000034	5e 			pop	si
	*** 000035	5f 			pop	di
	*** 000036	c9 			leave	
	*** 000037	c3 			ret	

_HashGetIdByName	ENDP
	PUBLIC	_HashGetName
_HashGetName	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn char *HashGetName (int hashId)
;|***  *	\brief Returns hash by name or 0 if no hash
;|***  *	\param[in] int hashId
;|***  *	\return char * HashGet (hashId)->Name
;|***  *
;|***  */
;|*** char *HashGetName (int hashId)
;|*** {
; Line 865
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	hashId = 4
;|*** 	return HashGet (hashId) -> Name;
; Line 866
	*** 000003	ff 76 04 		push	WORD PTR [bp+4]	;hashId
	*** 000006	e8 00 00 		call	_HashGet
	*** 000009	5b 			pop	bx
	*** 00000a	8b d8 			mov	bx,ax
	*** 00000c	8b 47 02 		mov	ax,WORD PTR [bx+2]
;|*** }
; Line 867
	*** 00000f	c9 			leave	
	*** 000010	c3 			ret	

_HashGetName	ENDP
	PUBLIC	_HashIsDeprecated
_HashIsDeprecated	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn BOOL HashIsDeprecated (int hashId)
;|***  *	\brief Returns true if deprecated, false else.
;|***  *	\param[in] int hashId
;|***  *	\return BOOL HashGet (hashId)->Deprecated
;|***  *
;|***  */
;|*** BOOL HashIsDeprecated (int hashId)
;|*** {
; Line 879
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	hashId = 4
;|*** 	return HashGet (hashId) -> Deprecated;
; Line 880
	*** 000003	ff 76 04 		push	WORD PTR [bp+4]	;hashId
	*** 000006	e8 00 00 		call	_HashGet
	*** 000009	5b 			pop	bx
	*** 00000a	8b d8 			mov	bx,ax
	*** 00000c	8a 47 04 		mov	al,BYTE PTR [bx+4]
;|*** }
; Line 881
	*** 00000f	c9 			leave	
	*** 000010	c3 			ret	

_HashIsDeprecated	ENDP
	PUBLIC	_crypto_open
_crypto_open	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** #endif // GST_WINDOWS_BOOT_SINGLE_CIPHER_MODE
;|*** 
;|*** 
;|*** #ifdef GST_WINDOWS_BOOT
;|*** 
;|*** static byte CryptoInfoBufferInUse = 0;
;|*** CRYPTO_INFO CryptoInfoBuffer;
;|*** 
;|*** #endif
;|*** 
;|*** /**
;|***  *
;|***  *	\fn PCRYPTO_INFO crypto_open ()
;|***  *	\brief Do the crypto
;|***  *	\return PCRYPTO_INFO cryptoInfo
;|***  *			NULL if (cryptoInfo == NULL)
;|***  *			GST_THROW_FATAL_EXCEPTION if (CryptoInfoBufferInUse) #else DEVICE_DRIVER
;|***  *			&CryptoInfoBuffer  #else DEVICE_DRIVER
;|***  *
;|***  */
;|*** PCRYPTO_INFO crypto_open ()
;|*** {
;|*** #ifndef GST_WINDOWS_BOOT
;|*** 
;|*** 	/* Do the crt allocation */
;|*** 	PCRYPTO_INFO cryptoInfo = (PCRYPTO_INFO) GSTalloc (sizeof (CRYPTO_INFO));
;|*** 	if (cryptoInfo == NULL)
;|*** 		return NULL;
;|*** 
;|*** 	memset (cryptoInfo, 0, sizeof (CRYPTO_INFO));
;|*** 
;|*** #ifndef DEVICE_DRIVER
;|*** 	VirtualLock (cryptoInfo, sizeof (CRYPTO_INFO));
;|*** #endif
;|*** 
;|*** 	cryptoInfo->ea = -1;
;|*** 	return cryptoInfo;
;|*** 
;|*** #else // GST_WINDOWS_BOOT
;|*** 
;|*** #if 0
;|*** 	if (CryptoInfoBufferInUse)
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** #endif
;|*** 	CryptoInfoBufferInUse = 1;
; Line 928
	*** 000000	c6 06 00 00 01 		mov	BYTE PTR $S1033_CryptoInfoBufferInUse,1
;|*** 	return &CryptoInfoBuffer;
; Line 929
	*** 000005	b8 00 00 		mov	ax,OFFSET DGROUP:_CryptoInfoBuffer
;|*** 
;|*** #endif // GST_WINDOWS_BOOT
;|*** }
; Line 932
	*** 000008	c3 			ret	

_crypto_open	ENDP
	PUBLIC	_crypto_loadkey
_crypto_loadkey	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void crypto_loadkey (PKEY_INFO keyInfo, char *lpszUserKey, int nUserKeyLen)
;|***  *	\brief Load the key
;|***  *	\param[in out] int nUserKeyLen
;|***  *	\param[in] char * lpszUserKey
;|***  *	\param[in] PKEY_INFO keyInfo
;|***  *	\return void
;|***  *
;|***  */
;|*** void crypto_loadkey (PKEY_INFO keyInfo, char *lpszUserKey, int nUserKeyLen)
;|*** {
; Line 945
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	keyInfo = 4
;	lpszUserKey = 6
;	nUserKeyLen = 8
	*** 000005	8b 76 04 		mov	si,WORD PTR [bp+4]	;keyInfo
	*** 000008	8b 7e 08 		mov	di,WORD PTR [bp+8]	;nUserKeyLen
;|*** 	keyInfo->keyLength = nUserKeyLen;
; Line 946
	*** 00000b	89 7c 02 		mov	WORD PTR [si+2],di
;|*** 	burn (keyInfo->userKey, sizeof (keyInfo->userKey));
; Line 947
	*** 00000e	6a 40 			push	64	;0040H
	*** 000010	8d 44 04 		lea	ax,WORD PTR [si+4]
	*** 000013	50 			push	ax
	*** 000014	8b f0 			mov	si,ax
	*** 000016	e8 00 00 		call	_EraseMemory
	*** 000019	83 c4 04 		add	sp,4
;|*** 	memcpy (keyInfo->userKey, lpszUserKey, nUserKeyLen);
; Line 948
	*** 00001c	57 			push	di
	*** 00001d	ff 76 06 		push	WORD PTR [bp+6]	;lpszUserKey
	*** 000020	56 			push	si
	*** 000021	e8 00 00 		call	_memcpy
	*** 000024	83 c4 06 		add	sp,6
;|*** }
; Line 949
	*** 000027	5e 			pop	si
	*** 000028	5f 			pop	di
	*** 000029	c9 			leave	
	*** 00002a	c3 			ret	

_crypto_loadkey	ENDP
	PUBLIC	_crypto_close
_crypto_close	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void crypto_close (PCRYPTO_INFO cryptoInfo)
;|***  *	\brief Close the crytpo
;|***  *	\param[in] PCRYPTO_INFO cryptoInfo
;|***  *	\return void
;|***  *
;|***  */
;|*** void crypto_close (PCRYPTO_INFO cryptoInfo)
;|*** {
; Line 960
;	cryptoInfo = 4
;|*** #ifndef GST_WINDOWS_BOOT
;|*** 
;|*** 	if (cryptoInfo != NULL)
;|*** 	{
;|*** 		burn (cryptoInfo, sizeof (CRYPTO_INFO));
;|*** #ifndef DEVICE_DRIVER
;|*** 		VirtualUnlock (cryptoInfo, sizeof (CRYPTO_INFO));
;|*** #endif
;|*** 		GSTfree (cryptoInfo);
;|*** 	}
;|*** 
;|*** #else // GST_WINDOWS_BOOT
;|*** 
;|*** 	burn (&CryptoInfoBuffer, sizeof (CryptoInfoBuffer));
; Line 974
	*** 000000	68 62 04 		push	1122	;0462H
	*** 000003	68 00 00 		push	OFFSET DGROUP:_CryptoInfoBuffer
	*** 000006	e8 00 00 		call	_EraseMemory
	*** 000009	83 c4 04 		add	sp,4
;|*** 	CryptoInfoBufferInUse = FALSE;
; Line 975
	*** 00000c	c6 06 00 00 00 		mov	BYTE PTR $S1033_CryptoInfoBufferInUse,0
;|*** 
;|*** #endif // GST_WINDOWS_BOOT
;|*** }
; Line 978
	*** 000011	c3 			ret	

_crypto_close	ENDP
	PUBLIC	_EncryptBuffer
_EncryptBuffer	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_SINGLE_CIPHER_MODE
;|*** 
;|*** 
;|*** #ifndef GST_NO_COMPILER_INT64
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void Xor128 (unsigned __int64 *a, unsigned __int64 *b)
;|***  *	\brief Do a xor 128bits
;|***  *	\param[in] unsigned __int64 * b
;|***  *	\param[in out] unsigned __int64 * a
;|***  *	\return void
;|***  *
;|***  */
;|*** void Xor128 (unsigned __int64 *a, unsigned __int64 *b)
;|*** {
;|*** 	*a++ ^= *b++;
;|*** 	*a ^= *b;
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void Xor64 (unsigned __int64 *a, unsigned __int64 *b)
;|***  *	\brief Do a xor 64bits
;|***  *	\param[in out] unsigned __int64 * b
;|***  *	\param[in out] unsigned __int64 * a
;|***  *	\return void
;|***  *
;|***  */
;|*** void Xor64 (unsigned __int64 *a, unsigned __int64 *b)
;|*** {
;|*** 	*a ^= *b;
;|*** }
;|*** #endif	// #ifndef GST_NO_COMPILER_INT64
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncryptBuffer (unsigned __int8 *buf, GST_LARGEST_COMPILER_UINT len, PCRYPTO_INFO cryptoInfo)
;|***  *	\brief	buf:  data to be encrypted; the start of the buffer is assumed to be aligned with the start of a data unit.
;|***  *			len:  number of bytes to encrypt; must be divisible by the block size (for cascaded ciphers, divisible by the largest block size used within the cascade)
;|***  *	\param[in] PCRYPTO_INFO cryptoInfo
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT len
;|***  *	\param[in out] unsigned __int8 * buf
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncryptBuffer (unsigned __int8 *buf, GST_LARGEST_COMPILER_UINT len, PCRYPTO_INFO cryptoInfo)
;|*** {
; Line 1028
	*** 000000	c8 0c 00 00 		enter	12,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	buf = 4
;	len = 6
;	cryptoInfo = 10
;	register di = ks
;	ks2 = -4
;	dataUnitNo = -12
;	cipher = -2
;	register di = ks
;	ks2 = -4
;	dataUnitNo = -12
;	cipher = -2
	*** 000006	8b 76 0a 		mov	si,WORD PTR [bp+10]	;cryptoInfo
;|*** 	switch (cryptoInfo->mode)
; Line 1029
	*** 000009	8b 44 02 		mov	ax,WORD PTR [si+2]
;|*** 	{
;|*** 	case XTS:
;|*** 		{
;|*** 			unsigned __int8 *ks = cryptoInfo->ks;
;|*** 			unsigned __int8 *ks2 = cryptoInfo->ks2;
;|*** 			UINT64_STRUCT dataUnitNo;
;|*** 			int cipher;
;|*** 
;|*** 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
;|*** 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
;|*** 			// always assumed to be aligned with the start of a data unit.
;|*** 			dataUnitNo.LowPart = 0;
;|*** 			dataUnitNo.HighPart = 0;
;|*** 
;|*** 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
;|*** 				cipher != 0;
;|*** 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))
;|*** 			{
;|*** 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);
;|*** 
;|*** 				ks += CipherGetKeyScheduleSize (cipher);
;|*** 				ks2 += CipherGetKeyScheduleSize (cipher);
;|*** 			}
;|*** 		}
;|*** 		break;
;|*** 	case XTS8:
;|*** 		{
;|*** 				 unsigned __int8 *ks = cryptoInfo->ks;
;|*** 				 unsigned __int8 *ks2 = cryptoInfo->ks2;
;|*** 				 UINT64_STRUCT dataUnitNo;
;|*** 				 int cipher;
;|*** 
;|*** 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
;|*** 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
;|*** 				 // always assumed to be aligned with the start of a data unit.
;|*** 				 dataUnitNo.LowPart = 0;
;|*** 				 dataUnitNo.HighPart = 0;
;|*** 
;|*** 				 for (cipher = EAGetFirstCipher(cryptoInfo->ea);
;|*** 					 cipher != 0;
;|*** 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))
;|*** 				 {
;|*** 					 EncryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);
;|*** 
;|*** 					 ks += CipherGetKeyScheduleSize(cipher);
;|*** 					 ks2 += CipherGetKeyScheduleSize(cipher);
;|*** 				 }
;|*** 		}
;|*** 		break;
;|*** 
;|*** 	default:		
;|*** 		// Unknown/wrong ID
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
; Line 1083
	*** 00000c	48 			dec	ax
	*** 00000d	74 0d 			je	SHORT $SC1057
	*** 00000f	48 			dec	ax
	*** 000010	74 65 			je	SHORT $SC1065
;|*** 		GST_THROW_FATAL_EXCEPTION;
; Line 1082
	*** 000012	68 3a 04 		push	1082	;043aH
	*** 000015	e8 00 00 		call	_ThrowFatalException
	*** 000018	5b 			pop	bx
;|*** 	}
; Line 1083
	*** 000019	e9 b4 00 		jmp	$EX1052
;|*** 	case XTS:
; Line 1031
					$SC1057:
;|*** 		{
;|*** 			unsigned __int8 *ks = cryptoInfo->ks;
; Line 1033
	*** 00001c	8d 7c 04 		lea	di,WORD PTR [si+4]
;|*** 			unsigned __int8 *ks2 = cryptoInfo->ks2;
; Line 1034
	*** 00001f	8d 84 24 02 		lea	ax,WORD PTR [si+548]
	*** 000023	89 46 fc 		mov	WORD PTR [bp-4],ax	;ks2
;|*** 			UINT64_STRUCT dataUnitNo;
;|*** 			int cipher;
;|*** 
;|*** 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
;|*** 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
;|*** 			// always assumed to be aligned with the start of a data unit.
;|*** 			dataUnitNo.LowPart = 0;
; Line 1041
	*** 000026	66 2b c0 		sub	eax,eax
	*** 000029	66 89 46 f4 		mov	DWORD PTR [bp-12],eax	;dataUnitNo
;|*** 			dataUnitNo.HighPart = 0;
; Line 1042
	*** 00002d	66 89 46 f8 		mov	DWORD PTR [bp-8],eax
;|*** 
;|*** 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
;|*** 				cipher != 0;
;|*** 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))
; Line 1046
	*** 000031	ff 34 			push	WORD PTR [si]
	*** 000033	e8 00 00 		call	_EAGetFirstCipher
	*** 000036	5b 			pop	bx
	*** 000037	89 46 fe 		mov	WORD PTR [bp-2],ax	;cipher
					$L1221:
	*** 00003a	8b f0 			mov	si,ax
	*** 00003c	0b f0 			or	si,ax
	*** 00003e	0f 84 8e 00 		je	$EX1052
;|*** 			{
;|*** 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);
; Line 1048
	*** 000042	56 			push	si
	*** 000043	ff 76 fc 		push	WORD PTR [bp-4]	;ks2
	*** 000046	57 			push	di
	*** 000047	6a 00 			push	0
	*** 000049	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;dataUnitNo
	*** 00004c	50 			push	ax
	*** 00004d	66 ff 76 06 		push	DWORD PTR [bp+6]	;len
	*** 000051	ff 76 04 		push	WORD PTR [bp+4]	;buf
	*** 000054	e8 00 00 		call	_EncryptBufferXTS
	*** 000057	83 c4 10 		add	sp,16	;0010H
;|*** 
;|*** 				ks += CipherGetKeyScheduleSize (cipher);
; Line 1050
	*** 00005a	56 			push	si
	*** 00005b	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 00005e	5b 			pop	bx
	*** 00005f	03 f8 			add	di,ax
;|*** 				ks2 += CipherGetKeyScheduleSize (cipher);
; Line 1051
	*** 000061	56 			push	si
	*** 000062	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 000065	5b 			pop	bx
	*** 000066	01 46 fc 		add	WORD PTR [bp-4],ax	;ks2
;|*** 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))
; Line 1046
	*** 000069	56 			push	si
	*** 00006a	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;cryptoInfo
	*** 00006d	ff 37 			push	WORD PTR [bx]
	*** 00006f	e8 00 00 		call	_EAGetNextCipher
	*** 000072	83 c4 04 		add	sp,4
	*** 000075	eb c3 			jmp	SHORT $L1221
;|*** 			{
;|*** 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);
;|*** 
;|*** 				ks += CipherGetKeyScheduleSize (cipher);
;|*** 				ks2 += CipherGetKeyScheduleSize (cipher);
;|*** 			}
;|*** 		}
;|*** 		break;
;|*** 	case XTS8:
; Line 1055
					$SC1065:
;|*** 		{
;|*** 				 unsigned __int8 *ks = cryptoInfo->ks;
; Line 1057
	*** 000077	8d 7c 04 		lea	di,WORD PTR [si+4]
;|*** 				 unsigned __int8 *ks2 = cryptoInfo->ks2;
; Line 1058
	*** 00007a	8d 84 24 02 		lea	ax,WORD PTR [si+548]
	*** 00007e	89 46 fc 		mov	WORD PTR [bp-4],ax	;ks2
;|*** 				 UINT64_STRUCT dataUnitNo;
;|*** 				 int cipher;
;|*** 
;|*** 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
;|*** 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
;|*** 				 // always assumed to be aligned with the start of a data unit.
;|*** 				 dataUnitNo.LowPart = 0;
; Line 1065
	*** 000081	66 2b c0 		sub	eax,eax
	*** 000084	66 89 46 f4 		mov	DWORD PTR [bp-12],eax	;dataUnitNo
;|*** 				 dataUnitNo.HighPart = 0;
; Line 1066
	*** 000088	66 89 46 f8 		mov	DWORD PTR [bp-8],eax
;|*** 
;|*** 				 for (cipher = EAGetFirstCipher(cryptoInfo->ea);
;|*** 					 cipher != 0;
;|*** 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))
; Line 1070
	*** 00008c	ff 34 			push	WORD PTR [si]
	*** 00008e	e8 00 00 		call	_EAGetFirstCipher
	*** 000091	5b 			pop	bx
	*** 000092	89 46 fe 		mov	WORD PTR [bp-2],ax	;cipher
					$L1222:
	*** 000095	8b f0 			mov	si,ax
	*** 000097	0b f0 			or	si,ax
	*** 000099	74 35 			je	SHORT $EX1052
;|*** 				 {
;|*** 					 EncryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);
; Line 1072
	*** 00009b	56 			push	si
	*** 00009c	ff 76 fc 		push	WORD PTR [bp-4]	;ks2
	*** 00009f	57 			push	di
	*** 0000a0	6a 00 			push	0
	*** 0000a2	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;dataUnitNo
	*** 0000a5	50 			push	ax
	*** 0000a6	66 ff 76 06 		push	DWORD PTR [bp+6]	;len
	*** 0000aa	ff 76 04 		push	WORD PTR [bp+4]	;buf
	*** 0000ad	e8 00 00 		call	_EncryptBufferXTS8Byte
	*** 0000b0	83 c4 10 		add	sp,16	;0010H
;|*** 
;|*** 					 ks += CipherGetKeyScheduleSize(cipher);
; Line 1074
	*** 0000b3	56 			push	si
	*** 0000b4	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 0000b7	5b 			pop	bx
	*** 0000b8	03 f8 			add	di,ax
;|*** 					 ks2 += CipherGetKeyScheduleSize(cipher);
; Line 1075
	*** 0000ba	56 			push	si
	*** 0000bb	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 0000be	5b 			pop	bx
	*** 0000bf	01 46 fc 		add	WORD PTR [bp-4],ax	;ks2
;|*** 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))
; Line 1070
	*** 0000c2	56 			push	si
	*** 0000c3	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;cryptoInfo
	*** 0000c6	ff 37 			push	WORD PTR [bx]
	*** 0000c8	e8 00 00 		call	_EAGetNextCipher
	*** 0000cb	83 c4 04 		add	sp,4
	*** 0000ce	eb c5 			jmp	SHORT $L1222
;|*** 				 {
;|*** 					 EncryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);
;|*** 
;|*** 					 ks += CipherGetKeyScheduleSize(cipher);
;|*** 					 ks2 += CipherGetKeyScheduleSize(cipher);
;|*** 				 }
;|*** 		}
;|*** 		break;
;|*** 
;|*** 	default:		
;|*** 		// Unknown/wrong ID
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
;|*** }
; Line 1084
					$EX1052:
	*** 0000d0	5e 			pop	si
	*** 0000d1	5f 			pop	di
	*** 0000d2	c9 			leave	
	*** 0000d3	c3 			ret	

_EncryptBuffer	ENDP
	PUBLIC	_EncryptDataUnits
_EncryptDataUnits	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void void EncryptDataUnits (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, uint32 nbrUnits, PCRYPTO_INFO ci)
;|***  *	\brief	buf:			data to be encrypted
;|***  *			unitNo:		sequential number of the data unit with which the buffer starts
;|***  *			nbrUnits:	number of data units in the buffer
;|***  *	\param[in] PCRYPTO_INFO ci
;|***  *	\param[in] uint32 nbrUnits
;|***  *	\param[in] const UINT64_STRUCT * structUnitNo
;|***  *	\param[in out] unsigned __int8 * buf
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncryptDataUnits (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, uint32 nbrUnits, PCRYPTO_INFO ci)
;|*** #ifndef GST_WINDOWS_BOOT
;|*** {
;|*** 	EncryptionThreadPoolDoWork (EncryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncryptDataUnitsCurrentThread (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, GST_LARGEST_COMPILER_UINT nbrUnits, PCRYPTO_INFO ci)
;|***  *	\brief Encryt data of current thread
;|***  *	\param[in] PCRYPTO_INFO ci
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT nbrUnits
;|***  *	\param[in] UINT64_STRUCT * structUnitNo
;|***  *	\param[in out] unsigned __int8 * buf
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncryptDataUnitsCurrentThread (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, GST_LARGEST_COMPILER_UINT nbrUnits, PCRYPTO_INFO ci)
;|*** #endif // !GST_WINDOWS_BOOT
;|*** {
; Line 1118
	*** 000000	c8 06 00 00 		enter	6,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	buf = 4
;	structUnitNo = 6
;	nbrUnits = 8
;	ci = 12
;	ea = -2
;	ks = -6
;	ks2 = -4
;	register si = cipher
	*** 000006	8b 76 0c 		mov	si,WORD PTR [bp+12]	;ci
;|*** 	int ea = ci->ea;
; Line 1119
	*** 000009	8b 3c 			mov	di,WORD PTR [si]
;|*** 	unsigned __int8 *ks = ci->ks;
; Line 1120
	*** 00000b	8d 44 04 		lea	ax,WORD PTR [si+4]
	*** 00000e	89 46 fa 		mov	WORD PTR [bp-6],ax	;ks
;|*** 	unsigned __int8 *ks2 = ci->ks2;
; Line 1121
	*** 000011	8d 84 24 02 		lea	ax,WORD PTR [si+548]
	*** 000015	89 46 fc 		mov	WORD PTR [bp-4],ax	;ks2
;|*** 	int cipher;
;|*** 
;|*** 	switch (ci->mode)
; Line 1124
	*** 000018	8b 44 02 		mov	ax,WORD PTR [si+2]
;|*** 	{
;|*** 	case XTS:
;|*** 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))
;|*** 		{
;|*** 			EncryptBufferXTS (buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
;|*** 
;|*** 			ks += CipherGetKeyScheduleSize (cipher);
;|*** 			ks2 += CipherGetKeyScheduleSize (cipher);
;|*** 		}
;|*** 		break;
;|*** 	case XTS8:
;|*** 		for (cipher = EAGetFirstCipher(ea); cipher != 0; cipher = EAGetNextCipher(ea, cipher))
;|*** 		{
;|*** 			EncryptBufferXTS8Byte(buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
;|*** 
;|*** 			ks += CipherGetKeyScheduleSize(cipher);
;|*** 			ks2 += CipherGetKeyScheduleSize(cipher);
;|*** 		}
;|*** 		break;
;|*** 	default:		
;|*** 		// Unknown/wrong ID
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
; Line 1159
	*** 00001b	48 			dec	ax
	*** 00001c	74 0d 			je	SHORT $SC1091
	*** 00001e	48 			dec	ax
	*** 00001f	74 57 			je	SHORT $SC1095
;|*** 		GST_THROW_FATAL_EXCEPTION;
; Line 1158
	*** 000021	68 86 04 		push	1158	;0486H
	*** 000024	e8 00 00 		call	_ThrowFatalException
	*** 000027	5b 			pop	bx
;|*** 	}
; Line 1159
	*** 000028	e9 98 00 		jmp	$EX1082
;|*** 	case XTS:
; Line 1126
					$SC1091:
;|*** 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))
; Line 1127
	*** 00002b	57 			push	di
	*** 00002c	e8 00 00 		call	_EAGetFirstCipher
	*** 00002f	5b 			pop	bx
	*** 000030	8b f0 			mov	si,ax
	*** 000032	89 7e fe 		mov	WORD PTR [bp-2],di	;ea
	*** 000035	8b 7e fc 		mov	di,WORD PTR [bp-4]	;ks2
					$F1092:
	*** 000038	0b f0 			or	si,ax
	*** 00003a	0f 84 85 00 		je	$EX1082
;|*** 		{
;|*** 			EncryptBufferXTS (buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
; Line 1135
	*** 00003e	56 			push	si
	*** 00003f	57 			push	di
	*** 000040	ff 76 fa 		push	WORD PTR [bp-6]	;ks
	*** 000043	6a 00 			push	0
	*** 000045	ff 76 06 		push	WORD PTR [bp+6]	;structUnitNo
	*** 000048	66 8b 46 08 		mov	eax,DWORD PTR [bp+8]	;nbrUnits
	*** 00004c	66 c1 e0 09 		shl	eax,9
	*** 000050	66 50 			push	eax
	*** 000052	ff 76 04 		push	WORD PTR [bp+4]	;buf
	*** 000055	e8 00 00 		call	_EncryptBufferXTS
	*** 000058	83 c4 10 		add	sp,16	;0010H
;|*** 
;|*** 			ks += CipherGetKeyScheduleSize (cipher);
; Line 1137
	*** 00005b	56 			push	si
	*** 00005c	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 00005f	5b 			pop	bx
	*** 000060	01 46 fa 		add	WORD PTR [bp-6],ax	;ks
;|*** 			ks2 += CipherGetKeyScheduleSize (cipher);
; Line 1138
	*** 000063	56 			push	si
	*** 000064	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 000067	5b 			pop	bx
	*** 000068	03 f8 			add	di,ax
;|*** 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))
; Line 1127
	*** 00006a	56 			push	si
	*** 00006b	ff 76 fe 		push	WORD PTR [bp-2]	;ea
	*** 00006e	e8 00 00 		call	_EAGetNextCipher
	*** 000071	83 c4 04 		add	sp,4
	*** 000074	8b f0 			mov	si,ax
	*** 000076	eb c0 			jmp	SHORT $F1092
;|*** 		{
;|*** 			EncryptBufferXTS (buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
;|*** 
;|*** 			ks += CipherGetKeyScheduleSize (cipher);
;|*** 			ks2 += CipherGetKeyScheduleSize (cipher);
;|*** 		}
;|*** 		break;
;|*** 	case XTS8:
; Line 1141
					$SC1095:
;|*** 		for (cipher = EAGetFirstCipher(ea); cipher != 0; cipher = EAGetNextCipher(ea, cipher))
; Line 1142
	*** 000078	57 			push	di
	*** 000079	e8 00 00 		call	_EAGetFirstCipher
	*** 00007c	5b 			pop	bx
	*** 00007d	8b f0 			mov	si,ax
	*** 00007f	89 7e fe 		mov	WORD PTR [bp-2],di	;ea
	*** 000082	8b 7e fa 		mov	di,WORD PTR [bp-6]	;ks
					$F1096:
	*** 000085	0b f0 			or	si,ax
	*** 000087	74 3a 			je	SHORT $EX1082
;|*** 		{
;|*** 			EncryptBufferXTS8Byte(buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
; Line 1150
	*** 000089	56 			push	si
	*** 00008a	ff 76 fc 		push	WORD PTR [bp-4]	;ks2
	*** 00008d	57 			push	di
	*** 00008e	6a 00 			push	0
	*** 000090	ff 76 06 		push	WORD PTR [bp+6]	;structUnitNo
	*** 000093	66 8b 46 08 		mov	eax,DWORD PTR [bp+8]	;nbrUnits
	*** 000097	66 c1 e0 09 		shl	eax,9
	*** 00009b	66 50 			push	eax
	*** 00009d	ff 76 04 		push	WORD PTR [bp+4]	;buf
	*** 0000a0	e8 00 00 		call	_EncryptBufferXTS8Byte
	*** 0000a3	83 c4 10 		add	sp,16	;0010H
;|*** 
;|*** 			ks += CipherGetKeyScheduleSize(cipher);
; Line 1152
	*** 0000a6	56 			push	si
	*** 0000a7	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 0000aa	5b 			pop	bx
	*** 0000ab	03 f8 			add	di,ax
;|*** 			ks2 += CipherGetKeyScheduleSize(cipher);
; Line 1153
	*** 0000ad	56 			push	si
	*** 0000ae	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 0000b1	5b 			pop	bx
	*** 0000b2	01 46 fc 		add	WORD PTR [bp-4],ax	;ks2
;|*** 		for (cipher = EAGetFirstCipher(ea); cipher != 0; cipher = EAGetNextCipher(ea, cipher))
; Line 1142
	*** 0000b5	56 			push	si
	*** 0000b6	ff 76 fe 		push	WORD PTR [bp-2]	;ea
	*** 0000b9	e8 00 00 		call	_EAGetNextCipher
	*** 0000bc	83 c4 04 		add	sp,4
	*** 0000bf	8b f0 			mov	si,ax
	*** 0000c1	eb c2 			jmp	SHORT $F1096
;|*** 		{
;|*** 			EncryptBufferXTS8Byte(buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
;|*** 
;|*** 			ks += CipherGetKeyScheduleSize(cipher);
;|*** 			ks2 += CipherGetKeyScheduleSize(cipher);
;|*** 		}
;|*** 		break;
;|*** 	default:		
;|*** 		// Unknown/wrong ID
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
;|*** }
; Line 1160
					$EX1082:
	*** 0000c3	5e 			pop	si
	*** 0000c4	5f 			pop	di
	*** 0000c5	c9 			leave	
	*** 0000c6	c3 			ret	

_EncryptDataUnits	ENDP
	PUBLIC	_DecryptBuffer
_DecryptBuffer	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecryptBuffer (unsigned __int8 *buf, GST_LARGEST_COMPILER_UINT len, PCRYPTO_INFO cryptoInfo)
;|***  *	\brief	buf:  data to be decrypted; the start of the buffer is assumed to be aligned with the start of a data unit.
;|***  *			len:  number of bytes to decrypt; must be divisible by the block size (for cascaded ciphers, divisible by the largest block size used within the cascade)
;|***  *	\param[in] PCRYPTO_INFO cryptoInfo
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT len
;|***  *	\param[in] unsigned __int8 * buf
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecryptBuffer (unsigned __int8 *buf, GST_LARGEST_COMPILER_UINT len, PCRYPTO_INFO cryptoInfo)
;|*** {
; Line 1174
	*** 000000	c8 0c 00 00 		enter	12,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	buf = 4
;	len = 6
;	cryptoInfo = 10
;	register di = ks
;	ks2 = -4
;	dataUnitNo = -12
;	cipher = -2
;	register di = ks
;	ks2 = -4
;	dataUnitNo = -12
;	cipher = -2
	*** 000006	8b 76 0a 		mov	si,WORD PTR [bp+10]	;cryptoInfo
;|*** 	switch (cryptoInfo->mode)
; Line 1175
	*** 000009	8b 44 02 		mov	ax,WORD PTR [si+2]
;|*** 	{
;|*** 	case XTS:
;|*** 		{
;|*** 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);
;|*** 			unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize (cryptoInfo->ea);
;|*** 			UINT64_STRUCT dataUnitNo;
;|*** 			int cipher;
;|*** 
;|*** 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
;|*** 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
;|*** 			// always assumed to be aligned with the start of the data unit 0.
;|*** 			dataUnitNo.LowPart = 0;
;|*** 			dataUnitNo.HighPart = 0;
;|*** 
;|*** 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
;|*** 				cipher != 0;
;|*** 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))
;|*** 			{
;|*** 				ks -= CipherGetKeyScheduleSize (cipher);
;|*** 				ks2 -= CipherGetKeyScheduleSize (cipher);
;|*** 
;|*** 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);
;|*** 			}
;|*** 		}
;|*** 		break;
;|*** 	case XTS8:
;|*** 	{
;|*** 				 unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize(cryptoInfo->ea);
;|*** 				 unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize(cryptoInfo->ea);
;|*** 				 UINT64_STRUCT dataUnitNo;
;|*** 				 int cipher;
;|*** 
;|*** 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
;|*** 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
;|*** 				 // always assumed to be aligned with the start of the data unit 0.
;|*** 				 dataUnitNo.LowPart = 0;
;|*** 				 dataUnitNo.HighPart = 0;
;|*** 
;|*** 				 for (cipher = EAGetLastCipher(cryptoInfo->ea);
;|*** 					 cipher != 0;
;|*** 					 cipher = EAGetPreviousCipher(cryptoInfo->ea, cipher))
;|*** 				 {
;|*** 					 ks -= CipherGetKeyScheduleSize(cipher);
;|*** 					 ks2 -= CipherGetKeyScheduleSize(cipher);
;|*** 
;|*** 					 DecryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);
;|*** 				 }
;|*** 	}
;|*** 		break;
;|*** 	default:		
;|*** 		// Unknown/wrong ID
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
; Line 1228
	*** 00000c	48 			dec	ax
	*** 00000d	74 0d 			je	SHORT $SC1111
	*** 00000f	48 			dec	ax
	*** 000010	74 76 			je	SHORT $SC1119
;|*** 		GST_THROW_FATAL_EXCEPTION;
; Line 1227
	*** 000012	68 cb 04 		push	1227	;04cbH
	*** 000015	e8 00 00 		call	_ThrowFatalException
	*** 000018	5b 			pop	bx
;|*** 	}
; Line 1228
	*** 000019	e9 d6 00 		jmp	$EX1106
;|*** 	case XTS:
; Line 1177
					$SC1111:
;|*** 		{
;|*** 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);
; Line 1179
	*** 00001c	ff 34 			push	WORD PTR [si]
	*** 00001e	e8 00 00 		call	_EAGetKeyScheduleSize
	*** 000021	5b 			pop	bx
	*** 000022	8b f8 			mov	di,ax
	*** 000024	03 fe 			add	di,si
	*** 000026	83 c7 04 		add	di,4
;|*** 			unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize (cryptoInfo->ea);
; Line 1180
	*** 000029	ff 34 			push	WORD PTR [si]
	*** 00002b	e8 00 00 		call	_EAGetKeyScheduleSize
	*** 00002e	5b 			pop	bx
	*** 00002f	03 c6 			add	ax,si
	*** 000031	05 24 02 		add	ax,548	;0224H
	*** 000034	89 46 fc 		mov	WORD PTR [bp-4],ax	;ks2
;|*** 			UINT64_STRUCT dataUnitNo;
;|*** 			int cipher;
;|*** 
;|*** 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
;|*** 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
;|*** 			// always assumed to be aligned with the start of the data unit 0.
;|*** 			dataUnitNo.LowPart = 0;
; Line 1187
	*** 000037	66 2b c0 		sub	eax,eax
	*** 00003a	66 89 46 f4 		mov	DWORD PTR [bp-12],eax	;dataUnitNo
;|*** 			dataUnitNo.HighPart = 0;
; Line 1188
	*** 00003e	66 89 46 f8 		mov	DWORD PTR [bp-8],eax
;|*** 
;|*** 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
;|*** 				cipher != 0;
;|*** 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))
; Line 1192
	*** 000042	ff 34 			push	WORD PTR [si]
	*** 000044	e8 00 00 		call	_EAGetLastCipher
	*** 000047	5b 			pop	bx
	*** 000048	89 46 fe 		mov	WORD PTR [bp-2],ax	;cipher
					$L1223:
	*** 00004b	8b f0 			mov	si,ax
	*** 00004d	0b f0 			or	si,ax
	*** 00004f	0f 84 9f 00 		je	$EX1106
;|*** 			{
;|*** 				ks -= CipherGetKeyScheduleSize (cipher);
; Line 1194
	*** 000053	56 			push	si
	*** 000054	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 000057	5b 			pop	bx
	*** 000058	2b f8 			sub	di,ax
;|*** 				ks2 -= CipherGetKeyScheduleSize (cipher);
;|*** 
;|*** 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);
; Line 1197
	*** 00005a	56 			push	si
	*** 00005b	56 			push	si
	*** 00005c	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 00005f	5b 			pop	bx
	*** 000060	29 46 fc 		sub	WORD PTR [bp-4],ax	;ks2
	*** 000063	ff 76 fc 		push	WORD PTR [bp-4]	;ks2
	*** 000066	57 			push	di
	*** 000067	6a 00 			push	0
	*** 000069	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;dataUnitNo
	*** 00006c	50 			push	ax
	*** 00006d	66 ff 76 06 		push	DWORD PTR [bp+6]	;len
	*** 000071	ff 76 04 		push	WORD PTR [bp+4]	;buf
	*** 000074	e8 00 00 		call	_DecryptBufferXTS
	*** 000077	83 c4 10 		add	sp,16	;0010H
;|*** 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))
; Line 1192
	*** 00007a	56 			push	si
	*** 00007b	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;cryptoInfo
	*** 00007e	ff 37 			push	WORD PTR [bx]
	*** 000080	e8 00 00 		call	_EAGetPreviousCipher
	*** 000083	83 c4 04 		add	sp,4
	*** 000086	eb c3 			jmp	SHORT $L1223
;|*** 			{
;|*** 				ks -= CipherGetKeyScheduleSize (cipher);
;|*** 				ks2 -= CipherGetKeyScheduleSize (cipher);
;|*** 
;|*** 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);
;|*** 			}
;|*** 		}
;|*** 		break;
;|*** 	case XTS8:
; Line 1201
					$SC1119:
;|*** 	{
;|*** 				 unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize(cryptoInfo->ea);
; Line 1203
	*** 000088	ff 34 			push	WORD PTR [si]
	*** 00008a	e8 00 00 		call	_EAGetKeyScheduleSize
	*** 00008d	5b 			pop	bx
	*** 00008e	8b f8 			mov	di,ax
	*** 000090	03 fe 			add	di,si
	*** 000092	83 c7 04 		add	di,4
;|*** 				 unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize(cryptoInfo->ea);
; Line 1204
	*** 000095	ff 34 			push	WORD PTR [si]
	*** 000097	e8 00 00 		call	_EAGetKeyScheduleSize
	*** 00009a	5b 			pop	bx
	*** 00009b	03 c6 			add	ax,si
	*** 00009d	05 24 02 		add	ax,548	;0224H
	*** 0000a0	89 46 fc 		mov	WORD PTR [bp-4],ax	;ks2
;|*** 				 UINT64_STRUCT dataUnitNo;
;|*** 				 int cipher;
;|*** 
;|*** 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
;|*** 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
;|*** 				 // always assumed to be aligned with the start of the data unit 0.
;|*** 				 dataUnitNo.LowPart = 0;
; Line 1211
	*** 0000a3	66 2b c0 		sub	eax,eax
	*** 0000a6	66 89 46 f4 		mov	DWORD PTR [bp-12],eax	;dataUnitNo
;|*** 				 dataUnitNo.HighPart = 0;
; Line 1212
	*** 0000aa	66 89 46 f8 		mov	DWORD PTR [bp-8],eax
;|*** 
;|*** 				 for (cipher = EAGetLastCipher(cryptoInfo->ea);
;|*** 					 cipher != 0;
;|*** 					 cipher = EAGetPreviousCipher(cryptoInfo->ea, cipher))
; Line 1216
	*** 0000ae	ff 34 			push	WORD PTR [si]
	*** 0000b0	e8 00 00 		call	_EAGetLastCipher
	*** 0000b3	5b 			pop	bx
	*** 0000b4	89 46 fe 		mov	WORD PTR [bp-2],ax	;cipher
					$L1224:
	*** 0000b7	8b f0 			mov	si,ax
	*** 0000b9	0b f0 			or	si,ax
	*** 0000bb	74 35 			je	SHORT $EX1106
;|*** 				 {
;|*** 					 ks -= CipherGetKeyScheduleSize(cipher);
; Line 1218
	*** 0000bd	56 			push	si
	*** 0000be	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 0000c1	5b 			pop	bx
	*** 0000c2	2b f8 			sub	di,ax
;|*** 					 ks2 -= CipherGetKeyScheduleSize(cipher);
;|*** 
;|*** 					 DecryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);
; Line 1221
	*** 0000c4	56 			push	si
	*** 0000c5	56 			push	si
	*** 0000c6	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 0000c9	5b 			pop	bx
	*** 0000ca	29 46 fc 		sub	WORD PTR [bp-4],ax	;ks2
	*** 0000cd	ff 76 fc 		push	WORD PTR [bp-4]	;ks2
	*** 0000d0	57 			push	di
	*** 0000d1	6a 00 			push	0
	*** 0000d3	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;dataUnitNo
	*** 0000d6	50 			push	ax
	*** 0000d7	66 ff 76 06 		push	DWORD PTR [bp+6]	;len
	*** 0000db	ff 76 04 		push	WORD PTR [bp+4]	;buf
	*** 0000de	e8 00 00 		call	_DecryptBufferXTS8Byte
	*** 0000e1	83 c4 10 		add	sp,16	;0010H
;|*** 					 cipher = EAGetPreviousCipher(cryptoInfo->ea, cipher))
; Line 1216
	*** 0000e4	56 			push	si
	*** 0000e5	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;cryptoInfo
	*** 0000e8	ff 37 			push	WORD PTR [bx]
	*** 0000ea	e8 00 00 		call	_EAGetPreviousCipher
	*** 0000ed	83 c4 04 		add	sp,4
	*** 0000f0	eb c5 			jmp	SHORT $L1224
;|*** 				 {
;|*** 					 ks -= CipherGetKeyScheduleSize(cipher);
;|*** 					 ks2 -= CipherGetKeyScheduleSize(cipher);
;|*** 
;|*** 					 DecryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);
;|*** 				 }
;|*** 	}
;|*** 		break;
;|*** 	default:		
;|*** 		// Unknown/wrong ID
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
;|*** }
; Line 1229
					$EX1106:
	*** 0000f2	5e 			pop	si
	*** 0000f3	5f 			pop	di
	*** 0000f4	c9 			leave	
	*** 0000f5	c3 			ret	

_DecryptBuffer	ENDP
	PUBLIC	_DecryptDataUnits
_DecryptDataUnits	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecryptDataUnits (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, uint32 nbrUnits, PCRYPTO_INFO ci)
;|***  *	\brief	buf:		data to be decrypted
;|***  *			unitNo:		sequential number of the data unit with which the buffer starts
;|***  *			nbrUnits:	number of data units in the buffer
;|***  *	\param[in] PCRYPTO_INFO ci
;|***  *	\param[in] uint32 nbrUnits
;|***  *	\param[in] UINT64_STRUCT * structUnitNo
;|***  *	\param[in out] unsigned __int8 * buf
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecryptDataUnits (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, uint32 nbrUnits, PCRYPTO_INFO ci)
;|*** #ifndef GST_WINDOWS_BOOT
;|*** {
;|*** 	EncryptionThreadPoolDoWork (DecryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecryptDataUnitsCurrentThread (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, GST_LARGEST_COMPILER_UINT nbrUnits, PCRYPTO_INFO ci)
;|***  *	\brief	buf:		data to be decrypted
;|***  *			unitNo:		sequential number of the data unit with which the buffer starts
;|***  *			nbrUnits:	number of data units in the buffer
;|***  *	\param[in] PCRYPTO_INFO ci
;|***  *	\param[in] uint32 nbrUnits
;|***  *	\param[in] UINT64_STRUCT* structUnitNo
;|***  *	\param[in out] unsigned __int8* buf
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecryptDataUnitsCurrentThread (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, GST_LARGEST_COMPILER_UINT nbrUnits, PCRYPTO_INFO ci)
;|*** #endif // !GST_WINDOWS_BOOT
;|*** {
; Line 1265
	*** 000000	c8 08 00 00 		enter	8,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	buf = 4
;	structUnitNo = 6
;	nbrUnits = 8
;	ci = 12
;	ea = -8
;	ks = -4
;	ks2 = -6
;	cipher = -2
	*** 000006	8b 76 0c 		mov	si,WORD PTR [bp+12]	;ci
;|*** 	int ea = ci->ea;
; Line 1266
	*** 000009	8b 3c 			mov	di,WORD PTR [si]
;|*** 	unsigned __int8 *ks = ci->ks;
; Line 1267
	*** 00000b	8d 4c 04 		lea	cx,WORD PTR [si+4]
;|*** 	unsigned __int8 *ks2 = ci->ks2;
; Line 1268
	*** 00000e	8d 84 24 02 		lea	ax,WORD PTR [si+548]
	*** 000012	89 46 fa 		mov	WORD PTR [bp-6],ax	;ks2
;|*** 	int cipher;
;|*** 
;|*** 	switch (ci->mode)
; Line 1271
	*** 000015	8b 44 02 		mov	ax,WORD PTR [si+2]
;|*** 	{
;|*** 	case XTS:
;|*** 		ks += EAGetKeyScheduleSize (ea);
;|*** 		ks2 += EAGetKeyScheduleSize (ea);
;|*** 
;|*** 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))
;|*** 		{
;|*** 			ks -= CipherGetKeyScheduleSize (cipher);
;|*** 			ks2 -= CipherGetKeyScheduleSize (cipher);
;|*** 
;|*** 			DecryptBufferXTS (buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
;|*** 		}
;|*** 		break;
;|*** 	case XTS8:
;|*** 		ks += EAGetKeyScheduleSize(ea);
;|*** 		ks2 += EAGetKeyScheduleSize(ea);
;|*** 
;|*** 		for (cipher = EAGetLastCipher(ea); cipher != 0; cipher = EAGetPreviousCipher(ea, cipher))
;|*** 		{
;|*** 			ks -= CipherGetKeyScheduleSize(cipher);
;|*** 			ks2 -= CipherGetKeyScheduleSize(cipher);
;|*** 
;|*** 			DecryptBufferXTS8Byte(buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
;|*** 		}
;|*** 		break;
;|*** 	default:		
;|*** 		// Unknown/wrong ID
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
; Line 1312
	*** 000018	48 			dec	ax
	*** 000019	74 0d 			je	SHORT $L1201
	*** 00001b	48 			dec	ax
	*** 00001c	74 6b 			je	SHORT $L1200
;|*** 		GST_THROW_FATAL_EXCEPTION;
; Line 1311
	*** 00001e	68 1f 05 		push	1311	;051fH
	*** 000021	e8 00 00 		call	_ThrowFatalException
	*** 000024	5b 			pop	bx
;|*** 	}
; Line 1312
	*** 000025	e9 c0 00 		jmp	$EX1136
					$L1201:
;|*** 	case XTS:
; Line 1273
	*** 000028	8b f1 			mov	si,cx
;|*** 		ks += EAGetKeyScheduleSize (ea);
; Line 1274
	*** 00002a	57 			push	di
	*** 00002b	e8 00 00 		call	_EAGetKeyScheduleSize
	*** 00002e	5b 			pop	bx
	*** 00002f	03 f0 			add	si,ax
;|*** 		ks2 += EAGetKeyScheduleSize (ea);
; Line 1275
	*** 000031	57 			push	di
	*** 000032	e8 00 00 		call	_EAGetKeyScheduleSize
	*** 000035	5b 			pop	bx
	*** 000036	01 46 fa 		add	WORD PTR [bp-6],ax	;ks2
;|*** 
;|*** 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))
; Line 1277
	*** 000039	57 			push	di
	*** 00003a	e8 00 00 		call	_EAGetLastCipher
	*** 00003d	5b 			pop	bx
	*** 00003e	89 7e f8 		mov	WORD PTR [bp-8],di	;ea
	*** 000041	89 76 fc 		mov	WORD PTR [bp-4],si	;ks
	*** 000044	8b f0 			mov	si,ax
	*** 000046	8b 7e fc 		mov	di,WORD PTR [bp-4]	;ks
					$F1146:
	*** 000049	0b f0 			or	si,ax
	*** 00004b	0f 84 99 00 		je	$EX1136
;|*** 		{
;|*** 			ks -= CipherGetKeyScheduleSize (cipher);
; Line 1279
	*** 00004f	56 			push	si
	*** 000050	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 000053	5b 			pop	bx
	*** 000054	2b f8 			sub	di,ax
;|*** 			ks2 -= CipherGetKeyScheduleSize (cipher);
;|*** 
;|*** 			DecryptBufferXTS (buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
; Line 1288
	*** 000056	56 			push	si
	*** 000057	56 			push	si
	*** 000058	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 00005b	5b 			pop	bx
	*** 00005c	29 46 fa 		sub	WORD PTR [bp-6],ax	;ks2
	*** 00005f	ff 76 fa 		push	WORD PTR [bp-6]	;ks2
	*** 000062	57 			push	di
	*** 000063	6a 00 			push	0
	*** 000065	ff 76 06 		push	WORD PTR [bp+6]	;structUnitNo
	*** 000068	66 8b 46 08 		mov	eax,DWORD PTR [bp+8]	;nbrUnits
	*** 00006c	66 c1 e0 09 		shl	eax,9
	*** 000070	66 50 			push	eax
	*** 000072	ff 76 04 		push	WORD PTR [bp+4]	;buf
	*** 000075	e8 00 00 		call	_DecryptBufferXTS
	*** 000078	83 c4 10 		add	sp,16	;0010H
;|*** 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))
; Line 1277
	*** 00007b	56 			push	si
	*** 00007c	ff 76 f8 		push	WORD PTR [bp-8]	;ea
	*** 00007f	e8 00 00 		call	_EAGetPreviousCipher
	*** 000082	83 c4 04 		add	sp,4
	*** 000085	8b f0 			mov	si,ax
	*** 000087	eb c0 			jmp	SHORT $F1146
					$L1200:
;|*** 		{
;|*** 			ks -= CipherGetKeyScheduleSize (cipher);
;|*** 			ks2 -= CipherGetKeyScheduleSize (cipher);
;|*** 
;|*** 			DecryptBufferXTS (buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
;|*** 		}
;|*** 		break;
;|*** 	case XTS8:
; Line 1291
	*** 000089	8b f1 			mov	si,cx
;|*** 		ks += EAGetKeyScheduleSize(ea);
; Line 1292
	*** 00008b	57 			push	di
	*** 00008c	e8 00 00 		call	_EAGetKeyScheduleSize
	*** 00008f	5b 			pop	bx
	*** 000090	03 f0 			add	si,ax
;|*** 		ks2 += EAGetKeyScheduleSize(ea);
; Line 1293
	*** 000092	57 			push	di
	*** 000093	e8 00 00 		call	_EAGetKeyScheduleSize
	*** 000096	5b 			pop	bx
	*** 000097	01 46 fa 		add	WORD PTR [bp-6],ax	;ks2
;|*** 
;|*** 		for (cipher = EAGetLastCipher(ea); cipher != 0; cipher = EAGetPreviousCipher(ea, cipher))
; Line 1295
	*** 00009a	57 			push	di
	*** 00009b	e8 00 00 		call	_EAGetLastCipher
	*** 00009e	5b 			pop	bx
	*** 00009f	89 7e f8 		mov	WORD PTR [bp-8],di	;ea
	*** 0000a2	89 76 fc 		mov	WORD PTR [bp-4],si	;ks
	*** 0000a5	8b f0 			mov	si,ax
	*** 0000a7	8b 7e fc 		mov	di,WORD PTR [bp-4]	;ks
					$F1150:
	*** 0000aa	0b f0 			or	si,ax
	*** 0000ac	74 3a 			je	SHORT $EX1136
;|*** 		{
;|*** 			ks -= CipherGetKeyScheduleSize(cipher);
; Line 1297
	*** 0000ae	56 			push	si
	*** 0000af	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 0000b2	5b 			pop	bx
	*** 0000b3	2b f8 			sub	di,ax
;|*** 			ks2 -= CipherGetKeyScheduleSize(cipher);
;|*** 
;|*** 			DecryptBufferXTS8Byte(buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
; Line 1306
	*** 0000b5	56 			push	si
	*** 0000b6	56 			push	si
	*** 0000b7	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 0000ba	5b 			pop	bx
	*** 0000bb	29 46 fa 		sub	WORD PTR [bp-6],ax	;ks2
	*** 0000be	ff 76 fa 		push	WORD PTR [bp-6]	;ks2
	*** 0000c1	57 			push	di
	*** 0000c2	6a 00 			push	0
	*** 0000c4	ff 76 06 		push	WORD PTR [bp+6]	;structUnitNo
	*** 0000c7	66 8b 46 08 		mov	eax,DWORD PTR [bp+8]	;nbrUnits
	*** 0000cb	66 c1 e0 09 		shl	eax,9
	*** 0000cf	66 50 			push	eax
	*** 0000d1	ff 76 04 		push	WORD PTR [bp+4]	;buf
	*** 0000d4	e8 00 00 		call	_DecryptBufferXTS8Byte
	*** 0000d7	83 c4 10 		add	sp,16	;0010H
;|*** 		for (cipher = EAGetLastCipher(ea); cipher != 0; cipher = EAGetPreviousCipher(ea, cipher))
; Line 1295
	*** 0000da	56 			push	si
	*** 0000db	ff 76 f8 		push	WORD PTR [bp-8]	;ea
	*** 0000de	e8 00 00 		call	_EAGetPreviousCipher
	*** 0000e1	83 c4 04 		add	sp,4
	*** 0000e4	8b f0 			mov	si,ax
	*** 0000e6	eb c2 			jmp	SHORT $F1150
;|*** 		{
;|*** 			ks -= CipherGetKeyScheduleSize(cipher);
;|*** 			ks2 -= CipherGetKeyScheduleSize(cipher);
;|*** 
;|*** 			DecryptBufferXTS8Byte(buf,
;|*** 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
;|*** 				structUnitNo,
;|*** 				0,
;|*** 				ks,
;|*** 				ks2,
;|*** 				cipher);
;|*** 		}
;|*** 		break;
;|*** 	default:		
;|*** 		// Unknown/wrong ID
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 	}
;|*** }
; Line 1313
					$EX1136:
	*** 0000e8	5e 			pop	si
	*** 0000e9	5f 			pop	di
	*** 0000ea	c9 			leave	
	*** 0000eb	c3 			ret	

_DecryptDataUnits	ENDP
	PUBLIC	_GetMaxPkcs5OutSize
_GetMaxPkcs5OutSize	PROC NEAR	;  COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int GetMaxPkcs5OutSize (void)
;|***  *	\brief Returns the maximum number of bytes necessary to be generated by the PBKDF2 (PKCS #5)
;|***  *	\return int size
;|***  *
;|***  */
;|*** int GetMaxPkcs5OutSize (void)
;|*** {
; Line 1323
	*** 000000	56 			push	si
;	register si = size
;|*** 	int size = 32;
; Line 1324
	*** 000001	be 20 00 		mov	si,32	;0020H
;|*** 
;|*** 	size = max (size, EAGetLargestKeyForMode (XTS) * 2);	// Sizes of primary + secondary keys
; Line 1326
	*** 000004	6a 01 			push	1
	*** 000006	e8 00 00 		call	_EAGetLargestKeyForMode
	*** 000009	5b 			pop	bx
	*** 00000a	03 c0 			add	ax,ax
	*** 00000c	3b c6 			cmp	ax,si
	*** 00000e	7c 0a 			jl	SHORT $L1203
	*** 000010	6a 01 			push	1
	*** 000012	e8 00 00 		call	_EAGetLargestKeyForMode
	*** 000015	5b 			pop	bx
	*** 000016	03 c0 			add	ax,ax
	*** 000018	8b f0 			mov	si,ax
					$L1203:
;|*** 	size = max (size, EAGetLargestKeyForMode (XTS8) * 2);
; Line 1327
	*** 00001a	6a 02 			push	2
	*** 00001c	e8 00 00 		call	_EAGetLargestKeyForMode
	*** 00001f	5b 			pop	bx
	*** 000020	03 c0 			add	ax,ax
	*** 000022	3b c6 			cmp	ax,si
	*** 000024	7c 0a 			jl	SHORT $L1205
	*** 000026	6a 02 			push	2
	*** 000028	e8 00 00 		call	_EAGetLargestKeyForMode
	*** 00002b	5b 			pop	bx
	*** 00002c	03 c0 			add	ax,ax
	*** 00002e	8b f0 			mov	si,ax
					$L1205:
;|*** 
;|*** 	return size;
; Line 1329
	*** 000030	8b c6 			mov	ax,si
;|*** }
; Line 1330
	*** 000032	5e 			pop	si
	*** 000033	c3 			ret	

_GetMaxPkcs5OutSize	ENDP
_TEXT	ENDS
END
;|*** 
;|*** 
;|*** #else // GST_WINDOWS_BOOT_SINGLE_CIPHER_MODE
;|*** 
;|*** 
;|*** #if !defined (GST_WINDOWS_BOOT_AES) && !defined (GST_WINDOWS_BOOT_SERPENT) && !defined (GST_WINDOWS_BOOT_TWOFISH)
;|*** #error No cipher defined
;|*** #endif
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncipherBlock(int cipher, void *data, void *ks)
;|***  *	\brief Returns the maximum number of bytes necessary to be generated by the PBKDF2 (PKCS #5)
;|***  *	\param[in] void * ks
;|***  *	\param[in] void * data
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncipherBlock(int cipher, void *data, void *ks)
;|*** {
;|*** #ifdef GST_WINDOWS_BOOT_AES
;|*** 	if (IsAesHwCpuSupported())
;|*** 		aes_hw_cpu_encrypt ((byte *) ks, data);
;|*** 	else
;|*** 		aes_encrypt (data, data, ks); 
;|*** #elif defined (GST_WINDOWS_BOOT_SERPENT)
;|*** 	serpent_encrypt (data, data, ks);
;|*** #elif defined (GST_WINDOWS_BOOT_TWOFISH)
;|*** 	twofish_encrypt (ks, data, data);
;|*** #endif
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecipherBlock(int cipher, void *data, void *ks)
;|***  *	\brief Decipher a block
;|***  *	\param[in] void * ks
;|***  *	\param[in] void * data
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecipherBlock(int cipher, void *data, void *ks)
;|*** {
;|*** #ifdef GST_WINDOWS_BOOT_AES
;|*** 	if (IsAesHwCpuSupported())
;|*** 		aes_hw_cpu_decrypt ((byte *) ks + sizeof (aes_encrypt_ctx) + 14 * 16, data);
;|*** 	else
;|*** 		aes_decrypt (data, data, (aes_decrypt_ctx *) ((byte *) ks + sizeof(aes_encrypt_ctx))); 
;|*** #elif defined (GST_WINDOWS_BOOT_SERPENT)
;|*** 	serpent_decrypt (data, data, ks);
;|*** #elif defined (GST_WINDOWS_BOOT_TWOFISH)
;|*** 	twofish_decrypt (ks, data, data);
;|*** #endif
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetFirst ()
;|***  *	\brief Get first EA (id)
;|***  *	\return int 1
;|***  *
;|***  */
;|*** int EAGetFirst ()
;|*** {
;|*** 	return 1;
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetNext ()
;|***  *	\brief Get next EA (id)
;|***  *	\return int 0
;|***  *
;|***  */
;|*** int EAGetNext (int previousEA)
;|*** {
;|*** 	return 0;
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAInit (int ea, unsigned char *key, unsigned __int8 *ks)
;|***  *	\brief Initialize the EA
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned char * key
;|***  *	\param[in] int ea
;|***  *	\return int ERR_SUCCESS if success
;|***  *			ERR_CIPHER_INIT_FAILURE if (aes_encrypt_key256 (key, (aes_encrypt_ctx *) ks) != EXIT_SUCCESS)
;|***  *			ERR_CIPHER_INIT_FAILURE if (aes_decrypt_key256 (key, (aes_decrypt_ctx *) (ks + sizeof (aes_encrypt_ctx))) != EXIT_SUCCESS)
;|***  *
;|***  */
;|*** int EAInit (int ea, unsigned char *key, unsigned __int8 *ks)
;|*** {
;|*** #ifdef GST_WINDOWS_BOOT_AES
;|*** 
;|*** 	aes_init();
;|*** 
;|*** 	if (aes_encrypt_key256 (key, (aes_encrypt_ctx *) ks) != EXIT_SUCCESS)
;|*** 		return ERR_CIPHER_INIT_FAILURE;
;|*** 	if (aes_decrypt_key256 (key, (aes_decrypt_ctx *) (ks + sizeof (aes_encrypt_ctx))) != EXIT_SUCCESS)
;|*** 		return ERR_CIPHER_INIT_FAILURE;
;|*** 
;|*** #elif defined (GST_WINDOWS_BOOT_SERPENT)
;|*** 	serpent_set_key (key, 32 * 8, ks);
;|*** #elif defined (GST_WINDOWS_BOOT_TWOFISH)
;|*** 	twofish_set_key ((TwofishInstance *)ks, (const u4byte *)key, 32 * 8);
;|*** #endif
;|*** 	return ERR_SUCCESS;
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetKeySize (int ea)
;|***  *	\brief Get size of ea key
;|***  *	\param[in] int ea
;|***  *	\return int 32
;|***  *
;|***  */
;|*** int EAGetKeySize (int ea)
;|*** {
;|*** 	return 32;
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn int EAGetFirstCipher (int ea)
;|***  *	\brief Get first cipher
;|***  *	\param[in] int ea
;|***  *	\return int 1
;|***  *
;|***  */
;|*** int EAGetFirstCipher (int ea)
;|*** {
;|*** 	return 1;
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncryptBuffer (unsigned __int8 *buf, GST_LARGEST_COMPILER_UINT len, PCRYPTO_INFO cryptoInfo)
;|***  *	\brief Encrypt the buffer
;|***  *	\param[in] PCRYPTO_INFO cryptoInfo
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT len
;|***  *	\param[in] unsigned __int8 * buf
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncryptBuffer (unsigned __int8 *buf, GST_LARGEST_COMPILER_UINT len, PCRYPTO_INFO cryptoInfo)
;|*** {
;|*** 	UINT64_STRUCT dataUnitNo;
;|*** 	dataUnitNo.LowPart = 0; dataUnitNo.HighPart = 0;
;|*** 	switch(cryptoInfo->mode)
;|*** 	{
;|*** 	case XTS:
;|*** 		EncryptBufferXTS (buf, len, ,&dataUnitNo, 0, cryptoInfo->ks, cryptoInfo->ks2, 1);
;|*** 		break;
;|*** 	case XTS8:
;|*** 		EncryptBufferXTS8Byte (buf, len, ,&dataUnitNo, 0, cryptoInfo->ks, cryptoInfo->ks2, 1);
;|*** 		break;
;|*** 	}
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncryptDataUnits (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, GST_LARGEST_COMPILER_UINT nbrUnits, PCRYPTO_INFO ci)
;|***  *	\brief Encrypt data units
;|***  *	\param[in out] PCRYPTO_INFO ci
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT nbrUnits
;|***  *	\param[in] const UINT64_STRUCT
;|***  *	\param[in] unsigned __int8
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncryptDataUnits (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, GST_LARGEST_COMPILER_UINT nbrUnits, PCRYPTO_INFO ci)
;|*** {
;|*** 	switch(ci->mode)
;|*** 	{
;|*** 	case XTS:
;|*** 		EncryptBufferXTS (buf, nbrUnits * ENCRYPTION_DATA_UNIT_SIZE, structUnitNo, 0, ci->ks, ci->ks2, 1);
;|*** 		break;
;|*** 	case XTS8:
;|*** 		EncryptBufferXTS8Byte (buf, nbrUnits * ENCRYPTION_DATA_UNIT_SIZE, structUnitNo, 0, ci->ks, ci->ks2, 1);
;|*** 		break;
;|*** 	}
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecryptBuffer (unsigned __int8 *buf, GST_LARGEST_COMPILER_UINT len, PCRYPTO_INFO cryptoInfo)
;|***  *	\brief Decrypt the buffer
;|***  *	\param[in] PCRYPTO_INFO cryptoInfo
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT len
;|***  *	\param[in] unsigned __int8 * buf
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecryptBuffer (unsigned __int8 *buf, GST_LARGEST_COMPILER_UINT len, PCRYPTO_INFO cryptoInfo)
;|*** {
;|*** 	UINT64_STRUCT dataUnitNo;
;|*** 	dataUnitNo.LowPart = 0; dataUnitNo.HighPart = 0;
;|*** 	switch(cryptoInfo->mode)
;|*** 	{
;|*** 	case XTS:
;|*** 		DecryptBufferXTS (buf, len, &dataUnitNo, 0, cryptoInfo->ks, cryptoInfo->ks2, 1);
;|*** 		break;
;|*** 	case XTS8:
;|*** 		DecryptBufferXTS8Byte (buf, len, &dataUnitNo, 0, cryptoInfo->ks, cryptoInfo->ks2, 1);
;|*** 		break;
;|*** 	}
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecryptDataUnits (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, GST_LARGEST_COMPILER_UINT nbrUnits, PCRYPTO_INFO ci)
;|***  *	\brief Decrypt data units
;|***  *	\param[in] PCRYPTO_INFO ci
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT nbrUnits
;|***  *	\param[in] const UINT64_STRUCT * structUnitNo
;|***  *	\param[in] unsigned __int8 * buf
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecryptDataUnits (unsigned __int8 *buf, const UINT64_STRUCT *structUnitNo, GST_LARGEST_COMPILER_UINT nbrUnits, PCRYPTO_INFO ci)
;|*** {
;|*** 	switch(ci->mode)
;|*** 	{
;|*** 	case XTS:
;|*** 		DecryptBufferXTS (buf, nbrUnits * ENCRYPTION_DATA_UNIT_SIZE, structUnitNo, 0, ci->ks, ci->ks2, 1);
;|*** 		break;
;|*** 	case XTS8:
;|*** 		DecryptBufferXTS8Byte (buf, nbrUnits * ENCRYPTION_DATA_UNIT_SIZE, structUnitNo, 0, ci->ks, ci->ks2, 1);
;|*** 		break;
;|*** 	}
;|*** 	
;|*** }
;|*** 
;|*** #endif // GST_WINDOWS_BOOT_SINGLE_CIPHER_MODE
;|*** 
;|*** 
;|*** #if !defined (GST_WINDOWS_BOOT) || defined (GST_WINDOWS_BOOT_AES)
;|*** 
;|*** static BOOL HwEncryptionDisabled = FALSE;
;|*** 
;|*** /**
;|***  *
;|***  *	\fn BOOL IsAesHwCpuSupported ()
;|***  *	\brief Is Aes Hardware cpu supported
;|***  *	\return BOOL FALSE if cpu is supported, TRUE else
;|***  *
;|***  */
;|*** BOOL IsAesHwCpuSupported ()
;|*** {
;|*** 	static BOOL state = FALSE;
;|*** 	static BOOL stateValid = FALSE;
;|*** 
;|*** 	if (!stateValid)
;|*** 	{
;|*** 		state = FALSE;//state = is_aes_hw_cpu_supported() ? TRUE : FALSE;
;|*** 		stateValid = TRUE;
;|*** 	}
;|*** 
;|*** 	return FALSE;//state && !HwEncryptionDisabled;
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EnableHwEncryption (BOOL enable)
;|***  *	\brief Deprecated useless
;|***  *	\param[in] BOOL enable
;|***  *	\return void
;|***  *
;|***  */
;|*** void EnableHwEncryption (BOOL enable)
;|*** {
;|*** 	//Deprecated
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn BOOL IsHwEncryptionEnabled ()
;|***  *	\brief Is Hardware encryption enabled
;|***  *	\return BOOL !HwEncryptionDisabled
;|***  *
;|***  */
;|*** BOOL IsHwEncryptionEnabled ()
;|*** {
;|*** 	return !HwEncryptionDisabled;
;|*** }
;|*** 
;|*** #endif // !GST_WINDOWS_BOOT
